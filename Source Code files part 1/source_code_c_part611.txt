lpConfig->lpszDCISectionName);
    }

    return (DRV_OK);
}


/****************************************************************************
 * Function: LRESULT viscaRemove - Respond to DRV_REMOVE message.
 *
 * Parameters:
 *
 *      HDRVR hDriver - Handle to driver being removed.
 *
 * Returns: TRUE on success, otherwise FALSE.
 ***************************************************************************/
static LRESULT NEAR PASCAL
viscaRemove(HDRVR hDriver)
{
    return ((LRESULT)TRUE);
}


/****************************************************************************
 * Function: int viscaDetectOnCommPort - Detect the number of VCRs on this commport.
 *
 * Parameters:
 *
 *      int  iPort - index into vcr array of port. (commport - 1).
 *
 * Returns: Number of VCRs (can be 0) or -1 for error.
 *
 ***************************************************************************/
static int NEAR PASCAL
viscaDetectOnCommPort(int iPort)
{
    BYTE    achPacket[MAXPACKETLENGTH];
    DWORD   dwErr;
    int     iInst;
    int     iDev = 0; //We will call ourselves the first device on the serial port.

    pvcr->fConfigure = TRUE;    // This also acks to synchronize

    iInst = viscaInstanceCreate(0, iPort, iDev); //0 means don't use MCI
    if (iInst == -1)
        return -1;

    if (!viscaTaskIsRunning())
    {
        if (!viscaTaskCreate())
        {
            DPF(DBG_ERROR, "Failed to create task.\n");
            viscaInstanceDestroy(iInst);
            return -1;
        }
    }
    //
    // Global handles are created immediately when the task starts up.
    //
    DuplicateGlobalHandlesToInstance(pvcr->htaskCommNotifyHandler, iInst);  // Always do this immediately.
    //
    // Okay, open the port.
    //
    viscaTaskDo(iInst, TASKOPENCOMM, iPort + 1, 0);
    if(pvcr->Port[iPort].idComDev < 0)
    {
        viscaInstanceDestroy(iInst);
        return -1;
    }
    DuplicatePortHandlesToInstance(pvcr->htaskCommNotifyHandler, iPort, iInst);
    //
    // Open the device.
    //
    viscaTaskDo(iInst, TASKOPENDEVICE, iPort, iDev);
    DuplicateDeviceHandlesToInstance(pvcr->htaskCommNotifyHandler, iPort, iDev, iInst);
    //
    // We have the green light to begin sending commands.
    //
    pvcr->Port[iPort].Dev[iDev].fDeviceOk = TRUE;
    //
    // There is no completion on non-broadcasted! (so who releases it?)
    //
    dwErr = viscaDoImmediateCommand(iInst, BROADCASTADDRESS,
                        achPacket,
                        viscaMessageIF_Address(achPacket + 1));
    if (dwErr)
    {
        viscaTaskDo(iInst, TASKCLOSECOMM, iPort + 1, 0); //Porthandles destroyed.
        viscaTaskDo(iInst, TASKCLOSEDEVICE, iPort, iDev); //Porthandles destroyed.
        viscaInstanceDestroy(iInst);
        return 0; //No devices.
    }

    viscaTaskDo(iInst, TASKCLOSECOMM, iPort + 1, 0); //Porthandles destroyed.
    viscaTaskDo(iInst, TASKCLOSEDEVICE, iPort, iDev); //Porthandles destroyed.

    viscaInstanceDestroy(iInst);

    pvcr->fConfigure = FALSE;

    DPF(DBG_CONFIG, "viscaDetectOnCommPort --> detect %d", (int)(BYTE)achPacket[2] - 1);

    return (int)(BYTE)achPacket[2] - 1; // -1 for the computer.
}



/***************************************************************************
 * Function: LONG DriverProc - Windows driver entry point.  All Windows driver
 *     control messages and all MCI messages pass through this entry point.
 *
 * Parameters:
 *
 *      DWORD dwDriverId - For most messages, <p dwDriverId> is the DWORD
 *     value that the driver returns in response to a <m DRV_OPEN> message.
 *     Each time that the driver is opened, through the <f DrvOpen> API,
 *     the driver receives a <m DRV_OPEN> message and can return an
 *     arbitrary, non-zero value. The installable driver interface
 *     saves this value and returns a unique driver handle to the
 *     application. Whenever the application sends a message to the
 *     driver using the driver handle, the interface routes the message
 *     to this entry point and passes the corresponding <p dwDriverId>.
 *     This mechanism allows the driver to use the same or different
 *     identifiers for multiple opens but ensures that driver handles
 *     are unique at the application interface layer.
 *
 *     The following messages are not related to a particular open
 *     instance of the driver. For these messages, the dwDriverId
 *     will always be zero.
 *
 *         DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
 *
 *      HDRVR  hDriver - This is the handle returned to the
 *     application by the driver interface.
 *
 *      UINT uMessage - The requested action to be performed. Message
 *     values below <m DRV_RESERVED> are used for globally defined messages.
 *     Message values from <m DRV_RESERVED> to <m DRV_USER> are used for
 *     defined driver protocols.  Messages above <m DRV_USER> are used
 *     for driver specific messages.
 *
 *      LPARAM lParam1 - Data for this message.  Defined separately for
 *     each message
 *
 *      LPARAM lParam2 - Data for this message.  Defined separately for
 *     each message
 *
 * Returns: Defined separately for each message.
 ***************************************************************************/
LRESULT CALLBACK LOADDS
DriverProc(DWORD dwDriverID, HDRVR hDriver, UINT uMessage, LPARAM lParam1, LPARAM lParam2)
{
    switch (uMessage) {

        case DRV_LOAD:
            /* the DRV_LOAD message is received once, when the driver is */
            /* first loaded - any one-time initialization code goes here */
            return (viscaDrvLoad());

        case DRV_FREE:
            /* the DRV_FREE message is received once when the driver is */
            /* unloaded - any final shut down code goes here */
            return (viscaDrvFree(LOWORD(dwDriverID)));

        case DRV_OPEN:
            /* the DRV_OPEN message is received once for each MCI device open */
            if (lParam2) {                  // normal open
                return (viscaDrvOpen((LPWSTR)lParam1,
                        (LPMCI_OPEN_DRIVER_PARMS)lParam2));
            }
            else {                                  // configuration open
                return (0x00010000);
            }

        case DRV_CLOSE:
            /* this message is received once for each MCI device close */
            return (viscaDrvClose(LOWORD(dwDriverID)));

        case DRV_QUERYCONFIGURE:
            /* the DRV_QUERYCONFIGURE message is used to determine if the */
            /* DRV_CONCIGURE message is supported - return 1 to indicate */
            /* configuration is supported */
            return (1L);

        case DRV_CONFIGURE:
            /* the DRV_CONFIGURE message instructs the device to perform */
            /* device configuration. */
            if (lParam2 && lParam1 &&
                (((LPDRVCONFIGINFO)lParam2)->dwDCISize == sizeof(DRVCONFIGINFO)))
            {
                return (viscaConfig((HWND)WINWORD(lParam1), (LPDRVCONFIGINFO)lParam2, hModuleInstance));
            }
            break;

        case DRV_REMOVE:
            /* the DRV_REMOVE message informs the driver that it is being removed */
            /* from the system */
            return (viscaRemove(hDriver));

        default:
            /* all other messages are processed here */

            /* select messages in the MCI range */
            if ((!HIWORD(dwDriverID)) && (uMessage >= DRV_MCI_FIRST) &&
                (uMessage <= DRV_MCI_LAST))
            {
                return (viscaMciProc(LOWORD(dwDriverID), (WORD)uMessage, lParam1, lParam2));
            }
            else
            {
                /* other messages get default processing */
                return (DefDriverProc(dwDriverID, hDriver, uMessage, lParam1, lParam2));
            }
    }
    return (0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mcivisca\mcivisca\mcicmds.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992-1995 Microsoft Corporation
 * 
 *  MCICMDS.C           
 *
 *  MCI ViSCA Device Driver         
 *
 *  Description:
 *
 *      MCI Command Message Procedures
 *
 ***************************************************************************/
            
#define  UNICODE
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include "appport.h"
#include <mmddk.h>
#include <stdlib.h>
#include <string.h>
#include "vcr.h"
#include "viscadef.h"
#include "mcivisca.h"
#include "viscamsg.h"
#include "common.h"            

#define NO_LENGTH   0xFFFFFFFF      /* Invalid length */

extern HINSTANCE       hModuleInstance;    // module instance  (different in NT - DLL instances)

// In muldiv.asm 
extern DWORD FAR PASCAL muldiv32(DWORD, DWORD, DWORD);

// Forward references to non-exported functions 
static BOOL  NEAR PASCAL viscaTimecodeCheck(int iInst);
static BOOL  NEAR PASCAL viscaStartTimecodeCheck(int iInst, BOOL fPause);
static DWORD NEAR PASCAL viscaMciSet(int iInst, DWORD dwFlags, LPMCI_VCR_SET_PARMS lpSet);

/****************************************************************************
 * Function: int viscaInstanceCreate - Create an OpenInstance
 *                       structure for a given MCI device ID.
 *
 * Parameters:
 *
 *      UINT uDeviceID - MCI device ID.
 *
 *      UINT iPort - Port index (0..3).
 *
 *      UINT iDev - Device index (0..6).
 *
 * Returns: a pointer to the OpenInstance structure created if
 *        successful, otherwise NULL.
 *
 *       Each time MCI uses this driver to open a device,
 *       viscaInstanceCreate() is called to create an OpenInstance structure
 *       and associate it with the MCI device ID.
 ***************************************************************************/
int FAR PASCAL
viscaInstanceCreate(UINT uDeviceID, UINT iPort, UINT iDev)
{
    int            iInst;

    //
    // Create new "open instance" entry for the specified device
    //
    iInst = MemAllocInstance();

    if(iInst != -1)
    {
        pinst[iInst].pidThisInstance  = MGetCurrentTask(); // Used to 1. open this task and dup event.
        pinst[iInst].uDeviceID        = uDeviceID;
        pinst[iInst].iPort            = iPort;
        pinst[iInst].iDev             = iDev;
        pinst[iInst].dwTimeFormat     = MCI_FORMAT_MILLISECONDS;
        pinst[iInst].dwCounterFormat  = MCI_FORMAT_MILLISECONDS;

        pinst[iInst].fGlobalHandles  = FALSE;
        pinst[iInst].fPortHandles    = FALSE;
        pinst[iInst].fDeviceHandles  = FALSE;

#ifdef _WIN32
        // Ack and completion events for this instance

        pinst[iInst].fCompletionEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        pinst[iInst].fAckEvent        = CreateEvent(NULL, TRUE, FALSE, NULL);
#endif

    }

    // 0 is an illegal value for device id.
    if(uDeviceID != 0) 
        mciSetDriverData(uDeviceID, (UINT)iInst);

    return (iInst);
}



/****************************************************************************
 * Function: void viscaInstanceDestroy - Destroy an OpenInstance.
 *
 * Parameters:
 *
 *      int iInst - Pointer to OpenInstance struct to
 *                       destroy.
 *
 *       When an MCI device ID is closed, viscaInstanceDestroy() is called
 *       to free the OpenInstance structure corresponding to that device ID.
 *
 ***************************************************************************/
void FAR PASCAL
viscaInstanceDestroy(int iInst)
{
    CloseAllInstanceHandles(iInst); // Close my handles to everything.
    mciSetDriverData(pinst[iInst].uDeviceID, 0L); // prevent reenter if we yield in this function.

    DPF(DBG_MEM, "viscaInstanceDestroy - Freeing iInst = %d \n", iInst);
    MemFreeInstance(iInst);
}
    

/****************************************************************************
 * Function: UINT viscaMciFPS - Returns the number of frames per second
 *               for an MCI time format.
 *
 * Parameters:
 *
 *      DWORD dwTimeFormat - MCI time format.
 *
 * Returns: number of frames per second if successful, otherwise 0.
 *
 *       This function should only be used for SMPTE time formats,
 *       i.e. MCI_FORMAT_SMPTE_XX, where XX is 24, 25, 30, or 30DROP.
 ***************************************************************************/
static UINT NEAR PASCAL
viscaMciFPS(DWORD dwMCITimeFormat)
{        
    switch (dwMCITimeFormat)
    {
        case MCI_FORMAT_SMPTE_24:
            return (24);
        case MCI_FORMAT_SMPTE_25:
            return (25);
        case MCI_FORMAT_SMPTE_30:
        case MCI_FORMAT_SMPTE_30DROP:
            return (30);
        default:
            return (0);
    }
}


/****************************************************************************
 * Function: DWORD viscaMciTimeFormatToViscaData - Convert an Mci time
 *               value to a ViSCA data structure.
 *
 * Parameters:
 *
 *      int iInst - Instance on whose behalf conversion
 *                       is being done.
 *
 *      BOOL fTimecode - Are we using the timecode or counter? (can both be non-drop frame).
 *
 *      DWORD dwTime - Time value to convert.
 *
 *      LPSTR lpstrData - Buffer to hold result.
 *
 *      BYTE bDataFormat - ViSCA data format desired.
 *
 * Returns: an Mci error code.
 *
 *       Converts an MCI DWORD position variable in the current MCI time
 *       format (specified in iInst->dwTimeFormat) to a ViSCA 5-byte
 *       position data structure of the type specified by bDataFormat.
 ***************************************************************************/
DWORD FAR PASCAL
viscaMciTimeFormatToViscaData(int iInst, BOOL fTimecode, DWORD dwTime, LPSTR lpstrData, BYTE bDataFormat)
{
    BYTE    bHours;
    BYTE    bMinutes;
    BYTE    bSeconds;
    BYTE    bFrames;
    UINT    uDevFPS  = pvcr->Port[pinst[iInst].iPort].Dev[pinst[iInst].iDev].uFramesPerSecond;
    DWORD   dwTimeFormat;

    if(fTimecode)
        dwTimeFormat =  pinst[iInst].dwTimeFormat;
    else
        dwTimeFormat =  pinst[iInst].dwCounterFormat;
    //
    // First extract hours, minutes, seconds, and frames from MCI data
    //
    switch (dwTimeFormat)
    {
        case MCI_FORMAT_MILLISECONDS:
            bHours   = (BYTE)(dwTime / 3600000L);
            bMinutes = (BYTE)((dwTime / 60000L) % 60);
            bSeconds = (BYTE)((dwTime /  1000L) % 60);
            bFrames  = (BYTE)((dwTime % 1000) * uDevFPS / 1000);
            break;
        case MCI_FORMAT_HMS:
            bHours   = MCI_HMS_HOUR(dwTime);
            bMinutes = MCI_HMS_MINUTE(dwTime);
            bSeconds = MCI_HMS_SECOND(dwTime);
            bFrames  = 0;
            break;
        case MCI_FORMAT_MSF:
            bHours   = (BYTE)(MCI_MSF_MINUTE(dwTime) / 60);
            bMinutes = (BYTE)(MCI_MSF_MINUTE(dwTime) % 60);
            bSeconds = MCI_MSF_SECOND(dwTime);
            bFrames  = MCI_MSF_FRAME(dwTime);
            break;
        case MCI_FORMAT_TMSF:
            if (MCI_TMSF_TRACK(dwTime) != 1)
                return(MCIERR_OUTOFRANGE);
            bHours   = (BYTE)(MCI_TMSF_MINUTE(dwTime) / 60);
            bMinutes = (BYTE)(MCI_TMSF_MINUTE(dwTime) % 60);
            bSeconds = MCI_TMSF_SECOND(dwTime);
            bFrames  = MCI_TMSF_FRAME(dwTime);
            break;
        case MCI_FORMAT_FRAMES:
        case MCI_FORMAT_SAMPLES:
            bHours   = (BYTE)(dwTime / (uDevFPS * 3600L));
            bMinutes = (BYTE)((dwTime / (uDevFPS * 60)) % 60);
            bSeconds = (BYTE)((dwTime / uDevFPS) % 60);
            bFrames  = (BYTE)(dwTime % uDevFPS);
            break;
        case MCI_FORMAT_SMPTE_24:
        case MCI_FORMAT_SMPTE_25:
        case MCI_FORMAT_SMPTE_30:
        case MCI_FORMAT_SMPTE_30DROP:
            bHours   = LOBYTE(LOWORD(dwTime));
            bMinutes = HIBYTE(LOWORD(dwTime));
            bSeconds = LOBYTE(HIWORD(dwTime));
            bFrames  = (BYTE)(UINT)MulDiv(HIBYTE(HIWORD(dwTime)),
                                          uDevFPS,
                                          viscaMciFPS(dwTimeFormat));
            //
            // Because of rounding, it's theoretically possible that bFrames
            // will exceed uDevFPS - 1.  So check for this condition.
            //
            if (bFrames >= uDevFPS)
                bFrames = uDevFPS - 1;
            break;
        case MCI_FORMAT_BYTES:
        default:
            return (MCIERR_BAD_TIME_FORMAT);
    }
    //
    // Create ViSCA data
    //

    if( (bMinutes >= 60) || (bSeconds >= 60) || (bFrames >= uDevFPS) )
        return(MCIERR_OUTOFRANGE);

    // Smpte timecode has a maximum of 23:59:59:29

    if(fTimecode && (bHours >= 24))
        return(MCIERR_OUTOFRANGE);

    viscaDataPosition(lpstrData, bDataFormat, bHours, bMinutes, bSeconds, bFrames);

    return (MCIERR_NO_ERROR);
}

/****************************************************************************
 * Function: DWORD viscaMciClockFormatToViscaData - Convert an MCI time
 *               value to a ViSCA data structure.
 *
 * Parameters:
 *
 *      DWORD dwTime - Time value to convert.
 *
 *      UINT   uTicksPerSecond - Ticks per second.
 *
 *      BYTE * bHours -  Hours returned.
 *
 *      BYTE * bMinutes - Minutes returned.
 *
 *      BYTE * bSeconds - Seconds returned.
 *
 *      UINT * uTicks - Ticks returned.
 *
 * Returns: an MCI error code.
 *
 *       Converts an MCI DWORD position variable in the current MCI time
 *       format (specified in pinst[iInst].dwTimeFormat) to a ViSCA 5-byte
 *       position data structure of the type specified by bDataFormat.
 ***************************************************************************/
DWORD FAR PASCAL
viscaMciClockFormatToViscaData(DWORD dwTime, UINT uTicksPerSecond, BYTE FAR *bHours, BYTE FAR *bMinutes, BYTE FAR *bSeconds, UINT FAR *uTicks)
{

    *bHours   = (BYTE)(dwTime / (3600L * (LONG) uTicksPerSecond));
    *bMinutes = (BYTE)((dwTime / (60L * (LONG) uTicksPerSecond)) % 60);
    *bSeconds = (BYTE)((dwTime / (LONG) uTicksPerSecond) % 60);
    *uTicks   = (UINT)((dwTime % (LONG) uTicksPerSecond));

    return MCIERR_NO_ERROR;
}

/****************************************************************************
 * Function: DWORD viscaDataToMciTimeFormat - Convert a ViSCA data structure
 *               to an MCI time value.
 *
 * Parameters:
 *
 *      int iInst - Instance on whose behalf conversion
 *                       is being done.
 *
 *      LPSTR lpstrData - ViSCA data structure to be converted.
 *
 *      DWORD FAR * lpdwTime - Pointer to DWORD to hold result.
 *
 * Returns: an MCI error code.
 *
 *       Converts a ViSCA 5-byte position data structure to an MCI DWORD
 *       position variable in the current MCI time format (specified in
 *       pinst[iInst].dwTimeFormat).
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaDataToMciTimeFormat(int iInst, BOOL fTimecode, LPSTR lpstrData, DWORD FAR *lpdwTime)
{
    UINT    uHours   = VISCAHOURS(lpstrData);
    UINT    uMinutes = VISCAMINUTES(lpstrData);
    UINT    uSeconds = VISCASECONDS(lpstrData);
    UINT    uFrames  = VISCAFRAMES(lpstrData);
    UINT    uDevFPS  = pvcr->Port[pinst[iInst].iPort].Dev[pinst[iInst].iDev].uFramesPerSecond;
    UINT    uMCIFPS  ;
    DWORD   dwTimeFormat;
   
    if(fTimecode)
        dwTimeFormat =  pinst[iInst].dwTimeFormat;
    else
        dwTimeFormat =  pinst[iInst].dwCounterFormat;

    uMCIFPS  = viscaMciFPS(dwTimeFormat);

    //
    // Sometimes a ViSCA device will return a bogus position. 
    //
    if ((uMinutes >= 60) || (uSeconds >= 60))
    {
        DPF(DBG_ERROR, "Bad uMinutes, uSeconds!\n");
        return (MCIERR_DRIVER_INTERNAL);
    }

    switch(dwTimeFormat)
    {
        case MCI_FORMAT_MILLISECONDS:
            *lpdwTime = (uHours * 3600000L) + (uMinutes * 60000L) +
                        (uSeconds * 1000L) +
                        (uFrames * 1000L / uDevFPS);
            return (MCIERR_NO_ERROR);

        case MCI_FORMAT_HMS:
            *lpdwTime = MCI_MAKE_HMS(uHours, uMinutes, uSeconds);
            return (MCI_COLONIZED3_RETURN);

        case MCI_FORMAT_MSF:
            *lpdwTime = MCI_MAKE_MSF((uHours * 60) + uMinutes, uSeconds,
                                                               uFrames);
            return (MCI_COLONIZED3_RETURN);

        case MCI_FORMAT_TMSF:
            *lpdwTime = MCI_MAKE_TMSF(1, (uHours * 60) + uMinutes, uSeconds,
                                                                   uFrames);
            return (MCI_COLONIZED4_RETURN);

        case MCI_FORMAT_FRAMES:
        case MCI_FORMAT_SAMPLES:
            *lpdwTime = ((uHours * 3600L + uMinutes * 60L + uSeconds) *
                         uDevFPS) + uFrames;
            return (MCIERR_NO_ERROR);

        case MCI_FORMAT_SMPTE_30DROP:
        case MCI_FORMAT_SMPTE_24:
        case MCI_FORMAT_SMPTE_25:
        case MCI_FORMAT_SMPTE_30:
        {
            uFrames  = MulDiv(uFrames, uMCIFPS, uDevFPS);
            //
            // Because of rounding, it's theoretically possible that uFrames
            // will exceed uMCIFPS - 1.  So check for this condition.
            //
            if (uFrames >= uMCIFPS) 
                uFrames = uMCIFPS - 1;
            
            *lpdwTime = ((DWORD)uHours) | ((DWORD)uMinutes << 8) |
                        ((DWORD)uSeconds << 16) | ((DWORD)uFrames << 24);
            return (MCI_COLONIZED4_RETURN);
        }

        default:
            return (MCIERR_BAD_TIME_FORMAT);
    }
}

/****************************************************************************
 * Function: DWORD viscaMciPos1LessThanPos2 - Checks whether a given position
 *               in the current MCI time format preceeds another
 *
 * Parameters:
 *
 *      int iInst - Instance on whose behalf check is made.
 *
 *      DWORD dwPos1 - First position.
 *
 *      DWORD dwPos2 - Second position.
 *
 * Returns: TRUE if dwPos1 preceeds dwPos2, otherwise FALSE.
 *
 *       This function is necessary because MCI stores byte-packed positions
 *       in reverse order.  I.e., SMPTE positions are stored as FFSSMMHH,
 *       which makes easy comparisons impossible.
 ***************************************************************************/
BOOL FAR PASCAL
viscaMciPos1LessThanPos2(int iInst, DWORD dwPos1, DWORD dwPos2)
{
#define REVERSEBYTES(x)     (((DWORD)HIBYTE(HIWORD(x))      ) | \
                             ((DWORD)LOBYTE(HIWORD(x)) <<  8) | \
                             ((DWORD)HIBYTE(LOWORD(x)) << 16) | \
                             ((DWORD)LOBYTE(LOBYTE(x)) << 24))

    switch (pinst[iInst].dwTimeFormat)
    {
        case MCI_FORMAT_SMPTE_24:
        case MCI_FORMAT_SMPTE_25:
        case MCI_FORMAT_SMPTE_30:
        case MCI_FORMAT_SMPTE_30DROP:
        case MCI_FORMAT_HMS:
        case MCI_FORMAT_TMSF:
        case MCI_FORMAT_MSF:
            return (REVERSEBYTES(dwPos1) < REVERSEBYTES(dwPos2));
        default:
            return (dwPos1 < dwPos2);
    }
}

/****************************************************************************
 * Function: DWORD viscaRoundSpeed - Map ranges of speeds into increments.
 *
 * Parameters:
 *
 *      DWORD dwSpeed  - MCI specified speed.
 *
 *      BOOL  fReverse - Direction of speed.
 *
 * Returns: rounded speed.
 *
 *       If total variable speed is desired then this function is needs
 *       to be changed to something device specific. i.e. A device specific
 *       mapping.
 *       
 ***************************************************************************/
DWORD FAR PASCAL
viscaRoundSpeed(DWORD dwSpeed, BOOL fReverse)
{
   if (dwSpeed == 0L)
       return(0L);
   else if (dwSpeed <= 150)
       return(100L);
   else if (dwSpeed <= 600)
       return(200L);
   else if (dwSpeed <= 1500)
       return(1000L);
   else
       return(2000L);
}

/****************************************************************************
 * Function: DWORD viscaMapSpeed - Map the speed into the VISCA command.
 *
 * Parameters:
 *
 *      DWORD dwSpeed  - MCI specified speed.
 *
 *      BOOL  fReverse - Direction of speed.
 *
 * Returns: rounded speed.
 *
 *       If total variable speed is desired then this function is needs
 *       to be changed to something device specific. i.e. A device specific
 *       mapping.
 *
 *       This should be combined with Round speed, since they do the
 *       same thing. So the return variables would be:
 *         1. Visca command
 *         2. The rounded speed this corresponds to.
 *
 *       We need to play at the speed dictated by DEVICEPLAYSPEED,
 *      where 1000 is normal.  We have 5 play speeds available:
 *      SLOW2 (x1/10), SLOW1 (x1/5), normal (x1), and FAST1 (x2).
 *      We choose one of these fives based on the following step function:
 *            0 -- STILL
 *     1 -  150 -- SLOW2
 *   151 -  600 -- SLOW1
 *   601 - 1500 -- normal
 *  1501 - .... -- FAST1
 *
 ***************************************************************************/
BYTE FAR PASCAL
viscaMapSpeed(DWORD dwSpeed, BOOL fReverse)
{
    if(fReverse)
    {
        //
        // You cannot set the speed to 0 and expect it to stop! 
        //
        if(dwSpeed == 0)
            return ( VISCAMODE1STILL);    
        if (dwSpeed <= 150) 
            return ( VISCAMODE1REVERSESLOW2);
        else if (dwSpeed <= 600) 
            return ( VISCAMODE1REVERSESLOW1);
        else if (dwSpeed <= 1500)
            return ( VISCAMODE1REVERSEPLAY);
        else 
            return ( VISCAMODE1REVERSEFAST1);
    }
    else
    {
        if (dwSpeed == 0)
            return ( VISCAMODE1STILL);    
        else if(dwSpeed <= 150) 
            return ( VISCAMODE1SLOW2);
        else if (dwSpeed <= 600) 
            return ( VISCAMODE1SLOW1);
        else if (dwSpeed <= 1500) 
            return ( VISCAMODE1PLAY);
        else 
            return ( VISCAMODE1FAST1);
    }
}

/****************************************************************************
 * Function: DWORD viscaMciCloseDriver - Edit instance-specific cleanup.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_GENERIC_PARMS lpGeneric - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_CLOSE_DRIVER
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciCloseDriver(int iInst, DWORD dwFlags, LPMCI_GENERIC_PARMS lpGeneric)
{
    UINT    iPort   = pinst[iInst].iPort;
    UINT    iDev    = pinst[iInst].iDev;

    //
    // Remove any delayed commands running for this instance.
    //
    viscaRemoveDelayedCommand(iInst);
    //
    // Close in same order opened port, device, instance. (task if necessary)
    // We cannot close task first because it is needed to receivce port closing messages.
    // WE cannot kill port before instance, because we need to synchronize closing.
    // 
    // Task is first opened and last closed. Port, device, instance are created
    // on demand. instance first, then device, then port. So close then
    // port, device, instance in reverse order.
    //
    pvcr->Port[iPort].nUsage--;
    pvcr->Port[iPort].Dev[iDev].nUsage--;
    //
    // Kill the port if necessary.
    //
    if (pvcr->Port[iPort].nUsage == 0)
    {
        DPF(DBG_COMM, "Port on Port=%d closing \n", iPort);
        viscaTaskDo(iInst, TASKCLOSECOMM, iPort + 1, 0);
        // Port handles owned by background process are closed.
    }
    //
    // Kill the device if this is the last of shared.
    //
    if(pvcr->Port[iPort].Dev[iDev].nUsage == 0)
    {
        DPF(DBG_COMM, "Device on Port=%d Device=%d closing \n", iPort, iDev);
        viscaTaskDo(iInst, TASKCLOSEDEVICE, iPort, iDev);
        // Device handles owned by background task are closed.
    }

    DPF(DBG_COMM, "Instance on Port=%d Device=%d Instance=%d closing \n", iPort, iDev, iInst);
    return (viscaNotifyReturn(iInst, (HWND) lpGeneric->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
}


/****************************************************************************
 * Function: DWORD viscaDeviceConfig - Get device specific information.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 * Returns: an MCI error code.
 *
 *         1. Get information that requires communication.
 *         2. Save static info that does not require communication.
 *
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaDeviceConfig(int iInst, DWORD dwFlags)
{
    UINT    iPort   = pinst[iInst].iPort;
    UINT    iDev    = pinst[iInst].iDev;
    BYTE    achPacket[MAXPACKETLENGTH];
    MCI_VCR_STATUS_PARMS mciStatus;
    DWORD   dwErr;
    //
    // Create this device's automatic command entry 
    //
    pvcr->Port[iPort].Dev[iDev].fDeviceOk       = TRUE;
    pvcr->Port[iPort].Dev[iDev].iInstTransport  = -1;
    pvcr->Port[iPort].Dev[iDev].iInstReply      = -1;
    pvcr->Port[iPort].Dev[iDev].dwPlaySpeed     = 1000L;
    pvcr->Port[iPort].Dev[iDev].fQueueReenter   = FALSE;

    // I should query this from device, if they're not reset.
    pvcr->Port[iPort].Dev[iDev].bVideoDesired   = 0x01; // on
    pvcr->Port[iPort].Dev[iDev].bAudioDesired   = 0x03;
    pvcr->Port[iPort].Dev[iDev].bTimecodeDesired= 0x01; 

    //
    // 0 means completion successful  
    //
    if(!viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
        achPacket,
        viscaMessageIF_DeviceTypeInq(achPacket + 1)))
    {
        // Is it one of the known types?
        pvcr->Port[iPort].Dev[iDev].uModelID   = achPacket[3]; // These are 1 relative
        pvcr->Port[iPort].Dev[iDev].uVendorID  = achPacket[5];
    }

    if(pvcr->Port[iPort].Dev[iDev].fDeviceOk)
    {
        DPF(DBG_MCI, "Vendor = %d ",  achPacket[3]);
        DPF(DBG_MCI, "Model  = %d\n", achPacket[5]);
    }
    else
    {
        DPF(DBG_ERROR, "Device refuses to open.\n");
    }

    //
    // An entry for number of -1 doesn't mean 0, it means no knowledge.
    //
    pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uNumInputs = -1;
    pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_AUDIO].uNumInputs = -1;

    //
    // It would be nice if these tables were external somewhere (like in an ini file)
    // The only published devices are Sony. Hence the table.  Not meant to be
    // exclusionary.
    //
    if(pvcr->Port[iPort].Dev[iDev].uModelID == VISCADEVICEVENDORSONY)
    {
        switch(pvcr->Port[iPort].Dev[iDev].uVendorID)
        {
            case VISCADEVICEMODELCI1000:
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uNumInputs = 2;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_AUDIO].uNumInputs = 2;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uInputType[0] = MCI_VCR_SRC_TYPE_MUTE;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uInputType[1] = MCI_VCR_SRC_TYPE_LINE;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_AUDIO].uInputType[0] = MCI_VCR_SRC_TYPE_MUTE;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_AUDIO].uInputType[1] = MCI_VCR_SRC_TYPE_LINE;
                //
                // Preroll duration in frames.
                //
                pvcr->Port[iPort].Dev[iDev].uPrerollDuration = 0;
                
                break;

            case VISCADEVICEMODELCVD1000:
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uNumInputs = 4;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_AUDIO].uNumInputs = 3;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uInputType[0] = MCI_VCR_SRC_TYPE_MUTE;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uInputType[1] = MCI_VCR_SRC_TYPE_LINE;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uInputType[2] = MCI_VCR_SRC_TYPE_LINE;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uInputType[3] = MCI_VCR_SRC_TYPE_SVIDEO;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_AUDIO].uInputType[0] = MCI_VCR_SRC_TYPE_MUTE;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_AUDIO].uInputType[1] = MCI_VCR_SRC_TYPE_LINE;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_AUDIO].uInputType[2] = MCI_VCR_SRC_TYPE_LINE;
                //
                // Preroll duration in frames.
                //
                pvcr->Port[iPort].Dev[iDev].uPrerollDuration = 42;
                break;

            case VISCADEVICEMODELEVO9650:
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uNumInputs = 4;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_AUDIO].uNumInputs = 2;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uInputType[0] = MCI_VCR_SRC_TYPE_MUTE;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uInputType[1] = MCI_VCR_SRC_TYPE_LINE;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uInputType[2] = MCI_VCR_SRC_TYPE_SVIDEO;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uInputType[3] = MCI_VCR_SRC_TYPE_AUX;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_AUDIO].uInputType[0] = MCI_VCR_SRC_TYPE_MUTE;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_AUDIO].uInputType[1] = MCI_VCR_SRC_TYPE_LINE;
                //
                // Preroll duration in frames.
                //
                pvcr->Port[iPort].Dev[iDev].uPrerollDuration = 90;
 

                viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                                achPacket, 
                                viscaMessageENT_FrameMemorySelectInq(achPacket + 1));

                if(achPacket[2] == 2)
                    pvcr->Port[iPort].Dev[iDev].dwFreezeMode    = MCI_VCR_FREEZE_OUTPUT;
                else if(achPacket[2] == 1)
                    pvcr->Port[iPort].Dev[iDev].dwFreezeMode    = MCI_VCR_FREEZE_INPUT;

                viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                                achPacket, 
                                viscaMessageSE_VDEReadModeInq(achPacket + 1));

                if(achPacket[2] == 2)
                    pvcr->Port[iPort].Dev[iDev].fField    = TRUE;
                else if(achPacket[2] == 1)
                    pvcr->Port[iPort].Dev[iDev].fField    = FALSE;

                break;
        }
    }
    //
    // Information that requires communication to the device 
    //
    if (!viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
        achPacket, 
        viscaMessageMD_ConfigureIFInq(achPacket + 1)))
        pvcr->Port[iPort].Dev[iDev].uFramesPerSecond = FROMBCD(achPacket[2]);
    else
        pvcr->Port[iPort].Dev[iDev].uFramesPerSecond = 30;

    pvcr->Port[iPort].Dev[iDev].uTimeMode      = MCI_VCR_TIME_DETECT;
    pvcr->Port[iPort].Dev[iDev].bTimeType      = (BYTE) 0;
    if(viscaSetTimeType(iInst, VISCAABSOLUTECOUNTER))
        pvcr->Port[iPort].Dev[iDev].bTimeType = VISCARELATIVECOUNTER;
    
    pvcr->Port[iPort].Dev[iDev].uIndexFormat   = MCI_VCR_INDEX_TIMECODE;
    //
    // Get the mode, be sure no to notify!! 
    //
    pvcr->Port[iPort].Dev[iDev].fTimecodeChecked = FALSE;

    mciStatus.dwItem = MCI_STATUS_MODE;
    dwErr = viscaMciStatus(iInst, MCI_STATUS_ITEM, &mciStatus);

    if(HIWORD(mciStatus.dwReturn) == MCI_MODE_NOT_READY)
    {
        MCI_VCR_SET_PARMS mciSet;
        DPF(DBG_MCI, "Power is off, turning power on now.\n");
        //
        // Turn the power on 
        //
        viscaMciSet(iInst, MCI_VCR_SET_POWER | MCI_SET_ON, &mciSet);
        //
        // Get the new mode 
        //
        mciStatus.dwItem = MCI_STATUS_MODE;
        dwErr = viscaMciStatus(iInst, MCI_STATUS_ITEM, &mciStatus);
    }

    //
    // Save our current state.
    //
    pvcr->Port[iPort].Dev[iDev].uLastKnownMode = (UINT) mciStatus.dwReturn;
    switch(HIWORD(mciStatus.dwReturn))
    {
        case MCI_MODE_STOP:
            // I don't need to know, so just start it now 
            viscaStartTimecodeCheck(iInst, TRUE);
            break;

        case MCI_MODE_PLAY:
        case MCI_MODE_RECORD:
        case MCI_MODE_SEEK:
        case MCI_MODE_PAUSE:
            // I don't need to know, so just start it now 
            viscaStartTimecodeCheck(iInst, FALSE);
            break;

        case MCI_MODE_NOT_READY:
        case MCI_MODE_OPEN:
        default:
            // nothing we can do 
            break;
    }
    //
    // Counter is different than Timecode because it can be read as
    // soon as a tape is inserted. There is no need to delay on that one.
    //
    if(!viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                                        achPacket, 
                                        viscaMessageMD_PositionInq(achPacket + 1, VISCADATARELATIVE)))
    {
        // The upper 4 bits indicates default counter in use 
        if(achPacket[1] == VISCADATAHMSF)
            pvcr->Port[iPort].Dev[iDev].bRelativeType = VISCADATAHMSF;
        else
            pvcr->Port[iPort].Dev[iDev].bRelativeType = VISCADATAHMS;
    }
    else
    {
        pvcr->Port[iPort].Dev[iDev].bRelativeType = 0;
    }
    pvcr->Port[iPort].Dev[iDev].fCounterChecked = TRUE;


    pvcr->Port[iPort].Dev[iDev].uRecordMode = FALSE;

    //
    // Bug in CI-1000 ROM.  Returns 30 instead of 300, so just set all to 300.
    //
#ifdef CLOCK_FIXED 
    if(!viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
        achPacket, 
        viscaMessageIF_ClockInq(achPacket + 1)))
          pvcr->Port[iPort].Dev[iDev].uTicksPerSecond = (10 * (FROMBCD(achPacket[7]))) + (FROMBCD(achPacket[8]));
#else
    pvcr->Port[iPort].Dev[iDev].uTicksPerSecond = 300;
#endif
    //
    // Save static device information, that does not require communication.
    //
    pvcr->Port[iPort].Dev[iDev].nUsage = 1;
    pvcr->Port[iPort].Dev[iDev].fShareable = ((dwFlags & MCI_OPEN_SHAREABLE) != 0L);
    pvcr->Port[iPort].Dev[iDev].dwTapeLength = NO_LENGTH;
    
    return (MCIERR_NO_ERROR);
}

/****************************************************************************
 * Function: DWORD viscaSetTimeType - If CI1000 we need subControl when changing
 *          from relative to absolute modes.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      BYTE bType - ABSOLUTE or RELATIVE
 *
 * Returns: 0L
 *
 ***************************************************************************/
DWORD FAR PASCAL viscaSetTimeType(int iInst, BYTE bType)
{
    UINT    iPort   = pinst[iInst].iPort;
    UINT    iDev    = pinst[iInst].iDev;
    //
    // The only reason to use, SubControl is for CI-1000 compatibility 
    //
    if((pvcr->Port[iPort].Dev[iDev].uModelID == VISCADEVICEVENDORSONY) &&
       (pvcr->Port[iPort].Dev[iDev].uVendorID == VISCADEVICEMODELCI1000))
    {
        if(pvcr->Port[iPort].Dev[iDev].bTimeType != bType)
        {
            BYTE    achPacket[MAXPACKETLENGTH];
            DWORD   dwErr;

            dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_Subcontrol(achPacket + 1, bType));

            if(!dwErr)
                pvcr->Port[iPort].Dev[iDev].bTimeType =  bType;
            else
                return 1L;
        }
    }
    else
    {
        pvcr->Port[iPort].Dev[iDev].bTimeType =  bType;
    }

    return 0L;
}


/****************************************************************************
 * Function: DWORD viscaDeviceAlreadyOpen - Open a device that is already open.
 *
 * Parameters:
 *
 *      int iInst - open instance.
 *
 *      DWORD dwFlags - Flags to the open.
 *
 *      LPMCI_OPEN_PARMS lpOpen - Pointer to MCI parameter block.
 *
 * Returns: 0L
 *
 ***************************************************************************/
DWORD NEAR PASCAL viscaDeviceAlreadyOpen(int iInst, DWORD dwFlags, LPMCI_OPEN_PARMS lpOpen)

{
    UINT    iPort   = pinst[iInst].iPort;
    UINT    iDev    = pinst[iInst].iDev;
    DWORD   dwErr;

    if (pvcr->Port[iPort].Dev[iDev].fShareable)
    {
        if (dwFlags & MCI_OPEN_SHAREABLE)
        {
            pvcr->Port[iPort].nUsage++;
            pvcr->Port[iPort].Dev[iDev].nUsage++;

            // Port is already open.
            DuplicatePortHandlesToInstance(pvcr->htaskCommNotifyHandler, iPort, iInst);

            // Device handles must already have been created to open shareable.
            DuplicateDeviceHandlesToInstance(pvcr->htaskCommNotifyHandler, iPort, iDev, iInst);

            // Is the device dead before we open it?
            if(!pvcr->Port[iPort].Dev[iDev].fDeviceOk)
            {
                dwErr = MCIERR_DEVICE_NOT_READY;
                pvcr->Port[iPort].Dev[iDev].fDeviceOk = TRUE;
                viscaNotifyReturn(iInst, (HWND) lpOpen->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr);
                return dwErr;
            }

            DPF(DBG_MCI, "Opening extra copy shareable\n");
            viscaNotifyReturn(iInst, (HWND) lpOpen->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR);
            return MCIERR_NO_ERROR;
        }
        else
        {
            DPF(DBG_MCI, "Cannot open non-shareable since already open shareable\n");

            dwErr = MCIERR_MUST_USE_SHAREABLE;
            viscaNotifyReturn(iInst, (HWND) lpOpen->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr);
            return dwErr;
        }
    }
    else
    {
        DPF(DBG_MCI, "Cannot open device since already open non-shareable\n");

        dwErr = MCIERR_MUST_USE_SHAREABLE;
        viscaNotifyReturn(iInst, (HWND) lpOpen->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr);
        return dwErr;
    }
}

/****************************************************************************
 * Function: DWORD viscaOpenCommPort - Open the commport.
 *
 * Parameters:
 *
 *      int iInst - Open instance.
 *
 *      DWORD dwFlags - Open flags.
 *
 *      LPMCI_OPEN_PARMS lpOpen - Pointer to MCI parameter block.
 *
 * Returns: 0L
 *
 ***************************************************************************/
DWORD NEAR PASCAL viscaOpenCommPortAndDevice(int iInst, DWORD dwFlags, LPMCI_OPEN_PARMS lpOpen)
{
    BYTE    achPacket[MAXPACKETLENGTH];
    UINT    iPort   = pinst[iInst].iPort;
    UINT    iDev    = pinst[iInst].iDev;
    DWORD   dwErr;

    viscaTaskDo(iInst, TASKOPENCOMM, iPort + 1, 0);

    if(pvcr->Port[iPort].idComDev < 0)
    {
        dwErr = MCIERR_HARDWARE;
        viscaNotifyReturn(iInst, (HWND) lpOpen->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr);

        return dwErr;
    }

    DuplicatePortHandlesToInstance(pvcr->htaskCommNotifyHandler, iPort, iInst);

    // We must open the device here to use it's data structures to communicate
    // with the Visca Network.

    viscaTaskDo(iInst, TASKOPENDEVICE, iPort, iDev);
    DuplicateDeviceHandlesToInstance(pvcr->htaskCommNotifyHandler, iPort, iDev, iInst);

    // We have the green light to begin sending commands.

    pvcr->Port[iPort].Dev[iDev].fDeviceOk = TRUE;

    dwErr = viscaDoImmediateCommand(iInst, BROADCASTADDRESS,
                    achPacket,
                    viscaMessageIF_Clear(achPacket + 1));

    // Find number of devices on comm port.
    pvcr->Port[iPort].Dev[iDev].fDeviceOk = TRUE;

    dwErr = viscaDoImmediateCommand(iInst, BROADCASTADDRESS,
                    achPacket,
                    viscaMessageIF_Address(achPacket + 1));
    if (dwErr)
    {
        DPF(DBG_ERROR, "Could not assign addresses.\n");
        //
        // We cannot return dwErr, because if this is the last instance
        // of the driver, we will be unloaded before it can look up
        // the error string. So, we must return a generic error from mmsystem.
        //
        if (dwErr >= MCIERR_CUSTOM_DRIVER_BASE)
            dwErr = MCIERR_DEVICE_NOT_READY;

        viscaNotifyReturn(iInst, (HWND) lpOpen->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr);
        viscaTaskDo(iInst, TASKCLOSECOMM, iPort + 1, 0); //Porthandles destroyed.
        viscaTaskDo(iInst, TASKCLOSEDEVICE, iPort, iDev); //Devicehandles destroyed.
        return dwErr;
    }

    // Okay, assign the addresses.

    pvcr->Port[iPort].nDevices = achPacket[2];  //!! From the address packet.
    if (pvcr->Port[iPort].nDevices > 0)
        pvcr->Port[iPort].nDevices--;           // Don't count the computer

    return MCIERR_NO_ERROR;
}

/****************************************************************************
 * Function: DWORD viscaRetryOpenDevice - Retries to open a device
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_OPEN_PARMS lpOpen - Pointer to MCI parameter block.
 *
 * Returns: 0L
 *
 ***************************************************************************/
DWORD NEAR PASCAL viscaRetryOpenDevice(int iInst, DWORD dwFlags, LPMCI_OPEN_PARMS lpOpen)
{
    BYTE    achPacket[MAXPACKETLENGTH];
    UINT    iPort   = pinst[iInst].iPort;
    UINT    iDev    = pinst[iInst].iDev;
    DWORD   dwErr;
    //
    // Try for a "hot-docking".  But this may really mess things up! but try anyway.
    //
    pvcr->Port[iPort].Dev[iDev].fDeviceOk = TRUE;
    dwErr = viscaDoImmediateCommand(iInst, BROADCASTADDRESS,
                achPacket,
                viscaMessageIF_Address(achPacket + 1));

    pvcr->Port[iPort].nDevices = achPacket[2];//!! From the address packet.
    if (pvcr->Port[iPort].nDevices > 0)
        pvcr->Port[iPort].nDevices--;       // Don't count the computer

    if(dwErr || (iDev >= pvcr->Port[iPort].nDevices))
    {
        dwErr = MCIERR_HARDWARE;

        viscaNotifyReturn(iInst, (HWND) lpOpen->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr);
        CloseDeviceHandles(pvcr->htaskCommNotifyHandler, iPort, iDev);
        return dwErr;
    }

    return MCIERR_NO_ERROR;
}


/****************************************************************************
 * Function: DWORD viscaMciOpenDriver - Edit instance-specific initialization.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_OPEN_PARMS lpOpen - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_OPEN_DRIVER
 *
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciOpenDriver(int iInst, DWORD dwFlags, LPMCI_OPEN_PARMS lpOpen)
{
    UINT    iPort   = pinst[iInst].iPort;
    UINT    iDev    = pinst[iInst].iDev;
    DWORD   dwErr;

    if (dwFlags & MCI_OPEN_ELEMENT)
    {
        dwErr = viscaNotifyReturn(iInst, (HWND) lpOpen->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_NO_ELEMENT_ALLOWED);

        return dwErr;
    }

    DuplicateGlobalHandlesToInstance(pvcr->htaskCommNotifyHandler, iInst);  // Always do this immediately.

    // Handle case in which device is already open.

    if (pvcr->Port[iPort].Dev[iDev].nUsage > 0)
        return(viscaDeviceAlreadyOpen(iInst, dwFlags, lpOpen));

    // Set the device status to ok here. We must be able to try.

    pvcr->Port[iPort].Dev[iDev].fDeviceOk = TRUE;

    // If we come here: The device is not open yet. Check if the port is not yet open.

    if (pvcr->Port[iPort].nUsage == 0)
    {
        // Okay, open the port.  

        dwErr = viscaOpenCommPortAndDevice(iInst, dwFlags, lpOpen);
        if(dwErr)
        {
            return dwErr;
        }
        // Continue if the port opens okay!
    }
    else
    {
        // Port is already open, but not this device.

        DuplicatePortHandlesToInstance(pvcr->htaskCommNotifyHandler, iPort, iInst);
        viscaTaskDo(iInst, TASKOPENDEVICE, iPort, iDev);
        DuplicateDeviceHandlesToInstance(pvcr->htaskCommNotifyHandler, iPort, iDev, iInst);
    }

    // *** From this point on we are guarnteed of having valid device handles!

    if (iDev >= pvcr->Port[iPort].nDevices)
    {
        DPF(DBG_COMM, "Device # not on line\n");

        // If the port was just opened(and address broadcast), then close it

        if (pvcr->Port[iPort].nUsage == 0)
        {
            dwErr = MCIERR_HARDWARE;

            dwErr = viscaNotifyReturn(iInst, (HWND) lpOpen->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr);
            viscaTaskDo(iInst, TASKCLOSECOMM, iPort + 1, 0); //Porthandles destroyed.
            viscaTaskDo(iInst, TASKCLOSEDEVICE, iPort, iDev); //Porthandles destroyed.
            return dwErr;
        }
        else
        {
            // Port was opened earlier, maybe some plugged in a second since then.

            dwErr = viscaRetryOpenDevice(iInst, dwFlags, lpOpen);
            if(dwErr)
                return dwErr;
        }
    }

    // Successful opening Store # of devices on port

    DPF(DBG_MCI, "# devs = %u\n", pvcr->Port[iPort].nDevices);
    DPF(DBG_MCI, "dev  # = %u\n", iDev);

    // All is well, the device is being opened for the first time.

    pvcr->Port[iPort].nUsage++;
    
    // Device specific information must now be gotten/filled in.

    viscaDeviceConfig(iInst, dwFlags);
    return (viscaNotifyReturn(iInst, (HWND) lpOpen->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
}

/****************************************************************************
 * Function: DWORD viscaMciGetDevCaps - Get device capabilities.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_GETDEVCAPS_PARMS lpCaps - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_GETDEVCAPS
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciGetDevCaps(int iInst, DWORD dwFlags, LPMCI_GETDEVCAPS_PARMS lpCaps)
{
    UINT    iDev  = pinst[iInst].iDev;
    UINT    iPort = pinst[iInst].iPort;

    if (!(dwFlags & MCI_GETDEVCAPS_ITEM))
        return (viscaNotifyReturn(iInst, (HWND) lpCaps->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_MISSING_PARAMETER));

    switch (lpCaps->dwItem)
    {
        case MCI_GETDEVCAPS_CAN_SAVE:
        case MCI_GETDEVCAPS_USES_FILES:
        case MCI_GETDEVCAPS_COMPOUND_DEVICE:
        case MCI_VCR_GETDEVCAPS_CAN_DETECT_LENGTH:
        case MCI_VCR_GETDEVCAPS_CAN_MONITOR_SOURCES:
        case MCI_VCR_GETDEVCAPS_CAN_PREVIEW:
            lpCaps->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
            return (viscaNotifyReturn(iInst, (HWND) lpCaps->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));

        case MCI_VCR_GETDEVCAPS_CLOCK_INCREMENT_RATE:
            // The ticks should have been read on device startup. 
            lpCaps->dwReturn =    pvcr->Port[iPort].Dev[iDev].uTicksPerSecond;
            return (viscaNotifyReturn(iInst, (HWND) lpCaps->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));


        case MCI_VCR_GETDEVCAPS_CAN_FREEZE:
        if((pvcr->Port[iPort].Dev[iDev].uModelID == VISCADEVICEVENDORSONY) &&
           (pvcr->Port[iPort].Dev[iDev].uVendorID == VISCADEVICEMODELEVO9650))
        {
            lpCaps->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
            return (viscaNotifyReturn(iInst, (HWND) lpCaps->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
        }
        else
        {
            lpCaps->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
            return (viscaNotifyReturn(iInst, (HWND) lpCaps->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
        }
        break;


        case MCI_VCR_GETDEVCAPS_HAS_TIMECODE: 
        {
            //
            // This is the VCR capability NOT the current tape! And returns true if unknown.
            //
            lpCaps->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
            return (viscaNotifyReturn(iInst, (HWND) lpCaps->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
        }

        case MCI_GETDEVCAPS_CAN_PLAY:
        case MCI_GETDEVCAPS_CAN_RECORD:
        case MCI_GETDEVCAPS_HAS_AUDIO:
        case MCI_GETDEVCAPS_HAS_VIDEO:
        case MCI_GETDEVCAPS_CAN_EJECT:
        case MCI_VCR_GETDEVCAPS_CAN_REVERSE:
        case MCI_VCR_GETDEVCAPS_CAN_PREROLL:
        case MCI_VCR_GETDEVCAPS_CAN_TEST:
        case MCI_VCR_GETDEVCAPS_HAS_CLOCK:
            lpCaps->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
            return (viscaNotifyReturn(iInst, (HWND) lpCaps->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));

        case MCI_GETDEVCAPS_DEVICE_TYPE:
            lpCaps->dwReturn = MAKEMCIRESOURCE(MCI_DEVTYPE_VCR,
                                               MCI_DEVTYPE_VCR);
            return (viscaNotifyReturn(iInst, (HWND) lpCaps->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));

        case MCI_VCR_GETDEVCAPS_NUMBER_OF_MARKS:
            lpCaps->dwReturn = 99L;
            return (viscaNotifyReturn(iInst, (HWND) lpCaps->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

       
        case MCI_VCR_GETDEVCAPS_SEEK_ACCURACY:
            lpCaps->dwReturn = 0L;
            return (viscaNotifyReturn(iInst, (HWND) lpCaps->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        default:
            return (viscaNotifyReturn(iInst, (HWND) lpCaps->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_BAD_CONSTANT));
    }
}


/****************************************************************************
 * Function: DWORD viscaMciInfo - Get device information.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_INFO_PARMS lpInfo - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_INFO
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciInfo(int iInst, DWORD dwFlags, LPMCI_INFO_PARMS lpInfo)
{
    if ((dwFlags & MCI_INFO_PRODUCT) && (lpInfo->lpstrReturn != NULL))
    {
        BYTE    achPacket[MAXPACKETLENGTH];
        UINT    iDev    = pinst[iInst].iDev;
        UINT    cb      = 0;

        if (lpInfo->dwRetSize == 0L)
            return (viscaNotifyReturn(iInst, (HWND) lpInfo->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_PARAM_OVERFLOW));

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpInfo->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        lpInfo->lpstrReturn[lpInfo->dwRetSize - 1] = '\0';

        if (!viscaDoImmediateCommand(iInst, (BYTE) (iDev + 1),
                    achPacket,
                    viscaMessageIF_DeviceTypeInq(achPacket + 1)))
        {
            cb += LoadString(hModuleInstance,IDS_VENDORID1_BASE + achPacket[3],
                             lpInfo->lpstrReturn, (int)lpInfo->dwRetSize);

            if ((cb > 0) && (cb < lpInfo->dwRetSize))
                lpInfo->lpstrReturn[cb++] = ' ';

            if (cb < lpInfo->dwRetSize)
                cb += LoadString(hModuleInstance,IDS_MODELID2_BASE + achPacket[5],
                                 lpInfo->lpstrReturn + cb, (int)lpInfo->dwRetSize - cb);

            if (cb > 0)
            {
                if (lpInfo->lpstrReturn[lpInfo->dwRetSize - 1] == '\0')
                    return (viscaNotifyReturn(iInst, (HWND) lpInfo->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
                else
                    return (viscaNotifyReturn(iInst, (HWND) lpInfo->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_PARAM_OVERFLOW));
            }
        }
        //
        // Couldn't successfully get vendor and model information
        // from device.  So return a default string.
        //
        LoadString(hModuleInstance, IDS_DEFAULT_INFO_PRODUCT,
                   lpInfo->lpstrReturn, (int)lpInfo->dwRetSize);

        if (lpInfo->lpstrReturn[lpInfo->dwRetSize - 1] == '\0')
            return (viscaNotifyReturn(iInst, (HWND) lpInfo->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
        else
            return (viscaNotifyReturn(iInst, (HWND) lpInfo->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_PARAM_OVERFLOW));

    }
    else if ((dwFlags & MCI_VCR_INFO_VERSION) && (lpInfo->lpstrReturn != NULL))
    {
        if (lpInfo->dwRetSize == 0L)
            return (viscaNotifyReturn(iInst, (HWND) lpInfo->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_PARAM_OVERFLOW));

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpInfo->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        lpInfo->lpstrReturn[lpInfo->dwRetSize - 1] = '\0';
        LoadString(hModuleInstance, IDS_VERSION,lpInfo->lpstrReturn, (int)lpInfo->dwRetSize);

        if (lpInfo->lpstrReturn[lpInfo->dwRetSize - 1] == '\0')
            return (viscaNotifyReturn(iInst, (HWND) lpInfo->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
        else
            return (viscaNotifyReturn(iInst, (HWND) lpInfo->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_PARAM_OVERFLOW));
    }
    else
    {
        return (viscaNotifyReturn(iInst, (HWND) lpInfo->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_MISSING_PARAMETER));
    }
}

/****************************************************************************
 * Function: DWORD viscaNotifyReturn - Notifies an instance (decides if).
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      HWND  hWndNotify  - Window to send notify to.
 *
 *      DWORD dwFlags     - Did the instance actually request notification.
 *
 *      DWORD dwNotifyMsg - Which notification message to send.
 *
 *      DWORD dwReturnMsg - What return value to return.
 *
 * Returns: dwReturnMsg, so you can just return this function.
 *
 *       This function, in a sense, synchronizes the sending of notifies
 *   on a per-instance basis.  I.e. If there is a notify already existing
 *   then it must be superseded because this is a second one. This can
 *   happen because the same or different instance has started a delayed
 *   command and set the notify hwnd when it was started.
 *
 ***************************************************************************/
DWORD FAR PASCAL
viscaNotifyReturn(int iInst, HWND hwndNotify, DWORD dwFlags, UINT uNotifyMsg, DWORD dwReturnMsg)
{
    if(dwFlags & MCI_NOTIFY)
    {
        //
        // If return is failure then do not notify at all!
        //
        if(uNotifyMsg == MCI_NOTIFY_FAILURE)
            return dwReturnMsg;
        //
        // If this inst has a transport running, then we must supersede the noitfication.
        //
        if(pinst[iInst].hwndNotify != (HWND)NULL)
        {
            mciDriverNotify(pinst[iInst].hwndNotify, pinst[iInst].uDeviceID, MCI_NOTIFY_SUPERSEDED);
            pinst[iInst].hwndNotify = (HWND)NULL;
        }

        //
        // If success, or abort, then we must notify now.
        //
        mciDriverNotify(hwndNotify, pinst[iInst].uDeviceID, uNotifyMsg);
    }
    return dwReturnMsg;
}


/****************************************************************************
 * Function: DWORD viscaStartTimecodeCheck - start the timecode check timer.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      BOOL fPause - Do we send a pause command.
 *
 * Returns: TRUE.
 *
 *       Some devices must be paused before timecode can be checked.
 *      
 ***************************************************************************/
static BOOL NEAR PASCAL
viscaStartTimecodeCheck(int iInst, BOOL fPause)
{
    DWORD   dwErr;
    BYTE    achPacket[MAXPACKETLENGTH];
    UINT    iDev    = pinst[iInst].iDev;
    UINT    iPort   = pinst[iInst].iPort;

    if(fPause)
    {
        dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1STILL));
    }
    //
    // First, check if the counter is now available 
    //
    if(pvcr->Port[iPort].Dev[iDev].fCounterChecked == FALSE)
    {
        if(!viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                                            achPacket, 
                                            viscaMessageMD_PositionInq(achPacket + 1, VISCADATARELATIVE)))
        {
            // the upper 4 bits indicates default counter in use 
            if(achPacket[1] == VISCADATAHMSF)
                pvcr->Port[iPort].Dev[iDev].bRelativeType = VISCADATAHMSF;
            else
                pvcr->Port[iPort].Dev[iDev].bRelativeType = VISCADATAHMS;

        }
        else
        {
            // For the new decks that can fail counter! (like cvd-500)
            pvcr->Port[iPort].Dev[iDev].bRelativeType = 0;
        }
        pvcr->Port[iPort].Dev[iDev].fCounterChecked = TRUE;
    }


    DPF(DBG_MCI, "Starting time code check timer\n");

    pvcr->Port[iPort].Dev[iDev].dwStartTime     = GetTickCount();    
    pvcr->Port[iPort].Dev[iDev].fTimecodeChecked   = TC_WAITING;

    return TRUE;
}

/****************************************************************************
 * Function: BOOL viscaTimecodeCheckAndSet - If there is timecode -> set the state.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 * Returns: TRUE.
 *
 *       Sony bug#2: does not know about timecode yet:
 *      1) door open
 *      2) play causes queue reset.
 *      3) pause (with a wait)
 *      4) media check, still doesn't know. (must wait some random time)
 *       
 ***************************************************************************/
BOOL FAR PASCAL
viscaTimecodeCheckAndSet(int iInst)
{
    UINT    iDev    = pinst[iInst].iDev;
    UINT    iPort   = pinst[iInst].iPort;
    BYTE    achPacket[MAXPACKETLENGTH];

    //
    // First, check if the counter is now available 
    //
    if(pvcr->Port[iPort].Dev[iDev].fCounterChecked == FALSE)
    {
        if(!viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                                            achPacket, 
                                            viscaMessageMD_PositionInq(achPacket + 1, VISCADATARELATIVE)))
        {
            // the upper 4 bits indicates default counter in use 
            if(achPacket[1] == VISCADATAHMSF)
                pvcr->Port[iPort].Dev[iDev].bRelativeType = VISCADATAHMSF;
            else
                pvcr->Port[iPort].Dev[iDev].bRelativeType = VISCADATAHMS;
        }
        else
        {
            pvcr->Port[iPort].Dev[iDev].bRelativeType = 0;
        }
        pvcr->Port[iPort].Dev[iDev].fCounterChecked = TRUE;
    }
 
    if( (pvcr->Port[iPort].Dev[iDev].fTimecodeChecked==TC_DONE) ||
        (pvcr->Port[iPort].Dev[iDev].uTimeMode != MCI_VCR_TIME_DETECT))
        return FALSE;

    if(viscaTimecodeCheck(iInst))
        viscaSetTimeType(iInst, VISCAABSOLUTECOUNTER);
    else
        viscaSetTimeType(iInst, VISCARELATIVECOUNTER);
    //
    // This means it has been set 
    //
    pvcr->Port[iPort].Dev[iDev].fTimecodeChecked = TC_DONE;

    return TRUE;
}


/****************************************************************************
 * Function: BOOL viscaTimecodeCheck - Is there timecode available?
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 * Returns: TRUE if there is, FALSE otherwise.
 *
 *       Some devices are a bit difficult to determine if there is timecode.
 *      
 ***************************************************************************/
static BOOL NEAR PASCAL
viscaTimecodeCheck(int iInst)
{
    DWORD   dwErr;
    BYTE    achPacket[MAXPACKETLENGTH];
    MCI_VCR_STATUS_PARMS mciStatus;
    DWORD   dwWaitTime  = 3000L;
    UINT    iDev        = pinst[iInst].iDev;
    UINT    iPort       = pinst[iInst].iPort;
    DWORD   dwStart, dwTime;


    if(pvcr->Port[iPort].Dev[iDev].fTimecodeChecked != TC_WAITING)
    {
        mciStatus.dwItem = MCI_STATUS_MODE;
        dwErr = viscaMciStatus(iInst, MCI_STATUS_ITEM, &mciStatus);

        switch(HIWORD(mciStatus.dwReturn))
        {
            case MCI_MODE_STOP:
                viscaStartTimecodeCheck(iInst, TRUE);
                break;

            case MCI_MODE_PLAY:
            case MCI_MODE_RECORD:
            case MCI_MODE_SEEK:
            case MCI_MODE_PAUSE:
                // do we need to wait one these no 
                viscaStartTimecodeCheck(iInst, FALSE);
                dwWaitTime = 200;
                break;

            case MCI_MODE_NOT_READY:
            case MCI_MODE_OPEN:
                return FALSE;
            default:
                // nothing we can do 
                break;
        }
    }
    //
    // Wait for the current one or the one just started to finnish 
    //
    dwStart = pvcr->Port[iPort].Dev[iDev].dwStartTime;
    while(1)
    {
        // This is a very bad loop.
        dwTime = GetTickCount();
        if(MShortWait(dwStart, dwTime, dwWaitTime))
            break;
        Yield();
    }
    pvcr->Port[iPort].Dev[iDev].fTimecodeChecked == TC_DONE;
    DPF(DBG_MCI, "Done time code check timer!\n");

    dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                achPacket,
                viscaMessageMD_MediaTrackInq(achPacket + 1));
    //
    // CI-1000 (CVD-801) supports timecode but not this command == ignore any errors 
    //
    if(!dwErr)
    {
        /* If we do support this command we know! for sure we support or not */
        if(achPacket[3] & VISCATRACKTIMECODE)
            return TRUE;
        else
           return FALSE;
    }
    //
    // Ok, we support timecode, now ask for position in time-code. 
    //
    dwErr = viscaDoImmediateCommand(iInst, (BYTE)(pinst[iInst].iDev + 1),
                achPacket,
                viscaMessageMD_PositionInq(achPacket + 1,VISCADATAABSOLUTE));
    //
    // On CI-1000 we cannot determine! It will just return 0 always! 
    //
    if(dwErr || (!VISCAHOURS(achPacket+2) && !VISCAMINUTES(achPacket+2)
            && !VISCAMINUTES(achPacket+2) && !VISCAFRAMES(achPacket+2)))
        return FALSE;

    return TRUE;
}

/****************************************************************************
 * Function: DWORD viscaMciStatus - Get device status.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_VCR_STATUS_PARMS lpStatus - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_STATUS
 *       command.
 ***************************************************************************/
DWORD FAR PASCAL
viscaMciStatus(int iInst, DWORD dwFlags, LPMCI_VCR_STATUS_PARMS lpStatus)
{
    UINT    iDev    = pinst[iInst].iDev;
    UINT    iPort   = pinst[iInst].iPort;

    BYTE    achPacket[MAXPACKETLENGTH];
    DWORD   dwErr;

    DPF(DBG_MCI, "Status Flags=%lx ", dwFlags);
 
    if (dwFlags & MCI_STATUS_ITEM)
    {
        switch (lpStatus->dwItem)
        {
            case MCI_STATUS_POSITION:
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                viscaTimecodeCheckAndSet(iInst);

                if (dwFlags & MCI_TRACK)
                {
                    if (lpStatus->dwTrack == 1)
                    {
                        lpStatus->dwReturn = 0;
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
                    }
                    else
                    {
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));
                    }
                }
                else if (dwFlags & MCI_STATUS_START)
                {
                    lpStatus->dwReturn = 0;
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
                }
                else
                {
                    UINT    fTimeCode = TRUE;

                    if(pvcr->Port[iPort].Dev[iDev].bTimeType == VISCAABSOLUTECOUNTER)
                    {
                        //
                        // This device supports timecode, so this should never return an error,
                        // only sometimes return 0.  But we do not change it here.
                        //
                        dwErr = viscaDoImmediateCommand(iInst, (BYTE) (iDev + 1),
                                    achPacket,
                                    viscaMessageMD_PositionInq(achPacket + 1, VISCADATAABSOLUTE));
                    }
                    else
                    {
                        fTimeCode = FALSE;
                        dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                                        achPacket, 
                                        viscaMessageMD_PositionInq(achPacket + 1, VISCADATARELATIVE));
                    }

                    if (dwErr)
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));
                    //
                    // Always use the time format 
                    //
                    dwErr = viscaDataToMciTimeFormat(iInst, TRUE, achPacket + 2,
                                                     &(lpStatus->dwReturn));

                    if (dwErr == MCIERR_DRIVER_INTERNAL)
                    {
#ifdef DEBUG
                        UINT i;
                        DPF(DBG_ERROR, "Bad positon! Internal error.\n");
                        for (i=0; i<MAXPACKETLENGTH; i++) 
                            DPF(DBG_ERROR, "%#02x ", (UINT)(BYTE)achPacket[i]);
                        DPF(DBG_ERROR, "\n");
#endif
                    }

                    if(!dwErr || (dwErr == MCI_COLONIZED3_RETURN) || (dwErr == MCI_COLONIZED4_RETURN))
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, dwErr));
                    else
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));
                }

            case MCI_STATUS_LENGTH:
                if ((dwFlags & MCI_TRACK) && (lpStatus->dwTrack != 1))
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));

                if (pvcr->Port[iPort].Dev[iDev].dwTapeLength != NO_LENGTH)
                {
                    if(dwFlags & MCI_TEST)
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
                    //
                    // The user has explicitly set the length of the tape.
                    //
                    lpStatus->dwReturn = pvcr->Port[iPort].Dev[iDev].dwTapeLength;
                    switch (pinst[iInst].dwTimeFormat)
                    {
                        case MCI_FORMAT_HMS:
                        case MCI_FORMAT_MSF:
                            return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_COLONIZED3_RETURN));
                        case MCI_FORMAT_TMSF:
                        case MCI_FORMAT_SMPTE_24:
                        case MCI_FORMAT_SMPTE_25:
                        case MCI_FORMAT_SMPTE_30:
                        case MCI_FORMAT_SMPTE_30DROP:
                            return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback,
                                dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_COLONIZED4_RETURN));

                        default:
                            return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
                    }
                }
                else
                {
                    BYTE    bHours   = 0;
                    BYTE    bMinutes = 0;

                    if(dwFlags & MCI_TEST)
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
                    //
                    // Find out what type of tape is in the VCR
                    //
                    dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1),
                                achPacket,
                                viscaMessageMD_MediaInq(achPacket + 1));
                    if (dwErr)
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwFlags));

                    switch ((BYTE)achPacket[2])
                    {
                        case VISCAFORMAT8MM:
                        case VISCAFORMATHI8:
                        case VISCAFORMATVHS:
                        case VISCAFORMATSVHS:
                            switch ((BYTE)achPacket[3])
                            {
                                case VISCASPEEDSP:
                                    bHours = 2;
                                    break;
                                case VISCASPEEDLP:
                                    bHours = 4;
                                    break;
                                case VISCASPEEDEP:
                                    bHours = 6;
                                    break;
                            }
                            break;
                        case VISCAFORMATBETA:
                        case VISCAFORMATEDBETA:
                            switch ((BYTE)achPacket[3])
                            {
                                case VISCASPEEDSP:
                                    bHours = 1;
                                    bMinutes = 30;
                                    break;
                                case VISCASPEEDLP:
                                    bHours = 3;
                                    break;
                                case VISCASPEEDEP:
                                    bHours = 4;
                                    bMinutes = 30;
                                    break;
                            }
                            break;
                    }
                    //
                    // Construct dummy ViSCA data structure, so that
                    // we can then easily convert the time to the
                    // appropriate MCI time format
                    //
                    viscaDataPosition(achPacket, VISCADATAHMS, bHours, bMinutes, (BYTE)0, (BYTE)0);
                    //
                    // Convert to MCI time format
                    //
                    dwErr = viscaDataToMciTimeFormat(iInst, TRUE, achPacket,&(lpStatus->dwReturn));

                    if(!dwErr || (dwErr == MCI_COLONIZED3_RETURN) || (dwErr == MCI_COLONIZED4_RETURN))
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, dwErr));
                    else
                         return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));
                }

            case MCI_STATUS_CURRENT_TRACK:
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = 1;
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

            case MCI_STATUS_NUMBER_OF_TRACKS:
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = 1;
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));


            case MCI_VCR_STATUS_NUMBER_OF_VIDEO_TRACKS:
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = 1;
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

            case MCI_VCR_STATUS_NUMBER_OF_AUDIO_TRACKS:
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = 2;
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

            case MCI_STATUS_MODE:
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1),
                            achPacket,
                            viscaMessageMD_Mode1Inq(achPacket + 1));
                if (dwErr)
                {
                    if (dwErr == MCIERR_VCR_POWER_OFF)
                    {
                        lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_MODE_NOT_READY, MCI_MODE_NOT_READY);
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags,
                                    MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
                    }
                    else
                    {
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));
                    }
                }
                switch (achPacket[2])
                {
                    case VISCAMODE1STOP:
                    case VISCAMODE1STOPTOP:
                    case VISCAMODE1STOPEND:
                    case VISCAMODE1STOPEMERGENCY:
                        if(pvcr->Port[iPort].Dev[iDev].fTimecodeChecked == TC_UNKNOWN)
                            viscaStartTimecodeCheck(iInst, TRUE);
                        lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_MODE_STOP,
                                                             MCI_MODE_STOP);
                        break;
                    case VISCAMODE1SLOW2:
                    case VISCAMODE1SLOW1:
                    case VISCAMODE1PLAY:
                    case VISCAMODE1FAST1:
                    case VISCAMODE1FAST2:
                    case VISCAMODE1REVERSESLOW2:
                    case VISCAMODE1REVERSESLOW1:
                    case VISCAMODE1REVERSEPLAY:
                    case VISCAMODE1REVERSEFAST1:
                    case VISCAMODE1REVERSEFAST2:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_MODE_PLAY,
                                                             MCI_MODE_PLAY);
                        break;
                    case VISCAMODE1RECORD:
                    case VISCAMODE1CAMERAREC:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_MODE_RECORD,
                                                             MCI_MODE_RECORD);
                        break;
                    case VISCAMODE1FASTFORWARD:
                    case VISCAMODE1REWIND:
                    case VISCAMODE1SCAN:
                    case VISCAMODE1REVERSESCAN:
                    case VISCAMODE1EDITSEARCHFORWARD:
                    case VISCAMODE1EDITSEARCHREVERSE:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_MODE_SEEK,
                                                             MCI_MODE_SEEK);
                        break;
                    case VISCAMODE1STILL:
                    case VISCAMODE1RECPAUSE:
                    case VISCAMODE1CAMERARECPAUSE:
                        // Kludge to make stepping return seeking.
                        if(pvcr->Port[iPort].Dev[iDev].iInstTransport != -1)
                            lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_MODE_SEEK,
                                                                 MCI_MODE_SEEK);
                        else
                            lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_MODE_PAUSE,
                                                                 MCI_MODE_PAUSE);
                        break;
                    case VISCAMODE1EJECT:
                        pvcr->Port[iPort].Dev[iDev].fTimecodeChecked = FALSE;
                        pvcr->Port[iPort].Dev[iDev].fCounterChecked  = FALSE;
                        lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_MODE_OPEN,
                                                             MCI_MODE_OPEN);
                        break;
                    default:
                        pvcr->Port[iPort].Dev[iDev].fTimecodeChecked = FALSE;
                        pvcr->Port[iPort].Dev[iDev].fCounterChecked  = FALSE;
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                                    MCI_MODE_NOT_READY, MCI_MODE_NOT_READY);
                    break;
                }
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
            }

            case MCI_VCR_STATUS_TIMECODE_PRESENT:
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                if(viscaTimecodeCheck(iInst))
                {
                    lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
                }
                else
                {
                    lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
                }
            }
           
            case MCI_STATUS_MEDIA_PRESENT:
            {
                //
                // Determine whether a tape is present by determining the current mode.
                //
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                dwErr = viscaDoImmediateCommand(iInst, (BYTE)(pinst[iInst].iDev + 1),
                            achPacket,                        
                            viscaMessageMD_Mode1Inq(achPacket + 1));

                if (dwErr)
                       return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

                if (achPacket[2] == VISCAMODE1EJECT)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
                else
                    lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
            }
            
            case MCI_STATUS_TIME_FORMAT:

                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = MAKEMCIRESOURCE(pinst[iInst].dwTimeFormat + MCI_FORMAT_MILLISECONDS,
                                            pinst[iInst].dwTimeFormat + MCI_FORMAT_MILLISECONDS_S);
 
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
            
            case MCI_STATUS_READY:
            {

                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));


                // Check if we are ready by determining VCR mode
                dwErr = viscaDoImmediateCommand(iInst, (BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_Mode1Inq(achPacket + 1));
                if (dwErr)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

                // Only if there is no tape then we aren't ready; otherwise we are ready.
                if (achPacket[2] == VISCAMODE1EJECT)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
                else
                    lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
            }

            case MCI_VCR_STATUS_FRAME_RATE: 
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1),
                                achPacket,
                                viscaMessageMD_ConfigureIFInq(achPacket + 1));
                
                if (dwErr)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));
                //
                // Store result in lpStatus->dwReturn,
                // as well as in the device's frames-per-second entry,
                // so that we store the most recent value.
                //
                pvcr->Port[iPort].Dev[iDev].uFramesPerSecond = FROMBCD(achPacket[2]);

                lpStatus->dwReturn = pvcr->Port[iPort].Dev[iDev].uFramesPerSecond;

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
            }

            case MCI_VCR_STATUS_SPEED:
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = pvcr->Port[iPort].Dev[iDev].dwPlaySpeed;

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
            }

            case MCI_VCR_STATUS_CLOCK:
            {
                UINT    uHours, uMinutes, uSeconds;
                UINT    uTicks, uTicksL,  uTicksH;
                UINT    uTicksPerSecondL;
                UINT    uTicksPerSecondH;
                UINT    uTicksPerSecond;

                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
                //
                // Try to read time
                //
                dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                                achPacket,
                                viscaMessageIF_ClockInq(achPacket + 1));

                uHours    = FROMBCD(achPacket[2]);
                uMinutes  = FROMBCD(achPacket[3]);
                uSeconds  = FROMBCD(achPacket[4]);                               
                uTicksH   = FROMBCD(achPacket[5]);
                uTicksL   = FROMBCD(achPacket[6]);
                uTicksPerSecondH = FROMBCD(achPacket[7]);
                uTicksPerSecondL = FROMBCD(achPacket[8]);
         
                uTicks = uTicksH * 10 + uTicksL;
                uTicksPerSecond = pvcr->Port[iPort].Dev[iDev].uTicksPerSecond;
                

                lpStatus->dwReturn = (DWORD)
                    ((DWORD)uHours * 3600L * (DWORD)uTicksPerSecond) +
                    ((DWORD)uMinutes * 60L * (DWORD)uTicksPerSecond) +
                    ((DWORD)uSeconds * (DWORD)uTicksPerSecond) +
                    ((DWORD)uTicks);
                //
                // might be possible to use colonized 3 
                //
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
            }
            break;

            case MCI_VCR_STATUS_CLOCK_ID:
                lpStatus->dwReturn = iPort; // 0 relative? so should we add one 
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

            case MCI_VCR_STATUS_MEDIA_TYPE:
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                viscaTimecodeCheckAndSet(iInst);

                dwErr = viscaDoImmediateCommand(iInst, (BYTE)(pinst[iInst].iDev + 1),
                                achPacket,
                                viscaMessageMD_MediaInq(achPacket + 1));
                if (dwErr) 
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

                switch ((BYTE)achPacket[2]){
                    case VISCAFORMAT8MM:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_MEDIA_8MM, MCI_VCR_MEDIA_8MM);
                        break;
                    case VISCAFORMATHI8:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_MEDIA_HI8, MCI_VCR_MEDIA_HI8);
                        break;
                    case VISCAFORMATVHS:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_MEDIA_VHS, MCI_VCR_MEDIA_VHS);
                        break;
                    case VISCAFORMATSVHS:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_MEDIA_SVHS, MCI_VCR_MEDIA_SVHS);
                        break;
                    case VISCAFORMATBETA:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_MEDIA_BETA, MCI_VCR_MEDIA_BETA);
                        break;
                    case VISCAFORMATEDBETA:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_MEDIA_EDBETA, MCI_VCR_MEDIA_EDBETA);
                        break;
                    default:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_MEDIA_OTHER, MCI_VCR_MEDIA_OTHER);
                            break;
                }
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));
            }

            case MCI_VCR_STATUS_RECORD_FORMAT:
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                viscaTimecodeCheckAndSet(iInst);

                dwErr = viscaDoImmediateCommand(iInst, (BYTE)(pinst[iInst].iDev + 1),
                                achPacket,
                                viscaMessageMD_RecSpeedInq(achPacket + 1));
                if (dwErr)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

                switch ((BYTE)achPacket[2])
                {
                    case VISCASPEEDSP:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_FORMAT_SP, MCI_VCR_FORMAT_SP);
                        break;
                    case VISCASPEEDLP:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_FORMAT_LP, MCI_VCR_FORMAT_LP);
                        break;
                    case VISCASPEEDEP:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_FORMAT_EP, MCI_VCR_FORMAT_EP);
                        break;
                    default:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_FORMAT_OTHER, MCI_VCR_FORMAT_OTHER);
                            break;
                }
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));
            }

            case MCI_VCR_STATUS_PLAY_FORMAT:
            {
                //
                // Should perhaps use MD_MediaSpeedInq?
                // We use MD_MediaInq since both the Vbox CI-1000 and
                // the Vdeck CVD-1000 do not accept MD_MediaSpeedInq.
                //
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                viscaTimecodeCheckAndSet(iInst);
                dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_MediaInq(achPacket + 1));
                if (dwErr)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

                switch ((BYTE)achPacket[3])
                {
                    case VISCASPEEDSP:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_FORMAT_SP, MCI_VCR_FORMAT_SP);
                        break;
                    case VISCASPEEDLP:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_FORMAT_LP, MCI_VCR_FORMAT_LP);
                        break;
                    case VISCASPEEDEP:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_FORMAT_EP, MCI_VCR_FORMAT_EP);
                        break;
                    default:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_FORMAT_OTHER, MCI_VCR_FORMAT_OTHER);
                            break;
                }
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));
            }


            case MCI_VCR_STATUS_AUDIO_SOURCE:
            {

                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_InputSelectInq(achPacket + 1));

                if (dwErr)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

                if(((BYTE)achPacket[3] == (BYTE)VISCATUNER) || ((BYTE)achPacket[3] == (BYTE)VISCAOTHER))
                    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_TUNER, MCI_VCR_SRC_TYPE_TUNER);
                else if ((BYTE)achPacket[3] == (BYTE)VISCAOTHERLINE)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_LINE, MCI_VCR_SRC_TYPE_LINE);
                else if ((BYTE)achPacket[3] &  (BYTE)VISCALINE)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_LINE, MCI_VCR_SRC_TYPE_LINE);
                else if ((BYTE)achPacket[3] &  (BYTE)VISCASVIDEOLINE)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_SVIDEO, MCI_VCR_SRC_TYPE_SVIDEO);
                else if ((BYTE)achPacket[3] &  (BYTE)VISCAAUX)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_AUX, MCI_VCR_SRC_TYPE_AUX);
                else if ((BYTE)achPacket[3] ==  (BYTE)VISCAMUTE)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_MUTE, MCI_VCR_SRC_TYPE_MUTE);

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));
            }

            case MCI_VCR_STATUS_AUDIO_SOURCE_NUMBER:
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_InputSelectInq(achPacket + 1));

                if (dwErr)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

                if(((BYTE)achPacket[3] == (BYTE)VISCATUNER) || ((BYTE)achPacket[3] == (BYTE)VISCAOTHER))
                    lpStatus->dwReturn = 1L;
                else if ((BYTE)achPacket[3] == (BYTE)VISCAOTHERLINE)
                    lpStatus->dwReturn = 1L;
                else if ((BYTE)achPacket[3] &  (BYTE)VISCALINE)
                    lpStatus->dwReturn = (DWORD)((BYTE)achPacket[3] - (BYTE)VISCALINE);
                else if (achPacket[3] &  VISCASVIDEOLINE)
                    lpStatus->dwReturn = (DWORD)((BYTE)achPacket[3] - (BYTE)VISCASVIDEOLINE);
                else if (achPacket[3] &  VISCAAUX)
                    lpStatus->dwReturn = (DWORD)((BYTE)achPacket[3] - (BYTE)VISCAAUX);

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
            }
 
            case MCI_VCR_STATUS_VIDEO_SOURCE:
            {

                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_InputSelectInq(achPacket + 1));

                if (dwErr)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

                if(((BYTE)achPacket[2] == (BYTE)VISCATUNER) || ((BYTE)achPacket[2] == (BYTE)VISCAOTHER))
                    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_TUNER, MCI_VCR_SRC_TYPE_TUNER);
                else if ((BYTE)achPacket[2] == (BYTE)VISCAOTHERLINE)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_LINE, MCI_VCR_SRC_TYPE_LINE);
                else if ((BYTE)(achPacket[2] & (BYTE)0xf0) ==  (BYTE)VISCALINE)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_LINE, MCI_VCR_SRC_TYPE_LINE);
                else if ((BYTE)(achPacket[2] & (BYTE)0xf0) == (BYTE)VISCASVIDEOLINE)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_SVIDEO, MCI_VCR_SRC_TYPE_SVIDEO);
                else if ((BYTE)(achPacket[2] & (BYTE)0xf0) == (BYTE)VISCAAUX)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_AUX, MCI_VCR_SRC_TYPE_AUX);
                else if ((BYTE)achPacket[2] ==  (BYTE)0x00)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_MUTE, MCI_VCR_SRC_TYPE_MUTE);

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));

            }

            case MCI_VCR_STATUS_VIDEO_SOURCE_NUMBER:
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_InputSelectInq(achPacket + 1));

                if (dwErr)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

                if(((BYTE)achPacket[2] == (BYTE)VISCATUNER) || ((BYTE)achPacket[2] == (BYTE)VISCAOTHER))
                    lpStatus->dwReturn = 1L;
                else if ((BYTE)achPacket[2] == (BYTE)VISCAOTHERLINE)
                    lpStatus->dwReturn = 1L;
                else if ((BYTE)(achPacket[2] & (BYTE)0xf0) == (BYTE)VISCALINE)
                    lpStatus->dwReturn = (DWORD)((BYTE)achPacket[2] - (BYTE)VISCALINE);
                else if ((BYTE)(achPacket[2] & (BYTE)0xf0) == (BYTE)VISCASVIDEOLINE)
                    lpStatus->dwReturn = (DWORD) ((BYTE)achPacket[2] - (BYTE)VISCASVIDEOLINE);
                else if ((BYTE)(achPacket[2] &  (BYTE)0xf0) == (BYTE)VISCAAUX)
                    lpStatus->dwReturn = (DWORD) ((BYTE)achPacket[2] - (BYTE)VISCAAUX);

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
            }

            case MCI_VCR_STATUS_AUDIO_MONITOR_NUMBER:
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = 1;
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

            case MCI_VCR_STATUS_VIDEO_MONITOR_NUMBER:
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = 1;
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));


            case MCI_VCR_STATUS_VIDEO_MONITOR:
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_OUTPUT, MCI_VCR_SRC_TYPE_OUTPUT);
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));
                break;

            case MCI_VCR_STATUS_AUDIO_MONITOR:
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_OUTPUT, MCI_VCR_SRC_TYPE_OUTPUT);
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));
                break;


            case MCI_VCR_STATUS_INDEX_ON:
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));


                dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                            achPacket,
                            viscaMessageMD_OSDInq(achPacket + 1));

                if(achPacket[2] == VISCAOSDPAGEOFF)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
                else
                    lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
            }

            case MCI_VCR_STATUS_INDEX:
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = MAKEMCIRESOURCE(pvcr->Port[iPort].Dev[iDev].uIndexFormat,pvcr->Port[iPort].Dev[iDev].uIndexFormat);
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));
            }


            case MCI_VCR_STATUS_COUNTER_FORMAT:
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = MAKEMCIRESOURCE(pinst[iInst].dwCounterFormat + MCI_FORMAT_MILLISECONDS,
                                            pinst[iInst].dwCounterFormat + MCI_FORMAT_MILLISECONDS_S);

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
            }
            break;

            case MCI_VCR_STATUS_COUNTER_RESOLUTION:

                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                if(pvcr->Port[iPort].Dev[iDev].bRelativeType == VISCADATAHMSF)
                    lpStatus->dwReturn =  MAKEMCIRESOURCE(MCI_VCR_COUNTER_RES_FRAMES,
                                                MCI_VCR_COUNTER_RES_FRAMES);
                else if(pvcr->Port[iPort].Dev[iDev].bRelativeType == VISCADATAHMS)
                    lpStatus->dwReturn =  MAKEMCIRESOURCE(MCI_VCR_COUNTER_RES_SECONDS,
                                                MCI_VCR_COUNTER_RES_SECONDS);
                else
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_HARDWARE));

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));
                break;


            case MCI_VCR_STATUS_TIMECODE_TYPE:
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                viscaTimecodeCheckAndSet(iInst);
                //
                // May or may not set the i.e. if not on detect 
                //
                if(pvcr->Port[iPort].Dev[iDev].uTimeMode != MCI_VCR_TIME_DETECT)
                {
                    if(viscaTimecodeCheck(iInst))
                        lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_TIMECODE_TYPE_SMPTE,
                                                             MCI_VCR_TIMECODE_TYPE_SMPTE);
                    else
                        lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_TIMECODE_TYPE_NONE,
                                                             MCI_VCR_TIMECODE_TYPE_NONE);
                }
                else
                {
                    switch(pvcr->Port[iPort].Dev[iDev].bTimeType)
                    {
                        case VISCAABSOLUTECOUNTER:
                            lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_TIMECODE_TYPE_SMPTE,
                                                             MCI_VCR_TIMECODE_TYPE_SMPTE);
                             break;

                        case VISCARELATIVECOUNTER:
                            lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_TIMECODE_TYPE_NONE,
                                                             MCI_VCR_TIMECODE_TYPE_NONE);
                            break;
                    }

                }
               
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));
                break;
    

            case MCI_VCR_STATUS_COUNTER_VALUE: // status index 
            {

                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));


                dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                            achPacket, 
                            viscaMessageMD_PositionInq(achPacket + 1,
                                            VISCADATARELATIVE));
                if (dwErr)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

                dwErr = viscaDataToMciTimeFormat(iInst, FALSE, achPacket + 2, &(lpStatus->dwReturn));

                if(!dwErr || (dwErr == MCI_COLONIZED3_RETURN) || (dwErr == MCI_COLONIZED4_RETURN))
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, dwErr));
                else
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

            }
 
            case MCI_VCR_STATUS_TUNER_CHANNEL:
            {
                UINT uNumber = 1; // 1 is the default tuner 

                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                if(dwFlags & MCI_VCR_SETTUNER_NUMBER)
                    uNumber = (UINT) lpStatus->dwNumber;
                
                dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_ChannelInq(achPacket + 1));

                if (dwErr) 
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

                lpStatus->dwReturn = 100 * (achPacket[2] & 0x0F)+
                                      10 * (achPacket[3] & 0x0F)+
                                           (achPacket[4] & 0x0F);

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
            }


            case MCI_VCR_STATUS_WRITE_PROTECTED:
            {
                //
                // We cannot tell.
                // So according to the alpha VCR command set spec.,
                // we should return false.
                //
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
            }

            case MCI_VCR_STATUS_TIMECODE_RECORD:
            case MCI_VCR_STATUS_VIDEO_RECORD:
            case MCI_VCR_STATUS_AUDIO_RECORD:
            case MCI_VCR_STATUS_ASSEMBLE_RECORD:
            {
                BOOL    fRecord;
                BYTE    bTrack = VISCATRACK1;

                // Audio has 2 tracks, video 1. This is a kludge!

                if(dwFlags & MCI_TRACK)
                {
                    if(lpStatus->dwTrack==0)
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));

                    if((lpStatus->dwItem == MCI_VCR_STATUS_AUDIO_RECORD) &&
                        ((UINT)lpStatus->dwTrack > 2))
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));

                    if((lpStatus->dwItem == MCI_VCR_STATUS_VIDEO_RECORD) &&
                        ((UINT)lpStatus->dwTrack > 1))
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));
                }

                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                if(dwFlags & MCI_TRACK)
                {
                    if(lpStatus->dwTrack == 1)
                        bTrack = VISCATRACK1;
                    else if (lpStatus->dwTrack == 2)
                        bTrack = VISCATRACK2;
                }

                dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_RecTrackInq(achPacket + 1));

                if (dwErr) 
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));
                
                switch (lpStatus->dwItem)
                {
                    case MCI_VCR_STATUS_ASSEMBLE_RECORD:
                        fRecord = (achPacket[2] == 0) ? TRUE : FALSE;
                        break;

                    case MCI_VCR_STATUS_TIMECODE_RECORD:
                        fRecord = (achPacket[4] & VISCATRACKTIMECODE);
                        break;
                    case MCI_VCR_STATUS_VIDEO_RECORD:
                        fRecord = (achPacket[3] & bTrack);
                        break;
                    case MCI_VCR_STATUS_AUDIO_RECORD:
                        fRecord = (achPacket[5] & bTrack);
                        break;
 
                }

                if (fRecord)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
                else
                    lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
            }

            case MCI_VCR_STATUS_VIDEO:
            case MCI_VCR_STATUS_AUDIO:
            {
                BOOL    fPlay;
                BYTE    bTrack = VISCATRACK1;

                // Audio has 2 tracks, video 1.

                if(dwFlags & MCI_TRACK)
                {
                    if(lpStatus->dwTrack==0)
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));

                    if((lpStatus->dwItem == MCI_VCR_STATUS_AUDIO) &&
                        ((UINT)lpStatus->dwTrack > 2))
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));

                    if((lpStatus->dwItem == MCI_VCR_STATUS_VIDEO) &&
                        ((UINT)lpStatus->dwTrack > 1))
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));
                }

                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                if(dwFlags & MCI_TRACK)
                {
                    if(lpStatus->dwTrack == 1)
                        bTrack = VISCATRACK1;
                    else if (lpStatus->dwTrack == 2)
                        bTrack = VISCATRACK2;
                }

                dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_PBTrackInq(achPacket + 1));

                if (dwErr) 
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));
                
                switch (lpStatus->dwItem)
                {
                    case MCI_VCR_STATUS_VIDEO:
                        fPlay = (achPacket[2] & bTrack);
                        break;
                    case MCI_VCR_STATUS_AUDIO:
                        fPlay = (achPacket[4] & bTrack);
                        break;
 
                }

                if (fPlay)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
                else
                    lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
            }
            
            case MCI_VCR_STATUS_TIME_MODE:
            {
                WORD    wDeviceTimeMode = pvcr->Port[iPort].Dev[iDev].uTimeMode;

                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                viscaTimecodeCheckAndSet(iInst);

                switch(pvcr->Port[iPort].Dev[iDev].uTimeMode)
                {
                    case MCI_VCR_TIME_DETECT:
                    case MCI_VCR_TIME_TIMECODE:
                    case MCI_VCR_TIME_COUNTER:
                        lpStatus->dwReturn = MAKEMCIRESOURCE( wDeviceTimeMode, wDeviceTimeMode);
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));
                }
            }
            break;

            case MCI_VCR_STATUS_TIME_TYPE:
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                viscaTimecodeCheckAndSet(iInst);

                switch(pvcr->Port[iPort].Dev[iDev].bTimeType)
                {
                    case VISCAABSOLUTECOUNTER:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_TIME_TIMECODE,
                                                        MCI_VCR_TIME_TIMECODE);
                        break;

                    case VISCARELATIVECOUNTER:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_TIME_COUNTER,
                                                        MCI_VCR_TIME_COUNTER);
                        break;
                }
               
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));
            }

            case MCI_VCR_STATUS_POWER_ON:
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                dwErr = viscaDoImmediateCommand(iInst,    (BYTE)(iDev + 1),
                            achPacket,
                            viscaMessageMD_PowerInq(achPacket + 1));
                if (dwErr)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

                if (achPacket[2] == VISCAPOWERON)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
                else 
                    lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
            }


            case MCI_VCR_STATUS_PREROLL_DURATION:
            {
                dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                            achPacket,    
                            viscaMessageMD_SegPreRollDurationInq(achPacket + 1));

                // If error, make something up from the device info table 
                if (dwErr)
                {
                    UINT uFrames = pvcr->Port[iPort].Dev[iDev].uPrerollDuration;
                    UINT uDevFPS = pvcr->Port[iPort].Dev[iDev].uFramesPerSecond;

                    (BYTE)achPacket[3] = (BYTE) 0;   // hours expected at 2.
                    (BYTE)achPacket[4] = (BYTE) 0;
                    (BYTE)achPacket[5] = (BYTE) (uFrames / uDevFPS);
                    (BYTE)achPacket[6] = (BYTE) (uFrames % uDevFPS); 
                }
                dwErr = viscaDataToMciTimeFormat(iInst, TRUE, achPacket + 2, &(lpStatus->dwReturn));

                if(!dwErr || (dwErr == MCI_COLONIZED3_RETURN) || (dwErr == MCI_COLONIZED4_RETURN))
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, dwErr));
                else
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));
            }

            case MCI_VCR_STATUS_POSTROLL_DURATION:
            {
                dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                            achPacket,    
                            viscaMessageMD_SegPostRollDurationInq(achPacket + 1));

                // If error, make something up from the device info table 
                if (dwErr)
                {
                    UINT uFrames = pvcr->Port[iPort].Dev[iDev].uPrerollDuration;
                    UINT uDevFPS = pvcr->Port[iPort].Dev[iDev].uFramesPerSecond;

                    (BYTE)achPacket[3] = (BYTE) 0;   // hours expected at 2.
                    (BYTE)achPacket[4] = (BYTE) 0;
                    (BYTE)achPacket[5] = (BYTE) (uFrames / uDevFPS);
                    (BYTE)achPacket[6] = (BYTE) (uFrames % uDevFPS); 
                }
                dwErr = viscaDataToMciTimeFormat(iInst, TRUE, achPacket + 2, &(lpStatus->dwReturn));

                if(!dwErr || (dwErr == MCI_COLONIZED3_RETURN) || (dwErr == MCI_COLONIZED4_RETURN))
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, dwErr));
                else
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));
            }

            case MCI_VCR_STATUS_PAUSE_TIMEOUT:
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_UNSUPPORTED_FUNCTION));

        }
    }

    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_MISSING_PARAMETER));
}

/****************************************************************************
 * Function: DWORD viscaMciSet - Set various settings.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_VCR_SET_PARMS lpSet - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_SET
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciSet(int iInst, DWORD dwFlags, LPMCI_VCR_SET_PARMS lpSet)
{
    BYTE    achPacket[MAXPACKETLENGTH];
    UINT    iDev    = pinst[iInst].iDev;
    UINT    iPort   = pinst[iInst].iPort;
    DWORD   dwErr;

    if (dwFlags & MCI_SET_TIME_FORMAT)
    {
        if( (lpSet->dwTimeFormat >= MCI_FORMAT_MILLISECONDS) &&
            (lpSet->dwTimeFormat <= MCI_FORMAT_TMSF) &&
            (lpSet->dwTimeFormat != MCI_FORMAT_BYTES))
        {
            //
            // First convert DEVICETAPLELENGTH to new time format.
            // We do this by first converting DEVICETAPLENGTH from
            // the current MCI time format to a ViSCA HMSF structure,
            // and then converting back to the new MCI time format.
            //
            if(dwFlags & MCI_TEST)
                return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

            if (pvcr->Port[iPort].Dev[iDev].dwTapeLength != NO_LENGTH)
            {
                BYTE    achData[5];

                viscaMciTimeFormatToViscaData(iInst, TRUE,
                    pvcr->Port[iPort].Dev[iDev].dwTapeLength,
                    achData, VISCADATAHMSF);

                pinst[iInst].dwTimeFormat = lpSet->dwTimeFormat;

                viscaDataToMciTimeFormat(iInst, TRUE, achData, 
                    &(pvcr->Port[iPort].Dev[iDev].dwTapeLength));
            }
            else
            {
                pinst[iInst].dwTimeFormat = lpSet->dwTimeFormat;
            }
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
        }
        else
        {
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_BAD_TIME_FORMAT));
        }
        
    }

    if (dwFlags & MCI_SET_DOOR_OPEN)
    {
        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        dwErr = viscaDoImmediateCommand(iInst, (BYTE) (iDev + 1),
                    achPacket,
                    viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1EJECT));

        pvcr->Port[iPort].Dev[iDev].fTimecodeChecked = FALSE;
        
        
        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
    }

    if (dwFlags & MCI_SET_DOOR_CLOSED)
        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_UNSUPPORTED_FUNCTION));

    if (dwFlags & MCI_SET_AUDIO)  // Why not vector this to setvideo? easy.
        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_UNSUPPORTED_FUNCTION));

    if (dwFlags & MCI_SET_VIDEO) 
        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_UNSUPPORTED_FUNCTION));

    if (dwFlags & MCI_VCR_SET_TRACKING)
        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_UNRECOGNIZED_KEYWORD));

    if(dwFlags & MCI_VCR_SET_COUNTER_FORMAT)
    {
        if( (lpSet->dwCounterFormat >= MCI_FORMAT_MILLISECONDS) &&
            (lpSet->dwCounterFormat <= MCI_FORMAT_TMSF) &&
            (lpSet->dwCounterFormat != MCI_FORMAT_BYTES))
            pinst[iInst].dwCounterFormat = lpSet->dwCounterFormat;
        else
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_BAD_TIME_FORMAT));

        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
    }

    if (dwFlags & MCI_VCR_SET_TIME_MODE)
    {
        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        switch(lpSet->dwTimeMode)
        {
            case MCI_VCR_TIME_DETECT:
                pvcr->Port[iPort].Dev[iDev].uTimeMode = MCI_VCR_TIME_DETECT;
                pvcr->Port[iPort].Dev[iDev].fTimecodeChecked= TC_UNKNOWN;
                // This guy may be first, do not pause unless necessary 
                viscaTimecodeCheckAndSet(iInst);
                break;

            case MCI_VCR_TIME_TIMECODE:
                pvcr->Port[iPort].Dev[iDev].uTimeMode = MCI_VCR_TIME_TIMECODE;
                viscaSetTimeType(iInst, VISCAABSOLUTECOUNTER);
                break;

            case MCI_VCR_TIME_COUNTER:
                // No need to check this 
                pvcr->Port[iPort].Dev[iDev].uTimeMode = MCI_VCR_TIME_COUNTER;
                viscaSetTimeType(iInst, VISCARELATIVECOUNTER);
                break;
        }
        //
        // Return success 
        //
        pvcr->Port[iPort].Dev[iDev].fTimecodeChecked = FALSE;

        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
    }

    if (dwFlags & MCI_VCR_SET_RECORD_FORMAT)
    {
        BYTE    bSpeed;

        switch (lpSet->dwRecordFormat)
        {
            case MCI_VCR_FORMAT_SP:
                bSpeed = VISCASPEEDSP;
                break;
            case MCI_VCR_FORMAT_LP:
                bSpeed = VISCASPEEDLP;
                break;
            case MCI_VCR_FORMAT_EP:
                bSpeed = VISCASPEEDEP;
                break;
            default:
                return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, MCIERR_BAD_CONSTANT));
        }

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1),
                    achPacket,
                    viscaMessageMD_RecSpeed(achPacket + 1, bSpeed));

        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
            (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));

    }

    if (dwFlags & MCI_VCR_SET_INDEX) 
    {
        //
        // Set page to the currently device selected index 
        //
        BYTE    bPageNo;
        BYTE    fResetQueue = FALSE;
        //
        // We can safely ignore this on CI-1000? or not? 
        //
        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        if( (lpSet->dwIndex >= MCI_VCR_INDEX_TIMECODE) &&
            (lpSet->dwIndex <= MCI_VCR_INDEX_TIME))
        {

            if(viscaDelayedCommand(iInst) == VISCA_SEEK)
            {
                viscaQueueReset(iInst, MCI_PAUSE, MCI_NOTIFY_ABORTED);
                fResetQueue = TRUE;

                // If mode is seeking, then pause the thing.
                dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                            achPacket,
                            viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1STILL));
            }

            // These must  be in order
            bPageNo = (BYTE) (lpSet->dwIndex - MCI_VCR_INDEX_TIMECODE + 1);

            dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_OSD(achPacket + 1, bPageNo));

            if(fResetQueue)
                viscaReleaseAutoParms(iPort, iDev);

        }
        else
        {
            dwErr = MCIERR_UNRECOGNIZED_KEYWORD;
        }

        if(!dwErr)
            pvcr->Port[iPort].Dev[iDev].uIndexFormat = (UINT) lpSet->dwIndex;

        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
    }

    if (dwFlags & MCI_VCR_SET_POWER)
    {
        UINT    cb;

        if (dwFlags & MCI_SET_ON)
        {
            if (dwFlags & MCI_SET_OFF)
                return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));

            if(dwFlags & MCI_TEST)
                return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));


            cb = viscaMessageMD_Power(achPacket + 1, VISCAPOWERON);
        }
        else if (dwFlags & MCI_SET_OFF)
        {
            if(dwFlags & MCI_TEST)
                return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

            cb = viscaMessageMD_Power(achPacket + 1, VISCAPOWEROFF);
        }
        else
        {
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_MISSING_PARAMETER));
        }

        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1), achPacket, cb);

        pvcr->Port[iPort].Dev[iDev].fTimecodeChecked = FALSE;

        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
    }

    if(dwFlags & MCI_VCR_SET_ASSEMBLE_RECORD)
    {
        if (dwFlags & MCI_SET_ON)
        {
            if (dwFlags & MCI_SET_OFF)
                return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));

            if(dwFlags & MCI_TEST)
                return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

            pvcr->Port[iPort].Dev[iDev].bVideoDesired   = 0x01; // on
            pvcr->Port[iPort].Dev[iDev].bTimecodeDesired= 0x01;
            pvcr->Port[iPort].Dev[iDev].bAudioDesired   = 0x03;

            dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_RecTrack(achPacket + 1,
                                            VISCARECORDMODEASSEMBLE,
                                            pvcr->Port[iPort].Dev[iDev].bVideoDesired,   
                                            pvcr->Port[iPort].Dev[iDev].bTimecodeDesired,
                                            pvcr->Port[iPort].Dev[iDev].bAudioDesired));
        }
        else if (dwFlags & MCI_SET_OFF)
        {
            if(dwFlags & MCI_TEST)
                return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

            //
            // This does nothing! You must select tracks to set off.
            // This just resets the desire the tracks to all desired on.
            //
            pvcr->Port[iPort].Dev[iDev].bVideoDesired   = 0x01; // on
            pvcr->Port[iPort].Dev[iDev].bTimecodeDesired= 0x01;
            pvcr->Port[iPort].Dev[iDev].bAudioDesired   = 0x03;

            dwErr = MCIERR_NO_ERROR;

        }
        else
        {
            dwErr = MCIERR_MISSING_PARAMETER;
        }

        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
            (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
    }

    if(dwFlags & MCI_VCR_SET_PREROLL_DURATION)
    {
        char    achPreroll[5];
        BYTE    bDataFormat;

        // This is the CI-1000 kludge, it may be relative but, timecode... 
        if(pvcr->Port[iPort].Dev[iDev].bTimeType == VISCAABSOLUTECOUNTER)
            bDataFormat = VISCADATATIMECODENDF;
        else
            bDataFormat = pvcr->Port[iPort].Dev[iDev].bRelativeType;

        // TRUE means we must use timecode for this command. 
        dwErr = viscaMciTimeFormatToViscaData(iInst, TRUE, lpSet->dwPrerollDuration, achPreroll, bDataFormat);

        if(dwErr)
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, dwErr));
    
        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1),
                    achPacket,
                    viscaMessageMD_SegPreRollDuration(achPacket, achPreroll));

        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
            (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
    }

    if(dwFlags & MCI_VCR_SET_POSTROLL_DURATION)
    {
        BYTE    achPacket[MAXPACKETLENGTH];
        char    achPostroll[5];
        BYTE    bDataFormat;

        // This is the CI-1000 kludge, it may be relative but, timecode... 
        if(pvcr->Port[iPort].Dev[iDev].bTimeType == VISCAABSOLUTECOUNTER)
            bDataFormat = VISCADATATIMECODENDF;
        else
            bDataFormat = pvcr->Port[iPort].Dev[iDev].bRelativeType;

        // TRUE means we must use timecode for this command. 
        dwErr = viscaMciTimeFormatToViscaData(iInst, TRUE, lpSet->dwPostrollDuration, achPostroll, bDataFormat);

        if(dwErr)
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, dwErr));
 
    
        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1),
                    achPacket,
                    viscaMessageMD_SegPostRollDuration(achPacket, achPostroll));

        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
    }

    if(dwFlags & MCI_VCR_SET_PAUSE_TIMEOUT)
    {
        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_UNSUPPORTED_FUNCTION));
    }

    if(dwFlags & MCI_VCR_SET_TAPE_LENGTH)
    {
        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        pvcr->Port[iPort].Dev[iDev].dwTapeLength = lpSet->dwLength;
        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
    }

    if(dwFlags & MCI_VCR_SET_CLOCK)
    {
        BYTE    achPacket[MAXPACKETLENGTH];
        BYTE    bHours;
        BYTE    bMinutes;
        BYTE    bSeconds;
        UINT    uTicks;
        UINT    uTicksPerSecond = pvcr->Port[iPort].Dev[iDev].uTicksPerSecond;
        //
        // This assumes 300 ticks per second for now, should read at startup 
        //
        viscaMciClockFormatToViscaData(lpSet->dwClock, uTicksPerSecond,
            (BYTE FAR *)&bHours, (BYTE FAR *)&bMinutes, (BYTE FAR *)&bSeconds, (UINT FAR *)&uTicks);

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        // Try to set time (then we must dump the serial line) 
        dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                    achPacket,                    
                    viscaMessageIF_ClockSet(achPacket + 1,
                    bHours,
                    bMinutes,
                    bSeconds,
                    uTicks,
                    (BYTE)0, (BYTE)0, (BYTE)0, (UINT)0));

        if(dwErr == MCIERR_NO_ERROR)
        {
#ifdef _WIN32
            viscaTaskDo(iInst, TASKPUNCHCLOCK, iPort + 1,  iDev);
#else
            DWORD dwWaitTime = 2L; //Must be at least 1 millisecond.
            DWORD dwStart;
            DWORD dwTime;

            EscapeCommFunction(iPort, CLRDTR);
            //
            // The time must be at least 1 millisecond 
            //
            dwStart = GetTickCount();
            while(1)                 
            {
                dwTime = GetTickCount();
                if(MShortWait(dwStart, dwTime, dwWaitTime))
                    break;
                Yield();
            }
            EscapeCommFunction(iPort, SETDTR);
#endif
        }

        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
    }

    if(dwFlags & MCI_VCR_SET_COUNTER_VALUE)
    {
        //
        // You may only RESET THIS COUNTER!! 
        //
        if (lpSet->dwCounter == 0L)
        {
            BOOL fResetQueue = FALSE;
            //
            // Time value will be in current time format
            //
            if(dwFlags & MCI_TEST)
                return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

            if(viscaDelayedCommand(iInst) == VISCA_SEEK)
            {
                viscaQueueReset(iInst, MCI_PAUSE, MCI_NOTIFY_ABORTED);
                fResetQueue = TRUE;

                // If mode is seeking, then pause the thing.
                dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                            achPacket,
                            viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1STILL));
            }

            dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_Subcontrol(achPacket + 1, VISCACOUNTERRESET));

            if(fResetQueue)
                viscaReleaseAutoParms(iPort, iDev);

            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                    (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
        }
        else
        {
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_UNSUPPORTED_FUNCTION));
        }
    }

    if(dwFlags & MCI_VCR_SET_SPEED)
    {
        UINT uCmd;

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
        //
        // Set the new speed value, cannot change direction! 
        //
        pvcr->Port[iPort].Dev[iDev].dwPlaySpeed = viscaRoundSpeed(lpSet->dwSpeed, pvcr->Port[iPort].Dev[iDev].fPlayReverse);
        //
        // If the device is playing we must cancel the current command */
        //
        if((uCmd = viscaDelayedCommand(iInst)) && !pvcr->Port[iPort].Dev[iDev].fQueueAbort)
        {
            if((uCmd == VISCA_PLAY) || (uCmd == VISCA_PLAY_TO))
            {
                int     iDevCmd = pvcr->Port[iPort].Dev[iDev].iCmdDone;
                BYTE    bAction;
                BYTE    achPacket[MAXPACKETLENGTH];
                DWORD   dwReply;

                // Need direction!! 
                bAction = viscaMapSpeed(pvcr->Port[iPort].Dev[iDev].dwPlaySpeed, pvcr->Port[iPort].Dev[iDev].fPlayReverse);

                // This command must be immediate, since it does not cancel ongoing transport 
                dwReply = viscaDoImmediateCommand(iInst, (BYTE)(iDev+1),
                                achPacket,
                                viscaMessageMD_Mode1(achPacket + 1, bAction));
            }
        }
        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
    }
}

/****************************************************************************
 * Function: DWORD viscaMciEscape - Escape.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_VCR_ESCAPE_PARMS lpEscape - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_ESCAPE
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciEscape(int iInst, DWORD dwFlags, LPMCI_VCR_ESCAPE_PARMS lpEscape)
{
    return (viscaNotifyReturn(iInst, (HWND) lpEscape->dwCallback, dwFlags,
        MCI_NOTIFY_FAILURE, MCIERR_UNRECOGNIZED_COMMAND));
}


/****************************************************************************
 * Function: DWORD viscaMciList - List.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_VCR_LIST_PARMS lpList - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_LIST
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciList(int iInst, DWORD dwFlags, LPMCI_VCR_LIST_PARMS lpList)
{
    UINT    uSourceFlag     = 0;
    UINT    uModel          = 0;
    UINT    iDev            = pinst[iInst].iDev;
    UINT    iPort           = pinst[iInst].iPort;
    //
    // Do we have one of the three possible sources specified.
    //
    if((dwFlags & MCI_VCR_LIST_VIDEO_SOURCE) && (dwFlags & MCI_VCR_LIST_AUDIO_SOURCE))
        return (viscaNotifyReturn(iInst, (HWND) lpList->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));

    if(!((dwFlags & MCI_VCR_LIST_VIDEO_SOURCE) || (dwFlags & MCI_VCR_LIST_AUDIO_SOURCE)))
        return (viscaNotifyReturn(iInst, (HWND) lpList->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_MISSING_PARAMETER));

    if((dwFlags & MCI_VCR_LIST_NUMBER) && (dwFlags & MCI_VCR_LIST_COUNT))
        return (viscaNotifyReturn(iInst, (HWND) lpList->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));


    if(!((dwFlags & MCI_VCR_LIST_NUMBER) || (dwFlags & MCI_VCR_LIST_COUNT)))
        return (viscaNotifyReturn(iInst, (HWND) lpList->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_MISSING_PARAMETER));

    if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpList->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

    // Parameter checking is done, now continue.

    if(dwFlags & MCI_VCR_LIST_VIDEO_SOURCE)
        uSourceFlag = VCR_INPUT_VIDEO;
    else
        uSourceFlag = VCR_INPUT_AUDIO;
    //
    // Inputs should be read from the ini file, because they cannot be
    // determined from the hardware.
    //
    if(dwFlags & MCI_VCR_LIST_COUNT)
    {
       if(pvcr->Port[iPort].Dev[iDev].rgInput[uSourceFlag].uNumInputs == -1)
       {
           // Unable to determine the number! So return 0, ? 
           lpList->dwReturn = 0L;
       }
       else
       {
           lpList->dwReturn = pvcr->Port[iPort].Dev[iDev].rgInput[uSourceFlag].uNumInputs;
       }
       return (viscaNotifyReturn(iInst, (HWND) lpList->dwCallback, dwFlags,
                   MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
    }
    else if(dwFlags & MCI_VCR_LIST_NUMBER)
    {
        // Return the type of the input, any number is greater than -1! so it works 
        if( ((UINT)lpList->dwNumber == 0) ||
            ((UINT)lpList->dwNumber > (UINT)pvcr->Port[iPort].Dev[iDev].rgInput[uSourceFlag].uNumInputs))
        {
           DPF(DBG_MCI, "\nBad input number has been specified.=%d", (UINT)lpList->dwNumber);
           return (viscaNotifyReturn(iInst, (HWND) lpList->dwCallback, dwFlags,
                       MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));
        }
        else
        {
           lpList->dwReturn = MAKEMCIRESOURCE(
               pvcr->Port[iPort].Dev[iDev].rgInput[uSourceFlag].uInputType[(UINT)lpList->dwNumber-1],
               pvcr->Port[iPort].Dev[iDev].rgInput[uSourceFlag].uInputType[(UINT)lpList->dwNumber-1]);

           return (viscaNotifyReturn(iInst, (HWND) lpList->dwCallback, dwFlags,
                       MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));
        }
    }

    return (viscaNotifyReturn(iInst, (HWND) lpList->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_UNSUPPORTED_FUNCTION));
}


/****************************************************************************
 * Function: DWORD viscaMciMark - Write or erase a mark.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_GENERIC_PARMS lpGeneric - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_MARK
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciMark(int iInst, DWORD dwFlags, LPMCI_GENERIC_PARMS lpGeneric)
{
    BYTE    achPacket[MAXPACKETLENGTH];
    DWORD   dwErr;
    UINT    iDev            = pinst[iInst].iDev;
    UINT    iPort           = pinst[iInst].iPort;
    BOOL    fResetQueue     = FALSE;

    if (dwFlags & MCI_VCR_MARK_WRITE)
    {
        if (dwFlags & MCI_VCR_MARK_ERASE)
            return (viscaNotifyReturn(iInst, (HWND) lpGeneric->dwCallback, dwFlags,
                        MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpGeneric->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        if(viscaDelayedCommand(iInst) == VISCA_SEEK)
        {
            fResetQueue = TRUE;
            viscaQueueReset(iInst, MCI_PAUSE, MCI_NOTIFY_ABORTED);

            // If mode is seeking, then pause the thing.
            dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1STILL));
        }

        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1),
                    achPacket,
                    viscaMessageMD_Mode2(achPacket + 1, VISCAMODE2INDEXMARK));
    
    }
    else if (dwFlags & MCI_VCR_MARK_ERASE)
    {
        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpGeneric->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        if(viscaDelayedCommand(iInst) == VISCA_SEEK)
        {
            viscaQueueReset(iInst, MCI_PAUSE, MCI_NOTIFY_ABORTED);
            fResetQueue = TRUE;

            // If mode is seeking, then pause the thing.
            dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1STILL));
        }

        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1),
                    achPacket,
                    viscaMessageMD_Mode2(achPacket + 1, VISCAMODE2INDEXERASE));
    }
    else
    {
        return (viscaNotifyReturn(iInst, (HWND) lpGeneric->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_MISSING_PARAMETER));
    }

    if(fResetQueue)
        viscaReleaseAutoParms(iPort, iDev);

    if(dwErr == MCIERR_VCR_CONDITION)
        dwErr = MCIERR_VCR_ISWRITEPROTECTED;

    return (viscaNotifyReturn(iInst, (HWND) lpGeneric->dwCallback, dwFlags,
            (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
}

/*
 * Check if the input is in range.
 */
static BOOL NEAR PASCAL
viscaInputCheck(int iInst, UINT uSource, UINT uRelType, UINT uRelNumber)
{
    UINT    iDev      = pinst[iInst].iDev;
    UINT     iPort    = pinst[iInst].iPort;
    //
    // If the inputs of video or audio are specified, then make sure
    // the range is good.  Otherwise just assume range is ok.
    //
    if(pvcr->Port[iPort].Dev[iDev].rgInput[uSource].uNumInputs != -1)
    {
        int  i;
        UINT uTempRelNumber = 0;
        //
        // Make sure there is a Numberth of that type.
        //
        for(i = 0; i  < pvcr->Port[iPort].Dev[iDev].rgInput[uSource].uNumInputs; i++)
        {
            if(pvcr->Port[iPort].Dev[iDev].rgInput[uSource].uInputType[i] == uRelType)
                uTempRelNumber++;
        }
        //
        // Are there any inputs of that type, or was one given larger then
        // the total number of inputs of that type.
        //
        if((uTempRelNumber == 0) || (uRelNumber > uTempRelNumber))
            return FALSE;
    }
    return TRUE; // Sorry, no check 
}


/****************************************************************************
 * Function: DWORD viscaMciSetAudio - Set audio settings.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_VCR_SETAUDIO_PARMS lpSetAudio - Pointer to MCI parameter
 *                                  block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_SETAUDIO
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciSetAudio(int iInst, DWORD dwFlags, LPMCI_VCR_SETAUDIO_PARMS lpSetAudio)
{
    BYTE    achPacket[MAXPACKETLENGTH];
    UINT    iDev     = pinst[iInst].iDev;
    UINT    iPort    = pinst[iInst].iPort;
    DWORD   dwErr;
    UINT    uInputType;
    UINT    uInputNumber;
    BYTE    bAudioTrack;
    BYTE    bTrack = 0x00;
    BYTE    fResetQueue = FALSE;

    if (dwFlags & MCI_VCR_SETAUDIO_SOURCE)
    {
        //
        // We must have a type with this command, absolute is not possible.
        //
        if(!(dwFlags & MCI_VCR_SETAUDIO_TO))
            return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_MISSING_PARAMETER));
        //
        // Make sure that the output flag is not specified.
        //
        if((UINT)lpSetAudio->dwTo == MCI_VCR_SRC_TYPE_OUTPUT)
            return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));
        //
        // Get the type and the number.
        //
        if(dwFlags & MCI_VCR_SETAUDIO_NUMBER)
        {
            // Check if there is a n'th input of type to.
            uInputType      = (UINT) lpSetAudio->dwTo;
            uInputNumber    = (UINT) lpSetAudio->dwNumber;
        }
        else 
        {
            uInputType      = (UINT) lpSetAudio->dwTo;
            uInputNumber    = (UINT) 1;
        }
        //
        // If it is one of the recognized Sony's check its input table.
        //
        if(!viscaInputCheck(iInst, VCR_INPUT_AUDIO,    uInputType, uInputNumber))
            return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, MCIERR_BAD_CONSTANT));

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
        //
        // Get the base for that type.
        //
        switch(uInputType)
        {
            case MCI_VCR_SRC_TYPE_LINE:
                uInputType = VISCALINE;
                break;
            case MCI_VCR_SRC_TYPE_TUNER:
                uInputType = 0x00; // tuner #1 gets added so it is 01 
                break;
            case MCI_VCR_SRC_TYPE_SVIDEO:
                uInputType = VISCASVIDEOLINE;
                break;
            case MCI_VCR_SRC_TYPE_AUX:
                uInputType = VISCAAUX;
                break;

            case MCI_VCR_SRC_TYPE_MUTE:
                uInputType =   VISCAMUTE;
                uInputNumber = 0x00;
                break;

        }
        //
        // Set to the correct number of the relative type.
        //
        uInputType = uInputType + uInputNumber;
        
        // Read settings so we don't overwrite current video.
        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_InputSelectInq(achPacket + 1));

        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_InputSelect(achPacket + 1,
                            (BYTE)achPacket[2], /* the old video */
                            (BYTE)uInputType));

    }
    else if (dwFlags & MCI_VCR_SETAUDIO_MONITOR)
    {
        if(lpSetAudio->dwTo == MCI_VCR_SRC_TYPE_OUTPUT)
        {
            if(dwFlags & MCI_TEST)
                return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));


            return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags,
                    MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
        }

        dwErr = MCIERR_UNSUPPORTED_FUNCTION;
    }

    else if (dwFlags & MCI_VCR_SETAUDIO_RECORD)
    {
        if((dwFlags & MCI_SET_ON) && (dwFlags & MCI_SET_OFF))
             return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags,
                     MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));

        if(dwFlags & MCI_TRACK)
        {
            if((lpSetAudio->dwTrack==0) || ((UINT)lpSetAudio->dwTrack > 2))
                return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));
        }
        else
        {
            lpSetAudio->dwTrack = 1;
        }

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        if(!(dwFlags & MCI_SET_OFF))
            dwFlags |= MCI_SET_ON;

        bTrack = pvcr->Port[iPort].Dev[iDev].bAudioDesired;

        if (dwFlags & MCI_SET_ON)
        {
            if(lpSetAudio->dwTrack==2)
                bTrack |= VISCATRACK2;
            else
                bTrack |= VISCATRACK1;
        }
        else
        {
            if(lpSetAudio->dwTrack==2)
                bTrack &= (BYTE) ~VISCATRACK2;
            else
                bTrack &= (BYTE) ~VISCATRACK1;
        }

        dwErr = viscaDoImmediateCommand(iInst, (BYTE)(pinst[iInst].iDev + 1),
                    achPacket,
                    viscaMessageMD_RecTrack(achPacket + 1,
                                            VISCARECORDMODEINSERT,
                                            pvcr->Port[iPort].Dev[iDev].bVideoDesired,      // video
                                            pvcr->Port[iPort].Dev[iDev].bTimecodeDesired,   // data
                                            bTrack)); // audio

        // Why doesn't EVO-9650 return 4A like good visca devices do?
        if( (dwErr == MCIERR_UNSUPPORTED_FUNCTION) ||
            (dwErr == MCIERR_VCR_REGISTER))
        {
            dwErr = MCIERR_VCR_TRACK_FAILURE;
            pvcr->Port[iPort].Dev[iDev].bAudioDesired = bTrack;
        }
        else
        {
            pvcr->Port[iPort].Dev[iDev].bAudioDesired = bTrack;
        }
    }
    else
    {
        // Set playback tracks.

        if((dwFlags & MCI_SET_ON) && (dwFlags & MCI_SET_OFF))
             return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags,
                     MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));

        if(dwFlags & MCI_TRACK)
        {
            if((lpSetAudio->dwTrack==0) || ((UINT)lpSetAudio->dwTrack > 2))
                return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));
        }
        else
        {
            lpSetAudio->dwTrack = 1;
        }


        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        if(viscaDelayedCommand(iInst) == VISCA_SEEK)
        {
            viscaQueueReset(iInst, MCI_PAUSE, MCI_NOTIFY_ABORTED);
            fResetQueue = TRUE;

            // If mode is seeking, then pause the thing.
            dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1STILL));
        }


        //
        // Get current playback track register values so that we can leave those we're not interested in unchanged.
        //
        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                    achPacket,
                    viscaMessageMD_PBTrackInq(achPacket + 1));

        if(fResetQueue)
            viscaReleaseAutoParms(iPort, iDev);

        if (dwErr)
            return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, dwErr));

        if(!(dwFlags & MCI_SET_OFF))
            dwFlags |= MCI_SET_ON;


        if (dwFlags & MCI_SET_ON)
        {
            if(lpSetAudio->dwTrack==2)
                bTrack |= VISCATRACK2;
            else
                bTrack |= VISCATRACK1;

            bAudioTrack = achPacket[4] | bTrack;
        }
        else
        {
            if(lpSetAudio->dwTrack==2)
                bTrack = (BYTE) ~VISCATRACK2;
            else
                bTrack = (BYTE) ~VISCATRACK1;

            bAudioTrack = achPacket[4] &= bTrack;
        }
        //
        // Now set record track register values with new bAudioTrack value.
        //
        dwErr = viscaDoImmediateCommand(iInst, (BYTE)(pinst[iInst].iDev + 1),
                    achPacket,
                    viscaMessageMD_PBTrack(achPacket + 1,
                                            achPacket[2],
                                            achPacket[3],
                                            bAudioTrack));

    }

    return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags,
        (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
}


/****************************************************************************
 * Function: DWORD viscaMciSetVideo - Set video settings.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_VCR_SETVIDEO_PARMS lpSetVideo - Pointer to MCI parameter
 *                                  block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_SETVIDEO
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciSetVideo(int iInst, DWORD dwFlags, LPMCI_VCR_SETVIDEO_PARMS lpSetVideo)
{
    BYTE    achPacket[MAXPACKETLENGTH];
    UINT    iDev        = pinst[iInst].iDev;
    UINT    iPort       = pinst[iInst].iPort;
    BYTE    bVideoTrack = 0x00;
    DWORD   dwErr;
    UINT    uInputType;
    UINT    uInputNumber;
    BYTE    bTrack = 0x00;
    BYTE    fResetQueue = FALSE;

    if (dwFlags & MCI_VCR_SETVIDEO_SOURCE)
    {
        //
        // We must have a type with this command, absolute is not possible.
        //
        if(!(dwFlags & MCI_VCR_SETVIDEO_TO))
            return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_MISSING_PARAMETER));
        //
        // Make sure that the output flag is not specified.
        //
        if((UINT)lpSetVideo->dwTo == MCI_VCR_SRC_TYPE_OUTPUT)
            return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));
        //
        // Get the type and the number.
        //
        if(dwFlags & MCI_VCR_SETVIDEO_NUMBER)
        {
            // Check if there is a n'th input of type to.
            uInputType      = (UINT) lpSetVideo->dwTo;
            uInputNumber    = (UINT) lpSetVideo->dwNumber;
        }
        else 
        {
            uInputType      = (UINT) lpSetVideo->dwTo;
            uInputNumber    = (UINT) 1;
        }
        //
        // If it is one of the recognized Sony's check its input table.
        //
        if(!viscaInputCheck(iInst, VCR_INPUT_VIDEO,    uInputType, uInputNumber))
        {
            DPF(DBG_MCI, "\nFailed input check.");;
            return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_BAD_CONSTANT));
        }

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
        //
        // Get the base for that type.
        //
        switch(uInputType)
        {
            case MCI_VCR_SRC_TYPE_LINE:
                uInputType = VISCALINE;
                break;
            case MCI_VCR_SRC_TYPE_TUNER:
                uInputType = 0x00; // tuner #1 gets added so it is 01 
                break;
            case MCI_VCR_SRC_TYPE_SVIDEO:
                uInputType = VISCASVIDEOLINE;
                break;
            case MCI_VCR_SRC_TYPE_AUX:
                uInputType = VISCAAUX;
                break;

            case MCI_VCR_SRC_TYPE_MUTE:
                uInputType   = VISCAMUTE;
                uInputNumber = 0x00;
                break;
        }
        //
        // Set to the correct number of the releative type.
        //
        uInputType = uInputType + uInputNumber;
        //
        // Read audio setting, so we don't destroy it.
        //
        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_InputSelectInq(achPacket + 1));

        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_InputSelect(achPacket + 1,
                                        (BYTE) uInputType,
                                        achPacket[3]));

    }
    else if (dwFlags & MCI_VCR_SETVIDEO_MONITOR)
    {
        if(lpSetVideo->dwTo == MCI_VCR_SRC_TYPE_OUTPUT)
        {
            if(dwFlags & MCI_TEST)
                return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

            return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags,
                MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
        }

        dwErr = MCIERR_UNSUPPORTED_FUNCTION;
    }
    else if (dwFlags & MCI_VCR_SETVIDEO_RECORD)
    {
        if((dwFlags & MCI_SET_ON) && (dwFlags & MCI_SET_OFF))
             return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags,
                     MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));

        if(dwFlags & MCI_TRACK)
        {
            if(lpSetVideo->dwTrack != 1)
                return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));
        }
        else
        {
            lpSetVideo->dwTrack = 1;
        }

        if(!(dwFlags & MCI_SET_OFF))
            dwFlags |= MCI_SET_ON;

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        bTrack = pvcr->Port[iPort].Dev[iDev].bVideoDesired;

        if (dwFlags & MCI_SET_ON)
            bTrack |= VISCATRACK1;
        else
            bTrack &= (BYTE) ~VISCATRACK1;


        dwErr = viscaDoImmediateCommand(iInst, (BYTE)(pinst[iInst].iDev + 1),
                    achPacket,
                    viscaMessageMD_RecTrack(achPacket + 1,
                                            VISCARECORDMODEINSERT,
                                            bTrack,
                                            pvcr->Port[iPort].Dev[iDev].bTimecodeDesired,   // data
                                            pvcr->Port[iPort].Dev[iDev].bAudioDesired));     // audio

        // if it was register remember what we wanted to do.
        if( (dwErr == MCIERR_UNSUPPORTED_FUNCTION) ||
            (dwErr == MCIERR_VCR_REGISTER))
        {
            pvcr->Port[iPort].Dev[iDev].bVideoDesired = bTrack;
            dwErr = MCIERR_VCR_TRACK_FAILURE;
        }
        else
        {
            pvcr->Port[iPort].Dev[iDev].bVideoDesired = bTrack;
        }

    }
    else
    {
        // Set playback option.

        if((dwFlags & MCI_SET_ON) && (dwFlags & MCI_SET_OFF))
             return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags,
                     MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));

        if(dwFlags & MCI_TRACK)
        {
            if(lpSetVideo->dwTrack != 1)
                return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));
        }
        else
        {
            lpSetVideo->dwTrack = 1;
        }

        if(!(dwFlags & MCI_SET_OFF))
            dwFlags |= MCI_SET_ON;

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        if (dwFlags & MCI_SET_ON)
            bVideoTrack |= VISCATRACK1;
        else
            bVideoTrack &= (BYTE) ~VISCATRACK1;

        if(viscaDelayedCommand(iInst) == VISCA_SEEK)
        {
            viscaQueueReset(iInst, MCI_PAUSE, MCI_NOTIFY_ABORTED);
            fResetQueue = TRUE;

            // If mode is seeking, then pause the thing.
            dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1STILL));
        }

        //
        // Get current record track register values so that we
        // can leave those we're not interested in unchanged.
        //
        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_PBTrackInq(achPacket + 1));

        if(fResetQueue)
            viscaReleaseAutoParms(iPort, iDev);


        if (dwErr)
            return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, dwErr));
        //
        // If current setting is equal to new setting, then don't
        // bother doing anything.
        //
        if (bVideoTrack == (BYTE)achPacket[2])
        {
            return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags,
                MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
        }
        //
        // Now set playback track register values with new bVideoTrack value.
        //
        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_PBTrack(achPacket + 1,
                                            bVideoTrack,
                                            achPacket[3],
                                            achPacket[4]));

        // If register failure record the track selection.
    }

    return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags,
        (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));

}

/****************************************************************************
 * Function: DWORD viscaMciSetTuner - Set video settings.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_VCR_SETTUNER_PARMS lpSetTuner - Pointer to MCI parameter
 *                                  block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_SETTUNER
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciSetTuner(int iInst, DWORD dwFlags, LPMCI_VCR_SETTUNER_PARMS lpSetTuner)
{
    BYTE    achPacket[MAXPACKETLENGTH];
    UINT    iDev    = pinst[iInst].iDev;
    UINT    iPort   = pinst[iInst].iPort;
    UINT    uNumber = 1;                // 1 is the default tuner. 

    if(dwFlags & MCI_VCR_SETTUNER_NUMBER)
    {
        uNumber = (UINT) lpSetTuner->dwNumber;
    }

    if (dwFlags & MCI_VCR_SETTUNER_CHANNEL)
    {
        DWORD dwErr;

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSetTuner->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                    achPacket, 
                    viscaMessageMD_Channel(achPacket + 1, (UINT)(lpSetTuner->dwChannel)));

        
        return (viscaNotifyReturn(iInst, (HWND) lpSetTuner->dwCallback, dwFlags,
                (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
    }

    if ((dwFlags & MCI_VCR_SETTUNER_CHANNEL_UP) || (dwFlags & MCI_VCR_SETTUNER_CHANNEL_DOWN))
    {
        UINT    uChannel;
        DWORD   dwErr;

        if ((dwFlags & MCI_VCR_SETTUNER_CHANNEL_UP) && (dwFlags & MCI_VCR_SETTUNER_CHANNEL_DOWN))
            return (viscaNotifyReturn(iInst, (HWND) lpSetTuner->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSetTuner->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_ChannelInq(achPacket + 1));

        if (dwErr) 
            return (viscaNotifyReturn(iInst, (HWND) lpSetTuner->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, dwErr));

        uChannel = 100 * (achPacket[2] & 0x0F) +
                    10 * (achPacket[3] & 0x0F) +
                         (achPacket[4] & 0x0F);

        if (dwFlags & MCI_VCR_SETTUNER_CHANNEL_UP)
            uChannel = (uChannel + 1) % 1000;
        else
            uChannel = (uChannel + 999) % 1000; // go one down

        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_Channel(achPacket + 1, uChannel));

        return (viscaNotifyReturn(iInst, (HWND) lpSetTuner->dwCallback, dwFlags,
                (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));

    }

    if (dwFlags & MCI_VCR_SETTUNER_CHANNEL_SEEK_UP)
        return (viscaNotifyReturn(iInst, (HWND) lpSetTuner->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_UNRECOGNIZED_KEYWORD));

    if (dwFlags & MCI_VCR_SETTUNER_CHANNEL_SEEK_DOWN) 
        return (viscaNotifyReturn(iInst, (HWND) lpSetTuner->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_UNRECOGNIZED_KEYWORD));
}

/****************************************************************************
 * Function: DWORD viscaMciSetTimecode - Set video settings.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_VCR_SETTIMECODE_PARMS lpSetTimecode - Pointer to MCI parameter
 *                                  block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_SETTUNER
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciSetTimecode(int iInst, DWORD dwFlags, LPMCI_GENERIC_PARMS lpSetTimecode)
{
    BYTE    achPacket[MAXPACKETLENGTH];
    BYTE    bTrack  = 0x00; 
    UINT    iDev    = pinst[iInst].iDev;
    UINT    iPort   = pinst[iInst].iPort;
    DWORD   dwErr;

    if (dwFlags & MCI_VCR_SETTIMECODE_RECORD)
    {
        if((dwFlags & MCI_SET_ON) && (dwFlags & MCI_SET_OFF))
             return (viscaNotifyReturn(iInst, (HWND) lpSetTimecode->dwCallback, dwFlags,
                     MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));

        if(!(dwFlags & MCI_SET_OFF))
            dwFlags |= MCI_SET_ON;

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSetTimecode->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        bTrack = pvcr->Port[iPort].Dev[iDev].bTimecodeDesired;

        if (dwFlags & MCI_SET_ON)
            bTrack |= VISCATRACK1;
        else
            bTrack &= (BYTE) ~VISCATRACK1;


        dwErr = viscaDoImmediateCommand(iInst, (BYTE)(pinst[iInst].iDev + 1),
                    achPacket,
                    viscaMessageMD_RecTrack(achPacket + 1,
                                            VISCARECORDMODEINSERT,
                                            pvcr->Port[iPort].Dev[iDev].bVideoDesired,
                                            bTrack,                                         // data
                                            pvcr->Port[iPort].Dev[iDev].bAudioDesired));     // audio

        // if it was register remember what we wanted to do.
        if((dwErr == MCIERR_UNSUPPORTED_FUNCTION)  ||
            (dwErr == MCIERR_VCR_REGISTER))
        {
            pvcr->Port[iPort].Dev[iDev].bTimecodeDesired = bTrack;
            dwErr = MCIERR_VCR_TRACK_FAILURE;
        }
        else
        {
            pvcr->Port[iPort].Dev[iDev].bTimecodeDesired = bTrack;
        }

        return (viscaNotifyReturn(iInst, (HWND) lpSetTimecode->dwCallback, dwFlags,
            (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
    }

}

/****************************************************************************
 * Function: DWORD viscaMciIndex - Index.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_RECORD_PARMS lpPerform - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This command may not work while seeking.
 *       
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciIndex(int iInst, DWORD dwFlags, LPMCI_GENERIC_PARMS lpIndex)
{
    BYTE    achPacket[MAXPACKETLENGTH];
    MCI_VCR_STATUS_PARMS mciStatus;
    UINT    iDev    = pinst[iInst].iDev;
    UINT    iPort   = pinst[iInst].iPort;
    DWORD   dwModeErr;
    DWORD   dwErr;

    if(dwFlags & MCI_TEST)
        return (viscaNotifyReturn(iInst, (HWND) lpIndex->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

    // What command is currently running on this device.
    if(viscaDelayedCommand(iInst) == VISCA_SEEK)
    {
        DPF(DBG_MCI, "Cannot change index when seeking\n");
        return (viscaNotifyReturn(iInst, (HWND) lpIndex->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_NONAPPLICABLE_FUNCTION));
    }

    // We should also do a status mode to see if we opened and it was seeking.
    // Is it still seeking.
    mciStatus.dwItem = MCI_STATUS_MODE;
    dwErr = viscaMciStatus(iInst, MCI_STATUS_ITEM, &mciStatus);
    if(HIWORD(mciStatus.dwReturn) == MCI_MODE_SEEK)
    {
        DPF(DBG_MCI, "Cannot change index when seeking\n");
        return (viscaNotifyReturn(iInst, (HWND) lpIndex->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_NONAPPLICABLE_FUNCTION));
    }

    //
    // If it is off then do nothing 
    //
    dwModeErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                achPacket,
                viscaMessageMD_OSDInq(achPacket + 1));

    if(dwFlags & MCI_SET_OFF)
    {
        if((achPacket[2] != VISCAOSDPAGEOFF) || dwModeErr)
        {
            // now toggle it 
            dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                            achPacket,
                            viscaMessageMD_Subcontrol(achPacket + 1, VISCATOGGLEDISPLAYONOFF));

        }
    }
    else
    {
        // Set page to the currently device selected index 
        BYTE bPageNo;
        //
        // We can safely ignore this on CI-1000? or not? 
        //
        switch(pvcr->Port[iPort].Dev[iDev].uIndexFormat)
        {
            case  MCI_VCR_INDEX_TIMECODE:
                bPageNo = 1;
                break;
            case  MCI_VCR_INDEX_COUNTER:
                bPageNo = 2;
                break;
            case  MCI_VCR_INDEX_DATE   :
                bPageNo = 3;
                break;
            case  MCI_VCR_INDEX_TIME   :
                bPageNo = 4;
                break;
        }
        //
        // Only change if it is not the currently selected page 
        //
        if(((BYTE)achPacket[2] != bPageNo) && !dwModeErr)
        {
            dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_OSD(achPacket + 1, bPageNo));
        }
        //
        // Only toggle if it is not already on 
        //
        if((achPacket[2] == VISCAOSDPAGEOFF) || dwModeErr)
        {
            // now toggle it 
            dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                            achPacket,
                            viscaMessageMD_Subcontrol(achPacket + 1, VISCATOGGLEDISPLAYONOFF));
        }
    }

    return (viscaNotifyReturn(iInst, (HWND) lpIndex->dwCallback, dwFlags,
            (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
}

/****************************************************************************
 * Function: DWORD viscaDoImmediateCommand - Perform a synchronous command (wait for response)
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      BYTE  bDest       - Destination device.
 *
 *      LPSTR lpstrPacket - Packet to send.
 *
 *      UINT  cbMessageLength - Length of the packet.
 *
 *      BOOL  fUseAckTimer - Do we want to use the ack-timeout timer, or just call GetTickCount.
 *
 * Returns: an MCI error code.
 *
 ***************************************************************************/
DWORD FAR PASCAL
viscaDoImmediateCommand(int iInst, BYTE bDest, LPSTR lpstrPacket,  UINT cbMessageLength)
{
    UINT    iPort   = pinst[iInst].iPort;
    UINT    iDev    = pinst[iInst].iDev;

    if (bDest == BROADCASTADDRESS)
        pvcr->Port[iPort].iBroadcastDev = iDev;

    if(!pvcr->Port[iPort].Dev[iDev].fDeviceOk)
        return MCIERR_VCR_CANNOT_WRITE_COMM;

    if(!viscaWrite(iInst, bDest, lpstrPacket, cbMessageLength, NULL, 0L, FALSE))
        return MCIERR_VCR_CANNOT_WRITE_COMM;

    // Wait completion, False==>we are not waiting on queue.
    if(!viscaWaitCompletion(iInst, FALSE, TRUE))
    {
        // Turn of the waiting flag and return
        pvcr->Port[iPort].Dev[iDev].fDeviceOk = FALSE;
        return MCIERR_VCR_READ_TIMEOUT;
    }

    if(pinst[iInst].bReplyFlags & VISCAF_ERROR_TIMEOUT)
    {
        pvcr->Port[iPort].Dev[iDev].fDeviceOk = FALSE;
        return MCIERR_VCR_READ_TIMEOUT;
    }

    // Copy the return packet 
    _fmemcpy(lpstrPacket, pinst[iInst].achPacket, MAXPACKETLENGTH);

    //
    // Compensate for address messages (which don't fit format)
    // by checking for error completions only.
    //
    if(pinst[iInst].bReplyFlags & VISCAF_ERROR)
        return viscaErrorToMCIERR(VISCAREPLYERRORCODE(pinst[iInst].achPacket));
    else
        return MCIERR_NO_ERROR;
}

MCI_GENERIC_PARMS Generic = { 0 };

/****************************************************************************
 * Function: DWORD viscaMciProc - Process MCI commands.
 *
 * Parameters:
 *
 *      WORD wDeviceID - MCI device ID.
 *
 *      WORD wMessage - MCI command.
 *
 *      DWORD dwParam1 - MCI command flags.
 *
 *      DWORD dwParam2 - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called by DriverProc() to process all MCI commands.
 ***************************************************************************/
DWORD FAR PASCAL
viscaMciProc(WORD wDeviceID, WORD wMessage, DWORD dwParam1, DWORD dwParam2)
{
    DWORD           dwRes;
    int             iInst   = (int)mciGetDriverData(wDeviceID);
    UINT            iPort, iDev;
    //
    // Some nice apps send null instead of structure pointers, give our own if this is the case.
    //
    if(!dwParam2)
        dwParam2 = (DWORD)(LPMCI_GENERIC_PARMS) &Generic;

    if (iInst == -1)
        return (MCIERR_INVALID_DEVICE_ID);

    DPF(DBG_MCI, "---->(enter) viscaMciProc: iInst = %d wMessage = %u \n", iInst, wMessage);
    
    iPort = pinst[iInst].iPort;
    iDev  = pinst[iInst].iDev;
    //
    // Set device to ok at the start of every message.
    //
    pvcr->Port[iPort].Dev[iDev].fDeviceOk = TRUE;
    
    switch (wMessage)
    {
        //
        // Required Commands 
        //
        case MCI_CLOSE_DRIVER:
            dwRes = viscaMciCloseDriver(iInst, dwParam1, (LPMCI_GENERIC_PARMS)dwParam2);
            break;

        case MCI_OPEN_DRIVER:
            dwRes = viscaMciOpenDriver(iInst, dwParam1, (LPMCI_OPEN_PARMS)dwParam2);
            break;

        case MCI_GETDEVCAPS:
            dwRes = viscaMciGetDevCaps(iInst, dwParam1, (LPMCI_GETDEVCAPS_PARMS)dwParam2);
            break;

        case MCI_INFO:
            dwRes = viscaMciInfo(iInst, dwParam1, (LPMCI_INFO_PARMS)dwParam2);
            break;

        case MCI_STATUS:
            dwRes = viscaMciStatus(iInst, dwParam1, (LPMCI_VCR_STATUS_PARMS)dwParam2);
            break;
        //
        // Basic Commands 
        //
        case MCI_SET:
            dwRes = viscaMciSet(iInst, dwParam1, (LPMCI_VCR_SET_PARMS)dwParam2);
            break;
        //
        // Extended Commands 
        //
        case MCI_INDEX:
            dwRes = viscaMciIndex(iInst, dwParam1, (LPMCI_GENERIC_PARMS)dwParam2);
            break;

        case MCI_ESCAPE:
            dwRes = viscaMciEscape(iInst, dwParam1, (LPMCI_VCR_ESCAPE_PARMS)dwParam2);
            break;

        case MCI_LIST:
            dwRes = viscaMciList(iInst, dwParam1, (LPMCI_VCR_LIST_PARMS)dwParam2);
            break;

        case MCI_MARK:
            dwRes = viscaMciMark(iInst, dwParam1, (LPMCI_GENERIC_PARMS)dwParam2);
            break;

        case MCI_SETAUDIO:
            dwRes = viscaMciSetAudio(iInst, dwParam1, (LPMCI_VCR_SETAUDIO_PARMS)dwParam2);
            break;

        case MCI_SETVIDEO:
            dwRes = viscaMciSetVideo(iInst, dwParam1, (LPMCI_VCR_SETVIDEO_PARMS)dwParam2);
            break;

        case MCI_SETTUNER:
            dwRes = viscaMciSetTuner(iInst, dwParam1, (LPMCI_VCR_SETTUNER_PARMS)dwParam2);
            break;

        case MCI_SETTIMECODE:
            dwRes = viscaMciSetTimecode(iInst, dwParam1, (LPMCI_GENERIC_PARMS)dwParam2);
            break;

        //
        // Delayed commands; in mcidelay.c 
        //
        case MCI_SIGNAL:
        case MCI_SEEK:
        case MCI_PAUSE:
        case MCI_PLAY:
        case MCI_RECORD:
        case MCI_RESUME:
        case MCI_STOP:
        case MCI_FREEZE:
        case MCI_UNFREEZE:
        case MCI_CUE:
        case MCI_STEP:
            dwRes = viscaMciDelayed(wDeviceID, wMessage, dwParam1, dwParam2);
            break;

        default:
            dwRes = MCIERR_UNRECOGNIZED_COMMAND;
            break;
    }

    DPF(DBG_MCI, "<----(exit) viscaMciProc: iInst = %d wMessage = %u \n", iInst, wMessage);
    return (dwRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mcivisca\mcivisca\commtask.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992-1995 Microsoft Corporation
 * 
 *  COMMTASK.C
 *
 *  MCI ViSCA Device Driver
 *
 *  Description:
 * 
 *      Background task procedures
 *
 ***************************************************************************/

#define  UNICODE
#include <windows.h>
#include <windowsx.h>
#include "appport.h"
#include <mmsystem.h>
#include <mmddk.h>
#include <string.h>
#include "vcr.h"
#include "viscadef.h"
#include "mcivisca.h"
#include "common.h"

//
// Global (not-changing) 
//
CODESEGCHAR szCommNotifyHandlerClassName[]  = TEXT("ViSCACommNotifyHandler");
extern HINSTANCE       hModuleInstance;    // module instance  (different in NT - DLL instances)

//
// Forward references to non-exported functions.
//
long FAR PASCAL TxThread(LPVOID uPort);  
long FAR PASCAL RxThread(LPVOID uPort);

static void NEAR PASCAL viscaAck(int iInst, BOOL FAR *pfTxRelease);
static void NEAR PASCAL viscaSuccessfulCompletion(int iInst, LPSTR lpstrPacket, BOOL FAR *pfTxRelease);
static void NEAR PASCAL viscaErrorCompletion(int iInst, LPSTR lpstrPacket, BOOL FAR *pfTxRelease);

static void NEAR PASCAL viscaAutoAck(UINT iPort, UINT iDev);
static void NEAR PASCAL viscaAutoSuccessfulCompletion(UINT iPort, UINT iDev, LPSTR lpstrPacket, BOOL FAR *pfTxRelease);
static void NEAR PASCAL viscaAutoErrorCompletion(UINT iPort, UINT iDev, LPSTR lpstrPacket, BOOL FAR *pfTxRelease);

static void NEAR PASCAL viscaReleaseAuto(UINT iPort, UINT iDev, DWORD dwNotify);
static BOOL NEAR PASCAL viscaAutoWrite(UINT iPort, UINT iDev, BOOL fBlockable, UINT uAutoBlocked, BOOL FAR *pfTxRelease); 
static BOOL NEAR PASCAL viscaSetCommandComplete(UINT iPort, UINT iDev, UINT uViscaCmd);
static void NEAR PASCAL TaskDoCommand(UINT uTaskState, DWORD lParam);
static void FAR  PASCAL SignalInstance(int iInst, BYTE bReplyFlags);
static void FAR  PASCAL SignalDevice(int iPort, int iDev, BYTE bReplyFlags);

#ifndef _WIN32
/****************************************************************************
 * Function: int viscaCommRead - Read bytes from a serial port.
 *
 * Parameters:
 *
 *      int idComDev - Comm device ID.
 *
 *      LPSTR lpstrData - Buffer into which to read data.
 *
 *      UINT cbData - Number of bytes to read.
 *
 *      UINT uWait - Maximum number of milliseconds to wait for data.
 *
 * Returns: 0 if successful, otherwise -1.
 ***************************************************************************/
static int NEAR PASCAL
    viscaCommRead(int idComDev, LPSTR lpstrData, UINT cbData, UINT uWait)
{
    int     cbRead;
    DWORD   dwTime0 = GetCurrentTime();
    DWORD   dwTime;
    
    while (cbData)
    {
        cbRead = ReadComm(idComDev, lpstrData, cbData);
        if (cbRead > 0)
        {
            lpstrData += cbRead;
            cbData -= cbRead;
        }
        else
        {
            if (GetCommError(idComDev, NULL))
            {
                DPF(DBG_ERROR, "viscaCommRead: GetCommError !\n");
                return (-1);
            }
            dwTime = GetCurrentTime();
            if (((dwTime < dwTime0) && ((dwTime + (ROLLOVER - dwTime0)) > uWait)) || 
                ((dwTime - dwTime0) > uWait))
            {
                DPF(DBG_ERROR, "viscaCommRead Timeout !");
                DPF(DBG_ERROR, "dwTime=%lu, dwTime0=%lu\n", dwTime, dwTime0);
                return (-1);
            }
        }
    }
    return (0);
}

/****************************************************************************
 * Function: int viscaCommWrite - Write bytes to a serial port.
 *
 * Parameters:
 *
 *      int idComDev - Comm device ID.
 *
 *      LPSTR lpstrData - Buffer to write.
 *
 *      UINT cbData - Number of bytes to read.
 *
 * Returns: TRUE if successful, otherwise FALSE.
 ***************************************************************************/
BOOL FAR PASCAL
    viscaCommWrite(int idComDev, LPSTR lpstrData, UINT cbData)
{
    int     cbWritten;

    while (cbData)
    {
        cbWritten = WriteComm(idComDev, lpstrData, cbData);
        if (cbWritten > 0)
        {
            lpstrData += cbWritten;
            cbData -= cbWritten;
        }
        else
        {
            if (GetCommError(idComDev, NULL))
            {
                return (0);
            }
        }
    }
    return (TRUE);
}
#endif


/****************************************************************************
 * Function: int viscaCommPortSetup - Open and setup the given comm port.
 *
 * Parameters:
 *
 *      int nComPort - Comm port to open (1..4).
 *
 * Returns: comm device ID if successful, otherwise a negative error
 *        code.
 ***************************************************************************/
VISCACOMMHANDLE FAR PASCAL
    viscaCommPortSetup(UINT nComPort)
{
    VISCACOMMHANDLE idComDev;
    int             err = 0;
    WCHAR           szDevControl[20];  
    DCB             dcb;
#ifdef _WIN32
    BOOL            bSuccess;
    COMMTIMEOUTS    toutComm;
#endif
    DPF(DBG_COMM, "Opening port number %u", nComPort);

    CreatePortHandles(pvcr->htaskCommNotifyHandler, nComPort-1);
    wsprintf(szDevControl, TEXT("COM%u"), nComPort);

#ifdef _WIN32
    idComDev = CreateFile(szDevControl, GENERIC_READ | GENERIC_WRITE,
                            0,              // exclusive access
                            NULL,           // no security
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL, // | FILE_FLAG_OVERLAPPED
                            NULL);

    // Set our timeouts to infinite, which means non-blocking.

    toutComm.ReadIntervalTimeout        = MAXDWORD;
    toutComm.ReadTotalTimeoutConstant   = 0;
    toutComm.ReadTotalTimeoutMultiplier = 0;

    SetCommTimeouts(idComDev, &toutComm);

    if(!idComDev)
        return FALSE;
    
    bSuccess = GetCommState(idComDev, &dcb);

    if(!bSuccess)
    {
        DPF(DBG_ERROR, "GetCommState has failed.\n");
    }

    dcb.BaudRate = 9600;
    dcb.ByteSize = 8;
    dcb.Parity   = NOPARITY;
    dcb.StopBits = ONESTOPBIT;

    bSuccess = SetCommState(idComDev, &dcb);

    if(!bSuccess)
    {
        DPF(DBG_ERROR, "SetCommState has failed\n");
    }

#else
    idComDev = OpenComm(szDevControl, 512, 128);
    if (idComDev < 0)
    {
        DPF(DBG_ERROR, "OpenComm(\"%s\", 512, 128) returned %d\n",(LPSTR)szDevControl, idComDev);
        return (idComDev);
    }
    
    wsprintf(szDevControl, "COM%u:9600,n,8,1", nComPort);
    err = BuildCommDCB(szDevControl, &dcb);
    if (err < 0)
    {
        DPF(DBG_ERROR, "BuildCommDCB(\"%s\", &dcb) returned %d\n",(LPSTR)szDevControl, err);
        CloseComm(idComDev);
        return (err);
    }
    
    err = SetCommState(&dcb);
    if (err < 0)
    {
        DPF(DBG_ERROR, "SetCommStat(&dcb) returned %d\n", err);
        CloseComm(idComDev);
        return (err);
    }
    
    FlushComm(idComDev, 0);
    FlushComm(idComDev, 1);

    EnableCommNotification(idComDev, pvcr->hwndCommNotifyHandler, 1, -1);
#endif
    return (idComDev); 
}


/****************************************************************************
 * Function: int viscaCommPortClose - Close an open comm port.
 *
 * Parameters:
 *
 *      int idComDev - Comm device ID to close.
 *
 * Returns: value returned by CloseComm() -- 0 if successful,
 *        otherwise less than 0.
 ***************************************************************************/
int FAR PASCAL
    viscaCommPortClose(VISCACOMMHANDLE idComDev, UINT uPort)
{
    return (MCloseComm(idComDev));
}

#ifdef _WIN32
BOOL IsTask(VISCAHTASK hTask)
{
    if(hTask != 0)
        return TRUE;
    else
        return FALSE;
}
#endif


#ifndef _WIN32
/****************************************************************************
 * Function: int    viscaPacketRead - Read a ViSCA packet from a serial port.
 *
 * Parameters:
 *
 *      int    idComDev      - Comm device ID.
 *
 *      LPSTR  lpstrPacket   - Buffer into which to read packet.
 *
 * Returns: 0 if successful, otherwise -1.
 ***************************************************************************/
static int NEAR PASCAL
    viscaPacketRead(int idComDev, LPSTR lpstrPacket)
{
    UINT    cbPacket = 0;
 
    if (viscaCommRead(idComDev, lpstrPacket, 1, PACKET_TIMEOUT))
    {
        DPF(DBG_ERROR, "Error reading 1st character!\n");
        return (-1);
    }
    while ((unsigned char) *lpstrPacket != (unsigned char)0xFF)
    {
        lpstrPacket++;
        cbPacket++;
        if (cbPacket == MAXPACKETLENGTH)
        {
            //
            // We've read max bytes, but still haven't got 0xff.
            //
            DPF(DBG_ERROR, " Bad Packet! No 0xFF!\n");
            return (-1);
        }
        if (viscaCommRead(idComDev, lpstrPacket, 1, PACKET_TIMEOUT))
        {
            DPF(DBG_ERROR, " viscaPacketRead, read: ");
            viscaPacketPrint(lpstrPacket - cbPacket, cbPacket);
            return (-1);
        }
    }
    lpstrPacket++;

    DPF(DBG_COMM, "---Read: ");
    viscaPacketPrint(lpstrPacket - cbPacket - 1, cbPacket + 1);

    return (0);
}
#endif

/****************************************************************************
 * Function: BOOL   viscaDeviceControl - Determine instance that started command and unlock or
 *                                      Lock device, etc.
 *
 * Parameters:
 *
 *      UINT   iPort         - Index of port on which message was received (0..3).
 *
 *      LPSTR  lpstrPacket   - ViSCA packet to process. 
 *
 * Returns: TRUE if processing should continue, FALSE if processing should return.
 *
 ***************************************************************************/
static BOOL NEAR PASCAL
    viscaDeviceControl(UINT iPort, LPSTR lpstrPacket, int FAR  *piInstReturn, BYTE FAR *pbRetType, UINT FAR *piDevReturn,
                        BOOL FAR *pfTxRelease)
{
    UINT            iDev    = VISCAREPLYDEVICE(lpstrPacket);
    int             iSocket = VISCAREPLYSOCKET(lpstrPacket);
    BYTE            bType   = VISCAREPLYTYPE(lpstrPacket);
    BOOL            fSocket = FALSE;


    //
    // If there is no device, there can be no socket. (like with cancel)
    //
    if(iDev==0)    
        iSocket = 0;

    *pfTxRelease = FALSE;

    if (((*lpstrPacket & 0x80) == 0x00) || (VISCAREPLYTODEVICE(lpstrPacket) != MASTERADDRESS))
    {
        // We're seriously hosed.
        DPF(DBG_ERROR, "Bad Packet\n");
        return (FALSE);
    }

    //
    // Don't be fooled! An error message 0x90 0x61 0x05 has a socket of 1
    // but error of 5.  That means No socket to be cancelled.
    //
    if((bType == VISCAREPLYERROR) &&
       iSocket                    &&
       (VISCAREPLYERRORCODE(lpstrPacket)==VISCAERRORNOSOCKET))
    {
        // Help it out by setting the socket to 0.
        iSocket = 0;
    }

    //
    // If port is locked, then this message MUST be response for port message.
    //
    if((BYTE)lpstrPacket[0] == VISCABROADCAST) // Broadcast response 0x88
    {
        iDev = pvcr->Port[iPort].iBroadcastDev; // Get responsible inst!
        *piDevReturn  = iDev;

        *piInstReturn = pvcr->Port[iPort].Dev[iDev].iInstReply;
        DPF(DBG_COMM, "Received a port message. port=%u, dev=%u, inst = %u", iPort, iDev, *piInstReturn);

        if(*piInstReturn != -1)
        {
            _fmemcpy(pinst[*piInstReturn].achPacket, lpstrPacket, MAXPACKETLENGTH);
            pinst[*piInstReturn].bReplyFlags |= VISCAF_COMPLETION;
            SignalInstance(*piInstReturn, VISCAF_ACK); // Ack and completion.
            SignalInstance(*piInstReturn, VISCAF_COMPLETION);
        }

        // This is not possible    
        if(pvcr->Port[iPort].Dev[iDev].fAckTimer)
        {
            KillTimer(pvcr->hwndCommNotifyHandler, MAKEACKTIMERID(iPort, 0));
            pvcr->Port[iPort].Dev[iDev].fAckTimer = FALSE;
        }
        
        *pfTxRelease = TRUE; // Not necessary.
        return FALSE;
    }

    if(iDev && pvcr->Port[iPort].Dev[iDev - 1].fTimerMsg)
    {
        //
        // This message has been generated by us to extend certain commands past their normal notifications.
        //
        iDev--;
        *piInstReturn = pvcr->iInstBackground;
        *piDevReturn  = iDev;
        DPF(DBG_COMM, "Timer message device=%d received.\n",iDev);
    }
    else if (iSocket && ((bType == VISCAREPLYCOMPLETION) || (bType == VISCAREPLYERROR)))
    {
        //                 (5x)                (6x)
        // This is either: command-complete or error.
        // And           : socket specified.
        //
        //
        // It is not possible that tx is locked here.
        //
        iDev--;
        iSocket--;
        fSocket = TRUE;
        //
        // Error codes 0x6n 0x04 where n is a valid socket will GO smoothly here.
        //
        // Which instance started this command.
        //
        *piInstReturn = pvcr->Port[iPort].Dev[iDev].rgSocket[iSocket].iInstReply;
        *piDevReturn  = iDev;
        pvcr->Port[iPort].Dev[iDev].rgSocket[iSocket].iInstReply = -1;
        //
        // If this is the auto-instance, then we need to know nothing more, clear socket.
        //
        if(*piInstReturn == pvcr->iInstBackground)
            pvcr->Port[iPort].Dev[iDev].iTransportSocket = -1;

        // Do not release TxLock here! Socket completions are asynchronous
    }
    else if (iDev)
    {
        // This is not a (socket completion) or (socket error).
        // 
        // The remaining options are:
        //      Socket ack.                 (4x)
        //      Non-socket completion.      (50)
        //      Non-socket error.           (60)
        //
        // The reason these are grouped together is that they all are
        // immediate responses to a sent command.
        //
        // If it is a cancelled message just ignore and return
        //
        if((bType == VISCAREPLYERROR) && (VISCAREPLYERRORCODE(lpstrPacket)==VISCAERRORCANCELLED))
            // Cancel commands do not block transmission.
            return FALSE;

        if((bType == VISCAREPLYERROR) && (VISCAREPLYERRORCODE(lpstrPacket)==VISCAERRORNOSOCKET))
            // Cancel commands do not block transmission.
            return FALSE;

        iDev--;
        //
        // Which instance started this command.
        //
        *piInstReturn = pvcr->Port[iPort].Dev[iDev].iInstReply;
        *piDevReturn  = iDev;
        pvcr->Port[iPort].Dev[iDev].iInstReply = -1;

        if (iSocket && (*piInstReturn != -1))
        {
            //
            // Ack with socket.  And there is an instance waiting for the ack.
            //
            fSocket = TRUE;
            iSocket--;
            pvcr->Port[iPort].Dev[iDev].rgSocket[iSocket].iInstReply = *piInstReturn;
            //
            // If this is an ack to the automatic instance, then unlock it now.
            //
            if(*piInstReturn == pvcr->iInstBackground)
            {
                DPF(DBG_QUEUE, "Setting transport socket\n");
                pvcr->Port[iPort].Dev[iDev].iTransportSocket = iSocket;
            }
        }

        // We always release tranport here!
        *pfTxRelease = TRUE;
    }
    *pbRetType = bType;
    return TRUE;
}


/****************************************************************************
 * Function: BOOL   viscaPacketProcess - Process a ViSCA packet.
 *
 * Parameters:
 *
 *      UINT   iPort         - Index of port on which message was received (0..3).
 *
 *      LPSTR  lpstrPacket   - ViSCA packet to process. 
 *
 * Returns: TRUE if message was stored with an OpenInstance,
 *        otherwise FALSE.
 *
 ***************************************************************************/
BOOL FAR PASCAL
    viscaPacketProcess(UINT iPort, LPSTR lpstrPacket)
{
    int iInst;
    BYTE bType;
    int  iDev = -1;
    BOOL fTxRelease = FALSE;


    if(!viscaDeviceControl(iPort, lpstrPacket, &iInst, &bType, &iDev, &fTxRelease))
    {
        // We must release the semaphore here. (unless cancel which does not return dev)
        if(iDev != -1)
            viscaReleaseSemaphore(OWNED(pvcr->Port[iPort].Dev[iDev].fTxLock));
        return TRUE;
    }

    // If it was a 90 38 ff (network change, ignore it)
    if(iInst == -1)
    {
        DPF(DBG_ERROR, "iInst == -1 \n");
        return TRUE; // What if we had a blocked! BAD
    }

    //
    //  We do not release the semaphore because the auto-inst may need
    //  to use it to transmit another command.
    //
    if(pvcr->Port[iPort].Dev[iDev].fTimerMsg != TRUE) // Device is already locked.
        viscaWaitForSingleObject(OWNED(pvcr->Port[iPort].Dev[iDev].fDeviceLock), FALSE, MY_INFINITE, (UINT)0);

    // It doesn't matter what it is, we can kill the ack timer now.
    if(pvcr->Port[iPort].Dev[iDev].fAckTimer)
    {
        DPF(DBG_COMM, "Killing timer now.\n");
        KillTimer(pvcr->hwndCommNotifyHandler, MAKEACKTIMERID(iPort, iDev));
        pvcr->Port[iPort].Dev[iDev].fAckTimer = FALSE;
    }


    switch(bType)
    {
        case VISCAREPLYERROR:
            if(iInst == pvcr->iInstBackground)
                viscaAutoErrorCompletion(iPort, iDev, lpstrPacket, &fTxRelease);
            else
                viscaErrorCompletion(iInst, lpstrPacket, &fTxRelease);
            break;

        case VISCAREPLYCOMPLETION:
            if(iInst == pvcr->iInstBackground)
                viscaAutoSuccessfulCompletion(iPort, iDev, lpstrPacket, &fTxRelease);
            else
                viscaSuccessfulCompletion(iInst, lpstrPacket, &fTxRelease);
            break;

        case VISCAREPLYADDRESS:
        case VISCAREPLYACK:
            if(iInst == pvcr->iInstBackground)
                viscaAutoAck(iPort, iDev);
            else
                viscaAck(iInst, &fTxRelease);
            break;

    }
    //
    // Did this survive?
    //
    if(fTxRelease)
        viscaReleaseSemaphore(OWNED(pvcr->Port[iPort].Dev[iDev].fTxLock));
    
    if(pvcr->Port[iPort].Dev[iDev].fTimerMsg != TRUE) // Device is already locked.
        viscaReleaseMutex(OWNED(pvcr->Port[iPort].Dev[iDev].fDeviceLock));

    return TRUE;
}


void FAR PASCAL SignalInstance(int iInst, BYTE bReplyFlags)
{
#ifdef _WIN32
    HANDLE      hProcess;
    HANDLE      hEventTemp;
#endif

    if(iInst < 0)
        return;

#ifdef _WIN32
    if(bReplyFlags & VISCAF_COMPLETION)
    {
        hProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pinst[iInst].pidThisInstance);

        DuplicateHandle(hProcess,
                pinst[iInst].fCompletionEvent,
                GetCurrentProcess(),
                &hEventTemp,
                0,
                FALSE,
                DUPLICATE_SAME_ACCESS);

        viscaSetEvent(hEventTemp);

        CloseHandle(hEventTemp);
        CloseHandle(hProcess);
    }
    else if(bReplyFlags & VISCAF_ACK)
    {
        hProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pinst[iInst].pidThisInstance);

        DuplicateHandle(hProcess,
                pinst[iInst].fAckEvent,
                GetCurrentProcess(),
                &hEventTemp,
                0,
                FALSE,
                DUPLICATE_SAME_ACCESS);

        SetEvent(hEventTemp);

        CloseHandle(hEventTemp);
        CloseHandle(hProcess);
    }
#else
    if(bReplyFlags & VISCAF_COMPLETION)
        viscaSetEvent(OWNED(pinst[iInst].fCompletionEvent));
    else if(bReplyFlags & VISCAF_ACK)
        viscaSetEvent(OWNED(pinst[iInst].fAckEvent));
#endif

    return;

}

void FAR PASCAL SignalDevice(int iPort, int iDev, BYTE bReplyFlags)
{
    // The background task own this one and it's duplicated in each instance.

    if(bReplyFlags & VISCAF_COMPLETION)
        viscaSetEvent(OWNED(pvcr->Port[iPort].Dev[iDev].fAutoCompletion));
    else if(bReplyFlags & VISCAF_ACK)
        viscaSetEvent(OWNED(pvcr->Port[iPort].Dev[iDev].fAutoAck));

    return;
}



/****************************************************************************
 * Function: void   viscaAck      - Handle acknowledgments.
 *
 * Parameters:
 *
 *      POpenInstace iInst   - Instance that started this comamnd.
 *
 ***************************************************************************/
static void NEAR PASCAL
    viscaAck(int iInst, BOOL FAR *pfTxRelease)
{
    UINT    iPort    = pinst[iInst].iPort;
    UINT    iDev     = pinst[iInst].iDev;

    // If a auto-command got blocked, then send it out now.
    DPF(DBG_QUEUE, "viscaAck -\n");

    if(pvcr->Port[iPort].Dev[iDev].uAutoBlocked)
        viscaAutoWrite(iPort, iDev, FALSE, 0, pfTxRelease); // This command is not blockable

    if(iInst != -1)
        pinst[iInst].bReplyFlags |= VISCAF_ACK;

    SignalInstance(iInst, VISCAF_ACK);
}


/****************************************************************************
 * Function: void   viscaSuccessfulCompletion - Handle successful completions
 *
 * Parameters:
 *
 *      int iInst  - Instance that started this command.
 *
 *      LPSTR  lpstrPacket   - The entire packet we have received.
 *
 ***************************************************************************/
static void NEAR PASCAL
    viscaSuccessfulCompletion(int iInst, LPSTR lpstrPacket, BOOL FAR *pfTxRelease)
{
    UINT iPort = pinst[iInst].iPort;
    UINT iDev  = pinst[iInst].iDev;

    DPF(DBG_QUEUE, "viscaSuccessfulCompletion - setting iInst to completed.\n");
    //
    // Process a completion and errors. (must be waiting).
    // 
    if(iInst != -1)
    {
        _fmemcpy(pinst[iInst].achPacket, lpstrPacket, MAXPACKETLENGTH);
        pinst[iInst].bReplyFlags |= VISCAF_COMPLETION;

        SignalInstance(iInst, VISCAF_ACK);          // This may already be signalled.
        SignalInstance(iInst, VISCAF_COMPLETION);   // This cannot be signalled yet.
    }

    if(pvcr->Port[iPort].Dev[iDev].uAutoBlocked)
        viscaAutoWrite(iPort, iDev, FALSE, 0, pfTxRelease);      // This command is not blockable 
}


/****************************************************************************
 * Function: void   viscaErrorCompletion - Handle error completions.
 *
 * Parameters:
 *
 *      int iInst  - Instance that started this command.
 *
 *      LPSTR  lpstrPacket   - The entire packet we have received.
 *
 ***************************************************************************/
static void NEAR PASCAL
    viscaErrorCompletion(int iInst, LPSTR lpstrPacket, BOOL FAR *pfTxRelease)
{
    UINT iPort = pinst[iInst].iPort;
    UINT iDev  = pinst[iInst].iDev;

    DPF(DBG_QUEUE, "viscaErrorCompletion - setting iInst to completed.\n");
    //
    // Process a completion and errors. (must be waiting).
    // 
    if(iInst != -1)
    {
        _fmemcpy(pinst[iInst].achPacket, lpstrPacket, MAXPACKETLENGTH);
        pinst[iInst].bReplyFlags |= VISCAF_COMPLETION;
        pinst[iInst].bReplyFlags |= VISCAF_ERROR;

        SignalInstance(iInst, VISCAF_ACK);          // This may already be signalled.
        SignalInstance(iInst, VISCAF_COMPLETION);   // This cannot be signalled yet.
    }

    if(pvcr->Port[iPort].Dev[iDev].uAutoBlocked)
        viscaAutoWrite(iPort, iDev, FALSE, 0, pfTxRelease); // This command is not blockable
}


/****************************************************************************
 * Function: void   viscaAutoWrite   - Send the next queued command.
 *
 * Parameters:
 *
 *      POpenInstace iInst      - Instance that started this command (auto).
 *
 *      BOOL   fBlockable       - Can transmission be blocked. If false then we must send.
 *
 *      UINT   uAutoBlocked     - If blocked, was it normal or error completion that was blocked.
 *
 ***************************************************************************/
static BOOL NEAR PASCAL
    viscaAutoWrite( UINT iPort,
                    UINT iDev,
                    BOOL fBlockable,
                    UINT uAutoBlocked,
                    BOOL FAR *pfTxRelease) 
{
    UINT    iDevDone        = pvcr->Port[iPort].Dev[iDev].iCmdDone;
    CmdInfo *pcmdCmd        = &(pvcr->Port[iPort].Dev[iDev].rgCmd[iDevDone]);
    LPSTR   lpstrCmd        = pcmdCmd->str[pcmdCmd->iCmdDone];
    BYTE    cbMessageLength = pcmdCmd->uLength[pcmdCmd->iCmdDone];
    UINT    uTimerID;

    if(fBlockable)
    {
        //
        // Only async completions can cause this (receive something after it gets locked)
        //    know async completion because txRelease is set to false.
        //
        if(!*pfTxRelease)  // We do not know if it is free, so check.
        {
            if(viscaWaitForSingleObject(OWNED(pvcr->Port[iPort].Dev[iDev].fTxLock), FALSE, 0L, 0)==WAIT_TIMEOUT) 
            {
                pvcr->Port[iPort].Dev[iDev].uAutoBlocked  = uAutoBlocked;
                pvcr->Port[iPort].Dev[iDev].wTransportCmd = 0;          // No command running after completion
                DPF(DBG_QUEUE, "viscaAutoWrite - We have been blocked!\n");
                return FALSE;
            }
        }
        // Claim the semaphore!
        *pfTxRelease = FALSE;
        DPF(DBG_QUEUE, "viscaAutoWrite - Clear sailing, transmitting now captain.\n");
        pvcr->Port[iPort].Dev[iDev].iInstReply     = pvcr->iInstBackground;
        pvcr->Port[iPort].Dev[iDev].uAutoBlocked   = uAutoBlocked;  // Set it to normal(I know we weren't blocked!)
    }
    else
    {
        // TxRelease must be true! No other way to get here.
        *pfTxRelease = FALSE;
        DPF(DBG_QUEUE, "viscaAutoWrite - Attempting blocked transmission now.\n");
        pvcr->Port[iPort].Dev[iDev].iInstReply = pvcr->iInstBackground;
    }

    lpstrCmd[0]                   = MAKEDEST((BYTE)(iDev+1));
    lpstrCmd[cbMessageLength + 1] = (BYTE)0xFF;

    DPF(DBG_COMM, "---Wrote: ");
    viscaPacketPrint(lpstrCmd, cbMessageLength + 2);

    pvcr->Port[iPort].Dev[iDev].uAutoBlocked  = FALSE;
    pvcr->Port[iPort].Dev[iDev].wTransportCmd = 0;  // No command running after completion
    //
    // Try to write packet
    //
#ifdef _WIN32
    //
    // We MUST have already claimed the Tx Lock on this device.
    // 
    WaitForSingleObject(pvcr->Port[iPort].fTxBuffer, MY_INFINITE);

    _fmemcpy(pvcr->Port[iPort].achTxPacket, lpstrCmd, cbMessageLength + 2);
    pvcr->Port[iPort].nchTxPacket = cbMessageLength + 2;

    // Signal that it is time to transmit. (we must use our version of the handle).
    SetEvent(pvcr->Port[iPort].fTxReady);
#else
    if (!viscaCommWrite(pvcr->Port[iPort].idComDev,
                lpstrCmd,
                cbMessageLength + 2))
    {
        pvcr->Port[iPort].Dev[iDev].iInstReply = -1;
        pvcr->Port[iPort].Dev[iDev].bReplyFlags |= VISCAF_ERROR;
        viscaReleaseAuto(iPort, iDev, MCI_NOTIFY_FAILURE);
        viscaReleaseSemaphore(OWNED(pvcr->Port[iPort].Dev[iDev].fTxLock));
        return FALSE;
    }
#endif

    uTimerID = MAKEACKTIMERID(iPort, iDev);

    DPF(DBG_COMM, "Timer ID = %x",uTimerID);

    if(SetTimer(pvcr->hwndCommNotifyHandler, uTimerID, ACK_TIMEOUT, NULL))
    {
        DPF(DBG_COMM, "Ack-timer started\n");
        pvcr->Port[iPort].Dev[iDev].fAckTimer = TRUE;
    }
    return TRUE;

}

/****************************************************************************
 * Function: void   viscaAutoAck  - Acknowledgements intended for auto-instance.
 *
 * Parameters:
 *
 *      int iInst  - Instance that started this command.
 *
 ***************************************************************************/
static void NEAR PASCAL
    viscaAutoAck(UINT iPort, UINT iDev)
{
    DPF(DBG_QUEUE, "viscaAutoAck - Setting wTransportCmd\n.");

    // Set current running command (Used only in cancel)
    pvcr->Port[iPort].Dev[iDev].wTransportCmd =
        pvcr->Port[iPort].Dev[iDev].rgCmd[pvcr->Port[iPort].Dev[iDev].iCmdDone].uViscaCmd;
        
    // The nth command, and the device (may be redundant on device).
    pvcr->Port[iPort].Dev[iDev].bReplyFlags |= VISCAF_ACK; // First ack

    // Auto-ack will never alter the state of pfTxRelease
    SignalDevice(iPort, iDev, VISCAF_ACK);       // This may already be signalled.
}



/****************************************************************************
 * Function: void   viscaAutoSuccessfulCompletion - Handle successful completion
 *                for the auto-instance.
 *
 * Parameters:
 *
 *      int iInst  - Instance that started this command.
 *
 *      LPSTR  lpstrPacket   - The entire packet we have received.
 *
 ***************************************************************************/
static void NEAR PASCAL
    viscaAutoSuccessfulCompletion(  UINT iPort,
                                    UINT iDev,
                                    LPSTR lpstrPacket,
                                    BOOL FAR *pfTxRelease)
{
    UINT iDevCmd    = pvcr->Port[iPort].Dev[iDev].iCmdDone;
    CmdInfo *pcmdCmd = &(pvcr->Port[iPort].Dev[iDev].rgCmd[iDevCmd]);
    UINT uViscaCmd   = pcmdCmd->uViscaCmd;

    DPF(DBG_QUEUE, "viscaAutoSuccessfulCompletion\n");
    //
    // Extend this command completion? Only need to do this on good completion, not error or others.
    //
    if( !pvcr->Port[iPort].Dev[iDev].fTimerMsg &&
        (pvcr->Port[iPort].Dev[iDev].uModelID  == VISCADEVICEVENDORSONY)    &&
        (pvcr->Port[iPort].Dev[iDev].uVendorID == VISCADEVICEMODELEVO9650))
    {
        UINT uTimerID;
        UINT uTimeOut;
        //
        // These timeouts have been emperically determined.
        //
        if(uViscaCmd == VISCA_FREEZE)
            uTimeOut = 3000;
        else if(uViscaCmd == VISCA_STEP)
            uTimeOut = 350;
        else
            uTimeOut = 0;

        if(uTimeOut != 0)
        {
            _fmemcpy(pvcr->Port[iPort].Dev[iDev].achPacket, lpstrPacket, MAXPACKETLENGTH);
            //
            // Make a unique timer id.
            // Put port in low-byte and device in hi-byte, add one so it is non-zero.
            //
            uTimerID = MAKETIMERID(iPort, iDev);

            if(SetTimer(pvcr->hwndCommNotifyHandler, uTimerID, uTimeOut, NULL))
            {
                pvcr->Port[iPort].Dev[iDev].fTimer = TRUE;
                DPF(DBG_COMM, "Started port=%d, device=%d\n", iPort, iDev);
            }
            return;
        }
    }
    //
    // Set the successful completion of the command. (see viscacom.c)
    //
    viscaSetCommandComplete(iPort, iDev, uViscaCmd);
    //
    // Are we done with this command?
    //
    pcmdCmd->uLoopCount--;
    if(pcmdCmd->uLoopCount == 0)
    {
        pcmdCmd->iCmdDone++;
        pvcr->Port[iPort].Dev[iDev].iCmdDone++;
    }
    //
    // We are done if we just incremented past the end of queue.
    //
    if(pvcr->Port[iPort].Dev[iDev].iCmdDone < pvcr->Port[iPort].Dev[iDev].nCmd)
    {
        DPF(DBG_QUEUE, "viscaAutoSuccessfulCompletion - Sending next command done=%d Total=%d\n", pvcr->Port[iPort].Dev[iDev].iCmdDone, pvcr->Port[iPort].Dev[iDev].nCmd);

        if(pvcr->Port[iPort].Dev[iDev].fQueueAbort)
        {
            // Someone has requested abort.
            pvcr->Port[iPort].Dev[iDev].bReplyFlags |= VISCAF_ERROR;
            viscaReleaseAuto(iPort, iDev, MCI_NOTIFY_ABORTED);
        }
        else
        {
            // Next command. TxRelease set to true. we might change it.
            viscaAutoWrite(iPort, iDev, TRUE, AUTOBLOCK_NORMAL, pfTxRelease);
            SignalDevice(iPort, iDev, VISCAF_ACK);       // This may already be signalled.
        }

    }
    else if(pvcr->Port[iPort].Dev[iDev].iCmdDone==pvcr->Port[iPort].Dev[iDev].nCmd)
    {
        DPF(DBG_QUEUE, "viscaAutoSuccessfulCompletion - Releasing auto.\n");
        viscaReleaseAuto(iPort, iDev, MCI_NOTIFY_SUCCESSFUL);
    }

    return;
}


/****************************************************************************
 * Function: void   viscaAutoErrorCompletion - Errors to the auto-instance.
 *
 * Parameters:
 *
 *      int iInst  - Instance that started this command.
 *
 *      LPSTR  lpstrPacket   - The entire packet we have received.
 *
 ***************************************************************************/
static void NEAR PASCAL
    viscaAutoErrorCompletion(   UINT iPort,
                                UINT iDev,
                                LPSTR lpstrPacket,
                                BOOL FAR *pfTxRelease)
{
    UINT iDevCmd        = pvcr->Port[iPort].Dev[iDev].iCmdDone;
    CmdInfo *pcmdCmd    = &(pvcr->Port[iPort].Dev[iDev].rgCmd[iDevCmd]);
    UINT uViscaCmd      = pcmdCmd->uViscaCmd;

    DPF(DBG_QUEUE, "viscaAutoErrorCompletion - \n");

    // One alternative has bit the dust (the main one).
    pcmdCmd->iCmdDone++;
    // If we are looping we will break now anyway!

    if(VISCAREPLYERRORCODE(lpstrPacket) == VISCAERRORCANCELLED)
    {
        //
        // We have been cancelled.
        //
        pvcr->Port[iPort].Dev[iDev].bReplyFlags |= VISCAF_ERROR;
        viscaReleaseAuto(iPort, iDev, MCI_NOTIFY_ABORTED);
    }
    else if(pcmdCmd->iCmdDone < pcmdCmd->nCmd)
    {
        //
        // Error is NOT cancel, and we have alternatives to send.
        //
        if(pvcr->Port[iPort].Dev[iDev].fQueueAbort)
        {
            pvcr->Port[iPort].Dev[iDev].bReplyFlags |= VISCAF_ERROR;
            viscaReleaseAuto(iPort, iDev, MCI_NOTIFY_ABORTED);
        }
        else
        {
            //
            // Try the next alternative to this command.
            //
            viscaAutoWrite(iPort, iDev, TRUE, AUTOBLOCK_ERROR, pfTxRelease);
        }
        pvcr->Port[iPort].Dev[iDev].wTransportCmd = 0;  // No command running after completion 
    }
    else
    {
        //
        // No alternatives and we had an error, so just die.
        //
        pvcr->Port[iPort].Dev[iDev].bReplyFlags |= VISCAF_ERROR;
        //
        // Only notify on error if this is not the first ack! The first
        // ack-error will be handled by the DoQueued command.
        //
        if(pvcr->Port[iPort].Dev[iDev].bReplyFlags & VISCAF_ACK)
        {
            viscaReleaseAuto(iPort, iDev, MCI_NOTIFY_FAILURE);
        }
        else  // In this case we need to know the error reason.
        {
            if(pvcr->Port[iPort].Dev[iDev].iInstTransport != -1)
                _fmemcpy(pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].achPacket, lpstrPacket, MAXPACKETLENGTH);

            viscaReleaseAuto(iPort, iDev, 0);
        }

    }

    return;
}


/****************************************************************************
 * Function: void   viscaReleaseAuto - Abort (cancel) in the auto-instance.
 *                                  
 * Parameters:
 *
 *      int iInst  - Instance that started this command.
 *
 *      DWORD  dwNotify  -   MCI-notification flags.
 *
 ***************************************************************************/
static void NEAR PASCAL
    viscaReleaseAuto(UINT iPort, UINT iDev, DWORD dwNotify)
{

    if(pvcr->Port[iPort].Dev[iDev].iInstTransport != -1)
    {
        //
        // Do we have to notify?
        //
        HWND hWndTransport = pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].hwndNotify;
        UINT uDeviceID     = pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].uDeviceID;

        //
        // hWnd Transport will be null if we do not want notification.
        //
        if(hWndTransport != NULL)
        {
            if((dwNotify == MCI_NOTIFY_FAILURE) || (dwNotify == MCI_NOTIFY_SUCCESSFUL))
            {
                mciDriverNotify(hWndTransport, uDeviceID, (UINT) dwNotify);
                pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].hwndNotify = NULL;

            }
            else if(dwNotify == MCI_NOTIFY_ABORTED)
            {
                // Special case pause, does not send abort or supersede.

                if(pvcr->Port[iPort].Dev[iDev].dwReason == MCI_NOTIFY_SUPERSEDED)
                {
                    mciDriverNotify(hWndTransport, uDeviceID, MCI_NOTIFY_SUPERSEDED);
                    pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].hwndNotify = NULL;
                }
                else if(pvcr->Port[iPort].Dev[iDev].dwReason == MCI_NOTIFY_ABORTED)
                {
                    mciDriverNotify(hWndTransport, uDeviceID, MCI_NOTIFY_ABORTED);
                    pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].hwndNotify = NULL;
                }

                // Pause will fall through and leave the hwndNotify in place.
                // Even though transport inst is not there.
            }
        }
    }

    //
    // Abort sending commands.
    //
    if(!pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].fWaiting)
    {
        DPF(DBG_QUEUE, "Releasing transport in commtask.c\n");
        viscaReleaseAutoParms(iPort, iDev);
        viscaSetEvent(OWNED(pvcr->Port[iPort].Dev[iDev].fTransportFree));
    }

    //
    // Set entire queue status to completion (may be waiting).
    //
    pvcr->Port[iPort].Dev[iDev].bReplyFlags |= VISCAF_COMPLETION;
    SignalDevice(iPort, iDev, VISCAF_COMPLETION);  //Owned by us!
    SignalDevice(iPort, iDev, VISCAF_ACK);       // This may already be signalled.
}

#ifndef _WIN32
/****************************************************************************
 * Function: void   viscaCommNotifyHandler - Handle WM_COMMNOTIFY message.
 *
 * Parameters:
 *
 *      HWND   hwnd          - Window that received WM_COMMNOTIFY message.
 *
 *      int    idComDev      - Comm device ID.
 *
 *      UINT   uNotifyStatus - Flags that indicate why WM_COMMNOTIFY was sent.
 *
 ***************************************************************************/
static void NEAR PASCAL
    viscaCommNotifyHandler(HWND hwnd, int idComDev, UINT uNotifyStatus)
{
    if (uNotifyStatus & CN_RECEIVE)
    {
        char        achPacket[MAXPACKETLENGTH];
        UINT        iPort;
        COMSTAT     comStat;

        for (iPort = 0; iPort < MAXPORTS; iPort++)
        {
            if (pvcr->Port[iPort].idComDev == idComDev)
            {
                break;
            }
        }
        if (iPort == MAXPORTS)
        {
            return;
        }
        comStat.cbInQue = 0;
        GetCommError(idComDev, &comStat);
        while (comStat.cbInQue > 0)
        {
            if (viscaPacketRead(idComDev, achPacket))
            {
                // Error reading packet.
                return;
            }

            viscaPacketProcess(iPort, achPacket);
            comStat.cbInQue = 0;
            GetCommError(idComDev, &comStat);
        }
    }
}
#else
static void NEAR PASCAL
    viscaCommNotifyHandler(HWND hwnd, int idComDev, UINT uNotifyStatus)
{
    return;
}
#endif

/****************************************************************************
 * Function: LRESULT viscaCommHandlerWndPro - Window procedure for background
 *                                         task window that receives
 *                                         WM_COMMNOTIFY messages.
 *
 * Parameters:
 *
 *      HWND   hwnd          - Window handle.
 *
 *      UINT   uMsg          - Windows message.
 *
 *      WPARAM wParam        - First message-specific parameter.
 *
 *      LPARAM lParam        - Second message-specific parameter.
 *
 * Returns: 0 if message was processed, otherwise returns value
 *        returned by DefWindowProc().
 ***************************************************************************/
LRESULT CALLBACK LOADDS
    viscaCommHandlerWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (LOWORD(uMsg))   // LOWORD for NT compatibility, Does nothing in Win3.1
    {
#ifndef _WIN32
        case WM_COMMNOTIFY:
            HANDLE_WM_COMMNOTIFY(hwnd, wParam, lParam, viscaCommNotifyHandler);
            return ((LRESULT)0);
#else
        case WM_USER:
            TaskDoCommand((UINT)wParam, lParam);
            break;
#endif

        //
        // Timer is used to extend command notifies.
        //
        case WM_TIMER:
            DPF(DBG_COMM, "------------->TimerMsg.\n");
            if(ISACKTIMER(wParam))
            {
                UINT iPort  = (UINT) (((0x00f0 & wParam) >> 4) - 1);
                UINT iDev   = (UINT) (((0xf000 & wParam) >> 12) - 1);

                KillTimer(hwnd, wParam);
                pvcr->Port[iPort].Dev[iDev].bReplyFlags    |= VISCAF_COMPLETION;
                pvcr->Port[iPort].Dev[iDev].bReplyFlags    |= VISCAF_ERROR;
                pvcr->Port[iPort].Dev[iDev].bReplyFlags    |= VISCAF_ERROR_TIMEOUT;

                // This messages is dispached through GetMessage loop in msmcivcr.exe! Check it out!
                // That means we, of course, own the following handle.
                viscaReleaseSemaphore(OWNED(pvcr->Port[iPort].Dev[iDev].fTxLock)); //We own this handle!

                if(pvcr->Port[iPort].Dev[iDev].iInstReply == pvcr->iInstBackground)
                    viscaReleaseAuto(iPort, iDev, MCI_NOTIFY_FAILURE);

                pvcr->Port[iPort].Dev[iDev].iInstReply     = -1;
                pvcr->Port[iPort].Dev[iDev].fAckTimer      = FALSE;
                DPF(DBG_ERROR, "Ack timeout! releasing TxLock now.\n");
            }
            else
            {
                UINT iPort  = (UINT) ((0x00ff & wParam) - 1);
                UINT iDev   = (UINT) (((0xff00 & wParam) >> 8) - 1);
                LPSTR lpstrFreeze;
                //
                // Kill the timer
                //
                KillTimer(hwnd, wParam);
                DPF(DBG_COMM, "Killed port=%d, device=%d\n", iPort, iDev);
                pvcr->Port[iPort].Dev[iDev].fTimer     = FALSE;
                pvcr->Port[iPort].Dev[iDev].fTimerMsg  = TRUE;
                viscaWaitForSingleObject(OWNED(pvcr->Port[iPort].Dev[iDev].fDeviceLock), FALSE, MY_INFINITE, (UINT)0);

                //
                // Resend the packet for processing, each device could have a packet (but clear the socket) 
                //
                lpstrFreeze     = pvcr->Port[iPort].Dev[iDev].achPacket;
                lpstrFreeze[1]  = (BYTE) ((BYTE)lpstrFreeze[1] & 0xf0);
                viscaPacketPrint(lpstrFreeze, 3);
                viscaPacketProcess(iPort, lpstrFreeze);
                _fmemset(pvcr->Port[iPort].Dev[iDev].achPacket, '\0', MAXPACKETLENGTH);
                pvcr->Port[iPort].Dev[iDev].fTimerMsg = FALSE;
                viscaReleaseMutex(OWNED(pvcr->Port[iPort].Dev[iDev].fDeviceLock));
            }
            break;

        default:
            return (DefWindowProc(hwnd, uMsg, wParam, lParam));
    }
}


/*
 * Create Handles necessary to synchronize device access.
 */
BOOL FAR PASCAL CreateDeviceHandles(DWORD pidBackground, UINT iPort, UINT iDev)  // This is called by the backgound task!
{
#ifdef _WIN32
    pvcr->Port[iPort].Dev[iDev].fTxLock    = CreateSemaphore(NULL,  // Null security description
                                                  1,            // Initial count. so someone can take it.
                                                  1,        // I do not want immediate ownership.
                                                  NULL);        // No name

    pvcr->Port[iPort].Dev[iDev].fQueueLock = CreateMutex(NULL,
                                                  FALSE,    // I do not want immediate ownership.
                                                  NULL);    // No name

    pvcr->Port[iPort].Dev[iDev].fTransportFree = CreateEvent(NULL,
                                                  TRUE,     // MANUAL
                                                  FALSE,    // Initially not-signalled.
                                                  NULL);    // No name

    pvcr->Port[iPort].Dev[iDev].fDeviceLock = CreateMutex(NULL,
                                                  FALSE,    // I do not want immediate ownership.
                                                  NULL);    // No name

    pvcr->Port[iPort].Dev[iDev].fAutoCompletion = CreateEvent(NULL,
                                                  TRUE,     // MANUAL
                                                  FALSE,    // Initially not-signalled.
                                                  NULL);    // No name

    pvcr->Port[iPort].Dev[iDev].fAutoAck = CreateEvent(NULL,
                                                  TRUE,     // MANUAL
                                                  FALSE,    // Initially not-signalled.
                                                  NULL);    // No name
#else
    pvcr->Port[iPort].Dev[iDev].fTxLock         = TRUE; //Count set to 1, one may go! with wait.
    pvcr->Port[iPort].Dev[iDev].fQueueLock      = TRUE;
    pvcr->Port[iPort].Dev[iDev].fTransportFree  = TRUE;
    pvcr->Port[iPort].Dev[iDev].fDeviceLock     = TRUE;
    pvcr->Port[iPort].Dev[iDev].fAutoCompletion = TRUE;
    pvcr->Port[iPort].Dev[iDev].fAutoAck        = TRUE;
#endif

    DPF(DBG_TASK, "CreateDeviceHandles Port=%u Dev=%uOk! \n", iPort, iDev);
    return TRUE;
}

/*
 * Create Handles necessary to synchronize device access.
 */
BOOL FAR PASCAL CloseDeviceHandles(DWORD pidBackground, UINT iPort, UINT iDev)  // This is called by the backgound task!
{
#ifdef _WIN32
    CloseHandle(pvcr->Port[iPort].Dev[iDev].fTxLock    );
    CloseHandle(pvcr->Port[iPort].Dev[iDev].fQueueLock );
    CloseHandle(pvcr->Port[iPort].Dev[iDev].fTransportFree );
    CloseHandle(pvcr->Port[iPort].Dev[iDev].fDeviceLock);
    CloseHandle(pvcr->Port[iPort].Dev[iDev].fAutoCompletion);
    CloseHandle(pvcr->Port[iPort].Dev[iDev].fAutoAck);
#endif
    DPF(DBG_TASK, "CloseDeviceHandles Port=%u Dev=%uOk! \n", iPort, iDev);
    return TRUE;
}


/*
 * Duplicate device Handles to an instance, so the instance can synchronize.
 */
BOOL FAR PASCAL DuplicateDeviceHandlesToInstance(DWORD pidBackground, UINT iPort, UINT iDev, int iInst)
{
#ifdef _WIN32
    HANDLE hProcessBackground;

    hProcessBackground = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pidBackground); // iInst has pid.

    DuplicateHandle(hProcessBackground,
            pvcr->Port[iPort].Dev[iDev].fTxLock,
            GetCurrentProcess(), 
            &pinst[iInst].pfTxLock,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);

    DuplicateHandle(hProcessBackground,
            pvcr->Port[iPort].Dev[iDev].fQueueLock,
            GetCurrentProcess(), 
            &pinst[iInst].pfQueueLock,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);

    DuplicateHandle(hProcessBackground,
            pvcr->Port[iPort].Dev[iDev].fTransportFree,
            GetCurrentProcess(), 
            &pinst[iInst].pfTransportFree,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);

    DuplicateHandle(hProcessBackground,
            pvcr->Port[iPort].Dev[iDev].fDeviceLock,
            GetCurrentProcess(), 
            &pinst[iInst].pfDeviceLock,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);

    DuplicateHandle(hProcessBackground,
            pvcr->Port[iPort].Dev[iDev].fAutoCompletion,
            GetCurrentProcess(), 
            &pinst[iInst].pfAutoCompletion,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);

    DuplicateHandle(hProcessBackground,
            pvcr->Port[iPort].Dev[iDev].fAutoAck,
            GetCurrentProcess(), 
            &pinst[iInst].pfAutoAck,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);




    CloseHandle(hProcessBackground);
#else
    pinst[iInst].pfTxLock           = &pvcr->Port[iPort].Dev[iDev].fTxLock;
    pinst[iInst].pfQueueLock        = &pvcr->Port[iPort].Dev[iDev].fQueueLock;
    pinst[iInst].pfTransportFree    = &pvcr->Port[iPort].Dev[iDev].fTransportFree;
    pinst[iInst].pfDeviceLock       = &pvcr->Port[iPort].Dev[iDev].fDeviceLock;
    pinst[iInst].pfAutoCompletion   = &pvcr->Port[iPort].Dev[iDev].fAutoCompletion;
    pinst[iInst].pfAutoAck          = &pvcr->Port[iPort].Dev[iDev].fAutoAck;
#endif
    pinst[iInst].fDeviceHandles = TRUE;
    DPF(DBG_TASK, "DuplicateDeviceHandles Port=%u Dev=%uOk! \n", iPort, iDev);
    return TRUE;
}

/*
 * Create handles needed to serialize Port access.
 */
BOOL FAR PASCAL CreatePortHandles(DWORD pidBackground, UINT iPort)
{
#ifdef _WIN32

    pvcr->Port[iPort].fTxBuffer = CreateEvent(NULL,
                                    FALSE,    // False means not-manual! This is auto.
                                    TRUE,     // Set to signalled! First person must gain access.
                                    NULL);    // No name

    pvcr->Port[iPort].fTxReady = CreateEvent(NULL,
                                    FALSE,    // False measn not-manual! This is auto!
                                    FALSE,    // Set to non-signalled state. 
                                    NULL);    // No name

#endif

    DPF(DBG_TASK, "CreatePortHandles for port index %u Ok! \n", iPort);
    return TRUE;
}

/*
 * Close handles needed to serialize Port access.
 */
BOOL FAR PASCAL ClosePortHandles(DWORD pidBackground, UINT iPort)
{
#ifdef _WIN32
    CloseHandle(pvcr->Port[iPort].fTxBuffer);
    CloseHandle(pvcr->Port[iPort].fTxReady);
#endif
    DPF(DBG_TASK, "ClosePortHandles for port index %u Ok! \n", iPort);
    return TRUE;
}


/*
 * Duplicate handles to instance needed to serialize Port access.
 */
BOOL FAR PASCAL DuplicatePortHandlesToInstance(DWORD pidBackground, UINT iPort, int iInst)
{
#ifdef _WIN32
    HANDLE hProcessBackground;

    hProcessBackground = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pidBackground); // iInst has pid.

    DuplicateHandle(hProcessBackground,
            pvcr->Port[iPort].fTxBuffer,
            GetCurrentProcess(), 
            &pinst[iInst].pfTxBuffer,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);

    DuplicateHandle(hProcessBackground,
            pvcr->Port[iPort].fTxReady,
            GetCurrentProcess(), 
            &pinst[iInst].pfTxReady,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);

    CloseHandle(hProcessBackground);
#endif
    pinst[iInst].fPortHandles = TRUE;

    DPF(DBG_TASK, "DuplicatePortHandles to port index %u Ok!\n", iPort);
    return TRUE;
}


/*
 * Create handles needed to serialize access to background task.
 */
BOOL FAR PASCAL CreateGlobalHandles(DWORD pidBackground)
{
#ifdef _WIN32
    pvcr->gfTaskLock        = CreateMutex(NULL,
                                    FALSE,    // I do not want immediate ownership.
                                    NULL);    // No name

    pvcr->gfTaskWorkDone    = CreateEvent(NULL,
                                    FALSE,    // False measn not-manual! This is auto!
                                    FALSE,    // Set to non-signalled state. 
                                    NULL);    // No name
#else 
    // These are globals. Not devices.
    pvcr->gfTaskLock        = TRUE;
    pvcr->gfTaskWorkDone    = TRUE;
#endif

    DPF(DBG_TASK, "CreateGlobalHandles Ok! \n");
    return TRUE;
}
/*
 * Close handles needed to serialize access to background task.
 */
BOOL FAR PASCAL CloseGlobalHandles(DWORD pidBackground)
{
#ifdef _WIN32
    CloseHandle(pvcr->gfTaskLock);
    CloseHandle(pvcr->gfTaskWorkDone);
#endif
    DPF(DBG_TASK, "CloseGlobalHandles Ok! \n");
    return TRUE;
}


/*
 * Duplicate handles to instance, needed to serialize access to background task.
 */
BOOL FAR PASCAL DuplicateGlobalHandlesToInstance(DWORD pidBackground, int iInst)
{
#ifdef _WIN32
    HANDLE hProcessBackground;

    hProcessBackground = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pidBackground); // iInst has pid.

    DuplicateHandle(hProcessBackground,
            pvcr->gfTaskLock,
            GetCurrentProcess(), 
            &pinst[iInst].pfTaskLock,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);

    DuplicateHandle(hProcessBackground,
            pvcr->gfTaskWorkDone,
            GetCurrentProcess(), 
            &pinst[iInst].pfTaskWorkDone,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);

    CloseHandle(hProcessBackground);
#else
    pinst[iInst].pfTaskLock = &pvcr->gfTaskLock;
#endif
    pinst[iInst].fGlobalHandles = TRUE;
    DPF(DBG_TASK, "DuplicateGlobalHandles Ok! \n");
    return TRUE;
}

BOOL FAR PASCAL CloseAllInstanceHandles(int iInst)
{
    // If it is pf mean pointer, we do not own it.
    // f means handle that we do own.
#ifdef _WIN32    
    if(pinst[iInst].fGlobalHandles)
    {
        CloseHandle(pinst[iInst].pfTaskLock  );
        CloseHandle(pinst[iInst].pfTaskWorkDone);
        pinst[iInst].fGlobalHandles = FALSE;
    }

    if(pinst[iInst].fPortHandles)
    {
        CloseHandle(pinst[iInst].pfTxReady   );
        CloseHandle(pinst[iInst].pfTxBuffer  );
        pinst[iInst].fPortHandles = FALSE;
    }

    if(pinst[iInst].fDeviceHandles)
    {

        CloseHandle(pinst[iInst].pfTxLock    );
        CloseHandle(pinst[iInst].pfQueueLock );
        CloseHandle(pinst[iInst].pfTransportFree );
        CloseHandle(pinst[iInst].pfDeviceLock );
        CloseHandle(pinst[iInst].pfAutoCompletion );
        CloseHandle(pinst[iInst].pfAutoAck);
        pinst[iInst].fDeviceHandles = FALSE;
    }

    CloseHandle(pinst[iInst].fCompletionEvent);
    CloseHandle(pinst[iInst].fAckEvent);
#endif
    return TRUE;
}

/*
 * Carry out a command in the background task.
 */
static void NEAR PASCAL TaskDoCommand(UINT uTaskState, DWORD lParam)
{
    UINT iPort, iDev;
#ifdef _WIN32
    DWORD ThreadId;
    pvcr->lParam = lParam;
#endif

    // Port is in the loword and device is in the highword.
    iPort  = (UINT) ((pvcr->lParam & 0x0000ffff));
    iDev   = (UINT) ((pvcr->lParam >> 16) & 0x0000ffff);

    switch(uTaskState)
    {
        case TASKOPENCOMM: //Open comm will have a device of 0 anyway.
            DPF(DBG_TASK, "TASKOPENCOMM message received.\n");

#ifdef _WIN32
            //
            // Create the semaphores and open the port.
            //
            pvcr->Port[iPort - 1].idComDev = viscaCommPortSetup(iPort);
            pvcr->Port[iPort - 1].fOk = TRUE;
            //
            // Create threads to handle transmission and recption.
            //
            pvcr->Port[iPort - 1].hRxThread = CreateThread(NULL,// Security.
                        4096,              // Use default stack size.
                        (LPTHREAD_START_ROUTINE) RxThread,       // Function thread executes.
                        (LPVOID)iPort,
                        0,              // Creation flag.
                        &ThreadId);     // Returns thread id.

            pvcr->Port[iPort - 1].hTxThread = CreateThread(NULL,// Security.
                        4096,              // Use default stack size.
                        (LPTHREAD_START_ROUTINE)TxThread,       // Function thread executes.
                        (LPVOID)iPort,   //
                        0,              // Creation flag.
                        &ThreadId);     // Returns thread id.


            DPF(DBG_TASK, "Opening comm in commtask now............................\n");
            if (pvcr->Port[iPort - 1].idComDev < 0)
            {
               DPF(DBG_ERROR, "Could not open comm port.. Die or something!\n");
            }
            SetEvent(pvcr->gfTaskWorkDone);
#else
            if(!pvcr->fConfigure)
                _fmemset(&pvcr->Port[iPort - 1], '\0', sizeof(PortEntry));

            pvcr->Port[iPort - 1].idComDev = viscaCommPortSetup(iPort);

            if (pvcr->Port[iPort - 1].idComDev < 0)
            {
                DPF(DBG_ERROR, "Could not open comm port.. Die or something!\n");
            }
#endif
            break;

        case TASKCLOSECOMM:
            DPF(DBG_TASK, "TASKCLOSECOMM message received.\n");
#ifdef _WIN32
            //
            // We must kill the threads first!
            //
            pvcr->Port[iPort - 1].fOk      = FALSE; // Kills the threads.

            if(!SetEvent(OWNED(pvcr->Port[iPort - 1].fTxReady)))
            {
                DPF(DBG_ERROR, "Unable to signal TxThread to close.\n");
            }

            //
            // Wait for threads to exit. Before closing port, otherwise who knows?
            //
            WaitForSingleObject(pvcr->Port[iPort - 1].hRxThread, MY_INFINITE);
            WaitForSingleObject(pvcr->Port[iPort - 1].hTxThread, MY_INFINITE);

            // All handles are closed, so background task must exit NOW!
            viscaCommPortClose(pvcr->Port[iPort - 1].idComDev, iPort);
 
            CloseHandle(pvcr->Port[iPort - 1].hRxThread);
            CloseHandle(pvcr->Port[iPort - 1].hTxThread);

            ClosePortHandles(pvcr->htaskCommNotifyHandler, iPort - 1);
            pvcr->uTaskState = TASKIDLE;
            DPF(DBG_TASK, "Closing comm in commtask now............................\n");
            //
            // Can't set it to -1 until we are sure it is dead.
            //
            SetEvent(pvcr->gfTaskWorkDone);
#else

            viscaCommPortClose(pvcr->Port[iPort - 1].idComDev, iPort);
            pvcr->Port[iPort - 1].idComDev = -1;
            DPF(DBG_COMM, "Closing comm in commtask now............................\n");
#endif
            break;

        case TASKCLOSE:
            DPF(DBG_TASK, "TASKCLOSE message received.\n");
#ifdef _WIN32
            pvcr->hwndCommNotifyHandler = NULL;
            PostQuitMessage(0);
            //
            // This is the only place we use the global variable! Because the inst handle is dead.
            //
            pvcr->uTaskState = TASKIDLE;  // We are done processing one message.
            return;
#else
            if (pvcr->hwndCommNotifyHandler)
            {
                DestroyWindow(pvcr->hwndCommNotifyHandler);
                pvcr->hwndCommNotifyHandler = NULL;
            }
            UnregisterClass(szCommNotifyHandlerClassName, hModuleInstance);
            CloseGlobalHandles(pvcr->htaskCommNotifyHandler);
            pvcr->htaskCommNotifyHandler = NULL;
            pvcr->uTaskState = 0;
#endif
            break;

        case TASKOPENDEVICE:
            CreateDeviceHandles(pvcr->htaskCommNotifyHandler, iPort, iDev);
#ifdef _WIN32
            SetEvent(pvcr->gfTaskWorkDone);
#endif
            break;

        case TASKCLOSEDEVICE:
            CloseDeviceHandles(pvcr->htaskCommNotifyHandler, iPort, iDev);
#ifdef _WIN32
            SetEvent(pvcr->gfTaskWorkDone);
#endif
            break;

// This function is only needed in the win32 version.
        case TASKPUNCHCLOCK:
#ifdef _WIN32
            EscapeCommFunction(pvcr->Port[iPort - 1].idComDev, CLRDTR);
            Sleep(2L); // Must be at least 1 millisecond long.
            EscapeCommFunction(pvcr->Port[iPort - 1].idComDev, SETDTR);
            SetEvent(pvcr->gfTaskWorkDone);
#endif
            break;

    }

   return;
}


/****************************************************************************
 * Function: void   viscaTaskCommNotifyHandlerProc - Function for background task.
 *
 * Parameters:
 *
 *      DWORD  dwInstData    - Instance specific data.  Not used.
 *
 ***************************************************************************/
void FAR PASCAL LOADDS
    viscaTaskCommNotifyHandlerProc(DWORD dwInstData)
{
    pvcr->htaskCommNotifyHandler = MGetCurrentTask(); // All other process can access this.

    if (pvcr->hwndCommNotifyHandler == (HWND)NULL)
    {
        WNDCLASS    wc;

        wc.style = 0;
        wc.lpfnWndProc      = viscaCommHandlerWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = hModuleInstance;
        wc.hIcon            = NULL;
        wc.hCursor          = NULL;
        wc.hbrBackground    = NULL;
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = szCommNotifyHandlerClassName;
        if (!RegisterClass(&wc))
        {
            DPF(DBG_ERROR, " Couldn't RegisterClass()\n");
            pvcr->htaskCommNotifyHandler = (VISCAHTASK)NULL;
            pvcr->uTaskState = 0;
            return;
        }
        pvcr->hwndCommNotifyHandler = CreateWindow(szCommNotifyHandlerClassName,
                                             TEXT("ViSCA CommNotify Handler"),
                                             0L, 0, 0, 0, 0,
                                             HWND_DESKTOP, NULL,
                                             hModuleInstance, NULL);
        if (!pvcr->hwndCommNotifyHandler)
        {
            DPF(DBG_ERROR, "Couldn't CreateWindow()\n");
            pvcr->htaskCommNotifyHandler =  (VISCAHTASK)NULL;
            pvcr->uTaskState = 0;
            return;
        }
    }

    if(pvcr->htaskCommNotifyHandler == (VISCAHTASK)NULL)
        return;
    //
    // All global semaphores are created by the background task and then
    // must be dupped into each instance. This is both versions!
    //
    CreateGlobalHandles(pvcr->htaskCommNotifyHandler);
    pvcr->uTaskState = TASKIDLE;
#ifdef _WIN32
    // In Win32 the when we return from this the process in msmcivcr.exe will go 
    // into it's idle loop and dispatch messages to the windows.
    return;
#else
    while (pvcr->htaskCommNotifyHandler != (VISCAHTASK)NULL)
    {
        // Block until task is needed.
        pvcr->uTaskState = TASKIDLE;
        while (pvcr->uTaskState == TASKIDLE)
        {
            // GetMsg() ;  Translate() ; Dispatch() ; all happens below!
            mmTaskBlock(pvcr->htaskCommNotifyHandler);
        }
        TaskDoCommand(pvcr->uTaskState, pvcr->lParam);
    }
#endif

}

/****************************************************************************
 * Function: BOOL   viscaTaskCreate - Create background task.
 *
 * Returns: TRUE if successful, otherwise FLASE.
 *
 ***************************************************************************/
BOOL FAR PASCAL
    viscaTaskCreate(void)
{
#ifdef _WIN32
    // Cannot unlock a semaphore that doesn't exist yet.  The background task must
    // create the global semaphores after it starts.
    BOOL fSuccess;
    PROCESS_INFORMATION ProcessInformation;
    STARTUPINFO    sui;

    /* set up the STARTUPINFO structure,
     *  then call CreateProcess to try and start the new exe.
     */
    sui.cb               = sizeof (STARTUPINFO);
    sui.lpReserved       = 0;
    sui.lpDesktop        = NULL;
    sui.lpTitle          = NULL;
    sui.dwX              = 0;
    sui.dwY              = 0;
    sui.dwXSize          = 0;
    sui.dwYSize          = 0;
    sui.dwXCountChars    = 0;
    sui.dwYCountChars    = 0;
    sui.dwFillAttribute  = 0;
    sui.dwFlags          = 0;
    sui.wShowWindow      = 0;
    sui.cbReserved2      = 0;
    sui.lpReserved2      = 0;


    // Create a real process! This process will in turn call CommNotifyHandlerProc to 

    fSuccess = CreateProcess(
        NULL,               // executable image.
        TEXT("msmcivcr.exe"),    // no command line.
        NULL,               // process attr.
        NULL,               // security attr.
        FALSE,              // Process inherit handles??
        NORMAL_PRIORITY_CLASS,   // Creation flags.
        NULL,               // Environment.
        NULL,               // New current directory.
        &sui,               // We have no main window.
        &ProcessInformation);
    //
    // Some arbitrary foreground task is creating this, be sure to close
    // the handles so it is not owned by parent.
    //

    if(fSuccess)
    {
        CloseHandle(ProcessInformation.hThread);
        CloseHandle(ProcessInformation.hProcess);
        DPF(DBG_TASK, "Background process is running.\n");
    }
    else
    {
        DPF(DBG_ERROR, "Background process has died in TaskCreate.\n");
    }

    //
    // We want to wait until the events, window, etc., is created and is dispatching messages.
    //
    while(pvcr->uTaskState != TASKIDLE)
        Sleep(200);

    DPF(DBG_TASK, "Background process has set uTaskState to idle.\n");
    return TRUE;
#else
    viscaReleaseMutex(&pvcr->gfTaskLock);

    // Create background task which will create a window to receive
    // comm port notifications.
    switch (mmTaskCreate((LPTASKCALLBACK)viscaTaskCommNotifyHandlerProc, NULL, 0L))
    {
        case 0:
            // Yield to the newly created task until it has
            // had a chance to initialize or fail to initialize
            while (pvcr->uTaskState == TASKINIT)
            {
                Yield();
            }
            if (!IsTask(pvcr->htaskCommNotifyHandler))
            {
                return (FALSE);
            }
            return (TRUE);
        
        case TASKERR_NOTASKSUPPORT:
        case TASKERR_OUTOFMEMORY:
        default:
            return (FALSE);
    }
#endif
}


/****************************************************************************
 * Function: LRESULT viscaTaskIsRunning - Check if background task is running.
 *
 * Returns: TRUE if background task is running, otherwise FLASE.
 ***************************************************************************/
BOOL FAR PASCAL
    viscaTaskIsRunning(void)
{
    return (pvcr->htaskCommNotifyHandler != (VISCAHTASK)NULL);
}


/****************************************************************************
 * Function: BOOL viscaTaskDestroy - Destroy background task.
 *
 * Returns: TRUE if successful, otherwise FLASE.
 ***************************************************************************/
BOOL FAR PASCAL
    viscaTaskDestroy(void)
{
#ifdef _WIN32
    //
    // We don't need to close the window or unregister class, because it will
    // die when the process dies.
    //
    DPF(DBG_TASK, "Destroying the task now.\n");

    //
    // No need to lock here!
    //
    if(pvcr->uTaskState != TASKIDLE)
    {
        DPF(DBG_ERROR, "---Major Problem! This cannot happen. Task is not idle...\n");
    }

    pvcr->uTaskState = TASKCLOSE;

    if(!PostMessage(pvcr->hwndCommNotifyHandler, (UINT) WM_USER, (WPARAM)TASKCLOSE, (LPARAM)0))
    {
        DPF(DBG_ERROR, "PostMessage to window has failed.");
    }

    DPF(DBG_TASK, "Waiting for pvcr->uTaskState to go idle.\n");

    while(pvcr->uTaskState != TASKIDLE)
    {
        Yield();
        Sleep(50);
    }
    pvcr->htaskCommNotifyHandler = 0L;
    DPF(DBG_TASK, "Destroyed the task.\n");
    return TRUE;
#else
    if (pvcr->htaskCommNotifyHandler)
    {
        pvcr->uTaskState = TASKCLOSE;
        // This PostApp is the same as mmTaskSignal
        PostAppMessage(pvcr->htaskCommNotifyHandler, WM_USER, 0, 0L);
        Yield();
        while (IsTask(pvcr->htaskCommNotifyHandler))
        {
            Yield();
        }
        return (TRUE);
    }
    else
    {
        return (FALSE);
    }
#endif
}


/****************************************************************************
 * Function: BOOL viscaSetCommandComplete - called when a command completes.
 *
 * Parameters:
 *
 *      int iInst  - Instance that started this command.
 *
 *      UINT  uViscaCmd - visca command being completed.
 *
 *       This function is used to change variables which describe the
 *  state of the device. Hence, they are only set on successful completion
 *  of the command in question.
 *
 * Returns: TRUE
 *
 ***************************************************************************/
static BOOL NEAR PASCAL
    viscaSetCommandComplete(UINT iPort, UINT iDev, UINT uViscaCmd)
{
    //
    // This function only is called if the function completes succesful.
    // And only for transport, which means only from commtask.c
    //
    if(uViscaCmd == VISCA_FREEZE)
        pvcr->Port[iPort].Dev[iDev].fFrozen = TRUE;

    if(uViscaCmd == VISCA_UNFREEZE)
        pvcr->Port[iPort].Dev[iDev].fFrozen = FALSE;

    if(uViscaCmd == VISCA_MODESET_OUTPUT)
        pvcr->Port[iPort].Dev[iDev].dwFreezeMode = MCI_VCR_FREEZE_OUTPUT;

    if(uViscaCmd == VISCA_MODESET_INPUT)
        pvcr->Port[iPort].Dev[iDev].dwFreezeMode = MCI_VCR_FREEZE_INPUT;

    if(uViscaCmd == VISCA_MODESET_FIELD)
        pvcr->Port[iPort].Dev[iDev].fField = TRUE;

    if(uViscaCmd == VISCA_MODESET_FRAME)
        pvcr->Port[iPort].Dev[iDev].fField = FALSE;

    //
    // Version 1.0 VISCA ROM's for CVD-1000, must wait 1/60th after search.
    // 
    if((uViscaCmd == VISCA_SEEK) &&
      ((pvcr->Port[iPort].Dev[iDev].uModelID == VISCADEVICEVENDORSONY) &&
       (pvcr->Port[iPort].Dev[iDev].uVendorID == VISCADEVICEMODELCVD1000)))
    {
        DWORD dwTime;
        DWORD dwStart = GetTickCount();

        while(1)
        {
            dwTime = GetTickCount();
            if (((dwTime < dwStart) && ((dwTime + (ROLLOVER - dwStart)) > 20)) ||
                ((dwTime - dwStart) > 20))
                break;
        }
    }
 
    return TRUE;
}

/****************************************************************************
 * Function: BOOL TaskDo - Get the background task to do some work for the foreground task.
 *
 * Parameters:
 *
 *      UINT uDo    - What to do? TASKCOMMOPEN or TASKCOMMCLOSE.
 *
 *      UINT uInfo  - Which commport to open or close.
 *
 *       This is actually a foreground process, and should be in mcicmds.c
 *
 * Returns: TRUE
 *
 ***************************************************************************/
BOOL FAR PASCAL
    viscaTaskDo(int iInst, UINT uDo, UINT uInfo, UINT uMoreInfo)
{
    DWORD lParam;
    //
    // Lock the task.
    //
    DPF(DBG_TASK, "Waiting for task lock.\n");
    viscaWaitForSingleObject(pinst[iInst].pfTaskLock, FALSE, 10000L, 0);  // Or we could wait for unlock.

    if(pvcr->uTaskState != TASKIDLE)
    {
        DPF(DBG_ERROR, "---Major Problem! This cannot happen. Task is not idle...\n");
    }
    //
    // The information is passed in a dword lparam.
    //
    lParam = (DWORD)( ((DWORD)uInfo            & 0x0000ffff) |
                     (((DWORD)uMoreInfo << 16) & 0xffff0000) );

#ifdef _WIN32
    if(!PostMessage(pvcr->hwndCommNotifyHandler, (UINT) WM_USER, (WPARAM)uDo, (LPARAM)lParam))
    {
        DPF(DBG_ERROR, "PostMessage has failed.\n");
    }

    DPF(DBG_TASK, "Waiting for background task to finish it's work.\n");

    WaitForSingleObject(pinst[iInst].pfTaskWorkDone, MY_INFINITE);
    viscaReleaseMutex(pinst[iInst].pfTaskLock);   // Release mutex only.
#else
    // uTaskState is just a "next thing to do" flag.  So.
    pvcr->uTaskState = uDo;
    pvcr->lParam     = lParam;

    // Signal the task to go for it.
    mmTaskSignal(pvcr->htaskCommNotifyHandler);

    // Now wait for the state to go back to idle

    while(pvcr->uTaskState != TASKIDLE)
    {
        Yield();
        DPF(DBG_TASK, "Waiting in viscaTaskDo.\n");
    }
    viscaReleaseMutex(&pvcr->gfTaskLock);
#endif

    return TRUE;
}

#ifdef _WIN32
/***************************************************************************
 *
 * RxThread()
 *
 * Read bytes into a buffer until 0xff (eopacket) is read.
 * Call packet process with this packet.
 *
 * Note: Thread per serial port.
 *       Non-blocking.
 *
 * Version 1.0: Non-blocking spin-loop.
 * Version 2.0: Use overlapped i/o to wait for a character to appear without
 *              polling.
 *
 *
 * Ownership: This thread is owned by background task.
 *  So all files-handles are owned by the current running task.
 *
 *
 */
long FAR PASCAL RxThread(LPVOID uPort)
{
    int     iIndex = 0;
    DWORD   dwRead;

    /*
     * Try to read a character.
     * Add char to buffer.
     * If char read was 0xff call packet process.
     *
     * Do it all over again.
     *
     */ 
    DPF(DBG_TASK, "RxThread ALIVE\n");

    while(pvcr->Port[(UINT) uPort - 1].fOk)
    {
        if(ReadFile(pvcr->Port[(UINT)uPort - 1].idComDev, pvcr->Port[(UINT)uPort - 1].achTempRxPacket, 1, &dwRead, NULL))
        {
            if(!pvcr->Port[(UINT)uPort - 1].fOk)
                break;

            if(dwRead > 0)
            {
                if(dwRead > 1)
                {
                    DPF(DBG_ERROR, "RxThread - Read too many chars.\n");
                }

                pvcr->Port[(UINT)uPort - 1].achRxPacket[iIndex] = pvcr->Port[(UINT)uPort - 1].achTempRxPacket[0];
                iIndex++;

                if((BYTE)(pvcr->Port[(UINT)uPort - 1].achTempRxPacket[0]) == (BYTE)0xff)
                {
                    //
                    // We have the entire packet, send it off to be processed.
                    //
                    DPF(DBG_TASK, "RxThread - packet beind sent to PacketProcess\n");
                    viscaPacketProcess((UINT)uPort - 1, pvcr->Port[(UINT)uPort - 1].achRxPacket); // Use shared memory.
                    iIndex = 0;
                }
            }
            else
            {
                Sleep(15);
            }

        }
        else
        {
            DPF(DBG_ERROR, "RxThread, ReadComm has failed.\n");
        }
    }

    DPF(DBG_TASK, "*** Exiting RxThread");
    ExitThread(0);
    return 0;
}

/***************************************************************************
 *
 * TxThread()
 *
 * Pseudo code:
 *
 *      Wait until the Transmit event is set.
 *      Read from the appropriate static spot.
 *      Do it all over again.
 *
 * Note: Thread per serial port.
 *       Non-blocking.
 *
 * Version 1.0: Non-blocking spin-loop.
 * Version 2.0: Use overlapped i/o to wait for a character to appear without
 *              polling.
 *
 *
 * Ownership: This thread is owned by background task.
 *
 */
long FAR PASCAL TxThread(LPVOID uPort)
{
    DWORD  nBytesWritten;

    DPF(DBG_TASK, "TxThread ALIVE\n");

    while(pvcr->Port[(UINT)uPort - 1].fOk)
    {
        DPF(DBG_TASK, "TxThread - Waiting for TxReady to be set. port index %u\n", (UINT)uPort - 1);

        if(WAIT_FAILED == WaitForSingleObject(pvcr->Port[(UINT)uPort - 1].fTxReady, MY_INFINITE))
        {
            DPF(DBG_ERROR, "TxThread - WaitFor fTxReady failed.\n");
        }

        //
        // We must be signalled to let use go and die.
        //
        if(!pvcr->Port[(UINT)uPort - 1].fOk)
            break;

        DPF(DBG_TASK, "Okay transmitting now.\n");

        // Read from static location.
        if(!WriteFile(pvcr->Port[(UINT)uPort - 1].idComDev,
            pvcr->Port[(UINT)uPort-1].achTxPacket,
            pvcr->Port[(UINT)uPort-1].nchTxPacket,
            &nBytesWritten,
            NULL))
        {
            DPF(DBG_ERROR, "TxThread - WriteFile failed.");
        }

        if(nBytesWritten != pvcr->Port[(UINT)uPort-1].nchTxPacket)
        {
            DPF(DBG_TASK, " TxThread: Error - tried %u, wrote %u ", pvcr->Port[(UINT)uPort-1].nchTxPacket, nBytesWritten);
        }

        if(!SetEvent(pvcr->Port[(UINT)uPort-1].fTxBuffer))
        {
            DPF(DBG_ERROR, "TxThread SetEvent fTxBuffer failed.\n");
        }
    }

    DPF(DBG_TASK, "*** Exiting TxThread");
    ExitThread(0);
    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mcivisca\mcivisca\libinit.asm ===
page	,132
;-----------------------------Module-Header-----------------------------;
;
;   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
;   KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
;   IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
;   PURPOSE.
;
;   Copyright (c) 1992-1995 Microsoft Corporation
;
;
;   Module Name:  LIBINIT.ASM
;
;   library stub to do local init for a Dynamic linked library
;
;   Exported Functions:   none
;
;   Public Functions:     none
;
;   Public Data:		none
;
;   General Description:
;
;   Restrictions:
;
;       This must be the first object file in the LINK line, this assures
;       that the reserved parameter block is at the *base* of DGROUP
;
;-----------------------------------------------------------------------;

?PLM=1      ; PASCAL Calling convention is DEFAULT
?WIN=1	    ; Windows calling convention

        .286
	.xlist
	include cmacros.inc
;       include windows.inc
        .list

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

;-----------------------------------------------------------------------;
;
;   externs from KERNEL
;
        externFP    <LocalInit>
        externFP    <FatalAppExit>

;-----------------------------------------------------------------------;
;
;   LibMain is the function in C code we will call on a DLL load.
;   it is assumed in the same segment as we are.
;
;;;;;;;;externNP    <LibMain>
        externFP    <LibMain>  ;; Use this line if LibMain is far call

;-----------------------------------------------------------------------;
;
; Stuff needed to avoid the C runtime coming in, and init the windows
; reserved parameter block at the base of DGROUP
;
sBegin  Data
assumes DS,Data
            org 0               ; base of DATA segment!

            DD  0               ; So null pointers get 0
maxRsrvPtrs = 5
            DW  maxRsrvPtrs
usedRsrvPtrs = 0
labelDP     <PUBLIC,rsrvptrs>

DefRsrvPtr  MACRO   name
globalW     name,0
usedRsrvPtrs = usedRsrvPtrs + 1
ENDM

DefRsrvPtr  pLocalHeap          ; Local heap pointer
DefRsrvPtr  pAtomTable          ; Atom table pointer
DefRsrvPtr  pStackTop           ; top of stack
DefRsrvPtr  pStackMin           ; minimum value of SP
DefRsrvPtr  pStackBot           ; bottom of stack

if maxRsrvPtrs-usedRsrvPtrs
            DW maxRsrvPtrs-usedRsrvPtrs DUP (0)
endif

public  __acrtused
	__acrtused = 1

sEnd        Data

;-----------------------------------------------------------------------;

sBegin  CodeSeg
        assumes cs,CodeSeg

;--------------------------Private-Routine-----------------------------;
;
; LibEntry - called when DLL is loaded
;
; Entry:
;       CX    = size of heap
;       DI    = module handle
;       DS    = automatic data segment
;       ES:SI = address of command line (not used by a DLL)
;
; Returns:
;       AX = TRUE if success
; Error Returns:
;       AX = FALSE if error (ie fail load process)
; Registers Preserved:
;	SI,DI,DS,BP
; Registers Destroyed:
;       AX,BX,CX,DX,ES,FLAGS
; Calls:
;	None
; History:
;
;       06-27-89    Created.
;-----------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

cProc   LibEntry,<FAR,PUBLIC,NODATA>,<>
cBegin
ifdef DEBUG
        ;
        ; if this module is not linked first the reserved parameter block
        ; will not be initialized correctly, check for this and
        ;
        lea     ax,pLocalHeap
        cmp     ax,6
        je      RsrvPtrsOk

RsrvPtrsHosed:
        int     3

        lea     ax,RsrvPtrsMsg
        cCall   FatalAppExit,<0,cs,ax>
        jmp short    RsrvPtrsOk

RsrvPtrsMsg:
        db      'RsrvPtrs hosed!',0

RsrvPtrsOk:
endif
	;
        ; Push frame for LibMain (hModule,cbHeap,lpszCmdLine)
	;
	push	di
	push	cx
	push	es
	push	si

        ;
        ; Init the local heap (if one is declared in the .def file)
        ;
        jcxz no_heap

        cCall   LocalInit,<0,0,cx>

no_heap:
        cCall   LibMain
cEnd

;--------------------------Exported-Routine-----------------------------;
;
;   WEP()
;
;   called when the DLL is unloaded, it is passed 1 WORD parameter that
;   is TRUE if the system is going down, or zero if the app is
;
;   WARNING:
;
;       This function is basicly useless, you cant can any kernel function
;       that may cause the LoadModule() code to be reentered..
;
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   WEP,<FAR,PUBLIC,NODATA>,<>
        ParmW  BogusParameter
cBegin
cEnd

sEnd    CodeSeg

        end     LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mcivisca\mcivisca\muldiv.asm ===
page    ,132
;---------------------------Module-Header-------------------------------;
;
;   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
;   KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
;   IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
;   PURPOSE.
;
;   Copyright (c) 1992-1995 Microsoft Corporation
;
;   Module Name: MULDIV.ASM
;
;   Contains FIXED point math routines.
;
;-----------------------------------------------------------------------;

?WIN	= 0
?PLM	= 1
?NODATA = 0

        .286

        .xlist
        include cmacros.inc
        include windows.inc
        .list

        externA     __WinFlags

UQUAD   struc
uq0     dw      ?
uq1     dw      ?
uq2     dw      ?
uq3     dw      ?
UQUAD	ends

;       The following two equates are just used as shorthand
;       for the "word ptr" and "byte ptr" overrides.

wptr    equ     word ptr
bptr    equ     byte ptr

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

EAXtoDXAX   macro
        shld    edx,eax,16      ; move HIWORD(eax) to dx
        endm

DXAXtoEAX   macro
        ror     eax,16          ; xchg HIWORD(eax) and LOWORD(eax)
        shrd    eax,edx,16      ; move LOWORD(edx) to HIWORD(eax)
        endm

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
        assumes cs,CodeSeg
	assumes ds,nothing
        assumes es,nothing

;---------------------------Public-Routine------------------------------;
; muldiv32
;
; multiples two 32 bit values and then divides the result by a third
; 32 bit value with full 64 bit presision
;
; ulResult = (ulNumber * ulNumerator) / ulDenominator
;
; Entry:
;       dwNumber = number to multiply by nNumerator
;       dwNumerator = number to multiply by nNumber
;       dwDenominator = number to divide the multiplication result by.
;   
; Returns:
;       DX:AX = result of multiplication and division.
; Error Returns:
;       none
; Registers Preserved:
;       DS,ES,SI,DI
; History:
;   Wed 14-June-1990 converted it to 386/286 code. (by checking __WinFlags)
;   Tue 08-May-1990  Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   muldiv32,<PUBLIC,FAR,NODATA,NONWIN>,<>
;       ParmD  ulNumber
;       ParmD  ulNumerator
;       ParmD  ulDenominator
cBegin	<nogen>
	mov	ax,__WinFlags
        test    ax,WF_CPU286+WF_CPU086+WF_CPU186
        jnz     muldiv32_286
        errn$   muldiv32_386
cEnd    <nogen>

cProc   muldiv32_386,<PUBLIC,FAR,NODATA,NONWIN>,<>
;       ParmD  ulNumber
;       ParmD  ulNumerator
;       ParmD  ulDenominator
cBegin  nogen
        .386
        pop     ecx     ; return address
        pop     ebx     ; ulDenominator
        pop     edx     ; ulNumerator
        pop     eax     ; ulNumber

        imul    edx     ; edx:eax = (ulNumber * ulNumerator)
        idiv    ebx     ; eax     = (ulNumber * ulNumerator) / ulDenominator

        EAXtoDXAX       ; covert eax to dx:ax for 16 bit programs

        push    ecx     ; return
        retf

        .286
cEnd    nogen

cProc   muldiv32_286,<PUBLIC,FAR,NODATA,NONWIN>,<di,si>
        ParmD  ulNumber
        ParmD  ulNumerator
        ParmD  ulDenominator
cBegin
        mov     ax,ulNumber.lo
        mov     dx,ulNumber.hi

        mov     bx,ulNumerator.lo
        mov     cx,ulNumerator.hi

        call    dmul

        mov     di,ulDenominator.lo
        mov     si,ulDenominator.hi

        call    qdiv
cEnd

;---------------------------Public-Routine------------------------------;
; idmul
;
; This is an extended precision multiply routine, intended to emulate
; 80386 imul instruction.
;
; Entry:
;       DX:AX = LONG
;       CX:BX = LONG
; Returns:
;       DX:CX:BX:AX = QUAD product
; Registers Destroyed:
;       none
; History:
;  Tue 26-Jan-1988 23:47:02  Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   idmul,<PUBLIC,NEAR>,<si,di>
        localQ  qTemp
cBegin

; put one argument in safe registers

        mov     si,dx
        mov     di,ax

; do the low order unsigned product

        mul     bx
        mov     qTemp.uq0,ax
        mov     qTemp.uq1,dx

; do the high order signed product

        mov     ax,si
        imul    cx
        mov     qTemp.uq2,ax
        mov     qTemp.uq3,dx

; do a mixed product

        mov     ax,si
        cwd
        and     dx,bx
        sub     qTemp.uq2,dx            ; adjust for sign bit
        sbb     qTemp.uq3,0
        mul     bx
        add     qTemp.uq1,ax
        adc     qTemp.uq2,dx
        adc     qTemp.uq3,0

; do the other mixed product

        mov     ax,cx
        cwd
	and	dx,di
        sub     qTemp.uq2,dx
        sbb     qTemp.uq3,0
        mul     di

; pick up the answer

        mov     bx,ax
        mov     cx,dx
        xor     dx,dx

        mov     ax,qTemp.uq0
        add     bx,qTemp.uq1
        adc     cx,qTemp.uq2
        adc     dx,qTemp.uq3
cEnd

;---------------------------Public-Routine------------------------------;
; dmul
;
; This is an extended precision multiply routine, intended to emulate
; 80386 mul instruction.
;
; Entry:
;       DX:AX = LONG
;       CX:BX = LONG
; Returns:
;       DX:CX:BX:AX = QUAD product
; Registers Destroyed:
;       none
; History:
;  Tue 02-Feb-1988 10:50:44  Copied from idmul and modified.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   dmul,<PUBLIC,NEAR>,<si,di>
        localQ  qTemp
cBegin

; put one argument in safe registers

        mov     si,dx
        mov     di,ax

; do the low order product

        mul     bx
        mov     qTemp.uq0,ax
        mov     qTemp.uq1,dx

; do the high order product

        mov     ax,si
        mul     cx
        mov     qTemp.uq2,ax
        mov     qTemp.uq3,dx

; do a mixed product

        mov     ax,si
        mul     bx
        add     qTemp.uq1,ax
        adc     qTemp.uq2,dx
        adc     qTemp.uq3,0

; do the other mixed product

        mov     ax,cx
        mul     di

; pick up the answer

        mov     bx,ax
        mov     cx,dx
        xor     dx,dx
        mov     ax,qTemp.uq0
        add     bx,qTemp.uq1
        adc     cx,qTemp.uq2
        adc     dx,qTemp.uq3
cEnd

;---------------------------Public-Routine------------------------------;
; iqdiv
;
; This is an extended precision divide routine which is intended to
; emulate the 80386 64 bit/32 bit IDIV instruction.  We don't have the
; 32 bit registers to work with, but we pack the arguments and results
; into what registers we do have.  We will divide two signed numbers
; and return the quotient and remainder.  We will do INT 0 for overflow,
; just like the 80386 microcode.  This should ease conversion later.
;
; This routine just keeps track of the signs and calls qdiv to do the
; real work.
;
; Entry:
;       DX:CX:BX:AX = QUAD Numerator
;       SI:DI       = LONG Denominator
; Returns:
;       DX:AX = quotient
;       CX:BX = remainder
; Registers Destroyed:
;       DI,SI
; History:
;  Tue 26-Jan-1988 02:49:19  Wrote it.
;-----------------------------------------------------------------------;

WIMP    equ     1

IQDIV_RESULT_SIGN       equ     1
IQDIV_REM_SIGN          equ     2

        assumes ds,nothing
        assumes es,nothing

cProc   iqdiv,<PUBLIC,NEAR>
        localB  flags
cBegin
        mov     flags,0

; take the absolute value of the denominator

        or      si,si
        jns     denominator_is_cool
        xor     flags,IQDIV_RESULT_SIGN
        neg     di
        adc     si,0
        neg     si
denominator_is_cool:

; take the absolute value of the denominator

        or      dx,dx
        jns     numerator_is_cool
        xor     flags,IQDIV_RESULT_SIGN + IQDIV_REM_SIGN
        not     ax
        not     bx
        not     cx
        not     dx
        add     ax,1
        adc     bx,0
        adc     cx,0
        adc     dx,0
numerator_is_cool:

; do the unsigned division

        call    qdiv
ifdef WIMP
        jo      iqdiv_exit
endif

; check for overflow

        or      dx,dx
        jns     have_a_bit_to_spare
ifdef WIMP
        mov     ax,8000h
        dec     ah
        jmp     short iqdiv_exit
else
        int     0                       ; You're toast, Jack!
endif
have_a_bit_to_spare:

; negate the result, if required

        test    flags,IQDIV_RESULT_SIGN
        jz      result_is_done
        neg     ax
        adc     dx,0
        neg     dx
result_is_done:

; negate the remainder, if required

        test    flags,IQDIV_REM_SIGN
        jz      remainder_is_done
        neg     bx
        adc     cx,0
        neg     cx
remainder_is_done:
iqdiv_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; qdiv
;
; This is an extended precision divide routine which is intended to
; emulate the 80386 64 bit/32 bit DIV instruction.  We don't have the
; 32 bit registers to work with, but we pack the arguments and results
; into what registers we do have.  We will divide two unsigned numbers
; and return the quotient and remainder.  We will do INT 0 for overflow,
; just like the 80386 microcode.  This should ease conversion later.
;
; Entry:
;       DX:CX:BX:AX = UQUAD Numerator
;       SI:DI       = ULONG Denominator
; Returns:
;       DX:AX = quotient
;       CX:BX = remainder
; Registers Destroyed:
;       none
; History:
;  Tue 26-Jan-1988 00:02:09 Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   qdiv,<PUBLIC,NEAR>,<si,di>
        localQ  uqNumerator
        localD  ulDenominator
        localD  ulQuotient
        localW  cShift
cBegin

; stuff the quad word into local memory

        mov     uqNumerator.uq0,ax
        mov     uqNumerator.uq1,bx
        mov     uqNumerator.uq2,cx
        mov     uqNumerator.uq3,dx


; check for overflow

qdiv_restart:
        cmp     si,dx
        ja      qdiv_no_overflow
        jb      qdiv_overflow
        cmp     di,cx
        ja      qdiv_no_overflow
qdiv_overflow:
ifdef WIMP
        mov     ax,8000h
        dec     ah
        jmp     qdiv_exit
else
        int     0                       ; You're toast, Jack!
        jmp     qdiv_restart
endif
qdiv_no_overflow:

; check for a zero Numerator

        or      ax,bx
        or      ax,cx
        or      ax,dx
        jz      qdiv_exit_relay         ; quotient = remainder = 0

; handle the special case when the denominator lives in the low word

        or      si,si
        jnz     not_that_special

; calculate (DX=0):CX:BX:uqNumerator.uq0 / (SI=0):DI

        cmp     di,1                    ; separate out the trivial case
        jz      div_by_one
        xchg    dx,cx                   ; CX = remainder.hi = 0
        mov     ax,bx
        div     di
        mov     bx,ax                   ; BX = quotient.hi
        mov     ax,uqNumerator.uq0
        div     di                      ; AX = quotient.lo
        xchg    bx,dx                   ; DX = quotient.hi, BX = remainder.lo
ifdef WIMP
        or      ax,ax           ; clear OF
endif
qdiv_exit_relay:
        jmp     qdiv_exit

; calculate (DX=0):(CX=0):BX:uqNumerator.uq0 / (SI=0):(DI=1)

div_by_one:
        xchg    dx,bx                   ; DX = quotient.hi, BX = remainder.lo = 0
        mov     ax,uqNumerator.uq0      ; AX = quotient.lo
        jmp     qdiv_exit
not_that_special:

; handle the special case when the denominator lives in the high word

        or      di,di
        jnz     not_this_special_either

; calculate DX:CX:BX:uqNumerator.uq0 / SI:(DI=0)

        cmp     si,1                    ; separate out the trivial case
        jz      div_by_10000h
        mov     ax,cx
        div     si
        mov     cx,ax                   ; CX = quotient.hi
        mov     ax,bx
        div     si                      ; AX = quotient.lo
        xchg    cx,dx                   ; DX = quotient.hi, CX = remainder.hi
        mov     bx,uqNumerator.uq0      ; BX = remainder.lo
ifdef WIMP
        or      ax,ax           ; clear OF
endif
        jmp     qdiv_exit

; calculate (DX=0):CX:BX:uqNumerator.uq0 / (SI=1):(DI=0)

div_by_10000h:
        xchg    cx,dx                   ; DX = quotient.hi, CX = remainder.hi = 0
        mov     ax,bx                   ; AX = quotient.lo
        mov     bx,uqNumerator.uq0      ; BX = remainder.lo
        jmp     qdiv_exit
not_this_special_either:

; normalize the denominator

        mov     dx,si
        mov     ax,di
        call    ulNormalize             ; DX:AX = normalized denominator
        mov     cShift,cx               ; CX < 16
        mov     ulDenominator.lo,ax
        mov     ulDenominator.hi,dx


; shift the Numerator by the same amount

        jcxz    numerator_is_shifted
        mov     si,-1
        shl     si,cl
        not     si                      ; SI = mask
        mov     bx,uqNumerator.uq3
        shl     bx,cl
        mov     ax,uqNumerator.uq2
        rol     ax,cl
        mov     di,si
        and     di,ax
        or      bx,di
        mov     uqNumerator.uq3,bx
        xor     ax,di
        mov     bx,uqNumerator.uq1
        rol     bx,cl
        mov     di,si
        and     di,bx
        or      ax,di
        mov     uqNumerator.uq2,ax
        xor     bx,di
        mov     ax,uqNumerator.uq0
        rol     ax,cl
        mov     di,si
        and     di,ax
        or      bx,di
        mov     uqNumerator.uq1,bx
        xor     ax,di
        mov     uqNumerator.uq0,ax
numerator_is_shifted:

; set up registers for division

        mov     dx,uqNumerator.uq3
        mov     ax,uqNumerator.uq2
        mov     di,uqNumerator.uq1
        mov     cx,ulDenominator.hi
        mov     bx,ulDenominator.lo

; check for case when Denominator has only 16 bits

        or      bx,bx
        jnz     must_do_long_division
        div     cx
        mov     si,ax
        mov     ax,uqNumerator.uq1
        div     cx
        xchg    si,dx                   ; DX:AX = quotient
        mov     di,uqNumerator.uq0      ; SI:DI = remainder (shifted)
        jmp     short unshift_remainder
must_do_long_division:

; do the long division, part IZ@NL@%

        cmp     dx,cx                   ; we only know that DX:AX < CX:BX!
        jb      first_division_is_safe
        mov     ulQuotient.hi,0         ; i.e. 10000h, our guess is too big
        mov     si,ax
        sub     si,bx                   ; ... remainder is negative
        jmp     short first_adjuster
first_division_is_safe:
        div     cx
        mov     ulQuotient.hi,ax
        mov     si,dx
        mul     bx                      ; fix remainder for low order term
        sub     di,ax
        sbb     si,dx
        jnc     first_adjuster_done     ; The remainder is UNSIGNED!  We have
first_adjuster:                         ; to use the carry flag to keep track
        dec     ulQuotient.hi           ; of the sign.  The adjuster loop
        add     di,bx                   ; watches for a change to the carry
        adc     si,cx                   ; flag which would indicate a sign
        jnc     first_adjuster          ; change IF we had more bits to keep
first_adjuster_done:                    ; a sign in.

; do the long division, part II

        mov     dx,si
        mov     ax,di
        mov     di,uqNumerator.uq0
        cmp     dx,cx                   ; we only know that DX:AX < CX:BX!
        jb      second_division_is_safe
        mov     ulQuotient.lo,0         ; i.e. 10000h, our guess is too big
        mov     si,ax
        sub     si,bx                   ; ... remainder is negative
        jmp     short second_adjuster
second_division_is_safe:
        div     cx
        mov     ulQuotient.lo,ax
        mov     si,dx
        mul     bx                      ; fix remainder for low order term
        sub     di,ax
        sbb     si,dx
        jnc     second_adjuster_done
second_adjuster:
        dec     ulQuotient.lo
        add     di,bx
        adc     si,cx
        jnc     second_adjuster
second_adjuster_done:
        mov     ax,ulQuotient.lo
        mov     dx,ulQuotient.hi

; unshift the remainder in SI:DI

unshift_remainder:
        mov     cx,cShift
        jcxz    remainder_unshifted
        mov     bx,-1
        shr     bx,cl
        not     bx
        shr     di,cl
        ror     si,cl
        and     bx,si
        or      di,bx
        xor     si,bx
remainder_unshifted:
        mov     cx,si
        mov     bx,di
ifdef WIMP
        or      ax,ax           ; clear OF
endif
qdiv_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; ulNormalize
;
; Normalizes a ULONG so that the highest order bit is 1.  Returns the
; number of shifts done.  Also returns ZF=1 if the ULONG was zero.
;
; Entry:
;       DX:AX = ULONG
; Returns:
;       DX:AX = normalized ULONG
;       CX    = shift count
;       ZF    = 1 if the ULONG is zero, 0 otherwise
; Registers Destroyed:
;       none
; History:
;  Mon 25-Jan-1988 22:07:03  Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   ulNormalize,<PUBLIC,NEAR>
cBegin

; shift by words

        xor     cx,cx
        or      dx,dx
        js      ulNormalize_exit
        jnz     top_word_ok
        xchg    ax,dx
        or      dx,dx
        jz      ulNormalize_exit        ; the zero exit
        mov     cl,16
        js      ulNormalize_exit
top_word_ok:

; shift by bytes

        or      dh,dh
        jnz     top_byte_ok
        xchg    dh,dl
        xchg    dl,ah
        xchg    ah,al
        add     cl,8
        or      dh,dh
        js      ulNormalize_exit
top_byte_ok:

; do the rest by bits

        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
ulNormalize_exit:
cEnd

sEnd   CodeSeg

       end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mcivisca\mcivisca\msmcivcr.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992-1995 Microsoft Corporation
 * 
 *  MSMCIVCR.C
 *
 *  Description:
 *
 *      Runs the background VCR task in NT.
 *
 *  Notes:
 *
 *      WinMain() - calls initialization function, processes message loop
 *
 **************************************************************************/
#define UNICODE

#include <windows.h>    // required for all Windows applications
#include <windowsx.h>

#ifdef DEBUG
#define DOUTSTR(a)  OutputDebugString(a);
#else
#define DOUTSTR(a)  //
#endif

#if !defined(_WIN32)     // Windows 3.x uses a FARPROC for dialogs
#define DLGPROC FARPROC
#endif
#if !defined (APIENTRY) // Windows NT defines APIENTRY, but 3.x doesn't
#define APIENTRY far pascal
#endif

HINSTANCE hInst;          // current instance

/****************************************************************************

    FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPSTR, int)

    PURPOSE: calls initialization function, processes message loop

    COMMENTS:

        Windows recognizes this function by name as the initial entry point
        for the program.  This function calls the application initialization
        routine, if no other instance of the program is running, and always
        calls the instance initialization routine.  It then executes a message
        retrieval and dispatch loop that is the top-level control structure
        for the remainder of execution.  The loop is terminated when a WM_QUIT
        message is received, at which time this function exits the application
        instance by returning the value passed by PostQuitMessage().

        If this function must abort before entering the message loop, it
        returns the conventional value NULL.

****************************************************************************/
int APIENTRY WinMain(
    HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{

    MSG msg;
    HINSTANCE hLibrary;
    FARPROC   lpFunc;

    /* Perform initializations that apply to a specific instance */
    DOUTSTR(L"** ** ** ** ** ** We are in the process...\n")

    hLibrary = LoadLibrary(L"mcivis32.dll"); // It's DLL in NT.

    if(!hLibrary)
    {
        DOUTSTR(L"===Error mcivisca.drv not found.\n")
    }

    lpFunc = GetProcAddress(hLibrary, "viscaTaskCommNotifyHandlerProc");

    if(lpFunc != (FARPROC)NULL)
    {
        (*lpFunc)((DWORD)hInstance);
    }
    else
    {
        DOUTSTR(L"Null function in msmcivcr.exe\n")
    }


    DOUTSTR(L"Going into message loop in msmcivcr.exe.\n")

    /* Acquire and dispatch messages until a WM_QUIT message is received. */

    while (GetMessage(&msg, // message structure
       (HWND)NULL,   // handle of window receiving the message
       0,      // lowest message to examine
       0))     // highest message to examine
    {
        TranslateMessage(&msg); // Translates virtual key codes
        DispatchMessage(&msg);  // Dispatches message to window
    }

    DOUTSTR(L"MsMciVcr.Exe Quitting _Goodbye_ *hei*.\n")

    FreeLibrary(hLibrary);

    return (msg.wParam); // Returns the value from PostQuitMessage

    lpCmdLine; // This will prevent 'unused formal parameter' warnings
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mcivisca\msmcivcr\msmcivcr.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992-1995 Microsoft Corporation
 * 
 *  MSMCIVCR.C
 *
 *  Description:
 *
 *      Runs the background VCR task in NT.
 *
 *  Notes:
 *
 *      WinMain() - calls initialization function, processes message loop
 *
 **************************************************************************/
#define UNICODE

#include <windows.h>    // required for all Windows applications
#include <windowsx.h>

#ifdef DEBUG
#define DOUTSTR(a)  OutputDebugString(a);
#else
#define DOUTSTR(a)  //
#endif

#if !defined(_WIN32)     // Windows 3.x uses a FARPROC for dialogs
#define DLGPROC FARPROC
#endif
#if !defined (APIENTRY) // Windows NT defines APIENTRY, but 3.x doesn't
#define APIENTRY far pascal
#endif

HINSTANCE hInst;          // current instance

/****************************************************************************

    FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPSTR, int)

    PURPOSE: calls initialization function, processes message loop

    COMMENTS:

        Windows recognizes this function by name as the initial entry point
        for the program.  This function calls the application initialization
        routine, if no other instance of the program is running, and always
        calls the instance initialization routine.  It then executes a message
        retrieval and dispatch loop that is the top-level control structure
        for the remainder of execution.  The loop is terminated when a WM_QUIT
        message is received, at which time this function exits the application
        instance by returning the value passed by PostQuitMessage().

        If this function must abort before entering the message loop, it
        returns the conventional value NULL.

****************************************************************************/
int APIENTRY WinMain(
    HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{

    MSG msg;
    HINSTANCE hLibrary;
    FARPROC   lpFunc;

    /* Perform initializations that apply to a specific instance */
    DOUTSTR(L"** ** ** ** ** ** We are in the process...\n")

    hLibrary = LoadLibrary(L"mcivis32.dll"); // It's DLL in NT.

    if(!hLibrary)
    {
        DOUTSTR(L"===Error mcivisca.drv not found.\n")
    }

    lpFunc = GetProcAddress(hLibrary, "viscaTaskCommNotifyHandlerProc");

    if(lpFunc != (FARPROC)NULL)
    {
        (*lpFunc)((DWORD)hInstance);
    }
    else
    {
        DOUTSTR(L"Null function in msmcivcr.exe\n")
    }


    DOUTSTR(L"Going into message loop in msmcivcr.exe.\n")

    /* Acquire and dispatch messages until a WM_QUIT message is received. */

    while (GetMessage(&msg, // message structure
       (HWND)NULL,   // handle of window receiving the message
       0,      // lowest message to examine
       0))     // highest message to examine
    {
        TranslateMessage(&msg); // Translates virtual key codes
        DispatchMessage(&msg);  // Dispatches message to window
    }

    DOUTSTR(L"MsMciVcr.Exe Quitting _Goodbye_ *hei*.\n")

    FreeLibrary(hLibrary);

    return (msg.wParam); // Returns the value from PostQuitMessage

    lpCmdLine; // This will prevent 'unused formal parameter' warnings
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mcivisca\mcivisca\viscamsg.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 * 
 **************************************************************************/

extern	UINT PASCAL FAR viscaHeaderReplaceFormat1WithFormat2(char FAR *lpstrMessage,UINT cbLen,unsigned char bHour,unsigned char bMinute,unsigned char bSecond,UINT uTicks);
extern	UINT PASCAL FAR viscaHeaderReplaceFormat1WithFormat3(char FAR *lpstrMessage,UINT cbLen,char FAR *lpstrPosition);
extern	UINT PASCAL FAR viscaHeaderReplaceFormat1WithFormat4(char FAR *lpstrMessage,UINT cbLen,char FAR *lpstrPosition);
extern	UINT PASCAL FAR viscaDataTopMiddleEnd(char FAR *lpstrData,unsigned char bTopMiddleEnd);
extern	UINT PASCAL FAR viscaDataPosition(char FAR *lpstrData,unsigned char bTimeFormat,unsigned char bHours,unsigned char bMinutes,unsigned char bSeconds,unsigned char bFrames);
extern	UINT PASCAL FAR viscaDataIndex(char FAR *lpstrData,unsigned char bDirection,UINT uNum);
extern	UINT PASCAL FAR viscaMessageIF_Address(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageIF_Cancel(char FAR *lpstrMessage,unsigned char bSocket);
extern	UINT PASCAL FAR viscaMessageIF_Clear(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageIF_DeviceTypeInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageIF_ClockInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageIF_ClockSet(char FAR *lpstrMessage,unsigned char bHours,unsigned char bMinutes,unsigned char bSeconds,UINT uTicks,
                BYTE dbHours, BYTE dbMinutes, BYTE dbSeconds, UINT duTicks);
extern	UINT PASCAL FAR viscaMessageMD_Channel(char FAR *lpstrMessage,UINT uChannel);
extern	UINT PASCAL FAR viscaMessageMD_ChannelInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_EditModes(char FAR *lpstrMessage,unsigned char bSubCode);
extern	UINT PASCAL FAR viscaMessageMD_EditControl(char FAR *lpstrMessage,unsigned char bHours,unsigned char bMinutes,unsigned char bSeconds,UINT uTicks,unsigned char bSubCode);
extern	UINT PASCAL FAR viscaMessageMD_EditControlInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageENT_FrameStill(char FAR *lpstrMessage,unsigned char bSubCode);
extern	UINT PASCAL FAR viscaMessageENT_NFrameRec(char FAR *lpstrMessage, int iSubCode);
extern	UINT PASCAL FAR viscaMessageENT_FrameMemorySelect(char FAR *lpstrMessage,unsigned char bSubCode);
extern	UINT PASCAL FAR viscaMessageENT_FrameMemorySelectInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageSE_VDEReadMode(char FAR *lpstrMessage,unsigned char bSubCode);
extern	UINT PASCAL FAR viscaMessageSE_VDEReadModeInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_Mode1(char FAR *lpstrMessage,unsigned char bModeCode);
extern	UINT PASCAL FAR viscaMessageMD_Mode1Inq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_Mode2(char FAR *lpstrMessage,unsigned char bModeCode);
extern	UINT PASCAL FAR viscaMessageMD_PositionInq(char FAR *lpstrMessage,unsigned char bCounterType);
extern	UINT PASCAL FAR viscaMessageMD_Power(char FAR *lpstrMessage,unsigned char bSubCode);
extern	UINT PASCAL FAR viscaMessageMD_PowerInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_Search(char FAR *lpstrMessage,char FAR *lpstrDataTarget,unsigned char bMode);
extern	UINT PASCAL FAR viscaMessageMD_MediaInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_InputSelect(char FAR *lpstrMessage,unsigned char bVideo,unsigned char bAudio);
extern	UINT PASCAL FAR viscaMessageMD_InputSelectInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_OSD(char FAR *lpstrMessage,unsigned char bPage);
extern	UINT PASCAL FAR viscaMessageMD_OSDInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_Subcontrol(char FAR *lpstrMessage,unsigned char bSubCode);
extern	UINT PASCAL FAR viscaMessageMD_ConfigureIFInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_RecSpeed(char FAR *lpstrMessage,unsigned char bSpeed);
extern	UINT PASCAL FAR viscaMessageMD_RecSpeedInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_RecTrack(char FAR *lpstrMessage,unsigned char bRecordMode,unsigned char bVideoTrack,unsigned char bDataTrack,unsigned char bAudioTrack);
extern	UINT PASCAL FAR viscaMessageMD_RecTrackInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_MediaTrackInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_SegPreRollDurationInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_SegPostRollDurationInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_SegInPoint(char FAR *lpstrMessage, char FAR *lpstrDataTarget);
extern	UINT PASCAL FAR viscaMessageMD_SegInPointInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_SegOutPoint(char FAR *lpstrMessage, char FAR *lpstrDataTarget);
extern	UINT PASCAL FAR viscaMessageMD_SegOutPointInq(char FAR *lpstrMessage);
extern  UINT PASCAL FAR viscaMessageMD_SegPreRollDuration(char FAR *lpstrMessage, char FAR *lpstrData);
extern  UINT PASCAL FAR viscaMessageMD_SegPostRollDuration(char FAR *lpstrMessage, char FAR *lpstrData);
extern  UINT PASCAL FAR viscaMessageMD_PBTrack(char FAR *lpstrMessage, unsigned char bVideoTrack, unsigned char bDataTrack, unsigned char bAudioTrack);
extern  UINT PASCAL FAR viscaMessageMD_PBTrackInq(char FAR *lpstrMessage);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mcivisca\mcivisca\vcr.h ===
/***************************************************************************
 *                                                                         *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY  *
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE    *
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR  *
 *  PURPOSE.                                                               *
 *                                                                         *
 *  Copyright (c) 1993-1995 Microsoft Corporation
 *                                                                         *
 * File:  vcr.h                                                            *
 * Title:           VCR-MCI Command Table Include File                     *
 *                                                                         *
 ***************************************************************************/

/* string resource base for vcr device type */
#define MCI_VCR_OFFSET                          1280

/* system MCI commands */
#define MCI_LIST                                0x0878
#define MCI_SETAUDIO                            0x0873 
#define MCI_SETVIDEO                            0x0876 
#define MCI_SIGNAL                              0x0875 

/* custom MCI commands for VCRs */
#define MCI_MARK                                (MCI_USER_MESSAGES + 0)
#define MCI_INDEX                               (MCI_USER_MESSAGES + 1)
#define MCI_SETTUNER                            (MCI_USER_MESSAGES + 2)
#define MCI_SETVCR                              (MCI_USER_MESSAGES + 3)
#define MCI_SETTIMECODE                         (MCI_USER_MESSAGES + 4)

/* Test is appplicable to all commands */
#define MCI_TEST                                0x00000020L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_VCR_GETDEVCAPS_CAN_DETECT_LENGTH    0x00004001L
#define MCI_VCR_GETDEVCAPS_SEEK_ACCURACY        0x00004002L
#define MCI_VCR_GETDEVCAPS_HAS_CLOCK            0x00004003L
#define MCI_VCR_GETDEVCAPS_CAN_REVERSE          0x00004004L
#define MCI_VCR_GETDEVCAPS_NUMBER_OF_MARKS      0x00004005L
#define MCI_VCR_GETDEVCAPS_CAN_TEST             0x00004006L
#define MCI_VCR_GETDEVCAPS_CAN_PREROLL          0x00004007L
#define MCI_VCR_GETDEVCAPS_CAN_PREVIEW          0x00004008L
#define MCI_VCR_GETDEVCAPS_CAN_MONITOR_SOURCES  0x00004009L
#define MCI_VCR_GETDEVCAPS_HAS_TIMECODE         0x0000400AL
#define MCI_VCR_GETDEVCAPS_CAN_FREEZE           0x0000401BL
#define MCI_VCR_GETDEVCAPS_CLOCK_INCREMENT_RATE 0x0000401CL

/* flags for dwFlags parameter of MCI_INFO command message */
#define MCI_VCR_INFO_VERSION                    0x00010000L

/* flags for dwFlags parameter of MCI_PLAY command message */
#define MCI_VCR_PLAY_REVERSE                    0x00010000L
#define MCI_VCR_PLAY_AT                         0x00020000L
#define MCI_VCR_PLAY_SCAN                       0x00040000L

/* flags for dwFlags parameter of MCI_RECORD command message */
#define MCI_VCR_RECORD_INITIALIZE               0x00010000L
#define MCI_VCR_RECORD_AT                       0x00020000L
#define MCI_VCR_RECORD_PREVIEW                  0x00040000L

/* flags for dwFlags parameter of MCI_CUE command message */
#define MCI_VCR_CUE_INPUT                       0x00010000L
#define MCI_VCR_CUE_OUTPUT                      0x00020000L
#define MCI_VCR_CUE_PREROLL                     0x00040000L
#define MCI_VCR_CUE_REVERSE                     0x00080000L

/* flags for dwFlags parameter of MCI_SEEK command message */
#define MCI_VCR_SEEK_REVERSE                    0x00010000L
#define MCI_VCR_SEEK_MARK                       0x00020000L
#define MCI_VCR_SEEK_AT                         0x00040000L
                                               
/* flags for dwFlags parameter of MCI_SETTUNER command message */
#define MCI_VCR_SETTUNER_CHANNEL                0x00010000L
#define MCI_VCR_SETTUNER_CHANNEL_UP             0x00020000L
#define MCI_VCR_SETTUNER_CHANNEL_DOWN           0x00040000L
#define MCI_VCR_SETTUNER_CHANNEL_SEEK_UP        0x00080000L
#define MCI_VCR_SETTUNER_CHANNEL_SEEK_DOWN      0x00100000L
#define MCI_VCR_SETTUNER_NUMBER                 0x00200000L

/* flags for dwFlags parameter of MCI_SET command message */
#define MCI_VCR_SET_TIME_MODE                   0x00010000L
#define MCI_VCR_SET_POWER                       0x00020000L
#define MCI_VCR_SET_RECORD_FORMAT               0x00040000L
#define MCI_VCR_SET_COUNTER_FORMAT              0x00080000L
#define MCI_VCR_SET_INDEX                       0x00100000L
#define MCI_VCR_SET_ASSEMBLE_RECORD             0x00200000L
#define MCI_VCR_SET_TRACKING                    0x00400000L
#define MCI_VCR_SET_SPEED                       0x00800000L
#define MCI_VCR_SET_TAPE_LENGTH                 0x01000000L
#define MCI_VCR_SET_COUNTER_VALUE               0x02000000L
#define MCI_VCR_SET_CLOCK                       0x04000000L
#define MCI_VCR_SET_PAUSE_TIMEOUT               0x08000000L
#define MCI_VCR_SET_PREROLL_DURATION            0x10000000L
#define MCI_VCR_SET_POSTROLL_DURATION           0x20000000L

/* flags for dwItem parameter of MCI_SETTIMECODE commmand message */
#define MCI_VCR_SETTIMECODE_RECORD              0x00010000L

/* flags for dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_VCR_STATUS_FRAME_RATE               0x00004001L /* Frame rate   */
#define MCI_VCR_STATUS_SPEED                    0x00004002L /* Speed        */
#define MCI_VCR_STATUS_MEDIA_TYPE               0x00004003L
#define MCI_VCR_STATUS_RECORD_FORMAT            0x00004004L
#define MCI_VCR_STATUS_PLAY_FORMAT              0x00004005L
#define MCI_VCR_STATUS_AUDIO_SOURCE             0x00004006L
#define MCI_VCR_STATUS_AUDIO_SOURCE_NUMBER      0x00004007L
#define MCI_VCR_STATUS_VIDEO_SOURCE             0x00004008L
#define MCI_VCR_STATUS_VIDEO_SOURCE_NUMBER      0x00004009L
#define MCI_VCR_STATUS_AUDIO_MONITOR            0x0000400AL
#define MCI_VCR_STATUS_AUDIO_MONITOR_NUMBER     0x0000400BL
#define MCI_VCR_STATUS_VIDEO_MONITOR            0x0000400CL
#define MCI_VCR_STATUS_VIDEO_MONITOR_NUMBER     0x0000400DL
#define MCI_VCR_STATUS_INDEX_ON                 0x0000400EL
#define MCI_VCR_STATUS_INDEX                    0x0000400FL
#define MCI_VCR_STATUS_COUNTER_FORMAT           0x00004010L
#define MCI_VCR_STATUS_COUNTER_RESOLUTION       0x00004011L
#define MCI_VCR_STATUS_TIMECODE_TYPE            0x00004012L
#define MCI_VCR_STATUS_COUNTER_VALUE            0x00004013L
#define MCI_VCR_STATUS_TUNER_CHANNEL            0x00004014L
#define MCI_VCR_STATUS_WRITE_PROTECTED          0x00004015L
#define MCI_VCR_STATUS_TIMECODE_RECORD          0x00004016L
#define MCI_VCR_STATUS_VIDEO_RECORD             0x00004017L
#define MCI_VCR_STATUS_AUDIO_RECORD             0x00004018L
#define MCI_VCR_STATUS_TIME_TYPE                0x00004019L
#define MCI_VCR_STATUS_TIME_MODE                0x0000401AL
#define MCI_VCR_STATUS_POWER_ON                 0x0000401BL
#define MCI_VCR_STATUS_CLOCK                    0x0000401CL
#define MCI_VCR_STATUS_ASSEMBLE_RECORD          0x0000401DL
#define MCI_VCR_STATUS_TIMECODE_PRESENT         0x0000401EL
#define MCI_VCR_STATUS_NUMBER_OF_VIDEO_TRACKS   0x0000401FL
#define MCI_VCR_STATUS_NUMBER_OF_AUDIO_TRACKS   0x00004020L
#define MCI_VCR_STATUS_CLOCK_ID                 0x00004021L
#define MCI_VCR_STATUS_PAUSE_TIMEOUT            0x00004022L
#define MCI_VCR_STATUS_PREROLL_DURATION         0x00004023L
#define MCI_VCR_STATUS_POSTROLL_DURATION        0x00004024L
#define MCI_VCR_STATUS_VIDEO                    0x00004025L
#define MCI_VCR_STATUS_AUDIO                    0x00004026L

#define MCI_VCR_STATUS_NUMBER                   0x00080000L

/* flags for dwFlags parameter of MCI_ESCAPE command message */
#define MCI_VCR_ESCAPE_STRING                   0x00000100L

/* flags for dwFlags parameter of MCI_LIST command message */
#define MCI_VCR_LIST_VIDEO_SOURCE               0x00010000L
#define MCI_VCR_LIST_AUDIO_SOURCE               0x00020000L
#define MCI_VCR_LIST_COUNT                      0x00040000L
#define MCI_VCR_LIST_NUMBER                     0x00080000L

/* flags for dwFlags parameter of MCI_MARK command message */
#define MCI_VCR_MARK_WRITE                      0x00010000L
#define MCI_VCR_MARK_ERASE                      0x00020000L

/* flags for dwFlags parameter for MCI_SETAUDIO command message */
#define MCI_VCR_SETAUDIO_RECORD                 0x00010000L
#define MCI_VCR_SETAUDIO_SOURCE                 0x00020000L
#define MCI_VCR_SETAUDIO_MONITOR                0x00040000L
#define MCI_VCR_SETAUDIO_TO                     0x00200000L
#define MCI_VCR_SETAUDIO_NUMBER                 0x00400000L

/* flags for dwFlags parameter for MCI_SETVIDEO command message */
#define MCI_VCR_SETVIDEO_RECORD                 0x00010000L
#define MCI_VCR_SETVIDEO_SOURCE                 0x00020000L
#define MCI_VCR_SETVIDEO_MONITOR                0x00040000L
#define MCI_VCR_SETVIDEO_TO                     0x00100000L
#define MCI_VCR_SETVIDEO_NUMBER                 0x00200000L

/* The following is the function digitalvideo drivers must use 
 * to signal when a frame marked by the SIGNAL command has been rendered:
 *
 *  SEND_VCRSIGNAL(dwFlags, dwCallback, hDriver, wDeviceID, dwUser, dwPos )
 *
 * The following is a description of the parameters:
 *
 *  dwFlags    - the dwFlags parameter passed when the signal was set
 *  dwCallback - the dwCallback value from the MCI_VCR_SIGNAL_PARMS struct
 *               used to set the signal
 *  hDriver    - the handle assigned to the driver by MMSYSTEM when the 
 *               device was opened
 *  wDeviceID  - the device ID
 *  dwUser     - the dwUserParm value from the MCI_VCR_SIGNAL_PARMS struct
 *               used to set the signal
 *  dwPos      - the position at which the signal was sent, in the current
 *               time format.
 *
 * The window indicated by the handle in the dwCallback field is notified 
 * by means of a Windows message with the following form:
 *
 * msg    = MM_MCISIGNAL
 * wParam = wDeviceID of the sending driver 
 * lParam = the uservalue specified or the position the signal was sent
 *          at; the latter if the MCI_VCR_SIGNAL_POSITION flag was set 
 *          in the dwFlags parameter when the signal was created.
 */

#define SEND_VCRSIGNAL(dwFlags, dwCallback, hDriver, wDeviceID, dwUser, dwPos ) \
  DriverCallback( (dwCallback), DCB_WINDOW, (HANDLE)(wDeviceID), MM_MCISIGNAL,\
  hDriver, ((dwFlags) & MCI_VCR_SIGNAL_POSITION) ? (dwPos):(dwUser),\
  ((dwFlags) & MCI_VCR_SIGNAL_POSITION) ? (dwUser):(dwPos))


/* Window message for signal notification */
#define MM_MCISIGNAL                            0x3CB

/* flags for dwFlags parameter of MCI_SIGNAL command message */
#define MCI_VCR_SIGNAL_AT                       0x00010000L
#define MCI_VCR_SIGNAL_EVERY                    0x00020000L
#define MCI_VCR_SIGNAL_USERVAL                  0x00040000L
#define MCI_VCR_SIGNAL_CANCEL                   0x00080000L
#define MCI_VCR_SIGNAL_POSITION                 0x00100000L

/* flags for dwFlags parameter of MCI_STEP command message */
#define MCI_VCR_STEP_FRAMES                     0x00010000L
#define MCI_VCR_STEP_REVERSE                    0x00020000L

/* flags for dwFlags parameter of MCI_FREEZE command message */
#define MCI_VCR_FREEZE_INPUT                    0x00010000L
#define MCI_VCR_FREEZE_OUTPUT                   0x00020000L
#define MCI_VCR_FREEZE_FIELD                    0x00040000L
#define MCI_VCR_FREEZE_FRAME                    0x00080000L

/* flags for dwFlags parameter of MCI_UNFREEZE command message */
#define MCI_VCR_UNFREEZE_INPUT                  0x00010000L
#define MCI_VCR_UNFREEZE_OUTPUT                 0x00020000L

/* string resource values for vcr media types */
#define MCI_VCR_MEDIA_8MM                       (MCI_VCR_OFFSET + 1)
#define MCI_VCR_MEDIA_HI8                       (MCI_VCR_OFFSET + 2)
#define MCI_VCR_MEDIA_VHS                       (MCI_VCR_OFFSET + 3)
#define MCI_VCR_MEDIA_SVHS                      (MCI_VCR_OFFSET + 4)
#define MCI_VCR_MEDIA_BETA                      (MCI_VCR_OFFSET + 5)
#define MCI_VCR_MEDIA_EDBETA                    (MCI_VCR_OFFSET + 6)
#define MCI_VCR_MEDIA_OTHER                     (MCI_VCR_OFFSET + 7)

/* string resource values for vcr play/record formats */
#define MCI_VCR_FORMAT_SP                       (MCI_VCR_OFFSET + 8)
#define MCI_VCR_FORMAT_LP                       (MCI_VCR_OFFSET + 9)
#define MCI_VCR_FORMAT_EP                       (MCI_VCR_OFFSET + 10)
#define MCI_VCR_FORMAT_OTHER                    (MCI_VCR_OFFSET + 11)

/* string resource values for timecode types */
#define MCI_VCR_TIME_TIMECODE                   (MCI_VCR_OFFSET + 12)
#define MCI_VCR_TIME_COUNTER                    (MCI_VCR_OFFSET + 13)
#define MCI_VCR_TIME_DETECT                     (MCI_VCR_OFFSET + 14)

/* string resource values for src types */
#define MCI_VCR_SRC_TYPE_TUNER                  (MCI_VCR_OFFSET + 15)
#define MCI_VCR_SRC_TYPE_LINE                   (MCI_VCR_OFFSET + 16)
#define MCI_VCR_SRC_TYPE_SVIDEO                 (MCI_VCR_OFFSET + 17)
#define MCI_VCR_SRC_TYPE_RGB                    (MCI_VCR_OFFSET + 18)
#define MCI_VCR_SRC_TYPE_AUX                    (MCI_VCR_OFFSET + 19)
#define MCI_VCR_SRC_TYPE_GENERIC                (MCI_VCR_OFFSET + 20)
#define MCI_VCR_SRC_TYPE_MUTE                   (MCI_VCR_OFFSET + 21)
#define MCI_VCR_SRC_TYPE_OUTPUT                 (MCI_VCR_OFFSET + 22)

/* string resource values for vcr counters */
#define MCI_VCR_INDEX_TIMECODE                  (MCI_VCR_OFFSET + 23)         
#define MCI_VCR_INDEX_COUNTER                   (MCI_VCR_OFFSET + 24)   
#define MCI_VCR_INDEX_DATE                      (MCI_VCR_OFFSET + 25)
#define MCI_VCR_INDEX_TIME                      (MCI_VCR_OFFSET + 26)

/* string resources for timecode type and counter resolution */
#define MCI_VCR_COUNTER_RES_SECONDS             (MCI_VCR_OFFSET + 27)            
#define MCI_VCR_COUNTER_RES_FRAMES              (MCI_VCR_OFFSET + 28)

#define MCI_VCR_TIMECODE_TYPE_SMPTE             (MCI_VCR_OFFSET + 29)
#define MCI_VCR_TIMECODE_TYPE_SMPTE_DROP        (MCI_VCR_OFFSET + 30)
#define MCI_VCR_TIMECODE_TYPE_OTHER             (MCI_VCR_OFFSET + 31)
#define MCI_VCR_TIMECODE_TYPE_NONE              (MCI_VCR_OFFSET + 32)

#define MCI_VCR_PLUS                            (MCI_VCR_OFFSET + 33)
#define MCI_VCR_MINUS                           (MCI_VCR_OFFSET + 34)
#define MCI_VCR_RESET                           (MCI_VCR_OFFSET + 35)

#ifndef RC_INVOKED

/* parameter block for MCI_SEEK command message */
typedef struct tagMCI_VCR_SEEK_PARMS {
    DWORD   dwCallback;
    DWORD   dwTo;
    DWORD   dwMark;
    DWORD   dwAt;
} MCI_VCR_SEEK_PARMS;
typedef MCI_VCR_SEEK_PARMS FAR *LPMCI_VCR_SEEK_PARMS;

/* parameter block for MCI_SET command message */
typedef struct tagMCI_VCR_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    DWORD   dwTimeMode;
    DWORD   dwRecordFormat;
    DWORD   dwCounterFormat;
    DWORD   dwIndex;
    DWORD   dwTracking;
    DWORD   dwSpeed;
    DWORD   dwLength;
    DWORD   dwCounter;
    DWORD   dwClock;
    DWORD   dwPauseTimeout;
    DWORD   dwPrerollDuration;
    DWORD   dwPostrollDuration;
} MCI_VCR_SET_PARMS;
typedef MCI_VCR_SET_PARMS FAR *LPMCI_VCR_SET_PARMS;

/* parameter block for MCI_VCR_SETTUNER command message */
typedef struct tagMCI_VCR_SETTUNER_PARMS {
    DWORD   dwCallback;
    DWORD   dwChannel;
    DWORD   dwNumber;
} MCI_VCR_SETTUNER_PARMS;
typedef MCI_VCR_SETTUNER_PARMS FAR *LPMCI_VCR_SETTUNER_PARMS;

/* parameter block for MCI_ESCAPE command message */
typedef struct tagMCI_VCR_ESCAPE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpstrCommand;
} MCI_VCR_ESCAPE_PARMS;
typedef MCI_VCR_ESCAPE_PARMS FAR *LPMCI_VCR_ESCAPE_PARMS;

/* parameter block for MCI_LIST command message */
typedef struct tagMCI_VCR_LIST_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwNumber;
} MCI_VCR_LIST_PARMS;
typedef MCI_VCR_LIST_PARMS FAR *LPMCI_VCR_LIST_PARMS;

/* parameter block for MCI_RECORD command message */
typedef struct tagMCI_VCR_RECORD_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwAt;
} MCI_VCR_RECORD_PARMS;
typedef MCI_VCR_RECORD_PARMS FAR *LPMCI_VCR_RECORD_PARMS;

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_VCR_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwAt;
} MCI_VCR_PLAY_PARMS;
typedef MCI_VCR_PLAY_PARMS FAR *LPMCI_VCR_PLAY_PARMS;

/* parameter block for MCI_SETAUDIO command message */
typedef struct tagMCI_VCR_SETAUDIO_PARMS {
    DWORD   dwCallback;
    DWORD   dwTrack;
    DWORD   dwTo;
    DWORD   dwNumber;
} MCI_VCR_SETAUDIO_PARMS;
typedef MCI_VCR_SETAUDIO_PARMS FAR *LPMCI_VCR_SETAUDIO_PARMS;

/* parameter block for MCI_SIGNAL command message */
typedef struct tagMCI_VCR_SIGNAL_PARMS {
    DWORD   dwCallback;
    DWORD   dwPosition;
    DWORD   dwPeriod;
    DWORD   dwUserParm;
} MCI_VCR_SIGNAL_PARMS;
typedef MCI_VCR_SIGNAL_PARMS FAR * LPMCI_VCR_SIGNAL_PARMS;

/* parameter block for MCI_VCR_STATUS command message */
typedef struct tagMCI_VCR_STATUS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
    DWORD   dwNumber;
} MCI_VCR_STATUS_PARMS;
typedef MCI_VCR_STATUS_PARMS FAR * LPMCI_VCR_STATUS_PARMS;

/* parameter block for MCI_SETVIDEO command message */
typedef struct tagMCI_VCR_SETVIDEO_PARMS {
    DWORD   dwCallback;
    DWORD   dwTrack;
    DWORD   dwTo;
    DWORD   dwNumber;
} MCI_VCR_SETVIDEO_PARMS;
typedef MCI_VCR_SETVIDEO_PARMS FAR *LPMCI_VCR_SETVIDEO_PARMS;

/* parameter block for MCI_STEP command message */
typedef struct tagMCI_VCR_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_VCR_STEP_PARMS;
typedef MCI_VCR_STEP_PARMS FAR *LPMCI_VCR_STEP_PARMS;

/* parameter block for MCI_CUE command message */
typedef struct tagMCI_VCR_CUE_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_VCR_CUE_PARMS;
typedef MCI_VCR_CUE_PARMS FAR *LPMCI_VCR_CUE_PARMS;

#endif /* NOT RC_INVOKED */

/* VCR error codes */
#define MCIERR_VCR_CANNOT_OPEN_COMM         (MCIERR_CUSTOM_DRIVER_BASE + 1)
#define MCIERR_VCR_CANNOT_WRITE_COMM        (MCIERR_CUSTOM_DRIVER_BASE + 2)
#define MCIERR_VCR_READ_TIMEOUT             (MCIERR_CUSTOM_DRIVER_BASE + 3)
#define MCIERR_VCR_COMMAND_BUFFER_FULL      (MCIERR_CUSTOM_DRIVER_BASE + 4)
#define MCIERR_VCR_COMMAND_CANCELLED        (MCIERR_CUSTOM_DRIVER_BASE + 5)
#define MCIERR_VCR_POWER_OFF                (MCIERR_CUSTOM_DRIVER_BASE + 6)
#define MCIERR_VCR_COMMAND_FAILED           (MCIERR_CUSTOM_DRIVER_BASE + 7)
#define MCIERR_VCR_SEARCH                   (MCIERR_CUSTOM_DRIVER_BASE + 8)
#define MCIERR_VCR_CONDITION                (MCIERR_CUSTOM_DRIVER_BASE + 9)
#define MCIERR_VCR_CAMERA_MODE              (MCIERR_CUSTOM_DRIVER_BASE + 10)
#define MCIERR_VCR_VCR_MODE                 (MCIERR_CUSTOM_DRIVER_BASE + 11)
#define MCIERR_VCR_COUNTER_TYPE             (MCIERR_CUSTOM_DRIVER_BASE + 12)
#define MCIERR_VCR_TUNER                    (MCIERR_CUSTOM_DRIVER_BASE + 13)
#define MCIERR_VCR_EMERGENCY_STOP           (MCIERR_CUSTOM_DRIVER_BASE + 14)
#define MCIERR_VCR_MEDIA_UNMOUNTED          (MCIERR_CUSTOM_DRIVER_BASE + 15)
#define MCIERR_VCR_REGISTER                 (MCIERR_CUSTOM_DRIVER_BASE + 16)
#define MCIERR_VCR_TRACK_FAILURE            (MCIERR_CUSTOM_DRIVER_BASE + 17)
#define MCIERR_VCR_CUE_FAILED_FLAGS         (MCIERR_CUSTOM_DRIVER_BASE + 18)
#define MCIERR_VCR_ISWRITEPROTECTED         (MCIERR_CUSTOM_DRIVER_BASE + 19)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mciwave\config.h ===
/****************************************************************************/

/*
**  Copyright (c) 1985-1992 Microsoft Corporation
**
**  Title: config.h Multimedia Systems Media Control Interface
**  streaming digital audio driver internal header file.
**
**  Version:    1.00
**
**  Date:       ?
**
**  Author:     ROBWI
*/

/****************************************************************************/

/*
**  Change log:
**
**  DATE        REV     DESCRIPTION
**  ----------- -----   ------------------------------------------
**                      Original
**  10-Jan-1992 MikeTri Ported to NT
**                  @@@ need to change slash slash comments to slash star
*/

/****************************************************************************/

#define IDD_CONFIG  1

#define IDSCROLL   0x00000100
#define IDCOUNT    0x00000101

// Stretched the above to make them DWORD rather than WORD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mcivisca\mcivisca\viscadef.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 * 
 *  VISCADEF.H
 *
 *  MCI ViSCA Device Driver
 *
 *  Description:
 *
 *      ViSCA constant declarations
 *
 ***************************************************************************/

#define MAXPACKETLENGTH             16

/* defines for addresses */
#define MASTERADDRESS               (BYTE)0x00    /* address of the computer */
#define BROADCASTADDRESS            (BYTE)0x08    /* address for broadcasts to all devices */

#define VISCA_READ_COMPLETE_OK      (BYTE)0x00
#define VISCA_READ_ACK_OK           (BYTE)0x01
#define VISCA_READ_BREAK            (BYTE)0x02
#define VISCA_READ_TIMEOUT          (BYTE)0x03
#define VISCA_READ_ACK_ERROR        (BYTE)0x04
#define VISCA_READ_COMPLETE_ERROR   (BYTE)0x05

#define VISCA_WRITE_ERROR           (BYTE)0x06
#define VISCA_WRITE_OK              (BYTE)0x07
#define VISCA_WRITE_BREAK           (BYTE)0x08

/* defines for reply types */
#define VISCAREPLYTYPEMASK          (BYTE)0xF0
#define VISCAREPLYSOCKETMASK        (BYTE)0x0F
#define VISCAREPLYADDRESS           (BYTE)0x30
#define VISCAREPLYACK               (BYTE)0x40
#define VISCAREPLYCOMPLETION        (BYTE)0x50
#define VISCAREPLYERROR             (BYTE)0x60
#define VISCAREPLYDEVICE(lp)        (BYTE)((((LPSTR)(lp))[0] & 0x70) >> 4)
#define VISCAREPLYTODEVICE(lp)      (BYTE)(((LPSTR)(lp))[0] & 0x07)
#define VISCAREPLYBROADCAST(lp)     (BYTE)(((LPSTR)(lp))[0] & 0x08)
#define VISCAREPLYSOCKET(lp)        (BYTE)(((LPSTR)(lp))[1] & VISCAREPLYSOCKETMASK)
#define VISCAREPLYTYPE(lp)          (BYTE)(((LPSTR)(lp))[1] & VISCAREPLYTYPEMASK)
#define VISCAREPLYERRORCODE(lp)     (BYTE)(((LPSTR)(lp))[2])

#define VISCABROADCAST              (BYTE)0x88


/* defines for reply error codes */
#define VISCAERRORMESSAGELENGTH     (BYTE)0x01
#define VISCAERRORSYNTAX            (BYTE)0x02
#define VISCAERRORBUFFERFULL        (BYTE)0x03
#define VISCAERRORCANCELLED         (BYTE)0x04
#define VISCAERRORNOSOCKET          (BYTE)0x05
#define VISCAERRORPOWEROFF          (BYTE)0x40
#define VISCAERRORCOMMANDFAILED     (BYTE)0x41
#define VISCAERRORSEARCH            (BYTE)0x42
#define VISCAERRORCONDITION         (BYTE)0x43
#define VISCAERRORCAMERAMODE        (BYTE)0x44
#define VISCAERRORVCRMODE           (BYTE)0x45
#define VISCAERRORCOUNTERTYPE       (BYTE)0x46
#define VISCAERRORTUNER             (BYTE)0x47
#define VISCAERROREMERGENCYSTOP     (BYTE)0x48
#define VISCAERRORMEDIAUNMOUNTED    (BYTE)0x49
#define VISCAERRORREGISTER          (BYTE)0x4A
#define VISCAERRORREGISTERMODE      (BYTE)0x4B


/*** DEFINES FOR VISCA DATA TYPES ***/

/* defines for VISCA data types, also used in
   MD_PositionInq and MD_RecDataInq messages */
#define VISCADATATOPMIDDLEEND       (BYTE)0x01
#define VISCADATARELATIVE           (BYTE)0x10
#define VISCADATA4DIGITDECIMAL      (BYTE)0x11
#define VISCADATAHMS                (BYTE)0x12
#define VISCADATAHMSF               (BYTE)0x13
#define VISCADATAINDEX              (BYTE)0x32
#define VISCADATAABSOLUTE           (BYTE)0x20
#define VISCADATATIMECODENDF        (BYTE)0x21
#define VISCADATATIMECODEDF         (BYTE)0x22
#define VISCADATACHAPTER            (BYTE)0x31
#define VISCADATADATE               (BYTE)0x41
#define VISCADATATIME               (BYTE)0x42

/* defines to convert to and from binary coded decimal */
#define FROMBCD(b)                  (UINT)(10 * ((BYTE)(b) >> 4) + ((BYTE)(b) & 0x0F))
#define TOBCD(n)                    (BYTE)((((UINT)(n) / 10) << 4) + ((UINT)(n) % 10))

/* defines to extract hours, minutes, seconds, frames from a data type */
#define VISCANEGATIVE(lp)           (BOOL)(((BYTE FAR *)(lp))[1] & 0x40)
#define VISCAHOURS(lp)              FROMBCD(((BYTE FAR *)(lp))[1])
#define VISCAMINUTES(lp)            FROMBCD(((BYTE FAR *)(lp))[2])
#define VISCASECONDS(lp)            FROMBCD(((BYTE FAR *)(lp))[3])
#define VISCAFRAMES(lp)             FROMBCD(((BYTE FAR *)(lp))[4])

/* defines for Top/Middle/End data type */
#define VISCATOP                    (BYTE)0x01
#define VISCAMIDDLE                 (BYTE)0x02
#define VISCAEND                    (BYTE)0x03

/* defines for Index, Date, Time, User Data data types */
#define VISCAFORWARD                (BYTE)0x00
#define VISCAREVERSE                (BYTE)0x40

#define VISCASTILLON                (BYTE)0x01
#define VISCASTILLOFF               (BYTE)0x00

/*** DEFINES FOR VISCA MESSSSAGES ***/

/* defines for MD_CameraFocus message */
#define VISCAFOCUSSTOP              (BYTE)0x00
#define VISCAFOCUSFAR               (BYTE)0x02
#define VISCAFOCUSNEAR              (BYTE)0x03

/* defines for MD_CameraZoom message */
#define VISCAZOOMSTOP               (BYTE)0x00
#define VISCAZOOMTELE               (BYTE)0x02
#define VISCAZOOMWIDE               (BYTE)0x03

/* defines for MD_EditControl message */
#define VISCAEDITPBSTANDBY          (BYTE)0x20
#define VISCAEDITPLAY               (BYTE)0x28    /* Format 2 only */
#define VISCAEDITPLAYSHUTTLESPEED   (BYTE)0x29    /* Format 2 only */
#define VISCAEDITRECSTANDBY         (BYTE)0x40
#define VISCAEDITRECORD             (BYTE)0x48    /* Format 2 only */
#define VISCAEDITRECORDSHUTTLESPEED (BYTE)0x49    /* Format 2 only */

/* defines for MD_Mode1 and responses to MD_Mode1 and MD_TransportInq messages */
#define VISCAMODE1STOP              (BYTE)0x00
#define VISCAMODE1STOPTOP           (BYTE)0x02
#define VISCAMODE1STOPEND           (BYTE)0x04
#define VISCAMODE1STOPEMERGENCY     (BYTE)0x06
#define VISCAMODE1FASTFORWARD       (BYTE)0x08
#define VISCAMODE1REWIND            (BYTE)0x10
#define VISCAMODE1EJECT             (BYTE)0x18
#define VISCAMODE1STILL             (BYTE)0x20
#define VISCAMODE1SLOW2             (BYTE)0x24
#define VISCAMODE1SLOW1             (BYTE)0x26
#define VISCAMODE1PLAY              (BYTE)0x28
#define VISCAMODE1SHUTTLESPEEDPLAY  (BYTE)0x29
#define VISCAMODE1FAST1             (BYTE)0x2A
#define VISCAMODE1FAST2             (BYTE)0x2C
#define VISCAMODE1SCAN              (BYTE)0x2E
#define VISCAMODE1REVERSESLOW2      (BYTE)0x34
#define VISCAMODE1REVERSESLOW1      (BYTE)0x36
#define VISCAMODE1REVERSEPLAY       (BYTE)0x38
#define VISCAMODE1REVERSEFAST1      (BYTE)0x3A
#define VISCAMODE1REVERSEFAST2      (BYTE)0x3C
#define VISCAMODE1REVERSESCAN       (BYTE)0x3E
#define VISCAMODE1RECPAUSE          (BYTE)0x40
#define VISCAMODE1RECORD            (BYTE)0x48
#define VISCAMODE1SHUTTLESPEEDRECORD    (BYTE)0x49
#define VISCAMODE1CAMERARECPAUSE    (BYTE)0x50
#define VISCAMODE1CAMERAREC         (BYTE)0x58
#define VISCAMODE1EDITSEARCHFORWARD (BYTE)0x5C
#define VISCAMODE1EDITSEARCHREVERSE (BYTE)0x5E

/* defines for MD_Mode2 message */
#define VISCAMODE2FRAMEFORWARD      (BYTE)0x02
#define VISCAMODE2FRAMEREVERSE      (BYTE)0x03
#define VISCAMODE2INDEXERASE        (BYTE)0x10
#define VISCAMODE2INDEXMARK         (BYTE)0x11
#define VISCAMODE2FRAMERECORDFORWARD    (BYTE)0x42

/* defines for MD_Power message */
#define VISCAPOWERON                (BYTE)0x02
#define VISCAPOWEROFF               (BYTE)0x03

/* defines for MD_Search message */
#define VISCASTOP                   (BYTE)0x00
#define VISCASTILL                  (BYTE)0x20
#define VISCAPLAY                   (BYTE)0x28
#define VISCANOMODE                 (BYTE)0xFF

/* defines for reply to MD_TransportInq message */
#define VISCATRANSPORTEDIT          (BYTE)0x04    /* Bit 2 */
#define VISCATRANSPORTSEARCH        (BYTE)0x02    /* Bit 1 */
#define VISCATRANSPORTINTRANSITION  (BYTE)0x01    /* Bit 0 */

/* defines for MD_ClockSet message */
#define VISCACLOCKSTART             (BYTE)0x02
#define VISCACLOCKSTOP              (BYTE)0x03

/* defines for reply to MD_MediaInq message */
#define VISCAFORMAT8MM              (BYTE)0x01
#define VISCAFORMATVHS              (BYTE)0x02
#define VISCAFORMATBETA             (BYTE)0x03
#define VISCAFORMATHI8              (BYTE)0x41
#define VISCAFORMATSVHS             (BYTE)0x42
#define VISCAFORMATEDBETA           (BYTE)0x43
#define VISCATYPEHG                 (BYTE)0x08    /* Bit 3 */
#define VISCATYPETHIN               (BYTE)0x04    /* Bit 2 */
#define VISCATYPEME                 (BYTE)0x02    /* Bit 1 */
#define VISCATYPEPLAYBACKONLY       (BYTE)0x01    /* Bit 0 */

/* defines for MD_RecSpeed and replies to MD_MediaInq and MD_RecSpeedInq message */
#define VISCASPEEDSP                (BYTE)0x01
#define VISCASPEEDBETAI             VISCASPEEDSP
#define VISCASPEEDLP                (BYTE)0x02
#define VISCASPEEDBETAII            VISCASPEEDLP
#define VISCASPEEDEP                (BYTE)0x03
#define VISCASPEEDBETAIII           VISCASPEEDEP

/* defines for MD_InputSelect and reply to MD_InputSelectInq messages */
#define VISCAMUTE                   (BYTE)0x00
#define VISCAOTHERLINE              (BYTE)0x03
#define VISCATUNER                  (BYTE)0x01
#define VISCAOTHER                  (BYTE)0x07    /* BS Tuner */
#define VISCALINE                   (BYTE)0x10    /* | with line # */
#define VISCASVIDEOLINE             (BYTE)0x20    /* | with line # */
#define VISCAAUX                    (BYTE)0x30    /* | with line # */
#define VISCARGB                    VISCAAUX

/* defines for MD_OSD and reply to MD_OSDInq messages */
#define VISCAOSDPAGEOFF             (BYTE)0x00
#define VISCAOSDPAGEDEFAULT         (BYTE)0x01

/* defines for MD_Subcontrol message */
#define VISCACOUNTERRESET           (BYTE)0x01
#define VISCAABSOLUTECOUNTER        (BYTE)0x21
#define VISCARELATIVECOUNTER        (BYTE)0x22
#define VISCASTILLADJUSTMINUS       (BYTE)0x30
#define VISCASTILLADJUSTPLUS        (BYTE)0x31
#define VISCASLOWADJUSTMINUS        (BYTE)0x32
#define VISCASLOWADJUSTPLUS         (BYTE)0x33
#define VISCATOGGLEMAINSUBAUDIO     (BYTE)0x43
#define VISCATOGGLERECORDSPEED      (BYTE)0x44
#define VISCATOGGLEDISPLAYONOFF     (BYTE)0x45
#define VISCACYCLEVIDEOINPUT        (BYTE)0x46

/* defines for MD_ConfigureIF and reply to MD_ConfigureIFInq messages */
#define VISCA25FPS                  (BYTE)0x25
#define VISCA30FPS                  (BYTE)0x30
#define VISCALEVEL1                 (BYTE)0x01
#define VISCACONTROLNONE            (BYTE)0x00
#define VISCACONTROLSYNC            (BYTE)0x01
#define VISCACONTROLLANC            (BYTE)0x02
#define VISCACONTROLF500            VISCALANC

/* defines for MD_PBTrack and MD_RecTrack,
   and replies to MD_PBTrackInq and MD_RecTrackInq messages */
#define VISCATRACKNONE              (BYTE)0x00
#define VISCATRACK1                 (BYTE)0x01    /* Bit 0 */
#define VISCATRACK2                 (BYTE)0x02    /* Bit 1 */
#define VISCATRACK3                 (BYTE)0x04    /* Bit 2 */
#define VISCATRACK1AND2             (BYTE)0x03
#define VISCATRACKTIMECODE          VISCATRACK1
#define VISCATRACK8MMAFM            VISCATRACK1
#define VISCATRACKVHSLINEAR         VISCATRACK1
#define VISCATRACK8MMPCM            VISCATRACK2
#define VISCATRACKVHSHIFI           VISCATRACK2
#define VISCATRACKVHSPCM            VISCATRACK3

/* defines for MD_PBTrackMode and MD_RecTrackMode,
   and replies to MD_PBTrackModeInq, MD_RecTrackModeInq, and MD_MediaTrackModeInq messages */
#define VISCATRACKVIDEO             (BYTE)0x01
#define VISCATRACKDATA              (BYTE)0x02
#define VISCATRACKAUDIO             (BYTE)0x03
#define VISCAVIDEOMODENORMAL        (BYTE)0x00
#define VISCAVIDEOMODEEDIT          (BYTE)0x01    /* for dubbing */
#define VISCAVIDEOMODESTANDARD      (BYTE)0x01
#define VISCAVIDEOMODEHIQUALITY     (BYTE)0x40    /* e.g. S-VHS, ED-Beta, Hi-8 */
#define VISCADATAMODENORMAL         (BYTE)0x00
#define VISCADATAMODETIMECODE       (BYTE)0x10
#define VISCADATAMODEDATEANDTIMECODE    (BYTE)0x11
#define VISCADATAMODECHAPTERANDUSERDATAANDTIMECODE  (BYTE)0x12
#define VISCAAUDIOMODENORMAL        (BYTE)0x00
#define VISCAAUDIOMODEMONO          (BYTE)0x01
#define VISCAAUDIOMODESTEREO        (BYTE)0x10
#define VISCAAUDIOMODERIGHTONLY     (BYTE)0x11
#define VISCAAUDIOMODELEFTONLY      (BYTE)0x12
#define VISCAAUDIOMODEMULTILINGUAL  (BYTE)0x20
#define VISCAAUDIOMODEMAINCHANNELONLY   (BYTE)0x21
#define VISCAAUDIOMODESUBCHANNELONLY    (BYTE)0x22

/* defines for MD_RecTrack and reply to MD_RecTrackInq messages */
#define VISCARECORDMODEASSEMBLE     (BYTE)0x00
#define VISCARECORDMODEINSERT       (BYTE)0x01

/* defines for Vendors and machine types */
#define VISCADEVICEVENDORSONY       (BYTE)0x01
#define VISCADEVICEMODELCI1000      (BYTE)0x01
#define VISCADEVICEMODELCVD1000     (BYTE)0x02
#define VISCADEVICEMODELEVO9650     (BYTE)0x03

#define MUTE                        (BYTE)0x00
#define TUNER                       (BYTE)0x01
#define OTHER                       (BYTE)0x07
#define LINEVIDEO_BASE              (BYTE)0x10
#define SVIDEO_BASE                 (BYTE)0x20
#define AUXVIDEO_BASE               (BYTE)0x30

#define VISCABUFFER                 (BYTE)0x01
#define VISCADNR                    (BYTE)0x02

#define VISCAFRAME                  (BYTE)0x01
#define VISCAFIELD                  (BYTE)0x02

#define VISCAEDITUSEFROM            (BYTE)0x01
#define VISCAEDITUSETO              (BYTE)0x02
#define VISCAEDITUSEFROMANDTO       (BYTE)0x03

#define VISCAPACKETEND              (BYTE)0xff
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mciwave\config.c ===
/************************************************************************/

/*
**  Copyright (c) 1985-1998 Microsoft Corporation
**
**  Title: config.c - Multimedia Systems Media Control Interface
**  waveform audio driver for RIFF wave files.
**
**  Version:    1.00
**
**  Date:       18-Apr-1990
**
**  Author:     ROBWI
*/

/************************************************************************/

/*
**  Change log:
**
**  DATE        REV     DESCRIPTION
**  ----------- -----   ------------------------------------------
**  10-Jan-1992 MikeTri Ported to NT
**                  @@@ need to change slash slash comments to slash star
*/

/************************************************************************/
#define UNICODE

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICONS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define OEMRESOURCE
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
#define NODRAWTEXT
#define NOGDI
#define NOKERNEL
#define NONLS
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOOPENFILE
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOCOMM
#define NOKANJI
#define NOPROFILER
#define NODEFERWINDOWPOS

#define NOMMDRV
#define MMNOMMIO
#define MMNOJOY
#define MMNOTIMER
#define MMNOAUX
#define MMNOMIDI
#define MMNOWAVE

#include <windows.h>
#include "mciwave.h"
#include <mmddk.h>
#include "config.h"
#include <mcihlpid.h>

/************************************************************************/

#define MAXINIDRIVER    132

PRIVATE SZCODE aszNULL[] = L"";
PRIVATE SZCODE aszSystemIni[] = L"system.ini";
PRIVATE WCHAR  aszWordFormat[] = L"%u";
PRIVATE WCHAR  aszTailWordFormat[] = L" %u";

const static DWORD aHelpIds[] = {  // Context Help IDs
    IDSCROLL,    IDH_MCI_WAVEFORM_DRIVER,
    (DWORD)-1,   IDH_MCI_WAVEFORM_DRIVER,
    IDCOUNT,     IDH_MCI_WAVEFORM_DRIVER,
    0, 0
};

const static TCHAR cszHelpFile[] = TEXT("MMDRV.HLP");

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   SSZ | GetTail |
    This function returns a pointer into the given string at the
    first non-blank character after the current word.  If it fails to find
    a second word, a pointer to the terminating NULL character is returned.

@parm   SSZ | ssz |
    Points to the string whose tail is to be returned.

@rdesc  Returns a pointer into the string passed.
*/

PRIVATE SSZ PASCAL NEAR GetTail(
    SSZ ssz)
{
    while (*ssz && *ssz != ' ')
        ssz++;
    while (*ssz == ' ')
        ssz++ ;
    return ssz;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   UINT | GetCmdParm |
    This function retrieves the current audio buffers parameter using
    the INI strings contained in the configuration block.  The audio
    buffers parameter is a number included in the INI entry for this
    driver as a parameter.

@parm   <t>LPDRVCONFIGINFO<d> | lpdci |
    Points to the driver configuration information passed to the
    dialog creation function.

@rdesc  Returns the current audio buffers.
*/

STATICFN UINT PASCAL NEAR GetCmdParm(
    LPDRVCONFIGINFO lpdci)
{
    WCHAR    aszDriver[MAXINIDRIVER];
    SSZ      pszTail;


    // Assume things will go wrong... initialise variables
    pszTail = aszDriver;

    if (GetPrivateProfileString( lpdci->lpszDCISectionName,
                                 lpdci->lpszDCIAliasName,
                                 aszNULL,
                                 aszDriver,
                                 sizeof(aszDriver) / sizeof(WCHAR),
                                 aszSystemIni))
    {
        // We have got the name of the driver
        // Just in case the user has added the command parameter to the
        // end of the name we had better make sure there is only one token
        // on the line.
        WCHAR parameters[6];
        LPWSTR pszDefault;

        pszTail = GetTail((SSZ)aszDriver);
        pszDefault = pszTail;     // Either the number on the end, or NULL

        if (*pszTail) {
            // RATS!!  Not a simple name
            while (*--pszTail == L' ') {
            }
            *++pszTail = L'\0';  // Terminate the string after the DLL name
        }

        if (GetProfileString(aszDriver, lpdci->lpszDCIAliasName, pszDefault, parameters, sizeof(parameters)/sizeof(WCHAR))) {
            pszTail = parameters;
        }

    } else {
        aszDriver[0] = L'\0';
    }
    return(GetAudioSeconds(pszTail));

}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   UINT | PutCmdParm |
    This function saves the current audio buffers parameter using
    the INI strings contained in the configuration block.

@parm   <t>LPDRVCONFIGINFO<d> | lpdci |
    Points to the driver configuration information passed to the
    dialog creation function.

@parm  UINT | wSeconds |
    Contains the audio buffer seconds parameter to save.

@rdesc  Nothing.
*/

PRIVATE VOID PASCAL NEAR PutCmdParm(
    LPDRVCONFIGINFO lpdci,
    UINT            wSeconds)
{
    WCHAR    aszDriver[MAXINIDRIVER];
    SSZ sszDriverTail;

    if (GetPrivateProfileString( lpdci->lpszDCISectionName,
                                 lpdci->lpszDCIAliasName,
                                 aszNULL,
                                 aszDriver,
                                 (sizeof(aszDriver) / sizeof(WCHAR)) - 6,
                                 aszSystemIni)) {
        WCHAR parameters[10];

        // There might be a command parameter on the end of the DLL name.
        // Ensure we only have the first token

        sszDriverTail = GetTail((SSZ)aszDriver);
        if (*sszDriverTail) {
            // RATS!!  Not a simple name
            while (*--sszDriverTail == L' ') {
            }
            *++sszDriverTail = L'\0';  // Terminate the string after the DLL name
        }

        wsprintfW(parameters, aszWordFormat, wSeconds);
        WriteProfileString(aszDriver, lpdci->lpszDCIAliasName, parameters);
    }
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   BOOL | ConfigDlgProc |
    This function is the message handle for the driver configuration
    window.

@parm   HWND | hwndDlg |
    Window handle to the dialog.

@parm   UINT | wMsg |
    Current message being sent.

@flag   WM_INITDIALOG |
    During dialog initialization, the pointer to the configuration
    parameter block is saved to a static pointer.  Note that there should
    only be a single instance of this dialog box at any one time.  The
    current audio dialog buffer seconds is set from the INI file entry.

@flag   WM_HSCROLL |
    This responds to the scroll bar by changing the currently displayed
    value of audio seconds and updating the scroll bar thumb.  To look
    nice, the count and scroll bar are only updated if the value actually
    changes.  Note that the error return for GetDlgItemInt is not checked
    because it is initially set to an integer value, so it is always
    valid.

@flag   WM_CLOSE |
    If the close box is used, cancel the dialog, returning DRVCNF_CANCEL.

@flag   WM_COMMAND |
    If the message is being sent on behalf of the OK button, the current
    audio seconds value is saved, and the dialog is terminated, returning
    the DRVCNF_OK value to the driver entry.  Note that the error return for
    GetDlgItemInt is not checked because it is initially set to an integer
    value, so it is always valid.  If the message is being sent on behalf
    of the Cancel button, the dialog is terminated returning the
    DRVCNF_CANCEL value.

@parm   WPARAM | wParam |
    Message parameter.

@parm   LPARAM | lParam |
    Message parameter.

@rdesc  Depends on the message sent.
*/

PUBLIC  INT_PTR PASCAL ConfigDlgProc(
    HWND    hwndDlg,
    UINT    wMsg,
    WPARAM  wParam,
    LPARAM  lParam)
{
    UINT    wSeconds;
    UINT    wNewSeconds;
    BOOL    fTranslated;
    HWND    hwndItem;
    static LPDRVCONFIGINFO  lpdci;

    switch (wMsg) {
    case WM_INITDIALOG:
        lpdci = (LPDRVCONFIGINFO)lParam;
        wSeconds = GetCmdParm(lpdci);
        hwndItem = GetDlgItem(hwndDlg, IDSCROLL);
        SetScrollRange(hwndItem, SB_CTL, MinAudioSeconds, MaxAudioSeconds, FALSE);
        SetScrollPos(hwndItem, SB_CTL, wSeconds, FALSE);
        SetDlgItemInt(hwndDlg, IDCOUNT, wSeconds, FALSE);
        break;

    case WM_HSCROLL:
        wSeconds = GetDlgItemInt(hwndDlg, IDCOUNT, &fTranslated, FALSE);
        hwndItem = (HWND)lParam;

        switch (LOWORD(wParam)) {
        case SB_PAGEDOWN:
        case SB_LINEDOWN:
            wNewSeconds = min(MaxAudioSeconds, wSeconds + 1);
            break;

        case SB_PAGEUP:
        case SB_LINEUP:
            wNewSeconds = max(MinAudioSeconds, wSeconds - 1);
            break;

        case SB_TOP:
            wNewSeconds = MinAudioSeconds;
            break;

        case SB_BOTTOM:
            wNewSeconds = MaxAudioSeconds;
            break;

        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            wNewSeconds = HIWORD(wParam);
            break;

        default:
            return FALSE;
        }

        if (wNewSeconds != wSeconds) {
            SetScrollPos(hwndItem, SB_CTL, wNewSeconds, TRUE);
            SetDlgItemInt(hwndDlg, IDCOUNT, wNewSeconds, FALSE);
        }
        break;

    case WM_CLOSE:
        EndDialog(hwndDlg, DRVCNF_CANCEL);
        break;

    case WM_CONTEXTMENU:
        WinHelp ((HWND)wParam, cszHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)aHelpIds);
        return TRUE;

    case WM_HELP:
    {
        LPHELPINFO lphi = (LPVOID) lParam;
        WinHelp (lphi->hItemHandle, cszHelpFile, HELP_WM_HELP, (ULONG_PTR)aHelpIds);
        return TRUE;
    }

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            PutCmdParm(lpdci, GetDlgItemInt(hwndDlg, IDCOUNT, &fTranslated, FALSE));
            EndDialog(hwndDlg, DRVCNF_OK);
            break;

        case IDCANCEL:
            EndDialog(hwndDlg, DRVCNF_CANCEL);
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   int | Config |
    This function creates the configuration dialog, and returns the
    value from dialog box call.

@parm   HWND | hwnd |
    Contains the handle of what is to be the parent of the dialog.

@parm   <t>LPDRVCONFIGINFO<d> | lpdci |
    Points to the driver configuration information passed to the
    configuration message.

@parm   HINSTANCE | hInstance |
    Contains a handle to the module in which the dialog is stored.

@rdesc  Returns the dialog box call function return.
*/

PUBLIC INT_PTR PASCAL FAR Config(
    HWND            hwnd,
    LPDRVCONFIGINFO lpdci,
    HINSTANCE       hInstance)
{
    return DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_CONFIG), hwnd, ConfigDlgProc, (LPARAM)lpdci);
}

/************************************************************************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mciwave\debug.c ===
/* Copyright (c) 1991-1994 Microsoft Corporation */
/*
    debug.c

    Support code for the dprintf routines.

    Note that all of this is conditional on the DBG flag

*/

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICONS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define OEMRESOURCE
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
#define NOCTLMGR
#define NODRAWTEXT
#define NOGDI
#define NOKERNEL
#define NONLS
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOMINMAX
#define NOOPENFILE
#define NOSCROLL
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOCOMM
#define NOKANJI
#define NOHELP
#define NOPROFILER
#define NODEFERWINDOWPOS

#define NOMMDRV
#define MMNOMMIO
#define MMNOJOY
#define MMNOTIMER
#define MMNOAUX
#define MMNOMIDI
#define MMNOWAVE

#include <windows.h>
#include "mciwave.h"            // private include file
#include <stdarg.h>

#if DBG
    #ifdef MEDIA_DEBUG
        int mciwaveDebugLevel = 1;
    #else
        int mciwaveDebugLevel = 1;
    #endif

/***************************************************************************

    @doc INTERNAL

    @api void | mciwaveDbgOut | This function sends output to the current
        debug output device.

    @parm LPSTR | lpszFormat | Pointer to a printf style format string.
    @parm ??? | ... | Args.

    @rdesc There is no return value.

****************************************************************************/

void mciwaveDbgOut(LPSTR lpszFormat, ...)
{
    char buf[256];
    UINT n;
    va_list va;
    UINT offset;

    // If the last character is a comma, do not add the newline
    // If the first character is a period, do not add thread/module info

    n = wsprintf(buf, "MCIWAVE: (tid %x) ", GetCurrentThreadId());
    offset = n;

    va_start(va, lpszFormat);
    n += vsprintf(buf+n, lpszFormat, va);
    if (*(buf+offset) == '.') {
	offset++;
    } else {
	offset = 0;
    }
    va_end(va);

    if (',' != buf[n-1]) {
	buf[n++] = '\n';
    }
    buf[n] = 0;
    OutputDebugString(buf+offset);
    Sleep(10);  // let terminal catch up
}

void mciwaveInitDebugLevel(void)
{
    UINT level = GetProfileInt("MMDEBUG", "MCIWAVE", 99);
    if (level != 99) {
        mciwaveDebugLevel = level;
    }
}


/***************************************************************************

    @doc INTERNAL

    @api void | dDbgAssert | This function prints an assertion message.

    @parm LPSTR | exp | Pointer to the expression string.
    @parm LPSTR | file | Pointer to the file name.
    @parm int | line | The line number.

    @rdesc There is no return value.

****************************************************************************/

void dDbgAssert(LPSTR exp, LPSTR file, int line)
{
    dprintf1(("Assertion failure:"));
    dprintf1(("  Exp: %s", exp));
    dprintf1(("  File: %s, line: %d", file, line));
    DebugBreak();
}

#endif // DBG

/**************************************************************************

    @doc INTERNAL

    @api void | mciwaveSetDebugLevel | Set the current debug level

    @parm int | iLevel | The new level to set

    @rdesc There is no return value

**************************************************************************/

void mciwaveSetDebugLevel(int level)
{
#if DBG
    mciwaveDebugLevel = level;
    dprintf(("debug level set to %d", mciwaveDebugLevel));
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mcivisca\mcivisca\viscamsg.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 * 
 *  VISCAMSG.C
 *
 *  MCI ViSCA Device Driver
 *
 *  Description:
 *
 *      ViSCA packet creation procedures
 *        ViSCA Message??_??? (MD_Mode1, MD_Mode2, etc.)
 *
 ***************************************************************************/

#define  UNICODE
#include <windows.h>
#include <windowsx.h>
#include "appport.h"
#include <math.h>
#include <string.h>
#include "viscadef.h"

//
//    The following functions prepare message headers.
//    See VISCA Developer Manual 1.0, Chapter 2.
//

/****************************************************************************
 * Function: UINT viscaHeaderFormat1 - Create a ViSCA "Format 1" header.
 *
 * Parameters:
 *
 *      LPSTR lpstrHeader - Buffer in which to create header.
 *
 *      BYTE bCategoryCode - ViSCA category code.
 *
 * Returns: length of header (2).
 ***************************************************************************/
static UINT NEAR PASCAL
viscaHeaderFormat1(LPSTR lpstrHeader, BYTE bCategoryCode)
{
    lpstrHeader[0] = 0x01;
    lpstrHeader[1] = bCategoryCode;
    return (2);
}


/****************************************************************************
 * Function: UINT viscaHeaderFormat2 - Create a ViSCA "Format 2" header.
 *
 * Parameters:
 *
 *      LPSTR lpstrHeader - Buffer in which to create header.
 *
 *      BYTE bCategoryCode - ViSCA category code.
 *
 *      BYTE bHour - Hour.
 *
 *      BYTE bMinute - Minute.
 *
 *      BYTE bSecond - Second.
 *
 *      UINT uTicks - Ticks.
 *
 * Returns: length of header (7).
 ***************************************************************************/
static UINT NEAR PASCAL
viscaHeaderFormat2(
               LPSTR   lpstrHeader,
               BYTE    bCategoryCode,
               BYTE    bHour,
               BYTE    bMinute,
               BYTE    bSecond,
               UINT    uTicks)
{
    lpstrHeader[0] = 0x02;
    lpstrHeader[1] = bCategoryCode;
    lpstrHeader[2] = TOBCD(bHour);
    lpstrHeader[3] = TOBCD(bMinute);
    lpstrHeader[4] = TOBCD(bSecond);
    lpstrHeader[5] = TOBCD(uTicks / 10);
    lpstrHeader[6] = TOBCD(uTicks % 10);
    return (7);
}


/****************************************************************************
 * Function: UINT viscaHeaderFormat3 - Create a ViSCA "Format 3" header.
 *
 * Parameters:
 *
 *      LPSTR lpstrHeader - Buffer in which to create header.
 *
 *      BYTE bCategoryCode - ViSCA category code.
 *
 *      LPSTR lpstrPosition - Position.
 *
 * Returns: length of header (7).
 ***************************************************************************/
static UINT NEAR PASCAL
viscaHeaderFormat3(
                LPSTR   lpstrHeader,
                BYTE    bCategoryCode,
                LPSTR   lpstrPosition)
{
    lpstrHeader[0] = 0x03;
    lpstrHeader[1] = bCategoryCode;
    _fmemcpy(lpstrHeader + 2, lpstrPosition, 5);
    return (7);
}


/****************************************************************************
 * Function: UINT viscaHeaderFormat4 - Create a ViSCA "Format 4" header.
 *
 * Parameters:
 *
 *      LPSTR lpstrHeader - Buffer in which to create header.
 *
 *      BYTE bCategoryCode - ViSCA category code.
 *
 *      LPSTR lpstrPosition - Position.
 *
 * Returns: length of header (7).
 ***************************************************************************/
static UINT NEAR PASCAL
viscaHeaderFormat4(
                LPSTR   lpstrHeader,
                BYTE    bCategoryCode,
                LPSTR   lpstrPosition)
{
    lpstrHeader[0] = 0x04;
    lpstrHeader[1] = bCategoryCode;
    _fmemcpy(lpstrHeader + 2, lpstrPosition, 5);
    return (7);
}


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaHeaderFormat3 - Create a ViSCA "Vendor Exclusive" header.
 *
 * Parameters:
 *
 *      LPSTR lpstrHeader - Buffer in which to create header.
 *
 *      BYTE bVendorID1 - Byte 1 of vendor ID.
 *
 *      BYTE bVendorID2 - Byte 2 of vendor ID.
 *
 *      BYTE bModelID1 - Byte 1 of model ID.
 *
 *      BYTE bModelID2 - Byte 2 of model ID.
 *
 * Returns: length of header (6).
 ***************************************************************************/
static UINT NEAR PASCAL
viscaHeaderVendorExclusive(
                LPSTR   lpstrHeader,
                BYTE    bVendorID1,
                BYTE    bVendorID2,
                BYTE    bModelID1,
                BYTE    bModelID2)
{
    lpstrHeader[0] = 0x01;
    lpstrHeader[1] = 0x7F;      /* category code */
    lpstrHeader[2] = bVendorID1;
    lpstrHeader[3] = bVendorID2;
    lpstrHeader[4] = bModelID1;
    lpstrHeader[5] = bModelID2;
    return (6);
}
#endif


/****************************************************************************
 * Function: UINT viscaHeaderFormat3 - Create a ViSCA "Inquiry" header.
 *
 * Parameters:
 *
 *      LPSTR lpstrHeader - Buffer in which to create header.
 *
 *      BYTE bCategoryCode - ViSCA category code.
 *
 * Returns: length of header in (2).
 ***************************************************************************/
static UINT NEAR PASCAL
viscaHeaderInquiry(
                LPSTR   lpstrHeader,
                BYTE    bCategoryCode)
{
    lpstrHeader[0] = 0x09;
    lpstrHeader[1] = bCategoryCode;
    return (2);
}

//
// All the viscaMessageXXXXX functions below construct messages
// with the ViSCA command format 1 header.  This is because virtually
// the entire MCI command set is written so as to be executed immediately.
// Occasionally though, it is necessary to have messages with other
// format headers.  (In particular, format 3 and 4 headers are used
// to implement to MCI_TO functionality of the MCI_PLAY and MCI_RECORD
// commands.)  Therefore the following functions convert messages
// with a format 1 header to messages with other types of headers.
//

/****************************************************************************
 * Function: UINT viscaHeaderReplaceFormat1WithFormat2 - Takes a ViSCA message
 *              with a "Format 1" header and converts it to a ViSCA message
 *              with a "Format 2" header.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - A "Format 1" message.
 *
 *      UINT cbLen - Length of message.
 *
 *      BYTE bHour - Hour.
 *
 *      BYTE bMinute - Minute.
 *
 *      BYTE bSecond - Second.
 *
 *      BYTE bTicks - Ticks.
 *
 * Returns: length message.
 ***************************************************************************/
UINT FAR PASCAL
viscaHeaderReplaceFormat1WithFormat2(
                LPSTR   lpstrMessage,
                UINT    cbLen,
                BYTE    bHour,
                BYTE    bMinute,
                BYTE    bSecond,
                UINT    uTicks)
{
    char    achTemp[MAXPACKETLENGTH];
    UINT    cb;

    cb = viscaHeaderFormat2(achTemp, lpstrMessage[1],
                            bHour, bMinute, bSecond, uTicks);
    _fmemcpy(achTemp + cb, lpstrMessage + 2, cbLen - 2);
    _fmemcpy(lpstrMessage, achTemp, cb + cbLen - 2);
    return (cb + cbLen - 2);
}


/****************************************************************************
 * Function: UINT viscaHeaderReplaceFormat1WithFormat3 - Takes a ViSCA message
 *              with a "Format 1" header and converts it to a ViSCA message
 *              with a "Format 3" header.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - A "Format 1" message.
 *
 *      UINT cbLen - Length of message.
 *
 *      LPSTR lpstrPosition - Position.
 *
 * Returns: length message.
 ***************************************************************************/
UINT FAR PASCAL
viscaHeaderReplaceFormat1WithFormat3(
                LPSTR   lpstrMessage,
                UINT    cbLen,
                LPSTR   lpstrPosition)
{
    char    achTemp[MAXPACKETLENGTH];
    UINT    cb;

    cb = viscaHeaderFormat3(achTemp, lpstrMessage[1], lpstrPosition);
    _fmemcpy(achTemp + cb, lpstrMessage + 2, cbLen - 2);
    _fmemcpy(lpstrMessage, achTemp, cb + cbLen - 2);
    return (cb + cbLen - 2);
}


/****************************************************************************
 * Function: UINT viscaHeaderReplaceFormat1WithFormat4 - Takes a ViSCA message
 *              with a "Format 1" header and converts it to a ViSCA message
 *              with a "Format 4" header.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - A "Format 1" message.
 *
 *      UINT cbLen - Length of message.
 *
 *      LPSTR lpstrPosition - Position.
 *
 * Returns: length message.
 ***************************************************************************/
UINT FAR PASCAL
viscaHeaderReplaceFormat1WithFormat4(
                LPSTR   lpstrMessage,
                UINT    cbLen,
                LPSTR   lpstrPosition)
{
    char    achTemp[MAXPACKETLENGTH];
    UINT    cb;

    cb = viscaHeaderFormat4(achTemp, lpstrMessage[1], lpstrPosition);
    _fmemcpy(achTemp + cb, lpstrMessage + 2, cbLen - 2);
    _fmemcpy(lpstrMessage, achTemp, cb + cbLen - 2);
    return (cb + cbLen - 2);
}




//
//  The following are functions to create VISCA data types.
//  See VISCA Developer Manual 1.0, Chapter 3.
//


/****************************************************************************
 * Function: UINT viscaDataTopMiddleEnd - Create a ViSCA Top/Middle/End
 *              data structure.
 *
 * Parameters:
 *
 *      LPSTR lpstrData - Buffer to hold ViSCA data structure.
 *
 *      BYTE bTopMiddleEnd - Position.  May be one of VISCATOP,
 *              VISCAMIDDLE, and VISCAEND.
 *
 * Returns: length of data structure (5).
 ***************************************************************************/
UINT FAR PASCAL
viscaDataTopMiddleEnd(
                LPSTR   lpstrData,
                BYTE    bTopMiddleEnd)
{
    lpstrData[0] = VISCADATATOPMIDDLEEND;       /* Data type ID:  Top/Middle/End */
    lpstrData[1] = bTopMiddleEnd;
    lpstrData[2] = 0x00;
    lpstrData[3] = 0x00;
    lpstrData[4] = 0x00;
    return (5);
}


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaData4DigitDecimal - Create a ViSCA 4-Digit Decimal
 *              data structure.
 *
 * Parameters:
 *
 *      LPSTR lpstrData - Buffer to hold ViSCA data structure.
 *
 *      UINT uDecimal - Decimal number.
 *
 * Returns: length of data structure (5).
 ***************************************************************************/
UINT FAR PASCAL
viscaData4DigitDecimal(
                LPSTR   lpstrData,
                UINT    uDecimal)
{
    lpstrData[0] = VISCADATA4DIGITDECIMAL;      /* Data type ID:  4 digit decimal */
    lpstrData[1] = (BYTE)( uDecimal / 1000);
    lpstrData[2] = (BYTE)((uDecimal / 100) % 10);
    lpstrData[3] = (BYTE)((uDecimal /  10) % 10);
    lpstrData[4] = (BYTE)( uDecimal        % 10);
    return (5);
}
#endif


/****************************************************************************
 * Function: UINT viscaDataPosition - Create a ViSCA position
 *              data structure.
 *
 * Parameters:
 *
 *      LPSTR lpstrData - Buffer to hold ViSCA data structure.
 *
 *      BYTE bTimeFormat - Time format.  May be one of:
 *              VISCADATAHMS, VISCADATAHMSF, VISCATIMECODENDF, and
 *              VISCADATATIMECODEDF.
 *
 *      BYTE bHours - Hours.
 *
 *      BYTE bMinutes - Minutes.
 *
 *      BYTE bSeconds - Seconds.
 *
 *      BYTE bFrames - Frames.
 *
 * Returns: length of data structure (5).
 ***************************************************************************/
UINT FAR PASCAL    
viscaDataPosition(
                LPSTR   lpstrData,
                BYTE    bTimeFormat,
                BYTE    bHours,
                BYTE    bMinutes,
                BYTE    bSeconds,
                BYTE    bFrames)
{
    lpstrData[0] = bTimeFormat;
    lpstrData[1] = TOBCD(bHours);
    lpstrData[2] = TOBCD(bMinutes);
    lpstrData[3] = TOBCD(bSeconds);
    if(bTimeFormat == VISCADATAHMS)
        lpstrData[4] = 0; /* We only support second accuracy */
    else
        lpstrData[4] = TOBCD(bFrames);
    return (5);
}


/****************************************************************************
 * Function: UINT viscaDataIndex - Create a ViSCA Index
 *              data structure.
 *
 * Parameters:
 *
 *      LPSTR lpstrData - Buffer to hold ViSCA data structure.
 *
 *      BYTE bDirection - Direction in which to search for index.
 *              May be VISCAFORWARD or VISCAREVERSE.
 *
 *      UINT uNum - Number of indices to search.
 *
 * Returns: length of data structure (5).
 ***************************************************************************/
UINT FAR PASCAL
viscaDataIndex(
                LPSTR   lpstrData,
                BYTE    bDirection,
                UINT    uNum)
{
    lpstrData[0] = VISCADATAINDEX;          // Data type ID:  Index 
    lpstrData[1] = bDirection;
    lpstrData[2] = 0x00;
    lpstrData[3] = (BYTE)(uNum / 10);
    lpstrData[4] = (BYTE)(uNum % 10);
    return (5);
}


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaDataChapter - Create a ViSCA Chapter
 *              data structure.
 *
 * Parameters:
 *
 *      LPSTR lpstrData - Buffer to hold ViSCA data structure.
 *
 *      UINT uNum - Chapter number.
 *
 * Returns: length of data structure (5).
 ***************************************************************************/
UINT FAR PASCAL
viscaDataChapter(
                LPSTR   lpstrData,
                UINT    uNum)
{
    lpstrData[0] = VISCADATACHAPTER;        // Data type ID:  Chapter 
    lpstrData[1] = 0x00;
    lpstrData[2] = 0x00;
    lpstrData[3] = (BYTE)(uNum / 10);
    lpstrData[4] = (BYTE)(uNum % 10);
    return (5);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaDataDate - Create a ViSCA Date
 *              data structure.
 *
 * Parameters:
 *
 *      LPSTR lpstrData - Buffer to hold ViSCA data structure.
 *
 *      BYTE bYear - Year.
 *
 *      BYTE bMonth - Month.
 *
 *      BYTE bDay - Day.
 *
 *      BYTE bDirection - Direction.  May be VISCAFORWARD or VISCAREVERSE.
 *
 * Returns: length of data structure (5).
 ***************************************************************************/
UINT FAR PASCAL
viscaDataDate(
                LPSTR   lpstrData,
                BYTE    bYear,
                BYTE    bMonth,
                BYTE    bDay,
                BYTE    bDirection)
{
    lpstrData[0] = VISCADATADATE;           // Data type ID:  Date 
    lpstrData[1] = (BYTE)((BYTE)((bYear / 10) * 10) | (bDirection << 4));
    lpstrData[2] = (BYTE)(bYear % 10);
    lpstrData[3] = TOBCD(bMonth);
    lpstrData[4] = TOBCD(bDay);
    return (5);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaDataTime - Create a ViSCA Time
 *              data structure.
 *
 * Parameters:
 *
 *      LPSTR lpstrData - Buffer to hold ViSCA data structure.
 *
 *      BYTE bHour - Hour.
 *
 *      BYTE bMinute - Minute.
 *
 *      BYTE bSecond - Second.
 *
 *      BYTE bDirection - Direction.  May be VISCAFORWARD or VISCAREVERSE.
 *
 * Returns: length of data structure (5).
 ***************************************************************************/
UINT FAR PASCAL
viscaDataTime(
                LPSTR   lpstrData,
                BYTE    bHour,
                BYTE    bMinute,
                BYTE    bSecond,
                BYTE    bDirection)
{
    lpstrData[0] = VISCADATATIME;           // Data type ID:  Time 
    lpstrData[1] = (BYTE)(TOBCD(bHour) | (bDirection << 4));
    lpstrData[2] = TOBCD(bMinute);
    lpstrData[3] = TOBCD(bSecond);
    lpstrData[4] = 0x00;
    return (5);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaDataUserData - Create a ViSCA User Data
 *              data structure.
 *
 * Parameters:
 *
 *      LPSTR lpstrData - Buffer to hold ViSCA data structure.
 *
 *      BYTE nByte - Byte number.
 *
 *      BYTE bDirection - Direction.  May be VISCAFORWARD or VISCAREVERSE.
 *
 *      BYTE bData - Byte value.
 *
 * Returns: length of data structure (5).
 ***************************************************************************/
UINT FAR PASCAL
viscaDataUserData(
                LPSTR   lpstrData,
                BYTE    nByte,
                BYTE    bDirection,
                BYTE    bData)
{
    lpstrData[0] = (char)(0x70 | (0x0F & nByte));    /* Data type ID:  User Data */
    lpstrData[1] = bDirection;
    lpstrData[2] = 0x00;
    lpstrData[3] = (char)(0x0F & (bData >> 4));
    lpstrData[4] = (char)(0x0F & bData);
    return (5);
}
#endif


#ifdef NOTUSED
#ifdef USEFLOATINGPOINT
/****************************************************************************
 * Function: UINT viscaDataFloatingPoint - Create a ViSCA Floating Point
 *              data structure.
 *
 * Parameters:
 *
 *      LPSTR lpstrData - Buffer to hold ViSCA data structure.
 *
 *      double dblFloat - Floating point value.
 *
 * Returns: length of data structure (5).
 *
 *        The following code has never been tested.
 *
 ***************************************************************************/
UINT FAR PASCAL
viscaDataFloatingPoint(
                LPSTR   lpstrData,
                double  dblFloat)
{
    BOOL    bNegative = (dblFloat < 0.0);
    BYTE    bExponent = 0;
    BYTE    b1000, b100, b10, b1;
    double  dblExponent;

    if (dblFloat == 0.0) {
        b1000 = b100 = b10 = b1 = 0;
    }
    else {
        if (bNegative) {
            dblFloat = (-dblFloat);
        }
        dblExponent = 3.0 - floor(log10(dblFloat));
        if ((dblExponent < 0.0) || (dblExponent > 15.0)) { /* can't store # */
            b1000 = b100 = b10 = b1 = 0;
        }
        else {
            bExponent = (char)(UINT)dblExponent;
            dblFloat *= pow(10.0, dblExponent);
            b1000 = (char)(UINT)floor(dblFloat / 1000);
            b100  = (char)(UINT)floor(fmod(dblFloat / 100, 10.0));
            b10   = (char)(UINT)floor(fmod(dblFloat / 10 , 10.0));
            b1    = (char)(UINT)floor(fmod(dblFloat     , 10.0));
        }
    }

    lpstrData[0] = (char)(0x50 | (0x0F & bExponent));   /* Data type ID:  Floating Point */
    lpstrData[1] = (char)(b1000 | (bNegative ? (1<<6) : 0));
    lpstrData[2] = b100;
    lpstrData[3] = b10;
    lpstrData[4] = b1;
    return (5);
}
#endif
#endif

//
//    The following functions create VISCA Interface messages.
//    See VISCA Developer Manual 1.0, Chapter 4.
//
/****************************************************************************
 * Function: UINT viscaMessageIF_Address - Create a ViSCA IF_Address
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message (2).
 *
 *       Address message, to initialize the addresses of all devices
 *
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageIF_Address(
                LPSTR   lpstrMessage)
{
    lpstrMessage[0] = 0x30;             /* address message */
    lpstrMessage[1] = 0x01;             /* set first device to 1 */
    return (2);
}


/****************************************************************************
 * Function: UINT viscaMessageIF_Cancel - Create a ViSCA IF_Cancel
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bSocket - Socket number of command to cancel.
 *
 * Returns: length of message (1).
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageIF_Cancel(
                LPSTR   lpstrMessage,
                BYTE    bSocket)
{
    *lpstrMessage = (char)(0x20 | (0x0F & bSocket));
    return (1);
}


/****************************************************************************
 * Function: UINT viscaMessageIF_Clear - Create a ViSCA IF_Clear
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageIF_Clear(
                LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x00);

    lpstrMessage[cb] = 0x01;        /* Clear */
    return (cb + 1);
}


/****************************************************************************
 * Function: UINT viscaMessageIF_DeviceTypeInq - Create a ViSCA IF_DeviceTypeInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageIF_DeviceTypeInq(
                LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x00);

    lpstrMessage[cb] = 0x02;
    return (cb + 1);
}


/****************************************************************************
 * Function: UINT viscaMessageIF_ClockInq - Create a ViSCA IF_ClockInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageIF_ClockInq(LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x00);

    lpstrMessage[cb] = 0x03;
    return (cb + 1);
}


/****************************************************************************
 * Function: UINT viscaMessageIF_ClockSet - Create a ViSCA IF_ClockSet
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bHours - Hours.
 *
 *      BYTE bMinutes - Minutes.
 *
 *      BYTE bSeconds - Seconds.
 *
 *      UINT uTicks - Ticks.
 *
 *      BYTE dbHours - Hours increment.
 *
 *      BYTE dbMinutes - Minutes increment.
 *
 *      BYTE dbSeconds - Seconds increment.
 *
 *      UINT duTicks - Ticks increment.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageIF_ClockSet(
                LPSTR   lpstrMessage,
                BYTE    bHours,
                BYTE    bMinutes,
                BYTE    bSeconds,
                UINT    uTicks,
                BYTE    dbHours,
                BYTE    dbMinutes,
                BYTE    dbSeconds,
                UINT    duTicks)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x00);

    lpstrMessage[cb] = 0x03;
    lpstrMessage[cb + 1] = TOBCD(bHours);
    lpstrMessage[cb + 2] = TOBCD(bMinutes);
    lpstrMessage[cb + 3] = TOBCD(bSeconds);
    lpstrMessage[cb + 4] = (char)(((uTicks / 100) << 4) | ((uTicks / 10) % 10));
    lpstrMessage[cb + 5] = (char)(uTicks % 10);
    lpstrMessage[cb + 6] = TOBCD(dbHours);
    lpstrMessage[cb + 7] = TOBCD(dbMinutes);
    lpstrMessage[cb + 8] = TOBCD(dbSeconds);
    lpstrMessage[cb + 9] = (char)(((duTicks / 100) << 4) | ((duTicks / 10) % 10));
    lpstrMessage[cb +10] = (char)(duTicks % 10);
    return (cb + 11);
}


//
//  The following functions create VISCA Control-S messages.
//  See VISCA Developer Manual 1.0, Chapter 5.
//
//  * We regret to inform you that the control-S messages have not been implemented. *
//

//
//  The following functions create VISCA Media Device messages.
//  See VISCA Developer Manual 1.0, Chapter 6.
//

#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_CameraFocus - Create a ViSCA MD_CameraFocus
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bSubCode - Focus action.  May be one of:  VISCAFOCUSSTOP,
 *              VISCAFOCUSFAR, and VISCAFOCUSNEAR.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_CameraFocus(
            LPSTR   lpstrMessage,
            BYTE    bSubCode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x08;
    lpstrMessage[cb + 1] = bSubCode;
    return (cb + 2);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_CameraZoom - Create a ViSCA MD_CameraZoom
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bSubCode - Zoom action.  May be one of:  VISCAZOOMSTOP,
 *              VISCAZOOMTELE, and VISCAZOOMWIDE.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_CameraZoom(
            LPSTR   lpstrMessage,
            BYTE    bSubCode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x07;
    lpstrMessage[cb + 1] = bSubCode;
    return (cb + 2);
}
#endif

/****************************************************************************
 * Function: UINT viscaMessageMD_EditModes - Create a ViSCA MD_EditModes
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bSubCode - Edit mode. VISCAEDITUSEFROM
 *                                    VISCAEDITUSETO
 *                                    VISCAEDITUSEFROMANDTO
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_EditModes(
            LPSTR   lpstrMessage,
            BYTE    bSubCode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb]        = 0x60;
    lpstrMessage[cb + 1]    = bSubCode;
    return (cb + 2);
}

/****************************************************************************
 * Function: UINT viscaMessageMD_Channel - Create a ViSCA MD_Channel
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      UINT uChannel - Channel number to select.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_Channel(
            LPSTR   lpstrMessage,
            UINT    uChannel)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x04;
    lpstrMessage[cb + 1] = (BYTE)(uChannel / 100);
    lpstrMessage[cb + 2] = (BYTE)((uChannel / 10) % 10);
    lpstrMessage[cb + 3] = (BYTE)(uChannel % 10);
    return (cb + 4);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_ChannelInq - Create a ViSCA MD_ChannelInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_ChannelInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x04;
    return (cb + 1);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_EditControl - Create a ViSCA MD_EditControl
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *        
 *      BYTE bSubCode - Edit action.  May be one of:
 *              VISCAEDITPBSTANDBY, VISCAEDITPLAY, VISCAEDITPLAYSHUTTLESPEED,
 *              VISCAEDITRECSTANDBY, VISCAEDITRECORD, and
 *              VISCAEDITRECORDSHUTTLESPEED.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_EditControl(
            LPSTR   lpstrMessage,
            BYTE    bHours,
            BYTE    bMinutes,
            BYTE    bSeconds,
            UINT    uTicks,
            BYTE    bSubCode)
{
    UINT    cb;

    /* these do not perform conversions, merely pick headers and add junk,
     * Headers are responsible for knowing position of atomic units only.
     */

    if ((bSubCode == VISCAEDITPBSTANDBY) ||
        (bSubCode == VISCAEDITRECSTANDBY))
    {
        cb = viscaHeaderFormat1(lpstrMessage, 0x02);
    }
    else
    {

        cb = viscaHeaderFormat2(lpstrMessage, 0x02,
                bHours,
                bMinutes,
                bSeconds,
                uTicks);

    }
    lpstrMessage[cb] = 0x05;
    lpstrMessage[cb + 1] = bSubCode;
    return (cb + 2);
}

/****************************************************************************
 * Function: UINT viscaMessageMD_EditControlInq - Create a ViSCA
 *              MD_EditControlInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_EditControlInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x05;
    lpstrMessage[cb+1] = 0x01;

    return (cb + 2);
}




/****************************************************************************
 * Function: UINT viscaMessageMD_Mode1 - Create a ViSCA MD_Mode1
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bModeCode - Mode to enter.  May be one of:
 *              VISCAMODE1STOP, VISCAMODE1FASTFORWARD, VISCAMODE1REWIND,
 *              VISCAMODE1EJECT, VISCAMODE1STILL, VISCAMODE1SLOW2,
 *              VISCAMODE1SLOW1, VISCAMODE1PLAY, VISCAMODE1SHUTTLESPEEDPLAY,
 *              VISCAMODE1FAST1, VISCAMODE1FAST2, VISCAMODE1SCAN,
 *              VISCAMODE1REVERSESLOW2, VISCAMODE1REVERSESLOW1,
 *              VISCAMODE1REVERSEPLAY, VISCAMODE1REVERSEFAST1,
 *              VISCAMODE1REVERSEFAST2, VISCAMODE1REVERSESCAN,
 *              VISCAMODE1RECPAUSE, VISCAMODE1RECORD,
 *              VISCAMODE1SHUTTLESPEEDRECORD, VISCAMODE1CAMERARECPAUSE,
 *              VISCAMODE1CAMERAREC, VISCAMODE1EDITSEARCHFORWARD, and
 *              VISCAMODE1EDITSEARCHREVERSE.
 *
 * Returns: length of message.
 *
 *       Right now the Mode1 "Shuttle speed play/record" messages are not
 *       supported, as they require a floating point parameter.
 *       Also, the Sony Vbox CI-1000 and Vdeck CVD-1000 do not support
 *       these commands.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_Mode1(
            LPSTR   lpstrMessage,
            BYTE    bModeCode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x01;
    lpstrMessage[cb + 1] = bModeCode;
    return (cb + 2);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_Mode1Inq - Create a ViSCA MD_Mode1Inq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_Mode1Inq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x01;
    return (cb + 1);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_Mode2 - Create a ViSCA MD_Mode2
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bModeCode - Mode to enter.  May be one of:
 *              VISCAMODE2FRAMEFORWARD, VISCAMODE2FRAMEREVERSE,
 *              VISCAMODE2INDEXERASE, VISCAMODE2INDEXMARK, and
 *              VISCAMODE2FRAMERECORDFORWARD.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_Mode2(
            LPSTR   lpstrMessage,
            BYTE    bModeCode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x02;
    lpstrMessage[cb + 1] = bModeCode;
    return (cb + 2);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_PositionInq - Create a ViSCA MD_PositionInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bCounterType - Counter type to request.  May be one of:
 *              VISCADATATOPMIDDLEEND, VISCADATA4DIGITDECIMAL,
 *              VISCADATAHMS, VISCADATAHMSF, VISCADATATIMECODENDF,
 *              VISCADATATIMECODEDF, VISCADATACHAPTER, VISCADATADATE,
 *              VISCADATATIME, and VISCADATAUSERDATA.  In addition,
 *              VISCADATARELATIVE and VISCADATAABSOLUTE may be specified,
 *              in which case the ViSCA device will select the data type
 *              to return.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_PositionInq(
            LPSTR   lpstrMessage,
            BYTE    bCounterType)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x03;
    lpstrMessage[cb + 1] = bCounterType;
    return (cb + 2);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_Power - Create a ViSCA MD_Power
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bSubCode - Action to take.  May be VISCAPOWERON or
 *              VISCAPOWEROFF.
 *
 * Returns: length of message.
 *
 *       Most media devices will enter "Standby" mode when set to OFF.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_Power(
            LPSTR   lpstrMessage,
            BYTE    bSubCode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x00;
    lpstrMessage[cb + 1] = bSubCode;
    return (cb + 2);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_PowerInq - Create a ViSCA MD_PowerInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_PowerInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x00;
    return (cb + 1);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_Search - Create a ViSCA MD_Search
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      LPSTR lpstrDataTarget - ViSCA data structure specifying position
 *               to which to search.
 *
 *      LPSTR bMode - Mode to enter after searching.  May be one of
 *               VISCASTOP, VISCASTILL, VISCAPLAY, and VISCANOMODE.
 *
 * Returns: length of message.
 *
 *       The mode component of the MD_Search message is optional.
 *       To ommitt the mode entry, specify VISCANOMODE.
 *       The Sony Vbox CI-1000 does not accept the mode parameter, and
 *       so VISCANOMODE must be specified if the driver is to work
 *       in the most general case.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_Search(
            LPSTR   lpstrMessage,
            LPSTR   lpstrDataTarget,
            BYTE    bMode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x03;
    _fmemcpy(&(lpstrMessage[cb + 1]), lpstrDataTarget, 5);
    if (bMode == VISCANOMODE) {     // CI-1000 V-box doesn't support mode
        return (cb + 6);
    }
    else {
        lpstrMessage[cb + 6] = bMode;
        return (cb + 7);
    }
}


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_TransportInq - Create a ViSCA MD_TransportInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_TransportInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x0A;
    return (cb + 1);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_ClockSet - Create a ViSCA MD_ClockSet
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bClockMode - Clock mode.  May be VISCACLOCKSTART or
 *              VISCACLOCKSTOP.
 *
 *      LPSTR lpstrData - ViSCA data structure specifying value to
 *               which to set the clock.
 *
 * Returns: length of message.
 *
 *       The Sony Vdec CI-1000 does not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_ClockSet(
            LPSTR   lpstrMessage,
            BYTE    bClockMode,
            LPSTR   lpstrData)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x16;
    lpstrMessage[cb + 1] = bClockMode;
    _fmemcpy(&(lpstrMessage[cb + 2]), lpstrData, 5);
    return (cb + 7);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_ClockInq - Create a ViSCA MD_ClockInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bDataType - ViSCA data type to use to retrieve clock value.
 *              May be VISCADATADATE or VISCADATATIME.
 * Returns: length of message.
 *
 *       The Sony Vbox CI-1000 and Vdeck CVD-1000 do not accept this inquiry.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_ClockInq(
            LPSTR   lpstrMessage,
            BYTE    bDataType)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x16;
    lpstrMessage[cb + 1] = bDataType;
    return (cb + 2);
}
#endif


/****************************************************************************
 * Function: UINT viscaMessageMD_MediaInq - Create a ViSCA MD_MediaInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_MediaInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x12;
    return (cb + 1);
}

/****************************************************************************
 * Function: UINT viscaMessageMD_InputSelect - Create a ViSCA MD_InputSelect
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bType - LINEVIDEO or SVIDEO or AUX, type to be set
 *
 *      BYTE bVideo - Video input selector.
 *
 *      BYTE bAudio - Audio input selector.
 *
 * Returns: length of message.
 *
 *       The Sony Vbox CI-1000 does not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_InputSelect(
            LPSTR   lpstrMessage,
            BYTE    bVideo,
            BYTE    bAudio)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);


    lpstrMessage[cb] = 0x13;
    lpstrMessage[cb + 1] = bVideo;
    lpstrMessage[cb + 2] = bAudio;
    
    return (cb + 3);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_InputSelectInq - Create a ViSCA
 *              MD_InputSelectInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_InputSelectInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x13;
    return (cb + 1);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_OSD - Create a ViSCA MD_OSD
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bPage - Page to which to set on-screen display.  May be
 *              VISCAOSDPAGEOFF, VISCAOSDPAGEDEFAULT, or a page number
 *              greater than or equal to 0x02.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_OSD(
            LPSTR   lpstrMessage,
            BYTE    bPage)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x15;
    lpstrMessage[cb + 1] = TOBCD(bPage);
    return (cb + 2);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_OSDInq - Create a ViSCA MD_OSDInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_OSDInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x15;
    return (cb + 1);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_Subcontrol - Create a ViSCA MD_Subcontrol
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bSubCode - Item to control.  May be one of:
 *              VISCACOUNTERRESET, VISCAABSOLUTECOUNTER, VISCARELATIVECOUNTER,
 *              VISCASTILLADJUSTMINUS, VISCASTILLADJUSTPLUS,
 *              VISCASLOWADJUSTMINUS, VISCASLOWADJUSTPLUS,
 *              VISCATOGGLEMAINSUBAUDIO, VISCATOGGLERECORDSPEED,
 *              VISCATOGGLEDISPLAYONOFF, and VISCACYCLEVIDEOINPUT.
 *
 * Returns: length of message.
 *
 *       The Sony Vbox CI-1000 does not accept the still- and slow-adjust
 *       commands.  The Sony Vdeck CVD-1000 does not accept the
 *       VISCATOGGLEMAINSUBAUDIO, VISCATOGGLERECORDSPEED, and
 *       VISCACYCLEVIDEOINPUT commands.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_Subcontrol(
            LPSTR   lpstrMessage,
            BYTE    bSubCode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x10;
    lpstrMessage[cb + 1] = bSubCode;
    return (cb + 2);
}


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_ConfigureIF - Create a ViSCA MD_ConfigureIF
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bFrameRate - Frame rate in frames per second.  May be
 *              VISCA25FPS or VISCA30FPS.
 *
 *      BYTE bInterfaceType - Interface type.  Should be VISCALEVEL1.
 *
 *      BYTE bControlCode - Control code.  May be VISCACONTROLNONE,
 *              VISCACONTROLSYNC, VISCACONTROLLANC, or VISCACONTROLF500
 *              (which is synonymous with VISCACONTROLLANC).
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_ConfigureIF(
            LPSTR   lpstrMessage,
            BYTE    bFrameRate,
            BYTE    bInterfaceType,
            BYTE    bControlCode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x20;
    lpstrMessage[cb + 1] = bFrameRate;
    lpstrMessage[cb + 2] = bInterfaceType;
    lpstrMessage[cb + 3] = bControlCode;
    return (cb + 4);
}
#endif


/****************************************************************************
 * Function: UINT viscaMessageMD_ConfigureIFInq - Create a ViSCA
 *              MD_ConfigureIFInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_ConfigureIFInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x20;
    return (cb + 1);
}


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_PBReset - Create a ViSCA MD_PBReset
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 *
 *       Reset playback registers.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_PBReset(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x30;
    lpstrMessage[cb + 1] = 0x00;   
    return (cb + 2);
}
#endif


/****************************************************************************
 * Function: UINT viscaMessageMD_PBTrack - Create a ViSCA MD_PBTrack
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bVideoTrack - Video track.  May be VISCATRACKNONE or
 *              VISCATRACK1.
 *
 *      BYTE bDataTrack - Data track.  May be VISCATRACKNONE or
 *              VISCATRACKTIMECODE.
 *
 *      BYTE bAudioTrack - Audio track.  May be VISCATRACKNONE,
 *              VISCATRACK8MMAFM, VISCATRACK8MMPCM,
 *              VISCATRACKVHSLINEAR, VISCATRACKVHSHIFI, or
 *              VISCATRACKVHSPCM.
 *
 * Returns: length of message.
 *
 *       Set the track registers which indicate the tracks to be played.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_PBTrack(
            LPSTR   lpstrMessage,
            BYTE    bVideoTrack,
            BYTE    bDataTrack,
            BYTE    bAudioTrack)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x31;
    lpstrMessage[cb + 1] = bVideoTrack;
    lpstrMessage[cb + 2] = bDataTrack;
    lpstrMessage[cb + 3] = bAudioTrack;
    return (cb + 4);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_PBTrackInq - Create a ViSCA MD_PBTrackInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 *
 *       Inquire for playback track register values.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_PBTrackInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x31;
    return (cb + 1);
}


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_PBTrackMode - Create a ViSCA MD_PBTrackMode
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bTrackType - Track type.  May be VISCATRACKVIDEO,
 *              VISCATRACKDATA, or VISCATRACKAUDIO.
 *
 *      BYTE bTrackNumber - Track number (0..7).
 *
 *      BYTE bTrackMode - Track mode.
 *              For video tracks, may be VISCAVIDEOMODENORMAL or
 *              VISCAVIDEOMODEEDIT.
 *              For auido tracks, may be VISCAAUDIOMODENORMAL,
 *              VISCAAUDIOMODEMONO, VISCAAUDIOMODESTEREO,
 *              VISCAAUDIOMODERIGHTONLY, VISCAAUDIOMODELEFTONLY,
 *              VISCAAUDIOMODEMULTILINGUAL, VISCAAUDIOMODEMAINCHANNELONLY, or
 *              VISCAAUDIOMODESUBCHANNELONLY.
 *
 * Returns: length of message.
 *
 *       Set the track mode register used to play a track.
 *       The Sony Vbox CI-1000 does not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_PBTrackMode(
            LPSTR   lpstrMessage,
            BYTE    bTrackType,
            BYTE    bTrackNumber,
            BYTE    bTrackMode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x32;
    lpstrMessage[cb + 1] = bTrackType;
    lpstrMessage[cb + 2] = bTrackNumber;
    lpstrMessage[cb + 3] = bTrackMode;
    return (cb + 4);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_PBTrackModeInq - Create a ViSCA 
 *              MD_PBTrackModeInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bTrackType - Track type.  May be VISCATRACKVIDEO,
 *              VISCATRACKDATA, or VISCATRACKAUDIO.
 *
 *      BYTE bTrackNumber - Track number (0..7).
 *
 * Returns: length of message.
 *
 *       Inquire for playback track mode register values.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_PBTrackModeInq(
            LPSTR   lpstrMessage,
            BYTE    bTrackType,
            BYTE    bTrackNumber)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x32;
    lpstrMessage[cb + 1] = bTrackType;
    lpstrMessage[cb + 2] = bTrackNumber;
    return (cb + 3);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_RecData - Create a ViSCA MD_RecData
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bTrackNumber - Track number (0..7).
 *
 *      LPSTR lpstrData - Data to store.
 *
 * Returns: length of message.
 *
 *       Set the record data registers.
 *       The Sony Vbox CI-1000 and Vdeck CVD-1000 do not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_RecData(
            LPSTR   lpstrMessage,
            BYTE    bTrackNumber,
            LPSTR   lpstrData)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x43;
    lpstrMessage[cb + 1] = bTrackNumber;
    _fmemcpy(&(lpstrMessage[cb + 2]), lpstrData, 5);
    return (cb + 7);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_RecDataInq - Create a ViSCA MD_RecDataInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bTrackNumber - Track number (0..7).
 *
 *      BYTE bDataType - Data type to retrieve.  May be VISCADATACHAPTER
 *              or VISCADATAUSERDATA.
 *
 * Returns: length of message.
 *
 *       Inquire for a track record data register value.
 *       The Sony Vbox CI-1000 and Vdeck CVD-1000 do not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_RecDataInq(
            LPSTR   lpstrMessage,
            BYTE    bTrackNumber,
            BYTE    bDataType)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x43;
    lpstrMessage[cb + 1] = bTrackNumber;
    lpstrMessage[cb + 2] = bDataType;
    return (cb + 3);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_RecReset - Create a ViSCA MD_RecReset
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 *
 *       Reset record registers.
 *       The Sony Vbox CI-1000 does not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_RecReset(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x40;
    lpstrMessage[cb + 1] = 0x00;
    return (cb + 2);
}
#endif


/****************************************************************************
 * Function: UINT viscaMessageMD_RecSpeed - Create a ViSCA MD_RecSpeed
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bSpeed - Recording speed.  May be VISCASPEEDSP,
 *              VISCASPEEDLP, VISCASPEEDEP, VISCASPEEDBETAI,
 *              VISCASPEEDBETAII, or VISCASPEEDBETAIII.
 *
 * Returns: length of message.
 *
 *       Set the record speed register used for recording.
 *       The Sony Vbox CI-1000 does not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_RecSpeed(
            LPSTR   lpstrMessage,
            BYTE    bSpeed)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x4B;
    lpstrMessage[cb + 1] = bSpeed;
    return (cb + 2);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_RecSpeedInq - Create a ViSCA MD_RecSpeedInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 *
 *       Inquire for the record speed register value.
 *       The Sony Vbox CI-1000 does not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_RecSpeedInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x4B;
    return (cb + 1);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_RecTrack - Create a ViSCA MD_RecTrack
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bRecordMode - Record mode.  May be VISCARECORDMODEASSEMBLE or
 *              VISCARECORDMODEINSERT.
 *
 *      BYTE bVideoTrack - Video track.  May be VISCATRACKNONE or
 *              VISCATRACK1.
 *
 *      BYTE bDataTrack - Data track.  May be VISCATRACKNONE or
 *              VISCATRACKTIMECODE.
 *
 *      BYTE bAudioTrack - Audio track.  May be VISCATRACKNONE,
 *              VISCATRACK8MMAFM, VISCATRACK8MMPCM,
 *              VISCATRACKVHSLINEAR, VISCATRACKVHSHIFI, or
 *              VISCATRACKVHSPCM.
 *
 * Returns: length of message.
 *
 *       Set the record track registers that indicate the tracks to be
 *       recorded.
 *       The Sony Vbox CI-1000 does not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_RecTrack(
            LPSTR   lpstrMessage,
            BYTE    bRecordMode,
            BYTE    bVideoTrack,
            BYTE    bDataTrack,
            BYTE    bAudioTrack)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x41;
    lpstrMessage[cb + 1] = bRecordMode;
    lpstrMessage[cb + 2] = bVideoTrack;
    lpstrMessage[cb + 3] = bDataTrack;
    lpstrMessage[cb + 4] = bAudioTrack;
    return (cb + 5);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_RecTrackInq - Create a ViSCA MD_RecTrackInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 *
 *       Inquire for the record track register values.
 *       The Sony Vbox CI-1000 does not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_RecTrackInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x41;
    return (cb + 1);
}


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_RecTrackMode - Create a ViSCA MD_RecTrackMode
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bTrackType - Track type.  May be VISCATRACKVIDEO,
 *              VISCATRACKDATA, or VISCATRACKAUDIO.
 *
 *      BYTE bTrackNumber - Track number (0..7).
 *
 *      BYTE bTrackMode - Track mode.
 *              For video tracks, may be VISCAVIDEOMODENORMAL,
 *              VISCAVIDEOMODESTANDARD, or VISCAVIDEOMODEHIQUALITY.
 *              For data tracks, may be VISCADATAMODENORMAL,
 *              VISCADATAMODETIMECODE, VISCADATAMODEDATEANDTIMECODE, or
 *              VISCADATAMODECHAPTERANDUSERDATAANDTIMECODE.
 *              For auido tracks, may be VISCAAUDIOMODENORMAL,
 *              VISCAAUDIOMODEMONO, VISCAAUDIOMODESTEREO,
 *              VISCAAUDIOMODERIGHTONLY, VISCAAUDIOMODELEFTONLY,
 *              VISCAAUDIOMODEMULTILINGUAL, VISCAAUDIOMODEMAINCHANNELONLY, or
 *              VISCAAUDIOMODESUBCHANNELONLY.
 *
 * Returns: length of message.
 *
 *       Set the track mode register used when recording a track.
 *       The Sony Vbox CI-1000 does not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_RecTrackMode(
            LPSTR   lpstrMessage,
            BYTE    bTrackType,
            BYTE    bTrackNumber,
            BYTE    bTrackMode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x42;
    lpstrMessage[cb + 1] = bTrackType;
    lpstrMessage[cb + 2] = bTrackNumber;
    lpstrMessage[cb + 3] = bTrackMode;
    return (cb + 4);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_RecTrackModeInq - Create a ViSCA 
 *              MD_RecTrackModeInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bTrackType - Track type.  May be VISCATRACKVIDEO,
 *              VISCATRACKDATA, or VISCATRACKAUDIO.
 *
 *      BYTE bTrackNumber - Track number (0..7).
 *
 * Returns: length of message.
 *
 *       Inquire for the record track register values.
 *       The Sony Vbox CI-1000 does not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_RecTrackModeInq(
            LPSTR   lpstrMessage,
            BYTE    bTrackType,
            BYTE    bTrackNumber)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x42;
    lpstrMessage[cb + 1] = bTrackType;
    lpstrMessage[cb + 2] = bTrackNumber;
    return (cb + 3);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_MediaSpeedInq - Create a ViSCA 
 *              MD_MediaSpeedInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 *
 *       Inquire for the recorded speed of the mounted media.
 *       The Sony Vbox CI-1000 and Vdeck CVD-1000 do not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_MediaSpeedInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x5B;
    return (cb + 1);
}
#endif


/****************************************************************************
 * Function: UINT viscaMessageMD_MediaTrackInq - Create a ViSCA 
 *              MD_MediaTrackInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 *
 *       Inquire for the tracks available on the mounted media.
 *       The Sony Vbox CI-1000 does not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_MediaTrackInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x51;
    return (cb + 1);
}


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_MediaTrackModeInq - Create a ViSCA 
 *              MD_MediaTrackModeInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bTrackType - Track type.  May be VISCATRACKVIDEO,
 *              VISCATRACKDATA, or VISCATRACKAUDIO.
 *
 *      BYTE bTrackNumber - Track number (0..7).
 *
 * Returns: length of message.
 *
 *       Inquire for the mode used to record a track on the mounted media.
 *       The Sony Vbox CI-1000 does not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_MediaTrackModeInq(
            LPSTR   lpstrMessage,
            BYTE    bTrackType,
            BYTE    bTrackNumber)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x52;
    lpstrMessage[cb + 1] = bTrackType;
    lpstrMessage[cb + 2] = bTrackNumber;
    return (cb + 3);
}
#endif


/****************************************************************************
 * Function: UINT viscaMessageMD_SegInPoint - Create a ViSCA 
 *              MD_SegInPoint message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      LPSTR lpstrData - ViSCA data to store.
 *
 * Returns: length of message.
 *
 *       Set the segment in point register.
 *       The Sony Vbox CI-1000 and Vdeck CVD-100 do not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_SegInPoint(
            LPSTR   lpstrMessage,
            LPSTR   lpstrData)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x61;
    _fmemcpy(&(lpstrMessage[cb + 1]), lpstrData, 5);
    return (cb + 6);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_SegInPointInq - Create a ViSCA 
 *              MD_SegInPointInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *       Inquire for the segment in point register value.
 *       The Sony Vbox CI-1000 and Vdeck CVD-100 do not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_SegInPointInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x61;
    return (cb + 1);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_SegOutPoint - Create a ViSCA 
 *              MD_SegOutPoint message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      LPSTR lpstrData - ViSCA data to store.
 *
 * Returns: length of message.
 *
 *       Set the segment out point register.
 *       The Sony Vbox CI-1000 and Vdeck CVD-100 do not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_SegOutPoint(
            LPSTR   lpstrMessage,
            LPSTR   lpstrData)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x62;
    _fmemcpy(&(lpstrMessage[cb + 1]), lpstrData, 5);
    return (cb + 6);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_SegOutPointInq - Create a ViSCA 
 *              MD_SegOutPointInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *       Inquire for the segment out point register value.
 *       The Sony Vbox CI-1000 and Vdeck CVD-100 do not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_SegOutPointInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x62;
    return (cb + 1);
}

/****************************************************************************
 * Function: UINT viscaMessageMD_SegPreRollDuration - Create a ViSCA 
 *              MD_SegPreRollDuration message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      LPSTR lpstrData - ViSCA data to store.
 *
 * Returns: length of message.
 *
 *       Set the segment pre-roll duration register.
 *       The Sony Vbox CI-1000 and Vdeck CVD-100 do not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_SegPreRollDuration(
            LPSTR   lpstrMessage,
            LPSTR   lpstrData)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x63;
    _fmemcpy(&(lpstrMessage[cb + 1]), lpstrData, 5);
    return (cb + 6);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_SegPreRollDurationInq - Create a ViSCA 
 *              MD_SegPreRollDurationInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *       Inquire for the segment pre-roll duration register value.
 *       The Sony Vbox CI-1000 and Vdeck CVD-100 do not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_SegPreRollDurationInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x63;
    return (cb + 1);
}

/****************************************************************************
 * Function: UINT viscaMessageMD_SegPostRollDuration - Create a ViSCA 
 *              MD_SegPostRollDuration message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      LPSTR lpstrData - ViSCA data to store.
 *
 * Returns: length of message.
 *
 *       Set the segment post-roll duration register.
 *       The Sony Vbox CI-1000 and Vdeck CVD-100 do not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_SegPostRollDuration(
            LPSTR   lpstrMessage,
            LPSTR   lpstrData)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x64;
    _fmemcpy(&(lpstrMessage[cb + 1]), lpstrData, 5);
    return (cb + 6);
}

/****************************************************************************
 * Function: UINT viscaMessageMD_SegPostRollDurationInq - Create a ViSCA 
 *              MD_SegPostRollDurationInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 *
 *       Inquire for the segment post-roll duration register value.
 *       The Sony Vbox CI-1000 and Vdeck CVD-100 do not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_SegPostRollDurationInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x64;
    return (cb + 1);
}

//
// The following are special mode commands taken from Sony EVO-9650 VISCA reference
//
//

/****************************************************************************
 * Function: UINT viscaMessageENT_FrameStill - Create a ViSCA ENT_FrameStill
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bSubCode - Action to take.  May be VISCSTILLON or
 *              VISCASTILLOFF
 *
 * Returns: length of message.
 *
 *       Most media devices will enter "Standby" mode when set to OFF.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageENT_FrameStill(
            LPSTR   lpstrMessage,
            BYTE    bSubCode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x7E);
    
    /*  -- This is category 7e! */
    
    lpstrMessage[cb]     = 0x00;
    lpstrMessage[cb + 1] = 0x01;
    lpstrMessage[cb + 2] = 0x02;
    lpstrMessage[cb + 3] = 0x03;
    lpstrMessage[cb + 4] = 0x04;    
    lpstrMessage[cb + 5] = bSubCode;    
    
    return (cb + 6);
}

/****************************************************************************
 * Function: UINT viscaMessageENT_FrameMemorySelect - Create a ViSCA ENT_FrameMemorySelect
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bSubCode - Action to take.  May be VISCABUFFER or
 *              VISCADNR
 *
 * Returns: length of message.
 *
 *       Most media devices will enter "Standby" mode when set to OFF.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageENT_FrameMemorySelect(
            LPSTR   lpstrMessage,
            BYTE    bSubCode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x7E);
    
    /*  -- This is category 7e! */
    
    lpstrMessage[cb]     = 0x00;
    lpstrMessage[cb + 1] = 0x01;
    lpstrMessage[cb + 2] = 0x02;
    lpstrMessage[cb + 3] = 0x03;
    lpstrMessage[cb + 4] = 0x05;    
    lpstrMessage[cb + 5] = bSubCode;    
    
    return (cb + 6);
}


/****************************************************************************
 * Function: UINT viscaMessageENT_FrameMemorySelectInq - Create a ViSCA MD_Mode1Inq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageENT_FrameMemorySelectInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x7E);

    lpstrMessage[cb]    = 0x00;
    lpstrMessage[cb+1]  = 0x01;
    lpstrMessage[cb+2]  = 0x02;
    lpstrMessage[cb+3]  = 0x03;
    lpstrMessage[cb+4]  = 0x05;

    return (cb + 5);
}


/****************************************************************************
 * Function: UINT   viscaMessageENT_NFrameRec - Create a ViSCA ENT_FrameMemorySelect
 *                      message.
 *
 * Parameters:
 *
 *      LPSTR  lpstrMessage  - Buffer to hold ViSCA message.
 *
 *      int    iSubCode      - Number of frames
 *
 * Returns: length of message.
 *
 *       Most media devices will enter "Standby" mode when set to OFF.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageENT_NFrameRec(
            LPSTR   lpstrMessage,
            int     iSubCode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x7E);
    
    /*  -- This is category 7e! */
    
    lpstrMessage[cb]     = 0x00;
    lpstrMessage[cb + 1] = 0x01;
    lpstrMessage[cb + 2] = 0x02;
    lpstrMessage[cb + 3] = 0x03;
    lpstrMessage[cb + 4] = 0x03;
    lpstrMessage[cb + 5] = 0x00;
    lpstrMessage[cb + 6] = (BYTE)(iSubCode / 100);
    lpstrMessage[cb + 7] = (BYTE)((iSubCode / 10) % 10);
    lpstrMessage[cb + 8] = (BYTE)(iSubCode % 10);
    
    return (cb + 9);
}

//
// The following are special effects modes taken from Sony EVO-9650 VISCA manual.
//
//

/****************************************************************************
 * Function: UINT   viscaMessageSE_VDEReadMode - 
 *              message.
 *
 * Parameters:
 *
 *      LPSTR  lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE   bSubCode - Action to take.  May be VISCABUFFER or
 *                  VISCADNR
 *
 * Returns: length of message.
 *
 *       Most media devices will enter "Standby" mode when set to OFF.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageSE_VDEReadMode(
            LPSTR   lpstrMessage,
            BYTE    bSubCode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x03);
    
    lpstrMessage[cb]     = 0x43;
    lpstrMessage[cb + 1] = 0x01;
    lpstrMessage[cb + 2] = bSubCode;
    
    return (cb + 3);
}

/****************************************************************************
 * Function: UINT viscaMessageSE_VDEReadModeInq - Create a ViSCA MD_Mode1Inq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageSE_VDEReadModeInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x03);

    lpstrMessage[cb]    = 0x43;
    lpstrMessage[cb+1]  = 0x01;

    return (cb + 2);
}

//
//  The following functions create VISCA Switcher messages.
//  See VISCA Developer Manual 1.0, Chapter 7.
//

#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageSwitcher_IO - Create a ViSCA 
 *              Switcher_IO message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE nMatrix - Matrix number.
 *
 *      BYTE nVidOutChannel - Video output channel.
 *
 *      BYTE nVidInChannel - Video input channel.
 *
 *      BYTE nAudOutChannel - Audio output channel.
 *
 *      BYTE nAudInChannel - Audio input channel.
 *
 * Returns: length of message.
 *
 *       Route audio and video signals from inputs to outputs.
 *       If audio and video signals cannot be routed independently,
 *       then the audio input/output channel numbers will be ignored.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageSwitcher_IO(
                LPSTR   lpstrMessage,
                BYTE    nMatrix,
                BYTE    nVidOutChannel,
                BYTE    nVidInChannel,
                BYTE    nAudOutChannel,
                BYTE    nAudInChannel)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x03);

    lpstrMessage[cb] = 0x11;
    lpstrMessage[cb + 1] = TOBCD(nMatrix);
    lpstrMessage[cb + 2] = TOBCD(nVidOutChannel);
    lpstrMessage[cb + 3] = TOBCD(nVidInChannel);
    lpstrMessage[cb + 4] = TOBCD(nAudOutChannel);
    lpstrMessage[cb + 5] = TOBCD(nAudInChannel);
    return (cb + 6);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageSwitcher_IOConfigInq - Create a ViSCA 
 *              Switcher_IOConfigInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE nMatrix - Matrix number.
 *
 * Returns: length of message.
 *
 *       Inquire for configuration of a selector matrix.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageSwitcher_IOConfigInq(
                LPSTR   lpstrMessage,
                BYTE    nMatrix)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x03);

    lpstrMessage[cb] = 0x10;
    lpstrMessage[cb + 1] = TOBCD(nMatrix);
    return (cb + 2);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageSwitcher_IOInq - Create a ViSCA 
 *              Switcher_IOInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE nMatrix - Matrix number.
 *
 *      BYTE nVidOutChannel - Video output channel.
 *
 *      BYTE nAudOutChannel - Audio output channel.
 *
 * Returns: length of message.
 *
 *       Inquire for inputs selected for the specified outputs.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageSwitcher_IOInq(
                LPSTR   lpstrMessage,
                BYTE    nMatrix,
                BYTE    nVidOutChannel,
                BYTE    nAudOutChannel)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x03);

    lpstrMessage[cb] = 0x11;
    lpstrMessage[cb + 1] = TOBCD(nMatrix);
    lpstrMessage[cb + 2] = TOBCD(nVidOutChannel);
    lpstrMessage[cb + 3] = TOBCD(nAudOutChannel);
    return (cb + 4);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageSwitcher_FX - Create a ViSCA 
 *              Switcher_FX message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE nEffector - Effector number.
 *
 *      BYTE nEffectMode - Effect mode.
 *
 *      BYTE bTargetLevel - Target level (0..255).
 *
 *      BYTE cDurationSeconds - Duration (seconds).
 *
 *      BYTE cDurationFrames - Duration (frames).
 *
 * Returns: length of message.
 *
 *       Start an effect.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageSwitcher_FX(
                LPSTR   lpstrMessage,
                BYTE    nEffector,
                BYTE    nEffectMode,
                BYTE    bTargetLevel,
                BYTE    cDurationSeconds,
                BYTE    cDurationFrames)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x03);

    lpstrMessage[cb] = 0x21;
    lpstrMessage[cb + 1] = nEffector;
    lpstrMessage[cb + 2] = nEffectMode;
    lpstrMessage[cb + 3] = (BYTE)(bTargetLevel >> 4);
    lpstrMessage[cb + 4] = (BYTE)(bTargetLevel & 0x0F);
    lpstrMessage[cb + 5] = TOBCD(cDurationSeconds);
    lpstrMessage[cb + 6] = TOBCD(cDurationFrames);
    return (cb + 7);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageSwitcher_FXConfigInq - Create a ViSCA 
 *              Switcher_FXConfigInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE nEffector - Effector number.
 *
 * Returns: length of message.
 *
 *       Inquire for effector configuration.
 *       If nEffector is 0, then inquires for number of effectors.
 *       If nEffector is 1 or greater, then inquires for configuration
 *       of the specified effector.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageSwitcher_FXConfigInq(
                LPSTR   lpstrMessage,
                BYTE    nEffector)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x03);

    lpstrMessage[cb] = 0x20;
    lpstrMessage[cb + 1] = TOBCD(nEffector);
    return (cb + 2);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageSwitcher_FXInq - Create a ViSCA 
 *              Switcher_FXInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE nEffector - Effector number.
 *
 * Returns: length of message.
 *
 *       Inquire for level of the specified effector.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageSwitcher_FXInq(
                LPSTR   lpstrMessage,
                BYTE    nEffector)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x03);

    lpstrMessage[cb] = 0x21;
    lpstrMessage[cb + 1] = TOBCD(nEffector);
    return (cb + 2);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mcivisca\mcivisca\viscacom.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 * 
 *  VISCACOM.C
 *
 *  MCI ViSCA Device Driver
 *
 *  Description:
 *
 *      Comm port procedures
 *
 ***************************************************************************/

#define  UNICODE
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include "appport.h"
#include <mmddk.h>
#include <string.h>
#include "vcr.h"
#include "viscadef.h"
#include "mcivisca.h"
#include "common.h"     //debugging macros

//
// This is used internally within this file. It is never returned to the calling process.
//
#define MCIERR_VCR_BREAK                    (MCIERR_CUSTOM_DRIVER_BASE)

/****************************************************************************
 * Function: BOOL viscaReleaseMutex  - Unlock the synchronization flag.
 *
 * Parameters:
 *
 *      BOOL FAR * gfFlag - Pointer to synchronization flag.
 *
 * Returns: state before unlock (either locked==0 or unlocked==1)
 *        
 ***************************************************************************/
BOOL FAR PASCAL viscaReleaseMutex(VISCAINSTHANDLE gfFlag)
{
#ifdef _WIN32
    DWORD dwResult;

    if(!ReleaseMutex(gfFlag))
    {
        dwResult = GetLastError();
        DPF(DBG_ERROR, "ReleaseMutex failed. %x Error:%u \n", gfFlag, dwResult);
        return FALSE;
    }

    DPF(DBG_SYNC, "viscaReleaseMutex. %x\n", gfFlag);
    return TRUE;
#else
    // Releasing a semaphore/mutex just increments its count/or sets it to true.
    BOOL fBefore = *gfFlag;
    *gfFlag = TRUE;
    return fBefore;
#endif
}


/****************************************************************************
 * Function: BOOL viscaReleaseMutex  - Unlock the synchronization flag.
 *
 * Parameters:
 *
 *      BOOL FAR * gfFlag - Pointer to synchronization flag.
 *
 * Returns: state before unlock (either locked==0 or unlocked==1)
 *        
 ***************************************************************************/
BOOL FAR PASCAL viscaReleaseSemaphore(VISCAINSTHANDLE gfFlag)
{
#ifdef _WIN32
    DWORD dwResult;

    if(!ReleaseSemaphore(gfFlag, 1, NULL))
    {
        dwResult = GetLastError();
        DPF(DBG_ERROR, "ReleaseSemaphore failed. %x Error:%u \n", gfFlag, dwResult);
        return FALSE;
    }

    DPF(DBG_SYNC, "viscaReleaseSemaphore. %x\n", gfFlag);
    return TRUE;
#else
    // Releasing a semaphore/mutex just increments its count/or sets it to true.
    BOOL fBefore = *gfFlag;
    *gfFlag      = TRUE;
    return fBefore;
#endif
}


/****************************************************************************
 * Function: BOOL viscaResetEvent  - Unlock the synchronization flag.
 *
 * Parameters:
 *
 *      BOOL FAR * gfFlag - Pointer to synchronization flag.
 *
 * Returns: state before unlock (either locked==0 or unlocked==1)
 *        
 ***************************************************************************/
BOOL FAR PASCAL viscaResetEvent(VISCAINSTHANDLE gfFlag)
{
#ifdef _WIN32
    DWORD dwResult;

    if(!ResetEvent(gfFlag))
    {
        dwResult = GetLastError();
        DPF(DBG_ERROR, "ResetEvent failed. %x Error:%u \n", gfFlag, dwResult);
        return FALSE;
    }
    DPF(DBG_SYNC, "viscaResetEvent %x.\n", gfFlag);
    return TRUE;
#else
    BOOL fBefore = *gfFlag;
    *gfFlag = FALSE;
    return fBefore;
#endif
}


/****************************************************************************
 * Function: BOOL viscaSetEvent  - Unlock the synchronization flag.
 *
 * Parameters:
 *
 *      BOOL FAR * gfFlag - Pointer to synchronization flag.
 *
 * Returns: state before unlock (either locked==0 or unlocked==1)
 *        
 ***************************************************************************/
BOOL FAR PASCAL viscaSetEvent(VISCAINSTHANDLE gfFlag)
{
#ifdef _WIN32
    DWORD dwResult;

    if(!SetEvent(gfFlag))
    {
        dwResult = GetLastError();
        DPF(DBG_ERROR, "SetEvent failed. %x Error:%u \n", gfFlag, dwResult);
        return FALSE;
    }
    DPF(DBG_SYNC, "viscaSetEvent %x.\n", gfFlag);
    return TRUE;
#else
    BOOL fBefore = *gfFlag;
    *gfFlag = TRUE;
    return fBefore;
#endif
}


/****************************************************************************
 * Function: BOOL viscaWaitForSingleObject - Wait for unlock, and then lock.
 *
 * Returns: true if unlock came before timeout.
 *        
 ***************************************************************************/
DWORD FAR PASCAL viscaWaitForSingleObject(VISCAINSTHANDLE gfFlag, BOOL fManual, DWORD dwTimeout, UINT uDeviceID)
{
#ifdef _WIN32
    DWORD dwResult, dwErrorResult;
    DWORD dwBreakTimeout = 250;

    // Succees is WAIT_ABANDONED, WAIT_OBJECT_0, WAIT_TIMEOUT
    // Failure is WAIT_FAILED == 0xffffffff            

    if(uDeviceID == 0)
    {
        dwResult = WaitForSingleObject(gfFlag, dwTimeout); // Infinite wait, and auto lock.
    }
    else
    {
        // Should be infinite for all these cases!
        while(1)
        {
            dwResult = WaitForSingleObject(gfFlag, dwBreakTimeout);

            if(dwResult == WAIT_TIMEOUT)
            {
                if (mciDriverYield(uDeviceID))
                {
                    DPF(DBG_SYNC, "Break received, relocking the device\n");
                    return FALSE;
                }
            }
            else
            {
                // Wait failed or wait success!
                break;
            }
        }
    }

    if(dwResult == WAIT_FAILED)
    {
        dwErrorResult = GetLastError();
        DPF(DBG_ERROR, "WaitForSingleObject %x Error:%u\n", gfFlag, dwErrorResult);
        return FALSE;
    }
    else if(dwResult == WAIT_TIMEOUT)
    {
        DPF(DBG_ERROR, "WaitForSingleObject %x Error:Timeout:%u", gfFlag, dwTimeout);
        return WAIT_TIMEOUT;
    }

    DPF(DBG_SYNC, "viscaWaitForSingleObject %x.\n", gfFlag);
#else
    DWORD   dwTime0     = GetTickCount();
    DWORD   dwTime;

    // It is locked when it is false.
    //
    // Wait until it goes to true. i.e. becomes unlocked.
    // Then set it to locked. i.e. Set it to false again.
    // So when we exit we are in locked state.
    //
    DPF(DBG_SYNC, "viscaWait <----- enter. &flag=%x\n", gfFlag);

    while(!*gfFlag)
    {
        if(dwTimeout != MY_INFINITE)
        {
            dwTime = GetTickCount();
            if (((dwTime < dwTime0) && ((dwTime + (ROLLOVER - dwTime0)) > dwTimeout)) ||
                    ((dwTime - dwTime0) > dwTimeout))
            {
                DPF(DBG_ERROR, "viscaWait - Timeout.\n");
                return WAIT_TIMEOUT;
            }
        }

        if(uDeviceID != 0)
        {
            if (mciDriverYield(uDeviceID))
            {
                DPF(DBG_SYNC, "Break received, relocking the device\n");
                return FALSE;
            }
        }
        else
        {
            Yield();
        }
    }

    DPF(DBG_SYNC, "viscaWait ----> exit. &flag=%x\n", gfFlag);

    if(!fManual)
        *gfFlag = FALSE;

#endif
    return 1L;
}

/****************************************************************************
 * Function: DWORD viscaErrorToMCIERR - Convert a ViSCA error code to an
 *               MCI error code (MCIERR_XXXX).
 *
 * Parameters:
 *
 *      BYTE bError - ViSCA error code.
 *
 * Returns: an MCI error code.
 *
 *       Converts a ViSCA error code to an MCI error code.
 *       If the ViSCA error code is not one of the predefined error codes,
 *       then MCIERR_DRIVER is returned.
 ***************************************************************************/
DWORD FAR PASCAL
    viscaErrorToMCIERR(BYTE bError)
{
    switch (bError) {
        case (BYTE)0x00:
            return (MCIERR_NO_ERROR);
        case VISCAERRORBUFFERFULL:
            return (MCIERR_VCR_COMMAND_BUFFER_FULL);
        case VISCAERRORCANCELLED:
            return (MCIERR_VCR_COMMAND_CANCELLED);
        case VISCAERRORPOWEROFF:
            return (MCIERR_VCR_POWER_OFF);
        case VISCAERRORCOMMANDFAILED:
            return (MCIERR_VCR_COMMAND_FAILED);
        case VISCAERRORSEARCH:
            return (MCIERR_VCR_SEARCH);
        case VISCAERRORCONDITION:
            return (MCIERR_VCR_CONDITION);
        case VISCAERRORCAMERAMODE:
            return (MCIERR_VCR_CAMERA_MODE);
        case VISCAERRORVCRMODE:
            return (MCIERR_VCR_VCR_MODE);
        case VISCAERRORCOUNTERTYPE:
            return (MCIERR_VCR_COUNTER_TYPE);
        case VISCAERRORTUNER:
            return (MCIERR_VCR_TUNER);
        case VISCAERROREMERGENCYSTOP:
            return (MCIERR_VCR_EMERGENCY_STOP);
        case VISCAERRORMEDIAUNMOUNTED:
            return (MCIERR_VCR_MEDIA_UNMOUNTED);
        case VISCAERRORSYNTAX:
            return (MCIERR_UNSUPPORTED_FUNCTION);
        case VISCAERRORREGISTER:
        case VISCAERRORREGISTERMODE:
            return (MCIERR_VCR_REGISTER);
        case VISCAERRORMESSAGELENGTH:
        case VISCAERRORNOSOCKET:
        default:
            return (MCIERR_DRIVER_INTERNAL);
    }
}

#ifdef DEBUG
/****************************************************************************
 * Function: void viscaPacketPrint - Print a ViSCA packet.
 *
 * Parameters:
 *
 *      LPSTR lpstrData - Data to print.
 *
 *      UINT cbData - Number of bytes to print.
 ***************************************************************************/
void FAR PASCAL
viscaPacketPrint(LPSTR lpstrData, UINT cbData)
{
    char    sz[128];
    LPSTR   lpch = sz;
    UINT    i;

    for (i = 0; i < cbData; i++, lpch += 5)
    {
#ifdef _WIN32
        wsprintfA(lpch, "%#02x ", (UINT)(BYTE)(lpstrData[i]));
#else
        wsprintf(lpch, "%#02x ", (UINT)(BYTE)(lpstrData[i]));
#endif
    }
    *lpch++ = '\n';
    *lpch = '\0';
#ifdef _WIN32
    OutputDebugStringA(sz);  // This MUST print in ASCII, override unicode!
#else
    DPF(DBG_COMM, sz);
#endif
}
#endif

/****************************************************************************
 * Function: BOOL viscaWriteCancel - Write cancel command
 *
 * Parameters:
 *
 *      int iInst - Comm device ID.
 *
 *      BYTE  bDest - Destination device (where to cancel)
 *
 *      LPSTR lpstrPacket - the cancel message.
 *
 *      UINT  cbMessageLength - message length.
 *
 * Returns: TRUE if successful or FALSE
 *
 ***************************************************************************/
BOOL FAR PASCAL
viscaWriteCancel(int iInst, BYTE bDest, LPSTR lpstrPacket, UINT cbMessageLength)
{
    lpstrPacket[0]                   = MAKEDEST(bDest);
    lpstrPacket[cbMessageLength + 1] = VISCAPACKETEND;

    DPF(DBG_QUEUE, "###Wrote Cancel: ");
    viscaPacketPrint(lpstrPacket, cbMessageLength + 2);

    // Do not lock here. Already should have been acquired.
#ifdef _WIN32
    WaitForSingleObject(pinst[iInst].pfTxBuffer, MY_INFINITE);  // This synchronizes to port.

    // Copy it to the Port Tx buffer.
    _fmemcpy(pvcr->Port[pinst[iInst].iPort].achTxPacket, lpstrPacket, cbMessageLength + 2);
    pvcr->Port[pinst[iInst].iPort].nchTxPacket = cbMessageLength + 2;

    // Signal that it is time to transmit. (we must use our version of the handle).
    SetEvent(pinst[iInst].pfTxReady);
#else
    if(!viscaCommWrite(pvcr->Port[pinst[iInst].iPort].idComDev, lpstrPacket, cbMessageLength + 2))
        return FALSE;
#endif

    return TRUE;
}


/****************************************************************************
 * Function: BOOL viscaWrite - Write a ViSCA packet.
 *
 * Parameters:
 *
 *      int iInst - Pointer to OpenInstance struct identifying
 *                               the MCI device which is doing the writing.
 *
 *      BYTE bDest - Destination device ID (1..7).
 *
 *      LPSTR lpstrPacket - Buffer containing ViSCA packet.
 *                             The ViSCA message is assumed to exist already
 *                             starting at lpstrPacket + 1.
 *
 *      UINT  cbMessageLength - Length of ViSCA message.
 *
 *      HWND  hwndNotify   - Window to notify on completion.
 *
 *      DWORD dwFlags      - MCI-flags (MCI_WAIT and/or MCI_NOTIFY)
 *
 *      BOOL  fQueue       - Is this a queued command or just syncrhonous.
 *
 * Returns: TRUE if things went ok, FALSE otherwise.
 *
 ***************************************************************************/
BOOL FAR PASCAL
    viscaWrite(int iInst,  BYTE bDest, LPSTR lpstrPacket,
        UINT cbMessageLength, HWND hwndNotify, DWORD dwFlags, BOOL fQueue)
{
    UINT iPort = pinst[iInst].iPort;
    UINT iDev  = pinst[iInst].iDev;
    UINT uTimerID = 0;

    if (bDest == BROADCASTADDRESS)
        pvcr->Port[iPort].iBroadcastDev = iDev;

    lpstrPacket[0]                   = MAKEDEST(bDest);
    lpstrPacket[cbMessageLength + 1] = VISCAPACKETEND;
    //
    // Allow only one out-standing message to a device at a time 
    //
    if(viscaWaitForSingleObject(pinst[iInst].pfTxLock, FALSE, 10000L, pinst[iInst].uDeviceID) == WAIT_TIMEOUT)
    {
        DPF(DBG_ERROR, "Failed waiting pfTxLock in viscaWrite.\n");
        return FALSE;
    }
    //
    // Set the packet flags.
    //
    if(fQueue)
    {
        // The autoinstance will take control after transmission. This will be an asynchronous command.
        _fmemset(pinst[iInst].achPacket, '\0', MAXPACKETLENGTH);
        pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].hwndNotify    = NULL;
        pvcr->Port[iPort].Dev[iDev].bReplyFlags                         = (BYTE) 0;
        pvcr->Port[iPort].Dev[iDev].iInstReply                          = pvcr->iInstBackground;
    
        if(dwFlags & MCI_NOTIFY)
            pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].hwndNotify = hwndNotify;
    
        if(dwFlags & MCI_WAIT)
            pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].fWaiting   = TRUE;
        else
            pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].fWaiting   = FALSE;

        viscaResetEvent(pinst[iInst].pfAutoCompletion);
        viscaResetEvent(pinst[iInst].pfAutoAck); //First ack to make sure it is alive.
    }
    else
    {
        // This is going to be a synchronous command with response to inst.
        _fmemset(pinst[iInst].achPacket, '\0', MAXPACKETLENGTH);
        pvcr->Port[iPort].Dev[iDev].iInstReply = iInst; 
        pinst[iInst].bReplyFlags               = 0;

        viscaResetEvent(OWNED(pinst[iInst].fCompletionEvent));
        viscaResetEvent(OWNED(pinst[iInst].fAckEvent));
    }


#ifdef _WIN32
    // Get a buffer to the port.
    if(viscaWaitForSingleObject(pinst[iInst].pfTxBuffer, FALSE, 10000L, 0) == WAIT_TIMEOUT)
    {
        DPF(DBG_ERROR, "Failed waiting pfTxBuffer in viscaWrite.\n");
    }
#endif

    DPF(DBG_COMM, "---Wrote: ");
    DF(DBG_COMM, viscaPacketPrint(lpstrPacket, cbMessageLength + 2));

    //
    // Try to write packet
    //
#ifdef _WIN32
    // Copy it to the Tx buffer. (I really should have a tx queue!
    _fmemcpy(pvcr->Port[iPort].achTxPacket, lpstrPacket, cbMessageLength + 2);
    pvcr->Port[iPort].nchTxPacket = cbMessageLength + 2;

    // Signal that it is time to transmit. (we must use our version of the handle).
    if(!SetEvent(pinst[iInst].pfTxReady))
    {
        DPF(DBG_ERROR, "Failed SetEvent pfTxReady. \n");
    }
#else
    if (!viscaCommWrite(pvcr->Port[pinst[iInst].iPort].idComDev, lpstrPacket, cbMessageLength + 2))
    {
        DPF(DBG_ERROR, "viscaWrite - viscaCommWrite has failed, unlock Tx now.\n");
        pvcr->Port[iPort].Dev[iDev].iInstReply = -1;

        viscaReleaseSemaphore(pinst[iInst].pfTxLock);
        return FALSE;
    }
#endif

    return TRUE;
}


/****************************************************************************
 * Function: DWORD viscaWaitCompletion. - Wait for completion of command.
 *
 * Parameters:
 *
 *      int iInst - Pointer to OpenInstance struct identifying
 *                               the MCI device which is awaiting a reply.
 *
 *      BOOL  fQueue - Is this a transport command?
 *
 *      BOOL  fUseAckTimer - Should we use ack timer for timeout, or use GetTickCount.
 *
 * Returns: TRUE if the wait runs until a completion, FALSE if someone breaks it.
 *
 ***************************************************************************/
BOOL FAR PASCAL
    viscaWaitCompletion(int iInst, BOOL fQueue, BOOL fWait)
{
    UINT    uDeviceID   = pinst[iInst].uDeviceID;
    UINT    iDev        = pinst[iInst].iDev;
    UINT    iPort       = pinst[iInst].iPort;
    DWORD   dwResult    = 0L;

    //
    // Always wait for the ack to instance on this command.
    // Auto-ack will signal first ack of an auto-command.
    //
    if(fQueue)
        dwResult = viscaWaitForSingleObject(pinst[iInst].pfAutoAck, TRUE, 4000L, 0);
    else
        dwResult = viscaWaitForSingleObject(OWNED(pinst[iInst].fAckEvent), TRUE, 4000L, 0);

    if(dwResult == WAIT_TIMEOUT)
    {
        DPF(DBG_ERROR, "Failed wait for AckEvent in viscaWaitCompletion.\n");
        pvcr->Port[iPort].Dev[iDev].iInstReply     = -1;
        if(fQueue)
        {
            pvcr->Port[iPort].Dev[iDev].bReplyFlags |= VISCAF_COMPLETION;
            pvcr->Port[iPort].Dev[iDev].bReplyFlags |= VISCAF_ERROR;
            pvcr->Port[iPort].Dev[iDev].bReplyFlags |= VISCAF_ERROR_TIMEOUT;

            // Transport command was not set until sucessful ack, and long running.
            pvcr->Port[iPort].Dev[iDev].wTransportCmd  = 0;
            pinst[iInst].hwndNotify                    = (HWND)NULL;
            viscaSetEvent(pinst[iInst].pfTransportFree);
            viscaReleaseSemaphore(pinst[iInst].pfTxLock);
            if(pvcr->Port[iPort].Dev[iDev].iInstTransport != -1)
                pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].fWaiting   = FALSE;
            pvcr->Port[iPort].Dev[iDev].iInstTransport = -1;
        }
        else
        {
            pinst[iInst].bReplyFlags |= VISCAF_COMPLETION;
            pinst[iInst].bReplyFlags |= VISCAF_ERROR;
            pinst[iInst].bReplyFlags |= VISCAF_ERROR_TIMEOUT;
            viscaReleaseSemaphore(pinst[iInst].pfTxLock);
        }
        return FALSE; 
    }

    if(fQueue && fWait)
    {
        if(viscaWaitForSingleObject(pinst[iInst].pfAutoCompletion, TRUE, MY_INFINITE, pinst[iInst].uDeviceID)==0)
            goto NotDone;            
        //
        // We must be sure of receiving the event before allowing another to be issued.
        // That's why the release is done in viscacom.c and not commtask.c
        //
        // We lock the device so noone (in mcidelay.c) sees -1 before tport free is signalled. (does it matter?)
        viscaWaitForSingleObject(pinst[iInst].pfDeviceLock, FALSE, MY_INFINITE, 0);

        DPF(DBG_QUEUE, "###Releasing transport in viscacom.c\n");
        viscaReleaseAutoParms(iPort, iDev);
        //
        // We are a foreground thread, so we must use our version.
        //
        viscaSetEvent(pinst[iInst].pfTransportFree); //Someone may be waiting for this.
        viscaReleaseMutex(pinst[iInst].pfDeviceLock);

    }
    else if(!fQueue)
    {
        if(WAIT_TIMEOUT == viscaWaitForSingleObject(OWNED(pinst[iInst].fCompletionEvent), TRUE, MY_INFINITE, pinst[iInst].uDeviceID))
        {
            DPF(DBG_ERROR, "Failed wait for CompletionEvent in viscaWaitCompletion.\n");
        }
    }

    NotDone:
    // This can be set done here before we get here.
    if(pvcr->Port[iPort].Dev[iDev].iInstTransport != -1)
        pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].fWaiting   = FALSE;

    return TRUE;
}


void FAR PASCAL viscaReleaseAutoParms(int iPort, int iDev)
{
    pvcr->Port[iPort].Dev[iDev].wCancelledCmd  = pvcr->Port[iPort].Dev[iDev].wTransportCmd;
    pvcr->Port[iPort].Dev[iDev].iCancelledInst = pvcr->Port[iPort].Dev[iDev].iInstTransport;
    pvcr->Port[iPort].Dev[iDev].hwndCancelled  = pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].hwndNotify;

    pvcr->Port[iPort].Dev[iDev].wTransportCmd  = 0;
    pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].hwndNotify = (HWND)NULL;
    pvcr->Port[iPort].Dev[iDev].iInstTransport = -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mciwave\gmem.h ===
// Copyright (c) 1994 Microsoft Corporation
/*
    gmem.h

    This module supplies macros for fixed global memory
    allocation compatible with those used in the Multimedia
    extensions to Windows 3.x.  It is included to simplify
    porting of the Windows 3.x 16 bit code.

    Jul-16-91   NigelT

*/

#ifndef _GMEMMACROS_
#define _GMEMMACROS_

__inline LPBYTE GlobalAllocPtr(DWORD flags, DWORD cb)
{
    HANDLE h;
    LPBYTE lp = NULL;
    h = GlobalAlloc(flags, cb);
    if (h) {
	lp = GlobalLock(h);
    }
    return(lp);
}


#define     GlobalFreePtr(lp)			\
	    {				        \
		HANDLE h;			\
		h = GlobalHandle(lp);		\
		if (GlobalUnlock(h)) {          \
		    /* memory still locked!! */ \
		}				\
		h = GlobalFree(h);		\
	    }
#endif // _GMEMMACROS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mciwave\drvproc.c ===
/************************************************************************/

/*
**  Copyright (c) 1985-1999 Microsoft Corporation
**
**  Title: drvproc.c - Multimedia Systems Media Control Interface
**  waveform audio driver for RIFF wave files.
**
**  Version:    1.00
**
**  Date:       18-Apr-1990
**
**  Author:     ROBWI
*/

/************************************************************************/

/*
**  Change log:
**
**  DATE        REV     DESCRIPTION
**  ----------- -----   ------------------------------------------
**  10-Jan-1992 MikeTri Ported to NT
**                  @@@ need to change slash slash comments to slash star
*/

/************************************************************************/
// #define DEBUGLEVELVAR mciwaveDebugLevel
#define UNICODE

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICONS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define OEMRESOURCE
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
#define NOCTLMGR
#define NODRAWTEXT
#define NOGDI
#define NOKERNEL
#define NONLS
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOMINMAX
#define NOOPENFILE
#define NOSCROLL
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOCOMM
#define NOKANJI
#define NOHELP
#define NOPROFILER
#define NODEFERWINDOWPOS


#define MMNOMMIO
#define MMNOJOY
#define MMNOTIMER
#define MMNOAUX
#define MMNOMIDI

#include <windows.h>
#include "mciwave.h"
#include <mmddk.h>

/************************************************************************/

/*
**  This constant is used for a return value when opening the MCI
**  driver for configuration.  Setting the high-order word of the
**  dwDriverID identifies configuration opens.
*/

#define CONFIG_ID   10000L

#define MAXINISTRING    32

/************************************************************************/

/*
**  wTableEntry Contains the wave command table identifier.
*/

#ifndef MCI_NO_COMMAND_TABLE
#define MCI_NO_COMMAND_TABLE    -1
#endif

PRIVATE UINT wTableEntry = MCI_NO_COMMAND_TABLE;

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   UINT | GetAudioSeconds |
    This converts the given string to a UINT which represents the
    number of seconds of audio buffers that should be available.  The
    number is bounded by the minimum and maximum number of seconds as
    defined by MinAudioSeconds and MaxAudioSeconds.

@parm   LPCSTR | lszNumber |
    Points to the string containing the string representation of the
    number to convert.

@rdesc  Returns the int representation of the number passed.  If the number
    is out of range, the default number of audio seconds is returned.
*/

PUBLIC  UINT PASCAL FAR GetAudioSeconds(
    LPCWSTR  lszNumber)
{
    UINT    wSeconds;

    for (wSeconds = 0;
         (wSeconds < MaxAudioSeconds) && (*lszNumber >= TEXT('0')) && (*lszNumber <= TEXT('9'));
         lszNumber++)
        wSeconds = wSeconds * 10 + (*lszNumber - '0');

    if ((wSeconds > MaxAudioSeconds) || (wSeconds < MinAudioSeconds))
        wSeconds = AudioSecondsDefault;

    return wSeconds;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    BOOL | mwLoadDriver |
    This function is called in response to a <m>DRV_LOAD<d> message, and
    performs driver initialization.  It determines the total number of
    input and output devices for use in trying to open any device.
    The function then tries to register the extended wave command table.

@rdesc  Returns TRUE on success, else FALSE.
*/

PRIVATE BOOL PASCAL NEAR mwLoadDriver(
    VOID)
{
    WCHAR    aszResource[MAXINISTRING];

    dprintf3(("mwLoadDriver called"));

    cWaveOutMax = waveOutGetNumDevs();
    cWaveInMax = waveInGetNumDevs();

#if DBG
    if (cWaveOutMax + cWaveInMax) {
        dprintf4(("Number of Wave Out devices = %d,  Wave In devices = %d", cWaveOutMax, cWaveInMax));
    } else {
        dprintf1(("NO wave input or output devices detected"));
    }
#endif

    if (LoadString( hModuleInstance,
                    IDS_COMMANDS,
                    aszResource,
                    sizeof(aszResource) / sizeof(WCHAR) ))
    {
        wTableEntry = mciLoadCommandResource(hModuleInstance, aszResource, 0);

        if (wTableEntry != MCI_NO_COMMAND_TABLE) {
            dprintf4(("Loaded MCIWAVE command table, table number %d", wTableEntry));
            return TRUE;
        }
#if DBG
        else
            dprintf1(("mwLoadDriver: mciLoadCommandResource failed"));
    }
    else
    {
        dprintf1(("mwLoadDriver: LoadString of command table identifier failed"));

#endif
    }

    dprintf1(("mwLoadDriver returning FALSE"));
    return FALSE;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    BOOL | mwFreeDriver |
    Perform driver cleanup in response to DRV_FREE message.  This is only
    called at driver unload time if a previous DRV_LOAD message succeeded.

@rdesc  Returns TRUE always.
*/

PRIVATE BOOL PASCAL NEAR mwFreeDriver(
    VOID)
{
    if (wTableEntry != MCI_NO_COMMAND_TABLE) {
        mciFreeCommandResource(wTableEntry);
        wTableEntry = MCI_NO_COMMAND_TABLE;
    }
    return TRUE;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    LRESULT | DriverProc |
    The entry point for an installable driver.

@parm   DWORD | dDriverId |
    For most messages, <p>dDriverId<d> is the DWORD value that the driver
    returns in response to a <m>DRV_OPEN<d> message.  Each time that the
    driver is opened, through the DrvOpen API, the driver receives a
    <m>DRV_OPEN<d> message and can return an arbitrary, non-zero, value.

    The installable driver interface saves this value and returns a unique
    driver handle to the application. Whenever the application sends a
    message to the driver using the driver handle, the interface routes the
    message to this entry point and passes the corresponding
    <p>dDriverId<d>.

    This mechanism allows the driver to use the same or different
    identifiers for multiple opens but ensures that driver handles are
    unique at the application interface layer.

    The following messages are not related to a particular open instance
    of the driver. For these messages, the <p>dDriverId<d> will always
    be ZERO: <m>DRV_LOAD<d>, <m>DRV_FREE<d>, <m>DRV_ENABLE<d>,
    <m>DRV_DISABLE<d>, <m>DRV_OPEN<d>.

@parm   HANDLE | hDriver |
    This is the handle returned to the application by the driver interface.

@parm   UINT | wMessage |
    The requested action to be performed. Message values below
    <m>DRV_RESERVED<d> are used for globally defined messages.  Message
    values from <m>DRV_RESERVED<d> to <m>DRV_USER<d> are used for defined
    driver portocols. Messages above <m>DRV_USER<d> are used for driver
    specific messages.

@flag   DRV_LOAD |
    Load the driver.

@flag   DRV_FREE |
    Free the driver.

@flag   DRV_OPEN |
    Open the driver.  If <p>dParam2<d> is NULL, the driver is being
    opened for configuration, else the parameter points to an open
    parameters block.  The command line in the open parameters optionally
    contains a replacement for the default audio seconds parameter.  If so,
    the current default is replaced with this new number.

    The rest of the open parameters block is filled in with the driver's
    extended command table and device type.  The device ID is then
    returned.

@flag   DRV_CLOSE |
    Close the driver.  Returns TRUE.

@flag   DRV_QUERYCONFIGURE |
    Query as to whether the driver can be configured.  Returns TRUE.

@flag   DRV_CONFIGURE |
    After verifying <p>dParam1<d> and <p>dParam2<d>, configure the
    driver.  Opens the driver configuration dialog.

@flag   DRV_ENABLE |
    Enable the driver.  Use DefDriverProc.

@flag   DRV_DISABLE |
    Disable the driver.  Use DefDriverProc.

@parm   LPARAM | lParam1 |
    Data for this message.  Defined separately for each message.

@parm   LPARAM | lParam2 |
    Data for this message.  Defined separately for each message.

@rdesc  Defined separately for each message.
*/

#if 0
PUBLIC  LRESULT PASCAL DefDriverProc(
    DWORD   dDriverID,
    HANDLE  hDriver,
    UINT    wMessage,
    LONG    lParam1,
    LONG    lParam2);
#endif

PUBLIC  LRESULT PASCAL DriverProc(
    DWORD   dDriverID,
    HANDLE  hDriver,
    UINT    wMessage,
    DWORD_PTR    lParam1,
    DWORD_PTR    lParam2)
{
    LPMCI_OPEN_DRIVER_PARMS lpOpen;

    switch (wMessage) {
    case DRV_LOAD:
        return (LRESULT)(LONG)mwLoadDriver();

    case DRV_FREE:
        return (LRESULT)(LONG)mwFreeDriver();

    case DRV_OPEN:
        if (!(LONG)lParam2)
            return (LRESULT)CONFIG_ID;
        lpOpen = (LPMCI_OPEN_DRIVER_PARMS)lParam2;
        if (lpOpen->lpstrParams != NULL)
            wAudioSeconds = GetAudioSeconds(lpOpen->lpstrParams);
        else
            wAudioSeconds = AudioSecondsDefault;
        lpOpen->wCustomCommandTable = wTableEntry;
        lpOpen->wType = MCI_DEVTYPE_WAVEFORM_AUDIO;
        return (LRESULT)(LONG)lpOpen->wDeviceID;

    case DRV_CLOSE:
    case DRV_QUERYCONFIGURE:
        return (LRESULT)1;

    case DRV_INSTALL:
    case DRV_REMOVE:
        return (LRESULT)DRVCNF_OK;

    case DRV_CONFIGURE:
        if ((LONG)lParam2 && (LONG)lParam1 && (((LPDRVCONFIGINFO)lParam2)->dwDCISize == sizeof(DRVCONFIGINFO)))
            return (LRESULT)(LONG)Config((HWND)lParam1, (LPDRVCONFIGINFO)lParam2, hModuleInstance);
        return (LRESULT)DRVCNF_CANCEL;

    default:
        if (!HIWORD(dDriverID) && wMessage >= DRV_MCI_FIRST && wMessage <= DRV_MCI_LAST)
            return mciDriverEntry((WORD)dDriverID, wMessage, (DWORD)lParam1, (LPMCI_GENERIC_PARMS)lParam2);
        else
            return DefDriverProc(dDriverID, hDriver, wMessage, lParam1, lParam2);
    }
}

/**************************************************************************

    @doc EXTERNAL

    @api BOOL | DllInstanceInit | This procedure is called whenever a
        process attaches or detaches from the DLL.

    @parm PVOID | hModule | Handle of the DLL.

    @parm ULONG | Reason | What the reason for the call is.

    @parm PCONTEXT | pContext | Some random other information.

    @rdesc The return value is TRUE if the initialisation completed ok,
        FALSE if not.

**************************************************************************/

BOOL DllInstanceInit(PVOID hModule, ULONG Reason, PCONTEXT pContext)
{
    UNREFERENCED_PARAMETER(pContext);

    if (Reason == DLL_PROCESS_ATTACH) {

#if DBG
        WCHAR strname[50];
#endif

        DisableThreadLibraryCalls(hModule);
        mciwaveInitDebugLevel ();

        InitCrit();
        hModuleInstance = hModule;

#if DBG
        GetModuleFileName(NULL, strname, sizeof(strname) / sizeof(WCHAR) );
        dprintf2(("Process attaching, exe=%ls (Pid %x  Tid %x)", strname, GetCurrentProcessId(), GetCurrentThreadId()));
        dprintf2(("  starting debug level=%d", mciwaveDebugLevel));
#endif

    } else if (Reason == DLL_PROCESS_DETACH) {
        dprintf2(("Process ending (Pid %x  Tid %x)", GetCurrentProcessId(), GetCurrentThreadId()));
        DeleteCrit();  // Something nasty happens if we don't do this
    } else {
        dprintf2(("DllInstanceInit - reason %d", Reason));
    }
    return TRUE;
}

/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mciwave\mciwave.h ===
/*
**  Copyright (c) 1985-1998 Microsoft Corporation
**
**  Title: mciwave.h - Multimedia Systems Media Control Interface
**  streaming digital audio driver internal header file.
*/


/*
**  Change log:
**
**  DATE        REV     DESCRIPTION
**  ----------- -----   ------------------------------------------
**  18-APR-1990 ROBWI   Original
**  10-Jan-1992 MikeTri Ported to NT
**     Aug 1994 Lauriegr Tried to add some explanation
*/


/********************* The OVERALL SCHEME OF THINGS ************************\

There are normally one or two files on the go.  One is the original wave file,
the other is a temporary file.  The data in these files is described by a
WAVEDESC which contains a pointer to an array of WAVEDATANODEs.
Each WAVEDATANODE identifies some part of one of the files.
The high order bit of the length field identifies which file (totally naff,
if you ask me, but I didn't invent it).  Concatenate all the sections that
the WAVEDATANODEs identify and that's the wave data.

The WAVEDATANODEs actually form a linked list (linked by array indices not
pointers) and it is the concatenation of that list which defines the file.
There may also be some WAVEDATANODEs that define free space.

I'm confused about what exactly the dDataStart in the NODEs means.  Is it the
position in the logical file or in one or other of the physical files?  Either
way it probably gets messed up if you try deleting anything (KNOWN BUG).

LaurieGr

\***************************************************************************/



#ifndef MCIWAVE_H
 #define MCIWAVE_H

#include <stdio.h>
#include <mmsystem.h>

#define WAIT_FOREVER ((DWORD)(-1))

#if DBG
    #define PUBLIC  extern      /* Public label.    SO DEBUGGER CAN   */
    #define PRIVATE extern      /* Private label.   SEE THE SYMBOLS   */
#else
    #define PUBLIC  extern      /* Public label.        */
    #define PRIVATE extern      /* Private label.       */
#endif
#define REALLYPRIVATE static

#define EXPORT              /* Export function.     */


#ifndef RC_INVOKED  /* These are defined to RC */
#define STATICDT
#define STATICFN
#define STATIC
#endif  /* RC_INVOKED */

/*
**  This constant defines the maximum length of strings containing
**  file paths.  This number is the same as the string in OFSTRUCT.
*/

#define _MAX_PATH   MAX_PATH

/*
**  These two constants define extended commands that are use within the
**  wave handler.  The first can be sent to the MCI entry point, and the
**  second is used entirely internally.
*/

#define MCI_MCIWAVE_PLAY_HOLD   0x01000000L
#define MCI_MCIWAVE_CUE         0x02000000L

/*
**  The first two constants represent the maximum and minimum number of
**  seconds of buffering that can be specified either on the SYSTEM.INI
**  device driver entry, or in the MCI_OPEN command.
**  The third constant defines the default number of seconds to use when
**  calculating the number of seconds of buffering to allocate.
*/

#define MaxAudioSeconds     9
#define MinAudioSeconds     2
#define AudioSecondsDefault 4

/*
**  This constant is used for recording when no record stopping point
**  is specified.
*/

#define INFINITEFILESIZE    0X7FFFFFFFL

/*
**  These constants represent the various RIFF components of the file.
*/

#define mmioWAVE    mmioFOURCC('W','A','V','E')
#define mmioFMT     mmioFOURCC('f','m','t',' ')
#define mmioDATA    mmioFOURCC('d','a','t','a')

/*
**  The following represent identifiers for string resources.
*/

#define IDS_PRODUCTNAME     0
#define IDS_MAPPER          1
#define IDS_COMMANDS        2

/*
**  The following constant is used to specify the sample size when
**  determing the input level during a Cued record.  This number must
**  be divisible by 4.
*/

#define NUM_LEVEL_SAMPLES   64L

/*
**  The following constants represent specific task modes and task
**  commands.
*/

#define MODE_PLAYING        0x0001
#define MODE_INSERT         0x0002
#define MODE_OVERWRITE      0x0004
#define MODE_PAUSED         0x0008
#define MODE_CUED           0x0010
#define MODE_HOLDING        0x0020
#define MODE_CLEANUP        0x0040
#define MODE_WAIT           0x0080
#define COMMAND_NEW         0x0100
#define COMMAND_PLAY        0x0200
#define COMMAND_INSERT      0x0400
#define COMMAND_OVERWRITE   0x0800
#define COMMAND_STOP        0x1000
#define COMMAND_CUE         0x2000
#define COMMAND_HOLD        0x4000

/*
**  The following macros allow modes and commands to be added, removed,
**  queried, set, and get.
*/

#define ADDMODE(pwd, m)     ((pwd)->wMode |= (m))
#define REMOVEMODE(pwd, m)  ((pwd)->wMode &= ~(m))
#define ISMODE(pwd, m)      ((pwd)->wMode & (m))
#define SETMODE(pwd, m)     ((pwd)->wMode = (m))
#define GETMODE(pwd)        ((pwd)->wMode)

/*
**  The following macros allow testing and setting of the current task
**  state.
*/

#define ISTASKSTATE(pwd, s)   ((pwd)->wTaskState == (s))
#define SETTASKSTATE(pwd, s)  ((pwd)->wTaskState = (s))
#define TASKSTATE(pwd)        ((pwd)->wTaskState)

/*
**  Define message for state changes for device tasks
*/

#define WTM_STATECHANGE (WM_USER + 1)

/*
@doc    INTERNAL MCIWAVE

@types  DIRECTION |
    The Direction enumeration is used internally in the MCI wave handler
    to indicate the current direction of data flow.  This is either input
    (record), or output (play).

@flag   input |
    Indicates the direction is record.

@flag   output |
    Indicates the direction is playback.

@tagname    tagDirection
*/

typedef enum tagDirection {
    input,
    output
}   DIRECTION;

/*
**  The following constants represent specific task states.
*/

#define TASKNONE    0
#define TASKINIT    1
#define TASKIDLE    2
#define TASKBUSY    3
#define TASKCLOSE   4
#define TASKSAVE    5
#define TASKDELETE  6
#define TASKCUT     7

/*
**  The following constants and macros are used in dealing with data nodes,
**  which are pointers to blocks of data.  The first constant is used
**  within these macros as a mask for block pointers which refer to data
**  located in the temporary file, and not in the original read-only file.
*/

#define TEMPDATAMASK            (0x80000000)
#define ENDOFNODES              (-1)
#define ISTEMPDATA(lpwdn)       (((lpwdn)->dDataStart & TEMPDATAMASK) != 0)
#define MASKDATASTART(d)        ((d) | TEMPDATAMASK)
#define UNMASKDATASTART(lpwdn)  ((lpwdn)->dDataStart & ~TEMPDATAMASK)
#define LPWDN(pwd, d)           ((pwd)->lpWaveDataNode + (d))
#define RELEASEBLOCKNODE(lpwdn) ((lpwdn)->dDataLength = (DWORD)-1)
#define ISFREEBLOCKNODE(lpwdn)  ((lpwdn)->dDataLength == (DWORD)-1)

/*
**  The following constant is used to determine the allocation increments
**  for data pointers
*/

#define DATANODEALLOCSIZE   32

/*
**  The following macro is used to round a data offset to the next nearest
**  buffer size increment.
*/

#define ROUNDDATA(pwd, d)   ((((DWORD)(d) + (pwd)->dAudioBufferLen - 1) / (pwd)->dAudioBufferLen) * (pwd)->dAudioBufferLen)
#define BLOCKALIGN(pwd, d)  ((((DWORD)(d) + (pwd)->pwavefmt->nBlockAlign - 1) / (pwd)->pwavefmt->nBlockAlign) * (pwd)->pwavefmt->nBlockAlign)

/************************************************************************/

/*
@doc    INTERNAL MCIWAVE

@types  WAVEDATANODE |
    The Wave Data Node structure is used internally in the MCI wave
    handler to store information about a block of wave data, located either
    in the original file, or in the temporary data file.  These structures
    are used to form a linked list of wave data nodes that describe the
    data in the entire file as it currently exists.

    The headers themselves are allocated as an expandable array of global
    memory, using <e>WAVEDATANODE.dDataLength<d> as an in-use flag when
    searching the list for free entries to use.  Note that a free entry
    can also have free temporary data attached to it, as in the case of
    performing a delete in which all the data for a specific node is
    removed.

@field  DWORD | dDataStart |
    Indicates the absolute position at which the data for this node begins.
    This element is also used in determining if the data pointed to by this
    node is original data, or newly created temporary data.  This is done
    by masking the length with <f>TEMPDATAMASK<d>.  The length can be
    accessed by using <f>UNMASKDATASTART<d>.

@field  DWORD | dDataLength |
    Indicates the length of active data pointed to by the node.  This
    could be zero if say, a write failed.  This contains -1 if the node
    is not part of the linked list of active nodes.

@field  DWORD | dTotalLength |
    Indicates the actual total length of data available to this node.  For
    original data, this will always be the same as the
    <e>WAVEDATANODE.dDataLength<d> element, but for temporary data, this
    may be longer, as it is a block aligned number, the block lengths being
    based on the size of wave data buffers.  If the node is not in use, it
    still may have data associated with it.  If there is no data associated
    with a free node, the total length is set to zero.

@field  DWORD | dNextWaveDataNode |
    This element is used for active nodes, and contains an index into the
    array of nodes indicating the location of the next active node, or
    <f>ENDOFNODES<d> to indicate the end of the list of active nodes.

@othertype  WAVEDATANODE NEAR * | LPWAVEDATANODE |
    A far pointer to the structure.

@tagname    tagWaveDataNode
*/

typedef struct tagWaveDataNode {
    DWORD   dDataStart;
    DWORD   dDataLength;
    DWORD   dTotalLength;
    DWORD   dNextWaveDataNode;
}   WAVEDATANODE,
    FAR * LPWAVEDATANODE;

/*
@doc    INTERNAL MCIWAVE

@types  WAVEDESC |
    The Wave Description structure is used internally in the MCI wave
    handler to store details for each device, along with any state information.

@field  MCIDEVICEID | wDeviceID |
    MCI device identifier passed to the driver during driver open.

@field  UINT | wMode |
    Contains the current mode of the background task, if there is a task.

@flag   MODE_PLAYING |
    This mode is set when the task is actually doing playback.  It is reset
    before Cleanup mode is entered.

@flag   MODE_INSERT |
    This mode is set when the task is actually doing insert recording.  It
    is reset before Cleanup mode is entered.

@flag   MODE_OVERWRITE |
    This mode is set when the task is actually doing overwrite recording.
    It is reset before Cleanup mode is entered.

@flag   MODE_PAUSED |
    This mode is set if playback or recording has been paused by an
    MCI_PAUSE command.

@flag   MODE_CUED |
    This mode is entered when playback or recording has actually been cued.

@flag   MODE_HOLDING |
    This mode is entered when playback is about to block itself and hold
    after doing playback.

@flag   MODE_CLEANUP |
    This mode is entered after playback or recording has finished, but
    before the task has entered idle state, and new commands are being
    ignored.

@flag   MODE_WAIT |
    This mode flag is used by both the calling task and the background
    task.  If the calling task received a Record or Play command with the
    Wait flag, then this mode is set, so that if an error occurs during
    playback or recording, the background task does not perform
    notification, but just clears the notification callback handle.  Just
    before it performs notification, the background task clears this
    flag so that the calling task will know that it should not return an
    error condition.  If the calling task is broken out of the wait loop,
    it checks this flag to determine if it should report an error
    condition.

@flag   COMMAND_NEW |
    This command specifies that a new command has been set.

@flag   COMMAND_PLAY |
    This command indicates that playback should be performed on the preset
    parameters.

@flag   COMMAND_INSERT |
    This command indicates that insert recording should be performed on
    the preset parameters.

@flag   COMMAND_OVERWRITE |
    This command indicates that overwrite recording should be performed on
    the preset parameters.

@flag   COMMAND_STOP |
    This command indicates that playback or recording should stop.

@flag   COMMAND_CUE |
    This command indicates that playback should initially pause itself
    before writing then enter Cue mode when all buffers have been written.
    For recording, it should enter a level checking loop and wait for
    further commands.

@flag   COMMAND_HOLD |
    This command specifies that playback should enter a hold state after
    completing playback.

@field  DWORD | dTimeFormat |
    Indicates the current format of position values used in messages.

@flag   MCI_FORMAT_MILLISECONDS |
    Milliseconds.

@flag   MCI_FORMAT_SAMPLES |
    Samples.

@flag   MCI_FORMAT_BYTES |
    Bytes.

@field  UINT | wSeconds |
    Contains the desired amount of buffering in terms of seconds.  This
    is then converted to actual buffers, and limited by the predefined
    min and max values.

@field  HWND | hwndCallback |
    If a message has specified notification, this contains the window
    handle to where notification is to be sent.  The handle is stored
    here for delayed notification, and can be checked when the function
    has finished or was interrupted.

@field  HTASK | hTask |
    If the MCI wave device instance was opened with an element attached,
    this element contains the handle to the background task used for
    playback and recording.

@field  <t>DIRECTION<d> | Direction |
    Indicates the current direction of data flow.

@flag   input |
    Indicates the direction is inwards, i.e. recording.

@flag   output |
    Indicates the direction is outwards, i.e. playback.

@field  UINT | wTaskState |
    MCIWAVE has a separate background task for every open instance of
    mciwave. The task handle and task state are stored  in the
    per-instance data structure.  The task can be in one of four states.

@flag   TASKNONE |
    This state is only set if the requested file cannot be opened during
    task initialization.  It is used so that the task create loop is able
    to abort on an initialization failure.

@flag   TASKINIT |
    This is the initial task state set when the instance data structure is
    initialized in <f>mwOpenDevice<d> before the actual task is created by
    <f>mmTaskCreate<d>.  After the task is created, <f>mwOpenDevice<d>
    waits until the task state changes to TASKIDLE before returning success
    so that the background task is definitely initialized after an open
    call.

@flag   TASKIDLE |
    The task sets the state to TASKIDLE and blocks whenever there is
    nothing to do.  When the task wakes, the state is either TASKCLOSE if
    the instance is being closed or else TASKBUSY if the task is to begin
    recording or playback of the file.

@flag   TASKCLOSE |
    <f>mwCloseDevice<d> stops playback or recording which forces the task
    state to TASKIDLE and then sets the state to TASKCLOSE and wakes the
    task so that the task will destroy itself.

@flag   TASKBUSY |
    The task is in this state during playback and recording.

@flag   TASKCLOSE |
    The task is closing and about to terminate.

@flag   TASKSAVE |
    The task saving the current data to the specified file.

@flag   TASKDELETE |
    The task deleting the specified data.

@flag   TASKCUT |
    The task cutting the specified data (Not implemented).

@field  UINT | idOut |
    Wave device id of output device to use, or WAVE_MAPPER for any.

@field  UINT | idIn |
    Wave device id of input device to use, or WAVE_MAPPER for any.

@field  HWAVEOUT | hWaveOut |
    Output wave device handle when in use.

@field  HWAVEIN | hWaveIn |
    Input wave device handle when in use.

@field  <t>LPWAVEHDR<d> | rglpWaveHdr |
    Pointer to array of audio buffers for wave buffering.

@field  DWORD | dCur |
    Current position in file in bytes.

@field  DWORD | dFrom |
    Position in bytes at which playback or recording should begin.

@field  DWORD | dTo |
    Position in bytes at which playback or recording should terminate,
    or <f>INFINITEFILESIZE<d> if recording should continue until stopped.

@field  DWORD | dSize |
    Actual wave data size in bytes.

@field  char | aszFile |
    Contains the name of the element attached to the MCI wave device
    instance, if any.  This might be a zero length string if the file is
    new and has not been named yet.

@field  char | aszTempFile |
    Contains the name of the temporary data file, if any.

@field  <t>HMMIO<d> | hmmio |
    MMIO identifier of the element attached to the MCI wave device
    instance, if any.

@field  HFILE | hfTempBuffers |
    Contains the temporary data DOS file handle, if any, else HFILE_ERROR.

@field  <t>LPMMIOPROC<d> | pIOProc |
    Contains a pointer to the alternate MMIO IO procedure, if any, else
    NULL.

@field  <t>LPWAVEDATANODE<d> | lpWaveDataNode |
    Points to the array of wave data nodes.  This is allocated when the
    file opens, so it is always valid.  The array is expanded as needed.

@field  DWORD | dRiffData |
    This contains an offset into the original file, if any, indicating
    the actual starting point of the wave data, which in a RIFF file will
    not be zero.

@field  DWORD | dWaveDataStartNode |
    This contains an index to the first active data pointer in the linked
    list of data pointer nodes.

@field  DWORD | dWaveDataCurrentNode |
    This contains an index to the current active data pointer in the
    linked list of data pointer nodes.

@field  DWORD | dVirtualWaveDataStart |
    This contains a virtual starting point representing logically where in
    the file the data for the current node begins.

@field  DWORD | dWaveDataNodes |
    This indicates the total number of data pointer nodes available.

@field  DWORD | dWaveTempDataLength |
    This contains the current length of the temporary data file, if any.

@field  DWORD | dLevel |
    Current input level if it is being scanned.

@field  UINT | wTaskError |
    Task error return.

@field  UINT | wAudioBuffers |
    Number of audio buffers actually allocated during playback or recording.

@field  DWORD | wAudioBufferLen |
    Length of each audio buffer.

@field  PSTR | szSaveFile |
    During a save command, this optionally contains the name of the file
    to save to, unless data is being saved to the original file.

@field  UINT | wFormatSize |
    This contains the size of the wave header, which is used when saving
    data to a new file.

@field  <t>WAVEFORMAT<d> | pwavefmt |
    Pointer to the wave format header.

@field  HANDLE | hTaskHandle |
    Handle to the thread that started this request

@field  CRITCAL_SECTION | CritSec |
    Serialisation object for threads accessing this <t>WAVEDESC<d> structure

@othertype  WAVEDESC NEAR * | PWAVEDESC |
    A near pointer to the structure.

@tagname    tagWaveDesc
*/

#ifndef MMNOMMIO
#ifndef MMNOWAVE

typedef struct tagWaveDesc {
    MCIDEVICEID     wDeviceID;
    UINT            wMode;
    DWORD           dTimeFormat;
    UINT            wSeconds;
    HWND            hwndCallback;
    DWORD           hTask;
    //HANDLE          hTask;
    DIRECTION       Direction;
    UINT            wTaskState;
    UINT            idOut;
    UINT            idIn;
    HWAVEOUT        hWaveOut;
    HWAVEIN         hWaveIn;
    DWORD           dCur;
    DWORD           dFrom;
    DWORD           dTo;
    DWORD           dSize;
    HMMIO           hmmio;
    HANDLE          hTempBuffers;
    LPMMIOPROC      pIOProc;
    LPWAVEDATANODE  lpWaveDataNode;
    DWORD           dRiffData;
    DWORD           dWaveDataStartNode;
    DWORD           dWaveDataCurrentNode;
    DWORD           dVirtualWaveDataStart;
    DWORD           dWaveDataNodes;
    DWORD           dWaveTempDataLength;
    DWORD           dLevel;
    UINT            wTaskError;
    UINT            wAudioBuffers;
    DWORD           dAudioBufferLen;
    LPWSTR          szSaveFile;
    UINT            wFormatSize;
    WAVEFORMAT NEAR * pwavefmt;
    HANDLE          hTaskHandle;  // Handle of the thread running this job
    LPWAVEHDR       rglpWaveHdr[MaxAudioSeconds];
    WCHAR           aszFile[_MAX_PATH];
    WCHAR           aszTempFile[_MAX_PATH];
}   WAVEDESC;
typedef WAVEDESC * PWAVEDESC;


/************************************************************************/

//PRIVATE DWORD PASCAL FAR time2bytes(
//        PWAVEDESC  pwd,
//        DWORD      dTime,
//        DWORD      dFormat);
//
//PRIVATE DWORD PASCAL FAR bytes2time(
//        PWAVEDESC  pwd,
//        DWORD      dBytes,
//        DWORD      dFormat);

PUBLIC  VOID PASCAL FAR mwDelayedNotify(
        PWAVEDESC  pwd,
        UINT       uStatus);

PUBLIC  LPWAVEHDR * PASCAL FAR NextWaveHdr(
        PWAVEDESC  pwd,
        LPWAVEHDR  * lplpWaveHdr);

PUBLIC  UINT PASCAL FAR PlayFile(
        register PWAVEDESC  pwd);

PUBLIC  UINT PASCAL FAR RecordFile(
        register PWAVEDESC  pwd);

PUBLIC  DWORD PASCAL FAR mwInfo(
        PWAVEDESC         pwd,
        DWORD             dFlags,
        LPMCI_INFO_PARMS  lpInfo);

PUBLIC  DWORD PASCAL FAR mwGetDevCaps(
        PWAVEDESC               pwd,
        DWORD                   dFlags,
        LPMCI_GETDEVCAPS_PARMS  lpCaps);

PUBLIC  DWORD PASCAL FAR mwAllocMoreBlockNodes(
        PWAVEDESC   pwd);

PUBLIC  DWORD PASCAL FAR mwFindAnyFreeDataNode(
        PWAVEDESC   pwd,
        DWORD   dMinDataLength);

PUBLIC  VOID PASCAL FAR mwDeleteData(
        PWAVEDESC   pwd);

PUBLIC  VOID PASCAL FAR mwSaveData(
        PWAVEDESC   pwd);

PUBLIC  VOID PASCAL FAR InitMMIOOpen(
        PWAVEDESC   pwd,
        LPMMIOINFO  lpmmioInfo);

#endif  // MMNOWAVE
#endif  // MMNOMMIO

PUBLIC  LRESULT PASCAL FAR mciDriverEntry(
        MCIDEVICEID         wDeviceID,
        UINT                uMessage,
        DWORD               dFlags,
        LPMCI_GENERIC_PARMS lpParms);

PUBLIC  INT_PTR PASCAL FAR Config(
        HWND    hWnd,
        LPDRVCONFIGINFO lpdci,
        HINSTANCE   hInstance);

PUBLIC  UINT PASCAL FAR GetAudioSeconds(
        LPCWSTR  pch);

__inline BOOL MySeekFile(HANDLE hFile, LONG Position)
{
    return 0xFFFFFFFF != SetFilePointer(hFile, Position, NULL, FILE_BEGIN);
}

__inline BOOL MyReadFile(HANDLE hFile, LPVOID pBuffer, ULONG cBytesToRead, PULONG pcBytesRead)
{
    BOOL fReturn;
    ULONG cBytesRead;
    if (!pcBytesRead) pcBytesRead = &cBytesRead;
    fReturn = ReadFile(hFile, pBuffer, cBytesToRead, pcBytesRead, NULL);
    if (fReturn && (*pcBytesRead == cBytesToRead))
    {
	return TRUE;
    }
    *pcBytesRead = -1;
    return FALSE;
}

__inline BOOL MyWriteFile(HANDLE hFile, LPCVOID pBuffer, ULONG cBytesToWrite, PULONG pcBytesWritten)
{
    BOOL fReturn;
    ULONG cBytesWritten;
    if (!pcBytesWritten) pcBytesWritten = &cBytesWritten;
    fReturn = WriteFile(hFile, pBuffer, cBytesToWrite, pcBytesWritten, NULL);
    if (fReturn && (*pcBytesWritten == cBytesToWrite))
    {
	return TRUE;
    }
    *pcBytesWritten = -1;
    return FALSE;
}

/************************************************************************/

/*
**  This defines a stack and code based pointer types.
*/

//#define STACK   _based(_segname("_STACK"))
//#define SZCODE  char _based(_segname("_CODE"))
//typedef char    STACK * SSZ;

#define SZCODE  WCHAR        // Should be sufficient,
typedef WCHAR   *SSZ;        // as segments no longer matter in Win32

/************************************************************************/

PUBLIC  HINSTANCE hModuleInstance;
PUBLIC  UINT   cWaveOutMax;
PUBLIC  UINT   cWaveInMax;
PUBLIC  UINT   wAudioSeconds;


/***************************************************************************

    Synchronisation support

***************************************************************************/


VOID InitCrit(VOID);

VOID DeleteCrit(VOID);

#if DBG
extern VOID DbgEnterCrit(UINT ln, LPCSTR lpszFile);
#define EnterCrit()    DbgEnterCrit(__LINE__, __FILE__)
#else
VOID EnterCrit(VOID);
#endif


VOID LeaveCrit(VOID);

VOID TaskWaitComplete(HANDLE h);

UINT TaskBlock(VOID);

BOOL TaskSignal(DWORD h, UINT Msg);

#ifndef MMNOMMIO
#ifndef MMNOWAVE

#if DBG
extern  DWORD dwCritSecOwner;
#define mmYield(pwd)  mmDbgYield(pwd, __LINE__, __FILE__)

extern VOID mmDbgYield(PWAVEDESC pwd, UINT ln, LPCSTR lpszFile);

#define CheckIn()  WinAssert((GetCurrentThreadId() == dwCritSecOwner))
#define CheckOut() WinAssert((GetCurrentThreadId() != dwCritSecOwner))

#else

#define CheckIn()
#define CheckOut()
#define mmYield(pwd)           \
          {                    \
              LeaveCrit();     \
              Sleep(10);       \
              EnterCrit();     \
          }
#endif

#endif
#endif


/***************************************************************************

    DEBUGGING SUPPORT

***************************************************************************/


#if DBG

    extern void mciwaveDbgOut(LPSTR lpszFormat, ...);
    extern void mciwaveInitDebugLevel(void);
    extern void dDbgAssert(LPSTR exp, LPSTR file, int line);

    #define WinAssert(exp) \
        ((exp) ? (void)0 : dDbgAssert(#exp, __FILE__, __LINE__))

    #define WinEval(exp) \
        ((__dwEval=(DWORD)(exp)),  \
          __dwEval ? (void)0 : dDbgAssert(#exp, __FILE__, __LINE__), __dwEval)

    int mciwaveDebugLevel;

    #define dprintf( _x_ )                              mciwaveDbgOut _x_
    #define dprintf1( _x_ ) if (mciwaveDebugLevel >= 1) mciwaveDbgOut _x_
    #define dprintf2( _x_ ) if (mciwaveDebugLevel >= 2) mciwaveDbgOut _x_
    #define dprintf3( _x_ ) if (mciwaveDebugLevel >= 3) mciwaveDbgOut _x_
    #define dprintf4( _x_ ) if (mciwaveDebugLevel >= 4) mciwaveDbgOut _x_

#else  // DBG

    #define mciwaveInitDebugLevel() 0

    #define WinAssert(exp) 0
    #define WinEval(exp) (exp)

    #define dprintf(x)
    #define dprintf1(x)
    #define dprintf2(x)
    #define dprintf3(x)
    #define dprintf4(x)

#endif

#endif // MCIWAVE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mciwave\support.c ===
/*******************************Module*Header*********************************\
* Module Name: support.c
*
* MultiMedia Systems MCIWAVE DLL
*
* Created: 27-Feb-1992
* Author:  ROBINSP
*
* History:
*
* Copyright (c) 1985-1996 Microsoft Corporation
*
\******************************************************************************/
#define UNICODE

#include <windows.h>
#include <mciwave.h>

STATICDT CRITICAL_SECTION CritSec;
#if DBG
STATICDT UINT             cCritSec = 0;
         DWORD            dwCritSecOwner = 0;
#endif

/*************************************************************************
 *
 * Cut-down critical section stuff
 *
 * This critical section is used to simulate windows tasking
 * The owner of the critical section runs exclusively in this
 * DLL.
 *
 * At the front of each function request the critical section is
 * grabbed and only release on mmYield or TaskBlock.
 *
 * Extra 'tasks' (threads) per device hold the critical section when
 * they are working.
 *
 * This method has been used to simplify porting the code from
 * windows.  A rewrite would use a different mechanism.
 *
 ************************************************************************/

VOID InitCrit(VOID)
{
    InitializeCriticalSection(&CritSec);
}


VOID DeleteCrit(VOID)
{
    DeleteCriticalSection(&CritSec);
}

#if DBG
VOID DbgEnterCrit(UINT ln, LPCSTR lpszFile)
{
    BOOL fPossibleWait;
    if (dwCritSecOwner) {
        dprintf3(("Critical section owned by thread %x", dwCritSecOwner));
        fPossibleWait = TRUE;
    } else {
        fPossibleWait = FALSE;
    }

    EnterCriticalSection(&CritSec);
    if (fPossibleWait) {
        dprintf2(("...entered critical section after possible wait"));
    }

    if (!cCritSec++) {
        // This is the first time into the critcal section
        dwCritSecOwner = GetCurrentThreadId();
        dprintf3(("...entered critical section (%d) at line %d in file %s", cCritSec, ln, lpszFile));
    } else {
        dprintf1(("Reentering critical section, count = %d", cCritSec));
	WinAssert(0);
	// Note: if the memory allocation stuff starts to be synchronised
	// then this assertion becomes invalid.
    }
}

#else

VOID EnterCrit(VOID)
{
    EnterCriticalSection(&CritSec);
}
#endif

VOID LeaveCrit(VOID)
{
#if DBG
        if (!--cCritSec) {
                // Relinquishing control of the critcal section
                dwCritSecOwner = 0;
                dprintf2(("...relinquished critical section (%d)",cCritSec));
        } else {
                dprintf3(("Leaving critical section, count = %d", cCritSec));
        }
#endif
    LeaveCriticalSection(&CritSec);
}

/*************************************************************************
 *
 * @doc     MCIWAVE
 *
 * @func    UINT | TaskBlock |  This function blocks the current
 *          task context if its event count is 0.
 *
 * @rdesc   Returns the message value of the signal sent.
 *
 ************************************************************************/

UINT TaskBlock(VOID)
{
   MSG msg;

   dprintf3(("Thread %x blocking", GetCurrentThreadId()));

   LeaveCrit();

   /*
    *   Loop until we get the message we want
    */
   for (;;) {
       /*
        *   Retrieve any message for task
        */
       GetMessage(&msg, NULL, 0, 0);

       /*
        *   If the message is for a window dispatch it
        */
       if (msg.hwnd != NULL) {
           DispatchMessage(&msg);
       } else {
           if (msg.message != WM_USER &&
               msg.message != WTM_STATECHANGE) {
               dprintf1(("Got thread message %8X", msg.message));
           }
           //
           // Because MCIWAVE background task can't cope with getting 
           // random(?) messages like MM_WIM_DATA because it thinks that 
           // WM_USER IS its MM_WIM_DATA.  Let the expected WM_USER 
           // messages go through, but trap the MM_WIM_DATA so that 
           // MCIWAVE's buffers don't get all messed up.
           //
           if (msg.message != MM_WIM_DATA)
               break;
       }
   }

   dprintf3(("TaskBlock returning with message 0x%x", msg.message));
   EnterCrit();

   return msg.message;
}


/*************************************************************************
 *
 * @doc     MCIWAVE
 *
 * @func    BOOL | TaskSignal |  This function signals the specified
 *          task, incrementing its event count and unblocking
 *          it.
 *
 * @parm    HANDLE | h | Task handle. For predictable results, get the
 *          task handle from <f mmGetCurrentTask>.
 *
 * @parm    UINT | Msg | Signal message to send.
 *
 * @rdesc   Returns TRUE if the signal was sent, else FALSE if the message
 *          queue was full.
 *
 * @xref    mmTaskBlock  mmTaskCreate
 *
 * @comm    For predictable results, must only be called from a task
 *          created with <f mmTaskCreate>.
 *
 ************************************************************************/
BOOL TaskSignal(DWORD h, UINT Msg)
{
#ifdef DBG
    BOOL fErr;
    dprintf2(("Signalling Thread %x", (ULONG)h));
    fErr = PostThreadMessage(h, Msg, 0, 0);
        if (!fErr) {
                dprintf1(("Error %d signalling Thread %x", GetLastError(), (ULONG)h));
        }
        return(fErr);
#else
    return PostThreadMessage(h, Msg, 0, 0);
#endif
}


/*************************************************************************
 *
 * @doc     MCIWAVE
 *
 * @func    VOID | TaskWaitComplete |  This function waits for the
 *          specified task to terminate.
 *
 * @parm    HANDLE | h | Task handle. For predictable results, get the
 *          task handle from <f mmGetCurrentTask>.
 *
 * @rdesc   No return code
 *
 ************************************************************************/
VOID TaskWaitComplete(HANDLE h)
{
    UINT Rc;

    LeaveCrit();

    /* Wait (no timeout) for thread to complete */

    Rc = WaitForSingleObject(h, INFINITE);

    if (Rc != 0) {
        dprintf(("Error terminating thread - WaitForSingleObject returned non-zero !!!"));
    }

    /* Note that the handle must be freed by us */

    CloseHandle(h);
    EnterCrit();
}

#if DBG
/*************************************************************************
 *
 * @doc     MCIWAVE
 *
 * @func    VOID | mmYield |  This function checks that we are in the
 *          critical section before Yielding.  If we are then the
 *                      critical section is reentered after yielding.
 *
 * @parm   <t>PWAVEDESC<d> | pwd |
 *          Pointer to the wave device descriptor.
 *
 * @rdesc   No return code
 *
 ************************************************************************/
VOID mmDbgYield(
        PWAVEDESC pwd,
        UINT      ln,
        LPCSTR    lpszFile)
{

        if (GetCurrentThreadId() != dwCritSecOwner) {
                dprintf1(("mmYield called while not in the critical section from line %d in file %s", ln, lpszFile));
        }

        CheckIn();
    LeaveCrit();
        CheckOut();
    Sleep(10);
    EnterCrit();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mciwave\mwrec.c ===
/*
**  Copyright (c) 1985-1998 Microsoft Corporation
**
**  Title: mwrec.c - Multimedia Systems Media Control Interface
**  waveform digital audio driver for RIFF wave files.
**  Routines for recording wave files
*/

/*
**  Change log:
**
**  DATE        REV DESCRIPTION
**  ----------- -----   ------------------------------------------
**  18-APR-1990 ROBWI   Original
**  19-JUN-1990 ROBWI   Added wave in
**  13-Jan-1992 MikeTri Ported to NT
**     Aug-1994 Lauriegr This is all out of date
*/


/*******************************************************************************
**                         !!READ THIS!!                                       *
**                         !!READ THIS!!                                       *
**                         !!READ THIS!!                                       *
**                                                                             *
** SEE MWREC.NEW FOR A SLIGHTLY BETTER PATCHED UP VERSION WITH MORE EXPLANATION
** ADDED.  YOU MIGHT WANT TO START FROM THERE INSTEAD
**
** As far as I can make out, this code was never finished.
** The scheme (which I tried to start writing up in MCIWAVE.H) is that there are
** a series of NODEs which describe a wave file.  As long as there is in fact
** only one NODE for the file (which is probably the only common case) then this
** all works fine.  If there are multiple NODEs (which you arrive at by inserting
** bits or deleting bits from the middle) then it all falls apart.
**
** We're pretty sure nobody's ever used this stuff as it's been broken for years
** in 16 and 32 bit.  We've discovered it just as Daytona is about to ship (that's
** Windows/NT version 3.5).  Maybe NMM wil replace it all anyway.
**
** This is a half-patched up version with several questions left outstanding.
**
*/




#define UNICODE

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICONS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define OEMRESOURCE
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
#define NOCTLMGR
#define NODRAWTEXT
#define NOGDI
#define NOKERNEL
#define NONLS
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOOPENFILE
#define NOSCROLL
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOCOMM
#define NOKANJI
#define NOHELP
#define NOPROFILER
#define NODEFERWINDOWPOS

#include <windows.h>
#include "mciwave.h"
#include <mmddk.h>
#include <gmem.h>  // 'cos of GAllocPtrF etc.

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   int | abs |
    This macro returns the absolute value of the signed integer passed to
    it.

@parm   int | x |
    Contains the integer whose absolute value is to be returned.

@rdesc  Returns the absolute value of the signed parameter passed.
*/

#define abs(x)  ((x) > 0 ? (x) : -(x))

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   DWORD | mwFindThisFreeDataNode |
    Attempts to locate a free wave data node whose temporary data points to
    <p>dDataStart<d>.  This allows data from one node to be expanded to
    adjacent free data of another node.  Note that this depends upon any
    free data nodes that previously pointed to original data to have their
    total length zeroed when freed.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dDataStart |
    Indicates the data start position to match.

@rdesc  Returns the free data node with adjacent free temporary data, else -1
    if there is none.
*/

PRIVATE DWORD PASCAL NEAR mwFindThisFreeDataNode(
    PWAVEDESC   pwd,
    DWORD   dDataStart)
{
    LPWAVEDATANODE  lpwdn;
    DWORD   dBlockNode;

    for (lpwdn = LPWDN(pwd, 0), dBlockNode = 0; dBlockNode < pwd->dWaveDataNodes; lpwdn++, dBlockNode++)
        if (ISFREEBLOCKNODE(lpwdn) && lpwdn->dTotalLength && (UNMASKDATASTART(lpwdn) == dDataStart))
            return dBlockNode;
    return (DWORD)-1;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   DWORD | mwFindAnyFreeBlockNode |
    Locates a free node with no data attached.  If there is none, it forces
    more to be allocated.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Returns a node with no data attached, else -1 if no memory is available.
    The node returned is marked as a free node, and need not be discarded if
    not used.
*/

PRIVATE DWORD PASCAL NEAR mwFindAnyFreeBlockNode(
    PWAVEDESC   pwd)
{
    LPWAVEDATANODE  lpwdn;
    DWORD   dCurBlockNode;

    for (lpwdn = LPWDN(pwd, 0), dCurBlockNode = 0; dCurBlockNode < pwd->dWaveDataNodes; lpwdn++, dCurBlockNode++)
        if (ISFREEBLOCKNODE(lpwdn) && !lpwdn->dTotalLength)
            return dCurBlockNode;
    return mwAllocMoreBlockNodes(pwd);
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   BOOL | CopyBlockData |
    Copies <p>wLength<d> bytes of data pointed to by the <p>lpwdnSrc<d>
    node to the data pointed to by the <p>lpwdnDst<d> node, starting at
    <p>dSrc<d> to <p>dDst<d>.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   <t>LPWAVEDATANODE<d> | lpwdnSrc |
    Points to the source node.

@parm   <t>LPWAVEDATANODE<d> | lpwdnDst |
    Points to the destination node.

@parm   DWORD | dSrc |
    Indicates the starting offset at which the data is located.

@parm   DWORD | dDst |
    Indicates the starting offset at which to place the data.

@parm   DWORD | dLength |
    Indicates the number of bytes of data to move.

@rdesc  Returns TRUE if the data was copied, else FALSE if no memory is
    available, or if a read or write error occured.  If an error occurs,
    the task error state is set.

@comm   Note that this function will not compile with C 6.00A -Ox.
*/

PRIVATE BOOL PASCAL NEAR CopyBlockData(
    PWAVEDESC   pwd,
    LPWAVEDATANODE  lpwdnSrc,
    LPWAVEDATANODE  lpwdnDst,
    DWORD   dSrc,
    DWORD   dDst,
    DWORD   dLength)
{
    LPBYTE  lpbBuffer;
    UINT    wError;

    if (0 != (lpbBuffer = GlobalAlloc(GMEM_FIXED, dLength))) {
	if (!MySeekFile(pwd->hTempBuffers, UNMASKDATASTART(lpwdnSrc) + dSrc) ||
	    !MyReadFile(pwd->hTempBuffers, lpbBuffer, dLength, NULL) ||
	    !MySeekFile(pwd->hTempBuffers, UNMASKDATASTART(lpwdnDst) + dDst))
	{
	    wError = MCIERR_FILE_READ;
	} else {
	    if (MyWriteFile(pwd->hTempBuffers, lpbBuffer, dLength, NULL))
	    {
		wError = 0;
	    } else {
		wError = MCIERR_FILE_WRITE;
	    }
	}
        GlobalFree(lpbBuffer);
    } else
        wError = MCIERR_OUT_OF_MEMORY;

    if (wError) {
        pwd->wTaskError = wError;
        return FALSE;
    }
    return TRUE;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   DWORD | mwSplitCurrentDataNode |
    Splits the current node at the current position, creating a new node
    to contain the rest of the data, and possibly creating a second node
    to hold data not aligned on a block boundary, in the case of temporary
    data.  The new node returned will have free temporary data space
    attached that is at least <p>wMinDataLength<d> bytes in length.

    If the split point is at the start of the current node, then the new
    node is just inserted in front of the current node.

    If the split point is at the end of the data of the current node, then
    the new node is just inserted after the current node.

    Else the current node must actually be split.  This means that a new
    block to point to the data after the split point is created.  If the
    current node points to temporary data and the split point is not block
    aligned, then any extra data needs to be copied over to the new node
    that is being inserted.  This is because all starting points for
    temporary data are block aligned.  If this is not temporary data,
    then the starting and ending points can just be adjusted to the exact
    split point, instead of having to be block aligned.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dMinDataLength |
    Indicates the minimum size of temporary data space that is to be
    available to the new data node returned.

@rdesc  Returns the new node after the split, which is linked to the point
    after the current position in the current node.  This node becomes the
    current node.  Returns -1 if no memory was available, or a file error
    occurred, in which case the task error code is set.
*/

PRIVATE DWORD PASCAL NEAR mwSplitCurrentDataNode(
    PWAVEDESC   pwd,
    DWORD   dMinDataLength)
{
    LPWAVEDATANODE  lpwdn;
    LPWAVEDATANODE  lpwdnNew;
    DWORD   dNewDataNode;
    DWORD   dSplitAtData;
    BOOL    fTempData;

    dSplitAtData = pwd->dCur - pwd->dVirtualWaveDataStart;
    lpwdn = LPWDN(pwd, pwd->dWaveDataCurrentNode);
    fTempData = ISTEMPDATA(lpwdn);
    if (fTempData)
        dMinDataLength += pwd->dAudioBufferLen;
    dNewDataNode = mwFindAnyFreeDataNode(pwd, dMinDataLength);
    if (dNewDataNode == -1)
        return (DWORD)-1;
    lpwdnNew = LPWDN(pwd, dNewDataNode);
    if (!dSplitAtData) {
        if (pwd->dWaveDataCurrentNode == pwd->dWaveDataStartNode)
            pwd->dWaveDataStartNode = dNewDataNode;
        else {
            LPWAVEDATANODE  lpwdnCur;

            for (lpwdnCur = LPWDN(pwd, pwd->dWaveDataStartNode); lpwdnCur->dNextWaveDataNode != pwd->dWaveDataCurrentNode; lpwdnCur = LPWDN(pwd, lpwdnCur->dNextWaveDataNode))
                ;
            lpwdnCur->dNextWaveDataNode = dNewDataNode;
        }
        lpwdnNew->dNextWaveDataNode = pwd->dWaveDataCurrentNode;
    } else if (dSplitAtData == lpwdn->dDataLength) {
        lpwdnNew->dNextWaveDataNode = lpwdn->dNextWaveDataNode;
        lpwdn->dNextWaveDataNode = dNewDataNode;
        pwd->dVirtualWaveDataStart += lpwdn->dDataLength;
    } else {
        DWORD   dEndBlockNode;
        LPWAVEDATANODE  lpwdnEnd;
        DWORD   dSplitPoint;

        if ((dEndBlockNode = mwFindAnyFreeBlockNode(pwd)) == -1) {
            RELEASEBLOCKNODE(lpwdnNew);
            return (DWORD)-1;
        }
        lpwdnEnd = LPWDN(pwd, dEndBlockNode);
        if (fTempData) {
            dSplitPoint = ROUNDDATA(pwd, dSplitAtData);
            if (dSplitPoint != dSplitAtData) {
                if (!CopyBlockData(pwd, lpwdn, lpwdnNew, dSplitAtData, 0, dSplitPoint - dSplitAtData)) {
                    RELEASEBLOCKNODE(lpwdnNew);
                    return (DWORD)-1;
                }
                lpwdnNew->dDataLength = dSplitPoint - dSplitAtData;
            }
        } else
            dSplitPoint = dSplitAtData;
        lpwdnEnd->dNextWaveDataNode = lpwdn->dNextWaveDataNode;
        lpwdnEnd->dDataStart = lpwdn->dDataStart + dSplitPoint;
        lpwdnEnd->dDataLength = lpwdn->dDataLength - dSplitPoint;
        lpwdnEnd->dTotalLength = lpwdn->dTotalLength - dSplitPoint;
        lpwdnNew->dNextWaveDataNode = dEndBlockNode;
        lpwdn->dDataLength = dSplitAtData;
        lpwdn->dTotalLength = dSplitPoint;
        lpwdn->dNextWaveDataNode = dNewDataNode;
        pwd->dVirtualWaveDataStart += lpwdn->dDataLength;
    }
    pwd->dWaveDataCurrentNode = dNewDataNode;
    return dNewDataNode;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   DWORD | GatherAdjacentFreeDataNodes |
    This function is used to attempt to consolidate adjacent temporary
    data pointed to by free nodes so that a write can place data into
    a single node.  This is done by repeatedly requesting any free data
    node whose data points to the end of the node's data passed.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   <t>LPWAVEDATANODE<d> | lpwdn |
    Points to the node which is to collect adjacent temporary data.

@parm   DWORD | dStartPoint |
    Indicates the starting point to use when calculating the amount of
    data retrieved.  This is just subtracted from the total length of
    the data attached to the node.

@parm   DWORD | dBufferLength |
    Indicates the amount of data to retrieve.

@rdesc  Returns the amount of data actually retrieved, adjusted by
    <d>dStartPoint<d>.
*/

PRIVATE DWORD PASCAL NEAR GatherAdjacentFreeDataNodes(
    PWAVEDESC   pwd,
    LPWAVEDATANODE  lpwdn,
    DWORD   dStartPoint,
    DWORD   dBufferLength)
{
    for (; lpwdn->dTotalLength - dStartPoint < dBufferLength;) {
        DWORD   dFreeDataNode;
        LPWAVEDATANODE  lpwdnFree;

        dFreeDataNode = mwFindThisFreeDataNode(pwd, UNMASKDATASTART(lpwdn) + lpwdn->dTotalLength);
        if (dFreeDataNode == -1)
            break;
        lpwdnFree = LPWDN(pwd, dFreeDataNode);
        lpwdn->dTotalLength += lpwdnFree->dTotalLength;
        lpwdnFree->dTotalLength = 0;
    }
    return min(dBufferLength, lpwdn->dTotalLength - dStartPoint);
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   <t>LPWAVEDATANODE<d> | NextDataNode |
    Locates a free data node with the specified amount of data, and inserts
    it after the current node, setting the current node to be this new
    node.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dBufferLength |
    Indicates the minimum amount of data that is to be available to the
    new node inserted.

@rdesc  Returns the newly inserted node, else NULL on error, in which case the
    task error code is set.
*/

PRIVATE LPWAVEDATANODE PASCAL NEAR NextDataNode(
    PWAVEDESC   pwd,
    DWORD   dBufferLength)
{
    DWORD   dWaveDataNew;
    LPWAVEDATANODE  lpwdn;
    LPWAVEDATANODE  lpwdnNew;

    if ((dWaveDataNew = mwFindAnyFreeDataNode(pwd, dBufferLength)) == -1)
        return NULL;
    lpwdn = LPWDN(pwd, pwd->dWaveDataCurrentNode);
    lpwdnNew = LPWDN(pwd, dWaveDataNew);
    lpwdnNew->dNextWaveDataNode = lpwdn->dNextWaveDataNode;
    lpwdn->dNextWaveDataNode = dWaveDataNew;
    pwd->dWaveDataCurrentNode = dWaveDataNew;
    pwd->dVirtualWaveDataStart += lpwdn->dDataLength;
    return lpwdnNew;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   BOOL | AdjustLastTempData |
    This function makes two passes through the nodes that are affected by
    an overwrite record.  These are nodes that are either no longer needed,
    or whose starting point needs to be adjusted.  The two passes allow
    any data to be successfully copied before removing any unneeded nodes.
    This creates a more graceful exit to any failure.

    The first pass locates the last node affected.  If that node points to
    temporary data, and the end of the overwrite does not fall on a block
    aligned boundary, then any extra data must be copied to a block aligned
    boundary.  This means that a new node might need to be created if the
    amount of data to be copied is greater than one block's worth.  If the
    end of overwrite happens to fall on a block boundary, then no copying
    need be done.  In either case the data start point is adjusted to
    compensate for the data logically overwritten in this node, and the
    total overwrite length is adjusted so that this node is not checked on
    the second pass.

    The second pass just frees nodes that become empty, and removes them
    from the linked list of in-use nodes.  When the last node affected is
    encountered, either it will point to temporary data, in which case be
    already adjusted, or point to original data, which must be adjusted.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   <t>LPWAVEDATANODE<d> | lpwdn |
    Points to the node which is being adjusted for.  It contains the new
    data.

@parm   DWORD | dStartPoint |
    Contains the starting point at which data was overwritten.

@parm   DWORD | dWriteSize |
    Contains the amount of data overwritten.

@rdesc  Returns TRUE if the nothing needed to be adjusted, or the last node
    in the overwrite pointed to temporary data, and it was moved correctly,
    else FALSE if no memory was available, or a file error occurred.  In
    that case the task error code is set.
*/

PRIVATE BOOL PASCAL NEAR AdjustLastTempData(
    PWAVEDESC   pwd,
    LPWAVEDATANODE  lpwdn,
    DWORD   dStartPoint,
    DWORD   dWriteSize)
{
    LPWAVEDATANODE  lpwdnCur;
    DWORD   dLength;

    if ((lpwdn->dDataLength - dStartPoint >= dWriteSize) || (lpwdn->dNextWaveDataNode == ENDOFNODES))
        return TRUE;
    dWriteSize -= (lpwdn->dDataLength - dStartPoint);
    for (dLength = dWriteSize, lpwdnCur = lpwdn;;) {
        LPWAVEDATANODE  lpwdnNext;

        lpwdnNext = LPWDN(pwd, lpwdnCur->dNextWaveDataNode);
        if (lpwdnNext->dDataLength >= dLength) {
            DWORD   dNewBlockNode;
            DWORD   dMoveData;

            if (!ISTEMPDATA(lpwdnNext) || (lpwdnNext->dDataLength == dLength))
                break;
            if (lpwdnNext->dDataLength - dLength > ROUNDDATA(pwd, 1)) {
                if ((dNewBlockNode = mwFindAnyFreeBlockNode(pwd)) == -1)
                    return FALSE;
            } else
                dNewBlockNode = (DWORD)-1;
            dMoveData = min(ROUNDDATA(pwd, dLength), lpwdnNext->dDataLength) - dLength;
            if (dMoveData && !CopyBlockData(pwd, lpwdnNext, lpwdnNext, dLength, 0, dMoveData))
                return FALSE;
            if (dNewBlockNode != -1) {
                lpwdnCur = LPWDN(pwd, dNewBlockNode);
                lpwdnCur->dDataStart = lpwdnNext->dDataStart + dLength + dMoveData;
                lpwdnCur->dDataLength = lpwdnNext->dDataLength - (dLength + dMoveData);
                lpwdnCur->dTotalLength = lpwdnNext->dTotalLength - (dLength + dMoveData);
                lpwdnCur->dNextWaveDataNode = lpwdnNext->dNextWaveDataNode;
                lpwdnNext->dNextWaveDataNode = dNewBlockNode;
                lpwdnNext->dTotalLength = dLength + dMoveData;
            }
            lpwdnNext->dDataLength = dMoveData;
            dWriteSize -= dLength;
            break;
        } else if ((!ISTEMPDATA(lpwdnNext)) && (lpwdnNext->dNextWaveDataNode == ENDOFNODES))
            break;
        dLength -= lpwdnNext->dDataLength;
        lpwdnCur = lpwdnNext;
    }
    for (;;) {
        LPWAVEDATANODE  lpwdnNext;

        lpwdnNext = LPWDN(pwd, lpwdn->dNextWaveDataNode);
        if (lpwdnNext->dDataLength > dWriteSize) {
            if (dWriteSize) {
                lpwdnNext->dDataStart += dWriteSize;
                lpwdnNext->dDataLength -= dWriteSize;
                lpwdnNext->dTotalLength -= dWriteSize;
            }
            return TRUE;
        }
        dWriteSize -= lpwdnNext->dDataLength;
        lpwdn->dNextWaveDataNode = lpwdnNext->dNextWaveDataNode;
        if (!ISTEMPDATA(lpwdnNext))
            lpwdnNext->dTotalLength = 0;
        RELEASEBLOCKNODE(lpwdnNext);
        if (lpwdn->dNextWaveDataNode == ENDOFNODES)
            return TRUE;
    }
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   BOOL | mwOverWrite |
    This function overwrites data in the wave file from the specified wave
    buffer.  The position is taken from the <e>WAVEDESC.dCur<d> pointer,
    which is updated with the number of bytes actually overwritten.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   LPBYTE | lpbBuffer |
    Points to a buffer to containing the data written.

@parm   DWORD | dBufferLength |
    Indicates the byte length of the buffer.

@rdesc  Returns TRUE if overwrite succeeded, else FALSE on an error.
*/

PRIVATE BOOL PASCAL NEAR mwOverWrite(
    PWAVEDESC   pwd,
    LPBYTE  lpbBuffer,
    DWORD   dBufferLength)
{
    LPWAVEDATANODE  lpwdn;

    lpwdn = LPWDN(pwd, pwd->dWaveDataCurrentNode);
    for (; dBufferLength;)
        if (ISTEMPDATA(lpwdn)) {
            DWORD   dStartPoint;
            DWORD   dRemainingSpace;
            DWORD   dMaxWrite;

            dStartPoint = pwd->dCur - pwd->dVirtualWaveDataStart;
            dRemainingSpace = min(dBufferLength, lpwdn->dTotalLength - dStartPoint);
            if (dRemainingSpace == dBufferLength)
                dMaxWrite = dBufferLength;
            else if (UNMASKDATASTART(lpwdn) + lpwdn->dTotalLength == pwd->dWaveTempDataLength) {
                dMaxWrite = dBufferLength;
                lpwdn->dTotalLength += ROUNDDATA(pwd, dBufferLength - dRemainingSpace);
                pwd->dWaveTempDataLength += ROUNDDATA(pwd, dBufferLength - dRemainingSpace);
            } else
                dMaxWrite = GatherAdjacentFreeDataNodes(pwd, lpwdn, dStartPoint, dBufferLength);
            if (dMaxWrite) {
                DWORD   dWriteSize;

		if (!MySeekFile(pwd->hTempBuffers, UNMASKDATASTART(lpwdn) + dStartPoint)) {
                    pwd->wTaskError = MCIERR_FILE_WRITE;
                    break;
                }
		if (MyWriteFile(pwd->hTempBuffers, lpbBuffer, dMaxWrite, &dWriteSize)) {
                    if (!AdjustLastTempData(pwd, lpwdn, dStartPoint, dWriteSize))
                        break;
                    if (lpwdn->dDataLength < dStartPoint + dWriteSize)
                        lpwdn->dDataLength = dStartPoint + dWriteSize;
                    lpbBuffer += dWriteSize;
                    dBufferLength -= dWriteSize;
                    pwd->dCur += dWriteSize;
                    if (pwd->dVirtualWaveDataStart + lpwdn->dDataLength > pwd->dSize)
                        pwd->dSize = pwd->dVirtualWaveDataStart + lpwdn->dDataLength;
                }
                if (dWriteSize != dMaxWrite) {
                    pwd->wTaskError = MCIERR_FILE_WRITE;
                    break;
                }
            }
            if (dBufferLength && !(lpwdn = NextDataNode(pwd, dBufferLength)))
                break;
        } else {
            DWORD   dWaveDataNew;

            if ((dWaveDataNew = mwSplitCurrentDataNode(pwd, dBufferLength)) != -1)
                lpwdn = LPWDN(pwd, dWaveDataNew);
            else
                break;
        }
    return !dBufferLength;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   BOOL | mwInsert |
    This function inserts data to the wave file from the specified wave
    buffer.  The position is taken from the <e>WAVEDESC.dCur<d> pointer,
    which is updated with the number of bytes actually written.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   LPBYTE | lpbBuffer |
    Points to a buffer to containing the data written.

@parm   DWORD | dBufferLength |
    Indicates the byte length of the buffer.

@rdesc  Returns TRUE if insert succeeded, else FALSE on an error.
*/

PRIVATE BOOL PASCAL NEAR mwInsert(
    PWAVEDESC   pwd,
    LPBYTE  lpbBuffer,
    DWORD   dBufferLength)
{
    LPWAVEDATANODE  lpwdn;

    lpwdn = LPWDN(pwd, pwd->dWaveDataCurrentNode);
    for (; dBufferLength;)
        if (ISTEMPDATA(lpwdn) && (pwd->dCur == pwd->dVirtualWaveDataStart + lpwdn->dDataLength)) {
            DWORD   dStartPoint;
            DWORD   dRemainingSpace;
            DWORD   dMaxInsert;

            dStartPoint = pwd->dCur - pwd->dVirtualWaveDataStart;
            dRemainingSpace = min(dBufferLength, lpwdn->dTotalLength - lpwdn->dDataLength);
            if (dRemainingSpace == dBufferLength)
                dMaxInsert = dBufferLength;
            else if (UNMASKDATASTART(lpwdn) + lpwdn->dTotalLength == pwd->dWaveTempDataLength) {
                dMaxInsert = dBufferLength;
                lpwdn->dTotalLength += ROUNDDATA(pwd, dBufferLength - dRemainingSpace);
                pwd->dWaveTempDataLength += ROUNDDATA(pwd, dBufferLength - dRemainingSpace);
            } else
                dMaxInsert = GatherAdjacentFreeDataNodes(pwd, lpwdn, dStartPoint, dBufferLength);
            if (dMaxInsert) {
                DWORD   dWriteSize;

		if (!MySeekFile(pwd->hTempBuffers, UNMASKDATASTART(lpwdn) + dStartPoint)) {
                    pwd->wTaskError = MCIERR_FILE_WRITE;
                    break;
                }
		if (MyWriteFile(pwd->hTempBuffers, lpbBuffer, dMaxInsert, &dWriteSize)) {
                    lpwdn->dDataLength += dWriteSize;
                    lpbBuffer += dWriteSize;
                    dBufferLength -= dWriteSize;
                    pwd->dCur += dWriteSize;
                    pwd->dSize += dWriteSize;
                }
                if (dWriteSize != dMaxInsert) {
                    pwd->wTaskError = MCIERR_FILE_WRITE;
                    break;
                }
            }
            if (dBufferLength && !(lpwdn = NextDataNode(pwd, dBufferLength)))
                break;
        } else {
            DWORD   dWaveDataNew;

            if ((dWaveDataNew = mwSplitCurrentDataNode(pwd, dBufferLength)) != -1)
                lpwdn = LPWDN(pwd, dWaveDataNew);
            else
                break;
        }
    return !dBufferLength;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   DWORD | mwGetLevel |
    This function finds the highest level in the specified wave sample.
    Note that the function assumes that in some cases the sample size
    is evenly divisable by 4.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   LPBYTE | lpbBuffer |
    Points to a buffer containing the sample whose highest level is to be
    returned.

@parm   int | cbBufferLength |
    Indicates the byte length of the sample buffer.

@rdesc  Returns the highest level encountered in the sample for PCM data only.
    If the device has been opened with one channel, the level is contained
    in the low-order word.  Else if the device has been opened with two
    channels, one channel is in the low-order word, and the other is in the
    high-order word.
*/

PRIVATE DWORD PASCAL NEAR mwGetLevel(
    PWAVEDESC   pwd,
    LPBYTE  lpbBuffer,
    register int    cbBufferLength)
{
    if (pwd->pwavefmt->wFormatTag != WAVE_FORMAT_PCM)
        return 0;
    else if (pwd->pwavefmt->nChannels == 1) {
        int iMonoLevel;

        iMonoLevel = 0;
        if (((NPPCMWAVEFORMAT)(pwd->pwavefmt))->wBitsPerSample == 8)
            for (; cbBufferLength--; lpbBuffer++)
                iMonoLevel = max(*lpbBuffer > 128 ? *lpbBuffer - 128 : 128 - *lpbBuffer, iMonoLevel);
        else if (((NPPCMWAVEFORMAT)(pwd->pwavefmt))->wBitsPerSample == 16)
            for (; cbBufferLength; lpbBuffer += sizeof(SHORT)) {
                iMonoLevel = max(abs(*(PSHORT)lpbBuffer), iMonoLevel);
                cbBufferLength -= sizeof(SHORT);
            }
        else
            return 0;
        return (DWORD)iMonoLevel;
    } else if (pwd->pwavefmt->nChannels == 2) {
        int iLeftLevel;
        int iRightLevel;

        iLeftLevel = 0;
        iRightLevel = 0;
        if (((NPPCMWAVEFORMAT)(pwd->pwavefmt))->wBitsPerSample == 8)
            for (; cbBufferLength;) {
                iLeftLevel = max(*lpbBuffer > 128 ? *lpbBuffer - 128 : 128 - *lpbBuffer, iLeftLevel);
                lpbBuffer++;
                iRightLevel = max(*lpbBuffer > 128 ? *lpbBuffer - 128 : 128 - *lpbBuffer, iRightLevel);
                lpbBuffer++;
                cbBufferLength -= 2;
            }
        else if (((NPPCMWAVEFORMAT)(pwd->pwavefmt))->wBitsPerSample == 16)
            for (; cbBufferLength;) {
                iLeftLevel = max(abs(*(PSHORT)lpbBuffer), iLeftLevel);
                lpbBuffer += sizeof(SHORT);
                iRightLevel = max(abs(*(PSHORT)lpbBuffer), iRightLevel);
                lpbBuffer += sizeof(SHORT);
                cbBufferLength -= 2 * sizeof(SHORT);
            }
        else
            return 0;
        return MAKELONG(iLeftLevel, iRightLevel);
    }
    return 0;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   BOOL | CheckNewCommand |
    This function is called when a New command flag is found during the
    record loop.  It determines if the new commands affect current
    recording enough that it must be terminated.  This can happen if a
    Stop command is received.

    Any other record change does not need to stop current recording, as
    they should just release all the buffers from the wave device before
    setting the command.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Returns TRUE if the new commands do not affect recording and it should
    continue, else FALSE if the new commands affect the recording, and it
    should be aborted.
*/

REALLYPRIVATE   BOOL PASCAL NEAR CheckNewCommand(
    PWAVEDESC   pwd)
{
    if (ISMODE(pwd, COMMAND_STOP))
        return FALSE;
    if (ISMODE(pwd, COMMAND_INSERT))
        ADDMODE(pwd, MODE_INSERT);
    else
        ADDMODE(pwd, MODE_OVERWRITE);
    REMOVEMODE(pwd, COMMAND_NEW);
    return TRUE;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   <t>HMMIO<d> | CreateSaveFile |
    This function creates the file to which the current data is to be
    saved to in RIFF format.  This is either a temporary file created on
    the same logical disk as the original file (so that this file can
    replace the original file), else a new file.

    The RIFF header and wave header chunks are written to the new file,
    and the file position is at the start of the data to be copied.  Note
    that all the RIFF chunk headers will contain correct lengths, so there
    is no need to ascend out of the data chunk when complete.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   SSZ | sszTempSaveFile |
    Points to a buffer to contain the name of the temporary file created,
    if any.  This is zero length if a new file is to be created instead of
    a temporary file that would replace the original file.

@rdesc  Returns the handle to the save file, else NULL if a create error or
    write error occurred.

@comm   Note that this needs to be fixed so that non-DOS IO systems can save
    the file to the original name by creating a temporary file name through
    MMIO.
*/

PRIVATE HMMIO PASCAL NEAR CreateSaveFile(
    PWAVEDESC   pwd,
    LPWSTR sszTempSaveFile)
{
    MMIOINFO    mmioInfo;
    HMMIO   hmmio;
    LPWSTR   lszFile;

    InitMMIOOpen(pwd, &mmioInfo);
    if (pwd->szSaveFile) {
        *sszTempSaveFile = (char)0;
        lszFile = pwd->szSaveFile;
    } else {
        lstrcpy(sszTempSaveFile, pwd->aszFile);
        if (!mmioOpen(sszTempSaveFile, &mmioInfo, MMIO_GETTEMP)) {
            pwd->wTaskError = MCIERR_FILE_WRITE;
            return NULL;
        }
        lszFile = sszTempSaveFile;
    }
    if (0 != (hmmio = mmioOpen(lszFile, &mmioInfo, MMIO_CREATE | MMIO_READWRITE | MMIO_DENYWRITE))) {
        MMCKINFO    mmck;

        mmck.cksize = sizeof(FOURCC) + sizeof(FOURCC) + sizeof(DWORD) + pwd->wFormatSize + sizeof(FOURCC) + sizeof(DWORD) + pwd->dSize;
        if (pwd->wFormatSize & 1)
            mmck.cksize++;
        mmck.fccType = mmioWAVE;
        if (!mmioCreateChunk(hmmio, &mmck, MMIO_CREATERIFF)) {
            mmck.cksize = pwd->wFormatSize;
            mmck.ckid = mmioFMT;
            if (!mmioCreateChunk(hmmio, &mmck, 0) && (mmioWrite(hmmio, (LPSTR)pwd->pwavefmt, (LONG)pwd->wFormatSize) == (LONG)pwd->wFormatSize) && !mmioAscend(hmmio, &mmck, 0)) {
                mmck.cksize = pwd->dSize;
                mmck.ckid = mmioDATA;
                if (!mmioCreateChunk(hmmio, &mmck, 0))
                    return hmmio;
            }
        }
        pwd->wTaskError = MCIERR_FILE_WRITE;
        mmioClose(hmmio, 0);
    } else
        pwd->wTaskError = MCIERR_FILE_NOT_SAVED;
    return NULL;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   VOID | mwSaveData |
    This function is used by the background task to save the data to a
    specified file.  This has the effect of making all the temporary data
    now original data, and removing any temporary data file.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Nothing.
*/

PUBLIC  VOID PASCAL FAR mwSaveData(
    PWAVEDESC   pwd)
{
    LPBYTE  lpbBuffer = NULL;
    HANDLE  hMem;
    DWORD   AllocSize = max(min(pwd->dAudioBufferLen, pwd->dSize),1);

    // If there is no wave data, we still allocate 1 byte in order to save a NULL
    // file.  Otherwise we have no choice but to return an error saying "Out of memory"
    hMem = GlobalAlloc(GMEM_MOVEABLE, AllocSize);
    if (hMem) {
	lpbBuffer = GlobalLock(hMem);
	dprintf3(("mwSaveData allocated %d bytes at %8x, handle %8x",
	    	    AllocSize, lpbBuffer, hMem));
	dprintf3(("pwd->AudioBufferLen = %d, pwd->dSize = %d",
	            pwd->dAudioBufferLen, pwd->dSize));
    }
    if (lpbBuffer) {
        WCHAR   aszTempSaveFile[_MAX_PATH];
        HMMIO   hmmioSave;

        if (0 != (hmmioSave = CreateSaveFile(pwd, (SSZ)aszTempSaveFile))) {
            LPWAVEDATANODE  lpwdn;

            lpwdn = LPWDN(pwd, pwd->dWaveDataStartNode);
            for (;;) {
                DWORD   dDataLength;
                BOOL    fTempData;

                fTempData = ISTEMPDATA(lpwdn);
                if (fTempData)
                    MySeekFile(pwd->hTempBuffers, UNMASKDATASTART(lpwdn));
                else
                    mmioSeek(pwd->hmmio, pwd->dRiffData + lpwdn->dDataStart, SEEK_SET);
                for (dDataLength = lpwdn->dDataLength; dDataLength;) {
                    DWORD   dReadSize;

                    dReadSize = min(pwd->dAudioBufferLen, dDataLength);

		    if (dReadSize >= AllocSize) {
			dprintf(("READING TOO MUCH DATA!!"));
		    }

                    if (fTempData) {
                        if (!MyReadFile(pwd->hTempBuffers, lpbBuffer, dReadSize, NULL)) {
                            pwd->wTaskError = MCIERR_FILE_READ;
                            break;
                        }
                    } else if ((DWORD)mmioRead(pwd->hmmio, lpbBuffer, (LONG)dReadSize) != dReadSize) {
                        pwd->wTaskError = MCIERR_FILE_READ;
                        break;
                    }

                    if ((DWORD)mmioWrite(hmmioSave, lpbBuffer, (LONG)dReadSize) != dReadSize) {
                        pwd->wTaskError = MCIERR_FILE_WRITE;
                        break;
                    }
                    dDataLength -= dReadSize;
                }
                if (pwd->wTaskError)
                    break;
                if (lpwdn->dNextWaveDataNode == ENDOFNODES)
                    break;
                lpwdn = LPWDN(pwd, lpwdn->dNextWaveDataNode);
            }
            mmioClose(hmmioSave, 0);
            if (!pwd->wTaskError) {
                MMIOINFO    mmioInfo;
                MMCKINFO    mmckRiff;
                MMCKINFO    mmck;

                if (pwd->hmmio)
                    mmioClose(pwd->hmmio, 0);
                InitMMIOOpen(pwd, &mmioInfo);
                if (pwd->szSaveFile)
                    lstrcpy(pwd->aszFile, pwd->szSaveFile);
                else {
                    if (!mmioOpen(pwd->aszFile, &mmioInfo, MMIO_DELETE))
                        pwd->wTaskError = MCIERR_FILE_WRITE;
                    if (!pwd->wTaskError)
                        if (mmioRename(aszTempSaveFile, pwd->aszFile, &mmioInfo, 0)) {
                            lstrcpy(pwd->aszFile, aszTempSaveFile);
                            *aszTempSaveFile = (char)0;
                        }
                }
                pwd->hmmio = mmioOpen(pwd->aszFile, &mmioInfo, MMIO_READ | MMIO_DENYWRITE);
                if (!pwd->wTaskError) {
                    LPWAVEDATANODE  lpwdn;

                    mmckRiff.fccType = mmioWAVE;
                    mmioDescend(pwd->hmmio, &mmckRiff, NULL, MMIO_FINDRIFF);
                    mmck.ckid = mmioDATA;
                    mmioDescend(pwd->hmmio, &mmck, &mmckRiff, MMIO_FINDCHUNK);
                    pwd->dRiffData = mmck.dwDataOffset;
                    if (pwd->hTempBuffers != INVALID_HANDLE_VALUE) {

			CloseHandle(pwd->hTempBuffers);
                        pwd->dWaveTempDataLength = 0;

                        DeleteFile( pwd->aszTempFile );

                        pwd->hTempBuffers = INVALID_HANDLE_VALUE;
                    }
                    if (pwd->lpWaveDataNode) {
                        GlobalFreePtr(pwd->lpWaveDataNode);
                        pwd->lpWaveDataNode = NULL;
                        pwd->dWaveDataNodes = 0;
                    }
                    pwd->dVirtualWaveDataStart = 0;
                    pwd->dWaveDataCurrentNode = 0;
                    pwd->dWaveDataStartNode = 0;
                    mwAllocMoreBlockNodes(pwd);
                    lpwdn = LPWDN(pwd, 0);
                    lpwdn->dNextWaveDataNode = (DWORD)ENDOFNODES;
                    lpwdn->dDataLength = pwd->dSize;
                    lpwdn->dTotalLength = pwd->dSize;
                    if (!pwd->szSaveFile && !*aszTempSaveFile)
                        pwd->wTaskError = MCIERR_FILE_WRITE;
                }
            }
        }
        GlobalUnlock(hMem);
    } else {
        pwd->wTaskError = MCIERR_OUT_OF_MEMORY;
    }

    if (hMem) {
        GlobalFree(hMem);
    }
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   VOID | mwDeleteData |
    This function is used by the background task to delete data.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Nothing.
*/

PUBLIC  VOID PASCAL FAR mwDeleteData(
    PWAVEDESC   pwd)
{
    DWORD   dTotalToDelete;
    LPWAVEDATANODE  lpwdn;
    LPWAVEDATANODE  lpwdnCur;
    DWORD dVirtualWaveDataStart;

    lpwdn = LPWDN(pwd, pwd->dWaveDataCurrentNode);
    dTotalToDelete = pwd->dTo - pwd->dFrom;

    if (dTotalToDelete == pwd->dSize) {
		// The whole wave chunk is to be deleted - nice and simple
        DWORD   dNewDataNode;

        if ((dNewDataNode = mwFindAnyFreeDataNode(pwd, 1)) == -1) {
			dprintf2(("mwDeleteData - no free data node"));
            return;
		}
        RELEASEBLOCKNODE(LPWDN(pwd, dNewDataNode));
    }

	dprintf3(("mwDeleteData - size to delete = %d", dTotalToDelete));
    for (dVirtualWaveDataStart = pwd->dVirtualWaveDataStart; dTotalToDelete;) {
        DWORD   dDeleteLength;

        dDeleteLength = min(dTotalToDelete, lpwdn->dDataLength - (pwd->dFrom - dVirtualWaveDataStart));
		dprintf4(("mwDelete dTotalToDelete = %d, dDeleteLength = %d", dTotalToDelete, dDeleteLength));

		if (!dDeleteLength) {
			// Nothing to be deleted from this block
			dprintf3(("mwDelete skipping to next block"));
            dVirtualWaveDataStart += lpwdn->dDataLength;
            lpwdn = LPWDN(pwd, lpwdn->dNextWaveDataNode);
			continue;  // iterate around the for loop
		}
		// Note: the block above is new to NT.  Windows 3.1 as shipped fails.
		// The problem can be seen with a wave file > 3 seconds long and
		// the following two commands:
		// delete wave from 1000 to 2000
		// delete wave from 1000 to 2000
		// Because of the fragmentation the second delete fails.  It decided
		// that NO data can be deleted from the first block, but never
		// stepped on to the next block.

        if (ISTEMPDATA(lpwdn)) {
			dprintf3(("mwDeleteData - temporary data"));
            if (dVirtualWaveDataStart + lpwdn->dDataLength <= pwd->dFrom + dTotalToDelete)
                lpwdn->dDataLength -= dDeleteLength;  // Delete data in this block
            else {
                DWORD   dNewBlockNode;
                DWORD   dDeleteStart;
                DWORD   dEndSplitPoint;
                DWORD   dMoveData;

                dDeleteStart = pwd->dFrom - dVirtualWaveDataStart;
                dEndSplitPoint = min(ROUNDDATA(pwd, dDeleteStart + dDeleteLength), lpwdn->dDataLength);
                if (dEndSplitPoint < lpwdn->dDataLength) {
                    if ((dNewBlockNode = mwFindAnyFreeBlockNode(pwd)) == -1)
                        break;
                } else
                    dNewBlockNode = (DWORD)-1;
                dMoveData = dEndSplitPoint - (dDeleteStart + dDeleteLength);
                if (dMoveData && !CopyBlockData(pwd, lpwdn, lpwdn, dDeleteStart + dDeleteLength, dDeleteStart, dMoveData))
                    break;
                if (dNewBlockNode != -1) {
                    lpwdnCur = LPWDN(pwd, dNewBlockNode);
                    lpwdnCur->dDataStart = lpwdn->dDataStart + dEndSplitPoint;
                    lpwdnCur->dDataLength = lpwdn->dDataLength - dEndSplitPoint;
                    lpwdnCur->dTotalLength = lpwdn->dTotalLength - dEndSplitPoint;
                    lpwdnCur->dNextWaveDataNode = lpwdn->dNextWaveDataNode;
                    lpwdn->dNextWaveDataNode = dNewBlockNode;
                    lpwdn->dTotalLength = dEndSplitPoint;
                }
                lpwdn->dDataLength = dDeleteStart + dMoveData;
            }
        } else if (dVirtualWaveDataStart == pwd->dFrom) {
			// FROM point is the same as the virtual start point, hence we are
			// deleting from the beginning of this wave data block.  We can
			// simply adjust the total length and start point.
			dprintf4(("mwDeleteData - From == Start, deleting from start of block"));
            lpwdn->dDataStart += dDeleteLength;
            lpwdn->dDataLength -= dDeleteLength;
            lpwdn->dTotalLength = lpwdn->dDataLength;
        } else if (dVirtualWaveDataStart + lpwdn->dDataLength <= pwd->dFrom + dTotalToDelete) {
			// FROM point plus amount to delete takes us to the end of the wave
			// data - meaning that the data block can be truncated. We can
			// simply adjust the total length.
			dprintf4(("mwDeleteData - delete to end of block"));
            lpwdn->dDataLength -= dDeleteLength;
            lpwdn->dTotalLength = lpwdn->dDataLength;
        } else {
			// We have to delete a chunk out of the middle.
            DWORD   dNewBlockNode;
            DWORD   dDeleteStart;

			// The existing single block will now be covered by two blocks
			// Find a new node, then set the current node start->deletefrom
			// and the new node deletefrom+deletelength for the remaining
			// length of this node.  It all hinges on finding a free node...
            if ((dNewBlockNode = mwFindAnyFreeBlockNode(pwd)) == -1) {
				dprintf2(("mwDeleteData - cannot find free node"));
                break;
			}

            dDeleteStart = pwd->dFrom - dVirtualWaveDataStart;
            lpwdnCur = LPWDN(pwd, dNewBlockNode);
            lpwdnCur->dDataStart = dVirtualWaveDataStart + dDeleteStart + dDeleteLength;
            lpwdnCur->dDataLength = lpwdn->dDataLength - (dDeleteStart + dDeleteLength);
            lpwdnCur->dTotalLength = lpwdnCur->dDataLength;
            lpwdnCur->dNextWaveDataNode = lpwdn->dNextWaveDataNode;
            lpwdn->dDataLength = dDeleteStart;
            lpwdn->dTotalLength = dDeleteStart;
            lpwdn->dNextWaveDataNode = dNewBlockNode;
        }
        dTotalToDelete -= dDeleteLength;
        if (!lpwdn->dDataLength && dTotalToDelete) {
            dVirtualWaveDataStart += lpwdn->dDataLength;
            lpwdn = LPWDN(pwd, lpwdn->dNextWaveDataNode);
			dprintf4(("mwDeleteData - more to delete, iterating"));
		}
    }

    pwd->dSize -= ((pwd->dTo - pwd->dFrom) + dTotalToDelete);
    for (lpwdn = NULL, lpwdnCur = LPWDN(pwd, pwd->dWaveDataStartNode);;) {
        if (!lpwdnCur->dDataLength) {
            if (lpwdn) {
                if (pwd->dWaveDataCurrentNode == lpwdn->dNextWaveDataNode)
                    pwd->dWaveDataCurrentNode = lpwdnCur->dNextWaveDataNode;
                lpwdn->dNextWaveDataNode = lpwdnCur->dNextWaveDataNode;
            } else {
                if (pwd->dWaveDataCurrentNode == pwd->dWaveDataStartNode)
                    pwd->dWaveDataCurrentNode = lpwdnCur->dNextWaveDataNode;
                pwd->dWaveDataStartNode = lpwdnCur->dNextWaveDataNode;
            }
            RELEASEBLOCKNODE(lpwdnCur);
        }
        if (lpwdnCur->dNextWaveDataNode == ENDOFNODES){
            break;
		}
        lpwdn = lpwdnCur;
        lpwdnCur = LPWDN(pwd, lpwdn->dNextWaveDataNode);
    }

    if (!pwd->dSize) {

        pwd->dWaveDataStartNode = mwFindAnyFreeDataNode(pwd, 1);
        pwd->dWaveDataCurrentNode = pwd->dWaveDataStartNode;
        lpwdn = LPWDN(pwd, pwd->dWaveDataStartNode);
        lpwdn->dNextWaveDataNode = (DWORD)ENDOFNODES;

    } else if (pwd->dWaveDataCurrentNode == ENDOFNODES) {

        pwd->dVirtualWaveDataStart = 0;
        pwd->dWaveDataCurrentNode = pwd->dWaveDataStartNode;

        for (lpwdn = LPWDN(pwd, pwd->dWaveDataStartNode); pwd->dFrom > pwd->dVirtualWaveDataStart + lpwdn->dDataLength;) {

            pwd->dVirtualWaveDataStart += lpwdn->dDataLength;
            pwd->dWaveDataCurrentNode = lpwdn->dNextWaveDataNode;
            lpwdn = LPWDN(pwd, pwd->dWaveDataCurrentNode);
        }
    }
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   UINT | RecordFile |
    This function is used to Cue or Record wave device input.  For normal
    recording mode the function basically queues buffers on the wave
    device, and writes them to a file as they are filled, blocking for
    each buffer.  It also makes sure to call <f>mmYield<d> while both
    writing out new buffers, and waiting for buffers to be filled.  This
    means that it will try to add all the buffers possible to the input
    wave device, and then write them as fast as possible.

    For Cue mode, the function also tries to add buffers to the wave
    input device, but nothing is ever written out, and only the highest
    level is calculated.

    Within the record loop, the function first checks to see if there
    is a Cue mode buffer waiting, and if so, waits for it.  This allows
    only one buffer to be added to the device when in Cue mode.  The
    current level is calculated with the contents of the buffer.

    If the function is not in Cue mode, or there is not currently a
    queued buffer, the function tries to add a new buffer to the input
    wave device.  This cannot occur if a new command is pending, or there
    are no buffers available.  This means that in normal recording mode,
    there will possibly be extra data recorded that does not need to be.
    If an error occurs adding the buffer to the wave device, the record
    function is aborted with an error, else the current outstanding buffer
    count is incremented, and a pointer to the next available recording
    buffer is fetched.

    If no new buffers can be added, the existing buffers are written to
    the file.  This section cannot be entered in Cue mode, as it is
    dealt with in the first condition.  The task is blocked pending a
    signal from the wave device that a buffer has been filled.  It then
    checks to see if any more data needs to be recorded before attempting
    to write that data.  Note that all filled buffers are dealt with one
    after the other without yielding or otherwise adding new record
    buffers.  If the input capability is much faster than the machine,
    this means that instead of getting a lot of disconnect samples, large
    gaps will be produced.  This loop is broken out of when either all the
    buffers that were added are written, or no more buffers are currently
    ready (checks the WHDR_DONE flag).

    If no buffers need to be written, the loop checks for the new command
    flag, which can possibly interrupt or change the current recording.
    The only thing that can really make a difference is a stop command,
    and as this case is handled after all buffers are written, the loop
    can immediately exit.

    The final default condition occurs when all the data has been recorded,
    all the buffers have been released, and no new command was encountered.
    In this case, recording is done, and the record loop is exited.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Returns the number of outstanding buffers added to the wave device.
    This can be used when removing task signal from the message queue.
    In cases of error, the <e>WAVEDESC.wTaskError<d> flag is set.  This
    specific error is not currently returned, as the calling task may not
    have waited for the command to complete.  But it is at least used for
    notification in order to determine if Failure status should be sent.

@xref   PlayFile.
*/

PUBLIC  UINT PASCAL FAR RecordFile(
    register PWAVEDESC  pwd)
{
    LPWAVEHDR   *lplpWaveHdrRecord;
    LPWAVEHDR   *lplpWaveHdrWrite;
    UINT        wMode;
    register UINT   wBuffersOutstanding;

    if (0 != (pwd->wTaskError = waveInStart(pwd->hWaveIn)))
        return 0;

    for (wBuffersOutstanding = 0, lplpWaveHdrRecord = lplpWaveHdrWrite = pwd->rglpWaveHdr;;) {

        if (ISMODE(pwd, COMMAND_CUE) && wBuffersOutstanding) {
            if (TaskBlock() == WM_USER) {
                wBuffersOutstanding--;
            }

            if (!ISMODE(pwd, COMMAND_NEW)) {
                pwd->dLevel = mwGetLevel(pwd, (*lplpWaveHdrWrite)->lpData, (int)(*lplpWaveHdrWrite)->dwBytesRecorded);
                ADDMODE(pwd, MODE_CUED);
            }

            lplpWaveHdrWrite = NextWaveHdr(pwd, lplpWaveHdrWrite);

        } else if (!ISMODE(pwd, COMMAND_NEW) && (wBuffersOutstanding < pwd->wAudioBuffers)) {

            (*lplpWaveHdrRecord)->dwBufferLength = (pwd->wMode & COMMAND_CUE) ? NUM_LEVEL_SAMPLES : min(pwd->dAudioBufferLen, pwd->dTo - pwd->dCur);
            (*lplpWaveHdrRecord)->dwFlags &= ~(WHDR_DONE | WHDR_BEGINLOOP | WHDR_ENDLOOP);
            if (0 != (pwd->wTaskError = waveInAddBuffer(pwd->hWaveIn, *lplpWaveHdrRecord, sizeof(WAVEHDR))))
                break;

            wBuffersOutstanding++;
            lplpWaveHdrRecord = NextWaveHdr(pwd, lplpWaveHdrRecord);

        } else if (wBuffersOutstanding) {

            BOOL    fExitRecording;

            for (fExitRecording = FALSE; wBuffersOutstanding && !fExitRecording;) {

                if (TaskBlock() == WM_USER) {
                    wBuffersOutstanding--;
                }
                if (pwd->dTo == pwd->dCur) {
                    fExitRecording = TRUE;
                    break;
                }
                if (!(pwd->wMode & COMMAND_CUE))
                    if (pwd->wMode & MODE_INSERT) {
                        if (!mwInsert(pwd, (LPBYTE)(*lplpWaveHdrWrite)->lpData, min((*lplpWaveHdrWrite)->dwBytesRecorded, pwd->dTo - pwd->dCur)))
                            fExitRecording = TRUE;
                    } else if (!mwOverWrite(pwd, (LPBYTE)(*lplpWaveHdrWrite)->lpData, min((*lplpWaveHdrWrite)->dwBytesRecorded, pwd->dTo - pwd->dCur)))
                        fExitRecording = TRUE;
                lplpWaveHdrWrite = NextWaveHdr(pwd, lplpWaveHdrWrite);
                if (!((*lplpWaveHdrWrite)->dwFlags & WHDR_DONE))
                    break;
            }

            if (fExitRecording)
                break;

        } else if (!ISMODE(pwd, COMMAND_NEW) || !CheckNewCommand(pwd))
            break;
        else
            wMode = GETMODE(pwd);

        mmYield(pwd);
    }
    REMOVEMODE(pwd, MODE_INSERT | MODE_OVERWRITE);
    return wBuffersOutstanding;
}

/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mciwave\mciwave.c ===
/************************************************************************/

/*
**  Copyright (c) 1985-1998 Microsoft Corporation
**
**  Title: mciwave.c - Multimedia Systems Media Control Interface
**  waveform audio driver for RIFF wave files.
**
**  Version:    1.00
**
**  Date:       18-Apr-1990
**
**  Author:     ROBWI
*/

/************************************************************************/

/*
**  Change log:
**
**  DATE        REV DESCRIPTION
**  ----------- -----   ------------------------------------------
**  18-APR-1990 ROBWI   Original
**  19-JUN-1990 ROBWI   Added wave in
**  13-Jan-1992 MikeTri Ported to NT
**                  @@@ To be changed
**   3-Mar-1992 SteveDav Continue port
*/

/************************************************************************/
#define UNICODE

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICONS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define OEMRESOURCE
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
#define NOCTLMGR
#define NODRAWTEXT
#define NOGDI
#define NOKERNEL
#define NONLS
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOOPENFILE
#define NOSCROLL
#define NOTEXTMETRIC
#define NOWH
//#define NOWINOFFSETS  Hides definition of GetDesktopWindow
#define NOCOMM
#define NOKANJI
#define NOHELP
#define NOPROFILER
#define NODEFERWINDOWPOS

#include <windows.h>
#include "mciwave.h"
#include <mmddk.h>
#include <wchar.h>
#include <gmem.h>


STATICFN LPBYTE GlobalReAllocPtr(LPVOID lp, DWORD cbNew, DWORD flags)
{
    HANDLE h, hNew;
    LPBYTE lpNew = NULL;

    h = GlobalHandle(lp);
    if (!h) {
   return(NULL);
    }

    GlobalUnlock(h);

    hNew = GlobalReAlloc(h , cbNew, flags);
    if (hNew) {
   lpNew = GlobalLock(hNew);
   if (!lpNew) {
       dprintf1(("FAILED to lock reallocated memory handle %8x (%8x)", hNew, lp));
       // we still return the lpNew pointer, even though the memory
       // is not locked down.  Perhaps this should be an error?
       // At this point the existing block could have been trashed!
   } else {
       dprintf3(("Reallocated ptr %8x to %8x (Handle %8x)", lp, lpNew, h));
   }
    } else {
   dprintf1(("FAILED to realloc memory handle %8x (%8x)", h, lp));
   GlobalLock(h);    // restore the lock
    }
    return(lpNew);
}

PRIVATE DWORD PASCAL FAR time2bytes(
        PWAVEDESC  pwd,
        DWORD      dTime,
        DWORD      dFormat);

PRIVATE DWORD PASCAL FAR bytes2time(
        PWAVEDESC  pwd,
        DWORD      dBytes,
        DWORD      dFormat);
PRIVATE UINT PASCAL NEAR mwCheckDevice(
        PWAVEDESC   pwd,
        DIRECTION   Direction);

/************************************************************************/

/*
**  The following constants define the default values used when creating
**  a new wave file during the MCI_OPEN command.
*/

#define DEF_CHANNELS    1
#define DEF_AVGBYTESPERSEC  11025L

/************************************************************************/

/*
**  hModuleInstance Instance handle of the wave driver module.
**  cWaveOutMax Number of wave output devices available.
**  cWaveInMax  Number of wave output devices available.
**  wAudioSeconds   Contains the number of seconds of audio buffers to
**          allocate for playback and recording.  This is set
**          during the DRV_OPEN message.
**  aszPrefix   Contains the prefix to use for temporary file names.
*/

HINSTANCE   hModuleInstance;
UINT    cWaveOutMax;
UINT    cWaveInMax;
UINT    wAudioSeconds;
PRIVATE SZCODE aszPrefix[] = L"mci";

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   VOID | ReleaseWaveBuffers |
    This function releases all buffers that have been added to the wave
    input or output device if any device is present.  This has the side
    affect of immediately posting signals to the task for each buffer
    released.  That allows a task to be released if it is waiting for
    a buffer to be freed, and to leave the current state.

    It also has the effect of resetting the byte input and output counters
    for the wave device, so that accurate byte counts must be retrieved
    before calling this function.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Nothing.
*/

PRIVATE VOID PASCAL NEAR ReleaseWaveBuffers(
    PWAVEDESC   pwd)
{
    if (pwd->hWaveOut || pwd->hWaveIn) {

        if (pwd->Direction == output)
            waveOutReset(pwd->hWaveOut);
        else
            waveInReset(pwd->hWaveIn);
    }
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    DWORD | time2bytes |
    Converts the specified time format to a byte equivalent.  For
    converting milliseconds, the <f>MulDiv<d> function is used to
    avoid overflows on large files with high average sample rates.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dTime |
    Position in Bytes, Samples or Milliseconds.

@parm   DWORD | dFormat |
    Indicates whether time is in Samples, Bytes or Milliseconds.

@rdesc  Returns byte offset equivalent of the <p>lTime<d> passed.
*/

PRIVATE DWORD PASCAL FAR time2bytes(
    PWAVEDESC   pwd,
    DWORD   dTime,
    DWORD   dFormat)
{
    if (dFormat == MCI_FORMAT_SAMPLES)
        dTime = (DWORD)(MulDiv((LONG)dTime, pwd->pwavefmt->nAvgBytesPerSec, pwd->pwavefmt->nSamplesPerSec) / pwd->pwavefmt->nBlockAlign) * pwd->pwavefmt->nBlockAlign;
    else if (dFormat == MCI_FORMAT_MILLISECONDS)
        dTime = (DWORD)MulDiv((LONG)dTime, pwd->pwavefmt->nAvgBytesPerSec, 1000L);

    return dTime;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    DWORD | bytes2time |
    Converts a byte offset to the specified time format equivalent.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dBytes |
    Position in bytes.

@parm   DWORD | dFormat |
    Indicates whether the return time is in Samples, Bytes or Milliseconds.

@rdesc  Returns the specified time equivalent.
*/

PRIVATE DWORD PASCAL FAR bytes2time(
    PWAVEDESC   pwd,
    DWORD   dBytes,
    DWORD   dFormat)
{
    if (dFormat == MCI_FORMAT_SAMPLES)
        dBytes = (DWORD)MulDiv((LONG)dBytes, pwd->pwavefmt->nSamplesPerSec, pwd->pwavefmt->nAvgBytesPerSec);
    else if (dFormat == MCI_FORMAT_MILLISECONDS)
        dBytes = (DWORD)MulDiv((LONG)dBytes, 1000L, pwd->pwavefmt->nAvgBytesPerSec);

    return dBytes;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    VOID | mwCloseFile |
    Close the currently open file by releasing the MMIO handle and closing
    the temporary buffer file, if any.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Nothing.
*/

PRIVATE VOID PASCAL NEAR mwCloseFile(
    PWAVEDESC   pwd)
{
    if (pwd->hmmio) {
        mmioClose(pwd->hmmio, 0);
        pwd->hmmio = NULL;
    }

    if (pwd->hTempBuffers != INVALID_HANDLE_VALUE) {
	CloseHandle(pwd->hTempBuffers);

        DeleteFile( pwd->aszTempFile );

        pwd->hTempBuffers = 0;
    }

    if (pwd->lpWaveDataNode) {
        GlobalFreePtr(pwd->lpWaveDataNode);
        pwd->lpWaveDataNode = NULL;
    }

    if (pwd->pwavefmt) {
        LocalFree(pwd->pwavefmt);
        pwd->pwavefmt = NULL;
    }

}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    VOID | SetMMIOError |
    Converts the specified MMIO error to an MCI error, and sets the task
    error <e>PWAVEDESC.wTaskError<d>.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   UINT | wError |
    Indicates the MMIO error that is to be converted to an MCI error.  An
    unknown MMIO error will generate an MCIERR_INVALID_FILE MCI error.

@rdesc  Nothing.
*/

PRIVATE VOID PASCAL NEAR SetMMIOError(
    PWAVEDESC   pwd,
    UINT    wError)
{
    //Assumes that we already own pwd

    switch (wError) {
    case MMIOERR_FILENOTFOUND:
        wError = MCIERR_FILE_NOT_FOUND;
        break;

    case MMIOERR_OUTOFMEMORY:
        wError = MCIERR_OUT_OF_MEMORY;
        break;

    case MMIOERR_CANNOTOPEN:
        wError = MCIERR_FILE_NOT_FOUND;
        break;

    case MMIOERR_CANNOTREAD:
        wError = MCIERR_FILE_READ;
        break;

    case MMIOERR_CANNOTWRITE:
        wError = MCIERR_FILE_WRITE;
        break;

    case MMIOERR_CANNOTSEEK:
        wError = MCIERR_FILE_READ;
        break;

    case MMIOERR_CANNOTEXPAND:
        wError = MCIERR_FILE_WRITE;
        break;

    case MMIOERR_CHUNKNOTFOUND:
    default:
        wError = MCIERR_INVALID_FILE;
        break;
    }
    pwd->wTaskError = wError;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    BOOL | ReadWaveHeader |
    Reads the RIFF header, and wave header chunk from the file.  Allocates
    memory to hold that chunk, and descends into the wave data chunk,
    storing the offset to the beginning of the actual wave data.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Returns TRUE if the current file is a valid RIFF format wave file,
    and can be read, else FALSE if a read error occurs, or invalid data is
    encountered.
*/

PRIVATE BOOL PASCAL NEAR ReadWaveHeader(
    PWAVEDESC   pwd)
{
    MMCKINFO    mmckRIFF;
    MMCKINFO    mmck;
    UINT    wError;

    mmckRIFF.fccType = mmioWAVE;
    if (0 != (wError = mmioDescend(pwd->hmmio, &mmckRIFF, NULL, MMIO_FINDRIFF))) {
        SetMMIOError(pwd, wError);
        return FALSE;
    }

    mmck.ckid = mmioFMT;
    if (0 != (wError = mmioDescend(pwd->hmmio, &mmck, &mmckRIFF, MMIO_FINDCHUNK))) {
        SetMMIOError(pwd, wError);
        return FALSE;
    }

    if (mmck.cksize < (LONG)sizeof(PCMWAVEFORMAT)) {
        pwd->wTaskError = MCIERR_INVALID_FILE;
        return FALSE;
    }

    pwd->wFormatSize = mmck.cksize;
    pwd->pwavefmt = (WAVEFORMAT NEAR *)LocalAlloc(LPTR, pwd->wFormatSize);
    if (!pwd->pwavefmt) {
        pwd->wTaskError = MCIERR_OUT_OF_MEMORY;
        return FALSE;
    }

    if ((DWORD)mmioRead(pwd->hmmio, (HPSTR)pwd->pwavefmt, mmck.cksize) != mmck.cksize) {
        pwd->wTaskError = MCIERR_FILE_READ;
        return FALSE;
    }

    if (0 != (wError = mmioAscend(pwd->hmmio, &mmck, 0))) {
        SetMMIOError(pwd, wError);
        return FALSE;
    }

    mmck.ckid = mmioDATA;
    if (0 != (wError = mmioDescend(pwd->hmmio, &mmck, &mmckRIFF, MMIO_FINDCHUNK))) {
        SetMMIOError(pwd, wError);
        return FALSE;
    }

    pwd->dSize = mmck.cksize;
    pwd->dRiffData = mmck.dwDataOffset;
    pwd->dAudioBufferLen = BLOCKALIGN(pwd, pwd->pwavefmt->nAvgBytesPerSec);
    return TRUE;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    DWORD | mwAllocMoreBlockNodes |
    This function is called in order to force more wave data nodes to be
    allocated.  This is done in increments of DATANODEALLOCSIZE, and the
    index to the first new node is returned.  The new nodes are initialized
    as free nodes.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Returns the index to the first of the new nodes allocated, else -1 if
    no memory was available, in which case the task error is set.  The
    node returned is marked as a free node, and need not be discarded if
    not used.
*/

PUBLIC  DWORD PASCAL FAR mwAllocMoreBlockNodes(
    PWAVEDESC   pwd)
{
    LPWAVEDATANODE  lpwdn;
    DWORD   dNewBlockNode;

#ifdef DEBUG
    if (pwd->thread) {
   dprintf(("reentering mwAllocMoreBlockNodes!!"));
    }
#endif

    //EnterCrit();
    if (pwd->dWaveDataNodes)
        lpwdn = (LPWAVEDATANODE)GlobalReAllocPtr(pwd->lpWaveDataNode, (pwd->dWaveDataNodes + DATANODEALLOCSIZE) * sizeof(WAVEDATANODE), GMEM_MOVEABLE | GMEM_ZEROINIT);
    else
        lpwdn = (LPWAVEDATANODE)GlobalAllocPtr(GMEM_MOVEABLE | GMEM_ZEROINIT, DATANODEALLOCSIZE * sizeof(WAVEDATANODE));

    if (lpwdn) {
   dprintf2(("Set lpWaveDataNode to %8x (it was %8x)", lpwdn, pwd->lpWaveDataNode));
        pwd->lpWaveDataNode = lpwdn;
        for (lpwdn = LPWDN(pwd, pwd->dWaveDataNodes), dNewBlockNode = 0; dNewBlockNode < DATANODEALLOCSIZE; lpwdn++, dNewBlockNode++)
            RELEASEBLOCKNODE(lpwdn);
        dNewBlockNode = pwd->dWaveDataNodes;
        pwd->dWaveDataNodes += DATANODEALLOCSIZE;
    } else {
   dprintf1(("** ERROR ** Allocating more block nodes (%8x)", pwd->lpWaveDataNode));
        dNewBlockNode =  (DWORD)-1;
        pwd->wTaskError = MCIERR_OUT_OF_MEMORY;
    }

    //LeaveCrit();
    return dNewBlockNode;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    BOOL | CreateTempFile |
    This function creates the temporary data file used to store newly
    recorded data before a Save command is issued to perminently store
    the data in a RIFF format file.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Returns TRUE if the temporary data file was created, else FALSE, in
    which case the task error is set.
*/

PRIVATE BOOL PASCAL NEAR CreateTempFile(
    PWAVEDESC   pwd)
{
    UINT n;
    TCHAR tempbuf[_MAX_PATH];
    /* First find out where the file should be stored */
    n = GetTempPath(sizeof(tempbuf)/sizeof(TCHAR), tempbuf);

    if (n && GetTempFileName(tempbuf, aszPrefix, 0, pwd->aszTempFile)) {

        pwd->hTempBuffers = CreateFile( pwd->aszTempFile,
					GENERIC_READ | GENERIC_WRITE,
					0,
					NULL,
					CREATE_ALWAYS,
					FILE_ATTRIBUTE_NORMAL,
					NULL );


        if ( pwd->hTempBuffers != INVALID_HANDLE_VALUE) {
            return TRUE;
        } else {
            dprintf2(("hTempBuffers == INVALID_HANDLE_VALUE in CreateTempFile"));
        }

    } else {
        dprintf2(("Error %d from GetTempFileName or GetTempPath in CreateTempFile", GetLastError()));
    }
    pwd->wTaskError = MCIERR_FILE_WRITE;
    return FALSE;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    DWORD | mwFindAnyFreeDataNode |
    This function is used to find a free wave data node with a minimum of
    <p>dMinDataLength<d> temporary data space attached.  To do this, all
    the current data nodes are traversed, looking for free ones with at
    least the specified amount of temporary data storage attached.

    As the nodes are being traversed, if a free block is encountered that
    has no data attached, it is saved.  Also, if a node with data attached
    that is too short, but is at the end of the temporary data storage file
    is found, that also is saved.  These will then be used if an
    appropriate node can not be found.

    If an appropriate node can not be found, but a node pointing to the
    last of the temporary data was found, then the data is expanded, and
    that node is returned.  Else if an empty node was found, then it is
    returned with data attached, else a new empty node is created.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dMinDataLength |
    Indicates the minimum amount of temporary data space that must be
    attached to the wave data node returned.  This number is rounded up to
    the nearest block aligned size.

@rdesc  Returns a node with a least the minimum request size of temporary
    data attached, else -1 if not enough memory was available, or the
    temporary data file could not be created.  In that case, the task error
    is set.  The node returned is marked as in use, and must be discarded
    if not used.
*/

PUBLIC  DWORD PASCAL FAR mwFindAnyFreeDataNode(
    PWAVEDESC   pwd,
    DWORD   dMinDataLength)
{
    LPWAVEDATANODE  lpwdn;
    DWORD   dNewBlockNode;
    DWORD   dEmptyBlockNode;
    DWORD   dEmptyDataNode;

    dEmptyBlockNode = (DWORD)-1;
    dEmptyDataNode = (DWORD)-1;
    for (lpwdn = LPWDN(pwd, 0), dNewBlockNode = 0; dNewBlockNode < pwd->dWaveDataNodes; lpwdn++, dNewBlockNode++) {
        if (ISFREEBLOCKNODE(lpwdn)) {
            if (lpwdn->dTotalLength >= dMinDataLength) {
                lpwdn->dDataLength = 0;
                return dNewBlockNode;
            }
            if (!lpwdn->dTotalLength)
                dEmptyBlockNode = dNewBlockNode;
            else if (lpwdn->dDataStart + lpwdn->dTotalLength == pwd->dWaveTempDataLength)
                dEmptyDataNode = dNewBlockNode;
        }
    }

    dMinDataLength = ROUNDDATA(pwd, dMinDataLength);
    if (dEmptyDataNode != -1) {
        lpwdn = LPWDN(pwd, dEmptyDataNode);
        lpwdn->dDataLength = 0;
        lpwdn->dTotalLength = dMinDataLength;
        if (UNMASKDATASTART(lpwdn) + lpwdn->dTotalLength > pwd->dWaveTempDataLength)
            pwd->dWaveTempDataLength = UNMASKDATASTART(lpwdn) + lpwdn->dTotalLength;
    } else {
        if ((pwd->hTempBuffers == INVALID_HANDLE_VALUE) && !CreateTempFile(pwd))
            return (DWORD)-1;
        if (dEmptyBlockNode != -1) {
            dNewBlockNode = dEmptyBlockNode;
        } else if ((dNewBlockNode = mwAllocMoreBlockNodes(pwd)) == -1)
            return (DWORD)-1;
        lpwdn = LPWDN(pwd, dNewBlockNode);
        lpwdn->dDataStart = MASKDATASTART(pwd->dWaveTempDataLength);
        lpwdn->dDataLength = 0;
        lpwdn->dTotalLength = dMinDataLength;
        pwd->dWaveTempDataLength += lpwdn->dTotalLength;
    }
    return dNewBlockNode;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    VOID | InitMMIOOpen |
    This function initializes the MMIO open structure by zeroing out all
    entries, and setting the IO procedure or file type if needed.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   <t>LPMMIOINFO<d> | lpmmioInfo |
    Points to the MMIO structure to initialize.

@rdesc  nothing.
*/

PUBLIC  VOID PASCAL FAR InitMMIOOpen(
    PWAVEDESC   pwd,
    LPMMIOINFO  lpmmioInfo)
{
    memset(lpmmioInfo, 0, sizeof(MMIOINFO));
    lpmmioInfo->pIOProc = pwd->pIOProc;
    lpmmioInfo->htask = mciGetCreatorTask(pwd->wDeviceID);
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    BOOL | mwOpenFile |
    This function opens and verifies the file specified in the wave
    descriptor block.  If no file is specified in the block, a new,
    unnamed wave format file is opened.

    If <e>WAVEDESC.aszFile<d> specifies a non-zero length string, it is
    assumed to contain the file name to open.  The function attempts to
    open this file name, setting the <e>WAVEDESC.hmmio<d> element, and
    returns any error.

    If on the other hand the file name element is zero length, the
    function assumes that it is to open a new, unnamed wave file.  It
    attempts to do so using the default parameters.

    If the file can be opened, the format information is set.  In order to be
    able to work with formats other than PCM, the length of the format block
    is not assumed, although the start of the block is assumed to be in PCM
    header format.  The format for a new file is PCM.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Returns TRUE if file opened and the header information read, else
    FALSE, in which case the <e>WAVEDESC.wTaskError<d> flag is set with
    the MCI error.
*/

PRIVATE BOOL PASCAL NEAR mwOpenFile(
    PWAVEDESC   pwd)
{
    LPWAVEDATANODE  lpwdn;

    pwd->dWaveDataStartNode = mwAllocMoreBlockNodes(pwd);
    if (pwd->dWaveDataStartNode == -1)
        return FALSE;

    if (*pwd->aszFile) {
        MMIOINFO    mmioInfo;

        InitMMIOOpen(pwd, &mmioInfo);
        pwd->hmmio = mmioOpen(pwd->aszFile, &mmioInfo, MMIO_READ | MMIO_DENYWRITE);

        if (pwd->hmmio == NULL)
            SetMMIOError(pwd, mmioInfo.wErrorRet);
        else if (ReadWaveHeader(pwd)) {
            lpwdn = LPWDN(pwd, pwd->dWaveDataStartNode);
            lpwdn->dDataLength = pwd->dSize;
            lpwdn->dTotalLength = pwd->dSize;
            lpwdn->dNextWaveDataNode = (DWORD)ENDOFNODES;

            pwd->wTaskError = mwCheckDevice( pwd, pwd->Direction );
            if (pwd->wTaskError) {
                mwCloseFile(pwd);
                return FALSE;
            }
            else {
                return TRUE;
            }
        }
    } else {
        pwd->pwavefmt = (WAVEFORMAT NEAR *)LocalAlloc(LPTR, sizeof(PCMWAVEFORMAT));

        if (pwd->pwavefmt) {
            pwd->pwavefmt->wFormatTag = WAVE_FORMAT_PCM;
            pwd->pwavefmt->nChannels = DEF_CHANNELS;
            pwd->pwavefmt->nAvgBytesPerSec = DEF_AVGBYTESPERSEC;
            pwd->pwavefmt->nSamplesPerSec = DEF_AVGBYTESPERSEC / DEF_CHANNELS;
            pwd->pwavefmt->nBlockAlign = (WORD)(pwd->pwavefmt->nSamplesPerSec / pwd->pwavefmt->nAvgBytesPerSec);
            ((NPPCMWAVEFORMAT)(pwd->pwavefmt))->wBitsPerSample = (WORD)pwd->pwavefmt->nBlockAlign * (WORD)8;
            pwd->wFormatSize = sizeof(PCMWAVEFORMAT);
            pwd->dAudioBufferLen = BLOCKALIGN(pwd, DEF_AVGBYTESPERSEC);

            if ((pwd->dWaveDataStartNode = mwFindAnyFreeDataNode(pwd, pwd->dAudioBufferLen)) != -1) {
                pwd->dWaveDataCurrentNode = pwd->dWaveDataStartNode;
                lpwdn = LPWDN(pwd, pwd->dWaveDataStartNode);
                lpwdn->dNextWaveDataNode = (DWORD)ENDOFNODES;
                return TRUE;
            }
        } else
            pwd->wTaskError = MCIERR_OUT_OF_MEMORY;
    }

    mwCloseFile(pwd);
    return FALSE;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    VOID | mwFreeDevice |
    This function frees the current wave device, if any.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Nothing.
*/

PRIVATE VOID PASCAL NEAR mwFreeDevice(
    PWAVEDESC   pwd)
{
    if (pwd->hWaveOut || pwd->hWaveIn) {
        if (pwd->Direction == output) {
            waveOutClose(pwd->hWaveOut);
            pwd->hWaveOut = NULL;
        } else {
            waveInClose(pwd->hWaveIn);
            pwd->hWaveIn = NULL;
        }

        while (TaskBlock() != WM_USER);
    }
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | mwCheckDevice |
    This function checks whether given the specified parameters, a
    compatible wave device is available.  Depending upon the current
    settings in the wave descriptor block, a specific device, or all
    devices might be checked for the specified direction.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DIRECTION | Direction |
    Indicates whether the parameters are being checked for input or
    for output.

@rdesc  Returns zero on success, else an MCI error code.
*/

PRIVATE UINT PASCAL NEAR mwCheckDevice(
    PWAVEDESC   pwd,
    DIRECTION   Direction)
{
    UINT    wReturn;

    if (!pwd->pwavefmt->nBlockAlign)
        return MCIERR_OUTOFRANGE;
    wReturn = 0;

    if (Direction == output) {
        if (waveOutOpen(NULL, pwd->idOut, (NPWAVEFORMATEX)pwd->pwavefmt, 0L, 0L, (DWORD)WAVE_FORMAT_QUERY))
            wReturn = (pwd->idOut == WAVE_MAPPER) ? MCIERR_WAVE_OUTPUTSUNSUITABLE : MCIERR_WAVE_SETOUTPUTUNSUITABLE;

    } else if (waveInOpen(NULL, pwd->idOut, (NPWAVEFORMATEX)pwd->pwavefmt, 0L, 0L, (DWORD)WAVE_FORMAT_QUERY))
        wReturn = (pwd->idOut == WAVE_MAPPER) ? MCIERR_WAVE_INPUTSUNSUITABLE : MCIERR_WAVE_SETINPUTUNSUITABLE;

    return wReturn;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | mwGetDevice |
    This function opens the specified input or output wave device.
    If the device id is -1, then the first available device which supports
    the format will be opened.

    If the function fails to get a suitable device, it checks to see if
    there are any that would have worked if they were not in use.  This is
    in order to return a more clear error to the calling function.

    The function initially tries to open the device requested or the
    default device.  Failing this, if the wave information block
    specifies that any device can be used, it attempts to open an
    appropriate device.

    If all else fails, the current configuration is checked to determine
    if any device would have worked had it been available, and the
    appropriate error is returned.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Returns 0 if wave device is successfully opened, else an MCI error.
*/

PRIVATE UINT PASCAL NEAR mwGetDevice(
    PWAVEDESC   pwd)
{
    UINT    wReturn;

#if DBG
    if (GetCurrentThreadId() != dwCritSecOwner) {
        dprintf1(("mwGetDevice called while outside the critical section"));
    }

#endif

    wReturn = 0;
    if (pwd->Direction == output) {
        if (waveOutOpen(&(pwd->hWaveOut),
                        pwd->idOut,
                        (NPWAVEFORMATEX)pwd->pwavefmt,
                        (DWORD)pwd->hTask,
                        0L,
                        (DWORD)CALLBACK_TASK)) {
            pwd->hWaveOut = NULL;
            wReturn = mwCheckDevice(pwd, pwd->Direction);
            if (!wReturn) {
                if (pwd->idOut == WAVE_MAPPER)
                    wReturn = MCIERR_WAVE_OUTPUTSINUSE;
                else
                    wReturn = MCIERR_WAVE_SETOUTPUTINUSE;
            }
        }
    } else if (waveInOpen(&(pwd->hWaveIn),
                          pwd->idIn,
                          (NPWAVEFORMATEX)pwd->pwavefmt,
                          (DWORD)pwd->hTask,
                          0L,
                          (DWORD)CALLBACK_TASK)) {
        pwd->hWaveIn = NULL;
        wReturn = mwCheckDevice(pwd, pwd->Direction);
        if (!wReturn) {
            if (pwd->idIn == WAVE_MAPPER)
                wReturn = MCIERR_WAVE_INPUTSINUSE;
            else
                wReturn = MCIERR_WAVE_SETINPUTINUSE;
        }
    }
    return wReturn;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    DWORD | mwDelayedNotify |
    This is a utility function that sends a notification saved with
    <f>mwSaveCallback<d> to mmsystem which posts a message to the
    application.  If there is no current notification callback handle,
    no notification is attempted.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   UINT | wStatus |
    Speicifies the type of notification to use.

@flag   MCI_NOTIFY_SUCCESSFUL |
    Operation completed successfully.

@flag   MCI_NOTIFY_SUPERSEDED |
    A new command which specified notification, but did not interrupt
    the current operation was received.

@flag   MCI_NOTIFY_ABORTED |
    The current command was aborted due to receipt of a new command.

@flag   MCI_NOTIFY_FAILURE |
    The current operation failed.

@rdesc  Nothing.
*/

PUBLIC  VOID PASCAL FAR mwDelayedNotify(
    PWAVEDESC   pwd,
    UINT    wStatus)
{
    if (pwd->hwndCallback) {
        dprintf3(("Calling driver callback"));
        mciDriverNotify(pwd->hwndCallback, pwd->wDeviceID, wStatus);
        pwd->hwndCallback = NULL;
    }
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    VOID | mwImmediateNotify |
    This is a utility function that sends a successful notification
    message to mmsystem.

@parm   MCIDEVICEID | wDeviceID |
    Device ID.

@parm   <t>LPMCI_GENERIC_PARMS<d> | lpParms |
    Far pointer to an MCI parameter block. The first field of every MCI
    parameter block is the callback handle.

@rdesc  Nothing.
*/

PRIVATE VOID PASCAL NEAR mwImmediateNotify(
    MCIDEVICEID     wDeviceID,
    LPMCI_GENERIC_PARMS lpParms)
{
    mciDriverNotify((HWND)(lpParms->dwCallback), wDeviceID, MCI_NOTIFY_SUCCESSFUL);
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    VOID | mwSaveCallback |
    This is a utility function that saves a new callback in the instance
    data block.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   HHWND | hwndCallback |
    Callback handle to save.

@rdesc  Nothing.
*/

PRIVATE VOID PASCAL NEAR mwSaveCallback(
    PWAVEDESC   pwd,
    HWND    hwndCallback)
{
    pwd->hwndCallback = hwndCallback;
}

/************************************************************************/

/*
@doc    INTERNAL MCIWAVE

@api    <t>LPWAVEHDR<d> * | NextWaveHdr |
    This function returns the next wave buffer based on the buffer passed.
    It either returns the next buffer in the list, or the first buffer
    in the list of the last buffer is passed.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   <t>LPWAVEHDR<d> * | lplpWaveHdr |
    Points to the array of wave buffer pointers from which a buffer pointer
    is returned.

@rdesc  Returns the next wave buffer to use.
*/

PUBLIC  LPWAVEHDR * PASCAL FAR NextWaveHdr(
    PWAVEDESC   pwd,
    LPWAVEHDR   *lplpWaveHdr)
{
    if (lplpWaveHdr < (pwd->rglpWaveHdr + pwd->wAudioBuffers - 1))
        return lplpWaveHdr + 1;
    else
        return pwd->rglpWaveHdr;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | GetPlayRecPosition |
    Gets the current playback or recording position.  For output, this
    means also determining how much data has actually passed through the
    wave device if a device is currently open.  This must be added to the
    starting playback position.  For input however, only the amount that
    has actually be written to disk is returned.

    Note that the return value from the driver is verified against the
    actual length of the data.  This is to protect against problems
    encountered in drivers that return bytes when samples are requested.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   LPDWORD | lpdTime |
    Points to a buffer to play the current position.

@parm   DWORD | dFormatReq |
    Indicates whether time is in samples, bytes or milliseconds.

@rdesc  Returns zero on success, else the device error on error.  This can
    only fail if getting the current playback position.  The recording
    position will alway succeed.
*/

PRIVATE UINT PASCAL NEAR GetPlayRecPosition(
    PWAVEDESC   pwd,
    LPDWORD lpdTime,
    DWORD   dFormatReq)
{
    if (pwd->Direction == output) {
        MMTIME  mmtime;
        DWORD   dDelta;
        UINT    wErrorRet;

        mmtime.wType = TIME_BYTES;
        if (!pwd->hWaveOut)
            mmtime.u.cb = 0;
        else if (0 != (wErrorRet = waveOutGetPosition(pwd->hWaveOut, &mmtime, sizeof(MMTIME))))
            return wErrorRet;

        dDelta = mmtime.u.cb;

//#ifdef DEBUG
        if (pwd->dFrom + dDelta > pwd->dSize)
            dDelta = pwd->dSize - pwd->dFrom;
//#endif
        *lpdTime = bytes2time(pwd, pwd->dFrom + dDelta, dFormatReq);
    } else
        *lpdTime = bytes2time(pwd, pwd->dCur, dFormatReq);
    return 0;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    VOID | SetCurrentPosition |
    Sets the starting and current file position, that is, the the point
    at which playback or recording will start at.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dByteOffset |
    Indicates the position to set in bytes.

@rdesc  Nothing.
*/

PRIVATE VOID PASCAL NEAR SetCurrentPosition(
    PWAVEDESC   pwd,
    DWORD   dByteOffset)
{
    LPWAVEDATANODE  lpwdn;

    lpwdn = LPWDN(pwd, 0);
    if (lpwdn) {
        if (dByteOffset >= pwd->dVirtualWaveDataStart)
            lpwdn += pwd->dWaveDataCurrentNode;
        else {
            lpwdn += pwd->dWaveDataStartNode;
            pwd->dVirtualWaveDataStart = 0;
            pwd->dWaveDataCurrentNode = pwd->dWaveDataStartNode;
        }
        for (; dByteOffset > pwd->dVirtualWaveDataStart + lpwdn->dDataLength;) {
            pwd->dVirtualWaveDataStart += lpwdn->dDataLength;
            pwd->dWaveDataCurrentNode = lpwdn->dNextWaveDataNode;
            lpwdn = LPWDN(pwd, pwd->dWaveDataCurrentNode);
        }
        pwd->dFrom = dByteOffset;
        pwd->dCur = dByteOffset;
    }
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   DWORD | RoundedBytePosition |
    This function returns the rounded byte format time position from the
    specified position parameter in the specified time format.  It
    transforms the position to byte format and rounds against the current
    block alignment.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dTime |
    Specifies the time position to translate and round.

@parm   DWORD | dFormat |
    Indicates the time format of <p>dTime<d>.

@rdesc  Returns the rounded byte formate of the position passed.
*/

PRIVATE DWORD PASCAL NEAR RoundedBytePosition(
    PWAVEDESC   pwd,
    DWORD   dTime,
    DWORD   dFormat)
{
    DWORD   dBytes;

    dBytes = time2bytes(pwd, dTime, dFormat);

    /*
    **  Get the end position right.  Because lots of compressed files don't
    **  end with a complete sample we make sure that the end stays the
    **  end.
    */

    if (dBytes >= pwd->dSize && pwd->Direction == output)
        return pwd->dSize;

    return dBytes - (dBytes % pwd->pwavefmt->nBlockAlign);
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    VOID | mwStop |
    This function is called in response to an <m>MCI_STOP<d> message, and
    internally by several function, and is used to stop playback or
    recording if the task is currently not idle.  The function yields
    until the task has actually become idle.  This has the side affect of
    releasing any buffers currently added to the pwave input or output
    device, and thus signalling the task that the buffers are available.

    Note that if the task is in Cleanup mode, indicating that it is
    blocking to remove extra signals, and ignoring any commands, the
    function just waits for the task to enter Idle state without signalling
    the task.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Nothing.
*/

PRIVATE VOID PASCAL NEAR mwStop(
    PWAVEDESC   pwd)
{
    if (ISTASKSTATE(pwd, TASKBUSY)) {
        if (!ISMODE(pwd, MODE_CLEANUP)) {
            DWORD   dPosition;

            ADDMODE(pwd, COMMAND_NEW | COMMAND_STOP);

            if (!GetPlayRecPosition(pwd, &dPosition,  MCI_FORMAT_BYTES))
                SetCurrentPosition(pwd, RoundedBytePosition(pwd, dPosition, MCI_FORMAT_BYTES));

            ReleaseWaveBuffers(pwd);

//!!            if (ISMODE(pwd, MODE_PAUSED | MODE_HOLDING) || (ISMODE(pwd, MODE_PLAYING) && ISMODE(pwd, MODE_CUED)))
            if (ISMODE(pwd, MODE_PAUSED | MODE_HOLDING))
                TaskSignal(pwd->hTask, WTM_STATECHANGE);
        }

        while (!ISTASKSTATE(pwd, TASKIDLE))
            mmYield(pwd);
    }
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | AllocateBuffers |
    Allocates and prepares an array of wave buffers used for playback or
    recording, up to the maximum number of seconds specified.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Returns number of buffers successfully allocated.
*/

PRIVATE UINT PASCAL NEAR AllocateBuffers(
    PWAVEDESC   pwd)
{
    UINT    wAllocatedBuffers;

    for (wAllocatedBuffers = 0; wAllocatedBuffers < pwd->wSeconds; wAllocatedBuffers++) {
        if (!(pwd->rglpWaveHdr[wAllocatedBuffers] = (LPWAVEHDR)GlobalAllocPtr(GMEM_MOVEABLE, (DWORD)(sizeof(WAVEHDR) + pwd->dAudioBufferLen))))
            break;

        dprintf3(("Allocated %8X", pwd->rglpWaveHdr[wAllocatedBuffers]));
        pwd->rglpWaveHdr[wAllocatedBuffers]->dwFlags = WHDR_DONE;
        pwd->rglpWaveHdr[wAllocatedBuffers]->lpData = (LPSTR)(pwd->rglpWaveHdr[wAllocatedBuffers] + 1);
        pwd->rglpWaveHdr[wAllocatedBuffers]->dwBufferLength = pwd->dAudioBufferLen;
        if (pwd->Direction == output) {
            if (!waveOutPrepareHeader(pwd->hWaveOut, pwd->rglpWaveHdr[wAllocatedBuffers], sizeof(WAVEHDR)))
            {
                pwd->rglpWaveHdr[wAllocatedBuffers]->dwFlags |= WHDR_DONE;
                continue;
            }
        } else if (!waveInPrepareHeader(pwd->hWaveIn, pwd->rglpWaveHdr[wAllocatedBuffers], sizeof(WAVEHDR))) {

            /*
            **  Initialize the bytes recorded or mwGetLevel can fall over
            */
            pwd->rglpWaveHdr[wAllocatedBuffers]->dwBytesRecorded = 0;
            continue;
        }
        GlobalFreePtr(pwd->rglpWaveHdr[wAllocatedBuffers]);
        pwd->rglpWaveHdr[wAllocatedBuffers] = 0;
        break;
    }

    dprintf2(("Allocated %u Buffers", wAllocatedBuffers));
    return wAllocatedBuffers;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    VOID | FreeBuffers |
    Frees the array of wave buffers.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Nothing.
*/

PRIVATE VOID PASCAL NEAR FreeBuffers(
    PWAVEDESC   pwd)
{
    UINT    wAllocatedBuffers;

    for (wAllocatedBuffers = pwd->wAudioBuffers; wAllocatedBuffers--;) {
        if (!pwd->rglpWaveHdr[wAllocatedBuffers]) continue;

        if (pwd->Direction == output)
            waveOutUnprepareHeader(pwd->hWaveOut, pwd->rglpWaveHdr[wAllocatedBuffers], sizeof(WAVEHDR));
        else
            waveInUnprepareHeader(pwd->hWaveIn, pwd->rglpWaveHdr[wAllocatedBuffers], sizeof(WAVEHDR));
   GlobalFreePtr(pwd->rglpWaveHdr[wAllocatedBuffers]);
    }
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    VOID | mwTask |
    This function represents the background task which plays or records
    wave audio.  It is called as a result of the call to <f>mmTaskCreate<d>
    <f>mwOpenDevice<d>.  When this function returns, the task is destroyed.

    In short, the task opens the designated file, and blocks itself in a
    loop until it is told to do something (close, play, or record).
    Upon entering the function, the signal count is zero,
    <e>WAVEDESC.wTaskState<d> is TASKINIT.  Note that <e>WAVEDESC.wMode<d>
    is left as is.  This is because of the Wait mode feature, in which
    the Wait mode flag needs to be tested by the calling task to determine
    if this task has already performed successful notification.  This
    means that in checking the current task mode, the task state must
    also be verified (except in cases of Recording and Playing modes,
    which are reset after leaving their functions).

    If the requested file is opened, the function enters a loop to allow
    it to act on the current task state when the task is signalled.  It
    then waits in a blocked state with <e>WAVEDESC.wTaskState<d> set to
    TASKIDLE until the state is changed.  So unless the task is closing,
    playing, or recording, it is idle and blocked.

    If the requested file cannot be opened, the task state must be reset
    to TASKNONE so that the task create wait loop recognizes that the
    create has failed.

    When the task is signalled, it again checks the current state just
    as a precaution.  This should be removed eventually.

    A TASKCLOSE state simply breaks out of the outer infinite loop,
    allowing the wave file to be closed, and the task function exited.
    This in turn terminates the task.

    A TASKBUSY state indicates that a wave device has been opened for
    either playback or recording, which is where the signal originated
    from.  The task must first then calculate and allocate the wave
    buffers.  The allocation function will provide up to the number of
    buffers requested, but may be constrained by current memory use.  The
    number of buffers allocated must meet a minimum requirement though to
    allow smooth playback and recording.

    If not enough buffers can be allocated, the current task error is
    set to an out of memory condition, and the function returns to an
    idle state.  Note that the current command mode is reset before
    entering the idle loop.  This ensures that all previous commands are
    removed before allowing the next set of commands to be set.

    If enough buffers are allocated the current task error is reset, and
    the playback or recording function is called to act on the previously
    set parameters.  When the recording or playback function returns, it
    may or may not have successfully finished.  The current position is
    set as based on where the recording or playback actually got to.
    For playback, this is how much data was processed by the wave device.
    For recording, this is how much data was written to disk.  To ensure
    that all buffers have been released by the wave device, the
    <f>ReleaseWaveBuffers<d> function is called in all cases after
    determining the current position.

    In determining the optional notification, the
    <e>WAVEDESC.wTaskError<d> will contain any failure error which
    occurred during the playback or recording.  If no error is set, then
    the only other error could be whether or not playback or recording was
    interrupted by another command.

    After freeing the buffers, the Cleanup mode is set.  This indicates
    that the task is not able to accept new commands until it reaches an
    idle state.  The reason for this flag is that the task must retrieve
    any left over signals from the message queue generated by releasing
    the wave buffers, and by freeing the wave device.  While getting the
    signals, it is possible for the task that opened the MCI wave device
    instance to try and send new commands.  These commands would be
    ignored, so the task must wait until cleanup is done.

    After entering Cleanup mode, the wave device is freed here, even though
    the calling task opened it.  This is bad, in that it assumes that wave
    drivers allocate either local memory, or global memory using
    GMEM_DDESHARE.  This of course generates another task signal from the
    wave device, which is ignored by the Free Device function.  The task
    can now remove any left over signals from the queue, if any, from the
    releasing of the wave buffers.

    Note that notification is only performed if the calling task is no
    longer waiting for this task, and no task error occurred (If the
    calling task is waiting, then notification must be either Failure or
    Successful, since nothing could abort this task).  If notification
    needs to take place, the Wait mode flag is cleared, else the callback
    is cleared.  The calling task will now know that either the background
    task failed, or succeeded and performed notification.

    Note that when terminating the task, the <e>WAVEDESC.hTask<d> must be
    set to NULL to indicate to the <f>mwCloseDevice<d> function that the
    task has indeed terminated itself.

@parm   DWORD | dInstanceData |
    This contains the instance data passed to the <f>mmTaskCreate<d>
    function.  It contains a pointer to the wave audio data in the
    high-order word.  The low-order word is not used.

@rdesc  Nothing.

@xref   mwOpenDevice.
*/

PUBLIC  VOID PASCAL EXPORT mwTask(
    DWORD_PTR dInstanceData)
{
    register PWAVEDESC  pwd;

    EnterCrit();

    /*
    ** Make a safe "user" call so that user knows about our thread.
    ** This is to allow WOW setup/initialisation on this thread
    */
    GetDesktopWindow();

    pwd = (PWAVEDESC)dInstanceData;

    pwd->hTask = mmGetCurrentTask();
    pwd->wTaskError = 0;

    dprintf2(("Bkgd Task %X", pwd->hTask));

    if (mwOpenFile(pwd)) {
        for (; !ISTASKSTATE(pwd, TASKCLOSE);) {
            UINT    wNotification;
            UINT    wBuffersOutstanding;

            SETTASKSTATE(pwd, TASKIDLE);
            while (ISTASKSTATE(pwd, TASKIDLE)) {

                dprintf2(("Task is IDLE"));
                while (TaskBlock() != WTM_STATECHANGE) {
                }
            }
            pwd->wTaskError = 0;

            switch (TASKSTATE(pwd)) {
            case TASKBUSY:
#if DBG
                dprintf2(("Task is BUSY"));
#endif

//!!            if (pwd->wTaskError = mwGetDevice(pwd)) {
//!!                mwDelayedNotify(pwd, MCI_NOTIFY_FAILURE);
//!!                break;
//!!            }
//!!            Leave(pwd);
//!!            mmTaskBlock(NULL);
//!!            Enter(pwd);

                pwd->wAudioBuffers = AllocateBuffers(pwd);
                if (pwd->wAudioBuffers >= MinAudioSeconds) {
                    DWORD   dPosition;

                    if (pwd->Direction == output)
                        wBuffersOutstanding = PlayFile(pwd);
                    else
                        wBuffersOutstanding = RecordFile(pwd);

                    /*
                    **  If we've played everything don't rely on the wave
                    **  device because for compressed files it only gives
                    **  and approximate answer based on the uncompressed
                    **  format
                    */

                    if (pwd->Direction == output && wBuffersOutstanding == 0) {
                        dPosition = pwd->dTo;
                        SetCurrentPosition(pwd, RoundedBytePosition(pwd, dPosition, MCI_FORMAT_BYTES));
                    } else {
                        if (!GetPlayRecPosition(pwd, &dPosition,  MCI_FORMAT_BYTES))
                            SetCurrentPosition(pwd, RoundedBytePosition(pwd, dPosition, MCI_FORMAT_BYTES));
                    }

                    ReleaseWaveBuffers(pwd);

                    if (pwd->wTaskError)
                        wNotification = MCI_NOTIFY_FAILURE;
                    else if (pwd->dCur >= pwd->dTo)
                        wNotification = MCI_NOTIFY_SUCCESSFUL;
                    else
                        wNotification = MCI_NOTIFY_ABORTED;

                } else {
                    dprintf1(("MinAudioSeconds <= wAudioBuffers  MCI_NOTIFY_FAILURE"));
                    pwd->wTaskError = MCIERR_OUT_OF_MEMORY;
                    wNotification = MCI_NOTIFY_FAILURE;
                    wBuffersOutstanding = 0;
                }

                FreeBuffers(pwd);
                ADDMODE(pwd, MODE_CLEANUP);

                if (!ISMODE(pwd, MODE_WAIT) || !pwd->wTaskError) {
                    REMOVEMODE(pwd, MODE_WAIT);
                    mwDelayedNotify(pwd, wNotification);
                } else
                    mwSaveCallback(pwd, NULL);

                mwFreeDevice(pwd);

                for (; wBuffersOutstanding; wBuffersOutstanding--) {
                    while (TaskBlock() != WM_USER) {
                    }
                }
                break;

            case TASKCLOSE:
#if DBG
                dprintf2(("Task is CLOSING"));
#endif
                break;

            case TASKSAVE:
                dprintf2(("mwTask: saving data"));
                mwSaveData(pwd);
                break;

            case TASKDELETE:
                dprintf2(("mwTask: deleting data"));
                mwDeleteData(pwd);
                break;

            case TASKCUT:
                dprintf2(("mwTask: Task CUT"));
                break;
            }
        }
        dprintf2(("Closing file %ls", pwd->aszFile));
        mwCloseFile(pwd);

    } else {
        dprintf1(("Cannot open file %ls", pwd->aszFile));
        SETTASKSTATE(pwd, TASKNONE);
    }

#if DBG
    dprintf2(("Background thread %x is terminating\r\n", pwd->hTask));
#endif
    pwd->hTask = 0; //NULL;

    LeaveCrit();
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | mwCloseDevice |
    This function is called in response to an <m>MCI_CLOSE_DRIVER<d>
    message, and is used to close the MCI device.  Note that since the
    message can be sent to an MCI device that just represents the wave
    device itself, and has no file or <t>WAVEDESC<d>, it must check and
    return success in that instance.

    If there is actually data attached to this MCI device, the function
    checks to determine if a task was successfully created for the device.
    This might not have happened if the <m>MCI_OPEN_DRIVER<d> message
    failed to create a task, or the wave device itself was being opened,
    and no task was created.

    If there is a task, it must first stop any playback or recording that
    is in progress, then inform the task that it must cease and desist by
    setting the task state to TASKCLOSE and signalling the task.  The
    function must then wait for the task to respond by terminating itself.
    Note that the last thing the task does is set <t>WAVEDESC.hTask<d> to
    NULL, thus allowing the wait loop to exit.

    After optionally terminating the task, the wave description data is
    freed, and the function returns success.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Returns zero on success, else an MCI error code.  The function cannot
    at this time fail.

@xref   mwOpenDevice.
*/

PRIVATE UINT PASCAL NEAR mwCloseDevice(
    PWAVEDESC   pwd)
{
    if (pwd) {
        if (pwd->hTask) {
            mwStop(pwd);
            SETTASKSTATE(pwd, TASKCLOSE);
            TaskSignal(pwd->hTask, WTM_STATECHANGE);
            TaskWaitComplete(pwd->hTaskHandle);
            //while (pwd->hTask)
            //    mmYield(pwd);
            dprintf3(("Waiting for task thread to complete"));
        } else {
        }
        LocalFree(pwd);

    }
    return 0;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | mwOpenDevice |
    This function is called in response to an <m>MCI_OPEN_DRIVER<d>
    message, and is used to open the MCI device, optionally allocating
    a wave description block and create a background playback and
    recording task.

    It is possible that the MCI device is being opened for information
    only.  In this case there is no element name or ID and no wave
    description block need be allocated.

    If an element or element ID is present, the wave descriptor block is
    allocated and initialized with the current device, default time
    formate, etc.  After storing either the element, or element ID, the
    secondary task is created, and the task state is set to TASKINIT.

    The first thing that the task must do is try and open the file
    specified in the descriptor block passed to the task function.  The
    calling task must yield upon successfully creating the task until
    the task has opened the wave file and entered its idle loop, or has
    failed the open and returned and error.  An error state indicates
    that the wave descriptor block is to be freed.

    Note that driver data, which is where the pointer to the wave
    descriptor data is stored, is not guarenteed to be initialized to any
    specific value, and must be initialized even if no descriptor block is
    being allocated.  To be to be on the safe side, the driver data is set
    to NULL on an error.  This data parameter can then be accessed by the
    MCI driver through the <p>wDeviceID<d> when processing driver messages.

@parm   DWORD | dFlags |
    Contains the open flags passed with the message (see mmsystem.h).
    The following flags are responded to specifically.  All others are
    ignored.

@flag   MCI_OPEN_ELEMENT |
    Specifies that a file name is present in the open message.  This is
    mutually incompatible with the MCI_OPEN_ELEMENT_ID flag.  If neither
    of these flags exist, no wave descriptor data or secondary task will
    be created.

@flag   MCI_OPEN_ELEMENT_ID |
    Specifies that an alternate IO function is present in the open
    message.  This is mutually incompatible with the MCI_OPEN_ELEMENT
    flag.  If neither of these flags exist, no wave descriptor data or
    secondary task will be created.

@flag   MCI_OPEN_SHAREABLE |
    Specifies that the more than one task can communicate with this
    MCI device.  The wave driver does not support this.

@flag   MCI_WAVE_OPEN_BUFFER |
    Indicates that the <e>MCI_OPEN_PARMS.dwBufferSeconds<d> parameter
    contains the number of seconds of audio to allow to be buffered.
    This number is constrained by the minimum and maximum numbers
    contained in mciwave.h.  If this flag is not present, the default
    value is used, which may have been set during driver open time.

@parm   <t>LPMCI_OPEN_PARMS<d> | lpOpen |
    Open parameters (see mmsystem.h)

@parm   MCIDEVICEID | wDeviceID |
    The MCI Driver ID for the new device.

@rdesc  Returns zero on success, else an MCI error code.

@xref   mwCloseDevice.
*/

PRIVATE UINT PASCAL NEAR mwOpenDevice(
    DWORD   dFlags,
    LPMCI_WAVE_OPEN_PARMS   lpOpen,
    MCIDEVICEID wDeviceID)
{
    UINT    wReturn;
    UINT    wSeconds;

    wReturn = 0;

    if (!(dFlags & MCI_WAVE_OPEN_BUFFER))
        wSeconds = wAudioSeconds;
    else {
        wSeconds = lpOpen->dwBufferSeconds;
        if ((wSeconds > MaxAudioSeconds) || (wSeconds < MinAudioSeconds))
            wReturn = MCIERR_OUTOFRANGE;
    }

    if (!wReturn && (dFlags & (MCI_OPEN_ELEMENT | MCI_OPEN_ELEMENT_ID))) {
        PWAVEDESC   pwd;

        if (dFlags & MCI_OPEN_SHAREABLE)
            wReturn = MCIERR_UNSUPPORTED_FUNCTION;

        else if ((dFlags & (MCI_OPEN_ELEMENT | MCI_OPEN_ELEMENT_ID)) == (MCI_OPEN_ELEMENT | MCI_OPEN_ELEMENT_ID))
            return MCIERR_FLAGS_NOT_COMPATIBLE;

//@@@
//@@@   else if ((dFlags & MCI_OPEN_ELEMENT_ID) && !ValidateIOCallback(lpOpen))
//@@@       return MCIERR_MISSING_PARAMETER;
//@@@ See notes re. ValidateIOCallback at the top of this file
//@@@

        else if (!(pwd = (PWAVEDESC)LocalAlloc(LPTR, sizeof(WAVEDESC))))
            wReturn = MCIERR_OUT_OF_MEMORY;

        else {
            pwd->wDeviceID = wDeviceID;
            pwd->dTimeFormat = MCI_FORMAT_MILLISECONDS;
            pwd->Direction = output;
            pwd->idOut = (DWORD)WAVE_MAPPER;
            pwd->idIn = (DWORD)WAVE_MAPPER;
            pwd->wSeconds = wSeconds;
            pwd->hTempBuffers = INVALID_HANDLE_VALUE;

            if (dFlags & MCI_OPEN_ELEMENT_ID)
                pwd->pIOProc = (LPMMIOPROC)(lpOpen + 1);

            if (*lpOpen->lpstrElementName) {
                MMIOINFO    mmioInfo;

                pwd->aszFile[ (sizeof(pwd->aszFile) / sizeof(WCHAR)) - 1] = '\0';
                wcsncpy( pwd->aszFile,
                         lpOpen->lpstrElementName,
                         ( sizeof(pwd->aszFile) / sizeof(WCHAR) ) - 1
                       );
                InitMMIOOpen(pwd, &mmioInfo);
                if (!mmioOpen(pwd->aszFile, &mmioInfo, MMIO_PARSE))
                    wReturn = MCIERR_FILENAME_REQUIRED;
            }

            if (!wReturn) {
                SETTASKSTATE(pwd, TASKINIT);

                switch (mmTaskCreate(mwTask, &pwd->hTaskHandle, (DWORD_PTR)pwd)) {
                case 0:
                    while (ISTASKSTATE(pwd, TASKINIT)) {
                        mmYield(pwd);
                    }

                    if (ISTASKSTATE(pwd,TASKNONE)) {
                        // Task detected an error and stopped itself
                        wReturn = pwd->wTaskError;
                        TaskWaitComplete(pwd->hTaskHandle);  // Wait for thread to completely terminate
                    }
                    else {
                        mciSetDriverData(wDeviceID, (DWORD_PTR)pwd);
                    }
                    break;

                case TASKERR_OUTOFMEMORY:
                case TASKERR_NOTASKSUPPORT:
                default:
                    wReturn = MCIERR_OUT_OF_MEMORY;
                    break;
                }
            }

            if (wReturn) {
                LocalFree(pwd);
            } else {
            }
        }
    }
    return wReturn;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   DWORD | VerifyRangeStart |
    Verifies and rounds range start value.  Note that the internal byte
    format time is converted to the current external time format in order
    to compensate for rounding errors.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dStart |
    Value to verify.

@rdesc  Returns the verified value, else -1 on range error.
*/

PRIVATE DWORD PASCAL NEAR VerifyRangeStart(
    PWAVEDESC   pwd,
    DWORD   dStart)
{
    if (dStart <= bytes2time(pwd, pwd->dSize, pwd->dTimeFormat)) {
        dStart = RoundedBytePosition(pwd, dStart, pwd->dTimeFormat);
        if (dStart > pwd->dSize)
            dStart = pwd->dSize;
    } else
        dStart = (DWORD)(-1);

    return dStart;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   DWORD | VerifyRangeEnd |
    Verifies and rounds range end value.  Note that the internal byte
    format time is converted to the current external time format in order
    to compensate for rounding errors.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dEnd |
    Value to verify.

@parm   BOOL | fVerifyLength |
    Indicates that the value specified should be verified against the
    current file length.  This is not done in circumstances such as
    recording, where the length might need to be expanded beyond the
    current value.

@rdesc  Returns the verified value, else -1 on range error.
*/

PRIVATE DWORD PASCAL NEAR VerifyRangeEnd(
    PWAVEDESC   pwd,
    DWORD   dEnd,
    BOOL    fVerifyLength)
{
    DWORD   dTimeSize;

    dTimeSize = bytes2time(pwd, pwd->dSize, pwd->dTimeFormat);

    if (!fVerifyLength || (dEnd <= dTimeSize)) {
        if (dEnd == dTimeSize)
            dEnd = pwd->dSize;
        else {
            dEnd = RoundedBytePosition(pwd, dEnd, pwd->dTimeFormat);
            if (fVerifyLength && (dEnd > pwd->dSize))
                dEnd = pwd->dSize;
        }
    } else
        dEnd = (DWORD)(-1);

    return dEnd;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   UINT | SetRange |
    This function sets the "to" and "from" range for recording or playback
    after validating them.  Note that the "from" parameter defaults to the
    current position, but the "to" parameter defaults to either the end of
    the file for playback, or infinity for recording.

    If either the "from" parameter is specified, or the "to" position is
    different than the current parameter, abort notification is attempted,
    else supersede notification is attempted later.  The "to" position
    could be changed by merely not specifying the MCI_TO flag if a current
    "to" position is in effect that does not specify the end of the data.

@parm   <t>PWAVEDESC<d> | pwd |
    Points to the data block for this device.

@parm   DWORD | dFlags |
    Contains the flags used to determine the parameters set in the
    <p>lpplay<d> structure.

@flag   MCI_FROM |
    Indicates the <e>MCI_PLAY_PARMS.dwFrom<d> contains a starting point.
    If this flag is not specified, the parameter defaults to the current
    position.  Setting this flag has the effect of resetting the wave
    output device so that any hold condition is signalled to continue.

    This is also important in that for output, it resets the wave device's
    byte counter of how much data has actually been processed.  This
    enables an accurate count to be retrieved when playback is either
    stopped, or finishes normally.

@flag   MCI_TO |
    Indicates the <e>MCI_PLAY_PARMS.dwTo<d> contains an ending point.
    If this flag is not specified, the parameter defaults to either the
    end of the file for playback, or infinity for recording.

@parm   <t>LPMCI_PLAY_PARMS<d> | lpplay |
    Optionally points to a structure containing "to" and "from" parameters.

@rdesc  Returns 0 on success, or MCIERR_OUTOFRANGE if a "to" or "from"
    parameter is not within the current file length, or "to" is less than
    "from".

@xref   mwSetup.
*/

PRIVATE UINT PASCAL NEAR SetRange(
    PWAVEDESC   pwd,
    DWORD   dFlags,
    LPMCI_PLAY_PARMS    lpPlay)
{
    DWORD   dFromBytePosition;
    DWORD   dToBytePosition;

    if (dFlags & MCI_FROM) {
        dFromBytePosition = VerifyRangeStart(pwd, lpPlay->dwFrom);
        if (dFromBytePosition == -1)
            return MCIERR_OUTOFRANGE;
    } else
        dFromBytePosition = pwd->dFrom;

    if (dFlags & MCI_TO) {
        dToBytePosition = VerifyRangeEnd(pwd, lpPlay->dwTo, pwd->Direction == output);
        if (dToBytePosition == -1)
            return MCIERR_OUTOFRANGE;
    } else if (pwd->Direction == output)
        dToBytePosition = pwd->dSize;
    else
        dToBytePosition = RoundedBytePosition(pwd, INFINITEFILESIZE, MCI_FORMAT_BYTES);

    if ((dFlags & MCI_TO) && !(dFlags & MCI_FROM) && (pwd->dCur > dToBytePosition)) {
        UINT    wErrorRet;

        if (0 != (wErrorRet = GetPlayRecPosition(pwd, &dFromBytePosition, MCI_FORMAT_BYTES)))
            return wErrorRet;
        if (dToBytePosition < dFromBytePosition)
            return MCIERR_OUTOFRANGE;
        SetCurrentPosition(pwd, RoundedBytePosition(pwd, dFromBytePosition, MCI_FORMAT_BYTES));
        ReleaseWaveBuffers(pwd);
    } else {
        if (dToBytePosition < dFromBytePosition)
            return MCIERR_OUTOFRANGE;
        if (dFlags & MCI_FROM) {
            SetCurrentPosition(pwd, dFromBytePosition);
            ReleaseWaveBuffers(pwd);
        }
    }

    if ((dFlags & MCI_FROM) || (dToBytePosition != pwd->dTo))
        mwDelayedNotify(pwd, MCI_NOTIFY_ABORTED);
    pwd->dTo = dToBytePosition;

    return 0;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | mwSetup |
    This function is called in response to an <m>MCI_PLAY<d>,
    <m>MCI_RECORD<d>, and indirectly through <m>MCI_CUE<d> and
    <m>MCI_STATUS<d> messages, and is used to set up for playing or
    recording a wave file and then signals the background task to begin.

    Before trying to set up for recording or playback, the input or output
    direction must match the request that is being made.  If it does not
    currently match, the current command, if any, is stopped, and the
    direction indicator is reset.  This action might cause an abort
    notification to occur.

    If however, the current direction matches the requested direction,
    the function must still wait if the task is currently in Cleanup mode
    and ignoring new commands.  This check does not need to be performed
    if the stop command is sent, as <f>mwStop<d> performs the same logic.
    If the task is currently in Idle state, the Cleanup mode is probably
    set, but the loop will immediately drop out anyway.

    If the start and end points are successfully parsed, the function
    begins either playback or recording.  If the task is idle, it must
    set the TASKBUSY state, else it must check to see if the task needs to
    be possibly un-paused by starting the wave device.  It does not check
    for a MODE_PAUSED or MODE_CUED state, as any <f>WaveOutReset<d> or
    <f>WaveInReset<d> will stop output or input.

    If the task was idle, the act of opening a wave device sends a signal
    to the task, and it is ready to go as soon as this task yields.  Else
    the task was already running, and this task just needs to yield.

    In the case of playback, the task may be additionally blocked by a
    previous Hold command, for which the function must send an extra
    signal to the task.

    For recording, there are two modes, Insert and Overwrite.  One can
    change between the two modes of recording with what normally is only
    a very slight delay between switching.  A check must be made to see if
    the task is currently recording, and if that method of recording is
    being changed (from Insert to Overwrite, or visa versa).  If so, then
    the current position must be logged, and the wave buffers released.
    This is so that only data up to this point is recorded in the previous
    method, and all new data is recorded in the new method.  Notice that
    in the recording function, if a new command is received, no new buffers
    are handed to the wave device until all the old buffers are dealt with
    and the new command is enacted.

    If the command flags where successfully set, and all needed signalling
    and un-pausing was performed, then before the task can be allowed to
    run, the notification parameter must be set.  If the previous command
    was not cancelled by a Stop, then a superseded notification is sent,
    and the current notification status is saved.

    At this point, the background task is ready to be begun.  If the
    Wait flag has been set, the calling task must now yield until the
    background task is finished the command (which means different
    things for different commands), else it can just return to the caller
    without waiting.  As this is the driver wait loop, it must use the
    <f>mciDriverYield<d> function in order to execute the driver callback
    function (and thus process the Break key, or whatever the callback
    performs).

    In order to make return values from a Record or Play command with the
    wait flag act as other commands, there is a special Wait mode flag.
    This tells the background task that the calling task is waiting for it
    to complete.  If the background task encounters an error, it does not
    perform notification, but just returns to Idle state and allows the
    calling task to return the error that was encountered.

    If the wait loop is broken out of, then it can check the Wait mode
    flag to determine if it should return the background task error.  In
    the case of Cue and Hold, the Wait mode can be removed, and the task
    error would presumably be zero.

    Note that the task error is set to zero before doing the first call
    to <f>mciDriverYield<d>, just in case an interrupt is received before
    the background task has a chance to run at all.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dFlags |
    Play flags.

@flag   MCI_TO |
    This flag indicates that a TO parameter is present in the <p>lpPlay<d>
    parameter block.

@flag   MCI_FROM |
    This flag indicates that a FROM parameter is present in the
    <p>lpPlay<d> parameter block.

@flag   MCI_WAIT |
    Wait for command to complete.

@flag   MCI_NOTIFY |
    Notify upon command completion.

@flag   MCI_RECORD_OVERWRITE |
    This flag indicates the recording should overwrite existing data.

@flag   MCI_RECORD_INSERT |
    This flag indicates the recording should insert in existing data.  This
    is the default recording method.

@flag   MCI_MCIWAVE_PLAY_HOLD |
    This flag indicates that playback should not release buffers after
    the TO position has been release, but instead go into a Paused state.

@flag   MCI_MCIWAVE_CUE |
    This internal flag indicates that Recording or Playback is being cued.

@parm   <t>LPMCI_PLAY_PARMS<d> | lpPlay |
    Play parameters.

@parm   DIRECTION | Direction |
    Indicates the direction being set up for.

@flag   output |
    Playback.

@flag   input |
    Recording.

@rdesc  Returns 0 if playback or recording was started, else an MCI error.
*/

PRIVATE UINT PASCAL NEAR mwSetup(
    PWAVEDESC   pwd,
    DWORD   dFlags,
    LPMCI_PLAY_PARMS    lpPlay,
    DIRECTION   Direction)
{
    UINT    wReturn;
    register UINT   wMode;

    wReturn = 0;

    if (Direction != pwd->Direction) {
        mwStop(pwd);
        pwd->Direction = Direction;
    } else if (ISMODE(pwd, MODE_CLEANUP)) {
        while (!ISTASKSTATE(pwd, TASKIDLE))
            mmYield(pwd);
    }

    if (0 != (wReturn = SetRange(pwd, dFlags, lpPlay)))
        return wReturn;

    wMode = COMMAND_NEW;

    if (dFlags & MCI_MCIWAVE_PLAY_HOLD)
        wMode |= COMMAND_HOLD;

    if (dFlags & MCI_MCIWAVE_CUE)
        wMode |= COMMAND_CUE;

    if (dFlags & MCI_WAIT)
        wMode |= MODE_WAIT;

    if (pwd->Direction == output) {
        wMode |= COMMAND_PLAY;

        if (ISTASKSTATE(pwd, TASKIDLE)) {
            if (!(wReturn = mwGetDevice(pwd)))
                SETTASKSTATE(pwd, TASKBUSY);
                TaskSignal(pwd->hTask, WTM_STATECHANGE);
        } else {
            if (ISMODE(pwd, COMMAND_PLAY)) {
                if (0 != (wReturn = waveOutRestart(pwd->hWaveOut)))
                    return wReturn;
                else
                    wMode |= MODE_PLAYING;
            }
            if (ISMODE(pwd, MODE_HOLDING))
                TaskSignal(pwd->hTask, WTM_STATECHANGE);
        }

    } else if ((dFlags & (MCI_RECORD_OVERWRITE | MCI_RECORD_INSERT)) == (MCI_RECORD_OVERWRITE | MCI_RECORD_INSERT))
        wReturn = MCIERR_FLAGS_NOT_COMPATIBLE;
    else {
        if (dFlags & MCI_RECORD_OVERWRITE)
            wMode |= COMMAND_OVERWRITE;
        else
            wMode |= COMMAND_INSERT;

        if (ISTASKSTATE(pwd, TASKIDLE)) {
            if (!(wReturn = mwGetDevice(pwd)))
                SETTASKSTATE(pwd, TASKBUSY);
                TaskSignal(pwd->hTask, WTM_STATECHANGE);

        } else if (ISMODE(pwd, COMMAND_INSERT | COMMAND_OVERWRITE)) {

            if ((ISMODE(pwd, COMMAND_OVERWRITE)
             && !(dFlags & MCI_RECORD_OVERWRITE))
             || (ISMODE(pwd, COMMAND_INSERT)
             && (dFlags & MCI_RECORD_OVERWRITE))) {
                DWORD   dPosition;

                GetPlayRecPosition(pwd, &dPosition,  MCI_FORMAT_BYTES);
                SetCurrentPosition(pwd, RoundedBytePosition(pwd, dPosition, MCI_FORMAT_BYTES));
                ReleaseWaveBuffers(pwd);
            }

            if (!(wReturn = waveInStart(pwd->hWaveIn)))
                if (ISMODE(pwd, COMMAND_INSERT))
                    wMode |= MODE_INSERT;
                else
                    wMode |= MODE_OVERWRITE;
        }
    }

    if (!wReturn) {
        if (dFlags & MCI_NOTIFY) {
            mwDelayedNotify(pwd, MCI_NOTIFY_SUPERSEDED);
            mwSaveCallback(pwd, (HWND)(lpPlay->dwCallback));
        }
        SETMODE(pwd, wMode);
        if (dFlags & MCI_WAIT) {
            pwd->wTaskError = 0;

            //
            // Wait for the device task to complete the function
            //
            for (;;) {
               LeaveCrit();
               if (mciDriverYield(pwd->wDeviceID)) {
                   EnterCrit();
                   break;
               }
               Sleep(10);
               EnterCrit();

               if (ISTASKSTATE(pwd, TASKIDLE) ||
                   ISMODE(pwd, MODE_HOLDING | MODE_CUED)) {
                   break;
               }
            }

            if (ISMODE(pwd, MODE_WAIT)) {
                REMOVEMODE(pwd, MODE_WAIT);
                wReturn = pwd->wTaskError;
            }
        }
    } else
        mwStop(pwd);

    return wReturn;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | mwPause |
    This function is called in response to an <m>MCI_PAUSE<d> message, and
    is used to pause wave file output or input.  By calling the
    <f>waveOutPause<d> or <f>waveInStop<d> function, all buffers added to
    the driver's queue will not be used, and thus eventually cause the
    background task to block itself waiting for buffers to be released.

    Note that this is only done if playback or recording is currently
    in progress, and cueing is not also being performed.  If the Cue
    command has been used, then the wave device is already in a paused
    state.  Also note that pausing can only be successfully performed
    if playback or recording is currently being performed, and the cleanup
    state has not been entered.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dFlags |
    Contains the pause flags passed with the message

@flag   MCI_WAIT |
    Wait for command to complete.

@flag   MCI_NOTIFY |
    Notify upon command completion.

@rdesc  Returns 0 if playback or recording was paused, else an MCI error.
*/

PRIVATE UINT PASCAL NEAR mwPause(
    PWAVEDESC   pwd,
    DWORD   dFlags)
{
    UINT    wReturn;

    if (dFlags & ~(MCI_NOTIFY | MCI_WAIT))
        return MCIERR_UNRECOGNIZED_KEYWORD;

    if (ISTASKSTATE(pwd, TASKBUSY) && !ISMODE(pwd, COMMAND_CUE | MODE_HOLDING)) {
        wReturn = 0;
        if (!ISMODE(pwd, MODE_PAUSED)) {
            if (ISMODE(pwd, COMMAND_PLAY)) {
                if (ISMODE(pwd, MODE_CLEANUP))
                    wReturn = MCIERR_NONAPPLICABLE_FUNCTION;
                else
                    wReturn = waveOutPause(pwd->hWaveOut);
            } else if (ISMODE(pwd, MODE_CLEANUP))
                wReturn = MCIERR_NONAPPLICABLE_FUNCTION;
            else
                wReturn = waveInStop(pwd->hWaveIn);
            if (!wReturn)
                ADDMODE(pwd, MODE_PAUSED);
        }
    } else
        wReturn = MCIERR_NONAPPLICABLE_FUNCTION;

    return wReturn;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | mwResume |
    This function is called in response to an <m>MCI_RESUME<d> message, and
    is used to resume wave file output or input if it was previously
    paused from output or input using MCI_PAUSE.

    Note that this is only done if playback or recording is currently
    paused, and cueing is not also being performed.  If the Cue command
    or Play Hold command is currently in effect, then there is no Play or
    Record command to resume, and the command is ignored.  If playback
    or recording is currently in effect, the command is ignored.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dFlags |
    Contains the resume flags passed with the message

@flag   MCI_WAIT |
    Wait for command to complete.

@flag   MCI_NOTIFY |
    Notify upon command completion.

@rdesc  Returns 0 if playback or recording was resumed, else an MCI error.
*/

PRIVATE UINT PASCAL NEAR mwResume(
    PWAVEDESC   pwd,
    DWORD   dFlags)
{
    UINT    wReturn;

    if (dFlags & ~(MCI_NOTIFY | MCI_WAIT))
        return MCIERR_UNRECOGNIZED_KEYWORD;

    if (ISTASKSTATE(pwd, TASKBUSY)) {
        wReturn = 0;
        if (!ISMODE(pwd, COMMAND_CUE) && ISMODE(pwd, MODE_PAUSED)) {
            if (ISMODE(pwd, COMMAND_PLAY))
                wReturn = waveOutRestart(pwd->hWaveOut);
            else
                wReturn = waveInStart(pwd->hWaveIn);
            if (!wReturn)
                REMOVEMODE(pwd, MODE_PAUSED);
        }
    } else
        wReturn = MCIERR_NONAPPLICABLE_FUNCTION;

    return wReturn;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | mwCue |
    This function is called in response to an <m>MCI_CUE<d> message, and
    is used to cue wave file input or output.  Cueing for playback simply
    causes the output device to be opened but paused, and all the buffers
    to fill.  Cueing for record puts the device into a level checking loop,
    using one buffer at a time.

    Note that the internal flag MCI_MCIWAVE_CUE is passed to the
    <f>mwSetup<d> function in order to indicate that it should use the Cue
    command when starting playback or recording.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dFlags |
    Contains the flags used to cue the MCI device.

@flag   MCI_WAVE_INPUT |
    Indicates that the MCI device should be cued for input.

@flag   MCI_WAVE_OUTPUT |
    Indicates that the MCI device should be cued for output.  This is the
    default case.

@flag   MCI_WAIT |
    Wait for command to complete.

@flag   MCI_NOTIFY |
    Notify upon command completion.

@parm   <t>LPMCI_GENERIC_PARMS<d> | lpGeneric |
    Far pointer to parameter block for cue.

@rdesc  Returns 0 if playback or recording was cued, else an MCI error.
*/

PRIVATE UINT PASCAL NEAR mwCue(
    PWAVEDESC   pwd,
    DWORD   dFlags,
    LPMCI_GENERIC_PARMS lpGeneric)
{
    MCI_PLAY_PARMS  mciPlay;
    DWORD   dWaveFlags;
    DIRECTION   Direction;

    dWaveFlags = dFlags & ~(MCI_NOTIFY | MCI_WAIT);
    if (dWaveFlags != (dWaveFlags & (MCI_WAVE_INPUT | MCI_WAVE_OUTPUT)))
        return MCIERR_UNRECOGNIZED_KEYWORD;

    switch (dWaveFlags) {
    case MCI_WAVE_INPUT:
        Direction = input;
        break;

    case MCI_WAVE_OUTPUT:
    case 0:
        Direction = output;
        break;

    default:
        return MCIERR_FLAGS_NOT_COMPATIBLE;
    }

    if (ISTASKSTATE(pwd, TASKBUSY)) {
        if (ISMODE(pwd, COMMAND_CUE) && (pwd->Direction == Direction)) {
            mwDelayedNotify(pwd, MCI_NOTIFY_SUPERSEDED);
            if (dFlags & MCI_NOTIFY)
                mwImmediateNotify(pwd->wDeviceID, lpGeneric);
            return 0L;
        }
        return MCIERR_NONAPPLICABLE_FUNCTION;
    }

    if (lpGeneric && (dFlags & MCI_NOTIFY))
        mciPlay.dwCallback = lpGeneric->dwCallback;

    dFlags &= ~(MCI_WAVE_INPUT | MCI_WAVE_OUTPUT);
    return mwSetup(pwd, dFlags | MCI_MCIWAVE_CUE, &mciPlay, Direction);
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | mwSeek |
    This function is called in response to an <m>MCI_SEEK<d> message, and
    is used to seek to position in wave file.

    This function has the side effect of stopping any current playback or
    recording.  If successful, the current position is set to the
    position specified.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dFlags |
    Contains the flags for seek message.

@flag   MCI_TO |
    This flag indicates that the parameter block contains the position to
    seek to.

@flag   MCI_SEEK_TO_START |
    This flag indicates that the current position should be moved to the
    start of the media.

@flag   MCI_SEEK_TO_END |
    This flag indicates that the current position should be moved to the
    end of the media.

@flag   MCI_WAIT |
    Wait for command to complete.

@flag   MCI_NOTIFY |
    Notify upon command completion.

@parm   <t>LPMCI_SEEK_PARMS<d> | lpmciSeek |
    Contains the seek parameters.

@rdesc  Returns 0 if the current position was successfully set, else an MCI
    error.
*/

PRIVATE UINT PASCAL NEAR mwSeek(
    PWAVEDESC   pwd,
    DWORD   dFlags,
    LPMCI_SEEK_PARMS    lpmciSeek)
{
    DWORD   dToBytePosition;

    dFlags &= ~(MCI_NOTIFY | MCI_WAIT);

    if (!dFlags)
        return MCIERR_MISSING_PARAMETER;

    if (dFlags != (dFlags & (MCI_TO | MCI_SEEK_TO_START | MCI_SEEK_TO_END)))
        return MCIERR_UNRECOGNIZED_KEYWORD;

    switch (dFlags) {
    case MCI_TO:
        dToBytePosition = VerifyRangeEnd(pwd, lpmciSeek->dwTo, TRUE);
        if (dToBytePosition == -1)
            return MCIERR_OUTOFRANGE;
        break;

    case MCI_SEEK_TO_START:
        dToBytePosition = 0;
        break;

    case MCI_SEEK_TO_END:
        dToBytePosition = pwd->dSize;
        break;

    default:
        return MCIERR_FLAGS_NOT_COMPATIBLE;
    }

    mwStop(pwd);
    SetCurrentPosition(pwd, dToBytePosition);
    return 0;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    DWORD | mwStatus |
    This function is called in response to an <m>MCI_STATUS<d> message, and
    is used to return numeric status information, including resource IDs.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   UINT | dFlags |
    Contains the status flags.

@flag   MCI_STATUS_ITEM |
    This flag must be set, and specifies that a specific item is being
    queried.

@flag   MCI_TRACK |
    This flag specifies that track information is being queried of the
    item.  This flag is only valid with Position and Status queries.

@parm   <t>LPMCI_STATUS_PARMS<d> | lpStatus |
    Status parameters.

@flag   MCI_STATUS_POSITION |
    Queries the current position.  If the Track flag is set, then the
    starting position of the track is being queried.  As there is only
    one track, and it starts at the beginning, this returns zero.  Else
    if the Start flag is set, the starting position of the audio is
    returned.  Else the current position within the wave file is returned.

@flag   MCI_STATUS_LENGTH |
    Queries the current length.  If the Track flag is set, then the length
    of the track is being queried.  As there is only one track, the track
    number must be one.  In either case, the length of the wave file is
    returned.

@flag   MCI_STATUS_NUMBER_OF_TRACKS |
    Queries the number of track.  There is always one track.

@flag   MCI_STATUS_CURRENT_TRACK |
    Queries the current of track.  As there is one track, this returns one.

@flag   MCI_STATUS_READY |
    Queries as to whether the MCI wave device can receive commands.  This
    is always TRUE.

@flag   MCI_STATUS_MODE |
    Queries the current mode of the MCI wave device instance.  This can be
    one of Paused, Playing, Recording, or Stopped.

@flag   MCI_STATUS_MEDIA_PRESENT |
    Queries as to whether there is media present.  Since there must be a
    wave file present to enter this function, this always returns TRUE.

@flag   MCI_STATUS_TIME_FORMAT |
    Queries the current time format.  This can be one of Bytes, Samples,
    or Milliseconds.

@flag   MCI_WAVE_STATUS_FORMATTAG |
    Queries the current format tag.  There is only PCM now, but it will
    return identifiers for other tag formats.

@flag   MCI_WAVE_STATUS_CHANNELS |
    Queries the number of channels.  This is one or two.

@flag   MCI_WAVE_STATUS_SAMPLESPERSEC |
    Queries the number of samples per second for playback and recording.

@flag   MCI_WAVE_STATUS_AVGBYTESPERSEC |
    Queries the average number of bytes per second for playback and
    recording.

@flag   MCI_WAVE_STATUS_BLOCKALIGN |
    Queries the current block alignment.

@flag   MCI_WAVE_STATUS_BITSPERSAMPLE |
    Queries the number of bits per sample.

@flag   MCI_WAVE_INPUT |
    Queries the current input wave device in use, if any.  If no device
    suits the current format, an error is returned.  If a device suits
    the current format, but the MCI wave device instance is not recording,
    then an error is also returned.  Else the device in use is returned.

@flag   MCI_WAVE_OUTPUT |
    Queries the current output wave device in use, if any.  If no device
    suits the current format, an error is returned.  If a device suits
    the current format, but the MCI wave device instance is not playing,
    then an error is also returned.  Else the device in use is returned.

@flag   MCI_WAVE_STATUS_LEVEL |
    Returns the current input level, if possible.  Before checking the
    task state, the function must make sure the task is not in Cleanup
    mode.  If it is, it must wait for the task to enter Idle state before
    sending new commands.  If the task is currently busy, and in-use error
    is returned.  If the task is idle, recording is Cued.  The function
    then waits for the background task to enter the Cued state (which it
    might have already been in), and retrieves the level sample.

@flag   MCI_WAIT |
    Wait for command to complete.

@flag   MCI_NOTIFY |
    Notify upon command completion.

@rdesc  Returns 0 if the request status was successfully returned, else an MCI
    error.
*/

PRIVATE DWORD PASCAL NEAR mwStatus(
    PWAVEDESC   pwd,
    DWORD   dFlags,
    LPMCI_STATUS_PARMS  lpStatus)
{
    DWORD   dReturn;
    #ifdef _WIN64
    DWORD   dwPos;
    #endif

    dReturn = 0;
    dFlags &= ~(MCI_NOTIFY | MCI_WAIT);

    if (dFlags & MCI_STATUS_ITEM) {
        dFlags &= ~MCI_STATUS_ITEM;

        if ((dFlags & MCI_TRACK)
            && !(lpStatus->dwItem == MCI_STATUS_POSITION || lpStatus->dwItem == MCI_STATUS_LENGTH))
            return MCIERR_FLAGS_NOT_COMPATIBLE;

        else if ((dFlags & MCI_STATUS_START) && (lpStatus->dwItem != MCI_STATUS_POSITION))
            return MCIERR_FLAGS_NOT_COMPATIBLE;

        switch (lpStatus->dwItem) {
            UINT    wResource;

        case MCI_STATUS_POSITION:
            switch (dFlags) {
            case 0:
                #ifndef _WIN64
                dReturn = GetPlayRecPosition(pwd, &(lpStatus->dwReturn), pwd->dTimeFormat);
                #else
                dwPos = (DWORD)lpStatus->dwReturn;
                dReturn = GetPlayRecPosition(pwd, &dwPos, pwd->dTimeFormat);
                lpStatus->dwReturn = dwPos;
                #endif
                break;

            case MCI_TRACK:
                if (lpStatus->dwTrack != 1)
                    dReturn = MCIERR_OUTOFRANGE;
                else
                    lpStatus->dwReturn = 0L;
                break;

            case MCI_STATUS_START:
                lpStatus->dwReturn = 0L;
                break;

            default:
                dReturn = MCIERR_UNRECOGNIZED_KEYWORD;
                break;
            }
            break;

        case MCI_STATUS_LENGTH:
            switch (dFlags) {
            case 0:
                lpStatus->dwReturn = bytes2time(pwd, pwd->dSize, pwd->dTimeFormat);
                break;

            case MCI_TRACK:
                if (lpStatus->dwTrack != 1)
                    dReturn = MCIERR_OUTOFRANGE;
                else
                    lpStatus->dwReturn = bytes2time(pwd, pwd->dSize, pwd->dTimeFormat);
                break;

            default:
                dReturn = MCIERR_UNRECOGNIZED_KEYWORD;
                break;
            }
            break;

        case MCI_STATUS_NUMBER_OF_TRACKS:
        case MCI_STATUS_CURRENT_TRACK:
            lpStatus->dwReturn = 1L;
            break;

        case MCI_STATUS_READY:
            lpStatus->dwReturn = (DWORD)MAKEMCIRESOURCE(TRUE, MCI_TRUE);
            dReturn = MCI_RESOURCE_RETURNED;
            break;

        case MCI_STATUS_MODE:
            if (ISTASKSTATE(pwd, TASKBUSY)) {
                if (ISMODE(pwd, MODE_PAUSED | COMMAND_CUE | MODE_HOLDING))
                    wResource = MCI_MODE_PAUSE;
                else if (ISMODE(pwd, COMMAND_PLAY))
                    wResource = MCI_MODE_PLAY;
                else
                    wResource = MCI_MODE_RECORD;
            } else
                wResource = MCI_MODE_STOP;
            lpStatus->dwReturn = (DWORD)MAKEMCIRESOURCE(wResource, wResource);
            dReturn = MCI_RESOURCE_RETURNED;
            break;

        case MCI_STATUS_MEDIA_PRESENT:
            lpStatus->dwReturn = (DWORD)MAKEMCIRESOURCE(TRUE, MCI_TRUE);
            dReturn = MCI_RESOURCE_RETURNED;
            break;

        case MCI_STATUS_TIME_FORMAT:
            wResource = LOWORD(pwd->dTimeFormat);
            lpStatus->dwReturn = (DWORD)MAKEMCIRESOURCE(wResource, wResource + MCI_FORMAT_RETURN_BASE);
            dReturn = MCI_RESOURCE_RETURNED;
            break;

        case MCI_WAVE_STATUS_FORMATTAG:
            if (pwd->pwavefmt->wFormatTag == WAVE_FORMAT_PCM) {
                lpStatus->dwReturn = (DWORD)MAKEMCIRESOURCE(WAVE_FORMAT_PCM, WAVE_FORMAT_PCM_S);
                dReturn = MCI_RESOURCE_RETURNED;
            } else
                lpStatus->dwReturn = MAKELONG(pwd->pwavefmt->wFormatTag, 0);
            break;

        case MCI_WAVE_STATUS_CHANNELS:
            lpStatus->dwReturn = MAKELONG(pwd->pwavefmt->nChannels, 0);
            break;

        case MCI_WAVE_STATUS_SAMPLESPERSEC:
            lpStatus->dwReturn = pwd->pwavefmt->nSamplesPerSec;
            break;

        case MCI_WAVE_STATUS_AVGBYTESPERSEC:
            lpStatus->dwReturn = pwd->pwavefmt->nAvgBytesPerSec;
            break;

        case MCI_WAVE_STATUS_BLOCKALIGN:
            lpStatus->dwReturn = MAKELONG(pwd->pwavefmt->nBlockAlign, 0);
            break;

        case MCI_WAVE_STATUS_BITSPERSAMPLE:

            if (pwd->pwavefmt->wFormatTag == WAVE_FORMAT_PCM)
                lpStatus->dwReturn = (((NPPCMWAVEFORMAT)(pwd->pwavefmt))->wBitsPerSample);
            else
                dReturn = MCIERR_UNSUPPORTED_FUNCTION;
            break;

        case MCI_WAVE_INPUT:

            if (pwd->idIn == WAVE_MAPPER) {
                lpStatus->dwReturn = (DWORD)MAKEMCIRESOURCE(WAVE_MAPPER, WAVE_MAPPER_S);
                dReturn = MCI_RESOURCE_RETURNED;
            } else
                lpStatus->dwReturn = pwd->idIn;
            break;

        case MCI_WAVE_OUTPUT:

            if (pwd->idOut == WAVE_MAPPER) {
                lpStatus->dwReturn = (DWORD)MAKEMCIRESOURCE(WAVE_MAPPER, WAVE_MAPPER_S);
                dReturn = MCI_RESOURCE_RETURNED;
            } else
                lpStatus->dwReturn = pwd->idOut;
            break;

        case MCI_WAVE_STATUS_LEVEL:

            if (ISMODE(pwd, MODE_CLEANUP)) {
                while (!ISTASKSTATE(pwd, TASKIDLE))
                    mmYield(pwd);
            }

            if (ISTASKSTATE(pwd, TASKIDLE)) {
                pwd->Direction = input;
                TaskSignal(pwd->hTask, WTM_STATECHANGE);

                if (0 != (dReturn = mwGetDevice(pwd)))
                    break;

                SETMODE(pwd, COMMAND_NEW | COMMAND_INSERT | COMMAND_OVERWRITE | COMMAND_CUE);
                SETTASKSTATE(pwd, TASKBUSY);

            } else if (!ISMODE(pwd, COMMAND_INSERT | COMMAND_OVERWRITE)
                    || !ISMODE(pwd, COMMAND_CUE)) {

                dReturn = MCIERR_WAVE_INPUTSINUSE;
                break;
            }

            while (!ISMODE(pwd, MODE_CUED) && !ISTASKSTATE(pwd, TASKIDLE))
                mmYield(pwd);

            if (pwd->wTaskError)
                dReturn = pwd->wTaskError;
            else
                lpStatus->dwReturn = pwd->dLevel;

            break;

        default:
            dReturn = MCIERR_UNSUPPORTED_FUNCTION;
            break;
        }
    } else
        dReturn = MCIERR_MISSING_PARAMETER;

    return dReturn;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | mwSet |
    This function is called in response to an <m>MCI_SET<d> message, and
    is used to set the specified parameters in the MCI device information
    block.  Note that format changes can only be performed on a file with
    no data, as data conversion is not performed.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   UINT | dFlags |
    Contains the status flags.

@flag   MCI_WAVE_INPUT |
    Sets the input wave device to be used to the specified device ID.
    This causes playback and recording to be stopped.

@flag   MCI_WAVE_OUTPUT |
    Sets the output wave device to be used to the specified device ID.
    This causes playback and recording to be stopped.

@flag   MCI_WAVE_SET_ANYINPUT |
    Enables recording to use any wave input device.

@flag   MCI_WAVE_SET_ANYOUTPUT |
    Enables recording to use any wave input device.

@flag   MCI_SET_TIME_FORMAT |
    Sets the time format used when interpreting or returning time-based
    command arguments.  Note that the time format can only be set to bytes
    if the file format is currently PCM, it does not care if

@flag   MCI_WAVE_SET_FORMATTAG |
    Sets the wave format tag.  This causes playback and recording to be
    stopped, and saves a copy of the current wave format header in case
    the new format is not valid for either recording or playback.

@flag   MCI_WAVE_SET_CHANNELS |
    Sets the number of channels.  This causes playback and recording to be
    stopped, and saves a copy of the current wave format header in case
    the new format is not valid for either recording or playback.

@flag   MCI_WAVE_SET_SAMPLESPERSEC |
    Sets the number of samples per second for recording and playback.  This
    causes playback and recording to be stopped, and saves a copy of the
    current wave format header in case the new format is not valid for
    either recording or playback.

@flag   MCI_WAVE_SET_AVGBYTESPERSEC |
    Sets the average number of bytes per second for recording and playback.
    This causes playback and recording to be stopped, and saves a copy of
    the current wave format header in case the new format is not valid for
    either recording or playback.

@flag   MCI_WAVE_SET_BLOCKALIGN |
    Sets the block alignment.  This causes playback and recording to be
    stopped, and saves a copy of the current wave format header in case
    the new format is not valid for either recording or playback.

@flag   MCI_WAVE_SET_BITSPERSAMPLE |
    Sets the number of bits per sample.  This causes playback and recording
    to be stopped, and saves a copy of the current wave format header in
    case the new format is not valid for either recording or playback.

@flag   MCI_SET_AUDIO |
    This is an unsupported function.

@flag   MCI_SET_DOOR_OPEN |
    This is an unsupported function.

@flag   MCI_SET_DOOR_CLOSED |
    This is an unsupported function.

@flag   MCI_SET_VIDEO |
    This is an unsupported function.

@flag   MCI_SET_ON |
    This is an unsupported function.

@flag   MCI_SET_OFF |
    This is an unsupported function.

@flag   MCI_WAIT |
    Wait for command to complete.

@flag   MCI_NOTIFY |
    Notify upon command completion.

@parm   <t>LPMCI_WAVE_SET_PARMS<d> | lpSet |
    Set parameters.

@rdesc  Returns 0 if the requested parameters were successfully set, else an
    MCI error if one or more error occurred.
*/

PRIVATE UINT PASCAL NEAR mwSet(
    PWAVEDESC   pwd,
    DWORD   dFlags,
    LPMCI_WAVE_SET_PARMS    lpSet)
{
    UINT    wReturn;

    dFlags &= ~(MCI_NOTIFY | MCI_WAIT);
    if (!dFlags)
        return MCIERR_MISSING_PARAMETER;

    wReturn = 0;
    if (dFlags & (MCI_WAVE_INPUT | MCI_WAVE_OUTPUT)) {
        mwStop(pwd);
        if (dFlags & MCI_WAVE_INPUT) {
            if (lpSet->wInput < cWaveInMax)
                pwd->idIn = lpSet->wInput;
            else
                wReturn = MCIERR_OUTOFRANGE;
        }
        if (dFlags & MCI_WAVE_OUTPUT) {
            if (lpSet->wOutput < cWaveOutMax)
                pwd->idOut = lpSet->wOutput;
            else
                wReturn = MCIERR_OUTOFRANGE;
        }
    }
    if (dFlags & MCI_WAVE_SET_ANYINPUT)
        pwd->idIn = (DWORD)WAVE_MAPPER;

    if (dFlags & MCI_WAVE_SET_ANYOUTPUT)
        pwd->idOut = (DWORD)WAVE_MAPPER;

    if (dFlags & MCI_SET_TIME_FORMAT) {
        if ((lpSet->dwTimeFormat == MCI_FORMAT_MILLISECONDS)
         || (lpSet->dwTimeFormat == MCI_FORMAT_SAMPLES)
         || ((lpSet->dwTimeFormat == MCI_FORMAT_BYTES) && (pwd->pwavefmt->wFormatTag == WAVE_FORMAT_PCM)))
            pwd->dTimeFormat = lpSet->dwTimeFormat;
        else
            wReturn = MCIERR_BAD_TIME_FORMAT;
    }

    if (dFlags
        & (MCI_WAVE_SET_FORMATTAG | MCI_WAVE_SET_CHANNELS | MCI_WAVE_SET_SAMPLESPERSEC | MCI_WAVE_SET_AVGBYTESPERSEC | MCI_WAVE_SET_BLOCKALIGN | MCI_WAVE_SET_BITSPERSAMPLE)) {

        if (pwd->dSize) {
            wReturn = MCIERR_NONAPPLICABLE_FUNCTION;
        } else {
            PBYTE   pbWaveFormat;

            mwStop(pwd);
            pbWaveFormat = (PBYTE)LocalAlloc(LPTR, pwd->wFormatSize);

            if (!pbWaveFormat)
                return MCIERR_OUT_OF_MEMORY;

            memcpy(pbWaveFormat, pwd->pwavefmt, pwd->wFormatSize);

            if (dFlags & MCI_WAVE_SET_FORMATTAG)
                pwd->pwavefmt->wFormatTag = lpSet->wFormatTag;

            if (dFlags & MCI_WAVE_SET_CHANNELS)
                pwd->pwavefmt->nChannels = lpSet->nChannels;

            if (dFlags & MCI_WAVE_SET_SAMPLESPERSEC)
                pwd->pwavefmt->nSamplesPerSec = lpSet->nSamplesPerSec;

            if (dFlags & MCI_WAVE_SET_AVGBYTESPERSEC)
                pwd->pwavefmt->nAvgBytesPerSec = lpSet->nAvgBytesPerSec;

            if (dFlags & MCI_WAVE_SET_BITSPERSAMPLE)
                if (pwd->pwavefmt->wFormatTag == WAVE_FORMAT_PCM)
                    ((NPPCMWAVEFORMAT)(pwd->pwavefmt))->wBitsPerSample = lpSet->wBitsPerSample;
                else
                    wReturn = MCIERR_UNSUPPORTED_FUNCTION;

            if (dFlags & MCI_WAVE_SET_BLOCKALIGN)
                pwd->pwavefmt->nBlockAlign = lpSet->nBlockAlign;
            else if (pwd->pwavefmt->wFormatTag == WAVE_FORMAT_PCM)
                pwd->pwavefmt->nBlockAlign = (WORD)pwd->pwavefmt->nSamplesPerSec / (WORD)pwd->pwavefmt->nAvgBytesPerSec;

            if (mwCheckDevice(pwd, output) && mwCheckDevice(pwd, input)) {
                wReturn = MCIERR_OUTOFRANGE;
                memcpy(pwd->pwavefmt, pbWaveFormat, pwd->wFormatSize);
            } else
                pwd->dAudioBufferLen = BLOCKALIGN(pwd, pwd->pwavefmt->nAvgBytesPerSec);

            LocalFree(pbWaveFormat);
        }
    }

    if (dFlags & (MCI_SET_DOOR_OPEN | MCI_SET_DOOR_CLOSED | MCI_SET_AUDIO | MCI_SET_VIDEO | MCI_SET_ON | MCI_SET_OFF))
        wReturn = MCIERR_UNSUPPORTED_FUNCTION;

    return wReturn;
}

/************************************************************************/

/*
@doc    INTERNAL MCIWAVE

@api    UINT | mwDelete |
    This function is called in response to an <m>MCI_DELETE<d> message, and
    is used to delete a portion of the wave file.

    The range checking performed on the "to" and "from" parameters is
    almost identical to that of playback and recording, except that the
    the "to" position cannot be larger than the file length.

    If the parameters are equal, the function sets the current position to
    the "from" parameter, and returns success without actually doing
    anything, else the specified range is deleted from the file.

    On success, the current position is set to the "from" position.  This
    is consistent with the other commands that have "to" and "from"
    paramters since the "to" position becomes the same as the "from"
    position after a deletion.

    In the future, support for Cut/Copy/Paste should be added.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dFlags |
    Contains the flags for delete message.

@flag   MCI_FROM |
    Indicates a starting position is present in <p>lpDelete<d>, else the
    current position is used.

@flag   MCI_TO |
    Indicates an ending position is present in <p>lpDelete<d>, else the file
    size is used.

@parm   <t>LPMCI_WAVE_DELETE_PARMS<d> | lpDelete |
    Optionally contains the delete parameters.

@rdesc  Returns 0 if the range was deleted, else MCIERR_OUTOFRANGE for invalid
    parameters or MCIERR_OUT_OF_MEMORY if the delete failed.
*/

PRIVATE UINT PASCAL NEAR mwDelete(
    PWAVEDESC   pwd,
    DWORD   dFlags,
    LPMCI_WAVE_DELETE_PARMS lpDelete)
{
    DWORD   dFrom;
    DWORD   dTo;

    mwStop(pwd);
    if (dFlags & MCI_FROM) {
        dFrom = VerifyRangeStart(pwd, lpDelete->dwFrom);
        if (dFrom == -1)
            return MCIERR_OUTOFRANGE;
    } else
        dFrom = pwd->dCur;

    if (dFlags & MCI_TO) {
        dTo = VerifyRangeEnd(pwd, lpDelete->dwTo, TRUE);
        if (dTo == -1)
            return MCIERR_OUTOFRANGE;
    } else
        dTo = pwd->dSize;

    if (dTo < dFrom)
        return MCIERR_OUTOFRANGE;

    SetCurrentPosition(pwd, dFrom);

    if (dTo == dFrom)
        return 0L;

    pwd->dTo = dTo;
    SETTASKSTATE(pwd, TASKDELETE);
    TaskSignal(pwd->hTask, WTM_STATECHANGE);

    while (!ISTASKSTATE(pwd, TASKIDLE))
        mmYield(pwd);

    return pwd->wTaskError;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | mwSave |
    This function is called in response to an <m>MCI_SAVE<d> message, and
    is used to save the file attached to the MCI device.  This has the
    side effect of stopping any current playback or recording.

    If the file is not named, the MCI_SAVE_FILE flag must be used and a
    named provided, else the function will fail.  If the function succeeds,
    and a name has been provided, the name attached to the MCI device will
    be changed, otherwise it will remain the same.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dFlags |
    Contains the save flags.

@flag   MCI_SAVE_FILE |
    Indicates that a file name has been provided in the <p>lpSave<d>
    structure.

@parm   <t>LPMCI_SAVE_PARMS<d> | lpSave |
    Structure optionally contains a pointer to a file name to save to.
    The current file name is only changed if the save is successful.

@rdesc  Returns 0 if the file was saved, else an MCI error.
*/

PRIVATE UINT PASCAL NEAR mwSave(
    PWAVEDESC   pwd,
    DWORD   dFlags,
    LPMCI_SAVE_PARMS    lpSave)
{
    if (((dFlags & MCI_SAVE_FILE) && !lpSave->lpfilename)
        || (!*pwd->aszFile && !(dFlags & MCI_SAVE_FILE)))
        return MCIERR_UNNAMED_RESOURCE;

    if (dFlags & MCI_SAVE_FILE) {

        MMIOINFO    mmioInfo;

        WCHAR    aszSaveFile[_MAX_PATH];

        aszSaveFile[ (sizeof(aszSaveFile) / sizeof(WCHAR)) - 1] = '\0';
        wcsncpy(aszSaveFile, lpSave->lpfilename, (sizeof(aszSaveFile) / sizeof(WCHAR)) - 1);

        InitMMIOOpen(pwd, &mmioInfo);

        if (!mmioOpen(aszSaveFile, &mmioInfo, MMIO_PARSE))
            return MCIERR_FILENAME_REQUIRED;
        // The fully qualified name is in aszSaveFile

        if (lstrcmp(aszSaveFile, pwd->aszFile)) {
            pwd->szSaveFile = (LPWSTR)LocalAlloc(LPTR,
                            sizeof(WCHAR)*lstrlen(aszSaveFile) + sizeof(WCHAR));
            if (pwd->szSaveFile)
                lstrcpy(pwd->szSaveFile, aszSaveFile);
            else
                return MCIERR_OUT_OF_MEMORY;
        }
    }

    mwStop(pwd);
    SETTASKSTATE(pwd, TASKSAVE);
    TaskSignal(pwd->hTask, WTM_STATECHANGE);

    while (!ISTASKSTATE(pwd, TASKIDLE))
        mmYield(pwd);

    if (pwd->szSaveFile) {
        LocalFree(pwd->szSaveFile);
        pwd->szSaveFile = NULL;
    }

    return pwd->wTaskError;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    LRESULT | mciDriverEntry |
    Single entry point for MCI drivers.

    After executing the command, if notification has been specified, any
    previous notification is superseded, and new notification is performed.
    Any command which performs delayed notification, or the special case
    of Cue, has already returned by this point.

@parm   MCIDEVICEID | wDeviceID |
    Contains the MCI device ID.

@parm   UINT | wMessage |
    The requested action to be performed.

@flag   MCI_OPEN_DRIVER |
    Open an instance of the MCI wave device driver, possibly attaching an
    element to the device.

@flag   MCI_CLOSE_DRIVER |
    Close an instance of the MCI wave device driver, closing any element
    attached to the device.

@flag   MCI_PLAY |
    Play the element attached to the instance of the MCI wave device
    driver.

@flag   MCI_RECORD |
    Record to the element attached to the instance of the MCI wave device
    driver.

@flag   MCI_STOP |
    Stop playback or recording of the element attached to the instance of
    the MCI wave device driver.

@flag   MCI_CUE |
    Cue playback or recording of the element attached to the instance of
    the MCI wave device driver.

@flag   MCI_SEEK |
    Set the current position in the element attached to the instance of
    the MCI wave device driver.

@flag   MCI_PAUSE |
    Pause playback or recording of the element attached to the instance of
    the MCI wave device driver.

@flag   MCI_RESUME |
    Resumes playback or recording of the element attached to the instance
    of the MCI wave device driver.

@flag   MCI_STATUS |
    Retrieve the specified status of the element attached to the instance
    of the MCI wave device driver.

@flag   MCI_GETDEVCAPS |
    Retrieve the specified device capabilities of the instance of the MCI
    wave device driver.

@flag   MCI_INFO |
    Retrieve the specified information from the element or the instance of
    the MCI wave device driver.

@flag   MCI_SET |
    Set the specified parameters of the element attached to the instance
    of the MCI wave device driver.

@flag   MCI_SAVE |
    Save the element attached to the instance of the MCI wave device
    driver.

@flag   MCI_DELETE |
    Delete data from the element attached to the instance of the MCI wave
    device driver.

@flag   MCI_LOAD |
    This is an unsupported function.

@parm   DWORD | dFlags |
    Data for this message.  Defined seperately for each message.

@parm   <t>LPMCI_GENERIC_PARMS<d> | lpParms |
    Data for this message.  Defined seperately for each message

@rdesc  Defined separately for each message.
*/

PUBLIC  LRESULT PASCAL FAR mciDriverEntry(
    MCIDEVICEID wDeviceID,
    UINT    wMessage,
    DWORD   dFlags,
    LPMCI_GENERIC_PARMS lpParms)
{
    PWAVEDESC   pwd;
    LRESULT     lReturn;

    if (!(pwd = (PWAVEDESC)(mciGetDriverData(wDeviceID))))
        switch (wMessage) {
        case MCI_PLAY:
        case MCI_RECORD:
        case MCI_STOP:
        case MCI_CUE:
        case MCI_SEEK:
        case MCI_PAUSE:
        case MCI_RESUME:
        case MCI_STATUS:
        case MCI_SET:
        case MCI_SAVE:
        case MCI_DELETE:
        case MCI_COPY:
        case MCI_PASTE:
            return (LRESULT)MCIERR_UNSUPPORTED_FUNCTION;
        }

    EnterCrit();

    switch (wMessage) {
    case MCI_OPEN_DRIVER:
        lReturn = mwOpenDevice(dFlags, (LPMCI_WAVE_OPEN_PARMS)lpParms, wDeviceID);
        break;

    case MCI_CLOSE_DRIVER:
        lReturn = mwCloseDevice(pwd);
        pwd = NULL;
        break;

    case MCI_PLAY:
        lReturn = (LRESULT)(LONG)mwSetup(pwd, dFlags, (LPMCI_PLAY_PARMS)lpParms, output);
        LeaveCrit();
        return lReturn;

    case MCI_RECORD:
        lReturn = (LRESULT)(LONG)mwSetup(pwd, dFlags, (LPMCI_PLAY_PARMS)lpParms, input);
        LeaveCrit();
        return lReturn;

    case MCI_STOP:
        mwStop(pwd);
        lReturn = 0;
        break;

    case MCI_CUE:
        lReturn = (LRESULT)(LONG)mwCue(pwd, dFlags, lpParms);
        LeaveCrit();
        return lReturn;

    case MCI_SEEK:
        lReturn = mwSeek(pwd, dFlags, (LPMCI_SEEK_PARMS)lpParms);
        break;

    case MCI_PAUSE:
        lReturn = mwPause(pwd, dFlags);
        break;

    case MCI_RESUME:
        lReturn = mwResume(pwd, dFlags);
        break;

    case MCI_STATUS:
        lReturn = mwStatus(pwd, dFlags, (LPMCI_STATUS_PARMS)lpParms);
        break;

    case MCI_GETDEVCAPS:
        lReturn = mwGetDevCaps(pwd, dFlags, (LPMCI_GETDEVCAPS_PARMS)lpParms);
        break;

    case MCI_INFO:
        lReturn = mwInfo(pwd, dFlags, (LPMCI_INFO_PARMS)lpParms);
        break;

    case MCI_SET:
        lReturn = mwSet(pwd, dFlags, (LPMCI_WAVE_SET_PARMS)lpParms);
        break;

    case MCI_SAVE:
        lReturn = mwSave(pwd, dFlags, (LPMCI_SAVE_PARMS)lpParms);
        break;

    case MCI_DELETE:
        lReturn = mwDelete(pwd, dFlags, (LPMCI_WAVE_DELETE_PARMS)lpParms);
        break;

    case MCI_COPY:
    case MCI_PASTE:
    case MCI_LOAD:
        lReturn = MCIERR_UNSUPPORTED_FUNCTION;
        break;

    default:
        lReturn = MCIERR_UNRECOGNIZED_COMMAND;
        break;
    }
    if (!LOWORD(lReturn) && (dFlags & MCI_NOTIFY)) {
        if (pwd)
            mwDelayedNotify(pwd, MCI_NOTIFY_SUPERSEDED);
        mwImmediateNotify(wDeviceID, lpParms);
    }

    LeaveCrit();
    return lReturn;
}

/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mciwave\mwplay.c ===
/************************************************************************/

/*
**  Copyright (c) 1985-1998 Microsoft Corporation
**
**  Title: mwplay.c - Multimedia Systems Media Control Interface
**  waveform digital audio driver for RIFF wave files.
**  Routines for playing wave files
**
**  Version:    1.00
**
**  Date:       18-Apr-1990
**
**  Author:     ROBWI
*/

/************************************************************************/

/*
**  Change log:
**
**  DATE        REV DESCRIPTION
**  ----------- -----   ------------------------------------------
**  18-APR-1990 ROBWI   Original
**  19-JUN-1990 ROBWI   Added wave in
**  10-Jan-1992 MikeTri Ported to NT
**                  @@@ Need to change comments from slash slash to slash star
**   4-Mar-1992 SteveDav Continue the port.  Update to current Win 3.1
*/

/************************************************************************/
#define UNICODE

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICONS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define OEMRESOURCE
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
#define NOCTLMGR
#define NODRAWTEXT
#define NOGDI
#define NOKERNEL
#define NONLS
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOOPENFILE
#define NOSCROLL
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOCOMM
#define NOKANJI
#define NOHELP
#define NOPROFILER
#define NODEFERWINDOWPOS

#include <windows.h>
#include "mciwave.h"
#include <mmddk.h>

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   DWORD | mwRead |
    This function reads a buffer of wave data from either the input file,
    or the temporary data file.  The position is taken from the
    <e>WAVEDESC.dCur<d> pointer, which is updated with the number of bytes
    actually read.

    The data needed may come from several consecutively linked nodes, so
    first the virtual data ending position for the current wave data node
    is checked against the the current position.  This is to determine if
    the next node needs to be accessed.  The function then reads the data
    from the appropriate source, either the temporary data file, or the
    original file.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   LPBYTE | lpbBuffer |
    Points to a buffer to contain the data read.

@parm   DWORD | dBufferLength |
    Indicates the maximum number of bytes to read into the buffer.

@rdesc  Returns number of bytes read, else 0 on an error wherein no bytes
    could be read.  This means that there is not distinction between a
    read of zero bytes, or an error, but the function is never called
    if no bytes are to be read.
*/

PRIVATE DWORD PASCAL NEAR mwRead(
    PWAVEDESC   pwd,
    LPBYTE  lpbBuffer,
    DWORD   dBufferLength)
{
    DWORD   dTotalRead;
    LPWAVEDATANODE  lpwdn;

    lpwdn = LPWDN(pwd, pwd->dWaveDataCurrentNode);
    for (dTotalRead = 0; dBufferLength;) {
        DWORD   dStartRead;
        DWORD   dReadSize;
        DWORD   dBytesRead;

        if (pwd->dVirtualWaveDataStart + lpwdn->dDataLength <= (DWORD)pwd->dCur) {
            pwd->dWaveDataCurrentNode = lpwdn->dNextWaveDataNode;
            pwd->dVirtualWaveDataStart += lpwdn->dDataLength;
            lpwdn = LPWDN(pwd, lpwdn->dNextWaveDataNode);
        }

        dStartRead = pwd->dCur - pwd->dVirtualWaveDataStart;
        dReadSize = min(dBufferLength, lpwdn->dDataLength - dStartRead);

        if (ISTEMPDATA(lpwdn)) {
            if (MySeekFile(pwd->hTempBuffers, UNMASKDATASTART(lpwdn) + dStartRead))
		MyReadFile(pwd->hTempBuffers, lpbBuffer, dReadSize, &dBytesRead);
            else
                dBytesRead = (DWORD)-1;
        } else {
            if (mmioSeek(pwd->hmmio, pwd->dRiffData + lpwdn->dDataStart + dStartRead, SEEK_SET) != -1)
                dBytesRead = (DWORD)mmioRead(pwd->hmmio, lpbBuffer, (LONG)dReadSize);
            else
                dBytesRead = (DWORD)-1;
        }

        if (dBytesRead != -1) {
            dTotalRead += dBytesRead;
            dBufferLength -= dBytesRead;
            lpbBuffer += dBytesRead;
            pwd->dCur += dBytesRead;
        }

        if (dBytesRead != dReadSize) {
            pwd->wTaskError = MCIERR_FILE_READ;
            break;
        }
    }
    return dTotalRead;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   BOOL | CheckNewCommand |
    This function is called when a New command flag is found during the
    playback loop.  It determines if the new commands affect current
    playback enough that it must be terminated.  This can happen if either
    a Stop command is received, or a Cue command is received and an error
    occurs while pausing the output wave device.

    Any other playback change does not need to stop current playback, as
    they should just release all the buffers from the wave device before
    setting the command.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Returns TRUE if the new commands do not affect playback and it should
    continue, else FALSE if the new commands affect the playback, and it
    should be aborted.
*/

REALLYPRIVATE   BOOL PASCAL NEAR CheckNewCommand(
    PWAVEDESC   pwd)
{
    if (ISMODE(pwd, COMMAND_STOP))
        return FALSE;

    if (ISMODE(pwd, COMMAND_CUE)
      && (0 != (pwd->wTaskError = waveOutPause(pwd->hWaveOut))))
        return FALSE;

    REMOVEMODE(pwd, COMMAND_NEW);
    return TRUE;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   VOID | HoldPlayback |
    This function blocks the task, waiting to be signalled that it can
    continue from the Hold command.  Since the Play Hold command is
    considered to be "finished" when playback is done, but before any
    buffers are freed, the optional notification is performed here.  When
    the task is signalled, it can then check for new commands, which may
    continue playback, or exit the playback loop.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Nothing.
*/

PRIVATE VOID PASCAL NEAR HoldPlayback(
    PWAVEDESC   pwd)
{
    ADDMODE(pwd, MODE_HOLDING);
    mwDelayedNotify(pwd, MCI_NOTIFY_SUCCESSFUL);
    while (TaskBlock() != WTM_STATECHANGE);
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   UINT | PlayFile |
    This function is used to Cue or Play a wave file.  The function
    basically reads buffers from the wave file, and sends them out to the
    wave device, blocking for each buffer sent.  It also makes sure to
    call <f>mmTaskYield<d> while both reading in new buffers, and waiting
    for buffers to be released.

    Within the playback loop, the function first checks for the new command
    flag, which can possibly interrupt or change the current playback.
    The only thing that can really make a difference is setting the stop
    flag.  Changing the playback TO and FROM positions should not affect
    the loop, and setting the Cue command only pauses the output of the
    wave device.

    When the playback loop is first entered, the New command flag is
    set, and this condition is entered.  This allows the Cue command to
    be sent with the Play command, and initially pause the wave output
    device.  Calling <f>waveOutPause<d> stops any data from going out the
    DACs but, but still allows all the buffers to be queued up.

    After checking for a new command, the loop checks to see if there is
    any more data to play from the wave file, and if there are any empty
    buffers to read it in to.  If so, that data is read and written to the
    wave device, with the appropriate error checking, the in-use buffer
    count in incremented, and a pointer to the next data buffer to use is
    retrieved.

    After checking for more data to play, there is a check to see if any
    more buffers are outstanding.  If so, the task blocks until a buffer
    is released by the wave device.  Normally during the end of playback,
    this condition is performed for each outstanding buffer until all
    buffers have been released, then the function would enter the default
    condition and fall out of the loop.  It just blocks the task, waiting
    for the wave device to signal this task after releasing the buffer,
    and the in-use buffer count is decremented.  Note that since the task
    blocked itself, a new command could have been sent, so the playback
    loop starts again after doing a task yield, as it does after each of
    conditional parts of the playback loop.

    Before blocking the Cue command must be checked for in order to
    determine if the optional notification should be sent.  This is
    because a Cue Output command is considered "finished" when the buffers
    have been filled.

    After all playback buffers have been released by the wave device, if
    the hold command was given with the current play command, the task is
    blocked (and thus does not release the memory used by the playback
    buffers, nor leave the playback loop), waiting for a signal, which
    may stop or continue playback with a new set of parameters.

    The final default condition occurs when all the data has been read,
    all the buffers have been released, and the hold flag was not set.
    In this case, playback is done, and the playback loop is exited.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Returns the number of outstanding buffers written to the wave device.
    This can be used when removing task signal from the message queue.
    In cases of error, the <e>WAVEDESC.wTaskError<d> flag is set.  This
    specific error is not currently returned, as the calling task may not
    have waited for the command to complete.  But it is at least used for
    notification in order to determine if Failure status should be sent.

@xref   RecordFile.
*/

PUBLIC  UINT PASCAL FAR PlayFile(
    register PWAVEDESC  pwd)
{
    LPWAVEHDR   *lplpWaveHdr;
    register UINT   wBuffersOutstanding;

    ADDMODE(pwd, MODE_PLAYING);

    for (wBuffersOutstanding = 0, lplpWaveHdr = pwd->rglpWaveHdr;;) {

        if (ISMODE(pwd, COMMAND_NEW) && !CheckNewCommand(pwd))
            break;

        if ((wBuffersOutstanding < pwd->wAudioBuffers) && (pwd->dCur < pwd->dTo)) {
            if (!((*lplpWaveHdr)->dwFlags & WHDR_DONE)) {
                #if DBG
                dprintf1(("\nMCIWAVE Buffer not complete ! %8X", *lplpWaveHdr));
                DebugBreak();
                #endif
            }

            if (!((*lplpWaveHdr)->dwBufferLength = mwRead(pwd, (LPBYTE)(*lplpWaveHdr)->lpData, min(pwd->dAudioBufferLen, pwd->dTo - pwd->dCur))))
                break;

            (*lplpWaveHdr)->dwFlags &= ~(WHDR_DONE | WHDR_BEGINLOOP | WHDR_ENDLOOP);

            if (0 != (pwd->wTaskError = waveOutWrite(pwd->hWaveOut, *lplpWaveHdr, sizeof(WAVEHDR))))
                break;

            wBuffersOutstanding++;
            lplpWaveHdr = NextWaveHdr(pwd, lplpWaveHdr);

        } else if (wBuffersOutstanding) {

            if (ISMODE(pwd, COMMAND_CUE)) {
                ADDMODE(pwd, MODE_CUED);
                mwDelayedNotify(pwd, MCI_NOTIFY_SUCCESSFUL);
            }

            if (TaskBlock() == WM_USER)
                wBuffersOutstanding--;

        } else if (ISMODE(pwd, COMMAND_HOLD)) {
            HoldPlayback(pwd);
        }
        else
            break;

//@@    mmTaskYield();
        mmYield(pwd);

    }

    REMOVEMODE(pwd, MODE_PLAYING);
    return wBuffersOutstanding;
}

/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mciwave\mwinfo.c ===
/************************************************************************/

/*
**  Copyright (c) 1985-1994 Microsoft Corporation
**
**  Title: mwinfo.c - Multimedia Systems Media Control Interface
**  waveform digital audio driver for RIFF wave files.
**
**  Version:    1.00
**
**  Date:       18-Apr-1990
**
**  Author:     ROBWI
*/

/************************************************************************/

/*
**  Change log:
**
**  DATE        REV DESCRIPTION
**  ----------- -----   ------------------------------------------
**  18-APR-1990 ROBWI   Original
**  19-JUN-1990 ROBWI   Added wave in
**  10-Jan-1992 MikeTri Ported to NT
**                  @@@ Change slash slash comments to slash star
*/

/************************************************************************/
#define UNICODE

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICONS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define OEMRESOURCE
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
#define NOCTLMGR
#define NODRAWTEXT
#define NOGDI
#define NOKERNEL
#define NONLS
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOOPENFILE
#define NOSCROLL
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOCOMM
#define NOKANJI
#define NOHELP
#define NOPROFILER
#define NODEFERWINDOWPOS

#include <windows.h>
#include "mciwave.h"
#include <mmddk.h>
#include <wchar.h>

/************************************************************************/

/*
**  The following two constants are used to describe the mask of flags
**  that are dealt with in the Info and Capability commands.
*/

#define MCI_WAVE_INFO_MASK  (MCI_INFO_FILE | MCI_INFO_PRODUCT | \
            MCI_WAVE_INPUT | MCI_WAVE_OUTPUT)

#define MCI_WAVE_CAPS_MASK  (MCI_WAVE_GETDEVCAPS_INPUTS    | \
            MCI_WAVE_GETDEVCAPS_OUTPUTS | MCI_GETDEVCAPS_CAN_RECORD   | \
            MCI_GETDEVCAPS_CAN_PLAY | MCI_GETDEVCAPS_CAN_SAVE         | \
            MCI_GETDEVCAPS_HAS_AUDIO | MCI_GETDEVCAPS_USES_FILES      | \
            MCI_GETDEVCAPS_COMPOUND_DEVICE | MCI_GETDEVCAPS_HAS_VIDEO | \
            MCI_GETDEVCAPS_CAN_EJECT | MCI_GETDEVCAPS_DEVICE_TYPE)

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    DWORD | mwInfo |
    Respond to info command.  The function tries to thoroughly check
    the <p>dFlags<d> parameter by masking out unrecognized commands
    and comparing against the original.  It then makes sure that only
    one command is present by doing a switch() on the flags, and returning
    an error condition if some combination of flags is present.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dFlags |
    Command flags.

@flag   MCI_INFO_FILE |
    Return the file name associated with the MCI wave device instance.
    The instance must have file information attached, that is, not just
    opened for configuration or capabilities checking.  The file name
    returned might be zero length if a name has not been associated with
    a new file.

@flag   MCI_INFO_PRODUCT |
    Return the product name of the driver.

@flag   MCI_WAVE_OUTPUT |
    Return the product name of the current wave output device.  This
    function also requires file information to be attached.  If any
    output can be used and playback is not currently in progress, then
    no device is currently selected.  Else the specific device in use
    is returned.

@flag   MCI_WAVE_INPUT |
    Return the product name of the current wave input device.  This
    function also requires file information to be attached.  If any
    input can be used and recording is not currently in progress, then
    no device is currently selected.  Else the specific device in use
    is returned.

@parm   <t>LPMCI_INFO_PARMS<d> | lpInfo |
    Info parameters.

@rdesc  Returns zero on success, or an MCI error code.
*/

PUBLIC  DWORD PASCAL FAR mwInfo(
    PWAVEDESC         pwd,
    DWORD             dFlags,
    LPMCI_INFO_PARMS  lpInfo)
{
    UINT    wReturnLength;
    UINT    wReturnBufferLength;
    UINT    wErrorRet;

    wReturnBufferLength = lpInfo->dwRetSize; // Win 16 only uses the loword

    if (!lpInfo->lpstrReturn || !wReturnBufferLength)
        return MCIERR_PARAM_OVERFLOW;

    // Turn off the uninteresting flags
    dFlags &= ~(MCI_NOTIFY | MCI_WAIT);

    // See if the user wants anything
    if (!dFlags)
        return MCIERR_MISSING_PARAMETER;

    if (dFlags != (dFlags & MCI_WAVE_INFO_MASK))
        return MCIERR_UNRECOGNIZED_KEYWORD;

    *(lpInfo->lpstrReturn + wReturnBufferLength - 1) = '\0';

    switch (dFlags) {
    case MCI_INFO_FILE:
        if (!pwd)
            return MCIERR_UNSUPPORTED_FUNCTION;

        if (!*pwd->aszFile)
            return MCIERR_NONAPPLICABLE_FUNCTION;

        // BYTE!!CHARACTER count ??
        wcsncpy(lpInfo->lpstrReturn, pwd->aszFile, wReturnBufferLength);
        // Note: the return length may be BIGGER than the buffer provided
        wReturnLength = lstrlen(pwd->aszFile);
        break;

    case MCI_INFO_PRODUCT:
        wReturnLength = LoadString(hModuleInstance, IDS_PRODUCTNAME, lpInfo->lpstrReturn, wReturnBufferLength);
        break;

    case MCI_WAVE_OUTPUT:
        if (pwd) {
            WAVEOUTCAPS waveOutCaps;
            UINT    idOut;

            if ((pwd->idOut == WAVE_MAPPER) && ISMODE(pwd, MODE_PLAYING))
                waveOutGetID(pwd->hWaveOut, &idOut);
            else
                idOut = pwd->idOut;

            if (0 != (wErrorRet = waveOutGetDevCaps(idOut, &waveOutCaps, sizeof(WAVEOUTCAPS)))) {
                if (idOut == WAVE_MAPPER)
                    wReturnLength = LoadString(hModuleInstance, IDS_MAPPER, lpInfo->lpstrReturn, wReturnBufferLength);
                else
                    return wErrorRet;
            } else {
            wcsncpy(lpInfo->lpstrReturn, waveOutCaps.szPname, wReturnBufferLength);
                wReturnLength = lstrlen(waveOutCaps.szPname);
                wReturnLength = min(wReturnLength, wReturnBufferLength);
            }
        } else
            return MCIERR_UNSUPPORTED_FUNCTION;
        break;

    case MCI_WAVE_INPUT:
        if (pwd) {
            WAVEINCAPS  waveInCaps;
            UINT    idIn;

            if ((pwd->idIn == WAVE_MAPPER) && ISMODE(pwd, MODE_INSERT | MODE_OVERWRITE))
                waveInGetID(pwd->hWaveIn, &idIn);
            else
                idIn = pwd->idIn;
            if (0 != (wErrorRet = waveInGetDevCaps(idIn, &waveInCaps, sizeof(WAVEINCAPS)))) {
                if (idIn == WAVE_MAPPER)
                    wReturnLength = LoadString(hModuleInstance, (UINT)IDS_MAPPER, lpInfo->lpstrReturn, wReturnBufferLength);
                else
                    return wErrorRet;
            } else {
            wcsncpy(lpInfo->lpstrReturn, waveInCaps.szPname, wReturnBufferLength);
                wReturnLength = lstrlen(waveInCaps.szPname);
                wReturnLength = min(wReturnLength, wReturnBufferLength);
            }
        } else
            return MCIERR_UNSUPPORTED_FUNCTION;
        break;

    default:
        return MCIERR_FLAGS_NOT_COMPATIBLE;
    }

    lpInfo->dwRetSize = (DWORD)wReturnLength;
    if (*(lpInfo->lpstrReturn + wReturnBufferLength - 1) != '\0')
        return MCIERR_PARAM_OVERFLOW;
    return 0;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    DWORD | mwGetDevCaps |
    Respond to device capabilities command.  The function tries to
    thoroughly check the <p>dFlags<d> parameter by masking out
    unrecognized commands and comparing against the original.  It then
    makes sure that only one command is present by doing a switch() on the
    flags, and returning an error condition if some combination of flags
    is present.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   UINT | dFlags |
    Command flags.

@flag   MCI_WAVE_GETDEVCAPS_INPUTS |
    Queries the number of wave audio input devices.

@flag   MCI_WAVE_GETDEVCAPS_OUTPUTS |
    Queries the number of wave audio output devices.

@flag   MCI_GETDEVCAPS_CAN_RECORD |
    Queries whether or not recording can be done.  This depends upon if
    there are any wave audio input devices.

@flag   MCI_GETDEVCAPS_CAN_PLAY |
    Queries whether or not playback can be done.  This depends upon if
    there are any wave audio output devices.

@flag   MCI_GETDEVCAPS_CAN_SAVE |
    Queries as to whether audio can be saved.  This returns TRUE.

@flag   MCI_GETDEVCAPS_HAS_AUDIO |
    Queries as to whether the device has audio.  As this is an audio
    device, this returns TRUE.

@flag   MCI_GETDEVCAPS_USES_FILES |
    Queries as to whether the device uses file to play or record.  This
    returns TRUE.

@flag   MCI_GETDEVCAPS_COMPOUND_DEVICE |
    Queries as to whether the device can deal with compound files.  This
    returns TRUE.

@flag   MCI_GETDEVCAPS_HAS_VIDEO |
    Queries as to whether the device has video capability.  This returns
    FALSE.

@flag   MCI_GETDEVCAPS_CAN_EJECT |
    Queries as to whether the device can eject media.  This returns FALSE.

@flag   MCI_GETDEVCAPS_DEVICE_TYPE |
    Queries the type of device.  This returns the wave audio device
    string resource identifier.

@parm   <t>LPMCI_GETDEVCAPS_PARMS<d> | lpCaps |
    Capability parameters.

@rdesc  Returns zero on success, or an MCI error code.
*/

PUBLIC  DWORD PASCAL FAR mwGetDevCaps(
    PWAVEDESC   pwd,
    DWORD       dFlags,
    LPMCI_GETDEVCAPS_PARMS  lpCaps)
{
    DWORD   dRet;

    dFlags &= ~(MCI_NOTIFY | MCI_WAIT);

    if (!dFlags || !lpCaps->dwItem)
        return MCIERR_MISSING_PARAMETER;

    if ((dFlags != MCI_GETDEVCAPS_ITEM) || (lpCaps->dwItem != (lpCaps->dwItem & MCI_WAVE_CAPS_MASK)))
        return MCIERR_UNRECOGNIZED_KEYWORD;

    switch (lpCaps->dwItem) {
    case MCI_WAVE_GETDEVCAPS_INPUTS:
        lpCaps->dwReturn = cWaveInMax;
        dRet = 0L;
        break;

    case MCI_WAVE_GETDEVCAPS_OUTPUTS:
        lpCaps->dwReturn = cWaveOutMax;
        dRet = 0L;
        break;

    case MCI_GETDEVCAPS_CAN_RECORD:
        if (cWaveInMax)
            lpCaps->dwReturn = MAKELONG(TRUE, MCI_TRUE);
        else
            lpCaps->dwReturn = MAKELONG(FALSE, MCI_FALSE);
        dRet = MCI_RESOURCE_RETURNED;
        break;

    case MCI_GETDEVCAPS_CAN_PLAY:
        if (cWaveOutMax)
            lpCaps->dwReturn = MAKELONG(TRUE, MCI_TRUE);
        else
            lpCaps->dwReturn = MAKELONG(FALSE, MCI_FALSE);
        dRet = MCI_RESOURCE_RETURNED;
        break;

    case MCI_GETDEVCAPS_CAN_SAVE:
    case MCI_GETDEVCAPS_HAS_AUDIO:
    case MCI_GETDEVCAPS_USES_FILES:
    case MCI_GETDEVCAPS_COMPOUND_DEVICE:
        lpCaps->dwReturn = MAKELONG(TRUE, MCI_TRUE);
        dRet = MCI_RESOURCE_RETURNED;
        break;

    case MCI_GETDEVCAPS_HAS_VIDEO:
    case MCI_GETDEVCAPS_CAN_EJECT:
        lpCaps->dwReturn = MAKELONG(FALSE, MCI_FALSE);
        dRet = MCI_RESOURCE_RETURNED;
        break;

    case MCI_GETDEVCAPS_DEVICE_TYPE:
        lpCaps->dwReturn = MAKELONG(MCI_DEVTYPE_WAVEFORM_AUDIO, MCI_DEVTYPE_WAVEFORM_AUDIO);
        dRet = MCI_RESOURCE_RETURNED;
        break;

    default:
        dRet = MCIERR_UNSUPPORTED_FUNCTION;
        break;
    }
    return dRet;
}

/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\midimap\clisti.asm ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  CLISTI.ASM - Enter/leave critical sections
;
; Created:  18 April 1994
; Author:   Jim Geist [jimge]
;
; Copyright (c) 1984-1995 Microsoft Corporation
;
;-----------------------------------------------------------------------;

        ?PLM    = 1
        ?WIN    = 0
        PMODE   = 1

        .xlist
        include cmacros.inc
        .list

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
        assumes cs, CodeSeg

        public  EnterCrit
EnterCrit       proc    near
                pop     ax                      ; Near return address
                pushf                           ; Save flags
                cli                             ; Interrupts off
                push    ax                      ; Near return address
                ret                             ; and return
EnterCrit       endp

        public  LeaveCrit
LeaveCrit       proc    near
                pop     ax                      ; Near return address
                pop     bx                      ; Flag state
                test    bx, 0200h               ; Interrupts should be on?
                jz      short @F                ; Nope
                sti                             ; Yep
@@:             push    ax                      ; Near return address
                ret                             ; and return
LeaveCrit       endp

sEnd    CodeSeg

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\midimap\cookfix.c ===
/**********************************************************************

  Copyright (c) 1992-1995 Microsoft Corporation

  cookfix.c

  DESCRIPTION:
    Fixed code for doing output mapping. KEEP THE SIZE OF THIS CODE
    TO A MINIMUM!

  HISTORY:
     03/04/94       [jimge]        created.

*********************************************************************/

#include "preclude.h"
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "idf.h"

#include "midimap.h"
#include "debug.h"

/***************************************************************************
  
   @doc internal
  
   @api void | SendNextCookedBuffer | Sends the next cooked buffer on a
    mapper handle.

   @parm PINSTANCE | pinstance | Pointer to an open instance.
   
***************************************************************************/
void FNGLOBAL SendNextCookedBuffer(
    PINSTANCE           pinstance)
{
    PCOOKSYNCOBJ        pcooksyncobj;
    UINT                idx;
    LPMIDIHDR           lpmh;
    MMRESULT            mmr;
    
    pcooksyncobj = (PCOOKSYNCOBJ)QueueGet(&pinstance->qCookedHdrs);
    if (NULL == pcooksyncobj)
    {
        DPF(1, TEXT ("SendNextCookedBuffer: No more buffers."));
        return;
    }

    lpmh = pcooksyncobj->lpmh;
    pcooksyncobj->cSync = 0;
    
    for (idx = 0; idx < pcooksyncobj->cLPMH; ++idx)
    {
        ++pcooksyncobj->cSync;
        
        mmr = midiOutPolyMsg(
                             (HMIDI)(HIWORD(lpmh->dwUser)),
                             lpmh,
                             sizeof(*lpmh));

        if (MMSYSERR_NOERROR != mmr)
        {
            --pcooksyncobj->cSync;
            DPF(1, TEXT ("midiOutPolyMsg *FAILED* mmr=%08lX"), (DWORD)mmr);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\midimap\config.c ===
/**********************************************************************

  Copyright (c) 1992-1999 Microsoft Corporation

  config.c

  DESCRIPTION:
    Code to configure the mapper when a device is added or deleted.

  HISTORY:
     02/21/93       [jimge]        created.

*********************************************************************/

#include "preclude.h"
#include <windows.h>
#include <winerror.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <mmddk.h>
#include <regstr.h>
#include "idf.h"

#include <memory.h>
#include <ctype.h>

#include "midimap.h"
#include "debug.h"




//=========================== Globals ======================================
//
static TCHAR BCODE gszMidiMapKey[]   =
    REGSTR_PATH_MULTIMEDIA TEXT ("\\MIDIMap");

static TCHAR BCODE gszSchemeListKey[] =
    REGSTR_PATH_PRIVATEPROPERTIES TEXT ("\\MIDI\\Schemes");

static TCHAR BCODE gsz2Keys[] =
    TEXT ("%s\\%s");  

static TCHAR BCODE gszMediaRsrcKey[] =
    REGSTR_PATH_MEDIARESOURCES TEXT ("\\MIDI");

static TCHAR BCODE gszDriverKey[] =
    REGSTR_PATH_MEDIARESOURCES TEXT ("\\MIDI\\%s");

#ifdef DEBUG
static TCHAR BCODE gszSystemINI[]        = TEXT ("system.ini");
static TCHAR BCODE gszMIDIMapSect[]      = TEXT ("MIDIMAP");
static TCHAR BCODE gszRunOnceValue[]     = TEXT ("RunOnce");
static TCHAR BCODE gszBreakOnConfigValue[]=TEXT ("BreakOnConfig");
#endif

static TCHAR BCODE gszUseSchemeValue[]   = TEXT ("UseScheme");
static TCHAR BCODE gszCurSchemeValue[]   = TEXT ("CurrentScheme");
static TCHAR BCODE gszCurInstrValue[]    = TEXT ("CurrentInstrument");
static TCHAR BCODE gszChannelsValue[]    = TEXT ("Channels");
static TCHAR BCODE gszPortValue[]        = TEXT ("Port");
static TCHAR BCODE gszDefinitionValue[]  = TEXT ("Definition");
static TCHAR BCODE gszFriendlyNameValue[]= TEXT ("FriendlyName");
static TCHAR BCODE gszDescription[]      = TEXT ("Description");
static TCHAR BCODE gszAutoSchemeValue[]  = TEXT ("AutoScheme");
static TCHAR BCODE gszDefaultFile[]      = TEXT ("<internal>");
static TCHAR BCODE gszDefaultInstr[]     = TEXT ("Default");
static TCHAR BCODE gszDoRunOnce[]        = TEXT ("RunDll32.exe mmsys.cpl,RunOnceSchemeInit");
static TCHAR BCODE gszSetupKey[]         = TEXT ("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup");
static TCHAR BCODE gszMachineDir[]       = TEXT ("WinDir");
static TCHAR BCODE gszConfigDir[]        = TEXT ("config\\");

extern BOOL        gfReconfigured;

//=========================== Prototypes ===================================
//
PRIVATE void FNLOCAL ConfigureFromToast(
    void);

PRIVATE void FNLOCAL ConfigureScheme(
    LPTSTR              pstrScheme);

PRIVATE void FNLOCAL ConfigureInstrument(
    LPTSTR              pstrInstr);                                    

PRIVATE UINT FNLOCAL AddDevice(
    WORD                wChannelMask,
    UINT                uDeviceID,
    LPTSTR              pstrDefinition);

#define PSIK_INVALID            ((UINT)(-1))

PRIVATE PPORT FNLOCAL GetPort(
    UINT                uDeviceID);                              

PRIVATE void FNLOCAL PortAddRef(
    PPORT               pport);

PRIVATE void FNLOCAL PortReleaseRef(
    PPORT               pport);

PRIVATE PINSTRUMENT FNLOCAL GetInstrument(
    LPTSTR              pstrFilename,                                  
    LPTSTR              pstrInstrument);

PRIVATE void FNLOCAL InstrumentAddRef(
    PINSTRUMENT         pinstrument);

PRIVATE void FNLOCAL InstrumentReleaseRef(
    PINSTRUMENT         pinstrument);

PRIVATE PINSTRUMENT FNLOCAL LoadInstrument(
    LPTSTR              pstrFileName,
    LPTSTR              pstrInstrument);

PRIVATE PINSTRUMENT FNLOCAL MakeDefInstrument(
    void);

#define GDID_INVALID        ((UINT)(-2))

PRIVATE BOOL FNLOCAL GetIDFDirectory(
    LPTSTR                  pszDir,
    DWORD                   cchDir);

PRIVATE VOID FNLOCAL ValidateChannelTypes(
    VOID);

//extern UINT FAR PASCAL wmmMIDIRunOnce();

#if 1
/***************************************************************************

    @doc internal

    @api void | Configure | Configure the mapper.

    @comm

     Uses new Windowws 2000 message to winmm to get the
     current preferred MIDI ID.
      
***************************************************************************/
BOOL FNGLOBAL Configure(DWORD fdwUpdate)
{
    UINT MidiOutId;
    DWORD dwFlags;
    MMRESULT mmr;

    gfReconfigured = TRUE;

    mmr = midiOutMessage((HMIDIOUT)(UINT_PTR)MIDI_MAPPER, DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR)&MidiOutId, (DWORD_PTR)&dwFlags);
    if (!mmr && (MIDI_MAPPER != MidiOutId)) AddDevice(ALL_CHANNELS, MidiOutId, TEXT("\0"));
    return FALSE;
}

#else
// Obsolete in Windows 2000:
/***************************************************************************

    @doc internal

    @api void | Configure | Configure the mapper.

    @comm

     Read HKCU\...\UseScheme to determine if we're loading a scheme or
      instrument.

     Read either HKCU\...\CurrentScheme or HKCU\...\CurrentInstrument
      and call the correct configuration routine.

***************************************************************************/
BOOL FNGLOBAL Configure(
    DWORD               fdwUpdate)
{
    HKEY                hKeyMidiMap     = NULL;
    HKEY                hKeySchemes     = NULL;
    LPTSTR              pstrValueStr    = NULL;
    DWORD               cbValueStr;
    DWORD               cbValue;
    DWORD               dwType;
    DWORD               dwUseScheme;
    DWORD               dwAutoScheme;
    MMRESULT            mmr;
    MIDIOUTCAPS         moc;
#ifdef DEBUG
    DWORD               dwBreak;
    DWORD               dwRunOnce;
#endif
    BOOL                fRanRunOnce = FALSE;

    static TCHAR        szConfigErr[256];
    static TCHAR        szConfigErrMsg[256];
    
    DPF(2, TEXT ("--- Configure start ---"));

#ifdef DEBUG
    dwBreak = (DWORD)GetPrivateProfileInt(gszMIDIMapSect, gszBreakOnConfigValue, 0, gszSystemINI);
    if (dwBreak)
	DebugBreak();
#endif

    SET_CONFIGERR;
    SET_NEEDRUNONCE;

    // Rest of configuration assumes we're starting from total scratch
    //
    assert(NULL == gpportList);
    assert(NULL == gpinstrumentList);
    
#ifdef DEBUG
    dwRunOnce = (DWORD)GetPrivateProfileInt(gszMIDIMapSect, gszRunOnceValue, 1, gszSystemINI);
#endif

		// Create List of Active MIDIOUT devices
    if (!mdev_Init())
    {
	DPF(1, TEXT ("Could not mdev_Init"));
	goto Configure_Cleanup;
    }

    if (ERROR_SUCCESS != RegOpenKey(HKEY_CURRENT_USER,
				    gszMidiMapKey,
				    &hKeyMidiMap))
    {
	DPF(1, TEXT ("Could not open MidiMap"));
	goto Configure_Cleanup;
    }

    cbValueStr = max(CB_MAXSCHEME, CB_MAXINSTR) * sizeof(TCHAR);
    if (NULL == (pstrValueStr = (LPTSTR)LocalAlloc(LPTR, (UINT)cbValueStr)))
    {
	DPF(1, TEXT ("No memory for pstrValueStr"));
	goto Configure_Cleanup;
    }

    // Get Scheme Values
#if 0
    cbValue = sizeof(dwUseScheme);
    if (ERROR_SUCCESS != RegQueryValueEx(hKeyMidiMap,
					 gszUseSchemeValue,
					 NULL,
					 &dwType,
					 (LPSTR)&dwUseScheme,
					 &cbValue))
    {
	DPF(1, TEXT ("Missing UseScheme; assuming scheme"));
	dwUseScheme = 1;
    }
#else
    // Windows 2000 does not support schemes.
    dwUseScheme = 0;
#endif

    cbValue = sizeof(dwAutoScheme);
    if (ERROR_SUCCESS != RegQueryValueEx(hKeyMidiMap,
					 gszAutoSchemeValue,
					 NULL,
					 &dwType,
					 (LPSTR)&dwAutoScheme,
					 &cbValue))
    {
	DPF(1, TEXT ("Missing AutoScheme; assuming TRUE"));
	dwAutoScheme = 1;
    }

    if (dwUseScheme)
    {
			// Get Scheme Name
	cbValue = cbValueStr;
	if (ERROR_SUCCESS != RegQueryValueEx(hKeyMidiMap,
					     gszCurSchemeValue,
					     NULL,
					     &dwType,
					     (LPSTR)pstrValueStr,
					     &cbValue))
	{
	    DPF(1, TEXT ("Could not read scheme"));

	    // Couldn't read scheme? Let's try to get the first one
	    //

	    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,
					    gszSchemeListKey,
					    &hKeySchemes))
	    {
		if (ERROR_SUCCESS == RegEnumKey(hKeySchemes,
						0,
						pstrValueStr,
						cbValueStr))
		{
		    CLR_CONFIGERR;
		    DPF(1, TEXT ("Using default scheme %s"), (LPTSTR)pstrValueStr);
		}
		else
		{
		    DPF(1, TEXT ("Could not enum schemes key"));
		}
	    }
	    else
	    {
		DPF(1, TEXT ("Could not open [%s]"), (LPTSTR)gszSchemeListKey);
	    }
	}
	else
	{
	    CLR_CONFIGERR;
	    CLR_NEEDRUNONCE;
	}
	
	if (!IS_CONFIGERR)
	{
	    DPF(1, TEXT ("Using scheme [%s]"), (LPTSTR)pstrValueStr);
	    ConfigureScheme(pstrValueStr);
	}
    }
    else
    {
	// Not using scheme -- try to configure via instrument description
	//
	cbValue = cbValueStr;
	if (ERROR_SUCCESS == RegQueryValueEx(hKeyMidiMap,
					     gszCurInstrValue,
					     NULL,
					     &dwType,
					     (LPSTR)pstrValueStr,
					     &cbValue))
	{
	    CLR_CONFIGERR;
	    CLR_NEEDRUNONCE;
	    
	    DPF(1, TEXT ("Using instrument [%s]"), (LPTSTR)pstrValueStr);
	    ConfigureInstrument(pstrValueStr);

	    // If we're autoconfigure and the device we're using isn't
	    // marked as an internal synth and we've added a new device,
	    // do the runonce in case we can find an internal synth
	    //

	    if (dwAutoScheme && ((fdwUpdate & 0xFFFF) == DRV_F_ADD))
	    {
		//assert(gpportList->pNext == NULL);
		if (gpportList == NULL)
		{
		   DPF(0, TEXT ("Configure: gpportList = NULL"));
		   goto Configure_Cleanup;
		}

		DPF(1, TEXT ("AutoScheme && DRV_F_ADD"));

		mmr = midiOutGetDevCaps(gpportList->uDeviceID,
					&moc,
					sizeof(moc));

		if (MMSYSERR_NOERROR != mmr ||
		    MOD_MIDIPORT == moc.wTechnology)
		{
		    UINT        cDev;
		    UINT        idxDev;

		    DPF(1, TEXT ("Bogus or internal"));

		    cDev = midiOutGetNumDevs();
		    for (idxDev = 0; idxDev < cDev; ++idxDev)
			if (MMSYSERR_NOERROR == midiOutGetDevCaps(
			    idxDev,
			    &moc,
			    sizeof(moc)) &&
			    MOD_MIDIPORT != moc.wTechnology)
			{
			    DPF(1, TEXT ("AutoConf: External or bogus port; RunOnce!"));
			    CLR_DONERUNONCE;
			    SET_NEEDRUNONCE;
			    break;
			}
		}
	    }
	}
    }

    // In all cases, if we are autoscheme and there is a new driver,
    // do runonce.
    //

    if (dwAutoScheme && mdev_NewDrivers())
    {
	DPF(1, TEXT ("New driver(s); force runonce."));
	CLR_DONERUNONCE;
	SET_NEEDRUNONCE;
    }
    
Configure_Cleanup:

    // Safe to call this even if mdev_Init() failed
    //
    mdev_Free();
    
    if (IS_CONFIGERR)
    {
	ConfigureFromToast();
    }

    if (IS_NEEDRUNONCE && !IS_DONERUNONCE)
    {
#ifdef DEBUG
	if (dwRunOnce)
	{
#endif
	    DPF(2, TEXT ("Configuration inconsistent -- calling RunOnce"));
	    
//            WinExec(gszDoRunOnce, 0);

	    SET_INRUNONCE;
	    wmmMIDIRunOnce();
	    CLR_INRUNONCE;
	    
	    fRanRunOnce = TRUE;

#ifdef DEBUG
	}
	else
	{
	    DPF(1, TEXT ("Debug and RunOnce==0, not executing RunOnce"));
	}
#endif

	SET_DONERUNONCE;
    }

    ValidateChannelTypes();

    // Call our own midiOutGetDevCaps handler to walk the new list of
    // ports and figure out what we support
    //
    modGetDevCaps(&moc, sizeof(moc));
    
    DPF(2, TEXT ("--- Configure end ---"));
    
    if (NULL != pstrValueStr)   
       LocalFree((HGLOBAL)pstrValueStr);
    
    if (NULL != hKeyMidiMap)    
       RegCloseKey(hKeyMidiMap);
    
    if (NULL != hKeySchemes)    
       RegCloseKey(hKeySchemes);

    return fRanRunOnce;
}
#endif

void FNGLOBAL Unconfigure(
    void)
{
    PCHANNEL                pchannel;
    UINT                    idxChannel;
    UINT                    idx2;
    
    for (idxChannel = 0; idxChannel < MAX_CHANNELS; idxChannel++)
    {
	if (NULL != (pchannel = gapChannel[idxChannel]))
	{
	    if (pchannel->pport)
	    {
		for (idx2 = idxChannel+1; idx2 < MAX_CHANNELS; idx2++)
		    if (NULL != gapChannel[idx2] &&
			pchannel->pport == gapChannel[idx2]->pport)
			gapChannel[idx2]->pport = NULL;

		PortReleaseRef(pchannel->pport);
	    }
	    
	    if (pchannel->pinstrument)
		InstrumentReleaseRef(pchannel->pinstrument);
	    
	    LocalFree((HLOCAL)pchannel);
	    gapChannel[idxChannel] = NULL;
	}
    }
}

/***************************************************************************
  
   @doc internal
  
   @api void | ConfigureFromToast | Build a configuration to use a 1:1 mapping
    of the first internal driver we can find. We use this only if the registry
    is totally blown and we have no other choice.

***************************************************************************/
PRIVATE void FNLOCAL ConfigureFromToast(
    void)
{
    UINT WavetableMidiOutId;
    UINT OtherMidiOutId;
    UINT FmMidiOutId;
    UINT SoftwareMidiOutId;
    UINT ExternalMidiOutId;
    UINT MidiOutId;
    UINT cMidiOutId;
    MIDIOUTCAPS moc;
    
    DPF(1, TEXT ("ConfigureFromToast()"));

    CLR_CONFIGERR;
    
    // In case there's any partial junk leftover
    Unconfigure();

    //
    //
    //
    WavetableMidiOutId = (-1);
    OtherMidiOutId = (-1);
    FmMidiOutId = (-1);
    SoftwareMidiOutId = (-1);
    ExternalMidiOutId = (-1);

    cMidiOutId = midiOutGetNumDevs();
    if (0 != cMidiOutId)
    {
	for (MidiOutId = 0; MidiOutId < cMidiOutId; MidiOutId++)
	{
	    if (!midiOutGetDevCaps(MidiOutId, &moc, sizeof(moc)))
	    {
		if (MOD_SWSYNTH == moc.wTechnology &&
		    MM_MSFT_WDMAUDIO_MIDIOUT == moc.wPid &&
		    MM_MICROSOFT == moc.wMid)
		{
		    SoftwareMidiOutId = MidiOutId;
		} else if (MOD_FMSYNTH == moc.wTechnology) {
		    FmMidiOutId = MidiOutId;
		} else if (MOD_MIDIPORT == moc.wTechnology) {
		    ExternalMidiOutId = MidiOutId;
		} else if (MOD_WAVETABLE == moc.wTechnology) {
		    WavetableMidiOutId = MidiOutId;
		} else {
		    OtherMidiOutId = MidiOutId;
		}
	    }
	}
    }

    if ((-1) != WavetableMidiOutId) MidiOutId = WavetableMidiOutId;
    else if ((-1) != SoftwareMidiOutId) MidiOutId = SoftwareMidiOutId;
    else if ((-1) != OtherMidiOutId) MidiOutId = OtherMidiOutId;
    else if ((-1) != FmMidiOutId) MidiOutId = FmMidiOutId;
    else if ((-1) != ExternalMidiOutId) MidiOutId = ExternalMidiOutId;
    else MidiOutId = (-1);

    if ((-1) == MidiOutId)
    {
	SET_CONFIGERR;
	DPF(1, TEXT (":-( Could not even find an internal device."));
	return;
    }

    DPF(1, TEXT ("CFT: Using device %u"), MidiOutId);

    if (!AddDevice(0xFFFF,
		   MidiOutId,
		   TEXT("\0")))
    {
	DPF(1, TEXT ("CFT: AddDevice failed!!!"));
	SET_CONFIGERR;
    }
}

/***************************************************************************
  
   @doc internal
  
   @api void | ConfigureScheme | Read configuration from registry and set up
    data structures.

   @parm PSTR | pstrScheme | The scheme to load. 

   @comm
   

    hkeyScheme = Open key from HKLM\...\Schemes\%scheme%

    Enumerate subkeys of Scheme -- each subkey is an alias
     GetKey of enumeration key into pstrDevKey
     GetValue of Channels= Value

     hkeyAlias = Open key from HKLM\...\Midi\%pstrDevKey%
     GetValue of Key=
     GetValue of Port=
     GetValue of File=
     GetValue of Instrument=

     If everything succeeded, add entry to configuration

***************************************************************************/
PRIVATE void FNLOCAL ConfigureScheme(
    LPTSTR              pstrScheme)
{
    UINT                cbKeyBuffer;
    LPTSTR              pstrKeyBuffer   = NULL;
    LPTSTR              pstrAlias       = NULL;
    LPTSTR              pstrDevKey      = NULL;
    LPTSTR              pstrDefinition  = NULL;

    DWORD               dwChannelMask;
    DWORD               dwType;
    DWORD               cbValue;
    DWORD               idxEnumKey;
    LPTSTR              pstrMMDevKey;

    UINT                uChannels;
    UINT                uTotalChannels  = 0;
    UINT                uDeviceID;

    BOOL                fSuccess;


    HKEY                hkeyScheme      = NULL;
    HKEY                hkeyAlias       = NULL;

    // Assume something will fail
    // 
    SET_CONFIGERR;
    
    cbKeyBuffer = max(sizeof(gszSchemeListKey) + 1 + CB_MAXSCHEME, sizeof(gszDriverKey) + CB_MAXALIAS);
    
    if (NULL == (pstrKeyBuffer = (LPTSTR)LocalAlloc(LPTR, cbKeyBuffer)) ||
	NULL == (pstrAlias     = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * CB_MAXALIAS)) ||
	NULL == (pstrDevKey    = (LPTSTR)LocalAlloc(LPTR, CB_MAXDEVKEY)) ||
	NULL == (pstrDefinition= (LPTSTR)LocalAlloc(LPTR, CB_MAXDEFINITION)))
    {
	DPF(1, TEXT ("No memory to read configuration!"));
	goto Configure_Cleanup;
    }

    wsprintf(pstrKeyBuffer, gsz2Keys, (LPTSTR)gszSchemeListKey, (LPSTR)pstrScheme);

    // NOTE: RegOpenKeyEx does not exist in Chicago
    //
    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
				    pstrKeyBuffer,
				    &hkeyScheme))
    {
	SET_NEEDRUNONCE;
	DPF(1, TEXT ("Could not open Schemes\\%s"), (LPTSTR)pstrScheme);
	goto Configure_Cleanup;
    }

    // NOTE: RegEnumKeyEx does not exist in Chicago
    //
    idxEnumKey = 0;
    while (ERROR_SUCCESS == RegEnumKey(hkeyScheme,
				       idxEnumKey++,
				       pstrAlias,
				       CB_MAXALIAS))
    {
	DPF(1, TEXT ("enum scheme component %lu"), idxEnumKey);
	
	if (ERROR_SUCCESS == RegOpenKey(hkeyScheme,
					pstrAlias,
					&hkeyAlias))
	{
	    cbValue = CB_MAXDEVKEY;
	    fSuccess = (ERROR_SUCCESS == RegQueryValue(hkeyAlias,
						       NULL,
						       pstrDevKey,
						       &cbValue));

	    if (!fSuccess)
	    {
		DPF(1, TEXT ("Failure after hkeyAlias"));

		SET_NEEDRUNONCE;
		goto Configure_Cleanup;
	    }

	    DPF(2, TEXT ("hkeyAlias key=%s"), (LPTSTR)pstrDevKey);


	    cbValue = sizeof(dwChannelMask);
	    if (ERROR_SUCCESS != RegQueryValueEx(hkeyAlias,
						 gszChannelsValue,
						 NULL,
						 &dwType,
						 (LPBYTE)&dwChannelMask,   
						 &cbValue))
	    {
		DPF(1, TEXT ("wChannelMask undefined -- using all channels"));
		dwChannelMask = 0xFFFF;
		SET_NEEDRUNONCE;
	    }

	    RegCloseKey(hkeyAlias);
	    hkeyAlias = NULL;
	    
	    if (fSuccess)
	    {
		wsprintf(pstrKeyBuffer, gszDriverKey, (LPTSTR)pstrDevKey);
		if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,
						pstrKeyBuffer,
						&hkeyAlias))
		{
		    pstrMMDevKey = pstrDevKey;

		    while (*pstrMMDevKey && *pstrMMDevKey != TEXT ('\\'))
			++pstrMMDevKey;

		    *pstrMMDevKey = TEXT ('\0');

		    DPF(1, TEXT ("pstrMMDevKey %s"), (LPTSTR)pstrDevKey);

		    cbValue = CB_MAXDEFINITION * sizeof (TCHAR);
		    if (ERROR_SUCCESS != RegQueryValueEx(hkeyAlias,
							 gszDefinitionValue,
							 NULL,
							 &dwType,
							 (LPSTR)pstrDefinition,
							 &cbValue))
		    {
			DPF(1, TEXT ("pstrDefinition undefined -- using 1:1 mapping"));
			*pstrDefinition = TEXT ('\0');
		    }

		    uDeviceID = mdev_GetDeviceID(pstrDevKey);

		    if (NO_DEVICEID != uDeviceID)
		    {
			// Success!!!! Add the entry
			//
			DPF(1, TEXT ("AddDevice("));
			DPF(1, TEXT ("  dwChannelMask=%08lX,"), dwChannelMask);
			DPF(1, TEXT ("  uDeviceID=%u,"), uDeviceID);
			DPF(1, TEXT ("  pstrDefinition=%s)"), (LPSTR)pstrDefinition);

			if (0 == (uChannels = AddDevice(
			    (WORD)dwChannelMask,
			    uDeviceID,
			    pstrDefinition)))
			{
			    SET_CONFIGERR;
			    goto Configure_Cleanup;
			}

			uTotalChannels += uChannels;
		    }
		    
		    RegCloseKey(hkeyAlias);
		    hkeyAlias = NULL;
		}
		else
		{
		    DPF(1, TEXT ("Could not open Aliases\\%s"), (LPTSTR)pstrAlias);
		}
	    }
	}
	else
	{
	    DPF(1, TEXT ("Could not open Schemes\\%s"), (LPTSTR)pstrAlias);
	}
    }

    // Fall-through is only path to success.
    //
    if (uTotalChannels)
    {
	CLR_CONFIGERR;
    }
    else
    {
	DPF(1, TEXT ("No channels configured; we're toast!"));
	SET_NEEDRUNONCE;
    }
					 
Configure_Cleanup:
    if (NULL != pstrKeyBuffer) 
	LocalFree((HLOCAL)pstrKeyBuffer);

    if (NULL != pstrAlias)     
	LocalFree((HLOCAL)pstrAlias);

    if (NULL != pstrDevKey)    
	LocalFree((HLOCAL)pstrDevKey);

    if (NULL != pstrDefinition)
	LocalFree((HLOCAL)pstrDefinition);

    if (NULL != hkeyScheme)    
	RegCloseKey(hkeyScheme);

    if (NULL != hkeyAlias)     
       RegCloseKey(hkeyAlias);
}

/***************************************************************************
  
   @doc internal
  
   @api void | ConfigureInstrument | Read configuration from registry and set up
    data structures.

   @parm PSTR | pstrInstrument | The instrument to load. 

   @comm

***************************************************************************/
PRIVATE void FNLOCAL ConfigureInstrument(
    LPTSTR                pstrInstr)
{
    HKEY                hKeyMediaRsrc   = NULL;
    LPTSTR              pstrKeyBuffer   = NULL;
    LPTSTR              pstrDevKey      = NULL;
    LPTSTR              pstrDefinition  = NULL;
#ifndef WINNT
    LPTSTR              pstrSrc;
    LPTSTR              pstrDst;
#endif // End WINNT

    DWORD               dwType;
    DWORD               cbValue;
    UINT                cbKeyBuffer;
    UINT                uDeviceID;
    
    SET_CONFIGERR;
    
    cbKeyBuffer = max(sizeof(gszSchemeListKey) + 1 + CB_MAXSCHEME, sizeof(gszDriverKey) + CB_MAXALIAS);
    if (NULL == (pstrKeyBuffer = (LPTSTR)LocalAlloc (LPTR, cbKeyBuffer * sizeof(TCHAR))) ||
	NULL == (pstrDefinition= (LPTSTR)LocalAlloc (LPTR, CB_MAXDEFINITION * sizeof(TCHAR))) ||
	NULL == (pstrDevKey    = (LPTSTR)LocalAlloc (LPTR, CB_MAXDEVKEY * sizeof(TCHAR))))
    {
	DPF(1, TEXT ("No memory to read configuration!"));
	goto Configure_Cleanup;
    }

#ifdef WINNT
	lstrcpy (pstrDevKey, pstrInstr);
#else

    pstrSrc = pstrInstr;
    pstrDst = pstrDevKey;

    while (*pstrSrc && *pstrSrc != TEXT ('\\'))
	*pstrDst++ = *pstrSrc++;

    *pstrDst = TEXT ('\0');
#endif // WINNT 

    wsprintf(pstrKeyBuffer, gszDriverKey, (LPTSTR)pstrInstr);

    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
				    pstrKeyBuffer,
				    &hKeyMediaRsrc))
    {   
	DPF(1, TEXT ("Could not open DevKey %s!"), (LPTSTR)pstrKeyBuffer);
	SET_NEEDRUNONCE;
	goto Configure_Cleanup; 
    }

    cbValue = CB_MAXDEFINITION;
    if (ERROR_SUCCESS != RegQueryValueEx(hKeyMediaRsrc,
					 gszDefinitionValue,
					 NULL,
					 &dwType,
					 (LPSTR)pstrDefinition,
					 &cbValue))
    {
	DPF(1, TEXT ("pstrDefinition undefined -- using 1:1 mapping"));
	*pstrDefinition = TEXT ('\0');
    }

    uDeviceID = mdev_GetDeviceID(pstrDevKey);
    if (NO_DEVICEID != uDeviceID)
    {
	// Success!!!! Add the entry
	//
	DPF(1, TEXT ("AddDevice("));
	DPF(1, TEXT ("  uDeviceID=%u"), uDeviceID);
	DPF(1, TEXT ("  pstrDefinition=%s)"), (LPTSTR)pstrDefinition);

	if (0 != AddDevice(ALL_CHANNELS,
			   uDeviceID,
			   pstrDefinition))
	{   
	    CLR_CONFIGERR;
	}
    }
    
Configure_Cleanup:
    if (NULL != pstrDefinition) 
	LocalFree((HLOCAL)pstrDefinition);

    if (NULL != pstrKeyBuffer)  
	LocalFree((HLOCAL)pstrKeyBuffer);

    if (NULL != pstrDevKey)     
	LocalFree((HLOCAL)pstrDevKey);

    if (NULL != hKeyMediaRsrc)  
	RegCloseKey(hKeyMediaRsrc);
}

PRIVATE UINT FNLOCAL AddDevice(
    WORD                wChannelMask,
    UINT                uDeviceID,
    LPTSTR              pstrDefinition)
{
    UINT                uRet            = 0;
    
    WORD                wChannelBit;
    WORD                wAddedMask      = 0;
    UINT                idxChannel;
    UINT                cbDefinition;
    PPORT               pport           = NULL;
    PINSTRUMENT         pinstrument     = NULL;
    PCHANNEL            pchannel;

    LPTSTR              pstrFile        = NULL;
    LPTSTR              pstrInstrument  = NULL;

    DPF(1, TEXT ("AddDevice: uDeviceID %u pstrDefinition %s"),
	uDeviceID,
	(LPTSTR)pstrDefinition);

    // Parse definition
    //
    // pstrFile -> filename
    // pstrInstrument -> instrument (empty string if none specified)
    //
    cbDefinition = lstrlen(pstrDefinition);

    if (cbDefinition)
    {
	pstrFile = pstrDefinition;

	if (pstrDefinition[cbDefinition-1] == '>')
	{
	    pstrInstrument = pstrDefinition + cbDefinition - 1;
	    *pstrInstrument-- = TEXT ('\0');

	    while (pstrInstrument != pstrDefinition && *pstrInstrument != TEXT ('<'))
		pstrInstrument--;

	    if (pstrInstrument == pstrDefinition)
	    {
		DPF(1, TEXT ("Bogus definition [%s]"), (LPTSTR)pstrDefinition);
		goto Cleanup_AddDevice;
	    }

	    *pstrInstrument++ = TEXT ('\0');
	}
	else
	{
	    pstrInstrument = pstrDefinition + cbDefinition;
	}

	DPF(1, TEXT ("AddDevice: pstrFile [%s]"), (LPTSTR)pstrFile);
	DPF(1, TEXT ("AddDevice: pstrInstrument: [%s]"), (LPTSTR)pstrInstrument);
    
	pinstrument = GetInstrument(pstrFile, pstrInstrument);
	if (NULL == pinstrument)
	{
	    DPF(1, TEXT ("Config Err: Could not load instrument!"));
	    goto Cleanup_AddDevice;
	}
    }
    else
    {
	DPF(1, TEXT ("Using default instrument"));
	// No definition given; use default instrument
	//
	pinstrument = NULL;
    }
    
    // Ok, now iterate through and try to allocate structures
    //
    pport = GetPort(uDeviceID);
    if (NULL == pport)
    {
	DPF(1, TEXT ("Config Err: No memory for port structure!"));
	goto Cleanup_AddDevice;
    }

    PortAddRef(pport);

    
    wChannelBit = 1; 
    for (idxChannel = 0; idxChannel < MAX_CHANNELS; idxChannel++, wChannelBit <<= 1)
    {
	if (wChannelMask & wChannelBit)
	{
	    if (gapChannel[idxChannel])
	    {
		DPF(1, TEXT ("Config Err: Attempt to overload channel!"));
		uRet = 0;
		goto Cleanup_AddDevice;
	    }
	    
	    pchannel = (PCHANNEL)LocalAlloc(LPTR, sizeof(CHANNEL));
	    if (NULL == pchannel)
	    {
		uRet = 0;
		DPF(1, TEXT ("Config Err: LocalAlloc() failed on PCHANNEL"));
		goto Cleanup_AddDevice;
	    }

	    pchannel->fwChannel     = 0;
	    pchannel->pport         = pport;
	    pchannel->uChannel      = idxChannel;       // MSG to change this???
	    pchannel->pinstrument   = pinstrument;
	    pchannel->pbPatchMap    = NULL;
	    if (pinstrument && DRUM_CHANNEL != idxChannel)
		pchannel->pbPatchMap = pinstrument->pbPatchMap;

	    // Port owns mask of channels which are used on itself
	    //
	    pport->wChannelMask |= (1 << idxChannel);

	    if (!pinstrument)
		pchannel->pbKeyMap = NULL;
	    else if (idxChannel != DRUM_CHANNEL)
		pchannel->pbKeyMap = pinstrument->pbGeneralKeyMap;
	    else
		pchannel->pbKeyMap = pinstrument->pbDrumKeyMap;

	    if (pinstrument)
		InstrumentAddRef(pinstrument);

	    gapChannel[idxChannel] = pchannel;
	    wAddedMask |= wChannelBit;

	    ++uRet;
	}
    }

Cleanup_AddDevice:

    if (!uRet)
    {
	DPF(1, TEXT ("AddDevice: gfConfigErr set!!!!"));
	// Something failed! Clean up everything we touched.
	//
	if (NULL != pport)
	{
	    PortReleaseRef(pport);

	    if (NULL != pinstrument)
	    {
		InstrumentAddRef(pinstrument);

		wChannelBit = 1;
		for (idxChannel = 0; idxChannel < MAX_CHANNELS; idxChannel++)
		{
		    if (wAddedMask & wChannelBit)
		    {
			InstrumentReleaseRef(pinstrument);

			LocalFree((HLOCAL)gapChannel[idxChannel]);
			gapChannel[idxChannel] = NULL;
		    }
		    wChannelBit <<= 1;
		}

		InstrumentReleaseRef(pinstrument);
	    }
	}
    }
    
    return uRet;
}

/***************************************************************************
  
   @doc internal
  
   @api PPORT | GetPort | Finds the port structure associated with
    the given device key and device ID, creating a blank port
    structure if one is not found.

   @parm UINT | uDeviceID | The device ID of the port to get
   
   @rdesc The PPORT describing the port or NULL if there was no port
    found and no memory to create a new port structure.
    
***************************************************************************/
PRIVATE PPORT FNLOCAL GetPort(
    UINT                uDeviceID)                              
{

    PPORT               pport;

    for (pport = gpportList; pport; pport = pport->pNext)
	if (pport->uDeviceID == uDeviceID)
	    break;

    if (NULL == pport)
    {
	pport = (PPORT)LocalAlloc(LPTR, sizeof(PORT));
	if (NULL != pport)
	{
	    pport->cRef         = 0;
	    pport->fwPort       = 0;
	    pport->wChannelMask = 0;
	    pport->uDeviceID    = uDeviceID;
	    pport->hmidi        = (HMIDIOUT)NULL;

	    pport->pNext = gpportList;
	    gpportList = pport;

	    ++gcPorts;
	}
    }
    else
    {
	DPF(1, TEXT ("Out of memory trying to create pport for device ID %u"),
	    (UINT)uDeviceID);
    }

    return pport;
}

PRIVATE void FNLOCAL PortAddRef(
    PPORT               pport)                                  
{
    ++pport->cRef;
}

PRIVATE void FNLOCAL PortReleaseRef(
    PPORT               pport)                                  
{
    PPORT               pportPrev;
    PPORT               pportCurr;

    assert(NULL == pport->hmidi);
    
    if (0 == --pport->cRef)
    {
	pportPrev = NULL;
	pportCurr = gpportList;
	
	while (pportCurr)
	{
	    if (pport == pportCurr)
		break;


	    pportPrev = pportCurr;
	    pportCurr = pportCurr->pNext;
	}

	if (pportCurr)
	{
	    if (pportPrev)
		pportPrev->pNext = pport->pNext;
	    else
		gpportList = pport->pNext;
	}
	
	LocalFree((HLOCAL)pport);
    }
}

/***************************************************************************
  
   @doc internal
  
   @api PINSTRUMENT | GetInstrument | Called to get a pointer to an instrument
    structure. 

   @parm PSTR | pstrFilename | Filename of IDF file to use.

   @parm PSTR | pstrInstrument | Description of instrument within file to use.

   @rdesc TRUE on success.

***************************************************************************/
PRIVATE PINSTRUMENT FNLOCAL GetInstrument(
    LPTSTR                pstrFilename,                                  
    LPTSTR                pstrInstrument)                                      
{
    PINSTRUMENT         pinstrument;
    static WORD         wMask;

    // See if we already have this instrument name in our list.
    // If so, no need to load another instance of it.
    //
    for (pinstrument = gpinstrumentList; pinstrument; pinstrument = pinstrument->pNext)
    {
	
	if ((!lstrcmpi(pinstrument->pstrInstrument, pstrInstrument)) &&
	    (!lstrcmpi(pinstrument->pstrFilename, pstrFilename)))
	    break;
    }

    // Instrument not already loaded? Try to load it.
    //
    if (NULL == pinstrument)
    {
	if (lstrcmpi(gszDefaultFile, pstrFilename) ||
	    lstrcmpi(gszDefaultInstr, pstrInstrument))
	{
	    // Not default 1:1 mapping, try to load IDF
	    //
	    pinstrument = LoadInstrument(pstrFilename, pstrInstrument);
	    if (NULL == pinstrument)
		pinstrument = MakeDefInstrument();
	}
	else
	{
	    // Generate a dummy mapping
	    //
	    pinstrument = MakeDefInstrument();
	}
    }

    return pinstrument;
}

PRIVATE void FNLOCAL InstrumentAddRef(
    PINSTRUMENT         pinstrument)                                  
{
    ++pinstrument->cRef;
}

PRIVATE void FNLOCAL InstrumentReleaseRef(
    PINSTRUMENT         pinstrument)                                  
{
    PINSTRUMENT         pinstrumentPrev;
    PINSTRUMENT         pinstrumentCurr;

    if (0 == --pinstrument->cRef)
    {
	pinstrumentPrev = NULL;
	pinstrumentCurr = gpinstrumentList;
	
	while (pinstrumentCurr)
	{
	    if (pinstrument == pinstrumentCurr)
		break;


	    pinstrumentPrev = pinstrumentCurr;
	    pinstrumentCurr = pinstrumentCurr->pNext;
	}

	if (pinstrumentCurr)
	{
	    if (pinstrumentPrev)
	    {
		pinstrumentPrev->pNext = pinstrument->pNext;
	    }
	    else
	    {
		gpinstrumentList = pinstrument->pNext;
	    }
	}

	if (pinstrument->pstrFilename)
	    LocalFree((HLOCAL)pinstrument->pstrFilename);
	
	if (pinstrument->pstrInstrument)
	    LocalFree((HLOCAL)pinstrument->pstrInstrument);
	
	if (pinstrument->pbPatchMap)
	    LocalFree((HLOCAL)pinstrument->pbPatchMap);
	
	if (pinstrument->pbDrumKeyMap)
	    LocalFree((HLOCAL)pinstrument->pbDrumKeyMap);
	
	if (pinstrument->pbGeneralKeyMap)
	    LocalFree((HLOCAL)pinstrument->pbGeneralKeyMap);
	
	LocalFree((HLOCAL)pinstrument);
    }
}

/***************************************************************************
  
   @doc internal
  
   @api PINSTRUMENT | LoadInstrument | Allocate memory for and load the
    contents of an instrument description from an IDF file.

   @parm PSTR | pstrFileName | File name of the IDF to read from.

   @parm PSTR | pstrInstrument | Instrument name within the IDF file
    to load the instrument from.
    
   @comm Load the instrument and add it to the global list of instruments.

    We use GlobalAlloc here instead of LocalAlloc since this isn't done
    very often and so we don't fragment our local heap by allocating/
    deallocating lots of little pieces.

   @rdesc TRUE on success; else FALSE.
       
***************************************************************************/
PRIVATE PINSTRUMENT FNLOCAL LoadInstrument(
    LPTSTR               pstrFileName,
    LPTSTR               pstrInstrument)
{
    HMMIO               hmmio;
    MMCKINFO            chkRIFF;
    MMCKINFO            chkParent;
    MMRESULT            mmr;
    LPIDFHEADER         lpIDFheader;
    LPIDFINSTCAPS       lpIDFinstcaps;
    LPIDFCHANNELINFO    rglpChanInfo[MAX_CHANNELS];
    LPIDFCHANNELINFO    lpChanInfo;
    LPIDFKEYMAP         rglpIDFkeymap[MAX_CHAN_TYPES];
    LPIDFPATCHMAPHDR    lpIDFpatchmaphdr;
    LPIDFCHANNELHDR     lpIDFchanhdr;
    BOOL                fFound;
    BOOL                fSuccess;
    PINSTRUMENT         pinstrument = NULL;
    PCHANINIT           pchaninit;
    UINT                idx;
    LPTSTR              lpsz;
    LPTSTR              pszName  = NULL;
    UINT                cbSize;
    UINT                cchSize;
    LPSTR               pszCHAR;
    LPTSTR              pszTCHAR;
    LPTSTR              pszID    = NULL;

    // Determine if the IDF has any path elements in it.
    //
    for (lpsz = pstrFileName; *lpsz; lpsz++)
	if (TEXT ('\\') == *lpsz || TEXT ('/') == *lpsz || TEXT (':') == *lpsz)
	    break;

    if (!*lpsz)
    {
	// Just a filename; precede it with path
	//
	cbSize = CB_MAXPATH * sizeof (TCHAR);
	if (NULL == (pszName = (LPTSTR)LocalAlloc(LPTR, cbSize)))
	    return NULL;

	if (! GetIDFDirectory(pszName, CB_MAXPATH))
	    lstrcpy(pszName, TEXT (".\\"));

	lstrcat(pszName, pstrFileName);

	lpsz = (LPTSTR)pszName;
    }
    else
    {
	lpsz = pstrFileName;
    }

    DPF(1, TEXT ("LoadInstrument: %s"), lpsz);
    
    // Try to open the IDF.
    //
    if (NULL == (hmmio = mmioOpen(lpsz, NULL, MMIO_ALLOCBUF|MMIO_READ)))
    {
	DPF(1, TEXT ("LoadInstrument: Cannot open [%s]!"), (LPTSTR)pstrFileName);
	goto LoadInstrument_Cleanup;
    }

    // Descend into the main RIFF chunk
    //
    chkRIFF.fccType = mmioFOURCC('I', 'D', 'F', ' ');
    if (MMSYSERR_NOERROR != (mmr = mmioDescend(hmmio, &chkRIFF, NULL, MMIO_FINDRIFF)))
    {
	DPF(1, TEXT ("mmioDescend returned %u on RIFF chunk"), mmr);
	mmioClose(hmmio, 0);
	goto LoadInstrument_Cleanup;
    }

    // Ensure valid format and scan for the instrument the caller specified.
    //
    fFound = FALSE;
    fSuccess = FALSE;
    pinstrument = NULL;
    
    while (!fFound)
    {
	chkParent.fccType = mmioFOURCC('M', 'M', 'A', 'P');
	if (MMSYSERR_NOERROR != (mmr = mmioDescend(hmmio, &chkParent, &chkRIFF, MMIO_FINDLIST)))
	{
	    DPF(1, TEXT ("mmioDescend returned %u before [%s] found."), (UINT)mmr, (LPTSTR)pstrInstrument);
	    mmioClose(hmmio, 0);
	    goto LoadInstrument_Cleanup;
	}

	if (NULL == (lpIDFheader = ReadHeaderChunk(hmmio, &chkParent)))
	{
	    DPF(1, TEXT ("No header chunk!"));
	}
	else
	{
	    //  Copy ID single byte string to UNICODE string 
	    //
	    cchSize = lstrlenA (lpIDFheader->abInstID);
	    cbSize = cchSize + 1 * sizeof(TCHAR);
	    pszID = (LPTSTR) LocalAlloc(LPTR, cbSize);

	    pszCHAR = (LPSTR)lpIDFheader->abInstID;
	    pszTCHAR = pszID;

	    while (0 != (*pszTCHAR++ = *pszCHAR++))
	       ;

	    if (NULL == pszID)
	       {
	       mmioClose(hmmio,0);
	       goto LoadInstrument_Cleanup;
	       }

	    DPF(1, TEXT ("Header chunk found! [%s]"), (LPTSTR)pszID);

	    // NOTE: Unspecified pstrInstrument (empty string) means get
	    // first one
	    //
	    if ((!*pstrInstrument) || !lstrcmpi(pszID, pstrInstrument))
		fFound = TRUE;

#ifdef DEBUG
	    if (!*pstrInstrument)
	    {
		DPF(1, TEXT ("LoadInstrument: Asked for first; got [%s]"), (LPTSTR)pszID);
	    }
#endif

	    if (pszID)
	       LocalFree ((HLOCAL)pszID);

	    if (fFound)
	    {
		DPF(1,TEXT ("Instrument found!"));

		// Pull in the rest of the stuff we need from the IDF. Don't
		// actually try to allocate the instrument structure
		// until we're sure eveything is OK.
		//

		lpIDFinstcaps       = ReadCapsChunk(hmmio, &chkParent);
		lpIDFchanhdr        = ReadChannelChunk(hmmio, &chkParent, (LPIDFCHANNELINFO BSTACK *)rglpChanInfo);
		lpIDFpatchmaphdr    = ReadPatchMapChunk(hmmio, &chkParent);
		ReadKeyMapChunk(hmmio, &chkParent, (LPIDFKEYMAP BSTACK *)rglpIDFkeymap);
		

		if (lpIDFinstcaps && lpIDFchanhdr)
		{
		    // We read all the chunks - now construct the PINSTRUMENT
		    // and add it to the list.
		    //
		    pinstrument = (PINSTRUMENT)LocalAlloc(LPTR, sizeof(INSTRUMENT));
		    if (NULL == pinstrument)
		    {
			DPF(1, TEXT ("[Local]Alloc failed on PINSTRUMENT!!!"));
		    }
		    else
		    {
			pinstrument->pstrInstrument     = NULL;
			pinstrument->cRef               = 0;
			pinstrument->fdwInstrument      = lpIDFchanhdr->fdwFlags;
			pinstrument->dwGeneralMask      = lpIDFchanhdr->dwGeneralMask;
			pinstrument->dwDrumMask         = lpIDFchanhdr->dwDrumMask;
			pinstrument->pbPatchMap         = NULL;
			pinstrument->pbDrumKeyMap       = NULL;
			pinstrument->pbGeneralKeyMap    = NULL;

			pchaninit = pinstrument->rgChanInit;
			for (idx = 0; idx < MAX_CHANNELS; idx++)
			{
			    pchaninit->cbInit        = 0;
			    pchaninit->pbInit        = NULL;
			    
			    pchaninit++;
			}

			// Save the instrument name and file name so we can identify future
			// instances. 
			//
			
			cbSize = lstrlen(pstrFileName)+1 * sizeof (TCHAR);
			pinstrument->pstrFilename = (LPTSTR)LocalAlloc(LPTR, cbSize);
			if (NULL == pinstrument->pstrFilename)
			    goto Instrument_Alloc_Failed;

			lstrcpy(pinstrument->pstrFilename, pstrFileName);
			
			cbSize = lstrlen(pstrInstrument)+1 * sizeof (TCHAR);
			pinstrument->pstrInstrument = (LPTSTR)LocalAlloc(LPTR, cbSize);
			if (NULL == pinstrument->pstrInstrument)
			    goto Instrument_Alloc_Failed;

			lstrcpy(pinstrument->pstrInstrument, pstrInstrument);

			// Alloc and save the patch and key maps, if any
			//

			if (NULL != lpIDFpatchmaphdr)
			{
			    pinstrument->pbPatchMap = (PBYTE)LocalAlloc(LPTR, sizeof(lpIDFpatchmaphdr->abPatchMap));
			    if (NULL == pinstrument->pbPatchMap)
				goto Instrument_Alloc_Failed;

			    hmemcpy(
				     pinstrument->pbPatchMap,
				     lpIDFpatchmaphdr->abPatchMap,
				     sizeof(lpIDFpatchmaphdr->abPatchMap));
			}

			// Alloc and copy whatever key maps were in the IDF
			//
			if (rglpIDFkeymap[IDX_CHAN_GEN])
			{
			    pinstrument->pbGeneralKeyMap = (PBYTE)LocalAlloc(LPTR, sizeof(rglpIDFkeymap[IDX_CHAN_GEN]->abKeyMap));
			    if (NULL == pinstrument->pbGeneralKeyMap)
				goto Instrument_Alloc_Failed;

			    hmemcpy(
				    pinstrument->pbGeneralKeyMap,
				    rglpIDFkeymap[IDX_CHAN_GEN]->abKeyMap,
				    sizeof(rglpIDFkeymap[IDX_CHAN_GEN]->abKeyMap));
			}
			    
			if (rglpIDFkeymap[IDX_CHAN_DRUM])
			{
			    pinstrument->pbDrumKeyMap = (PBYTE)LocalAlloc(LPTR, sizeof(rglpIDFkeymap[IDX_CHAN_DRUM]->abKeyMap));
			    if (NULL == pinstrument->pbDrumKeyMap)
				goto Instrument_Alloc_Failed;

			    hmemcpy(
				    pinstrument->pbDrumKeyMap,
				    rglpIDFkeymap[IDX_CHAN_DRUM]->abKeyMap,
				    sizeof(rglpIDFkeymap[IDX_CHAN_DRUM]->abKeyMap));
			}
			   

			// Now build the channel init structures
			//
			for (idx = 0; idx < MAX_CHANNELS; idx++)
			{
			    if (NULL != (lpChanInfo = rglpChanInfo[idx]))
			    {
				if (lpChanInfo->cbInitData & 0xFFFF0000)
				{
				    DPF(1, TEXT ("IDF specifies init data > 64K! Ignored."));
				    continue;
				}
				
				pchaninit = &pinstrument->rgChanInit[idx];

				if (lpChanInfo->cbInitData)
				{
				    if (NULL == (pchaninit->pbInit = (PBYTE)
					LocalAlloc(LPTR, (UINT)lpChanInfo->cbInitData)))
					goto Instrument_Alloc_Failed;

				    hmemcpy(
					     pchaninit->pbInit,
					     lpChanInfo->abData,
					     (UINT)lpChanInfo->cbInitData);

				    pchaninit->cbInit = lpChanInfo->cbInitData;
				}
			    }
			}
		    }
		}

Instrument_Alloc_Failed:                
		// Make sure we free anything the parse threw at us.
		//
		if (NULL != lpIDFinstcaps)
		    GlobalFreePtr(lpIDFinstcaps);
		
		if (NULL != lpIDFpatchmaphdr)
		    GlobalFreePtr(lpIDFpatchmaphdr);

		if (NULL != lpIDFchanhdr)
		    GlobalFreePtr(lpIDFchanhdr);
		
		for (idx = 0; idx < MAX_CHAN_TYPES; idx++)
		    if (NULL != rglpIDFkeymap[idx])
			GlobalFreePtr(rglpIDFkeymap[idx]);
	    }
	}

	GlobalFreePtr(lpIDFheader);
	mmioAscend(hmmio, &chkParent, 0);
    }

    if (!fSuccess)
    {
	// Clean up anything we might have possibly allocated
	//
    }
    
    if (pinstrument)
    {
	DPF(1, TEXT ("LoadInstrument success!"));
	pinstrument->pNext = gpinstrumentList;
	gpinstrumentList = pinstrument;
    }
    else
    {
	DPF(1, TEXT ("LoadInstrument failure."));
    }

    mmioAscend(hmmio, &chkRIFF, 0);
    mmioClose(hmmio, 0);


LoadInstrument_Cleanup:
    
    if (pszName) 
	LocalFree((HLOCAL)pszName);

    return pinstrument;
}

PRIVATE PINSTRUMENT FNLOCAL MakeDefInstrument(
    void)
{
    PINSTRUMENT             pinstrument;
    PCHANINIT               pchaninit; 
    UINT                    idx;
    UINT                    cbSize;
    
    pinstrument = (PINSTRUMENT)LocalAlloc(LPTR, sizeof(INSTRUMENT));
    if (NULL == pinstrument)
    {
	DPF(1, TEXT ("[Local]Alloc failed on PINSTRUMENT!!!"));
	return NULL;
    }

    pinstrument->pstrInstrument     = NULL;
    pinstrument->cRef               = 0;
    pinstrument->fdwInstrument      = 0;
    pinstrument->pbPatchMap         = NULL;
    pinstrument->pbDrumKeyMap       = NULL;
    pinstrument->pbGeneralKeyMap    = NULL;

    pchaninit = pinstrument->rgChanInit;
    for (idx = 0; idx < MAX_CHANNELS; idx++, pchaninit++)
    {
	pchaninit->cbInit = 0;
	pchaninit->pbInit = NULL;
    }

    // Save the instrument name and file name so we can identify future
    // instances. 
    //
    cbSize = (lstrlen(gszDefaultFile) + 1) * sizeof(TCHAR);

    pinstrument->pstrFilename = (LPTSTR)LocalAlloc(LPTR, cbSize);
    if (NULL == pinstrument->pstrFilename)
    {
	LocalFree((HLOCAL)pinstrument);
	return NULL;
    }

    lstrcpy(pinstrument->pstrFilename, gszDefaultFile);


    cbSize = (lstrlen(gszDefaultInstr) + 1) * sizeof(TCHAR);
    
    pinstrument->pstrInstrument = (LPTSTR)LocalAlloc(LPTR, cbSize);
    if (NULL == pinstrument->pstrInstrument)
    {
	LocalFree((HLOCAL)pinstrument->pstrFilename);
	LocalFree((HLOCAL)pinstrument);
	return NULL;
    }

    lstrcpy(pinstrument->pstrInstrument, gszDefaultInstr);

    
    return pinstrument;
}

/***************************************************************************
  
   @doc internal
  
   @api BOOL | UpdateInstruments | Called to reconfigure the mapper when
    control panel pokes at it.

   @rdesc TRUE on success; FALSE if the request was deferred because
    there are open instances.

***************************************************************************/
BOOL FNGLOBAL UpdateInstruments(     
    BOOL                fFromCPL,
    DWORD               fdwUpdate)

{
    if (IS_INRUNONCE)
    {
	DPF(1, TEXT ("Got reconfig while RunOnce going...ignored"));
	return TRUE;
    }
    
    if ((fdwUpdate & 0xFFFF) == DRV_F_PROP_INSTR)
       {
       DPF(1, TEXT ("Reconfig from CPL or RunOnce"));
       }
    
    DPF(1, TEXT ("UpdateInstruments called."));
    if (IS_DEVSOPENED)
    {
	SET_RECONFIGURE;
	return FALSE;
    }
    else
    {
	Unconfigure();

	if (Configure(fdwUpdate))
	{
	    Unconfigure();
	    if (Configure(fdwUpdate))
		DPF(1, TEXT ("Tried to reconfigure more than twice -- uh-oh"));
	}
    }

    return TRUE;
}

/*+ GetIDFDirectory
 *
 *-=================================================================*/

PRIVATE BOOL FNLOCAL GetIDFDirectory (
    LPTSTR                  pszDir,
    DWORD                   cchDir)
{
    HKEY                    hKey;
    UINT                    cbSize;

    *pszDir = 0;

    cbSize = cchDir * sizeof(TCHAR);

    if (!RegOpenKey (HKEY_LOCAL_MACHINE, gszSetupKey, &hKey))
    {
	RegQueryValueEx (hKey, 
			 gszMachineDir, 
			 NULL, 
			 NULL, 
			 (LPBYTE)pszDir, 
			 &cbSize);
	RegCloseKey (hKey);
	
	cchDir = cbSize / sizeof(TCHAR);
	if (!cchDir--)
	    return FALSE;
    }
    else if (!GetWindowsDirectory(pszDir, (UINT)cchDir))
	return FALSE;

    cchDir = lstrlen (pszDir);
    if (pszDir[cchDir -1] != TEXT ('\\'))
	pszDir[cchDir++] = TEXT ('\\');
    lstrcpy (pszDir + cchDir, gszConfigDir);

    return TRUE;
}

/***************************************************************************
  
   @doc internal
  
   @api VOID | ValidateChannelTypes | Ensure that the given channel
    assignments in the registry are correct in terms of the IDF's. Make an
    attempt to find a drum channel if needed; it might be on channel 16
    for a hindered driver.

***************************************************************************/
PRIVATE VOID FNLOCAL DeassignChannel(
    UINT                uChannel)
{
    UINT                idx;

    assert(uChannel < MAX_CHANNELS);

    if (!gapChannel[uChannel])
	return;
    
    for (idx = 0; idx < MAX_CHANNELS; idx++)
    {
	if (gapChannel[idx])
	{
	    if ((idx != uChannel) &&
		(gapChannel[uChannel]->pport == gapChannel[idx]->pport))
	    {
		break;
	    }
	}
    }

    if (idx == MAX_CHANNELS)
	PortReleaseRef(gapChannel[uChannel]->pport);

    InstrumentReleaseRef(gapChannel[uChannel]->pinstrument);
    LocalFree((HLOCAL)gapChannel[uChannel]);
    gapChannel[uChannel] = NULL;
}

PRIVATE VOID FNLOCAL ValidateChannelTypes(
    VOID)
{
    UINT                idxChan;
    DWORD               dwChanBit;
    DWORD               dwIDFMask;
    PCHANNEL            pchannel;
    UINT                uNewDrumChan;
    PINSTRUMENT         pinst;

    DPF(2, TEXT ("  --- ValidateChannelTypes ---"));
    // First, mute any channel that doesn't match the correct channel type
    //
    for (idxChan = 0,           dwChanBit = 1;
	 idxChan < MAX_CHANNELS;
	 ++idxChan,             dwChanBit <<= 1)
    {
	if (NULL == (pchannel = gapChannel[idxChan]))
	{
	    DPF(2, TEXT ("  Channel %u was never allocated"), idxChan);
	    continue;
	}

	if (NULL == pchannel->pinstrument)
	{
	    DPF(2, TEXT ("  Channel %u contains default instrument"), idxChan);
	    continue;
	}

	dwIDFMask = (idxChan != DRUM_CHANNEL) ?
			pchannel->pinstrument->dwGeneralMask :
			pchannel->pinstrument->dwDrumMask;

	if (dwIDFMask & dwChanBit)
	    continue;

	DPF(2, TEXT ("  Muting channel %u"), idxChan);

	pchannel->fwChannel |= CHAN_F_MUTED;
    }

    // Now, if the drum channel is assigned but muted, attempt to find a drum
    // channel on the same instrument.
    //
    if (NULL == (pchannel = gapChannel[DRUM_CHANNEL]))
    {
	DPF(2, TEXT ("  No drum channel"));
	goto Validate_Cleanup;
    }

    if (!(pchannel->fwChannel & CHAN_F_MUTED))
    {
	DPF(2, TEXT ("  Drum channel already valid"));
	goto Validate_Cleanup;
    }

    pinst = pchannel->pinstrument;
    assert(pinst);

    dwIDFMask = pchannel->pinstrument->dwDrumMask;

    for (uNewDrumChan = 0,              dwChanBit = 1;
	 uNewDrumChan < MAX_CHANNELS;
	 ++uNewDrumChan,                dwChanBit <<= 1)
	if (dwChanBit & dwIDFMask)
	    break;

    if (uNewDrumChan != MAX_CHANNELS)
    {
	DPF(2, TEXT ("  New drum channel %u"), uNewDrumChan);
	
	// We've found a new drum channel; mute anything that's using it as a
	// general channel
	//
	for (idxChan = 0; idxChan < MAX_CHANNELS; ++idxChan)
	    if (idxChan != DRUM_CHANNEL &&
		gapChannel[idxChan] &&
		gapChannel[idxChan]->pinstrument == pinst &&
		gapChannel[idxChan]->uChannel == uNewDrumChan)
	    {
		DPF(2, TEXT ("  Channel %u was on new drum channel"), idxChan);
		gapChannel[idxChan]->fwChannel |= CHAN_F_MUTED;
	    }

	// Now assign it is a drum channel
	//

	pchannel->fwChannel     &= ~CHAN_F_MUTED;
	pchannel->uChannel      = uNewDrumChan;
	pchannel->pbPatchMap    = NULL;
	pchannel->pbKeyMap      = pinst->pbDrumKeyMap;
    }
	
    // Now go through and deassign all muted channels. This will free
    // their memory
    //

Validate_Cleanup:
    DPF(2, TEXT ("  Validate cleanup"));
    
    for (idxChan = 0; idxChan < MAX_CHANNELS; ++idxChan)
	if (gapChannel[idxChan] &&
	    (gapChannel[idxChan]->fwChannel & CHAN_F_MUTED))
	{
	    DPF(2, TEXT ("  Deassign %u"), idxChan);
	    DeassignChannel(idxChan);
	}

    DPF(2, TEXT ("  --- Validate End ---"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\midimap\cookmap.c ===
/**********************************************************************

  Copyright (c) 1992-1998 Microsoft Corporation

  cookmap.c

  DESCRIPTION:
    Non-fixed code for doing cooked-mode output mapping. 

  HISTORY:
     03/04/94       [jimge]        created.

*********************************************************************/

#include "preclude.h"
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "idf.h"

#include <memory.h>

#include "midimap.h"
#include "debug.h"

/***************************************************************************
  
   @doc internal
  
   @api int | MapCookedBuffer | Perform output mapping of a polymsg buffer.

   @parm PINSTANCE | pinstance | Instance owning the polymsg buffer.

   @parm LPMIDIHDR | lpmh | The buffer to map.

   @comm
    Map this buffer (which may allocate more channels to us).

    Build array of used ports and physical channels used on each port.

    Acquire shadow buffers and a sync object and set them up.

    Queue the sync object and send it if there isn't anything playing.

   @rdesc | MMSYSERR_xxx.
       
***************************************************************************/
#define SKIP_BYTES(x,s)                 \
{                                       \
    if (cbBuffer < (x))                 \
    {                                   \
        DPF(1, TEXT ("MapCookedBuffer: ran off end of polymsg buffer in parse! %ls"), (LPTSTR)(s)); \
        mmRet = MMSYSERR_INVALPARAM;    \
        goto CLEANUP;                   \
    }                                   \
    ((LPBYTE)lpdwBuffer) += (x);        \
    cbBuffer -= (x);                    \
}

MMRESULT FNGLOBAL MapCookedBuffer(
    PINSTANCE               pinstance,
    LPMIDIHDR               lpmhParent)
{
    LPDWORD                 lpdwBuffer;
    DWORD                   cbBuffer;
    BYTE                    bEventType;
    DWORD                   dwEvent;
    DWORD                   dwStreamID = 0;
    MMRESULT                mmRet;
    LPMIDIHDR               lpmh;
    PSHADOWBLOCK            psb;

    mmRet = MMSYSERR_NOERROR;

    psb = (PSHADOWBLOCK)(UINT_PTR)lpmhParent->dwReserved[MH_SHADOW];
    lpmh = psb->lpmhShadow;
    
    DPF(2, TEXT ("Map: pinstance %04X lpmh %p"), (WORD)pinstance, lpmh);

    lpmh->reserved = lpmhParent->reserved;
    lpmh->dwBytesRecorded = lpmhParent->dwBytesRecorded;

    lpmh->dwReserved[MH_MAPINST] = (DWORD_PTR)pinstance;
    
    // In-place map the buffer. Run through it, mapping all of the
    // short events.
    //
    lpdwBuffer = (LPDWORD)lpmh->lpData;
    cbBuffer   = lpmh->dwBytesRecorded;

    while (cbBuffer)
    {
        SKIP_BYTES(sizeof(DWORD), TEXT ("d-time"));

        if (cbBuffer < 2*sizeof(DWORD))
            return MMSYSERR_INVALPARAM;
        
        bEventType = MEVT_EVENTTYPE(lpdwBuffer[1]);
        dwEvent    = MEVT_EVENTPARM(lpdwBuffer[1]);
        
        if (bEventType == MEVT_SHORTMSG)
        {
            dwEvent = MapSingleEvent(pinstance,
                                     dwEvent,
                                     MSE_F_RETURNEVENT,
                                     (DWORD BSTACK *)&dwStreamID);
            
            lpdwBuffer[0] = dwStreamID;
            lpdwBuffer[1] = dwEvent;
        }

        SKIP_BYTES(sizeof(DWORD), TEXT ("stream-id"));
        SKIP_BYTES(sizeof(DWORD), TEXT ("event type"));

        if (bEventType & (MEVT_F_LONG >> 24))
        {
            dwEvent = (dwEvent+3)&~3;
            SKIP_BYTES(dwEvent, TEXT ("long event data"));
        }
    }

    mmRet = midiStreamOut(ghMidiStrm, lpmh, sizeof(MIDIHDR));
    
CLEANUP:
    return mmRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\midimap\debug.c ===
//==========================================================================; 
//
//      Copyright (c) 1991-1995 Microsoft Corporation
//
//      You have a royalty-free right to use, modify, reproduce and 
//      distribute the Sample Files (and/or any modified version) in 
//      any way you find useful, provided that you agree that 
//      Microsoft has no warranty obligations or liability for any 
//      Sample Application Files which are modified. 
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code yanked from several places to provide debug
//      support that works in win 16 and win 32.
//
//  History:
//      11/23/92    cjp     [curtisp] 
//
//==========================================================================;

#ifdef   DEBUG

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <stdarg.h>

#include "debug.h"

#ifdef WIN32
   #define  BCODE
#else
   #define  BCODE                   __based(__segname("_CODE"))
#endif // End #ifdef WIN32

#ifdef WIN32
   #define GlobalSmartPageLock(a) (TRUE)
#endif // End #ifdef WIN32


#define WSPRINTF_LIMIT 1024

typedef struct tagLOG
{
     LPTSTR             lpszQueue;  // TCHAR Representation
     UINT               cchBuffer;  // Size of Log in TCHAR's
     UINT               idxRead;    // Read index
     UINT               idxWrite;   // Write index
} LOG, FAR *LPLOG;

#define LOG_INCIDX(pl,x) ((++x >= pl->cchBuffer) ? x = 0 : x)

void FAR CDECL DbgVPrintF (LPTSTR szFmt, va_list va);

BOOL NEAR PASCAL LogInit (LPLOG lpLog, UINT ckBuffer);
void NEAR PASCAL LogWrite (LPLOG lpLog, LPTSTR lpstrEvent);
BOOL NEAR PASCAL LogRead (LPLOG lpLog, LPTSTR lpstrBuffer, UINT cchBuffer);

#ifdef ISRDEBUG
int wivsprintf (LPTSTR lpOut, LPCTSTR lpFmt, VOID FAR* lpParms) ;

LPCTSTR NEAR PASCAL SP_GetFmtValue (LPCTSTR lpch, UINT * lpw) ;
UINT    NEAR PASCAL SP_PutNumber (LPTSTR lpb, DWORD n, UINT limit, UINT radix, UINT icase) ;
VOID    NEAR PASCAL SP_Reverse (LPTSTR lpFirst, LPTSTR lpLast) ;
UINT    NEAR PASCAL ilstrlen (LPTSTR lpstr) ;
VOID    NEAR PASCAL ilstrcat (LPTSTR lpstrDest, LPTSTR lpstrSrc) ;
#endif


//
// Use interruptable versions of functions
//

#ifdef ISRDEBUG
   #define wvsprintf        wivsprintf
   #define lstrcat          ilstrcat
   #define lstrlen          ilstrlen    
#endif


//
//
//
BOOL    __gfDbgEnabled  = TRUE;     // master enable
UINT    __guDbgLevel    = 0;        // current debug level
BOOL    __gfLogging     = 0;        // Are we logging as well?

HWND    ghWndCB         = (HWND)NULL;
LOG     gLog;
WORD    wDebugLevel     = 0;


//************************************************************************
//**
//**  WinAssert();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     LPSTR lpstrExp
//**     LPSTR lpstrFile
//**     DWORD dwLine  
//**
//**  RETURNS:
//**     void 
//**
//**  HISTORY:
//**
//************************************************************************

VOID WINAPI WinAssert(
    LPSTR           lpstrExp,
    LPSTR           lpstrFile,
    DWORD           dwLine)
{
    static TCHAR szWork[256];
    static TCHAR BCODE szFormat[] =
        TEXT ("Assertion failed!\n\nFile:\t%s\nLine:\t%lu\n\n[%s]");
    static TCHAR BCODE szOops[] =
        DEBUG_MODULE_NAME TEXT (" is confused"); 

    // Use regular wsprintf here; assert's can't be at interrupt time
    // anyway. 
    //

#ifdef UNICODE
    static TCHAR szFile[256];
    static TCHAR szMsg[256];

      // Convert File to UNICODE
    INT cLen = lstrlenA (lpstrFile);
    if (cLen >= 255)
      cLen = 255;

    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED,
                         lpstrFile, cLen, szFile, 256);
    szFile[cLen] = 0;

      // Convert Message to UNICODE
    cLen = lstrlenA (lpstrExp);
    if (cLen >= 255)
      cLen = 255;

    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED,
                         lpstrExp, cLen, szMsg, 256);
    szMsg[cLen] = 0;

      // Create Assert String
    wsprintf (szWork, szFormat, szFile, dwLine, szMsg);
#else
    wsprintf (szWork, szFormat, lpstrFile, dwLine, lpstrExp);
#endif

    if (IDCANCEL == MessageBox(NULL, szWork, szOops, MB_OKCANCEL|MB_ICONEXCLAMATION))
        DebugBreak();

}


//************************************************************************
//**
//**  DbgVPrintF();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     LPSTR szFmt
//**     LPSTR va
//**
//**  RETURNS:
//**     void 
//**
//**  HISTORY:
//**
//************************************************************************

void FAR CDECL DbgVPrintF(
   LPTSTR   szFmt, 
   va_list  va)
{
    TCHAR   ach[DEBUG_MAX_LINE_LEN];
    BOOL    fDebugBreak = FALSE;
    BOOL    fPrefix     = TRUE;
    BOOL    fCRLF       = TRUE;

    ach[0] = TEXT ('\0');

    for (;;)
    {
        switch(*szFmt)
        {
            case '!':
                fDebugBreak = TRUE;
                szFmt++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFmt++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFmt++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = TEXT ('\007');
        ach[1] = TEXT ('\0');
    }

    if (fPrefix)
        lstrcat (ach, DEBUG_MODULE_NAME TEXT (": "));

    wvsprintf (ach + lstrlen(ach), szFmt, va);

    if (fCRLF)
        lstrcat (ach, TEXT ("\r\n") );

    if (__gfLogging)
    {
        LogWrite (&gLog, ach);
        if (ghWndCB)
            PostMessage (ghWndCB, WM_DEBUGUPDATE, 0, 0);
    }

    OutputDebugString (ach);

    if (fDebugBreak)
        DebugBreak();
} //** DbgVPrintF()


//************************************************************************
//**
//**  dprintf();
//**
//**  DESCRIPTION:
//**     dprintf() is called by the DPF macro if DEBUG is defined at compile
//**     time.
//**     
//**     The messages will be send to COM1: like any debug message. To
//**     enable debug output, add the following to WIN.INI :
//**
//**     [debug]
//**     ICSAMPLE=1
//**
//**
//**  ARGUMENTS:
//**     UINT     uDbgLevel
//**     LPCSTR   szFmt
//**     ...
//**
//**  RETURNS:
//**     void 
//**
//**  HISTORY:
//**     06/12/93       [t-kyleb]      
//**
//************************************************************************

void FAR CDECL dprintf(
   UINT     uDbgLevel, 
   LPTSTR   szFmt, 
   ...)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start (va, szFmt);
    DbgVPrintF (szFmt, va);
    va_end (va);
} //** dprintf()


//************************************************************************
//**
//**  DbgEnable();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     BOOL fEnable
//**
//**  RETURNS:
//**     BOOL 
//**
//**  HISTORY:
//**     06/12/93       [t-kyleb]      
//**
//************************************************************************

BOOL WINAPI DbgEnable(
   BOOL fEnable)
{
    BOOL    fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} //** DbgEnable()



//************************************************************************
//**
//**  DbgSetLevel();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     UINT uLevel
//**
//**  RETURNS:
//**     UINT 
//**
//**  HISTORY:
//**     06/12/93       [t-kyleb]      
//**
//************************************************************************

UINT WINAPI DbgSetLevel(
   UINT uLevel)
{
    UINT    uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = wDebugLevel = uLevel;

    return (uOldLevel);
} //** DbgSetLevel()


//--------------------------------------------------------------------------;
//
//  UINT DbgInitialize(void)
//
//  Description:
//      
//
//  Arguments:
//
//  Return (UINT):
//
//
//  History:
//      11/24/92    cjp     [curtisp] 
//
//--------------------------------------------------------------------------;


UINT WINAPI DbgInitialize(BOOL fEnable)
{
    TCHAR           szTemp[64];
    LPTSTR          pstr;
    UINT            uLevel;
    UINT            uLogMem;
    
    GetProfileString (DEBUG_SECTION, DEBUG_MODULE_NAME, TEXT (""), szTemp, sizeof(szTemp));

    pstr = szTemp;
    uLevel = 0;
    while (*pstr >= TEXT ('0') && *pstr <= TEXT ('9'))
    {
        uLevel = uLevel*10 + (UINT)(*pstr - TEXT ('0'));
        pstr++;
    }

    __gfLogging = FALSE;
    if (*pstr == TEXT (','))
    {
        pstr++;
        uLogMem = 0;
        while (*pstr >= TEXT ('0') && *pstr <= TEXT ('9'))
        {
            uLogMem = uLogMem*10 + (UINT)(*pstr - TEXT ('0'));
            pstr++;
        }

        if (0 == uLogMem) 
           uLogMem = K_DEFAULT_LOGMEM;
        
        if (uLogMem > K_MAX_LOGMEM) 
           uLogMem = K_MAX_LOGMEM;

        __gfLogging = TRUE;
    }
    
    if (__gfLogging)
        __gfLogging = LogInit(&gLog, uLogMem);
    
    DbgSetLevel (GetProfileInt(DEBUG_SECTION, DEBUG_MODULE_NAME, 0));
    DbgEnable (fEnable);

    return (__guDbgLevel);
} // DbgInitialize()

void WINAPI DbgRegisterCallback (HWND hWnd)
{
    ghWndCB = hWnd;
}

BOOL WINAPI DbgGetNextLogEntry (LPTSTR lpstrBuffer, UINT cchBuffer)
{
    if (!__gfLogging)
        return FALSE;

    return LogRead (&gLog, lpstrBuffer, cchBuffer);
}

BOOL NEAR PASCAL LogInit (LPLOG lpLog, UINT ckMem)
{
    DWORD   cbMem = 1024L * ckMem;

    LPTSTR  lpszQueue = GlobalAllocPtr (GPTR, cbMem);
    if (NULL == lpszQueue)
        return FALSE;

    if (! GlobalSmartPageLock (HIWORD(lpszQueue)))
    {
        GlobalFreePtr (lpszQueue);
        return FALSE;
    }

    lpLog->lpszQueue = (LPTSTR)lpszQueue;
    lpLog->cchBuffer = (UINT)cbMem/sizeof(TCHAR);
    lpLog->idxRead   = 0;
    lpLog->idxWrite  = 0;

    return TRUE;
}

void NEAR PASCAL LogWrite (LPLOG lpLog, LPTSTR lpstrEvent)
{
    if (!*lpstrEvent)
        return;

    while (*lpstrEvent)
    {
        lpLog->lpszQueue[lpLog->idxWrite] = *lpstrEvent++;
        LOG_INCIDX (lpLog,lpLog->idxWrite);
    }

    lpLog->idxRead = lpLog->idxWrite;

    while (lpLog->lpszQueue[lpLog->idxRead])
    {
        lpLog->lpszQueue[lpLog->idxRead] = TEXT ('\0');
        LOG_INCIDX(lpLog,lpLog->idxRead);
    }
    
    LOG_INCIDX(lpLog,lpLog->idxRead);
    LOG_INCIDX(lpLog,lpLog->idxWrite);
}

BOOL NEAR PASCAL LogRead(LPLOG lpLog, LPTSTR lpstrBuffer, UINT cchBuffer)
{
    TCHAR                   ch;
    UINT                    idx;

    if (!cchBuffer)
        return FALSE;
    
    idx = lpLog->idxRead;

    while (TEXT ('\0') == lpLog->lpszQueue[idx])
    {
        LOG_INCIDX(lpLog,idx);
        if (idx == lpLog->idxRead)
            return FALSE;
    }

    cchBuffer--;
    while (0 != (ch = lpLog->lpszQueue[idx]))
    {
        if (cchBuffer)
        {
            *lpstrBuffer++ = ch;
            cchBuffer--;
        }
            
        lpLog->lpszQueue[idx] = TEXT ('\0');
        LOG_INCIDX(lpLog,idx);
    }

    *lpstrBuffer = TEXT ('\0');

    LOG_INCIDX (lpLog,idx);

    lpLog->idxRead = idx;
    return TRUE;
}



//--------------------------------------------------------------------------;
//
// The rest of the code is only needed if we're in Win16 and need to be
// interrupt callable.
//
//--------------------------------------------------------------------------;

#ifdef ISRDEBUG

#define OUT(ch) if (--cchLimit) *lpOut++=(ch); else goto error_Out

//************************************************************************
//**
//**  wivsprintf();
//**
//**  DESCRIPTION:
//**     Interrupt callable version of wvsprintf() 
//**
//**
//**  ARGUMENTS:
//**     LPTSTR       lpOut    -  Buffer to format into.
//**     LPCTSTR      lpFmt    -  Format string.
//**     VOID FAR*    lpParms  -  Points to the first of args 
//**                              described by lpFmt.
//**
//**  RETURNS:
//**     int   -  Number of characters stored.
//**
//**  HISTORY:
//**     3/28/93     jfg      [jimge] 
//**
//************************************************************************

int wivsprintf(
    LPTSTR       lpOut,
    LPCTSTR      lpFmt,
    VOID FAR*    lpParms)
{
    int         left ;
    TCHAR       prefix ;
    int         width ;
    int         prec ;
    TCHAR       fillch ;
    int         size ;
    int         sign ;
    int         radix ;
    int         upper ;
    int         cchLimit = WSPRINTF_LIMIT;
    int         cch ;
    LPTSTR      lpT ;
    union
    {
        long            l ;
        unsigned long   ul ;
        TCHAR sz[sizeof(long)] ;
    } val;
                
    while (*lpFmt)
    {
        if (*lpFmt==TEXT ('%'))
        {
            //
            // Read the format flags. 
            //
            left   = 0 ;
            prefix = 0 ;

            while (*++lpFmt)
            {
                if (*lpFmt==TEXT ('-'))
                {    
                    left++;
                }
                else if (*lpFmt==TEXT ('#'))
                {
                    prefix++;
                }
                else
                {
                    break;
                }
            }

            //
            // Find the fill character (either '0' or ' ')
            //
            if (*lpFmt==TEXT ('0'))
            {
                fillch = TEXT ('0') ;
                lpFmt++ ;
            }
            else
            {
                fillch = TEXT (' ') ;
            }

            //
            // Now parse [width[.precision]]
            //
            lpFmt = SP_GetFmtValue(lpFmt,&cch);
            width = cch;

            if (*lpFmt==TEXT ('.'))
            {
                lpFmt = SP_GetFmtValue(++lpFmt,&cch);
                prec = cch;
            }
            else
            {
                prec = (UINT)-1 ;
            }

            //
            // Get the operand size modifier
            //
            if (*lpFmt==TEXT ('l'))
            {
                size = 1 ;
                lpFmt++ ;
            }
            else
            {
                size = 0 ;
                if (*lpFmt==TEXT ('h'))
                {
                    lpFmt++ ;
                }
            }
            
            //
            // We've gotten all the modifier; now format the output
            // based on the type (which should now be pointed at
            // by lpFmt).
            //
            upper = 0 ;
            sign = 0 ;
            radix = 10 ;

            switch (*lpFmt)
            {
                case 0:
                    goto error_Out ;

                case TEXT ('i') :
                case TEXT ('d') :
                    sign++ ;

                case TEXT ('u'):
                    //
                    // Don't show a prefix for decimal formats
                    // 
                    prefix=0 ;
do_Numeric:
                    //
                    // Special cases to act like MSC v5.10
                    //
                    if (left || prec>=0)
                    {
                        fillch = TEXT (' ');
                    }

                    //
                    // Get value from parm list into val union 
                    // 
                    if (size)
                    {
                        val.l=*((long far *)lpParms)++;
                    }
                    else
                    {
                        if (sign)
                        {
                            val.l=(long)*((short far *)lpParms)++;
                        }
                        else
                        {
                            val.ul=(unsigned long)*((unsigned far *)lpParms)++;
                        }
                    }

                    //
                    // Save sign of val.l in sign and set val.l positive.
                    //
                    if (sign && val.l<0L)
                    {
                        val.l=-val.l;
                    }
                    else
                    {
                        sign=0;
                    }

                    //
                    // Save start of output stream for later reverse
                    //
                    lpT = lpOut;

                    //
                    // Blast the number backwards into the user buffer 
                    //
                    cch = SP_PutNumber(lpOut,val.l,cchLimit,radix,upper) ;
                    if (!(cchLimit-=cch))
                        goto error_Out ;

                    lpOut += cch ;
                    width -= cch ;
                    prec -= cch ;

                    if (prec>0)
                    {
                        width -= prec ;
                    }

                    //
                    // Fill in up to precision
                    //
                    while (prec-- > 0)
                    {
                        OUT(TEXT ('0')) ;
                    }

                    if (width>0 && !left)
                    {
                        //
                        // If we're filling with spaces, put sign first 
                        //
                        if (fillch != '0')
                        {
                            if (sign)
                            {
                                sign = 0 ;
                                OUT(TEXT ('-')) ;
                                width-- ;
                            }

                            if (prefix)
                            {
                                OUT(prefix) ;
                                OUT(TEXT ('0')) ;
                                prefix = 0 ;
                            }
                        }

                        if (sign)
                        {
                            width-- ;
                        }

                        //
                        // Now fill to width
                        //
                        while (width-- > 0)
                        {
                            OUT(fillch) ;
                        }

                        //
                        // Still have a sign? 
                        //
                        if (sign)
                        {
                            OUT(TEXT ('-')) ;
                        }

                        if (prefix)
                        {
                            OUT(prefix) ;
                            OUT(TEXT ('0')) ;
                        }

                        //
                        // Now reverse the string in place
                        //
                        SP_Reverse(lpT,lpOut-1);
                    }
                    else
                    {
                        //
                        // Add the sign character
                        //
                        if (sign)
                        {
                            OUT(TEXT ('-')) ;
                            width-- ;
                        }

                        if (prefix)
                        {
                            OUT(prefix);
                            OUT(TEXT ('0'));
                        }

                        //
                        // Now reverse the string in place
                        //
                        SP_Reverse(lpT,lpOut-1);

                        //
                        // Pad to the right of the string in case left aligned 
                        //
                        while (width-- > 0)
                        {
                            OUT(fillch) ;
                        }
                    }
                    break ;

                case TEXT ('X'):
                    upper++ ;
                    //
                    // Falling through...
                    //

                case TEXT ('x'):
                    radix=16 ;
                    if (prefix)
                    {
                        prefix = upper ? TEXT ('X') : TEXT ('x') ;
                    }
                    goto do_Numeric ;

                case TEXT ('c'):
                    //
                    // Save as one character string and join common code
                    // 
                    val.sz[0] = *((TCHAR far*)lpParms) ;
                    val.sz[1] = 0 ;
                    lpT = val.sz ;
                    cch = 1 ;  

                    // Note: this may need to be fixed for UNICODE
                    (BYTE far*)lpParms += sizeof(WORD) ;

                    goto put_String ;

                case 's':
                    lpT = *((LPTSTR FAR *)lpParms)++ ;
                    cch = ilstrlen(lpT) ;
put_String:
                    if (prec>=0 && cch>prec)
                    {
                        cch = prec ;
                    }

                    width -= cch ;

                    if (left)
                    {
                        while (cch--)
                        {
                            OUT(*lpT++) ;
                        }

                        while (width-->0)
                        {
                            OUT(fillch) ;
                        }
                    }
                    else
                    {
                        while (width-- > 0)
                        {
                            OUT(fillch) ;
                        }

                        while (cch--)
                        {
                            OUT(*lpT++) ;
                        }
                    }
                    break ;

                default:
                    //
                    // An unsupported type character was given. We just
                    // print the character and go on. 
                    //
                    OUT(*lpFmt) ;
                    break ;

            } // switch(*lpfmt)
        } // if (*lpfmt == '%')
        else
        {
            //
            // Normal not-format character
            //
            OUT(*lpFmt) ;
        }
                
        lpFmt++ ;
    } // while (*lpFmt) 

error_Out:
    *lpOut = 0 ;

    return WSPRINTF_LIMIT-cchLimit ;
} //** wivsprintf()


//************************************************************************
//**
//**  SP_GetFmtValue();
//**
//**  DESCRIPTION:
//**     Parse a decimal integer forming part of a format string.
//**
//**
//**  ARGUMENTS:
//**     LPCSTR   lpch  -  Points to the string to parse.
//**     LPWORD   lpw   -  Points to a word where the value will be 
//**                       returned.
//**
//**  RETURNS:
//**     LPCSTR   -  Pointer of first character past the format value.
//**
//**  HISTORY:
//**     3/28/93     jfg      [jimge] 
//**
//************************************************************************

LPCTSTR NEAR PASCAL SP_GetFmtValue(
   LPCTSTR   lpch,
   UINT *    lpw)
{
    UINT       i = 0 ;

    while (*lpch>=TEXT ('0') && *lpch<=TEXT ('9'))
    {
        i *= 10;
        i += (UINT)(*lpch++-TEXT ('0'));
    }     

    *lpw = i;

    return(lpch); 
} //** SP_GetFmtValue()

//************************************************************************
//**
//**  SP_PutNumber();
//**
//**  DESCRIPTION:
//**     Formats the given number in the given radix into the buffer
//**     *backwards*. The entire string will be reversed after printf
//**     has added sign, prefix, etc. to it.
//**
//**  
//**  ARGUMENTS:
//**     LPSTR lpb   -  Points to the output buffer.
//**     DWORD n     -  Number to convert.
//**     UINT  limit -  Maximum number of characters to store.
//**     UINT  radix -  Base to format in.
//**     UINT  icase -  Non-zero if the string should be upper case (hex).
//**
//**  RETURNS:
//**     UINT  -  Number of characters output.
//**
//**  HISTORY:
//**
//************************************************************************

UINT NEAR PASCAL SP_PutNumber(
   LPTSTR   lpb,
   DWORD    n,
   UINT     limit,
   UINT     radix,
   UINT     icase)
{
   TCHAR  bTemp;
   UINT   cchStored = 0;

   //
   // Set icase to the offset to add to the character if it
   // represents a value > 10
   //
   icase = (icase ? TEXT ('A') : TEXT ('a')) - TEXT ('0') - 10 ;

   while (limit--)
   {
      bTemp = TEXT ('0') + (TCHAR)(n%radix);

      if (bTemp > TEXT ('9'))
      {
         bTemp += icase ;
      }

      *lpb++ = bTemp;
      ++cchStored;

      n /= radix;

      if (n == 0)
      {
         break ;
      }    
   }

   return cchStored ;
} //** SP_PutNumber()


//************************************************************************
//**
//**  SP_Reverse();
//**
//**  DESCRIPTION:
//**     Reverse string in place.
//**
//**  ARGUMENTS:
//**     LPSTR pFirst
//**     LPSTR pLast
//**
//**  RETURNS:
//**     VOID 
//**
//**  HISTORY:
//**
//************************************************************************

VOID NEAR PASCAL SP_Reverse(
   LPTSTR pFirst,
   LPTSTR pLast)
{
   UINT   uSwaps = (pLast - pFirst + sizeof(TCHAR)) / (2 * sizeof(TCHAR));
   TCHAR  bTemp;

   while (uSwaps--)
   {
      bTemp   = *pFirst;
      *pFirst = *pLast;
      *pLast  = bTemp;

      pFirst++, pLast--;
   }
} //** SP_Reverse()

//************************************************************************
//**
//**  ilstrlen();
//**
//**  DESCRIPTION:
//**     Interrupt callable version of strlen().
//**
//**  ARGUMENTS:
//**     LPSTR   pstr
//**
//**  RETURNS:
//**     UINT 
//**
//**  HISTORY:
//**
//************************************************************************

UINT NEAR PASCAL ilstrlen(
    LPTSTR   pstr)
{
   UINT    cch = 0 ;

   while (*pstr++)
      ++cch;

   return(cch);
} //** ilstrlen()

//************************************************************************
//**
//**  ilstrcat();
//**
//**  DESCRIPTION:
//**     Interrupt callable version of lstrcat().
//**
//**  ARGUMENTS:
//**     LPSTR   pstrDest
//**     LPSTR   pstrSrc
//**
//**  RETURNS:
//**     VOID 
//**
//**  HISTORY:
//**
//************************************************************************

VOID NEAR PASCAL ilstrcat(
    LPTSTR   pstrDest,
    LPTSTR   pstrSrc)
{
   while (*pstrDest)
      pstrDest++;

   while (*pstrDest++ = *pstrSrc++)
      ;

} //** ilstrcat()

#endif // #ifdef ISRDEBUG

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\midimap\drvproc.c ===
/**********************************************************************

  Copyright (c) 1992-1999 Microsoft Corporation

  drvproc.c

  DESCRIPTION:
    Driver procedure for the Midi Mapper.

  HISTORY:
     06/09/93       [t-kyleb]      created.

*********************************************************************/

#include "preclude.h"
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "idf.h"

#include <memory.h>

#include "midimap.h"
#include "debug.h"

//=========================== Globals ======================================
//
PCHANNEL                gapChannel[MAX_CHANNELS]    = {NULL};
WORD                    gwConfigWhere       = 0;
UINT                    gcPorts             = 0;
WORD                    gwFlags             = 0;

HINSTANCE               ghinst              = NULL;
PPORT                   gpportList          = NULL;
PINSTANCE               gpinstanceList      = NULL;
PINSTANCE               gpIoctlInstance     = NULL;
PINSTRUMENT             gpinstrumentList    = NULL;
QUEUE                   gqFreeSyncObjs;
HMIDISTRM               ghMidiStrm          = NULL;
TCHAR                   szVersion[]         = TEXT (__DATE__)
                                              TEXT ("@")
                                              TEXT (__TIME__);
DWORD                   gdwVolume           = 0xFFFFFFFFL;

HANDLE			hMutexRefCnt		= NULL;
static const TCHAR	gszRefCnt[]		= TEXT ("MidiMapper_modLongMessage_RefCnt");

HANDLE			hMutexConfig		= NULL;

static const TCHAR      gszReconfigure[]        = TEXT("MidiMapper_Reconfig");

//=========================== Prototypes ===================================
//
PRIVATE LRESULT FNLOCAL GetMapperStatus(
    LPMAPPERSTATUS          lpStat);

/***************************************************************************

   @doc INTERNAL

   @api LRESULT | DriverProc | The entry point for an installable driver.

   @parm DWORD | dwID | For most messages, <p dwID> is the DWORD value
       that the driver returns in response to a <m DRV_OPEN> message.
       Each time that the driver is opened, through the <f DrvOpen> API,
       the driver receives a <m DRV_OPEN> message and can return an
       arbitrary, non-zero value. The installable driver interface
       saves this value and returns a unique driver handle to the
       application. Whenever the application sends a message to the
       driver using the driver handle, the interface routes the message
       to this entry point and passes the corresponding <p dwID>.
       This mechanism allows the driver to use the same or different
       identifiers for multiple opens but ensures that driver handles
       are unique at the application interface layer.

       The following messages are not related to a particular open
       instance of the driver. For these messages, the dwID will always
       be zero.

           DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN

   @parm HDRVR  | hdrvr | This is the handle returned to the application
       by the driver interface.

   @parm UINT | umsg | The requested action to be performed. Message
       values below <m DRV_RESERVED> are used for globally defined messages.
       Message values from <m DRV_RESERVED> to <m DRV_USER> are used for
       defined driver protocols. Messages above <m DRV_USER> are used
       for driver specific messages.

   @parm LPARAM | lParam1 | Data for this message.  Defined separately for
       each message

   @parm LPARAM | lParam2 | Data for this message.  Defined separately for
       each message

   @rdesc Defined separately for each message.

****************************************************************************/

LRESULT FNEXPORT DriverProc(
    DWORD_PTR           dwID,
    HDRVR               hdrvr,
    UINT                umsg,
    LPARAM              lParam1,
    LPARAM              lParam2)
{
    //
    //  NOTE DS is not valid here.
    //
    switch (umsg)
    {
        case DRV_LOAD:
            return(1L);

        case DRV_FREE:
            return(0L);

        case DRV_OPEN:
        case DRV_CLOSE:
            return(1L);

        case DRV_ENABLE:
				// Prevent Synchronization problems
				// During Configuration
            if (NULL != hMutexConfig)
				WaitForSingleObject (hMutexConfig, INFINITE);

            SET_ENABLED;
            DPF(1, TEXT ("Enable!"));
            Configure(0);

            if (NULL != hMutexConfig)
				ReleaseMutex (hMutexConfig);
            return(0L);

        case DRV_DISABLE:
            CLR_ENABLED;
            return(0L);

        case DRV_INSTALL:
        case DRV_REMOVE:
            // If the user installs or removes the driver then let them
            // know that they will have to restart.
            //
            return((LRESULT)DRVCNF_RESTART);

        case DRV_ENABLE_DEBUG:
            return(DbgEnable((BOOL)lParam1));

        case DRV_SET_DEBUG_LEVEL:
            return(DbgSetLevel((UINT)lParam1));

        case DRV_GETMAPPERSTATUS:
            return GetMapperStatus((LPMAPPERSTATUS)lParam1);

#ifdef DEBUG
        case DRV_REGISTERDEBUGCB:
            DbgRegisterCallback((HWND)lParam1);
            return 1L;

        case DRV_GETNEXTLOGENTRY:
            return (LRESULT)DbgGetNextLogEntry((LPTSTR)lParam1, (UINT)lParam2);
#endif

            // Let the default handler handle everything else.
            //
        default:
            DPF(1, TEXT ("DriverProc unsupported=%08lX"), (DWORD)umsg);
            return(DefDriverProc(dwID, hdrvr, umsg, lParam1, lParam2));
    }
} //** DriverProc()

/***************************************************************************

   @doc internal

   @api LRESULT | GetMapperStatus | Return information about the current
    mapper setup to a debug application.

   @parm LPMAPPERSTATUS | lpStat | Pointer to a structure to receive
    the mapper information. lpStat->cbStruct must be filled in.

   @rdesc | Always returns 0;

***************************************************************************/

PRIVATE LRESULT FNLOCAL GetMapperStatus(
    LPMAPPERSTATUS          lpStat)
{
    MAPPERSTATUS            stat;


    if (lpStat->cbStruct < sizeof(stat))
        DPF(1, TEXT ("MAPPERSTATUS struct too small -- recompile MAPWATCH!!!"));

    stat.cbStruct               = lpStat->cbStruct;
//    stat.DS                     = __segname("_DATA");
    stat.ghinst                 = ghinst;
    stat.gwFlags                = gwFlags;
    stat.gwConfigWhere          = gwConfigWhere;
    stat.pgapChannel            = gapChannel;
    stat.gpportList             = gpportList;
    stat.gpinstanceList         = gpinstanceList;
    stat.gpinstrumentList       = gpinstrumentList;
    stat.lpszVersion            = szVersion;

    hmemcpy(lpStat, &stat, (UINT)lpStat->cbStruct);

    return 0;
}


/***************************************************************************

   @doc internal

   @api BOOL | DllEntryPoint | Entry point for the DLL

   @parm HINSTANCE | hinstDLL | handle of DLL module

   @parm DWORD | fdwReason | Why function was called

   @parm LPVOID | lpvReserved | Reserved = must be NULL

   @rdesc | Should always return TRUE for success.

***************************************************************************/
BOOL WINAPI DllEntryPoint(
   HINSTANCE         hinstDLL,
   DWORD             fdwReason,
   LPVOID            lpvReserved)
{
   static TCHAR BCODE   szSection[]    = TEXT ("MIDIMAP");
   static TCHAR BCODE   szSystemIni[]  = TEXT ("system.ini");
   static HANDLE        hThread        = NULL;
   DWORD                dw;

   switch (fdwReason)
      {
      case DLL_PROCESS_ATTACH:
#ifdef DEBUG
         {
            UINT     uDebugLevel;

            uDebugLevel = DbgInitialize(TRUE);

            DPF(0, TEXT ("DllEntryPoint - DLL_PROCESS_ATTACH (hinstDLL=%.4Xh, lpvReserved=%.08lXh)"),
                hinstDLL, lpvReserved);

            DPF(0, TEXT ("Debug Level = %u"), uDebugLevel);

            if (2 <= uDebugLevel)
               DebugBreak();
         }
#endif
         // Save our instance handle in a global.
         //
         ghinst = hinstDLL;

         // Initialize Synchronization object
         //
         QueueInit(&gqFreeSyncObjs);

        // Initialize modLongMessage RefCnt Synchronization Object
        hMutexRefCnt = CreateMutex (NULL, FALSE, gszRefCnt);

        // Initialize Configure Synchronization Object
        hMutexConfig = CreateMutex (NULL, FALSE, NULL);

         break;

      case DLL_THREAD_ATTACH:
#ifdef DEBUG
         DPF(0, TEXT ("DllEntryPoint - DLL_THREAD_ATTACH (hinstDLL=%.4Xh, lpvReserved=%.08lXh)"),
                hinstDLL, lpvReserved);
#endif
         break;

      case DLL_THREAD_DETACH:
#ifdef DEBUG
         DPF(0, TEXT ("DllEntryPoint - DLL_THREAD_DETACH (hinstDLL=%.4Xh, lpvReserved=%.08lXh)"),
                hinstDLL, lpvReserved);
#endif
         break;

      case DLL_PROCESS_DETACH:
	 // Cleanup Configure Synchronization Object
	 //
         if (NULL != hMutexConfig) CloseHandle (hMutexConfig);

	 // Cleanup modLongMessage RefCnt Synchronization Object
	 //
	 if (NULL != hMutexRefCnt) CloseHandle (hMutexRefCnt);

	 // Cleanup Synchronization object
         //
         QueueCleanup(&gqFreeSyncObjs);

         // cleanup instance handle
         //
         ghinst = NULL;

#ifdef DEBUG
         DPF(0, TEXT ("DllEntryPoint - DLL_PROCESS_DETACH (hinstDLL=%.4Xh, lpvReserved=%.08lXh)"),
                hinstDLL, lpvReserved);
#endif
         break;
      } // End switch (fdwReason)

   return TRUE;
} // End DllEntryPoint
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\midimap\debug.h ===
//==========================================================================;
//
//      Copyright (c) 1991-1995 Microsoft Corporation
//
//      You have a royalty-free right to use, modify, reproduce and 
//      distribute the Sample Files (and/or any modified version) in 
//      any way you find useful, provided that you agree that 
//      Microsoft has no warranty obligations or liability for any 
//      Sample Application Files which are modified. 
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//
//
//  Notes:
//
//      To use this library at interrupt time under Win16, you must do
//      the following:
//
//      1. Defined ISRDEBUG when compiling debug.c
//  
//      2. Add a line in the SEGMENTS section of your .DEF file to
//         define the DEBUG_TEXT segment:
//
//
//      SEGMENTS
//          DEBUG_TEXT FIXED PRELOAD
//
//
//      These routines are callable at interrupt time under Win32 by
//      default.
//
//      3. No need for UNICODE support for debug routines
//
//  win.ini
//  [debug]
//  MIDIMAP=0|1|2|3|4
//
//  History:
//      11/23/92    cjp     [curtisp] 
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//  
//
//
//
#define  ISRDEBUG             1
#define  DEBUG_SECTION        TEXT ("debug")   // section name for 
#define  DEBUG_MODULE_NAME    TEXT ("MIDIMAP") // key name and prefix for output
#define  DEBUG_MAX_LINE_LEN   255              // max line length (bytes)

#define  K_DEFAULT_LOGMEM     32
#define  K_MAX_LOGMEM         63
    
#define  DRV_ENABLE_DEBUG     (DRV_USER+1)   // Enable/disable debug message
#define  DRV_SET_DEBUG_LEVEL  (DRV_USER+2)   // Message to set the debug level

#define WM_DEBUGUPDATE        (WM_USER+1000)

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    VOID WINAPI WinAssert(LPSTR lpstrExp, LPSTR lpstrFile, DWORD dwLine);
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);
    void WINAPI DbgRegisterCallback(HWND hWnd);
    BOOL WINAPI DbgGetNextLogEntry(LPTSTR lpstrBuffer, UINT cbBuffer);

    void FAR CDECL dprintf(UINT uDbgLevel, LPTSTR szFmt, ...);

    #define assert(exp) \
        ( (exp) ? (void) 0 : WinAssert(#exp, __FILE__, __LINE__) )

    #define DPF                  dprintf

    #define D1(sz)               dprintf(1,sz) 
    #define D2(sz)               dprintf(2,sz) 
    #define D3(sz)               dprintf(3,sz) 
    #define D4(sz)               dprintf(4,sz) 
#else
    #define assert(exp)          ((void)0)
    
    #define DbgEnable(x)         FALSE
    #define DbgSetLevel(x)       0
    #define DbgInitialize(x)     0

    #define DPF                  1 ? (void)0 : (void)

    #define D1(sz)
    #define D2(sz)
    #define D3(sz)
    #define D4(sz)
#endif


#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\midimap\idf.h ===
//************************************************************************
//**
//**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//**  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
//**  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
//**  A PARTICULAR PURPOSE.
//**
//**  Copyright (c) 1993-1995 Microsoft Corporation
//**
//**  IDF.h
//**
//**  DESCRIPTION:
//**     This file contains the format of the .IDF files.
//**
//**  HISTORY:
//**     04/29/93       created.
//**     07/04/93       added UNICODE for displayable strings.
//**     09/04/93       added keymaps.
//**     09/05/93       added ID's for channel types.
//**
//************************************************************************

/*
@doc  EXTERNAL SDK

@types   IDFHEADER |
   This is the format of the "hdr " chunk in a Microsoft IDF file.
   This will be the first subchunk of a "MMAP" list chunk.  This will 
   provide information on the IDF itself; what version, who created it,
   and a unique ASCII ID for the instrument.

@field   DWORD | cbStruct |
   This is the inclusive size of the header structure.

@field   DWORD | dwVersion |
   This is the version of the IDF file.
   under.

@field   DWORD | dwCreator |
   This is the creator ID for the IDF.

@field   DWORD | cbInstID |
   This is the size of the unique instrument identifier including the NULL.

@field   BYTE | abInstID[] |
   This is the actual ASCII bytes of the unique instrument id. This _IS_ 
   NULL terminated.  There is no UNICODE version of this since this will
   only be used internally and not displayed to the user.

@othertype  IDFHEADER * | PIDFHEADER |
   A memory model dependant pointer to the structure.

@othertype  IDFHEADER FAR* | LPIDFHEADER |
   A far pointer to the structure.
*/

typedef struct tag_IDFHEADER
{
   DWORD cbStruct;

   DWORD dwVersion;
   DWORD dwCreator;

   DWORD cbInstID;
   BYTE  abInstID[1];
} IDFHEADER, *PIDFHEADER, FAR *LPIDFHEADER;


/*
@doc  EXTERNAL SDK

@types   IDFINSTINFO |
   This is the format of the "inst" chunk in a Microsoft IDF file.
   This chunk will contain information on the instrument, e.g. who
   manufactured it, the name of the instrument, it's manufacturer and
   product id's and a revision number.

@field   DWORD | cbStruct |
   This is the inclusive size of the instrument information structure.

@field   DWORD | dwManufactID |
   Manufacturer's ID.

@field   DWORD | dwProductID |
   Product's ID.

@field   DWORD | dwRevision |
   Revision of the product.

@field   DWORD | cbManufactASCII |
   Length of the ASCII version of the manufacturuers name.

@field   DWORD | cbManufactUNICODE |
   Length of the UNICODE version of the manufacturuers name.

@field   DWORD | cbProductASCII |
   Length of the ASCII version of the product name.

@field   DWORD | cbProductUNICODE |
   Length of the UNICODE version of the product name.

@field   BYTE | abData[] |
   Contains the ASCII and UNICODE strings for the manufacturer and product
   names.  NOTE that all strings are separated by a NULL and the NULL IS
   counted in the string lengths.

@othertype  IDFINSTINFO * | PIDFINSTINFO |
   A memory model dependant pointer to the structure.

@othertype  IDFINSTINFO FAR * | LPIDFINSTINFO |
   A far pointer to the structure.

@comm The idea is that the cbManufactXXXXX and cbProductXXXXX will be the
      offsets into the bData array of bytes and it will contain a complete
      string that you can strcpy out.  That is why the NULL is included in
      the byte count and in the actual data.
*/

typedef struct tag_IDFINSTINFO
{
   DWORD cbStruct;

   DWORD dwManufactID;
   DWORD dwProductID;
   DWORD dwRevision;

   DWORD cbManufactASCII;
   DWORD cbManufactUNICODE;
   DWORD cbProductASCII;
   DWORD cbProductUNICODE;

   BYTE  abData[1];
} IDFINSTINFO, FAR *LPIDFINSTINFO;

/*
@doc  EXTERNAL SDK

@types   IDFINSTCAPS |
   This is the format of the "caps" chunk in a Microsoft IDF file.
   This chunk will contain information on the MIDI capabilities of
   the device. e.g. basic channel of the instrument, number of channels
   that the instrument has available. the polyphony of the instrument, 
   whether or not it supports General MIDI, etc....

@field   DWORD | cbStruct |
   This is the size of the capabilities structure.

@field   DWORD | fdwFlags |
   Flags specifiying additional capabilities of an instrument.

@flag IDFINSTCAPS_F_GENERAL_MIDI |
   Instrument supports General MIDI.

@flag IDFINSTCAPS_F_SYSTEMEXCLUSIVE |
   Instrument supports system exclusive messages

@field   DWORD | dwBasicChannel |
   The basic channel for the instrument.

@field   DWORD | cNumChannels |
   Number of channels that the instrument supports to.

@field   DWORD | cInstrumentPolyphony |
   The total polyphony for the instrument.

@field   DWORD | cChannelPolyphony |
   The polyphony per channel.

@othertype  IDFINSTCAPS * | PIDFINSTCAPS |
   A memory model dependant pointer to the structure.

@othertype  IDFINSTCAPS FAR * | LPIDFINSTCAPS |
   A far pointer to the structure.
*/

typedef struct tag_IDFINSTCAPS
{
   DWORD cbStruct;
   DWORD fdwFlags;
   DWORD dwBasicChannel;
   DWORD cNumChannels;
   DWORD cInstrumentPolyphony;
   DWORD cChannelPolyphony;
} IDFINSTCAPS, *PIDFINSTCAPS, FAR *LPIDFINSTCAPS;

#define  IDFINSTCAPS_F_GENERAL_MIDI       0x00000001
#define  IDFINSTCAPS_F_SYSTEMEXCLUSIVE    0x00000002

/*
@doc  EXTERNAL SDK

@types   IDFCHANNELHDR |
   This is the format of the "chan" chunk in a Microsoft IDF file.
   This contains a description on what "type" a channel is, i.e. 
   is it a General MIDI channel, a drum channel, etc... Directly 
   following this header is the actual data on each channel.

@field   DWORD | cbStruct |
   This is the size of the channel header structure.

@field   DWORD | fdwFlags |
   Flags describing the channel type information.

@flag IDFCHANNELHDR_F_GENERAL_MIDI |
   If this flag is set then any channels that are not defined in the 
   IDF are General MIDI channel types.  If this flag is _NOT_ set then
   any channels that are not defined in the IDF are undefined and should 
   NOT be used in mapping. This flag overrides the contents of dwGeneralMask
   and dwDrumMask.

@field DWORD | dwGeneralMask |
   This mask indicates which channels are available for
   use as general channels. The channels will be considered usable even if
   there is no associcate IDFCHANNELINFO structure defined.

@field DWORD | dwDrumMask |
   This mask indicates which channels are available for
   use as drum channels. The channels will be considered usable even if
   there is no associcate IDFCHANNELINFO structure defined.

@field   DWORD | cNumChannels |
   This is the number of channels that follows the header.

@othertype  IDFCHANNELHDR * | PIDFCHANNELHDR |
   A memory model dependant pointer to the structure.

@othertype  IDFCHANNELHDR FAR * | LPIDFCHANNELHDR |
   A far pointer to the structure.
*/

typedef struct tag_IDFCHANNELHDR
{
   DWORD cbStruct;
   DWORD dwGeneralMask;
   DWORD dwDrumMask;
   DWORD dwReserved;                    // Must be zero
   DWORD fdwFlags;
} IDFCHANNELHDR, *PIDFCHANNELHDR, FAR *LPIDFCHANNELHDR;

#define  IDFCHANNELHDR_F_GENERAL_MIDI     0x00000001


/*
@doc  EXTERNAL SDK

@types    IDFCHANNELINFO |
   This is the format of the actual channel information for Microsoft
   authored IDF files. This is the Microsoft supported format for
   channel information.

@field   DWORD | dwChannel |
   This is the channel number that the structure defines.

@field   DWORD | fdwChannel |
   Defines the possible types this channel can be.

   @flag    IDFCHANNELINFO_F_GENERAL_CHANNEL |
       Indicates that this channel may be a general channel.

   @flag    IDFCHANNELINFO_F_DRUM_CHANNEL |
       Indicates that this channel may be a drum channel.

@field   DWORD | cbInitData |
    Specifies the length of the data which should be sent to initialize
    the channel. This data will be send to initialize the channel each
    time the mapper is opened.

@field    BYTE | abData[] |
    This field contains the actual initialization data.
    <f cbInitData> should indicate the length of this sequence,
    byte aligned. However, the actual sequence should be padded so that
    it is actually DWORD aligned (i.e. even multiple
    of four bytes). <f cbStruct> should reflect the padded length of
    the sequences.
        
@othertype  IDFCHANNELINFO * | PIDFCHANNELINFO |
   A memory model dependant pointer to the structure.

@othertype  IDFCHANNELINFO FAR * | LPIDFCHANNELINFO |
   A far pointer to the structure.
*/

typedef struct tag_IDFCHANNELINFO
{
   DWORD cbStruct;
   DWORD dwChannel;
   DWORD cbInitData;
   BYTE  abData[];
} IDFCHANNELINFO, *PIDFCHANNELINFO, FAR *LPIDFCHANNELINFO;

/*
@doc  EXTERNAL SDK

@types   IDFPATCHMAPHDR |
   This is the format of the "map " chunk in a Microsoft IDF file.
   This chunk contains information on the patch map used for the 
   instrument. Directly following this header is the actual mapping 
   information for each patch.

@field   DWORD | cbStruct |
   This is the size of the patch map header structure.

@field   BYTE | abPatchMap[128] |
   This array contains the actual patch map. The incoming patch is
   used to index the array; the array contents are the new patch value
   and must be in the range 0x00-0x7F. Patch maps will only apply to
   channels of type general. If the instrument needs a patch change
   on a drum channel, it should be included in the initialization data
   in the IDFCHANNELINFO.

@othertype  IDFPATCHMAPHDR * | PIDFPATCHMAPHDR |
   A memory model dependant pointer to the structure.

@othertype  IDFPATCHMAPHDR FAR * | LPIDFPATCHMAPHDR |
   A far pointer to the structure.
*/

typedef struct tag_IDFPATCHMAPHDR
{
   DWORD cbStruct;
   BYTE  abPatchMap[128];
           
} IDFPATCHMAPHDR, *PIDFPATCHMAPHDR, FAR *LPIDFPATCHMAPHDR;

/*
@doc  EXTERNAL SDK

@types   IDFKEYMAPHDR |
   This is the format of the "key " chunk in a Microsoft IDF file.
   This chunk contains information on the all of the key maps used 
   for a given instrument. The information that is in this structure
   pertains to all of the key maps for the instrument.  It contains
   the total number of key maps for the instrument and whether or not
   the key maps are General MIDI.

@field   DWORD | cbStruct |
   This is the size of the key map header structure.

@field   DWORD | cNumKeyMaps |
   This is the number of key maps that follow the header.

@field   DWORD | cbKeyMap |
   This is the size of each key map that follows the header.   

@othertype  IDFPATCHMAPHDR * | PIDFPATCHMAPHDR |
   A memory model dependant pointer to the structure.

@othertype  IDFPATCHMAPHDR FAR * | LPIDFPATCHMAPHDR |
   A far pointer to the structure.
*/

typedef struct tag_IDFKEYMAPHDR
{
   DWORD cbStruct;
   DWORD cNumKeyMaps;
   DWORD cbKeyMap;
} IDFKEYMAPHDR, *PIDFKEYMAPHDR, FAR *LPIDFKEYMAPHDR;

/*
@doc  EXTERNAL SDK

@types   IDFKEYMAP |
   This is the format of the "gkey" or "dkey" chunk in a Microsoft
   IDF file. This chunk contains information on the all of the key maps
   used for a given instrument. The information that is in this structure
   pertains to all of the key maps for the instrument.  It contains
   the total number of key maps for the instrument and whether or not
   the key maps are General MIDI.

@field   DWORD | cbStruct |
   This is the size of the key map header structure.

@field   BYTE | abKeyMap[128] |
    This field contains the actual key map. The incoming key number from
    a note on or note off message is used to index this array; the array
    contents are the new key value. If the high bit it set in the new
    key value, then the note on or note off will be ignore; otherwise,
    it will be transmitted with the new key value.
    
@othertype  IDFKEYMAP * | PIDFKEYMAP |
   A memory model dependant pointer to the structure.

@othertype  IDFKEYMAP FAR * | LPIDFKEYMAP |
   A far pointer to the structure.
*/

typedef struct tag_IDFKEYMAP
{
   DWORD cbStruct;
   BYTE  abKeyMap[128];
} IDFKEYMAP, *PIDFKEYMAP, FAR *LPIDFKEYMAP;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\midimap\locks.c ===
/**********************************************************************

  Copyright (c) 1992-1995 Microsoft Corporation

  locks.c

  DESCRIPTION:
    Code to lock each of the FIX'ed segments so they are only
    fixed when they need to be.

  HISTORY:
     03/03/94       [jimge]        created.

*********************************************************************/

#include "preclude.h"
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "idf.h"

#include "midimap.h"
#include "debug.h"

// Lock/unlock routines for code segments are stored in that segment
// so we know the segment will be in memory when GlobalSmartPageLock
// is called (else it will fail).
//
#ifndef WIN32
   #pragma allocTEXT ext(TEXT EXT, LockMapperData)
   #pragma allocTEXT ext(TEXT EXT, UnlockMapperData)
   #pragma allocTEXT ext(MAPPACKED_FIX, LockPackedMapper)
   #pragma allocTEXT ext(MAPPACKED_FIX, UnlockPackedMapper)
   #pragma allocTEXT ext(MAPCOOKED_FIX, LockCookedMapper)
   #pragma allocTEXT ext(MAPCOOKED_FIX, UnlockCookedMapper)
#endif // End #ifndef WIN32


void FNGLOBAL LockMapperData(
    void)
{
    DPF(2, TEXT ("LockMapperData"));
    if (!GlobalSmartPageLock(__segname("_DATA")))
    {
        DPF(1, TEXT ("LockMapperData: GlobalSmartPageLock() failed!!!"));
    }
}

void FNGLOBAL UnlockMapperData(
    void)
{
    DPF(2, TEXT ("UnlockMapperData"));
    if (!GlobalSmartPageUnlock(__segname("_DATA")))
    {
        DPF(1, TEXT ("UnlockMapperData: GlobalSmartPageUnlock() failed!!!"));
    }
}

void FNGLOBAL LockPackedMapper(
    void)
{
    DPF(2, TEXT ("LockPackedMapper"));
    if (!GlobalSmartPageLock(__segname("MAPPACKED_FIX")))
    {
        DPF(1, TEXT ("LockPackedMapper: GlobalSmartPageLock() failed!!!"));
    }
}

void FNGLOBAL UnlockPackedMapper(
    void)
{
    DPF(2, TEXT ("UnlockPackedMapper"));
    if (!GlobalSmartPageUnlock(__segname("MAPPACKED_FIX")))
    {
        DPF(1, TEXT ("UnlockPackedMapper: GlobalSmartPageUnlock() failed!!!"));
    }
}

void FNGLOBAL LockCookedMapper(
    void)
{
    DPF(2, TEXT ("LockCookedMapper"));
    if (!GlobalSmartPageLock(__segname("MAPCOOKED_FIX")))
    {
        DPF(1, TEXT ("LockCookedMapper: GlobalSmartPageLock() failed!!!"));
    }
}

void FNGLOBAL UnlockCookedMapper(
    void)
{
    DPF(2, TEXT ("UnlockCookedMapper"));
    if (!GlobalSmartPageUnlock(__segname("MAPCOOKED_FIX")))
    {
        DPF(1, TEXT ("UnlockCookedMapper: GlobalSmartPageUnlock() failed!!!"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\midimap\libentry.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   LIBENTRY.ASM
;
;   Copyright (c) 1989-1995 Microsoft Corporation
;
;   This module contains the entry point for MidiMap.dll
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        PMODE = 1

        include cmacros.inc                   

?PLM=1  ; pascal call convention
?WIN=0  ; Windows prolog/epilog code

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   extrns
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        externFP LibMain
        externFP LocalInit

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Code segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

;-----------------------------------------------------------------------;
;
; Stuff needed to avoid the C runtime coming in, and init the windows
; reserved parameter block at the base of DGROUP
;
sBegin  Data
assumes DS,Data

            DD  0               ; So null pointers get 0
maxRsrvPtrs = 5
            DW  maxRsrvPtrs
usedRsrvPtrs = 0
labelDP     <PUBLIC,rsrvptrs>

DefRsrvPtr  MACRO   name
globalW     name,0
usedRsrvPtrs = usedRsrvPtrs + 1
ENDM

DefRsrvPtr  pLocalHeap          ; Local heap pointer
DefRsrvPtr  pAtomTable          ; Atom table pointer
DefRsrvPtr  pStackTop           ; top of stack
DefRsrvPtr  pStackMin           ; minimum value of SP
DefRsrvPtr  pStackBot           ; bottom of stack

if maxRsrvPtrs-usedRsrvPtrs
            DW maxRsrvPtrs-usedRsrvPtrs DUP (0)
endif

public  __acrtused
	__acrtused = 1

sEnd        Data

sBegin  CodeSeg
	assumes cs,CodeSeg
        assumes ds,Data
        assumes es,nothing

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       Library entry point
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;--------------------------Private-Routine-----------------------------;
;
; LibEntry - called when DLL is loaded
;
; Entry:
;       CX    = size of heap
;       DI    = module handle
;       DS    = automatic data segment
;       ES:SI = address of command line (not used)
;
; Returns:
;       AX = TRUE if success
; Error Returns:
;       AX = FALSE if error (ie fail load process)
; Registers Preserved:
;	SI,DI,DS,BP
; Registers Destroyed:
;       AX,BX,CX,DX,ES,FLAGS
; Calls:
;	None
; History:
;
;       06-27-89 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;

cProc   LibEntry,<FAR,PUBLIC,NODATA>,<>
cBegin
	;
        ; Push frame for LibMain (hModule,cbHeap,lpszCmdLine)
	;
	push	di
	push	cx
	push	es
	push	si

        ;
        ; Init the local heap (if one is declared in the .def file)
        ;
        jcxz no_heap

        xor     ax,ax
        cCall   LocalInit,<ax,ax,cx>

no_heap:
        cCall   LibMain
cEnd

	assumes ds,nothing
	assumes es,nothing

cProc   WEP, <FAR, PUBLIC, PASCAL>, <>
;	ParmW  fSystemExit
cBegin nogen
	mov	ax, 1
	retf	2
cEnd   nogen

        sEnd CodeSeg

        end LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\midimap\file.c ===
/**********************************************************************

  Copyright (c) 1992-1995 Microsoft Corporation

  file.c

  DESCRIPTION:
    Code to read stuff out of IDF files.

  HISTORY:
     02/26/93       [jimge]        created (copied from IDFEDIT).

*********************************************************************/

#include "preclude.h"
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "idf.h"

#include <ctype.h>

#include "midimap.h"
#include "debug.h"

/***************************************************************************
  
   @doc internal
  
   @api LPIDFHEADER | ReadHeaderChunk | Read the header chunk from a IDF
    file. 

   @parm HMMIO | hmmio | Handle to the file to read from.

   @parm LPMMCKINFO | pchkParent | Pointer to a chunk information structure
    which describes the parent chunk.

   @comm
    Must already be descended into the parent chunk.

    This function will GlobalAlloc memory to read the chunk into.
    The caller must free it when he is done with it.

   @rdesc NULL on failure or a far pointer to the header structure.
       
***************************************************************************/
LPIDFHEADER FNLOCAL ReadHeaderChunk(
    HMMIO               hmmio,                                    
    LPMMCKINFO          pchkParent)
{
    LPIDFHEADER         pIDFHeader;
    MMRESULT            mmr;
    MMCKINFO            chkSub;
    LONG                l;

    // We are looking for the instruments header chunk.
    //
    chkSub.ckid = mmioFOURCC('h', 'd', 'r', ' ');

    // Descend to the "hdr " chunk in this list.
    //
    mmioSeek(hmmio, pchkParent->dwDataOffset + sizeof(FOURCC), SEEK_SET);
    mmr = mmioDescend(hmmio, &chkSub, pchkParent, MMIO_FINDCHUNK);
    if (MMSYSERR_NOERROR != mmr)
    {
        // Could not find the chunk.
        //
        DPF(1, TEXT ("ReadHeaderChunk: mmr %u on mmioDescend"), (UINT)mmr);
        return NULL;
    }

    // We found the "hdr " chunk, now check it's size and
    // see if it is one that we can read.
    // We check to make sure that the size of the chunks is
    // greater than a IDFHEADER, this ensures that the IDF
    // has some sort of unique name at the end.
    //
    if (sizeof(IDFHEADER) >= chkSub.cksize)
    {
        // The sizeof the IDF header is not what we expected.
        //
        DPF(1, TEXT ("ReadHeaderChunk: Chunk size too small"));
        mmioAscend(hmmio, &chkSub, 0);
        return NULL;
    }

    // Allocate memory for the header.
    //
    pIDFHeader = (LPIDFHEADER)GlobalAllocPtr(GHND, chkSub.cksize);
    if (NULL == pIDFHeader)
    {
        mmioAscend(hmmio, &chkSub, 0);
        return NULL;
    }

    // Read in the whole chunk into our buffer.
    //
    l = mmioRead(hmmio, (HPSTR)pIDFHeader, chkSub.cksize);
    if (chkSub.cksize != (DWORD)l)
    {
        // We didn't read in the amount of data that was
        // expected, return in error.
        //
        GlobalFreePtr(pIDFHeader);
        mmioAscend(hmmio, &chkSub, 0);
        return NULL;
    }

    // Ascend out of the chunk.
    //
    mmioAscend(hmmio, &chkSub, 0);

    // Return success.
    //
    return pIDFHeader;
}

/***************************************************************************
  
   @doc internal
  
   @api LPIDFINSTCAPS | ReadCapsChunk | Read the instrument capabilty
    chunk from an IDF file. 

   @parm HMMIO | hmmio | Handle to the file to read from.

   @parm LPMMCKINFO | pchkParent | Pointer to a chunk information structure
    which describes the parent chunk.

   @comm
    Must already be descended into the parent chunk.

    This function will GlobalAlloc memory to read the chunk into.
    The caller must free it when he is done with it.

   @rdesc NULL on failure or a far pointer to the header structure.
       
***************************************************************************/
LPIDFINSTCAPS FNLOCAL ReadCapsChunk(
    HMMIO               hmmio,                               
    LPMMCKINFO          pchkParent)
{
    LPIDFINSTCAPS       lpIDFinstcaps;
    MMRESULT            mmr;
    MMCKINFO            chkSub;
    LONG                l;

    // We are looking for the instrument capabilities chunk.
    //
    chkSub.ckid = mmioFOURCC('c', 'a', 'p', 's');

    // Descend to the "caps" chunk in this list.
    //

    mmioSeek(hmmio, pchkParent->dwDataOffset + sizeof(FOURCC), SEEK_SET);
    mmr = mmioDescend(hmmio, &chkSub, pchkParent, MMIO_FINDCHUNK);
    if (MMSYSERR_NOERROR != mmr)
    {
        // Could not find the chunk.
        //
        return NULL;
    }

    // We found the "caps" chunk, now check it's size and
    // see if it is one that we can read.
    //
    if (sizeof(IDFINSTCAPS) != chkSub.cksize)
    {
        // The sizeof the IDF header is not what we expected.
        // 
        mmioAscend(hmmio, &chkSub, 0);
        return NULL;
    }

    lpIDFinstcaps = (LPIDFINSTCAPS)GlobalAllocPtr(GHND, chkSub.cksize);
    if (NULL == lpIDFinstcaps)
    {
        // Could not allocate memory for chunk
        //
        mmioAscend(hmmio, &chkSub, 0);
        return NULL;

    }

    // Read the instrument's capabilities from the file.
    //
    l = mmioRead(hmmio, (HPSTR)lpIDFinstcaps, sizeof(IDFINSTCAPS));
    if (sizeof(IDFINSTCAPS) != l)
    {
        // We didn't read in the amount of data that was
        // expected, return in error.
        //
        GlobalFreePtr(lpIDFinstcaps);
        mmioAscend(hmmio, &chkSub, 0);
        return NULL;
    }

    // Ascend out of the capabilities chunk.
    //
    mmioAscend(hmmio, &chkSub, 0);
    return lpIDFinstcaps;
}

/***************************************************************************
  
   @doc internal
  
   @api LPIDFCHANHELHDR | ReadChannelChunk | Read the channel information 
    chunk from an IDF file. 

   @parm HMMIO | hmmio | Handle to the file to read from.

   @parm LPMMCKINFO | pchkParent | Pointer to a chunk information structure
    which describes the parent chunk.

   @parm LPIDFCHANNELINFO | rglpChanInfo[] | Array of pointers to receive
    the channel information. The pointers will be allocated by this
    function; any channel without a channel description in the IDF file
    will fill the corresponding slot with NULL.

   @comm
    Must already be descended into the parent chunk.

    This function will GlobalAlloc memory to read the chunk into.
    The caller must free it when he is done with it.

    Caller must free memory in array even if function fails.

   @rdesc TRUE on success; else FALSE
       
***************************************************************************/
LPIDFCHANNELHDR FNLOCAL ReadChannelChunk(
    HMMIO               hmmio,                                  
    LPMMCKINFO          pchkParent,
    LPIDFCHANNELINFO BSTACK rglpChanInfo[])
{
    MMRESULT            mmr;
    MMCKINFO            chkSub;
    DWORD               cbIDFchnlinfo;
    LPIDFCHANNELINFO    lpIDFchnlinfo;
    LPIDFCHANNELHDR     lpIDFchanhdr;
    DWORD               c;
    LONG                cbRemain;

    // Default return value
    //
    lpIDFchanhdr = NULL;

    // Nuke anything currently in the return struct
    //
    for (c = 0; c < MAX_CHANNELS; c++)
        rglpChanInfo[c] = NULL;

    // We are looking for the instrument channel definitions.
    //
    chkSub.ckid = mmioFOURCC('c', 'h', 'a', 'n');

    // Descend to the "chnl" chunk in this list.
    //
    
    mmioSeek(hmmio, pchkParent->dwDataOffset + sizeof(FOURCC), SEEK_SET);
    mmr = mmioDescend(hmmio, &chkSub, pchkParent, MMIO_FINDCHUNK);
    if (MMSYSERR_NOERROR != mmr)
    {
        // Could not find the chunk.
        //
        DPF(1, TEXT ("chnl chunk not found."));
        return NULL;
    }

    // We found the "chnl" chunk, now check it's size and
    // make sure it's at least as big as a IDFCHANNELHDR.
    //
    if (sizeof(IDFCHANNELHDR) > chkSub.cksize)
    {
        // The sizeof the IDF header is not what we expected.
        //
        DPF(1, TEXT ("Channel chunk too small"));
        goto Read_Channel_Chunk_Err;
    }

    if (NULL == (lpIDFchanhdr = (LPIDFCHANNELHDR)GlobalAllocPtr(GHND, chkSub.cksize)))
    {
        DPF(1, TEXT ("No memory for channel header"));
        goto Read_Channel_Chunk_Err;
    }

    // Read the channel header in.
    //
    cbRemain = mmioRead(hmmio, (HPSTR)lpIDFchanhdr, chkSub.cksize);
    if (chkSub.cksize != (DWORD)cbRemain)
    {
        // Couldn't read in all of the header.
        //
        DPF(1, TEXT ("Channel chunk header size lied"));
        GlobalFreePtr(lpIDFchanhdr);
        lpIDFchanhdr = NULL;
        goto Read_Channel_Chunk_Err;
    }

    cbRemain -= sizeof(*lpIDFchanhdr);
    lpIDFchnlinfo = (LPIDFCHANNELINFO)(lpIDFchanhdr+1);

    // Read all the channels that are defined in the IDF.
    //
    cbIDFchnlinfo = 0;
    while (cbRemain > 0)
    {
        if (lpIDFchnlinfo->cbStruct < sizeof(IDFCHANNELINFO) ||
            lpIDFchnlinfo->cbStruct > (DWORD)cbRemain)
        {
            DPF(1, TEXT ("Bogus cbStruct in channel info"));
            GlobalFreePtr(lpIDFchanhdr);
            lpIDFchanhdr = NULL;
            goto Read_Channel_Chunk_Err;
        }

        if (lpIDFchnlinfo->dwChannel >= MAX_CHANNELS)
        {
            DPF(1, TEXT ("Channel number out of range (Channel info corrupt?)"));
            GlobalFreePtr(lpIDFchanhdr);
            lpIDFchanhdr = NULL;
            goto Read_Channel_Chunk_Err;
        }
        
        rglpChanInfo[lpIDFchnlinfo->dwChannel] = lpIDFchnlinfo;

        ((LPBYTE)lpIDFchnlinfo) += lpIDFchnlinfo->cbStruct;
        cbRemain -= lpIDFchnlinfo->cbStruct;
    }

Read_Channel_Chunk_Err:

    mmioAscend(hmmio, &chkSub, 0);
    return lpIDFchanhdr;
}

/***************************************************************************
  
   @doc internal
  
   @api LPIDFPATCHMAPHDR | ReadPatchMapChunk | Read the patch map chunk
    from a IDF file. 

   @parm HMMIO | hmmio | Handle to the file to read from.

   @parm LPMMCKINFO | pchkParent | Pointer to a chunk information structure
    which describes the parent chunk.

   @comm
    Must already be descended into the parent chunk.

    This function will GlobalAlloc memory to read the chunk into.
    The caller must free it when he is done with it.

   @rdesc NULL on failure or a far pointer to the header structure.
       
***************************************************************************/
LPIDFPATCHMAPHDR FNLOCAL ReadPatchMapChunk(
    HMMIO               hmmio,                                          
    LPMMCKINFO          pchkParent)
{
    MMRESULT            mmr;
    MMCKINFO            chkSub;
    LONG                l;
    LPIDFPATCHMAPHDR    lpIDFpatchmaphdr;

    // We are looking for the patch map for the instrument.
    //
    chkSub.ckid = mmioFOURCC('p', 'm', 'a', 'p');

    // Descend to the "pmap" chunk in this list.
    //
    mmioSeek(hmmio, pchkParent->dwDataOffset + sizeof(FOURCC), SEEK_SET);
    mmr = mmioDescend(hmmio, &chkSub, pchkParent, MMIO_FINDCHUNK);
    if (MMSYSERR_NOERROR != mmr)
    {
        // Could not find the chunk.
        //
        return NULL;
    }

    // We found the "pmap" chunk, now check it's size and
    // make sure it's at least as big as a IDFPATCHMAPHDR.
    //
    if (sizeof(IDFPATCHMAPHDR) > chkSub.cksize)
    {
        // The sizeof the IDF header is not what we expected.
        // 
        mmioAscend(hmmio, &chkSub, 0);
        return NULL;
    }

    lpIDFpatchmaphdr = (LPIDFPATCHMAPHDR)GlobalAllocPtr(GHND, chkSub.cksize);
    if (NULL == lpIDFpatchmaphdr)
    {
        mmioAscend(hmmio, &chkSub, 0);
        return NULL;
    }

    // Read the channel header in.
    //
    l = mmioRead(hmmio, (HPSTR)lpIDFpatchmaphdr, sizeof(IDFPATCHMAPHDR));
    if (sizeof(IDFPATCHMAPHDR) != l)
    {
        // Couldn't read in all of the header.
        //
        mmioAscend(hmmio, &chkSub, 0);
        return NULL;
    }

    mmioAscend(hmmio, &chkSub, 0);

    // Return success.
    //
    return lpIDFpatchmaphdr;
}

PRIVATE void FNLOCAL ReadSingleKeyMap(
    HMMIO               hmmio,
    LPMMCKINFO          pchkParent,
    LPIDFKEYMAP BSTACK *pIDFkeymap,
    FOURCC              fccChunk)
{
    MMRESULT            mmr;
    MMCKINFO            chkSub;
    LONG                l;

    chkSub.ckid = fccChunk;
    *pIDFkeymap = NULL;

    mmioSeek(hmmio, pchkParent->dwDataOffset + sizeof(FOURCC), SEEK_SET);
    mmr = mmioDescend(hmmio, &chkSub, pchkParent, MMIO_FINDCHUNK);
    if (MMSYSERR_NOERROR == mmr)
    {
        DPF(1, TEXT ("Located key chunk"));

        if (sizeof(IDFKEYMAP) > chkSub.cksize)
        {
            DPF(1, TEXT ("key chunk is incomplete"));
            mmioAscend(hmmio, &chkSub, 0);
            return;
        }

        *pIDFkeymap = (LPIDFKEYMAP)GlobalAllocPtr(GHND, chkSub.cksize);
        if (NULL == *pIDFkeymap)
        {
            DPF(1, TEXT ("No memory for key chunk"));
            mmioAscend(hmmio, &chkSub, 0);
            return;
        }

        l = mmioRead(hmmio, 
                       (HPSTR)(*pIDFkeymap),
                       chkSub.cksize);
        
        if (chkSub.cksize != (DWORD)l)
        {
            DPF(1, TEXT ("Error reading key chunk"));
            mmioAscend(hmmio, &chkSub, 0);
            GlobalFreePtr(*pIDFkeymap);
            *pIDFkeymap = NULL;
        }
    }
}
                                      

/***************************************************************************
  
   @doc internal
  
   @api BOOL | ReadKeyMapChunk | Read the key map information 
    chunk from an IDF file. 

   @parm HMMIO | hmmio | Handle to the file to read from.

   @parm LPMMCKINFO | pchkParent | Pointer to a chunk information structure
    which describes the parent chunk.

   @parm LPIDFKEYMAP | rglpIDFkeymap[] | Array of pointers to receive
    the key map information. The pointers will be allocated by this
    function; any channel without a channel description in the IDF file
    will fill the corresponding slot with NULL.

   @comm
    Must already be descended into the parent chunk.

    This function will GlobalAlloc memory to read the chunk into.
    The caller must free it when he is done with it.

    Caller must free memory in array even if function fails.
    
   @rdesc TRUE on success; else FALSE
       
***************************************************************************/
void FNLOCAL ReadKeyMapChunk(
    HMMIO               hmmio,                                  
    LPMMCKINFO          pchkParent,
    LPIDFKEYMAP BSTACK  rglpIDFkeymap[])
{
    UINT                iKeyMap;
    
    // Initialize the in-memory key maps to default values before
    // we try reading anything. Default is a 1:1 nul mapping.
    //
    for (iKeyMap = 0; iKeyMap < MAX_CHAN_TYPES; iKeyMap++)
        rglpIDFkeymap[iKeyMap] = NULL;

    ReadSingleKeyMap(hmmio,
                     pchkParent,
                     &rglpIDFkeymap[IDX_CHAN_GEN],
                     mmioFOURCC('g', 'k', 'e', 'y'));
        
    ReadSingleKeyMap(hmmio,
                     pchkParent,
                     &rglpIDFkeymap[IDX_CHAN_DRUM],
                     mmioFOURCC('d', 'k', 'e', 'y'));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\midimap\mididev.c ===
/**********************************************************************

  Copyright (c) 1992-1999 Microsoft Corporation

  mididev.c

  DESCRIPTION:
    Code to match device ID's with associated registry entries

  HISTORY:
     02/24/95       [jimge]        created.

*********************************************************************/
#include <windows.h>
#include <windowsx.h>
#include <winerror.h>
#include <regstr.h>
#include <mmsystem.h>
#include <mmddkp.h>

#include "idf.h"
#include "midimap.h"
#include "debug.h"

typedef struct tagMDEV_NODE *PMDEV_NODE;
typedef struct tagMDEV_NODE
{
    PMDEV_NODE              pNext;
    TCHAR                   szAlias[CB_MAXALIAS];
    DWORD                   dwDevNode;
    TCHAR                   szDriver[CB_MAXDRIVER];
    UINT                    uDeviceID;
    UINT                    uPort;
    BOOL                    fNewDriver;
} MDEV_NODE;

static TCHAR BCODE gszMediaRsrcKey[] =
    REGSTR_PATH_MEDIARESOURCES TEXT ("\\MIDI");

static TCHAR BCODE gszDriverKey[] =
    REGSTR_PATH_MEDIARESOURCES TEXT ("\\MIDI\\%s");

static TCHAR BCODE gszDriverValue[]          = TEXT ("Driver");
static TCHAR BCODE gszDevNodeValue[]         = TEXT ("DevNode");
static TCHAR BCODE gszPortValue[]            = TEXT ("Port");
static TCHAR BCODE gszActiveValue[]          = TEXT ("Active");
static TCHAR BCODE gszMapperConfig[]         = TEXT ("MapperConfig");

static PMDEV_NODE gpMDevList                = NULL;
static DWORD gdwNewDrivers                  = (DWORD)-1L;

PRIVATE BOOL FNLOCAL mdev_BuildRegList(
    void);

PRIVATE BOOL FNLOCAL mdev_SyncDeviceIDs(
    void);

PRIVATE BOOL FNLOCAL mdev_MarkActiveDrivers(
    void);

#ifdef DEBUG
PRIVATE VOID FNLOCAL mdev_ListActiveDrivers(
    void);                                         
#endif

BOOL FNGLOBAL mdev_Init(
    void)
{
    if (gpMDevList)
        mdev_Free();

    if ((!mdev_BuildRegList()) ||
        (!mdev_SyncDeviceIDs()) ||
        (!mdev_MarkActiveDrivers()))
    {
        mdev_Free();
        return FALSE;
    }
    
#ifdef DEBUG
    mdev_ListActiveDrivers();
#endif
    
    return TRUE;
}

//
// mdev_BuildRegList
//
// Builds the base device list out of the registry
//
// Assumes the list has been cleared
//
// For each alias (key) under MediaResources\MIDI
//  Make sure the Active value exists and is '1'
//  Allocate a list node
//  Try to read the alias's devnode
//  If the alias's devnode is 0 or missing,
//   Read the alias's driver name
//  Read the alias's port number
//  Add the alias to the global list
//
// The uDeviceID member will not be initialized by this routine;
// mdev_SyncDeviceIDs must be called to figure out the current
// device ID mapping.
//
PRIVATE BOOL FNLOCAL mdev_BuildRegList(
    void)
{
    BOOL                    fRet            = FALSE;
    HKEY                    hKeyMediaRsrc   = NULL;
    HKEY                    hKeyThisAlias   = NULL;
    DWORD                   dwEnumAlias     = 0;
    LPTSTR                  pstrAlias       = NULL;
    PMDEV_NODE              pmd             = NULL;
    TCHAR                   szActive[2];
    DWORD                   dwPort;
    DWORD                   cbValue;
    DWORD                   dwType;
    DWORD                   dwMapperConfig;
    
	cbValue = CB_MAXALIAS * sizeof(TCHAR);
    pstrAlias = (LPTSTR)LocalAlloc(LPTR, CB_MAXALIAS * sizeof(TCHAR));
    if (NULL == pstrAlias)
    {
        DPF(1, TEXT ("mdev_Init: Out of memory"));
        goto mBRL_Cleanup;
    }

    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
                                    gszMediaRsrcKey,
                                    &hKeyMediaRsrc))
    {
        DPF(1, TEXT ("mdev_Init: Could not open ...\\MediaResoruces\\MIDI"));
        goto mBRL_Cleanup;
    }

    
    while (ERROR_SUCCESS == RegEnumKey(hKeyMediaRsrc,
                                       dwEnumAlias++,
                                       pstrAlias,
                                       CB_MAXALIAS))
    {
        if (ERROR_SUCCESS != (RegOpenKey(hKeyMediaRsrc,
                                         pstrAlias,
                                         &hKeyThisAlias)))
        {
            DPF(1, TEXT ("mdev_Init: Could not open enum'ed key %s"), (LPTSTR)pstrAlias);
            continue;
        }

        // MUST have Active == "1" to be running
        //
        cbValue = sizeof(szActive);
        if (ERROR_SUCCESS != (RegQueryValueEx(hKeyThisAlias,
                                              gszActiveValue,
                                              NULL,
                                              &dwType,
                                              (LPSTR)szActive,
                                              &cbValue)) ||
            *szActive != '1')
        {
            DPF(2, TEXT ("mdev_Init: Device %s exists but is not loaded."),
                (LPTSTR)pstrAlias);
            RegCloseKey(hKeyThisAlias);
            continue;
        }

        // Determine if we have ever configured with this driver before
        //
        cbValue = sizeof(dwMapperConfig);
        if (ERROR_SUCCESS != (RegQueryValueEx(hKeyThisAlias,
                                              gszMapperConfig,
                                              NULL,
                                              &dwType,
                                              (LPSTR)&dwMapperConfig,
                                              &cbValue)))
            dwMapperConfig = 0;

#ifdef DEBUG
        if (!dwMapperConfig)
            DPF(1, TEXT ("Alias '%s' is a new driver."),
                (LPTSTR)pstrAlias);
#endif

        // We have a running driver, go ahead and alloc a node
        // for it
        //
        pmd = (PMDEV_NODE)LocalAlloc(LPTR, sizeof(*pmd));
        if (NULL == pmd)
        {
            DPF(1, TEXT ("mdev_Init: Out of memory allocating node for %s"),
                (LPTSTR)pstrAlias);
            RegCloseKey(hKeyThisAlias);
            continue;
        }

        lstrcpyn(pmd->szAlias, pstrAlias, (sizeof(pmd->szAlias)/sizeof(pmd->szAlias[0])) - 1);
        pmd->szAlias[(sizeof(pmd->szAlias)/sizeof(pmd->szAlias[0])) - 1] = '\0';

        pmd->fNewDriver = (dwMapperConfig ? FALSE : TRUE);

        // Try to get the DevNode value
        //
        cbValue = sizeof(pmd->dwDevNode);
        if (ERROR_SUCCESS != RegQueryValueEx(hKeyThisAlias,
                                             gszDevNodeValue,
                                             NULL,
                                             &dwType,
                                             (LPSTR)(LPDWORD)&pmd->dwDevNode,
                                             &cbValue))
        {
            // Ok to not have a devnode value, 3.1 drivers don't
            //

            DPF(2, TEXT ("mdev_Init: Device %s has no devnode; must be 3.1"),
                (LPTSTR)pstrAlias);
            pmd->dwDevNode = 0;
        }

        // Leave something reasonable in driver even if we don't
        // expect to use it
        //
        *pmd->szDriver = '\0';

        // If we didn't get a devnode or it was 0, and we can't find the
        // driver name to match against, we can't use this entry. (If it
        // has no ring 3 driver, it can't be running anyway).
        //
        if (!pmd->dwDevNode)
        {
            cbValue = sizeof(pmd->szDriver);
            if (ERROR_SUCCESS != RegQueryValueEx(
                hKeyThisAlias,
                gszDriverValue,
                NULL,
                &dwType,
                (LPSTR)pmd->szDriver,
                &cbValue))
            {
                DPF(1, TEXT ("mdev_Init: Device %s has no ring 3 driver entry"),
                    (LPTSTR)pstrAlias);
                LocalFree((HLOCAL)pmd);
                RegCloseKey(hKeyThisAlias);
                continue;
            }
        }

        // Success! Now try to figure out the port number
        //
        cbValue = sizeof(dwPort);

        // Guard against INF's which only specify a byte's worth of
        // port value
        //
        dwPort = 0;
        if (ERROR_SUCCESS != RegQueryValueEx(hKeyThisAlias,
                                             gszPortValue,
                                             NULL,
                                             &dwType,
                                             (LPSTR)(LPDWORD)&dwPort,
                                             &cbValue))
        {
            DPF(2, TEXT ("mdev_Init: Device %s has no port entry; using 0."),
                (LPTSTR)pstrAlias);
            dwPort = 0;
        }

        pmd->uPort = (UINT)dwPort;

        // We have a valid node, put it into the list
        //
        pmd->pNext = gpMDevList;
        gpMDevList = pmd;

        RegCloseKey(hKeyThisAlias);
    }

    fRet = TRUE;

mBRL_Cleanup:


    if (hKeyMediaRsrc)      RegCloseKey(hKeyMediaRsrc);
    if (pstrAlias)          LocalFree((HLOCAL)pstrAlias);

    return fRet;
}

//
// mdev_SyncDeviceIDs
//
// Traverse the device list and bring the uDeviceID members up to date.
// Also remove any devices which MMSYSTEM claims are not really running.
//
// NOTE: The uDeviceID member is actually the device ID of the base driver.
// If you want to open the device, you have to add uDeviceID and uPort for
// the node you want to open.
//
// Set all uDeviceID's to NO_DEVICEID
// 
// For each base device ID in MMSYSTEM (i.e. port 0 on each loaded driver)
//  Get the matching alias from MMSYSTEM
//  Locate the node with that alias in the device list
//  Set that node's uDeviceID
//
// For each node in the device list with non-zero port
//  If this node has a DevNode
//   Find a matching node by DevNode with port == 0 and get its device ID
//  else
//   Find a matching node by driver name with port == 0 and get its device ID
//
// NOTE: We match by driver name on DevNode == 0 (3.1 devices) because it
// isn't possible to have multiple instances of a 3.1 driver loaded.
//
// For each node in the device list,
//  If the node's uDeviceID is still not set,
//   Remove and free the node
//
PRIVATE BOOL FNLOCAL mdev_SyncDeviceIDs(
    void)
{
    BOOL                    fRet            = FALSE;
    LPTSTR                  pstrAlias       = NULL;
    
    PMDEV_NODE              pmdCurr;
    PMDEV_NODE              pmdPrev;
    PMDEV_NODE              pmdEnum;
    UINT                    cDev;
    UINT                    idxDev;
    DWORD                   cPort;
    MMRESULT                mmr;
	DWORD					cbSize;

	cbSize = CB_MAXALIAS * sizeof(TCHAR);
    pstrAlias = (LPTSTR)LocalAlloc(LPTR, cbSize);
    if (NULL == pstrAlias)
    {
        goto mSDI_Cleanup;
    }
    
    // The device list has been built and the uPort member is valid.
    // Now update the uDeviceID field to be proper. First, walk the list
    // and set them all to NO_DEVICEID.

    for (pmdCurr = gpMDevList; pmdCurr; pmdCurr = pmdCurr->pNext)
        pmdCurr->uDeviceID = NO_DEVICEID;

    // Now walk MMSYSTEM's list of loaded drivers and fill in all the port 0
    // nodes with their proper device ID
    //

    cDev = midiOutGetNumDevs();

    for (idxDev = 0; idxDev < cDev; )
    {
        mmr = (MMRESULT)midiOutMessage((HMIDIOUT)(UINT_PTR)idxDev,
#ifdef WINNT
				       DRV_QUERYNUMPORTS,
#else
                                       MODM_GETNUMDEVS,
#endif // End WINNT
                                       (DWORD_PTR)(LPDWORD)&cPort,
                                       0);
        if (mmr)
        {
            DPF(1, TEXT ("mdev_Sync: Device ID %u returned %u for MODM_GETNUMDEVS"),
                (UINT)idxDev,
                (UINT)mmr);
            
            ++idxDev;
            continue;
        }

        mmr = (MMRESULT)midiOutMessage((HMIDIOUT)(UINT_PTR)idxDev,
                                       DRV_QUERYDRVENTRY,
#ifdef WINNT
                                       (DWORD_PTR)(LPTSTR)pstrAlias,
#else
                                       (DWORD_PTR)(LPTSTR)pstrPath,
#endif // End Winnt

                                       CB_MAXALIAS);

        if (!mmr)
        {
            for (pmdCurr = gpMDevList; pmdCurr; pmdCurr = pmdCurr->pNext)
			{
                if ((0 == pmdCurr->uPort) &&
                    (! lstrcmpi(pstrAlias, pmdCurr->szAlias)))
                {
                    pmdCurr->uDeviceID = idxDev;
                    break;
                }
			}

#ifdef DEBUG
            if (!pmdCurr)
            {
                DPF(1, TEXT ("mdev_Sync: Device ID %u not found in device list."),
                    (UINT)idxDev);
            }
#endif
        }
        else
        {
            DPF(1, TEXT ("mdev_Sync: Device ID %u returned %u for DRV_QUERYDRVENTRY"),
                (UINT)idxDev,
                (UINT)mmr);
        }

        idxDev += (UINT)cPort;
    }

    // Now walk the list again. This time we catch all the non-zero ports
    // and set their uDeviceID properly.
    //
    for (pmdCurr = gpMDevList; pmdCurr; pmdCurr = pmdCurr->pNext)
    {
        if (!pmdCurr->uPort)
            continue;

        if (pmdCurr->dwDevNode)
        {
            for (pmdEnum = gpMDevList; pmdEnum; pmdEnum = pmdEnum->pNext)
                if (0 == pmdEnum->uPort &&
                    pmdEnum->dwDevNode == pmdCurr->dwDevNode)
                {
                    pmdCurr->uDeviceID = pmdEnum->uDeviceID;
                    break;
                }
        }
        else
        {
            for (pmdEnum = gpMDevList; pmdEnum; pmdEnum = pmdEnum->pNext)
                if (0 == pmdEnum->uPort &&
                    !lstrcmpi(pmdEnum->szDriver, pmdCurr->szDriver))
                {
                    pmdCurr->uDeviceID = pmdEnum->uDeviceID;
                    break;
                }
        }

#ifdef DEBUG
        if (!pmdEnum)
        {
            DPF(1, TEXT ("mdev_Sync: No parent driver found for %s"),
                (LPTSTR)pmdCurr->szAlias);
        }
#endif
    }

    // Now we walk the list one more time and discard anyone without a device
    // ID assigned.
    //

    pmdPrev = NULL;
    pmdCurr = gpMDevList;

    while (pmdCurr)
    {
        if (NO_DEVICEID == pmdCurr->uDeviceID)
        {
            DPF(1, TEXT ("mdev_Sync: Removing %s; never found a device ID"),
                (LPTSTR)pmdCurr->szAlias);
            
            if (pmdPrev)
                pmdPrev->pNext = pmdCurr->pNext;
            else
                gpMDevList = pmdCurr->pNext;

            LocalFree((HLOCAL)pmdCurr);

            pmdCurr = (pmdPrev ? pmdPrev->pNext : gpMDevList);
        }
        else
        {
            pmdPrev = pmdCurr;
            pmdCurr = pmdCurr->pNext;
        }
    }

    fRet = TRUE;

mSDI_Cleanup:
    if (pstrAlias)          LocalFree((HLOCAL)pstrAlias);

    return fRet;
}

//
// mdev_MarkActiveDrivers
//
// Mark drivers which are loaded and have not been seen before by
// mapper configuration as seen. Also flag that we want to run
// RunOnce if there are any of these
//
PRIVATE BOOL FNLOCAL mdev_MarkActiveDrivers(
    void)
{
    BOOL                    fRet            = FALSE;
    HKEY                    hKeyMediaRsrc   = NULL;
    HKEY                    hKeyThisAlias   = NULL;

    DWORD                   dwMapperConfig;
    PMDEV_NODE              pmd;

    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
                                    gszMediaRsrcKey,
                                    &hKeyMediaRsrc))
    {
        DPF(1, TEXT ("mdev_MarkActiveDrivers: Could not open ")
               TEXT ("...\\MediaResources\\MIDI"));
        goto mMAD_Cleanup;
    }

    gdwNewDrivers = 0;
    for (pmd = gpMDevList; pmd; pmd = pmd->pNext)
        if (pmd->fNewDriver)
        {
            ++gdwNewDrivers;

            // Mark this driver as seen
            //
            if (ERROR_SUCCESS != (RegOpenKey(hKeyMediaRsrc,
                                             pmd->szAlias,
                                             &hKeyThisAlias)))
            {
                DPF(1, TEXT ("mdev_MarkActiveDrivers: Could not open alias '%s'"),
                    (LPTSTR)pmd->szAlias);
                goto mMAD_Cleanup;
            }

            dwMapperConfig = 1;
            RegSetValueEx(hKeyThisAlias,
                          gszMapperConfig,
                          0,
                          REG_DWORD,
                          (LPSTR)&dwMapperConfig,
                          sizeof(dwMapperConfig));

            RegCloseKey(hKeyThisAlias);
        }

    fRet = TRUE;
    
mMAD_Cleanup:

    if (hKeyMediaRsrc)      RegCloseKey(hKeyMediaRsrc);

    return fRet;
}

//
// mdev_ListActiveDrivers
//
// List the currently loaded drivers to debug output
//
#ifdef DEBUG
PRIVATE VOID FNLOCAL mdev_ListActiveDrivers(
    void)
{
    PMDEV_NODE              pmd;
    static TCHAR BCODE       szNo[]  = TEXT ("No");
    static TCHAR BCODE       szYes[] = TEXT ("Yes");

    DPF(2, TEXT ("=== mdev_ListActiveDrivers start ==="));
    for (pmd = gpMDevList; pmd; pmd = pmd->pNext)
    {
        DPF(2, TEXT ("Alias %-31.31s  Driver %-31.31s"),
            (LPTSTR)pmd->szAlias,
            (LPTSTR)pmd->szDriver);
        DPF(2, TEXT ("      dwDevNode %08lX uDeviceID %u uPort %u fNewDriver %s"),
            pmd->dwDevNode,
            pmd->uDeviceID,
            pmd->uPort,
            (LPTSTR)(pmd->fNewDriver ? szYes : szNo));
    }
    DPF(2, TEXT ("=== mdev_ListActiveDrivers end   ==="));
}
#endif

//
// mdev_Free
//
// Discard the current device list
//
void FNGLOBAL mdev_Free(
    void)
{
    PMDEV_NODE              pmdNext;
    PMDEV_NODE              pmdCurr;

    pmdCurr = gpMDevList;
    
    while (pmdCurr)
    {
        pmdNext = pmdCurr->pNext;

        LocalFree((HLOCAL)pmdCurr);
        pmdCurr = pmdNext;
    }

    gpMDevList = NULL;

    gdwNewDrivers = (DWORD)-1L;
}

//
// mdev_GetDeviceID
//
// Get the current device ID for the given alias.
//
UINT FNGLOBAL mdev_GetDeviceID(
    LPTSTR                   lpstrAlias)
{
    PMDEV_NODE              pmd;

    for (pmd = gpMDevList; pmd; pmd = pmd->pNext)
        if (!lstrcmpi(pmd->szAlias, lpstrAlias))
            return pmd->uDeviceID + pmd->uPort;

    DPF(1, TEXT ("mdev_GetDeviceID: Failed for %s"), lpstrAlias);
    return NO_DEVICEID;
}

//
// mdev_GetAlias
//
// Get the registry alias for the requested device ID
//
BOOL FNGLOBAL mdev_GetAlias(
    UINT                    uDeviceID,
    LPTSTR                  lpstrBuffer,
    UINT                    cbBuffer)
{
    PMDEV_NODE              pmd;

    for (pmd = gpMDevList; pmd; pmd = pmd->pNext)
        if (uDeviceID == (pmd->uDeviceID + pmd->uPort))
        {
            lstrcpyn(lpstrBuffer, pmd->szAlias, cbBuffer);
            return TRUE;
        }

    DPF(1, TEXT ("mdev_GetAlias: Failed for device ID %u"), uDeviceID);
    return FALSE;
}

//
// mdev_NewDrivers
//
// Returns TRUE if there were new drivers in the registry that we've never
// encountered before
//
BOOL FNGLOBAL mdev_NewDrivers(
    void)
{
    if (gdwNewDrivers == (DWORD)-1L)
    {
        DPF(0, TEXT ("mdevNewDrivers() called before mdev_Init()!"));
        return FALSE;
    }

    return (BOOL)(gdwNewDrivers != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\midimap\midimap.h ===
/**********************************************************************

    Copyright (c) 1992-1999 Microsoft Corporation

    midimap.h

    DESCRIPTION:
      Main private include file for the MIDI mapper.

*********************************************************************/

#ifndef _MIDIMAP_
#define _MIDIMAP_

//
// The following macro defines a CODE based pointer to data, which
// is used for constants that do not need to be placed in the read/write
// DATA segment.
//
#ifdef WIN32
#define __based(a)
#endif


#ifdef WIN32
   #define  BCODE
   #define  BSTACK
#else
   #define  BCODE                   __based(__segname("_CODE"))
   #define  BSTACK                  __based(__segname("_STACK"))
#endif

#include <mmsysp.h>

// Defines Win95 stuff not supported in NT 4.0
// Remove as soon as it is supported
#include "mmcompat.h"

//
// Macro definitions
//
#ifdef DEBUG
#define PRIVATE
#else
#define PRIVATE static
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))
#endif

#define DEF_TRANS_SIZE	512

#define  DEF_CHAN_PER_INST          8   

#define  FNLOCAL                    NEAR PASCAL
#define  FNGLOBAL                   FAR PASCAL
//#define  FNEXPORT                   FAR PASCAL __export
#define  FNEXPORT                   FAR PASCAL 

#define  VERSION_MINOR              0x01
#define  VERSION_MAJOR              0x04
#define  MMAPPER_VERSION            ((DWORD)(WORD)((BYTE)VERSION_MINOR | (((WORD)(BYTE)VERSION_MAJOR) << 8)))

// Indices 3,4,5 into LPMIDIHDR->dwReserved[] are reserved for MIDI mapper
//
#define  MH_MAPINST                 3 // Mapper instance owning this header
#define  MH_SHADOW                  4 // Cross links between parent/child
#define  MH_SHADOWEE                4 //  shadow headers
#define  MH_LMREFCNT                5 // Long message reference count

#define  MAX_CHANNELS               16
#define  ALL_CHANNELS               (0xFFFF)    // Channel mask
#define  DRUM_CHANNEL               9
#define  MAX_CHAN_TYPES             2

#define  IDX_CHAN_GEN               0
#define  IDX_CHAN_DRUM              1

#define  CB_MAXDRIVER               64
#define  CB_MAXSCHEME               64
#define  CB_MAXINSTR                64
#define  CB_MAXALIAS                64
#define  CB_MAXDEVKEY               64
#define  CB_MAXPATH                 256
#define  CB_MAXDEFINITION           (256+64+2)  // file<instrument>

#define  NO_DEVICEID                ((UINT)-2)

#define  MSG_STATUS(dw)      ((BYTE)((dw) & 0xFF))
#define  MSG_PARM1(dw)       ((BYTE)(((dw) >> 8) & 0xFF))
#define  MSG_PARM2(dw)       ((BYTE)(((dw) >> 16) & 0xFF))

#define  MSG_PACK1(bs,b1)    ((DWORD)((((DWORD)(b1)) << 8) | ((DWORD)(bs))))
#define  MSG_PACK2(bs,b1,b2) ((DWORD)((((DWORD)(b2)) << 16) | (((DWORD)(b1)) << 8) | ((DWORD)(bs))))

#define  IS_REAL_TIME(b)    ((b) > 0xF7)
#define  IS_STATUS(b)       ((b) & 0x80)
#define  MSG_EVENT(b)       ((b) & 0xF0)
#define  MSG_CHAN(b)        ((b) & 0x0F)


#define  MIDI_NOTEOFF           ((BYTE)0x80)
#define  MIDI_NOTEON            ((BYTE)0x90)
#define  MIDI_POLYPRESSURE      ((BYTE)0xA0)
#define  MIDI_CONTROLCHANGE     ((BYTE)0xB0)
#define  MIDI_PROGRAMCHANGE     ((BYTE)0xC0)
#define  MIDI_CHANPRESSURE      ((BYTE)0xD0)
#define  MIDI_PITCHBEND         ((BYTE)0xE0)
#define  MIDI_SYSEX             ((BYTE)0xF0)
#define  MIDI_QFRAME			((BYTE)0xF1)
#define	 MIDI_SONGPOINTER		((BYTE)0xF2)
#define	 MIDI_SONGSELECT		((BYTE)0xF3)
#define	 MIDI_F4				((BYTE)0xF4)
#define	 MIDI_F5				((BYTE)0xF5)
#define	 MIDI_TUNEREQUEST		((BYTE)0xF6)
#define  MIDI_SYSEXEND          ((BYTE)0xF7)
#define  MIDI_TIMINGCLOCK       ((BYTE)0xF8)
#define  MIDI_F9				((BYTE)0xF9)
#define	 MIDI_START				((BYTE)0xFA)
#define	 MIDI_CONTINUE			((BYTE)0xFB)
#define	 MIDI_STOP				((BYTE)0xFC)
#define  MIDI_FD				((BYTE)0xFD)
#define  MIDI_ACTIVESENSING		((BYTE)0xFE)
#define  MIDI_META              ((BYTE)0xFF)

#define  DWORD_ROUND(x)         (((x)+3L)&~3L)

// Global flags in gwFlags
//
#define  GF_ENABLED             0x0001
#define  GF_CONFIGERR           0x0002
#define  GF_NEEDRUNONCE         0x0004
#define  GF_DONERUNONCE         0x0008
#define  GF_DEVSOPENED          0x0010
#define  GF_RECONFIGURE         0x0020
#define  GF_INRUNONCE           0x0040
#define  GF_ALLOWVOLUME         0x0080
#define  GF_ALLOWCACHE          0x0100
#define  GF_KILLTHREAD          0x0200

#define  SET_ENABLED            {gwFlags |= GF_ENABLED;}
#define  CLR_ENABLED            {gwFlags &=~GF_ENABLED;}
#define  IS_ENABLED             (gwFlags & GF_ENABLED)

#define  SET_CONFIGERR          {gwFlags |= GF_CONFIGERR;}
#define  CLR_CONFIGERR          {gwFlags &=~GF_CONFIGERR;}
#define  IS_CONFIGERR           (gwFlags & GF_CONFIGERR)

#define  SET_NEEDRUNONCE        {gwFlags |= GF_NEEDRUNONCE;}
#define  CLR_NEEDRUNONCE        {gwFlags &=~GF_NEEDRUNONCE;}
#define  IS_NEEDRUNONCE         (gwFlags & GF_NEEDRUNONCE)

#define  SET_DONERUNONCE        {gwFlags |= GF_DONERUNONCE;}
#define  CLR_DONERUNONCE        {gwFlags &=~GF_DONERUNONCE;}
#define  IS_DONERUNONCE         (gwFlags & GF_DONERUNONCE)

#define  SET_DEVSOPENED         {gwFlags |= GF_DEVSOPENED;}
#define  CLR_DEVSOPENED         {gwFlags &=~GF_DEVSOPENED;}
#define  IS_DEVSOPENED          (gwFlags & GF_DEVSOPENED) 

#define  SET_RECONFIGURE        {gwFlags |= GF_RECONFIGURE;}
#define  CLR_RECONFIGURE        {gwFlags &=~GF_RECONFIGURE;}
#define  IS_RECONFIGURE         (gwFlags & GF_RECONFIGURE)

#define  SET_INRUNONCE          {gwFlags |= GF_INRUNONCE;}
#define  CLR_INRUNONCE          {gwFlags &=~GF_INRUNONCE;}
#define  IS_INRUNONCE           (gwFlags & GF_INRUNONCE)

#define  SET_ALLOWVOLUME        {gwFlags |= GF_ALLOWVOLUME;}
#define  CLR_ALLOWVOLUME        {gwFlags &=~GF_ALLOWVOLUME;}
#define  IS_ALLOWVOLUME         (gwFlags & GF_ALLOWVOLUME)

#define  SET_ALLOWCACHE         {gwFlags |= GF_ALLOWCACHE;}
#define  CLR_ALLOWCACHE         {gwFlags &=~GF_ALLOWCACHE;}
#define  IS_ALLOWCACHE          (gwFlags & GF_ALLOWCACHE)

#define  SET_KILLTHREAD         {gwFlags |= GF_KILLTHREAD;}
#define  CLR_KILLTHREAD         {gwFlags &=~GF_KILLTHREAD;}
#define  IS_KILLTHREAD          (gwFlags & GF_KILLTHREAD)

//=========================== Typedef's=====================================
//

typedef struct tagQUEUE         NEAR *PQUEUE;
typedef struct tagQUEUEELE      NEAR *PQUEUEELE;
typedef struct tagCHANINIT      NEAR *PCHANINIT;
typedef struct tagCHANNEL       NEAR *PCHANNEL;
typedef struct tagPORT          NEAR *PPORT;
typedef struct tagINSTRUMENT    NEAR *PINSTRUMENT;
typedef struct tagINSTPORT      NEAR *PINSTPORT;
typedef struct tagINSTANCE      NEAR *PINSTANCE;
typedef struct tagCOOKSYNCOBJ   NEAR *PCOOKSYNCOBJ;

typedef struct tagQUEUE
{
    CRITICAL_SECTION cs;
    PQUEUEELE        pqeFront;
    PQUEUEELE        pqeRear;
    DWORD            cEle;
}   QUEUE;

#define QueueIsEmpty(q) (NULL == (q)->pqeFront)
#define QueueCount(q)   ((q)->cEle)

typedef struct tagQUEUEELE
{
    PQUEUEELE       pqePrev;
    PQUEUEELE       pqeNext;
    UINT            uPriority;
}   QUEUEELE;

typedef struct tagCHANINIT
{
    DWORD               cbInit;
    PBYTE               pbInit;
}   CHANINIT;

// Flags for this channel which indicate what type of channel it is
// and whether or not it's allocated.
//
#define CHAN_F_OPEN             (0x0001)
#define CHAN_F_ALLOCATED        (0x0002)
#define CHAN_F_DRUM             (0x0004)
#define CHAN_F_GENERAL          (0x0008)
#define CHAN_F_MUTED            (0x0010)

typedef struct tagCHANNEL
{
//    QUEUEELE            q;                  // !!! MUST BE FIRST !!!
    PPORT               pport;
    WORD                fwChannel;
    UINT                uChannel;           // This physical channel #
    PINSTRUMENT         pinstrument;        // -> IDF describing this channel
    PBYTE               pbPatchMap;         // In use patch map
    PBYTE               pbKeyMap;           // In use key map
    DWORD               dwStreamID;         // Stream ID if cooked
}   CHANNEL;

#define PORT_F_REMOVE            (0x0001)
#define PORT_F_HASDRUMCHANNEL    (0x0002)
#define PORT_F_OPENFAILED        (0x0004)
#define PORT_F_RESET             (0x0008)
#define PORT_F_GENERICINSTR      (0x0010)

typedef struct tagPORT
{
    PPORT               pNext;
    UINT                cRef;
    WORD                fwPort;
    WORD                wChannelMask;
    UINT                uDeviceID;
    HMIDIOUT            hmidi;
}   PORT;

#define IDF_F_GENERICINSTR      (0x80000000L)

typedef struct tagINSTRUMENT
{
    PINSTRUMENT         pNext;
    LPTSTR              pstrFilename;       // Filename of IDF
    LPTSTR              pstrInstrument;     // Instrument name from IDF
    UINT                cRef;               // # ports which are using this IDF
    DWORD               fdwInstrument;
    DWORD               dwGeneralMask;
    DWORD               dwDrumMask;
    PBYTE               pbPatchMap;         // -> 128 bytes of patch map
    PBYTE               pbDrumKeyMap;       // -> 128 bytes of key map
    PBYTE               pbGeneralKeyMap;    // -> 128 bytes of key map
    CHANINIT            rgChanInit[MAX_CHANNELS];
}   INSTRUMENT;

#define INST_F_TIMEDIV  (0x0001)            // Instance has received MIDIPROP_TIMEDIV
#define INST_F_TEMPO    (0x0002)            // Instance has received MIDIPROP_TEMPO
#define INST_F_IOCTL    (0x0004)            // IOCTL open

typedef struct tagINSTANCE
{
    PINSTANCE           pNext;

    // stuff we need to save so we can do callbacks
    //
    HMIDI               hmidi;              // MMSYSTEM's handle
    DWORD_PTR           dwCallback;         // Callback address
    DWORD_PTR           dwInstance;         // User instance data
    DWORD               fdwOpen;            // Describe the callback & open mode
    QUEUE               qCookedHdrs;        // Cooked headers pending to be sent
    WORD                fwInstance;         // Instance flags
    BYTE                bRunningStatus;     // Need to track running status

	// Translation Buffer
    CRITICAL_SECTION	csTrans;			// Critical Section for Translation buffer
	LPBYTE				pTranslate;			// Buffer For Translating MODM_LONGDATA messages
	DWORD				cbTransSize;		// Current Translation buffer size				
}   INSTANCE;

#if 0
typedef struct tagCOOKINSTANCE
{
    INSTANCE            inst;               // Common instance data
    UINT                cInstPort;          // # ports in use on instance
    INSTPORT            rginstport[MAX_CHANNELS];
    DWORD               dwTimeDiv;          // MIDIPROP_TIMEDIV
    DWORD               dwTempo;            // MIDIPROP_TEMPO
}   COOKINSTANCE;
#endif

typedef struct tagCOOKSYNCOBJ
{
    QUEUEELE            q;                  // !!! MUST BE FIRST !!!
    
    LPMIDIHDR           lpmh;               // First of our shadow headers
    LPMIDIHDR           lpmhUser;           // Original user header
    PINSTANCE           pinstance;          // Owning pinstance
    UINT                cLPMH;              // # allocated
    UINT                cSync;              // # outstanding
}   COOKSYNCOBJ;

typedef struct tagSHADOWBLOCK
{
    LPMIDIHDR           lpmhShadow;
    DWORD               cRefCnt;
    DWORD               dwBufferLength;
} SHADOWBLOCK, *PSHADOWBLOCK;


#define DRV_GETMAPPERSTATUS     (DRV_USER+3)
#define DRV_REGISTERDEBUGCB     (DRV_USER+4)
#define DRV_GETNEXTLOGENTRY     (DRV_USER+5)

typedef struct tagMAPPERSTATUS
{
    DWORD               cbStruct;
#ifndef WIN32
    __segment           DS;
#endif
    HINSTANCE           ghinst;
    WORD                gwFlags;
    WORD                gwConfigWhere;
    PCHANNEL*           pgapChannel;
    PPORT               gpportList;
    PINSTANCE           gpinstanceList;
    PINSTRUMENT         gpinstrumentList;
    LPTSTR              lpszVersion;
}   MAPPERSTATUS,
    FAR *LPMAPPERSTATUS;

//=========================== Globals ======================================
//
extern PCHANNEL                 gapChannel[];
extern WORD                     gwFlags;
extern WORD                     gwConfigWhere;
extern UINT                     gcPorts;

extern HINSTANCE                ghinst;        
extern PPORT                    gpportList;    
extern PINSTANCE                gpinstanceList;
extern PINSTANCE                gpIoctlInstance;
extern PINSTRUMENT              gpinstrumentList;
extern QUEUE                    gqFreeSyncObjs;
extern HMIDISTRM                ghMidiStrm;
extern DWORD                    gdwVolume;

//=========================== Prototypes ===================================
//

extern BOOL FNGLOBAL UpdateInstruments(     // config.c
    BOOL                fFromCPL,
    DWORD               fdwUpdate);

extern BOOL FNGLOBAL Configure(             // config.c
    DWORD               fdwUpdate);

extern BOOL FNLOCAL AddPort(                // config.c
    UINT                uDeviceID,
    UINT                uPorts,
    PSTR                szSysIniEntry);

extern void FNGLOBAL SyncDeviceIDs(         // config.c
    void);

extern LPIDFHEADER FNLOCAL ReadHeaderChunk( // file.c
    HMMIO               hmmio,
    LPMMCKINFO          pchkParent);

extern LPIDFINSTCAPS FNLOCAL ReadCapsChunk( // file.c
    HMMIO               hmmio,                               
    LPMMCKINFO          pchkParent);

extern LPIDFCHANNELHDR FNLOCAL ReadChannelChunk( // file.c
    HMMIO               hmmio,                                  
    LPMMCKINFO          pchkParent,
    LPIDFCHANNELINFO BSTACK rglpChanInfo[]);

extern LPIDFPATCHMAPHDR FNLOCAL ReadPatchMapChunk( // file.c
    HMMIO               hmmio,                                          
    LPMMCKINFO          pchkParent);

extern void FNLOCAL ReadKeyMapChunk(        // file.c
    HMMIO               hmmio,                                  
    LPMMCKINFO          pchkParent,
    LPIDFKEYMAP BSTACK  rglpIDFkeymap[]);

extern void CALLBACK _loadds modmCallback(  // modfix.c
    HMIDIOUT            hmo,
    WORD                wmsg,
    DWORD_PTR           dwInstance,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2);                                  

#define MSE_F_SENDEVENT     (0x0000L)
#define MSE_F_RETURNEVENT   (0x0001L)

extern DWORD FNGLOBAL MapSingleEvent(       // modfix.c
    PINSTANCE           pinstance,
    DWORD               dwData,
    DWORD               fdwFlags,
    DWORD BSTACK *      pdwStreamID);

extern DWORD FNLOCAL modLongMsg(            // modfix.c
    PINSTANCE           pinstance,                                
    LPMIDIHDR           lpmh);                                

extern MMRESULT FNGLOBAL MapCookedBuffer(   // cookmap.c
    PINSTANCE           pinstance,
    LPMIDIHDR           lpmh);

extern DWORD FNGLOBAL modGetDevCaps(        // modmsg.c
    LPMIDIOUTCAPS       pmoc,
    DWORD               cbmoc);

extern DWORD FNGLOBAL modOpen(              // modmsg.c
    PDWORD_PTR          lpdwInstance,
    LPMIDIOPENDESC      lpmidiopendesc,
    DWORD               fdwOpen);

extern BOOL FNGLOBAL CanChannelBeDrum(      // modmsg.c
    PQUEUEELE           pqe);

extern DWORD FNGLOBAL modClose(             // modmsg.c
    PINSTANCE           pinstance);

extern DWORD FNGLOBAL modPrepare(
    LPMIDIHDR           lpmh);              // modmsg.c

extern DWORD FNGLOBAL modUnprepare(         // modmsg.c
    LPMIDIHDR           lpmh);

extern DWORD FNGLOBAL modGetPosition(       // modmsg.c
    PINSTANCE           pinstance,
    LPMMTIME            lpmmt,
    DWORD               cbmmt);

extern DWORD FNGLOBAL modSetVolume(         // modmsg.c
    DWORD               dwVolume);

extern void FNGLOBAL QueueInit(             // queue.c
    PQUEUE              pq);

extern void FNGLOBAL QueueCleanup(          // queue.c
    PQUEUE              pq);

extern void FNGLOBAL QueuePut(              // queue.c
    PQUEUE              pq,
    PQUEUEELE           pqe,
    UINT                uPriority);

extern PQUEUEELE FNGLOBAL QueueGet(         // queue.c
    PQUEUE              pq);

extern BOOL FNGLOBAL QueueRemove(           // queue.c
    PQUEUE              pq, 
    PQUEUEELE           pqe);

typedef BOOL (FNGLOBAL *FNFILTER)(PQUEUEELE);

extern PQUEUEELE FNGLOBAL QueueGetFilter(   // queue.c
    PQUEUE              pq,
    FNFILTER            fnf);

extern void FNGLOBAL LockMapperData(        // locks.c
    void);

extern void FNGLOBAL UnlockMapperData(      // locks.c
    void);

extern void FNGLOBAL LockPackedMapper(      // locks.c
    void);

extern void FNGLOBAL UnlockPackedMapper(    // locks.c
    void);

extern void FNGLOBAL LockCookedMapper(      // locks.c
    void);

extern void FNGLOBAL UnlockCookedMapper(    // locks.c
    void);

extern void FNGLOBAL mdev_Free(             // mididev.c
    void);                           

extern BOOL FNGLOBAL mdev_Init(             // mididev.c
    void);

UINT FNGLOBAL mdev_GetDeviceID(             // mididev.c
    LPTSTR                   pszAlias);

BOOL FNGLOBAL mdev_GetAlias(                // mididev.c
    UINT                    uDeviceID,
    LPTSTR                  pszBuffer,
    UINT                    cchSize);

BOOL FNGLOBAL mdev_NewDrivers(              // mididev.c
    void);                              

	// Translation buffer stuff for MODM_LONGDATA
BOOL FNGLOBAL InitTransBuffer (PINSTANCE pinstance);
BOOL FNGLOBAL CleanupTransBuffer (PINSTANCE pinstance);
LPBYTE FNGLOBAL AccessTransBuffer (PINSTANCE pinstance);
void FNGLOBAL ReleaseTransBuffer (PINSTANCE pinstance);
BOOL FNGLOBAL GrowTransBuffer (PINSTANCE pinstance, DWORD cbNewSize);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\midimap\mmcompat.h ===
/**********************************************************************

    Copyright (c) 1992-1998 Microsoft Corporation

    mmcompat.h

    DESCRIPTION:
      Win95 Multimedia definitions, structures, and functions
      not currently supported in NT 4.0

*********************************************************************/

#ifndef _MMCOMPAT_
#define _MMCOMPAT_


#define __segname(a)
#define GlobalSmartPageLock(a) (TRUE)
#define GlobalSmartPageUnlock(a) (TRUE)
#define wmmMIDIRunOnce()


//
// Note:  Temporary definitions, please remove when mmddk.h
// have been updated to new standard !!!
//

// Should be defined in <mmddk.h>

#ifndef DRV_F_ADD
   #define DRV_F_ADD             0x00000000L
#endif

#ifndef DRV_F_REMOVE
   #define DRV_F_REMOVE          0x00000001L
#endif

#ifndef DRV_F_CHANGE
   #define DRV_F_CHANGE          0x00000002L
#endif

#ifndef DRV_F_PROP_INSTR
   #define DRV_F_PROP_INSTR      0x00000004L
#endif

#ifndef DRV_F_NEWDEFAULTS
   #define DRV_F_NEWDEFAULTS     0x00000008L
#endif

#ifndef DRV_F_PARAM_IS_DEVNODE
   #define DRV_F_PARAM_IS_DEVNODE   0x10000000L
#endif

#endif // end #ifndef _MMCOMPAT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\midimap\modfix.c ===
/**********************************************************************

  Copyright (c) 1992-1999 Microsoft Corporation

  modfix.c

  DESCRIPTION:
    Fixed code for doing output mapping. KEEP THE SIZE OF THIS CODE
    TO A MINIMUM!

  HISTORY:
     02/22/94       [jimge]        created.

*********************************************************************/
#pragma warning(disable:4704)

#include "preclude.h"
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "idf.h"

#include "midimap.h"
#include "debug.h"

extern HANDLE hMutexRefCnt; // Located in DRVPROC.C
extern HANDLE hMutexConfig; // Located in DRVPROC.C

#define MSG_UNKNOWN 0
#define MSG_SHORT	1
#define MSG_LONG	2

INT FNLOCAL MapEvent (
	BYTE  * pStatus,
	DWORD	dwBuffSize,
	DWORD * pSkipBytes,
	DWORD * pShortMsg);

DWORD FNLOCAL modMapLongMsg (
	PINSTANCE pinstance,
    LPMIDIHDR lpmh);

/***************************************************************************

   @doc internal

   @api int | modMessage | Exported entry point for MIDI out messages.
    This function conforms to the definition in the MM DDK.

   @parm UINT | uid | Device ID within driver to open. For mapper, this
    should always be zero.

   @parm UINT | umsg | Message to process. This should be one of the
    #define'd MODM_xxx messages.

   @parm DWORD | dwUser | Points to a DWORD where the driver (us) can
    save instance data. This will store the near pointer to our
    instance. On every other message, this will contain the instance
    data.

   @parm DWORD | dwParam1 | Message specific parameters.

   @parm DWORD | dwParam2 | Message specific parameters.

   @comm This function MUST be in a fixed segment since short messages
    are allowed to be sent at interrupt time.

   @rdesc | MMSYSERR_xxx.

***************************************************************************/
DWORD FNEXPORT modMessage(
    UINT                uid,
    UINT                umsg,
    DWORD_PTR           dwUser,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2)
{
    BYTE                bs;
    PINSTANCE           pinstance;
//    UINT                uDeviceID;
    PPORT               pport;
    MMRESULT            mmrc;
    MMRESULT            mmrc2;
	DWORD				dwResult;

    if (0 != uid)
    {
        DPF(1, TEXT ("Mapper called with non-zero uid!"));
        return MMSYSERR_BADDEVICEID;
    }

    pinstance = (PINSTANCE)(UINT_PTR)(dwUser);

    switch(umsg)
    {
        case MODM_GETDEVCAPS:
            return modGetDevCaps((LPMIDIOUTCAPS)dwParam1,
                                 (DWORD)dwParam2);

        case MODM_OPEN:
            return modOpen((PDWORD_PTR)dwUser,
                           (LPMIDIOPENDESC)dwParam1,
                           (DWORD)dwParam2);

        case MODM_CLOSE:
            return modClose((PINSTANCE)dwUser);

        case MODM_DATA:
            assert(NULL != pinstance);

            // In cooked mode, don't allow non-status short messages.
            // Otherwise (packed mode) maintain running status.
            //
            // TESTTEST -- Make sure running status works properly in
            // MIDI_IO_PACKED - essential for backwards compatibility!!!
            //
            bs = MSG_STATUS(dwParam1);
            if (pinstance->fdwOpen & MIDI_IO_COOKED)
            {
                bs = MSG_STATUS(dwParam1);
                if (!IS_STATUS(bs))
                {
                    DPF(1, TEXT ("Non-status short msg while opened in MIDI_IO_COOKED!"));
                    return MMSYSERR_INVALPARAM;
                }
            }
            else
            {
                // Track running status
                //
                if (IS_STATUS(bs))
                {
                    // Do not use real-time messages as the status 
                    // byte of the next message.
                    if (!IS_REAL_TIME(bs))
                    {
                        pinstance->bRunningStatus = bs;
                    }
                }
                else
                    dwParam1 = (dwParam1 << 8) | (pinstance->bRunningStatus);
            }

            return MapSingleEvent((PINSTANCE)dwUser,
                                  (DWORD)dwParam1,
                                  MSE_F_SENDEVENT,
                                  NULL);

        case MODM_LONGDATA:
            assert(NULL != pinstance);

//            return modLongMsg(pinstance, (LPMIDIHDR)dwParam1);
			return modMapLongMsg (pinstance, (LPMIDIHDR)dwParam1);

        case MODM_PREPARE:
            assert(NULL != pinstance);

            return modPrepare((LPMIDIHDR)dwParam1);

        case MODM_UNPREPARE:
            assert(NULL != pinstance);

            return modUnprepare((LPMIDIHDR)dwParam1);

        case MODM_GETVOLUME:
            if (!IS_ALLOWVOLUME)
                return MMSYSERR_NOTSUPPORTED;

            *(LPDWORD)dwParam1 = gdwVolume;

            return MMSYSERR_NOERROR;

        case MODM_SETVOLUME:
            if (!IS_ALLOWVOLUME)
                return MMSYSERR_NOTSUPPORTED;

            gdwVolume = (DWORD)dwParam1;

            if (ghMidiStrm)
                return midiOutSetVolume((HMIDIOUT)ghMidiStrm, (DWORD)dwParam1);

            return modSetVolume((DWORD)dwParam1);

        case MODM_PROPERTIES:
            assert(NULL != pinstance);

            return midiStreamProperty(ghMidiStrm, (LPVOID)dwParam1, (DWORD)dwParam2);

        case MODM_STRMDATA:
            assert(NULL != pinstance);

            return MapCookedBuffer(pinstance, (LPMIDIHDR)dwParam1);

        case MODM_RESET:
            assert(NULL != pinstance);

            if (ghMidiStrm)
                return midiOutReset((HMIDIOUT)ghMidiStrm);

            mmrc = MMSYSERR_NOERROR;
            for (pport = gpportList; pport; pport=pport->pNext)
                if (MMSYSERR_NOERROR != (mmrc2 =
                    midiOutReset(pport->hmidi)))
                    mmrc = mmrc2;

            return mmrc;

        case MODM_GETPOS:
            assert(NULL != pinstance);

            return modGetPosition((PINSTANCE)pinstance,
                                  (LPMMTIME)dwParam1,
                                  (DWORD)dwParam2  /* cbmmtime */);


        case MODM_PAUSE:
            assert(NULL != pinstance);

            return midiStreamPause(ghMidiStrm);

        case MODM_RESTART:
            assert(NULL != pinstance);

            return midiStreamRestart(ghMidiStrm);

        case MODM_STOP:
            assert(NULL != pinstance);

            return midiStreamStop(ghMidiStrm);

        case MODM_CACHEPATCHES:
            assert(NULL != pinstance);

            if (!IS_ALLOWCACHE)
                return MMSYSERR_NOTSUPPORTED;

            if (ghMidiStrm)
                return midiOutCachePatches(
                        (HMIDIOUT)ghMidiStrm,   // hmidi
                        HIWORD(dwParam2),       // wBank
                        (WORD FAR *)dwParam1,   // lpPatchArray
                        LOWORD(dwParam2));      // wFlags

            mmrc = MMSYSERR_NOERROR;
            for (pport = gpportList; pport; pport=pport->pNext)
                if (MMSYSERR_NOERROR != (mmrc2 =
                    midiOutCachePatches(
                        pport->hmidi,           // hmidi
                        HIWORD(dwParam2),       // wBank
                        (WORD FAR *)dwParam1,   // lpPatchArray
                        LOWORD(dwParam2))) &&   // wFlags
                    MMSYSERR_NOTSUPPORTED != mmrc2)
                    mmrc = mmrc2;

            return mmrc;

        case MODM_CACHEDRUMPATCHES:
            assert(NULL != pinstance);

            if (!IS_ALLOWCACHE)
                return MMSYSERR_NOTSUPPORTED;

            if (ghMidiStrm)
                return midiOutCacheDrumPatches(
                        (HMIDIOUT)ghMidiStrm,   // hmidi
                        HIWORD(dwParam2),       // wBank
                        (WORD FAR *)dwParam1,   // lpKeyArray
                        LOWORD(dwParam2));      // wFlags

            mmrc = MMSYSERR_NOERROR;
            for (pport = gpportList; pport; pport=pport->pNext)
                if (MMSYSERR_NOERROR != (mmrc2 =
                    midiOutCacheDrumPatches(
                        pport->hmidi,           // hmidi
                        HIWORD(dwParam2),       // wBank
                        (WORD FAR *)dwParam1,   // lpKeyArray
                        LOWORD(dwParam2))) &&   // wFlags
                    MMSYSERR_NOTSUPPORTED != mmrc2)
                    mmrc = mmrc2;

            return mmrc;

        case DRVM_MAPPER_RECONFIGURE:

	    DPF(2, TEXT ("DRV_RECONFIGURE"));

	    // Prevent Synchronization problems during Configuration
	    if (NULL != hMutexConfig) WaitForSingleObject (hMutexConfig, INFINITE);
	    dwResult = UpdateInstruments(TRUE, (DWORD)dwParam2);
	    if (NULL != hMutexConfig) ReleaseMutex (hMutexConfig);
	    return dwResult;

    }

    return MMSYSERR_NOTSUPPORTED;
}

/***************************************************************************

   @doc internal

   @api void | modmCallback | Callback for completion of sending of
    long messages. This function conforms to the definition in the SDK.

   @parm HMIDIOUT | hmo | The MMSYSTEM handle of the device which
    complete sending.

   @parm WORD | wmsg | Contains a MOM_xxx code signifying what event
    occurred. We only care about MOM_DONE.

   @parm DWORD | dwInstance | DWORD of instance data given at open time;
    this contains the PPORT which owns the handle.

   @parm DWORD | dwParam1 | Message specific parameters. For MOM_DONE,
    this contains a far pointer to the header which completed.

   @parm DWORD | dwParam2 | Message specific parameters. Contains
    nothinf for MOM_DONE.

   @comm This function MUST be in a fixed segment since the driver
    may call it at interrupt time.

***************************************************************************/
void CALLBACK _loadds modmCallback(
    HMIDIOUT            hmo,
    WORD                wmsg,
    DWORD_PTR           dwInstance,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2)
{
    LPMIDIHDR           lpmhShadow;
    LPMIDIHDR           lpmhUser;
    PINSTANCE           pinstance;
    PSHADOWBLOCK        psb;
    LPMIDIHDR31         lpmh31;
    BOOL                fNeedCB         = FALSE;

    lpmhShadow = (LPMIDIHDR)dwParam1;

    if (wmsg == MOM_DONE && lpmhShadow)
    {
        DPF(1, TEXT ("Callback: MOM_DONE"));
        pinstance = (PINSTANCE)(UINT_PTR)lpmhShadow->dwReserved[MH_MAPINST];
        lpmhUser = (LPMIDIHDR)lpmhShadow->dwReserved[MH_SHADOWEE];

        if (ghMidiStrm)
            fNeedCB = TRUE;
        else
        {
            lpmh31 = (LPMIDIHDR31)lpmhUser;
            psb = (PSHADOWBLOCK)(UINT_PTR)lpmh31->reserved;
            if (0 == --psb->cRefCnt && !(lpmh31->dwFlags & MHDR_SENDING))
                fNeedCB = TRUE;
        }

        if (fNeedCB)
        {
            DPF(1, TEXT ("Callback: Propogating"));
            lpmhUser->dwFlags |= MHDR_DONE;
            lpmhUser->dwFlags &= ~MHDR_INQUEUE;
            DriverCallback(
                           pinstance->dwCallback,
                           HIWORD(pinstance->fdwOpen),
                           (HANDLE)pinstance->hmidi,
                           MM_MOM_DONE,
                           pinstance->dwInstance,
                           (DWORD_PTR)lpmhUser,
                           0L);
        }
    }
    else if (wmsg == MOM_POSITIONCB && lpmhShadow)
    {
        pinstance = (PINSTANCE)(UINT_PTR)lpmhShadow->dwReserved[MH_MAPINST];
        lpmhUser = (LPMIDIHDR)lpmhShadow->dwReserved[MH_SHADOWEE];

        if (!ghMidiStrm)
        {
            DPF(0, TEXT ("Got MOM_POSITIONCB on non-stream handle?"));
            return;
        }


        lpmhUser->dwOffset = lpmhShadow->dwOffset;
        DriverCallback(
                       pinstance->dwCallback,
                       HIWORD(pinstance->fdwOpen),
                       (HANDLE)pinstance->hmidi,
                       MM_MOM_POSITIONCB,
                       pinstance->dwInstance,
                       (DWORD_PTR)lpmhUser,
                       0L);

    }
}

/***************************************************************************

   @doc internal

   @api DWORD | MapSingleEvent | Map and possibly send a short message.

   @parm PINSTANCE | pinstance | Pointer to an open instance.

   @parm DWORD | dwData | Contains the short message to transmit.

   @parm DWORD | fdwFlags | One of the the following values:
    @flag MSE_F_SENDEVENT | Send the event to the physical channel
    @flag MSE_F_RETURNEVENT | Return the event to be re-packed into
     a buffer.

   @comm Running status should be taken care of before we get
    called.

   @rdesc | Some MMSYSERR_xxx code if MSE_F_SENDEVENT; otherwise the
    mapped event if no error, 0L on error.

***************************************************************************/
DWORD FNGLOBAL MapSingleEvent(
    PINSTANCE       pinstance,
    DWORD           dwData,
    DWORD           fdwFlags,
    DWORD BSTACK *  pdwStreamID)
{
    BYTE            bMsg;
    BYTE            bChan;
    BYTE            b1;
    BYTE            b2;
    PCHANNEL        pchannel;
    MMRESULT        mmr;
    BOOL            frtm;  // isrealtimemessage.

    // Extract message type and channel number.
    //

    bMsg  = MSG_STATUS(dwData);
    frtm  = IS_REAL_TIME(bMsg);
    bChan = MSG_CHAN(bMsg);
    bMsg  = MSG_EVENT(bMsg);

    // Ignore sysex messages. 
    // (MIDI_SYSEX == bMsg) will also eliminate real time
    // messages. Therefore real-time messages are special cased
    // 

    if (MIDI_SYSEX == bMsg && !frtm)
        return !(fdwFlags & MSE_F_RETURNEVENT) ? MMSYSERR_NOERROR : (((DWORD)MEVT_NOP)<<24);

    if (NULL == (pchannel = gapChannel[bChan]))
        return !(fdwFlags & MSE_F_RETURNEVENT) ? MMSYSERR_NOERROR : (((DWORD)MEVT_NOP)<<24);


    bChan = (BYTE)pchannel->uChannel;

    if (pdwStreamID)
        *pdwStreamID = pchannel->dwStreamID;

    switch(bMsg)
    {
        case MIDI_NOTEOFF:
        case MIDI_NOTEON:
            b1 = MSG_PARM1(dwData);
            b2 = MSG_PARM2(dwData);

            if (NULL != pchannel->pbKeyMap)
                b1 = pchannel->pbKeyMap[b1];

            dwData = MSG_PACK2(bMsg|bChan, b1, b2);
            break;

        case MIDI_POLYPRESSURE:
        case MIDI_CONTROLCHANGE:
        case MIDI_PITCHBEND:
            b1 = MSG_PARM1(dwData);
            b2 = MSG_PARM2(dwData);

            dwData = MSG_PACK2(bMsg|bChan, b1, b2);
            break;

        case MIDI_PROGRAMCHANGE:
            b1 = MSG_PARM1(dwData);

            if (NULL != pchannel->pbPatchMap)
                b1 = pchannel->pbPatchMap[b1];

            dwData = MSG_PACK1(bMsg|bChan, b1);
            break;
    }

    if (!(fdwFlags & MSE_F_RETURNEVENT))
    {
        if (dwData)
        {
            if (ghMidiStrm)
                mmr = midiOutShortMsg((HMIDIOUT)ghMidiStrm, dwData);
            else
                mmr = midiOutShortMsg(pchannel->pport->hmidi, dwData);
            if (MMSYSERR_NOERROR != mmr)
            {
                DPF(1, TEXT ("midiOutShortMsg(%04X, %08lX) -> %u"), (WORD)(pchannel->pport->hmidi), dwData, (UINT)mmr);
            }
        }

        return mmr;
    }
    else
        return dwData;
}

/***************************************************************************

   @doc internal

   @api DWORD | modLongMsg | Handle MODM_LONGDATA in compatibility mode.

   @parm LPMIDIHDR | lpmh | The header to broadcast.

   @comm Propogate the header across all drivers. <f modmCallback> handles
    counting the returning callbacks and making sure the caller only gets
    one.

   @rdesc | Some MMSYSERR_xxx code if MSE_F_SENDEVENT; otherwise the
    mapped event if no error, 0L on error.

***************************************************************************/
DWORD FNLOCAL modLongMsg(
    PINSTANCE           pinstance,
    LPMIDIHDR           lpmh)
{
    WORD                wIntStat;
    LPMIDIHDR           lpmhWork;
    PPORT               pport;
    MMRESULT            mmrc            = MMSYSERR_NOERROR;
    BOOL                fNeedCB         = FALSE;
    LPMIDIHDR31         lpmh31          = (LPMIDIHDR31)lpmh;
    PSHADOWBLOCK        psb;

    if (ghMidiStrm)
        psb = (PSHADOWBLOCK)(UINT_PTR)lpmh->dwReserved[MH_SHADOW];
    else
        psb = (PSHADOWBLOCK)(UINT_PTR)lpmh31->reserved;

    lpmhWork = psb->lpmhShadow;

    lpmhWork->dwReserved[MH_MAPINST] = (DWORD_PTR)pinstance;

    if (ghMidiStrm)
    {
        lpmhWork->dwBufferLength = lpmh->dwBufferLength;
        return midiOutLongMsg((HMIDIOUT)ghMidiStrm,
                              lpmhWork,
                              sizeof(*lpmhWork));
    }

    lpmh->dwFlags |= MHDR_SENDING;
    psb->cRefCnt = 0;

    DPF(1, TEXT ("LongMsg: User hdr %p  Shadow %p"), lpmh, lpmhWork);

    for (pport = gpportList; pport; pport=pport->pNext, lpmhWork++)
    {
        lpmhWork->dwBufferLength = lpmh->dwBufferLength;
        mmrc = midiOutLongMsg(pport->hmidi, lpmhWork, sizeof(*lpmhWork));

        if (MMSYSERR_NOERROR != mmrc)
        {
            // Don't turn off MHDR_SENDING; this will prevent any callbacks
            // from being propogated to the user.
            return mmrc;
        }

        ++psb->cRefCnt;
    }

		// Wait for synchronization object
	WaitForSingleObject (hMutexRefCnt, INFINITE);

		// Do we need to do callback
    if (0 == psb->cRefCnt)
        fNeedCB = TRUE;

		// Release synchronization object
	ReleaseMutex (hMutexRefCnt);

    if (fNeedCB)
    {
        lpmh->dwFlags |= MHDR_DONE;
        DriverCallback(
            pinstance->dwCallback,
            HIWORD(pinstance->fdwOpen),
            (HANDLE)pinstance->hmidi,
            MM_MOM_DONE,
            pinstance->dwInstance,
            (DWORD_PTR)lpmh,
            0L);
    }

    return MMSYSERR_NOERROR;
}


/***************************************************************************

   @doc internal

   @api DWORD | modMapLongMsg | Handle MODM_LONGDATA in compatibility mode.

   @parm LPMIDIHDR | lpmh | The header to broadcast.

   @comm if a SYSEXE event Propogate the header across all drivers.
   <f modmCallback> handles counting the returning callbacks and making sure the caller only gets
    one.   Otherwise, parse the Long Message into a bunch of short messages
	and Map each one individually.

   @rdesc | Some MMSYSERR_xxx code if MSE_F_SENDEVENT; otherwise the
    mapped event if no error, 0L on error.

***************************************************************************/
DWORD FNLOCAL modMapLongMsg (
	PINSTANCE pinstance,
    LPMIDIHDR lpmh)
{
    WORD                wIntStat;
    LPMIDIHDR           lpmhWork;
    PPORT               pport;
    MMRESULT            mmrc            = MMSYSERR_NOERROR;
    BOOL                fNeedCB         = FALSE;
    LPMIDIHDR31         lpmh31          = (LPMIDIHDR31)lpmh;
    PSHADOWBLOCK        psb;
	LPBYTE				pbData;		// Pointer to Data
	BYTE				bMsg;
	UINT				uMessageLength;
	LPBYTE				pbTrans;		// Pointer to Translation Buffer
	DWORD				dwCurr;
	DWORD				dwLength;
	DWORD				dwMsg;
	DWORD				dwBuffLen;
	INT					rMsg;				

		// Get Shadow Block
    if (ghMidiStrm)
        psb = (PSHADOWBLOCK)(UINT_PTR)lpmh->dwReserved[MH_SHADOW];
    else
        psb = (PSHADOWBLOCK)(UINT_PTR)lpmh31->reserved;

    lpmhWork = psb->lpmhShadow;

    lpmhWork->dwReserved[MH_MAPINST] = (DWORD_PTR)pinstance;

		// Check for MIDI streaming
    if (ghMidiStrm)
    {
        lpmhWork->dwBufferLength = lpmh->dwBufferLength;
        return midiOutLongMsg((HMIDIOUT)ghMidiStrm,
                              lpmhWork,
                              sizeof(*lpmhWork));
    }

    lpmh->dwFlags |= MHDR_SENDING;
    psb->cRefCnt = 0;

    DPF(1, TEXT ("MapLongMsg: User hdr %p  Shadow %p"), lpmh, lpmhWork);

    pbData = lpmhWork->lpData;
    bMsg  = MSG_EVENT(*pbData);

    if (MIDI_SYSEX == bMsg)
	{
		// Broadcast SYSEX message to all active ports
	    for (pport = gpportList; pport; pport=pport->pNext, lpmhWork++)
		{
			lpmhWork->dwBufferLength = lpmh->dwBufferLength;
			mmrc = midiOutLongMsg(pport->hmidi, lpmhWork, sizeof(*lpmhWork));
			if (MMSYSERR_NOERROR != mmrc)
			{
				// Don't turn off MHDR_SENDING; this will prevent any callbacks
				// from being propogated to the user.
				return mmrc;
			}
			++psb->cRefCnt;
		}
	}
	else
	{
		// Parse and Translate list of Short messages
		dwBuffLen = lpmh->dwBufferLength;

		// Grow Translation buffer to at least this size
		if (!GrowTransBuffer (pinstance, dwBuffLen))
		{
			// That didn't work !!!
			// Default to Broadcast messages to all active ports
			for (pport = gpportList; pport; pport=pport->pNext, lpmhWork++)
			{
				lpmhWork->dwBufferLength = lpmh->dwBufferLength;
				mmrc = midiOutLongMsg(pport->hmidi, lpmhWork, sizeof(*lpmhWork));
				if (MMSYSERR_NOERROR != mmrc)
				{
					// Don't turn off MHDR_SENDING; this will prevent any callbacks
					// from being propogated to the user.
					return mmrc;
				}
				++psb->cRefCnt;
			}
		}
		else
		{
				// Copy buffer to translation buffer
			pbTrans = AccessTransBuffer (pinstance);
			CopyMemory (pbTrans, pbData, dwBuffLen);

				// Parse translation buffer
			dwCurr	= 0L;
			while (dwBuffLen)
			{
					// Map Event
				rMsg = MapEvent (&pbTrans[dwCurr], dwBuffLen, &dwLength, &dwMsg);
				switch (rMsg)
				{
				case MSG_SHORT:
						// Send Short Message
					MapSingleEvent(pinstance,
				  				   dwMsg,
								   MSE_F_SENDEVENT,
								   NULL);
					dwCurr += dwLength;
					break;

				case MSG_LONG:
					//
					//	Note:  For completeness, we should probably broadcast
					//         this, but for now assume that there are no embedded
					//         SYSEX messages in the buffer and skip any we encounter
					//
					dwCurr += dwLength;
					break;

				default:
					dwCurr += dwLength;
					break;
				}

				dwBuffLen -= dwLength;
			} // End While

				// Release Translation Buffer
			ReleaseTransBuffer (pinstance);
		}
	}

		// Wait for synchronization object
	WaitForSingleObject (hMutexRefCnt, INFINITE);

		// Do we need to do callback
    if (0 == psb->cRefCnt)
        fNeedCB = TRUE;

		// Release synchronization object
	ReleaseMutex (hMutexRefCnt);

    if (fNeedCB)
    {
        lpmh->dwFlags |= MHDR_DONE;
        DriverCallback(
            pinstance->dwCallback,
            HIWORD(pinstance->fdwOpen),
            (HANDLE)pinstance->hmidi,
            MM_MOM_DONE,
            pinstance->dwInstance,
            (DWORD_PTR)lpmh,
            0L);
    }

    return MMSYSERR_NOERROR;

} // End modMapLongMsg


	// returns length of various MIDI messages in bytes
INT FNLOCAL MapEvent (
	BYTE  * pStatus,
	DWORD	dwBuffSize,
	DWORD * pSkipBytes,
	DWORD * pShortMsg)
{
	INT	 fResult = MSG_SHORT;
	BYTE bMsg    = 0;
	BYTE bParam1 = 0;
	BYTE bParam2 = 0;

    bMsg  = *pStatus;
	*pSkipBytes = 0;

	// Mask Off Channel bits
    switch (bMsg & 0xF0)
	{
	case MIDI_NOTEOFF:
	case MIDI_NOTEON:
	case MIDI_POLYPRESSURE:
	case MIDI_CONTROLCHANGE:
		bParam1 = *(pStatus+1);
		bParam2 = *(pStatus+2);
		*pShortMsg = MSG_PACK2(bMsg,bParam1,bParam2);
		*pSkipBytes = 3;
		break;

	case MIDI_PROGRAMCHANGE:
	case MIDI_CHANPRESSURE:
		bParam1 = *(pStatus+1);
		*pShortMsg = MSG_PACK1(bMsg,bParam1);
		*pSkipBytes = 2;
		break;

	case MIDI_PITCHBEND:
		bParam1 = *(pStatus+1);
		bParam2 = *(pStatus+2);
		*pShortMsg = MSG_PACK2(bMsg,bParam1,bParam2);
		*pSkipBytes = 3;
		break;

	case MIDI_SYSEX:
			// It's a system message
			// Keep counting system messages until
			// We don't find any more
		fResult = MSG_LONG;
		*pSkipBytes = 0;
		while (((bMsg & 0xF0) == 0xF0) && 
			   (*pSkipBytes < dwBuffSize))
		{
			switch (bMsg)
			{
			case MIDI_SYSEX:
						// Find end of SysEx message
				*pSkipBytes ++;
				while ((*pSkipBytes < dwBuffSize) && 
					   (pStatus[*pSkipBytes] != MIDI_SYSEXEND))
				{
					*pSkipBytes++;
				}
				break;

			case MIDI_QFRAME:
				*pSkipBytes += 2;
				break;

			case MIDI_SONGPOINTER:
				*pSkipBytes += 3;
				break;

			case MIDI_SONGSELECT:
				*pSkipBytes += 2;
				break;

			case MIDI_F4:					// Undefined message
			case MIDI_F5:					// Undefined message
			case MIDI_TUNEREQUEST:
			case MIDI_SYSEXEND:				// Not really a message, but skip it
			case MIDI_TIMINGCLOCK:
			case MIDI_F9:					// Undefined Message
			case MIDI_START:
			case MIDI_CONTINUE:
			case MIDI_STOP:
			case MIDI_FD:					// Undefined Message
			case MIDI_ACTIVESENSING:		
			case MIDI_META:					// Is this how handle this message ?!?
				*pSkipBytes += 1;
				break;			
			} // End Switch

			if (*pSkipBytes < dwBuffSize)
				bMsg = pStatus[*pSkipBytes];
		} // End While
		break;

	default:
			// Unknown just increment skip count
		fResult = MSG_UNKNOWN;
		*pSkipBytes = 1;
		break;
	} // End switch

		// Truncate to end of buffer
	if (*pSkipBytes > dwBuffSize)
		*pSkipBytes = dwBuffSize;

	return fResult;
} // End MapEvent



	// Create Translation buffer
BOOL FNGLOBAL InitTransBuffer (PINSTANCE pinstance)
{
	if (!pinstance)
		return FALSE;

	InitializeCriticalSection (& (pinstance->csTrans));

	EnterCriticalSection (&(pinstance->csTrans));

	pinstance->pTranslate	= NULL;
	pinstance->cbTransSize	= 0;

	LeaveCriticalSection (&(pinstance->csTrans));

	return TRUE;
} // End InitTransBuffer


	// Cleanup Translation Buffer
BOOL FNGLOBAL CleanupTransBuffer (PINSTANCE pinstance)
{
	if (!pinstance)
		return FALSE;

	EnterCriticalSection (&(pinstance->csTrans));

	if (pinstance->pTranslate)
	{
		LocalFree((HLOCAL)(pinstance->pTranslate));
		pinstance->pTranslate = NULL;
		pinstance->cbTransSize = 0L;
	}

	LeaveCriticalSection (&(pinstance->csTrans));

	DeleteCriticalSection (&(pinstance->csTrans));

	return TRUE;
} // End CleanupTransBuffer


	// Get Pointer to translation buffer
LPBYTE AccessTransBuffer (PINSTANCE pinstance)
{
	if (!pinstance)
		return NULL;

	EnterCriticalSection (&(pinstance->csTrans));

	return pinstance->pTranslate;
} // End AccessTransBuffer


	// Release pointer to translation buffer
void FNGLOBAL ReleaseTransBuffer (PINSTANCE pinstance)
{
	if (!pinstance)
		return;

	LeaveCriticalSection (&(pinstance->csTrans));
} // End ReleaseTransBuffer


	// Resize Translation buffer
BOOL FNGLOBAL GrowTransBuffer (PINSTANCE pinstance, DWORD cbNewSize)
{
	LPBYTE pNew;

	if (!pinstance)
		return FALSE;

	EnterCriticalSection (&(pinstance->csTrans));

		// Do we even need to grow buffer
	if (cbNewSize > pinstance->cbTransSize)
	{
		pNew = (LPBYTE)LocalAlloc(LPTR, cbNewSize);
		if (!pNew)
		{
		LeaveCriticalSection (&(pinstance->csTrans));
		return FALSE;
		}

			// Remove old translation buffer, if any
		if (pinstance->pTranslate)
			LocalFree ((HLOCAL)(pinstance->pTranslate));

			// Assign new buffer
		pinstance->pTranslate = pNew;
		pinstance->cbTransSize = cbNewSize;
	}

	LeaveCriticalSection (&(pinstance->csTrans));
	return TRUE;
} // End GrowTransBuffer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\midimap\modmsg.c ===
/**********************************************************************

  Copyright (c) 1992-1999 Microsoft Corporation

  modmsg.c

  DESCRIPTION:
     Non-fixed code for doing output mapping. Keep out of the reach
     of children. This prescription may be refilled twice. May cause
     temporary distortion of reality in your vicinity.

  HISTORY:
     02/21/94       [jimge]        created.

*********************************************************************/

#include "preclude.h"
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "idf.h"

#include <mmreg.h>
#include <memory.h>

#include "midimap.h"
#include "res.h"
#include "debug.h"


//=========================== Globals ======================================
//
extern HANDLE hMutexConfig; // Located in DRVPROC.C
BOOL          gfReconfigured = FALSE;

//=========================== Prototypes ===================================
//

PRIVATE MMRESULT FNLOCAL SendChannelInitString(
    HMIDIOUT            hmidi,
    PBYTE               pbinit,
    DWORD               cbinit);

/***************************************************************************
  
   @doc internal
  
   @api DWORD | modGetDevCaps | Handles the MODM_GETDEVCAPS message.
  
   @parm LPMIDIOUTCAPS | pmoc | Pointer to a caps structure to fill in.

   @parm DWORD | cbmoc | How big the caller thinks the structure is.
  
   @rdesc Some MMSYSERR_xxx code.
       
***************************************************************************/
DWORD FNGLOBAL modGetDevCaps(
    LPMIDIOUTCAPS   pmoc,
    DWORD           cbmoc)
{
    MIDIOUTCAPS     moc;
    MIDIOUTCAPS     mocWork;
    DWORD           cbCopy;
    WORD            wMask;
    UINT            idx;
    MMRESULT        mmr;
    PPORT           pport;
    
    moc.wMid            = MM_MICROSOFT;
    moc.wPid            = MM_MIDI_MAPPER;
    moc.vDriverVersion  = 0x0500;
    LoadString(ghinst, IDS_MIDIMAPPER, moc.szPname, sizeof(moc.szPname)/sizeof(moc.szPname[0]));
    moc.wTechnology     = MOD_MAPPER;
    moc.wVoices         = 0;
    moc.wNotes          = 0;
    moc.wChannelMask    = 0;

    wMask = 1;
    for (idx = 0; idx < MAX_CHANNELS; idx++)
    {
        if (gapChannel[idx])
            moc.wChannelMask |= wMask;
        wMask <<= 1;
    }

    // If any underlying device supports cache patches, we must support it.
    // Only support volume or lrvolume, however, if ALL devices support it.
    //
    
    do
    {
        gfReconfigured = FALSE;
        moc.dwSupport  = MIDICAPS_STREAM|MIDICAPS_VOLUME|MIDICAPS_LRVOLUME;
        
        for (pport = gpportList; pport; pport=pport->pNext)
        {
            mmr = midiOutGetDevCaps(pport->uDeviceID, &mocWork, sizeof(mocWork));

            //  This prevents a corrupt gpportList in the event of a pnp event
            //  during a midiOutGetDevCaps call...            
            if (gfReconfigured)
                break;
                
            if (MMSYSERR_NOERROR != mmr)
                continue;

            if (!(mocWork.dwSupport & MIDICAPS_LRVOLUME))
                moc.dwSupport &= ~MIDICAPS_LRVOLUME;

            if (!(mocWork.dwSupport & MIDICAPS_VOLUME))
                moc.dwSupport &= ~(MIDICAPS_VOLUME|MIDICAPS_LRVOLUME);

            moc.dwSupport |= (mocWork.dwSupport & MIDICAPS_CACHE);
        }
    } 
    while (gfReconfigured);

    CLR_ALLOWVOLUME;
    if (moc.dwSupport & MIDICAPS_VOLUME)
        SET_ALLOWVOLUME;

    CLR_ALLOWCACHE;
    if (moc.dwSupport & MIDICAPS_CACHE)
        SET_ALLOWCACHE;

    cbCopy = min(cbmoc, sizeof(moc));
    hmemcpy((LPSTR)pmoc, (LPSTR)&moc, cbCopy);

    return MMSYSERR_NOERROR;
}


/***************************************************************************
  
   @doc internal
  
   @api DWORD | modOpen | Handles the MODM_OPEN message.
  
   @parm LPDWORD | lpdwInstance | Points to a DWORD where we can store
    our instance data. We save our PINSTANCE here.
  
   @parm LPMIDIOPENDESC | lpmidiopendesc | Points to parameters from
    MMSYSTEM describing the caller's callback, etc.
  
   @parm DWORD | fdwOpen | Flags describing the callback type.
  
   @rdesc Some MMSYSERR_xxx code.
       
***************************************************************************/
DWORD FNGLOBAL modOpen(
    PDWORD_PTR      lpdwInstance,
    LPMIDIOPENDESC  lpmidiopendesc,
    DWORD           fdwOpen)                  
{
    PINSTANCE       pinstance				= NULL;
    PPORT           pport;
    MMRESULT        mmrc					= MMSYSERR_NOERROR;
    UINT            idx;
    UINT            idx2;
    UINT            auDeviceID[MAX_CHANNELS];

    // Open in MIDI_IO_CONTROL -- only allows reconfigure message. This MUST
    // ALWAYS succeed so we have a chance of recovery on reconfigure no matter
    // how badly messed up the old config was.
    //
    if (!(fdwOpen & MIDI_IO_CONTROL))
    {
        if (IS_DEVSOPENED)
            return MMSYSERR_ALLOCATED;
        
        // Mapper is single instance now
        //
        assert(NULL == gpinstanceList);
    }
    else
    {
        if (NULL != gpIoctlInstance)
            return MMSYSERR_ALLOCATED;
    }
    
#ifdef DEBUG
    if (fdwOpen & MIDI_IO_COOKED)
        DPF(2, TEXT ("Mapper opened in polymsg mode!!!"));
#endif
    
    // Alloc this zero-init so all the initial channel mappings in
    // rgpChannel are NULL.
    //
    if (NULL == (pinstance = (PINSTANCE)LocalAlloc(LPTR, sizeof(INSTANCE))))
        return MMSYSERR_NOMEM;

    pinstance->hmidi        = lpmidiopendesc->hMidi;
    pinstance->dwCallback   = lpmidiopendesc->dwCallback;
    pinstance->dwInstance   = lpmidiopendesc->dwInstance;
    pinstance->fdwOpen      = fdwOpen;

		// Create Translation buffer
	if (! InitTransBuffer (pinstance))
	{
		LocalFree ((HGLOBAL)pinstance);
		return MMSYSERR_NOMEM;
	}

    if (fdwOpen & MIDI_IO_CONTROL)
    {
        *lpdwInstance = (DWORD_PTR)pinstance;

        gpIoctlInstance = pinstance;
        
        DriverCallback(
                       pinstance->dwCallback,
                       HIWORD(pinstance->fdwOpen),
                       (HDRVR)(pinstance->hmidi),
                       MM_MOM_OPEN,
                       pinstance->dwInstance,
                       0L,
                       0L);        


        return MMSYSERR_NOERROR;
    }
    

    DPF(2, TEXT ("modOpen pinstance %04X"), (WORD)pinstance);

    *lpdwInstance = 0;   // Assume failure

    if (IS_CONFIGERR)
    {
        DPF(1, TEXT ("Open failed because configuration invalid"));
        mmrc = MIDIERR_NOMAP;
		goto midi_Out_Open_Cleanup;
    }

	if (fdwOpen & MIDI_IO_COOKED)
	{
		// Build list of device ID's (stream id's emuerate ports) and
		// assign stream id's to channels.
		//
		for (idx = 0, pport = gpportList; pport; idx++,pport=pport->pNext)
		{
			auDeviceID[idx] = pport->uDeviceID;
			for (idx2 = 0; idx2 < MAX_CHANNELS; idx2++)
				if (gapChannel[idx2] && gapChannel[idx2]->pport == pport)
					gapChannel[idx2]->dwStreamID = (DWORD)idx;
		}

		// Attempt to open.
		//
		mmrc = midiStreamOpen(&ghMidiStrm, auDeviceID, idx, (DWORD_PTR)modmCallback, 0L, CALLBACK_FUNCTION);

		// Fall through to cleanup code
		// 
	}
	else
	{
		// Run through the port list and try to open all referenced ports 
		//
		for (pport = gpportList; pport; pport=pport->pNext)
		{
			if (NULL == pport->hmidi)
			{
				mmrc = midiOutOpen(&pport->hmidi,
								   pport->uDeviceID,
								   (DWORD_PTR)modmCallback,
								   (DWORD_PTR)pport,
								   CALLBACK_FUNCTION|MIDI_IO_SHARED);

				if (MMSYSERR_NOERROR != mmrc)
				{
					DPF(1, TEXT ("Could not open pport %04X device %u"), (WORD)pport, pport->uDeviceID);

					// Just in case....
					//
					pport->hmidi = NULL;

					for (pport = gpportList; pport; pport=pport->pNext)
						if (NULL != pport->hmidi)
						{
							midiOutClose(pport->hmidi);
							pport->hmidi = NULL;
						}

					// Return whatever caused the underlying open to fail
					//
					break;
				}
			}
		}
	}
    
midi_Out_Open_Cleanup:
	if (MMSYSERR_NOERROR != mmrc)
	{
			// Cleanup
		CleanupTransBuffer (pinstance);
		if (pinstance) LocalFree((HLOCAL)pinstance);
		return mmrc;
	}

    gdwVolume = 0xFFFFFFFFL;
    
	SET_DEVSOPENED;
	
    // We've succeeded; put the instance into the global instance list
    // and return it as our instance data.
    //
    pinstance->pNext = gpinstanceList;
    gpinstanceList = pinstance;

    *lpdwInstance = (DWORD_PTR)pinstance;
    

    // Lock the segments we need. If we're doing packed mode mapping,
    // we don't need the cooked mode segment in memory. However, the
    // cooked mode mapper DOES call the packed routines, so we need to
    // lock both in that case.
    //
    if (fdwOpen & MIDI_IO_COOKED)
    {
		LockMapperData();
		LockPackedMapper();
		LockCookedMapper();
    }
    else
    {
		LockMapperData();
		LockPackedMapper();
    }

    // Do the (useless) callback
    //
    DriverCallback(
        pinstance->dwCallback,
        HIWORD(pinstance->fdwOpen),
        (HDRVR)(pinstance->hmidi),
        MM_MOM_OPEN,
        pinstance->dwInstance,
        0L,
        0L);        
                   
    
    return MMSYSERR_NOERROR;
}

/***************************************************************************
  
   @doc internal
  
   @api DWORD | modPrepare | Handles the MODM_PREPARE message.

   @parm LPMIDIHDR | lpmh | The user header to prepare.
  
   @rdesc Some MMSYSERR_xxx code.

   @comm

     Create some shadow headers.

     For the case of mapper opened for stream
      we only require one shadow header that we can pass along to our
      mapped-to stream. We need this because the mapped-to stream and
      the mapped-from stream will both want to use the dwReserved[]
      fields in the MIDIHDR.

     For the case of mapper opened not-for-stream
      This must be a long message header that we want to propogate to all
      ports. Therefore we have gcPorts shadow headers and each one is
      prepared on one node of the global port list.

     In either case, we return MMSYSERR_NOTSUPPORTED on success so that
      MMSYSTEM will take its default action and page lock the user MIDIHDR
      for us.
       
***************************************************************************/
DWORD FNGLOBAL modPrepare(
    LPMIDIHDR           lpmh)
{
    LPMIDIHDR           lpmhNew;
    LPMIDIHDR           lpmhWork;
    MMRESULT            mmrcRet         = MMSYSERR_NOERROR;
    PPORT               pport;
    PPORT               pportWork;
    PSHADOWBLOCK        psb             = NULL;

    psb = (PSHADOWBLOCK)LocalAlloc(LPTR, sizeof(*psb));
    if (NULL == psb)
    {
        mmrcRet = MMSYSERR_NOMEM;
        goto modPrepare_Cleanup;
    }
            
    psb->cRefCnt = 0;
    psb->dwBufferLength = lpmh->dwBufferLength;
    
    if (ghMidiStrm)
    {
        psb->lpmhShadow = (LPMIDIHDR)GlobalAllocPtr(
            GMEM_MOVEABLE|GMEM_SHARE,
            sizeof(*lpmhNew));
        
        if (NULL == psb->lpmhShadow)
        {
            mmrcRet = MMSYSERR_NOMEM;
            goto modPrepare_Cleanup;
        }

        lpmhNew = psb->lpmhShadow;
        *lpmhNew = *lpmh;

        lpmhNew->dwReserved[MH_SHADOWEE] = (DWORD_PTR)lpmh;
        lpmh->dwReserved[MH_SHADOW] = (DWORD_PTR)psb;

        lpmhNew->dwFlags |= MHDR_SHADOWHDR;

        mmrcRet = midiOutPrepareHeader((HMIDIOUT)ghMidiStrm, 
                                       lpmhNew, 
                                       sizeof(*lpmhNew));
        if (MMSYSERR_NOERROR != mmrcRet)
            lpmh->dwReserved[MH_SHADOW] = 0;
    }
    else
    {
        LPMIDIHDR31         lpmh31  = (LPMIDIHDR31)lpmh;
        
        // Prepare shadow headers for sending to multiple non-stream
        // drivers
        //
        // NOTE: The parent header is a 3.1 style header; the children
        // are 4.0 and thus are longer.
        //

        psb->lpmhShadow = (LPMIDIHDR)GlobalAllocPtr(
            GMEM_MOVEABLE|GMEM_SHARE|GMEM_ZEROINIT,
            sizeof(*lpmhNew)*gcPorts);
        
        if (NULL == psb->lpmhShadow)
        {
            mmrcRet = MMSYSERR_NOMEM;
            goto modPrepare_Cleanup;
        }

        lpmhNew = psb->lpmhShadow;
        lpmhWork = lpmhNew;
        for (pport = gpportList; pport; pport = pport->pNext, lpmhWork++)
        {
            *(LPMIDIHDR31)lpmhWork = *lpmh31;
            lpmhWork->dwFlags |= MHDR_SHADOWHDR;
            
            mmrcRet = midiOutPrepareHeader(pport->hmidi,
                                        lpmhWork,
                                        sizeof(*lpmhWork));
            if (MMSYSERR_NOERROR != mmrcRet)
            {
                lpmhWork = lpmhNew;
                for (pportWork = gpportList; pportWork != pport; pportWork = pportWork->pNext, lpmhWork++)
                    midiOutUnprepareHeader(pport->hmidi, lpmhWork, sizeof(*lpmhWork));

                goto modPrepare_Cleanup;
            }

            lpmhWork->dwReserved[MH_SHADOWEE] = (DWORD_PTR)lpmh31;
        }

        DPF(1, TEXT ("Prepare: User header %p  Shadow %p"), lpmh, lpmhNew);

        lpmh31->reserved = (DWORD_PTR)psb;
    }

    // This will force MMSYSTEM to do default prepare on the parent header --
    // i.e. page lock it for us.
    //
modPrepare_Cleanup:
    if (MMSYSERR_NOERROR != mmrcRet)
    {
        if (psb)
        {
            if (psb->lpmhShadow) GlobalFreePtr(psb->lpmhShadow);
            LocalFree((HLOCAL)psb);
        }
    }
    
    return (MMSYSERR_NOERROR != mmrcRet) ? mmrcRet : MMSYSERR_NOTSUPPORTED;
}

/***************************************************************************
  
   @doc internal
  
   @api DWORD | modUnprepare | Handles the MODM_UNPREPARE message.

   @parm LPMIDIHDR | lpmh | The user header to unprepare.
  
   @rdesc Some MMSYSERR_xxx code.

   @comm

     Fully undo the effects of the modPrepare call.

     Unprepare and free all shadow headers.

     Return MMSYSERR_NOTSUPPORTED so MMSYSTEM will correctly handle the
      final unprepare of the user header.
       
***************************************************************************/
DWORD FNGLOBAL modUnprepare( 
    LPMIDIHDR           lpmh)
{
    LPMIDIHDR           lpmhNew;
    MMRESULT            mmrc;
    PPORT               pport;
    PSHADOWBLOCK        psb;
    
    if (ghMidiStrm)
    {
        psb = (PSHADOWBLOCK)(UINT_PTR)lpmh->dwReserved[MH_SHADOW];
        lpmhNew = psb->lpmhShadow;

        lpmhNew->dwBufferLength = psb->dwBufferLength;
        mmrc = midiOutUnprepareHeader((HMIDIOUT)ghMidiStrm, 
                                      lpmhNew, 
                                      sizeof(*lpmhNew));
        if (MMSYSERR_NOERROR != mmrc)
            return mmrc;

        LocalFree((HLOCAL)psb);
        GlobalFreePtr(lpmhNew);
        lpmh->dwReserved[MH_SHADOW] = 0;
    }
    else
    {
        LPMIDIHDR31         lpmh31  = (LPMIDIHDR31)lpmh;

        psb = (PSHADOWBLOCK)(UINT_PTR)lpmh31->reserved;
        lpmhNew = psb->lpmhShadow;

        for (pport = gpportList; pport; pport = pport->pNext, ++lpmhNew)
        {
            lpmhNew->dwBufferLength = psb->dwBufferLength;
            midiOutUnprepareHeader(pport->hmidi, lpmhNew, sizeof(*lpmhNew));
        }

        GlobalFreePtr(psb->lpmhShadow);
        LocalFree((HLOCAL)psb);

        lpmh31->reserved = 0;
    }
    
    // Need the default action of unprepare in MMSYSTEM here
    //
    return MMSYSERR_NOTSUPPORTED;
}

/***************************************************************************
  
   @doc internal
  
   @api DWORD | modClose | Handles the MODM_CLOSE message.

   @parm PINSTANCE | pinstance | Pointer to an open instance to close.
  
   @rdesc Some MMSYSERR_xxx code.
       
***************************************************************************/
DWORD FNGLOBAL modClose(
    PINSTANCE       pinstance)
{
    PPORT           pport;

    DPF(1, TEXT ("Mapper close"));
    // Close underlying streams on the query can-close (which is first)
    // and just succeed the actual close
    //

    assert(pinstance);

    if (pinstance->fdwOpen & MIDI_IO_CONTROL)
    {
        assert(pinstance == gpIoctlInstance);
        
        gpIoctlInstance = NULL;
        goto modClose_Cleanup;
    }
    
	// Assert that we're the only thing in the instance list
	//
	assert(gpinstanceList == pinstance);
	assert(pinstance->pNext == NULL);

	gpinstanceList = NULL;

    if (pinstance->fdwOpen & MIDI_IO_COOKED)
		UnlockCookedMapper();
	
	UnlockMapperData();
	UnlockPackedMapper();

	if (ghMidiStrm)
	{
		midiStreamClose(ghMidiStrm);
		ghMidiStrm = NULL;
	}
	else
	{
		for (pport = gpportList; pport; pport = pport->pNext)
		{
			if (NULL != pport->hmidi)
			{
				midiOutClose(pport->hmidi);
				pport->hmidi = NULL;
			}
		}
	}
        
    CLR_DEVSOPENED;
   
    // If reconfigure due, do it!
    //
    if (IS_RECONFIGURE)
    {
				// Prevent Synchronization problems
				// During Configuration
        if (NULL != hMutexConfig)
			WaitForSingleObject (hMutexConfig, INFINITE);

        DPF(1, TEXT ("Delayed reconfigure now being done"));
        UpdateInstruments(FALSE, 0);

        if (NULL != hMutexConfig)
			ReleaseMutex (hMutexConfig);
        
		CLR_RECONFIGURE;

    }
    

modClose_Cleanup:
    DriverCallback(
        pinstance->dwCallback,
        HIWORD(pinstance->fdwOpen),
        (HDRVR)(pinstance->hmidi),
        MM_MOM_CLOSE,
        pinstance->dwInstance,
        0L,
        0L);        
    
    // Free up instance memory.
    //
	CleanupTransBuffer (pinstance);
    LocalFree((HLOCAL)pinstance);

    return MMSYSERR_NOERROR;
}

/***************************************************************************
  
   @doc internal
  
   @api DWORD | modGetPosition | Get the current position in the MIDI stream.
    
   @parm LPINSTANCE | pinstance | Stream we want the position in.

   @parm LPMMTIME | lpmmt | Pointer to a standard MMTIME struct to fill in.

   @parm DWORD | cbmmt | Size of the MMTIME structure passed.

   @comment
     Pass the structure along to the first open subsidiary stream.
     This will be considered the de facto timebase until there's a
     way to set it.

   @rdesc MMSYSERR_xxx       
***************************************************************************/
DWORD FNGLOBAL modGetPosition(
    PINSTANCE           pinstance,
    LPMMTIME            lpmmt,
    DWORD               cbmmt)
{
    return midiStreamPosition(ghMidiStrm,
                              lpmmt,
                              (UINT)cbmmt);
}

DWORD FNGLOBAL modSetVolume(         
    DWORD               dwVolume)
{
    PPORT               pport;
    MMRESULT            mmrc;
    MMRESULT            mmrc2;
    
    // Walk the port list and send the volume change to everyone
    //

    mmrc2 = MMSYSERR_NOERROR;
    for (pport = gpportList; pport; pport = pport->pNext)
    {
        mmrc = midiOutSetVolume(pport->hmidi, dwVolume);
        if (MMSYSERR_NOERROR != mmrc)
            mmrc2 = mmrc;
    }

    return mmrc2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\midimap\preclude.h ===
// Copyright (c) 1995 Microsoft Corporation

// MMSYSTEM precludes
//
 
#define     MMNOSOUND
#define     MMNOWAVE
#define     MMNOSEQ
#define     MMNOTIMER
#define     MMNOJOY
////#define     MMNOMCI
#define     MMNOTASK

// MMDDK precludes
//
#define     MMNOWAVEDEV
#define     MMNOAUXDEV
#define     MMNOTIMERDEV
#define     MMNOJOYDEV
/////#define     MMNOMCIDEV
#define     MMNOTASKDEV

// WINDOWS precludes
//

#define     NOGDICAPMASKS        //- CC_*, LC_*, PC_*, CP_*, TC_*, RC_
#define     NOVIRTUALKEYCODES    //- VK_*
#define     NOICONS              //- IDI_*
#define     NOKEYSTATES          //- MK_*
#define     NOSYSCOMMANDS        //- SC_*
#define     NORASTEROPS          //- Binary and Tertiary raster ops
#define     OEMRESOURCE          //- OEM Resource values
#define     NOCLIPBOARD          //- Clipboard routines
#define     NOMETAFILE           //- typedef METAFILEPICT
//#define     NOOPENFILE           //- OpenFile(), OemToAnsi, AnsiToOem, and OF_*
#define     NOSOUND              //- Sound driver routines
#define     NOWH                 //- SetWindowsHook and WH_*
#define     NOCOMM               //- COMM driver routines
#define     NOKANJI              //- Kanji support stuff.
//#define     NOHELP               //- Help engine interface.
#define     NOPROFILER           //- Profiler interface.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\midimap\queue.c ===
/**********************************************************************

  Copyright (c) 1992-1995 Microsoft Corporation

  queue.c

  DESCRIPTION:
    Priority queue routines.

  HISTORY:
     02/22/94       [jimge]        created.

*********************************************************************/

#include "preclude.h"
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "idf.h"

#include "midimap.h"

#include "debug.h"

//#pragma warning(disable:4704)

/***************************************************************************
  
   @doc internal
  
   @api void | QueueInit | Prepare a queue for use.
  
   @parm PQUEUE | pq | Queue to clear.
  
***************************************************************************/
void FNGLOBAL QueueInit(
    PQUEUE              pq)
{
    InitializeCriticalSection (&(pq->cs));
    pq->pqeFront = NULL;
    pq->pqeRear  = NULL;
    pq->cEle     = 0;
}



/***************************************************************************
  
   @doc internal
  
   @api void | QueueCleanup | Cleans up a queue after use.
  
   @parm PQUEUE | pq | Queue to clear.
  
***************************************************************************/
void FNGLOBAL QueueCleanup(
    PQUEUE              pq)
{
    DeleteCriticalSection (&(pq->cs));
    pq->pqeFront = NULL;
    pq->pqeRear  = NULL;
    pq->cEle     = 0;
}

/***************************************************************************
  
   @doc internal
  
   @api void | QueuePut | Insert an item into the queue.

   @parm PQUEUE | pq | Queue to insert into.

   @parm PQUEUEELE | pqe | New element to insert.

   @parm UINT | uPriority | Priority of the new element.

   @comm New elements will be inserted in priority order. Low priorities
   go near the front of the queue (first to be dequeued). New elements
   will be inserted at the end of all elements in the queue with
   equal or lower priorities.
  
***************************************************************************/
void FNGLOBAL QueuePut(
    PQUEUE              pq,
    PQUEUEELE           pqe,
    UINT                uPriority)
{
    PQUEUEELE           pqePrev;
    PQUEUEELE           pqeCurr;
    
    EnterCriticalSection(&(pq->cs));
  
    pqePrev = NULL;
    pqeCurr = pq->pqeFront;

    pqe->uPriority = uPriority;

    // Position pqePrev and pqeCurr so that pqe should be
    // inserted between them.
    //
    while (NULL != pqeCurr)
    {
        if (uPriority < pqeCurr->uPriority)
            break;

        pqePrev = pqeCurr;
        pqeCurr = pqeCurr->pqeNext;
    }

    // Now do the actual insertion.
    //
    if (NULL == pqePrev)
        pq->pqeFront = pqe;
    else
        pqePrev->pqeNext = pqe;

    if (NULL == pqeCurr)
        pq->pqeRear = pqe;
    else
        pqeCurr->pqePrev = pqe;

    pqe->pqePrev = pqePrev;
    pqe->pqeNext = pqeCurr;
    ++pq->cEle;

    LeaveCriticalSection(&(pq->cs));
}

/***************************************************************************
  
   @doc internal
  
   @api void | QueueGet | Get and remove the first element from the queue. 

   @parm PQUEUE | pq | Queue to get the element from.

   @rdesc NULL if the queue is empty, otherwise the element pointer. 
  
***************************************************************************/
PQUEUEELE FNGLOBAL QueueGet(
    PQUEUE              pq)
{
    PQUEUEELE           pqe;

    EnterCriticalSection(&(pq->cs));

    pqe = pq->pqeFront;

    if (NULL != pqe)
    {
        pq->pqeFront = pqe->pqeNext;

        if (NULL == pqe->pqeNext)
            pq->pqeRear = NULL;
        else
            pqe->pqeNext->pqePrev = NULL;
    
        pqe->pqePrev = pqe->pqeNext = NULL;

        --pq->cEle;
    }
    
    LeaveCriticalSection(&(pq->cs));

    return pqe;
}

/***************************************************************************
  
   @doc internal
  
   @api void | QueueRemove | Remove a specific element from the queue.

   @parm PQUEUE | pq | Queue to remove from.

   @parm PQUEUEELE | pqe | Element to remove.

   @rdesc TRUE on success, FALSE if the element does not exist in the
    queue.
  
***************************************************************************/
BOOL FNGLOBAL QueueRemove(
    PQUEUE              pq,
    PQUEUEELE           pqe)
{
    PQUEUEELE           pqeCurr;
    
    EnterCriticalSection(&(pq->cs));

    // Ensure that we don't muck around with pointers to some
    // other queue.
    //

    for (pqeCurr = pq->pqeFront; pqeCurr; pqeCurr = pqeCurr->pqeNext)
        if (pqe == pqeCurr)
            break;

    if (NULL == pqeCurr)
    {
        LeaveCriticalSection(&(pq->cs));
        return FALSE;
    }

    // It's in the queue, remove it.
    //
    if (NULL == pqe->pqePrev)
        pq->pqeFront = pqe->pqeNext;
    else
        pqe->pqePrev->pqeNext = pqe->pqeNext;

    if (NULL == pqe->pqeNext)
        pq->pqeRear = pqe->pqePrev;
    else
        pqe->pqeNext->pqePrev = pqe->pqePrev;

    --pq->cEle;
    
    LeaveCriticalSection(&(pq->cs));
    return TRUE;
}

/***************************************************************************
  
   @doc internal
  
   @api PQUEUEELE | QueueGetFilter | Remove the first element from a
    priority queue which matches a filter.

   @parm PQUEUE | pq | Queue to remove from.

   @parm FNFILTER | fnf | Filter function. Should return TRUE if
    the passed PQUEUEELE matches the filter criteria and should
    be removed.

   @rdesc A PQUEUEELE or NULL if none are available that match the
    filter.
  
***************************************************************************/
PQUEUEELE FNGLOBAL QueueGetFilter(
    PQUEUE              pq,
    FNFILTER            fnf)
{
    PQUEUEELE           pqe;
    
    EnterCriticalSection(&(pq->cs));

    for (pqe = pq->pqeFront; pqe; pqe = pqe->pqeNext)
        if (fnf(pqe))
            break;

    if (NULL != pqe)
        QueueRemove(pq, pqe);
    
    LeaveCriticalSection(&(pq->cs));

    return pqe;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\midimap\regfix.h ===
// Copyright (c) 1995 Microsoft Corporation

/*
**-----------------------------------------------------------------------------
**	File:		RegFix.c
**	Purpose:	fix up registry settings for MIDI-Mapper
**	Mod Log:	Created by Shawn Brown (11/14/95)
**-----------------------------------------------------------------------------
*/
#ifndef REGFIX_H
#define REGFIX_H

#include <windows.h>
#include <mmsystem.h>
#include <regstr.h>

BOOL CheckRegistry (void);

BOOL 

#endif // REGFIX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\midimap\res.h ===
/**********************************************************************

    Copyright (c) 1992-1995 Microsoft Corporation

    res.h

    DESCRIPTION:
      Resource ID include file for the MIDI mapper.

*********************************************************************/

#ifndef _RES_
#define _RES_

#define IDS_MIDIMAPPER          1000

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\midimap\regfix.c ===
/* Copyright (c) 1995 Microsoft Corporation */
/*
**-----------------------------------------------------------------------------
**	File:		RegFix.c
**	Purpose:	Fix up various registry settings for MidiMapper
**	Mod Log:	Created by Shawn Brown (11/14/95)
**-----------------------------------------------------------------------------
*/

/*
**-----------------------------------------------------------------------------
**	Includes
**-----------------------------------------------------------------------------
*/
#include "RegFix.h"



/*
**-----------------------------------------------------------------------------
**	Local Prototypes
**-----------------------------------------------------------------------------
*/

BOOL CheckMidiOK (void);
BOOL SetMidiOK (BOOL fOK);

BOOL CheckMidiHeader (void);
BOOL CheckMidiSchemes (void);
BOOL CheckMidiDrivers (void);

BOOL CreateDefMidiHeader (void);
BOOL CreateDefMidiSchemes (void);
BOOL CreateDefMidiDrivers (void);


/*
**-----------------------------------------------------------------------------
**	Local Variables
**-----------------------------------------------------------------------------
*/

	// Consider - revisit these and make them use the appropriate roots 
	//			from regstr.h
static const TCHAR l_aszMidiMapKey[]	= TEXT ("Software\\Microsoft\\Multimedia\\MidiMap");

static const TCHAR l_aszMediaPropKey[]	= TEXT ("System\\CurrentControlSet\\Control\\MediaProperties");
static const TCHAR l_aszMediaRsrcKey[]	= TEXT ("System\\CurrentControlSet\\Control\\MediaResources");

static const TCHAR l_aszMRMidiKey[]		= TEXT ("System\\CurrentControlSet\\Control\\MediaResources\\Midi");

static const TCHAR l_aszSchemesKey[]	= TEXT ("System\\CurrentControlSet\\Control\\MediaProperties\\PrivateProperties\\MIDI\\Schemes");

static const TCHAR l_aszMediaKey[]		= TEXT ("Media");
static const TCHAR l_aszMIDIKey[]		= TEXT ("Midi");
static const TCHAR aszInstrumentKey[]	= TEXT ("Instruments");
static const TCHAR aszDrvMIDIKey[]		= TEXT ("Drivers\\MIDI");
static const TCHAR aszPrivateKey[]		= TEXT ("Private Properties");
static const TCHAR aszDefaultKey[]		= TEXT ("Default");

static const TCHAR aszMigratedVal[]		= TEXT ("Migrated");

static const TCHAR aszMIDI[]			= TEXT ("MIDI");
static const TCHAR aszNULL[]			= TEXT ("");

static const TCHAR l_aszOK[]			= TEXT ("Validate");

static const TCHAR aszActiveVal[]		= TEXT ("Active");
static const TCHAR aszDescripVal[]		= TEXT ("Description");
static const TCHAR aszDeviceIDVal[]		= TEXT ("DeviceID");
static const TCHAR aszDevNodeVal[]		= TEXT ("DevNode");
static const TCHAR aszDriverVal[]		= TEXT ("Driver");
static const TCHAR aszFriendlyVal[]		= TEXT ("FriendlyName");
static const TCHAR aszMapCfgVal[]		= TEXT ("MapperConfig");
static const TCHAR aszSoftwareVal[]		= TEXT ("SOFTWAREKEY");

static const TCHAR aszInstallerVal[]	= TEXT ("Installer");
static const TCHAR aszChannelsVal[]		= TEXT ("Channels");

static const TCHAR aszMIDIClass[]		= TEXT ("Midi");
static const TCHAR aszAuxClass[]		= TEXT ("Aux");
static const TCHAR aszWaveClass[]		= TEXT ("Wave");
static const TCHAR aszMixerClass[]		= TEXT ("Mixer");

static const TCHAR aszOne[]				= TEXT ("1");
static const TCHAR aszZeroZeroKey[]		= TEXT ("00");



/*
**-----------------------------------------------------------------------------
**	Name:       CheckRegistry
**  Purpose:
**  Mod Log:    Created by Shawn Brown (11/95)
**-----------------------------------------------------------------------------
*/

BOOL CheckRegistry (BOOL fForceUpdate)
{
	if (!fForceUpdate)
	{
			// Check OK flag
		if (CheckMidiOK())
			return TRUE;
	}

		// Fix up Header
	if (! CheckMidiHeader())
		return FALSE;

		// Fix up schemes
	if (! CheckMidiSchemes ())
		return FALSE;

		// Fix up drivers
	if (! CheckMidiDrivers ())
		return FALSE;

		// All done, set OK flag
	SetMIDIOK (TRUE);

	return TRUE;
}



/*
**-----------------------------------------------------------------------------
**	Name:       CheckMidiOK
**  Purpose:	Simple quick check to see if everything is OK
**  Mod Log:    Created by Shawn Brown (11/95)
**-----------------------------------------------------------------------------
*/

BOOL CheckMidiOK (void)
{
	HKEY	hKey;
	LONG	lResult;
	DWORD	dwType;
	DWORD	dwVal;
	DWORD	cbSize;

	lResult = RegOpenEx (HKEY_CURRENT_USER, l_aszMidiMapKey,
						 0, KEY_ALL_ACCESS, &hKey);
	if (ERROR_SUCCESS != lResult)
		return FALSE;

	dwType = REG_DWORD;
	cbSize = sizeof (DWORD);
	lResult = RegQueryValueEx (hKey, l_aszOK, NULL, &dwType,
							   (LPBYTE)(LPDWORD)&dwVal, &cbSize);
	if (ERROR_SUCCESS != lResult)
	{
		RegCloseKey (hKey);
		return FALSE;
	}
	RegCloseKey (hKey);

	if (0 == dwVal)
		return FALSE;

	return TRUE;
} // End CheckMidiOK


  
/*
**-----------------------------------------------------------------------------
**	Name:       SetMidiOK
**  Purpose:	Set OK value
**  Mod Log:    Created by Shawn Brown (11/95)
**-----------------------------------------------------------------------------
*/

BOOL SetMidiOK (BOOL fOK)
{
	HKEY	hKey;
	LONG	lResult;
	DWORD	dwType;
	DWORD	dwVal;
	DWORD	cbSize;

	lResult = RegOpenEx (HKEY_CURRENT_USER, l_aszMidiMapKey,
						 0, KEY_ALL_ACCESS, &hKey);
	if (ERROR_SUCCESS != lResult)
		return FALSE;

	dwType	= REG_DWORD;
	dwVal	= (DWORD)fOK;
	cbSize	= sizeof (DWORD);
	lResult = RegSetValueEx (hKey, l_aszOK, 0, &dwType, 
							(LPBYTE)(LPDWORD)&dwVal, &cbSize);
	if (ERROR_SUCCESS != lResult)
	{
		RegCloseKey (hKey);
		return FALSE;
	}
	RegCloseKey (hKey);

	return TRUE;
} // End SetMidiOK



/*
**-----------------------------------------------------------------------------
**	Name:       CheckHeader
**  Purpose:	do we have a valid Midi Header ?!?
**  Mod Log:    Created by Shawn Brown (11/95)
**-----------------------------------------------------------------------------
*/
 
BOOL CheckMidiHeader (void)
{
	return CreateDefMidiHeader ();
} // End CheckMidiHeader

  

/*
**-----------------------------------------------------------------------------
**	Name:       CreateDefMidiHeader
**  Purpose:
**  Mod Log:    Created by Shawn Brown (11/95)
**-----------------------------------------------------------------------------
*/
 
BOOL CreateDefaultHeader (void)
{
} // End CreateDefaultHeader


  
/*
**-----------------------------------------------------------------------------
**	Name:       IsMIDIDriver
**  Purpose:
**  Mod Log:    Created by Shawn Brown (11/95)
**-----------------------------------------------------------------------------
*/

BOOL IsMIDIDriver (
	LPCTSTR pszDriverName)		// IN:	driver name
{
	UINT cNumDrivers;
	UINT ii;
	TCHAR	szDriver[MAX_PATH];

		// Look for the MIDI driver
	cNumDrivers = midiOutGetNumDevs ();
	for (ii = 0; ii < cNumDrivers; ii++)
	{
		if (! GetDriverName (aszMIDI, ii, szDriver, MAX_PATH))
			continue;

		if (0 == lstrcmpi (pszDriverName, szDriver))
			return TRUE;
	} // End for

		// Look for the MIDI driver
	cNumDrivers = midiInGetNumDevs ();
	for (ii = 0; ii < cNumDrivers; ii++)
	{
		if (! GetDriverName (aszMIDI, ii, szDriver, MAX_PATH))
			continue;

		if (0 == lstrcmpi (pszDriverName, szDriver))
			return TRUE;
	} // End for

	return FALSE;
} // End IsMIDIDriver
  


/*
**-----------------------------------------------------------------------------
**	Name:       IsMigrated
**  Purpose:
**  Mod Log:    Created by Shawn Brown (11/95)
**-----------------------------------------------------------------------------
*/

BOOL IsMigrated (UINT uDeviceID)
{
	TCHAR szDriver[MAX_PATH];
	TCHAR szBuffer[MAX_PATH];
	HKEY  hDriverKey;
	DWORD cbSize;

		// Get Driver 
	if (! GetDriverName (aszMIDI, uDeviceID, szDriver, MAX_PATH))
		return FALSE;

		// Open Driver Key
	wsprintf (szBuffer, TEXT ("%s\\%s<%04ld>"), aszMRMidiKey, szDriver, uDeviceID);
	if (ERROR_SUCCESS != RegOpenKeyEx (HKEY_LOCAL_MACHINE, szBuffer,
									   0, KEY_ALL_ACCESS, &hDriverKey))
		return FALSE;

		// Get Migrated Value
		// The mere existence of the Migrated value indicates
		// we have already successfully migrated this driver
	cbSize = sizeof(szBuffer);
	if (ERROR_SUCCESS != RegQueryValueEx (hDriverKey, aszMigratedVal, 
										  NULL, NULL, (LPBYTE)szBuffer, &cbSize))
	{
		RegCloseKey (hDriverKey);
		return FALSE;
	}

	RegCloseKey (hDriverKey);

	return TRUE;
} // End IsMigrated

  

/*
**-----------------------------------------------------------------------------
**	Name:       MigrateNewMIDIDriver
**  Purpose:
**  Mod Log:    Created by Shawn Brown (11/95)
**-----------------------------------------------------------------------------
*/
  
BOOL MigrateNewMIDIDriver (
	UINT uDeviceID)				// IN: MIDI Driver device ID
{
	TCHAR		szDriver[MAX_PATH];
	TCHAR		szFriend[MAX_PATH];
	TCHAR		szDescrip[MAX_PATH];
	TCHAR		szBuffer[MAX_PATH];	
	DWORD		cOut;
	MIDIOUTCAPS moc;
	DWORD		dwDisposition;
	DWORD		cbSize;
	DWORD		dwVal;
	HKEY		hMIDIKey		= NULL;
	HKEY		hDriverKey		= NULL;
	HKEY		hInstrumentKey	= NULL;
	HKEY		hKey			= NULL;
	BOOL		fResult = FALSE;

	cOut = midiOutGetNumDevs ();
	if (uDeviceID >= cOut)
		return FALSE;

		// Get Driver
	if (! GetDriverName (aszMIDI, uDeviceID, szDriver, MAX_PATH))
		return FALSE;

		// Get Friendly Name
	if (! GetDriverFriendlyName (aszMIDI, uDeviceID, szFriend, MAX_PATH))
	{
		lstrcpy (szFriend, szDriver);
	}

		// Get Description
	if (MMSYSERR_NOERROR != midiOutGetDevCaps (uDeviceID, &moc, sizeof(moc)))
		return FALSE;

	if (moc.szPname[0] == 0)
	{
		lstrcpy (szDescrip, szDriver);
	}
	else
	{
		lstrcpy (szDescrip, moc.szPname);
	}

		// Open key, create it if it doesn't already exist
	if (ERROR_SUCCESS != RegCreateKeyEx (HKEY_LOCAL_MACHINE, aszMRMidiKey,
										 0, NULL, 0, KEY_ALL_ACCESS, NULL, 
										 &hMIDIKey, NULL))
	{
		return FALSE;
	}

		// Create new driver key
	wsprintf (szBuffer, TEXT ("%s<%04ld>"), szDriver, uDeviceID);
	if (ERROR_SUCCESS != RegCreateKeyEx (hMIDIKey, szBuffer,
										 0, NULL, 0, KEY_ALL_ACCESS, NULL,
										 &hDriverKey, &dwDisposition))
	{
		goto lblCLEANUP;
	}
	RegCloseKey (hMIDIKey);
	hMIDIKey = NULL;


		//
		// Set Driver Values
		//


		// Set Active = "1" value
	cbSize = sizeof (aszOne);	
	if (ERROR_SUCCESS != RegSetValueEx (hDriverKey, aszActiveVal, 0, 
										REG_SZ, (LPBYTE)aszOne, cbSize))
	{
		goto lblCLEANUP;
	}

		// Set Description = szDescrip value
	cbSize = (lstrlen (szDescrip) + 1) * sizeof(TCHAR);	
	if (ERROR_SUCCESS != RegSetValueEx (hDriverKey, aszDescripVal, 0, 
										REG_SZ, (LPBYTE)szDescrip, cbSize))
	{
		goto lblCLEANUP;
	}

		// Set DeviceID = "" value
	cbSize = (lstrlen (aszNULL) + 1) * sizeof(TCHAR);
	if (ERROR_SUCCESS != RegSetValueEx (hDriverKey, aszDeviceIDVal, 0, 
										REG_SZ, (LPBYTE)aszNULL, cbSize))
	{
		goto lblCLEANUP;
	}

		// Set DevNode =  value
	cbSize = 0;
	if (ERROR_SUCCESS != RegSetValueEx (hDriverKey, aszDeviceIDVal, 0, 
										REG_BINARY, (LPBYTE)NULL, cbSize))
	{
		goto lblCLEANUP;
	}

		// Set Driver =  szDriver
	cbSize = (lstrlen (szDriver) + 1) * sizeof(TCHAR);
	if (ERROR_SUCCESS != RegSetValueEx (hDriverKey, aszDriverVal, 0, 
										REG_SZ, (LPBYTE)szDriver, cbSize))
	{
		goto lblCLEANUP;
	}

		// Set FriendlyName
	cbSize = (lstrlen (szFriend) + 1) * sizeof(TCHAR);
	if (ERROR_SUCCESS != RegSetValueEx (hDriverKey, aszFriendlyVal, 0, 
										REG_SZ, (LPBYTE)szFriend, cbSize))
	{
		goto lblCLEANUP;
	}

		// Set Mapper Config
	cbSize = sizeof(DWORD);
	dwVal = 0;
	if (ERROR_SUCCESS != RegSetValueEx (hDriverKey, aszMapCfgVal, 0, 
										REG_DWORD, (LPBYTE)&dwVal, cbSize))
	{
		goto lblCLEANUP;
	}

		// Set SOFTWARE value
	wsprintf (szBuffer, TEXT("%s\\%04ld"), aszServiceKey, uDeviceID);
	cbSize = (lstrlen (szBuffer) + 1) * sizeof(TCHAR);
	if (ERROR_SUCCESS != RegSetValueEx (hDriverKey, aszSoftwareVal, 0, 
										REG_SZ, (LPBYTE)szBuffer, cbSize))
	{
		goto lblCLEANUP;
	}

		// Create Instruments Key
	if (ERROR_SUCCESS != RegCreateKeyEx (hDriverKey, aszInstrumentKey, 0, NULL, 
										0, KEY_ALL_ACCESS, NULL,
										&hInstrumentKey, &dwDisposition))
	{
		goto lblCLEANUP;
	}
	RegCloseKey (hInstrumentKey);
	hInstrumentKey = NULL;


		// Create Services\Class\Media\0001\Drivers\midi key
		// Open key, create it if it doesn't already exist
//	wsprintf (szBuffer, TEXT("%s\\%04ld\\%s"), aszServiceKey, uDeviceID, aszDrvMIDIKey);
//	if (ERROR_SUCCESS != RegCreateKeyEx (HKEY_LOCAL_MACHINE, szBuffer,
//										 0, NULL, 0, KEY_ALL_ACCESS, NULL, 
//										 &hMIDIKey, NULL))
//	{
//		goto lblCLEANUP;
//	}

		// Create 

		// Set MIGRATED value
		// NOTE: this is always the very last thing to do to indicate successful migration
	cbSize = (lstrlen (aszOne) + 1) * sizeof(TCHAR);
	if (ERROR_SUCCESS != RegSetValueEx (hDriverKey, aszMigratedVal, 0, REG_SZ, (LPBYTE)aszOne, cbSize))
	{
		goto lblCLEANUP;
	}

			// Success
	fResult = TRUE;

lblCLEANUP:
	if (hInstrumentKey)
		RegCloseKey (hInstrumentKey);

	if (hDriverKey)
		RegCloseKey (hDriverKey);

	if (hMIDIKey)
		RegCloseKey (hMIDIKey);

	return fResult;
} // End MigrateNewMIDIDriver


  
/*
**-----------------------------------------------------------------------------
**	Name:       CreateDefaultMIDISchemes
**  Purpose:
**  Mod Log:    Created by Shawn Brown (11/95)
**-----------------------------------------------------------------------------
*/

BOOL CreateDefaultMIDISchemes (void)
{
	HKEY hSchemeKey;
	HKEY hDefaultKey;
	HKEY hZeroKey;
	DWORD dwVal;
	DWORD cbSize;


		// Create MIDI Schemes key
	if (ERROR_SUCCESS != RegCreateKeyEx (HKEY_LOCAL_MACHINE, aszMIDISchemesKey,
										 0, NULL, 0, KEY_ALL_ACCESS, NULL, 
										 &hSchemeKey, NULL))
	{
		return FALSE;
	}


		// Create Default Key
	if (ERROR_SUCCESS != RegCreateKeyEx (hSchemeKey, aszDefaultKey,
										 0, NULL, 0, KEY_ALL_ACCESS, NULL, 
										 &hDefaultKey, NULL))
	{
		RegCloseKey (hSchemeKey);
		return FALSE;
	}
	RegCloseKey (hSchemeKey);


		// Create 00 Key
	if (ERROR_SUCCESS != RegCreateKeyEx (hDefaultKey, aszZeroZeroKey,
										 0, NULL, 0, KEY_ALL_ACCESS, NULL, 
										 &hZeroKey, NULL))
	{
		RegCloseKey (hDefaultKey);
		return FALSE;
	}
	RegCloseKey (hDefaultKey);


		// Create Default Channels Value
	dwVal = 0x0000FFFF;
	cbSize = sizeof(DWORD);
	if (ERROR_SUCCESS != RegSetValueEx (hZeroKey, aszChannelsVal, 0, 
										REG_DWORD, (LPBYTE)&dwVal, cbSize))
	{
		RegCloseKey (hZeroKey);
		return FALSE;
	}
	RegCloseKey (hZeroKey);

		// Success
	return TRUE;
} // End CreateDefaultMIDISchemes


  
  
/*
**-----------------------------------------------------------------------------
**	Name:       MigrateExistingMIDISchemes
**  Purpose:
**  Mod Log:    Created by Shawn Brown (11/95)
**-----------------------------------------------------------------------------
*/

BOOL MigrateExistingMIDISchemes (void)
{
	return TRUE;
} // End MigrateExistingMIDISchemes

  

/*
**-----------------------------------------------------------------------------
**	Name:       MigrateMIDIDrivers
**  Purpose:
**  Mod Log:    Created by Shawn Brown (11/95)
**-----------------------------------------------------------------------------
*/
  
BOOL MigrateMIDIDrivers (void)
{
	UINT cOut;
	UINT ii;
	BOOL fResult = TRUE;

	if (! CreateDefaultMIDISchemes ())
	{
		return FALSE;
	}

	if (! MigrateExistingMIDISchemes ())
	{
		return FALSE;
	}

	cOut = midiOutGetNumDevs ();
	if (cOut == 0L)
		return FALSE;

	for (ii = 0; ii < cOut; ii++)
	{
		if (IsMigrated (ii))
			continue;

		if (! MigrateNewMIDIDriver (ii))
			fResult = FALSE;
	}

	return fResult;

} // End MigrateMIDIDrivers


  
/*
**-----------------------------------------------------------------------------
**	Name:       DumpDeviceCaps
**  Purpose:
**  Mod Log:    Created by Shawn Brown (11/95)
**-----------------------------------------------------------------------------
*/

BOOL DumpMidiOutDeviceCaps (UINT uDeviceID, LPSTR pszBuff, UINT cchLen)
{
	static const aszMMicrosoft[] = TEXT ("Microsoft(TM)");
	static const aszMMUnknown[]	 = 

	MIDIOUTCAPS moc;
	MMRESULT	mmr;
	DWORD		wMid;
	DWORD		wPid;
	DWORD		dwVerHigh, dwVerLow;
	LPTSTR		pszName;
    WORD		wTechnology; 
    WORD		wVoices; 
    WORD		wNotes; 
    WORD		wChannelMask; 
    DWORD		dwSupport; 

	mmr = midiOutGetDevCaps (uDeviceId, &moc, sizeof(moc));
	if (MMSYSERR_NOERROR != mmr)
		return FALSE;

	
	
	

	return TRUE;
} // End DumpDeviceCaps



/*
**-----------------------------------------------------------------------------
** End of File
**-----------------------------------------------------------------------------
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\midimap\wassert.h ===
// Copyright (c) 1995 Microsoft Corporation
/*
 * Define the assert() macro for windows apps.
 *
 * The macro will only be expanded to a function call if DEBUG is 
 * defined.
 *
 */

#undef  assert

#ifndef DEBUG

#define assert(exp) ((void)0)

#else 

void FAR PASCAL WinAssert
(
    LPSTR       lpstrModule,
    LPSTR       lpstrFile,
    DWORD       dwLine
);

#define assert(exp) \
    ( (exp) ? (void) 0 : WinAssert(#exp, __FILE__, __LINE__) )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mixerapp\dlg.h ===
// Copyright (c) 1995-1998 Microsoft Corporation

#define IDOFFSET   1000

LPBYTE  Dlg_HorizDupe (LPBYTE lpSrc, DWORD cbSrc, int cDups,  DWORD *pcbNew);
HGLOBAL Dlg_LoadResource (HINSTANCE hModule, LPCTSTR lpszName, DWORD *pcbSize);
DWORD   Dlg_CopyDLGITEMTEMPLATE (LPBYTE lpDst, LPBYTE lpSrc, WORD wIdOffset,short xOffset, short yOffset, BOOL bDialogEx);
DWORD   Dlg_CopyDLGTEMPLATE (LPBYTE lpDst, LPBYTE lpSrc, BOOL bDialogEx);
LPBYTE  Dlg_HorizAttach (LPBYTE lpMain, DWORD cbMain, LPBYTE lpAdd, DWORD cbAdd, WORD wIdOffset, DWORD *pcbNew);
DWORD Dlg_HorizSize(LPBYTE lpDlg);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mixerapp\dlg.c ===
/*****************************************************************************
 *
 *  Component:  sndvol32.exe
 *  File:       dlg.c
 *  Purpose:    dialog template aggregator
 * 
 *  Copyright (c) 1985-1998 Microsoft Corporation
 *
 *****************************************************************************/
#include <windows.h>
#include <windowsx.h>
#include <string.h>
#include "dlg.h"
#include <winuserp.h>

/*
 * DlgLoadResource
 *
 * */
HGLOBAL Dlg_LoadResource(
    HINSTANCE hModule,
    LPCTSTR   lpszName,
    DWORD     *pcbSize)
{
    HRSRC hrsrc;
    HGLOBAL hres;
    HGLOBAL hlock;
    
    hrsrc = FindResource(hModule, lpszName, RT_DIALOG);        
    if (!hrsrc)
        return NULL;

    hres = LoadResource(hModule, hrsrc);
    
    if (!hres)
        return NULL;
    
    hlock = LockResource(hres);
    if (pcbSize)
    {
        if (hlock)
            *pcbSize = SizeofResource(hModule, hrsrc);
        else
            *pcbSize = 0L;
    }
    return hlock;
}


/*
 * DlgHorizAttach
 * - Attaches a dialog template horizontally to another dialog
 * - if lpMain == NULL allocs a new dialog copy.
 *
 * */
LPBYTE Dlg_HorizAttach(
    LPBYTE  lpMain,
    DWORD   cbMain,
    LPBYTE  lpAdd,
    DWORD   cbAdd,
    WORD    wIdOffset,
    DWORD   *pcbNew)
{
    LPBYTE  lpDst;
    LPBYTE  lpDstOffset;
    LPBYTE  lpSrcOffset;        
    DWORD   cbDst;
    DWORD   cbOffset = 0L, cbAddOffset;
    int     idit;
    BOOL    bDialogEx;
    int     iditCount;
    
    DLGTEMPLATE * lpdtDst;
    DLGTEMPLATE * lpdtAdd;    
    DLGTEMPLATE2 * lpdtDst2;
    DLGTEMPLATE2 * lpdtAdd2;    
        
    if (lpMain)
    {
        cbDst = cbMain + cbAdd;
        lpDst = GlobalReAllocPtr(lpMain, cbDst, GHND);
    }
    else
    {
        // no dialog to append to, so just make a copy
        
        lpDst = Dlg_HorizDupe(lpAdd, cbAdd, 1, &cbDst);
        if (!lpDst)
        {
            if (pcbNew)
                *pcbNew = 0L;
            return NULL;
        }
        *pcbNew = cbDst;
        return lpDst;
    }
    
    if (!lpDst)
    {
        if (pcbNew)
            *pcbNew = 0L;
        return NULL;
    }

    // advance to end of dlgitemtemplates already there

    if(((DLGTEMPLATE2 *)lpDst)->wSignature == 0xffff) 
    {    
        //
        //  We assume lpdtDst and lpdtAdd are both the same type of 
        //  template, either DIALOG or DIALOGEX
        //
        lpdtDst2 = (DLGTEMPLATE2 *)lpDst;
        iditCount = lpdtDst2->cDlgItems;
        bDialogEx = TRUE;
    }
    else
    {
        
        lpdtDst = (DLGTEMPLATE *)lpDst;
        iditCount = lpdtDst->cdit;
        bDialogEx = FALSE;
    }
    cbOffset = Dlg_CopyDLGTEMPLATE(NULL, lpDst, bDialogEx);
    
    for (idit = 0; idit < iditCount; idit++)
    {
        DWORD cbDIT;
            
        lpDstOffset = lpDst + cbOffset;
        cbDIT = Dlg_CopyDLGITEMTEMPLATE(NULL
                                       , lpDstOffset
                                       , (WORD)0
                                       , (short)0
                                       , (short)0 
                                       , bDialogEx);
            
        cbOffset    += cbDIT;
    }

    // advance to the start of the dlgitemtemplates to add
    
    if (bDialogEx)
    {
        lpdtAdd2 = (DLGTEMPLATE2 *)lpAdd;
        iditCount = lpdtAdd2->cDlgItems;
    }
    else
    {
        lpdtAdd = (DLGTEMPLATE *)lpAdd;
        iditCount = lpdtAdd->cdit;
    }

    cbAddOffset = Dlg_CopyDLGTEMPLATE(NULL, lpAdd, bDialogEx);

    // add the new dialog templates
    
    for (idit = 0; idit < iditCount; idit++)
    {
        DWORD cbDIT;
        short cx = bDialogEx ? lpdtDst2->cx : lpdtDst->cx;
            
        lpDstOffset = lpDst + cbOffset;
        lpSrcOffset = lpAdd + cbAddOffset;
                
        cbDIT = Dlg_CopyDLGITEMTEMPLATE(lpDstOffset
                                       , lpSrcOffset
                                       , (WORD)wIdOffset
                                       , cx
                                       , (short)0 
                                       , bDialogEx);
            
        cbOffset    += cbDIT;
        cbAddOffset += cbDIT;
    }

    if (bDialogEx)
    {
        lpdtDst2->cDlgItems += lpdtAdd2->cDlgItems;
        lpdtDst2->cx   += lpdtAdd2->cx;
        lpdtDst2->cy   = max(lpdtAdd2->cy, lpdtDst2->cy);
    }
    else
    {
        lpdtDst->cdit += lpdtAdd->cdit;
        lpdtDst->cx   += lpdtAdd->cx;
        lpdtDst->cy   = max(lpdtAdd->cy, lpdtDst->cy);
    }

    if (pcbNew)
        *pcbNew = cbOffset;
    
    return lpDst;
}

/*
 * Dlg_HorizSize
 *
 * Returns width of dialog box in dlu's.
 *
 * */
DWORD Dlg_HorizSize(
    LPBYTE lpDlg)
{
    if(((DLGTEMPLATE2 *)lpDlg)->wSignature == 0xffff) 
    {    
        return (((DLGTEMPLATE2 *)lpDlg)->cx - 2);  // Compensate for right side trimming
    }
    else
    {
        return (((DLGTEMPLATE *)lpDlg)->cx - 2);  // Compensate for right side trimming
    }
}

/*
 * DlgHorizDupe
 *
 * */
LPBYTE Dlg_HorizDupe(
    LPBYTE  lpSrc,
    DWORD   cbSrc,
    int     cDups,
    DWORD   *pcbNew)
{
    int     idit;
    int     iDup;
    DWORD   cbOffset;
    DWORD   cbDTOffset;
    DWORD   cbDT0Offset;
    LPBYTE  lpDst;
    DLGTEMPLATE * lpdt;
    DLGTEMPLATE2 * lpdt2;
    LPBYTE  lpDstOffset;
    LPBYTE  lpSrcOffset;
    DWORD   cbSize;
    int     iCount;
    BOOL    bDialogEx;
    
    cbSize = cDups * cbSrc;
    //DWORD align
    cbSize = (cbSize + 3)&~3;
    
    lpDst = GlobalAllocPtr(GHND, cbSize);
    if (!lpDst)
        return NULL;
    
    if(((DLGTEMPLATE2 *)lpSrc)->wSignature == 0xffff) 
    {
        lpdt2 = (DLGTEMPLATE2 *)lpDst;
        iCount = ((DLGTEMPLATE2 *)lpSrc)->cDlgItems;
        bDialogEx = TRUE;
    }
    else
    {
        lpdt = (DLGTEMPLATE *)lpDst;
        iCount = ((DLGTEMPLATE *)lpSrc)->cdit;
        bDialogEx = FALSE;
    }
    cbDT0Offset = cbDTOffset = cbOffset = Dlg_CopyDLGTEMPLATE(lpDst,lpSrc, bDialogEx);

    for (iDup = 0; iDup < cDups; iDup++)
    {
        // reset the DTOffset to the first DIT
        cbDTOffset = cbDT0Offset;
        
        for (idit = 0; idit < iCount; idit++)
        {
            DWORD cbDIT;
            short cx = bDialogEx ? lpdt2->cx : lpdt->cx;
            
            lpDstOffset = lpDst + cbOffset;
            lpSrcOffset = lpSrc + cbDTOffset;
                
            cbDIT = Dlg_CopyDLGITEMTEMPLATE(lpDstOffset
                , lpSrcOffset
                , (WORD)(iDup * IDOFFSET)   // all id increments are by IDOFFSET
                , (short)(iDup * cx)
                , (short)0                  // no y increments
                , bDialogEx);                 
            
            cbOffset    += cbDIT;
            cbDTOffset  += cbDIT;
        }
    }

    // adjust template width and number of items    
    if (bDialogEx)
    {
        lpdt2->cDlgItems  *= (WORD)cDups;
        lpdt2->cx    *= (short)cDups;
    }
    else
    {
        lpdt->cdit  *= (WORD)cDups;
        lpdt->cx    *= (short)cDups;
    }
    
    if (pcbNew)
        *pcbNew = cbOffset;
    
    return lpDst;
}


/*
 * DlgCopyDLGITEMTEMPLATE
 *
 * if lpDst == NULL only returns offset into lpSrc of next dlgitemtemplate
 * */
DWORD Dlg_CopyDLGITEMTEMPLATE(
    LPBYTE  lpDst,
    LPBYTE  lpSrc,
    WORD    wIdOffset,
    short   xOffset,
    short   yOffset,
    BOOL    bDialogEx)
{
    LPBYTE  lpOffset;
    DWORD   cbDlg=bDialogEx ? sizeof(DLGITEMTEMPLATE2):sizeof(DLGITEMTEMPLATE);
    DLGITEMTEMPLATE * lpdit;
    DLGITEMTEMPLATE2 * lpdit2;
    
    if (bDialogEx)
    {
        lpdit2= (DLGITEMTEMPLATE2 *)lpDst;
    }
    else
    {
        lpdit = (DLGITEMTEMPLATE *)lpDst;
    }
    // Control class
    
    lpOffset = lpSrc + cbDlg;
    if (*(LPWORD)lpOffset == 0xFFFF)
    {
        cbDlg += 2*sizeof(WORD);
    }
    else
    {
        cbDlg += (wcslen((LPWSTR)lpOffset) + 1) * sizeof(WCHAR);
    }

    lpOffset = lpSrc + cbDlg;
    if (*(LPWORD)lpOffset == 0xFFFF)
    {
        cbDlg += 2*sizeof(WORD);
    }
    else
    {
        cbDlg += (wcslen((LPWSTR)lpOffset) + 1) * sizeof(WCHAR);
    }

    cbDlg += sizeof(WORD);
        
    // DWORD align.
    cbDlg = (cbDlg + 3)&~3;

    if (lpDst)
    {
        CopyMemory(lpDst, lpSrc, cbDlg);
    
        if (bDialogEx)
        {
            lpdit2->x    += xOffset;
            lpdit2->y    += yOffset;

            // id offset only if the control isn't static
            if (lpdit2->dwID != -1)
                lpdit2->dwID += wIdOffset;
        }
        else
        {
            lpdit->x    += xOffset;
            lpdit->y    += yOffset;

            // id offset only if the control isn't static
            if (lpdit->id != -1)
                lpdit->id += wIdOffset;
        }
        
    }
    return cbDlg;
}
    
/*
 * DlgCopyDLGTEMPLATE
 *
 * if lpDst == NULL only returns offset into lpSrc to first dlgitemtemplate
 *
 * */
DWORD Dlg_CopyDLGTEMPLATE(
    LPBYTE lpDst,
    LPBYTE lpSrc,
    BOOL   bDialogEx)
{
    LPBYTE  lpOffset;
    UINT    uiStyle;
    DWORD   cbDlg = bDialogEx ? sizeof(DLGTEMPLATE2) : sizeof(DLGTEMPLATE);

    // Menu description

    lpOffset = lpSrc + cbDlg;
    if (*(LPWORD)lpOffset == 0xFFFF)
    {
        cbDlg += 2*sizeof(WORD);
    }
    else if (*(LPWORD)lpOffset == 0x0000)
    {
        cbDlg += sizeof(WORD);
    }
    else
    {
        cbDlg += (wcslen((LPWSTR)lpOffset) + 1)*sizeof(WCHAR);
    }

    // Window class

    lpOffset = lpSrc + cbDlg;
    if (*(LPWORD)lpOffset == 0xFFFF)
    {
        cbDlg += 2*sizeof(WORD);
    }
    else if (*(LPWORD)lpOffset == 0x0000)
    {
        cbDlg += sizeof(WORD);
    }
    else
    {
        cbDlg += (wcslen((LPWSTR)lpOffset) + 1) * sizeof(WCHAR);
    }

    // Title

    lpOffset = lpSrc + cbDlg;
    cbDlg += (wcslen((LPWSTR)lpOffset) + 1) * sizeof(WCHAR);

    // Font
    if (bDialogEx)
    {
        uiStyle = ((DLGTEMPLATE2 * )lpSrc)->style;
    }
    else
    {
        uiStyle = ((DLGTEMPLATE * )lpSrc)->style;
    }

    if (uiStyle & DS_SETFONT) 
    {
        cbDlg += sizeof(WORD);
        if (bDialogEx)
        {
            cbDlg += sizeof(WORD);
            cbDlg += sizeof(BYTE);
            cbDlg += sizeof(BYTE);
        }
        lpOffset = lpSrc + cbDlg;
        cbDlg += (wcslen((LPWSTR)lpOffset) + 1) *sizeof(WCHAR);
    }
    // DWORD align
    
    cbDlg = (cbDlg + 3)&~3;

    // copy the dlgtemplate into the destination.
    if (lpDst)
        CopyMemory(lpDst, lpSrc, cbDlg);
    
    return cbDlg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mixerapp\helpids.h ===
// Copyright (c) 1995-1998 Microsoft Corporation
#define IDH_SNDVOL32_SELECT_DEVICE			4300
#define IDH_SNDVOL32_SELECT_SOUND			4301
#define IDH_SNDVOL32_VOLCONTROL			4302
#define IDH_SNDVOL32_OPTIONS_PROPERTIES		4303
#define IDH_SNDVOL32_OPTIONS_ADVANCED_CONTROLS	4304
#define IDH_SNDVOL32_OPTIONS_EXIT			4305
#define IDH_SNDVOL32_HELP_HELP_TOPICS		4306
#define IDH_SNDVOL32_HELP_ABOUT			4307
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mixerapp\mixer.c ===
/*****************************************************************************
 *
 *  Component:  sndvol32.exe
 *  File:       mixer.c
 *  Purpose:    mixer api specific implementations
 *
 *  Copyright (c) 1985-1999 Microsoft Corporation
 *
 *****************************************************************************/
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <commctrl.h>

#include <math.h>
#include "volumei.h"
#include "volids.h"
#include "vu.h"

#define STRSAFE_LIB
#include <strsafe.h>

extern void Mixer_Multichannel(PMIXUIDIALOG pmxud, DWORD dwVolumeID);
extern void Mixer_Advanced(PMIXUIDIALOG pmxud, DWORD dwLineID, LPTSTR szName);
extern HRESULT GetDestination(DWORD mxid, int *piDest);
extern BOOL DeviceChange_Init(HWND hWnd, DWORD dwMixerID);

/*****************************************************************************
 *
 *  INIT SPECIFIC CODE
 *
 *****************************************************************************/

/*
 * Mixer_GetNumDevs
 *
 * */
int Mixer_GetNumDevs()
{
    return mixerGetNumDevs();
}

/*
 * Mixer_GetDeviceName()
 *
 * */
BOOL Mixer_GetDeviceName(
    PMIXUIDIALOG pmxud)
{
    MIXERCAPS       mxcaps;
    MMRESULT        mmr;

    mmr = mixerGetDevCaps( pmxud->mxid, &mxcaps, sizeof(mxcaps));
    if( mmr == MMSYSERR_NOERROR )
	{
		HRESULT hr;
		hr = StringCchCopy( pmxud->szMixer, SIZEOF(pmxud->szMixer), mxcaps.szPname );
		if( hr == S_OK )
		{
			return TRUE;
		}
	}

	pmxud->szMixer[0] = TEXT('\0');
	return FALSE;
}


BOOL Mixer_AreChannelsAtMinimum(MIXERCONTROLDETAILS_UNSIGNED* pmcdVolume,
                                DWORD cChannels)
{
    UINT uiIndx;
    if (pmcdVolume && cChannels > 0)
    {
        for (uiIndx = 0; uiIndx < cChannels; uiIndx++)
        {
           if ((pmcdVolume + uiIndx) -> dwValue != 0)
           {
               return (FALSE);
           }
        }
        return (TRUE);      // Volume of all channels equals zero since we haven't returned yet.

    }
    else return (FALSE);

}






void Mixer_RefreshMixCache (PVOLCTRLDESC pvcd,
                            MIXERCONTROLDETAILS_UNSIGNED* pmcdVolume,
                            DWORD cChannels)
{

    if (pmcdVolume && cChannels > 0)
    {

        // Create cache if necessary
        if (!pvcd->pdblCacheMix)
            pvcd->pdblCacheMix = (double*) GlobalAllocPtr(GHND, sizeof (double) * cChannels);

        // Refresh cache
        if (pvcd->pdblCacheMix)
        {

            UINT uiIndx;
            double* pdblMixPercent;
            DWORD dwVolume;

            // Get the maximum volume
            DWORD dwMaxVol = 0;
            for (uiIndx = 0; uiIndx < cChannels; uiIndx++)
                dwMaxVol = max (dwMaxVol, (pmcdVolume + uiIndx) -> dwValue);

            // Caculate the percentage distance each channel is away from the max
            // value. Creating this cache allows us to maintain the relative distance
            // of the channel levels from each other as the user adjusts the master
            // volume level.
            for (uiIndx = 0; uiIndx < cChannels; uiIndx++)
            {
                dwVolume       = (pmcdVolume + uiIndx) -> dwValue;
                pdblMixPercent = (pvcd->pdblCacheMix + uiIndx);

                // Caculate the percentage this value is from the max ...
                if (dwMaxVol == dwVolume)
                {
                    *pdblMixPercent = 1.0F;
                }
                else
                {
                    // Note: if 0 == dwMaxVol all values would be zero and this part
                    //       of the "if" statement will never execute.
                    *pdblMixPercent = ((double) dwVolume / (double) dwMaxVol);
                }
            }
        }
    }
}

/*
 * Mixer_SetLines
 *
 * Locate mixer/mux relationships.  Fix up uninitialized volume description
 * information.
 *
 * */
static void Mixer_SetLines(
    HMIXEROBJ       hmx,
    PVOLCTRLDESC    pvcd,
    UINT            cPvcd)
{
    LPMIXERCONTROLDETAILS_LISTTEXT pmcd_lt;
    PMIXERCONTROLDETAILS_BOOLEAN pmcd_b;
    MIXERCONTROLDETAILS mxd;
    MMRESULT        mmr;
    UINT            i,j;
    MIXERLINE       mxl;
    DWORD           dwDst;

    //
    // Another test for drivers.  Some drivers (Mediavision)
    // don't return the proper destination / source index in the
    // mixerGetLineInfo call.  Tag a workaround.
    //
    mxl.cbStruct    = sizeof(mxl);
    mxl.dwLineID    = pvcd[0].dwLineID;

    mmr = mixerGetLineInfo(hmx
                           , &mxl
                           , MIXER_GETLINEINFOF_LINEID);

    if (mmr == MMSYSERR_NOERROR)
    {
        dwDst = mxl.dwDestination;
        for (i = 1; i < cPvcd; i++)
        {
            mxl.cbStruct    = sizeof(mxl);
            mxl.dwLineID    = pvcd[i].dwLineID;

            mmr = mixerGetLineInfo(hmx
                                   , &mxl
                                   , MIXER_GETLINEINFOF_LINEID);
            if (mmr != MMSYSERR_NOERROR)
            {
                pvcd[0].dwSupport |= VCD_SUPPORTF_BADDRIVER;
                break;
            }
            if (mxl.dwDestination != dwDst)
            {
                pvcd[0].dwSupport |= VCD_SUPPORTF_BADDRIVER;
                break;
            }
        }
    }

    //
    // for the first pvcd (destination), propogate the mixer/mux control
    // id's to those controls that are part of the list.  0 out the rest.
    // The UI can just do a mixerXXXControlDetails on the control ID to
    // locate the state information
    //
    if (pvcd->dwSupport & VCD_SUPPORTF_MIXER_MIXER)
    {
        pmcd_lt = GlobalAllocPtr(GHND, sizeof(MIXERCONTROLDETAILS_LISTTEXT)
                                 * pvcd->cMixer);
        pmcd_b = GlobalAllocPtr(GHND, sizeof(MIXERCONTROLDETAILS_BOOLEAN)
                                  * pvcd->cMixer);

        if (!pmcd_lt || !pmcd_b)
            return;

        mxd.cbStruct       = sizeof(mxd);
        mxd.dwControlID    = pvcd->dwMixerID;
        mxd.cChannels      = 1;
        mxd.cMultipleItems = pvcd->cMixer;
        mxd.cbDetails      = sizeof(MIXERCONTROLDETAILS_LISTTEXT);
        mxd.paDetails      = pmcd_lt;
        mmr = mixerGetControlDetails(hmx
                                     , &mxd
                                     , MIXER_GETCONTROLDETAILSF_LISTTEXT);

        if (mmr == MMSYSERR_NOERROR)
        {
            //
            // iterate over all source lines s.t. dwMixerID points to the
            // correct control id on the destination and iMixer is the
            // correct index into the value list
            //
            pvcd[0].amcd_bMixer = pmcd_b;
            for (i = 1; i < cPvcd; i++)
            {
                for (j = 0; j < pvcd->cMixer; j++)
                {
                    if (!lstrcmp(pmcd_lt[j].szName,pvcd[i].szName))
                    {
                        pvcd[i].dwMixerID   = pvcd->dwMixerID;
                        pvcd[i].iMixer      = j;
                        pvcd[i].cMixer      = pvcd->cMixer;
                        pvcd[i].dwSupport   |= VCD_SUPPORTF_MIXER_MIXER;
                        pvcd[i].dwVisible   |= VCD_VISIBLEF_MIXER_MIXER;
                        pvcd[i].dwVisible   &= ~VCD_VISIBLEF_MIXER_MUTE;
                        pvcd[i].amcd_bMixer = pmcd_b;
                    }
                }
            }
        }
        GlobalFreePtr(pmcd_lt);
    }

    if (pvcd->dwSupport & VCD_SUPPORTF_MIXER_MUX)
    {
        pmcd_lt = GlobalAllocPtr(GHND, sizeof(MIXERCONTROLDETAILS_LISTTEXT)
                                 * pvcd->cMux);
        pmcd_b = GlobalAllocPtr(GHND, sizeof(MIXERCONTROLDETAILS_BOOLEAN)
                                * pvcd->cMux);

        if (!pmcd_lt || !pmcd_b)
            return;

        mxd.cbStruct       = sizeof(mxd);
        mxd.dwControlID    = pvcd->dwMuxID;
        mxd.cChannels      = 1;
        mxd.cMultipleItems = pvcd->cMux;
        mxd.cbDetails      = sizeof(MIXERCONTROLDETAILS_LISTTEXT);
        mxd.paDetails      = pmcd_lt;

        mmr = mixerGetControlDetails(hmx
                                     , &mxd
                                     , MIXER_GETCONTROLDETAILSF_LISTTEXT);

        if (mmr == MMSYSERR_NOERROR)
        {
            //
            // iterate over all source lines s.t. dwMuxID points to the
            // correct control id on the destination and iMux is the
            // correct index into the value list
            //
            pvcd[0].amcd_bMux = pmcd_b;
            for (i = 1; i < cPvcd; i++)
            {
                for (j = 0; j < pvcd->cMux; j++)
                {
                    if (!lstrcmp(pmcd_lt[j].szName,pvcd[i].szName))
                    {
                        pvcd[i].dwMuxID     = pvcd->dwMuxID;
                        pvcd[i].iMux        = j;
                        pvcd[i].cMux        = pvcd->cMux;
                        pvcd[i].dwSupport   |= VCD_SUPPORTF_MIXER_MUX;
                        pvcd[i].dwVisible   |= VCD_VISIBLEF_MIXER_MUX;
                        pvcd[i].dwVisible   &= ~VCD_VISIBLEF_MIXER_MUTE;
                        pvcd[i].amcd_bMux   = pmcd_b;
                    }
                }
            }
        }
        GlobalFreePtr(pmcd_lt);
    }
}

/*
 * Mixer_CheckdDriver
 *
 * Consistency check for bad mixer drivers.
 * */
static DWORD Mixer_CheckBadDriver(
    HMIXEROBJ           hmx,
    PMIXERLINECONTROLS  pmxlc,
    PMIXERCONTROL       pmxc,
    DWORD               dwControlID,
    DWORD               dwLineID)
{
    MMRESULT mmr;

    pmxlc->cbStruct     = sizeof(MIXERLINECONTROLS);
    pmxlc->dwControlID  = dwControlID;
    pmxlc->cControls    = 1;
    pmxlc->cbmxctrl     = sizeof(MIXERCONTROL);
    pmxlc->pamxctrl     = pmxc;

    mmr = mixerGetLineControls(hmx
                               , pmxlc
                               , MIXER_GETLINECONTROLSF_ONEBYID);

    if (mmr != MMSYSERR_NOERROR)
        return VCD_SUPPORTF_BADDRIVER;

    if (pmxlc->dwLineID != dwLineID)
        return VCD_SUPPORTF_BADDRIVER;

    return 0L;
}

/*
 * IsDestinationMux
 *
 * Helper function to determine if a source line has a mux on its associated
 * destination line
 *
 * */
BOOL IsDestinationMux(
    HMIXEROBJ           hmx,
    DWORD               dwLineID
)
{
    MIXERLINE           mxl;
    MIXERLINECONTROLS   mxlc;
    MIXERCONTROL        mxc;
    MMRESULT            mmr;

    mxl.cbStruct    = sizeof(mxl);
    mxl.dwLineID    = dwLineID;

    // Get the destination number for this line
    mmr = mixerGetLineInfo(hmx
                           , &mxl
                           , MIXER_GETLINEINFOF_LINEID);
    if (mmr != MMSYSERR_NOERROR)
    {
        return FALSE;
    }

    //
    // Get the LineId for this destination number
    //
    // mxl.dwDestination will been filled in by the last
    // call to mixerGetLineInfo
    //
    mmr = mixerGetLineInfo(hmx
                           , &mxl
                           , MIXER_GETLINEINFOF_DESTINATION);
    if (mmr != MMSYSERR_NOERROR)
    {
        return FALSE;
    }

    mxlc.cbStruct       = sizeof(mxlc);
    mxlc.dwLineID       = mxl.dwLineID; // use the dwLineId obtained from mixerGetLinInfo
    mxlc.dwControlType  = MIXERCONTROL_CONTROLTYPE_MUX;
    mxlc.cControls      = 1;
    mxlc.cbmxctrl       = sizeof(mxc);
    mxlc.pamxctrl       = &mxc;

    mmr = mixerGetLineControls(hmx
                               , &mxlc
                               , MIXER_GETLINECONTROLSF_ONEBYTYPE);
    if (mmr == MMSYSERR_NOERROR)
    {
        return TRUE;
    }

    return FALSE;
}

/*
 * Mixer_InitLineControls
 *
 * Initialize the mixer api specific part of the volume control description
 * mark hidden lines.
 * */
static void Mixer_InitLineControls(
    HMIXEROBJ           hmx,
    PVOLCTRLDESC        pvcd,
    DWORD               dwLineID)
{
    MIXERLINECONTROLS   mxlc;
    MIXERCONTROL        mxc;
    MMRESULT            mmr;
    int                 iType;

    const DWORD dwAdvTypes[] = {
        MIXERCONTROL_CONTROLTYPE_BOOLEAN,
        MIXERCONTROL_CONTROLTYPE_ONOFF,
        MIXERCONTROL_CONTROLTYPE_MONO,
        MIXERCONTROL_CONTROLTYPE_LOUDNESS,
        MIXERCONTROL_CONTROLTYPE_STEREOENH,
        MIXERCONTROL_CONTROLTYPE_BASS,
        MIXERCONTROL_CONTROLTYPE_TREBLE
    };


    pvcd->dwLineID      = dwLineID;
    pvcd->dwMeterID     = 0;
    pvcd->dwVolumeID    = 0;
    pvcd->dwMuteID      = 0;
    pvcd->dwMixerID     = 0;
    pvcd->dwMuxID       = 0;

    //
    // advanced controls
    //
    for (iType = 0;
         iType < SIZEOF(dwAdvTypes);
         iType++)
         {
             mxlc.cbStruct       = sizeof(mxlc);
             mxlc.dwLineID       = dwLineID;
             mxlc.dwControlType  = dwAdvTypes[iType];
             mxlc.cControls      = 1;
             mxlc.cbmxctrl       = sizeof(mxc);
             mxlc.pamxctrl       = &mxc;

             mmr = mixerGetLineControls(hmx
                                        , &mxlc
                                        , MIXER_GETLINECONTROLSF_ONEBYTYPE);
             if (mmr == MMSYSERR_NOERROR)
             {
                 pvcd->dwSupport |= VCD_SUPPORTF_MIXER_ADVANCED;
                 break;
             }
         }

    //
    // stock controls
    //

    //
    // peakmeter
    //
    mxlc.cbStruct       = sizeof(mxlc);
    mxlc.dwLineID       = dwLineID;
    mxlc.dwControlType  = MIXERCONTROL_CONTROLTYPE_PEAKMETER;
    mxlc.cControls      = 1;
    mxlc.cbmxctrl       = sizeof(mxc);
    mxlc.pamxctrl       = &mxc;

    mmr = mixerGetLineControls(hmx
                               , &mxlc
                               , MIXER_GETLINECONTROLSF_ONEBYTYPE);
    if (mmr == MMSYSERR_NOERROR)
    {
        pvcd->dwMeterID  = mxc.dwControlID;
        pvcd->dwSupport |= VCD_SUPPORTF_MIXER_METER;
        pvcd->dwSupport |= Mixer_CheckBadDriver(hmx
                                                , &mxlc
                                                , &mxc
                                                , mxc.dwControlID
                                                , dwLineID);
    }

    //
    // mute
    //
    mxlc.cbStruct       = sizeof(mxlc);
    mxlc.dwLineID       = dwLineID;
    mxlc.dwControlType  = MIXERCONTROL_CONTROLTYPE_MUTE;
    mxlc.cControls      = 1;
    mxlc.cbmxctrl       = sizeof(mxc);
    mxlc.pamxctrl       = &mxc;

    mmr = mixerGetLineControls(hmx
                               , &mxlc
                               , MIXER_GETLINECONTROLSF_ONEBYTYPE);
    if (mmr == MMSYSERR_NOERROR)
    {
        pvcd->fdwMuteControl = mxc.fdwControl;
        pvcd->dwMuteID   = mxc.dwControlID;
        pvcd->dwSupport |= VCD_SUPPORTF_MIXER_MUTE;
        pvcd->dwVisible |= VCD_VISIBLEF_MIXER_MUTE;

        pvcd->dwSupport |= Mixer_CheckBadDriver(hmx
                                                , &mxlc
                                                , &mxc
                                                , mxc.dwControlID
                                                , dwLineID);
    }

    //
    // volume
    //
    mxlc.cbStruct       = sizeof(mxlc);
    mxlc.dwLineID       = dwLineID;
    mxlc.dwControlType  = MIXERCONTROL_CONTROLTYPE_VOLUME;
    mxlc.cControls      = 1;
    mxlc.cbmxctrl       = sizeof(mxc);
    mxlc.pamxctrl       = &mxc;

    mmr = mixerGetLineControls(hmx
                               , &mxlc
                               , MIXER_GETLINECONTROLSF_ONEBYTYPE);
    if (mmr == MMSYSERR_NOERROR)
    {
        pvcd->fdwVolumeControl = mxc.fdwControl;
        pvcd->dwVolumeID = mxc.dwControlID;
        pvcd->dwSupport |= VCD_SUPPORTF_MIXER_VOLUME;
        pvcd->dwSupport |= Mixer_CheckBadDriver(hmx
                                                , &mxlc
                                                , &mxc
                                                , mxc.dwControlID
                                                , dwLineID);
    }

    //
    // mixer
    //
    mxlc.cbStruct       = sizeof(mxlc);
    mxlc.dwLineID       = dwLineID;
    mxlc.dwControlType  = MIXERCONTROL_CONTROLTYPE_MIXER;
    mxlc.cControls      = 1;
    mxlc.cbmxctrl       = sizeof(mxc);
    mxlc.pamxctrl       = &mxc;

    mmr = mixerGetLineControls(hmx
                               , &mxlc
                               , MIXER_GETLINECONTROLSF_ONEBYTYPE);
    if (mmr == MMSYSERR_NOERROR)
    {
        pvcd->dwMixerID  = mxc.dwControlID;
        pvcd->cMixer     = mxc.cMultipleItems;
        pvcd->dwSupport |= VCD_SUPPORTF_MIXER_MIXER;
        pvcd->dwSupport |= Mixer_CheckBadDriver(hmx
                                                , &mxlc
                                                , &mxc
                                                , mxc.dwControlID
                                                , dwLineID);
    }

    //
    // mux
    //
    mxlc.cbStruct       = sizeof(mxlc);
    mxlc.dwLineID       = dwLineID;
    mxlc.dwControlType  = MIXERCONTROL_CONTROLTYPE_MUX;
    mxlc.cControls      = 1;
    mxlc.cbmxctrl       = sizeof(mxc);
    mxlc.pamxctrl       = &mxc;

    mmr = mixerGetLineControls(hmx
                               , &mxlc
                               , MIXER_GETLINECONTROLSF_ONEBYTYPE);
    if (mmr == MMSYSERR_NOERROR)
    {
        pvcd->dwMuxID    = mxc.dwControlID;
        pvcd->cMux       = mxc.cMultipleItems;
        pvcd->dwSupport |= VCD_SUPPORTF_MIXER_MUX;
        pvcd->dwSupport |= Mixer_CheckBadDriver(hmx
                                                , &mxlc
                                                , &mxc
                                                , mxc.dwControlID
                                                , dwLineID);
    }
    if (!(pvcd->dwSupport & ( VCD_SUPPORTF_MIXER_MUTE
                              | VCD_SUPPORTF_MIXER_METER
                              | VCD_SUPPORTF_MIXER_VOLUME)))
    {
        if (IsDestinationMux(hmx, dwLineID) &&
            !(pvcd->dwSupport & VCD_SUPPORTF_MIXER_MUX))
        {
            //
            // Visible, and not hidden
            //
            pvcd->dwSupport |= VCD_SUPPORTF_VISIBLE;
            pvcd->dwSupport &= ~VCD_SUPPORTF_DEFAULT;
        }
        else
        {
            //
            // make it invisible in the UI.
            //
            pvcd->dwSupport |= VCD_SUPPORTF_HIDDEN;
        }
    }
    else
    {
        //
        // Visible, and not hidden
        //
        pvcd->dwSupport |= VCD_SUPPORTF_VISIBLE;
    }


}


/*
 * Mixer_CreateVolumeDescription
 *
 * */
PVOLCTRLDESC Mixer_CreateVolumeDescription(
    HMIXEROBJ           hmx,
    int                 iDest,
    DWORD*              pcvd )
{
    MMRESULT            mmr;
    PVOLCTRLDESC        pvcdPrev = NULL, pvcd = NULL;
    MIXERLINE           mlDst;
    DWORD               cLines = 0;
    DWORD               dwSupport = 0L;
    UINT                iSrc;
    int                 newDest=0;

    ZeroMemory(&mlDst, sizeof(mlDst));

    mlDst.cbStruct      = sizeof(mlDst);
    mlDst.dwDestination = iDest;

    mmr = mixerGetLineInfo(hmx
                           , &mlDst
                           , MIXER_GETLINEINFOF_DESTINATION);

    if(!mlDst.cConnections)
    {
        //No lines to list. Try with a different mixer ID.
        GetDestination(0, &newDest);
        mlDst.dwDestination = newDest;

        mmr = mixerGetLineInfo(hmx
                         , &mlDst
                         , MIXER_GETLINEINFOF_DESTINATION);

        //Even if we do not get any connections here lets continue. Nothing more we can do.
        //This will be taken care of before opening the dialog.
    }

    if (mmr == MMSYSERR_NOERROR)
    {
        if (mlDst.cChannels == 1L)
            dwSupport |= VCD_SUPPORTF_MONO;

        if (mlDst.fdwLine & MIXERLINE_LINEF_DISCONNECTED)
            dwSupport |= VCD_SUPPORTF_DISABLED;

        //
        // a default type
        //
        dwSupport |= VCD_SUPPORTF_DEFAULT;
    }
    else
    {
        //
        // we need to add it anyway s.t. a UI comes up
        //
        dwSupport = VCD_SUPPORTF_DISABLED;
    }

    pvcd = PVCD_AddLine(NULL
                       , iDest
                       , VCD_TYPE_MIXER
                       , mlDst.szShortName
                       , mlDst.szName
                       , dwSupport
                       , &cLines );

    if (!pvcd)
        return NULL;

    Mixer_InitLineControls( hmx, pvcd, mlDst.dwLineID );

    pvcdPrev = pvcd;

    for (iSrc = 0; iSrc < mlDst.cConnections; iSrc++)
    {
        MIXERLINE    mlSrc;

        mlSrc.cbStruct          = sizeof(mlSrc);
        mlSrc.dwDestination     = iDest;
        mlSrc.dwSource          = iSrc;

        mmr = mixerGetLineInfo(hmx
                               , &mlSrc
                               , MIXER_GETLINEINFOF_SOURCE);
        dwSupport = 0L;

        if (mmr == MMSYSERR_NOERROR)
        {
            if (mlSrc.cChannels == 1L)
            {
                dwSupport |= VCD_SUPPORTF_MONO;
            }

            if (mlSrc.fdwLine & MIXERLINE_LINEF_DISCONNECTED)
                dwSupport |= VCD_SUPPORTF_DISABLED;

            //
            // Mark these types as "default" just to lessen the shock on
            // some advanced sound cards.
            //
            if (mlDst.dwComponentType == MIXERLINE_COMPONENTTYPE_DST_SPEAKERS
                || mlDst.dwComponentType == MIXERLINE_COMPONENTTYPE_DST_HEADPHONES)
            {
                switch (mlSrc.dwComponentType)
                {
                    case MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT:
                    case MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC:
                    case MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER:
                    case MIXERLINE_COMPONENTTYPE_SRC_LINE:
                        dwSupport |= VCD_SUPPORTF_DEFAULT;
                        break;
                }
            }
            else if (mlDst.dwComponentType == MIXERLINE_COMPONENTTYPE_DST_WAVEIN
                     || mlDst.dwComponentType == MIXERLINE_COMPONENTTYPE_DST_VOICEIN)
            {
                switch (mlSrc.dwComponentType)
                {
                    case MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE:
                    case MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC:
                    case MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER:
                    case MIXERLINE_COMPONENTTYPE_SRC_LINE:
                    case MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED:
                        dwSupport |= VCD_SUPPORTF_DEFAULT;
                        break;
                }
            }
        }
        else
        {
            //
            // we need to add it anyway s.t. lookups aren't under counted
            //
            dwSupport = VCD_SUPPORTF_DISABLED;
        }
        pvcd = PVCD_AddLine(pvcdPrev
                            , iDest
                            , VCD_TYPE_MIXER
                            , mlSrc.szShortName
                            , mlSrc.szName
                            , dwSupport
                            , &cLines );
        if (pvcd)
        {
            Mixer_InitLineControls( hmx, &pvcd[cLines-1], mlSrc.dwLineID );
            pvcdPrev = pvcd;
        }
    }


    //
    // Fixup dependencies
    //
    Mixer_SetLines(hmx, pvcdPrev, cLines);

    *pcvd = cLines;
    return pvcdPrev;
}


/*
 * Mixer_IsValidRecordingDestination
 *
 * */
BOOL Mixer_IsValidRecordingDestination (HMIXEROBJ hmx, MIXERLINE* pmlDst)
{

    BOOL fReturn = FALSE;

    if (pmlDst && MIXERLINE_COMPONENTTYPE_DST_WAVEIN == pmlDst -> dwComponentType)
    {

        UINT uiSrc;
        MIXERLINE mlSrc;

        for (uiSrc = 0; uiSrc < pmlDst -> cConnections; uiSrc++)
        {

            mlSrc.cbStruct      = sizeof (mlSrc);
            mlSrc.dwDestination = pmlDst -> dwDestination;
            mlSrc.dwSource      = uiSrc;

            if (SUCCEEDED (mixerGetLineInfo (hmx, &mlSrc, MIXER_GETLINEINFOF_SOURCE)))
            {
                switch (mlSrc.dwComponentType)
                {
                    case MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE:
                    case MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC:
                    case MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER:
                    case MIXERLINE_COMPONENTTYPE_SRC_LINE:
                    case MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED:
                        fReturn = TRUE;
                        break;
                }
            }
        }
    }

    return fReturn;

}


/*
 * Mixer_CleanupVolumeDescription
 *
 * */
void Mixer_CleanupVolumeDescription(
    PVOLCTRLDESC    avcd,
    DWORD           cvcd)
{
    if (cvcd == 0)
        return;

    if (avcd[0].pdblCacheMix)
    {
        GlobalFreePtr(avcd[0].pdblCacheMix);
    }

    if (avcd[0].dwSupport & VCD_SUPPORTF_MIXER_MIXER)
    {
        if (avcd[0].amcd_bMixer)
            GlobalFreePtr(avcd[0].amcd_bMixer);
    }

    if (avcd[0].dwSupport & VCD_SUPPORTF_MIXER_MUX)
    {
        if (avcd[0].amcd_bMux)
            GlobalFreePtr(avcd[0].amcd_bMux);
    }

}
/*****************************************************************************
 *
 *  ACTIVE GET/SET CODE
 *
 *****************************************************************************/

static
MMRESULT
Mixer_GetMixerLineInfo(
    HMIXEROBJ hmx,      // handle to mixer
    LPMIXERLINE pml,    // Returns destination info
    DWORD dwLineID      //
    )
{
    if (!pml || !hmx)
        return MMSYSERR_INVALPARAM;

    // Get mixerline info
    ZeroMemory( pml, sizeof(*pml) );
    pml->cbStruct = sizeof(*pml);
    pml->dwLineID = dwLineID;

    return (mixerGetLineInfo (hmx, pml, MIXER_GETLINEINFOF_LINEID));
}

/*
 * Mixer_GetMixerVolume
 *
 * */
static MMRESULT Mixer_GetMixerVolume(
    PMIXUIDIALOG pmxud,                          // app instance
    PVOLCTRLDESC pvcd,                           // volume to change
    MIXERCONTROLDETAILS_UNSIGNED* pmcdVolume,    // array for volume levels
    LPDWORD lpSize                               // size of array (or return size needed)
    )
{

    MMRESULT mmr;
    MIXERLINE ml;
    MIXERCONTROLDETAILS mxcd;
    DWORD cChannels;

    if (!lpSize || !pmxud)
        return MMSYSERR_INVALPARAM;

    // Get mixerline info
    if (pvcd->fdwVolumeControl & MIXERCONTROL_CONTROLF_UNIFORM)
    {
        cChannels = 1;
    }
    else
    {
        mmr = Mixer_GetMixerLineInfo ((HMIXEROBJ)(pmxud->hmx), &ml, pvcd->dwLineID);
        if (MMSYSERR_NOERROR != mmr)
        {
            return mmr;
        }
        cChannels = ml.cChannels;
    }

    if (!pmcdVolume)
    {
        // Just return size needed
        *lpSize = cChannels * sizeof (MIXERCONTROLDETAILS_UNSIGNED);
        return MMSYSERR_NOERROR;
    }
    else
    {
        // Verify passed array size
        if (*lpSize < cChannels * sizeof (MIXERCONTROLDETAILS_UNSIGNED))
            return MMSYSERR_INVALPARAM;
    }

    // Get volume levels
    ZeroMemory (&mxcd, sizeof (mxcd));
    mxcd.cbStruct       = sizeof(mxcd);
    mxcd.dwControlID    = pvcd->dwVolumeID;
    mxcd.cChannels      = cChannels;
    mxcd.cbDetails      = sizeof (MIXERCONTROLDETAILS_UNSIGNED);
    mxcd.paDetails      = (LPVOID) pmcdVolume;

    mmr = mixerGetControlDetails((HMIXEROBJ)(pmxud->hmx),
                                 &mxcd,
                                 MIXER_OBJECTF_HANDLE | MIXER_GETCONTROLDETAILSF_VALUE);
    return mmr;

}

static MMRESULT Mixer_Mute(
    HMIXEROBJ               hmx,
    PVOLCTRLDESC            pvcd,
    PMIXERCONTROLDETAILS    pmxcd,
    DWORD                   fMute)
{
    MIXERLINE ml;
    DWORD cChannels;
    DWORD dwSize;
    LPDWORD lpdwCurrent;
    UINT uiIndx;
    MMRESULT mmr;

    // Check the parameters
    if (!hmx || !pvcd || !pmxcd)
        return MMSYSERR_INVALPARAM;

    // Get mixerline info
    if (pvcd->fdwMuteControl & MIXERCONTROL_CONTROLF_UNIFORM)
    {
        cChannels = 1;
    }
    else
    {
        mmr = Mixer_GetMixerLineInfo(hmx, &ml, pvcd->dwLineID);
        if (MMSYSERR_NOERROR != mmr)
        {
            return mmr;
        }
        cChannels = ml.cChannels;
    }

    dwSize = (DWORD)(cChannels * sizeof(DWORD));

    pmxcd->paDetails = LocalAlloc (LPTR, dwSize);
    if (!pmxcd->paDetails)
        return MMSYSERR_NOMEM;

    for (uiIndx = 0; uiIndx < cChannels; uiIndx++)
    {
        lpdwCurrent = ((LPDWORD)pmxcd->paDetails + uiIndx);
        *lpdwCurrent = fMute;
    }

    pmxcd->cbStruct         = sizeof(*pmxcd);
    pmxcd->dwControlID      = pvcd->dwMuteID ;
    pmxcd->cChannels        = cChannels;
    pmxcd->cMultipleItems   = 0;
    pmxcd->cbDetails        = sizeof(DWORD);

    mmr = mixerSetControlDetails(hmx
                               , pmxcd
                               , MIXER_SETCONTROLDETAILSF_VALUE);

    LocalFree (pmxcd->paDetails);
    return mmr;
}


/*
 * Mixer_GetControl
 *
 * Change a UI control in response to a device or initialization event
 *
 * */

void Mixer_GetControl(
    PMIXUIDIALOG        pmxud,
    HWND                hctl,
    int                 imxul,
    int                 itype)
{
    PMIXUILINE      pmxul = &pmxud->amxul[imxul];
    PVOLCTRLDESC    pvcd = pmxul->pvcd;
    DWORD           dwID = 0L;
    BOOL            fSet = FALSE;

    switch (itype)
    {
        case MIXUI_VUMETER:
            fSet = (pmxul->pvcd->dwSupport & VCD_SUPPORTF_MIXER_METER);
            if (fSet)
                dwID = pmxul->pvcd->dwMeterID;
            break;

        case MIXUI_SWITCH:
            fSet = (pmxul->pvcd->dwSupport & VCD_SUPPORTF_MIXER_MUTE)
                   && (pmxul->pvcd->dwVisible & VCD_VISIBLEF_MIXER_MUTE);
            if (fSet)
            {
                dwID = pmxul->pvcd->dwMuteID;
                break;
            }

            fSet = (pmxul->pvcd->dwSupport & VCD_SUPPORTF_MIXER_MUX)
                   && (pmxul->pvcd->dwVisible & VCD_VISIBLEF_MIXER_MUX);
            if (fSet)
            {
                dwID = pmxul->pvcd->dwMuxID;
                break;
            }

            fSet = (pmxul->pvcd->dwSupport & VCD_SUPPORTF_MIXER_MIXER)
                   && (pmxul->pvcd->dwVisible & VCD_VISIBLEF_MIXER_MIXER);
            if (fSet)
            {
                dwID = pmxul->pvcd->dwMixerID;
                break;
            }
            break;

        case MIXUI_VOLUME:
        case MIXUI_BALANCE:
            fSet = (pmxul->pvcd->dwSupport & VCD_SUPPORTF_MIXER_VOLUME);
            if (fSet)
                dwID = pmxul->pvcd->dwVolumeID;
            break;

        default:
            return;
    }
    if (fSet)
        Mixer_GetControlFromID(pmxud, dwID);

}


/*
 * Mixer_SetVolume
 *
 * - Change a mixerControl in response to a user event
 * */
MMRESULT Mixer_SetVolume (
    PMIXUIDIALOG pmxud,         // app instance
    PVOLCTRLDESC pvcd,          // volume to change
    DWORD        dwVolume,      // volume value                         VOLUME_MAX to VOLUME_MIN
    LPDWORD      lpdwBalance    // Balance desired (NULL == No Balance) 0 to 64
    )
{

    MIXERLINE ml;
    DWORD cChannels;
    DWORD dwSize;
    MIXERCONTROLDETAILS_UNSIGNED* pmcdVolume;
    MMRESULT mmr;

    // Check the parameters
    if ( !pvcd || !pmxud || (dwVolume > VOLUME_MAX) )
        return MMSYSERR_INVALPARAM;

    // Find needed buffer size for volumes
    if (pvcd->fdwVolumeControl & MIXERCONTROL_CONTROLF_UNIFORM)
    {
        cChannels = 1;
    }
    else
    {
        mmr = Mixer_GetMixerLineInfo ((HMIXEROBJ)(pmxud->hmx), &ml, pvcd->dwLineID);
        if (MMSYSERR_NOERROR != mmr)
        {
            return mmr;
        }

        cChannels = ml.cChannels;
    }

    dwSize = (DWORD)(cChannels * sizeof (MIXERCONTROLDETAILS_UNSIGNED));

    // Create volume buffer
    pmcdVolume = LocalAlloc (LPTR, dwSize);
    if (!pmcdVolume)
        return MMSYSERR_NOMEM;

    // Note: From here on, do not return without releasing 'pmcdVolume'.

    mmr = Mixer_GetMixerVolume (pmxud, pvcd, pmcdVolume, &dwSize);
    if (MMSYSERR_NOERROR == mmr)
    {

        MIXERCONTROLDETAILS mcd;
        ZeroMemory (&mcd, sizeof (mcd));

        // Create volume mix cache if necessary
        // if we have no cache we make one of course
        // other wise we first check that not all the volumes of the channels are equal to zero
       if (!pvcd->pdblCacheMix || !Mixer_AreChannelsAtMinimum(pmcdVolume,cChannels))
       {
            Mixer_RefreshMixCache (pvcd, pmcdVolume, cChannels);
       }

        // Create volume buffer for new values
        mcd.paDetails = LocalAlloc (LPTR, dwSize);
        if (!mcd.paDetails || !pvcd->pdblCacheMix)
            mmr = MMSYSERR_NOMEM;

        // Caculate the new volume & balance
        if (MMSYSERR_NOERROR == mmr)
        {

            UINT uiIndx;
            MIXERCONTROLDETAILS_UNSIGNED* pmcdCurrent;

            // Account for Balance (only for Stereo)
            if ( lpdwBalance && (cChannels == 2) && (*lpdwBalance <= 64) )
            {
                MIXERCONTROLDETAILS_UNSIGNED* pmcdLeft = ((MIXERCONTROLDETAILS_UNSIGNED*)mcd.paDetails);
                MIXERCONTROLDETAILS_UNSIGNED* pmcdRight = ((MIXERCONTROLDETAILS_UNSIGNED*)mcd.paDetails + 1);
                long lBalance = *lpdwBalance;

                lBalance -= 32; // -32 to 32 range

                // Caculate volume based on balance and refresh mix cache
                if (lBalance > 0) // Balance Right
                {
                    // Left
                    if (lBalance == 32) // Pegged Right
                        pmcdLeft -> dwValue = 0;
                    else
                        pmcdLeft -> dwValue = dwVolume - (lBalance * (dwVolume - VOLUME_MIN))/32;

                    // Right
                    pmcdRight -> dwValue = dwVolume;
                }
                if (lBalance < 0) // Balance Left
                {
                    // Left
                    pmcdLeft -> dwValue = dwVolume;
                    // Right
                    if (lBalance == -32) // Pegged Left
                        pmcdRight -> dwValue = 0;
                    else
                        pmcdRight -> dwValue = dwVolume - (-lBalance * (dwVolume - VOLUME_MIN))/32;
                }
                if (lBalance == 0) // Balance Centered
                {
                    // Left
                    pmcdLeft -> dwValue = dwVolume;
                    // Right
                    pmcdRight -> dwValue = dwVolume;
                }
                Mixer_RefreshMixCache (pvcd, mcd.paDetails, cChannels);
            }
            else
            {
                // Caculate the new volume level for each of the channels. For volume levels
                // at the current max, we simply set the newly requested level (in this case
                // the cache value is 1.0). For those less than the max, we set a value that
                // is a percentage of the max. This maintains the relative distance of the
                // channel levels from each other.
                for (uiIndx = 0; uiIndx < cChannels; uiIndx++)
                {
                    pmcdCurrent = ((MIXERCONTROLDETAILS_UNSIGNED*)mcd.paDetails + uiIndx);
                    // The 0.5f forces rounding (instead of truncation)
                    pmcdCurrent -> dwValue = (DWORD)(*(pvcd->pdblCacheMix + uiIndx) * (double) dwVolume + 0.5f);
                }
            }

            mcd.cbStruct    = sizeof (mcd);
            mcd.dwControlID = pvcd -> dwVolumeID;
            mcd.cChannels   = cChannels;
            mcd.cbDetails   = sizeof (MIXERCONTROLDETAILS_UNSIGNED);
                            // seems like it would be sizeof(mcd.paDetails),
                            // but actually, it is the size of a single value
                            // and is multiplied by channel in the driver.

            // Apply new value only if it is different. This prevents unessary calls to
            // mixerSetControlDetails() when we are pegged.
            if (memcmp (pmcdVolume, mcd.paDetails, dwSize))
            {
                mixerSetControlDetails ((HMIXEROBJ)(pmxud->hmx), &mcd, MIXER_SETCONTROLDETAILSF_VALUE);
            }

        }
        // Free new volume array
        if (mcd.paDetails)
            LocalFree (mcd.paDetails);
    }

    // Free volume array
    LocalFree (pmcdVolume);

    return mmr;

}


/*
 * Mixer_GetControlFromID
 *
 * */
void Mixer_GetControlFromID(
    PMIXUIDIALOG        pmxud,
    DWORD               dwControlID)
{
    MIXERLINE           mxl;
    MIXERLINECONTROLS   mxlc;
    MIXERCONTROL        mxc;
    MIXERCONTROLDETAILS mxcd;
    PMIXUILINE          pmxul;
    PMIXUICTRL          pmxuc;
    PVOLCTRLDESC        pvcd;
    DWORD               ivcd;
    BOOL                fBarf = FALSE;
    MMRESULT            mmr;

    //
    // Retrieve the control information
    //
    mxlc.cbStruct       = sizeof(mxlc);
    mxlc.dwControlID    = dwControlID;
    mxlc.cControls      = 1;
    mxlc.cbmxctrl       = sizeof(mxc);
    mxlc.pamxctrl       = &mxc;

    mmr = mixerGetLineControls((HMIXEROBJ)(pmxud->hmx)
                               , &mxlc
                               , MIXER_GETLINECONTROLSF_ONEBYID);
    if (mmr != MMSYSERR_NOERROR)
        return;

    if (!(pmxud->dwFlags & MXUD_FLAGSF_BADDRIVER))
    {
        //
        // The *correct* code for this lookup using the mixer API.
        //
        // Is this our current destination line?
        //
        mxl.cbStruct    = sizeof(mxl);
        mxl.dwLineID    = mxlc.dwLineID;

        mmr = mixerGetLineInfo((HMIXEROBJ)(pmxud->hmx)
                               , &mxl
                               , MIXER_GETLINEINFOF_LINEID);
        if (mmr != MMSYSERR_NOERROR)
            return;

        if (mxl.dwDestination != pmxud->iDest)
            return;

        //
        // Is this a source line or a destination line?
        //

        ivcd    = (mxl.fdwLine & MIXERLINE_LINEF_SOURCE)? 1 + mxl.dwSource : 0;
        pvcd    = &pmxud->avcd[ivcd];

        //
        // a bad driver was detected!
        //
        if (pvcd->dwLineID != mxlc.dwLineID)
        {
            pmxud->dwFlags |= MXUD_FLAGSF_BADDRIVER;
        }
    }
    if (pmxud->dwFlags & MXUD_FLAGSF_BADDRIVER)
    {
        PVOLCTRLDESC        pvcdTmp;
        //
        // take evasive action if this was a bad driver by doing a brute force
        // search.
        //

        pvcd = NULL;
        for (ivcd = 0; ivcd < pmxud->cvcd; ivcd ++)
        {
            pvcdTmp = &pmxud->avcd[ivcd];
            if ( ( (pvcdTmp->dwSupport & VCD_SUPPORTF_MIXER_VOLUME)
                   && pvcdTmp->dwVolumeID == dwControlID )
                 || ( (pvcdTmp->dwSupport & VCD_SUPPORTF_MIXER_MUTE)
                      && pvcdTmp->dwMuteID == dwControlID )
                 || ( (pvcdTmp->dwSupport & VCD_SUPPORTF_MIXER_MIXER)
                      && pvcdTmp->dwMixerID == dwControlID )
                 || ( (pvcdTmp->dwSupport & VCD_SUPPORTF_MIXER_MUX)
                      && pvcdTmp->dwMuxID == dwControlID )
                 || ( (pvcdTmp->dwSupport & VCD_SUPPORTF_MIXER_METER)
                      && pvcdTmp->dwMeterID == dwControlID ) )
            {
                pvcd = pvcdTmp;
                break;
            }
        }
        if (pvcd == NULL)
            return;
    }

    pmxul   = pvcd->pmxul;

    //
    // Go through our visible lines to determine if this control affects
    // any visible control and change them.
    //
    switch (mxc.dwControlType)
    {
        case MIXERCONTROL_CONTROLTYPE_VOLUME:
        {
            MIXERCONTROLDETAILS_UNSIGNED* pmcdVolume;
            DWORD cChannels;
            DWORD dwSize;
            MIXERLINE ml;

            //
            // A nonvisible line should be shunned
            //
            if (pmxul == NULL)
                return;

            // Find needed buffer size for volumes
            if (pvcd->fdwVolumeControl & MIXERCONTROL_CONTROLF_UNIFORM)
            {
                cChannels = 1;
            }
            else
            {
                mmr = Mixer_GetMixerLineInfo ((HMIXEROBJ)(pmxud->hmx), &ml, pvcd->dwLineID);
                if (MMSYSERR_NOERROR != mmr)
                {
                    return;
                }
                cChannels = ml.cChannels;
            }

            dwSize = (DWORD)(cChannels * sizeof (MIXERCONTROLDETAILS_UNSIGNED));
            // Create volume buffer
            pmcdVolume = LocalAlloc (LPTR, dwSize);
            if (!pmcdVolume)
                return;

            // Note : Do not return without releasing 'pmcdVolume'.

            if (Mixer_GetMixerVolume (pmxud, pvcd, pmcdVolume, &dwSize)
                == MMSYSERR_NOERROR)
            {
                UINT  uindx;
                DWORD dwVolume;
                DWORD dwMax = 0;

                // Set Volume slider
                for (uindx = 0; uindx < cChannels; uindx++)
                    dwMax = max (dwMax, (pmcdVolume + uindx) -> dwValue);
                dwVolume = VOLUME_TO_SLIDER(dwMax);
                dwVolume = VOLUME_TICS - dwVolume;

                pmxuc = &pmxul->acr[MIXUI_VOLUME];
                if (pmxuc->state)
                {
                    SendMessage(pmxuc->hwnd, TBM_SETPOS, TRUE, dwVolume);
                }

                // Set Balance Slider
                pmxuc = &pmxul->acr[MIXUI_BALANCE];
                if (dwVolume < VOLUME_TICS && pmxuc->state && 2 >= cChannels)
                {
                    long lBalance;
                    double dblBalance;

                    if (1 >= cChannels)
                        lBalance = 0;
                    else
                    {
                        // Stereo
                        dblBalance = (double)(32 * (long)(pmcdVolume -> dwValue - (pmcdVolume + 1) -> dwValue))
                                   / (double)(dwMax - VOLUME_MIN);
                        lBalance = (long)((32.0F - dblBalance) + 0.5F); // 0.5 forces rounding
                    }

                    SendMessage(pmxuc->hwnd, TBM_SETPOS, TRUE, lBalance);
                }
            }

            LocalFree (pmcdVolume);

            break;
        }

        case MIXERCONTROL_CONTROLTYPE_MIXER:
        {
            DWORD   i;

            mxcd.cbStruct       = sizeof(mxcd);
            mxcd.dwControlID    = pvcd->dwMixerID ;
            mxcd.cChannels      = 1;
            mxcd.cMultipleItems = pvcd->cMixer;
            mxcd.cbDetails      = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
            mxcd.paDetails      = (LPVOID)pvcd->amcd_bMixer;

            mmr = mixerGetControlDetails((HMIXEROBJ)(pmxud->hmx)
                                         , &mxcd
                                         , MIXER_GETCONTROLDETAILSF_VALUE);

            if (mmr == MMSYSERR_NOERROR)
            {
                for (i = 0; i < pmxud->cvcd; i++)
                {
                    pvcd = &pmxud->avcd[i];
                    if ( (pvcd->dwSupport & VCD_SUPPORTF_MIXER_MIXER)
                         && (pvcd->dwVisible & VCD_VISIBLEF_MIXER_MIXER)
                         && pvcd->pmxul)
                    {
                        pmxuc = &pvcd->pmxul->acr[MIXUI_SWITCH];
                        if (pmxuc->state == MIXUI_CONTROL_INITIALIZED)
                        {
                            SendMessage(pmxuc->hwnd
                                        , BM_SETCHECK
                                        , pvcd->amcd_bMixer[pvcd->iMixer].fValue, 0);
                        }
                    }
                }
            }
            break;
        }

        case MIXERCONTROL_CONTROLTYPE_MUX:
        {
            DWORD   i;

            mxcd.cbStruct       = sizeof(mxcd);
            mxcd.dwControlID    = pvcd->dwMuxID ;
            mxcd.cChannels      = 1;
            mxcd.cMultipleItems = pvcd->cMux;
            mxcd.cbDetails      = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
            mxcd.paDetails      = (LPVOID)pvcd->amcd_bMux;

            mmr = mixerGetControlDetails((HMIXEROBJ)(pmxud->hmx)
                                         , &mxcd
                                         , MIXER_GETCONTROLDETAILSF_VALUE);

            if (mmr == MMSYSERR_NOERROR)
            {
                for (i = 0; i < pmxud->cvcd; i++)
                {
                    pvcd = &pmxud->avcd[i];
                    if ( (pvcd->dwSupport & VCD_SUPPORTF_MIXER_MUX)
                         && (pvcd->dwVisible & VCD_VISIBLEF_MIXER_MUX)
                         && pvcd->pmxul)
                    {
                        pmxuc = &pvcd->pmxul->acr[MIXUI_SWITCH];
                        if (pmxuc->state == MIXUI_CONTROL_INITIALIZED)
                            SendMessage(pmxuc->hwnd
                                        , BM_SETCHECK
                                        , pvcd->amcd_bMux[pvcd->iMux].fValue, 0);
                    }
                }
            }
            break;
        }

        case MIXERCONTROL_CONTROLTYPE_MUTE:
        {
            DWORD fChecked;

            //
            // A nonvisible line should be shunned
            //
            if (pmxul == NULL)
                return;

            if (! (pvcd->dwSupport & VCD_SUPPORTF_MIXER_MUTE
                   && pvcd->dwVisible & VCD_VISIBLEF_MIXER_MUTE))
                return;

            pmxuc = &pmxul->acr[MIXUI_SWITCH];
            if (pmxuc->state != MIXUI_CONTROL_INITIALIZED)
                break;

            mxcd.cbStruct       = sizeof(mxcd);
            mxcd.dwControlID    = pvcd->dwMuteID;
            mxcd.cChannels      = 1;
            mxcd.cMultipleItems = 0;
            mxcd.cbDetails      = sizeof(DWORD);
            mxcd.paDetails      = (LPVOID)&fChecked;

            mmr = mixerGetControlDetails((HMIXEROBJ)(pmxud->hmx)
                                         , &mxcd
                                         , MIXER_GETCONTROLDETAILSF_VALUE);

            if (mmr != MMSYSERR_NOERROR)
                break;

            SendMessage(pmxuc->hwnd, BM_SETCHECK, fChecked, 0);
            break;
        }

        case MIXERCONTROL_CONTROLTYPE_PEAKMETER:
        {
            LONG            lVol;
            DWORD           dwVol;

            //
            // A nonvisible line should be shunned
            //
            if (pmxul == NULL)
                return;

            pmxuc = &pmxul->acr[MIXUI_VUMETER];
            if (pmxuc->state != MIXUI_CONTROL_INITIALIZED)
                break;

            mxcd.cbStruct       = sizeof(mxcd);
            mxcd.dwControlID    = pvcd->dwMeterID;
            mxcd.cChannels      = 1;
            mxcd.cMultipleItems = 0;
            mxcd.cbDetails      = sizeof(DWORD);
            mxcd.paDetails      = (LPVOID)&lVol;

            mmr = mixerGetControlDetails((HMIXEROBJ)(pmxud->hmx)
                                         , &mxcd
                                         , MIXER_GETCONTROLDETAILSF_VALUE);

            if (mmr != MMSYSERR_NOERROR)
                break;

            dwVol = (DWORD)abs(lVol);
            dwVol = (VOLUME_TICS * dwVol) / 32768;

            SendMessage(pmxuc->hwnd, VU_SETPOS, 0, dwVol);
            break;
        }

        default:
            return;
    }
}


/*
 * Mixer_SetControl
 *
 * - Change a mixerControl in response to a user event
 * */
void Mixer_SetControl(
    PMIXUIDIALOG pmxud,         // app instance
    HWND         hctl,          // hwnd of control that changed
    int          iLine,         // visible line index of control that changed
    int          iCtl)          // control id%line of control that changed
{
    MMRESULT            mmr;
    MIXERCONTROLDETAILS mxcd;
    PMIXUILINE          pmxul;
    PMIXUICTRL          pmxuc;
    PVOLCTRLDESC        pvcd = NULL;

    if ((DWORD)iLine >= pmxud->cmxul)
        return;

    pmxul = &pmxud->amxul[iLine];
    pvcd = pmxul->pvcd;

    if (iCtl <= MIXUI_LAST)
    {
        pmxuc = &pmxul->acr[iCtl];
    }

    switch (iCtl)
    {
        case MIXUI_ADVANCED:
            Mixer_Advanced(pmxud, pvcd->dwLineID, pvcd->szName);
            break;

        case MIXUI_MULTICHANNEL:
            // Note: This will always be true:
            // (MXUL_STYLEF_DESTINATION & pmxul->dwStyle)
            Mixer_Multichannel(pmxud, pvcd->dwVolumeID);
            break;

        case MIXUI_VOLUME:
        case MIXUI_BALANCE:
        {
            // Make sure we have a volume slider
            if ( pmxul->acr[MIXUI_VOLUME].state != MIXUI_CONTROL_UNINITIALIZED)
            {
                DWORD   dwVolume;
                DWORD   dwBalance;
                LPDWORD lpdwBalance = NULL;

                dwVolume = (DWORD)SendMessage( pmxul->acr[MIXUI_VOLUME].hwnd
                                        , TBM_GETPOS
                                        , 0
                                        , 0 );

                dwVolume = VOLUME_TICS - dwVolume;
                dwVolume = SLIDER_TO_VOLUME(dwVolume);

                // See if we have a balance slider as well
                if ( pmxul->acr[MIXUI_BALANCE].state != MIXUI_CONTROL_UNINITIALIZED)
                {
                    dwBalance = (DWORD)SendMessage(pmxul->acr[MIXUI_BALANCE].hwnd
                                           , TBM_GETPOS
                                           , 0
                                           , 0);
                    lpdwBalance = &dwBalance;

                }
                Mixer_SetVolume (pmxud, pvcd, dwVolume, lpdwBalance);
            }

            break;
        }

        case MIXUI_SWITCH:
        {
            LONG fChecked;

            if (pmxuc->state != MIXUI_CONTROL_INITIALIZED)
                break;

            fChecked = (LONG)SendMessage(pmxuc->hwnd, BM_GETCHECK, 0, 0);

            //
            // it's unlikely that there is a mixer and a mux and a mute
            // representing the same line. It's most important that when a line
            // is selected that the user gets a response.  If there is a mute
            // but no mux, then mute and mixer should be OFF and ON
            // respectively and vice versa.  If there is a mux and a mute the
            // same is true.
            // If there is a mux and a mixer... then the mux select should
            // correspond.
            //

            if ( pvcd->dwSupport & VCD_SUPPORTF_MIXER_MUTE
                 && pvcd->dwVisible & VCD_VISIBLEF_MIXER_MUTE )
            {
                mmr = Mixer_Mute((HMIXEROBJ)(pmxud->hmx),
                                 pvcd, &mxcd, fChecked);
            }

            if (pvcd->dwSupport & VCD_SUPPORTF_MIXER_MIXER
                && pvcd->dwVisible & VCD_VISIBLEF_MIXER_MIXER )
            {
                //
                // get all other mixer settings, make sure this one is checked
                //
                mxcd.cbStruct       = sizeof(mxcd);
                mxcd.dwControlID    = pvcd->dwMixerID ;
                mxcd.cChannels      = 1;
                mxcd.cMultipleItems = pvcd->cMixer;
                mxcd.cbDetails      = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
                mxcd.paDetails      = (LPVOID)pvcd->amcd_bMixer;

                mmr = mixerGetControlDetails((HMIXEROBJ)(pmxud->hmx)
                                             , &mxcd
                                             , MIXER_GETCONTROLDETAILSF_VALUE);

                if (mmr == MMSYSERR_NOERROR)
                {
                    pvcd->amcd_bMixer[pvcd->iMixer].fValue = fChecked;
                    mmr = mixerSetControlDetails((HMIXEROBJ)(pmxud->hmx)
                                                 , &mxcd
                                                 , MIXER_SETCONTROLDETAILSF_VALUE);
                }

                if (fChecked && pvcd->dwSupport & VCD_SUPPORTF_MIXER_MUTE)
                {
                    mmr = Mixer_Mute((HMIXEROBJ)(pmxud->hmx), pvcd, &mxcd, FALSE);
                }
            }

            if (pvcd->dwSupport & VCD_SUPPORTF_MIXER_MUX
                && pvcd->dwVisible & VCD_VISIBLEF_MIXER_MUX )
            {
                DWORD i;
                //
                // get all other mux settings, make sure this one is checked
                // or unchecked and all others are not.
                //

                for (i = 0; i < pvcd->cMux; i++)
                    pvcd->amcd_bMux[i].fValue = FALSE;

                pvcd->amcd_bMux[pvcd->iMux].fValue = TRUE;

                mxcd.cbStruct       = sizeof(mxcd);
                mxcd.dwControlID    = pvcd->dwMuxID ;
                mxcd.cChannels      = 1;
                mxcd.cMultipleItems = pvcd->cMux;
                mxcd.cbDetails      = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
                mxcd.paDetails      = (LPVOID)pvcd->amcd_bMux;

                mmr = mixerSetControlDetails((HMIXEROBJ)(pmxud->hmx)
                                             , &mxcd
                                             , MIXER_SETCONTROLDETAILSF_VALUE);

                if (fChecked && pvcd->dwSupport & VCD_SUPPORTF_MIXER_MUTE)
                {
                    mmr = Mixer_Mute((HMIXEROBJ)(pmxud->hmx), pvcd, &mxcd, FALSE);
                }
            }

            break;
        }
        default:
            break;
    }
}



/*
 * Mixer_PollingUpdate
 *
 * Controls that need to be updated by a timer.
 *
 * */
void Mixer_PollingUpdate(
    PMIXUIDIALOG pmxud)
{
    DWORD       i;
    MMRESULT    mmr;
    MIXERLINE   mxl;
    //
    // For all visible mixer lines, locate the control id's that need to be
    // updated.
    //
    for (i = 0; i < pmxud->cmxul; i++)
    {
        PMIXUICTRL      pmxuc = &pmxud->amxul[i].acr[MIXUI_VUMETER];
        PVOLCTRLDESC    pvcd = pmxud->amxul[i].pvcd;

        if (pmxuc->state == MIXUI_CONTROL_UNINITIALIZED)
            continue;

        if (!(pvcd->dwSupport & VCD_SUPPORTF_MIXER_METER))
            continue;

        //
        // Is the line active?
        //
        mxl.cbStruct = sizeof(MIXERLINE);
        mxl.dwLineID = pvcd->dwLineID;

        mmr = mixerGetLineInfo((HMIXEROBJ)(pmxud->hmx)
                               , &mxl
                               , MIXER_GETLINEINFOF_LINEID);
        //
        // Force non active or invalid lines to 0
        //
        if (mmr != MMSYSERR_NOERROR || !(mxl.fdwLine & MIXERLINE_LINEF_ACTIVE))
        {
            SendMessage(pmxuc->hwnd, VU_SETPOS, 0, 0L);
            continue;
        }

        //
        // Force a visible update
        //
        Mixer_GetControlFromID(pmxud, pvcd->dwMeterID);
    }
}


void ShowAndEnableWindow (HWND hWnd, BOOL fEnable)
{
    ShowWindow (hWnd, fEnable ? SW_SHOW : SW_HIDE);
    EnableWindow (hWnd, fEnable);
}


/*
 * Mixer_Init
 *
 * Control initialization
 * */
BOOL Mixer_Init(
    PMIXUIDIALOG    pmxud)
{
    MMRESULT        mmr;
    MIXERLINE       mlDst;
    DWORD           iline;
    TCHAR           achFmt[256];
    TCHAR           achTitle[256];
    TCHAR           achAccessible[256];
    int             x;

    ZeroMemory (achFmt, sizeof (achFmt)); // Inital value for prefix

    mmr = mixerOpen((LPHMIXER)&pmxud->hmx
                    , pmxud->mxid
                    , (DWORD_PTR)pmxud->hwnd
                    , 0
                    , CALLBACK_WINDOW);

    if (mmr != MMSYSERR_NOERROR)
    {
        return FALSE;
    }
    else
    {
        DeviceChange_Init(pmxud->hwnd, pmxud->mxid);
    }

    if (mixerMessage((HMIXER)ULongToPtr(pmxud->mxid), DRV_QUERYDEVNODE, (DWORD_PTR)&pmxud->dwDevNode, 0L))
        pmxud->dwDevNode = 0L;

    LoadString(pmxud->hInstance, IDS_APPTITLE, achFmt, SIZEOF(achFmt));

    mlDst.cbStruct      = sizeof ( mlDst );
    mlDst.dwDestination = pmxud->iDest;

    mmr = mixerGetLineInfo((HMIXEROBJ)ULongToPtr(pmxud->mxid)
                           , &mlDst
                           , MIXER_GETLINEINFOF_DESTINATION);

	achTitle[0] = TEXT('\0');
    if( mmr == MMSYSERR_NOERROR )
    {
		HRESULT hr = StringCchCopy( achTitle, SIZEOF(achTitle), mlDst.szName );
		if( hr != S_OK )
		{
			achTitle[0] = TEXT('\0');
		}
    }
	if( !achTitle[0] )
    {
        LoadString(pmxud->hInstance, IDS_APPBASE, achTitle, SIZEOF(achTitle));
    }

    SetWindowText(pmxud->hwnd, achTitle);

    //
    // since we cannot get a WM_PARENTNOTIFY, we need to run through
    // all controls and make appropriate modifications.
    //
    for ( iline = 0 ; iline < pmxud->cmxul ; iline++ )
    {
        PMIXUILINE  pmxul = &pmxud->amxul[iline];
        PMIXUICTRL  amxuc = pmxul->acr;
        HWND        ctrl;

        ctrl = Volume_GetLineItem(pmxud->hwnd, iline, IDC_LINELABEL);
        if (ctrl)
        {
            if (pmxud->dwStyle & MXUD_STYLEF_SMALL)
                Static_SetText(ctrl, pmxul->pvcd->szShortName);
            else
                Static_SetText(ctrl, pmxul->pvcd->szName);
        }

        // for MSAA (accessibility), we need to put the control name on the sliders
        for (x = IDC_ACCESS_BALANCE; x <= IDC_ACCESS_VOLUME; x++)
        {
            ctrl = Volume_GetLineItem(pmxud->hwnd, iline, x);
            if (ctrl)
            {
                Static_GetText(ctrl, achFmt, sizeof(achFmt)/sizeof(TCHAR));

                if (pmxud->dwStyle & MXUD_STYLEF_SMALL)
                {
                    StringCchPrintf(achAccessible,SIZEOF(achAccessible),achFmt,pmxul->pvcd->szShortName);
                    Static_SetText(ctrl, achAccessible);
                }
                else
                {
                    StringCchPrintf(achAccessible,SIZEOF(achAccessible),achFmt,pmxul->pvcd->szName);
                    Static_SetText(ctrl, achAccessible);
                }
            }
        }


        //
        // Master Control Multichannel Support
        //
        // Init multichannel support for master control if available. Note that if a master
        // control exisits on the dialog, it is currently in the first position, but we do
        // NOT rely on that fact here.
        // Note: Not only must there be multiple channels, but Volume must also be
        //       Supported to manipulate the channels.
        if (mlDst.cChannels > 2L &&
            MXUL_STYLEF_DESTINATION & pmxul->dwStyle &&
            pmxul->pvcd->dwSupport & VCD_SUPPORTF_MIXER_VOLUME)
        {
            int idc;
            for (idc = IDC_MASTER_BALANCE_ICON_2; idc >= IDC_MULTICHANNEL; idc--)
            {
                ctrl = Volume_GetLineItem (pmxud->hwnd, iline, idc);
                if (ctrl)
                    ShowAndEnableWindow (ctrl, (IDC_MULTICHANNEL == idc));
            }
            ctrl = Volume_GetLineItem (pmxud->hwnd, iline, IDC_BALANCE);
            if (ctrl)
                ShowAndEnableWindow (ctrl, FALSE);


            switch (mlDst.dwComponentType)
            {
                case MIXERLINE_COMPONENTTYPE_DST_SPEAKERS:
                    // No Change
                    break;

                case MIXERLINE_COMPONENTTYPE_DST_WAVEIN:
                case MIXERLINE_COMPONENTTYPE_DST_VOICEIN:
                    // Recording
                    LoadString(pmxud->hInstance, IDS_MC_RECORDING, achFmt, SIZEOF(achFmt));
                    SetWindowText (ctrl, achFmt);
                    break;

                default:
                    // Anything else...
                    LoadString(pmxud->hInstance, IDS_MC_LEVEL, achFmt, SIZEOF(achFmt));
                    SetWindowText (ctrl, achFmt);
                    break;

            }
        }


        //
        // Advanced escape
        //
        if (MXUD_ADVANCED(pmxud) &&
            !(pmxud->dwStyle & MXUD_STYLEF_SMALL))

        {
            HWND hadv = Volume_GetLineItem(pmxud->hwnd, iline, IDC_ADVANCED);
            if (hadv)
            {
                ShowWindow(hadv,(pmxul->pvcd->dwSupport & VCD_SUPPORTF_MIXER_ADVANCED)?SW_SHOW:SW_HIDE);
                EnableWindow(hadv,
                    (pmxul->pvcd->dwSupport & VCD_SUPPORTF_MIXER_ADVANCED)?TRUE:FALSE);
            }
        }

        if (pmxul->pvcd->dwSupport & VCD_SUPPORTF_DISABLED)
            continue;

        //
        // allow init of control structures
        //
        if (pmxul->pvcd->dwSupport & VCD_SUPPORTF_MIXER_VOLUME)
        {
            amxuc[MIXUI_VOLUME].state = MIXUI_CONTROL_ENABLED;
            if (pmxul->pvcd->dwSupport & VCD_SUPPORTF_MONO)
            {
                amxuc[MIXUI_BALANCE].state = MIXUI_CONTROL_UNINITIALIZED;
            }
            else
                amxuc[MIXUI_BALANCE].state = MIXUI_CONTROL_ENABLED;

        }
        if (pmxul->pvcd->dwSupport & VCD_SUPPORTF_MIXER_METER)
            amxuc[MIXUI_VUMETER].state = MIXUI_CONTROL_ENABLED;

        if (pmxul->pvcd->dwSupport & VCD_SUPPORTF_MIXER_MUTE)
            amxuc[MIXUI_SWITCH].state = MIXUI_CONTROL_ENABLED;

        if ((pmxul->pvcd->dwSupport & ( VCD_SUPPORTF_MIXER_MIXER
                                        | VCD_SUPPORTF_MIXER_MUX))
            && (pmxul->pvcd->dwVisible & ( VCD_VISIBLEF_MIXER_MIXER
                                           | VCD_VISIBLEF_MIXER_MUX)))
        {
            //
            // No longer make the mute visible
            //
            pmxul->pvcd->dwVisible &= ~VCD_VISIBLEF_MIXER_MUTE;

            amxuc[MIXUI_SWITCH].state = MIXUI_CONTROL_ENABLED;
            ctrl = Volume_GetLineItem(pmxud->hwnd, iline, IDC_SWITCH);
            if (ctrl)
            {
                TCHAR ach[256];
                if (LoadString(pmxud->hInstance, IDS_SELECT, ach, SIZEOF(ach)))
                    Button_SetText(ctrl, ach);
            }
        }
    }
    return TRUE;
}

/*
 * Mixer_Shutdown
 *
 * Close handles, etc..
 * */
void Mixer_Shutdown(
    PMIXUIDIALOG    pmxud)
{
    if (pmxud->hmx)
    {
        mixerClose(pmxud->hmx);
        pmxud->hmx = NULL;
    }

    Mixer_CleanupVolumeDescription(pmxud->avcd, pmxud->cvcd);
}


/*      -       -       -       -       -       -       -       -       - */

typedef struct tagAdv {
    PMIXUIDIALOG pmxud;     // IN
    DWORD        dwLineID;  // IN
    HMIXER       hmx;       // IN
    LPTSTR       szName;    // IN

    DWORD        dwSupport;
    DWORD        dwBassID;
    DWORD        dwTrebleID;
    DWORD        dwSwitch1ID;
    DWORD        dwSwitch2ID;

} ADVPARAM, *PADVPARAM;

#define GETPADVPARAM(x)       (ADVPARAM *)GetWindowLongPtr(x, DWLP_USER)
#define SETPADVPARAM(x,y)     SetWindowLongPtr(x, DWLP_USER, y)
#define ADV_HAS_BASS          0x00000001
#define ADV_HAS_TREBLE        0x00000002
#define ADV_HAS_SWITCH1       0x00000004
#define ADV_HAS_SWITCH2       0x00000008


void Mixer_Advanced_Update(
    PADVPARAM       pap,
    HWND            hwnd)
{
    MIXERCONTROLDETAILS mxcd;
    DWORD           dwValue = 0;
    MMRESULT        mmr;

    if (pap->dwSupport & ADV_HAS_TREBLE)
    {
        mxcd.cbStruct       = sizeof(mxcd);
        mxcd.dwControlID    = pap->dwTrebleID ;
        mxcd.cChannels      = 1;
        mxcd.cMultipleItems = 0;
        mxcd.cbDetails      = sizeof(DWORD);
        mxcd.paDetails      = (LPVOID)&dwValue;

        mmr = mixerGetControlDetails((HMIXEROBJ)(pap->hmx)
                                     , &mxcd
                                     , MIXER_GETCONTROLDETAILSF_VALUE);

        if (mmr == MMSYSERR_NOERROR)
        {
            dwValue = VOLUME_TO_SLIDER(dwValue);
            SendMessage(GetDlgItem(hwnd, IDC_TREBLE), TBM_SETPOS, TRUE, dwValue);
        }
    }

    if (pap->dwSupport & ADV_HAS_BASS)
    {
        mxcd.cbStruct       = sizeof(mxcd);
        mxcd.dwControlID    = pap->dwBassID;
        mxcd.cChannels      = 1;
        mxcd.cMultipleItems = 0;
        mxcd.cbDetails      = sizeof(DWORD);
        mxcd.paDetails      = (LPVOID)&dwValue;

        mmr = mixerGetControlDetails((HMIXEROBJ)(pap->hmx)
                                     , &mxcd
                                     , MIXER_GETCONTROLDETAILSF_VALUE);

        if (mmr == MMSYSERR_NOERROR)
        {
            dwValue = VOLUME_TO_SLIDER(dwValue);
            SendMessage(GetDlgItem(hwnd, IDC_BASS), TBM_SETPOS, TRUE, dwValue);
        }
    }

    if (pap->dwSupport & ADV_HAS_SWITCH1)
    {
        mxcd.cbStruct       = sizeof(mxcd);
        mxcd.dwControlID    = pap->dwSwitch1ID;
        mxcd.cChannels      = 1;
        mxcd.cMultipleItems = 0;
        mxcd.cbDetails      = sizeof(DWORD);
        mxcd.paDetails      = (LPVOID)&dwValue;

        mmr = mixerGetControlDetails((HMIXEROBJ)(pap->hmx)
                                     , &mxcd
                                     , MIXER_GETCONTROLDETAILSF_VALUE);

        if (mmr == MMSYSERR_NOERROR)
        {
            Button_SetCheck(GetDlgItem(hwnd,IDC_SWITCH1),dwValue);
        }

    }

    if (pap->dwSupport & ADV_HAS_SWITCH2)
    {
        mxcd.cbStruct       = sizeof(mxcd);
        mxcd.dwControlID    = pap->dwSwitch2ID;
        mxcd.cChannels      = 1;
        mxcd.cMultipleItems = 0;
        mxcd.cbDetails      = sizeof(DWORD);
        mxcd.paDetails      = (LPVOID)&dwValue;

        mmr = mixerGetControlDetails((HMIXEROBJ)(pap->hmx)
                                     , &mxcd
                                     , MIXER_GETCONTROLDETAILSF_VALUE);

        if (mmr == MMSYSERR_NOERROR)
        {
            Button_SetCheck(GetDlgItem(hwnd,IDC_SWITCH2),dwValue);
        }
    }
}

void Mixer_Advanced_OnMixmControlChange(
    HWND            hwnd,
    HMIXER          hmx,
    DWORD           dwControlID)
{
    PADVPARAM     pap = GETPADVPARAM(hwnd);

    if (!pap)
        return;

    if ( ((pap->dwSupport & ADV_HAS_BASS)
          && dwControlID == pap->dwBassID)
         || ((pap->dwSupport & ADV_HAS_TREBLE)
             && dwControlID == pap->dwTrebleID)
         || ((pap->dwSupport & ADV_HAS_SWITCH1)
             && dwControlID == pap->dwSwitch1ID)
         || ((pap->dwSupport & ADV_HAS_SWITCH2)
             && dwControlID == pap->dwSwitch2ID) )
    {
        Mixer_Advanced_Update(pap,hwnd);
    }
}

BOOL Mixer_Advanced_OnInitDialog(
    HWND            hwnd,
    HWND            hwndFocus,
    LPARAM          lParam)
{
    PADVPARAM           pap;
    MIXERLINECONTROLS   mxlc;
    MIXERCONTROL        *pmxc;
    MIXERLINE           ml;
    MMRESULT            mmr;
    DWORD               iCtrl, iSwitch1, iSwitch2;
    TCHAR               ach[MIXER_LONG_NAME_CHARS + 24];
    TCHAR               achFmt[256];

    HWND                hBass,hTreble,hSwitch1,hSwitch2;

    SETPADVPARAM(hwnd, lParam);
    pap = GETPADVPARAM(hwnd);
    if (!pap)
        EndDialog(hwnd, FALSE);

    //
    // clone the mixer handle to catch callbacks
    //
    #ifndef _WIN64
    mmr = mixerOpen((LPHMIXER)&pap->hmx
                    , (UINT)pap->pmxud->hmx
                    , (DWORD_PTR)hwnd
                    , 0
                    , CALLBACK_WINDOW | MIXER_OBJECTF_HMIXER );
    #else
    mmr = mixerOpen((LPHMIXER)&pap->hmx
                    , (UINT)pap->pmxud->mxid
                    , (DWORD_PTR)hwnd
                    , 0
                    , CALLBACK_WINDOW | MIXER_OBJECTF_HMIXER );
    #endif

    if (mmr != MMSYSERR_NOERROR)
        EndDialog(hwnd, FALSE);

    //
    // Get all controls.
    //

    ml.cbStruct      = sizeof(ml);
    ml.dwLineID      = pap->dwLineID;

    mmr = mixerGetLineInfo((HMIXEROBJ)pap->hmx
                           , &ml
                           , MIXER_GETLINEINFOF_LINEID);

    if (mmr != MMSYSERR_NOERROR || ml.cControls == 0L)
        EndDialog(hwnd, FALSE);

    pmxc = (MIXERCONTROL *)GlobalAllocPtr(GHND,
                                          sizeof(MIXERCONTROL) * ml.cControls);
    if (!pmxc)
    {
        EndDialog(hwnd, FALSE);
        return FALSE; // Bail on error
    }

    mxlc.cbStruct   = sizeof(mxlc);
    mxlc.dwLineID   = pap->dwLineID;
    mxlc.cControls  = ml.cControls;
    mxlc.cbmxctrl   = sizeof(MIXERCONTROL);
    mxlc.pamxctrl   = pmxc;

    mmr = mixerGetLineControls((HMIXEROBJ)(pap->hmx)
                               , &mxlc
                               , MIXER_GETLINECONTROLSF_ALL);
    if (mmr != MMSYSERR_NOERROR)
    {
        GlobalFreePtr(pmxc);
        EndDialog(hwnd, FALSE);
    }

    pap->dwSupport = 0L;
    for (iCtrl = 0; iCtrl < ml.cControls; iCtrl++)
    {
        switch (pmxc[iCtrl].dwControlType)
        {
            case MIXERCONTROL_CONTROLTYPE_BASS:
                if (!(pap->dwSupport & ADV_HAS_BASS))
                {
                    pap->dwBassID  = pmxc[iCtrl].dwControlID;
                    pap->dwSupport |= ADV_HAS_BASS;
                }
                break;
            case MIXERCONTROL_CONTROLTYPE_TREBLE:
                if (!(pap->dwSupport & ADV_HAS_TREBLE))
                {
                    pap->dwTrebleID  = pmxc[iCtrl].dwControlID;
                    pap->dwSupport |= ADV_HAS_TREBLE;
                }
                break;

            case MIXERCONTROL_CONTROLTYPE_BOOLEAN:
            case MIXERCONTROL_CONTROLTYPE_MONO:
            case MIXERCONTROL_CONTROLTYPE_STEREOENH:
            case MIXERCONTROL_CONTROLTYPE_ONOFF:
            case MIXERCONTROL_CONTROLTYPE_LOUDNESS:
                if (!(pap->dwSupport & ADV_HAS_SWITCH1))
                {
                    pap->dwSwitch1ID  = pmxc[iCtrl].dwControlID;
                    pap->dwSupport |= ADV_HAS_SWITCH1;
                    iSwitch1 = iCtrl;
                }
                else if (!(pap->dwSupport & ADV_HAS_SWITCH2))
                {
                    pap->dwSwitch2ID  = pmxc[iCtrl].dwControlID;
                    pap->dwSupport |= ADV_HAS_SWITCH2;
                    iSwitch2 = iCtrl;
                }
                break;
        }
    }

    //
    //
    //

    hBass = GetDlgItem(hwnd, IDC_BASS);
    hTreble = GetDlgItem(hwnd, IDC_TREBLE);
    hSwitch1 = GetDlgItem(hwnd, IDC_SWITCH1);
    hSwitch2 = GetDlgItem(hwnd, IDC_SWITCH2);

    SendMessage(hBass, TBM_SETRANGE, 0, MAKELONG(0, VOLUME_TICS));
    SendMessage(hBass, TBM_SETTICFREQ, (VOLUME_TICS + 5)/6, 0 );

    SendMessage(hTreble, TBM_SETRANGE, 0, MAKELONG(0, VOLUME_TICS));
    SendMessage(hTreble, TBM_SETTICFREQ, (VOLUME_TICS + 5)/6, 0 );

    if (!(pap->dwSupport & ADV_HAS_BASS))
    {
        SendMessage(hBass, TBM_SETPOS, 64, 0 );
        EnableWindow(GetDlgItem(hwnd, IDC_TXT_LOW1), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_TXT_HI1), FALSE);
    }
    EnableWindow(hBass, (pap->dwSupport & ADV_HAS_BASS));

    if (!(pap->dwSupport & ADV_HAS_TREBLE))
    {
        SendMessage(hTreble, TBM_SETPOS, 64, 0 );
        EnableWindow(GetDlgItem(hwnd, IDC_TXT_LOW2), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_TXT_HI2), FALSE);
    }
    EnableWindow(hTreble, (pap->dwSupport & ADV_HAS_TREBLE));

    if (pap->dwSupport & ADV_HAS_SWITCH1)
    {
        LoadString(pap->pmxud->hInstance, IDS_ADV_SWITCH1, achFmt,
            SIZEOF(achFmt));
        StringCchPrintf(ach, SIZEOF(ach), achFmt, pmxc[iSwitch1].szName);

        SetWindowText(hSwitch1, ach);
        ShowWindow(hSwitch1, SW_SHOW);
        ShowWindow(GetDlgItem(hwnd, IDC_TXT_SWITCHES), SW_SHOW);
        ShowWindow(GetDlgItem(hwnd, IDC_GRP_OTHER), SW_SHOW);
    }
    EnableWindow(hSwitch1, (pap->dwSupport & ADV_HAS_SWITCH1));

    if (pap->dwSupport & ADV_HAS_SWITCH2)
    {
        LoadString(pap->pmxud->hInstance, IDS_ADV_SWITCH2, achFmt,
            SIZEOF(achFmt));
        StringCchPrintf(ach, SIZEOF(ach), achFmt, pmxc[iSwitch2].szName);

        SetWindowText(hSwitch2, ach);
        ShowWindow(hSwitch2, SW_SHOW);
    }

    EnableWindow(hSwitch2, (pap->dwSupport & ADV_HAS_SWITCH2));

    if (pap->dwSupport & (ADV_HAS_SWITCH1 | ADV_HAS_SWITCH2))
    {
        RECT    rcGrp,rcGrp2,rcClose,rcWnd;
        DWORD   dwDY=0L;
        POINT   pos;
        HWND    hClose = GetDlgItem(hwnd, IDOK);
        HWND    hGrp2 = GetDlgItem(hwnd, IDC_GRP_OTHER);

        GetWindowRect(GetDlgItem(hwnd, IDC_GRP_TONE), &rcGrp);
        GetWindowRect(GetDlgItem(hwnd, IDC_GRP_OTHER), &rcGrp2);
        GetWindowRect(hClose, &rcClose);
        GetWindowRect(hwnd, &rcWnd);

        if (pap->dwSupport & ADV_HAS_SWITCH2)
        {
            RECT rc1, rc2;
            GetWindowRect(hSwitch1,&rc1);
            GetWindowRect(hSwitch2,&rc2);

            rcGrp2.bottom += rc2.bottom - rc1.bottom;
        }

        dwDY = rcGrp2.bottom - rcGrp.bottom;

        //
        // resize our main window
        //
        MoveWindow(hwnd, rcWnd.left
                   , rcWnd.top
                   , rcWnd.right - rcWnd.left
                   , (rcWnd.bottom - rcWnd.top) + dwDY
                   , FALSE);

        //
        // move the close button
        //
        MapWindowPoints(NULL, hwnd, (LPPOINT)&rcClose, 2);
        pos.x = rcClose.left;
        pos.y = rcClose.top;

        MoveWindow(hClose, pos.x
                   , pos.y + dwDY
                   , rcClose.right - rcClose.left
                   , rcClose.bottom - rcClose.top
                   , FALSE);

        //
        // resize our group box if necessary
        //
        if (pap->dwSupport & ADV_HAS_SWITCH2)
        {
            MapWindowPoints(NULL, hwnd, (LPPOINT)&rcGrp2, 2);
            pos.x = rcGrp2.left;
            pos.y = rcGrp2.top;

            MoveWindow(hGrp2, pos.x
                       , pos.y
                       , rcGrp2.right - rcGrp2.left
                       , rcGrp2.bottom - rcGrp2.top
                       , FALSE);
        }
    }

    GlobalFreePtr(pmxc);

    {
        TCHAR achTitle[MIXER_LONG_NAME_CHARS+256];
        LoadString(pap->pmxud->hInstance, IDS_ADV_TITLE, achFmt,
            SIZEOF(achFmt));
        StringCchPrintf(achTitle, SIZEOF(achTitle), achFmt, pap->szName);
        SetWindowText(hwnd, achTitle);
    }

    Mixer_Advanced_Update(pap, hwnd);

    return TRUE;
}

void Mixer_Advanced_OnXScroll(
    HWND            hwnd,
    HWND            hwndCtl,
    UINT            code,
    int             pos)
{
    PADVPARAM       pap;
    MIXERCONTROLDETAILS mxcd;
    DWORD           dwVol;
    MMRESULT        mmr;

    pap = GETPADVPARAM(hwnd);

    if (!pap)
        return;

    if (pap->dwSupport & ADV_HAS_TREBLE)
    {
        dwVol = (DWORD)SendMessage( GetDlgItem(hwnd, IDC_TREBLE)
                                , TBM_GETPOS
                                , 0
                                , 0 );


        dwVol = SLIDER_TO_VOLUME(dwVol);

        mxcd.cbStruct       = sizeof(mxcd);
        mxcd.dwControlID    = pap->dwTrebleID ;
        mxcd.cChannels      = 1;
        mxcd.cMultipleItems = 0;
        mxcd.cbDetails      = sizeof(DWORD);
        mxcd.paDetails      = (LPVOID)&dwVol;

        mixerSetControlDetails((HMIXEROBJ)(pap->hmx)
                               , &mxcd
                               , MIXER_SETCONTROLDETAILSF_VALUE);
    }

    if (pap->dwSupport & ADV_HAS_BASS)
    {
        dwVol = (DWORD)SendMessage( GetDlgItem(hwnd, IDC_BASS)
                                , TBM_GETPOS
                                , 0
                                , 0 );

        dwVol = SLIDER_TO_VOLUME(dwVol);

        mxcd.cbStruct       = sizeof(mxcd);
        mxcd.dwControlID    = pap->dwBassID;
        mxcd.cChannels      = 1;
        mxcd.cMultipleItems = 0;
        mxcd.cbDetails      = sizeof(DWORD);
        mxcd.paDetails      = (LPVOID)&dwVol;

        mmr = mixerSetControlDetails((HMIXEROBJ)(pap->hmx)
                                     , &mxcd
                                     , MIXER_SETCONTROLDETAILSF_VALUE);
    }
}

void Mixer_Advanced_OnSwitch(
    HWND            hwnd,
    int             id,
    HWND            hwndCtl)
{
    PADVPARAM       pap;
    MIXERCONTROLDETAILS mxcd;
    DWORD           dwValue;
    MMRESULT        mmr;

    pap = GETPADVPARAM(hwnd);

    if (!pap)
        return;


    dwValue = Button_GetCheck(hwndCtl);

    mxcd.cbStruct       = sizeof(mxcd);
    mxcd.dwControlID    = (id == IDC_SWITCH1)?pap->dwSwitch1ID:pap->dwSwitch2ID;
    mxcd.cChannels      = 1;
    mxcd.cMultipleItems = 0;
    mxcd.cbDetails      = sizeof(DWORD);
    mxcd.paDetails      = (LPVOID)&dwValue;

    mmr = mixerSetControlDetails((HMIXEROBJ)(pap->hmx)
                                 , &mxcd
                                 , MIXER_SETCONTROLDETAILSF_VALUE);

}


BOOL Mixer_Advanced_OnCommand(
    HWND            hwnd,
    int             id,
    HWND            hwndCtl,
    UINT            codeNotify)
{
    switch (id)
    {
        case IDOK:
            EndDialog(hwnd, TRUE);
            break;

        case IDCANCEL:
            EndDialog(hwnd, FALSE);
            break;

        case IDC_SWITCH1:
            Mixer_Advanced_OnSwitch(hwnd, id, hwndCtl);
            break;

        case IDC_SWITCH2:
            Mixer_Advanced_OnSwitch(hwnd, id, hwndCtl);
            break;

    }
    return FALSE;
}

INT_PTR CALLBACK Mixer_Advanced_Proc(
    HWND            hwnd,
    UINT            msg,
    WPARAM          wparam,
    LPARAM          lparam)
{
    switch (msg)
    {
        case WM_INITDIALOG:
            HANDLE_WM_INITDIALOG(hwnd, wparam, lparam, Mixer_Advanced_OnInitDialog);
            return TRUE;

        case MM_MIXM_CONTROL_CHANGE:
            HANDLE_MM_MIXM_CONTROL_CHANGE(hwnd
                                          , wparam
                                          , lparam
                                          , Mixer_Advanced_OnMixmControlChange);
            break;

        case WM_CLOSE:
            EndDialog(hwnd, FALSE);
            break;

        case WM_HSCROLL:
            HANDLE_WM_XSCROLL(hwnd, wparam, lparam, Mixer_Advanced_OnXScroll);
            break;

        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wparam, lparam, Mixer_Advanced_OnCommand);
            break;

        case WM_DESTROY:
        {
            PADVPARAM pap = GETPADVPARAM(hwnd);
            if (pap)
            {
                if (pap->hmx)
                    mixerClose(pap->hmx);
            }
            break;
        }

        default:
            break;
    }

    return FALSE;
}

/*
 * Advanced Features for specific mixer lines.
 */
void Mixer_Advanced(
    PMIXUIDIALOG    pmxud,
    DWORD           dwLineID,
    LPTSTR          szName)
{
    ADVPARAM advp;

    ZeroMemory(&advp, sizeof(ADVPARAM));
    advp.pmxud = pmxud;
    advp.dwLineID = dwLineID;
    advp.szName = szName;

    DialogBoxParam(pmxud->hInstance
                   , MAKEINTRESOURCE(IDD_ADVANCED)
                   , pmxud->hwnd
                   , Mixer_Advanced_Proc
                   , (LPARAM)(LPVOID)&advp);
}

typedef void (*MULTICHANNELFUNC)(HWND, UINT, DWORD, DWORD);
void Mixer_Multichannel (PMIXUIDIALOG pmxud, DWORD dwVolumeID)
{
    HMODULE          hModule;
    MULTICHANNELFUNC fnMultiChannel;

    if (pmxud)
    {
        hModule = (HMODULE) LoadLibrary (TEXT ("mmsys.cpl"));
        if (hModule)
        {
            fnMultiChannel = (MULTICHANNELFUNC) GetProcAddress (hModule, "Multichannel");
            if (fnMultiChannel)
            {
                (*fnMultiChannel)(pmxud->hwnd, pmxud->mxid, pmxud->iDest, dwVolumeID);
            }
            FreeLibrary (hModule);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mixerapp\choice.c ===
/*****************************************************************************
 *
 *  Component:  sndvol32.exe
 *  File:       choice.c
 *  Purpose:    properties dialog box code
 * 
 *  Copyright (c) 1985-1999 Microsoft Corporation
 *
 *****************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <commctrl.h>

#include "volids.h"
#include "volumei.h"
#include "utils.h"

typedef struct t_DEVICEPROP {
    BOOL            fMixer;             // is mixer
    UINT            uDeviceID;          // device ID
    DWORD           dwPlayback;         // mixerline representing playback
    DWORD           dwRecording;        // mixerline representing recording
    MIXERCAPS       mxcaps;
} DEVICEPROP, *PDEVICEPROP;

typedef struct t_PRIVPROP {
    PMIXUIDIALOG    pmxud;              // app instance data
    PDEVICEPROP     adp;                // array of allocated device props
    PDEVICEPROP     pdpCurSel;          // current device selection
    DWORD           dwDestSel;          // last destination selection
    
    PVOLCTRLDESC    avcd;
    DWORD           cvcd;
    
    // in/out params

    UINT            uDeviceID;
    BOOL            fMixer;
    DWORD           dwDestination;
    DWORD           dwStyle;
    
} PRIVPROP, *PPRIVPROP;

#define PROPATOM        TEXT("privprop")
const TCHAR gszPropAtom[] = PROPATOM;
#define SETPROP(x,y)    SetProp((x), gszPropAtom, (HANDLE)(y))
#define GETPROP(x)      (PPRIVPROP)GetProp((x), gszPropAtom)
#define REMOVEPROP(x)   RemoveProp(x,gszPropAtom)

void SetCheckState (HWND hwndLV, int nItem, BOOL bCheck)
{
    LVITEM item;
	int nCheck = bCheck ? 2 : 1;	// one based index

    ZeroMemory (&item, sizeof (item));
    item.mask = LVIF_STATE;
    item.iItem = nItem;
    item.stateMask = LVIS_STATEIMAGEMASK;
    item.state = INDEXTOSTATEIMAGEMASK (nCheck);
    ListView_SetItem (hwndLV, &item);
}

void EnableOk(
    HWND            hwnd,
    BOOL            fEnable)
{
    HWND    hOk, hCancel;
    BOOL    fWasEnabled;
    
    hOk     = GetDlgItem(hwnd,IDOK);
    hCancel = GetDlgItem(hwnd,IDCANCEL);
    
    fWasEnabled = IsWindowEnabled(hOk);

    if (!fEnable && fWasEnabled)
    {
        Button_SetStyle(hOk, BS_PUSHBUTTON, TRUE);
        SendMessage(hwnd, DM_SETDEFID, IDCANCEL, 0L);
        EnableWindow(hOk, FALSE);
    }
    else if (fEnable && !fWasEnabled)
    {
        EnableWindow(hOk, TRUE);
        Button_SetStyle(hCancel, BS_PUSHBUTTON, TRUE);
        SendMessage(hwnd, DM_SETDEFID, IDOK, 0L);
    }
}

void Properties_GroupEnable(
    HWND            hwnd,
    const int       ids[],
    int             cids,
    BOOL            fEnable)
{
    int i;
    for (i = 0; i < cids; i++)
        EnableWindow(GetDlgItem(hwnd, ids[i]), fEnable);
}
    
void Properties_Enable_Prop_Volumes(
    HWND            hwnd,
    BOOL            fEnable)
{
    const int ids[] = {
        IDC_PROP_VOLUMES,
        IDC_PROP_PLAYBACK,
        IDC_PROP_RECORDING,
        IDC_PROP_OTHER,
        IDC_PROP_OTHERLIST
    };
    if (!fEnable)
        ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_PROP_OTHERLIST), -1);
    Properties_GroupEnable(hwnd, ids, SIZEOF(ids), fEnable);
}

void Properties_Enable_PROP_DEVICELIST(
    HWND            hwnd,
    BOOL            fEnable)
{
    const int ids[] = {
        IDC_PROP_TXT1,
        IDC_PROP_DEVICELIST,
    };
    if (!fEnable)
        ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_PROP_OTHERLIST), -1);
    Properties_GroupEnable(hwnd, ids, SIZEOF(ids), fEnable);
}

void Properties_Enable_PROP_VOLUMELIST(
    HWND            hwnd,
    BOOL            fEnable)
{
    const int ids[] = {
        IDC_PROP_TXT2,
        IDC_PROP_VOLUMELIST,
    };
    Properties_GroupEnable(hwnd, ids, SIZEOF(ids), fEnable);
}


void Properties_CommitState(
    PPRIVPROP       ppr,
    HWND            hlb)
{
    DWORD           i;
    DWORD           cItems = ListView_GetItemCount(hlb);
    
    if (!ppr->avcd)
        return;
               
    for (i=0;i<cItems;i++)
    {
        LV_ITEM         lvi;
        
        lvi.iItem       = i;
        lvi.iSubItem    = 0;
        lvi.mask        = LVIF_PARAM;
        
        if (ListView_GetItem(hlb, &lvi))
        {
            ppr->avcd[lvi.lParam].dwSupport = (ListView_GetCheckState (hlb, i))?0:VCD_SUPPORTF_HIDDEN;
        }
    }
            
    Volume_GetSetRegistryLineStates(ppr->pdpCurSel->mxcaps.szPname
                                    , ppr->avcd[0].szShortName
                                    , ppr->avcd
                                    , ppr->cvcd
                                    , SET );

    Mixer_CleanupVolumeDescription(ppr->avcd, ppr->cvcd);

    GlobalFreePtr(ppr->avcd);
    ppr->avcd = NULL;
    ppr->cvcd = 0L;
}
    

/*
 * Init the destination type groupbox
 * 
 * */
BOOL Properties_Init_Prop_Volumes(
    PPRIVPROP       ppr,
    HWND            hwnd)
{
    HWND            hPlay = GetDlgItem(hwnd, IDC_PROP_PLAYBACK);
    HWND            hRec = GetDlgItem(hwnd, IDC_PROP_RECORDING);
    HWND            hOther = GetDlgItem(hwnd, IDC_PROP_OTHER);
    HWND            hOtherList = GetDlgItem(hwnd, IDC_PROP_OTHERLIST);
    DWORD           iDest, cDest;
    BOOL            fPlay = FALSE, fRec = FALSE;
    
    if (!ppr->pdpCurSel->fMixer)
        return FALSE;

    ComboBox_ResetContent(hOtherList);

    cDest = ppr->pdpCurSel->mxcaps.cDestinations;
    
    EnableWindow(hPlay, FALSE);
    EnableWindow(hRec, FALSE);
    EnableWindow(hOther, FALSE);
    
    for (iDest = 0; iDest < cDest; iDest++)
    {
        MIXERLINE   mlDst;
        int         imx;
        
        mlDst.cbStruct      = sizeof ( mlDst );
        mlDst.dwDestination = iDest;

        if (mixerGetLineInfo((HMIXEROBJ)UIntToPtr(ppr->pdpCurSel->uDeviceID)
                             , &mlDst
                             , MIXER_GETLINEINFOF_DESTINATION)
            != MMSYSERR_NOERROR)
            continue;

        //
        // Conditionally enable selections.  The first type for Play and
        // Record are the default Playback and Recording radiobuttons.
        // The next occurence of the same type is heaped into the Other
        // category.
        //

        if (mlDst.dwComponentType == MIXERLINE_COMPONENTTYPE_DST_SPEAKERS
            && !fPlay)
        {
            EnableWindow(hPlay, TRUE);

            if (iDest == ppr->dwDestSel)
                CheckRadioButton(hwnd, IDC_PROP_PLAYBACK, IDC_PROP_OTHER
                                 , IDC_PROP_PLAYBACK);
            ppr->pdpCurSel->dwPlayback = iDest;
            fPlay = TRUE;
        }
        else if (mlDst.dwComponentType == MIXERLINE_COMPONENTTYPE_DST_WAVEIN
                 && !fRec)
        {
            EnableWindow(hRec, TRUE);

            if (iDest == ppr->dwDestSel)
                CheckRadioButton(hwnd, IDC_PROP_PLAYBACK, IDC_PROP_OTHER
                                 , IDC_PROP_RECORDING);
            ppr->pdpCurSel->dwRecording = iDest;
            fRec = TRUE;
        }
        else
        {
            EnableWindow(hOther, TRUE);
            imx = ComboBox_AddString(hOtherList, mlDst.szName);
            ComboBox_SetItemData(hOtherList, imx, iDest);

            if (iDest == ppr->dwDestSel)
            {
                CheckRadioButton(hwnd, IDC_PROP_PLAYBACK, IDC_PROP_OTHER
                                 , IDC_PROP_OTHER);
                ComboBox_SetCurSel(hOtherList, imx);
            }
        }
    }

    //
    // Disable the "other" drop down if its not selected
    //
    if (!IsDlgButtonChecked(hwnd, IDC_PROP_OTHER))
    {
        ComboBox_SetCurSel(hOtherList, 0);
        EnableWindow(hOtherList, FALSE);
    }
            
    return TRUE;
}
    
BOOL Properties_Init_PROP_VOLUMELIST(
    PPRIVPROP       ppr,
    HWND            hwnd)
{
    HWND            hlb = GetDlgItem(hwnd, IDC_PROP_VOLUMELIST);
    LV_COLUMN       col = {LVCF_FMT | LVCF_WIDTH, LVCFMT_LEFT};
    RECT            rc;
    BOOL            fSet = FALSE;
    PVOLCTRLDESC    avcd = NULL;
    DWORD           cvcd = 0L;
    DWORD           ivcd;
    int             ilvi;
    LV_ITEM         lvi;
        
    
    ListView_DeleteAllItems(hlb);
    ListView_SetExtendedListViewStyleEx (hlb, LVS_EX_CHECKBOXES, LVS_EX_CHECKBOXES);
    ZeroMemory (&lvi, sizeof (lvi));

    GetClientRect(hlb, &rc);
    col.cx = rc.right - 2 * GetSystemMetrics(SM_CXEDGE);
    ListView_InsertColumn(hlb, 0, &col);

    if (ppr->avcd)
    {
        if (ppr->pdpCurSel->fMixer)
            Mixer_CleanupVolumeDescription(ppr->avcd, ppr->cvcd);
//        else
//            Nonmixer_CleanupVolumeDescription(ppr->avcd, ppr->cvcd);

        GlobalFreePtr(ppr->avcd);
                    
        ppr->avcd = NULL;
        ppr->cvcd = 0L;
    }
            
    if (ppr->pdpCurSel->fMixer)
    {
		HMIXER		hmx;
		MMRESULT	mmr;

		//
		//  Mixer API's are much more efficient with mixer handle...
		//

		mmr = mixerOpen(&hmx
				, ppr->pdpCurSel->uDeviceID
				, 0L
				, 0L
				, MIXER_OBJECTF_MIXER);

		if(MMSYSERR_NOERROR == mmr)
		{
	        avcd = Mixer_CreateVolumeDescription((HMIXEROBJ)hmx
	                                             , ppr->dwDestSel
	                                             , &cvcd);

			mixerClose(hmx);
		}
		else
		{
	        avcd = Mixer_CreateVolumeDescription((HMIXEROBJ)UIntToPtr(ppr->pdpCurSel->uDeviceID)
	                                             , ppr->dwDestSel
	                                             , &cvcd);
		}
    }
    else
    {
        avcd = Nonmixer_CreateVolumeDescription(ppr->dwDestSel
                                                , &cvcd);

    }

    if (avcd)
    {
        BOOL fFirstRun;
        //
        // Restore hidden state 
        //
        fFirstRun = !Volume_GetSetRegistryLineStates(ppr->pdpCurSel->mxcaps.szPname
                                                    , avcd[0].szShortName
                                                    , avcd
                                                    , cvcd
                                                    , GET );

        if (fFirstRun)
        {
            for (ivcd = 0; ivcd < cvcd; ivcd++)
            {
                if (!(avcd[ivcd].dwSupport & VCD_SUPPORTF_DEFAULT))
                    avcd[ivcd].dwSupport |= VCD_SUPPORTF_HIDDEN;
            }
            Volume_GetSetRegistryLineStates(ppr->pdpCurSel->mxcaps.szPname
                                            , avcd[0].szShortName
                                            , avcd
                                            , cvcd
                                            , SET);
        }
            
        for (ivcd = 0, ilvi = 0; ivcd < cvcd; ivcd++)
        {
            if (!(avcd[ivcd].dwSupport & VCD_SUPPORTF_VISIBLE))
                continue;

            lvi.iItem           = ilvi;
            lvi.iSubItem        = 0;
            lvi.mask            = LVIF_TEXT|LVIF_PARAM;
            lvi.lParam          = ivcd;
            lvi.pszText         = avcd[ivcd].szName;

            ListView_InsertItem(hlb, &lvi);
        
            if (!(avcd[ivcd].dwSupport & VCD_SUPPORTF_HIDDEN))
            {
                fSet = TRUE;
                SetCheckState (hlb, ilvi, TRUE);
            }
            ilvi++;

        }
    
        ppr->avcd = avcd;
        ppr->cvcd = cvcd;
    }
    
    ListView_SetItemState(hlb, 0, TRUE, LVIS_FOCUSED);

    EnableOk(hwnd, fSet);
        
    return TRUE;
}

/*
 * Init the list of devices.
 *
 * */
BOOL Properties_Init_PROP_DEVICELIST(
    PPRIVPROP       ppr,
    HWND            hwnd)
{
    HWND            hlb = GetDlgItem(hwnd, IDC_PROP_DEVICELIST);
    int             iMixer;
    int             cValidMixers = 0;
    int             cMixers;

    cMixers = mixerGetNumDevs();
    if (!cMixers)
        return FALSE;

    ppr->adp = (PDEVICEPROP)GlobalAllocPtr(GHND,cMixers * sizeof(DEVICEPROP));
    if (ppr->adp == NULL)
        return FALSE;
    
    for (iMixer = 0; iMixer < cMixers; iMixer++)
    {
        int         imx;
        MIXERCAPS*  pmxcaps = &ppr->adp[iMixer].mxcaps;
        MMRESULT    mmr;
        
        mmr = mixerGetDevCaps(iMixer, pmxcaps, sizeof(MIXERCAPS));

        if (mmr != MMSYSERR_NOERROR)
            continue;

        cValidMixers++;
        
        imx = ComboBox_AddString(hlb, pmxcaps->szPname);
        
        ppr->adp[iMixer].uDeviceID  = iMixer;
        ppr->adp[iMixer].fMixer     = TRUE;
        
        ComboBox_SetItemData(hlb, imx, &ppr->adp[iMixer]);
    }
    
    if (cValidMixers == 0)
        return FALSE;

    return TRUE;
}

BOOL Properties_OnCommand(
    HWND            hwnd,
    int             id,
    HWND            hctl,
    UINT            unotify)
{
    PPRIVPROP       ppr = GETPROP(hwnd);
    if (!ppr)
        return FALSE;

    switch (id)
    {
        case IDC_PROP_DEVICELIST:
            if (unotify == CBN_SELCHANGE)
            {
                int         imx;
                PDEVICEPROP pdp;
                
                imx = ComboBox_GetCurSel(hctl);
                pdp = (PDEVICEPROP)ComboBox_GetItemData(hctl, imx);

                if (pdp == ppr->pdpCurSel)
                    break;

                ppr->pdpCurSel = pdp;
                
                if (ppr->pdpCurSel->fMixer)
                    Properties_Init_Prop_Volumes(ppr, hwnd);
                else
                    Properties_Enable_Prop_Volumes(hwnd, FALSE);
                Properties_Init_PROP_VOLUMELIST(ppr, hwnd);
            }
            break;
            
        case IDC_PROP_PLAYBACK:
            EnableWindow(GetDlgItem(hwnd, IDC_PROP_OTHERLIST), FALSE);
            if (ppr->dwDestSel == ppr->pdpCurSel->dwPlayback)
                break;
            ppr->dwDestSel = ppr->pdpCurSel->dwPlayback;            
            Properties_Init_PROP_VOLUMELIST(ppr, hwnd);
            break;
            
        case IDC_PROP_RECORDING:
            EnableWindow(GetDlgItem(hwnd, IDC_PROP_OTHERLIST), FALSE);
            if (ppr->dwDestSel == ppr->pdpCurSel->dwRecording)
                break;
            ppr->dwDestSel = ppr->pdpCurSel->dwRecording;
            Properties_Init_PROP_VOLUMELIST(ppr, hwnd);            
            break;
            
        case IDC_PROP_OTHER:
        {
            HWND        hol;
            DWORD       dwSel;
            
            hol = GetDlgItem(hwnd, IDC_PROP_OTHERLIST);
            EnableWindow(hol, TRUE);
            ComboBox_SetCurSel(hol, 0);
            dwSel = (DWORD)ComboBox_GetItemData(hol, 0);
            
            if (ppr->dwDestSel == dwSel)
                break;

            ppr->dwDestSel = dwSel;
            Properties_Init_PROP_VOLUMELIST(ppr, hwnd);
            break;
        }
        case IDC_PROP_OTHERLIST:
            if (unotify == CBN_SELCHANGE)
            {
                int         idst;
                DWORD       dwSel;
                
                idst = ComboBox_GetCurSel(hctl);
                dwSel = (DWORD)ComboBox_GetItemData(hctl, idst);
                if (ppr->dwDestSel == dwSel)
                    break;
                ppr->dwDestSel = dwSel;
                Properties_Init_PROP_VOLUMELIST(ppr, hwnd);
            }
            break;
        case IDOK:
            //
            // Save out to registry for restaring.
            //
            Properties_CommitState(ppr, GetDlgItem(hwnd, IDC_PROP_VOLUMELIST));

            ppr->uDeviceID      = ppr->pdpCurSel->uDeviceID;
            ppr->fMixer         = TRUE;
            ppr->dwDestination  = ppr->dwDestSel;
            EndDialog(hwnd, TRUE);
            break;
            
        case IDCANCEL:
            Mixer_CleanupVolumeDescription(ppr->avcd, ppr->cvcd);
            if (ppr->avcd)
            {
                GlobalFreePtr(ppr->avcd);
                ppr->avcd = NULL;
                ppr->cvcd = 0L;
            }
            EndDialog(hwnd, FALSE);
            break;
    }
    return FALSE;
}


/*
 * Initialize the dialog
 *
 * */
BOOL Properties_OnInitDialog(
    HWND            hwnd,
    HWND            hwndFocus,
    LPARAM          lParam)
{
    PPRIVPROP       ppr;
    BOOL            fEnable = TRUE;
    HWND            hlv;
    
    SETPROP(hwnd, (PPRIVPROP)lParam);
    
    ppr = GETPROP(hwnd);
    
    if (!ppr)
        fEnable = FALSE;
    
    if (fEnable)
        fEnable = Properties_Init_PROP_DEVICELIST(ppr, hwnd);

    hlv = GetDlgItem(hwnd, IDC_PROP_VOLUMELIST);
    
    if (!fEnable)
    {
        //
        // Bad state, disable everything except cancel
        //
        Properties_Enable_PROP_DEVICELIST(hwnd, FALSE);        
        Properties_Enable_Prop_Volumes(hwnd, FALSE);
        Properties_Enable_PROP_VOLUMELIST(hwnd, FALSE);
        EnableOk(hwnd, FALSE);
        return FALSE;
    }
    else
    {
        int             i;
        PDEVICEPROP     pdp;
        HWND            hdl;

        //
        // make intial device selection
        //
        hdl = GetDlgItem(hwnd, IDC_PROP_DEVICELIST);

        ppr->dwDestSel = 0;
        ComboBox_SetCurSel(hdl, 0);
        ppr->pdpCurSel = (PDEVICEPROP)ComboBox_GetItemData(hdl, 0);
        i = ComboBox_GetCount(hdl);
        
        for (; i > 0 ; i-- )
        {
            pdp = (PDEVICEPROP)ComboBox_GetItemData(hdl,i-1);
            //
            // if things match up, then set the init data
            //
            if (pdp->uDeviceID == ppr->uDeviceID
                && pdp->fMixer == ppr->fMixer)
            {
                ppr->pdpCurSel = pdp;
                ComboBox_SetCurSel(hdl, i-1);
                ppr->dwDestSel = ppr->dwDestination;
                break;
            }
        }
    }

    Properties_Init_Prop_Volumes(ppr, hwnd);
    Properties_Init_PROP_VOLUMELIST(ppr, hwnd);
    
    return FALSE;
}



INT_PTR CALLBACK Properties_Proc(
    HWND            hwnd,
    UINT            msg,
    WPARAM          wparam,
    LPARAM          lparam)
{
    extern TCHAR gszHelpFileName[];
#include "helpids.h"
    static const DWORD aHelpIds[] = {
        IDC_PROP_TXT1,          IDH_SNDVOL32_SELECT_DEVICE,
        IDC_PROP_DEVICELIST,    IDH_SNDVOL32_SELECT_DEVICE,
        IDC_PROP_VOLUMES,       IDH_SNDVOL32_SELECT_SOUND,
        IDC_PROP_PLAYBACK,      IDH_SNDVOL32_SELECT_SOUND,
        IDC_PROP_RECORDING,     IDH_SNDVOL32_SELECT_SOUND,
        IDC_PROP_OTHER,         IDH_SNDVOL32_SELECT_SOUND,
        IDC_PROP_OTHERLIST,     IDH_SNDVOL32_SELECT_SOUND,
        IDC_PROP_TXT2,          IDH_SNDVOL32_VOLCONTROL,
        IDC_PROP_VOLUMELIST,    IDH_SNDVOL32_VOLCONTROL,
        0,                      0
    };
    switch (msg)
    {
        case WM_CONTEXTMENU:
            WinHelp((HWND)wparam, gszHelpFileName, HELP_CONTEXTMENU,
                (UINT_PTR)(LPSTR)aHelpIds);
            break;
            
        case WM_HELP:
        {
            LPHELPINFO lphi = (LPVOID) lparam;
            WinHelp (lphi->hItemHandle, gszHelpFileName, HELP_WM_HELP,
                (UINT_PTR) (LPSTR) aHelpIds);
            return TRUE;
        }            
                
        case WM_INITDIALOG:
            HANDLE_WM_INITDIALOG(hwnd, wparam, lparam, Properties_OnInitDialog);
            return TRUE;
            
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wparam, lparam, Properties_OnCommand);
            break;

        case WM_CLOSE:
            EndDialog(hwnd, FALSE);
            break;

        case WM_DESTROY:
        {
            PPRIVPROP ppr = GETPROP(hwnd);
            if (ppr)
            {
                if (ppr->adp)
                {
                    GlobalFreePtr(ppr->adp);
                    ppr->adp = NULL;
                }
                REMOVEPROP(hwnd);
            }
            break;
        }

        case WM_NOTIFY:
        {
            NMHDR FAR* lpnm = (NMHDR FAR *)lparam;
            if ((LVN_ITEMCHANGED == lpnm->code) && hwnd)
            {
                HWND hwndLV = GetDlgItem (hwnd, IDC_PROP_VOLUMELIST);
                if (hwndLV)
                {
                    int nItems = ListView_GetItemCount (hwndLV);
                    int indx;

                    for (indx = 0; indx < nItems; indx++)
                        if (ListView_GetCheckState (hwndLV, indx))
                            break;

                    EnableOk (hwnd, nItems != indx);
                }
			}
            break;
        }
    }
    return FALSE;
}

BOOL Properties(
    PMIXUIDIALOG    pmxud,
    HWND            hwnd)
{
    INT_PTR         iret;
    PRIVPROP        pr;

    ZeroMemory(&pr, sizeof(pr));
    pr.dwDestination = pmxud->iDest;
    pr.uDeviceID     = pmxud->mxid;
    pr.fMixer        = pmxud->dwFlags & MXUD_FLAGSF_MIXER;
    pr.dwStyle       = pmxud->dwStyle;
                      
    pr.pmxud         = pmxud;

    iret = DialogBoxParam(pmxud->hInstance
                          , MAKEINTRESOURCE(IDD_PROPERTIES)
                          , hwnd
                          , Properties_Proc
                          , (LPARAM)(LPVOID)&pr );

    if (iret == TRUE)
    {
        pmxud->mxid     = pr.uDeviceID;
        pmxud->iDest    = pr.dwDestination;
        pmxud->dwFlags  &= ~MXUD_FLAGSF_MIXER;
        pmxud->dwFlags  |= (pr.fMixer)?MXUD_FLAGSF_MIXER:0L;
        pmxud->dwStyle  = pr.dwStyle;
    }    

    return (iret == -1) ? FALSE : TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mixerapp\nonmixer.c ===
/*****************************************************************************
 *
 *  Component:  sndvol32.exe
 *  File:       nonmixer.c
 *  Purpose:    non-mixer api specific implementations
 * 
 *  Copyright (c) 1985-1995 Microsoft Corporation
 *
 *****************************************************************************/
/*
 * These are the volume control api's we have to work with.
 * 
 * WINMMAPI MMRESULT WINAPI midiOutGetVolume(HMIDIOUT hmo, LPDWORD pdwVolume);
 * WINMMAPI MMRESULT WINAPI midiOutSetVolume(HMIDIOUT hmo, DWORD dwVolume);
 * WINMMAPI MMRESULT WINAPI waveOutGetVolume(UINT uId, LPDWORD pdwVolume);
 * WINMMAPI MMRESULT WINAPI waveOutSetVolume(UINT uId, DWORD dwVolume);
 * WINMMAPI MMRESULT WINAPI auxSetVolume(UINT uDeviceID, DWORD dwVolume);
 * WINMMAPI MMRESULT WINAPI auxGetVolume(UINT uDeviceID, LPDWORD pdwVolume);
 *
 * */

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>

#include "volumei.h"

#define STRSAFE_LIB
#include <strsafe.h>

int Nonmixer_GetNumDevs()
{
    UINT    cNumDevs = 0;
    int     iDev;
    UINT    uMxID;
    BOOL    fAdd = FALSE;
    
    //
    // Is aux support required?
    //
    iDev = auxGetNumDevs();
    for (;iDev > 0; iDev --)
    {
        if (mixerGetID((HMIXEROBJ)IntToPtr(iDev-1)
                       , &uMxID
                       , MIXER_OBJECTF_AUX) == MMSYSERR_NODRIVER)
        {
            AUXCAPS     axcaps;
            
            if (auxGetDevCaps(iDev-1, &axcaps, sizeof(AUXCAPS))
                == MMSYSERR_NOERROR)
            {
                if (axcaps.dwSupport & AUXCAPS_VOLUME)
                    fAdd = TRUE;
            }
        }
    }
    if (fAdd)
        cNumDevs++;

    iDev = midiOutGetNumDevs();
    for (; iDev > 0; iDev --)
    {
        if (mixerGetID((HMIXEROBJ)IntToPtr(iDev-1)
                       , &uMxID
                       , MIXER_OBJECTF_MIDIOUT) == MMSYSERR_NODRIVER)
        {
            MIDIOUTCAPS     mocaps;
            
            if (midiOutGetDevCaps(iDev-1, &mocaps, sizeof(MIDIOUTCAPS))
                == MMSYSERR_NOERROR)
            {
                if ((mocaps.dwSupport & MIDICAPS_VOLUME) ||
                    (mocaps.dwSupport & MIDICAPS_LRVOLUME))
                    fAdd = TRUE;
            }
        }
    }
    if (fAdd)
        cNumDevs++;
    
    iDev = waveOutGetNumDevs();
    for (; iDev > 0; iDev --)
    {
        if (mixerGetID((HMIXEROBJ)IntToPtr(iDev-1)
                       , &uMxID
                       , MIXER_OBJECTF_WAVEOUT) == MMSYSERR_NODRIVER)
        {
            WAVEOUTCAPS     wocaps;
            
            if (waveOutGetDevCaps(iDev-1, &wocaps, sizeof(WAVEOUTCAPS))
                == MMSYSERR_NOERROR)
            {
                if ((wocaps.dwSupport & WAVECAPS_VOLUME) ||
                    (wocaps.dwSupport & WAVECAPS_LRVOLUME))
                    fAdd = TRUE;
            }
        }
    }
    if (fAdd)
        cNumDevs++;

    return cNumDevs;
    
}

void Nonmixer_SetLines(
    PVOLCTRLDESC    pvcd)
{
    ;
}

const TCHAR szAuxIn[]	= TEXT ("Aux-In");
const TCHAR szCD[]		= TEXT ("CDROM");
const TCHAR szAux[]		= TEXT ("Aux");
const TCHAR szMidiOut[] = TEXT ("Midi-Out");
                    

/*
 * Nonmixer_CreateVolumeDescription
 *
 * Return an array of volumedescriptions
 *
 */
PVOLCTRLDESC Nonmixer_CreateVolumeDescription (
    int             iDest,
    DWORD *         pcvcd )
{
    int             iDev;
    PVOLCTRLDESC    pvcd = NULL;
    UINT            uMxID;
    DWORD           cLines = 0;
    
    //
    // aux's
    //

    for (iDev = auxGetNumDevs(); iDev > 0; iDev --)
    {
        if (mixerGetID((HMIXEROBJ)IntToPtr(iDev-1)
                       , &uMxID
                       , MIXER_OBJECTF_AUX) == MMSYSERR_NODRIVER)
        {
            AUXCAPS     axcaps;
            
            if (auxGetDevCaps(iDev-1, &axcaps, sizeof(AUXCAPS))
                == MMSYSERR_NOERROR)
            {
                if (axcaps.dwSupport & AUXCAPS_VOLUME)
                {
                    LPCTSTR pszLabel;
                    DWORD dwSupport = 0L;
                    
                    pszLabel = szAux;
                    
                    pszLabel = axcaps.wTechnology & AUXCAPS_CDAUDIO
                               ? szCD : pszLabel;
                    pszLabel = axcaps.wTechnology & AUXCAPS_AUXIN
                               ? szAuxIn : pszLabel;

                    dwSupport |= axcaps.dwSupport & AUXCAPS_LRVOLUME ? VCD_SUPPORTF_STEREO : VCD_SUPPORTF_MONO;
                    
                    pvcd = PVCD_AddLine(pvcd
                                        , iDev
                                        , VCD_TYPE_AUX
                                        , axcaps.szPname
                                        , (LPTSTR)pszLabel
                                        , dwSupport
                                        , &cLines );
                                      
                }
            }
        }
    }
    
    for (iDev = midiOutGetNumDevs(); iDev > 0; iDev --)
    {
        if (mixerGetID((HMIXEROBJ)IntToPtr(iDev-1)
                       , &uMxID
                       , MIXER_OBJECTF_MIDIOUT) == MMSYSERR_NODRIVER)
        {
            MIDIOUTCAPS     mocaps;
            
            if (midiOutGetDevCaps(iDev-1, &mocaps, sizeof(MIDIOUTCAPS))
                == MMSYSERR_NOERROR)
            {
                if (mocaps.dwSupport & MIDICAPS_VOLUME)
                {
                    DWORD dwSupport = 0L;

                    dwSupport |= mocaps.dwSupport & MIDICAPS_LRVOLUME ? VCD_SUPPORTF_STEREO : VCD_SUPPORTF_MONO;
                    
                    pvcd = PVCD_AddLine(pvcd
                                        , iDev
                                        , VCD_TYPE_MIDIOUT
                                        , mocaps.szPname
                                        , (LPTSTR)szMidiOut
                                        , dwSupport
                                        , &cLines );
                }
            }
        }
    }
    
    iDev = waveOutGetNumDevs();
    for (; iDev > 0; iDev --)
    {
        if (mixerGetID((HMIXEROBJ)IntToPtr(iDev-1)
                       , &uMxID
                       , MIXER_OBJECTF_WAVEOUT) == MMSYSERR_NODRIVER)
        {
            WAVEOUTCAPS     wocaps;
            
            if (waveOutGetDevCaps(iDev-1, &wocaps, sizeof(WAVEOUTCAPS))
                == MMSYSERR_NOERROR)
            {
                if (wocaps.dwSupport & WAVECAPS_VOLUME)
                {
                    const TCHAR szWaveOut[] = TEXT ("Wave-Out");
                    DWORD dwSupport = 0L;
                    
                    dwSupport |= wocaps.dwSupport & WAVECAPS_LRVOLUME ? VCD_SUPPORTF_STEREO : VCD_SUPPORTF_MONO;

                    pvcd = PVCD_AddLine(pvcd
                                        , iDev
                                        , VCD_TYPE_WAVEOUT
                                        , wocaps.szPname
                                        , (LPTSTR)szWaveOut
                                        , dwSupport
                                        , &cLines );
                }
            }
        }
    }

    //
    // Setup indicies, etc...
    //
    Nonmixer_SetLines(pvcd);
    
    *pcvcd = cLines;
    
    return pvcd;
}

void Nonmixer_PollingUpdate(
    PMIXUIDIALOG pmxud)
{
    
}
BOOL Nonmixer_Init(
    PMIXUIDIALOG pmxud)
{
    return TRUE;
}

void Nonmixer_GetControl(
    PMIXUIDIALOG    pmxud,
    HWND            hctl,
    int             imxul,
    int             ictl)
{
    ;
}

void Nonmixer_SetControl(
    PMIXUIDIALOG    pmxud,
    HWND            hctl,
    int             imxul,
    int             ictl)
{
    ;
}

void Nonmixer_Shutdown(
    PMIXUIDIALOG    pmxud)
{
    ;
}

const TCHAR szNonMixer[] = TEXT ("Wave,MIDI,Aux");
BOOL Nonmixer_GetDeviceName(
    PMIXUIDIALOG    pmxud)
{
	HRESULT hr = StringCchCopy( pmxud->szMixer, SIZEOF(pmxud->szMixer), szNonMixer );
	if( hr == S_OK )
	{
	    return TRUE;
	}

	pmxud->szMixer[0] = TEXT('\0');
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mixerapp\pvcd.c ===
/*****************************************************************************
 *
 *  Component:  sndvol32.exe
 *  File:       pvcd.c
 *  Purpose:    volume control line meta description
 * 
 *  Copyright (c) 1985-1995 Microsoft Corporation
 *
 *****************************************************************************/
#include <windows.h>
#include <mmsystem.h>
#include <windowsx.h>

#include "volumei.h"

#define STRSAFE_LIB
#include <strsafe.h>

PVOLCTRLDESC PVCD_AddLine(
    PVOLCTRLDESC        pvcd,
    int                 iDev,
    DWORD               dwType,
    LPTSTR              szShortName,
    LPTSTR              szName,
    DWORD               dwSupport,
    DWORD               *cLines)
{
    PVOLCTRLDESC        pvcdNew;
    
    if (pvcd)
    {
        pvcdNew = (PVOLCTRLDESC)GlobalReAllocPtr(pvcd, (*cLines+1)*sizeof(VOLCTRLDESC), GHND );
    }
    else
    {
        pvcdNew = (PVOLCTRLDESC)GlobalAllocPtr(GHND, (*cLines+1)*sizeof(VOLCTRLDESC));
    }
    
    if (!pvcdNew)
        return NULL;

    pvcdNew[*cLines].iVCD       = *cLines;
    pvcdNew[*cLines].iDeviceID  = iDev;
    pvcdNew[*cLines].dwType     = dwType;
    pvcdNew[*cLines].dwSupport  = dwSupport;

    StringCchCopy(pvcdNew[*cLines].szShortName
             , SIZEOF(pvcdNew[*cLines].szShortName)
             , szShortName);
    
    StringCchCopy(pvcdNew[*cLines].szName
             , SIZEOF(pvcdNew[*cLines].szName)
             , szName);

    *cLines = *cLines + 1;
    return pvcdNew;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mixerapp\pvcd.h ===
/*****************************************************************************
 *
 *  Component:  sndvol32.exe
 *  File:       pvcd.h
 *  Purpose:    Volume Control Descriptor
 *
 *  Copyright (c) 1985-1995 Microsoft Corporation
 *
 *****************************************************************************/

#define VCD_TYPE_MIXER          0
#define VCD_TYPE_AUX            1
#define VCD_TYPE_WAVEOUT        2
#define VCD_TYPE_MIDIOUT        3

#define VCD_SUPPORTF_STEREO     0x00000000
#define VCD_SUPPORTF_MONO       0x00000001
#define VCD_SUPPORTF_DISABLED   0x00000002
#define VCD_SUPPORTF_HIDDEN     0x00000004  // hidden by choice
#define VCD_SUPPORTF_BADDRIVER  0x00000008
#define VCD_SUPPORTF_VISIBLE    0x00000010  // not visible (i.e. no controls)
#define VCD_SUPPORTF_DEFAULT    0x00000020  // default type

#define VCD_SUPPORTF_MIXER_MUTE       0x00010000
#define VCD_SUPPORTF_MIXER_METER      0x00020000
#define VCD_SUPPORTF_MIXER_MUX        0x00040000
#define VCD_SUPPORTF_MIXER_MIXER      0x00080000
#define VCD_SUPPORTF_MIXER_VOLUME     0x00100000
#define VCD_SUPPORTF_MIXER_ADVANCED   0x80000000

#define VCD_VISIBLEF_MIXER_MUTE       0x00000001
#define VCD_VISIBLEF_MIXER_METER      0x00000002
#define VCD_VISIBLEF_MIXER_MUX        0x00000004
#define VCD_VISIBLEF_MIXER_MIXER      0x00000008
#define VCD_VISIBLEF_MIXER_VOLUME     0x00000010
#define VCD_VISIBLEF_MIXER_ADVANCED   0x00008000


//
// The generic volume control descriptor
//
typedef struct t_VOLCTRLDESC {
    //
    // for all
    //
    int         iVCD;                   // descriptor index
    UINT        iDeviceID;              // device identifier

    DWORD       dwType;                 // type bits
    DWORD       dwSupport;              // support bits
    DWORD       dwVisible;              // control visibility flags

    TCHAR       szShortName[MIXER_SHORT_NAME_CHARS];     // short name
    TCHAR       szName[MIXER_LONG_NAME_CHARS];      // line label

    struct t_MIXUILINE * pmxul;         // back pointer to a ui

    union {
        struct {

            //
            // for mixer
            //

            HMIXER      hmx;            // open device handle

            BOOL        fIsSource;      // is source line
            DWORD       dwDest;         // destination index
            DWORD       dwSrc;          // source index
            DWORD       dwLineID;       // mixer line id

            DWORD       dwVolumeID;     // VOLUME control id
            DWORD       fdwVolumeControl; // Control flags for Volume control

            //
            // For mixers and mux
            //

            DWORD       dwMuteID;       // MUTE control id
            DWORD       fdwMuteControl; // Control flags for Mute control
            DWORD       dwMeterID;      // PEAKMETER control id

            DWORD       dwMixerID;      // MUX/MIXER control id
            DWORD       iMixer;         // mixer index
            DWORD       cMixer;         // mixer controls
            PMIXERCONTROLDETAILS_BOOLEAN amcd_bMixer;// mixer array

            DWORD       dwMuxID;        // MUX/MIXER control id
            DWORD       iMux;           // mux index
            DWORD       cMux;           // mux controls
            PMIXERCONTROLDETAILS_BOOLEAN amcd_bMux;// mux array

            double*     pdblCacheMix;   // Volume Channel mix cache

        };
        struct {

            //
            // for wave
            //

            HWAVEOUT    hwo;            // open device handle
        };
        struct {

            //
            // for midi
            //

            HMIDIOUT    hmo;            // open device handle
        };
        struct {

            //
            // for aux
            //

            DWORD       dwParam;        // nothing
        };
    };

} VOLCTRLDESC, *PVOLCTRLDESC;

extern PVOLCTRLDESC Mixer_CreateVolumeDescription(HMIXEROBJ hmx, int iDest, DWORD *pcvcd);
extern void Mixer_CleanupVolumeDescription(PVOLCTRLDESC avcd, DWORD cvcd);

extern int  Mixer_GetNumDevs(void);
extern BOOL Mixer_Init(PMIXUIDIALOG pmxud);
extern void Mixer_GetControlFromID(PMIXUIDIALOG pmxud, DWORD dwControlID);
extern void Mixer_GetControl(PMIXUIDIALOG pmxud, HWND hctl, int imxul, int ictl);
extern void Mixer_SetControl(PMIXUIDIALOG pmxud, HWND hctl, int imxul, int ictl);
extern void Mixer_PollingUpdate(PMIXUIDIALOG pmxud);
extern void Mixer_Shutdown(PMIXUIDIALOG pmxud);
extern BOOL Mixer_GetDeviceName(PMIXUIDIALOG pmxud);
extern BOOL Mixer_IsValidRecordingDestination (HMIXEROBJ hmx, MIXERLINE* pmlDst);

extern PVOLCTRLDESC Nonmixer_CreateVolumeDescription(int iDest, DWORD *pcvcd);
extern int  Nonmixer_GetNumDevs(void);
extern BOOL Nonmixer_Init(PMIXUIDIALOG pmxud);
extern void Nonmixer_GetControl(PMIXUIDIALOG pmxud, HWND hctl, int imxul, int ictl);
extern void Nonmixer_SetControl(PMIXUIDIALOG pmxud, HWND hctl, int imxul, int ictl);
extern void Nonmixer_PollingUpdate(PMIXUIDIALOG pmxud);
extern void Nonmixer_Shutdown(PMIXUIDIALOG pmxud);
extern BOOL Nonmixer_GetDeviceName(PMIXUIDIALOG pmxud);

extern PVOLCTRLDESC PVCD_AddLine(PVOLCTRLDESC pvcd, int iDev, DWORD dwType, LPTSTR szProduct, LPTSTR szLabel, DWORD dwSupport, DWORD *cLines);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mixerapp\reg.c ===
/*****************************************************************************
 *
 *  Component:  sndvol32.exe
 *  File:       reg.c
 *  Purpose:    registry access functions
 * 
 *  Copyright (c) 1985-1995 Microsoft Corporation
 *
 *****************************************************************************/
#include <windows.h>
#include <regstr.h>

// Note: The following line generates a UNICODE error
//       so it has been replaced by the line after.
//const TCHAR szRegPath[] = REGSTR_PATH_WINDOWSAPPLETS "\\Volume Control";
const TCHAR szRegPath[] = TEXT ("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Volume Control");


/* ReadRegistryData
 *
 * Reads information from the registry
 *
 * Parameters:
 *
 *     pEntryNode - The node under Media Player which should be opened
 *         for this data.  If this is NULL, the value is
 *         written directly under szRegPath.
 *
 *     pEntryName - The name of the value under pEntryNode to be retrieved.
 *
 *     pType - Pointer to a buffer to receive type of data read.  May be NULL.
 *
 *     pData - Pointer to a buffer to receive the value data.
 *
 *     Size - Size, in bytes, of the buffer pointed to by pData.
 *
 * Return:
 *
 *     Registry status return (NO_ERROR is good)
 *
 *
 * Andrew Bell (andrewbe) wrote it, 10 September 1992
 *
 */
DWORD ReadRegistryData( LPTSTR pEntryNode,
                        LPTSTR pEntryName,
                        PDWORD pType,
                        LPBYTE pData,
                        DWORD  DataSize )
{
    DWORD  Status;
    HKEY   hkeyRegPath;
    HKEY   hkeyEntryNode;
    DWORD  Size;

    /* Open the top-level node.  For Media Player this is:
     * "Software\\Microsoft\\Windows NT\\CurrentVersion\\Sound Recorder"
     */
    Status = RegOpenKeyEx( HKEY_CURRENT_USER, szRegPath, 0,
                           KEY_READ, &hkeyRegPath );

    if( Status == NO_ERROR )
    {
        /* Open the sub-node:
         */
        if( pEntryNode )
            Status = RegOpenKeyEx( hkeyRegPath, pEntryNode, 0,
                                   KEY_READ, &hkeyEntryNode );
        else
            hkeyEntryNode = hkeyRegPath;

        if( Status == NO_ERROR )
        {
            Size = DataSize;

            /* Read the entry from the registry:
             */
            Status = RegQueryValueEx( hkeyEntryNode,
                                      pEntryName,
                                      0,
                                      pType,
                                      pData,
                                      &Size );

            if( pEntryNode )
                RegCloseKey( hkeyEntryNode );
        }

        RegCloseKey( hkeyRegPath );
    }
    return Status;
}
DWORD QueryRegistryDataSizeAndType(
    LPTSTR  pEntryNode,
    LPTSTR  pEntryName,
	DWORD	dwType,
    DWORD   *pDataSize )
{
    DWORD  Status;
    HKEY   hkeyRegPath;
    HKEY   hkeyEntryNode;
    DWORD  Size;
	DWORD  Type;

    /* Open the top-level node.  For Media Player this is:
     * "Software\\Microsoft\\Windows NT\\CurrentVersion\\Sound Recorder"
     */
    Status = RegOpenKeyEx( HKEY_CURRENT_USER, szRegPath, 0,
                           KEY_READ, &hkeyRegPath );

    if( Status == NO_ERROR )
    {
        /* Open the sub-node:
         */
        if( pEntryNode )
            Status = RegOpenKeyEx( hkeyRegPath, pEntryNode, 0,
                                   KEY_READ, &hkeyEntryNode );
        else
            hkeyEntryNode = hkeyRegPath;

        if( Status == NO_ERROR )
        {
            /* Read the entry from the registry:
             */
            Size = 0;
            Status = RegQueryValueEx( hkeyEntryNode,
                                      pEntryName,
                                      0,
                                      &Type,
                                      NULL,
                                      &Size );
			if( Status == NO_ERROR)
			{
				if( Type == dwType )
				{
					if( pDataSize )
				        *pDataSize = Size;
				}
				else
				{
					Status = ERROR_BAD_FORMAT;
				}
			}

            if( pEntryNode )
                RegCloseKey( hkeyEntryNode );
        }

        RegCloseKey( hkeyRegPath );
    }
    return Status;
}
/* WriteRegistryData
 *
 * Writes a bunch of information to the registry
 *
 * Parameters:
 *
 *     pEntryNode - The node under szRegPath which should be created
 *         or opened for this data.  If this is NULL, the value is
 *         written directly under szRegPath.
 *
 *     pEntryName - The name of the value under pEntryNode to be set.
 *
 *     Type - Type of data to read (e.g. REG_SZ).
 *
 *     pData - Pointer to the value data to be written.  If this is NULL,
 *         the value under pEntryNode is deleted.
 *
 *     Size - Size, in bytes, of the buffer pointed to by pData.
 *
 *
 * This routine is fairly generic, apart from the name of the top-level node.
 *
 * The data are stored in the following registry tree:
 *
 * HKEY_CURRENT_USER
 *  
 *   Software
 *      
 *       Microsoft
 *          
 *           Windows NT
 *              
 *               CurrentVersion
 *                  
 *                   Media Player
 *                      
 *                       AVIVideo
 *                      
 *                       DisplayPosition
 *                      
 *                       SysIni
 *
 *
 * Return:
 *
 *     Registry status return (NO_ERROR is good)
 *
 *
 * Andrew Bell (andrewbe) wrote it, 10 September 1992
 *
 */
DWORD WriteRegistryData( LPTSTR pEntryNode,
                         LPTSTR pEntryName,
                         DWORD  Type,
                         LPBYTE pData,
                         DWORD  Size )
{
    DWORD  Status;
    HKEY   hkeyRegPath;
    HKEY   hkeyEntryNode;

    /* Open or create the top-level node.  For Media Player this is:
     * "Software\\Microsoft\\Windows NT\\CurrentVersion\\Media Player"
     */
    Status = RegCreateKeyEx( HKEY_CURRENT_USER, szRegPath, 0,
                             NULL, 0, KEY_WRITE, NULL, &hkeyRegPath, NULL );

    if( Status == NO_ERROR )
    {
        /* Open or create the sub-node.
         */
        if( pEntryNode )
            Status = RegCreateKeyEx( hkeyRegPath, pEntryNode, 0,
                                     NULL, 0, KEY_WRITE, NULL, &hkeyEntryNode, NULL );
        else
            hkeyEntryNode = hkeyRegPath;

        if( Status == NO_ERROR )
        {
            if( pData )
            {
                Status = RegSetValueEx( hkeyEntryNode,
                                        pEntryName,
                                        0,
                                        Type,
                                        pData,
                                        Size );

            }
            else
            {
                Status = RegDeleteValue( hkeyEntryNode, pEntryName );
            }

            if( pEntryNode )
                RegCloseKey( hkeyEntryNode );
        }

        RegCloseKey( hkeyRegPath );
    }


    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mixerapp\utils.c ===
/*****************************************************************************
 *
 *  Component:  sndvol32.exe
 *  File:       utils.c
 *  Purpose:    miscellaneous 
 * 
 *  Copyright (c) 1985-1999 Microsoft Corporation
 *
 *****************************************************************************/
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>

#include "volumei.h"
#include "volids.h"
#include "mmddkp.h"

#define STRSAFE_LIB
#include <strsafe.h>

/*  misc. */

const  TCHAR gszStateSubkey[] = TEXT ("%s\\%s");
static TCHAR gszAppName[256];

BOOL Volume_ErrorMessageBox(
    HWND            hwnd,
    HINSTANCE       hInst,
    UINT            id)
{
    TCHAR szMessage[256];
    BOOL fRet;
    szMessage[0] = 0;

    if (!gszAppName[0])
        LoadString(hInst, IDS_APPBASE, gszAppName, SIZEOF(gszAppName));
    
    LoadString(hInst, id, szMessage, SIZEOF(szMessage));
    fRet = (MessageBox(hwnd
                       , szMessage
                       , gszAppName
                       , MB_APPLMODAL | MB_ICONINFORMATION
                       | MB_OK | MB_SETFOREGROUND) == MB_OK);
    return fRet;
}
                                  
const TCHAR aszXPos[]           = TEXT ("X");
const TCHAR aszYPos[]           = TEXT ("Y");
const TCHAR aszLineInfo[]       = TEXT ("LineStates");

///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
DWORD GetWaveOutID(BOOL *pfPreferred)
{
    MMRESULT        mmr;
    DWORD           dwWaveID=0;
    DWORD           dwFlags = 0;
    
    if (pfPreferred)
    {
        *pfPreferred = TRUE;
    }

    mmr = waveOutMessage((HWAVEOUT)UIntToPtr(WAVE_MAPPER), DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR) &dwWaveID, (DWORD_PTR) &dwFlags);

    if (!mmr && pfPreferred)
    {
        *pfPreferred = dwFlags & 0x00000001;
    }

    return(dwWaveID);
}

///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
DWORD GetWaveInID(BOOL *pfPreferred)
{
    MMRESULT        mmr;
    DWORD           dwWaveID=0;
    DWORD           dwFlags = 0;
    
    if (pfPreferred)
    {
        *pfPreferred = TRUE;
    }

    mmr = waveInMessage((HWAVEIN)UIntToPtr(WAVE_MAPPER), DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR) &dwWaveID, (DWORD_PTR) &dwFlags);

    if (!mmr && pfPreferred)
    {
        *pfPreferred = dwFlags & 0x00000001;
    }

    return(dwWaveID);
}


/*
 * Volume_GetDefaultMixerID
 *
 * Get the default mixer id.  We only appear if there is a mixer associated
 * with the default wave.
 *
 */                                  
MMRESULT Volume_GetDefaultMixerID(
    int         *pid,
	BOOL		fRecord)
{
    MMRESULT    mmr;
    UINT        u, uMxID;
    BOOL        fPreferredOnly = 0;
    
    *pid = 0;
    mmr = MMSYSERR_ERROR;
    
    //
    // We use messages to the Wave Mapper in Win2K to get the preferred device.
    //
	if (fRecord)
	{
        if(waveInGetNumDevs())
        {
            u = GetWaveInID(&fPreferredOnly);
		
            // Can we get a mixer device ID from the wave device?
		    mmr = mixerGetID((HMIXEROBJ)UIntToPtr(u), &uMxID, MIXER_OBJECTF_WAVEIN);
		    if (mmr == MMSYSERR_NOERROR)
		    {
    		    // Return this ID.
			    *pid = uMxID;
		    }
        }
	}
	else
	{
        if(waveOutGetNumDevs())
        {
            u = GetWaveOutID(&fPreferredOnly);
		
            // Can we get a mixer device ID from the wave device?
		    mmr = mixerGetID((HMIXEROBJ)UIntToPtr(u), &uMxID, MIXER_OBJECTF_WAVEOUT);
		    if (mmr == MMSYSERR_NOERROR)
		    {
			    // Return this ID.
			    *pid = uMxID;
		    }
        }
	}
        
    return mmr;
}

            
const TCHAR aszOptionsSection[]  = TEXT ("Options");
/*
 * Volume_GetSetStyle
 *
 * */
void Volume_GetSetStyle(
    DWORD       *pdwStyle,
    BOOL        Get)
{
    const TCHAR aszStyle[]           = TEXT ("Style");
    
    if (Get)
	{
        if (QueryRegistryDataSizeAndType((LPTSTR)aszOptionsSection
										 , (LPTSTR)aszStyle
										 , REG_DWORD
										 , NULL) == NO_ERROR)
		{
			ReadRegistryData((LPTSTR)aszOptionsSection
				             , (LPTSTR)aszStyle
					         , NULL
						     , (LPBYTE)pdwStyle
							 , sizeof(DWORD));
		}
	}
    else
	{
        WriteRegistryData((LPTSTR)aszOptionsSection
                          , (LPTSTR)aszStyle
                          , REG_DWORD
                          , (LPBYTE)pdwStyle
                          , sizeof(DWORD));
	}
}

/*
 * Volume_GetTrayTimeout
 *
 * */
//DWORD Volume_GetTrayTimeout(
//    DWORD       dwTimeout)
//{
//    const TCHAR aszTrayTimeout[]     = TEXT ("TrayTimeout");
//    DWORD dwT = dwTimeout;
//    ReadRegistryData(NULL
//                     , (LPTSTR)aszTrayTimeout
//                     , NULL
//                     , (LPBYTE)&dwT
//                     , sizeof(DWORD));
//    return dwT;
//}

/*
 * Volume_GetSetRegistryLineStates
 *
 * Get/Set line states s.t. lines can be disabled if not used.
 *
 * */
struct LINESTATE {
    DWORD   dwSupport;
    TCHAR   szName[MIXER_LONG_NAME_CHARS];
};

#define VCD_STATEMASK   (VCD_SUPPORTF_VISIBLE|VCD_SUPPORTF_HIDDEN)

BOOL Volume_GetSetRegistryLineStates(
    LPTSTR      pszMixer,
    LPTSTR      pszDest,
    PVOLCTRLDESC avcd,
    DWORD       cvcd,
    BOOL        Get)
{
    struct LINESTATE *  pls;
    DWORD       ils, cls;
    TCHAR       achEntry[128];

    if (cvcd == 0)
        return TRUE;
    
    StringCchPrintf(achEntry, SIZEOF(achEntry), gszStateSubkey, pszMixer, pszDest);
    
    if (Get)
    {
        UINT cb;
        if (QueryRegistryDataSizeAndType((LPTSTR)achEntry
										 , (LPTSTR)aszLineInfo
										 , REG_BINARY
										 , &cb) != NO_ERROR)
            return FALSE;

        pls = (struct LINESTATE *)GlobalAllocPtr(GHND, cb);

        if (!pls)
            return FALSE;
        
        if (ReadRegistryData((LPTSTR)achEntry
                             , (LPTSTR)aszLineInfo
                             , NULL
                             , (LPBYTE)pls
                             , cb) != NO_ERROR)
        {
            GlobalFreePtr(pls);
            return FALSE;
        }

        cls = cb / sizeof(struct LINESTATE);
        if (cls > cvcd)
            cls = cvcd;

        //
        // Restore the hidden state of the line.
        //
        for (ils = 0; ils < cls; ils++)
        {
            if (lstrcmp(pls[ils].szName, avcd[ils].szName) == 0)
            {
                avcd[ils].dwSupport |= pls[ils].dwSupport;
            }
        }
        GlobalFreePtr(pls);
        
    }
    else 
    {
        pls = (struct LINESTATE *)GlobalAllocPtr(GHND, cvcd * sizeof (struct LINESTATE));
        if (!pls)
            return FALSE;

        //
        // Save the hidden state of the line
        //
        for (ils = 0; ils < cvcd; ils++)
        {
            StringCchCopy(pls[ils].szName, SIZEOF(pls[ils].szName), avcd[ils].szName);
            pls[ils].dwSupport = avcd[ils].dwSupport & VCD_SUPPORTF_HIDDEN;

        }

        if (WriteRegistryData((LPTSTR)achEntry
                              , (LPTSTR)aszLineInfo
                              , REG_BINARY
                              , (LPBYTE)pls
                              , cvcd*sizeof(struct LINESTATE)) != NO_ERROR)
        {
            GlobalFreePtr(pls);
            return FALSE;            
        }
        
        GlobalFreePtr(pls);
    }
    
    return TRUE;
}    

/*
 * Volume_GetSetRegistryRect
 *
 * Set/Get window position for restoring the postion of the app window
 * 
 * */
BOOL Volume_GetSetRegistryRect(
    LPTSTR      szMixer,
    LPTSTR      szDest,
    LPRECT      prc,
    BOOL        Get)
{
    TCHAR  achEntry[128];
    
    StringCchPrintf(achEntry, SIZEOF(achEntry), gszStateSubkey, szMixer, szDest);

    if (Get)
    {
        if (QueryRegistryDataSizeAndType((LPTSTR)achEntry
										 , (LPTSTR)aszXPos
										 , REG_DWORD
										 , NULL) != NO_ERROR)
        {
            return FALSE;
        }
        if (ReadRegistryData((LPTSTR)achEntry
                             , (LPTSTR)aszXPos
                             , NULL
                             , (LPBYTE)&prc->left
                             , sizeof(prc->left)) != NO_ERROR)
        {
            return FALSE;
        }
        if (QueryRegistryDataSizeAndType((LPTSTR)achEntry
										 , (LPTSTR)aszYPos
										 , REG_DWORD
										 , NULL) != NO_ERROR)
        {
            return FALSE;
        }
        if (ReadRegistryData((LPTSTR)achEntry
                              , (LPTSTR)aszYPos
                              , NULL
                              , (LPBYTE)&prc->top
                              , sizeof(prc->top)) != NO_ERROR)
        {
            return FALSE;
        }
    }
    else 
    {
        if (prc)
        {
            if (WriteRegistryData((LPTSTR)achEntry
                                  , (LPTSTR)aszXPos
                                  , REG_DWORD
                                  , (LPBYTE)&prc->left
                                  , sizeof(prc->left)) != NO_ERROR)
            {
                return FALSE;            
            }
            if (WriteRegistryData((LPTSTR)achEntry
                                  , (LPTSTR)aszYPos
                                  , REG_DWORD
                                  , (LPBYTE)&prc->top
                                  , sizeof(prc->top)) != NO_ERROR)
            {
                return FALSE;            
            }        
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mixerapp\utils.h ===
// Copyright (c) 1995-1997 Microsoft Corporation

BOOL Volume_GetSetRegistryRect(
    LPTSTR       szMixer,
    LPTSTR       szDest,
    LPRECT       prc,
    BOOL         Get);
BOOL Volume_GetSetRegistryLineStates(
    LPTSTR       pszMixer,
    LPTSTR       pszDest,
    PVOLCTRLDESC pvcd,
    DWORD        cvcd,
    BOOL         Get);
void Volume_GetSetStyle(
    DWORD*       pdwStyle,
    BOOL         Get);
BOOL Volume_ErrorMessageBox(
    HWND         hwnd,
    HINSTANCE    hInst,
    UINT         id);
MMRESULT Volume_GetDefaultMixerID(
    int         *pid,
	BOOL		fRecord);
//DWORD Volume_GetTrayTimeout(
//    DWORD       dwTimeout);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mixerapp\volumei.h ===
// Copyright (c) 1995-1998 Microsoft Corporation

/*
 * Tray notification message
 * */
#define MYWM_BASE               (WM_APP+100)
//#define MYWM_NOTIFYICON         (MYWM_BASE+0)
#define MYWM_TIMER              (MYWM_BASE+1)
#define MYWM_RESTART            (MYWM_BASE+2)
//#define MYWM_FREECHILD          (MYWM_BASE+3)
//#define MYWM_ADDCHILD           (MYWM_BASE+4)
#define MYWM_HELPTOPICS         (MYWM_BASE+5)
#define MYWM_WAKEUP             (MYWM_BASE+6)

/*
 * MMSYS.CPL notifcation to kill tray volume
 * */
//#define MYWM_KILLTRAYVOLUME     (WM_USER+100)
//#define REGSTR_PATH_MEDIA       "SYSTEM\\CurrentControlSet\\Control\\MediaResources"
//#define REGSTR_PATH_MEDIATMP    REGSTR_PATH_MEDIA "\\tmp"
//#define REGKEY_TRAYVOL          "TrayVolumeControlWindow"

/*
 * Upon an option change, the dialog box can force a reinit
 * */
#define MIXUI_EXIT          0
#define MIXUI_RESTART       1
#define MIXUI_ERROR         2
#define MIXUI_MMSYSERR      3


#define GET (TRUE)
#define SET (!GET)
 
#define VOLUME_TICS (500L) // VOLUME_TICS * VOLUME_MAX must be less than 0xFFFFFFFF
#define VOLUME_MIN  (0L)
#define VOLUME_MAX  (65535L)
#define VOLUME_RANGE (VOLUME_MAX - VOLUME_MIN)
#define SLIDER_TO_VOLUME(pos) (VOLUME_MIN + ((VOLUME_RANGE * pos + VOLUME_TICS / 2) / VOLUME_TICS))
#define VOLUME_TO_SLIDER(vol) ((VOLUME_TICS * (vol - VOLUME_MIN) + VOLUME_RANGE / 2) / VOLUME_RANGE)

#define MXUC_STYLEF_VISIBLE     0x00000001
#define MXUC_STYLEF_ENABLED     0x00000002

typedef struct t_MIXUICTRL
{
    DWORD       dwStyle;    // ui style (see style flags)
    HWND        hwnd;       // hwnd to control
    int         state;      // app init state

} MIXUICTRL, * PMIXUICTRL, FAR * LPMIXUICTRL;

typedef enum
{
    MIXUI_VOLUME = 0,
    MIXUI_BALANCE,
    MIXUI_SWITCH,
    MIXUI_VUMETER,
    MIXUI_ADVANCED,
    MIXUI_MULTICHANNEL
} MIXUICONTROL;

typedef enum
{
    MIXUI_CONTROL_UNINITIALIZED = 0,
    MIXUI_CONTROL_ENABLED,
    MIXUI_CONTROL_INITIALIZED
};
 
#define MIXUI_FIRST MIXUI_VOLUME
#define MIXUI_LAST  MIXUI_VUMETER

typedef struct t_MIXUILINE
{
    MIXUICTRL   acr [4];    // 5 fixed types
    DWORD       dwStyle;    // line style
    struct t_VOLCTRLDESC * pvcd;        // ptr to volume description
    
} MIXUILINE, * PMIXUILINE, FAR * LPMIXUILINE;

/*
 * LOWORD == type
 * HIWORD == style
 */
#define MXUL_STYLEF_DESTINATION  0x00000001
#define MXUL_STYLEF_SOURCE       0x00000002
#define MXUL_STYLEF_HIDDEN       0x00010000
#define MXUL_STYLEF_DISABLED     0x00020000

/*
 * The MIXUIDIALOG data structure is a global variable baggage to be
 * attached to dialogs and other windows.  This allows to let windows
 * carry state information rather than us keeping track of it.  It also
 * allows us to simply clone off of another dialog state with simple
 * changes.
 */
typedef struct t_MIXUIDIALOG
{
    HINSTANCE   hInstance;  // app instance
    HWND        hwnd;       // this window

    DWORD       dwFlags;    // random flags    
    
    HMIXER      hmx;        // open handle to mixer
    DWORD       mxid;       // mixer id
    DWORD       dwDevNode;  // mixer dev node
    
    DWORD       iDest;      // destination line id
    DWORD       dwStyle;    // visual options.

    TCHAR       szMixer[MAXPNAMELEN];   // product name
    TCHAR       szDestination[MIXER_SHORT_NAME_CHARS]; // line name

    LPBYTE      lpDialog;   // ptr to dialog template
    DWORD       cbDialog;   // sizeof dialog buffer
    
    PMIXUILINE  amxul;      // ptr to array of mixuiline's
    DWORD       cmxul;      // number of lines
    
    struct t_VOLCTRLDESC *avcd;        // array of volume descriptions
    DWORD       cvcd;       // number of volume descriptions
    
    HWND        hParent;    // HWND of parent window
    UINT        uTimerID;   // peakmeter timer
    HWND        hStatus;    // HWND of status bar

    WNDPROC     lpfnTrayVol;// Tray volume subclass trackbar
    DWORD       dwTrayInfo; // Tray volume info
    
    int         nShowCmd;   // init window

    DWORD       dwDeviceState;  // device change state information

    int         cTimeInQueue;   // timer messages in queue

    //
    // Return values from dialogs, etc.. can be put in dwReturn
    // Upon EndDialog, dwReturn gets set to MIXUI_EXIT or MIXUI_RESTART
    //
    
    DWORD       dwReturn;   // return value on exit
    
    MMRESULT    mmr;        // last result      (iff dwReturn == MIXUI_MMSYSERR)
    RECT        rcRestart;  // restart position (iff dwReturn == MIXUI_RESTART)

    int         cxDlgContent;   // size of dialog content
    int         cxDlgWidth;     // width of dialog
    int         xOffset;        // offset if scrolling is needed
    int         cxScroll;       // amount to scroll by

} MIXUIDIALOG, *PMIXUIDIALOG, FAR *LPMIXUIDIALOG;

/*
 * Style bits - these generally determine the look of the app
 */
#define MXUD_STYLEF_TRAYMASTER  0x00000002  // use the tray
#define MXUD_STYLEF_MASTERONLY  0x00000004  // only destination volumes --obsolete
#define MXUD_STYLEF_HORIZONTAL  0x00000008  // horizontal mode
#define MXUD_STYLEF_TWOCHANNEL  0x00000010  // two channel slider volume
#define MXUD_STYLEF_SMALL       0x00000020  // half-pint version
#define MXUD_STYLEF_CHILD       0x00000040  // child window?    --obsolete
#define MXUD_STYLEF_KEEPWINDOW  0x00000080  // keep window      --obsolete
#define MXUD_STYLEF_NOHELP      0x00000100  // no help
#define MXUD_STYLEF_STATUS      0x00000200  // status bar
#define MXUD_STYLEF_TOPMOST     0x00000400  // top most window
#define MXUD_STYLEF_ADVANCED    0x00000800  // show advanced
#define MXUD_STYLEF_CLOSE       0x00001000  // find and close TRAYMASTER window

/*
 * Flag bits - these generally indicate operating modes and internal info
 */
#define MXUD_FLAGSF_MIXER       0x00000001  // bound to a mixer driver
#define MXUD_FLAGSF_USETIMER    0x00000002  // update timer enabled
#define MXUD_FLAGSF_BADDRIVER   0x00000004  // mixer driver with control map bug
#define MXUD_FLAGSF_NOADVANCED  0x00000008  // advanced features disabled

/*
 * Macro - if both advanced style and advanced state
 */
#define MXUD_ADVANCED(x)    (!((x)->dwFlags & MXUD_FLAGSF_NOADVANCED) && (x)->dwStyle & MXUD_STYLEF_ADVANCED)

/*
 * Tray info bits - state bits for the tray volume
 */
#define MXUD_TRAYINFOF_SIGNAL   0x00000001  // has a change been made?


#define GETMIXUIDIALOG(x)       (MIXUIDIALOG *)GetWindowLongPtr(x, DWLP_USER)
#define SETMIXUIDIALOG(x,y)     SetWindowLongPtr(x, DWLP_USER, y)

DWORD ReadRegistryData( LPTSTR pEntryNode,
			LPTSTR pEntryName,
			PDWORD pType,
			LPBYTE pData,
			DWORD  DataSize );

DWORD WriteRegistryData( LPTSTR pEntryNode,
			 LPTSTR pEntryName,
			 DWORD  Type,
			 LPBYTE pData,
			 DWORD  Size );
DWORD QueryRegistryDataSizeAndType( LPTSTR  pEntryNode,
			    LPTSTR  pEntryName,
				DWORD   dwType,
			    DWORD   *pDataSize );

int Volume_NumDevs(void);
HWND Volume_GetLineItem(HWND, DWORD, DWORD);

BOOL Properties(PMIXUIDIALOG pmxud, HWND hwnd);

#define HANDLE_WM_XSCROLL(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(lParam), (UINT)(LOWORD(wParam)),  (int)(short)HIWORD(wParam)), 0L)
#define HANDLE_MM_MIXM_CONTROL_CHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMIXER)(wParam), (DWORD)(lParam)))
#define HANDLE_MM_MIXM_LINE_CHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMIXER)(wParam), (DWORD)(lParam)))
#define HANDLE_MYWM_TIMER(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd)))
#define HANDLE_WM_IDEVICECHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), wParam, lParam))
#define HANDLE_MYWM_WAKEUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), wParam))

#define VOLUME_TRAYSHUTDOWN_ID    1

#define SIZEOF(x)   (sizeof((x))/sizeof((x)[0]))

#include "pvcd.h"

#ifndef DRV_QUERYDEVNODE
#define DRV_QUERYDEVNODE     (DRV_RESERVED + 2)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mixerapp\vu.h ===
// Copyright (c) 1995 Microsoft Corporation
#ifdef UNICODE
   #define VUMETER_CLASS L"mixctls_vumeter"
#else
   #define VUMETER_CLASS "mixctls_vumeter"
#endif

BOOL InitVUControl(HINSTANCE hInst);

#define VUS_HORZ                0x0001
#define VUS_VERT                0x0000  /* default */

/*
 * LPARAM == ptr to RGBQUAD array, WPARAM == count RGBQUAD
 * */ 
#define VU_SETCOLORLIST         (WM_USER + 1)

/*
 * LPARAM == ptr to RGBQUAD array
 **/ 
#define VU_GETCOLORLIST         (WM_USER + 2)

/*
 * LPARAM == DWORD value in range
 * */
#define VU_SETPOS               (WM_USER + 3)
#define VU_GETPOS               (WM_USER + 4)

/*
 * LPARAM == DWORD max
 **/
#define VU_SETRANGEMAX          (WM_USER + 5)

/*
 * LPARAM == DWORD min
 * */
#define VU_SETRANGEMIN          (WM_USER + 6)


#define VU_GETRANGEMAX          (WM_USER + 7)
#define VU_GETRANGEMIN          (WM_USER + 8)

/*
 * */
#define VU_SETBREAKFREQ         (WM_USER + 9)
#define VU_GETBREAKFREQ         (WM_USER + 10)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\alloc.c ===
/* ---File: alloc.c -------------------------------------------------------
 *
 *  Description:
 *    Contains memory allocation routines.
 *
 *    This document contains confidential/proprietary information.
 *    Copyright (c) 1990-1994 Microsoft Corporation, All Rights Reserved.
 *
 * Revision History:
 *
 * ---------------------------------------------------------------------- */
/* Notes -

    Global Functions:

        AllocMem () -
        AllocStr () -
        FreeMem () -
        FreeStr () -
        ReallocMem () -

 */

#include <windows.h>
#include "mplayer.h"

LPTSTR AllocStr( LPTSTR lpStr )

/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    lpStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    LPTSTR lpMem;

    if( !lpStr )
        return NULL;

    lpMem = AllocMem( STRING_BYTE_COUNT( lpStr ) );

    if( lpMem )
        lstrcpy( lpMem, lpStr );

    return lpMem;
}


VOID FreeStr( LPTSTR lpStr )
{
    FreeMem( lpStr, STRING_BYTE_COUNT( lpStr ) );
}


VOID ReallocStr( LPTSTR *plpStr, LPTSTR lpStr )
{
    FreeStr( *plpStr );
    *plpStr = AllocStr( lpStr );
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mixerapp\volids.h ===
// Copyright (c) 1995-1997 Microsoft Corporation

#define IDD_MIXERDIALOGS                100
#define IDC_MIXERCONTROLS               1000
#define IDS_MIXERSTRINGS                200
#define IDM_MIXERMENUS                  0
#define IDI_MIXERICONS                  300
#define IDR_MIXERRES                    400

/* DIALOGBOX: IDD_DESTINATION */
#define IDD_DESTINATION                 101

/* CONTROLS */
#define IDC_SWITCH                      (IDC_MIXERCONTROLS+0)
#define IDC_VOLUME                      (IDC_MIXERCONTROLS+1)
#define IDC_BALANCE                     (IDC_MIXERCONTROLS+2)
#define IDC_LINELABEL                   (IDC_MIXERCONTROLS+4)
#define IDC_VUMETER                     (IDC_MIXERCONTROLS+5)
#define IDC_STATUSBAR                   (IDC_MIXERCONTROLS+21)
#define IDC_ADVANCED                    (IDC_MIXERCONTROLS+22)
#define IDC_BORDER                      (IDC_MIXERCONTROLS+23)
#define IDC_MULTICHANNEL                (IDC_MIXERCONTROLS+24)
#define IDC_MASTER_BALANCE_TEXT         (IDC_MIXERCONTROLS+25)
#define IDC_MASTER_BALANCE_ICON_1       (IDC_MIXERCONTROLS+26)
#define IDC_MASTER_BALANCE_ICON_2       (IDC_MIXERCONTROLS+27)

/* END DIALOGBOX: IDD_DESTINATION */


/* DIALOGBOX: IDD_SOURCE */
#define IDD_SOURCE                      102

/* CONTROLS */

/* END DIALOGBOX: IDD_SOURCE */


/* DIALOGBOX: IDD_CHOOSEDEVICE */
#define IDD_CHOOSEDEVICE                103

/* CONTROLS */
#define IDC_CHOOSELIST                  (IDC_MIXERCONTROLS+6)

/* END DIALOGBOX: IDD_CHOOSEDEVICE */


/* DIALOGBOX: IDD_CHOOSEOUTPUT */
#define IDD_CHOOSEOUTPUT                104

/* CONTROLS */
#define IDC_NEWWINDOW                   (IDC_MIXERCONTROLS+7)
/* END DIALOGBOX: IDD_CHOOSEOUTPUT */

/* DIALOGBOX: IDD_CHOOSELINES */
#define IDD_CHOOSELINES                 105

/* CONTROLS */

/* END DIALOGBOX: IDD_CHOOSEOUTPUT */

/*  DIALOGBOX: IDD_TRAYMASTER */
#define IDD_TRAYMASTER                  106

/* CONTROLS */
//#define IDC_ICONVOL                     (IDC_MIXERCONTROLS+8)
//#define IDC_ICONBAL                     (IDC_MIXERCONTROLS+9)
#define IDC_TRAYLABEL                   (IDC_MIXERCONTROLS+10)
#define IDC_VOLUMECUE                   (IDC_MIXERCONTROLS+11)
                          
/* END DIALOGBOX: IDD_TRAYMASTER */
                  
/*  DIALOGBOX: IDD_PROPERTIES */
#define IDD_PROPERTIES                  107

/* CONTROLS */
#define IDC_PROP_DEVICELIST             (IDC_MIXERCONTROLS+12)
#define IDC_PROP_PLAYBACK               (IDC_MIXERCONTROLS+13)
#define IDC_PROP_RECORDING              (IDC_MIXERCONTROLS+14)
#define IDC_PROP_OTHER                  (IDC_MIXERCONTROLS+15)
#define IDC_PROP_OTHERLIST              (IDC_MIXERCONTROLS+16)
#define IDC_PROP_VOLUMELIST             (IDC_MIXERCONTROLS+17)
#define IDC_PROP_TXT1                   (IDC_MIXERCONTROLS+18)
#define IDC_PROP_TXT2                   (IDC_MIXERCONTROLS+19)
#define IDC_PROP_VOLUMES                (IDC_MIXERCONTROLS+20)
#define IDC_PROP_ADVANCED               (IDC_MIXERCONTROLS+24)

/* END DIALOGBOX: IDD_TRAYMASTER */

/* DIALOGBOX: IDD_SM SRC/DST */
#define IDD_SMSRC                       108
#define IDD_SMDST                       109
/* END DIALOGBOX: IDD_SM SRC/DST */

/* DIALOGBOX: IDD_ADVANCED */
#define IDD_ADVANCED                    110
#define IDC_BASS                        (IDC_MIXERCONTROLS+25)
#define IDC_TREBLE                      (IDC_MIXERCONTROLS+26)
#define IDC_TXT_LOW1                    (IDC_MIXERCONTROLS+27)
#define IDC_TXT_LOW2                    (IDC_MIXERCONTROLS+28)
#define IDC_TXT_HI1                     (IDC_MIXERCONTROLS+29)
#define IDC_TXT_HI2                     (IDC_MIXERCONTROLS+30)
#define IDC_SWITCH1                     (IDC_MIXERCONTROLS+31)
#define IDC_SWITCH2                     (IDC_MIXERCONTROLS+32)
#define IDC_TXT_SWITCHES                (IDC_MIXERCONTROLS+33)
#define IDC_GRP_TONE                    (IDC_MIXERCONTROLS+34)
#define IDC_GRP_OTHER                   (IDC_MIXERCONTROLS+35)

          
/* END DIALOGBOX: IDD_ADVANCED */

/* FOR ACCESSIBILITY: These must be in a continuous range */
#define IDC_ACCESS_BALANCE              (IDC_MIXERCONTROLS+36)
#define IDC_ACCESS_VOLUME               (IDC_MIXERCONTROLS+37)
/* END FOR ACCESSIBILITY */

                    
/* MENU: */
#define IDR_MIXERMENU                   150
#define IDR_MODIFYMENU                  152

#define IDM_OPEN                        (IDM_MIXERMENUS + 2)
#define IDM_SAVE                        (IDM_MIXERMENUS + 3)
#define IDM_SAVEAS                      (IDM_MIXERMENUS + 4)
#define IDM_EXIT                        (IDM_MIXERMENUS + 5)
#define IDM_CHOOSEINPUT                 (IDM_MIXERMENUS + 6)
#define IDM_ADDINPUT                    (IDM_MIXERMENUS + 7)
#define IDM_CHOOSEOUTPUT                (IDM_MIXERMENUS + 8)
#define IDM_ADDOUTPUT                   (IDM_MIXERMENUS + 9)
#define IDM_HELPINDEX                   (IDM_MIXERMENUS + 10) // dead
#define IDM_HELPABOUT                   (IDM_MIXERMENUS + 11)
#define IDM_MASTERONLY                  (IDM_MIXERMENUS + 12)
#define IDM_TRAYMASTER                  (IDM_MIXERMENUS + 13)
#define IDM_CHOOSEDEVICE                (IDM_MIXERMENUS + 14)
#define IDM_CHOOSELINES                 (IDM_MIXERMENUS + 15)
#define IDM_CONTROLPANEL                (IDM_MIXERMENUS + 17)
#define IDM_STUB                        (IDM_MIXERMENUS + 18)
#define IDM_HELPTOPICS                  (IDM_MIXERMENUS + 19)
#define IDM_VOLUMECONTROL               (IDM_MIXERMENUS + 20)
#define IDM_PROPERTIES                  (IDM_MIXERMENUS + 21)         
#define IDM_SMALLMODESWITCH             (IDM_MIXERMENUS + 22)         
#define IDM_ALLWAYSONTOP                (IDM_MIXERMENUS + 23)
#define IDM_ADVANCED                    (IDM_MIXERMENUS + 24)

// do not exceed IDC_MIXERCONTROLS

/* END MENU: */


/* STRINGTABLE: */
#define IDS_FMTAPPTITLE                 (IDS_MIXERSTRINGS + 0)
#define IDS_APPTITLE                    (IDS_MIXERSTRINGS + 1)
#define IDS_TRAYNAME                    (IDS_MIXERSTRINGS + 2)
#define IDS_APPBASE                     (IDS_MIXERSTRINGS + 3)
#define IDS_LABEL_MASTER                (IDS_MIXERSTRINGS + 4)

#define IDS_LABEL_DST_VOLUME            (IDS_MIXERSTRINGS + 5)
#define IDS_LABEL_DST_RECORDING         (IDS_MIXERSTRINGS + 6)
#define IDS_LABEL_DST_UNDEFINED         (IDS_MIXERSTRINGS + 7)
#define IDS_LABEL_DST_DIGITAL           (IDS_MIXERSTRINGS + 8)
#define IDS_LABEL_DST_LINE              (IDS_MIXERSTRINGS + 9)
#define IDS_LABEL_DST_MONITOR           (IDS_MIXERSTRINGS + 10)
#define IDS_LABEL_DST_SPEAKERS          (IDS_MIXERSTRINGS + 11)
#define IDS_LABEL_DST_HEADPHONES        (IDS_MIXERSTRINGS + 12)
#define IDS_LABEL_DST_TELEPHONE         (IDS_MIXERSTRINGS + 13)
#define IDS_LABEL_DST_WAVEIN            (IDS_MIXERSTRINGS + 14)
#define IDS_LABEL_DST_VOICEIN           (IDS_MIXERSTRINGS + 15)

#define IDS_LABEL_SRC_UNDEFINED         IDS_LABEL_DST_UNDEFINED
#define IDS_LABEL_SRC_DIGITAL           IDS_LABEL_DST_DIGITAL
#define IDS_LABEL_SRC_LINE              IDS_LABEL_DST_LINE
#define IDS_LABEL_SRC_MICROPHONE        (IDS_MIXERSTRINGS + 17)
#define IDS_LABEL_SRC_SYNTHESIZER       (IDS_MIXERSTRINGS + 18)
#define IDS_LABEL_SRC_COMPACTDISC       (IDS_MIXERSTRINGS + 19)
#define IDS_LABEL_SRC_TELEPHONE         IDS_LABEL_DST_TELEPHONE
#define IDS_LABEL_SRC_PCSPEAKER         (IDS_MIXERSTRINGS + 20)
#define IDS_LABEL_SRC_WAVEOUT           (IDS_MIXERSTRINGS + 21)
#define IDS_LABEL_SRC_AUXILIARY         (IDS_MIXERSTRINGS + 22)
#define IDS_LABEL_SRC_ANALOG            (IDS_MIXERSTRINGS + 23)
#define IDS_LABEL_SRC_SNDBLST           (IDS_MIXERSTRINGS + 24)

#define IDS_MMSYSPROPTITLE              (IDS_MIXERSTRINGS + 25)
#define IDS_MMSYSPROPTAB                (IDS_MIXERSTRINGS + 26)

#define IDS_ERR_NODEV                   (IDS_MIXERSTRINGS + 27)
#define IDS_HELPFILENAME                (IDS_MIXERSTRINGS + 28)
#define IDS_HTMLHELPFILENAME            (IDS_MIXERSTRINGS + 29)
#define IDS_OTHERDEVICES                (IDS_MIXERSTRINGS + 30)
#define IDS_SELECT                      (IDS_MIXERSTRINGS + 31)
#define IDS_ERR_HARDWARE                (IDS_MIXERSTRINGS + 32)
#define IDS_IS_RTL                      (IDS_MIXERSTRINGS + 33)
#define IDS_ADV_TITLE                   (IDS_MIXERSTRINGS + 34)
#define IDS_ADV_SWITCH1                 (IDS_MIXERSTRINGS + 35)
#define IDS_ADV_SWITCH2                 (IDS_MIXERSTRINGS + 36)
#define IDS_MC_RECORDING                (IDS_MIXERSTRINGS + 37)
#define IDS_MC_LEVEL                    (IDS_MIXERSTRINGS + 38)

/* END STRINGTABLE: */

#define IDC_STATIC                      -1

/* BEGIN ICONS */
#define IDI_MIXER                       300
#define IDI_LSPEAKER                    301
#define IDI_RSPEAKER                    302
#define IDI_MUTE                        303
#define IDI_TRAY                        304

/* BEGIN OTHER RESOURCES */
#define IDR_VOLUMEACCEL                 401
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mixerapp\vu.c ===
/*****************************************************************************
 *
 *  Component:  sndvol32.exe
 *  File:       vu.c
 *  Purpose:    peak meter custom control
 * 
 *  Copyright (c) 1985-1998 Microsoft Corporation
 *
 *****************************************************************************/
/*
 * VUMeter Control
 *
 * */
#include <windows.h>
#include <windowsx.h>
#include "vu.h"

const TCHAR gszVUClass[] = VUMETER_CLASS;

LRESULT FAR PASCAL VUMeterProc(HWND hwnd, UINT wMessage, WPARAM wParam, LPARAM lParam);

#define GETVUINST(x)       (VUINST *)GetWindowLongPtr(x, 0)
#define SETVUINST(x,y)     SetWindowLongPtr(x, 0, (LONG_PTR)y)

typedef struct tag_VUINST {
    CREATESTRUCT cs;
    DWORD   dwLevel;        // current value
    DWORD   dwMax;          // value max
    DWORD   dwMin;          // value min
    DWORD   dwBreak;        // last break
    DWORD   dwStyle;        // dbl extra style bits ???
    DWORD   cBreaks;        // no. of breaks
    DWORD   cRGB;           // no. of RGBQUADs
    DWORD   dwHeight;
    DWORD   dwWidth;
    HBITMAP hColor;         // bitmap cache of full display
    HBITMAP hBackground;    // bitmap cache of background   
    RGBQUAD *aRGB;          // array of RGBQUADs describing colors
} VUINST, *PVUINST, FAR *LPVUINST;

const RGBQUAD gaRGBDefault[] = {
    {   0, 127,   0, 0},        // dark green    
    {   0, 127,   0, 0},        // dark green
    {   0, 255,   0, 0},        // light green
    {   0, 255, 255, 0},        // yellow
    {   0,   0, 255, 0}         // red    
};

BOOL InitVUControl(HINSTANCE hInst)
{
    WNDCLASS wc;
    wc.lpszClassName   = (LPTSTR)gszVUClass;
    wc.hCursor         = LoadCursor( NULL, IDC_ARROW );
    wc.lpszMenuName    = (LPTSTR)NULL;
    wc.style           = CS_HREDRAW|CS_VREDRAW|CS_GLOBALCLASS;
    wc.lpfnWndProc     = VUMeterProc;
    wc.hInstance       = hInst;
    wc.hIcon           = NULL;
    wc.cbWndExtra      = sizeof(VUINST *);
    wc.cbClsExtra      = 0;
    wc.hbrBackground   = (HBRUSH)(COLOR_WINDOW + 1 );

    /* register meter window class */
    if(!RegisterClass(&wc))
    {
        return FALSE;
    }

    return (TRUE);
}

DWORD vu_CalcBreaks(
    PVUINST pvi)
{
    DWORD cBreaks;
    
    if (pvi->dwMax - pvi->dwMin > 0)
    {
        cBreaks = ((pvi->dwLevel - pvi->dwMin) * pvi->cBreaks)
                  / (pvi->dwMax - pvi->dwMin);
        if (!cBreaks && pvi->dwLevel > pvi->dwMin)
            cBreaks++;
    }
    else
        cBreaks = 0;
    
    if (cBreaks > pvi->cBreaks)
        cBreaks = pvi->cBreaks;
    
    return cBreaks;
}

BOOL vu_OnCreate(
    HWND            hwnd,
    LPCREATESTRUCT  lpCreateStruct)
{
    PVUINST pvi;

    //
    // alloc an instance data structure
    pvi = LocalAlloc(LPTR, sizeof(VUINST));
    if (!pvi)
        return FALSE;
    SETVUINST(hwnd, pvi);
    
    pvi->cBreaks    = 10;
    pvi->cRGB       = sizeof(gaRGBDefault)/sizeof(RGBQUAD);
    pvi->aRGB       = (RGBQUAD *)gaRGBDefault;
    pvi->dwMin      = 0;
    pvi->dwMax      = 0;
    pvi->dwLevel    = 0;
    pvi->dwBreak    = 0;
    pvi->hColor     = NULL;
    pvi->hBackground = NULL;
    return TRUE;
}

void vu_ResetControl(
    PVUINST pvi)
{
    if (pvi->hColor)
    {
        DeleteObject(pvi->hColor);
        pvi->hColor = NULL;
    }
    if (pvi->hBackground)
    {
        DeleteObject(pvi->hBackground);
        pvi->hBackground = NULL;
    }
}

void vu_OnDestroy(
    HWND        hwnd)
{
    PVUINST pvi = GETVUINST(hwnd);
    
    if (pvi)
    {
        vu_ResetControl(pvi);
        LocalFree((HLOCAL)pvi);
        SETVUINST(hwnd,0);
    }
}

void vu_OnPaint(
    HWND        hwnd)
{
    PVUINST     pvi = GETVUINST(hwnd);
    RECT        rc, rcB;
    PAINTSTRUCT ps;
    int         i;
    int         iSize;
    DWORD       cBreaks;
    
    if (!GetUpdateRect(hwnd, &rc, FALSE))
        return;

    BeginPaint(hwnd, &ps);
    
    GetClientRect(hwnd, &rc);
    
    //
    // Create the foreground bitmap if not already cached
    //
    if (pvi->hColor == NULL)
    {
        HDC     hdc;
        HBITMAP hbmp, hold;
        HBRUSH  hbr;
        RECT    rcp;
        
        rcp.left    = 0;
        rcp.right   = rc.right - rc.left - 4;
        rcp.top     = 0;
        rcp.bottom  = rc.bottom - rc.top - 4 ;
        
        hdc  = CreateCompatibleDC(ps.hdc);
        hbmp = CreateCompatibleBitmap(ps.hdc, rcp.right, rcp.bottom);
        hold = SelectObject(hdc, hbmp);

        //
        // background
        //
        hbr  = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
        FillRect(hdc, &rcp, hbr);
        if (hbr) DeleteObject(hbr);
        
        //
        // each block will be iSize tall
        //
        iSize = (rcp.bottom - 1) / pvi->cBreaks;

        //
        // color blocks
        //
        for (i = 0; i < (int)pvi->cBreaks; i++)
        {
            int iColor = i / (pvi->cBreaks/pvi->cRGB);
            if (iColor >= (int)pvi->cRGB - 1)
                iColor = (int)pvi->cRGB - 1;

            hbr = CreateSolidBrush(RGB(pvi->aRGB[iColor].rgbRed
                                       ,pvi->aRGB[iColor].rgbGreen
                                       ,pvi->aRGB[iColor].rgbBlue));
            rcB.left    = 0;
            rcB.right   = rcp.right;
            rcB.top     = rcp.bottom - (i+1)*iSize;
//            rcB.bottom  = rcp.bottom - i*iSize;
            rcB.bottom  = rcB.top + iSize - 1;            

            FillRect(hdc, &rcB, hbr);
            DeleteObject(hbr);
        }
        pvi->hColor = SelectObject(hdc, hold);
        DeleteDC(hdc);
    }

    //
    // Paint it
    // 
    {
        HDC     hdc, hdcColor;
        HBITMAP holdColor, hbmp, hold;
        RECT    rcC = rc;
        HBRUSH  hbr;

        
        //
        // always show something if we exceed the minimum
        cBreaks = vu_CalcBreaks(pvi);
        
        rcC.left     = 0;
        rcC.right    = rc.right - rc.left - 4;
        rcC.top      = 0;
        rcC.bottom   = rc.bottom - rc.top - 4;
        
        // each block will be iSize+1 tall
        iSize = (rcC.bottom - 1) / pvi->cBreaks ;
        
        // paint the uncolor area
        hdc  = CreateCompatibleDC(ps.hdc);
        hbmp = CreateCompatibleBitmap(ps.hdc, rcC.right, rcC.bottom);
        hold = SelectObject(hdc, hbmp);
        hbr  = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
        FillRect(hdc, &rcC, hbr);
        if (hbr)
            DeleteObject(hbr);

        if (cBreaks > 0)
        {
            // paint the color area        
            hdcColor  = CreateCompatibleDC(ps.hdc);
            if (hdcColor)
                holdColor = SelectObject(hdcColor, pvi->hColor);

            BitBlt(hdc
                   , 0
                   , rcC.bottom - (iSize * cBreaks)
                   , rcC.right
                   , iSize * cBreaks 
                   , hdcColor
                   , 0
                   , rcC.bottom - (iSize * cBreaks)
                   , SRCCOPY);
        
            SelectObject(hdcColor, holdColor);
            DeleteDC(hdcColor);
        }
        
        //
        // finally, blt into the real dc
        BitBlt(ps.hdc
               , 2
               , 2
               , rcC.right
               , rcC.bottom
               , hdc
               , 0
               , 0
               , SRCCOPY);
        
        SelectObject(hdc, hold);
        if (hbmp) DeleteObject(hbmp);
        DeleteDC(hdc);
    }
    DrawEdge(ps.hdc, &rc, BDR_SUNKENOUTER, BF_RECT);

    EndPaint(hwnd, &ps);
}

void vu_OnSysColorChange(
    HWND        hwnd)
{
    PVUINST pvi = GETVUINST(hwnd);
    vu_ResetControl(pvi);
}

void vu_OnPaletteChanged(
    HWND        hwnd,
    HWND        hwndPaletteChange)
{
    PVUINST pvi = GETVUINST(hwnd);
    vu_ResetControl(pvi);    
}

void vu_OnSize(
    HWND        hwnd,
    UINT        state,
    int         cx,
    int         cy)
{
    PVUINST pvi = GETVUINST(hwnd);
    pvi->dwWidth    = cx;
    pvi->dwHeight   = cy;
    vu_ResetControl(pvi);
}

void vu_OnEnable(
    HWND        hwnd,
    BOOL        fEnable)
{
    PVUINST pvi = GETVUINST(hwnd);

}

void vu_OnPrivateMessage(
    HWND        hwnd,
    UINT        wMessage,
    WPARAM      wParam,
    LPARAM      lParam)
{
    PVUINST pvi = GETVUINST(hwnd);
    switch (wMessage)
    {
        case VU_SETRANGEMIN:
//            OutputDebugString(TEXT ("SetRangeMin\r\n"));
            pvi->dwMin = (DWORD)lParam;
            break;
            
        case VU_SETRANGEMAX:
//            OutputDebugString(TEXT ("SetRangeMax\r\n"));            
            pvi->dwMax = (DWORD)lParam;
            break;

        case VU_SETPOS:
            pvi->dwLevel = (DWORD)lParam;
//            {TCHAR foo[256];
//            wsprintf(foo, TEXT ("v:%lx\r\n"),lParam);
//            OutputDebugString(foo);
//            }
            if (pvi->dwBreak != vu_CalcBreaks(pvi))
            {
                pvi->dwBreak = vu_CalcBreaks(pvi);
                InvalidateRect(hwnd, NULL, TRUE);
            }
            else if (wParam)
                InvalidateRect(hwnd, NULL, TRUE);
            
            break;
    }
}

LRESULT FAR PASCAL
VUMeterProc(
    HWND        hwnd,
    UINT        wMessage,
    WPARAM      wParam,
    LPARAM      lParam)
{
    switch (wMessage)
    {
        HANDLE_MSG(hwnd, WM_CREATE, vu_OnCreate);
        HANDLE_MSG(hwnd, WM_DESTROY, vu_OnDestroy);
        HANDLE_MSG(hwnd, WM_PAINT, vu_OnPaint);
        HANDLE_MSG(hwnd, WM_SYSCOLORCHANGE, vu_OnSysColorChange);
        HANDLE_MSG(hwnd, WM_PALETTECHANGED, vu_OnPaletteChanged);
        HANDLE_MSG(hwnd, WM_SIZE, vu_OnSize);
        HANDLE_MSG(hwnd, WM_ENABLE, vu_OnEnable);
//        HANDLE_MSG(hwnd, WM_TIMER, vu_OnTimer);        
        case VU_SETRANGEMIN:
        case VU_SETRANGEMAX:
        case VU_SETPOS:
            vu_OnPrivateMessage(hwnd, wMessage, wParam, lParam);
            return 0;
        case WM_ERASEBKGND:
            return TRUE;
        default:
            break;
    }
    return DefWindowProc (hwnd, wMessage, wParam, lParam) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\alloc.h ===
#define AllocMem(cb)            (LPVOID)LocalAlloc(LPTR | LMEM_ZEROINIT, cb)
 #define FreeMem(ptr,cb)           (VOID)LocalFree((HANDLE)ptr)
 #define ReallocMem(ptr,cbo,cbn) (LPVOID)LocalReAlloc((HANDLE)ptr, cbn, LMEM_ZEROINIT | LMEM_MOVEABLE)

 LPTSTR AllocStr( LPTSTR lpStr );
 VOID FreeStr( LPTSTR lpStr );
 VOID ReallocStr( LPTSTR *plpStr, LPTSTR lpStr );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\arrow.c ===
/*-----------------------------------------------------------------------------+
| ARROW.C                                                                      |
|                                                                              |
| Control panel arrow code - stolen from WINCOM                                |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32/WIN16 Common code                        |
|                                                                              |
+-----------------------------------------------------------------------------*/

#include <windows.h>
#include <stdlib.h>
#include "mplayer.h"

#define SHIFT_TO_DOUBLE 1
#define DOUBLECLICK     0
#define POINTSPERARROW  3
#define ARROWXAXIS      15
#define ARROWYAXIS      15

POINT ArrowUp[POINTSPERARROW] = {7,1, 3,5, 11,5};
POINT ArrowDown[POINTSPERARROW] = {7,13, 3,9, 11,9};

static    BOOL      bRight;
static    RECT      rUp, rDown;
static    LPRECT    lpUpDown;
static    FARPROC   lpArrowProc;
static    HANDLE    hParent;
BOOL      fInTimer;


#define TEMP_BUFF_SIZE    32

#define SENDSCROLL(hwnd, msg, a, b, h)           \
        SendMessage(hwnd, msg, (UINT_PTR)MAKELONG(a,b), (LONG_PTR)(h))

#define SCROLLMSG(hwndTo, msg, code, hwndId)                                     \
                          SENDSCROLL(hwndTo, msg, code, GETWINDOWID(hwndId), hwndId)



UINT NEAR PASCAL UpOrDown()
{
    LONG pos;
    UINT retval;
    POINT pt;

    pos = GetMessagePos();
    LONG2POINT(pos,pt);
    if (PtInRect((LPRECT)&rUp, pt))
        retval = SB_LINEUP;
    else if (PtInRect((LPRECT)&rDown, pt))
        retval = SB_LINEDOWN;
    else
        retval = (UINT)(-1);      /* -1, because SB_LINEUP == 0 */

    return(retval);
}



UINT FAR PASCAL ArrowTimerProc(HANDLE hWnd, UINT wMsg, short nID, DWORD dwTime)
{
    UINT wScroll;

    if ((wScroll = UpOrDown()) != -1)
    {
        if (bRight == WM_RBUTTONDOWN)
            wScroll += SB_PAGEUP - SB_LINEUP;
        SCROLLMSG( hParent, WM_VSCROLL, wScroll, hWnd);
    }
/* Don't need to call KillTimer(), because SetTimer will reset the right one */
    SetTimer(hWnd, nID, 50, (TIMERPROC)lpArrowProc);
    return(0);
}


void InvertArrow(HANDLE hArrow, UINT wScroll)
{
    HDC hDC;

    lpUpDown = (wScroll == SB_LINEUP) ? &rUp : &rDown;
    hDC = GetDC(hArrow);
    ScreenToClient(hArrow, (LPPOINT)&(lpUpDown->left));
    ScreenToClient(hArrow, (LPPOINT)&(lpUpDown->right));
    InvertRect(hDC, lpUpDown);
    ClientToScreen(hArrow, (LPPOINT)&(lpUpDown->left));
    ClientToScreen(hArrow, (LPPOINT)&(lpUpDown->right));
    ReleaseDC(hArrow, hDC);
    ValidateRect(hArrow, lpUpDown);
    return;
}


LONG_PTR FAR PASCAL _EXPORT ArrowControlProc(HWND hArrow, unsigned message,
                                         WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT ps;
    RECT        rArrow;
    HBRUSH      hbr;
    short       fUpDownOut;
    UINT        wScroll;

    switch (message) {
/*
        case WM_CREATE:
            break;

        case WM_DESTROY:
            break;
*/

        case WM_MOUSEMOVE:
            if (!bRight)  /* If not captured, don't worry about it */
                break;

            if (lpUpDown == &rUp)
                fUpDownOut = SB_LINEUP;
            else if (lpUpDown == &rDown)
                fUpDownOut = SB_LINEDOWN;
            else
                fUpDownOut = -1;

            switch (wScroll = UpOrDown()) {
                case SB_LINEUP:
                    if (fUpDownOut == SB_LINEDOWN)
                        InvertArrow(hArrow, SB_LINEDOWN);

                    if (fUpDownOut != SB_LINEUP)
                        InvertArrow(hArrow, wScroll);

                    break;

                case SB_LINEDOWN:
                    if (fUpDownOut == SB_LINEUP)
                        InvertArrow(hArrow, SB_LINEUP);

                    if (fUpDownOut != SB_LINEDOWN)
                        InvertArrow(hArrow, wScroll);

                    break;

                default:
                    if (lpUpDown) {
                        InvertArrow(hArrow, fUpDownOut);
                        lpUpDown = 0;
                    }
                }

                break;

        case WM_RBUTTONDOWN:
        case WM_LBUTTONDOWN:
            if (bRight)
                break;

            bRight = message;
            SetCapture(hArrow);
            hParent = GetParent(hArrow);
            GetWindowRect(hArrow, (LPRECT) &rUp);
            CopyRect((LPRECT)&rDown, (LPRECT) &rUp);
            rUp.bottom = (rUp.top + rUp.bottom) / 2;
            rDown.top = rUp.bottom + 1;
            wScroll = UpOrDown();
            InvertArrow(hArrow, wScroll);
#if SHIFT_TO_DOUBLE
            if (wParam & MK_SHIFT) {
                if (message != WM_RBUTTONDOWN)
                    goto ShiftLClick;
                else
                    goto ShiftRClick;
            }
#endif
            if (message == WM_RBUTTONDOWN)
                wScroll += SB_PAGEUP - SB_LINEUP;

            SCROLLMSG(hParent, WM_VSCROLL, wScroll, hArrow);

            lpArrowProc = MakeProcInstance((FARPROC) ArrowTimerProc,ghInst);
            SetTimer(hArrow, GETWINDOWID(hArrow), 200, (TIMERPROC)lpArrowProc);

            break;

        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
            if ((bRight - WM_LBUTTONDOWN + WM_LBUTTONUP) == (int)message) {
                bRight = 0;
                ReleaseCapture();
                if (lpUpDown)
                    InvertArrow(hArrow,(UINT)(lpUpDown==&rUp)?
                                                        SB_LINEUP:SB_LINEDOWN);
                if (lpArrowProc) {
                    SCROLLMSG(hParent, WM_VSCROLL, SB_ENDSCROLL, hArrow);
                    KillTimer(hArrow, GETWINDOWID(hArrow));
                    ReleaseCapture();
                    lpArrowProc = 0;
                }
            }
            break;

        case WM_LBUTTONDBLCLK:
ShiftLClick:
            wScroll = UpOrDown() + SB_TOP - SB_LINEUP;
            SCROLLMSG(hParent, WM_VSCROLL, wScroll, hArrow);
            SCROLLMSG(hParent, WM_VSCROLL, SB_ENDSCROLL, hArrow);

            break;

        case WM_RBUTTONDBLCLK:
ShiftRClick:
            wScroll = UpOrDown() + SB_THUMBPOSITION - SB_LINEUP;
            SCROLLMSG(hParent, WM_VSCROLL, wScroll, hArrow);
            SCROLLMSG(hParent, WM_VSCROLL, SB_ENDSCROLL, hArrow);
/*
            hDC = GetDC(hArrow);
            InvertRect(hDC, (LPRECT) &rArrow);
            ReleaseDC(hArrow, hDC);
            ValidateRect(hArrow, (LPRECT) &rArrow);
*/
            break;

        case WM_PAINT:
            BeginPaint(hArrow, &ps);
            GetClientRect(hArrow, (LPRECT) &rArrow);
            hbr = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
            FillRect(ps.hdc, (LPRECT)&rArrow, hbr);
            DeleteObject(hbr);
            hbr = SelectObject(ps.hdc, GetStockObject(BLACK_BRUSH));
            SetTextColor(ps.hdc, GetSysColor(COLOR_WINDOWFRAME));
            SetMapMode(ps.hdc, MM_ANISOTROPIC);

            MSetViewportOrg(ps.hdc, rArrow.left, rArrow.top);
            MSetViewportExt(ps.hdc, rArrow.right - rArrow.left,
                                                    rArrow.bottom - rArrow.top);
            MSetWindowOrg(ps.hdc, 0, 0);
            MSetWindowExt(ps.hdc, ARROWXAXIS, ARROWYAXIS);
            MMoveTo(ps.hdc, 0, (ARROWYAXIS / 2));
            LineTo(ps.hdc, ARROWXAXIS, (ARROWYAXIS / 2));
/*
            Polygon(ps.hdc, (LPPOINT) Arrow, 10);
*/
            Polygon(ps.hdc, (LPPOINT) ArrowUp, POINTSPERARROW);
            Polygon(ps.hdc, (LPPOINT) ArrowDown, POINTSPERARROW);
            SelectObject(ps.hdc, hbr);

            EndPaint(hArrow, &ps);

            break;

        default:
            return(DefWindowProc(hArrow, message, wParam, lParam));

            break;
        }

    return(0L);
}


BOOL FAR PASCAL ArrowInit(HANDLE hInst)
{
	static SZCODE aszComArrow[] = TEXT("ComArrow");
    WNDCLASS wcArrow;

    wcArrow.lpszClassName = aszComArrow;
    wcArrow.hInstance     = hInst;
    wcArrow.lpfnWndProc   = ArrowControlProc;
    wcArrow.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wcArrow.hIcon         = NULL;
    wcArrow.lpszMenuName  = NULL;
    wcArrow.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wcArrow.style         = CS_HREDRAW | CS_VREDRAW;
#if DOUBLECLICK
    wcArrow.style         |= CS_DBLCLKS;
#endif
    wcArrow.cbClsExtra    = 0;
    wcArrow.cbWndExtra    = 0;

    if (!RegisterClass(&wcArrow))
        return FALSE;

    return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\avocado.c ===
#include <windows.h>

// initguid.h requires this.
//
#ifdef MTN
#pragma warning(disable: 4103)  // used #pragma pack to change alignment (on Chicago)
#endif
#include <ole2.h>

// this redefines the DEFINE_GUID() macro to do allocation.
//
#include <initguid.h>

// due to the previous header, including this causes the DEFINE_GUID
// definitions in the following header(s) to actually allocate data.
//
#include <oleguid.h>
#include <coguid.h>

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mixerapp\volume.c ===
/*****************************************************************************
 *
 *  Component:  sndvol32.exe
 *  File:       volume.c
 *  Purpose:    main application module
 *
 *  Copyright (c) 1985-1999 Microsoft Corporation
 *
 *****************************************************************************/
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <commctrl.h>
#include <shellapi.h>
#include <dbt.h>
#include <htmlhelp.h>
#include <regstr.h>

#include "vu.h"
#include "dlg.h"
#include "volids.h"

#include "volumei.h"
#include "utils.h"
#include "stdlib.h"
#include "helpids.h"

#if(WINVER >= 0x040A)
//Support for new WM_DEVICECHANGE behaviour in NT5
/////////////////////////////////////////////////
#include <objbase.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <initguid.h>
#include <devguid.h>
#include <mmddkp.h>
#include <ks.h>
#include <ksmedia.h>
#include <wchar.h>

#define STRSAFE_LIB
#include <strsafe.h>

#define HMIXER_INDEX(i)       ((HMIXER)IntToPtr(i))

HDEVNOTIFY DeviceEventContext = NULL;
BOOL bUseHandle = FALSE; //Indicates whether a handle is being used for device notification,
                         //instead of the general KSCATEGORY_AUDIO
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////
#endif /* WINVER >= 0x040A */

void    Volume_SetControl(PMIXUIDIALOG pmxud, HWND hctl, int iLine, int iCtl);
void    Volume_GetControl(PMIXUIDIALOG pmxud, HWND hctl, int iLine, int iCtl);
DWORD   Volume_DialogBox(PMIXUIDIALOG pmxud);
void    Volume_Cleanup(PMIXUIDIALOG pmxud);
void    Volume_InitLine(PMIXUIDIALOG pmxud, DWORD iLine);
HRESULT GetDestLineID(int mxid, DWORD *piDest);
HRESULT GetSrcLineID(int mxid, DWORD *piDest);
HRESULT GetDestination(DWORD mxid, int *piDest);
HICON GetAppIcon (HINSTANCE hInst, UINT uiMixID);
void FreeAppIcon ();
HKEY OpenDeviceRegKey (UINT uiMixID, REGSAM sam);
PTCHAR GetInterfaceName (DWORD dwMixerID);
HKEY OpenDeviceBrandRegKey (UINT uiMixID);


/* string declarations */
const TCHAR gszParentClass[]         = TEXT( "SNDVOL32" );

const TCHAR gszAppClassName[]        = TEXT( "Volume Control" );
const TCHAR gszTrayClassName[]       = TEXT( "Tray Volume" );


#ifdef DEBUG
static void _dlout(LPSTR szExp, LPSTR szFile, UINT uLine)
{
    char sz[256];
    StringCchPrintfA(sz, SIZEOF(sz), "%s, file %s, line %u\r\n", szExp, szFile, uLine);
    OutputDebugStringA(sz);
}
#define dlout(exp)  (void)(_dlout(exp, __FILE__, __LINE__), 0)
#else
#define dlout(exp)  ((void)0)
#endif


/* app global
 * */
TCHAR gszHelpFileName[MAX_PATH];
TCHAR gszHtmlHelpFileName[MAX_PATH];
BOOL gfIsRTL;
BOOL fCanDismissWindow = FALSE;
BOOL gfRecord = FALSE;
HICON ghiconApp = NULL;
static HHOOK     fpfnOldMsgFilter;
static HOOKPROC  fpfnMsgHook;
//Data used for supporting context menu help
BOOL   bF1InMenu=FALSE; //If true F1 was pressed on a menu item.
UINT   currMenuItem=0;  //The current selected menu item if any.
static HWND ghwndApp=NULL;

/*
 * Number of uniquely supported devices.
 *
 * */
int Volume_NumDevs()
{
    int     cNumDevs = 0;

#pragma message("----Nonmixer issue here.")
//    cNumDevs = Nonmixer_GetNumDevs();
    cNumDevs += Mixer_GetNumDevs();

    return cNumDevs;
}

/*
 * Volume_EndDialog
 *
 * */
void Volume_EndDialog(
    PMIXUIDIALOG    pmxud,
    DWORD           dwErr,
    MMRESULT        mmr)
{
    pmxud->dwReturn = dwErr;
    if (dwErr == MIXUI_MMSYSERR)
        pmxud->mmr = mmr;

    if (IsWindow(pmxud->hwnd))
        PostMessage(pmxud->hwnd, WM_CLOSE, 0, 0);
}

/*
 * Volume_OnMenuCommand
 *
 * */
BOOL Volume_OnMenuCommand(
    HWND            hwnd,
    int             id,
    HWND            hctl,
    UINT            unotify)
{
    PMIXUIDIALOG    pmxud = GETMIXUIDIALOG(hwnd);

    switch(id)
    {
    case IDM_PROPERTIES:
        if (Properties(pmxud, hwnd))
        {
            Volume_GetSetStyle(&pmxud->dwStyle, SET);
            Volume_EndDialog(pmxud, MIXUI_RESTART, 0);
        }
        break;

    case IDM_HELPTOPICS:
        SendMessage(pmxud->hParent, MYWM_HELPTOPICS, 0, 0L);
        break;

    case IDM_HELPABOUT:
    {
        TCHAR        ach[256];
        GetWindowText(hwnd, ach, SIZEOF(ach));
        ShellAbout(hwnd
               , ach
               , NULL
               , (HICON)SendMessage(hwnd, WM_QUERYDRAGICON, 0, 0L));
        break;
    }

    case IDM_ADVANCED:
    {
        HMENU hmenu;

        pmxud->dwStyle ^= MXUD_STYLEF_ADVANCED;

        hmenu = GetMenu(hwnd);
        if (hmenu)
        {
            CheckMenuItem(hmenu, IDM_ADVANCED, MF_BYCOMMAND
                  | ((pmxud->dwStyle & MXUD_STYLEF_ADVANCED)?MF_CHECKED:MF_UNCHECKED));
        }
        Volume_GetSetStyle(&pmxud->dwStyle, SET);
        Volume_EndDialog(pmxud, MIXUI_RESTART, 0);
        break;
    }

    case IDM_SMALLMODESWITCH:
        if (!(pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER))
        {
            pmxud->dwStyle ^= MXUD_STYLEF_SMALL;
            if (pmxud->dwStyle & MXUD_STYLEF_SMALL)
            {
                pmxud->dwStyle &= ~MXUD_STYLEF_STATUS;
            }
            else
                pmxud->dwStyle |= MXUD_STYLEF_STATUS;

            Volume_GetSetStyle(&pmxud->dwStyle, SET);
            Volume_EndDialog(pmxud, MIXUI_RESTART, 0);
        }
        break;

    case IDM_EXIT:
        Volume_EndDialog(pmxud, MIXUI_EXIT, 0);
        return TRUE;
    }
    return FALSE;
}


/*
 * Volume_OnCommand
 *
 * - Process WM_COMMAND
 *
 * Note: We need a 2 way mapping.  Dialog control -> Mixer control
 * and Mixer control -> Dialog control.
 *
 * */
void Volume_OnCommand(
    HWND            hdlg,
    int             id,
    HWND            hctl,
    UINT            unotify)
{
    int             iMixerLine;
    PMIXUIDIALOG    pmxud = GETMIXUIDIALOG(hdlg);

    //
    // Filter menu messages
    //
    if (Volume_OnMenuCommand(hdlg, id, hctl, unotify))
        return;

    // Each control is offset from the original template control by IDOFFSET.
    // e.g.
    // IDC_VOLUME, IDC_VOLUME+IDOFFSET, .. IDC_VOLUME+(IDOFFSET*cMixerLines)
    //
    iMixerLine = id/IDOFFSET - 1;
    switch ((id % IDOFFSET) + IDC_MIXERCONTROLS)
    {
        case IDC_SWITCH:
            Volume_SetControl(pmxud, hctl, iMixerLine, MIXUI_SWITCH);
            break;
        case IDC_ADVANCED:
            if (MXUD_ADVANCED(pmxud) && !(pmxud->dwStyle & MXUD_STYLEF_SMALL))
                Volume_SetControl(pmxud, hctl, iMixerLine, MIXUI_ADVANCED);
            break;
        case IDC_MULTICHANNEL:
            Volume_SetControl(pmxud, hctl, iMixerLine, MIXUI_MULTICHANNEL);
            break;
    }
}

/*
 * Volume_GetLineItem
 *
 * - Helper function.
 * */
HWND Volume_GetLineItem(
    HWND            hdlg,
    DWORD           iLine,
    DWORD           idCtrl)
{
    HWND            hwnd;
    DWORD           id;

    id      = (iLine * IDOFFSET) + idCtrl;
    hwnd    = GetDlgItem(hdlg, id);

    return hwnd;
}

/*      -       -       -       -       -       -       -       -       - */

/*
 * Volume_TimeProc
 *
 * This is the callback for the periodic timer that does updates for
 * controls that need to be polled.  We only allocate one per app to keep
 * the number of callbacks down.
 */
void CALLBACK Volume_TimeProc(
    UINT            idEvent,
    UINT            uReserved,
    DWORD_PTR       dwUser,
    DWORD_PTR       dwReserved1,
    DWORD_PTR       dwReserved2)
{
    PMIXUIDIALOG    pmxud = (PMIXUIDIALOG)dwUser;

    if (!(pmxud->dwFlags & MXUD_FLAGSF_USETIMER))
        return;

    if (pmxud->cTimeInQueue < 5)
    {
        pmxud->cTimeInQueue++;
        PostMessage(pmxud->hwnd, MYWM_TIMER, 0, 0L);
    }
}


#define PROPATOM        TEXT("dingprivprop")
const TCHAR gszDingPropAtom[] = PROPATOM;
#define SETPROP(x,y)    SetProp((x), gszDingPropAtom, (HANDLE)(y))
#define GETPROP(x)      (PMIXUIDIALOG)GetProp((x), gszDingPropAtom)
#define REMOVEPROP(x)   RemoveProp(x,gszDingPropAtom)

LRESULT CALLBACK Volume_TrayVolProc(
    HWND            hwnd,
    UINT            umsg,
    WPARAM          wParam,
    LPARAM          lParam)
{
    PMIXUIDIALOG    pmxud = (PMIXUIDIALOG)GETPROP(hwnd);
    static const TCHAR cszDefSnd[] = TEXT(".Default");

    if (umsg == WM_KILLFOCUS)
    {
        //
        // if we've just been made inactive via keyboard, clear the signal
        //
        pmxud->dwTrayInfo &= ~MXUD_TRAYINFOF_SIGNAL;
    }

    if (umsg == WM_KEYUP && (pmxud->dwTrayInfo & MXUD_TRAYINFOF_SIGNAL))
    {
        if (wParam == VK_UP || wParam == VK_DOWN || wParam == VK_END ||
            wParam == VK_HOME || wParam == VK_LEFT || wParam == VK_RIGHT ||
            wParam == VK_PRIOR || wParam == VK_NEXT || wParam == VK_SPACE)
        {
            PlaySound(cszDefSnd, NULL, SND_ASYNC | SND_ALIAS);
            pmxud->dwTrayInfo &= ~MXUD_TRAYINFOF_SIGNAL;
        }
    }

    if (umsg == WM_LBUTTONUP && (pmxud->dwTrayInfo & MXUD_TRAYINFOF_SIGNAL))
    {
        PlaySound(cszDefSnd, NULL, SND_ASYNC | SND_ALIAS);
        pmxud->dwTrayInfo &= ~MXUD_TRAYINFOF_SIGNAL;

    }
    return CallWindowProc(pmxud->lpfnTrayVol, hwnd, umsg, wParam, lParam);
}


#if(WINVER >= 0x040A)

void DeviceChange_Cleanup()
{
   if (DeviceEventContext)
   {
       UnregisterDeviceNotification(DeviceEventContext);
       DeviceEventContext = 0;
   }

   bUseHandle = FALSE;

   return;
}

/*
**************************************************************************************************
    GetDeviceHandle()

    given a mixerID this functions opens its corresponding device handle. This handle can be used
    to register for DeviceNotifications.

    dwMixerID -- The mixer ID
    phDevice -- a pointer to a handle. This pointer will hold the handle value if the function is
                successful

    return values -- If the handle could be obtained successfully the return vlaue is TRUE.

**************************************************************************************************
*/
BOOL GetDeviceHandle(DWORD dwMixerID, HANDLE *phDevice)
{
    MMRESULT mmr;
    ULONG cbSize=0;
    TCHAR *szInterfaceName=NULL;

    //Query for the Device interface name
    mmr = mixerMessage((HMIXER)ULongToPtr(dwMixerID), DRV_QUERYDEVICEINTERFACESIZE, (DWORD_PTR)&cbSize, 0L);
    if(MMSYSERR_NOERROR == mmr)
    {
        szInterfaceName = (TCHAR *)GlobalAllocPtr(GHND, (cbSize+1)*sizeof(TCHAR));
        if(!szInterfaceName)
        {
            return FALSE;
        }

        mmr = mixerMessage((HMIXER)ULongToPtr(dwMixerID), DRV_QUERYDEVICEINTERFACE, (DWORD_PTR)szInterfaceName, cbSize);
        if(MMSYSERR_NOERROR != mmr)
        {
            GlobalFreePtr(szInterfaceName);
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

    //Get an handle on the device interface name.
    *phDevice = CreateFile(szInterfaceName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    GlobalFreePtr(szInterfaceName);
    if(INVALID_HANDLE_VALUE == *phDevice)
    {
        return FALSE;
    }

    return TRUE;
}


/*  DeviceChange_Init()
*   First time initialization for WM_DEVICECHANGE messages
*
*   On NT 5.0, you have to register for device notification
*/
BOOL DeviceChange_Init(HWND hWnd, DWORD dwMixerID)
{

    DEV_BROADCAST_HANDLE DevBrodHandle;
    DEV_BROADCAST_DEVICEINTERFACE dbi;
    HANDLE hMixerDevice;

    //If we had registered already for device notifications, unregister ourselves.
    DeviceChange_Cleanup();

    //If we get the device handle register for device notifications on it.
    if(GetDeviceHandle(dwMixerID, &hMixerDevice))
    {
        memset(&DevBrodHandle, 0, sizeof(DEV_BROADCAST_HANDLE));

        DevBrodHandle.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
        DevBrodHandle.dbch_devicetype = DBT_DEVTYP_HANDLE;
        DevBrodHandle.dbch_handle = hMixerDevice;

        DeviceEventContext = RegisterDeviceNotification(hWnd, &DevBrodHandle,
                                                    DEVICE_NOTIFY_WINDOW_HANDLE);

        if(hMixerDevice)
        {
            CloseHandle(hMixerDevice);
            hMixerDevice = NULL;
        }

        if(DeviceEventContext)
        {
            bUseHandle = TRUE;
            return TRUE;
        }
    }

    if(!DeviceEventContext)
    {
        //Register for notifications from all audio devices. KSCATEGORY_AUDIO gives notifications
        //on device arrival and removal. We cannot identify which device the notification has arrived for
        //but we can take some precautionary measures on these messages so that we do not crash.
        dbi.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
        dbi.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
        dbi.dbcc_reserved   = 0;
        dbi.dbcc_classguid  = KSCATEGORY_AUDIO;
        dbi.dbcc_name[0] = TEXT('\0');

        DeviceEventContext = RegisterDeviceNotification(hWnd,
                                         (PVOID)&dbi,
                                         DEVICE_NOTIFY_WINDOW_HANDLE);
        if(!DeviceEventContext)
            return FALSE;
    }

    return TRUE;
}

#endif /* WINVER >= 0x040A */


//fixes bug where controls are lopped off on high-contract extra-large modes
void AdjustForStatusBar(PMIXUIDIALOG pmxud)
{
    RECT statusrect, windowrect;
    statusrect.bottom = 0;
    statusrect.top = 0;

    if (pmxud)
    {
        if (pmxud->hStatus)
        {
            GetClientRect(pmxud->hStatus,&statusrect);
            GetWindowRect(pmxud->hwnd,&windowrect);

            if (statusrect.bottom - statusrect.top > 20)
            {
                int y_adjustment = (statusrect.bottom - statusrect.top) - 20;

                MoveWindow(pmxud->hwnd, windowrect.left, windowrect.top, windowrect.right - windowrect.left,
                       (windowrect.bottom - windowrect.top) + y_adjustment, FALSE );

                GetClientRect(pmxud->hwnd,&windowrect);

                MoveWindow(pmxud->hStatus, statusrect.left, windowrect.bottom - (statusrect.bottom - statusrect.top), statusrect.right - statusrect.left,
                       statusrect.bottom - statusrect.top, FALSE );
            }
        } //end if hStatus is valid
    } //end if pmxud is not null
}

/*
 *
 * */
BOOL Volume_Init(
    PMIXUIDIALOG pmxud)
{
    DWORD           iLine, ictrl;
    RECT            rc, rcWnd;


    if (!Mixer_Init(pmxud) && !Nonmixer_Init(pmxud))
    Volume_EndDialog(pmxud, MIXUI_EXIT, 0);

    //
    // For all line controls, make sure we initialize the values.
    //
    for (iLine = 0; iLine < pmxud->cmxul; iLine++)
    {
        //
        // init the ui control
        //
        Volume_InitLine(pmxud, iLine);

        for (ictrl = MIXUI_FIRST; ictrl <= MIXUI_LAST; ictrl++)
        {
            PMIXUICTRL pmxc = &pmxud->amxul[iLine].acr[ictrl];

            //
            // set initial settings
            //
            if (pmxc->state == MIXUI_CONTROL_INITIALIZED)
                Volume_GetControl(pmxud, pmxc->hwnd, iLine, ictrl);
        }
    }

    if (!(pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER))
    {
        RECT    rcBase;
        HWND    hBase;
        RECT    rcAdv,rcBorder;
        HWND    hAdv,hBorder;
        DWORD   i;
        LONG    lPrev;
        POINT   pos;
        HMENU   hmenu;
        HMONITOR hMonitor;
        MONITORINFO monitorInfo;

        if (GetWindowRect(pmxud->hwnd, &rcWnd))
        {
            if (pmxud->cmxul == 1)
            {
                // Adjust size if small
                if (pmxud->dwStyle & MXUD_STYLEF_SMALL)
                    rcWnd.right -= 20;
                ShowWindow(GetDlgItem(pmxud->hwnd, IDC_BORDER), SW_HIDE);
            }

            if (!Volume_GetSetRegistryRect(pmxud->szMixer
                          , pmxud->szDestination
                          , &rc
                          , GET))
            {
                rc.left = rcWnd.left;
                rc.top = rcWnd.top;
            }
            else
            {
                // Check if the rect is visible is any of the monitors
                if (!MonitorFromRect(&rc, MONITOR_DEFAULTTONULL))
                {
                    //The window is not visible. Let's center it in the nearest monitor.
                    //Note: the window could be in this state if (1) the display mode was changed from 
                    //a high-resolution to a lower resolution, with the mixer in the corner. Or,
                    //(2) the multi-mon configuration was rearranged.
                    hMonitor = MonitorFromRect(&rc, MONITOR_DEFAULTTONEAREST);
                    if (hMonitor)
                    {
                        monitorInfo.cbSize = sizeof(MONITORINFO);
                        if (GetMonitorInfo(hMonitor, &monitorInfo))
                        {
                            rc.left = ((monitorInfo.rcWork.right - monitorInfo.rcWork.left) - (rcWnd.right - rcWnd.left)) / 2; //center in x
                            rc.top = ((monitorInfo.rcWork.bottom - monitorInfo.rcWork.top) - (rcWnd.bottom - rcWnd.top)) / 3; //and a little towards the top
                        }
                    }
                }
                //else, the window is visible, so let's leave the (x,y) as read from the settings
            }
            //
            // Adjusted bottom to match switch bottom
            //
            if (!(pmxud->dwStyle & MXUD_STYLEF_SMALL))
            {
                hBase = GetDlgItem(pmxud->hwnd, IDC_SWITCH);
                if (hBase && GetWindowRect(hBase, &rcBase))
                {
                    rcWnd.bottom = rcBase.bottom;
                }

                //
                // Adjusted bottom to match "Advanced" bottom
                //
                if (MXUD_ADVANCED(pmxud))
                {
                    hAdv = GetDlgItem(pmxud->hwnd, IDC_ADVANCED);
                    if (hAdv && GetWindowRect(hAdv, &rcAdv))
                    {
                        lPrev = rcWnd.bottom;
                        rcWnd.bottom = rcAdv.bottom;

                        //
                        // Adjust height of all border lines
                        //
                        lPrev = rcWnd.bottom - lPrev;
                        for (i = 0; i < pmxud->cmxul; i++)
                        {
                            hBorder = GetDlgItem(pmxud->hwnd,
                                     IDC_BORDER+(IDOFFSET*i));
                            if (hBorder && GetWindowRect(hBorder, &rcBorder))
                            {
                                MapWindowPoints(NULL, pmxud->hwnd, (LPPOINT)&rcBorder, 2);
                                pos.x = rcBorder.left;
                                pos.y = rcBorder.top;
                                MoveWindow(hBorder
                                       , pos.x
                                       , pos.y
                                       , rcBorder.right - rcBorder.left
                                       , (rcBorder.bottom - rcBorder.top) + lPrev
                                       , TRUE );
                            }
                        }
                    }
                }
                //
                // Allocate some more space.
                //
                rcWnd.bottom += 28;
            }

            MoveWindow(pmxud->hwnd, rc.left, rc.top, rcWnd.right - rcWnd.left,
                   rcWnd.bottom - rcWnd.top, FALSE );

            //
            // Tack on the status bar after resizing the dialog
            //

            //init status bar hwnd variable
            pmxud->hStatus = NULL;

            if (pmxud->dwStyle & MXUD_STYLEF_STATUS)
            {
                MapWindowPoints(NULL, pmxud->hwnd, (LPPOINT)&rcWnd, 2);
                pos.x = rcWnd.left;
                pos.y = rcWnd.bottom;

                pmxud->hStatus = CreateWindowEx ( gfIsRTL ? WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT | WS_EX_RTLREADING : 0
                                , STATUSCLASSNAME
                                , TEXT ("X")
                                , WS_VISIBLE | WS_CHILD
                                , 0
                                , pos.y
                                , rcWnd.right - rcWnd.left
                                , 14
                                , pmxud->hwnd
                                , NULL
                                , pmxud->hInstance
                                , NULL);

                if (pmxud->hStatus)
                {
                    SendMessage(pmxud->hStatus, WM_SETTEXT, 0,
                     (LPARAM)(LPVOID)(LPTSTR)pmxud->szMixer);
                }
                else
                    pmxud->dwStyle ^= MXUD_STYLEF_STATUS;
            }

            AdjustForStatusBar(pmxud);

            hmenu = GetMenu(pmxud->hwnd);
            CheckMenuItem(hmenu, IDM_ADVANCED, MF_BYCOMMAND
                  | ((pmxud->dwStyle & MXUD_STYLEF_ADVANCED)?MF_CHECKED:MF_UNCHECKED));

            if (pmxud->dwStyle & MXUD_STYLEF_SMALL || pmxud->dwFlags & MXUD_FLAGSF_NOADVANCED)
                EnableMenuItem(hmenu, IDM_ADVANCED, MF_BYCOMMAND | MF_GRAYED);

        }

        if (pmxud->dwFlags & MXUD_FLAGSF_USETIMER)
        {
            pmxud->cTimeInQueue = 0;
            pmxud->uTimerID = timeSetEvent(100
                           , 50
                           , Volume_TimeProc
                           , (DWORD_PTR)pmxud
                           , TIME_PERIODIC);
            if (!pmxud->uTimerID)
            pmxud->dwFlags &= ~MXUD_FLAGSF_USETIMER;
        }
    }
    else
    {
        WNDPROC lpfnOldTrayVol;
        HWND    hVol;

        hVol = pmxud->amxul[0].acr[MIXUI_VOLUME].hwnd;
        lpfnOldTrayVol = SubclassWindow(hVol, Volume_TrayVolProc);

        if (lpfnOldTrayVol)
        {
            pmxud->lpfnTrayVol = lpfnOldTrayVol;
            SETPROP(hVol, pmxud);
        }
    }

    #if(WINVER >= 0x040A)
    //Register for WM_DEVICECHANGE messages
    DeviceChange_Init(pmxud->hwnd, pmxud->mxid);
    #endif /* WINVER >= 0x040A */


    return TRUE;
}


/*
 * Volume_OnInitDialog
 *
 * - Process WM_INITDIALOG
 *
 * */
BOOL Volume_OnInitDialog(
    HWND            hwnd,
    HWND            hwndFocus,
    LPARAM          lParam)
{
    PMIXUIDIALOG    pmxud;
    RECT            rc;

    //
    // set app instance data
    //
    SETMIXUIDIALOG(hwnd, lParam);

    pmxud       = (PMIXUIDIALOG)(LPVOID)lParam;
    pmxud->hwnd = hwnd;

    if (!Volume_Init(pmxud))
    {
        Volume_EndDialog(pmxud, MIXUI_EXIT, 0);
    }
    else
    {
        if (pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER)
            PostMessage(hwnd, MYWM_WAKEUP, 0, 0);
    }

    //
    //  If we are so big that we need a scroll bar, then make one.
    //
    rc.top = rc.bottom = 0;
    rc.left = 60; // typical width of a dialog template
    rc.right = Dlg_HorizSize(pmxud->lpDialog);
    MapDialogRect(hwnd, &rc);
    pmxud->cxDlgContent = rc.right;
    pmxud->cxScroll = rc.left;
    pmxud->xOffset = 0;

    GetClientRect(hwnd, &rc);
    pmxud->xOffset = 0;
    pmxud->cxDlgWidth = rc.right;
    if (rc.right < pmxud->cxDlgContent)
    {
        RECT rcWindow;
        SCROLLINFO si;
        LONG lStyle = GetWindowStyle(hwnd);
        SetWindowLong(hwnd, GWL_STYLE, lStyle | WS_HSCROLL);

        si.cbSize = sizeof(si);
        si.fMask = SIF_PAGE | SIF_RANGE;
        si.nMin = 0;
        si.nMax = pmxud->cxDlgContent - 1;  // endpoint is inclusive
        si.nPage = rc.right;
        SetScrollInfo(hwnd, SB_HORZ, &si, TRUE);

        // Grow the dialog to accomodate the scrollbar
        GetWindowRect(hwnd, &rcWindow);
        SetWindowPos(hwnd, NULL, 0, 0, rcWindow.right - rcWindow.left,
                     rcWindow.bottom - rcWindow.top + GetSystemMetrics(SM_CYHSCROLL),
                     SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE |
                     SWP_NOOWNERZORDER | SWP_NOZORDER);
    }


    //
    // If we are the tray master, don't ask to set focus
    //
    return (!(pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER));
}


/*
 * Volume_OnDestroy
 *
 * Shut down this dialog.  DO NOT TOUCH the hmixer!
 *
 * */
void Volume_OnDestroy(
    HWND            hwnd)
{
    PMIXUIDIALOG    pmxud = GETMIXUIDIALOG(hwnd);

    DeviceChange_Cleanup();

    if (!pmxud)
        return;

    if (pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER)
    {
        HWND    hVol;
        hVol = pmxud->amxul[0].acr[MIXUI_VOLUME].hwnd;
        SubclassWindow(hVol, pmxud->lpfnTrayVol);
        REMOVEPROP(hVol);
    }

    Volume_Cleanup(pmxud);

    if (!(pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER))
    {
        //
        // save window position
        //
        if (!IsIconic(hwnd))
        {
            RECT    rc;
            GetWindowRect(hwnd, &rc);
            Volume_GetSetRegistryRect(pmxud->szMixer
                          , pmxud->szDestination
                          , &rc
                          , SET);
        }
    }

    if (pmxud->dwReturn == MIXUI_RESTART)
        PostMessage(pmxud->hParent, MYWM_RESTART, 0, (LPARAM)pmxud);
    else
        PostMessage(pmxud->hParent, WM_CLOSE, 0, 0L);
}

/*
 * Volume_SetControl
 *
 * Update system controls from visual controls
 *
 * */
void Volume_SetControl(
    PMIXUIDIALOG    pmxud,
    HWND            hctl,
    int             imxul,
    int             itype)
{
    if (pmxud->dwFlags & MXUD_FLAGSF_MIXER)
        Mixer_SetControl(pmxud, hctl, imxul, itype);
    else
        Nonmixer_SetControl(pmxud, hctl, imxul, itype);
}

/*
 * Volume_GetControl
 *
 * Update visual controls from system controls
 * */
void Volume_GetControl(
    PMIXUIDIALOG    pmxud,
    HWND            hctl,
    int             imxul,
    int             itype)
{
    if (pmxud->dwFlags & MXUD_FLAGSF_MIXER)
        Mixer_GetControl(pmxud, hctl, imxul, itype);
    else
        Nonmixer_GetControl(pmxud, hctl, imxul, itype);
}


extern DWORD GetWaveOutID(BOOL *pfPreferred);
/*
 * Volume_PlayDefaultSound
 *
 * Play the default sound on the current mixer
 *
 * */
void Volume_PlayDefaultSound (PMIXUIDIALOG pmxud)
{
/*
// TODO: Implement for all master volumes. Convert mixerid to wave id then
//       use wave API to play the file

    TCHAR szDefSnd[MAX_PATH];
    long lcb = sizeof (szDefSnd);

    // Get the default sound filename
    if (ERROR_SUCCESS != RegQueryValue (HKEY_CURRENT_USER, REGSTR_PATH_APPS_DEFAULT TEXT("\\.Default\\.Current"), szDefSnd, &lcb) ||
        0 >= lstrlen (szDefSnd))
        return;
*/

    DWORD dwWave = GetWaveOutID (NULL);
    UINT uiMixID;

     // Check Parameter
    if (!pmxud)
        return;

    // Play the sound only if we are on the default mixer...
    if (MMSYSERR_NOERROR == mixerGetID (ULongToPtr(dwWave), &uiMixID, MIXER_OBJECTF_WAVEOUT) &&
        pmxud -> mxid == uiMixID)
    {

        static const TCHAR cszDefSnd[] = TEXT(".Default");
        PlaySound(cszDefSnd, NULL, SND_ASYNC | SND_ALIAS);
    }
}

/*
 * Volume_ScrollTo
 *
 * Move the scrollbar position.
 */
void Volume_ScrollTo(
    PMIXUIDIALOG pmxud,
    int pos
)
{
    RECT rc;

    /*
     *  Keep in range.
     */
    pos = max(pos, 0);
    pos = min(pos, pmxud->cxDlgContent - pmxud->cxDlgWidth);

    /*
     *  Scroll the window contents accordingly.  But don't scroll
     *  the status bar.
     */

    GetClientRect(pmxud->hwnd, &rc);
    if (pmxud->hStatus)
    {
        RECT rcStatus;
        GetWindowRect(pmxud->hStatus, &rcStatus);
        MapWindowRect(NULL, pmxud->hwnd, &rcStatus);
        SubtractRect(&rc, &rc, &rcStatus);
    }

    rc.left = -pmxud->cxDlgContent;
    rc.right = pmxud->cxDlgContent;

    ScrollWindowEx(pmxud->hwnd, pmxud->xOffset - pos, 0,
                   &rc, NULL, NULL, NULL,
                   SW_ERASE | SW_INVALIDATE | SW_SCROLLCHILDREN);
    pmxud->xOffset = pos;

    /*
     *  Move the scrollbar to match.
     */
    SetScrollPos(pmxud->hwnd, SB_HORZ, pos, TRUE);
}

/*
 * Volume_ScrollContent
 *
 * Process scroll bar messages for the dialog itself.
 */

void Volume_ScrollContent(
    PMIXUIDIALOG pmxud,
    UINT code,
    int pos
)
{
    switch (code) {
    case SB_LINELEFT:
        Volume_ScrollTo(pmxud, pmxud->xOffset - pmxud->cxScroll);
        break;

    case SB_LINERIGHT:
        Volume_ScrollTo(pmxud, pmxud->xOffset + pmxud->cxScroll);
        break;

    case SB_PAGELEFT:
        Volume_ScrollTo(pmxud, pmxud->xOffset - pmxud->cxDlgWidth);
        break;

    case SB_PAGERIGHT:
        Volume_ScrollTo(pmxud, pmxud->xOffset + pmxud->cxDlgWidth);
        break;

    case SB_LEFT:
        Volume_ScrollTo(pmxud, 0);
        break;

    case SB_RIGHT:
        Volume_ScrollTo(pmxud, MAXLONG);
        break;

    case SB_THUMBPOSITION:
    case SB_THUMBTRACK:
        Volume_ScrollTo(pmxud, pos);
        break;
    }
}

/*
 * Volume_OnXScroll
 *
 * Process Scroll bar messages
 *
 * */
void Volume_OnXScroll(
    HWND            hwnd,
    HWND            hwndCtl,
    UINT            code,
    int             pos)
{
    PMIXUIDIALOG    pmxud = GETMIXUIDIALOG(hwnd);
    UINT            id;
    int             ictl;
    int             iline;

    // If this is a scroll message from the dialog itself, then we need
    // to scroll our content.
    if (hwndCtl == NULL)
    {
        Volume_ScrollContent(pmxud, code, pos);
        return;
    }

    id              = GetDlgCtrlID(hwndCtl);
    iline           = id/IDOFFSET - 1;
    ictl            = ((id % IDOFFSET) + IDC_MIXERCONTROLS == IDC_BALANCE)
              ? MIXUI_BALANCE : MIXUI_VOLUME;

    Volume_SetControl(pmxud, hwndCtl, iline, ictl);

    //
    // Make sure a note gets played
    //
    if (pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER)
    pmxud->dwTrayInfo |= MXUD_TRAYINFOF_SIGNAL;

    // Play a sound on for the master volume or balance slider when the
    // user ends the scroll and we are still in focus and the topmost app.
    if (code == SB_ENDSCROLL && pmxud && !(pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER) &&
        pmxud->amxul[iline].pvcd &&
       (MXUL_STYLEF_DESTINATION & pmxud->amxul[iline].dwStyle)
       && hwndCtl ==  GetFocus() && hwnd == GetForegroundWindow ())
    {
        Volume_PlayDefaultSound (pmxud);
    }
}

/*
 * Volume_OnMyTimer
 *
 * Frequent update timer for meters
 * */
void Volume_OnMyTimer(
    HWND            hwnd)
{
    PMIXUIDIALOG    pmxud = GETMIXUIDIALOG(hwnd);

    if (!pmxud)
        return;

    if (pmxud->cTimeInQueue > 0)
        pmxud->cTimeInQueue--;

    if (!(pmxud->dwFlags & MXUD_FLAGSF_USETIMER))
        return;

    if (pmxud->dwFlags & MXUD_FLAGSF_MIXER)
        Mixer_PollingUpdate(pmxud);
    else
        Nonmixer_PollingUpdate(pmxud);
}

/*
 * Volume_OnTimer
 *
 * Infrequent update timer for tray shutdown
 * */
void Volume_OnTimer(
    HWND            hwnd,
    UINT            id)
{
    PMIXUIDIALOG    pmxud = GETMIXUIDIALOG(hwnd);

    KillTimer(hwnd, VOLUME_TRAYSHUTDOWN_ID);
    Volume_EndDialog(pmxud, MIXUI_EXIT, 0);
}

/*
 * Volume_OnMixmControlChange
 *
 * Handle control changes
 *
 * */
void Volume_OnMixmControlChange(
    HWND            hwnd,
    HMIXER          hmx,
    DWORD           dwControlID)
{
    PMIXUIDIALOG    pmxud = GETMIXUIDIALOG(hwnd);
    Mixer_GetControlFromID(pmxud, dwControlID);
}

/*
 * Volume_EnableLine
 *
 * Enable/Disable a line
 *
 * */
void Volume_EnableLine(
    PMIXUIDIALOG    pmxud,
    DWORD           iLine,
    BOOL            fEnable)
{
    DWORD           iCtrl;
     PMIXUICTRL      pmxc;

    for (iCtrl = MIXUI_FIRST; iCtrl <= MIXUI_LAST; iCtrl++ )
    {
        pmxc = &pmxud->amxul[iLine].acr[iCtrl];
        if (pmxc->state == MIXUI_CONTROL_INITIALIZED)
            EnableWindow(pmxc->hwnd, fEnable);
    }

    pmxud->amxul[iLine].dwStyle ^= MXUL_STYLEF_DISABLED;
}

/*
 * Volume_InitLine
 *
 * Initialize the UI controls for the dialog
 *
 * */
void Volume_InitLine(
    PMIXUIDIALOG    pmxud,
    DWORD           iLine)
{
    HWND            ctrl;
    PMIXUICTRL      pmxc;

    //
    // Peakmeter control
    //
    pmxc = &pmxud->amxul[iLine].acr[MIXUI_VUMETER];
    ctrl = Volume_GetLineItem(pmxud->hwnd, iLine, IDC_VUMETER);

    pmxc->hwnd  = ctrl;

    if (! (pmxc->state == MIXUI_CONTROL_ENABLED) )
    {
        if (ctrl)
            ShowWindow(ctrl, SW_HIDE);
    }
    else if (ctrl)
    {
        HWND    hvol;

        SendMessage(ctrl, VU_SETRANGEMAX, 0, VOLUME_TICS);
        SendMessage(ctrl, VU_SETRANGEMIN, 0, 0);

        hvol = Volume_GetLineItem(pmxud->hwnd, iLine, IDC_VOLUME);
        if (hvol)
        {
            RECT    rc;
            POINT   pos;

            GetWindowRect(hvol, &rc);
            MapWindowPoints(NULL, pmxud->hwnd, (LPPOINT)&rc, 2);
            pos.x = rc.left;
            pos.y = rc.top;

            MoveWindow(hvol
                   , pos.x - 15
                   , pos.y
                   , rc.right - rc.left
                   , rc.bottom - rc.top
                   , FALSE);
        }
        //
        // Signal use of update timer
        //
        pmxud->dwFlags |= MXUD_FLAGSF_USETIMER;
        pmxc->state = MIXUI_CONTROL_INITIALIZED;

    }
    else
        pmxc->state = MIXUI_CONTROL_UNINITIALIZED;


    //
    // Balance control
    //
    pmxc = &pmxud->amxul[iLine].acr[MIXUI_BALANCE];
    ctrl = Volume_GetLineItem(pmxud->hwnd, iLine, IDC_BALANCE);

    pmxc->hwnd  = ctrl;

    if (ctrl)
    {
        SendMessage(ctrl, TBM_SETRANGE, 0, MAKELONG(0, 64));
        SendMessage(ctrl, TBM_SETTICFREQ, 32, 0 );
        SendMessage(ctrl, TBM_SETPOS, TRUE, 32);

        if (pmxc->state != MIXUI_CONTROL_ENABLED)
        {
            EnableWindow(ctrl, FALSE);
        }
        else
            pmxc->state = MIXUI_CONTROL_INITIALIZED;

    }
    else
        pmxc->state = MIXUI_CONTROL_UNINITIALIZED;

    //
    // Volume control
    //
    pmxc = &pmxud->amxul[iLine].acr[MIXUI_VOLUME];
    ctrl = Volume_GetLineItem(pmxud->hwnd, iLine, IDC_VOLUME);

    pmxc->hwnd  = ctrl;

    if (ctrl)
    {
        SendMessage(ctrl, TBM_SETRANGE, 0, MAKELONG(0, VOLUME_TICS));
        SendMessage(ctrl, TBM_SETTICFREQ, (VOLUME_TICS + 5)/6, 0 );

        if (pmxc->state != MIXUI_CONTROL_ENABLED)
        {
            SendMessage(ctrl, TBM_SETPOS, TRUE, 128);
            EnableWindow(ctrl, FALSE);
        }
        else
            pmxc->state = MIXUI_CONTROL_INITIALIZED;

    }
    else
        pmxc->state = MIXUI_CONTROL_UNINITIALIZED;

    //
    // Switch
    //
    pmxc = &pmxud->amxul[iLine].acr[MIXUI_SWITCH];
    ctrl = Volume_GetLineItem(pmxud->hwnd, iLine, IDC_SWITCH);

    pmxc->hwnd  = ctrl;

    if (ctrl)
    {
        if (pmxc->state != MIXUI_CONTROL_ENABLED)
            EnableWindow(ctrl, FALSE);
        else
            pmxc->state = MIXUI_CONTROL_INITIALIZED;
    }
    else
        pmxc->state = MIXUI_CONTROL_UNINITIALIZED;

}


/*
 * Volume_OnMixmLineChange
 *
 * */
void Volume_OnMixmLineChange(
    HWND            hwnd,
    HMIXER          hmx,
    DWORD           dwLineID)
{
    PMIXUIDIALOG    pmxud = GETMIXUIDIALOG(hwnd);
    DWORD           iLine;

    for (iLine = 0; iLine < pmxud->cmxul; iLine++)
    {
        if ( dwLineID == pmxud->amxul[iLine].pvcd->dwLineID )
        {
            MIXERLINE       ml;
            MMRESULT        mmr;
            BOOL            fEnable;

            ml.cbStruct     = sizeof(ml);
            ml.dwLineID     = dwLineID;

            mmr = mixerGetLineInfo((HMIXEROBJ)hmx, &ml, MIXER_GETLINEINFOF_LINEID);

            if (mmr != MMSYSERR_NOERROR)
            {
                fEnable = !(ml.fdwLine & MIXERLINE_LINEF_DISCONNECTED);
                Volume_EnableLine(pmxud, iLine, fEnable);
            }
        }
    }
}


/*
 * Volume_OnActivate
 *
 * Important for tray volume only.  Dismisses the dialog and starts an
 * expiration timer.
 *
 * */
void Volume_OnActivate(
    HWND            hwnd,
    UINT            state,
    HWND            hwndActDeact,
    BOOL            fMinimized)
{
    PMIXUIDIALOG pmxud = GETMIXUIDIALOG(hwnd);

    if (!(pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER))
    {
        return;
    }

    if (state != WA_INACTIVE)
    {
        fCanDismissWindow = TRUE;
    }
    else if (fCanDismissWindow)
    {
        PostMessage(hwnd, WM_CLOSE, 0, 0L);
/*
        DWORD   dwTimeout = 5 * 60 * 1000;
        fCanDismissWindow = FALSE;
        ShowWindow(hwnd, SW_HIDE);
        //
        // Set expiration timer.  If no one adjusts the volume, make the
        // application go away after 5 minutes.
        //
        dwTimeout = Volume_GetTrayTimeout(dwTimeout);
        SetTimer(hwnd, VOLUME_TRAYSHUTDOWN_ID, dwTimeout, NULL);
*/
    }
}


/*
 * Volume_PropogateMessage
 *
 * WM_SYSCOLORCHANGE needs to be send to all child windows (esp. trackbars)
 */
void Volume_PropagateMessage(
    HWND        hwnd,
    UINT        uMessage,
    WPARAM      wParam,
    LPARAM      lParam)
{
    HWND hwndChild;

    for (hwndChild = GetWindow(hwnd, GW_CHILD); hwndChild != NULL;
         hwndChild = GetWindow(hwndChild, GW_HWNDNEXT))
    {
        SendMessage(hwndChild, uMessage, wParam, lParam);
    }
}

/*
 * Volume_OnPaint
 *
 * Handle custom painting
 * */
void Volume_OnPaint(HWND hwnd)
{
    PMIXUIDIALOG    pmxud = GETMIXUIDIALOG(hwnd);
    RECT            rc;
    PAINTSTRUCT     ps;
    HDC             hdc;

    hdc = BeginPaint(hwnd, &ps);

    //
    // for all styles other than the tray master, draw an etched
    // line to delinate the menu area
    //
    if (!(pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER))
    {
        GetClientRect(hwnd, &rc);
        rc.bottom = 0;
        DrawEdge(hdc, &rc, EDGE_ETCHED, BF_TOP);
        EndPaint(hwnd, &ps);
        return;
    }

    //
    // for the tray master, draw some significant icon to indicate
    // volume
    //
    GetWindowRect(GetDlgItem(hwnd, IDC_VOLUMECUE), &rc);

    MapWindowPoints(NULL, hwnd, (LPPOINT)&rc, 2);

    DrawEdge(hdc, &rc, BDR_RAISEDINNER, BF_DIAGONAL|BF_TOP|BF_LEFT);
    DrawEdge(hdc, &rc, BDR_RAISEDINNER, BF_TOP);
    rc.bottom   -= 8;
    DrawEdge(hdc, &rc, BDR_RAISEDINNER, BF_RIGHT);

    EndPaint(hwnd, &ps);
}

/*
 * Volume_OnClose
 *
 * */
void Volume_OnClose(
    HWND    hwnd)
{
    DestroyWindow(hwnd);
}

/*
 * Volume_OnEndSession
 *
 * */
void Volume_OnEndSession(
    HWND        hwnd,
    BOOL        fEnding)
{
    if (!fEnding)
        return;

    //
    // Be sure to call the close code to free open handles
    //
    Volume_OnClose(hwnd);
}

#define V_DC_STATEF_PENDING     0x00000001
#define V_DC_STATEF_REMOVING    0x00000002
#define V_DC_STATEF_ARRIVING    0x00000004

/*
 * Volume_OnDeviceChange
 *
 * */
void Volume_OnDeviceChange(
    HWND        hwnd,
    WPARAM      wParam,
    LPARAM      lParam)
{
    PMIXUIDIALOG    pmxud = GETMIXUIDIALOG(hwnd);
    MMRESULT        mmr;
    UINT            uMxID;
    PDEV_BROADCAST_DEVICEINTERFACE bdi = (PDEV_BROADCAST_DEVICEINTERFACE)lParam;
    PDEV_BROADCAST_HANDLE bh = (PDEV_BROADCAST_HANDLE)lParam;

    //
    // Determine if this is our event.
    //
    if(!DeviceEventContext)
        return;

    //If we have an handle on the device then we get a DEV_BROADCAST_HDR structure as the lParam.
    //Or else it means that we have registered for the general audio category KSCATEGORY_AUDIO.
    if(bUseHandle)
    {
        if(!bh ||
           bh->dbch_devicetype != DBT_DEVTYP_HANDLE)
        {
            return;
        }
    }
    else if (!bdi ||
       bdi->dbcc_devicetype != DBT_DEVTYP_DEVICEINTERFACE ||
       !IsEqualGUID(&KSCATEGORY_AUDIO, &bdi->dbcc_classguid) ||
       !(*bdi->dbcc_name)
       )
    {
       return;
    }


    switch (wParam)
    {
        case DBT_DEVICEQUERYREMOVE:
            //The mixer has to be shutdown now.
            //Posting a WM_CLOSE message as Volume_EndDialog does will not help.
            if (pmxud->dwFlags & MXUD_FLAGSF_MIXER)
                Mixer_Shutdown(pmxud);
            else
                Nonmixer_Shutdown(pmxud);

            // Don't attempt restart, just exit. The wavemapper is not
            // updated with the new default device, so do not know what
            // to restart as and we should NOT hardcode device #0!
            // pmxud->mxid = (DWORD) 0;
            // GetDestination(pmxud->mxid, &pmxud->iDest);
            Volume_EndDialog(pmxud, MIXUI_EXIT, 0);
            return;


        case DBT_DEVICEQUERYREMOVEFAILED:       // The query failed, the device will not be removed, so lets reopen it.

            mmr = Volume_GetDefaultMixerID(&uMxID, gfRecord);
            pmxud->mxid = (mmr == MMSYSERR_NOERROR)?uMxID:0;
            GetDestination(pmxud->mxid, &pmxud->iDest);
            Volume_EndDialog(pmxud, MIXUI_RESTART, 0);
            return;

        case DBT_DEVNODES_CHANGED:
            //
            // We cannot reliably determine the final state of the devices in
            // the system until this message is broadcast.
            //
            if (pmxud->dwDeviceState & V_DC_STATEF_PENDING)
            {
                pmxud->dwDeviceState ^= V_DC_STATEF_PENDING;
                break;
            }
            return;

        case DBT_DEVICEREMOVECOMPLETE:
            //The mixer has to be shutdown now.
            //Posting a WM_CLOSE message as Volume_EndDialog does will not help.
            if (pmxud->dwFlags & MXUD_FLAGSF_MIXER)
                Mixer_Shutdown(pmxud);
            else
                Nonmixer_Shutdown(pmxud);

            //A DBT_DEVICEQUERYREMOVE is not guaranteed before a DBT_DEVICEREMOVECOMPLETE.
            //There should be a check here to see if this message is meant for this device.
            //We do not know a way of doing that right now.

            // Don't attempt restart, just exit. The wavemapper is not
            // updated with the new default device, so do not know what
            // to restart as and we should NOT hardcode device #0!
            // pmxud->mxid = (DWORD) 0;
            // GetDestination(pmxud->mxid, &pmxud->iDest);
            Volume_EndDialog(pmxud, MIXUI_EXIT, 0);

            pmxud->dwDeviceState = V_DC_STATEF_PENDING
                            | V_DC_STATEF_REMOVING;
                return;
        case DBT_DEVICEARRIVAL:
            //
            //  A devnode is being added to the system
            //
            pmxud->dwDeviceState = V_DC_STATEF_PENDING
                           | V_DC_STATEF_ARRIVING;
            return;

        default:
            return;
    }

    mmr = Volume_GetDefaultMixerID(&uMxID, gfRecord);

    if (pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER)
    {
        if ( mmr == MMSYSERR_NOERROR
             && (pmxud->dwDeviceState & V_DC_STATEF_ARRIVING))
        {
            DWORD dwDevNode;
            if (!mixerMessage((HMIXER)UIntToPtr(uMxID), DRV_QUERYDEVNODE
                      , (DWORD_PTR)&dwDevNode, 0L))
            {
                if (dwDevNode == pmxud->dwDevNode)
                {
                    //
                    // ignore this device, it doesn't affect us
                    //
                    pmxud->dwDeviceState = 0L;
                    return;
                }
            }
        }

        //
        // Our device state has changed.  Just go away.
        //
        Volume_EndDialog(pmxud, MIXUI_EXIT, 0);
    }
    else if (pmxud->dwDeviceState & V_DC_STATEF_REMOVING)
    {
        //
        // Restart with the default mixer if we can.
        //
        pmxud->mxid = (mmr == MMSYSERR_NOERROR)?uMxID:0;
        GetDestination(pmxud->mxid, &pmxud->iDest);
        Volume_EndDialog(pmxud, MIXUI_RESTART, 0);
    }
    pmxud->dwDeviceState = 0L;
}


void Volume_OnWakeup(
    HWND        hwnd,
    WPARAM      wParam)
{
    POINT       pos;
    RECT        rc, rcPopup;
    LONG        w,h;
    HWND        hTrack;
    HMONITOR    hMonitor;
    MONITORINFO moninfo;

    PMIXUIDIALOG pmxud = GETMIXUIDIALOG(hwnd);

    if (!(pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER))
        return;

    KillTimer(hwnd, VOLUME_TRAYSHUTDOWN_ID);

    if (wParam != 0)
    {
        Volume_EndDialog(pmxud, MIXUI_EXIT, 0);
        return;
    }

    //
    // Make the tray volume come up.
    //

    //Get the current position.
    GetCursorPos(&pos);

    //Get the width and height of the popup.
    GetWindowRect(hwnd, &rc);
    w = rc.right - rc.left; //This value will always be positive as left is always lesser than right.
    h = rc.bottom - rc.top; //This value will always be positive as top is always lesser than bottom.

    //Initialize the rectangle for the popup. Position it so that the popup appears to the right,
    //bottom of the cursor.
    rcPopup.left = pos.x;
    rcPopup.right = pos.x + w;
    rcPopup.top = pos.y;
    rcPopup.bottom = pos.y+h;

    //Get the rectangle for the monitor.
    hMonitor = MonitorFromPoint(pos, MONITOR_DEFAULTTONEAREST);
    moninfo.cbSize = sizeof(moninfo);
    GetMonitorInfo(hMonitor,&moninfo);

    //If the popup rectangle is leaking off from the right of the screen. Make it appear on the
    //left of the cursor.
    if(rcPopup.right > moninfo.rcWork.right)
    {
        OffsetRect(&rcPopup, -w, 0);
    }

    //If the popup rectangle is leaking off from the bottom of the screen. Make it appear on top
    //of the cursor.
    if(rcPopup.bottom > moninfo.rcWork.bottom)
    {
        OffsetRect(&rcPopup, 0, -h);
    }


    SetWindowPos(hwnd
         , HWND_TOPMOST
         , rcPopup.left
         , rcPopup.top
         , w
         , h
         , SWP_SHOWWINDOW);

    // make us come to the front
    SetForegroundWindow(hwnd);
    fCanDismissWindow = TRUE;

    hTrack = GetDlgItem(hwnd, IDC_VOLUME);
    if (hTrack)
        SetFocus(hTrack);
}


/*
 * VolumeProc
 *
 * */
INT_PTR CALLBACK VolumeProc(
    HWND            hdlg,
    UINT            msg,
    WPARAM          wparam,
    LPARAM          lparam)
{
    switch (msg)
    {
        case WM_INITDIALOG:
            return HANDLE_WM_INITDIALOG(hdlg, wparam, lparam, Volume_OnInitDialog);

        case WM_COMMAND:
            HANDLE_WM_COMMAND(hdlg, wparam, lparam, Volume_OnCommand);
            break;

        case WM_CLOSE:
            HANDLE_WM_CLOSE(hdlg, wparam, lparam, Volume_OnClose);
            break;

        case WM_DESTROY:
            HANDLE_WM_DESTROY(hdlg, wparam, lparam, Volume_OnDestroy);
            break;

        case WM_HSCROLL:
        case WM_VSCROLL:
            //
            // balance and volume are essentially the same
            //
            HANDLE_WM_XSCROLL(hdlg, wparam, lparam, Volume_OnXScroll);
            break;

        case WM_MENUSELECT:
            //Keep track of which menu bar item is currently popped up.
            //This will be used for displaying the appropriate help from the mplayer.hlp file
            //when the user presses the F1 key.
            currMenuItem = (UINT)LOWORD(wparam);
            break;

        case MM_MIXM_LINE_CHANGE:
            HANDLE_MM_MIXM_LINE_CHANGE(hdlg
                           , wparam
                           , lparam
                           , Volume_OnMixmLineChange);
            return FALSE;

        case MM_MIXM_CONTROL_CHANGE:
            HANDLE_MM_MIXM_CONTROL_CHANGE(hdlg
                          , wparam
                          , lparam
                          , Volume_OnMixmControlChange);
            return FALSE;

        case WM_ACTIVATE:
            HANDLE_WM_ACTIVATE(hdlg, wparam, lparam, Volume_OnActivate);
            break;

        case MYWM_TIMER:
            HANDLE_MYWM_TIMER(hdlg, wparam, lparam, Volume_OnMyTimer);
            break;

        case WM_TIMER:
            HANDLE_WM_TIMER(hdlg, wparam, lparam, Volume_OnTimer);
            break;

        case WM_PAINT:
            HANDLE_WM_PAINT(hdlg, wparam, lparam, Volume_OnPaint);
            break;

        case WM_SYSCOLORCHANGE:
            Volume_PropagateMessage(hdlg, msg, wparam, lparam);
            break;

        case WM_DEVICECHANGE:
            HANDLE_WM_IDEVICECHANGE(hdlg, wparam, lparam, Volume_OnDeviceChange);
            break;

        case MYWM_WAKEUP:
            HANDLE_MYWM_WAKEUP(hdlg, wparam, lparam, Volume_OnWakeup);
            break;

        case WM_ENDSESSION:
            HANDLE_WM_ENDSESSION(hdlg, wparam, lparam, Volume_OnEndSession);
            break;

        default:
            break;
    }
    return FALSE;
}

/*
 * Volume_AddLine
 *
 * */
BOOL Volume_AddLine(
    PMIXUIDIALOG    pmxud,
    LPBYTE          lpAdd,
    DWORD           cbAdd,
    DWORD           dwStyle,
    PVOLCTRLDESC    pvcd)
{
    LPBYTE          pbNew;
    DWORD           cbNew;
    PMIXUILINE      pmxul;

    if (pmxud->amxul)
    {
        pmxul = (PMIXUILINE)GlobalReAllocPtr(pmxud->amxul
                             , (pmxud->cmxul+1)*sizeof(MIXUILINE)
                             , GHND);
    }
    else
    {
        pmxul = (PMIXUILINE)GlobalAllocPtr(GHND, sizeof(MIXUILINE));
    }

    if (!pmxul)
        return FALSE;

    pbNew = Dlg_HorizAttach(pmxud->lpDialog
                , pmxud->cbDialog
                , lpAdd
                , cbAdd
                , (WORD)(IDOFFSET * pmxud->cmxul)
                , &cbNew );
    if (!pbNew)
    {
        if (!pmxud->amxul)
            GlobalFreePtr(pmxul);

        return FALSE;
    }

    pmxul[pmxud->cmxul].dwStyle  = dwStyle;
    pmxul[pmxud->cmxul].pvcd     = pvcd;

    pmxud->amxul        = pmxul;
    pmxud->lpDialog     = pbNew;
    pmxud->cbDialog     = cbNew;
    pmxud->cmxul ++;

    return TRUE;
}

/*
 * Volume_Cleanup
 *
 * */
void Volume_Cleanup(
    PMIXUIDIALOG pmxud)
{
    if (pmxud->dwFlags & MXUD_FLAGSF_USETIMER)
    {
        timeKillEvent(pmxud->uTimerID);
        pmxud->dwFlags ^= MXUD_FLAGSF_USETIMER;
    }
    if (pmxud->dwFlags & MXUD_FLAGSF_BADDRIVER)
    {
        pmxud->dwFlags ^= MXUD_FLAGSF_BADDRIVER;
    }
    if (pmxud->dwFlags & MXUD_FLAGSF_NOADVANCED)
    {
        pmxud->dwFlags ^= MXUD_FLAGSF_NOADVANCED;
    }

    if (pmxud->dwFlags & MXUD_FLAGSF_MIXER)
        Mixer_Shutdown(pmxud);
    else
        Nonmixer_Shutdown(pmxud);

    if (pmxud->lpDialog)
        GlobalFreePtr(pmxud->lpDialog);

    if (pmxud->amxul)
        GlobalFreePtr(pmxud->amxul);

    if (pmxud->avcd)
        GlobalFreePtr(pmxud->avcd);

    pmxud->amxul    = NULL;
    pmxud->lpDialog = NULL;
    pmxud->cbDialog = 0;
    pmxud->cmxul    = 0;
    pmxud->hwnd     = NULL;
    pmxud->hStatus  = NULL;
    pmxud->uTimerID = 0;
    pmxud->dwDevNode = 0L;

    FreeAppIcon ();
}

/*
 * Volume_CreateVolume
 * */
BOOL Volume_CreateVolume(
    PMIXUIDIALOG    pmxud)
{
    WNDCLASS        wc;
    LPBYTE          lpDst = NULL, lpSrc = NULL, lpMaster = NULL;
    DWORD           cbDst, cbSrc, cbMaster;
    PVOLCTRLDESC    avcd;
    DWORD           cvcd;
    DWORD           ivcd;
    DWORD           imxul;
    DWORD           dwSupport = 0L;
    BOOL            fAddLine = TRUE;

    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon            = GetAppIcon (pmxud->hInstance, pmxud->mxid);
    wc.lpszMenuName     = NULL;
    wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1);
    wc.hInstance        = pmxud->hInstance;
    wc.style            = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc      = DefDlgProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = DLGWINDOWEXTRA;
    wc.lpszClassName    = (pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER)
              ? gszTrayClassName : gszAppClassName;
    RegisterClass(&wc);

    if (pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER)
    {
        lpMaster = (LPBYTE)Dlg_LoadResource(pmxud->hInstance
                           , MAKEINTRESOURCE(IDD_TRAYMASTER)
                           , &cbMaster);
        if (!lpMaster)
            return FALSE;
    }
    else
    {
        if (pmxud->dwStyle & MXUD_STYLEF_SMALL)
        {
            lpDst = (LPBYTE)Dlg_LoadResource(pmxud->hInstance
                             , MAKEINTRESOURCE(IDD_SMDST)
                             , &cbDst);

            lpSrc = (LPBYTE)Dlg_LoadResource(pmxud->hInstance
                             , MAKEINTRESOURCE(IDD_SMSRC)
                             , &cbSrc);

        }
        else
        {
            lpDst = (LPBYTE)Dlg_LoadResource(pmxud->hInstance
                             , MAKEINTRESOURCE(IDD_DESTINATION)
                             , &cbDst);

            lpSrc = (LPBYTE)Dlg_LoadResource(pmxud->hInstance
                             , MAKEINTRESOURCE(IDD_SOURCE)
                             , &cbSrc);
        }

        if (!lpDst || !lpSrc)
            return FALSE;
    }

    pmxud->lpDialog = NULL;
    pmxud->cbDialog = 0;
    pmxud->amxul    = NULL;
    pmxud->cmxul    = 0;
    pmxud->avcd     = NULL;
    pmxud->cvcd     = 0;

    //
    // Create the volume description
    //

    if (pmxud->dwFlags & MXUD_FLAGSF_MIXER)
    {
        HMIXER          hmx;
        MMRESULT        mmr;

        //
        //  Mixer API's work much more efficiently with a mixer handle...
        //
        mmr = mixerOpen(&hmx, pmxud->mxid, 0L, 0L, MIXER_OBJECTF_MIXER);


        if(MMSYSERR_NOERROR == mmr)
        {
            avcd = Mixer_CreateVolumeDescription((HMIXEROBJ)hmx
                                 , pmxud->iDest
                                 , &cvcd);

            mixerClose(hmx);
        }
        else
        {
            avcd = Mixer_CreateVolumeDescription((HMIXEROBJ)ULongToPtr(pmxud->mxid)
                                 , pmxud->iDest
                                 , &cvcd);
        }

        if (!Mixer_GetDeviceName(pmxud))
        {
            GlobalFreePtr(avcd);
            avcd = NULL;
        }
    }
    else
    {
        avcd = Nonmixer_CreateVolumeDescription(pmxud->iDest
                            , &cvcd);
        if (!Nonmixer_GetDeviceName(pmxud))
        {
            GlobalFreePtr(avcd);
            avcd = NULL;
        }
    }


    //
    // Create the dialog box to go along with it
    //
    if (avcd)
    {
        pmxud->avcd = avcd;
        pmxud->cvcd = cvcd;

        if (pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER)
        {
            if (!Volume_AddLine(pmxud
                   , lpMaster
                   , cbMaster
                   , MXUL_STYLEF_DESTINATION
                   , &avcd[0]))
            {
                return FALSE;
            }
        }
        else
        {
            BOOL    fFirstRun;
            //
            // Restore HIDDEN flags.
            //
            // On first run, be sure to re-save state so there's something
            // there.
            //
            fFirstRun = !Volume_GetSetRegistryLineStates(pmxud->szMixer
                                 , pmxud->avcd[0].szShortName
                                 , avcd
                                 , cvcd
                                 , GET);


            for (ivcd = 0; ivcd < cvcd; ivcd++)
            {
                //
                // Lines are marked hidden if a state has been saved in the
                // registry or no state has been saved and there are too many
                // unnecessary lines.
                //
                if (avcd[ivcd].dwSupport & VCD_SUPPORTF_HIDDEN)
                {
                    continue;
                }

                //
                // Lines are marked VISIBLE if they have sufficient controls
                // to be useful.
                //
                if (!(avcd[ivcd].dwSupport & VCD_SUPPORTF_VISIBLE))
                {
                    continue;
                }

                //
                // Show only defaults on first run.
                //
                if (fFirstRun && !(avcd[ivcd].dwSupport & VCD_SUPPORTF_DEFAULT))
                {
                    avcd[ivcd].dwSupport |= VCD_SUPPORTF_HIDDEN;
                    continue;
                }

                //
                // For those lines that have important controls, add them to
                // the UI.
                //
                if ((pmxud->dwFlags & MXUD_FLAGSF_MIXER) && ivcd == 0 )
                    fAddLine = Volume_AddLine(pmxud
                           , lpDst
                           , cbDst
                           , MXUL_STYLEF_DESTINATION
                           , &avcd[ivcd]);
                else
                    fAddLine = Volume_AddLine(pmxud
                           , lpSrc
                           , cbSrc
                           , MXUL_STYLEF_SOURCE
                           , &avcd[ivcd]);

                if (!fAddLine)
                {
                    return FALSE;
                }
            }

            if (fFirstRun)
                Volume_GetSetRegistryLineStates(pmxud->szMixer
                                , pmxud->avcd[0].szShortName
                                , avcd
                                , cvcd
                                , SET);
        }

        //
        // Now that both arrays are now fixed, set back pointers for
        // the vcd's to ui lines.
        //
        for (imxul = 0; imxul < pmxud->cmxul; imxul++)
        {
            pmxud->amxul[imxul].pvcd->pmxul = &pmxud->amxul[imxul];

            //
            // Accumulate support bits
            //
            dwSupport |= pmxud->amxul[imxul].pvcd->dwSupport;
        }

        //
        // Support bits say we have no advanced controls, so don't make
        // them available.
        //
        if (!(dwSupport & VCD_SUPPORTF_MIXER_ADVANCED))
        {
            pmxud->dwFlags |= MXUD_FLAGSF_NOADVANCED;
        }

        //
        // Propogate bad driver bit to be app global.  A bad driver was
        // detected during the construction of a volume description.
        //
        for (ivcd = 0; ivcd < pmxud->cvcd; ivcd++)
        {
            if (pmxud->avcd[ivcd].dwSupport & VCD_SUPPORTF_BADDRIVER)
            {
                dlout("Bad Control->Line mapping.  Marking bad driver.");
                pmxud->dwFlags |= MXUD_FLAGSF_BADDRIVER;
                break;
            }
        }
    }
    //
    // Note: it isn't necessary to free/unlock the lpMaster/lpDst/lpSrc
    // because they are ptr's to resources and Win32 is smart about resources
    //
    return (avcd != NULL);
}


/*
 * Volume_DialogBox
 *
 * */
DWORD Volume_DialogBox(
    PMIXUIDIALOG    pmxud)
{
    pmxud->dwReturn = MIXUI_EXIT;
    if (Volume_CreateVolume(pmxud))
    {
        HWND hdlg;

        if(NULL == pmxud->lpDialog)
        {
            Volume_Cleanup(pmxud);
            return MIXUI_ERROR;
        }

        hdlg = CreateDialogIndirectParam(pmxud->hInstance
                         , (DLGTEMPLATE *)pmxud->lpDialog
                         , NULL
                         , VolumeProc
                         , (LPARAM)(LPVOID)pmxud );

        if (!hdlg)
        {
            Volume_Cleanup(pmxud);
            return MIXUI_ERROR;
        }
        else
        {
            // Unfortunately, re-registering the winclass does not re-apply any
            // new icon correctly, so we must explicitly apply it here.
            SendMessage (hdlg, WM_SETICON, (WPARAM) ICON_BIG,
                        (LPARAM) GetAppIcon (pmxud->hInstance, pmxud->mxid));
        }

        ShowWindow(hdlg, pmxud->nShowCmd);
    }
    else
    {
        return MIXUI_ERROR;
    }

    return (DWORD)(-1);
}

void DoHtmlHelp()
{
    //note, using ANSI version of function because UNICODE is foobar in NT5 builds
    char chDst[MAX_PATH];
    WideCharToMultiByte(CP_ACP, 0, gszHtmlHelpFileName,
                                            -1, chDst, MAX_PATH, NULL, NULL);
    HtmlHelpA(GetDesktopWindow(), chDst, HH_DISPLAY_TOPIC, 0);
}

void ProcessHelp(HWND hwnd)
{
    static TCHAR HelpFile[] = TEXT("SNDVOL32.HLP");

    //Handle context menu help
    if(bF1InMenu)
    {
        switch(currMenuItem)
        {
            case IDM_PROPERTIES:
                WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SNDVOL32_OPTIONS_PROPERTIES);
            break;
            case IDM_ADVANCED:
                WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SNDVOL32_OPTIONS_ADVANCED_CONTROLS);
            break;
            case IDM_EXIT:
                WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SNDVOL32_OPTIONS_EXIT);
            break;
            case IDM_HELPTOPICS:
                WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SNDVOL32_HELP_HELP_TOPICS);
            break;
            case IDM_HELPABOUT:
                WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SNDVOL32_HELP_ABOUT);
            break;
            default://In the default case just display the HTML Help.
                DoHtmlHelp();
        }
        bF1InMenu = FALSE; //This flag will be set again if F1 is pressed in a menu.
    }
    else
        DoHtmlHelp();
}


/*
 * VolumeParent_WndProc
 *
 * A generic invisible parent window.
 *
 * */
LRESULT CALLBACK VolumeParent_WndProc(
    HWND        hwnd,
    UINT        msg,
    WPARAM      wparam,
    LPARAM      lparam)
{
    PMIXUIDIALOG pmxud;

    switch (msg)
    {
        case WM_CREATE:
        {
            LPCREATESTRUCT lpcs = (LPCREATESTRUCT)lparam;
            pmxud = (PMIXUIDIALOG)lpcs->lpCreateParams;

            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pmxud);
            pmxud->hParent = hwnd;

            if (Volume_DialogBox(pmxud) == MIXUI_ERROR)
            {
                if ( !(pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER))
                {
                    if ( Volume_NumDevs() == 0 )
                        Volume_ErrorMessageBox(NULL, pmxud->hInstance, IDS_ERR_NODEV);
                    else
                        Volume_ErrorMessageBox(NULL, pmxud->hInstance, IDS_ERR_HARDWARE);
                }
                PostMessage(hwnd, WM_CLOSE, 0, 0L);
            }
            return 0;
        }
        case WM_CLOSE:
            DestroyWindow(hwnd);
            return 0;

        case WM_DESTROY:
            //
            // Post-close cleanup
            //
            pmxud = (PMIXUIDIALOG)GetWindowLongPtr(hwnd, GWLP_USERDATA);
            if (!(pmxud->dwStyle & MXUD_STYLEF_NOHELP))
                WinHelp(hwnd, gszHelpFileName, HELP_QUIT, 0L);

            PostQuitMessage(0);

            return 0;

        case MYWM_HELPTOPICS:
            //
            // F1 Help
            //
            pmxud = (PMIXUIDIALOG)GetWindowLongPtr(hwnd, GWLP_USERDATA);
            if (!(pmxud->dwStyle & MXUD_STYLEF_NOHELP))
            {
                ProcessHelp(hwnd);
            }
            break;

        case MYWM_RESTART:
            //
            // A device change or other user property change caused a UI
            // change.  Sending a restart to the parent prevents ugly stuff
            // like WinHelp shutting down and exiting our primary message
            // loop.
            //
            pmxud = (PMIXUIDIALOG)GetWindowLongPtr(hwnd, GWLP_USERDATA);

            if (!(pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER))
            {
                if (Volume_NumDevs() == 0)
                {
                    Volume_ErrorMessageBox(NULL
                               , pmxud->hInstance
                               , IDS_ERR_NODEV);
                    PostMessage(hwnd, WM_CLOSE, 0, 0L);

                }
                else if (Volume_DialogBox((PMIXUIDIALOG)lparam) == MIXUI_ERROR)
                {
                    Volume_ErrorMessageBox(NULL
                               , pmxud->hInstance
                               , IDS_ERR_HARDWARE);
                    PostMessage(hwnd, WM_CLOSE, 0, 0L);
                }
            }
            else
            {
                if (Mixer_GetNumDevs() == 0
                    || Volume_DialogBox((PMIXUIDIALOG)lparam) == MIXUI_ERROR)
                    PostMessage(hwnd, WM_CLOSE, 0, 0L);
            }
            break;

        default:
            break;
    }

    return (DefWindowProc(hwnd, msg, wparam, lparam));
}

const TCHAR szNull[] = TEXT ("");

/*
 * Parent Dialog
 * */
HWND VolumeParent_DialogMain(
    PMIXUIDIALOG pmxud)
{
    WNDCLASS    wc;
    HWND        hwnd;

    wc.lpszClassName  = gszParentClass;
    wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon          = NULL;
    wc.lpszMenuName   = NULL;
    wc.hbrBackground  = NULL;
    wc.hInstance      = pmxud->hInstance;
    wc.style          = 0;
    wc.lpfnWndProc    = VolumeParent_WndProc;
    wc.cbClsExtra     = 0;
    wc.cbWndExtra     = 0;

    if (!RegisterClass(&wc))
        return NULL;

    hwnd = CreateWindow(gszParentClass
            , szNull
            , 0
            , 0
            , 0
            , 0
            , 0
            , NULL
            , NULL
            , pmxud->hInstance
            , (LPVOID)pmxud );

    return hwnd;
}

/*
 * Determines if what the recording destination ID
 */

HRESULT GetRecordingDestID(int mxid, DWORD *piDest)
{
    HRESULT         hr = E_FAIL;
    DWORD       cDest;
    int         iDest;
    MMRESULT    mmr;
    MIXERCAPS   mxcaps;

    if (piDest)
    {
        *piDest = 0;

        mmr = mixerGetDevCaps(mxid, &mxcaps, sizeof(MIXERCAPS));

        if (mmr == MMSYSERR_NOERROR)
        {
            cDest = mxcaps.cDestinations;

            for (iDest = cDest - 1; iDest >= 0; iDest--)
            {
                MIXERLINE   mlDst;

                mlDst.cbStruct      = sizeof ( mlDst );
                mlDst.dwDestination = iDest;

                if (mixerGetLineInfo((HMIXEROBJ)IntToPtr(mxid), &mlDst, MIXER_GETLINEINFOF_DESTINATION) != MMSYSERR_NOERROR)
                    continue;

                if (Mixer_IsValidRecordingDestination ((HMIXEROBJ)IntToPtr(mxid), &mlDst))
                {
                    *piDest = iDest;
                    hr = S_OK;
                    break;
                }
            }
        }
    }

    return(hr);

}


/*------------------------------------------------------+
| HelpMsgFilter - filter for F1 key in dialogs          |
|                                                       |
+------------------------------------------------------*/

DWORD FAR PASCAL HelpMsgFilter(int nCode, UINT wParam, DWORD_PTR lParam)
{
    if (nCode >= 0)
    {
        LPMSG    msg = (LPMSG)lParam;

        if (ghwndApp && (msg->message == WM_KEYDOWN) && (msg->wParam == VK_F1))
        {
            if(nCode == MSGF_MENU)
                bF1InMenu = TRUE;
            SendMessage(ghwndApp, WM_COMMAND, (WPARAM)IDM_HELPTOPICS, 0L);
        }
    }
    return 0;
}


/*
 *  Returns the correct Destination ID for the specified device ID
 */

HRESULT GetDestination(DWORD mxid, int *piDest)
{
    if (gfRecord)
    {
        return GetDestLineID(mxid,piDest);
    }
    else
    {
        return GetSrcLineID(mxid,piDest);
    }
}



/*
 * Determines line ID
 */

HRESULT GetDestLineID(int mxid, DWORD *piDest)
{
    HRESULT     hr = E_FAIL;
    MIXERLINE   mlDst;

    if (piDest)
    {
        hr = S_OK;
        *piDest = 0;

        mlDst.cbStruct = sizeof ( mlDst );
        mlDst.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_WAVEIN;

        if (mixerGetLineInfo((HMIXEROBJ)IntToPtr(mxid), &mlDst, MIXER_GETLINEINFOF_COMPONENTTYPE) == MMSYSERR_NOERROR)
        {
            *piDest = mlDst.dwDestination;
        }
    }

   return(hr);
}

/*
 * Determines line ID
 */

HRESULT GetSrcLineID(int mxid, DWORD *piDest)
{
    HRESULT     hr = E_FAIL;
    MIXERLINE   mlDst;

    if (piDest)
    {
        hr = S_OK;
        *piDest = 0;

        mlDst.cbStruct = sizeof ( mlDst );
        mlDst.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_SPEAKERS;

        if (mixerGetLineInfo((HMIXEROBJ)IntToPtr(mxid), &mlDst, MIXER_GETLINEINFOF_COMPONENTTYPE ) == MMSYSERR_NOERROR)
        {
            *piDest = mlDst.dwDestination;
        }
        else
        {
            mlDst.cbStruct = sizeof ( mlDst );
            mlDst.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_HEADPHONES;

            if (mixerGetLineInfo((HMIXEROBJ)IntToPtr(mxid), &mlDst, MIXER_GETLINEINFOF_COMPONENTTYPE ) == MMSYSERR_NOERROR)
            {
                *piDest = mlDst.dwDestination;
            }
            else
            {
                mlDst.cbStruct = sizeof ( mlDst );
                mlDst.dwComponentType = MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT;

                if (mixerGetLineInfo((HMIXEROBJ)IntToPtr(mxid), &mlDst, MIXER_GETLINEINFOF_COMPONENTTYPE ) == MMSYSERR_NOERROR)
                {
                    *piDest = mlDst.dwDestination;
                }
            }
        }
    }

    return(hr);
}


/*      -       -       -       -       -       -       -       -       - */

/*
 * entry point
 * */
int WINAPI WinMain(
    HINSTANCE       hInst,
    HINSTANCE       hPrev,
    LPSTR           lpCmdLine,
    int             nShowCmd)
{
    int             err = 0;
    MIXUIDIALOG     mxud;
    MSG             msg;
    HWND            hwnd;
    HANDLE          hAccel;
    MMRESULT        mmr;
    TCHAR           ach[2];
    UINT            u;
    BOOL            fGotDevice = FALSE;
    UINT            uDeviceID;

    ach[0] = '\0'; // PREFIX complains if we do not init this.
    LoadString(hInst, IDS_IS_RTL, ach, SIZEOF(ach));
    gfIsRTL = ach[0] == TEXT('1');

    //
    // initialize the app instance data
    //
    ZeroMemory(&mxud, sizeof(mxud));
    mxud.hInstance  = hInst;
    mxud.dwFlags    = MXUD_FLAGSF_MIXER;

    /* setup the message filter to handle grabbing F1 for this task */
    fpfnMsgHook = (HOOKPROC)MakeProcInstance((FARPROC)HelpMsgFilter, ghInst);
    fpfnOldMsgFilter = (HHOOK)SetWindowsHook(WH_MSGFILTER, fpfnMsgHook);

    //
    // parse the command line for "/T"
    //
    u = 0;

    while (lpCmdLine[u] != '\0')
    {
        switch (lpCmdLine[u])
        {
            case TEXT('-'):
            case TEXT('/'):
            {
                u++;

                if (lpCmdLine[u] != '\0')
                {
                    switch (lpCmdLine[u])
                    {
                        case TEXT('T'):
                        case TEXT('t'):
                            mxud.dwStyle |= MXUD_STYLEF_TRAYMASTER;
                            u++;
                            break;

                        case TEXT('S'):
                        case TEXT('s'):
                            mxud.dwStyle |= MXUD_STYLEF_SMALL;
                            u++;
                            break;

                        case TEXT('R'):        // Should run in Record mode, not Playback (default)
                        case TEXT('r'):
                            gfRecord = TRUE;
                            u++;
                        break;

                        case TEXT('X'):
                        case TEXT('x'):
                            mxud.dwStyle |= MXUD_STYLEF_TRAYMASTER | MXUD_STYLEF_CLOSE;
                        break;

                        case TEXT('D'):        // Should use the specified device
                        case TEXT('d'):
                        {
                            u++;            // Skip "d" and any following spaces
                            while (lpCmdLine[u] != '\0' && isspace(lpCmdLine[u]))
                            {
                                u++;
                            }

                            if (lpCmdLine[u] != '\0')
                            {
                                char szDeviceID[255];
                                UINT uDev = 0;

                                while ((uDev < 2) && lpCmdLine[u] != '\0' && !isalpha(lpCmdLine[u]) && !isspace(lpCmdLine[u]))
                                {
                                    szDeviceID[uDev] = lpCmdLine[u];
                                    u++;
                                    uDev++;
                                }

                                szDeviceID[uDev] = '\0';

                                uDeviceID = strtoul(szDeviceID,NULL,10);

                                fGotDevice = TRUE;
                            }
                        }
                        break;

                        default:            // Unknown Command, just ignore it.
                            u++;
                        break;
                    }
                }
            }
            break;

            default:
            {
                u++;
            }
            break;
        }
    }


    //
    // Restore last style
    //
    if (!(mxud.dwStyle & (MXUD_STYLEF_TRAYMASTER|MXUD_STYLEF_SMALL)))
    {
        Volume_GetSetStyle(&mxud.dwStyle, GET);
    }

    if (mxud.dwStyle & MXUD_STYLEF_TRAYMASTER)
    {
        HWND hwndSV;

        //
        // Locate a waiting instance of the tray volume and wake it up
        //
        hwndSV = FindWindow(gszTrayClassName, NULL);
        if (hwndSV) {
            SendMessage(hwndSV, MYWM_WAKEUP,
                (mxud.dwStyle & MXUD_STYLEF_CLOSE), 0);
            goto mxendapp;
        }
    }

    if (mxud.dwStyle & MXUD_STYLEF_CLOSE) {
        goto mxendapp;
    }


    //
    // Init to the default mixer
    //

    if (fGotDevice)
    {
        UINT cWaves;

        if (gfRecord)
        {
            cWaves = waveInGetNumDevs();
        }
        else
        {
            cWaves = waveOutGetNumDevs();
        }

        if (uDeviceID >= cWaves)
        {
            fGotDevice = FALSE;
        }
    }


    if (!fGotDevice)
    {
        mmr = Volume_GetDefaultMixerID(&mxud.mxid, gfRecord);
    }
    else
    {
        mxud.mxid = uDeviceID;
    }

    if (gfRecord)
    {
        if (FAILED(GetRecordingDestID(mxud.mxid,&mxud.iDest)))
        {
            goto mxendapp;
        }
    }
    else
    {
        if (FAILED(GetDestination(mxud.mxid,&mxud.iDest)))
        {
           goto mxendapp;
        }
    }


    //
    // For the tray master, get the mix id associated with the default
    // wave device.  If this fails, go away.
    //
    if (mxud.dwStyle & MXUD_STYLEF_TRAYMASTER)
    {
        if (mmr != MMSYSERR_NOERROR)
            goto mxendapp;
        mxud.dwStyle |= MXUD_STYLEF_NOHELP;
        mxud.nShowCmd = SW_HIDE;

    }
    else
    {
        if (!Volume_NumDevs())
        {
            Volume_ErrorMessageBox(NULL, hInst, IDS_ERR_NODEV);
            goto mxendapp;
        }
        InitVUControl(hInst);
        if (!LoadString(hInst
                , IDS_HELPFILENAME
                , gszHelpFileName
                , SIZEOF(gszHelpFileName)))
            mxud.dwStyle |= MXUD_STYLEF_NOHELP;

        if (!LoadString(hInst
                , IDS_HTMLHELPFILENAME
                , gszHtmlHelpFileName
                , SIZEOF(gszHtmlHelpFileName)))
            mxud.dwStyle |= MXUD_STYLEF_NOHELP;

        mxud.nShowCmd   = (nShowCmd == SW_SHOWMAXIMIZED)
                  ? SW_SHOWNORMAL:nShowCmd;
        if (!(mxud.dwStyle & MXUD_STYLEF_SMALL))
            mxud.dwStyle  |= MXUD_STYLEF_STATUS;   // has status bar
    }

    //
    // Use the common controls
    //
    InitCommonControls();
    hAccel = LoadAccelerators(hInst, MAKEINTRESOURCE(IDR_VOLUMEACCEL));

    hwnd = VolumeParent_DialogMain(&mxud);

    //Initialize the handle which the hook for F1 help will use.
    ghwndApp = mxud.hwnd;

    if (hwnd)
    {
        while (GetMessage(&msg, NULL, 0, 0))
        {
            if (mxud.hwnd) {
                if (hAccel && TranslateAccelerator(mxud.hwnd, hAccel, &msg))
                    continue;

                if (IsDialogMessage(mxud.hwnd,&msg))
                    continue;
            }

            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
mxendapp:
    /* if the message hook was installed, remove it and free */
    /* up our proc instance for it.                          */
    if (fpfnOldMsgFilter){
        UnhookWindowsHook(WH_MSGFILTER, fpfnMsgHook);
    }
    return err;
}


void FreeAppIcon ()
{
    if (ghiconApp)
    {
        DestroyIcon (ghiconApp);
        ghiconApp = NULL;
    }
}

// TODO: Move to "regstr.h"
#define REGSTR_KEY_BRANDING TEXT("Branding")
#define REGSTR_VAL_AUDIO_BITMAP TEXT("bitmap")
#define REGSTR_VAL_AUDIO_ICON TEXT("icon")
#define REGSTR_VAL_AUDIO_URL TEXT("url")

HKEY OpenDeviceBrandRegKey (UINT uiMixID)
{

    HKEY hkeyBrand = NULL;
    HKEY hkeyDevice = OpenDeviceRegKey (uiMixID, KEY_READ);

    if (hkeyDevice)
    {
        if (ERROR_SUCCESS != RegOpenKeyEx (hkeyDevice, REGSTR_KEY_BRANDING, 0, KEY_READ, &hkeyBrand))
            hkeyBrand = NULL; // Make sure NULL on failure

        // Close the Device key
        RegCloseKey (hkeyDevice);
    }

    return hkeyBrand;

}

///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
PTCHAR GetInterfaceName (DWORD dwMixerID)
{
    MMRESULT mmr;
    ULONG cbSize=0;
    TCHAR *szInterfaceName=NULL;

    //Query for the Device interface name
    mmr = mixerMessage(HMIXER_INDEX(dwMixerID), DRV_QUERYDEVICEINTERFACESIZE, (DWORD_PTR)&cbSize, 0L);
    if(MMSYSERR_NOERROR == mmr)
    {
        szInterfaceName = (TCHAR *)GlobalAllocPtr(GHND, (cbSize+1)*sizeof(TCHAR));
        if(!szInterfaceName)
        {
            return NULL;
        }

        mmr = mixerMessage(HMIXER_INDEX(dwMixerID), DRV_QUERYDEVICEINTERFACE, (DWORD_PTR)szInterfaceName, cbSize);
        if(MMSYSERR_NOERROR != mmr)
        {
            GlobalFreePtr(szInterfaceName);
            return NULL;
        }
    }

    return szInterfaceName;
}


HKEY OpenDeviceRegKey (UINT uiMixID, REGSAM sam)
{

    HKEY hkeyDevice = NULL;
    PTCHAR szInterfaceName = GetInterfaceName (uiMixID);

    if (szInterfaceName)
    {
        HDEVINFO DeviceInfoSet = SetupDiCreateDeviceInfoList (NULL, NULL);

        if (INVALID_HANDLE_VALUE != DeviceInfoSet)
        {
            SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
            DeviceInterfaceData.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);

            if (SetupDiOpenDeviceInterface (DeviceInfoSet, szInterfaceName,
                                            0, &DeviceInterfaceData))
            {
                DWORD dwRequiredSize;
                SP_DEVINFO_DATA DeviceInfoData;
                DeviceInfoData.cbSize = sizeof (SP_DEVINFO_DATA);

                // Ignore error, it always returns "ERROR_INSUFFICIENT_BUFFER" even though
                // the "SP_DEVICE_INTERFACE_DETAIL_DATA" parameter is supposed to be optional.
                (void) SetupDiGetDeviceInterfaceDetail (DeviceInfoSet, &DeviceInterfaceData,
                                                        NULL, 0, &dwRequiredSize, &DeviceInfoData);
                // Open device reg key
                hkeyDevice = SetupDiOpenDevRegKey (DeviceInfoSet, &DeviceInfoData,
                                                   DICS_FLAG_GLOBAL, 0,
                                                   DIREG_DRV, sam);

            }
            SetupDiDestroyDeviceInfoList (DeviceInfoSet);
        }
        GlobalFreePtr (szInterfaceName);
    }

    return hkeyDevice;

}


HICON GetAppIcon (HINSTANCE hInst, UINT uiMixID)
{

    HKEY hkeyBrand = OpenDeviceBrandRegKey (uiMixID);

    FreeAppIcon ();

    if (hkeyBrand)
    {
        WCHAR szBuffer[MAX_PATH];
        DWORD dwType = REG_SZ;
        DWORD cb     = sizeof (szBuffer);

        if (ERROR_SUCCESS == RegQueryValueEx (hkeyBrand, REGSTR_VAL_AUDIO_ICON, NULL, &dwType, (LPBYTE)szBuffer, &cb))
        {
			if (REG_SZ == dwType)
			{
				WCHAR* pszComma = wcschr (szBuffer, L',');
				if (pszComma)
				{
					WCHAR* pszResourceID = pszComma + 1;
					HANDLE hResource;

					// Remove comma delimeter
					*pszComma = L'\0';

					// Should be a resource module and a resource ID
					hResource = LoadLibrary (szBuffer);
					if (!hResource)
					{
						TCHAR szDriversPath[MAX_PATH];

						// If we didn't find it on the normal search path, try looking
						// in the "drivers" directory.
						if (GetSystemDirectory (szDriversPath, MAX_PATH))
						{
							HRESULT hr = StringCchCat(szDriversPath, SIZEOF(szDriversPath), TEXT("\\drivers\\"));
							if( hr == S_OK )
							{
								hr = StringCchCat(szDriversPath, SIZEOF(szDriversPath), szBuffer);
								if( hr == S_OK )
								{
									hResource = LoadLibrary (szDriversPath);
								}
							}
						}

					}
					if (hResource)
					{
						ghiconApp = LoadImage (hResource, MAKEINTRESOURCE(_wtoi (pszResourceID)), IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);
						FreeLibrary (hResource);
					}
				}
				else
					// Should be an *.ico file
					ghiconApp = LoadImage (NULL, szBuffer, IMAGE_ICON, 0, 0, LR_DEFAULTSIZE | LR_LOADFROMFILE);
			}
        }
        RegCloseKey (hkeyBrand);

        // Return the custom icon
        if (ghiconApp)
            return ghiconApp;
    }

    return (LoadIcon (hInst, MAKEINTRESOURCE (IDI_MIXER)));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\bltprop.h ===
/*-----------------------------------------------------------------------------+
| BLTPROP.H                                                                    |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Created                                                  |
|                                                                              |
+-----------------------------------------------------------------------------*/

#define     RED       0
#define     GREEN     1
#define     BLUE      2

#define     GrayThresh  128
#define     LoThresh    128
#define     HiThresh    192

#define     Mask0    0x01
#define     Mask1    0x02
#define     Mask2    0x04
#define     Mask3    0x08
#define     Mask4    0x10
#define     Mask5    0x20
#define     Mask6    0x40
#define     Mask7    0x80
#define     MaskAll  0xFF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\ctrls.h ===
#define TOOLGROW        8                // power of 2

#define IDC_TOOLBAR   189                // wParam sent to Parent

//
//  Init routine, will register the various classes.
//
BOOL FAR PASCAL ControlInit (HANDLE hInst);
void FAR PASCAL ControlCleanup (void);


extern HBRUSH hbrGray;
extern HBRUSH hbrButtonFace;
extern HBRUSH hbrButtonShadow;
extern HBRUSH hbrButtonText;
extern HBRUSH hbrButtonHighLight;
extern HBRUSH hbrWindowFrame;
extern HBRUSH hbrWindowColour;

extern DWORD  rgbButtonHighLight;
extern DWORD  rgbButtonFocus;
extern DWORD  rgbButtonFace;
extern DWORD  rgbButtonText;
extern DWORD  rgbButtonShadow;
extern DWORD  rgbWindowFrame;
extern DWORD  rgbWindowColour;
#if 0
extern HBITMAP hbTBMain;
extern HBITMAP hbTBMark;
extern HBITMAP hbTBArrows;
#endif



#define TB_FIRST            -1
#define TB_LAST             -2

#define BTN_PLAY            0
#define BTN_PAUSE           1
#define BTN_STOP            2
#define BTN_EJECT           3
#define BTN_HOME            4
#define BTN_RWD             5
#define BTN_FWD             6
#define BTN_END             7
#define BTN_SEP             8
#define TB_NUM_BMPS         9
#define TB_NUM_BTNS         9


#define ARROW_PREV          0
#define ARROW_NEXT          1
#define ARROW_NUM_BMPS      3
#define ARROW_NUM_BTNS      2

#define BTN_MARKIN          0
#define BTN_MARKOUT         1
#define MARK_NUM_BMPS       2
#define MARK_NUM_BTNS       2

#define BTNST_GRAYED        0
#define BTNST_UP            1
#define BTNST_DOWN          2

#define TBINDEX_MAIN        0
#define TBINDEX_MARK        1
#define TBINDEX_ARROWS      2


/* bitmap resources */
#define IDR_TOOLBAR         101
#define IDR_ARROWS          102
#define IDR_MARK            103


#define IDT_TBMAINCID       301
#define IDT_TBMARKCID       302
#define IDT_TBARROWSCID     303
#define IDT_STATUSWINDOWCID 304

#define IDT_PLAY                501
#define IDT_PAUSE               502
#define IDT_STOP                503
#define IDT_EJECT               504
#define IDT_HOME                505
#define IDT_RWD                 506
#define IDT_FWD                 507
#define IDT_END                 508
#define IDT_MARKIN              509
#define IDT_MARKOUT             510
#define IDT_ARROWPREV           511
#define IDT_ARROWNEXT           512

#define MSEC_BUTTONREPEAT   200        // milliseconds for auto-repeat
#define REPEAT_ID           200

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\bltprop.c ===
/*-----------------------------------------------------------------------------+
| BLTPROP.C                                                                    |
|                                                                              |
| Emulates the 16 bit BLTPROP.ASM for WIN32                                    |
|                                                                              |
| (C) Copyright Microsoft Corporation 1993.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
| 21-Oct-1992 MikeTri  Created                                                  |
| 09-Apr-1993 GeraintD Added error propagation
|                                                                              |
+-----------------------------------------------------------------------------*/

#include <windows.h>
#include <stdlib.h>
#include "mplayer.h"
#include "bltprop.h"


/*
 * 256 colour to 16 colour dithering by error propagation
 *
 * This function takes an 8-bit DIB using 256 colours and converts
 * it to a DIB that uses only 16 distinct colours.
 *
 * We take a pixel and convert it to one of the 16 standard vga colours
 * by taking each component and comparing it against a low and high
 * threshold. Less than the low gets 0 of that component; between low
 * and high gets an intensity of 128, and above the high threshold gets
 * an intensity of 255 for that component. (the standard 16 colours
 * have the 8 combinations of 0 or 128 for each component, and the
 * 8 combinations of 0 or 255 for each component - there are no colours
 * combining intensities of 255 and 128). So if any of our colours
 * are above the high threshold, we use 255 for any non-0 intensity.
 * We also have 2 grey levels that are picked out if all colour intensities
 * are less than a given threshold.
 *
 * The conversion is done by building an 8-bit value with bits set to
 * indicate if each component is above either of the two thresholds,
 * and then using this as a palette index. We thus use an output colour
 * table that contains 256 entries, though only 16 distinct colours.
 *
 * Having converted the pixel into the new palette index, we calculate the
 * difference for each r,g,b component between the original and the final
 * colour. We then add a fraction of this error to the adjacent pixels
 * along, down and diagonally. These error values are added to the
 * red, green and blue values for the adjacent pixels before comparing
 * against the thresholds in the colour conversion process.
 */


/*
 * y error propagation - this contains the error for each component that
 * we wish to pass to the line below. Thus there is one entry for each
 * colour component for each pixel. The same max line length is assumed
 * in the win-16 version.
 */
#define MAXBITMAPWIDTH 	1500
typedef struct _colour_error {
    int red_error;
    int green_error;
    int blue_error;
} colour_error, *pcolour_error;

colour_error y_error[MAXBITMAPWIDTH];

/*
 * we take the difference between the actual and desired components,
 * multiply up by SCALE_UP, and then pass the result divided by SCALE_X
 * to both the pixel across and below, and divided by SCALE_Z to the pixel
 * diagonally across and below. (Below of course, means further down the
 * DIB, and therefore higher up the screen)
 */
#define SCALE_UP	8
#define SCALE_X		32
#define SCALE_Z		64



/*
 * The final pixel has the following form:
 *
 *          bits 7x543210
 *               | ||||||
 *               | |||||+-- set iff RED   > HiThresh
 *               | ||||+--- set iff RED   > LoThresh
 *               | |||+---- set iff GREEN > HiThresh
 *               | ||+----- set iff GREEN > LoThresh
 *               | |+------ set iff BLUE  > HiThresh
 *               | +------- set iff BLUE  > LoThresh
 *               +--------- set iff all colors > GrayThresh
 */

#define RED_HITHRESH	0x01
#define RED_LOTHRESH	0x02
#define GREEN_HITHRESH	0x04
#define GREEN_LOTHRESH	0x08
#define BLUE_HITHRESH	0x10
#define BLUE_LOTHRESH	0x20
#define GRAY_THRESH	0x80

#define ALL_HITHRESH	(RED_HITHRESH | GREEN_HITHRESH | BLUE_HITHRESH)
#define ALL_LOTHRESH	(RED_LOTHRESH | GREEN_LOTHRESH | BLUE_LOTHRESH)

/*
 * convert a palette index in the above threshold format into the
 * rgb component values.
 */
RGBQUAD
ThresholdToRGB(int PalIndex)
{
    RGBQUAD rgbq;
    BYTE RGBVal;

    /* Special case greys */

    if (PalIndex == (GRAY_THRESH | ALL_LOTHRESH)) {

    	rgbq.rgbRed = rgbq.rgbGreen = rgbq.rgbBlue = 0xc0;

    } else if (PalIndex == GRAY_THRESH) {

	rgbq.rgbRed = rgbq.rgbGreen = rgbq.rgbBlue = 0x80;

    } else {

	rgbq.rgbRed = 0;
	rgbq.rgbGreen = 0;
	rgbq.rgbBlue = 0;

	/*
	 * if any components are above hi-threshold, then
	 * use the high threshold for all non-zero components; otherwise
	 * use the low threshold for all non-zero components.
	 */
	if (PalIndex & ALL_HITHRESH) {
	    RGBVal = 0xff;
	} else {
	    RGBVal = 0x80;
	}

	if (PalIndex & (RED_HITHRESH | RED_LOTHRESH)) {
	    rgbq.rgbRed = RGBVal;
	}

	if (PalIndex & (GREEN_HITHRESH | GREEN_LOTHRESH)) {
	    rgbq.rgbGreen = RGBVal;
	}

	if (PalIndex & (BLUE_HITHRESH | BLUE_LOTHRESH)) {
	    rgbq.rgbBlue = RGBVal;
	}
    }

    return (rgbq);

}


/*
 * copy a dib from pbSrc to pbDst reducing to 16 distinct colours
 */
void FAR PASCAL BltProp(LPBITMAPINFOHEADER pbiSrc,
                        LPBYTE pbSrc,
                        UINT SrcX,
                        UINT SrcY,
                        UINT SrcXE,
                        UINT SrcYE,
                        LPBITMAPINFOHEADER pbiDst,
                        LPBYTE pbDst,
                        UINT DstX,
                        UINT DstY)
{
    UINT    count, row, column;
    BYTE    TempByte;
    BYTE    ColourTableIndex;

    int    RedVal;
    int    GreenVal;
    int    BlueVal;
    colour_error x_error, z_error;
    int scaled_error, scaled_x, scaled_z;
    RGBQUAD rgbq;

    LPBITMAPINFO ColourTable;


    DPF2("BltProp");




    /*
     * clear the y_error to zero at start of bitmap
     */
    for (count = 0; count < SrcXE; count++) {
	y_error[count].red_error = 0;
	y_error[count].green_error = 0;
	y_error[count].blue_error = 0;
    }



/*****************************************************************************\
 *
 * Loop through the bitmap picking up the pixel r,g,b values, adjust for
 * the error propagated and then compare the components against the two
 * threshold values. The resulting byte has the following form:
 *
 *          bits 7x543210
 *               | ||||||
 *               | |||||+-- set iff RED   > HiThresh
 *               | ||||+--- set iff RED   > LoThresh
 *               | |||+---- set iff GREEN > HiThresh
 *               | ||+----- set iff GREEN > LoThresh
 *               | |+------ set iff BLUE  > HiThresh
 *               | +------- set iff BLUE  > LoThresh
 *               +--------- set iff all colors > GrayThresh
 *
 * This is an index into the 256-entry colour table generated below (that
 * uses only 16 distinct colours).
 *
 * After creating the correct colour, we calculate the difference between
 * this colour and the original, and propagate that error forwards and down.
 *
\*****************************************************************************/


    /* offset source, dest pointers by SrcX rows */
    pbSrc += (SrcY * pbiSrc->biWidth) + SrcX;
    pbDst += (DstY * pbiDst->biWidth) + DstX;
    ColourTable = (LPBITMAPINFO)pbiSrc;

    for (row=0; row < SrcYE ; row++) {

	/* clear x error for start of row */
	x_error.red_error = 0;
	x_error.green_error = 0;
	x_error.blue_error = 0;
	z_error.red_error = 0;
	z_error.green_error = 0;
	z_error.blue_error = 0;


        for (column = 0; column < SrcXE; column++) {

	    /* pick up the source palette index and get rgb components */
            ColourTableIndex = *pbSrc++;
	    RedVal = ColourTable->bmiColors[ColourTableIndex].rgbRed;
	    GreenVal = ColourTable->bmiColors[ColourTableIndex].rgbGreen;
	    BlueVal = ColourTable->bmiColors[ColourTableIndex].rgbBlue;

	    /* add on error - x-error is propagated from
	     * previous column. y-error is passed down from pixel above.
	     * z-error is passed diagonally and has already been added
	     * into y-error for this pixel.
	     */
	    RedVal += x_error.red_error + y_error[column].red_error;
	    GreenVal += x_error.green_error + y_error[column].green_error;
	    BlueVal += x_error.blue_error + y_error[column].blue_error;

	    /*
	     * As we move along the line, y_error[] for the pixels
	     * ahead of us contains the error to be added to the pixels
	     * on this row. y_error[] for the pixels we have done contains
	     * the error to be propagated to those pixels on the row
	     * below.
	     *
	     * Now that we have picked up the error for this pixel, we
	     * can start accumulating errors for this column on the
	     * row below. We start with the z_error from the previous pixel
	     * and then add in (later) the y_error from the current pixel.
	     */
	    y_error[column] = z_error;



            TempByte = 0x00; // Our "new" bitmap entry, once it has been munged

	    /*
	     * set threshold bits for each component based on adjusted colours
	     */

	    if (RedVal > LoThresh) {
		TempByte |= RED_LOTHRESH;
		if (RedVal > HiThresh){
		    TempByte |= RED_HITHRESH;
		}
	    }
	    if (GreenVal > LoThresh) {
		TempByte |= GREEN_LOTHRESH;
		if (GreenVal > HiThresh){
		    TempByte |= GREEN_HITHRESH;
		}
	    }
	    if (BlueVal > LoThresh) {
		TempByte |= BLUE_LOTHRESH;
		if (BlueVal > HiThresh){
		    TempByte |= BLUE_HITHRESH;
		}
	    }

	    /* set grey scale bit if all colours > grey threshold */
	    if (
		(RedVal > GrayThresh)
		&& (BlueVal > GrayThresh)
		&& (GreenVal > GrayThresh)
	       ) {
		    TempByte |= GRAY_THRESH;
	    }

	    /* we now have palette index into new colour table */
            *pbDst++ = TempByte;

	    /*
	     * calculate difference for each component between
	     * desired colour (after error adjustment) and actual
	     * colour. Remember to add in to the y-error, since this
	     * already contains the z_error from the previous cell.
	     * Hold the z_error for this cell, since we can't add this
	     * to the next y_error until we have used it for the next cell
	     * on this row.
	     *
	     * do the scaling on the absolute values and then
	     * put the sign back in afterwards - to make sure
	     * we handle small negative numbers ok.
	     */
	    rgbq = ThresholdToRGB(TempByte);

	    scaled_error = (RedVal - rgbq.rgbRed) * SCALE_UP;
	    scaled_x = abs(scaled_error) / SCALE_X;
	    scaled_z = abs(scaled_error) / SCALE_Z;
	    x_error.red_error = (scaled_error > 0) ? scaled_x : -scaled_x;
	    z_error.red_error = (scaled_error > 0) ? scaled_z : -scaled_z;
	    y_error[column].red_error += x_error.red_error;


	    scaled_error = (GreenVal - rgbq.rgbGreen) * SCALE_UP;
	    scaled_x = abs(scaled_error) / SCALE_X;
	    scaled_z = abs(scaled_error) / SCALE_Z;
	    x_error.green_error = (scaled_error > 0) ? scaled_x : -scaled_x;
	    z_error.green_error = (scaled_error > 0) ? scaled_z : -scaled_z;
	    y_error[column].green_error += x_error.green_error;

	    scaled_error = (BlueVal - rgbq.rgbBlue) * SCALE_UP;
	    scaled_x = abs(scaled_error) / SCALE_X;
	    scaled_z = abs(scaled_error) / SCALE_Z;
	    x_error.blue_error = (scaled_error > 0) ? scaled_x : -scaled_x;
	    z_error.blue_error = (scaled_error > 0) ? scaled_z : -scaled_z;
	    y_error[column].blue_error += x_error.blue_error;


        }

	/* advance source and dest pointers from end of rectangle to start of
	 * next line
	 */
	pbSrc += pbiSrc->biWidth - SrcXE;
	pbDst += pbiDst->biWidth - SrcXE;
    }

    DPF2("BltProp - finished first loop");
/*****************************************************************************\
 *
 * This part generates a new output colour table entry that is accessed by the
 * modified bitmap generated above, and updates the destination DIB colour
 * table with that new entry.
 *
\*****************************************************************************/

    ColourTable = (LPBITMAPINFO)pbiDst;

    for (count=0; count<256; count++ ) {


/* Update the original colour table within the destination DIB */

        ColourTable->bmiColors[count] = ThresholdToRGB(count);

    }
    DPF2("BltProp - finished second loop");
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\cdrag.c ===
/*---------------------------------------------------------------------------
|   CDRAG.C
|   This file has the interfaces for the object transferred through the
|   Clipboard or through a Drag-Drop. These interfaces unlike the interfaces
|   implemented in the file OBJ.C transfer the state of the object at
|   Edit->Copy time or Drag-Drop time. The interfaces in OBJ.C transfer the
|   real-time Object Data.
|
|   Created by: Vij Rajarajan (VijR)
+---------------------------------------------------------------------------*/
#define SERVERONLY
#include <windows.h>
#include <windowsx.h>
#include "mpole.h"
#include "mplayer.h"

#include <malloc.h>

#define OLESTDDELIM "!"
#define STGM_SALL (STGM_READWRITE | STGM_SHARE_EXCLUSIVE)

HANDLE GetMetafilePict (VOID);
SCODE SaveMoniker (LPSTREAM lpstream);
HANDLE PASCAL GetDib (VOID);

HANDLE  ghClipData = NULL;  /*  Holds the  data handle at the time of Copy */
HANDLE  ghClipMetafile = NULL;  /*  to clipboard */
HANDLE  ghClipDib = NULL;

/* Global flag to indicate OLE was initialized for drag.
 * This happens on a separate thread from the main window,
 * so we need to initialize and uninitialize independently.
 */
BOOL    gfOleInitForDrag = FALSE;

extern LPDATAOBJECT gpClipboardDataObject;

/**************************************************************************
*   CutOrCopyObject
*   Sets the clipboard with the IDataObject interface of the lpdoc
*   object passed as the argument. The function also saves a snapshot of
*   the state of the object in the globals ghClipMetafile, ghClipData,
*   and ghClipDib.
**************************************************************************/
void CutOrCopyObj (LPDOC lpdoc)
{
    LPDATAOBJECT lpDataObj;

    lpDataObj = (LPDATAOBJECT)CreateClipDragDataObject(lpdoc,TRUE);

    if (lpDataObj != NULL) {
        if (ghClipData)
            GLOBALFREE(ghClipData);
        if (ghClipMetafile) {
            {
            // note that ghClipMetafile is set deep in PictureFromDib and contains
            // a handle to a windows metafile. Clean this up properly here. There may
            // be other memory/handle leaks caused by this coding of the metafile handle elsewhere.
            // SteveZ
               LPMETAFILEPICT pmfp;
               BOOL bReturn;
               DWORD dw;
               pmfp = (LPMETAFILEPICT)GLOBALLOCK(ghClipMetafile);
               bReturn = DeleteMetaFile(pmfp->hMF);
               if (!bReturn) {
                  dw = GetLastError();
               }
               GLOBALUNLOCK(ghClipMetafile);
            }
            GLOBALFREE(ghClipMetafile);
		}
        if (ghClipDib)
            GLOBALFREE(ghClipDib);
        ghClipData = GetLink();
        ghClipMetafile = GetMetafilePict();
        ghClipDib = GetDib();
        OleSetClipboard(lpDataObj);
        IDataObject_Release(lpDataObj);
        gpClipboardDataObject = lpDataObj;
    }
}


/**************************************************************************
*   CreateClipDragDataObject:
*   This function returns an initialized instance of the CLIPDRAGDATA data
*   structure. fClipData = TRUE if the object is for the clipboard and
*   = FALSE if the object is for Drag-Drop operation.
**************************************************************************/
LPCLIPDRAGDATA CreateClipDragDataObject(LPDOC lpdoc, BOOL fClipData)
{
    LPCLIPDRAGDATA lpclipdragdata;

    lpclipdragdata = malloc( sizeof(CLIPDRAGDATA) );

    if (lpclipdragdata == NULL)
    {
        DPF0("Malloc failed in CreateClipDragDataObject\n");
        return NULL;
    }

    lpclipdragdata->m_IDataObject.lpVtbl = &clipdragVtbl;
    lpclipdragdata->lpClipDragEnum = NULL;

    lpclipdragdata->m_IDropSource.lpVtbl = &dropsourceVtbl;
    lpclipdragdata->m_IDataObject.lpclipdragdata = lpclipdragdata;
    lpclipdragdata->m_IDropSource.lpclipdragdata = lpclipdragdata;
    lpclipdragdata->lpdoc = lpdoc;
    lpclipdragdata->cRef    = 1;
    lpclipdragdata->fClipData   = fClipData;

    return lpclipdragdata;
}

/**************************************************************************
*   DoDrag:
*   Initiates the Drag-Drop operation.
**************************************************************************/
void DoDrag(void)
{
    DWORD       dwEffect;
    LPCLIPDRAGDATA  lpclipdragdata;

    if (!InitOLE(&gfOleInitForDrag, NULL))
    {
        DPF0("Initialization of OLE FAILED!!  Can't do drag.\n");
        return;
    }

    lpclipdragdata = CreateClipDragDataObject ((LPDOC)&docMain, FALSE);

    if (lpclipdragdata)
    {
        HRESULT hr;

        hr = (HRESULT)DoDragDrop((IDataObject FAR*)&lpclipdragdata->m_IDataObject,
                        (IDropSource FAR*)&lpclipdragdata->m_IDropSource,
                        DROPEFFECT_COPY, &dwEffect);

        DPF("DoDragDrop returned %s\n", hr == S_OK ? "S_OK" : hr == DRAGDROP_S_DROP ? "DRAGDROP_S_DROP" : hr == DRAGDROP_S_CANCEL ? "DRAGDROP_S_CANCEL" : hr == E_OUTOFMEMORY ? "E_OUTOFMEMORY" : hr == E_UNEXPECTED ? "E_UNEXPECTED" : "<?>");

        IDataObject_Release((IDataObject *)&lpclipdragdata->m_IDataObject);
    }
}

void CleanUpDrag(void)
{
    if (gfOleInitForDrag)
    {
        DPF("Uninitializing OLE for thread %d\n", GetCurrentThreadId());
        CoDisconnectObject((LPUNKNOWN)&docMain, 0);
        OleUninitialize();
        gfOleInitForDrag = FALSE;
    }
}

/**************************************************************************
*   GetObjectDescriptorData:
*   Packages an ObjectDescriptor data structure.
**************************************************************************/
HGLOBAL GetObjectDescriptorData(
    CLSID     clsid,
    DWORD     dwAspect,
    SIZEL     sizel,
    POINTL    pointl,
    DWORD     dwStatus,
    LPTSTR    lpszFullUserTypeName,
    LPTSTR    lpszSrcOfCopy
)
{
    HGLOBAL            hMem = NULL;
    IBindCtx   FAR    *pbc = NULL;
    LPOBJECTDESCRIPTOR lpOD;
    DWORD              dwObjectDescSize, dwFullUserTypeNameLen, dwSrcOfCopyLen;
    DWORD              Offset;

    // Get the length of Full User Type Name:
    dwFullUserTypeNameLen = STRING_BYTE_COUNT_NULLOK(lpszFullUserTypeName);
    dwFullUserTypeNameLen *= (sizeof(WCHAR) / sizeof(TCHAR));

    // Get the Source of Copy string and its length:
    dwSrcOfCopyLen = STRING_BYTE_COUNT_NULLOK(lpszSrcOfCopy);
    dwSrcOfCopyLen *= (sizeof(WCHAR) / sizeof(TCHAR));

    if (lpszSrcOfCopy == NULL) {
       // No src moniker so use user type name as source string.
       lpszSrcOfCopy  = lpszFullUserTypeName;
       dwSrcOfCopyLen = dwFullUserTypeNameLen;
    }

    // Allocate space for OBJECTDESCRIPTOR and the additional string data
    dwObjectDescSize = sizeof(OBJECTDESCRIPTOR);
    hMem = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE,
                       dwObjectDescSize
                       + dwFullUserTypeNameLen
                       + dwSrcOfCopyLen);
    if (NULL == hMem)
        goto error;

    lpOD = (LPOBJECTDESCRIPTOR)GLOBALLOCK(hMem);

    if(!lpOD)
        goto error;

    // Set offset to copy strings at end of the object descriptor:
    Offset = dwObjectDescSize;

    // Set the FullUserTypeName offset and copy the string
    if (lpszFullUserTypeName)
    {
        lpOD->dwFullUserTypeName = Offset;
#ifdef UNICODE
        lstrcpy((LPWSTR)(((LPBYTE)lpOD)+Offset), lpszFullUserTypeName);
#else
        AnsiToUnicodeString(lpszFullUserTypeName, (LPWSTR)(((LPBYTE)lpOD)+Offset), -1);
#endif
        Offset += dwFullUserTypeNameLen;
    }
    else lpOD->dwFullUserTypeName = 0;  // zero offset indicates that string is not present

    // Set the SrcOfCopy offset and copy the string
    if (lpszSrcOfCopy)
    {
        lpOD->dwSrcOfCopy = Offset;
#ifdef UNICODE
        lstrcpy((LPWSTR)(((LPBYTE)lpOD)+Offset), lpszSrcOfCopy);
#else
        AnsiToUnicodeString(lpszSrcOfCopy, (LPWSTR)(((LPBYTE)lpOD)+Offset), -1);
#endif
    }
    else lpOD->dwSrcOfCopy = 0;  // zero offset indicates that string is not present

    // Initialize the rest of the OBJECTDESCRIPTOR
    lpOD->cbSize       = dwObjectDescSize + dwFullUserTypeNameLen + dwSrcOfCopyLen;
    lpOD->clsid        = clsid;
    lpOD->dwDrawAspect = dwAspect;
    lpOD->sizel        = sizel;
    lpOD->pointl       = pointl;
    lpOD->dwStatus     = dwStatus;

    GLOBALUNLOCK(hMem);
    return hMem;

error:
   if (hMem)
   {
       GLOBALUNLOCK(hMem);
       GLOBALFREE(hMem);
   }
   return NULL;
}



/**************************************************************************
***************   IUnknown INTERFACE INPLEMENTATION.
**************************************************************************/
STDMETHODIMP    ClipDragUnknownQueryInterface (
    LPCLIPDRAGDATA    lpclipdragdata, // data object ptr
    REFIID            riidReq,        // IID required
    LPVOID FAR *      lplpUnk         // pre for returning the interface
)
{
    if ( IsEqualIID(riidReq, &IID_IDataObject) ||  IsEqualIID(riidReq, &IID_IUnknown) )
    {
        *lplpUnk = (LPVOID) lpclipdragdata;
    }
    else if ( IsEqualIID(riidReq, &IID_IDropSource))
    {
        *lplpUnk = (LPVOID) &lpclipdragdata->m_IDropSource;
    }
    else
    {
        *lplpUnk = (LPVOID) NULL;
        RETURN_RESULT(E_NOINTERFACE);
    }

    DPF("ClipDragAddRef: cRef = %d\n", lpclipdragdata->cRef + 1);
    lpclipdragdata->cRef++;
    return NOERROR;
}


STDMETHODIMP_(ULONG)    ClipDragUnknownAddRef(
    LPCLIPDRAGDATA      lpclipdragdata     // data object ptr
)
{
    DPF("ClipDragAddRef: cRef = %d\n", lpclipdragdata->cRef + 1);

    return ++lpclipdragdata->cRef;
}


STDMETHODIMP_(ULONG)    ClipDragUnknownRelease (
    LPCLIPDRAGDATA lpclipdragdata
)
{
    DPF("ClipDragRelease: cRef = %d\n", lpclipdragdata->cRef - 1);

    if ( --lpclipdragdata->cRef != 0 )
        return lpclipdragdata->cRef;

    free(lpclipdragdata);

    return 0;
}


/**************************************************************************
******************   IDataObject INTERFACE IMPLEMENTATION.
**************************************************************************/
STDMETHODIMP    ClipDragQueryInterface (
    LPDATAOBJECT      lpDataObj,      // data object ptr
    REFIID            riidReq,        // IID required
    LPVOID FAR *      lplpUnk         // pre for returning the interface
)
{
    DPF("ClipDragQueryInterface\n");

    return
        ClipDragUnknownQueryInterface (
            (LPCLIPDRAGDATA)  (( struct CDataObject FAR* )lpDataObj)->lpclipdragdata ,
            riidReq,
            lplpUnk
        );
}


STDMETHODIMP_(ULONG)    ClipDragAddRef(
    LPDATAOBJECT      lpDataObj      // data object ptr
)
{
    return
        ClipDragUnknownAddRef (
            (LPCLIPDRAGDATA)  (( struct CDataObject FAR* )lpDataObj)->lpclipdragdata
        );
}


STDMETHODIMP_(ULONG)    ClipDragRelease (
    LPDATAOBJECT      lpDataObj      // data object ptr
)
{
    return
        ClipDragUnknownRelease (
            (LPCLIPDRAGDATA)  (( struct CDataObject FAR* )lpDataObj)->lpclipdragdata
        );
}



/* Routines called by ClipDragGetData, one for each format supported:
 */
HRESULT ClipDragGetData_EmbedSource(
    LPCLIPDRAGDATA lpclipdragdata,
    LPSTGMEDIUM    lpMedium
);
HRESULT ClipDragGetData_ObjectDescriptor(
    LPCLIPDRAGDATA lpclipdragdata,
    LPSTGMEDIUM    lpMedium
);
HRESULT ClipDragGetData_MetafilePict(
    LPCLIPDRAGDATA lpclipdragdata,
    LPSTGMEDIUM    lpMedium
);
HRESULT ClipDragGetData_DIB(
    LPCLIPDRAGDATA lpclipdragdata,
    LPSTGMEDIUM    lpMedium
);

/**************************************************************************
*   ClipDragGetData:
*   Returns the saved snapshot of the Object in the required format,
*   if available. If not, returns the current snapshot.  We still write
*   out the OLE1 embedding to maintain backward compatibility.
**************************************************************************/
STDMETHODIMP    ClipDragGetData (
    LPDATAOBJECT lpDataObj,
    LPFORMATETC  lpformatetc,
    LPSTGMEDIUM  lpMedium
)
{
    LPCLIPDRAGDATA lpclipdragdata;
    SCODE          scode;
    STGMEDIUM      stgm;
    CLIPFORMAT     cfFormat;
    DWORD          tymed;

    DPF("ClipDragGetData\n");

    if (lpMedium == NULL)
        RETURN_RESULT( E_FAIL);

    VERIFY_LINDEX(lpformatetc->lindex);

    memset(&stgm, 0, sizeof stgm);

    lpclipdragdata = (LPCLIPDRAGDATA) lpDataObj;

    cfFormat = lpformatetc->cfFormat;
    tymed    = lpformatetc->tymed;

    if ((cfFormat == cfEmbedSource) && (tymed & TYMED_ISTORAGE))
        scode = ClipDragGetData_EmbedSource(lpclipdragdata, &stgm);

    else if ((cfFormat == cfObjectDescriptor) && (tymed & TYMED_HGLOBAL))
        scode = ClipDragGetData_ObjectDescriptor(lpclipdragdata, &stgm);

    else if ((cfFormat == CF_METAFILEPICT) && (tymed & TYMED_MFPICT))
        scode = ClipDragGetData_MetafilePict(lpclipdragdata, &stgm);

    else if ((cfFormat == CF_DIB) && (tymed & TYMED_HGLOBAL))
        scode = ClipDragGetData_DIB(lpclipdragdata, &stgm);

    else
        scode = DATA_E_FORMATETC;

    if (scode == S_OK)
        *lpMedium = stgm;

    RETURN_RESULT(scode);
}

#ifdef DEBUG
BOOL WriteOLE2Class( )
{
    HKEY  hKey;
    TCHAR Data[8];
    DWORD Size;
    BOOL  rc = FALSE;

    if( RegOpenKeyEx( HKEY_CLASSES_ROOT, TEXT( "MPlayer\\Debug" ), 0,
                      KEY_READ, &hKey ) == ERROR_SUCCESS )
    {
        if( RegQueryValueEx( hKey, TEXT( "WriteOLE2Class" ), NULL, NULL,
                             (LPBYTE)&Data, &Size ) == ERROR_SUCCESS )
        {
            if( Data[0] == TEXT( 'y' ) || Data[0] == TEXT( 'Y' ) )
                rc = TRUE;
        }

        RegCloseKey( hKey );
    }

    return rc;
}
#endif


/*
 *
 */
HRESULT ClipDragGetData_EmbedSource(
    LPCLIPDRAGDATA lpclipdragdata,
    LPSTGMEDIUM    lpMedium
)
{
    SCODE    scode;
    LPSTREAM lpstm = NULL;
    LPWSTR   lpszUserType;
    HANDLE   hGlobal = NULL;
    DWORD_PTR    nNativeSz;
    ULONG    cbWritten;

    scode = GetScode(StgCreateDocfile(NULL, /* Create temporary compound file */
                                      STGM_CREATE | STGM_SALL | STGM_DELETEONRELEASE,
                                      0,    /* Reserved */
                                      &lpMedium->pstg));

    if (scode != S_OK)
        RETURN_RESULT(scode);

    lpMedium->tymed          = TYMED_ISTORAGE;
    lpMedium->pUnkForRelease = NULL;

    //Mark the Object as OLE1.
#ifdef UNICODE
    lpszUserType = gachClassRoot;
#else
    lpszUserType = AllocateUnicodeString(gachClassRoot);
    if (!lpszUserType)
        RETURN_RESULT(E_OUTOFMEMORY);
#endif

#ifdef DEBUG
    if(WriteOLE2Class())
    {
        DPF("ClipDragGetData_EmbedSource: Writing OLE2 class ID\n");
        scode = GetScode(WriteClassStg(lpMedium->pstg, &CLSID_MPLAYER));
    }
    else
#endif
    scode = GetScode(WriteClassStg(lpMedium->pstg, &CLSID_OLE1MPLAYER));

    if (scode != S_OK)
        RETURN_RESULT(scode);

    scode = GetScode(WriteFmtUserTypeStg(lpMedium->pstg, cfMPlayer, lpszUserType));
#ifndef UNICODE
    FreeUnicodeString(lpszUserType);
#endif
    if (scode != S_OK)
        RETURN_RESULT(scode);

    //Write to \1Ole10Native stream so that this will be readable by OLE1 Mplayer
    scode = GetScode(IStorage_CreateStream(lpMedium->pstg,sz1Ole10Native,
                     STGM_CREATE | STGM_SALL,0,0,&lpstm));

    if (scode != S_OK)
        RETURN_RESULT(scode);

    //Duplicate the handle we have saved.
    if(lpclipdragdata->fClipData && ghClipData)
        hGlobal = OleDuplicateData(ghClipData, cfEmbedSource, 0);
    else
        hGlobal = GetLink();

    if (!hGlobal)
    {
        GLOBALFREE(hGlobal);
        RETURN_RESULT(E_OUTOFMEMORY);
    }

    nNativeSz = GlobalSize(hGlobal);
    lpclipdragdata->lpdoc->native = GLOBALLOCK(hGlobal);
    if(!lpclipdragdata->lpdoc->native)
    {
        GLOBALUNLOCK(hGlobal);
        GLOBALFREE(hGlobal);
        RETURN_RESULT(E_OUTOFMEMORY);   /* What's the right error here? */
    }

    scode = GetScode(IStream_Write(lpstm,&nNativeSz,4,&cbWritten));

    if (scode != S_OK)
        RETURN_RESULT(scode);

    scode = GetScode(IStream_Write(lpstm,lpclipdragdata->lpdoc->native,
                                   (ULONG)nNativeSz,&cbWritten));

    if (cbWritten != nNativeSz)
        scode = E_FAIL  ;

    IStream_Release(lpstm);
    GLOBALUNLOCK(hGlobal);
    GLOBALFREE(hGlobal);
    lpstm = NULL;

    RETURN_RESULT(scode);
}

/*
 *
 */
HRESULT ClipDragGetData_ObjectDescriptor(
    LPCLIPDRAGDATA lpclipdragdata,
    LPSTGMEDIUM    lpMedium
)
{
    SIZEL   sizel;
    POINTL  pointl;
    TCHAR   displayname[256];
    LPTSTR  lpszdn = (LPTSTR)displayname;
    HGLOBAL hobjdesc;
    DWORD   dwStatus = 0;
	static  SZCODE aszDispFormat[] = TEXT("%"TS" : %"TS"");

    DPF("\n^^^^^^CDGetdata: OBJECTDESC");
    sizel.cx = extWidth;
    sizel.cy = extHeight;
    pointl.x = pointl.y = 0;
    wsprintf(displayname, aszDispFormat, (LPTSTR)gachClassRoot, (LPTSTR)gachWindowTitle);

#ifdef DEBUG
    if(WriteOLE2Class())
    {
        DPF("ClipDragGetData_ObjectDescriptor: Getting OLE2 class\n");
        hobjdesc = GetObjectDescriptorData(CLSID_MPLAYER, DVASPECT_CONTENT,
                                           sizel, pointl, dwStatus, lpszdn, lpszdn);
    }
    else
#endif
    hobjdesc = GetObjectDescriptorData(CLSID_OLE1MPLAYER, DVASPECT_CONTENT,
                                       sizel, pointl, dwStatus, lpszdn, lpszdn);

    if (hobjdesc)
    {
        lpMedium->hGlobal = hobjdesc;
        lpMedium->tymed = TYMED_HGLOBAL;
        lpMedium->pUnkForRelease = NULL;
        return NOERROR;
    }

    RETURN_RESULT(E_OUTOFMEMORY);
}

/*
 *
 */
HRESULT ClipDragGetData_MetafilePict(
    LPCLIPDRAGDATA lpclipdragdata,
    LPSTGMEDIUM    lpMedium
)
{
    SCODE scode;

    lpMedium->tymed = TYMED_MFPICT;

    if(lpclipdragdata->fClipData && ghClipMetafile)
        lpMedium->hGlobal = OleDuplicateData(ghClipMetafile, CF_METAFILEPICT, 0);
    else
        lpMedium->hGlobal = GetMetafilePict();

    if (lpMedium->hGlobal == NULL)
        scode = E_OUTOFMEMORY;
    else
        scode = S_OK;

    lpMedium->pUnkForRelease = NULL;

    RETURN_RESULT(scode);
}

/*
 *
 */
HRESULT ClipDragGetData_DIB(
    LPCLIPDRAGDATA lpclipdragdata,
    LPSTGMEDIUM    lpMedium
)
{
    SCODE scode;

    lpMedium->tymed = TYMED_HGLOBAL;

    if(lpclipdragdata->fClipData && ghClipDib)
        lpMedium->hGlobal = OleDuplicateData(ghClipDib, CF_DIB, 0);
    else
        /* We must make sure GetDib() happens on the main thread,
         * because otherwise MCI complains.
         */
        lpMedium->hGlobal = (HANDLE)SendMessage(ghwndApp, WM_GETDIB, 0, 0);

    if (lpMedium->hGlobal == NULL)
        scode = E_OUTOFMEMORY;
    else
        scode = S_OK;

    lpMedium->pUnkForRelease = NULL;

    RETURN_RESULT(scode);
}


/**************************************************************************
*   ClipDragGetDataHere:
*   Make the embedding by writing into the Stream Mplayer3EmbedSource.
*
**************************************************************************/
STDMETHODIMP    ClipDragGetDataHere (
    LPDATAOBJECT lpDataObj,
    LPFORMATETC  lpformatetc,
    LPSTGMEDIUM  lpMedium
)
{
    LPCLIPDRAGDATA  lpclipdragdata;
    HANDLE      hGlobal = NULL;
    DWORD_PTR   nNativeSz;
    LPTSTR      lpnative;
    ULONG       cbWritten;

    DPF("ClipDragGetDataHere\n");

    if (lpMedium == NULL)
        RETURN_RESULT(E_FAIL);

    VERIFY_LINDEX(lpformatetc->lindex);

    lpclipdragdata = (LPCLIPDRAGDATA) lpDataObj;

    if (lpformatetc->cfFormat == cfEmbedSource)
    {
        SCODE       scode;
        LPSTREAM    lpstm = NULL;
        LPWSTR      lpszUserType;

            if (lpMedium->tymed != TYMED_ISTORAGE)
            RETURN_RESULT(DATA_E_FORMATETC);

#ifdef UNICODE
        lpszUserType = gachClassRoot;
#else
        lpszUserType = AllocateUnicodeString(gachClassRoot);
        if (!lpszUserType)
            RETURN_RESULT(E_OUTOFMEMORY);
#endif
        //Mark the object as OLE1 MPlayer object for backward compatibility:
#ifdef DEBUG
        if(WriteOLE2Class())
        {
            DPF("ClipDragGetDataHere: Writing OLE2 class ID\n");
            scode = GetScode(WriteClassStg(lpMedium->pstg, &CLSID_MPLAYER));
        }
        else
#endif
        scode = GetScode(WriteClassStg(lpMedium->pstg, &CLSID_OLE1MPLAYER));

        if (scode != S_OK)
            RETURN_RESULT(scode);

        scode = GetScode(WriteFmtUserTypeStg(lpMedium->pstg, cfMPlayer, lpszUserType));
#ifndef UNICODE
        FreeUnicodeString(lpszUserType);
#endif
        if (scode != S_OK)
            RETURN_RESULT(scode);

        //Write to the \1Ole10Native stream so the object will be readable by OLE1 Mplayer
        if ((scode = GetScode(IStorage_CreateStream(lpMedium->pstg,
                                                    sz1Ole10Native,
                                                    STGM_CREATE | STGM_SALL,
                                                    0, 0, &lpstm))) != S_OK)
                RETURN_RESULT(scode);

        //Duplicate and give out the handle we have saved.
        if(lpclipdragdata->fClipData && ghClipData)
            hGlobal = OleDuplicateData(ghClipData, cfEmbedSource, 0);
        else
            hGlobal = GetLink();

        if (!hGlobal)
        {
            RETURN_RESULT(E_OUTOFMEMORY);
        }

        nNativeSz = GlobalSize(hGlobal);
        lpnative = GLOBALLOCK(hGlobal);
        if (!lpnative)
        {
            GLOBALUNLOCK(hGlobal);
            GLOBALFREE(hGlobal);
            RETURN_RESULT(E_OUTOFMEMORY);
        }

        scode = GetScode(IStream_Write(lpstm,&nNativeSz,4,&cbWritten));

        scode = GetScode(IStream_Write(lpstm,lpnative,(ULONG)nNativeSz,&cbWritten));
        if (cbWritten != nNativeSz) scode = E_FAIL  ;

        IStream_Release(lpstm);
        GLOBALUNLOCK(hGlobal);
        GLOBALFREE(hGlobal);
        RETURN_RESULT( scode);
    } else
        RETURN_RESULT(DATA_E_FORMATETC);
}



STDMETHODIMP    ClipDragQueryGetData (
    LPDATAOBJECT lpDataObj,
    LPFORMATETC  lpformatetc
)
{
    DPF("ClipDragQueryGetData\n");

    if (lpformatetc->cfFormat == cfEmbedSource ||
        lpformatetc->cfFormat == CF_METAFILEPICT ||
        lpformatetc->cfFormat == CF_DIB ||
        lpformatetc->cfFormat == cfObjectDescriptor
    )

    return NOERROR;
    else
    RETURN_RESULT(DATA_E_FORMATETC);
}


STDMETHODIMP    ClipDragGetCanonicalFormatEtc(
    LPDATAOBJECT lpDataObj,
    LPFORMATETC  lpformatetc,
    LPFORMATETC  lpformatetcOut
)
{
    DPF("ClipDragGetCanonicalFormatEtc\n");

    RETURN_RESULT(DATA_S_SAMEFORMATETC);
}


STDMETHODIMP        ClipDragSetData (
    LPDATAOBJECT lpDataObj,
    LPFORMATETC  lpformatetc,
    LPSTGMEDIUM  lpmedium,
    BOOL         fRelease
)
{
    DPF("ClipDragSetData\n");

    RETURN_RESULT(E_NOTIMPL);
}

STDMETHODIMP ClipDragEnumFormatEtc(
    LPDATAOBJECT         lpDataObj,
    DWORD                dwDirection,
    LPENUMFORMATETC FAR* ppenumFormatEtc
){
    LPCLIPDRAGENUM lpclipdragenum;

    if (ppenumFormatEtc != NULL)
        *ppenumFormatEtc = NULL;

    lpclipdragenum = _fmalloc(sizeof(CLIPDRAGENUM));
    if (lpclipdragenum == NULL)
    RETURN_RESULT(E_OUTOFMEMORY);

    lpclipdragenum->lpVtbl          = &ClipDragEnumVtbl;
    lpclipdragenum->cRef            = 1;
    lpclipdragenum->lpClipDragData  = (LPCLIPDRAGDATA) lpDataObj;
    lpclipdragenum->cfNext          = cfEmbedSource;

    lpclipdragenum->lpClipDragData->lpClipDragEnum = lpclipdragenum;
    *ppenumFormatEtc = (LPENUMFORMATETC) lpclipdragenum;
    return NOERROR;
}


STDMETHODIMP ClipDragAdvise(
    LPDATAOBJECT LPDATAOBJect,
    FORMATETC FAR* pFormatetc,
    DWORD advf,
    IAdviseSink FAR* pAdvSink,
    DWORD FAR* pdwConnection
)
{
    RETURN_RESULT(E_NOTIMPL);
}

STDMETHODIMP ClipDragUnadvise(
    LPDATAOBJECT LPDATAOBJect,
    DWORD dwConnection
)
{
    RETURN_RESULT(E_NOTIMPL);
}

STDMETHODIMP ClipDragEnumAdvise(
    LPDATAOBJECT LPDATAOBJect,
    LPENUMSTATDATA FAR* ppenumAdvise
)
{
    RETURN_RESULT(E_NOTIMPL);
}


/**************************************************************************
****************   IDropSource INTERFACE IMPLEMENTAION.
**************************************************************************/
STDMETHODIMP    DropSourceQueryInterface (
    LPDROPSOURCE      lpdropsource,    // data object ptr
    REFIID            riidReq,        // IID required
    LPVOID FAR *      lplpUnk         // pre for returning the interface
)
{
    return
        ClipDragUnknownQueryInterface (
            (LPCLIPDRAGDATA) ( ( struct CDropSource FAR* )lpdropsource)->lpclipdragdata ,
            riidReq,
            lplpUnk
        );
}


STDMETHODIMP_(ULONG)    DropSourceAddRef(
    LPDROPSOURCE      lpdropsource      // data object ptr
)
{
    return
        ClipDragUnknownAddRef (
            (LPCLIPDRAGDATA) ( ( struct CDropSource FAR* )lpdropsource)->lpclipdragdata
        );
}


STDMETHODIMP_(ULONG)    DropSourceRelease (
    LPDROPSOURCE      lpdropsource      // data object ptr
)
{
    return
        ClipDragUnknownRelease (
            (LPCLIPDRAGDATA) ( ( struct CDropSource FAR* )lpdropsource)->lpclipdragdata
        );
}

STDMETHODIMP    DropSourceQueryContinueDrag (
    LPDROPSOURCE      lpdropsource,     // data object ptr
    BOOL              fEscapePressed,
    DWORD          grfKeyState
)
{

    if (fEscapePressed)
    {
        DPF("DropSourceQueryContinueDrag: fEscapePressed\n");
        RETURN_RESULT( DRAGDROP_S_CANCEL);
    }
    else if (!(grfKeyState & MK_LBUTTON))
    {
        DPF("DropSourceQueryContinueDrag: !(grfKeyState & MK_LBUTTON)\n");
        RETURN_RESULT(DRAGDROP_S_DROP);
    }
    else
        return NOERROR;
}


STDMETHODIMP    DropSourceGiveFeedback (
    LPDROPSOURCE      lpsropsource,      // data object ptr
    DWORD             dwEffect
)
{
    DPF("DropSourceGiveFeedback\n");

    RETURN_RESULT(DRAGDROP_S_USEDEFAULTCURSORS);
}


/**************************************************************************
*************   IEnumFormatEtc INTERFACE IMPLEMENTATION.
**************************************************************************/
STDMETHODIMP ClipDragEnumQueryInterface
(
LPENUMFORMATETC lpEnumFormatEtc,  // Enumerator object ptr
REFIID          riidReq,          // IID required
LPVOID FAR*     lplpUnk           // pre for returning the interface
)
{
    LPCLIPDRAGENUM lpClipDragEnum;

    DPF("ClipDragEnumQueryInterface\n");

    lpClipDragEnum = (LPCLIPDRAGENUM) lpEnumFormatEtc;

    if (IsEqualIID(riidReq, &IID_IEnumFORMATETC) || IsEqualIID(riidReq, &IID_IUnknown)) {
    *lplpUnk = (LPVOID) lpClipDragEnum;
    lpClipDragEnum->cRef++;
    return NOERROR;
    } else {
        *lplpUnk = (LPVOID) NULL;
    RETURN_RESULT( E_NOINTERFACE);
    }
}


STDMETHODIMP_(ULONG) ClipDragEnumAddRef
(
LPENUMFORMATETC lpEnumFormatEtc   // Enumerator object ptr
)
{
    LPCLIPDRAGENUM lpClipDragEnum;

    lpClipDragEnum = (LPCLIPDRAGENUM) lpEnumFormatEtc;

    return ++lpClipDragEnum->cRef;
}


STDMETHODIMP_(ULONG) ClipDragEnumRelease
(
LPENUMFORMATETC lpEnumFormatEtc   // Enumerator object ptr
)
{
    LPCLIPDRAGENUM lpClipDragEnum;

    lpClipDragEnum = (LPCLIPDRAGENUM) lpEnumFormatEtc;

    if (--lpClipDragEnum->cRef != 0)
    return lpClipDragEnum->cRef;

    // Remove Data object pointer (if one exists) to this
    //
    if (lpClipDragEnum->lpClipDragData != NULL)
    lpClipDragEnum->lpClipDragData->lpClipDragEnum = NULL;

    _ffree(lpClipDragEnum);

    return 0;
}


STDMETHODIMP ClipDragEnumNext
(
LPENUMFORMATETC lpEnumFormatEtc,  // Enumerator object ptr
ULONG celt,                       // Number of items requested
FORMATETC FAR rgelt[],            // Buffer for retuend items
ULONG FAR* pceltFetched           // Number of items returned
)
{
    LPCLIPDRAGENUM lpClipDragEnum;
    int ce;
    LPFORMATETC pfe;

    DPF("ClipDragEnumNext\n");

    lpClipDragEnum = (LPCLIPDRAGENUM) lpEnumFormatEtc;

    if (pceltFetched != NULL)
        *pceltFetched = 0;

    if (lpClipDragEnum->lpClipDragData == NULL) // data object gone
    RETURN_RESULT( E_FAIL);

    pfe = rgelt;
    pfe->lindex = DEF_LINDEX;


    for (ce = (int) celt; ce > 0 && lpClipDragEnum->cfNext != 0; ce--) {

    if (lpClipDragEnum->cfNext == cfEmbedSource) {

            pfe->cfFormat = cfEmbedSource;
        pfe->ptd = NULL;
        pfe->dwAspect = DVASPECT_CONTENT;
            pfe->tymed = TYMED_ISTORAGE;
            pfe++;

        lpClipDragEnum->cfNext = CF_METAFILEPICT;
        }
    else
    if (lpClipDragEnum->cfNext == CF_METAFILEPICT) {

            pfe->cfFormat = CF_METAFILEPICT;
            pfe->ptd = NULL;
            pfe->dwAspect = DVASPECT_CONTENT;
        pfe->tymed = TYMED_MFPICT;
            pfe++;
        lpClipDragEnum->cfNext = CF_DIB; //0;
    }
    else
    if (lpClipDragEnum->cfNext == CF_DIB) {

        pfe->cfFormat = CF_DIB;
            pfe->ptd = NULL;
            pfe->dwAspect = DVASPECT_CONTENT;
        pfe->tymed = TYMED_HGLOBAL;
            pfe++;
        lpClipDragEnum->cfNext = cfObjectDescriptor; //0;
    }

    else
    if (lpClipDragEnum->cfNext == cfObjectDescriptor) {

        pfe->cfFormat = cfObjectDescriptor;
            pfe->ptd = NULL;
        pfe->dwAspect = DVASPECT_CONTENT;
        pfe->tymed = TYMED_HGLOBAL;
            pfe++;
        lpClipDragEnum->cfNext = 0;
    }

    }

    if (pceltFetched != NULL)
        *pceltFetched = celt - ((ULONG) ce) ;

    RETURN_RESULT( (ce == 0) ? S_OK : S_FALSE);
}


STDMETHODIMP ClipDragEnumSkip
(
LPENUMFORMATETC lpEnumFormatEtc,  // Enumerator object ptr
ULONG celt                        // Number of elements to skip
)
{
    LPCLIPDRAGENUM lpClipDragEnum;

    DPF("ClipDragEnumSkip\n");

    lpClipDragEnum = (LPCLIPDRAGENUM) lpEnumFormatEtc;

    if (lpClipDragEnum->lpClipDragData == NULL) // data object gone
    RETURN_RESULT( E_FAIL);

    if (lpClipDragEnum->cfNext == cfEmbedSource)
    {
    if (celt == 1)
        lpClipDragEnum->cfNext = CF_METAFILEPICT;
    else if (celt == 2)
        lpClipDragEnum->cfNext = CF_DIB;
    else if (celt == 3)
        lpClipDragEnum->cfNext = cfObjectDescriptor;
    else if (celt > 3)
        goto ReturnFalse;
    }
    else
    if (lpClipDragEnum->cfNext == CF_METAFILEPICT)
    {
    if (celt == 1)
        lpClipDragEnum->cfNext = CF_DIB;
    else if (celt == 2)
        lpClipDragEnum->cfNext = cfObjectDescriptor;
    else if (celt > 2)
        goto ReturnFalse;
    }
    else
    if (lpClipDragEnum->cfNext == CF_DIB)
    {
    if (celt == 1)
        lpClipDragEnum->cfNext = cfObjectDescriptor;
    else if (celt > 1)
        goto ReturnFalse;
    }
    else
    if (lpClipDragEnum->cfNext == cfObjectDescriptor)
    {
    if (celt > 0)
        goto ReturnFalse;
    }
    else
    {
ReturnFalse:
    RETURN_RESULT(S_FALSE);
    }
    return NOERROR;
}


STDMETHODIMP ClipDragEnumReset
(
LPENUMFORMATETC lpEnumFormatEtc   // Enumerator object ptr
)
{
    LPCLIPDRAGENUM lpClipDragEnum;

    DPF("ClipDragEnumReset\n");

    lpClipDragEnum = (LPCLIPDRAGENUM) lpEnumFormatEtc;

    if (lpClipDragEnum->lpClipDragData == NULL) // data object gone
    RETURN_RESULT( E_FAIL);

    lpClipDragEnum->cfNext = cfEmbedSource;

    return NOERROR;
}


STDMETHODIMP     ClipDragEnumClone
(
LPENUMFORMATETC lpEnumFormatEtc,  // Enumerator object ptr
LPENUMFORMATETC FAR* ppenum
)
{
    DPF("ClipDragEnumClone\n");

    if (ppenum != NULL)
        *ppenum = NULL;

    RETURN_RESULT( E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\ctrls.c ===
/*-----------------------------------------------------------------------------+
| TOOLBAR.C                                                                    |
|                                                                              |
| Contains the code which implements the toolbar and its buttons.              |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

#include <windows.h>
#include <string.h>
#include <shellapi.h>

#include "toolbar.h"
#include "mpole.h"
#include "mplayer.h"

#ifndef COLOR_BTNFACE
    #define COLOR_BTNFACE           15
    #define COLOR_BTNSHADOW         16
    #define COLOR_BTNTEXT           18
#endif

extern void FAR cdecl dprintf(LPSTR szFormat, ...);

extern HWND ghwndApp;
extern HWND ghwndToolbar;
extern HWND ghwndFSArrows;


/*
    Variables
*/

HBRUSH hbrGray = NULL;                 // Gray for text

HBRUSH hbrButtonFace;
HBRUSH hbrButtonShadow;
HBRUSH hbrButtonText;
HBRUSH hbrButtonHighLight;
HBRUSH hbrWindowFrame;
HBRUSH hbrWindowColour;

DWORD  rgbButtonHighLight;
DWORD  rgbButtonFocus;
DWORD  rgbButtonFace;
DWORD  rgbButtonText;
DWORD  rgbButtonShadow;
DWORD  rgbWindowFrame;
DWORD  rgbWindowColour;

TBBUTTON tbBtns[TB_NUM_BTNS + MARK_NUM_BTNS + ARROW_NUM_BTNS] =
{
    {BTN_PLAY,  IDT_PLAY,   TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    {BTN_PAUSE, IDT_PAUSE,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    {BTN_STOP,  IDT_STOP,   TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    {BTN_EJECT, IDT_EJECT,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    {BTN_HOME,  IDT_HOME,   TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    {BTN_RWD,   IDT_RWD,    TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    {BTN_FWD,   IDT_FWD,    TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    {BTN_END,   IDT_END,    TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    {-1,        0,          TBSTATE_ENABLED, TBSTYLE_SEP,    0},
    {BTN_MARKIN,    IDT_MARKIN,     TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    {BTN_MARKOUT,   IDT_MARKOUT,    TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    {ARROW_PREV,    IDT_ARROWPREV,     TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    {ARROW_NEXT,    IDT_ARROWNEXT,     TBSTATE_ENABLED, TBSTYLE_BUTTON, 0}
};

int BtnIndex[TB_NUM_BTNS + MARK_NUM_BTNS + ARROW_NUM_BTNS];

static int iBtnOffset[3] = {0,TB_NUM_BTNS, TB_NUM_BTNS+MARK_NUM_BTNS};


WNDPROC fnTBWndProc = NULL;
WNDPROC fnStatusWndProc = NULL;

/*
    ControlInit( hInst )

    This is called when the application is first loaded into
    memory.  It performs all initialization.

    Arguments:
        hInst    instance handle of current instance

    Returns:
        TRUE if successful, FALSE if not
*/

BOOL
FAR PASCAL
ControlInit(
HANDLE hInst)

{
    long        patGray[4];
    HBITMAP     hbmGray;
    int         i;

    /* initialize the brushes */

        for (i=0; i < 4; i++)
            patGray[i] = 0xAAAA5555L;   //  0x11114444L; // lighter gray

        hbmGray = CreateBitmap(8, 8, 1, 1, patGray);
        hbrGray = CreatePatternBrush(hbmGray);
        if (hbmGray)
            DeleteObject(hbmGray);

        rgbButtonFace       = GetSysColor(COLOR_BTNFACE);
        rgbButtonShadow     = GetSysColor(COLOR_BTNSHADOW);
        rgbButtonText       = GetSysColor(COLOR_BTNTEXT);
        rgbButtonHighLight  = GetSysColor(COLOR_BTNHIGHLIGHT);
        rgbButtonFocus      = GetSysColor(COLOR_BTNTEXT);
        rgbWindowFrame      = GetSysColor(COLOR_WINDOWFRAME);
        rgbWindowColour     = GetSysColor(COLOR_WINDOW);

        if (rgbButtonFocus == rgbButtonFace)
                rgbButtonFocus = rgbButtonText;

        hbrButtonFace       = CreateSolidBrush(rgbButtonFace);
        hbrButtonShadow     = CreateSolidBrush(rgbButtonShadow);
        hbrButtonText       = CreateSolidBrush(rgbButtonText);
        hbrButtonHighLight  = CreateSolidBrush(rgbButtonHighLight);
        hbrWindowFrame      = CreateSolidBrush(rgbWindowFrame);
        hbrWindowColour     = CreateSolidBrush(rgbWindowColour);

        if (((UINT_PTR)hbrWindowFrame  &      // fail if any of them are NULL ???
             (UINT_PTR)hbrButtonShadow &
             (UINT_PTR)hbrButtonText   &
             (UINT_PTR)hbrButtonHighLight &
             (UINT_PTR)hbrWindowFrame) == (UINT_PTR)0)


            return FALSE;
    return TRUE;
}

/*
    ControlCleanup()

    Delete the brushes we've been using
*/

void FAR PASCAL ControlCleanup(void)
{
        DeleteObject(hbrGray);
        DeleteObject(hbrButtonFace);
        DeleteObject(hbrButtonShadow);
        DeleteObject(hbrButtonText);
        DeleteObject(hbrButtonHighLight);
        DeleteObject(hbrWindowFrame);
        DeleteObject(hbrWindowColour);

#if 0
        DeleteObject(hbTBMain);
        DeleteObject(hbTBMark);
        DeleteObject(hbTBArrows);
#endif
}


BOOL FAR PASCAL toolbarInit(void)
{
    int i;

    InitCommonControls();

    for(i = 0; i < TB_NUM_BTNS + MARK_NUM_BTNS + ARROW_NUM_BTNS; i++)
        BtnIndex[i] = -1;
    return TRUE;
}


LONG_PTR FAR PASCAL SubClassedTBWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    switch(wMsg)
    {
    case WM_SIZE:
        return 0;

    case WM_STARTTRACK:
        switch(wParam)
        {
        case IDT_RWD:
        case IDT_FWD:
        case IDT_ARROWPREV:
        case IDT_ARROWNEXT:
            PostMessage(ghwndApp, WM_COMMAND, wParam, REPEAT_ID);
            SetTimer(hwnd, (UINT_PTR)ghwndApp, MSEC_BUTTONREPEAT, NULL);
        }
        return 0;

    case WM_ENDTRACK:
        switch(wParam)
        {
        case IDT_RWD:
        case IDT_FWD:
        case IDT_ARROWPREV:
        case IDT_ARROWNEXT:
            KillTimer(hwnd, wParam);
            SendMessage(ghwndApp, WM_HSCROLL, (WPARAM)TB_ENDTRACK, (LPARAM)hwnd);
        }
        return 0;

    case WM_TIMER:
        {
            WPARAM cmd;

            if (wParam != (WPARAM)ghwndApp)
                break;
            if (hwnd == ghwndToolbar)
            {
                if(SendMessage(hwnd, TB_ISBUTTONPRESSED, tbBtns[BTN_RWD].idCommand, 0L))
                    cmd = IDT_RWD;
                else if(SendMessage(hwnd, TB_ISBUTTONPRESSED, tbBtns[BTN_FWD].idCommand, 0L))
                    cmd = IDT_FWD;
                else
                    return 0;

                PostMessage(ghwndApp, WM_COMMAND, cmd, REPEAT_ID);
                return 0;
            }
            else
            if (hwnd == ghwndFSArrows)
            {
                if(SendMessage(hwnd, TB_ISBUTTONPRESSED, tbBtns[TB_NUM_BTNS+MARK_NUM_BTNS+ARROW_PREV].idCommand, 0L))
                    cmd = IDT_ARROWPREV;
                else if(SendMessage(hwnd, TB_ISBUTTONPRESSED, tbBtns[TB_NUM_BTNS+MARK_NUM_BTNS+ARROW_NEXT].idCommand, 0L))
                    cmd = IDT_ARROWNEXT;
                else
                    return 0;

                PostMessage(ghwndApp, WM_COMMAND, cmd, REPEAT_ID);
                return 0;
            }
            KillTimer(hwnd, wParam);
            return 0;
        }
    }
    return CallWindowProc(fnTBWndProc, hwnd, wMsg, wParam, lParam);
}

void SubClassTBWindow(HWND hwnd)
{
    if (!fnTBWndProc)
        fnTBWndProc = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_WNDPROC);
    if (hwnd)
        SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)SubClassedTBWndProc);
}

#ifndef CCS_NODIVIDER
/* For NT: */
#define CCS_NODIVIDER   0
#endif
HWND FAR PASCAL toolbarCreateMain(HWND hwndParent)
{
    HWND hwnd;

    hwnd =  CreateToolbarEx(hwndParent,
                            WS_VISIBLE|WS_CHILD|WS_CLIPSIBLINGS|TBSTYLE_BUTTON|TBSTYLE_TOOLTIPS|
                                CCS_NODIVIDER,
                            IDT_TBMAINCID, 8,
                            ghInst, IDR_TOOLBAR, NULL, 0, 16, 16, 16, 16, sizeof(TBBUTTON));

    if (hwnd)
        SubClassTBWindow(hwnd);
    return hwnd;
}

HWND FAR PASCAL toolbarCreateMark(HWND hwndParent)
{
    HWND hwnd;

    hwnd =  CreateToolbarEx(hwndParent,
                            WS_VISIBLE|WS_CHILD|WS_CLIPSIBLINGS|TBSTYLE_BUTTON|TBSTYLE_TOOLTIPS|
                                CCS_NODIVIDER,
                            IDT_TBMARKCID, 2,
                            ghInst, IDR_MARK, NULL, 0, 17, 16, 17, 16, sizeof(TBBUTTON));

    if (hwnd)
        SubClassTBWindow(hwnd);
    return hwnd;
}

HWND FAR PASCAL toolbarCreateArrows(HWND hwndParent)
{
    HWND hwnd;

    hwnd =  CreateToolbarEx(hwndParent,
                            WS_VISIBLE|WS_CHILD|WS_CLIPSIBLINGS|TBSTYLE_BUTTON|TBSTYLE_TOOLTIPS|
                                CCS_NODIVIDER,
                            IDT_TBARROWSCID,
                            2,
                            ghInst,
                            IDR_ARROWS,
                            NULL,
                            0,
                            4,
                            7,
                            4,
                            7,
                            sizeof(TBBUTTON));

    if (hwnd)
        SubClassTBWindow(hwnd);
    return hwnd;
}


/***************************************************************************/
/* toolbarStateFromButton: This fn is called by the parent application     */
/*                         to get the state of a button.  It will only     */
/*                         return DOWN, or UP or GRAYED as opposed to      */
/*                         toolbarFullStateFromButton which could return   */
/*                         FULLDOWN.                                       */
/***************************************************************************/
BOOL FAR PASCAL toolbarStateFromButton(HWND hwnd, int iButton, int tbIndex)
{
    int idBtn;
    int pos;

    pos = BtnIndex[iBtnOffset[tbIndex] + iButton];
    if (pos == -1)
        return FALSE;

    idBtn = tbBtns[iBtnOffset[tbIndex] + iButton].idCommand;
    return (BOOL)SendMessage(hwnd, TB_ISBUTTONENABLED, (WPARAM)idBtn, 0L);
}



/***************************************************************************/
/* toolbarAddTool:  Add a button to this toolbar.  Sort them by leftmost   */
/*                  position in the window (for tabbing order).            */
/*                  Return FALSE for an error.                             */
/***************************************************************************/
BOOL FAR PASCAL toolbarAddTool(HWND hwnd, int iButton, int tbIndex, int iState)
{
    TBBUTTON tb;

    tb = tbBtns[iBtnOffset[tbIndex] + iButton];
    if (iState)
        tb.fsState |= TBSTATE_ENABLED;
    else
        tb.fsState &= ~TBSTATE_ENABLED;

    if(!SendMessage(hwnd, TB_ADDBUTTONS, (WPARAM)1, (LPARAM)(const TBBUTTON FAR *)&tb))
        return FALSE;
    BtnIndex[iBtnOffset[tbIndex] + iButton] =
        (int)SendMessage(hwnd, TB_BUTTONCOUNT, 0, 0L) - 1;
    return TRUE;
}

BOOL FAR PASCAL toolbarSwapTools(HWND hwnd, int iButton, int jButton, int tbIndex)
{
    int pos;
    TBBUTTON tb;
    int newBut, oldBut;

    pos = BtnIndex[iBtnOffset[tbIndex] + iButton];
    if (pos == -1)
    {
        pos = BtnIndex[iBtnOffset[tbIndex] + jButton];
        if (pos == -1)
            return FALSE;
        newBut = iButton;
        oldBut = jButton;
    }
    else
    {
        newBut = jButton;
        oldBut = iButton;
    }

    SendMessage(hwnd, TB_DELETEBUTTON, (WPARAM)pos, 0L);
    BtnIndex[iBtnOffset[tbIndex] + oldBut] = -1;

    tb = tbBtns[iBtnOffset[tbIndex] + newBut];

    if(!SendMessage(hwnd, TB_INSERTBUTTON, (WPARAM)pos, (LPARAM)(const TBBUTTON FAR *)&tb))
        return FALSE;
    BtnIndex[iBtnOffset[tbIndex] + newBut] = pos;
    return TRUE;

}


/***************************************************************************/
/* toolbarModifyState:  Given a button ID on the toolbar, change its       */
/*                      state.                                             */
/*                      returns FALSE for an error or if no such button    */
/***************************************************************************/
BOOL FAR PASCAL toolbarModifyState(HWND hwnd, int iButton, int tbIndex, int iState)
{
    int idBtn;
    int pos;

    pos = BtnIndex[iBtnOffset[tbIndex] + iButton];
    if (pos == -1)
        return FALSE;

    idBtn = tbBtns[iBtnOffset[tbIndex] + iButton].idCommand;

    SendMessage(hwnd, TB_PRESSBUTTON,  (WPARAM)idBtn, 0L); //unpress button first. commctrl bug
    if (idBtn == IDT_STOP)
    {
         SendMessage(hwnd, TB_PRESSBUTTON,  (WPARAM)IDT_HOME, 0L);
         SendMessage(hwnd, TB_PRESSBUTTON,  (WPARAM)IDT_END, 0L);
         SendMessage(hwnd, TB_PRESSBUTTON,  (WPARAM)IDT_FWD, 0L);
         SendMessage(hwnd, TB_PRESSBUTTON,  (WPARAM)IDT_RWD, 0L);
    }
    if (!iState)
         SendMessage(hwnd, TB_PRESSBUTTON,  (WPARAM)IDT_EJECT, 0L);
    SendMessage(hwnd, TB_ENABLEBUTTON, (WPARAM)idBtn, (LPARAM)MAKELONG(iState, 0));
    return TRUE;
}

/***************************************************************************/
/* toolbarSetFocus :  Set the focus in the toolbar to the specified button.*/
/*                    If it's gray, it'll set focus to next ungrayed btn.  */
/***************************************************************************/
BOOL FAR PASCAL toolbarSetFocus(HWND hwnd, int iButton)
{
    int pos;

    if ((hwnd != ghwndToolbar) || (iButton != BTN_PLAY && iButton != BTN_PAUSE))
        return TRUE;

    pos = BtnIndex[iButton];
    if (pos != -1)
        return TRUE;

    toolbarSwapTools(hwnd, iButton, 1-iButton, TBINDEX_MAIN);

    return TRUE;
}

LONG_PTR FAR PASCAL SubClassedStatusWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    switch(wMsg)
    {
    case WM_SIZE:
        return 0;
    }
    return CallWindowProc(fnStatusWndProc, hwnd, wMsg, wParam, lParam);
}

void SubClassStatusWindow(HWND hwnd)
{
    if (!fnStatusWndProc)
        fnStatusWndProc = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_WNDPROC);
    if (hwnd)
        SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)SubClassedStatusWndProc);
}



/* SBS_SIZEGRIP isn't defined for NT!! */
#ifndef SBS_SIZEGRIP
#define SBS_SIZEGRIP 0
#endif

HWND CreateStaticStatusWindow(HWND hwndParent, BOOL fSizeGrip)
{
    HWND hwnd;

    hwnd = CreateStatusWindow(WS_CHILD|WS_VISIBLE|(fSizeGrip ? 0 : CCS_NOMOVEY),
                                TEXT(""), hwndParent, IDT_STATUSWINDOWCID);

    if (hwnd)
        SubClassStatusWindow(hwnd);
    return hwnd;
}

BOOL WriteStatusMessage(HWND hwnd, LPTSTR szMsg)
{
    TCHAR Text[64];
    SIZE  StatusTextExtent;
    LONG  StatusTextWidth;
    BOOL  rc;

    Text[0] = TEXT('\0');
    GetWindowText(hwnd, Text, CHAR_COUNT(Text));
    if (lstrcmp(szMsg, Text) == 0)
        return TRUE;

    GetStatusTextExtent(ghwndStatic, &StatusTextExtent);

    StatusTextWidth = StatusTextExtent.cy;

    rc = (BOOL)SendMessage(hwnd, SB_SETTEXT, (WPARAM)0, (LPARAM)szMsg);

    GetStatusTextExtent(ghwndStatic, &StatusTextExtent);

    if (StatusTextWidth != StatusTextExtent.cy)
        Layout();

    return rc;
}

BOOL GetStatusTextExtent(HWND hwnd, LPSIZE pTextExtent)
{
    HDC    hdc;
    HFONT  hfontOld;
    TCHAR  Text[64];

    hdc = GetDC(NULL);
    if (hdc == NULL)
        return FALSE;

    Text[0] = TEXT('\0');

    GetWindowText(hwnd, Text, CHAR_COUNT(Text));

    hfontOld = SelectObject(hdc, (HFONT)SendMessage(hwnd, WM_GETFONT, 0, 0));

    GetTextExtentPoint32(hdc, Text, STRLEN(Text), pTextExtent);

    SelectObject(hdc, hfontOld);

    ReleaseDC(NULL, hdc);

    return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\dynalink.c ===
/*-----------------------------------------------------------------------------+
| DYNALINK.H                                                                   |
|                                                                              |
| (C) Copyright Microsoft Corporation 1994.  All rights reserved.              |
|                                                                              |
| This file contains static PROC_INFO structures listing APIs called in each   |
| dynamically linked DLL.                                                      |
|                                                                              |
|                                                                              |
| Revision History                                                             |
|    July 1994 Andrew Bell created                                             |
|                                                                              |
+-----------------------------------------------------------------------------*/

#include <windows.h>
#include "mplayer.h"

TCHAR szComDlg32[] = TEXT("ComDlg32");
TCHAR szMPR[]      = TEXT("MPR");
TCHAR szOLE32[]    = TEXT("OLE32");

HMODULE hComDlg32;
HMODULE hMPR;
HMODULE hOLE32;

PROC_INFO ComDlg32Procs[] =
{
#ifdef UNICODE
    "GetOpenFileNameW",         0,
#else
    "GetOpenFileNameA",         0,
#endif
    NULL,                       0
};

PROC_INFO MPRProcs[] =
{
#ifdef UNICODE
    "WNetGetUniversalNameW",    0,
    "WNetGetConnectionW",       0,
    "WNetGetLastErrorW",        0,
#else
    "WNetGetUniversalNameA",    0,
    "WNetGetConnectionA",       0,
    "WNetGetLastErrorA",        0,
#endif
    NULL,                       0
};

PROC_INFO OLE32Procs[] =
{
    "CLSIDFromProgID",          0,
    "CoCreateInstance",         0,
    "CoDisconnectObject",       0,
    "CoGetMalloc",              0,
    "CoRegisterClassObject",    0,
    "CoRevokeClassObject",      0,
    "CreateDataAdviseHolder",   0,
    "CreateFileMoniker",        0,
    "CreateOleAdviseHolder",    0,
    "DoDragDrop",               0,
    "IsAccelerator",            0,
    "OleCreateMenuDescriptor",  0,
    "OleDestroyMenuDescriptor", 0,
    "OleDuplicateData",         0,
    "OleFlushClipboard",        0,
    "OleGetClipboard",          0,
    "OleInitialize",            0,
    "OleIsCurrentClipboard",    0,
    "OleSetClipboard",          0,
    "OleTranslateAccelerator",  0,
    "OleUninitialize",          0,
    "StgCreateDocfile",         0,
    "WriteClassStg",            0,
    "WriteFmtUserTypeStg",      0,
#ifndef IsEqualGUID
    /* This is now a macro on Daytona!
     */
    "IsEqualGUID",              0,
#endif
    NULL,                       0
};


BOOL LoadLibraryAndProcs(LPTSTR pLibrary, PPROC_INFO pProcInfo, HMODULE *phLibrary)
{
    HMODULE    hLibrary;
    PPROC_INFO p;

#ifdef DEBUG
    if (PROCS_LOADED(pProcInfo))
    {
        DPF0("Attempt to load %s when already loaded\n", pLibrary);
        return TRUE;
    }
#endif

    hLibrary = LoadLibrary(pLibrary);

    if (hLibrary == NULL)
    {
        Error1(ghwndApp, IDS_CANTLOADLIB, pLibrary);
        ExitProcess(0);
    }

    p = pProcInfo;

    while (p->Name)
    {
        p->Address = GetProcAddress(hLibrary, p->Name);

        if (p->Address == NULL)
        {
            Error2(ghwndApp, IDS_CANTFINDPROC, p->Name, pLibrary);
            ExitProcess(0);
        }

        p++;
    }

    *phLibrary = hLibrary;

    return TRUE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\dlgs.c ===
/*-----------------------------------------------------------------------------+
| DLGS.C                                                                       |
|                                                                              |
| Routines to handle selection range display                                   |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

//#undef NOSCROLL        // SB_* and scrolling routines
//#undef NOWINOFFSETS    // GWL_*, GCL_*, associated routines
//#undef NOCOLOR         // color stuff
//#include <string.h>
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include "mplayer.h"
#include "stdlib.h"

extern    UINT    gwCurScale;

TCHAR aszHelpFile[] = TEXT("MPLAYER.HLP");

/*
 * FUNCTION PROTOTYPES
 */
INT_PTR FAR PASCAL _EXPORT setselDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR FAR PASCAL _EXPORT optionsDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR FAR PASCAL _EXPORT mciDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

/*--------------------------------------------------------------+
| ******************* PUBLIC FUNCTIONS ************************ |
+--------------------------------------------------------------*/
/*--------------------------------------------------------------+
| setselDialog - bring up the dialog for Set Selection          |
|                                                               |
+--------------------------------------------------------------*/
BOOL FAR PASCAL setselDialog(HWND hwnd)
{
    //FARPROC fpfn;

    frameboxInit(ghInst, ghInstPrev);

    //fpfn = MakeProcInstance((FARPROC)setselDlgProc, ghInst);

    DialogBox(ghInst, TEXT("SetSelection"), hwnd, setselDlgProc);
    // FreeProcInstance missing anyway

    return TRUE;                // should we check return value?
}

static BOOL    sfNumLastChosen;
static BOOL    sfInUpdate = FALSE;
/*--------------------------------------------------------------+
| setselDlgProc - dialog procedure for Set Selection dialog     |
|                                                               |
+--------------------------------------------------------------*/
INT_PTR PASCAL _EXPORT setselDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    int     iItem;
    DWORD_PTR   fr, fr2, frIn, frOut, frMarkIn, frMarkOut, frCurrent;
    TCHAR   ach[80];
    LPTSTR  lpsz = (LPTSTR)ach;
    static int aKeyWordIds[] = {
				   IDC_EDITALL,  IDH_SELECT_ALL,
				   IDC_EDITNONE, IDH_SELECT_NONE,
				   IDC_EDITSOME, IDH_SELECT_FROM,
				   IDC_EDITFROM, IDH_SELECT_FROM,
				   IDC_ETTEXT,   IDH_SELECT_FROM,
				   IDC_EDITTO,   IDH_SELECT_FROM,
				   IDC_ESTEXT,   IDH_SELECT_FROM,
				   IDC_EDITNUM,  IDH_SELECT_FROM,
				   0, 0
			       };

    frMarkIn = frIn = SendMessage(ghwndTrackbar, TBM_GETSELSTART, 0, 0);
    frMarkOut = frOut = SendMessage(ghwndTrackbar, TBM_GETSELEND, 0, 0);
    frCurrent = SendMessage(ghwndTrackbar, TBM_GETPOS, 0, 0);

    switch(msg){
	case WM_INITDIALOG:
	    if (gwCurScale == ID_TIME) {
		LOADSTRING(IDS_TIMEMODE, ach);
		SetWindowText(hwnd, lpsz);
	    } else if (gwCurScale == ID_FRAMES) {
		LOADSTRING(IDS_FRAMEMODE, ach);
		SetWindowText(hwnd, lpsz);
	    } else {
		LOADSTRING(IDS_TRACKMODE, ach);
		SetWindowText(hwnd, lpsz);
	    }

	/* Always put something here - if no selection, use the cur frame */
	    if (frMarkIn == -1 || frMarkOut == -1) {
		SetDlgItemInt(hwnd, IDC_EDITFROM, (UINT)frCurrent, FALSE);
		SetDlgItemInt(hwnd, IDC_EDITTO, (UINT)frCurrent, FALSE);
		SetDlgItemInt(hwnd, IDC_EDITNUM, 0, FALSE);
	    } else {
		SetDlgItemInt(hwnd, IDC_EDITFROM, (UINT)frMarkIn, FALSE);
		SetDlgItemInt(hwnd, IDC_EDITTO, (UINT)frMarkOut, FALSE);
		SetDlgItemInt(hwnd, IDC_EDITNUM, (UINT)(frMarkOut - frMarkIn), FALSE);
	    }

	    if (frMarkIn == -1 || frMarkOut == -1) {
		/* turn on the NONE radio button */
		CheckRadioButton(hwnd, IDC_EDITALL, IDC_EDITNONE, IDC_EDITNONE);
	    } else if(frMarkIn == gdwMediaStart &&
		frMarkOut == gdwMediaStart + gdwMediaLength){
		/* turn on the ALL button, it is all selected */
		CheckRadioButton(hwnd, IDC_EDITALL, IDC_EDITNONE, IDC_EDITALL);
	    } else {
		/* turn on the From/To portion */
		CheckRadioButton(hwnd, IDC_EDITALL, IDC_EDITNONE, IDC_EDITSOME);
	    }

	    return TRUE;

	case WM_CONTEXTMENU:
	    {
		int i;
		for (i = 0; aKeyWordIds[i]; i+=2)
		    if (aKeyWordIds[i] == GetDlgCtrlID((HWND)wParam))
			break;
		if (aKeyWordIds[i] == 0)
		    break;

		WinHelp((HWND)wParam, aszHelpFile, HELP_CONTEXTMENU, (UINT_PTR)(LPVOID)aKeyWordIds);
		return TRUE;
	    }

	case WM_HELP:
	    {
		int i;

		for (i = 0; aKeyWordIds[i]; i+=2)
		    if (aKeyWordIds[i] == ((LPHELPINFO)lParam)->iCtrlId)
			break;
		if (aKeyWordIds[i] == 0)
		    break;

		WinHelp(((LPHELPINFO)lParam)->hItemHandle, aszHelpFile,
			HELP_WM_HELP, (UINT_PTR)(LPVOID)aKeyWordIds);
		return TRUE;
	    }

	case WM_COMMAND:
	    switch(LOWORD(wParam)){
		WORD Code;
		BOOL OK;

		case IDOK:
		    /* We hit this AFTER we press OK on the selection box */

		    /* Make sure box we're editing loses focus before we */
		    /* execute, so values will be set properly.          */
		    SetFocus(GetDlgItem(hwnd, IDOK));
		    if (IsDlgButtonChecked(hwnd, IDC_EDITALL)) {
			/* this is the All: case */
			frIn = gdwMediaStart;
			frOut = gdwMediaStart + gdwMediaLength;
		    } else if (IsDlgButtonChecked(hwnd, IDC_EDITNONE)){
			/* this is the None: case */
			frIn = frOut = (DWORD)(-1);
		    } else {
			/* this is the From: To: case */
			iItem = 0;

			frIn = GetDlgItemInt(hwnd, IDC_EDITFROM, &OK, FALSE);

			if (!OK)
			    iItem = IDC_EDITFROM;    // we misbehaved
			else {

			    frOut = GetDlgItemInt(hwnd, IDC_EDITTO, &OK, FALSE);

			    if (!OK)
				iItem = IDC_EDITTO;
			}
			if ((!OK)
			    || (frOut < frIn)
			    || ((long)frIn < (long)gdwMediaStart)
			    || (frOut > gdwMediaStart + gdwMediaLength)) {
			    if (!iItem && (long)frIn < (long)gdwMediaStart)
				iItem = IDC_EDITFROM; // who misbehaved?
			    else if (!iItem)
				iItem = IDC_EDITTO;
//                   Don't beep -- Lose focus message already beeped
//                          MessageBeep(MB_ICONEXCLAMATION);
		    /* Illegal values, display msg box  */
			    ErrorResBox(hwnd, ghInst,
					MB_ICONEXCLAMATION | MB_OK,
					IDS_APPNAME, IDS_FRAMERANGE);
		    /* Prevent box from ending */
		    /* select offending value */
			    SetFocus(GetDlgItem(hwnd, iItem));

			    SendMessage(GetDlgItem(hwnd, iItem),
					EM_SETSEL, 0, (LPARAM)-1);

			    return TRUE;
			}
		    }
		    SendMessage(ghwndTrackbar, TBM_SETSELSTART, (WPARAM)FALSE, frIn);
		    SendMessage(ghwndTrackbar, TBM_SETSELEND, (WPARAM)TRUE, frOut);
		    DirtyObject(TRUE);
		    EndDialog(hwnd, TRUE);
		    break;

		case IDCANCEL:
		    EndDialog(hwnd, FALSE);
		    break;

		case IDC_EDITALL:
		    CheckRadioButton(hwnd, IDC_EDITALL,
				     IDC_EDITNONE, IDC_EDITALL);
		    break;

		case IDC_EDITNONE:
		    CheckRadioButton(hwnd, IDC_EDITALL,
				     IDC_EDITNONE, IDC_EDITNONE);
		    break;

		case IDC_EDITSOME:
		    CheckRadioButton(hwnd, IDC_EDITALL,
				    IDC_EDITNONE, IDC_EDITSOME);

		    /* put the focus on the FROM box */
		    SetFocus(GetDlgItem(hwnd, IDC_EDITFROM));
		    break;

		case IDC_EDITNUM:
		    /* turn on the FROM box if it isn't */
		    Code = GET_WM_COMMAND_CMD(wParam, lParam);

		    if (!IsDlgButtonChecked(hwnd, IDC_EDITSOME))
		    {
			SetFocus(GetDlgItem(hwnd, IDC_EDITSOME));
			CheckRadioButton(hwnd, IDC_EDITALL,
					IDC_EDITNONE, IDC_EDITSOME);
		    }

		    if (!sfInUpdate && Code == EN_KILLFOCUS) {
			sfNumLastChosen = TRUE;
			goto AdjustSomething;
		    }
		    break;

		case IDC_EDITTO:
		    /* turn on the FROM box if it isn't */
		    Code = GET_WM_COMMAND_CMD(wParam, lParam);

		    if (!IsDlgButtonChecked(hwnd, IDC_EDITSOME))
		    {
			SetFocus(GetDlgItem(hwnd, IDC_EDITSOME));
			CheckRadioButton(hwnd, IDC_EDITALL,
					IDC_EDITNONE, IDC_EDITSOME);
			
		    }

		    if (!sfInUpdate && Code == EN_KILLFOCUS) {
			sfNumLastChosen = FALSE;
			goto AdjustSomething;
		    }
		    break;

		case IDC_EDITFROM:
		    /* turn on the FROM box if it isn't */
		    Code = GET_WM_COMMAND_CMD(wParam, lParam);

		    if (!IsDlgButtonChecked(hwnd, IDC_EDITSOME))
		    {
			CheckRadioButton(hwnd, IDC_EDITALL,
					IDC_EDITNONE, IDC_EDITSOME);
			if (GetFocus() != GetDlgItem(hwnd, IDC_EDITSOME))
				SetFocus(GetDlgItem(hwnd, IDC_EDITSOME));

		    }

		    if (!sfInUpdate && Code == EN_KILLFOCUS) {
			sfNumLastChosen = FALSE;
			goto AdjustSomething;
		    }
		    break;

AdjustSomething:
		    sfInUpdate = TRUE;

		    fr = GetDlgItemInt(hwnd, IDC_EDITFROM, &OK, FALSE);

		    if (!OK)
			MessageBeep(MB_ICONEXCLAMATION);
		    else {
			if ((long)fr < (long)gdwMediaStart) {
			    MessageBeep(MB_ICONEXCLAMATION);
			    fr = gdwMediaStart;
			}
			if (fr > gdwMediaStart + gdwMediaLength) {
			    MessageBeep(MB_ICONEXCLAMATION);
			    fr = gdwMediaStart + gdwMediaLength;
			}

		    // We have to do this in time format, or if fr changed

			SetDlgItemInt(hwnd, IDC_EDITFROM, (UINT)fr, FALSE);

			if (sfNumLastChosen) {
			    /* They changed the number of frames last, */
			    /* so keep it constant.                    */
AdjustTo:
			    fr2 = GetDlgItemInt(hwnd, IDC_EDITNUM, &OK, FALSE);

			    if (!OK)
				MessageBeep(MB_ICONEXCLAMATION);
			    else {
				if (fr + fr2 > gdwMediaStart + gdwMediaLength) {
				    MessageBeep(MB_ICONEXCLAMATION);
				    fr2 = gdwMediaStart + gdwMediaLength - fr;
				}

//                               if (fr2 < 0)
//                                   fr2 = 0;

			// We have to do this in time format, or if fr changed

				SetDlgItemInt(hwnd, IDC_EDITNUM, (UINT)fr2, FALSE);
				SetDlgItemInt(hwnd, IDC_EDITTO, (UINT)(fr + fr2), FALSE);
			    }
			} else {
			    /* They changed a frame number last, */
			    /* so vary the number of frames      */

			    fr2 = GetDlgItemInt(hwnd, IDC_EDITTO, &OK, FALSE);

			    if (!OK)
				MessageBeep(MB_ICONEXCLAMATION);
			    else {
				if (fr2 < fr) {
				/* Set TO = FROM */
				SetDlgItemInt(hwnd, IDC_EDITNUM, 0, FALSE);
				goto AdjustTo;
			    }

			    if (fr2 > gdwMediaStart + gdwMediaLength) {
				MessageBeep(MB_ICONEXCLAMATION);
				fr2 = gdwMediaStart + gdwMediaLength;
			    }

			    SetDlgItemInt(hwnd, IDC_EDITNUM, (UINT)(fr2 - fr), FALSE);

			    // must redraw for time mode or if fr2 changed
			    SetDlgItemInt(hwnd, IDC_EDITTO, (UINT)fr2, FALSE);
			}
		    }
		}

		sfInUpdate = FALSE;
		return TRUE;

		break;
	    }
	    break;

	}
	return FALSE;
}

/*--------------------------------------------------------------+
| optionsDialog - bring up the dialog for Options               |
|                                                               |
+--------------------------------------------------------------*/
BOOL FAR PASCAL optionsDialog(HWND hwnd)
{
    //FARPROC fpfn;
#if 0
    DWORD   ThreadId;
    DWORD   WindowThreadId;
#endif

    //fpfn = MakeProcInstance((FARPROC)optionsDlgProc, ghInst);

#if 0
    Problem:

    When in-place editing, bring up the Options (or other) dialog,
    then bring another app into the foreground.  If you now click on
    our container, you just get a beep.  You can get back using the
    Task List.

    I can't get it to work with AttachThreadInput, but I'm not even
    sure that this should be the server's responsibility.  It's the
    container that's receiving the mouse clicks.

    I haven't had any word from the OLE guys on this question.

    if (gfOle2IPEditing)
    {
	ThreadId = GetCurrentThreadId( );
	WindowThreadId = GetWindowThreadProcessId(ghwndCntr, NULL);
	AttachThreadInput(WindowThreadId, ThreadId, TRUE);
    }
#endif

    DialogBox(ghInst, TEXT("Options"), hwnd, optionsDlgProc);

#if 0
    if (gfOle2IPEditing)
	AttachThreadInput(ThreadId, WindowThreadId, FALSE);
#endif

    // FreeProcInstance missing anyway
    return TRUE;    // should we check return value?
}

/*--------------------------------------------------------------+
| optionsDlgProc - dialog procedure for Options dialog          |
|                                                               |
+--------------------------------------------------------------*/
INT_PTR FAR PASCAL _EXPORT optionsDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    UINT w;
    HDC  hdc;
    static int aKeyWordIds[] =
    {
	OPT_AUTORWD,     IDH_OPT_AUTO,
	OPT_AUTOREP,     IDH_OPT_REPEAT,
	IDC_OLEOBJECT,   IDH_OPT_CAPTCONTROL,
	OPT_BAR,         IDH_OPT_CAPTCONTROL,
	OPT_BORDER,      IDH_OPT_BORDER,
	OPT_PLAY,        IDH_OPT_PLAYCLIENT,
	OPT_DITHER,      IDH_OPT_DITHER,
	IDC_CAPTIONTEXT, IDH_OPT_CAPTION,
	IDC_TITLETEXT,   IDH_OPT_CAPTION,
	0  , 0
    };

    switch(msg){
	case WM_INITDIALOG:
	    /* Take advantage of the fact that the button IDS are the */
	    /* same as the bit fields.                                */
	    for (w = OPT_FIRST; w <= OPT_LAST; w <<= 1)
		CheckDlgButton(hwnd, w, gwOptions & w);

	    /* Enable and Fill the Title Text */
	    /* limit this box to CAPTION_LEN chars of input */
	    SendMessage(GetDlgItem(hwnd, IDC_TITLETEXT), EM_LIMITTEXT,
			(WPARAM)CAPTION_LEN, 0L);
	    SendMessage(hwnd, WM_COMMAND, (WPARAM)OPT_BAR, 0L);

	    hdc = GetDC(NULL);
	    if (!(GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) ||
		!(gwDeviceType & DTMCI_CANWINDOW)) {
		CheckDlgButton(hwnd, OPT_DITHER, FALSE);
		EnableWindow(GetDlgItem(hwnd, OPT_DITHER), FALSE);

#if 0
		CheckDlgButton(hwnd, OPT_USEPALETTE, FALSE);
		EnableWindow(GetDlgItem(hwnd, OPT_USEPALETTE), FALSE);
#endif
	    }
	    ReleaseDC(NULL, hdc);
	    return TRUE;

	case WM_CONTEXTMENU:
	    {
		WinHelp((HWND)wParam, aszHelpFile, HELP_CONTEXTMENU, (UINT_PTR)(LPVOID)aKeyWordIds);
		return TRUE;
	    }
	case WM_HELP:
	    {
		int i;

		for (i = 0; aKeyWordIds[i]; i+=2)
		    if (aKeyWordIds[i] == ((LPHELPINFO)lParam)->iCtrlId)
			break;
		
		WinHelp(((LPHELPINFO)lParam)->hItemHandle, aszHelpFile,
			HELP_WM_HELP, (UINT_PTR)(LPVOID)aKeyWordIds);
		return TRUE;
	    }

	case WM_COMMAND:
	    switch(LOWORD(wParam)){
		BOOL f;

		case IDOK:
		    /* Change auto-repeat on the fly:
		     * If the auto-repeat option has changed
		     * and we're playing right now, toggle
		     * the appropriate global option and call
		     * PlayMCI().  This will update things.
		     * Note that if we are currently playing
		     * a selection, this causes the whole clip
		     * to be played.  Is there any way round this?
		     */
		    if ((gwStatus == MCI_MODE_PLAY)
		       &&(((gwOptions & OPT_AUTOREP) == OPT_AUTOREP)
			 != (BOOL)IsDlgButtonChecked(hwnd, OPT_AUTOREP)))
		    {
			gwOptions ^= OPT_AUTOREP;
			PlayMCI(0,0);
		    }

		    gwOptions &= OPT_SCALE;    // keep the Scale Mode

		    /* Take advantage of the fact that the button IDS are the */
		    /* same as the bit fields.                                */
		    for (w = OPT_FIRST; w <= OPT_LAST; w <<= 1)
			if (IsDlgButtonChecked(hwnd, w))
			    gwOptions |= w;

		    if (IsDlgButtonChecked(hwnd, OPT_BAR))
		    {
			GetWindowText(GetDlgItem(hwnd, IDC_TITLETEXT),
				      gachCaption, CHAR_COUNT(gachCaption));

			if (gachCaption[0])
			    gwOptions |= OPT_TITLE;
			else
			    gwOptions &= ~OPT_TITLE;
		    }

		    DirtyObject(FALSE);
		    EndDialog(hwnd, TRUE);
		    break;

		case IDCANCEL:
		    EndDialog(hwnd, FALSE);
		    break;

		case OPT_BAR:
		    f = IsDlgButtonChecked(hwnd, OPT_BAR);
		    EnableWindow(GetDlgItem(hwnd, IDC_CAPTIONTEXT), f);
		    EnableWindow(GetDlgItem(hwnd, IDC_TITLETEXT), f);

		    if(f) {
			SetWindowText(GetDlgItem(hwnd, IDC_TITLETEXT), gachCaption);
		    } else {
			GetWindowText(GetDlgItem(hwnd, IDC_TITLETEXT),
				      gachCaption, CHAR_COUNT(gachCaption));
			SetWindowText(GetDlgItem(hwnd, IDC_TITLETEXT), TEXT(""));
		    }

		    break;
	    }
    }
    return FALSE;
}


/*--------------------------------------------------------------+
| mciDialog - bring up the dialog for MCI Send Command          |
|                                                               |
+--------------------------------------------------------------*/
BOOL FAR PASCAL mciDialog(HWND hwnd)
{
    //FARPROC fpfn;

    //fpfn = MakeProcInstance((FARPROC)mciDlgProc, ghInst);
    DialogBox(ghInst, MAKEINTATOM(DLG_MCICOMMAND), hwnd, mciDlgProc);
    // FreeProcInstance missing anyway

    return TRUE;    // should we check return value?
}


/* StripLeadingAndTrailingWhiteSpace
 *
 * Removes blanks at the beginning and end of the string.
 *
 * Parameters:
 *
 *     pIn - Pointer to the beginning of the string
 *
 *     InLen - Length of the input string.  If 0, the length will be checked.
 *
 *     pOutLen - Pointer to a buffer to receive the length of the output string.
 *
 * Return:
 *
 *     Pointer to the output string.
 *
 * Remarks:
 *
 *     If InLen == *pOutLen, the string has not changed.
 *
 *     This routine is destructive: all trailing white space is converted
 *     to NULLs.
 *
 *
 * Andrew Bell, 4 January 1995
 */
LPTSTR StripLeadingAndTrailingWhiteSpace(LPTSTR pIn, DWORD InLen, LPDWORD pOutLen)
{
    LPTSTR pOut = pIn;
    DWORD  Len = InLen;

    if (Len == 0)
	Len = lstrlen(pIn);

    /* Strip trailing blanks:
     */
    while ((Len > 0) && (pOut[Len - 1] == TEXT(' ')))
    {
	pOut[Len - 1] = TEXT('\0');
	Len--;
    }

    /* Strip leading blanks:
     */
    while ((Len > 0) && (*pOut == TEXT(' ')))
    {
	pOut++;
	Len--;
    }

    if (pOutLen)
	*pOutLen = Len;

    return pOut;
}


INT_PTR FAR PASCAL _EXPORT mciDlgProc(HWND hwnd, unsigned msg, WPARAM wParam, LPARAM lParam)
{
    TCHAR   ach[MCI_STRING_LENGTH];
    UINT    w;
    DWORD   dw;
    LPTSTR  pStrip;
    DWORD   NewLen;

    switch (msg)
    {
	case WM_INITDIALOG:
	    SendDlgItemMessage(hwnd, IDC_MCICOMMAND, EM_LIMITTEXT, CHAR_COUNT(ach) -1, 0);
	    return TRUE;

	case WM_COMMAND:
	    switch (LOWORD(wParam))
	    {
		case IDOK:
		    w = GetDlgItemText(hwnd, IDC_MCICOMMAND, ach, CHAR_COUNT(ach));

		    /* Strip off any white space at the start of the command,
		     * otherwise we get an MCI error.  Remove it from the
		     * end also.
		     */
		    pStrip = StripLeadingAndTrailingWhiteSpace(ach, w, &NewLen);

		    if (w > NewLen)
		    {
			SetDlgItemText(hwnd, IDC_MCICOMMAND, pStrip);
			w = GetDlgItemText(hwnd, IDC_MCICOMMAND, ach, CHAR_COUNT(ach));
		    }

		    if (w == 0)
			break;

		    SendDlgItemMessage(hwnd, IDC_MCICOMMAND, EM_SETSEL, 0, (LPARAM)-1);

		    dw = SendStringMCI(ach, ach, CHAR_COUNT(ach));

		    if (dw != 0)
		    {
			mciGetErrorString(dw, ach, CHAR_COUNT(ach));
//                        Error1(hwnd, IDS_DEVICEERROR, (LPTSTR)ach);
		    }

		    SetDlgItemText(hwnd, IDC_RESULT, ach);

		    break;

		case IDCANCEL:
		    EndDialog(hwnd, FALSE);
		    break;
	    }
	    break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\doverb.c ===
/*---------------------------------------------------------------------------
|   DOVERB.C
|   This file is used to be called server.c in the OLE1 versions of MPlayer.
|   This file has the ReallyDoVerb function which is called by the the
|   OLE DoVerb method. This file also has some functions to do the
|   InPlace activation in OLE1 apps.
|
|   Modified for OLE2 By:   Vij Rajarajan (VijR)
+---------------------------------------------------------------------------*/
#define SERVERONLY
#include <windows.h>
#include <mmsystem.h>
#include <shellapi.h>
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#undef _MAX_PATH             // ??? someone hacking?
#undef _MAX_DIR              // ??? someone hacking?
#undef _MAX_FNAME            // ??? someone hacking?
#undef _MAX_EXT              // ??? someone hacking?

#include "ctrls.h"
#include "mpole.h"
#include "mplayer.h"
#include "toolbar.h"
#include "ole2ui.h"

#define OLE_OK S_OK
#define NOVERB 1000

extern HANDLE   ghInst;
extern HWND ghwndFocus;     //  Who had focus when we went inactive
extern HWND     ghwndFocusSave;         // saved focus window
extern HOOKPROC fpMouseHook;            // Mouse hook proc address.

extern UINT     gwPlaybarHeight;        //tell playbar how tall to make
                                        //itself so it covers the title
DWORD           gdwPosition;
LONG            glCurrentVerb = NOVERB;
BOOL               gfBrokenLink = FALSE;
static BOOL     gfMouseUpSeen = FALSE;     // OK to close play in place?
static BOOL     gfKeyStateUpSeen = FALSE;  // OK to close play in place?
extern HMODULE  hMciOle;

/*
** These functions are exported from mciole32.dll.
**
*/
typedef BOOL (*LPINSTALLHOOK)( HWND, DWORD );
typedef BOOL (*LPREMOVEHOOK)( VOID );

LPINSTALLHOOK       fpInstallHook;
LPREMOVEHOOK        fpRemoveHook;
BOOL                fHookInstalled = FALSE;

char                aszInstallHook[]       = "InstallHook";
char                aszRemoveHook[]        = "RemoveHook";


/* Height of picture given to client to be pasted */
static UINT  gwPastedHeight;
static DWORD gwOldOptions;
static DWORD gwOldHeight;

TCHAR gachFile[_MAX_PATH];
static int   gerr;
static HWND  ghwndClient = NULL;
static RECT  grcClient;
BOOL   gfOle1Client = FALSE;

WNDPROC      gfnMCIWndProc;
HWND         ghwndSubclass;


BOOL    SkipInPlaceEdit = FALSE;     //TRUE if we are just reactivating
BOOL    gfSeenPBCloseMsg;            //TRUE if the subclasses PlayBack WIndow Proc
                                     //has seen the WM_CLOSE message
HWND    ghwndFocusSave;              //Who had the focus when we were activated.?

#define abs(x) ((x) < 0 ? -(x) : (x))
#ifndef GetWS
#define GetWS(hwnd)     GetWindowLongPtr(hwnd, GWL_STYLE)
#define PutWS(hwnd, f)  SetWindowLongPtr(hwnd, GWL_STYLE, f)
#define TestWS(hwnd,f)  (GetWS(hwnd) & f)
#define SetWS(hwnd, f)  PutWS(hwnd, GetWS(hwnd) | f)
#define ClrWS(hwnd, f)  PutWS(hwnd, GetWS(hwnd) & ~(f))
#endif

static  SZCODE aszAppName[]           = TEXT("MPlayer");


STATICFN BOOL FileExists(LPTSTR szFile, LPTSTR szFullName, int iLen);
STATICFN BOOL NetParseFile(LPTSTR szFile, LPTSTR szDrive, LPTSTR szPath);

HPALETTE FAR PASCAL CreateSystemPalette(void);
void TransferTools(HWND hwndToolWindow);

#ifdef DEBUG
BOOL ShowAppWindow(int nCmdShow)
{
    return ShowWindow(ghwndApp, nCmdShow);
}
#define SHOWAPPWINDOW(nCmdShow) ShowAppWindow(nCmdShow)
#else
#define SHOWAPPWINDOW(nCmdShow) ShowWindow(ghwndApp, nCmdShow)
#endif

/*************************************************************************
* DirtyObject(BOOL fDocStgChangeOnly) - mark the "object" dirty,
* ie has been changed.
*
* We set the gfDirty flag to TRUE and iff we are a embedded object tell
* the client we have changed by sending a SendDocMsg(OLE_CHANGED).
* fDocStgChangeOnly is TRUE if the change would affect the Embedding if there
* is one but not appearence of the object i.e. the Metafile.
* OLE_CHANGED message is sent only if fDocStgChangeOnly is FALSE;
***************************************************************************/
void DirtyObject(BOOL fDocStgChangeOnly)
{
    //
    // NOTE we want to send OLE_CHANGED even if selection has changed
    //

    if (gfOle2IPEditing && ((gwOptions & OPT_BAR) != (gwOldOptions &OPT_BAR)) && !fDocStgChangeOnly)
    {
        RECT rc;
        BOOL fCanWindow = gwDeviceType & DTMCI_CANWINDOW;

        if (fCanWindow)
        {
            GetWindowRect(ghwndApp, (LPRECT)&rc);
            OffsetRect((LPRECT)&rc, -rc.left, -rc.top);

            /* rc contains the coordinates of the current app window.
             * If we have a playbar, we must allow space for it:
             */
            if ((gwOptions & OPT_BAR) && !(gwOldOptions &OPT_BAR))
            {
                /* Add bar */
                Layout();
                gwPlaybarHeight = TOOLBAR_HEIGHT;
            }
            else if(!(gwOptions & OPT_BAR) && (gwOldOptions &OPT_BAR))
            {
                /* Remove bar */
                Layout();
                gwPlaybarHeight = 0;
            }
        }
        else
        {
            HBITMAP hbm;
            BITMAP  bm;

            GetWindowRect(ghwndIPHatch, (LPRECT)&rc);
            if (gwOptions & OPT_BAR)
                gwPlaybarHeight = TOOLBAR_HEIGHT;
            else
                gwPlaybarHeight = 0;

            hbm =   BitmapMCI();
            GetObject(hbm,sizeof(bm),&bm);
            rc.bottom = rc.top + bm.bmHeight;
            rc.right = rc.left + bm.bmWidth;
            DeleteObject(hbm);

            MapWindowPoints(NULL,ghwndCntr,(LPPOINT)&rc, (UINT)2);

            DPF("IOleInPlaceSite::OnPosRectChange %d, %d, %d, %d\n", rc);
            if (!gfInPPViewer)
                IOleInPlaceSite_OnPosRectChange(docMain.lpIpData->lpSite, &rc);
        }
    }

    if (gwOptions != gwOldOptions)
    {
        gwOldOptions = gwOptions;
        if (gfEmbeddedObject && !fDocStgChangeOnly)
            SendDocMsg(&docMain, OLE_CHANGED);
    }

    if (gfDirty /* IsObjectDirty() */)
        return;

    fDocChanged=gfDirty = TRUE;
    gfValidCaption = FALSE;
}


/**************************************************************************
 IsObjectDirty() - Object is dirty if the dirty flag is set or the selection
           has changed since we last cleaned or the Metafile has
           changed

***************************************************************************/
BOOL FAR PASCAL IsObjectDirty(void)
{
    // don't let anyone insert an empty mplayer into a document
    if (gwDeviceID == (UINT)0)
        return FALSE;

    return (gfDirty
           || glSelStart != (long)SendMessage(ghwndTrackbar, TBM_GETSELSTART, 0, 0L)
        || glSelEnd != (long)SendMessage(ghwndTrackbar, TBM_GETSELEND, 0, 0L)

/// I don't see this.  This line results in the Update Object dialog coming
/// up when it shouldn't.  What has it got to do with metafiles?
/// ??? || gdwPosition != (DWORD)SendMessage(ghwndTrackbar, TBM_GETPOS, 0, 0L)

        );
}

/**************************************************************************
 CleanObject() - mark the "object" clean.
***************************************************************************/

void CleanObject(void)
{
    if (!IsObjectDirty())
        return;

    fDocChanged = gfDirty = FALSE;

    /* Reset selection globals so we can see if they changed */
    glSelStart = (long)SendMessage(ghwndTrackbar, TBM_GETSELSTART, 0, 0L);
    glSelEnd = (long)SendMessage(ghwndTrackbar, TBM_GETSELEND, 0, 0L);
    gdwPosition = (DWORD)SendMessage(ghwndTrackbar, TBM_GETPOS, 0, 0L);

    gfValidCaption = FALSE;
}

/**************************************************************************
//## Just parses the play etc options in the embedded object
//## description string
***************************************************************************/
SCODE FAR PASCAL ParseOptions(LPSTR pOpt)
{
#ifdef UNICODE
    DWORD       OptLen;
#endif
    PTSTR       pT, pSave;
    int         c;

    if (pOpt == NULL || *pOpt == 0)
        return OLE_OK;

#ifdef UNICODE
    OptLen = ANSI_STRING_BYTE_COUNT( pOpt );

    pT = AllocMem( OptLen * sizeof( TCHAR ) );

    if (pT == NULL)
        return E_OUTOFMEMORY;

    MultiByteToWideChar( CP_ACP,
                         MB_PRECOMPOSED,
                         pOpt,
                         OptLen,
                         pT,
                         OptLen );
#else
    pT = pOpt;
#endif

    pSave = pT;                      // wasn't NULL terminated before

    for (c = 0; *pT && c < 5; pT++)  // change 1st 5 ','s to '\0'
    if (*pT == TEXT(','))
    {
        c++;
        *pT = TEXT('\0');
    }

    pT = pSave;                 // restore back to beginning

    pT += STRLEN(pT) + 1;      // skip over Device Name

    gwOptions = ATOI(pT);
    gwCurScale = (gwOptions & OPT_SCALE);

/* Can't set selection now because Media isn't initialized (UpdateMCI) */

    pT += STRLEN(pT) + 1;
    glSelStart = ATOL(pT);      // remember start of selection for later

    pT += STRLEN(pT) + 1;
    glSelEnd = ATOL(pT);        // remember end of selection for later

    pT += STRLEN(pT) + 1;
    // remember position in a global so we can Seek later!!
    gdwPosition = ATOL(pT);

/* Maybe there is the original height of the picture given to the client in */
/* here hidden in the Position string after a semicolon.                    */
/* Old versions of Mplayer didn't have any such thing.                      */
    for (; *pT && *pT != TEXT(';'); pT++);
    if (*pT == TEXT(';'))
    {
        pT++;
        gwPastedHeight = (UINT)ATOL(pT);
    }
    else
        gwPastedHeight = 0;

    pT += STRLEN(pT) + 1;
    StringCchCopy(gachCaption, MAX_PATH, pT);

#ifdef UNICODE
    FreeMem( pSave, OptLen * sizeof( TCHAR ) );
#endif

    return OLE_OK;
}


/**************************************************************************
//## Used to find the parent window of the window handle passed till the
//## window handle is a top level handle
***************************************************************************/
HWND TopWindow(HWND hwnd)
{
    HWND hwndP;

    while ((hwndP = GetParent(hwnd)) != NULL)
        hwnd = hwndP;

    return hwnd;
}

/**************************************************************************
***************************************************************************/
void FAR PASCAL SetEmbeddedObjectFlag(BOOL flag)
{
    TCHAR ach[60];
    TCHAR achText[_MAX_PATH];

    gfEmbeddedObject = flag;
    srvrMain.fEmbedding = flag;

    if (!ghMenu)
        return;

    /*** First fix the Close/Update menu item ***/

    LOADSTRING(flag ? IDS_UPDATE : IDS_CLOSE, ach);
    if (flag)
    StringCchPrintf(achText, _MAX_PATH, ach, (LPTSTR)FileName(szClientDoc));
    else
        lstrcpy(achText, ach);

    /* Menu option will either say "Close" or "Update" (for embedded obj) */
    /* and for update, will have the doc name in the text.                */
    ModifyMenu(ghMenu, IDM_CLOSE, MF_BYCOMMAND, IDM_CLOSE, achText);

    /*** Now fix the Exit menu item ***/
    LOADSTRING(flag ? IDS_EXITRETURN : IDS_EXIT, ach);
    if (flag)
    StringCchPrintf(achText, _MAX_PATH, ach, (LPTSTR)FileName(szClientDoc));
    else
        lstrcpy(achText, ach);

    /* Menu option will either say "Close" or "Update" (for embedded obj) */
    /* and for update, will have the doc name in the text.                */
    ModifyMenu(ghMenu, IDM_EXIT, MF_BYCOMMAND, IDM_EXIT, achText);

    DrawMenuBar(ghwndApp);  /* Can't hurt... */
}


/**************************************************************************
//## MORE STUFF FOR PLAY IN PLACE, should disappear in OLE2.
//VIJR: Nope. Still needed for playing inplace in OLE1 clients.
***************************************************************************/
void PASCAL DinkWithWindowStyles(HWND hwnd, BOOL fRestore)
{
    #define MAX_DINK    80
    static  LONG_PTR    lStyleSave[MAX_DINK];
    static  HWND        hwndSave[MAX_DINK];
    static  int         nSave;
    int                 i;
    HWND                hwndT;
    RECT                rc, rcT;

    if (!TestWS(hwnd, WS_CHILD))
        return;

    if (fRestore)
        for (i=0; i<nSave; i++)
        {
            if(IsWindow(hwndSave[i])) {
               ClrWS(hwndSave[i],WS_CLIPSIBLINGS|WS_CLIPCHILDREN);
               SetWS(hwndSave[i],lStyleSave[i] & (WS_CLIPSIBLINGS|WS_CLIPCHILDREN));
            }
        }
    else
    {
        //
        // walk all the siblings that intersect us and set CLIPSIBLINGS
        //
        i = 0;

        GetWindowRect(hwnd, &rc);

        for (hwndT = GetWindow(hwnd, GW_HWNDFIRST);
             hwndT;
             hwndT = GetWindow(hwndT, GW_HWNDNEXT))
        {
            GetWindowRect(hwndT, &rcT);
            if (IntersectRect(&rcT, &rcT, &rc))
            {
                lStyleSave[i] = GetWS(hwndT);
                hwndSave[i] = hwndT;
                SetWS(hwndT,WS_CLIPSIBLINGS|WS_CLIPCHILDREN);

                if (++i == MAX_DINK-4)
                    break;
            }
        }

        //
        // walk up the window chain, making sure we get clipped from our
        // parent(s).
        //
        for (hwndT = hwnd; hwndT; hwndT = GetParent(hwndT))
        {
            lStyleSave[i] = GetWS(hwndT);
            hwndSave[i] = hwndT;
            if(IsWindow(hwndT))
                SetWS(hwndT,WS_CLIPSIBLINGS|WS_CLIPCHILDREN);

            if (++i == MAX_DINK)
                break;
        }

        nSave = i;
    }
}

#define SLASH(c)     ((c) == TEXT('/') || (c) == TEXT('\\'))

/**************************************************************************
 FileName  - return a pointer to the filename part of szPath
             with no preceding path.
***************************************************************************/
LPTSTR FAR FileName(LPCTSTR lszPath)
{
    LPCTSTR   lszCur;

    for (lszCur = lszPath + STRLEN(lszPath); lszCur > lszPath && !SLASH(*lszCur) && *lszCur != TEXT(':');)
        lszCur = CharPrev(lszPath, lszCur);
    if (lszCur == lszPath)
        return (LPTSTR)lszCur;
    else
        return (LPTSTR)(lszCur + 1);
}


/**************************************************************************
//## This function should be handled by OLE2
//VIJR: Nope. Still needed for playing inplace in OLE1 clients.
***************************************************************************/

void FAR PASCAL PlayInPlace(HWND hwndApp, HWND hwndClient, LPRECT prc)
{
    if (gfPlayingInPlace)           // this is bad
        return;

    DPF("Using Child window for playback\n");
    SetWS(hwndApp, WS_CHILD);
    SetParent(hwndApp, hwndClient);
    if(!(gfOle2IPEditing || gfOle2IPPlaying))
        DinkWithWindowStyles(hwndApp, FALSE);

    if(!gfOle2IPEditing)
        gfPlayingInPlace = TRUE;
    if(gfOle2IPPlaying)
        MapWindowPoints(NULL,hwndClient,(LPPOINT)prc,2);

    /* For OLE2, now calls MoveWindow in DoInPlaceEdit (inplace.c).
     * This fixes 23429, window positioning in Word.
     */
    if(!(gfOle2IPEditing || gfOle2IPPlaying))
    {
        SetWindowPos(hwndApp, HWND_TOP,
                        prc->left,prc->top,
                        prc->right  - prc->left,
                        prc->bottom - prc->top,
                        SWP_NOACTIVATE);
    }

    if(!gfOle2IPPlaying)      // OLE1 Clients
    {
        /*
        ** On NT we have to install a global mouse HookProc which has to
        ** in a DLL.  Also we have to tell the DLL which process/thread we are
        ** interested in, therefore let the DLL install the HookProc.  When the
        ** HookProc detects an "interesting" mouse message it stops the
        ** device from playing.  However, the device "stopping" function is
        ** inside mplayer, so we have to export it so that the HookProc can
        ** call it.
        */
        if ( hMciOle ) {

            fpInstallHook = (LPINSTALLHOOK)GetProcAddress( hMciOle,
                                                           aszInstallHook );
            fpRemoveHook = (LPREMOVEHOOK)GetProcAddress( hMciOle,
                                                         aszRemoveHook );
        }
        else {
            fpInstallHook = NULL;
            fpRemoveHook = NULL;
        }


        // Is the key down at this INSTANT ???  Then wait until it comes up before
        // we allow GetAsyncKeyState to make us go away
        gfMouseUpSeen =   !((GetAsyncKeyState(VK_LBUTTON) & 0x8000) ||
                                    (GetAsyncKeyState(VK_RBUTTON) & 0x8000));
        // Is GetKeyState saying it's down?  If so, wait until GetKeyState returns
        // up before we let GetKeyState kill us.
        gfKeyStateUpSeen= !(GetKeyState(VK_LBUTTON) || GetKeyState(VK_RBUTTON));

#ifdef DEBUG
        if ( fHookInstalled ) {

            DPF( "Hook already installed\n" );
            //DebugBreak();
        }
#endif

        if ( fpInstallHook ) {

            DWORD wow_thread_id = 0L;

            /*
            ** This is a HACK.  If the client applications is a WOW app the
            ** HIWORD of the window handle will be 0x0000 or 0xFFFF.
            ** Chandan tells me that on Daytona the HIWORD could be
            ** either of the above.
            */
            if ( HIWORD(hwndClient) == 0x0000 || HIWORD(hwndClient) == 0xFFFF) {
                wow_thread_id = GetWindowThreadProcessId( hwndClient, NULL );
            }

            fHookInstalled = (*fpInstallHook)( ghwndApp, wow_thread_id );
        }
    }

    ghwndFocusSave = GetFocus();
}

//This function is new for OLE2. It sets the container window as
//our window's (actually the hatch window's) parent and positions the window
void FAR PASCAL EditInPlace(HWND hwndApp, HWND hwndClient, LPRECT prc)
{
    RECT rc;

    rc = *prc;

    SetWS(hwndApp, WS_CHILD);
    SetParent(hwndApp, hwndClient);

    ScreenToClient(hwndClient,(LPPOINT)&rc);
    ScreenToClient(hwndClient,(LPPOINT)&rc+1);
    if(gwDeviceType & DTMCI_CANWINDOW)
    {
       /* Sometimes the position (though not the size) of this rectangle
        * gets messed up (most reliably in PowerPoint 7).
        * I can't figure out why this is happening (see the nightmarish
        * code in ReallyDoVerb() to get a flavour of what happens).
        * But it turns out that this call is unnecessary in any case,
        * since the window has already been positioned properly in
        * IPObjSetObjectRects().
        * I suspect there's a lot of surplus window-positioning code,
        * but now isn't the time to start making major changes.
        * This is the minimal change that makes things work.
        */
		//This fixes NTRaid bug #236641 in Excel. AND bug #247393 in Word
		//Sometimes there is confusion between who the parent is. mplay32 sets the document
		//window as the parent and the rectangle sent in SetObjectRects might not be with respect to
		//the document window (this might happen when the document window is not in the maximized state).
		//In this function we know the parent and the rectangle in that parent. Setting
		//the position here places our OLE object as the client requires. This change is even safe in
		//terms of introducing regressions.
       SetWindowPos(hwndApp, HWND_TOP,
            rc.left, rc.top,
            rc.right - rc.left,
            rc.bottom - rc.top,
            SWP_NOACTIVATE | SWP_FRAMECHANGED);
    }
    else if(gwDeviceID)
        SetWindowPos(hwndApp, HWND_TOP,
            rc.left,rc.top,
            rc.right - rc.left,
            rc.bottom - rc.top,
            SWP_SHOWWINDOW);
    else
    SetWindowPos(hwndApp, HWND_TOP,
            rc.left,rc.top,
            rc.right - rc.left,
            rc.bottom - rc.top,
            SWP_HIDEWINDOW);

    ghwndFocusSave = GetFocus();

	//Set the focus for the parent.
	if((gwDeviceID == (UINT)0) && IsWindow(hwndClient))
	{
		SetFocus(hwndClient);
	}
}


/**************************************************************************
//##  This is called to end PlayInPlace and make sure that the window goes
//## away and the also to manage the palette stuff (May go away in OLE2)
//## This function should be handled by OLE2
***************************************************************************/

void FAR PASCAL EndPlayInPlace(HWND hwndApp)
{
    HWND hwndP;
    HWND hwndT;

    if (!gfPlayingInPlace || !IsWindow(hwndApp))
        return;

    /* Do this BEFORE hiding our window and BEFORE we do anything that */
    /* might yield so client can't redraw with the wrong styles set.   */
    if (!(gfOle2IPEditing || gfOle2IPPlaying))
        DinkWithWindowStyles(hwndApp, TRUE);

    gfPlayingInPlace = FALSE;

    /*
    ** Tell mciole32.dll to remove its mouse HookProc.
    */

    if ( fHookInstalled && fpRemoveHook ) {

        fHookInstalled = !(*fpRemoveHook)();
    }

    if (gfOle2IPPlaying)
        hwndP = ghwndCntr;
    else
        hwndP = GetParent(hwndApp);

    //
    //  If we have the focus, then restore it to who used to have it.
    //  ACK!! If the person who used to have it is GONE, we must give it away
    //  to somebody (who choose our parent) because our child can't
    //  keep the focus without making windows crash hard during the WM_DESTROY
    //  (or maybe later whenever it feels like crashing at some random time).
    //  See bug #8634.
    //
    if (((hwndT = GetFocus()) != NULL) && GetWindowTask(hwndT) == MGetCurrentTask) {
        if (IsWindow(ghwndFocusSave))
            SetFocus(ghwndFocusSave);
    else
        SetFocus(hwndP);
    }

    if (!hwndP ||
        (gwOptions & OPT_BAR) ||
        (gwOptions & OPT_BORDER) ||
        (gwOptions & OPT_AUTORWD))
    {

        // hide the aplication window

        SetWindowPos(hwndApp, NULL, 0, 0, 0, 0,
            SWP_NOZORDER|SWP_NOSIZE|SWP_NOMOVE|SWP_HIDEWINDOW|SWP_NOACTIVATE);
    }
    else
    {
        //
        // hide our window, but don't redraw it will look
        // like we are still on the last frame.
        //
        // this is when we are playing in place, and there is
        // no playbar, and no rewind
        //
        // this is for Playing a AVI in a PowerPoint slide
        // without redraw problems.
        //

        SetWindowPos(hwndApp, NULL, 0, 0, 0, 0,
            SWP_NOREDRAW|SWP_NOZORDER|SWP_NOSIZE|SWP_NOMOVE|
            SWP_HIDEWINDOW|SWP_NOACTIVATE);
    }

    SetParent(hwndApp, NULL);
    ClrWS(hwndApp, WS_CHILD);

    if (hwndP && gfParentWasEnabled)
        EnableWindow(hwndP, TRUE);

    //
    // set either the owner or the WS_CHILD bit so it will
    // not act up because we have the palette bit set and cause the
    // desktop to steal the palette.
    //
    SetWS(hwndApp, WS_CHILD);

}

//If we were InPlace editing restore the windows state.
void FAR PASCAL EndEditInPlace(HWND hwndApp)
{
    HWND hwndP;
    HWND hwndT;

    if (!gfOle2IPEditing || !IsWindow(hwndApp))
        return;

    /* Do this BEFORE hiding our window and BEFORE we do anything that */
    /* might yield so client can't redraw with the wrong styles set.   */
    DinkWithWindowStyles(hwndApp, TRUE);

    gfOle2IPEditing = FALSE;

    if (gfOle2IPPlaying)
    hwndP = ghwndCntr;
    else
    hwndP = GetParent(hwndApp);

    //
    //  If we have the focus, then restore it to who used to have it.
    //  ACK!! If the person who used to have it is GONE, we must give it away
    //  to somebody (who choose our parent) because our child can't
    //  keep the focus without making windows crash hard during the WM_DESTROY
    //  (or maybe later whenever it feels like crashing at some random time).
    //  See bug #8634.
    //
    if (((hwndT = GetFocus()) != NULL) && GetWindowTask(hwndT) == MGetCurrentTask) {
        if (IsWindow(ghwndFocusSave))
            SetFocus(ghwndFocusSave);
    else
        if (IsWindow(hwndP))
            SetFocus(hwndP);
    }

    if (!IsWindow(hwndP) ||
        (gwOptions & OPT_BAR) ||
        (gwOptions & OPT_BORDER) ||
    (gwOptions & OPT_AUTORWD))
    {
        // hide the aplication window
        SetWindowPos(hwndApp, NULL, 0, 0, 0, 0,
            SWP_NOZORDER|SWP_NOSIZE|SWP_NOMOVE|SWP_HIDEWINDOW|SWP_NOACTIVATE);
    }
    else
    {
        //
        // hide our window, but don't redraw it will look
        // like we are still on the last frame.
        //
        // this is when we are playing in place, and there is
        // no playbar, and no rewind
        //
        // this is for Playing a AVI in a PowerPoint slide
        // without redraw problems.
        //
        SetWindowPos(hwndApp, NULL, 0, 0, 0, 0,
            SWP_NOREDRAW|SWP_NOZORDER|SWP_NOSIZE|SWP_NOMOVE|
            SWP_HIDEWINDOW|SWP_NOACTIVATE);
    }

    SetParent(hwndApp, NULL);
    ClrWS(hwndApp, WS_CHILD);

    if (IsWindow(hwndP) && gfParentWasEnabled)
        EnableWindow(hwndP, TRUE);

    //
    // set either the owner or the WS_CHILD bit so it will
    // not act up because we have the palette bit set and cause the
    // desktop to steal the palette.
    //
    SetWS(hwndApp, WS_CHILD);

}




/* Tell the user that something's amiss with a network call.
 * For network-specific errors, call WNetGetLastError,
 * otherwise see if it's a system error.
 */
void DisplayNetError(DWORD Error)
{
    DWORD  ErrorCode;           // address of error code
    TCHAR  szDescription[512];  // address of string describing error
    TCHAR  szProviderName[64];  // address of buffer for network provider name

    if (Error == ERROR_EXTENDED_ERROR)
    {
        if (WNetGetLastError(&ErrorCode, szDescription, CHAR_COUNT(szDescription),
                             szProviderName, CHAR_COUNT(szProviderName)) == NO_ERROR)
        {
            Error1(ghwndApp, IDS_NETWORKERROR, szDescription);
            return;
        }
    }
    else
    {
        if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, Error, 0,
                          szDescription, CHAR_COUNT(szDescription), NULL) > 0)
        {
            Error1(ghwndApp, IDS_NETWORKERROR, szDescription);
            return;
        }
    }

    /* If all else fails:
     */
    Error(ghwndApp, IDS_UNKNOWNNETWORKERROR);
}



/**************************************************************************
    convert a file name to a fully qualifed path name, if the file
    exists on a net drive the UNC name is returned.
***************************************************************************/

STATICFN BOOL NetParseFile(LPTSTR szFile, LPTSTR szDrive, LPTSTR szPath)
{
    TCHAR       szTemp[MAX_PATH];
    BYTE        UNBuffer[(MAX_PATH * sizeof(TCHAR)) + sizeof(UNIVERSAL_NAME_INFO)];
    DWORD       UNBufferSize = sizeof UNBuffer;
    DWORD_PTR   Error;
    LPTSTR      pUniversalName;

    //
    // Turn into a fully qualified path name
    //
    if (!FileExists(szFile, szPath, MAX_PATH))
        return FALSE;

    //
    // if the file is not drive based (probably UNC)
    //
    if (szPath[1] != TEXT(':'))
        return TRUE;

    Error = WNetGetUniversalName(szDrive, UNIVERSAL_NAME_INFO_LEVEL,
                                 UNBuffer, &UNBufferSize);

    if (Error == ERROR_NOT_SUPPORTED)
    {
        /* This means that the network provider doesn't support
         * UNC conventions.  Give WNetGetConnection a try.
         * Note: dynalink.h assumes that WNetGetUniversalName
         * will always be called before WNetGetConnection.
         */
        UNBufferSize = CHAR_COUNT(UNBuffer);

        Error = WNetGetConnection(szDrive, (LPTSTR)UNBuffer, &UNBufferSize);

        if (Error == NO_ERROR)
        {
            /* What does the following mean?  It was in the original code.
             */
            if (!SLASH(UNBuffer[0]) || !SLASH(UNBuffer[1]))
                return TRUE;

            StringCchCat((LPTSTR)UNBuffer, UNBufferSize, szPath+2);
            StringCchCopy(szPath, MAX_PATH, (LPTSTR)UNBuffer);

            return TRUE;
        }
    }


    if (Error != NO_ERROR)
    {
        DisplayNetError((DWORD)Error);

        return FALSE;
    }

    pUniversalName = ((LPUNIVERSAL_NAME_INFO)UNBuffer)->lpUniversalName;

    StringCchCopy(szTemp, MAX_PATH, pUniversalName);
    StringCchCat(szTemp, MAX_PATH, szPath+2);
    StringCchCopy(szPath, MAX_PATH, szTemp);

    return TRUE;
}

/**************************************************************************
    Get the data that represents the currently open MCI file/device. as
    a link. MPlayer links look like this:
        MPLAYER|<filename>!<MCIDevice> [selection]
//## This is the opposite of parse options and sets the data string to be
//## embedded in the OLE object.
    Note we store the data in an ANSI string, regardless of whether we're
    compiled as a Unicode app, for Daytona/Chicago/OLE1/OLE2 compatibility.
***************************************************************************/
HANDLE GetLink( VOID )
{
    TCHAR       szFileName[MAX_PATH];
    TCHAR       szFullName[MAX_PATH];
    TCHAR       szDevice[MAX_DEVICE];
    TCHAR       szDrive[4];
    HANDLE      h;
    LPSTR       p;  /* NOT LPTSTR */
    int         len;
    int         lenAppName;
    int         lenFullName;

    StringCchCopy(szFileName, MAX_PATH, gachFileDevice);
    StringCchCopy(szFullName, MAX_PATH, gachFileDevice);

    //
    // convert the filename into a UNC file name, if it exists on the net
    //
    if (gwDeviceType & DTMCI_FILEDEV)
    {
        if (szFileName[1] == TEXT(':'))
        {
            /* This is a file name with a drive letter.
             * Find out if it's redirected:
             */
            szDrive[0] = szFileName[0];
            szDrive[1] = szFileName[1];
            szDrive[2] = TEXT('\\');    // GetDriveType requires the root.
            szDrive[3] = TEXT('\0');    // Null-terminate.

            if ((szDrive[1] == TEXT(':')) && GetDriveType(szDrive) == DRIVE_REMOTE)
            {
                szDrive[2] = TEXT('\0');    // Zap backslash.
                if (!NetParseFile(szFileName, szDrive, szFullName))
                    return NULL;
            }
        }
    }
    else if (gwDeviceType & DTMCI_SIMPLEDEV)
    {
        szFullName[0] = 0;
    }

    if (gwCurDevice == 0)
        GetDeviceNameMCI(szDevice, BYTE_COUNT(szDevice));
    else
        StringCchCopy(szDevice, MAX_DEVICE, garMciDevices[gwCurDevice].szDevice);

#ifdef UNICODE
    // length of the string in bytes != length of the string in characters
    lenAppName  = WideCharToMultiByte(CP_ACP, 0, aszAppName, -1, NULL, 0, NULL, NULL) - 1;
    lenFullName = WideCharToMultiByte(CP_ACP, 0, szFullName, -1, NULL, 0, NULL, NULL) - 1;
#else
    lenAppName  = STRLEN(aszAppName);
    lenFullName = STRLEN(szFullName);
#endif

    /* How much data will we be writing? */
#ifdef UNICODE
    // length of the string in bytes != length of the string in characters
    len = 9 +                    // all the delimeters
          lenAppName +
          lenFullName +
          WideCharToMultiByte(CP_ACP, 0, szDevice, -1, NULL, 0, NULL, NULL)-1 +
          5 + 10 + 10 + 10 +     // max length of int and long strings
          WideCharToMultiByte(CP_ACP, 0, gachCaption, -1, NULL, 0, NULL, NULL)-1;
#else
    len = 9 +                    // all the delimeters
          lenAppName +
          lenFullName +
          STRLEN(szDevice) +
          5 + 10 + 10 + 10 +     // max length of int and long strings
          STRLEN(gachCaption);
#endif

    h = GlobalAlloc(GMEM_DDESHARE|GMEM_ZEROINIT, len * sizeof(CHAR));
    if (!h)
        return NULL;
    p = GLOBALLOCK(h);

    /* This string must have two terminating null characters.
     * The GlobalAlloc GMEM_ZEROINIT flag should ensure this.
     */
#ifdef UNICODE
    wsprintfA(p, "%ws%c%ws%c%ws%c%d%c%d%c%d%c%d%c%d%c%ws",
#else
    wsprintfA(p, "%s%c%s%c%s%c%d%c%d%c%d%c%d%c%d%c%s",
#endif
        aszAppName,
        '*',          // placeholder
        szFullName,
        '*',          // placeholder
        szDevice, ',',
        (gwOptions & ~OPT_SCALE) | gwCurScale, ',',
        (long)SendMessage(ghwndTrackbar, TBM_GETSELSTART, 0, 0L), ',',
        (long)SendMessage(ghwndTrackbar, TBM_GETSELEND, 0, 0L), ',',
        (long)SendMessage(ghwndTrackbar, TBM_GETPOS, 0, 0L), ';',
        // new parameter snuck in since initial version
        // Height of picture we're giving the client - w/o caption
        grcSize.bottom - grcSize.top, ',',
        gachCaption);

    /* Replace *'s with NULL characters  (wsprintf doesn't accept
     * 0 as a replacement parameter for %c):
     */
    p[lenAppName] = '\0';
    p[lenAppName + 1 + lenFullName] = '\0';

    DPF("Native data %hs has been created\n", p);

    GLOBALUNLOCK(h);

    return h;
}



/****************************************************************************
 DOS share has a bug.  If the file we're testing for existence is open
 already by someone else, we have to give it the same flag for SHARE as
 the other person is using.  So we have to try both on and off.  Only one
 of these will return TRUE but if one of them does, the file exists.  Also
 we have to try with SHARE first, because the test without share might
 give a system modal error box!!!
//## Check to see if DOS 7 has this bug or is it fixed

 Parameter iLen is the number of characters in the szFullName buffer
****************************************************************************/
STATICFN BOOL FileExists(LPTSTR szFile, LPTSTR szFullName, int iLen)
{
    DWORD  rc;
    LPTSTR pFilePart;

    rc = SearchPath(NULL,       /* Default path search order */
                    szFile,
                    NULL,       /* szFile includes extension */
                    (DWORD)iLen,
                    szFullName,
                    &pFilePart);

    if(rc > (DWORD)iLen)
    {
        DPF0("Buffer passed to FileExists is of insufficient length\n");
    }

    return (BOOL)rc;
}

/****************************************************************************
 FindRealFileName - If szFile isn't valid, try searching
                    client directory for it, or anywhere on
                    the path, or bringing up a locate dlg.
                    Set szFile to the valid path name.
//## This function is used to repair broken links

 Parameter iLen is the number of characters in the szFile buffer
****************************************************************************/
BOOL FindRealFileName(LPTSTR szFile, int iLen)
{
    TCHAR           achFile[_MAX_PATH + 1];  /* file or device name buffer  */
    int             iFileSize = _MAX_PATH + 1; 

    /* This isn't a file device, so don't do anything */
    if (!szFile || *szFile == 0)
        return TRUE;

    /* The file name we've been given is valid, so do nothing. */
    //!!! what about share
    if (FileExists(szFile, achFile, iLen))
    {
        StringCchCopy(szFile, iLen, achFile);
        return TRUE;
    }

    DPF("FindRealFileName: Can't find file '%"DTS"'\n", szFile);

    DPF("FindRealFileName: ...Looking on the $PATH\n");

    /* Look for the file anywhere */
    StringCchCopy(achFile, iFileSize, FileName(szFile));
    if (FileExists(achFile, szFile, iLen))
        return TRUE;

    return FALSE;
}

/**************************************************************************
*   SubClassedMCIWndProc:
*   This the WndProc function used to sub-class the Play Back window.
*   This function is used to trap the drag-drops and also
*   to route the WM_CLOSE to the IDM_CLOSE of Mplayer.
**************************************************************************/
LONG_PTR FAR PASCAL SubClassedMCIWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    static BOOL fDragCapture = FALSE;
    static RECT rcWin;
    POINT       pt;
    LONG_PTR    lRc;

    switch(wMsg)
    {
    case WM_LBUTTONDOWN:
//        break; // Disable drag from MPlayer!  It's broken.
        if (!gfOle2IPEditing)
        {
            fDragCapture = TRUE;
            SetCapture(hwnd);
            GetClientRect(hwnd, (LPRECT)&rcWin);
            MapWindowPoints(hwnd, NULL, (LPPOINT)&rcWin, 2);
        }
        break;

    case WM_LBUTTONUP:
        if (!fDragCapture)
            break;

        fDragCapture = FALSE;
        ReleaseCapture();
        break;

    case WM_MOUSEMOVE:
        if (!fDragCapture)
            break;

        LONG2POINT(lParam, pt);
        MapWindowPoints(hwnd, NULL, &pt, 1);

        if (!PtInRect((LPRECT)&rcWin, pt))
        {
            ReleaseCapture();
            DoDrag();
            fDragCapture = FALSE;
        }

        SetCursor(LoadCursor(ghInst,MAKEINTRESOURCE(IDC_DRAG)));

        break;

    case WM_CLOSE:
        if (gfSeenPBCloseMsg || gfOle2IPEditing || gfOle2IPPlaying) {
            lRc = CallWindowProc(gfnMCIWndProc, hwnd, wMsg, wParam, lParam);
        } else {
            gfSeenPBCloseMsg = TRUE;
            PostMessage(ghwndApp,WM_COMMAND,IDM_CLOSE,0L);
            lRc = 0L;
        }
        CleanUpDrag();

        return lRc;

    case WM_DESTROY:
        ghwndSubclass = NULL;
        CleanUpDrag();
        break;

    case WM_ACTIVATE:
        /* Get the app's main window somewhere it can be seen
         * if the MCI window gets activated:
         */
        if (((WORD)wParam != 0) && !IsIconic(ghwndApp))
        {
            SetWindowPos(ghwndApp, hwnd, 0, 0, 0, 0,
                         SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
        }
        break;
    }

    return CallWindowProc(gfnMCIWndProc, hwnd, wMsg, wParam, lParam);
}

/**************************************************************************
*   SubClassMCIWindow:
*   This function sub-classes the Play Back window by hooking in
*   SubClassedMCIWndProc function.
**************************************************************************/
void SubClassMCIWindow(void)
{

    HWND hwndMCI;

    hwndMCI = GetWindowMCI();
    if(!IsWindow(hwndMCI))
        return;
    if (gfnMCIWndProc != NULL && IsWindow(ghwndSubclass)) {
        SetWindowLongPtr(ghwndSubclass, GWLP_WNDPROC, (LONG_PTR)gfnMCIWndProc);
    }
    gfnMCIWndProc = (WNDPROC)GetWindowLongPtr(hwndMCI, GWLP_WNDPROC);
    if (hwndMCI)
        SetWindowLongPtr(hwndMCI, GWLP_WNDPROC, (LONG_PTR)SubClassedMCIWndProc);
    ghwndSubclass = hwndMCI;
    gfSeenPBCloseMsg = FALSE;

#ifdef CHICAGO_PRODUCT
    SendMessage(hwndMCI, WM_SETICON, FALSE,
                (LPARAM)GetIconForCurrentDevice(GI_SMALL, IDI_DDEFAULT));
    SetWindowText(hwndMCI, gachCaption);
#endif
}


INT_PTR FAR PASCAL FixLinkDialog(LPTSTR szFile, LPTSTR szDevice, int iLen);

/* ANSI-to-Unicode version of lstrcpyn:
 *
 * Zero terminates the buffer in case it isn't long enough,
 * then maps as many characters as will fit into the Unicode buffer.
 *
 */
#define LSTRCPYNA2W(strW, strA, buflen)    \
    strW[buflen-1] = L'\0',                                             \
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,                        \
                         (strA), min( strlen( strA )+1, (buflen)-1 ),   \
                         (strW), ((buflen)-1) )


/**************************************************************************
* ItemSetData(LPBYTE p): This function is left over from OLE1 days, but is
* very important because the embedded data is still the same. This function
* parses the embedded data and opens the appropriate device/file and sets
* everything in motion. "p" is the pointer memory block having the embedded
* data.
* Note we store the data in an ANSI string, regardless of whether we're
* compiled as a Unicode app, for Daytona/Chicago/OLE1/OLE2 compatibility.
**************************************************************************/
SCODE ItemSetData(LPBYTE p)
{
    LPSTR pSave, pT;
    LPSTR szFile, szDevice;
    CHAR  ach[40];
    TCHAR achFile[_MAX_PATH];
    TCHAR achCaption[_MAX_PATH];
    LPTSTR pDevice = NULL;
    SCODE scode = E_FAIL;
    int iCnt = 0;

    if (p && *p != 0)
    {
        szFile   = p + strlen(p) + 1;      // pick off the Filename
        p = szFile + strlen(szFile) + 1;
        pSave = p;
        szDevice = ach;									// copy over Device name and
        for (pT = ach; *p && *p != ',' && iCnt < 39;)	// NULL terminate it (it ends
        {												// with a ',' right now).
            iCnt++;
            *pT++ = *p++;
        }
        *pT = '\0';


        /* It is OK for szFile and szDevice to be empty, since we may have
         * a Media Clip object with no device or file selected
         */
        DPF("%hs|%hs!%hs\n", p, szFile, szDevice);


        CloseMCI(TRUE);         // nuke old gachCaption
        scode = ParseOptions(pSave);   // this will set new gachCaption

        if (scode != S_OK)
            return scode;

            // If this file doesn't exist, we won't continue setting data, we
            // will succeed and get out, and do it later, because we can't
            // bring up a dialog right now because clients like WinWord
            // won't dispatch any msgs.

#ifdef UNICODE
        LSTRCPYNA2W(achFile, szFile, CHAR_COUNT(achFile));
#else
        lstrcpyn(achFile, szFile, CHAR_COUNT(achFile));
#endif

        // Check for  file existence. if the filename we were given is bad,
        // try and find it somewhere on the disk

#ifdef UNICODE
        pDevice = AllocateUnicodeString(szDevice);
        if (!pDevice)
            return E_OUTOFMEMORY;
#else
        pDevice = szDevice;
#endif

        if (FindRealFileName(achFile, CHAR_COUNT(achFile)))
        {
            lstrcpy(achCaption, gachCaption);  //Save caption.

            if (OpenMciDevice(achFile, pDevice))
            {
                /* Set the selection to what we parsed in ParseOptions. */
                SendMessage(ghwndTrackbar, TBM_SETSELSTART, 0, glSelStart);
                SendMessage(ghwndTrackbar, TBM_SETSELEND, 0, glSelEnd);
            }
            lstrcpy(gachCaption, achCaption);   //Restore Caption
        }
        else if (FixLinkDialog(achFile, pDevice, sizeof(achFile)) )
        {
            if (OpenMciDevice(achFile, pDevice))
            {
                /* Set the selection to what we parsed in ParseOptions. */
                SendMessage(ghwndTrackbar, TBM_SETSELSTART, 0, glSelStart);
                SendMessage(ghwndTrackbar, TBM_SETSELEND, 0, glSelEnd);
                gfBrokenLink = TRUE;
            }
        }
        else
            scode = E_FAIL;
    }
#ifdef UNICODE
    FreeUnicodeString(pDevice);
#endif

    return scode;
}


/**************************************************************************
* UpdateObject() - handle the update of the object
* If the object has changed in content or appearance a message is
* sent to the container.
***************************************************************************/

void UpdateObject(void)
{
    LONG lPos;

    if((gfOle2IPPlaying || gfPlayingInPlace) && !fDocChanged)
        return;

    if (IsWindow(ghwndTrackbar))
        lPos = (LONG)SendMessage(ghwndTrackbar, TBM_GETPOS, 0, 0L);
    else
        lPos = -1;


    if (gfEmbeddedObject &&
        (fDocChanged || ((lPos >= 0) && (lPos != (LONG)gdwPosition)
         && (gwDeviceType & DTMCI_CANWINDOW))))
    {
        //
        //  Some clients (e.g. Excel 3.00 and PowerPoint 1.0) don't
        //  handle saved notifications; they expect to get an
        //  OLE_CLOSED message.
        //
        //  We will send an OLE_CLOSED message right before we
        //  revoke the DOC iff gfDirty == -1 (see FileNew()).
        //
        if ((lPos >= 0) && (lPos != (LONG)gdwPosition) && (gwDeviceType & DTMCI_CANWINDOW))
        {
            gdwPosition = (DWORD)lPos;
            SendDocMsg((LPDOC)&docMain,OLE_CHANGED);
        }

        if (fDocChanged)
            SendDocMsg(&docMain, OLE_SAVEOBJ);
    }
}



/**************************************************************************
* int FAR PASCAL ReallyDoVerb: This is the main function in the server stuff.
* This function used to implement the PlayInPlace in OLE1. Most of the code
* has not been changed and has been used to munge the MPlayer for EditInPlace
* in OLE2. For OLE2 this function calls DoInPlaceEdit to get the containers
* hwnd and Object rectangle. For OLE1 clients the rectangle is still got
* from the OleQueryObjPos funtion in mciole.dll. A new twist in the PlayVerb
* is that if we are just hidden in a deactivated state we just reappear
* and play instead of PlayingInPlace without the toolbars etc. This function
* is also called when reactivating, deactivating etc. The BOOL SkipInPlaceEdit
* is used to avoid redoing all the stuff if we are just reactivating.
***************************************************************************/
int FAR PASCAL  ReallyDoVerb (
LPDOC   lpobj,
LONG        verb,
LPMSG       lpmsg,
LPOLECLIENTSITE lpActiveSite,
BOOL         fShow,
BOOL         fActivate)
{
    BOOL    fWindowWasVisible = IsWindowVisible(ghwndApp);

    int     dx,dy;
    HWND    hwndClient;
    HWND    hwndT;
    RECT    rcSave;
    RECT    rcClient;
    RECT    rc;
    LONG    err;
    SCODE   sc;
    HPALETTE hpal;
    HDC     hdc;
    INT     xTextExt;
    int     yOrig, yNow, xOrig, ytitleNow, xtitleOrig, xNow;
    int     xIndent = 0; // Avoid warning C4701: local variable 'xIndent'
                         // may be used without having been initialized
    int     wWinNow;
    HWND    hwndMCI;

    int     Result = S_OK;

    DPFI("VERB = %d\n", verb);

    /* MSProject assumes that our primary verb is Edit; in fact it's Play.
     * So when we're called with the default verb, make sure we've loaded
     * something from storage and, if not, do the Edit thing.
     *
     * Nope, that doesn't work, because if you insert an object, deactivate
     * it and then play it, PSLoad hasn't been called.  A better bet is
     * to check whether we have a current device.
     */
    if (gfRunWithEmbeddingFlag && gwDeviceType == 0)
    {
        if (verb == OLEIVERB_PRIMARY)
        {
            DPF("Primary Verb called without current device -- changing verb to Edit...\n");
            verb = verbEdit;
        }
    }

    /* If a Media Clip is currently open, the user can give the focus back
     * to the container and issue another verb or double-click the object.
     * If this happens, set the focus back to the open object.
     *
     * We don't need to worry about resetting fObjectOpen, since the server
     * shuts down when the user exits and returns to the container.
     */
    if (gfOle2Open)
    {
        SetFocus(ghwndApp);
        return S_OK;
    }


    // This is the first verb we are seeing. So the container must
    // have the focus. Save it so that we can return it later.
    if (glCurrentVerb == NOVERB)
        ghwndFocusSave = GetFocus();
    if (verb == OLEIVERB_PRIMARY && !gfOle2IPEditing && (glCurrentVerb != verbEdit))
    {
        EnableMenuItem((HMENU)GetMenu(ghwndApp), IDM_CLOSE,   MF_GRAYED);
    }

    glCurrentVerb = verb;

    //
    // dont even try to nest things.
    //
    if (gfPlayingInPlace && verb != OLEIVERB_HIDE)
        return OLE_OK;

    if (gfBrokenLink)
    {
        PostMessage(ghwndApp, WM_SEND_OLE_CHANGE, 0, 0L);
        gfBrokenLink = FALSE;
    }

    //We are just reactivating. Don't do through all the steps again.
    if (gfOle2IPEditing)
        SkipInPlaceEdit = TRUE;

    // Make sure the timer's doing the right thing:
    gfAppActive = ( verb != OLEIVERB_HIDE );

    // NTVDM can get into a spin if we have too meany TIMER messages,
    // so make sure we don't have any if there's no device.
    if (gwDeviceID)
        EnableTimer( gfAppActive );
    else
        EnableTimer( FALSE );

    if (verb == OLEIVERB_PRIMARY)
    {
        gfOle1Client = FALSE;

        //We are already up but deactivated. Just come up and play.
        if (gfOle2IPEditing)
        {
            if (!(gwDeviceType & DTMCI_CANWINDOW))
            {
                Result = ReallyDoVerb(lpobj, verbEdit, lpmsg, lpActiveSite, fShow, fActivate);
                PostMessage(ghwndApp, WM_COMMAND, ID_PLAYSEL, 0); // play selection
            }
            else
            {
                ClrWS(ghwndApp, WS_THICKFRAME|WS_CAPTION|WS_SYSMENU|WS_MINIMIZEBOX|WS_MAXIMIZEBOX|WS_BORDER);

                err = GetScode(DoInPlaceEdit(lpobj, lpmsg, lpActiveSite, verbEdit, &hwndClient,
                          &rcClient));
                if (err)
                {
                    SHOWAPPWINDOW(SW_HIDE);
                    PostMessage(ghwndApp,WM_CLOSE,0,0);
                    return((int)err);
                }

                gfInPlaceResize = TRUE;
                rcClient = gInPlacePosRect;
                MapWindowPoints(NULL,ghwndCntr,(LPPOINT)&rcClient,2);

                DPF("IOleInPlaceSite::OnPosRectChange %d, %d, %d, %d\n", rcClient);
                if (!gfInPPViewer)
                    IOleInPlaceSite_OnPosRectChange(docMain.lpIpData->lpSite, &rcClient);

                toolbarSetFocus(ghwndToolbar, BTN_PLAY);
                SetFocus(ghwndToolbar);
                PostMessage(ghwndApp, WM_COMMAND, ID_PLAYSEL, 0); // play selection
            }
        }

        else
        {
            if(gwDeviceID == (UINT)0)       //Play without a device !?!!!
            {
                PostMessage(ghwndApp, WM_CLOSE, 0, 0L);
                sc = E_FAIL;
                return (int)sc;
            }

            // if the device can't window and the user does not want a playbar
            // dont play in place - just start the media and run invisible.
            //
            if (!(gwDeviceType & DTMCI_CANWINDOW) && !(gwOptions & OPT_BAR))
                gwOptions &= ~OPT_PLAY;


            //  Select the palette in right now on behalf of the active
            //  window, so USER will think it is palette aware.
            //
            //  any palette will do we dont even have to realize it!!
            //
            if (((hpal = PaletteMCI()) != NULL) && ((hwndT = GetActiveWindow()) != NULL))
            {
                hdc = GetDC(hwndT);
                hpal = SelectPalette(hdc, hpal, FALSE);
                        SelectPalette(hdc, hpal, FALSE);
                        ReleaseDC(hwndT, hdc);
            }

            if (ghwndClient)
            {
                hwndClient = ghwndClient;
                err = gerr;
                rcClient = grcClient;
                ghwndClient = NULL;
            }

            else
            {
                err = GetScode(DoInPlaceEdit(lpobj, lpmsg, lpActiveSite, verb, &hwndClient,
                                             &rcClient));

                if (err != S_OK)
                {
                    err = OleQueryObjPos(lpobj, &hwndClient, &rcClient, NULL);

                    if (err == S_OK)
                    {
                        gfOle1Client = TRUE;
                        ghwndCntr = hwndClient;
                    }
                }
                else
                {
                    if (gwOptions & OPT_TITLE)
                    gwOptions |= OPT_BAR;
                    else
                    gwOptions &= ~OPT_BAR;
                }
            }


            /* We want to play in place and we can.              */
            /* If we're a link, not an embedded object, and there was an instance*/
            /* of MPlayer up when we said "Play" that was already editing this  */
            /* file, we don't want to play in place... we'll just play in that  */
            /* instance.    We can tell this by the fact that our main MPlayer     */
            /* window is already visible.                        */

            if ((err == S_OK)
             && (!gfOle1Client
              || (gwOptions & OPT_PLAY))    /* Ignore Play in client doc for OLE2 clients */
             && (gfOle2IPPlaying
              || (IsWindow(hwndClient)
               && IsWindowVisible(hwndClient)
               && !fWindowWasVisible)))
            {
                rc = grcSize;    // default playback window size for this movie

                /* If we can't window, or something's wrong, use ICON size */
                if (IsRectEmpty(&rc))
                SetRect(&rc, 0, 0, GetSystemMetrics(SM_CXICON),
                GetSystemMetrics(SM_CYICON));

                /* rcSave is the area for the MCI window above the control bar */
                /* (if we have one).                                           */
                /* rcClient is the area of the MCI window (0 based) to play in.*/
                /* Control bar may be longer than picture, so rcClient may be  */
                /* smaller than rcSave.                                        */
                rcSave = rcClient;    // remember stretched size

                /* Make rcClient 0 based from rcSave */
                rcClient.left = 0;
                rcClient.right = rcSave.right - rcSave.left;
                rcClient.top = 0;
                rcClient.bottom = rcSave.bottom - rcSave.top;

                /* Assume playbar will be regular height for now */

                if (gwOptions & OPT_BAR)
                    gwPlaybarHeight = TOOLBAR_HEIGHT;
                else
                    gwPlaybarHeight = 0;

                //
                // munge rectangle to account for a title in the picture
                // and the fact that picture is centred above title.
                // Remember, it's been stretched around.
                //
                if (gwOptions & OPT_TITLE)
                {
                    SIZE Size;

                    hdc = GetDC(NULL);

                    if (ghfontMap)
                        SelectObject(hdc, ghfontMap);

                    GetTextExtentPoint32(hdc, gachCaption,
                                         STRLEN(gachCaption), &Size);
                    xTextExt = Size.cx;

                    ReleaseDC(NULL, hdc);

                    yOrig = rc.bottom - rc.top;
                    xOrig = rc.right - rc.left;
                    xtitleOrig = max(xTextExt + 4, xOrig);
                    yNow    = rcClient.bottom - rcClient.top;
                    xNow    = rcClient.right - rcClient.left;
                    ytitleNow = (int)((long)yNow - ((long)yOrig * yNow)
                                / (yOrig + TITLE_HEIGHT));
                    /* for windowed devices, center the playback area above the */
                    /* control bar if the control bar is longer.            */
                    if (gwDeviceType & DTMCI_CANWINDOW)
                    {
                                wWinNow =(int)((long)xOrig * (long)xNow / (long)xtitleOrig);
                                xIndent = (xNow - wWinNow) / 2;
                                rcClient.left += xIndent;
                                rcClient.right = rcClient.left + wWinNow;
                    }

                    // Align top of control bar with the top of the title bar.
                    // The control bar (if there) will appear under rcSave.
                    rcClient.bottom = rcClient.top + yNow - ytitleNow;
                    rcSave.bottom = rcSave.top + yNow - ytitleNow;

                    /* When we make the playbar, make it cover the title */
                            /* if the caption was stretched taller than ordinary.*/
                    if (gwOptions & OPT_BAR)
                        gwPlaybarHeight = max(ytitleNow, TOOLBAR_HEIGHT);
                }

                /* Enforce a minimum width for the control bar */
                if ((gwOptions & OPT_BAR) &&
                    (rcSave.right - rcSave.left < 3 * GetSystemMetrics(SM_CXICON)))
                {
                    rcSave.right = rcSave.left + 3 * GetSystemMetrics(SM_CXICON);
                    if (gwDeviceType & DTMCI_CANWINDOW)
                        xIndent = TRUE; // force SetWindowMCI to be called to
                                        // avoid stretching to this new size.
                }

                if (gwDeviceType & DTMCI_CANWINDOW)
                {
                    //  THIS CODE IS USED TO AVOID SLOW PLAYBACK
                    //  If we've only stretched a bit, don't stretch at all.
                    //  We might be off a bit due to rounding problems.
                    //
                    dx = (rcClient.right - rcClient.left) - (rc.right - rc.left);
                    dy = (rcClient.bottom - rcClient.top) - (rc.bottom - rc.top);

                    if (dx && abs(dx) <= 2)
                    {
                        rcClient.right = rcClient.left + (rc.right - rc.left);
                        // Fix Save rect too
                        rcSave.right = rcSave.left + (rc.right - rc.left);
                    }

                    if (dy && abs(dy) <= 2)
                    {
                        rcClient.bottom = rcClient.top + (rc.bottom - rc.top);
                        // Fix Save rect, too.
                        rcSave.bottom = rcSave.top + (rc.bottom - rc.top);
                    }
                    //
                    // Try to get the right palette from the client.  If our
                    // presentation data was dithered, or the user asked us to
                    // always use the object palette, then ignore any client
                    // palette.
                    //
#ifdef DEBUG
                    if (GetProfileInt(TEXT("options"), TEXT("UseClientPalette"),
                                      !(gwOptions & OPT_USEPALETTE)))
                        gwOptions &= ~OPT_USEPALETTE;
                    else
                        gwOptions |= OPT_USEPALETTE;
#endif
                    if (!(gwOptions & OPT_USEPALETTE)&& !(gwOptions & OPT_DITHER))
                    {
                        //
                        // Try to get a OWNDC Palette of the client.  PowerPoint
                        // uses a PC_RESERVED palette in "SlideShow" mode, so
                        // we must use its exact palette.
                        //
                        hdc = GetDC(ghwndCntr);
                        hpal = SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), FALSE);
                        SelectPalette(hdc, hpal, FALSE);
                        ReleaseDC(ghwndCntr, hdc);

                        if (hpal == NULL || hpal==GetStockObject(DEFAULT_PALETTE))
                        {
                            /* Assume client realized the proper palette for us */

                            if (ghpalApp)
                                DeleteObject(ghpalApp);

                            hpal = ghpalApp = CreateSystemPalette();
                        }
                        else
                            DPF("Using clients OWNDC palette\n");

                        if (hpal)
                            SetPaletteMCI(hpal);
                    }
                    else
                        DPF("Using MCI Object's normal palette\n");
                }

                else
                {
                    //
                    // for non window devices, just have the playbar show up!
                    // so use a zero height MCI Window area.
                    //
                    rcSave.top = rcSave.bottom;
                }

                //
                // if we are not in small mode, get there now
                //
                if (!gfPlayOnly)
                {
                    SHOWAPPWINDOW(SW_HIDE);
                    gfPlayOnly = TRUE;
                    SizeMPlayer();
                }

                ClrWS(ghwndApp, WS_THICKFRAME|WS_CAPTION|WS_SYSMENU|WS_MINIMIZEBOX|WS_MAXIMIZEBOX|WS_BORDER);

                if (gwOptions & OPT_BORDER)
                    SetWS(ghwndApp, WS_BORDER);

                /* Set the size of Mplayer to have enough space for the MCI */
                /* playback area and a playbar and the non-client area.     */

                rcSave.bottom += gwPlaybarHeight;

                AdjustWindowRect(&rcSave, (DWORD)GetWS(ghwndApp), FALSE);

                if (!(gwDeviceType & DTMCI_CANWINDOW))
                {
                    rcSave.left += 2*GetSystemMetrics(SM_CXBORDER);
                    rcSave.right -= 2*GetSystemMetrics(SM_CXBORDER);
                }

                PlayInPlace(ghwndApp, hwndClient, &rcSave);

                if (!gfOle2IPEditing)
                    gfCloseAfterPlaying = TRUE;

                fShow = FALSE;
                fActivate = FALSE;

                /* become visible */
                SHOWAPPWINDOW(SW_SHOW);

                /* Remember to play the video in the rcClient area of rcSave */
                if ((gwDeviceType & DTMCI_CANWINDOW) &&
                    (gwOptions & OPT_TITLE) && xIndent != 0)
                    SetDestRectMCI(&rcClient);

                /* Let keyboard interface work on control bar, and let the  */
                /* accelerators go through.                                 */
                toolbarSetFocus(ghwndToolbar, BTN_PLAY);
                SetFocus(ghwndToolbar);

                /* We won't play in place - use a popup window or nothing. */
            }
            else
            {
                /* If we want a playbar, then use MPlayer reduced mode to play. */
                /* If we don't want one, then don't show mplayer's window -     */
                /* we'll just use the default MCI window (for a windowed device)*/
                /* or nothing for a non-windowed device.  If we stole an already*/
                /* running instance of mplayer, we must use it and not run      */
                /* silently.                                                    */

                DPF("DoVerb: Not is play in place stuff ");
                if ((gwOptions & OPT_BAR) || fWindowWasVisible)
                {
                    DPF("Using Toplevel window for playback\n");

                    /* go to our little miniature version */
                    if (!gfPlayOnly && !fWindowWasVisible)
                    {
                        gwPlaybarHeight = TOOLBAR_HEIGHT;
                        gfPlayOnly = TRUE;
                        SizeMPlayer();
                    }

                    fShow = fActivate = TRUE;
                    gfCloseAfterPlaying = !fWindowWasVisible;

                }
                else
                {
                            DPF("Running silently\n");

                    if (!fWindowWasVisible)
                                SetWindowMCI(NULL);
                    // make sure we're using default MCI win

                    fShow = fActivate = FALSE;
                    // DIE when you are done playing
                    gfCloseAfterPlaying = TRUE; // we're invisible, so close auto.
                }
            }

            Yield();    // If play goes to full screen mode, PowerPig will
            Yield();    // time out and put up errors thinking we didn't play.
            PostMessage(ghwndApp, WM_COMMAND, ID_PLAYSEL, 0); // play selection
        }
    }
    else if (verb == verbEdit ||
             verb == verbOpen ||
             verb == OLEIVERB_OPEN ||
             verb == OLEIVERB_SHOW ||
             verb == OLEIVERB_INPLACEACTIVATE ||
             verb == OLEIVERB_UIACTIVATE)
    {
        gfOle1Client = FALSE;
#ifdef DEBUG
        switch(verb)
        {
        case verbEdit: DPFI("VERBEDIT\r\n");break;
        case OLEIVERB_SHOW: DPFI("OLEIVERB_SHOW\r\n");break;
        case OLEIVERB_INPLACEACTIVATE: DPFI("OLEIVERB_IPACTIVATE\r\n");break;
        case OLEIVERB_UIACTIVATE: DPFI("OLEIVERB_UIACTIVATE\r\n");break;
        }
#endif
        // If we are already playing inside an Icon, then restore..
        hwndMCI = GetWindowMCI();
        if (IsWindow(hwndMCI) && IsIconic(hwndMCI))
            SendMessage(hwndMCI, WM_SYSCOMMAND, SC_RESTORE, 0L);

        // If we come up empty, it's OK to be in OPEN or NOT_READY mode
        // and don't try to seek anywhere.
        if (gwDeviceID)
        {
            switch (gwStatus)
            {
            case MCI_MODE_OPEN:
            case MCI_MODE_NOT_READY:
                Error(ghwndApp, IDS_CANTPLAY);
                break;

            default:
                // Seek to the position we were when we copied.
                // Stop first.
                if (StopMCI())
                {
                    // fix state so Seek recognizes we're stopped
                    gwStatus = MCI_MODE_STOP;
                    SeekMCI(gdwPosition);
                }

                break;
            }
        }

        // Let UpdateDisplay set focus properly by saying we're invalid
        // FORCES UPDATE
        gwStatus = (UINT)(-1);
        if (((hpal = PaletteMCI()) != NULL) && ((hwndT = GetActiveWindow()) != NULL))
        {
             hdc = GetDC(hwndT);
             hpal = SelectPalette(hdc, hpal, FALSE);
             SelectPalette(hdc, hpal, FALSE);
             ReleaseDC(hwndT, hdc);
        }

        if (verb == verbOpen || verb == OLEIVERB_OPEN)
        {
            DoInPlaceDeactivate(lpobj);
            gfOle2IPEditing = FALSE;
            gfPlayOnly = FALSE;
            SetWindowPos(ghwndApp, NULL, 0, 0, 0, 0,
                SWP_NOZORDER|SWP_NOSIZE|SWP_NOMOVE|SWP_HIDEWINDOW|SWP_NOACTIVATE);
            SetParent(ghwndApp, NULL);
            PutWS(ghwndApp, WS_THICKFRAME | WS_OVERLAPPED | WS_CAPTION |
                            WS_CLIPCHILDREN | WS_SYSMENU | WS_MINIMIZEBOX);
            TransferTools(ghwndApp);

            if (lpobj->lpoleclient) /* This is NULL if it's the first verb issued to a link */
                IOleClientSite_OnShowWindow(lpobj->lpoleclient, TRUE);
            SendMessage(ghwndTrackbar, TBM_SHOWTICS, TRUE, FALSE);
            gfOle2Open = TRUE;  /* This global is referenced in SizeMPlayer */
            SizeMPlayer();
            SHOWAPPWINDOW(SW_SHOW);
        }
        else if((err = GetScode(DoInPlaceEdit(lpobj, lpmsg, lpActiveSite, verb, &hwndClient,
                    &rcClient))) !=S_OK)
        {
            err = OleQueryObjPos(lpobj, &hwndClient, &rcClient, NULL);
            if (err == S_OK)
            {
                gfOle1Client = TRUE;
            }

            gfOle2IPEditing = FALSE;

            if (gfPlayOnly)
            {
                gfPlayOnly = FALSE;
                SizeMPlayer();
            }
        }
        else
        {
            if (gwOptions & OPT_TITLE)
                gwOptions |= OPT_BAR;
            else
                gwOptions &= ~OPT_BAR;
        }

        if (gfOle2IPEditing && SkipInPlaceEdit)
        {
            gfInPlaceResize = TRUE;
            if(!(gwDeviceType & DTMCI_CANWINDOW) && (gwOptions & OPT_BAR))
            {
                yNow  = rcClient.bottom - rcClient.top;

                if (gwOldHeight)
                {
                    ytitleNow = (int)((long)yNow * gwPlaybarHeight/gwOldHeight);
                    gwPlaybarHeight = max(ytitleNow, TOOLBAR_HEIGHT);
                    gwOldHeight = yNow;
                    rcClient.top = rcClient.bottom - gwPlaybarHeight;
                }
                else
                {
                    gwPlaybarHeight = TOOLBAR_HEIGHT;
                    rcClient.top = rcClient.bottom - gwPlaybarHeight;
                    ytitleNow = rcClient.bottom - rcClient.top;
                    gwOldHeight = yNow;
                }
            }
            if(!(gwDeviceType & DTMCI_CANWINDOW) && !(gwOptions & OPT_BAR))
                rcClient.bottom = rcClient.top = rcClient.left = rcClient.right = 0;

            EditInPlace(ghwndApp, hwndClient, &rcClient);
            Layout();
        }

        else
        if (gfOle2IPEditing && gwDeviceID == (UINT)0 && IsWindow(ghwndFrame))
            EditInPlace(ghwndApp, hwndClient, &rcClient);

        if(gfOle2IPEditing && gwDeviceID != (UINT)0 && !SkipInPlaceEdit)
        {
            gwOldOptions = gwOptions;
            rc = grcSize;   // default playback window size for this movie

            /* If we can't window, or something's wrong, use ICON size */
            if (IsRectEmpty(&rc))
                SetRect(&rc, 0, 0, GetSystemMetrics(SM_CXICON),
            GetSystemMetrics(SM_CYICON));

            /* rcSave is the area for the MCI window above the control bar */
            /* (if we have one).                                           */
            /* rcClient is the area of the MCI window (0 based) to play in.*/
            /* Control bar may be longer than picutre, so rcClient may be  */
            /* smaller than rcSave.                                        */
            rcSave = rcClient;    // remember stretched size

            /* Make rcClient 0 based from rcSave */
            rcClient.left = 0;
            rcClient.right = rcSave.right - rcSave.left;
            rcClient.top = 0;
            rcClient.bottom = rcSave.bottom - rcSave.top;

            /* Assume playbar will be regular height for now */
            if (gwOptions & OPT_BAR)
                gwPlaybarHeight = TOOLBAR_HEIGHT;
            else
                gwPlaybarHeight = 0;

            //
            // munge rectangle to account for a title in the picture
            // and the fact that picture is centred above title.
            // Remember, it's been stretched around.
            //

            if (gwOptions & OPT_TITLE)
            {
                SIZE Size;

                hdc = GetDC(NULL);

                if (ghfontMap)
                    SelectObject(hdc, ghfontMap);

                GetTextExtentPoint32(hdc, gachCaption,
                                     STRLEN(gachCaption), &Size);
                xTextExt = Size.cx;

                ReleaseDC(NULL, hdc);
                if (gwPastedHeight && !(gwDeviceType & DTMCI_CANWINDOW) )
                    yOrig = gwPastedHeight;
                else
                    yOrig = rc.bottom - rc.top;
                xOrig = rc.right - rc.left;
                xtitleOrig = max(xTextExt + 4, xOrig);
                yNow  = rcClient.bottom - rcClient.top;
                xNow  = rcClient.right - rcClient.left;
                if (gwDeviceType & DTMCI_CANWINDOW)
                    ytitleNow = TITLE_HEIGHT;
                else
                {
                    ytitleNow = (int)((long)yNow - ((long)yOrig * yNow)
                                / (yOrig + TITLE_HEIGHT));
                    gwOldHeight = yNow;
                }

                /* for windowed devices, center the playback area above the */
                /* control bar if the control bar is longer.                */
                if (gwDeviceType & DTMCI_CANWINDOW)
                {
                    wWinNow =(int)((long)xOrig * (long)xNow / (long)xtitleOrig);
                    xIndent = (xNow - wWinNow) / 2;
                    rcClient.left += xIndent;
                    rcClient.right = rcClient.left + wWinNow;
                }

                // Align top of control bar with the top of the title bar.
                // The control bar (if there) will appear under rcSave.
                rcClient.bottom = rcClient.top + yNow - ytitleNow;
                rcSave.bottom = rcSave.top + yNow - ytitleNow;

                /* When we make the playbar, make it cover the title */
                /* if the caption was stretched taller than ordinary.*/
                if (gwOptions & OPT_BAR)
                    gwPlaybarHeight = max(ytitleNow, TOOLBAR_HEIGHT);
            }

            /* Enforce a minimum width for the control bar */
#if 0
            /* No, don't, because this screws up PowerPoint, which is usually
             * scaled.  If anything, it would be better to hide the control bar
             * under these circumstances.
             */
            if ((gwOptions & OPT_BAR) &&
                (rcSave.right - rcSave.left < 3 * GetSystemMetrics(SM_CXICON)))
            {
                rcSave.right = rcSave.left + 3 * GetSystemMetrics(SM_CXICON);
                if (gwDeviceType & DTMCI_CANWINDOW)
                    xIndent = TRUE;     // force SetWindowMCI to be called to
                                        // avoid stretching to this new size.
            }
#endif

            if (!(gwOptions & OPT_USEPALETTE)&& !(gwOptions & OPT_DITHER))
            {
                //
                // try to get a OWNDC Palette of the client, PowerPoint
                // uses a PC_RESERVED palette in "SlideShow" mode. so
                // we must use it's exact palette.
                //
                hdc = GetDC(ghwndCntr);
                hpal = SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE),
                                    FALSE);
                SelectPalette(hdc, hpal, FALSE);
                ReleaseDC(ghwndCntr, hdc);

                if (hpal == NULL || hpal==GetStockObject(DEFAULT_PALETTE))
                {
                    /* Assume client realized the proper palette for us */

                    if (ghpalApp)
                        DeleteObject(ghpalApp);

                    hpal = ghpalApp = CreateSystemPalette();
                }
                else
                    DPF("Using clients OWNDC palette\n");

                if (hpal)
                    SetPaletteMCI(hpal);
            }

            else
                DPF("Using MCI Object's normal palette\n");

            ClrWS(ghwndApp, WS_THICKFRAME|WS_CAPTION|WS_SYSMENU|WS_MINIMIZEBOX|WS_MAXIMIZEBOX|WS_BORDER);

            if (gwOptions & OPT_BORDER)
                SetWS(ghwndApp, WS_BORDER);

            /* Set the size of Mplayer to have enough space for the MCI */
            /* playback area and a playbar and the non-client area.     */

            rcSave.bottom += gwPlaybarHeight;
            if(!(gwDeviceType & DTMCI_CANWINDOW) && (gwOptions & OPT_BAR))
                rcSave.top = rcSave.bottom - gwPlaybarHeight;

            AdjustWindowRect(&rcSave, (DWORD)GetWS(ghwndApp), FALSE);
            if(!(gwDeviceType & DTMCI_CANWINDOW) && !(gwOptions & OPT_BAR))
                    rcSave.bottom = rcSave.top = rcSave.left = rcSave.right = 0;

                EditInPlace(ghwndApp, hwndClient, &rcSave);
            /* become visible */
            SHOWAPPWINDOW(SW_SHOW);

            /* Remember to play the video in the rcClient area of rcSave */

            if ((gwDeviceType & DTMCI_CANWINDOW) &&
               (gwOptions & OPT_TITLE) && xIndent != 0)
                    SetDestRectMCI(&rcClient);
        }
    }

    else
    if (verb == verbOpen || verb == OLEIVERB_OPEN)
    {
        DPFI("\n*verbopen");
        DoInPlaceDeactivate(lpobj);

        if (gwDeviceID)
            return ReallyDoVerb(lpobj, verbEdit, lpmsg, lpActiveSite, fShow, fActivate);
    }

    else
    if (verb == OLEIVERB_HIDE)
    {
        DPFI("\n*^*^* OLEVERB_HIDE *^*^");
        DoInPlaceDeactivate(lpobj);
        return S_OK;
    }

    else
    if (verb > 0)
    {
        Result = ReallyDoVerb(lpobj, OLEIVERB_PRIMARY, lpmsg, lpActiveSite, fShow, fActivate);
    }

    else
        return E_NOTIMPL;


    if (fShow )
    {
        if (ghwndMCI || !gfOle2IPEditing)
            SHOWAPPWINDOW(SW_SHOW);

        /* MUST BE A POST or palette realization will not happen properly */
        if (IsIconic(ghwndApp))
            SendMessage(ghwndApp, WM_SYSCOMMAND, SC_RESTORE, 0L);
    }
    if (fActivate )
    {
        BringWindowToTop (ghwndApp);  // let WM_ACTIVATE put client
        SetActiveWindow (ghwndApp);   // underneath us
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\dynalink.h ===
/*-----------------------------------------------------------------------------+
| DYNALINK.H                                                                   |
|                                                                              |
| (C) Copyright Microsoft Corporation 1994.  All rights reserved.              |
|                                                                              |
| This file contains definitions and macros which allow the transparent        |
| loading and calling of APIs which are dynamically rather than statically     |
| linked.                                                                      |
|                                                                              |
|                                                                              |
| Revision History                                                             |
|    July 1994 Andrew Bell created                                             |
|                                                                              |
+-----------------------------------------------------------------------------*/

typedef struct _PROC_INFO
{
    LPCSTR  Name;
    FARPROC Address;
}
PROC_INFO, *PPROC_INFO;

BOOL LoadLibraryAndProcs(LPTSTR pLibrary, PPROC_INFO pProcInfo, HMODULE *phLibrary);

#define PROCS_LOADED( pProcInfo ) ( (pProcInfo)[0].Address != NULL )
#define LOAD_IF_NEEDED( Library, ProcInfo, phLibrary ) ( PROCS_LOADED( ProcInfo ) ||   \
                                    LoadLibraryAndProcs( Library, ProcInfo, phLibrary ) )

extern TCHAR szComDlg32[];
extern TCHAR szMPR[];
extern TCHAR szOLE32[];

extern HMODULE hComDlg32;
extern HMODULE hMPR;
extern HMODULE hOLE32;

extern PROC_INFO ComDlg32Procs[];
extern PROC_INFO MPRProcs[];
extern PROC_INFO OLE32Procs[];

#ifdef UNICODE
#define GetOpenFileNameW              (LOAD_IF_NEEDED(szComDlg32, ComDlg32Procs, &hComDlg32),\
                                       (*ComDlg32Procs[0].Address))
#else
#define GetOpenFileNameA              (LOAD_IF_NEEDED(szComDlg32, ComDlg32Procs, &hComDlg32),\
                                       (*ComDlg32Procs[0].Address))
#endif

#ifdef UNICODE
/* This assumes that WNetGetUniversalName will always be the first to be called.
 */
#define WNetGetUniversalNameW         (LOAD_IF_NEEDED(szMPR, MPRProcs, &hMPR),   \
                                       (*MPRProcs[0].Address))
#define WNetGetConnectionW            (*MPRProcs[1].Address)
#define WNetGetLastErrorW             (*MPRProcs[2].Address)
#else
#define WNetGetUniversalNameA         (LOAD_IF_NEEDED(szMPR, MPRProcs, &hMPR),   \
                                       (*MPRProcs[0].Address))
#define WNetGetConnectionA            (*MPRProcs[1].Address)
#define WNetGetLastErrorA             (*MPRProcs[2].Address)
#endif

/* OleInitialize must always be called before before any of the
 * other APIs.
 */
#define CLSIDFromProgID               (*OLE32Procs[0].Address)
#define CoCreateInstance              (*OLE32Procs[1].Address)
#define CoDisconnectObject            (*OLE32Procs[2].Address)
#define CoGetMalloc                   (*OLE32Procs[3].Address)
#define CoRegisterClassObject         (*OLE32Procs[4].Address)
#define CoRevokeClassObject           (*OLE32Procs[5].Address)
#define CreateDataAdviseHolder        (*OLE32Procs[6].Address)
#define CreateFileMoniker             (*OLE32Procs[7].Address)
#define CreateOleAdviseHolder         (*OLE32Procs[8].Address)
#define DoDragDrop                    (*OLE32Procs[9].Address)
#define IsAccelerator                 (*OLE32Procs[10].Address)
#define OleCreateMenuDescriptor       (HOLEMENU)(*OLE32Procs[11].Address)
#define OleDestroyMenuDescriptor      (*OLE32Procs[12].Address)
#define OleDuplicateData              (HANDLE)(*OLE32Procs[13].Address)
#define OleFlushClipboard             (*OLE32Procs[14].Address)
#define OleGetClipboard               (*OLE32Procs[15].Address)
#define OleInitialize                 (LOAD_IF_NEEDED(szOLE32, OLE32Procs, &hOLE32),    \
                                       (*OLE32Procs[16].Address))
#define OleIsCurrentClipboard         (*OLE32Procs[17].Address)
#define OleSetClipboard               (*OLE32Procs[18].Address)
#define OleTranslateAccelerator       (*OLE32Procs[19].Address)
#define OleUninitialize               (*OLE32Procs[20].Address)
#define StgCreateDocfile              (*OLE32Procs[21].Address)
#define WriteClassStg                 (*OLE32Procs[22].Address)
#define WriteFmtUserTypeStg           (*OLE32Procs[23].Address)
#ifndef IsEqualGUID
#define IsEqualGUID                   (*OLE32Procs[24].Address)
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\errorbox.c ===
/*-----------------------------------------------------------------------------+
| ERRORBOX.C                                                                   |
|                                                                              |
| Routines for dealing with Resource-string based messages                     |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
| 15-Oct-1992 LaurieGr (AKA LKG) Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

#include <windows.h>
#include <mmsystem.h>
#include <stdio.h>           // needed for va_list stuff
#include <stdarg.h>          // needed for va_list stuff
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#include "mplayer.h"

/*
 * @doc    INTERNAL
 *
 * @func short | ErrorResBox | This function displays a message box using
 * program resource error strings.
 *
 * @parm    HWND | hwnd | Specifies the message box parent window.
 *
 * @parm    HANDLE | hInst | Specifies the instance handle of the module
 * that contains the resource strings specified by <p idAppName> and
 * <p idErrorStr>.  If this value is NULL, the instance handle is
 * obtained from <p hwnd> (in which case <p hwnd> may not be NULL).
 *
 * @parm        WORD | flags | Specifies message box types controlling the
 * message box appearance.  All message box types valid for <f MessageBox> are
 * valid.
 *
 * @parm    WORD | idAppName | Specifies the resource ID of a string that
 * is to be used as the message box caption.
 *
 * @parm    WORD | idErrorStr | Specifies the resource ID of a error
 * message format string.  This string is of the style passed to
 * <f wsprintf>, containing the standard C argument formatting
 * characters.  Any procedure parameters following <p idErrorStr> will
 * be taken as arguments for this format string.
 *
 * @parm    arguments | [ arguments, ... ] | Specifies additional
 * arguments corresponding to the format specification given by
 * <p idErrorStr>.  All string arguments must be FAR pointers.
 *
 * @rdesc    Returns the result of the call to <f MessageBox>.  If an
 * error occurs, returns zero.
 *
 * @comm    This is a variable arguments function, the parameters after
 * <p idErrorStr> being taken for arguments to the <f printf> format
 * string specified by <p idErrorStr>.  The string resources specified
 * by <p idAppName> and <p idErrorStr> must be loadable using the
 * instance handle <p hInst>.  If the strings cannot be
 * loaded, or <p hwnd> is not valid, the function will fail and return
 * zero.
 *
 */
#define STRING_SIZE 256

void PositionMsgID(PTSTR szMsg, HANDLE hInst, UINT iErr)
{
    PTSTR psz;
    TCHAR szMplayerMsgID[16];
    TCHAR szTmp[STRING_SIZE];
    TCHAR szFmt[STRING_SIZE];

    if (!LoadString(hInst, IDS_MSGFORMAT, szFmt, STRING_SIZE))
        	return;
    if (!iErr)
    {
        for (psz = szMsg; psz && *psz && *psz != TEXT(' '); psz++)
    	    ;
	if (*psz == TEXT(' '))
	{
	    *psz++ = TEXT('\0');
	    wsprintf((LPTSTR)szTmp, (LPTSTR)szFmt, (LPTSTR)psz, (LPTSTR)szMsg);
	}
	else
	    return;
    }
    else
    {
    	wsprintf((LPTSTR)szMplayerMsgID, TEXT("MPLAYER%3.3u"), iErr);
    	wsprintf((LPTSTR)szTmp, (LPTSTR)szFmt, (LPTSTR)szMsg, (LPTSTR)szMplayerMsgID);
    }

    lstrcpy((LPTSTR)szMsg, (LPTSTR)szTmp);
}

short FAR cdecl ErrorResBox(HWND hwnd, HANDLE hInst, UINT flags,
            UINT idAppName, UINT idErrorStr, ...)
{
    TCHAR       sz[STRING_SIZE];
    TCHAR       szFmt[STRING_SIZE];
    UINT        w;
    va_list va;

    /* We're going away... bringing a box up will crash */
    if (gfInClose)
	return 0;

    if (hInst == NULL) {
        if (hwnd == NULL)
            hInst = ghInst;
        else
            hInst = GETHWNDINSTANCE(hwnd);
    }

    w = 0;

    if (!sz || !szFmt)
        goto ExitError;    // no mem, get out

    if (!LOADSTRINGFROM(hInst, idErrorStr, szFmt))
        goto ExitError;

    va_start(va, idErrorStr);
    StringCchVPrintf(sz, STRING_SIZE, szFmt, va);
    va_end(va);

    if (flags == MB_ERROR)
        if (idErrorStr == IDS_DEVICEERROR)
            PositionMsgID(sz, hInst, 0);
        else
            PositionMsgID(sz, hInst, idErrorStr);

    if (!LOADSTRINGFROM(hInst, idAppName, szFmt))
            goto ExitError;

    if (gfErrorBox) {
            DPF("*** \n");
            DPF("*** NESTED ERROR: '%"DTS"'\n", (LPTSTR)sz);
            DPF("*** \n");
            return 0;
    }

//  BlockServer();
    gfErrorBox++;

    /* Don't own this error box if we are not visible... eg. PowerPoint will
       hard crash.                                 */
    if (!IsWindowVisible(ghwndApp) || gfPlayingInPlace) {
        DPF("Bring error up as SYSTEMMODAL because PowerPig crashes in slide show\n");
        hwnd = NULL;
        flags |= MB_SYSTEMMODAL;
    }

    w = MessageBox(hwnd, sz, szFmt,
    flags);
    gfErrorBox--;
//  UnblockServer();

    if (gfErrorDeath) {
            DPF("*** Error box is gone ok to destroy window\n");
            PostMessage(ghwndApp, gfErrorDeath, 0, 0);
    }

ExitError:

    return (short)w;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\errprop.h ===
/*-----------------------------------------------------------------------------+
| ERRORPROP.H                                                                  |
|                                                                              |
| Interactive error propagation bitmap enhancement program.                    |
|                                                                              |
| (C) Copyright Microsoft Corporation 1992.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

#define MAXPROP     16
#define MAXMULT     64

typedef struct {
    short   GrayThresh;
    short   LoThresh;
    short   HiThresh;
    short   Prop;
    short   Mult[3];
} ERRPROPPARAMS;

typedef ERRPROPPARAMS NEAR *PERRPROPPARAMS;

int  SetDIBitsErrProp(HDC hdc,HBITMAP hbm,WORD nStart,WORD nScans,LPBYTE lpBits,LPBITMAPINFO lpbi,WORD wUsage);
void SetErrPropParams(PERRPROPPARAMS pErrProp);
void GetErrPropParams(PERRPROPPARAMS pErrProp);

extern void FAR PASCAL BltProp(LPBITMAPINFOHEADER lpbiSrc, LPBYTE pbSrc, UINT SrcX, UINT SrcY, UINT SrcXE, UINT SrcYE,
                               LPBITMAPINFOHEADER lpbiDst, LPBYTE pbDst, UINT DstX, UINT DstY);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\fixreg.h ===
/*-----------------------------------------------------------------------------+
| FIXREG.H                                                                     |
|                                                                              |
| (C) Copyright Microsoft Corporation 1994.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    10-Aug-1994 Lauriegr Created.                                             |
|                                                                              |
+-----------------------------------------------------------------------------*/

/* Call this with the hwnd that you want a WM_BADREG message posted to
   It will check the registry.  No news is good news.
   It does the work on a separate thread, so this should return quickly.
*/
void BackgroundRegCheck(HWND hwnd);

/* Insert the good values into the regtistry
   Call this if you get a WM_BADREG back from BackgroundRegCheck.
*/
BOOL SetRegValues(void);

/* Ignore the registry check
*/
BOOL IgnoreRegCheck(void);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\framebox.h ===
/*-----------------------------------------------------------------------------+
| FRAMEBOX.H                                                                   |
|                                                                              |
| Header file for the FrameBox routines.                                       |
|                                                                              |
| (C) Copyright Microsoft Corporation 1992.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

/* function prototypes */
BOOL FAR PASCAL frameboxInit(HANDLE hInst, HANDLE hPrev);
LONG_PTR FAR PASCAL frameboxSetText(HWND hwnd, LPTSTR lpsz);


/* special messages for FrameBox */
/* Edit box messages go up to WM_USER+34, so this doesn't conflict */
#define FBOX_SETMAXFRAME    (WM_USER+100)





=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\hatch.c ===
/*
 * HATCH.C
 *
 * Miscellaneous API's to generate hatch window for in-place active
 * objects. This is part of the OLE 2.0 User Interface Support Library.
 *
 * Copyright (c)1993 Microsoft Corporation, All Right Reserved
 */

#define STRICT  1
#include <windows.h>
#ifdef MTN
#pragma warning(disable: 4103)  // used #pragma pack to change alignment (on Chicago)
#endif
#include <ole2.h>
#include "mplayer.h"
#include "ole2ui.h"

// offsets in the extra bytes stored with the hatch window
#define EB_HATCHWIDTH       (0 * sizeof(INT))
#define EB_HATCHRECT_LEFT   (1 * sizeof(INT))
#define EB_HATCHRECT_TOP    (2 * sizeof(INT))
#define EB_HATCHRECT_RIGHT  (3 * sizeof(INT))
#define EB_HATCHRECT_BOTTOM (4 * sizeof(INT))
#define EB_HATCHRECT_HANDLE (5 * sizeof(INT))

// class name of hatch window
static TCHAR szHatchWindow[] = TEXT("Hatch Window");

// local function prototypes
LRESULT FAR PASCAL _EXPORT HatchWndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam);

/*
 * HatchRegisterClass
 *
 * Purpose:
 *  Register the hatch window
 *
 * Parameters:
 *  hInst           Process instance
 *
 * Return Value:
 *  TRUE            if successful
 *  FALSE           if failed
 *
 */
STDAPI_(BOOL) RegisterHatchWindowClass(HINSTANCE hInst)
{
    WNDCLASS wc;

    // Register Hatch Window Class
    wc.style = CS_BYTEALIGNWINDOW;
    wc.lpfnWndProc = HatchWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 6 * sizeof(int);    // extra bytes stores
                                        //     uHatchWidth
                                        //     rcHatchRect
    wc.hInstance = hInst;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = szHatchWindow;

    if (!RegisterClass(&wc))
        return FALSE;
    else
        return TRUE;
}


/*
 * CreateHatchWindow
 *
 * Purpose:
 *  Create the hatch window
 *
 * Parameters:
 *  hWndParent          parent of hatch window
 *  hInst               instance handle
 *
 * Return Value:
 *  pointer to hatch window         if successful
 *  NULL                            if failed
 *
 */
STDAPI_(HWND) CreateHatchWindow(HWND hWndParent, HINSTANCE hInst)
{
    HWND         hWnd;

    if (!hWndParent || !hInst)
        return NULL;

    hWnd = CreateWindowEx(
        gfdwFlagsEx,
        szHatchWindow,
        szHatchWindow,
        WS_CHILDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
        0, 0, 0, 0,
        hWndParent,
        (HMENU)NULL,
        hInst,
        0L
    );

    if (!hWnd)
        return NULL;

    return hWnd;
}

/*
 *  GetHatchWidth
 *
 *  Purpose:
 *      Get width of hatch border
 *
 *  Parameters:
 *      hWndHatch       hatch window handle
 *
 *  Return Value:
 *      width of the hatch border
 */
STDAPI_(UINT) GetHatchWidth(HWND hWndHatch)
{
    if (!IsWindow(hWndHatch))
        return 0;

    return (UINT)GETWINDOWUINT(hWndHatch, EB_HATCHWIDTH);
}

/*
 *  GetHatchRect
 *
 *  Purpose:
 *      Get hatch rect. this is the size of the hatch window if it were
 *      not clipped by the ClipRect.
 *
 *  Parameters:
 *      hWndHatch       hatch window handle
 *      lprcHatchRect   hatch rect
 *
 *  Return Value:
 *      none
 */
STDAPI_(void) GetHatchRect(HWND hWndHatch, LPRECT lprcHatchRect)
{
    if (!IsWindow(hWndHatch)) {
        SetRect(lprcHatchRect, 0, 0, 0, 0);
        return;
    }

    lprcHatchRect->left = GETWINDOWUINT(hWndHatch, EB_HATCHRECT_LEFT);
    lprcHatchRect->top = GETWINDOWUINT(hWndHatch, EB_HATCHRECT_TOP);
    lprcHatchRect->right = GETWINDOWUINT(hWndHatch, EB_HATCHRECT_RIGHT);
    lprcHatchRect->bottom = GETWINDOWUINT(hWndHatch, EB_HATCHRECT_BOTTOM);
}


/* SetHatchRect
 *
 *
 *  Purpose:
 *      Store hatch rect with HatchRect window.
 *      this rect is the size of the hatch window if it were
 *      not clipped by the ClipRect.
 *
 *  Parameters:
 *      hWndHatch       hatch window handle
 *      lprcHatchRect   hatch rect
 *
 *  Return Value:
 *      none
 */
STDAPI_(void) SetHatchRect(HWND hWndHatch, LPRECT lprcHatchRect)
{
    if (!IsWindow(hWndHatch))
        return;

    SETWINDOWUINT(hWndHatch, EB_HATCHRECT_LEFT, lprcHatchRect->left);
    SETWINDOWUINT(hWndHatch, EB_HATCHRECT_TOP, lprcHatchRect->top);
    SETWINDOWUINT(hWndHatch, EB_HATCHRECT_RIGHT, lprcHatchRect->right);
    SETWINDOWUINT(hWndHatch, EB_HATCHRECT_BOTTOM, lprcHatchRect->bottom);
    SETWINDOWUINT(hWndHatch, EB_HATCHRECT_HANDLE, 0);
}


/* SetHatchWindowSize
 *
 *
 *  Purpose:
 *      Move/size the HatchWindow correctly given the rect required by the
 *      in-place server object window and the lprcClipRect imposed by the
 *      in-place container. both rect's are expressed in the client coord.
 *      of the in-place container's window (which is the parent of the
 *      HatchWindow).
 *
 *      OLE2NOTE: the in-place server must honor the lprcClipRect specified
 *      by its in-place container. it must NOT draw outside of the ClipRect.
 *      in order to achieve this, the hatch window is sized to be
 *      exactly the size that should be visible (rcVisRect). the
 *      rcVisRect is defined as the intersection of the full size of
 *      the HatchRect window and the lprcClipRect.
 *      the ClipRect could infact clip the HatchRect on the
 *      right/bottom and/or on the top/left. if it is clipped on the
 *      right/bottom then it is sufficient to simply resize the hatch
 *      window. but if the HatchRect is clipped on the top/left then
 *      in-place server document window (child of HatchWindow) must be moved
 *      by the delta that was clipped. the window origin of the
 *      in-place server window will then have negative coordinates relative
 *      to its parent HatchWindow.
 *
 *  Parameters:
 *      hWndHatch       hatch window handle
 *      lprcIPObjRect   full size of in-place server object window
 *      lprcClipRect    clipping rect imposed by in-place container
 *      lpptOffset      offset required to position in-place server object
 *                      window properly. caller should call:
 *                          OffsetRect(&rcObjRect,lpptOffset->x,lpptOffset->y)
 *
 *  Return Value:
 *      none
 */
STDAPI_(void) SetHatchWindowSize(
        HWND        hWndHatch,
        LPCRECT     lprcIPObjRect,
        LPCRECT     lprcClipRect,
        LPPOINT     lpptOffset,
        BOOL        handle
)
{
    RECT        rcHatchRect;
    RECT        rcVisRect;
    UINT        uHatchWidth;
    POINT       ptOffset;

    if (!IsWindow(hWndHatch))
        return;

    rcHatchRect = *lprcIPObjRect;
    uHatchWidth = GetHatchWidth(hWndHatch);

    if (uHatchWidth > 0) // If it's 0, we're hiding the hatch window
        InflateRect((LPRECT)&rcHatchRect, uHatchWidth + 1, uHatchWidth + 1);

    IntersectRect((LPRECT)&rcVisRect, (LPRECT)&rcHatchRect, lprcClipRect);
    MoveWindow(
            hWndHatch,
            rcVisRect.left,
            rcVisRect.top,
            rcVisRect.right-rcVisRect.left,
            rcVisRect.bottom-rcVisRect.top,
            TRUE    /* fRepaint */
    );

    InvalidateRect(hWndHatch, NULL, TRUE);

    ptOffset.x = -rcHatchRect.left + (rcHatchRect.left - rcVisRect.left);
    ptOffset.y = -rcHatchRect.top + (rcHatchRect.top - rcVisRect.top);

    /* convert the rcHatchRect into the client coordinate system of the
    **    HatchWindow itself
    */
    OffsetRect((LPRECT)&rcHatchRect, ptOffset.x, ptOffset.y);

    SetHatchRect(hWndHatch, (LPRECT)&rcHatchRect);

    // calculate offset required to position in-place server doc window
    lpptOffset->x = ptOffset.x;
    lpptOffset->y = ptOffset.y;

//  No size handles:
//  SETWINDOWUINT(hWndHatch, EB_HATCHRECT_HANDLE, handle);
}


/*
 *  HatchWndProc
 *
 *  Purpose:
 *      WndProc for hatch window
 *
 *  Parameters:
 *      hWnd
 *      Message
 *      wParam
 *      lParam
 *
 *  Return Value:
 *      message dependent
 */
LRESULT FAR PASCAL _EXPORT HatchWndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam)
{
    int nBorderWidth;

    switch (Message) {

        case WM_CREATE:
            nBorderWidth = GetProfileInt(
                TEXT("windows"),
                TEXT("oleinplaceborderwidth"),
                DEFAULT_HATCHBORDER_WIDTH
            );
            SETWINDOWUINT(hWnd, EB_HATCHWIDTH, nBorderWidth);
            break;

        case WM_PAINT:
        {
            HDC hDC;
            PAINTSTRUCT ps;
            RECT rcHatchRect;

            nBorderWidth = GetHatchWidth(hWnd);
            hDC = BeginPaint(hWnd, &ps);

            GetHatchRect(hWnd, (LPRECT)&rcHatchRect);
            OleUIDrawShading(&rcHatchRect, hDC, OLEUI_SHADE_BORDERIN,
                    nBorderWidth);
            InflateRect((LPRECT)&rcHatchRect, -nBorderWidth, -nBorderWidth);
	        if (GETWINDOWUINT(hWnd,EB_HATCHRECT_HANDLE))
		        OleUIDrawHandles(&rcHatchRect, hDC, OLEUI_HANDLES_OUTSIDE,
                                 nBorderWidth+1, TRUE);

            EndPaint(hWnd, &ps);
            break;
        }


        case WM_ERASEBKGND:
            /* If the hatch is hidden, don't bother erasing the background,
             * since the media clip will fill it in.
             */
            if (GETWINDOWUINT(hWnd, EB_HATCHWIDTH) == 0)
                return 1;

            /* Fall through ... */

        default:
            return DefWindowProc(hWnd, Message, wParam, lParam);
    }

    return 0L;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\helpids.h ===
#define IDH_MPLYR_CS_MEDIA_PLAYER_FILE_OPEN			4287
#define IDH_MPLYR_CS_MEDIA_PLAYER_FILE_CLOSE			4288
#define IDH_MPLYR_CS_MEDIA_PLAYER_FILE_EXIT			4289
#define IDH_MPLYR_CS_MEDIA_PLAYER_EDIT_COPY_OBJECT		4290
#define IDH_MPLYR_CS_MEDIA_PLAYER_EDIT_OPTIONS			4291
#define IDH_MPLYR_CS_MEDIA_PLAYER_EDIT_SELECTION		4292
#define IDH_MPLYR_CS_MEDIA_PLAYER_DEVICE_PROPERTIES		4293
#define IDH_MPLYR_CS_MEDIA_PLAYER_DEVICE_VOLUME_CONTROL		4294
#define IDH_MPLYR_CS_MEDIA_PLAYER_SCALE_TIME			4295
#define IDH_MPLYR_CS_MEDIA_PLAYER_SCALE_FRAMES			4296
#define IDH_MPLYR_CS_MEDIA_PLAYER_SCALE_TRACKS			4297
#define IDH_MPLYR_CS_MEDIA_PLAYER_HELP_HELP_TOPICS		4298
#define IDH_MPLYR_CS_MEDIA_PLAYER_HELP_ABOUT			4299
#define IDH_OPT_AUTO                   				4300
#define IDH_OPT_CAPTION              				4301
#define IDH_OPT_BORDER                 				4302
#define IDH_OPT_PLAYCLIENT             				4303
#define IDH_OPT_DITHER             				4304
#define IDH_SELECT_SELECT          				4305
#define IDH_OPT_REPEAT             				4306
#define IDH_OPT_CAPTCONTROL        				4307
#define IDH_SELECT_ALL              				4308
#define IDH_SELECT_NONE              				4309
#define IDH_SELECT_FROM              				4310
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\framebox.c ===
/*-----------------------------------------------------------------------------+
| FRAMEBOX.C                                                                   |
|                                                                              |
| Code to handle the frame edit boxes for MPlayer.                             |
|                                                                              |
| This code handles the edit box that goes between time, track &               |
| frame view.  When a FrameBox is created we will create an                    |
| Edit box and spin arrows for it.  By checking the                            |
| <gwCurScale> flag we will display text in either frame, track                |
| or in time mode.  The displayed time mode will be HH:MM:SS.ss                |
| Track mode is TT HH:MM:SS or maybe TT MM:SS or something.                    |
| GETTEXT will return a frame number in frame mode or a millisec               |
| value in time or track mode.                                                 |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

#include <windows.h>
#include <mmsystem.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "mplayer.h"
#include "framebox.h"

extern  int gInc;        // amount spin arrows inc/dec by

#define SPINARROWWIDTH 6 /* In dialog base units */

#define IDC_EDITBOX    5000
#define IDC_SPINARROW  5001

// extra fields in window instance data
#define GWI_EDITBOX     (0 * sizeof(INT)) // edit box window handle
#define GWI_SPINARROWS  (1 * sizeof(INT)) // spinarrow window handle
#define GWL_MAXFRAME    (2 * sizeof(INT)) // max frame value
#define GWI_ALLOCATE    (2 * sizeof(INT) + sizeof(LONG)) // number of BYTEs to allocate

#define GETEDITBOXWND(hwnd) (HWND)GetWindowLongPtr (hwnd, GWI_EDITBOX)
#define GETSPINARRWND(hwnd) (HWND)GetWindowLongPtr (hwnd, GWI_SPINARROWS)

#define SETEDITBOXWND(hwnd, hwndEdit) \
        SETWINDOWUINT(hwnd, GWI_EDITBOX, hwndEdit)
#define SETSPINARRWND(hwnd, hwndArr) \
        SETWINDOWUINT(hwnd, GWI_SPINARROWS, hwndArr)

#define HILIGHTEDITBOX(hwnd) \
        SendMessage(GETEDITBOXWND(hwnd), EM_SETSEL, (WPARAM)0, (LPARAM)(UINT)-1);

#define GETMAXFRAME(hwnd)   (DWORD)GetWindowLongPtr(hwnd, GWL_MAXFRAME)
#define SETMAXFRAME(hwnd, l) SetWindowLongPtr(hwnd, GWL_MAXFRAME, (LONG_PTR)l)

// internal functions
LONG_PTR FAR PASCAL _EXPORT frameboxWndProc(HWND hwnd, unsigned wMsg, WPARAM wParam, LPARAM lParam);

LONG_PTR NEAR PASCAL  frameboxiSetText(HWND hwnd, LPTSTR lpsz);
LONG_PTR NEAR PASCAL  frameboxiGetText(HWND hwnd, UINT_PTR wStrLen, LPTSTR lpsz);
LONG_PTR NEAR PASCAL  frameboxiArrowEdit(HWND hwnd, WPARAM wParam, LONG_PTR lParam);

// strings
TCHAR   szFrameBoxClass[] = TEXT("aviframebox");


/*--------------------------------------------------------------+
| ******************** EXTERNAL FUNCTIONS ********************* |
+--------------------------------------------------------------*/
/*--------------------------------------------------------------+
| frameboxInit() - initialize by registering our class.         |
|                  NOTE: Even if we return FALSE, nobody should |
|                  care, because we don't register these classes|
|                  at AppInit time, but on demand, so only the  |
|                  first call will succeed.  Complain to Todd.  |
|                  (DM).                                        |
|                                                               |
+--------------------------------------------------------------*/
BOOL FAR PASCAL frameboxInit(HANDLE hInst, HANDLE hPrev)
{
  WNDCLASS    cls;

  if (1) {
      cls.hCursor           = LoadCursor(NULL, IDC_ARROW);
      cls.hIcon             = NULL;
      cls.lpszMenuName      = NULL;
      cls.lpszClassName     = szFrameBoxClass;
      cls.hbrBackground     = (HBRUSH)(COLOR_WINDOW + 1);
      cls.hInstance         = ghInst;
      cls.style             = CS_HREDRAW | CS_VREDRAW;
      cls.lpfnWndProc       = frameboxWndProc;
      cls.cbClsExtra        = 0;
      cls.cbWndExtra        = GWI_ALLOCATE;  // room for stuff

      if (!RegisterClass(&cls))
          return FALSE;

      if (!ArrowInit(hInst))
          return FALSE;
  }
  return TRUE;
}

/*--------------------------------------------------------------+
| frameboxSetText() - set the text for the window passed in     |
|                     <hwnd>.                                   |
|                                                               |
+--------------------------------------------------------------*/
LONG_PTR FAR PASCAL frameboxSetText(HWND hwnd, LPTSTR lpsz)
{
    LONG_PTR    l;
    TCHAR       achTimeString[20];
    BOOL        fFrameFormat = (gwCurScale == ID_FRAMES);
    UINT        wCurScaleSave = gwCurScale;

    if (fFrameFormat || *lpsz == TEXT('\0')){
        /* we are in frame format - this is easy and all we need*/
        /* to do is to return what is in the Edit box           */
         l = SendMessage(hwnd, WM_SETTEXT, (WPARAM)0, (LPARAM)lpsz);
    } else {
        /* we are in time/track format - need to convert to a time string */
        /* based on the msec value we have been passed in.                */
        DWORD_PTR        dwmSecs;

        /* get into local buffer */
        lstrcpy((LPTSTR)achTimeString, (LPTSTR)lpsz);
        dwmSecs = (DWORD_PTR)ATOL(achTimeString);

        /* It's meaningless to print track style numbers for the length of  */
        /* the selection, so use ordinary time mode.                        */
        if (GetParent(hwnd) ==
                GetDlgItem(GetParent(GetParent(hwnd)), IDC_EDITNUM))
            gwCurScale = ID_TIME;

        FormatTime(dwmSecs, (LPTSTR)achTimeString, NULL, FALSE);
        gwCurScale = wCurScaleSave;

        /* send it to the control */
        l = SendMessage(hwnd,
                        WM_SETTEXT,
                        (WPARAM)0,
                        (LPARAM)(LPTSTR)achTimeString);
    }
    return l;
}


/*--------------------------------------------------------------+
| *********************** WINDOW PROC ************************* |
+--------------------------------------------------------------*/
/*--------------------------------------------------------------+
| frameboxWndProc - window process to handle the FrameBox       |
|                                                               |
+--------------------------------------------------------------*/
LONG_PTR FAR PASCAL _EXPORT frameboxWndProc(HWND hwnd, unsigned wMsg,
                                        WPARAM wParam, LPARAM lParam)
{
    HWND        hwndNew;
    RECT        rc;
    UINT        wArrowWidth;

    switch(wMsg){
        case WM_CREATE:
            /* create the Edit box and the spin arrows for this */
            /* FrameBox window.                                 */
            GetClientRect(hwnd, (LPRECT)&rc);

            /* Calculate arrow width in pixels */
            wArrowWidth = ((SPINARROWWIDTH * LOWORD(GetDialogBaseUnits()))
                                            / 4) - 1;

            /* create the edit box */

            hwndNew = CreateWindowEx(gfdwFlagsEx,
                                     TEXT("edit"),
                                     TEXT(""),
                                     WS_CHILD|WS_TABSTOP|ES_LEFT|WS_BORDER,
                                     0,
                                     0,
                                     rc.right - wArrowWidth,
                                     rc.bottom,
                                     hwnd,
                                     (HMENU)IDC_EDITBOX,
                                     GETHWNDINSTANCE(hwnd),
                                     0L);

            if (!hwndNew){
                return 0L;
            }
            SETEDITBOXWND(hwnd, hwndNew);

            /* limit this box to 15 chars of input */
            SendMessage(hwndNew, EM_LIMITTEXT, (WPARAM)15, (LPARAM)0L);
            ShowWindow(hwndNew, SW_SHOW);


            /* create the spin arrows */

            hwndNew = CreateWindowEx(gfdwFlagsEx,
                                     TEXT("comarrow"),
                                     TEXT(""),
                                     WS_CHILD|WS_TABSTOP|WS_BORDER,
                                     rc.right - wArrowWidth,
                                     0,
                                     wArrowWidth,
                                     rc.bottom,
                                     hwnd,
                                     (HMENU)IDC_SPINARROW,
                                     GETHWNDINSTANCE(hwnd),
                                     0L);

            if (!hwndNew){
                return 0L;
            }
            SETSPINARRWND(hwnd, hwndNew);
            ShowWindow(hwndNew, SW_SHOW);

            /* set the max to be the end of the media by default */
            SETMAXFRAME(hwnd, (DWORD)(gdwMediaStart + gdwMediaLength));
            break;


        case WM_DESTROY:
            /* Delete the Edit box and the spin arrows */
            DestroyWindow(GETEDITBOXWND(hwnd));
            DestroyWindow(GETSPINARRWND(hwnd));
            break;

        case WM_SETFONT:
            return SendMessage(GETEDITBOXWND(hwnd), wMsg, wParam, lParam);

        case WM_SETFOCUS:
            /* when we get the focus just send it on to the edit control */
            SetFocus(GETEDITBOXWND(hwnd));
            break;

        case WM_SETTEXT:
            /* set the text which is a frame number or time in  */
            /* msec to be a frame or time mode string           */
            return frameboxiSetText(hwnd, (LPTSTR)lParam);

        case WM_GETTEXT:
            /* get the text from the Edit box and translate to a */
            /* frame number or time in msec.                     */
            return frameboxiGetText(hwnd, wParam, (LPTSTR)lParam);

        case WM_VSCROLL:
            /* handle the scrolling via spin arrows */
            return frameboxiArrowEdit(hwnd, wParam, lParam);

        case WM_COMMAND:
            switch (LOWORD(wParam) ){
                case IDC_EDITBOX:
                    // route editbox messages back to our parent

                    SendMessage(GetParent(hwnd),
                                WM_COMMAND,
                                GETWINDOWID(hwnd),
                                lParam);

                    break;
            }
            break;

        case EM_SETSEL:
            /* Perhaps we should only let this through if the caller
            ** is trying to select the entire contents of the edit box,
            ** because otherwise we'll have to map the range.
            */
            SendMessage(GETEDITBOXWND(hwnd), wMsg, wParam, lParam);
            break;

#pragma message("Should we be supporting other EM_* messages?")

        /* handle special case messages for the FrameBox control */
        case FBOX_SETMAXFRAME:
            /* set the max frames to allow spin arrows to go */
            SETMAXFRAME(hwnd, lParam);
            break;

        default:
            return(DefWindowProc(hwnd, wMsg, wParam, lParam));
            break;

    }
    return (0L);
}

/*--------------------------------------------------------------+
| ******************** INTERNAL FUNCTIONS ********************* |
+--------------------------------------------------------------*/
/*--------------------------------------------------------------+
| frameboxiSetText() - handle setting the text depending on if  |
|                        we are in time or frame format.        |
|                                                               |
+--------------------------------------------------------------*/
LONG_PTR NEAR PASCAL  frameboxiSetText(HWND hwnd, LPTSTR lpsz)
{
    LONG_PTR l;

/* We want to set the text even if it's identical because someone might */
/* have typed 03 06:00 and if track 3 if only 4 minutes long we want it */
/* to change to 04 02:00.  Clever, eh?                                  */
#if 0
    TCHAR ach[12];

    /* see if we are setting the same string as what is there  */
    /* and just don't do it if so to avoid flicker.            */
    l = frameboxiGetText(hwnd, CHAR_COUNT(ach), (LPTSTR)ach);
    if (lstrcmp((LPTSTR)ach, lpsz) == 0)
        goto HighLight;
#endif

    /* call generic function to handle this */
    l = frameboxSetText(GETEDITBOXWND(hwnd), lpsz);

#if 0
HighLight:
#endif
    /* now let's highlight the whole thing */
    HILIGHTEDITBOX(hwnd);

    return l;
}


#define IsCharNumeric( ch ) ( IsCharAlphaNumeric( ch ) && !IsCharAlpha( ch ) )

/*--------------------------------------------------------------+
| frameboxiGetText() - handle getting the text depending on if  |
|                      we are in time or frame format. Either   |
|                      returns a frame number or msec number    |
|                      depending on the mode.                   |
|                                                               |
+--------------------------------------------------------------*/
LONG_PTR NEAR PASCAL  frameboxiGetText(HWND hwnd, UINT_PTR wStrLen, LPTSTR lpsz)
{
    UINT    wCurScaleSave = gwCurScale;

    if (gwCurScale == ID_FRAMES) {
        LPTSTR   p;
        LPTSTR   pStart;
        UINT     w;

        /* we are in frame format - this is easy and all we need*/
        /* to do is to return what is in the Edit box           */
        if (GetWindowText(GETEDITBOXWND(hwnd), lpsz, (int)wStrLen) == 0)
            goto LB_Error;

        /* cut through leading white space */
        for (pStart = lpsz; *pStart == TEXT(' ') || *pStart == TEXT('\t'); pStart++)
            ;

        /* now rip out trailing white space */
        if (*pStart) {    // don't backtrack before beginning of string
            for (p=pStart; *p; p++)
                ;
            for (--p; *p == TEXT(' ') || *p == TEXT('\t'); --p)
                ;
            *++p = TEXT('\0');
        }

        // make sure digits only were entered
        for (p=pStart, w=0; *p; p++, w++)
            if (!IsCharNumeric(*p))
                goto LB_Error;

        // copy over only the part you need and return #chars
        lstrcpy(lpsz, pStart);
        return w;

    } else {
        /* we are in time or track format - we need to convert the time */
        /* to msec.                                                     */
        PTSTR   pStart;         // pointer to achTime buffer
        TCHAR   achTime[20];    // buffer for time string (input)
        DWORD   dwmSecs;        // total mSecs for this thing */
        TCHAR   *pDelim;        // pointer to next delimeter
        TCHAR   *p;             // general pointer
        DWORD   dwTrack = 0;    // track number
        DWORD   dwHours = 0;    // # of hours
        DWORD   dwMins = 0;     // # of minutes
        DWORD   dwSecs = 0;     // # of seconds
        DWORD    wmsec = 0;      // # hundredths
        DWORD    w;

        /* It's meaningless to use track style numbers for the length of    */
        /* the selection, so use ordinary time mode.                        */
        if (hwnd == GetDlgItem(GetParent(hwnd), IDC_EDITNUM))
            gwCurScale = ID_TIME;

        /* get the string from the edit box */
        SendMessage(GETEDITBOXWND(hwnd),
                    WM_GETTEXT,
                    (WPARAM)CHAR_COUNT(achTime),
                    (LPARAM)(LPTSTR) achTime);

        if (achTime[0] == TEXT('\0'))
            goto LB_Error;       // bad char so error out

        /* go past any white space up front */
        for (pStart = achTime; *pStart == TEXT(' ') || *pStart == TEXT('\t'); pStart++)
            ;

        /* now rip out trailing white space */
        if (*pStart) {          // don't backtrack before beginning of string
            for (p=pStart; *p; p++)
                ;
            for (--p; *p == TEXT(' ') || *p == TEXT('\t'); --p)
                ;
            *++p = TEXT('\0');
        }

        /* We're in track mode so peel the track number off the front */
        if (gwCurScale == ID_TRACKS) {

            /* First non-digit better be a space */
            for (p = pStart; *p && *p != TEXT(' '); p++){
                if (!IsCharNumeric(*p))
                    goto LB_Error;    // bad char so error out
            }

            /* It is, so just grab the first numeric and use the rest of */
            /* the string as the time.                                   */
            dwTrack = ATOI(pStart);
            if ((int)dwTrack < (int)gwFirstTrack || dwTrack >= gwFirstTrack +
                                                                gwNumTracks)
                goto LB_Error;

            /* Now bypass the spaces between track number and time */
            pStart = p;
            while (*pStart == TEXT(' '))
                pStart++;

            /* There is nothing after the track number.  Use it. */
            if (*pStart == TEXT('\0'))
                goto MAKETOTAL;

        }

        /* rip through the whole string and look for illegal chars */
        for (p = pStart; *p ; p++){
            if (!IsCharNumeric(*p) && *p != chDecimal && *p != chTime)
                goto LB_Error;       // bad char so error out
        }

/*
 * The reason for the slightly odd "if" statements of the form:
 *
 *       if (pDelim) {
 *           if (*pDelim){
 *
 * is because strchr(...) returns an offset OR NULL. As this is then promptly
 * dereferenced to see what character (if any) is there we have a problem.
 * Win16 is allows this sort of thing, but Win32
 * will generate an address exception post haste...
 *
 * Hence we try to do it properly.
 *
 */

        /* go find the milliseconds portion if it exists */
        pDelim = STRCHR(pStart, chDecimal);
        if (pDelim) {
            if (*pDelim){
                p = STRRCHR(pStart, chDecimal);
                if (pDelim != p){
                    goto LB_Error;       // string has > 1 '.', return error
                }
                p++;                     // move up past delim
                if (STRLEN(p) > 3)
                    *(p+3) = TEXT('\0'); // knock off all but thousandths
                wmsec = ATOI(p);         // get the fractional part
                if (STRLEN(p) == 1)     // adjust to a millisecond value
                    wmsec *= 100;
                if (STRLEN(p) == 2)
                    wmsec *= 10;
                *pDelim = TEXT('\0');    // null out this terminator
            }
        }

        /* try and find seconds */
        pDelim = STRRCHR(pStart, chTime);    // get last ':'
        if (pDelim) {
            if (*pDelim)
                p = (pDelim+1);
            else
                p = pStart;
            dwSecs = ATOI(p);

            if (*pDelim)
                *pDelim = TEXT('\0');
            else
                goto MAKETOTAL;
        } else {
            p = pStart;
            dwSecs = ATOI(p);

            goto MAKETOTAL;
        }

        /* go and get the minutes part */
        pDelim = STRRCHR(pStart, chTime);
        if (pDelim) {
            if (*pDelim)
                p = (pDelim + 1);
            else {
                p = pStart;
                dwMins = ATOI(p);
            }
        } else {
            p = pStart;
            dwMins = ATOI(p);
        }

        if (pDelim)
            if (*pDelim)
                *pDelim = TEXT('\0');
            else
                goto MAKETOTAL;
        else
            goto MAKETOTAL;


        /* get the hours */
        p = pStart;
        dwHours = ATOI(p);

MAKETOTAL:
        /* now we've got the hours, minutes, seconds and any        */
        /* fractional part.  Time to build up the total time        */

        dwSecs += (dwHours * 3600);   // add in hours worth of seconds
        dwSecs += (dwMins * 60);      // add in minutes worth of seconds
        dwmSecs = (dwSecs * 1000L) + wmsec;

        /* For track mode, this is an offset into a track, so add track start */
        if (gwCurScale == ID_TRACKS) {
            dwmSecs += gadwTrackStart[dwTrack - 1];
        }

        /* build this into a string */
        wsprintf(achTime, TEXT("%ld"), dwmSecs);
        w = STRLEN(achTime);

        if (wCurScaleSave)
            gwCurScale = wCurScaleSave;

        /* copy to user buffer and return */
        lstrcpy(lpsz, achTime);
        return w;

LB_Error:
        gwCurScale = wCurScaleSave;
        return LB_ERR;
    }
}


/*--------------------------------------------------------------+
| frameboxiArrowEdit() - handle the spin arrows for msec mode.  |
|                                                               |
+--------------------------------------------------------------*/
LONG_PTR NEAR PASCAL  frameboxiArrowEdit(HWND hwnd, WPARAM wParam, LONG_PTR lParam)
{
        TCHAR        achTime[20];
        DWORD        dwmSecs, dwStart, dwEnd;

        if (hwnd == GetDlgItem(GetParent(hwnd), IDC_EDITNUM)) {
            dwStart = 0;
            dwEnd = gdwMediaLength;
        } else {
            dwStart = gdwMediaStart;
            dwEnd = GETMAXFRAME(hwnd);
        }

        frameboxiGetText(hwnd, CHAR_COUNT(achTime), (LPTSTR)achTime);
        dwmSecs = ATOL(achTime);
        if (LOWORD(wParam) == SB_LINEUP){
            if ((long)dwmSecs >= (long)dwStart - gInc &&
                                (long)dwmSecs < (long)dwEnd) {
                dwmSecs += gInc;
                wsprintf(achTime, TEXT("%ld"), dwmSecs);
                /* bring focus here NOW! so update works */
                SendMessage(hwnd,
                            WM_NEXTDLGCTL,
                            (WPARAM)GETEDITBOXWND(hwnd),
                            (LPARAM)1L);
                frameboxSetText(GETEDITBOXWND(hwnd), (LPTSTR)achTime);
                /* now let's highlight the whole thing */

                HILIGHTEDITBOX(hwnd);

            } else
                MessageBeep(MB_ICONEXCLAMATION);
        } else if (LOWORD(wParam) == SB_LINEDOWN){
            if ((long)dwmSecs > (long)dwStart &&
                        (long)dwmSecs <= (long)dwEnd + gInc) {
                if ((long)dwmSecs - gInc < (long)dwStart)
                    dwmSecs = dwStart;
                else
                    dwmSecs -= gInc;
                wsprintf(achTime, TEXT("%ld"), dwmSecs);
                /* bring focus here NOW! so update works */
                SendMessage(hwnd,
                            WM_NEXTDLGCTL,
                            (WPARAM)GETEDITBOXWND(hwnd),
                            (LPARAM)1L);
                frameboxSetText(GETEDITBOXWND(hwnd), (LPTSTR)achTime);
                /* now let's highlight the whole thing */

                HILIGHTEDITBOX(hwnd);

            } else
                MessageBeep(MB_ICONEXCLAMATION);
        }
        // now update the world by sending the proper message

        SendMessage(GetParent(hwnd),
                    WM_COMMAND,
                    (WPARAM)MAKELONG((WORD)GETWINDOWID(hwnd), EN_KILLFOCUS),
                    (LPARAM)hwnd);

        return dwmSecs;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\fixreg.c ===
/*-----------------------------------------------------------------------------+
| FIXREG.C                                                                     |
|                                                                              |
| Publisher and Video For Windows make evil changes to the registry            |
| when they are installed.  Look for these changes.  If they are spotted       |
| then put up a message box to warn the user and offer the user the chance to  |
| correct them (i.e. stuff our version back in)                                |
|                                                                              |
| (C) Copyright Microsoft Corporation 1994.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    10-Aug-1994 Lauriegr Created.                                             |
|                                                                              |
+-----------------------------------------------------------------------------*/

#include <windows.h>
#include "mplayer.h"
#include "fixreg.h"
#include "registry.h"

/* The idea is to call CheckRegValues(hinst) on a separate thread
   (sort of backgroundy thing) and have it just die
   quietly if there's no problem.  If on the other hand there is a problem
   then we need to get the message box up - and it's a VERY BAD IDEA to
   try to put a message box up on anything other than the thread that's doing
   all the UI (otherwise ScottLu will get you with a weasle word - guaranteed).

   So the background thread should PostMessage (Post, don't Send - more weasles)
   to the main thread a message to say "WM_BADREG".  The main thread should then
   wack up the dialog box by calling FixRegValues.

   Suggested coding in main thread:

       BackgroundRegCheck(hwndmain);

   in window proc for hwndmain:
       case WM_HEYUP:
          // if ( IDOK == MessageBox(hwnd, text, appname, MB_OKCANCEL) )
          if ( IDOK == ErrorResBox(hwnd, NULL, MB_OKCANCEL, IDS_APPNAME, IDS_BADREG) )
              if (!SetRegValues())
                  Error(ghwndApp, IDS_FIXREGERROR);
*/

/* This is a reg setting to disable the check. */
extern  SZCODE aszOptionsSection[];
static  SZCODE aszIgnoreRegistryCheck[]   = TEXT("Ignore Registry Check");

/* These are the things we check up.

   First define them as static strings, since the compiler's not smart enough
   to spot common strings.

   NOTE - these values are NOT LOCALISED, except for the ones that are.
*/

#ifdef CHICAGO_PRODUCT
#define APPNAME TEXT("mplayer.exe")
#define WINDIR  TEXT("%s\\")  // To be replaced by Windows directory
LPTSTR pWindowsDirectory = NULL;
#else
#define APPNAME TEXT("mplay32.exe")
#define WINDIR
#endif
TCHAR szMPlayer[]                = TEXT("MPlayer");
TCHAR szMPlayer_CLSID[]          = TEXT("MPlayer\\CLSID");
TCHAR szMPOLE2GUID[]             = TEXT("{00022601-0000-0000-C000-000000000046}");
TCHAR szMPCLSID_OLE1GUID[]       = TEXT("CLSID\\{0003000E-0000-0000-C000-000000000046}");
TCHAR szMPStdExecute_Server[]    = TEXT("MPlayer\\protocol\\StdExecute\\server");
TCHAR szAppName[]                = WINDIR APPNAME;
TCHAR szMPShell_Open_Command[]   = TEXT("MPlayer\\shell\\open\\command");
TCHAR szAppName_Play_Close[]     = WINDIR APPNAME TEXT(" /play /close %1");
TCHAR szMPlayer_insertable[]     = TEXT("MPlayer\\insertable");
TCHAR szEmpty[]                  = TEXT("");
TCHAR szMPStdFileEdit_Handler[]  = TEXT("MPlayer\\protocol\\StdFileEditing\\handler");
#ifdef CHICAGO_PRODUCT
TCHAR szMCIOLE[]                 = WINDIR TEXT("mciole.dll");
#else
TCHAR szMCIOLE16[]               = TEXT("mciole16.dll");
TCHAR szMPStdFileEdit_Hand32[]   = TEXT("MPlayer\\protocol\\StdFileEditing\\handler32");
TCHAR szMCIOLE32[]               = TEXT("mciole32.dll");
#endif
TCHAR szMPStdFileEdit_Package[]  = TEXT("MPlayer\\protocol\\StdFileEditing\\PackageObjects");
TCHAR szMPStdFileEdit_Server[]   = TEXT("MPlayer\\protocol\\StdFileEditing\\server");
TCHAR szMPStdFileEdit_verb_0[]   = TEXT("MPlayer\\protocol\\StdFileEditing\\verb\\0");
TCHAR szMPStdFileEdit_verb_1[]   = TEXT("MPlayer\\protocol\\StdFileEditing\\verb\\1");

/* That sleazebag Publisher setup even farts around with these new settings!!
 */
TCHAR szAVIStdFileEdit_Server[]  = TEXT("AVIFile\\protocol\\StdFileEditing\\server");
TCHAR szMIDStdFileEdit_Server[]  = TEXT("MIDFile\\protocol\\StdFileEditing\\server");
TCHAR szServerAVI[]              = WINDIR APPNAME TEXT(" /avi");
TCHAR szServerMID[]              = WINDIR APPNAME TEXT(" /mid");

/* The following ones DO need to be localised.

   They will be loaded in CheckRegValues.
 */
#define RES_STR_LEN 40  /* Should be enough as a maximum resource string. */
TCHAR szMediaClip[RES_STR_LEN];  // IDS_CLASSROOT in resources
TCHAR sz_Play[RES_STR_LEN];      // IDS_PLAYVERB in resources
TCHAR sz_Edit[RES_STR_LEN];      // IDS_EDITVERB in resources

TCHAR szAviFile[] = TEXT("AVIFile");
TCHAR szMidFile[] = TEXT("MIDFile");


/* Array of registry value-data pairs to check:
 */
LPTSTR RegValues[] =
{
    szMPlayer,                szMediaClip,
    szMPlayer_CLSID,          szMPOLE2GUID,
    szMPCLSID_OLE1GUID,       szMediaClip,
    szMPStdExecute_Server,    szAppName,
    szMPShell_Open_Command,   szAppName_Play_Close,
    szMPlayer_insertable,     szEmpty,
#ifdef CHICAGO_PRODUCT
    szMPStdFileEdit_Handler,  szMCIOLE,
#else
    szMPStdFileEdit_Handler,  szMCIOLE16,
    szMPStdFileEdit_Hand32,   szMCIOLE32,
#endif
    szMPStdFileEdit_Package,  szEmpty,
    szMPStdFileEdit_Server,   szAppName,
    szMPStdFileEdit_verb_0,   sz_Play,
    szMPStdFileEdit_verb_1,   sz_Edit,

    aszKeyAVI,                szAviFile,
    aszKeyMID,                szMidFile,
    aszKeyRMI,                szMidFile,

    szAVIStdFileEdit_Server,  szServerAVI,
    szMIDStdFileEdit_Server,  szServerMID
};


#ifdef CHICAGO_PRODUCT

/* AllocWindowsDirectory
 *
 * Dynamically allocates a string containing the Windows directory.
 * This may be freed using FreeStr().
 *
 */
LPTSTR AllocWindowsDirectory()
{
    UINT   cchWinPath;
    LPTSTR pWindowsDirectory = NULL;

    cchWinPath = GetWindowsDirectory(NULL, 0);

    if (cchWinPath > 0)
    {
        if (pWindowsDirectory = AllocMem(cchWinPath * sizeof(TCHAR)))
        {
            cchWinPath = GetWindowsDirectory(pWindowsDirectory, cchWinPath);

            if (cchWinPath == 0)
            {
                /* Unlikely, but check anyway:
                 */
                DPF0("GetWindowsDiretory failed: Error %d\n", GetLastError());

                *pWindowsDirectory = TEXT('\0');
            }
        }
    }

    return pWindowsDirectory;
}

#endif


/* Check that a REG_SZ value in the registry has the value that it should do
   Return TRUE if it does, FALSE if it doesn't.
*/
BOOL CheckRegValue(HKEY RootKey, LPTSTR KeyName, LPTSTR ShouldBe)
{
    DWORD Type;
    TCHAR Data[100];
    DWORD cData = sizeof(Data);
    LONG lRet;
    HKEY hkey;


    if (ERROR_SUCCESS!=RegOpenKeyEx( RootKey
                                   , KeyName
                                   , 0  /* reserved */
                                   , KEY_QUERY_VALUE
                                   , &hkey
                                   )
       )
        return FALSE;  /* couldn't even open the key */


    lRet=RegQueryValueEx( hkey
                        , NULL /* ValueName */
                        , NULL  /* reserved */
                        , &Type
                        , (LPBYTE)Data
                        , &cData
                        );

    RegCloseKey(hkey);  /* no idea what to do if this fails */

    if (ERROR_SUCCESS!=lRet) return FALSE;  /* couldn't query it */

    /*  Data, cData and Type give the data, length and type */
    if (Type!=REG_SZ) return FALSE;
    lRet = lstrcmpi(Data,ShouldBe);  /* capture lRet to make debug easier */
    return 0==lRet;

} /* CheckRegValue */


/* check the registry for anything evil.  Return TRUE if it's OK else FALSE */
BOOL CheckRegValues(void)
{
    HKEY HCL = HKEY_CLASSES_ROOT;  /* save typing! */

    /* Now just check that the OLE2 class ID is correct
     */
    if( !CheckRegValue( HCL, szMPlayer_CLSID, szMPOLE2GUID ) )
        return FALSE;

    /* Running the old MPlayer on Chicago also screws up the
     * file-extension associations, so make sure they haven't changed:
     */
    if( !CheckRegValue( HCL, aszKeyAVI, szAviFile ) )
        return FALSE;

    return TRUE;

} /* CheckRegValues */


/* start this thread to get the registry checked out.
   hwnd is typed as a LPVOID because that's what CreateThread wants.
*/
DWORD WINAPI RegCheckThread(LPVOID hwnd)
{
   if (!CheckRegValues())
       PostMessage((HWND)hwnd, WM_BADREG, 0, 0);

   return 0;   /* end of thread! */
}


/* Call this with the hwnd that you want a WM_BADREG message posted to
   It will check the registry.  No news is good news.
   It does the work on a separate thread, so this should return quickly.
*/
void BackgroundRegCheck(HWND hwnd)
{
    HANDLE hThread;
    DWORD thid;
    hThread = CreateThread( NULL /* no special security */
                          , 0    /* default stack size */
                          , RegCheckThread
                          , (LPVOID)hwnd
                          , 0 /* start running at once */
                          , &thid
                          );
    if (hThread!=NULL) CloseHandle(hThread);  /* we don't need this any more */

    /* Else we're in some sort of trouble - dunno what to do.
       Can't think of an intelligible message to give to the user.
       Too bad.  Creep home quietly.
    */

} /* BackgroundRegCheck */


/* returns TRUE if it worked.  Dunno what to do if it didn't

*/
BOOL SetRegValue(HKEY RootKey, LPTSTR KeyName, LPTSTR ValueName, LPTSTR ShouldBe)
{
    HKEY hkey;

    if (ERROR_SUCCESS!=RegOpenKeyEx( RootKey
                                   , KeyName
                                   , 0  /* reserved */
                                   , KEY_SET_VALUE
                                   , &hkey
                                   )
       ) {
        /* Maybe the key has been DELETED - we've seen that */
        DWORD dwDisp;
        if (ERROR_SUCCESS!=RegCreateKeyEx( RootKey
                                         , KeyName
                                         , 0  /* reserved */
                                         , TEXT("") /* class */
                                         , REG_OPTION_NON_VOLATILE
                                         , KEY_SET_VALUE
                                         , NULL   /* SecurityAttributes */
                                         , &hkey
                                         , &dwDisp
                                       )
           ) /* well we're really in trouble */
           return FALSE;
        else /* So now it exists, but we now have to open it */
            if (ERROR_SUCCESS!=RegOpenKeyEx( RootKey
                                           , KeyName
                                           , 0  /* reserved */
                                           , KEY_SET_VALUE
                                           , &hkey
                                           )
               ) /* Give up */
                   return FALSE;

    }


    if (ERROR_SUCCESS!=RegSetValueEx( hkey
                                    , ValueName
                                    , 0  /* reserved */
                                    , REG_SZ
                                    , (LPBYTE)ShouldBe
                                    , (lstrlen(ShouldBe)+1)*sizeof(TCHAR)  /* BYTES */
                                    )
       )
        return FALSE;    /* couldn't set it */

    if ( ERROR_SUCCESS!=RegCloseKey(hkey) )
        /* no idea what to do!*/   ;    /* couldn't set it */

    /* I'm NOT calling RegFlushKey.  They'll get there eventually */

    return TRUE;

} /* SetRegValue */


/* Update the registry with the correct values.  Return TRUE if everything succeeds */
BOOL SetRegValues(void)
{
    HKEY HCL = HKEY_CLASSES_ROOT;  /* save typing! */
    DWORD i;
#ifdef CHICAGO_PRODUCT
    TCHAR Buffer[MAX_PATH+40];
#endif

    if( !( LOADSTRING( IDS_CLASSROOT, szMediaClip )
        && LOADSTRING( IDS_PLAYVERB, sz_Play )
        && LOADSTRING( IDS_EDITVERB, sz_Edit ) ) )
        /* If any of the strings fails to load, forget it:
         */
        return TRUE;

#ifdef CHICAGO_PRODUCT
    if (pWindowsDirectory == NULL)
    {
        if ((pWindowsDirectory = AllocWindowsDirectory()) == NULL)
            return TRUE;
    }
#endif

    for( i = 0; i < ( sizeof RegValues / sizeof *RegValues ); i+=2 )
    {
        /* Do a check to see whether this one needs changing,
         * to avoid gratuitous changes, and to avoid the slim chance
         * that an unnecessary SetRegValue might fail:
         */
#ifdef CHICAGO_PRODUCT
        /* Do substitution of Windows directory, if required.
         * This simply copies the value to the buffer unchanged
         * if it doesn't contain a replacement character.
         */
        wsprintf(Buffer, RegValues[i+1], pWindowsDirectory);

        if( !CheckRegValue( HCL, RegValues[i], Buffer ) )
#else
        if( !CheckRegValue( HCL, RegValues[i], RegValues[i+1] ) )
#endif
        {
#ifdef CHICAGO_PRODUCT
            DPF("Fixing the registry: Value - %"DTS"; Data - %"DTS"\n", RegValues[i], Buffer);
            if( !SetRegValue( HCL, RegValues[i], NULL, Buffer ) )
#else
            DPF("Fixing the registry: Value - %"DTS"; Data - %"DTS"\n", RegValues[i], RegValues[i+1]);
            if( !SetRegValue( HCL, RegValues[i], NULL, RegValues[i+1] ) )
#endif
                return FALSE;
        }
    }

#ifdef CHICAGO_PRODUCT
    FreeStr (pWindowsDirectory);
#endif

    return TRUE;

} /* SetRegValues */

BOOL IgnoreRegCheck()
{
    DWORD fIgnore = 0L;
    ReadRegistryData(aszOptionsSection
                     , aszIgnoreRegistryCheck
                     , NULL
                     , (LPBYTE)&fIgnore
                     , sizeof fIgnore);

    return (fIgnore != 0L);

} /* IgnoreRegCheck */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\init.c ===
/*-----------------------------------------------------------------------------+
| INIT.C                                                                       |
|                                                                              |
| This file houses the discardable code used at initialisation time. Among     |
| other things, this code reads .INI information and looks for MCI devices.    |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

/* include files */

#include <windows.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <stdlib.h>

#include <shellapi.h>
#include "mpole.h"
#include "mplayer.h"
#include "toolbar.h"
#include "registry.h"

DWORD   gfdwFlagsEx;

static SZCODE   aszMPlayer[]          = TEXT("MPlayer");

extern char szToolBarClass[];  // toolbar class

/*
 * Static variables
 *
 */

HANDLE  ghInstPrev;

TCHAR   gachAppName[40];            /* string holding the name of the app.    */
TCHAR   gachClassRoot[48];     /* string holding the name of the app. */
TCHAR   aszNotReadyFormat[48];
TCHAR   aszReadyFormat[48];
TCHAR   aszDeviceMenuSimpleFormat[48];
TCHAR   aszDeviceMenuCompoundFormat[48];
TCHAR   gachOpenExtension[5] = TEXT("");/* Non-null if a device extension passed in */
TCHAR   gachOpenDevice[128] = TEXT(""); /* Non-null if a device extension passed in */
TCHAR   gachProgID[128] = TEXT("");
CLSID   gClsID;
CLSID   gClsIDOLE1Compat;           /* For writing to IPersist - may be MPlayer's   */
                                    /* OLE1 class ID or same as gClsID.             */

TCHAR   gszMPlayerIni[40];          /* name of private .INI file              */
TCHAR   gszHelpFileName[_MAX_PATH]; /* name of the help file                  */
TCHAR   gszHtmlHelpFileName[_MAX_PATH]; /* name of the html help file         */

PTSTR   gpchFilter;                 /* GetOpenFileName() filter */
PTSTR   gpchInitialDir;             /* GetOpenFileName() initial directory */

RECT    grcSave;    /* size of mplayer before shrunk to */
                    /* play only size.                  */

int 	giDefWidth;

extern BOOL gfSeenPBCloseMsg;       //TRUE if the subclasses PlayBack WIndow Proc
                                    //has seen the WM_CLOSE message
////////////////////////////////////////////
// these strings *must* be in DGROUP!
static TCHAR    aszNULL[]       = TEXT("");
static TCHAR    aszAllFiles[]   = TEXT("*.*");
////////////////////////////////////////////

// strings for registration database - also referenced from fixreg.c
SZCODE aszKeyMID[]      = TEXT(".mid");
SZCODE aszKeyRMI[]      = TEXT(".rmi");
SZCODE aszKeyAVI[]      = TEXT(".avi");
SZCODE aszKeyMMM[]      = TEXT(".mmm");
SZCODE aszKeyWAV[]      = TEXT(".wav");

static  SZCODE aszFormatExts[]   = TEXT("%s;*.%s");
static  SZCODE aszFormatExt[]    = TEXT("*.%s");
static  SZCODE aszFormatFilter[] = TEXT("%s (%s)");
static  SZCODE aszPositionFormat[]= TEXT("%d,%d,%d,%d");

static  SZCODE aszSysIniTime[]      = TEXT("SysIni");
static  SZCODE aszDisplayPosition[] = TEXT("DisplayPosition");
        SZCODE aszOptionsSection[]  = TEXT("Options");
static  SZCODE aszShowPreview[]     = TEXT("ShowPreview");
static  SZCODE aszWinIni[]          = TEXT("win.ini");
        SZCODE aszIntl[]            = TEXT("intl");
        TCHAR  chDecimal            = TEXT('.');   /* localised in AppInit, GetIntlSpecs */
        TCHAR  chTime               = TEXT(':');   /* localised in AppInit, GetIntlSpecs */
        TCHAR  chLzero              = TEXT('1');

static SZCODE   gszWinIniSection[]  = TEXT("MCI Extensions"); /* section name in WIN.INI*/
static SZCODE   aszSystemIni[]      = TEXT("SYSTEM.INI");

#ifdef CHICAGO_PRODUCT
static SZCODE   gszSystemIniSection[] = TEXT("MCI");
#else
static SZCODE   gszSystemIniSection[] = MCI_SECTION;
#endif

static SZCODE   aszBlank[] = TEXT(" ");

static SZCODE   aszDecimalFormat[] = TEXT("%d");
static SZCODE   aszTrackClass[] = TEXT("MPlayerTrackMap");

extern HMENU    ghMenu;                      /* handle to main menu           */
extern HMENU    ghDeviceMenu;                /* handle to the Device menu     */
extern UINT     gwCurScale;                  /* current scale style           */
extern HANDLE   hAccel;
extern int      gcAccelEntries;


/* private function prototypes */
void  NEAR PASCAL QueryDevices(void);
void  NEAR PASCAL BuildDeviceMenu(void);
void  NEAR PASCAL ReadDefaults(void);
void  NEAR PASCAL BuildFilter(void);
BOOL PostOpenDialogMessage(void);

extern  BOOL InitServer(HWND, HANDLE);
extern  BOOL InitInstance (HANDLE);

/**************************************************************************

ScanCmdLine  checks first for the following options
-----------
    Open
    Play Only
    Close After Playing
    Embedded (play as a server)
    If the embedded flag is set, then the play only is also set.
    It then removes these options from the cmd line
    If no filename is present then turn close option off, and set the play
    option to have the same value as the embedded option
    If /WAVE, /MIDI or /VFW is specified along with /file,
    the file extension must match, otherwise the app exits.


MPLAYER command options.

        MPLAYER [/open] [/play] [/close] [/embedding] [/WAV] [/MID] [/AVI] [file]

            /open       open file if specified, otherwise put up dialog.
            /play       play file right away.
            /close      close after playing. (only valid with /play)
            /embedding  run as an OLE server.
            /WAV        open a wave file \
            /MID        open a midi file  > Valid with /open
            /AVI        open an AVI file /
            [file]      file or device to open.

***************************************************************************/

static  SZCODE aszEmbedding[]         = TEXT("Embedding");
static  SZCODE aszPlayOnly[]          = TEXT("Play");
static  SZCODE aszClose[]             = TEXT("Close");
static  SZCODE aszOpen[]              = TEXT("Open");
static  SZCODE aszWAVE[]              = TEXT("WAVE");
static  SZCODE aszMIDI[]              = TEXT("MIDI");
static  SZCODE aszVFW[]               = TEXT("VFW");

BOOL NEAR PASCAL ScanCmdLine(LPTSTR szCmdLine)
{
    int         i;
    TCHAR       buf[100];
    LPTSTR      sz=szCmdLine;

    gfPlayOnly = FALSE;
    gfCloseAfterPlaying = FALSE;
    gfRunWithEmbeddingFlag = FALSE;

    while (*sz == TEXT(' '))
        sz++;

    while (*sz == TEXT('-') || *sz == TEXT('/')) {

        for (i=0,sz++; *sz && *sz != TEXT(' ') && (i < 99); buf[i++] = *sz++)
            ;
        buf[i++] = 0;

        if (!lstrcmpi(buf, aszPlayOnly)) {
            gfPlayOnly = TRUE;
        }

        if (!lstrcmpi(buf, aszOpen))
            gfOpenDialog = TRUE;

        /* Check for open option, but accept only the first: */

        if (!gachOpenDevice[0]
           && (GetProfileString(gszWinIniSection, buf, aszNULL, gachOpenDevice,
                                CHAR_COUNT(gachOpenDevice)) > 0))
        {
            /* Take a copy of the extension, which we will use to find stuff
             * in the registry relating to OLE:
             */
            gachOpenExtension[0] = TEXT('.');
            lstrcpy(&gachOpenExtension[1], buf);
        }

        if (!lstrcmpi(buf, aszClose))
            gfCloseAfterPlaying = TRUE;

        if (!lstrcmpi(buf, aszEmbedding))
            gfRunWithEmbeddingFlag = TRUE;

        if (gfRunWithEmbeddingFlag) {
            gfPlayOnly = TRUE;
        }

        while (*sz == TEXT(' '))
            sz++;
    }

    /*
    ** Do we have a long file name with spaces in it ?
    ** This is most likely to have come from the FileMangler.
    ** If so copy the file name without the quotes.
    */
    if ( *sz == TEXT('\'') || *sz == TEXT('\"') ) {

        TCHAR ch = *sz;   // Remember which quote character it was
        // According to the DOCS " is invalid in a filename...

        i = 0;
        /* Move over the initial quote, then copy the filename */
        while ( *++sz && *sz != ch ) {

            szCmdLine[i++] = *sz;
        }

        szCmdLine[i] = TEXT('\0');

    }
    else {

        lstrcpy( szCmdLine, sz );     // remove options
    }

    // It's assumed that OLE2 servers don't accept file name
    // with -Embedding.
    // (Not doing this caused Win95 bug 4096 with OLE1 apps,
    // because MPlayer loaded the file, and, in the meantime,
    // OLE called PFLoad, resulting in OpenMCI being called
    // recursively.)
    if (gfRunWithEmbeddingFlag)
        szCmdLine[0] = TEXT('\0');

    //
    // if there's /play, make sure there's /open
    // (this may affect the checks below)
    //
    if (gfPlayOnly && !gfRunWithEmbeddingFlag)
        gfOpenDialog = TRUE;

    //
    // if no file specifed ignore the /play option
    //
    if (szCmdLine[0] == 0 && !gfOpenDialog) {
        gfPlayOnly = gfRunWithEmbeddingFlag;
    }

    //
    // if file specifed ignore the /open option
    //
    if (szCmdLine[0] != 0) {
        gfOpenDialog = FALSE;
    }

    if (!gfPlayOnly && szCmdLine[0] == 0)
        gfCloseAfterPlaying = FALSE;

    SetEvent(heventCmdLineScanned);

    return gfRunWithEmbeddingFlag;
}


BOOL ResolveIfLink(PTCHAR szFileName);


BOOL ProgIDFromExtension(LPTSTR szExtension, LPTSTR szProgID, DWORD BufSize /* in BYTES */)
{
    DWORD Status;
    HKEY  hkeyExtension;
    BOOL  rc = FALSE;
    DWORD Type;
    DWORD Size;

    Status = RegOpenKeyEx( HKEY_CLASSES_ROOT, szExtension, 0,
                           KEY_READ, &hkeyExtension );

    if (Status == NO_ERROR)
    {
        Size = BufSize;

        Status = RegQueryValueEx( hkeyExtension,
                                  aszNULL,
                                  0,
                                  &Type,
                                  (LPBYTE)szProgID,
                                  &Size );

        if (Status == NO_ERROR)
        {
            rc = TRUE;
        }
        else
        {
            DPF0("Couldn't find ProgID for extension %"DTS"\n", szExtension);
        }

        RegCloseKey(hkeyExtension);
    }

    return rc;
}


BOOL GetClassNameFromProgID(LPTSTR szProgID, LPTSTR szClassName, DWORD BufSize /* in BYTES */)
{
    DWORD Status;
    HKEY  hkeyProgID;
    BOOL  rc = FALSE;
    DWORD Type;
    DWORD Size;

    Status = RegOpenKeyEx( HKEY_CLASSES_ROOT, szProgID, 0,
                           KEY_READ, &hkeyProgID );

    if (Status == NO_ERROR)
    {
        Size = BufSize;

        Status = RegQueryValueEx( hkeyProgID,
                                  aszNULL,
                                  0,
                                  &Type,
                                  (LPBYTE)szClassName,
                                  &Size );

        if (Status == NO_ERROR)
        {
            DPF1("Found Class Name %"DTS" for ProgID %"DTS"\n", szClassName, szProgID);
            rc = TRUE;
        }
        else
        {
            DPF0("Couldn't find Class Name for ProgID %"DTS"\n", szProgID);
        }

        RegCloseKey(hkeyProgID);
    }

    return rc;
}


/**************************************************************************
***************************************************************************/
BOOL FAR PASCAL ProcessCmdLine(HWND hwnd, LPTSTR szCmdLine)
{
    BOOL   f;
    LPTSTR lp;
    SCODE  status;
    CLSID  ClsID;
    LPWSTR pUnicodeProgID;

    if (gfRunWithEmbeddingFlag)
    {
        srvrMain.cRef++;

        gClsID = CLSID_MPLAYER;
        gClsIDOLE1Compat = CLSID_OLE1MPLAYER;

        if (*gachOpenExtension)
        {
            /* We accept as a parameter the extension of a registered type.
             * If we can find a corresponding Prog ID in the registry and
             * a class ID, we register ourselves with that class ID:
             */
            if(ProgIDFromExtension(gachOpenExtension, gachProgID, CHAR_COUNT(gachProgID)))
            {
#ifndef UNICODE
                pUnicodeProgID = AllocateUnicodeString(gachProgID);
#else
                pUnicodeProgID = gachProgID;
#endif
                if (CLSIDFromProgID(pUnicodeProgID, &ClsID) == S_OK)
                {
                    /* No OLE1 compatibility for this class:
                     */
                    gClsID = gClsIDOLE1Compat = ClsID;
                }
                else
                {
                    DPF0("Couldn't get CLSID for %"DTS"\n", gachProgID);
                }
#ifndef UNICODE
                FreeUnicodeString(pUnicodeProgID);
#endif
            }
        }

        if (*gachProgID)
            GetClassNameFromProgID(gachProgID, gachClassRoot, CHAR_COUNT(gachClassRoot));
        else
            LOADSTRING(IDS_CLASSROOT, gachClassRoot);

        status = GetScode(CoRegisterClassObject(&gClsID, (IUnknown FAR *)&srvrMain,
                                                CLSCTX_LOCAL_SERVER,
                                                REGCLS_SINGLEUSE, &srvrMain.dwRegCF));

        DPF("CoRegisterClassObject\n");
        srvrMain.cRef--;
        if (status  != S_OK)
        {
            DPF0("CoRegisterClassObject failed with error %08x\n", status);

            return FALSE;
        }
    }
    else
        InitNewDocObj(&docMain);

    if (gfRunWithEmbeddingFlag)
        SetEmbeddedObjectFlag(TRUE);

    if (*szCmdLine != 0)
    {
        HCURSOR    hcurPrev;

        InitDeviceMenu();
        hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));
        WaitForDeviceMenu();
        SetCursor(hcurPrev);

        ResolveIfLink(szCmdLine);

        /* Change trailing white space to \0 because mci barfs on filenames */
        /* with trailing whitespace.                                        */
        for (lp = szCmdLine; *lp; lp++);
        for (lp--; *lp == TEXT(' ') || *lp == TEXT('\t'); *lp = TEXT('\0'), lp--);

        f = OpenMciDevice(szCmdLine, NULL);

        if (f)
            CreateDocObjFromFile(szCmdLine, &docMain);

        if (gfRunWithEmbeddingFlag && !f) {
            DPF0("Error opening link, quiting...");
            PostMessage(ghwndApp, WM_CLOSE, 0, 0);
        }

        SetMPlayerIcon();

        return f;
    }

    return TRUE;
}


/**************************************************************************
***************************************************************************/

/* At time of writing, this stuff isn't in Daytona;
 */
#ifndef WS_EX_LEFTSCROLLBAR
#define WS_EX_LEFTSCROLLBAR   0
#define WS_EX_RIGHT           0
#define WS_EX_RTLREADING      0
#endif

BOOL FAR PASCAL AppInit(HANDLE hInst, HANDLE hPrev, LPTSTR szCmdLine)
{
    WNDCLASS    cls;    /* window class structure used for initialization     */
    TCHAR       ach[80];
    HCURSOR     hcurPrev;           /* the pre-hourglass cursor   */

    /* Get the debug level from the WIN.INI [Debug] section. */

#ifdef DEBUG
     if(__iDebugLevel == 0) // So we can set it in the debugger
          __iDebugLevel = GetProfileIntA("Debug", "MPlayer", 0);
      DPF("debug level %d\n", __iDebugLevel);
#endif

    DPF("AppInit: cmdline = '%"DTS"'\n", (LPTSTR)szCmdLine);

    /* Save the instance handle in a global variable for later use. */

    ghInst     = hInst;


    /* Retrieve the RTL state of the binary */

    LOADSTRING(IDS_IS_RTL, ach);
    gfdwFlagsEx = (ach[0] == TEXT('1')) ? WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT | WS_EX_RTLREADING : 0;

    LOADSTRING(IDS_MPLAYERWIDTH, ach);
    giDefWidth = ATOI(ach);
    if (giDefWidth <= 0)	//bogus
    	giDefWidth = DEF_WIDTH;

    /* Retrieve the name of the application and store it in <gachAppName>. */

    if (!LOADSTRING(IDS_APPNAME, gachAppName))
        return Error(ghwndApp, IDS_OUTOFMEMORY);

    LOADSTRING(IDS_DEVICEMENUCOMPOUNDFORMAT, aszDeviceMenuCompoundFormat);
    LOADSTRING(IDS_DEVICEMENUSIMPLEFORMAT, aszDeviceMenuSimpleFormat);
    LOADSTRING(IDS_NOTREADYFORMAT, aszNotReadyFormat);
    LOADSTRING(IDS_READYFORMAT, aszReadyFormat);
    LoadStatusStrings();

    //
    // read needed things from the [Intl] section of WIN.INI
    //
    GetIntlSpecs();

    /* Enable / disable the buttons, and display everything */
    /* unless we were run as an OLE server....*/

    ScanCmdLine(szCmdLine);
    gszCmdLine = szCmdLine;

    //Truncate if string is longer than MAX_PATH after ScanCmdLine()
    // due to the inability to handle longer strings in following modules
    if (STRLEN(gszCmdLine) >= MAX_PATH)
    {
        gszCmdLine[MAX_PATH - 1] = TEXT('\0');
    }

    if (!toolbarInit() ||
        !InitMCI(hPrev, hInst)    ||
        !ControlInit (hInst)) {

        Error(NULL, IDS_OUTOFMEMORY);
        return FALSE;
    }

    if (!(hAccel = LoadAccelerators(hInst, MAKEINTRESOURCE(MPLAYERACCEL)))) {
        Error(NULL, IDS_OUTOFMEMORY);
        return FALSE;
    }

    /* This rather obscure call is to get the number of entries
     * in the accelerator table to pass to IsAccelerator.
     * It isn't entirely obvious why IsAccelerator needs to be
     * told how many entries there are.
     */
    if (gfRunWithEmbeddingFlag)
        gcAccelEntries = CopyAcceleratorTable(hAccel, NULL, 0);

    /* Make the dialog box's icon identical to the MPlayer icon */

    hiconApp = LoadIcon(ghInst, MAKEINTRESOURCE(APPICON));

    if (!hPrev) {

        cls.lpszClassName   = aszTrackClass;
        cls.lpfnWndProc     = fnMPlayerTrackMap;
        cls.style           = CS_VREDRAW;
        cls.hCursor         = LoadCursor(NULL,IDC_ARROW);
        cls.hIcon           = NULL;
        cls.lpszMenuName    = NULL;
        cls.hbrBackground   = (HBRUSH)(COLOR_WINDOW + 1);
        cls.hInstance       = ghInst;
        cls.cbClsExtra      = 0;
        cls.cbWndExtra      = 0;

        RegisterClass(&cls);

        /*
         * Initialize and register the "MPlayer" class.
         *
         */
        cls.lpszClassName   = aszMPlayer;
        cls.lpfnWndProc     = MPlayerWndProc;
        cls.style           = CS_VREDRAW;
        cls.hCursor         = LoadCursor(NULL,IDC_ARROW);
        cls.hIcon           = hiconApp;
        cls.lpszMenuName    = NULL;
        cls.hbrBackground   = (HBRUSH)(COLOR_BTNFACE + 1);
        cls.hInstance       = ghInst;
        cls.cbClsExtra      = 0;
        cls.cbWndExtra      = DLGWINDOWEXTRA;

        RegisterClass(&cls);
    }

    // set ghInstPrev to the handle of the first mplayer instance by
    // FindWindow (hPrev will always be NULL). This global is checked
    // by window positioning code to behave differently for the second
    // and subsequent instances - so make sure it is NULL in the first case
    // and non-null in the others.
    // note we can't check for the window title, only the class, since
    // in play-only mode, the window title is *just* the name of the file.
    ghInstPrev = FindWindow(aszMPlayer, NULL);


    /*
     * Retain a pointer to the command line parameter string so that the player
     * can automatically open a file or device if one was specified on the
     * command line.
     *
     */

    if(!InitInstance (hInst))
        return FALSE;

    gwHeightAdjust = 2 * GetSystemMetrics(SM_CYFRAME) +
                     GetSystemMetrics(SM_CYCAPTION) +
                     GetSystemMetrics(SM_CYBORDER) +
                     GetSystemMetrics(SM_CYMENU);

    /* create the main (control) window                   */


    ghwndApp = CreateWindowEx(gfdwFlagsEx,
                              aszMPlayer,
                              gachAppName,
                              WS_THICKFRAME | WS_OVERLAPPED | WS_CAPTION |
                              WS_CLIPCHILDREN | WS_SYSMENU | WS_MINIMIZEBOX,
                              CW_USEDEFAULT,
                              0,
                              giDefWidth,
                              MAX_NORMAL_HEIGHT + gwHeightAdjust,
                              NULL,   // no parent
                              NULL,   // use class menu
                              hInst,  // instance
                              NULL);  // no data
    if (!ghwndApp) {
        DPF0("CreateWindowEx failed for main window: Error %d\n", GetLastError());
        return FALSE;
    }

    DPF("\n**********After create set\n");
/****
  Removed from WM_CREATE so that it can be called similar to the way sdemo1
  i.e. after the create window call has completed
      May be completely unnecessary
*****/

    /* Process dragged and dropped file */
    DragAcceptFiles(ghwndApp, TRUE);

    /* We will check that this has been filled in before calling
     * CoDisconnectObject.  It should be non-null if an instance of the OLE
     * server has been created.
     */
    docMain.hwnd = NULL;

    /* Initialize the OLE server if appropriate.
     * If we don't initialize OLE here, a Copy will cause it to be initialized:
     */
    if (gfRunWithEmbeddingFlag)
    {
        if (InitOLE(&gfOleInitialized, &lpMalloc))
            InitServer(ghwndApp, ghInst);
        else
            return FALSE;
    }

    if (!gfRunWithEmbeddingFlag && (!gfPlayOnly || gszCmdLine[0]==0) && !gfOpenDialog)
    {
        ShowWindow(ghwndApp,giCmdShow);
        if (giCmdShow != SW_SHOWNORMAL)
            Layout();
        UpdateDisplay();
        UpdateWindow(ghwndApp);
    }

    /* Show the 'Wait' cursor in case this takes a long time */

    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    /*
     * Read the SYSTEM.INI and MPLAYER.INI files to see what devices
     * are available.
     */
    if (gfPlayOnly)
        garMciDevices[0].wDeviceType  = DTMCI_CANPLAY | DTMCI_FILEDEV;

    //
    // this may open a file....
    //

    if (!ProcessCmdLine(ghwndApp,gszCmdLine)) {
        DPF0("ProcessCmdLine failed\n");
        return FALSE;
    }

    /* Restore the original cursor */
    if (hcurPrev)
        SetCursor(hcurPrev);


    /* Check for options to put up initial dialog etc.:
     */
    if (gfOpenDialog)
    {
        if (!PostOpenDialogMessage())
        {
            PostMessage(ghwndApp, WM_CLOSE, 0, 0);
            return FALSE;
        }
    }


    /* The "Play" button should have the focus initially */

    if (!gfRunWithEmbeddingFlag && !gfOpenDialog)
    {
        //SetFocus(ghwndToolbar); //setting focus messes up the menu access
								  //using the ALT key

                                // HACK!!! Want play button
        if (gfPlayOnly) {

            if (gwDeviceID == (UINT)0 || !(gwDeviceType & DTMCI_CANWINDOW)) {
                gfPlayOnly = FALSE;
                SizeMPlayer();
            }

            ShowWindow(ghwndApp,giCmdShow);

            if (giCmdShow != SW_SHOWNORMAL)
                Layout();

            /* stop any system sound from playing so the MCI device
               can have it HACK!!!! */
            sndPlaySound(NULL, 0);

            if (gwDeviceID)
                PostMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_PLAY, 0);
        }
    }

    return TRUE;
}


/* PostOpenDialogMessage
 *
 * This routine is called if /open was in the command line.
 * If there was also an open option (/MIDI, /VFW or /WAVE in the command line,
 * it causes an Open dialog to be displayed, as would appear via the Device menu.
 * Otherwise it simulates File.Open.
 *
 * When this is called, the main window is hidden.  The window must be made
 * visible when the dialog is dismissed.  Calling CompleteOpenDialog(TRUE)
 * will achieve this.
 *
 * Returns TRUE if a message was posted, otherwise FALSE.
 *
 *
 * Global variables referenced:
 *
 *     gachOpenExtension
 *     ghwndApp
 *
 *
 * Andrew Bell, 1 July 1994
 *
 */
BOOL PostOpenDialogMessage( )
{
    BOOL Result = TRUE;

    InitDeviceMenu();
    WaitForDeviceMenu();

    if (*gachOpenExtension)
    {
        if (gwNumDevices)
        {
            /* If we've got here, the user specified a device, and that's
             * the only one the Device menu lists, so go ahead and open it:
             */
            PostMessage(ghwndApp, WM_COMMAND, IDM_DEVICE0 + 1, 0);
        }
        else
        {
            /* Couldn't find a device.  Put up an error message then close
             * MPlayer down:
             */
            SendMessage(ghwndApp, WM_NOMCIDEVICES, 0, 0);

            Result = FALSE;
        }
    }
    else
    {
        /* No option specified, so put up the generic open dialog:
         */
        PostMessage(ghwndApp, WM_COMMAND, IDM_OPEN, 0);
    }

    return Result;
}


/* CompleteOpenDialog
 *
 * This should be called after the initial Open dialog (i.e. if gfOpenDialog
 * is TRUE).  It makes MPlayer visible if a file was selected, otherwise posts
 * a close message to the app.
 *
 *
 * Global variables referenced:
 *
 *     ghwndApp
 *     gfOpenDialog
 *     gfPlayOnly
 *
 *
 * Andrew Bell, 1 July 1994
 */
VOID FAR PASCAL CompleteOpenDialog(BOOL FileSelected)
{
    if (FileSelected)
    {
        /* We were invoked with /open, and came up invisible.
         * Now make ourselves visible:
         */
        gfOpenDialog = FALSE; // Used on init only
        ShowWindow(ghwndApp, SW_SHOWNORMAL);
        if (gfPlayOnly)
            PostMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_PLAY, 0);
    }
    else
    {
        /* We were invoked with /open, and user cancelled
         * out of the open dialog.
         */
        PostMessage(ghwndApp, WM_CLOSE, 0, 0);
    }
}



void SubClassTrackbarWindow();
void CreateControls()
{
    int         i;

    #define APP_NUMTOOLS 7

    static  int aiButton[] = { BTN_PLAY, BTN_STOP,BTN_EJECT,
                               BTN_HOME, BTN_RWD, BTN_FWD,BTN_END};

    /*
     * CREATE THE CONTROLS NEEDED FOR THE CONTROL PANEL DISPLAY
     * in the proper order so tabbing z-order works logically
     */

/******* Make the Track bar ********/

    if (!ghwndTrackbar)
    ghwndTrackbar = CreateWindowEx(gfdwFlagsEx,
                             TRACKBAR_CLASS,
                             NULL,
                             TBS_ENABLESELRANGE |
                             (gfPlayOnly ? TBS_BOTH | TBS_NOTICKS : 0 ) |
                             WS_CLIPSIBLINGS | WS_CHILD | WS_VISIBLE | WS_TABSTOP,
                             0,
                             0,
                             0,
                             0,
                             ghwndApp,
                             NULL,
                             ghInst,
                             NULL);


    SubClassTrackbarWindow();


/******* Make the TransportButtons Toolbar ********/
    if (!ghwndToolbar) {

    ghwndToolbar =  toolbarCreateMain(ghwndApp);
#if 0 //VIJR-TB

    CreateWindowEx(gfdwFlagsEx,
                   szToolBarClass,
                   NULL,
                   WS_CHILD | WS_VISIBLE | WS_TABSTOP |
                   WS_CLIPSIBLINGS,
                   0,
                   0,
                   0,
                   0,
                   ghwndApp,
                   NULL,
                   ghInst,
                   NULL);
#endif
        /* set the bitmap and button size to be used for this toolbar */
#if 0 //VIJR-TB
        pt.x = BUTTONWIDTH;
        pt.y = BUTTONHEIGHT;
        toolbarSetBitmap(ghwndToolbar, ghInst, IDBMP_TOOLBAR, pt);
#endif
        for (i = 0; i < 2; i++) {
            toolbarAddTool(ghwndToolbar, aiButton[i], TBINDEX_MAIN, BTNST_UP);
        }
    }

    /* Create a font for use in the track map and embedded object captions. */

    if (ghfontMap == NULL) {
        LOGFONT lf;
        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), (LPVOID)&lf,
                             0);
        ghfontMap = CreateFontIndirect(&lf);
    }

/******* we have been here before *******/
    if (ghwndFSArrows)
        return;

/******* add more buttons to the toolbar ******/
    for (i = 2; i < APP_NUMTOOLS; i++) {
        if (i==3)
            toolbarAddTool(ghwndToolbar, BTN_SEP, TBINDEX_MAIN, 0);
        toolbarAddTool(ghwndToolbar, aiButton[i], TBINDEX_MAIN, BTNST_UP);
    }

/******* load menus ********/
    /* Set up the menu system for this dialog */
    if (ghMenu == NULL)
        ghMenu = LoadMenu(ghInst, aszMPlayer);

    ghDeviceMenu = GetSubMenu(ghMenu, 2);

/******* Make the Arrows for the Scrollbar Toolbar ********/

    // No tabstop, because arrows would steal focus from thumb
    ghwndFSArrows = toolbarCreateArrows(ghwndApp);
#if 0 //VIJR-TB

    CreateWindowEx(gfdwFlagsEx,
                   szToolBarClass,
                   NULL,
                   WS_CLIPSIBLINGS | WS_CHILD|WS_VISIBLE,
                   0,
                   0,
                   0,
                   0,
                   ghwndApp,
                   NULL,
                   ghInst,
                   NULL);
#endif
    /* set the bmp and button size to be used for this toolbar*/
    toolbarAddTool(ghwndFSArrows, ARROW_PREV, TBINDEX_ARROWS, BTNST_UP);
    toolbarAddTool(ghwndFSArrows, ARROW_NEXT, TBINDEX_ARROWS, BTNST_UP);

/******* Make the Mark In / Mark Out toolbar ********/

    ghwndMark =  toolbarCreateMark(ghwndApp);
#if 0 //VIJR-TB
    CreateWindowEx(gfdwFlagsEx,
                   szToolBarClass,
                   NULL,
                   WS_TABSTOP | WS_CLIPSIBLINGS | WS_CHILD |
                   WS_VISIBLE,
                   0,
                   0,
                   0,
                   0,
                   ghwndApp,
                   NULL,
                   ghInst,
                   NULL);
#endif
    /* set the bmp and button size to be used for this toolbar */
    toolbarAddTool(ghwndMark, BTN_MARKIN, TBINDEX_MARK, BTNST_UP);
    toolbarAddTool(ghwndMark, BTN_MARKOUT, TBINDEX_MARK, BTNST_UP);

/******* Make the Map ********/
    ghwndMap =
    CreateWindowEx(gfdwFlagsEx,
                   TEXT("MPlayerTrackMap"),
                   NULL,
                   WS_GROUP | WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS,
                   0,
                   0,
                   0,
                   0,
                   ghwndApp,
                   NULL,
                   ghInst,
                   NULL);

#if DBG
    if( ghwndMap == NULL)
    {
        DPF0( "CreateWindowEx(MPlayerTrackMap, ...) failed: Error %d\n", GetLastError());
    }
#endif

/******* Make the Static Text ********/

    ghwndStatic = CreateStaticStatusWindow(ghwndApp, FALSE);
#if 0    //VIJR-SB
    CreateWindowEx(gfdwFlagsEx,
                   TEXT("SText"),
                   NULL,
                   WS_GROUP | WS_CHILD | WS_VISIBLE |
                   WS_CLIPSIBLINGS | SS_LEFT,
                   0,
                   0,
                   0,
                   0,
                   ghwndApp,
                   NULL,
                   ghInst,
                   NULL);
#endif
////SetWindowText(ghwndStatic, TEXT("Scale: Time (hh:mm)"));

    SendMessage(ghwndStatic, WM_SETFONT, (UINT_PTR)ghfontMap, 0);
}

void FAR PASCAL InitMPlayerDialog(HWND hwnd)
{
    ghwndApp = hwnd;

    CreateControls();

    /* Get the name of the Help and ini file */

    LOADSTRING(IDS_INIFILE, gszMPlayerIni);
    LOADSTRING(IDS_HELPFILE,gszHelpFileName);
    LOADSTRING(IDS_HTMLHELPFILE,gszHtmlHelpFileName);

    ReadDefaults();


}


/* Use a default size or the size we pass in to size mplayer.
 * For PlayOnly version, this size is the MCI Window Client size.
 * For regular mplayer, this is the full size of the main window.
 * If we are inplace editing do the same as for PLayOnly.
 */
void FAR PASCAL SetMPlayerSize(LPRECT prc)
{
    RECT rc;
    UINT w=SWP_NOMOVE;

    if (prc && !IsRectEmpty(prc))
        rc = *prc;
    else if (gfPlayOnly || gfOle2IPEditing)
        rc = grcSize;
    else
        SetRect(&rc, 0, 0, giDefWidth, DEF_HEIGHT);

    //
    //  if the passed rectangle has a non zero (left,top) move MPlayer
    //  also (ie remove the SWP_NOMOVE flag)
    //
    if (rc.left != 0 || rc.top != 0)
        w = 0;

    if (gfPlayOnly || gfOle2IPEditing) {
        if (IsRectEmpty(&rc)) {
            GetClientRect(ghwndApp, &rc);
            rc.bottom = 0;
        }

        rc.bottom += TOOLBAR_HEIGHT;

        AdjustWindowRect(&rc,
                         (DWORD)GetWindowLongPtr(ghwndApp, GWL_STYLE),
                         GetMenu(ghwndApp) != NULL);
    }
    else
       if (gfWinIniChange)
       AdjustWindowRect(&rc,
                         (DWORD)GetWindowLongPtr(ghwndApp, GWL_STYLE),
             GetMenu(ghwndApp) != NULL);

    SetWindowPos(ghwndApp,
                 HWND_TOP,
                 rc.left,
                 rc.top,
                 rc.right-rc.left,
                 rc.bottom-rc.top,
                 w | SWP_NOZORDER | SWP_NOACTIVATE);
}


/* InitDeviceMenuThread
 *
 * This is now executed as a separate thread.
 * On completion, sets the event so that the File and Device menus
 * can be accessed.
 * If, after querying the devices, we find none, post a message to
 * the main window to inform it.
 */
void InitDeviceMenuThread(LPVOID pUnreferenced)
{
    UNREFERENCED_PARAMETER(pUnreferenced);

    /* Wait until the command line has been scanned:
     */
    WaitForSingleObject(heventCmdLineScanned, INFINITE);

    /* We don't need this event any more:
     */
    CloseHandle(heventCmdLineScanned);

    if (ghMenu == NULL) {
        ghMenu = LoadMenu(ghInst, aszMPlayer);
        ghDeviceMenu = GetSubMenu(ghMenu, 2);
    }

    QueryDevices();
    BuildDeviceMenu();
    BuildFilter();

    if (gwDeviceID)
        FindDeviceMCI();

    SetEvent(heventDeviceMenuBuilt);

    if (gwNumDevices == 0)
        PostMessage(ghwndApp, WM_NOMCIDEVICES, 0, 0);

    ExitThread(0);
}

/* InitDeviceMenu
 *
 * Initialize and build the Devices menu.
 *
 * This now spins off a separate thread to enable the UI to come up
 * more quickly.  This is especially important when there is a slow
 * CD device installed, though crappy CD drivers which run single threaded
 * at dispatch level will still give performance degradation.
 *
 * If the user selects either the File or the Device menu, the UI
 * must wait until the device menu has been built.  Typically this
 * should not be longer than about 2 seconds after the app started.
 *
 */
void FAR PASCAL InitDeviceMenu()
{
    DWORD       ThreadID;
    HANDLE      hThread;
    static BOOL CalledOnce = FALSE;

    /* This should only ever be called by the main thread, so we don't need
     * to protect access to CalledOnce:
     */
    if (CalledOnce == FALSE)
    {
        CalledOnce = TRUE;

#ifdef DEBUG
        if (WaitForSingleObject(heventDeviceMenuBuilt, 0) == WAIT_OBJECT_0)
            DPF0("Expected heventDeviceMenuBuilt to be non-signaled\n");
#endif
        hThread = CreateThread(NULL,    /* Default security attributes */
                               0,       /* Stack size same as primary thread's */
                               (LPTHREAD_START_ROUTINE)InitDeviceMenuThread,
                               NULL,    /* Parameter to start routine */
                               0,       /* Thread runs immediately */
                               &ThreadID);

        if(hThread)
            CloseHandle(hThread);
        else
        {
            DPF0("CreateThread failed");

            /* This is unlikely to happen, but the only thing to do
             * is set the event, so that the UI doesn't hang.
             */
            SetEvent(heventDeviceMenuBuilt);

            /* What if SetEvent failed?!
             */
        }
    }
}


/* WaitForDeviceMenu
 *
 * This routine calls MsgWaitForMultipleObjects instead of WaitForSingleObject
 * because some MCI devices do things like realizing palettes, which may
 * require some messages to be dispatched.  Otherwise we can hit a deadlock.
 *
 * Andrew Bell (andrewbe), 8 April 1995
 */
void WaitForDeviceMenu()
{
    DWORD Result;

    while ((Result = MsgWaitForMultipleObjects(1,
                                               &heventDeviceMenuBuilt,
                                               FALSE,
                                               INFINITE,
                                               QS_ALLINPUT)) != WAIT_OBJECT_0)
    {
        MSG msg;

        if (Result == (DWORD)-1)
        {
            DPF0("MsgWaitForMultipleObjects failed: Error %d\n", GetLastError());
            return;
        }

        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            DispatchMessage(&msg);
    }
}



/*
 * SizeMPlayer()
 *
 */
void FAR PASCAL SizeMPlayer()
{
    RECT        rc;
    HWND        hwndPB;

    if(!gfOle2IPEditing)
        CreateControls();

    if (gfPlayOnly) {

        /* Remember our size before we shrink it so we can go back to it. */
        GetWindowRect(ghwndApp, &grcSave);

        SetMenu(ghwndApp, NULL);

        SendMessage(ghwndTrackbar, TBM_CLEARTICS, FALSE, 0);

        /* Next preserve the current size of the window as the size */
        /* for the new built-in MCI window.                         */

        if ((hwndPB = GetWindowMCI()) != NULL) {
            if (IsIconic(hwndPB))
                ShowWindow(hwndPB, SW_RESTORE);

            GetClientRect(hwndPB, &rc);
            ClientToScreen(hwndPB, (LPPOINT)&rc);
            ClientToScreen(hwndPB, (LPPOINT)&rc+1);
            ShowWindowMCI(FALSE);
        } else {        // not a windowed device?
            SetRectEmpty(&rc);
        }

        if (ghwndMap) {

            //If we are inplace editing set the toolbar control states appropriately.
            if(!gfOle2IPEditing) {

                ShowWindow(ghwndMap, SW_HIDE);
                ShowWindow(ghwndMark, SW_HIDE);
                ShowWindow(ghwndFSArrows, SW_HIDE);
                ShowWindow(ghwndStatic, SW_HIDE);
                ShowWindow(ghwndTrackbar, SW_SHOW);

                toolbarModifyState(ghwndToolbar, BTN_EJECT, TBINDEX_MAIN, BTNST_GRAYED);
                toolbarModifyState(ghwndToolbar, BTN_HOME, TBINDEX_MAIN, BTNST_GRAYED);
                toolbarModifyState(ghwndToolbar, BTN_END, TBINDEX_MAIN, BTNST_GRAYED);
                toolbarModifyState(ghwndToolbar, BTN_RWD, TBINDEX_MAIN, BTNST_GRAYED);
                toolbarModifyState(ghwndToolbar, BTN_FWD, TBINDEX_MAIN, BTNST_GRAYED);
                toolbarModifyState(ghwndMark, BTN_MARKIN, TBINDEX_MARK, BTNST_GRAYED);
                toolbarModifyState(ghwndMark, BTN_MARKOUT, TBINDEX_MARK, BTNST_GRAYED);
                toolbarModifyState(ghwndFSArrows, ARROW_PREV, TBINDEX_ARROWS, BTNST_GRAYED);
                toolbarModifyState(ghwndFSArrows, ARROW_NEXT, TBINDEX_ARROWS, BTNST_GRAYED);

            } else {

                ShowWindow(ghwndMap, SW_SHOW);
                ShowWindow(ghwndMark, SW_SHOW);
                ShowWindow(ghwndFSArrows, SW_SHOW);
                ShowWindow(ghwndStatic, SW_SHOW);
            }
        }

        SendMessage(ghwndTrackbar, TBM_SHOWTICS, FALSE, FALSE);
        CreateWindowMCI();
        SetMPlayerSize(&rc);

    } else {

        if (ghwndMCI) {
            GetClientRect(ghwndMCI, &rc);
            ClientToScreen(ghwndMCI, (LPPOINT)&rc);
            ClientToScreen(ghwndMCI, (LPPOINT)&rc+1);

            /*
            **  Make sure our hook proc doesn't post IDM_CLOSE!
            **  The WM_CLOSE message will set the playback window back
            **  to the video playback window by calling SetWindowMCI(NULL);
            */
            gfSeenPBCloseMsg = TRUE;
            SendMessage(ghwndMCI, WM_CLOSE, 0, 0);
            /*
            **  Subclass the real video window now.  This will also set
            **  gfSeenPBCloseMsg to FALSE.
            */
            SubClassMCIWindow();


        } else {

            GetWindowRect(ghwndApp,&rc);
            OffsetRect(&grcSave, rc.left - grcSave.left,
                                 rc.top - grcSave.top);
            SetRectEmpty(&rc);
        }

        SendMessage(ghwndTrackbar, TBM_SHOWTICS, TRUE, FALSE);
        ShowWindow(ghwndMap, SW_SHOW);
        ShowWindow(ghwndMark, SW_SHOW);
        ShowWindow(ghwndStatic, SW_SHOW);

        /* If we remembered a size, use it, else use default */
        SetMPlayerSize(&grcSave);

        InvalidateRect(ghwndStatic, NULL, TRUE);    // why is this necessary?

        if (gwDeviceID && (gwDeviceType & DTMCI_CANWINDOW)) {

        /* make the playback window the size our MCIWindow was and */
        /* show the playback window and stretch to it ?            */

            if (!IsRectEmpty(&rc))
                PutWindowMCI(&rc);

            SmartWindowPosition(GetWindowMCI(), ghwndApp, gfOle2Open);

            ShowWindowMCI(TRUE);
            SetForegroundWindow(ghwndApp);
        }

        ShowWindow(ghwndFSArrows, SW_SHOW);
    }

    InvalidateRect(ghwndApp, NULL, TRUE);
    gfValidCaption = FALSE;

    gwStatus = (UINT)(-1);          // force a full update
    UpdateDisplay();
}


/*
 * pKeyBuf = LoadProfileKeys(lszProfile, lszSection)
 *
 * Load the keywords from the <szSection> section of the Windows profile
 * file named <szProfile>.  Allocate buffer space and return a pointer to it.
 * On failure, return NULL.
 *
 * The INT pointed to by pSize will be filled in with the size of the
 * buffer returned, so that checks for corruption can be made when it's freed.
 */

PTSTR NEAR PASCAL LoadProfileKeys(

LPTSTR   lszProfile,                 /* the name of the profile file to access */
LPTSTR   lszSection,                 /* the section name to look under         */
PUINT    pSize)
{
    PTSTR   pKeyBuf;                /* pointer to the section's key list      */
    PTSTR   pKeyBufNew;
    UINT    wSize;                  /* the size of <pKeyBuf>                  */

////DPF("LoadProfileKeys('%"DTS"', '%"DTS"')\n", (LPTSTR) lszProfile, (LPTSTR)lszSection);

    /*
     * Load all keynames present in the <lszSection> section of the profile
     * file named <lszProfile>.
     *
     */

    wSize = 256;                    /* make a wild initial guess */
    pKeyBuf = NULL;                 /* the key list is initially empty */

    do {
        /* (Re)alloc the space to load the keynames into */

        if (pKeyBuf == NULL)
            pKeyBuf = AllocMem(wSize);
        else {
            pKeyBufNew = ReallocMem( (HANDLE)pKeyBuf, wSize, wSize + 256);
            if (NULL == pKeyBufNew) {
                FreeMem((HANDLE)pKeyBuf, wSize);
            }
            pKeyBuf = pKeyBufNew;
            wSize += 256;
        }

        if (pKeyBuf == NULL)        /* the (re)alloc failed */
            return NULL;

        /*
         * THIS IS A WINDOWS BUG!!!  It returns size minus two!!
         * (The same feature is present in Windows/NT)
         */

    } while (GetPrivateProfileString(lszSection, NULL, aszNULL, pKeyBuf, wSize/sizeof(TCHAR),
        lszProfile) >= (wSize/sizeof(TCHAR) - 2));

    if (pSize)
        *pSize = wSize;

    return pKeyBuf;
}



/*
 * QueryDevices(void)
 *
 * Find out what devices are available to the player. and initialize the
 * garMciDevices[] array.
 *
 */
void NEAR PASCAL QueryDevices(void)
{
    PTSTR   pch;
    PTSTR   pchDevices;
    PTSTR   pchExtensions;
    PTSTR   pchDevice;
    PTSTR   pchExt;

    TCHAR   ach[1024];  /*1024 is the maximum buffer size for a wsprintf call*/

    UINT    wDeviceType;    /* Return value from DeviceTypeMCI() */

    INT     DevicesSize;
    INT     ExtensionsSize;

    if (gwNumDevices > 0)
        return;

    /*
     * make device zero be the autoopen device.
     * its device name will be "" and the files it supports will be "*.*"
     */
    LOADSTRING(IDS_ALLFILES, ach);

    garMciDevices[0].wDeviceType  = DTMCI_CANPLAY | DTMCI_FILEDEV;
    garMciDevices[0].szDevice     = aszNULL;
    garMciDevices[0].szDeviceName = AllocStr(ach);
    garMciDevices[0].szFileExt    = aszAllFiles;

    gwNumDevices = 0;

    /* Load the SYSTEM.INI [MCI] section */

    /* If the user specified a device to open, build a string containing
     * that device alone, and don't bother looking in the registry
     * (or system.ini in the case of Win95) for the MCI devices.
     */
    if (*gachOpenDevice)
    {
        LPTSTR pDevice;
        DWORD DeviceLength;

        pDevice = gachOpenDevice;
        DeviceLength = STRING_BYTE_COUNT(pDevice);
        DevicesSize = ((DeviceLength + 1) * sizeof *pchDevice);

        if (pchDevices = AllocMem(DevicesSize))
            CopyMemory(pchDevices, pDevice, DevicesSize);
    }
    else
    {
        pchDevices = AllocMem(DevicesSize = 256);
        if (pchDevices)
            QueryDevicesMCI(pchDevices, DevicesSize);
    }

    pchExtensions = LoadProfileKeys(aszWinIni, gszWinIniSection, &ExtensionsSize);

    if (pchExtensions == NULL || pchDevices == NULL) {
        DPF("unable to load extensions section\n");
        if (pchExtensions)
            FreeMem(pchExtensions, ExtensionsSize);
        if (pchDevices)
            FreeMem(pchDevices, DevicesSize);
        return;
    }

    /*
     *  Search through the list of device names found in SYSTEM.INI, looking for
     *  keywords; if profile was not found, then *gpSystemIniKeyBuf == 0
     *
     *  in SYSTEM.INI:
     *
     *      [MCI]
     *          device = driver.drv
     *
     *  in WIN.INI:
     *
     *      [MCI Extensions]
     *          xyz = device
     *
     *  in MPLAYER.INI:
     *
     *      [Devices]
     *          device = <device type>, <device name>
     *
     *  NOTE: The storage of device information in MPLAYER.INI has been nuked
     *        for NT - it may speed things up, but where we are changing
     *        devices regularly after initial setup this is a pain, as deleting
     *        the INI file regularly gets stale real quick.
     *
     */
    for (pchDevice = pchDevices;
        *pchDevice;
        pchDevice += STRLEN(pchDevice)+1) {

        //
        // we have no info in MPLAYER.INI about this device, so load it and
        // ask it.
        //
        wDeviceType = DeviceTypeMCI(pchDevice, ach, CHAR_COUNT(ach));

        //
        // if we don't like this device, don't store it
        //
        if (wDeviceType == DTMCI_ERROR ||
            wDeviceType == DTMCI_IGNOREDEVICE ||
            !(wDeviceType & DTMCI_CANPLAY)) {

            continue;
        }

        gwNumDevices++;
        garMciDevices[gwNumDevices].wDeviceType  = wDeviceType;
        garMciDevices[gwNumDevices].szDevice     = AllocStr(pchDevice);
        garMciDevices[gwNumDevices].szDeviceName = AllocStr(ach);
        garMciDevices[gwNumDevices].szFileExt    = NULL;

        //
        // now look in the [mci extensions] section in WIN.INI to find
        // out the files this device deals with.
        //
        for (pchExt = pchExtensions; *pchExt; pchExt += STRLEN(pchExt)+1) {
            GetProfileString(gszWinIniSection, pchExt, aszNULL, ach, CHAR_COUNT(ach));

            if (lstrcmpi(ach, pchDevice) == 0) {
                if ((pch = garMciDevices[gwNumDevices].szFileExt) != NULL) {
                    wsprintf(ach, aszFormatExts, (LPTSTR)pch, (LPTSTR)pchExt);
                    CharLowerBuff(ach, STRLEN(ach)); // Make sure it's lower case so
                                                     // we can use STRSTR if necessary.
                    FreeStr((HANDLE)pch);
                    garMciDevices[gwNumDevices].szFileExt = AllocStr(ach);
                }
                else {
                    wsprintf(ach, aszFormatExt, (LPTSTR)pchExt);
                    CharLowerBuff(ach, STRLEN(ach));
                    garMciDevices[gwNumDevices].szFileExt = AllocStr(ach);
                }
            }
        }

    //
    // !!!only do this if the device deals with files.
    //
        if (garMciDevices[gwNumDevices].szFileExt == NULL &&
           (garMciDevices[gwNumDevices].wDeviceType & DTMCI_FILEDEV))
            garMciDevices[gwNumDevices].szFileExt = aszAllFiles;

#ifdef DEBUG
        DPF1("Device:%"DTS"; Name:%"DTS"; Type:%d; Extension:%"DTS"\n",
             (LPTSTR)garMciDevices[gwNumDevices].szDevice,
             (LPTSTR)garMciDevices[gwNumDevices].szDeviceName,
                     garMciDevices[gwNumDevices].wDeviceType,
             garMciDevices[gwNumDevices].szFileExt
             ? (LPTSTR)garMciDevices[gwNumDevices].szFileExt
             : aszNULL);
#endif
    }

    /* all done with the system.ini keys so free them */
    FreeMem(pchDevices, DevicesSize);
    FreeMem(pchExtensions, ExtensionsSize);
}



/*
 *  BuildDeviceMenu()
 *
 *  Insert all devices into the device menu, we only want devices that
 *  support the MCI_PLAY command.
 *
 *  Add "..." to the menu for devices that support files.
 *
 */
void NEAR PASCAL BuildDeviceMenu()
{
    int i;
    TCHAR ach[128];

    if (gwNumDevices == 0)
        return;

    DeleteMenu(ghDeviceMenu, IDM_NONE, MF_BYCOMMAND);


    //
    // start at device '1' because device 0 is the auto open device
    //
    for (i=1; i<=(int)gwNumDevices; i++) {
        //
        //  we only care about devices that can play!
        //
        if (!(garMciDevices[i].wDeviceType & DTMCI_CANPLAY))
            continue;

        if (garMciDevices[i].wDeviceType & DTMCI_SIMPLEDEV)
            wsprintf(ach, aszDeviceMenuSimpleFormat, i, (LPTSTR)garMciDevices[i].szDeviceName);
        else if (garMciDevices[i].wDeviceType & DTMCI_FILEDEV)
            wsprintf(ach, aszDeviceMenuCompoundFormat, i, (LPTSTR)garMciDevices[i].szDeviceName);
        else
            continue;

        InsertMenu(ghDeviceMenu, i-1, MF_STRING|MF_BYPOSITION, IDM_DEVICE0+i, ach);
    }
}

/*
 *  BuildFilter()
 *
 *  build the filter to be used with GetOpenFileName()
 *
 *  the filter will look like this...
 *
 *      DEVICE1 (*.111)
 *      DEVICE2 (*.222)
 *
 *      DEVICEn (*.333)
 *
 *      All Files (*.*)
 *
 */
void NEAR PASCAL BuildFilter()
{
    UINT  w;
    PTSTR pch;
    PTSTR pchFilterNew;
#define INITIAL_SIZE    ( 8192 * sizeof( TCHAR ) )

    pch = gpchFilter = AllocMem( INITIAL_SIZE ); //!!!

    if (gpchFilter == NULL)
        return; //!!!

    for (w=1; w<=gwNumDevices; w++)
    {
        if (garMciDevices[w].wDeviceType == DTMCI_ERROR ||
            garMciDevices[w].wDeviceType == DTMCI_IGNOREDEVICE)
            continue;

       	if (garMciDevices[w].wDeviceType & DTMCI_FILEDEV ||
			lstrcmpi(TEXT("CDAudio"), garMciDevices[w].szDevice) == 0) //Hack!!! This will list *.cda files
																	   //in the open dialog box. MCI by itself
																	   //does not handle playing of *.cda files
																	   //but media player does locally.

        {
            wsprintf(pch, aszFormatFilter,
                (LPTSTR)garMciDevices[w].szDeviceName,
                (LPTSTR)garMciDevices[w].szFileExt);
            pch += STRLEN(pch)+1;
            lstrcpy(pch, garMciDevices[w].szFileExt);
            pch += STRLEN(pch)+1;
        }
        else
        {
            lstrcpy(pch, garMciDevices[w].szDeviceName);
            pch += STRLEN(pch)+1;
            lstrcpy(pch, aszBlank);
            pch += STRLEN(pch)+1;
        }
    }

    //
    //  now add "All Files" (device 0) last
    //
    wsprintf(pch, aszFormatFilter, (LPTSTR)garMciDevices[0].szDeviceName, (LPTSTR)garMciDevices[0].szFileExt);
    pch += STRLEN(pch)+1;
    lstrcpy(pch, garMciDevices[0].szFileExt);
    pch += STRLEN(pch)+1;

    //
    // all done!
    //
    *pch++ = 0;

    //
    // realloc this down to size
    //
    pchFilterNew = ReallocMem( gpchFilter,
                               INITIAL_SIZE,
                               (UINT)(pch-gpchFilter)*sizeof(*pch) );
    if (NULL == pchFilterNew) {
        FreeMem(gpchFilter, 0);
    }
    gpchFilter = pchFilterNew;
}

/* Call every time we open a different device to get the default options */
void FAR PASCAL ReadOptions(void)
{
    TCHAR ach[20];

    if (gwDeviceID == (UINT)0)
        return;

    /* Get the options and scale style to be used for this device */

    GetDeviceNameMCI(ach, BYTE_COUNT(ach));

    ReadRegistryData(aszOptionsSection, ach, NULL, (LPBYTE)&gwOptions, sizeof gwOptions);

    if (gwOptions == 0)
        gwOptions |= OPT_BAR | OPT_TITLE | OPT_BORDER;

    gwOptions |= OPT_PLAY;   /* Always default to play in place. */

    gwCurScale = gwOptions & OPT_SCALE;

    switch (gwCurScale) {
        case ID_TIME:
        case ID_FRAMES:
        case ID_TRACKS:
            break;

        default:
            /* Default CD scale to tracks rather than time.
             * Much more sensible:
             */
            if ((gwDeviceType & DTMCI_DEVICE) == DTMCI_CDAUDIO)
                gwCurScale = ID_TRACKS;
            else
                gwCurScale = ID_TIME;
            break;
    }
}

/*
 * ReadDefaults()
 *
 * Read the user defaults from the MPLAYER.INI file.
 *
 */
void NEAR PASCAL ReadDefaults(void)
{
    TCHAR       sz[20];
    TCHAR       *pch;
    int         x,y,w,h;
    UINT        f;

    *sz = TEXT('\0');

    ReadRegistryData(aszOptionsSection, aszDisplayPosition, NULL, (LPBYTE)sz, BYTE_COUNT(sz));

    x = ATOI(sz);

    pch = sz;
    while (*pch && *pch++ != TEXT(','))
        ;

    if (*pch) {
        y = ATOI(pch);

        while (*pch && *pch++ != TEXT(','))
            ;

        if (*pch) {
            w = ATOI(pch);

            while (*pch && *pch++ != TEXT(','))
                ;

            if (*pch) {
                h = ATOI(pch);

                f = SWP_NOACTIVATE | SWP_NOZORDER;

                if (w == 0 || h == 0)
                    f |= SWP_NOSIZE;

                if (!ghInstPrev && x >= 0 && y >= 0
                    && x < GetSystemMetrics(SM_CXSCREEN)
                    && y < GetSystemMetrics(SM_CYSCREEN)) {
                    SetWindowPos(ghwndApp, NULL, x, y, w, h, f);
                    // Remember this so even if we come up in teeny mode and
                    // someone exits, it'll have these numbers to save
                    SetRect(&grcSave, x, y, x + w, y + h);
                } else {
                    SetWindowPos(ghwndApp, NULL, 0, 0, w, h, f | SWP_NOMOVE);
                }
            }
        }
    }
}


/* Call every time we close a device to save its options */
void FAR PASCAL WriteOutOptions(void)
{
    if (gwCurDevice) {
        /* Put the scale in the proper bits of the Options */
        gwOptions = (gwOptions & ~OPT_SCALE) | gwCurScale;

        WriteRegistryData(aszOptionsSection,
                garMciDevices[gwCurDevice].szDevice, REG_DWORD, (LPBYTE)&gwOptions, sizeof gwOptions);
    }
}


void FAR PASCAL WriteOutPosition(void)
{
    TCHAR               sz[20];
    WINDOWPLACEMENT     wp;

    //
    // Only the first instance will save settings.
    // Play only mode will save the remembered rect for when it was in
    // regular mode.  If no rect is remembered, don't write anything.
    //
    if (ghInstPrev || (gfPlayOnly && grcSave.left == 0))
        return;

    /* Save the size it was when it was Normal because the next time */
    /* MPlayer comes up, it won't be in reduced mode.                */
    /* Only valid if some number has been saved.                     */
    if (gfPlayOnly)
        wp.rcNormalPosition = grcSave;
    else {
        wp.length = sizeof(WINDOWPLACEMENT);
        GetWindowPlacement(ghwndApp, &wp);
    }

    wsprintf(sz, aszPositionFormat,
                wp.rcNormalPosition.left,
                wp.rcNormalPosition.top,
                wp.rcNormalPosition.right - wp.rcNormalPosition.left,
                wp.rcNormalPosition.bottom - wp.rcNormalPosition.top);

    WriteRegistryData(aszOptionsSection, aszDisplayPosition, REG_SZ, (LPBYTE)sz, STRING_BYTE_COUNT(sz));
}


BOOL FAR PASCAL GetIntlSpecs()
{
    TCHAR szTmp[2];

    szTmp[0] = chDecimal;
    szTmp[1] = 0;
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, szTmp, CHAR_COUNT(szTmp));
    chDecimal = szTmp[0];

    szTmp[0] = chTime;
    szTmp[1] = 0;
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STIME, szTmp, CHAR_COUNT(szTmp));
    chTime = szTmp[0];

    szTmp[0] = chLzero;
    szTmp[1] = 0;
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_ILZERO, szTmp, CHAR_COUNT(szTmp));
    chLzero = szTmp[0];

    return TRUE;
}

/*----------------------------------------------------------------------------*\
|   SmartWindowPosition (HWND hWndDlg, HWND hWndShow)
|
|   Description:
|       This function attempts to position a dialog box so that it
|       does not obscure the hWndShow window. This function is
|       typically called during WM_INITDIALOG processing.
|
|   Arguments:
|       hWndDlg         handle of the soon to be displayed dialog
|       hWndShow        handle of the window to keep visible
|
|   Returns:
|       1 if the windows overlap and positions were adjusted
|       0 if the windows don't overlap
|
\*----------------------------------------------------------------------------*/
void FAR PASCAL SmartWindowPosition (HWND hWndDlg, HWND hWndShow, BOOL fForce)
{
    RECT rc, rcDlg, rcShow;
    int iHeight, iWidth;

    int dxScreen = GetSystemMetrics(SM_CXSCREEN);
    int dyScreen = GetSystemMetrics(SM_CYSCREEN);

    if (hWndDlg == NULL || hWndShow == NULL)
        return;

    GetWindowRect(hWndDlg, &rcDlg);
    GetWindowRect(hWndShow, &rcShow);
    InflateRect (&rcShow, 5, 5); // allow a small border
    if (fForce || IntersectRect(&rc, &rcDlg, &rcShow)){
        /* the two do intersect, now figure out where to place  */
        /* this dialog window.  Try to go below the Show window */
        /* first and then to the right, top and left.           */

        /* get the size of this dialog */
        iHeight = rcDlg.bottom - rcDlg.top;
        iWidth = rcDlg.right - rcDlg.left;

        if ((rcShow.top - iHeight - 1) > 0){
                /* will fit on top, handle that */
                rc.top = rcShow.top - iHeight - 1;
                rc.left = (((rcShow.right - rcShow.left)/2) + rcShow.left)
                            - (iWidth/2);
        } else if ((rcShow.bottom + iHeight + 1) <  dyScreen){
                /* will fit on bottom, go for it */
                rc.top = rcShow.bottom + 1;
                rc.left = (((rcShow.right - rcShow.left)/2) + rcShow.left)
                        - (iWidth/2);
        } else if ((rcShow.right + iWidth + 1) < dxScreen){
                /* will fit to right, go for it */
                rc.left = rcShow.right + 1;
                rc.top = (((rcShow.bottom - rcShow.top)/2) + rcShow.top)
                            - (iHeight/2);
        } else if ((rcShow.left - iWidth - 1) > 0){
                /* will fit to left, do it */
                rc.left = rcShow.left - iWidth - 1;
                rc.top = (((rcShow.bottom - rcShow.top)/2) + rcShow.top)
                            - (iHeight/2);
        } else {
                /* we are hosed, they cannot be placed so that there is */
                /* no overlap anywhere. */
                /* just leave it alone */

                rc = rcDlg;
        }

        /* make any adjustments necessary to keep it on the screen */
        if (rc.left < 0)
                rc.left = 0;
        else if ((rc.left + iWidth) > dxScreen)
                rc.left = dxScreen - iWidth;

        if (rc.top < 0)
                rc.top = 0;
        else if ((rc.top + iHeight) > dyScreen)
                rc.top = dyScreen - iHeight;

        SetWindowPos(hWndDlg, NULL, rc.left, rc.top, 0, 0,
                SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);

        return;
    } // if the windows overlap by default
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\inplace.c ===
/*---------------------------------------------------------------------------
|   INPLACE.C
|   This file has the InPlace activation related interfaces and functions.
|   This file has the function DoInPlaceEdit which initiaites the server side
|   operations for InPlace activation.
|
|   Created By: Vij Rajarajan (VijR)
+---------------------------------------------------------------------------*/
#define SERVERONLY
#include <windows.h>
#include <windowsx.h>
#include "mpole.h"
#include <mmsystem.h>

#include "mplayer.h"
#include "toolbar.h"
#include "ole2ui.h"

#define DEF_HATCH_SZ 4                      //Width of the hatch marks
#define EW_HATCH_HANDLE 10                  //GetWindowWord offset to check
                                            //if resize handle needed in hatch window

//#define DUMMY_TOOLBAR_WIDTH 58              //Width of dummy toolbar transferred during play.
#define DUMMY_TOOLBAR_WIDTH 0               //Width of dummy toolbar transferred during play.

HWND      ghwndIPHatch = NULL;              //Hatch window surrounding object.
HWND      ghwndIPToolWindow;                //The toolwindow appearing on top
HWND      ghwndIPScrollWindow;              //Tool window appearing at bottom with tthe scrollbar
                                            //if the container does not give us space on top.
HMENU       ghInPlaceMenu;

POINT   gHatchOffset;
WNDPROC gfnHatchWndProc = NULL;

BOOL gfOle2Open = FALSE;
BOOL gfOle2IPEditing = FALSE;
BOOL gfOle2IPPlaying = FALSE;
BOOL gfInPlaceResize  = FALSE;               //TRUE: We have resized when InPlace
BOOL gfTopAndBottomTool = TRUE;              // We have toolbars both on top and bottom
RECT gInPlacePosRect;                        //Our position in the container.
HWND ghwndCntr;                              //Container
HWND ghwndFrame = NULL;                      //Frame of the container.
int toolbarwidth;
BOOL gfPosRectChange = FALSE;
RECT gPrevPosRect;

BOOL    gfInPPViewer;           /* Hack to stop PowerPoint Viewer crashing */

extern TCHAR    szToolBarClass[];
extern HMENU    ghDeviceMenu;         /* handle to the Device menu     */
extern UINT     gwPlaybarHeight;        //tell playbar how tall to make
                                        //itself so it covers the title
void AllocInPlaceDataBlock (LPDOC lpdoc);
void FreeInPlaceDataBlock (LPDOC lpdoc);
void DeactivateTools(LPDOC lpdoc);
HRESULT ActivateTools(LPDOC lpdoc, BOOL fPlayOnly);
void InPlaceCreateControls(BOOL fPlayOnly);
LONG_PTR FAR PASCAL SubClassedHatchWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam);



/**************************************************************************
*   TransferTools:
*   This function changes parents and positions the toolbar buttons
*   from the main Mplayer window to the toolbar window/windows we will
*   display in the client.
***************************************************************************/
void TransferTools(HWND hwndToolWindow)
{
    SetParent(ghwndToolbar, hwndToolWindow);
    MoveWindow(ghwndToolbar, 5,0,7*BUTTONWIDTH+15,TOOL_WIDTH,TRUE);
    SetParent(ghwndMark, hwndToolWindow);
    MoveWindow(ghwndMark, 7*BUTTONWIDTH+16,0,2*BUTTONWIDTH+15,TOOL_WIDTH,TRUE);
    SetParent(ghwndFSArrows, hwndToolWindow);
    MoveWindow(ghwndFSArrows, 9*BUTTONWIDTH+16+10+3,0,toolbarwidth-9*BUTTONWIDTH-25,TOOL_WIDTH,TRUE);
    if(!ghwndMCI) {
        toolbarModifyState(ghwndToolbar, BTN_EJECT, TBINDEX_MAIN, BTNST_GRAYED);
        toolbarModifyState(ghwndToolbar, BTN_STOP, TBINDEX_MAIN, BTNST_GRAYED);
        toolbarModifyState(ghwndToolbar, BTN_PLAY, TBINDEX_MAIN, BTNST_GRAYED);
        toolbarModifyState(ghwndMark, BTN_MARKIN, TBINDEX_MARK, BTNST_GRAYED);
        toolbarModifyState(ghwndMark, BTN_MARKOUT, TBINDEX_MARK, BTNST_GRAYED);
        toolbarModifyState(ghwndFSArrows, ARROW_PREV, TBINDEX_ARROWS, BTNST_GRAYED);
        toolbarModifyState(ghwndFSArrows, ARROW_NEXT, TBINDEX_ARROWS, BTNST_GRAYED);
    }
    if(hwndToolWindow == ghwndApp)
    {
        SetParent(ghwndTrackbar,ghwndApp);
        SetParent(ghwndMap,ghwndApp);
    }
}



/**************************************************************************
*   ActivateTools:
*   This function negotiates for toolbar space with the client. If possible
*   one broad toolbar is placed at the top of the client, if not the
*   toolbar is split and one is placed on top and other at bottom. If even
*   that is not possible then the function fails. The top toolbar window is
*   ghwndIPToolWindow and the bottom one is ghwndIPScrollWindow (because it
*   has the scrolling trackbar.
*
*   fPlayOnly is TRUE if we are just going to play. In that case a dummy, empty
*   tool bar is transferred.  No, we don't want anything.  But we have to
*   negotiate space, even empty space, otherwise Word doesn't think we're
*   in-place active.
***************************************************************************/
HRESULT ActivateTools(LPDOC lpdoc, BOOL fPlayOnly)
{
    RECT rect, size;
    SCODE sc;


    size.left = 0;
    size.top = 0;
    size.bottom = 0;
    size.right = 0;
    IOleInPlaceFrame_GetBorder(lpdoc->lpIpData->lpFrame, &rect);
    if (fPlayOnly)
        size.top = DUMMY_TOOLBAR_WIDTH; /* This is now 0 - no toolbar space needed */
    else
        size.top = 3*TOOL_WIDTH+1;
    size.bottom = 0;
    sc = GetScode(IOleInPlaceFrame_RequestBorderSpace(lpdoc->lpIpData->lpFrame,
                                                      &size));
    if (sc == S_OK)
    {
        size.bottom = size.left = size.right = 0;
        if (fPlayOnly)
            size.top = DUMMY_TOOLBAR_WIDTH;
        else
            size.top = 3*TOOL_WIDTH+1;

        sc = GetScode(IOleInPlaceFrame_SetBorderSpace(lpdoc->lpIpData->lpFrame,
                                                      &size));
        if (sc != S_OK)
            goto ToolBottom;

        IOleInPlaceFrame_GetBorder(lpdoc->lpIpData->lpFrame, &rect);

        IOleInPlaceFrame_GetWindow (lpdoc->lpIpData->lpFrame, &ghwndFrame);

        if (GetParent(ghwndIPToolWindow) != ghwndFrame)
            SetParent(ghwndIPToolWindow, ghwndFrame);

        if (!fPlayOnly)
            MoveWindow(ghwndIPToolWindow, rect.left, rect.top,
                       toolbarwidth, 3*TOOL_WIDTH+1, TRUE);
        else
            return NOERROR;  /* That's all folks, if we're just playing. */

        if(ghwndIPToolWindow != GetParent(ghwndTrackbar))
        {
            SetParent(ghwndTrackbar,ghwndIPToolWindow);
            SetWindowPos(ghwndTrackbar, NULL,3,TOOL_WIDTH+2,
                 11*BUTTONWIDTH+15,FSTRACK_HEIGHT,SWP_NOZORDER | SWP_NOACTIVATE);
            SetParent(ghwndMap,ghwndIPToolWindow);
            SetWindowPos(ghwndMap, NULL,3,TOOL_WIDTH+FSTRACK_HEIGHT+2+2,
                 11*BUTTONWIDTH+50,MAP_HEIGHT,SWP_NOZORDER | SWP_NOACTIVATE);
        }
        ShowWindow(ghwndIPToolWindow, SW_SHOW);
        ShowWindow(ghwndMark, SW_SHOW);
        ShowWindow(ghwndFSArrows, SW_SHOW);

        gfTopAndBottomTool = FALSE;
        return NOERROR;

    }
    else
    {
ToolBottom:
        if (!fPlayOnly)
        {
            size.top = TOOL_WIDTH+1;
            size.bottom = 2*TOOL_WIDTH+1;
        }
        else
        {
            ShowWindow(ghwndFSArrows, SW_HIDE);
            ShowWindow(ghwndStatic, SW_HIDE);
            ShowWindow(ghwndMark, SW_HIDE);
            return NOERROR;
        }
        sc = GetScode(IOleInPlaceFrame_RequestBorderSpace(lpdoc->lpIpData->lpFrame,
                                                          &size));
        size.left = size.right = 0;
        size.top = TOOL_WIDTH+1;
        size.bottom = 2*TOOL_WIDTH+1;
        if (sc != S_OK)
            goto error;

        sc = GetScode(IOleInPlaceFrame_SetBorderSpace(lpdoc->lpIpData->lpFrame,
                                                      &size));
        if (sc != S_OK)
            goto error;

        IOleInPlaceFrame_GetBorder(lpdoc->lpIpData->lpFrame, &rect);

        if (GetParent(ghwndIPToolWindow) != ghwndFrame)
        {
            SetParent(ghwndIPToolWindow, ghwndFrame);
            SetParent(ghwndIPScrollWindow, ghwndFrame);
        }

        if(ghwndIPScrollWindow != GetParent(ghwndTrackbar))
        {
            SetParent(ghwndTrackbar,ghwndIPScrollWindow);
            SetWindowPos(ghwndTrackbar, NULL,3,4,
                         11*BUTTONWIDTH+15,FSTRACK_HEIGHT,SWP_NOZORDER | SWP_NOACTIVATE);
            SetParent(ghwndMap,ghwndIPScrollWindow);
            SetWindowPos(ghwndMap, NULL,3,FSTRACK_HEIGHT+4+2,
                         11*BUTTONWIDTH+50,MAP_HEIGHT,SWP_NOZORDER | SWP_NOACTIVATE);
        }

        MoveWindow(ghwndIPToolWindow, rect.left, rect.top,
            toolbarwidth, TOOL_WIDTH+1, TRUE);
        ShowWindow(ghwndIPToolWindow, SW_SHOW);
        MoveWindow(ghwndIPScrollWindow, rect.left,rect.bottom-2*TOOL_WIDTH,//-1,
                toolbarwidth,2*TOOL_WIDTH+1,TRUE);
        ShowWindow(ghwndIPScrollWindow, SW_SHOW);
        gfTopAndBottomTool = TRUE;
        return NOERROR;
    }
error:
    RETURN_RESULT(sc);
}


/**************************************************************************
*   DeactivateTools:
*   Hides the toolbars.
***************************************************************************/
void DeactivateTools(LPDOC lpdoc)
{
    ShowWindow(ghwndIPToolWindow, SW_HIDE);
    SetParent(ghwndIPToolWindow, NULL);
    if (gfTopAndBottomTool)
    {
        ShowWindow(ghwndIPScrollWindow, SW_HIDE);
        SetParent(ghwndIPScrollWindow, NULL);
    }
}




/**************************************************************************
************   IOleInPlaceObject INTERFACE IMPLEMENTATION.
***************************************************************************/
//Delegate to the common IUnknown implementation.
STDMETHODIMP IPObjQueryInterface (
LPOLEINPLACEOBJECT  lpIPObj,        // inplace object ptr
REFIID              riidReq,        // IID required
LPVOID FAR *        lplpUnk         // pre for returning the interface
)
{
    return UnkQueryInterface((LPUNKNOWN)lpIPObj, riidReq, lplpUnk);
}


STDMETHODIMP_(ULONG) IPObjAddRef(
LPOLEINPLACEOBJECT  lpIPObj         // inplace object ptr
)
{
    return UnkAddRef((LPUNKNOWN) lpIPObj);
}


STDMETHODIMP_(ULONG) IPObjRelease(
LPOLEINPLACEOBJECT  lpIPObj         // inplace object ptr
)
{
    return UnkRelease((LPUNKNOWN) lpIPObj);
}


STDMETHODIMP IPObjGetWindow(
LPOLEINPLACEOBJECT  lpIPObj,        // inplace object ptr
HWND FAR*           lphwnd          // window handle of the object
)
{
    DPF("IPObjGetWindow\n");
    *lphwnd = docMain.hwnd;
    return NOERROR;
}


STDMETHODIMP IPObjContextSensitiveHelp(
LPOLEINPLACEOBJECT  lpIPObj,        // inplace object ptr
BOOL                fEnable
)
{
    //Not very useful at this time.

    LPDOC lpdoc;

    lpdoc = ((struct COleInPlaceObjectImpl FAR*)lpIPObj)->lpdoc;
    lpdoc->lpIpData->fInContextHelpMode = fEnable;
    return NOERROR;
}


STDMETHODIMP     IPObjInPlaceDeactivate(
LPOLEINPLACEOBJECT  lpIPObj        // inplace object ptr
)
{
    LPDOC         lpdoc;
    LPINPLACEDATA lpIpData;
    static int    EntryCount;   /* OLE sometimes calls us recursively. */

    DPF("IPObjInPlaceDeactivate\n");

    if (EntryCount++ == 0)
    {
        lpdoc = ((struct COleInPlaceObjectImpl FAR*)lpIPObj)->lpdoc;
        lpIpData = lpdoc->lpIpData;

        if (lpIpData)
        {
            // This stops PowerPoint crashing, since it forces UpdateObject
            // to send change notification when there's an empty Media Clip.
            if (gwDeviceID == 0)
                fDocChanged = TRUE;

            //Make sure the container has the correct metafile before we are hidden
            UpdateObject();
            IOleInPlaceObject_UIDeactivate ((LPOLEINPLACEOBJECT)&lpdoc->m_InPlace);

            if (lpIpData && lpIpData->lpSite)
            {
                if (!gfInPPViewer)
                    IOleInPlaceSite_OnInPlaceDeactivate (lpIpData->lpSite);

                IOleInPlaceSite_Release (lpIpData->lpSite);
            }

            FreeInPlaceDataBlock (lpdoc);
        }
    }
    else
    {
        /* This sometimes happens during the above OnInPlaceDeactivate call,
         * which resulted in an access violation because the data block had
         * been freed when the call returned.
         * According to the OLE guys, apps should guard against this.
         */
        DPF("Attempt to re-enter IPObjInPlaceDeactivate\n");
    }

    --EntryCount;

    /* Dontcha just love these global variables!
     */
    gfOle2IPEditing = FALSE;
    gfOle2IPPlaying = FALSE;
    gfPlayingInPlace = FALSE;

    return NOERROR;
}

//Hide our inplace UI.
STDMETHODIMP     IPObjUIDeactivate(
LPOLEINPLACEOBJECT  lpIPObj        // inplace object ptr
)
{
    LPDOC   lpdoc;

    DPF("IPObjUIDeactivate\n");
    lpdoc = ((struct COleInPlaceObjectImpl FAR*)lpIPObj)->lpdoc;

    if (!(lpdoc->lpIpData && lpdoc->lpIpData->lpFrame))
        return NOERROR;

    IOleInPlaceFrame_SetMenu (lpdoc->lpIpData->lpFrame, NULL, NULL, lpdoc->hwnd);
    // clear inplace-state

    IOleInPlaceFrame_SetActiveObject (lpdoc->lpIpData->lpFrame, NULL, NULL);

    if (lpdoc->lpIpData->lpUIWindow)
        IOleInPlaceUIWindow_SetActiveObject (lpdoc->lpIpData->lpUIWindow, NULL, NULL);

    if(gfOle2IPPlaying)
        PostMessage(ghwndApp, WM_COMMAND, ID_STOP, 0L);

    /* We could also be playing if we're in-place editing:
     */
    else if(gfOle2IPEditing && (gwStatus == MCI_MODE_PLAY || gwStatus == MCI_MODE_SEEK))
        PostMessage(ghwndApp, WM_COMMAND, ID_STOP, 0L);

    ShowWindow(ghwndIPHatch,SW_HIDE);

    DeactivateTools(lpdoc);
    DisassembleMenus (lpdoc);

    if (lpdoc->lpIpData->lpUIWindow) {
        IOleInPlaceUIWindow_Release (lpdoc->lpIpData->lpUIWindow);
        lpdoc->lpIpData->lpUIWindow = NULL;
    }

    if (lpdoc->lpIpData->lpFrame) {
        IOleInPlaceFrame_Release (lpdoc->lpIpData->lpFrame);
        lpdoc->lpIpData->lpFrame = NULL;
    }

    // Set the parent back to hwndClient window
    SetParent(ghwndIPHatch,NULL);
    gPrevPosRect.left = gPrevPosRect.top =gPrevPosRect.right = gPrevPosRect.bottom = 0;
    lpdoc->hwndParent = NULL;

    if (!gfInPPViewer)
        IOleInPlaceSite_OnUIDeactivate (lpdoc->lpIpData->lpSite, FALSE);

    return NOERROR;
}

/**************************************************************************
*   IPObjSetObjectRects:
*   The client specifies our window position and size. Move our
*   window accordingly. Also size the Hatch window to fit around the
*   ghwndApp. If the change is very small compared to the previous
*   size ignore and return. This account for slop speeds things up.
***************************************************************************/
STDMETHODIMP     IPObjSetObjectRects(
LPOLEINPLACEOBJECT  lpIPObj,        // inplace object ptr
LPCRECT             lprcPosRect,
LPCRECT             lprcVisRect
)
{
    LPDOC   lpdoc;
    RECT rc;

    GetWindowRect(ghwndApp, (LPRECT)&rc);

    DPFI("\n*IPObjSetObjectRects");
    DPFI("\n^^^^^^^^ LPRECPOSRECT:  %d, %d, %d, %d ^^^^\n", *lprcPosRect);
    DPFI("\n^^^^^^^^ PREVRECT:  %d, %d, %d, %d ^^^^\n", gPrevPosRect);
    DPFI("\n^^^^^^^^ HWNDRECT:  %d, %d, %d, %d ^^^^\n", rc);

    lpdoc = ((struct COleInPlaceObjectImpl FAR*)lpIPObj)->lpdoc;
    if (!ghwndIPHatch || (ghwndCntr != GetParent(ghwndIPHatch)))
        return NOERROR;
    if (!(lpdoc->lpIpData))
        return NOERROR;

    rc = *lprcPosRect;

    if (!(gwDeviceID == (UINT)0 || !(gwDeviceType & DTMCI_CANWINDOW)))
        SetHatchWindowSize(ghwndIPHatch, (LPRECT)&rc,lprcVisRect, (LPPOINT)&gHatchOffset,TRUE);
    else
        SetHatchWindowSize(ghwndIPHatch, (LPRECT)&rc,lprcVisRect, (LPPOINT)&gHatchOffset,FALSE);


    if(!(gwDeviceType & DTMCI_CANWINDOW) && (gwOptions & OPT_BAR))
        rc.top = rc.bottom - gwPlaybarHeight;
    if(!(gwDeviceType & DTMCI_CANWINDOW) && !(gwOptions & OPT_BAR))
        rc.bottom = rc.top = rc.left = rc.right = 0;
    MapWindowPoints(ghwndCntr,ghwndIPHatch,(LPPOINT)&rc, 2);
    gfPosRectChange = TRUE;

    if (gwDeviceID)
        MoveWindow(lpdoc->hwnd, rc.left, rc.top,
            rc.right - rc.left,
            rc.bottom - rc.top, TRUE);
    else
        MoveWindow(lpdoc->hwnd, rc.left, rc.top,
            rc.right - rc.left,
            rc.bottom - rc.top, FALSE);

    GetWindowRect(lpdoc->hwnd, &gInPlacePosRect);
    gPrevPosRect = *lprcPosRect;

    /* I've commented out the below line, because PowerPoint calls
     * SetObjectRects after we deactivate, and this was causing the
     * MPlayer window to reappear when it was supposed to be hidden.
     * This line seems to have been superfluous in any case.
     */
//  ShowWindow(ghwndIPHatch,SW_SHOW);

    return NOERROR;
}

//We don't have an Undo state.
STDMETHODIMP     IPObjReactivateAndUndo(
LPOLEINPLACEOBJECT  lpIPObj        // inplace object ptr
)
{
    RETURN_RESULT(INPLACE_E_NOTUNDOABLE);
}



/**************************************************************************
**************   IOleInPlaceActiveObject INTERFACE IMPLEMENTATION.
***************************************************************************/
//delegate to the common IUnknown implementation.
STDMETHODIMP IPActiveQueryInterface (
LPOLEINPLACEACTIVEOBJECT    lpIPActive,     // inplace active object ptr
REFIID                      riidReq,        // IID required
LPVOID FAR *                lplpUnk         // pre for returning the interface
)
{
    return UnkQueryInterface((LPUNKNOWN)lpIPActive, riidReq, lplpUnk);
}


STDMETHODIMP_(ULONG) IPActiveAddRef(
LPOLEINPLACEACTIVEOBJECT    lpIPActive      // inplace active object ptr
)
{
    return UnkAddRef((LPUNKNOWN) lpIPActive);
}


STDMETHODIMP_(ULONG) IPActiveRelease (
LPOLEINPLACEACTIVEOBJECT    lpIPActive      // inplace active object ptr
)
{
    return UnkRelease((LPUNKNOWN) lpIPActive);
}


STDMETHODIMP IPActiveGetWindow(
LPOLEINPLACEACTIVEOBJECT    lpIPActive,     // inplace active object ptr
HWND FAR*                   lphwnd          // window handle of the object
)
{
    DPF("IPActiveGetWindow\n");
    *lphwnd = ghwndIPHatch;
    return NOERROR;
}

//Not very useful at this time.
STDMETHODIMP IPActiveContextSensitiveHelp(
LPOLEINPLACEACTIVEOBJECT    lpIPActive,     // inplace active object ptr
BOOL                        fEnable
)
{
    LPDOC lpdoc;

    lpdoc = ((struct COleInPlaceActiveObjectImpl FAR*)lpIPActive)->lpdoc;
    lpdoc->lpIpData->fInContextHelpMode = fEnable;
    return NOERROR;
}



STDMETHODIMP IPActiveTranslateAccelerator(
LPOLEINPLACEACTIVEOBJECT    lpIPActive,     // inplace active object ptr
LPMSG                       lpmsg
)
{
    // This will never be called because this server is implemented as an EXE
    RETURN_RESULT(S_FALSE);
}

STDMETHODIMP IPActiveOnFrameWindowActivate(
LPOLEINPLACEACTIVEOBJECT    lpIPActive,     // inplace active object ptr
BOOL                        fActivate
)
{
    DPF("IPActiveOnFrameWindowActivate = %d **\r\n", (int)fActivate);
    if (gwStatus == MCI_MODE_PAUSE)
            PostMessage(ghwndApp, WM_COMMAND, ID_STOP, 0L);

    return NOERROR;
}


//If activating show the toolbar and menu. If not hide the toolbar and menu.
STDMETHODIMP IPActiveOnDocWindowActivate(
LPOLEINPLACEACTIVEOBJECT    lpIPActive,     // inplace active object ptr
BOOL                        fActivate
)
{
    LPDOC   lpdoc;
    RECT rc;
    DPF("IPActiveOnDocWindowActivate\n");
    lpdoc = ((struct COleInPlaceActiveObjectImpl FAR*)lpIPActive)->lpdoc;
    GetWindowRect(lpdoc->hwnd, &rc);
    ScreenToClient(lpdoc->hwndParent, (POINT FAR *)&rc);
    ScreenToClient(lpdoc->hwndParent, (POINT FAR *)&(rc.right));
    if (fActivate) {

        if(gfOle2IPEditing)
        {
            ActivateTools(lpdoc,FALSE);
            TransferTools(ghwndIPToolWindow);
        }
        else
        {
            ActivateTools(lpdoc,TRUE);
            TransferTools(ghwndApp);
        }

        Layout();

        IOleInPlaceFrame_SetMenu (lpdoc->lpIpData->lpFrame,
                                  lpdoc->lpIpData->hmenuShared,
                                  lpdoc->lpIpData->holemenu,
                                  lpdoc->hwnd);
    }
    else {
        DeactivateTools(lpdoc);
        if(gfOle2IPPlaying)
            PostMessage(ghwndApp, WM_COMMAND, ID_STOP, 0L);
        IOleInPlaceFrame_SetMenu (lpdoc->lpIpData->lpFrame,
                                  NULL, NULL, lpdoc->hwnd);
    }
    return NOERROR;
}

//If we have a toolwindow at the bottom reposition that window to match
//the new frame window size.
STDMETHODIMP IPActiveResizeBorder(
LPOLEINPLACEACTIVEOBJECT    lpIPActive,     // inplace active object ptr
LPCRECT                     lprectBorder,
LPOLEINPLACEUIWINDOW        lpIPUiWnd,
BOOL                        fFrameWindow
)
{
    DPF("IPActiveResizeBorder\n");

    if (fFrameWindow)
    {
    LPDOC lpdoc;

    lpdoc = ((struct COleInPlaceActiveObjectImpl FAR*)lpIPActive)->lpdoc;
    if (gfTopAndBottomTool && (GetParent(ghwndIPScrollWindow) != NULL))
        MoveWindow(ghwndIPScrollWindow, lprectBorder->left,lprectBorder->bottom-2*TOOL_WIDTH,
                toolbarwidth,2*TOOL_WIDTH+1,TRUE);

    }
    return NOERROR;
}

STDMETHODIMP IPActiveEnableModeless(
LPOLEINPLACEACTIVEOBJECT    lpIPActive,     // inplace active object ptr
BOOL                        fEnable
)
{
    return NOERROR;
}


/**************************************************************************
*   DoInplaceEdit:
*   This is the function that initiates the InPlace activation from the
*   server side. It sets up the InPlace data structures required by us,
*   makes sure that the client supports the required interfaces and
*   can provide the space we require. It also prepares the toolbar to be
*   displayed and the layout of the Mplayer window.
***************************************************************************/
STDMETHODIMP DoInPlaceEdit(
LPDOC           lpdoc,
LPMSG           lpmsg,
LPOLECLIENTSITE lpActiveSite,
LONG        verb,
HWND    FAR * lphwnd,
LPRECT  lprect
)
{
    SCODE            error = S_OK;
    LPOLEINPLACESITE lpIPSite;
    RECT             rcPos;
    RECT             rcVis;
    RECT             hatchrc;
    LPWSTR           lpObjName;

    if (!(lpdoc->lpoleclient))
        RETURN_RESULT( E_FAIL);

    if (!(lpdoc->lpIpData))
    {
        if ((error = GetScode(IOleClientSite_QueryInterface(
                        lpdoc->lpoleclient,
                        &IID_IOleInPlaceSite,
                        (void FAR* FAR*) &lpIPSite))) != S_OK)
            RETURN_RESULT( error);

        if ((error = GetScode(IOleInPlaceSite_CanInPlaceActivate(lpIPSite))) != S_OK)
            goto errActivate;

        if (!gfInPPViewer)
            IOleInPlaceSite_OnInPlaceActivate(lpIPSite);

        AllocInPlaceDataBlock (lpdoc);
        lpdoc->lpIpData->lpSite = lpIPSite;
    }

    if ((error = GetScode(IOleInPlaceSite_GetWindow (lpdoc->lpIpData->lpSite, &lpdoc->hwndParent))) != S_OK)
        goto errRtn;

    if (!(lpdoc->hwndParent))
        goto errRtn;

    if (!gfInPPViewer)
        IOleInPlaceSite_OnUIActivate(lpdoc->lpIpData->lpSite);

    if ((error = GetScode(IOleInPlaceSite_GetWindowContext(
                                lpdoc->lpIpData->lpSite,
                                &lpdoc->lpIpData->lpFrame,
                                &lpdoc->lpIpData->lpUIWindow,
                                &rcPos, &rcVis,
                                &lpdoc->lpIpData->frameInfo))) != S_OK)
        goto errRtn;

#ifdef LATER
    if (gscaleInitXY[SCALE_X].denom)
    {
        gscaleInitXY[SCALE_X].num   = (rcPos.right - rcPos.left) * HIMETRIC_PER_INCH / giXppli;
        gscaleInitXY[SCALE_Y].num   = (rcPos.bottom - rcPos.top) * HIMETRIC_PER_INCH / giYppli;

        DPF0("Scale: %d%c X %d%c (%d/%d X %d/%d)\n",
             gscaleInitXY[SCALE_X].num * 100 / gscaleInitXY[SCALE_X].denom, '%',
             gscaleInitXY[SCALE_Y].num * 100 / gscaleInitXY[SCALE_Y].denom, '%',
             gscaleInitXY[SCALE_X].num,
             gscaleInitXY[SCALE_X].denom,
             gscaleInitXY[SCALE_Y].num,
             gscaleInitXY[SCALE_Y].denom);
    }
#endif

#ifdef UNICODE
    lpObjName = gachClassRoot;
#else
    lpObjName = AllocateUnicodeString(gachClassRoot);
    if (!lpObjName)
        RETURN_RESULT(E_OUTOFMEMORY);
#endif /* UNICODE */

    IOleInPlaceFrame_SetActiveObject (lpdoc->lpIpData->lpFrame,
                                      (LPOLEINPLACEACTIVEOBJECT) &lpdoc->m_IPActive,
                                      lpObjName);
    if (lpdoc->lpIpData->lpUIWindow) {
        IOleInPlaceUIWindow_SetActiveObject (lpdoc->lpIpData->lpUIWindow,
                                             (LPOLEINPLACEACTIVEOBJECT) &lpdoc->m_IPActive,
                                             lpObjName);
    }

#ifndef UNICODE
    FreeUnicodeString(lpObjName);
#endif

    ghwndCntr = lpdoc->hwndParent;

    //Create and initialize the hatch window to surround the Mplayer window.
    if (!ghwndIPHatch)
    {
        RegisterHatchWindowClass(ghInst);
        if ( !(ghwndIPHatch = CreateHatchWindow(lpdoc->hwndParent,ghInst)))
            goto errRtn;
        gfnHatchWndProc = (WNDPROC)GetWindowLongPtr(ghwndIPHatch, GWLP_WNDPROC);
        SetWindowLongPtr(ghwndIPHatch, GWLP_WNDPROC, (LONG_PTR)SubClassedHatchWndProc);
    }


    SetParent(ghwndIPHatch, ghwndCntr);

	SetFocus(ghwndIPHatch);

    CopyRect(&hatchrc, &rcPos);

#define EB_HATCHWIDTH       (0 * sizeof(INT))
    if (verb == OLEIVERB_PRIMARY)
    {
        /* I don't want to show the hatch window on play, because it looks
         * really bad in PowerPoint.  Can't make it invisible, because
         * the app window is its child, and it inherits the flag.
         * Instead, just make it of zero width.
         */
        SETWINDOWUINT(ghwndIPHatch, EB_HATCHWIDTH, 0);
    }
    else
    {
        SETWINDOWUINT(ghwndIPHatch, EB_HATCHWIDTH, DEF_HATCH_SZ);
        InflateRect(&hatchrc, DEF_HATCH_SZ, DEF_HATCH_SZ);
    }


    SetHatchRect(ghwndIPHatch,(LPRECT)&hatchrc);


    *lphwnd = ghwndIPHatch;

    //If we are going to Play inplace, do the minimum stuff and return.
    if (verb == OLEIVERB_PRIMARY)
    {
        gfOle2IPPlaying = TRUE;

        GetWindowRect(ghwndCntr,(LPRECT)&rcVis);
        MapWindowPoints(NULL,ghwndCntr,(LPPOINT)&rcVis, 2);
        SetHatchWindowSize(ghwndIPHatch, (LPRECT)&rcPos,(LPRECT)&rcVis, (LPPOINT)&gHatchOffset,FALSE);
        MoveWindow(ghwndApp, 0, 0, rcPos.right  - rcPos.left, rcPos.bottom - rcPos.top, TRUE);
        InPlaceCreateControls(TRUE);
        ActivateTools(lpdoc, TRUE);
        TransferTools(ghwndApp);

        ClientToScreen(lpdoc->hwndParent, (LPPOINT)&rcPos);
        ClientToScreen(lpdoc->hwndParent, (LPPOINT)&rcPos+1);

        lpdoc->hwndParent = NULL;

/* MENU STUFF */
        /* We have to set the menus even if we're only playing, because otherwise
         * Word doesn't believe we're in-place active, and doesn't send us any
         * deactivation notification when the user clicks outside us.
         */
        AssembleMenus (lpdoc, TRUE);

        if ((error = GetScode(IOleInPlaceFrame_SetMenu (lpdoc->lpIpData->lpFrame,
                                lpdoc->lpIpData->hmenuShared,
                                lpdoc->lpIpData->holemenu,
                                lpdoc->hwnd))) != S_OK)
                goto errRtn;
/* END MENU STUFF */

        *lprect = rcPos;

        ShowWindow(ghwndIPHatch, SW_SHOW);
        return NOERROR;
    }

    //Edit InPlace.


    if (!(gwDeviceID == (UINT)0 || !(gwDeviceType & DTMCI_CANWINDOW)))
        //No resize handles.
        SetHatchWindowSize(ghwndIPHatch, (LPRECT)&rcPos,(LPRECT)&rcVis, (LPPOINT)&gHatchOffset,TRUE);
    else
        //There will be resize handles.
        SetHatchWindowSize(ghwndIPHatch, (LPRECT)&rcPos,(LPRECT)&rcVis, (LPPOINT)&gHatchOffset,FALSE);

    gfOle2IPEditing = TRUE;

    if (!SkipInPlaceEdit)           //don't layout and transfer the tools
    {                                // if we are just reactivating.
        DestroyWindow(ghwndStatic);
        ghwndStatic = CreateStaticStatusWindow(ghwndApp, FALSE);
        SendMessage(ghwndStatic, WM_SETFONT, (UINT_PTR)ghfontMap, 0);
        Layout();
        InPlaceCreateControls(FALSE);
    }

    else
        SetParent (lpdoc->hwnd, ghwndIPHatch);

    TransferTools(ghwndIPToolWindow);

    if ((error = GetScode(AssembleMenus (lpdoc, FALSE))) != S_OK)
        goto errRtn;

    ShowWindow (lpdoc->hwnd, SW_HIDE);
    // currently we are not using the pane

    // prevent OnDataChange() notification
    lpdoc->lpIpData->fNoNotification = FALSE;

    if ((error = GetScode(IOleInPlaceFrame_SetMenu (lpdoc->lpIpData->lpFrame,
                            lpdoc->lpIpData->hmenuShared,
                            lpdoc->lpIpData->holemenu,
                            lpdoc->hwnd))) != S_OK)
            goto errRtn;

    if ((error = GetScode(ActivateTools(lpdoc,FALSE))) != S_OK)
            goto errRtn;

    ShowWindow(ghwndIPHatch,SW_SHOW);
    ShowWindow(ghwndMCI,SW_SHOW);

    ClientToScreen(lpdoc->hwndParent, (LPPOINT)&rcPos);
    ClientToScreen(lpdoc->hwndParent, (LPPOINT)&rcPos+1);

    *lprect = rcPos;
    if (SkipInPlaceEdit)
        OffsetRect(&gInPlacePosRect,rcPos.left-gInPlacePosRect.left,
                rcPos.top-gInPlacePosRect.top);

    else
        gInPlacePosRect = rcPos;
    return NOERROR;

errRtn:
    DoInPlaceDeactivate(lpdoc);
    TransferTools(ghwndApp);
    RETURN_RESULT(error);

errActivate:
    IOleInPlaceSite_Release(lpIPSite);

    FreeInPlaceDataBlock (lpdoc);
    RETURN_RESULT( error);
}

#if 0
HMENU GetInPlaceMenu(void)
{
    if (ghInPlaceMenu)
    return GetSubMenu(ghInPlaceMenu,0);
    else
    {
        ghInPlaceMenu = LoadMenu(ghInst, TEXT("InPlaceMenu"));
        return GetSubMenu(ghInPlaceMenu,0);
    }
}
#endif

/**************************************************************************
*   AssembleMenus:
*   This function merges our menu with that of the client.
***************************************************************************/
STDMETHODIMP AssembleMenus (LPDOC lpdoc, BOOL fPlayOnly)
{

    HMENU       hmenuMain = ghMenu;
    HMENU       hmenuEditPopup = GetSubMenu(hmenuMain, menuposEdit);
    HMENU       hmenuDevicePopup = GetSubMenu(hmenuMain, menuposDevice);
    HMENU       hmenuScalePopup = GetSubMenu(hmenuMain, menuposScale);
    //HMENU       hmenuCommandPopup = GetInPlaceMenu();
    HMENU       hmenuHelpPopup = GetSubMenu(hmenuMain, menuposHelp);

    HMENU       hmenuShared;
    LONG FAR*   lpMenuWidths;
    SCODE       error = S_OK;
    UINT        uPos;
    UINT        uPosStart;
    static TCHAR szEdit[40] = TEXT("");
    static TCHAR szInsert[40] = TEXT("");
    static TCHAR szScale[40] = TEXT("");
    //static TCHAR szCommand[40] = TEXT("");
    static TCHAR szHelp[40] = TEXT("");

    if (szEdit[0] == TEXT('\0'))
    {
        LOADSTRING(IDS_EDITMENU, szEdit);
        LOADSTRING(IDS_INSERTMENU, szInsert);
        LOADSTRING(IDS_SCALEMENU, szScale);
        //LOADSTRING(IDS_COMMANDMENU, szCommand);
        LOADSTRING(IDS_HELPMENU, szHelp);
    }

    lpMenuWidths = lpdoc->lpIpData->menuWidths.width;
    hmenuShared = CreateMenu();
    if((error = GetScode(IOleInPlaceFrame_InsertMenus (lpdoc->lpIpData->lpFrame,
                            hmenuShared, &lpdoc->lpIpData->menuWidths))) !=S_OK)
    {
        if (hmenuShared)
            DestroyMenu(hmenuShared);
        RETURN_RESULT( error);
    }

    if(fPlayOnly)
    {
        /* No server menu items if we're only playing:
         */
        lpMenuWidths[1] = lpMenuWidths[3] = lpMenuWidths[5] = 0;
    }
    else
    {
        uPos = (UINT)lpMenuWidths[0]; /* # of menus in the FILE group */
        uPosStart = uPos;

        InsertMenu (hmenuShared, (WORD)uPos,
                MF_BYPOSITION | MF_POPUP, (UINT_PTR)hmenuEditPopup, szEdit);
        uPos++;

        lpMenuWidths[1] = uPos - uPosStart;

        /* Insert OBJECT group menus */

        uPos += (UINT)lpMenuWidths[2];
        uPosStart = uPos;

        InsertMenu (hmenuShared, (WORD)uPos,
                MF_BYPOSITION | MF_POPUP, (UINT_PTR)hmenuDevicePopup, szInsert);
        uPos++;
        InsertMenu (hmenuShared, (WORD)uPos,
                MF_BYPOSITION | MF_POPUP, (UINT_PTR)hmenuScalePopup,  szScale);
        uPos++;
        //InsertMenu (hmenuShared, (WORD)uPos,
        //        MF_BYPOSITION | MF_POPUP, (UINT)hmenuCommandPopup,    szCommand);
        //uPos++;
        lpMenuWidths[3] = uPos - uPosStart;

        /* Insert HELP group menus */

        uPos += (UINT) lpMenuWidths[4]; /* # of menus in WINDOW group */
        uPosStart = uPos;

        InsertMenu (hmenuShared, (WORD)uPos, MF_BYPOSITION | MF_POPUP, (UINT_PTR)hmenuHelpPopup,
                szHelp);
        uPos++;

        lpMenuWidths[5] = uPos - uPosStart;
    }

    if(!(lpdoc->lpIpData->holemenu = OleCreateMenuDescriptor (hmenuShared,
                            &lpdoc->lpIpData->menuWidths)))
         RETURN_RESULT( E_OUTOFMEMORY);

    lpdoc->lpIpData->hmenuShared = hmenuShared;
    RETURN_RESULT( error);
}

//Removes our menu from the shared menu,
STDMETHODIMP DisassembleMenus (LPDOC lpdoc)
{

    HMENU   hmenuMain = ghMenu;
    HMENU   hmenuEditPopup = GetSubMenu(hmenuMain, menuposEdit);
    HMENU   hmenuDevicePopup = GetSubMenu(hmenuMain, menuposDevice);
    HMENU   hmenuScalePopup = GetSubMenu(hmenuMain, menuposScale);
    //HMENU   hmenuCommandPopup = GetInPlaceMenu();
    HMENU   hmenuHelpPopup = GetSubMenu(hmenuMain, menuposHelp);
    HMENU   hmenuTmp;
    HMENU   hmenuShared = lpdoc->lpIpData->hmenuShared;
    int     i, n, cnt;
    SCODE   error = S_OK;

    OleDestroyMenuDescriptor (lpdoc->lpIpData->holemenu);
    lpdoc->lpIpData->holemenu = NULL;

    if(!(lpdoc->lpIpData->hmenuShared))
         RETURN_RESULT( error);
    n = GetMenuItemCount(hmenuShared);
    cnt = 0;
    i = 0;
    while (i < n) {
        hmenuTmp = GetSubMenu(hmenuShared, i);
        if (hmenuTmp == hmenuEditPopup
                || hmenuTmp == hmenuDevicePopup
                || hmenuTmp == hmenuHelpPopup
                //|| hmenuTmp == hmenuCommandPopup
                || hmenuTmp == hmenuScalePopup  ) {
            RemoveMenu (hmenuShared, i, MF_BYPOSITION);
            ++cnt;
            if (cnt == 4) { // added 3 (4 if command menu included) popup menus.
                break;
            }
            --n;
        }
        else
            ++i;
    }

    IOleInPlaceFrame_RemoveMenus (lpdoc->lpIpData->lpFrame,
                                  lpdoc->lpIpData->hmenuShared);
    DestroyMenu(lpdoc->lpIpData->hmenuShared);
    lpdoc->lpIpData->hmenuShared = NULL;
    RETURN_RESULT( error);
}


void AllocInPlaceDataBlock (LPDOC lpdoc)
{
    // When this app is ready to support mutiple objects (documents), these
    // structures should be allocated dynamically one per object.

    static INPLACEDATA  IpData;

    lpdoc->lpIpData = (LPINPLACEDATA) &IpData;
    lpdoc->lpIpData->lpFrame = NULL;
    lpdoc->lpIpData->lpUIWindow = NULL;
    lpdoc->lpIpData->fInContextHelpMode = FALSE;
}


void FreeInPlaceDataBlock (LPDOC lpdoc)
{
    lpdoc->lpIpData = NULL;
}


void DoInPlaceDeactivate (LPDOC lpdoc)
{
    if (!(lpdoc->lpIpData))
        return;
    ShowWindow(ghwndApp,SW_HIDE);
    IOleInPlaceObject_InPlaceDeactivate ((LPOLEINPLACEOBJECT)&lpdoc->m_InPlace);
}


/**************************************************************************
*   ToolWndProc:
*   This is the Window proc for the ToolWindow/Windows we will be trasnferring
*   to the client window. Some messages are routed to the MPlayer main window
*   to ensure proper operation.
***************************************************************************/
LONG_PTR FAR PASCAL ToolWndProc (HWND hwnd, unsigned message, WPARAM wparam,
                LPARAM lparam)
{
    switch(message)
    {
    case WM_COMMAND:
        PostMessage(ghwndApp,WM_COMMAND,
        wparam,lparam);
        break;
    case WM_NEXTDLGCTL:
    case WM_CTLCOLOR:
    case WM_HSCROLL:
        return (SendMessage(ghwndApp,message,wparam,lparam));
    default:
        return DefWindowProc(hwnd,message,wparam,lparam);
    }

    return 0;
}

/**************************************************************************
*   RegisterToolWinClasses:
*   Register the WindowClasses for the Toolbar windows we use to display
*    in the client document.
***************************************************************************/
BOOL RegisterToolWinClasses()
{
    WNDCLASS  wc;


    wc.lpszClassName = TEXT("ObjTool");
    wc.lpfnWndProc   = ToolWndProc;
    wc.style         = 0;
    wc.hInstance     = ghInst;
    wc.hIcon         = NULL;
    wc.cbClsExtra    = 4;
    wc.cbWndExtra    = 0;
    wc.lpszMenuName  = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);

    if (!RegisterClass(&wc))
        return FALSE;

    return TRUE;
}



/**************************************************************************
*   InPlaceCreateControls:
*   This function creates the toolbar windows we will display in the client
*   and transfers the tool button to these windows by changing parents
*   and repositioning them.
*   If fPlayOnly is true all we need is a Dummy toolbar to fill space on
*   the top of the container. Don't transfer the tools.
***************************************************************************/
void InPlaceCreateControls(BOOL fPlayOnly)
{
    RECT    rc;

    if(IsWindow(ghwndIPToolWindow))
        return;
    RegisterToolWinClasses();
    GetWindowRect(GetDesktopWindow(),&rc);
    toolbarwidth =  2*(rc.right - rc.left);
    IOleInPlaceFrame_GetWindow (docMain.lpIpData->lpFrame, &ghwndFrame);

    ghwndIPToolWindow = CreateWindowEx(gfdwFlagsEx,
                                       TEXT("ObjTool"),
                                       NULL,
                                       WS_CHILD | WS_BORDER,
                                       0, 0,
                                       toolbarwidth,
                                       3*TOOL_WIDTH+1,
                                       ghwndFrame,
                                       NULL,
                                       ghInst,
                                       NULL);

    ShowWindow(ghwndIPToolWindow, SW_HIDE);
    if (fPlayOnly)
        return;

    ghwndIPScrollWindow = CreateWindowEx(gfdwFlagsEx,
                                         TEXT("ObjTool"),
                                         NULL,
                                         WS_CHILD | WS_BORDER,
                                         0, 0,
                                         toolbarwidth,
                                         3*TOOL_WIDTH+1,
                                         ghwndFrame,
                                         NULL,
                                         ghInst,
                                         NULL);

    ShowWindow(ghwndIPScrollWindow, SW_HIDE);
}




/**************************************************************************
*   SubClassedHatchWndProc:
*   The Hatch Window is created in the OLE2UI.LIB. The window proc
*   is also specified there. But in order to do things like resizing
*   the Mplayer when the handles in the hatch window are dragged
*   we need to subclass the window.
***************************************************************************/
LONG_PTR FAR PASCAL SubClassedHatchWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    static BOOL fCapture = FALSE;
    static RECT hatchRC;
    RECT rc;
    static POINT ptLast;
    POINT pt;
    HDC hdcDeskTop;
    HPEN hpenOld;
    HBRUSH hbrushOld;
    int nropOld;
    int nBkOld;
    HPEN hpen;
    static int dL,dR, dT, dB;
    static int left, right, top, bottom;


    switch(wMsg)
    {
    case WM_LBUTTONDOWN:    //Check to see if the click is on the resize handles.
                            //If yes then capture the mouse.

        if(!GETWINDOWUINT(ghwndIPHatch,EW_HATCH_HANDLE))
            break;

        if(gfOle2IPPlaying)
            break;

        GetHatchRect(ghwndIPHatch, &hatchRC);

        pt.x = (int)(SHORT)LOWORD(lParam);
        pt.y = (int)(SHORT)HIWORD(lParam);

        left = right = top = bottom = 0;

        rc.left = hatchRC.left;
        rc.top = hatchRC.top;
        rc.right = rc.left + DEF_HATCH_SZ + 1;
        rc.bottom = rc.top + DEF_HATCH_SZ + 1;

        if(PtInRect((LPRECT)&rc,pt))
        left = top = 1;

        rc.top = hatchRC.top+(hatchRC.bottom-hatchRC.top-DEF_HATCH_SZ-1)/2;
        rc.bottom = rc.top + DEF_HATCH_SZ + 1;

        if(PtInRect((LPRECT)&rc,pt))
        left = 1;

        rc.top = hatchRC.bottom-DEF_HATCH_SZ-1;
        rc.bottom = rc.top + DEF_HATCH_SZ + 1;

        if(PtInRect((LPRECT)&rc,pt))
        {
        bottom = 1;
        left = 1;
        }

        rc.left = hatchRC.right - DEF_HATCH_SZ-1;
        rc.right = rc.left + DEF_HATCH_SZ + 1;
        if(PtInRect((LPRECT)&rc,pt))
        {
        bottom = 1;
        right = 1;
        }
        rc.top = hatchRC.top+(hatchRC.bottom-hatchRC.top-DEF_HATCH_SZ-1)/2;
        rc.bottom = rc.top + DEF_HATCH_SZ + 1;
        if(PtInRect((LPRECT)&rc,pt))
        right = 1;

        rc.top = hatchRC.top;
        rc.bottom = rc.top + DEF_HATCH_SZ + 1;
        if(PtInRect((LPRECT)&rc,pt))
        {
        top = 1;
        right = 1;
        }

        rc.left = hatchRC.left + (hatchRC.right - hatchRC.left - DEF_HATCH_SZ-1)/2;
        rc.right = rc.left + DEF_HATCH_SZ + 1;
        if(PtInRect((LPRECT)&rc,pt))
        top = 1;

        rc.top = hatchRC.bottom-DEF_HATCH_SZ-1;
        rc.bottom = rc.top + DEF_HATCH_SZ + 1;
        if(PtInRect((LPRECT)&rc,pt))
        bottom = 1;

        if (!(left || right || top || bottom))
        break;
        fCapture = TRUE;
        SetCapture(hwnd);
        ptLast = pt;
        MapWindowPoints(hwnd,NULL,(LPPOINT)&hatchRC,2);
        dL = dR = dT = dB = 0;
        hpen = CreatePen(PS_DASH, 1, 0x00000000);

        hdcDeskTop = GetDC(NULL);
        hpenOld = SelectObject (hdcDeskTop, hpen);
        hbrushOld = SelectObject (hdcDeskTop,
            GetStockObject(HOLLOW_BRUSH));
        nropOld = GetROP2(hdcDeskTop);
        SetROP2(hdcDeskTop, R2_NOT);
        nBkOld = GetBkMode(hdcDeskTop);
        SetBkMode(hdcDeskTop, TRANSPARENT);

        Rectangle(hdcDeskTop, hatchRC.left+dL, hatchRC.top+dT,
            hatchRC.right+dR, hatchRC.bottom+dB);


        SetBkMode(hdcDeskTop, nBkOld);
        SetROP2(hdcDeskTop, nropOld);
        SelectObject(hdcDeskTop, hbrushOld);
        SelectObject(hdcDeskTop, hpenOld);
        DeleteObject (hpen);
        ReleaseDC(NULL, hdcDeskTop);

        break;

    case WM_MOUSEMOVE:          //If we have the capture draw the resize rectangles.
        if (!fCapture)
        break;
        else {

            pt.x = (int)(SHORT)LOWORD(lParam);
            pt.y = (int)(SHORT)HIWORD(lParam);

        hpen = CreatePen(PS_DASH, 1, 0x00000000);

        hdcDeskTop = GetDC(NULL);
        hpenOld = SelectObject (hdcDeskTop, hpen);
        hbrushOld = SelectObject (hdcDeskTop,
            GetStockObject(HOLLOW_BRUSH));
        nropOld = GetROP2(hdcDeskTop);
        SetROP2(hdcDeskTop, R2_NOT);
        nBkOld = GetBkMode(hdcDeskTop);
        SetBkMode(hdcDeskTop, TRANSPARENT);

        Rectangle(hdcDeskTop, hatchRC.left+dL, hatchRC.top+dT,
            hatchRC.right+dR, hatchRC.bottom+dB);

        dL = dR = pt.x - ptLast.x;
        dT = dB = pt.y - ptLast.y;
        dL *= left;
        dR *= right;
        dT *= top;
        dB *= bottom;

        Rectangle(hdcDeskTop, hatchRC.left+dL, hatchRC.top+dT,
            hatchRC.right+dR, hatchRC.bottom+dB);

        SetBkMode(hdcDeskTop, nBkOld);
        SetROP2(hdcDeskTop, nropOld);
        SelectObject(hdcDeskTop, hbrushOld);
        SelectObject(hdcDeskTop, hpenOld);
        if (hpen)
            DeleteObject (hpen);
        ReleaseDC(NULL, hdcDeskTop);
        }

        break;

    case WM_LBUTTONUP:  //release capture and resize.
        if (!fCapture)
        break;
        else {
        hpen = CreatePen(PS_DASH, 1, 0x00000000);

        hdcDeskTop = GetDC(NULL);
        hpenOld = SelectObject (hdcDeskTop, hpen);
        hbrushOld = SelectObject (hdcDeskTop,
            GetStockObject(HOLLOW_BRUSH));
        nropOld = GetROP2(hdcDeskTop);
        SetROP2(hdcDeskTop, R2_NOT);
        nBkOld = GetBkMode(hdcDeskTop);
        SetBkMode(hdcDeskTop, TRANSPARENT);

        Rectangle(hdcDeskTop, hatchRC.left+dL, hatchRC.top+dT,
            hatchRC.right+dR, hatchRC.bottom+dB);


        SetBkMode(hdcDeskTop, nBkOld);
        SetROP2(hdcDeskTop, nropOld);
        SelectObject(hdcDeskTop, hbrushOld);
        SelectObject(hdcDeskTop, hpenOld);
        DeleteObject (hpen);
        ReleaseDC(NULL, hdcDeskTop);
        ReleaseCapture();
        }
        fCapture = FALSE;

        GetWindowRect(ghwndApp,&hatchRC);
        hatchRC.left += dL;
        hatchRC.right += dR;
        hatchRC.top += dT;
        hatchRC.bottom += dB;
        MapWindowPoints(NULL,ghwndCntr,(LPPOINT)&hatchRC, 2);

        if (gwStatus != MCI_MODE_STOP)
            PostMessage(ghwndApp, WM_COMMAND, ID_STOP, 0L);

        // Negotiate with client for space. We accept the size specified by client.
        DPFI("Hatch Resize: Before OnPosRectChange: %d, %d, %d, %d\r\n", hatchRC);
        if (!gfInPPViewer)
            IOleInPlaceSite_OnPosRectChange(docMain.lpIpData->lpSite, &hatchRC);

        SendDocMsg((LPDOC)&docMain, OLE_CHANGED);

        break;

    case WM_PAINT:
    {
        HDC hdc;
        HDC hdcmem;
        RECT rcH;
        HBITMAP hbm;
        BITMAP bm;

        if(ghwndMCI)
        break;
        CallWindowProc(gfnHatchWndProc, hwnd, wMsg, wParam, lParam);
        hdc = GetDC(hwnd);
        GetHatchRect(hwnd, (LPRECT)&rcH);
        InflateRect((LPRECT)&rcH,-DEF_HATCH_SZ,-DEF_HATCH_SZ);
        hbm = BitmapMCI();

        hdcmem = CreateCompatibleDC(hdc);
        if(!hdcmem)
            return(E_FAIL);
        SelectObject(hdcmem,hbm);
        GetObject(hbm,sizeof(bm),(LPVOID)&bm);
        StretchBlt(hdc,rcH.left,rcH.top,rcH.right-rcH.left,rcH.bottom-rcH.top,hdcmem,
               0,0,bm.bmWidth,bm.bmHeight,SRCCOPY);
        DeleteDC(hdcmem);
        ReleaseDC(ghwndIPHatch,hdc);


        return 0L;

        }

    }
    return CallWindowProc(gfnHatchWndProc, hwnd, wMsg, wParam, lParam);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\mci.c ===
/*-----------------------------------------------------------------------------+
| MCI.C                                                                        |
|                                                                              |
| This file contains the routines which the media player uses to interact with |
| the Media Control Interface (MCI).                                           |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

#undef NOGDICAPMASKS           // CC_*, LC_*, PC_*, CP_*, TC_*, RC_
#undef NOSCROLL
#undef NOWINOFFSETS
#undef NODRAWTEXT

#include <windows.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <stdlib.h>
#include <shellapi.h>
#include "digitalv.h"
#include "mpole.h"
#include "mplayer.h"
#include "ctrls.h"
#include "errprop.h"
#include "utils.h"

#ifndef MCI_MCIAVI_PLAY_WINDOW
// force MCIAVI to play windowed in play in place
#define MCI_MCIAVI_PLAY_WINDOW                0x01000000L
#endif

// gets the name of the current device
STATICDT SZCODE   aszInfoProduct[]    = TEXT("info zyzsmag product");
STATICDT SZCODE   aszMMPName[]    = TEXT("Microsoft Multimedia Movie Player");

//#ifdef CHICAGO_PRODUCT
#define NEW_MCI_DIALOG
//#endif

#ifdef NEW_MCI_DIALOG

STATICDT SZCODE	  aszMCIAVIOpt[] =	TEXT("Software\\Microsoft\\Multimedia\\Video For Windows\\MCIAVI");
STATICDT SZCODE   aszDefVideoOpt[] = TEXT("DefaultOptions");

//
// !!! Caution.  These are stolen from \MCIAVI\graphic.h and are registry values
// for MCIAVI.
//
#define MCIAVIO_ZOOMBY2			0x00000100L
#define MCIAVIO_1QSCREENSIZE		0x00010000L
#define MCIAVIO_2QSCREENSIZE		0x00020000L
#define MCIAVIO_3QSCREENSIZE		0x00040000L
#define MCIAVIO_MAXWINDOWSIZE		0x00080000L
#define MCIAVIO_DEFWINDOWSIZE		0x00000000L
#define MCIAVIO_WINDOWSIZEMASK		0x000f0000L

#endif /* NEW_MCI_DIALOG */

extern HMENU    ghMenu;

/*
 * global variables
 *
 * <gwDeviceID> is the MCI device ID of the currently-open device, or NULL
 * if no device is open.  <gdwMediaLength> is the length of the entire medium
 * in milliseconds.  If <gwDeviceID> is not NULL, then:
 *   -- <gwNumTracks> is the number of tracks on the medium, or 0 if the
 *      medium doesn't support tracks
 *   -- <gwFirstTrack> is the number of the first track, currently constrained
 *      to be 0 or 1.
 *   -- <gadwTrackStart> is an array; the i-th element specifies the position
 *      of track i (starting from track 0), in milliseconds from the beginning
 *      of the medium
 *   -- <gfCanEject> is TRUE if the medium can be ejected
 *
 */

UINT            gwDeviceID;            /* MCI device ID of the current device */
UINT            gwDeviceType;          /* DTMCI_ flags of current device      */
DWORD           gdwMediaLength;        /* length in msec of the entire medium */
DWORD           gdwMediaStart;         /* start time in msec of medium        */
UINT            gwNumTracks;           /* # of tracks in the medium           */
UINT            gwFirstTrack;          /* # of first track                    */
DWORD NEAR *    gadwTrackStart;        /* array of track start positions      */
DWORD           gdwLastSeekToPosition; /* Last requested seek position        */
int extHeight;
int extWidth;

STATICDT SZCODE   aszMPlayerAlias[]     = TEXT("zyzsmag");
STATICDT SZCODE   aszStatusCommand[]    = TEXT("status zyzsmag mode");
STATICDT SZCODE   aszStatusWindow[]     = TEXT("status zyzsmag window handle");
STATICDT SZCODE   aszWindowShow[]       = TEXT("window zyzsmag state show");
STATICDT SZCODE   aszWindowHide[]       = TEXT("window zyzsmag state hide");
STATICDT SZCODE   aszSeekExactOn[]      = TEXT("set zyzsmag seek exactly on");
STATICDT SZCODE   aszSeekExactOff[]     = TEXT("set zyzsmag seek exactly off");
STATICDT SZCODE   aszSeekExact[]        = TEXT("status zyzsmag seek exactly");

STATICDT SZCODE   aszMCI[]              = MCI_SECTION;

extern UINT     gwCurScale;            // either ID_FRAMES, ID_TIME, ID_TRACKS

//#define MCI_CONFIG  0x900          // these are not found in MMSYSTEM.H
//#define MCI_TEST    0x00000020L

HWND            ghwndMCI = NULL;        /* current window for window objects */
#ifdef NEW_MCI_DIALOG
RECT            grcInitSize = { 0, 0, 0, 0 };
#endif
RECT            grcSize;                /* size of MCI object */
BOOL            gfInPlayMCI = FALSE;
extern WNDPROC  gfnMCIWndProc;
extern HWND     ghwndSubclass;



/* Status mapping stuff:
 */
typedef struct _MCI_STATUS_MAPPING
{
    WORD    Mode;
    WORD    ResourceID;
    LPTSTR  pString;
}
MCI_STATUS_MAPPING, *PMCI_STATUS_MAPPING;

MCI_STATUS_MAPPING MCIStatusMapping[] =
{
    { MCI_MODE_NOT_READY,   IDS_SSNOTREADY,     NULL },
    { MCI_MODE_STOP,        IDS_SSSTOPPED,      NULL },
    { MCI_MODE_PLAY,        IDS_SSPLAYING,      NULL },
    { MCI_MODE_RECORD,      IDS_SSRECORDING,    NULL },
    { MCI_MODE_SEEK,        IDS_SSSEEKING,      NULL },
    { MCI_MODE_PAUSE,       IDS_SSPAUSED,       NULL },
    { MCI_MODE_OPEN,        IDS_SSOPEN,         NULL },
    { MCI_VD_MODE_PARK,     IDS_SSPARKED,       NULL },
    { 0,                    IDS_SSUNKNOWN,      NULL }
};

static TCHAR szNULL[] = TEXT("");

/* Devices we know about, as they appear in system.ini, or the registry:
 */
SZCODE szCDAudio[]     = TEXT("cdaudio");
SZCODE szVideoDisc[]   = TEXT("videodisc");
SZCODE szSequencer[]   = TEXT("sequencer");
SZCODE szVCR[]         = TEXT("vcr");
SZCODE szWaveAudio[]   = TEXT("waveaudio");
SZCODE szAVIVideo[]    = TEXT("avivideo");


STRING_TO_ID_MAP DevToDevIDMap[] =
{
    { szCDAudio,    DTMCI_CDAUDIO   },
    { szVideoDisc,  DTMCI_VIDEODISC },
    { szSequencer,  DTMCI_SEQUENCER },
    { szVCR,        DTMCI_VCR       },
    { szWaveAudio,  DTMCI_WAVEAUDIO },
    { szAVIVideo,   DTMCI_AVIVIDEO  }
};


void LoadStatusStrings(void);
STATICFN BOOL NEAR PASCAL CheckErrorMCI(DWORD dwRet);
extern LPTSTR FAR FileName(LPCTSTR szPath);

HPALETTE CopyPalette(HPALETTE hpal);
HANDLE   PictureFromBitmap(HBITMAP hbm, HPALETTE hpal);
HANDLE   FAR PASCAL PictureFromDib(HANDLE hdib, HPALETTE hpal);
HANDLE   FAR PASCAL DibFromBitmap(HBITMAP hbm, HPALETTE hpal);



LONG_PTR FAR PASCAL _EXPORT MCIWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

//
// we will either send every command with a MCI_NOTIFY, or we will
// not.
//

  #define F_NOTIFY  MCI_NOTIFY
//#define F_NOTIFY  0

BOOL FAR PASCAL InitMCI(HANDLE hPrev, HANDLE hInst)
{
    if (!hPrev)
    {
        WNDCLASS cls;

        cls.lpszClassName   = MCI_WINDOW_CLASS;
        cls.lpfnWndProc     = MCIWndProc;
        cls.style           = CS_HREDRAW | CS_VREDRAW | CS_SAVEBITS |
                              CS_DBLCLKS;
        cls.hCursor         = LoadCursor(NULL,IDC_ARROW);
        cls.hIcon           = NULL;
        cls.lpszMenuName    = NULL;
        cls.hbrBackground   = (HBRUSH)(COLOR_WINDOW + 1);
        cls.hInstance       = hInst;
        cls.cbClsExtra      = 0;
        cls.cbWndExtra      = 0;

        if (!RegisterClass(&cls))
            return FALSE;
    }

    LoadStatusStrings();

    return TRUE;
}


/* LoadStatusStrings
 *
 * Fixes up the status-mapping table with pointers to strings loaded
 * from resources.  This need be called only on initialisation.
 *
 * 2 February 1994, andrewbe, hardly at all based on the original.
 */
void LoadStatusStrings(void)
{
    int   i;
    TCHAR Buffer[80];

    for( i = 0; i < sizeof(MCIStatusMapping) / sizeof(*MCIStatusMapping); i++ )
    {
        if( LOADSTRING( MCIStatusMapping[i].ResourceID, Buffer ) )
        {
            MCIStatusMapping[i].pString = AllocStr( Buffer );

            if( MCIStatusMapping[i].pString == NULL )
            {
                MCIStatusMapping[i].pString = szNULL;
            }
        }
        else
        {
            DPF0( "LoadStatusStrings failed to load string ID %d\n", MCIStatusMapping[i].ResourceID );

            MCIStatusMapping[i].pString = szNULL;
        }
    }
}



/* MapModeToStatusString
 *
 * Given an MCI mode, scans the mapping table to find the corresponding string.
 * In the event that an unknown mode is passed in (which shouldn't really happen),
 * the last string in the mapping table is returned.
 *
 * 2 February 1994, andrewbe
 */
LPTSTR MapModeToStatusString( WORD Mode )
{
    int i;

    for( i = 0; i < sizeof(MCIStatusMapping) / sizeof(*MCIStatusMapping); i++ )
    {
        if( MCIStatusMapping[i].Mode == Mode )
        {
            return MCIStatusMapping[i].pString;
        }
    }

    /* The following assumes that the last in the array of status mappings
     * contains a pointer to the "(unknown)" string:
     */
    return MCIStatusMapping[sizeof(MCIStatusMapping) / sizeof(*MCIStatusMapping) - 1].pString;
}


/******************************Public*Routine******************************\
* IsCdromTrackAudio
*
* Filched from CD Player
*
\**************************************************************************/
BOOL IsCdromTrackAudio(
    MCIDEVICEID DevHandle,
    int iTrackNumber)
{
    MCI_STATUS_PARMS mciStatus;

    ZeroMemory( &mciStatus, sizeof(mciStatus) );
    mciStatus.dwItem = MCI_CDA_STATUS_TYPE_TRACK;
    mciStatus.dwTrack = iTrackNumber + 1;

    mciSendCommand( DevHandle, MCI_STATUS, MCI_STATUS_ITEM | MCI_TRACK,
                    (DWORD_PTR)(LPVOID)&mciStatus);

    return mciStatus.dwReturn == MCI_CDA_TRACK_AUDIO;
}


/* IsCdromDataOnly
 *
 * It seems that MCICDA can handle CDs with some audio tracks, so just check
 * whether there is at least one audio track.
 *
 */
BOOL IsCdromDataOnly()
{
    MCI_STATUS_PARMS mciStatus;
    DWORD            dw;
    DWORD            iTrack;
    DWORD_PTR            NumTracks;

    /* gwNumTracks is set in UpdateMCI, but it hasn't been called
     * at this stage in the proceedings, and I'm not about to start
     * changing the order that things are done and bring this whole
     * flimsy edifice tumbling down.
     */
    ZeroMemory( &mciStatus, sizeof(mciStatus) );
    mciStatus.dwItem = MCI_STATUS_NUMBER_OF_TRACKS;
    dw = mciSendCommand(gwDeviceID, MCI_STATUS, MCI_STATUS_ITEM,
                        (DWORD_PTR)&mciStatus);

    /* Do NOT set gwNumtracks here, because this will result in an
     * access violation in CalcTicsOfDoom.  What a nightmare!
     */
    NumTracks = mciStatus.dwReturn;

    /* If there was an error or there are no tracks, let's hope MCICDA
     * will throw a wobbly.
     */
    if (dw != 0 || NumTracks == 0)
        return FALSE;

    /* Now run through the tracks until we find an audio one:
     */
    for (iTrack = 0; iTrack < NumTracks - 1; iTrack++)
    {
        if (IsCdromTrackAudio(gwDeviceID, iTrack))
            return FALSE;
    }

    return TRUE;
}


#ifdef NEW_MCI_DIALOG
//
// Read the MCIAVI playback options from the registry
//
DWORD ReadOptionsFromReg(void)
{
	HKEY hkVideoOpt;
	DWORD dwType;
	DWORD dwOpt;
	DWORD cbSize;

    if(RegCreateKey(HKEY_CURRENT_USER, (LPTSTR)aszMCIAVIOpt,  &hkVideoOpt))
		return 0 ;

    cbSize = sizeof(DWORD);
    if (RegQueryValueEx(hkVideoOpt, (LPTSTR)aszDefVideoOpt, NULL, &dwType,
		(LPBYTE)&dwOpt,&cbSize ))
    {
	dwOpt = 0;
	RegSetValueEx(hkVideoOpt, (LPTSTR)aszDefVideoOpt, 0, REG_DWORD,
		(LPBYTE)&dwOpt, sizeof(DWORD));
    }
	RegCloseKey(hkVideoOpt);
    return dwOpt;
}

//
// Obey the registry default sizing of Zoom by 2 and Fixed screen %.  Takes the
// registry values for MCIAVI and a rect, and either zooms it by 2 or replaces
// it with a constant size or leaves it alone.
//
void FAR PASCAL AlterRectUsingDefaults(LPRECT lprc)
{
        DWORD dwOptions;

	// This is only an MCIAVI hack.
	if ((gwDeviceType & DTMCI_DEVICE) != DTMCI_AVIVIDEO)
	    return;

	dwOptions = ReadOptionsFromReg();

	if (dwOptions & MCIAVIO_ZOOMBY2)
	    SetRect(lprc, 0, 0, lprc->right*2, lprc->bottom*2);

	else if (dwOptions & MCIAVIO_WINDOWSIZEMASK) {
		lprc->right = GetSystemMetrics (SM_CXSCREEN);
       		lprc->bottom = GetSystemMetrics (SM_CYSCREEN);
		switch(dwOptions & MCIAVIO_WINDOWSIZEMASK)
		{
		    case MCIAVIO_1QSCREENSIZE:
			SetRect(lprc, 0, 0, lprc->right/4, lprc->bottom/4);
			break;
		    case MCIAVIO_2QSCREENSIZE:
			SetRect(lprc, 0, 0, lprc->right/2, lprc->bottom/2);
			break;
		    case MCIAVIO_3QSCREENSIZE:
			SetRect(lprc, 0, 0, lprc->right*3/4, lprc->bottom*3/4);
			break;
		    case MCIAVIO_MAXWINDOWSIZE:
			SetRect(lprc, 0, 0, lprc->right, lprc->bottom);
			break;
		}
	}
}

#endif /* NEW_MCI_DIALOG */

/*
 * fOK = OpenMCI(szFile, szDevice)
 *
 * Open the file/device combination of <szFile> and <szDevice>.
 * <szFile> may be "" if a "pure device" (e.g. "CDAudio") is to be opened.
 * <szDevice> may be "" if a file is to be opened with an implicit type.
 * However, <szFile> and <szDevice> may not both be "".
 *
 * On success, return TRUE.  On failure, display an error message and
 * return FALSE.
 *
 */

BOOL FAR PASCAL OpenMCI(
    LPCTSTR szFile,        /* name of the media file to be loaded (or "")    */
    LPCTSTR szDevice)      /* name of the device to be opened (or "")        */
{
    MCI_OPEN_PARMS      mciOpen;    /* Structure for MCI_OPEN command */
    DWORD               dwFlags;
    DWORD               dw;
    HCURSOR             hcurPrev;
    HDRVR               hdrv;
    SHFILEINFO          sfi;
	HFILE				hFile;

    /*
     * This application is designed to handle only one device at a time,
     * so before opening a new device we should close the device that is
     * currently open (if there is one).
     *
     * in case the user is opening a file of the same device again, do
     * an OpenDriver to hold the DLL in memory.
     *
     */
    if (gwDeviceID && gwCurDevice > 0) {

#ifdef UNICODE
        hdrv = OpenDriver(garMciDevices[gwCurDevice].szDevice, aszMCI, 0);
#else
        //
        // There is only a UNICODE version of OpenDriver.  Unfortunately
        // the majority of this code is Ascii.  Convert the ASCII strings
        // to UNICODE, then call OpenDriver
        //
        WCHAR               waszMCI[sizeof(aszMCI)];
        WCHAR               wszDevice[40];
        AnsiToUnicodeString(aszMCI, waszMCI, UNKNOWN_LENGTH);
        AnsiToUnicodeString(garMciDevices[gwCurDevice].szDevice, wszDevice, UNKNOWN_LENGTH);
        hdrv = OpenDriver((LPCWSTR)garMciDevices[gwCurDevice].szDevice,
                          (LPCWSTR)aszMCI,
                          0);
#endif
    }
    else
        hdrv = NULL;

    CloseMCI(TRUE);

    //
    //  Store the displayable file/device name in <gachFileDevice>
    //
    if (szFile == NULL || szFile[0] == 0) {
        /* It's a device -- display the device name */
        lstrcpy(gachFileDevice, szDevice);

        if (gwCurDevice > 0)
            lstrcpy(gachWindowTitle,garMciDevices[gwCurDevice].szDeviceName);
        else
            lstrcpy(gachWindowTitle,gachFileDevice);
    } else {
        /* It's a file -- display the filename */
        lstrcpy(gachFileDevice,  szFile);  //!!!

        // Makes the window title be the name of the file being played
        lstrcpy(gachWindowTitle, FileName(gachFileDevice));
    }

    /* Get the display name for this file:
     */

    if (SHGetFileInfo(gachFileDevice, 0 /* No file attributes specified */,
                    &sfi, sizeof sfi, SHGFI_DISPLAYNAME))
        lstrcpy(gachWindowTitle, sfi.szDisplayName);

    //
    // Set caption to the WindowTitle
    //
    lstrcpy(gachCaption, gachWindowTitle);


    /*
     * because *most* MCI devices yield during the open call, we *must*
     * register our document *before* doing the open.  OLE does not expect
     * the server app to yield when exec'ed with a link request.
     *
     * if the open fails then we revoke our document right away.
     */

//  if (!gfEmbeddedObject)
//      RegisterDocument(0L,0L);

    /*
     * Show the hourglass cursor -- who knows how long this stuff
     * will take
     */

    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    DPF("OpenMCI: Device = %"DTS", File = %"DTS"\n", szDevice ? szDevice : TEXT("(null)"),szFile ? szFile : TEXT("(null)"));

    mciOpen.lpstrAlias = aszMPlayerAlias;
    dwFlags = MCI_OPEN_ALIAS;

    if (szFile == NULL || szFile[0] == 0) {

        /* Open a fileless (simple) device (e.g. "CDAudio") */

        mciOpen.lpstrDeviceType = szDevice;
        dwFlags |= MCI_WAIT | MCI_OPEN_TYPE | MCI_OPEN_SHAREABLE;
    } else if (szDevice == NULL || szDevice[0] == 0) {
        /*
         * Open a file; the correct device is determined implicitly by the
         * filename extension.
         *
         */
        mciOpen.lpstrElementName = szFile;
        mciOpen.lpstrDeviceType = NULL;
        dwFlags |= MCI_WAIT | MCI_OPEN_ELEMENT;
    } else {

        /* Open a file with an explicitly specified device */

        mciOpen.lpstrDeviceType = szDevice;
        mciOpen.lpstrElementName = szFile;
        dwFlags |= MCI_WAIT | MCI_OPEN_ELEMENT | MCI_OPEN_TYPE;
    }

    /*
     * Now that we have filled the parameter structure appropriately and
     * supplied the correct flags, send the actual MCI_OPEN message.
     *
     */

    //
    // What if the MCI device brings up an error box!  We don't want MPlayer
    // to be allowed to exit.
    //
    gfErrorBox++;

    dw = mciSendCommand((MCIDEVICEID)0, MCI_OPEN, dwFlags,(DWORD_PTR)(LPVOID)&mciOpen);

    if (dw != 0 && (dwFlags & MCI_OPEN_SHAREABLE))
        dw = mciSendCommand((MCIDEVICEID)0, MCI_OPEN, (dwFlags & ~MCI_OPEN_SHAREABLE),
            (DWORD_PTR)(LPVOID)&mciOpen);
    DPF("MCI_OPEN returned %lu, wDeviceID=%u\n", dw, mciOpen.wDeviceID);
    gfErrorBox--;

    /*
     * now free the driver instance we opened above.
     */
    if (hdrv)
        CloseDriver(hdrv, 0, 0);

    if (hcurPrev)
        SetCursor(hcurPrev);

    if (dw != 0 && !gfEmbeddedObject) {
//      UnblockServer();        // we may have blocked before and the error
                                // recovery code will loop infinitely if we're
                                // blocked!
        InitDoc(TRUE);
    }

    /* If the open was unsuccessful, display an error message and return */

    if (dw == MCIERR_DEVICE_OPEN ||       /* nonshareable device already open */
        dw == MCIERR_MUST_USE_SHAREABLE) {
        Error(ghwndApp, IDS_DEVICEINUSE);
        return FALSE;
    }

    if (dw == MCIERR_FILE_NOT_FOUND) {
		//Need to give an appropriate error message.
		//The following could be the causes:
		//1. File does not exist
		//This is already handled by the file open dialog box.
		//2. Access to the file is denied. (bug #53492)
		//3. The file is opened exclusively by another app.
		//The file already exists. so if it cannot be opened for reading
		//either access is denied or it is opened by another app.
	    if ((hFile = (HFILE)HandleToUlong(CreateFile (szFile, GENERIC_READ, 
						    FILE_SHARE_READ, NULL, 
						    OPEN_EXISTING, 0, NULL))) == HFILE_ERROR)
        {
			Error(ghwndApp, IDS_CANTACCESSFILE);
		}
		//4. File was not in a recognized format
		else
		{	
			_lclose(hFile);
			Error(ghwndApp, IDS_CANTOPENFILE);
		}
        return FALSE;
    }


   /* If the MCI device that plays the given file does not exist then  */
   /* bring up a  dialog box and close mplayer.                        */
    if (dw == MCIERR_INVALID_DEVICE_NAME) {
        Error(ghwndApp,  IDS_DEVICENOTINSTALLED);
        return FALSE;
    }

    if (dw != 0) {                     /* some other error */
        //
        // try again, if we can't open the file with a particular device.
        // this lets the MCI core try to figure out the device type from
        // the file extension, or some other method.
        //
        if ((dw != MCIERR_DRIVER_INTERNAL) && szDevice != NULL &&
            szDevice[0] != 0) {
            if (szFile && szFile[0] != 0) {
                return OpenMCI(szFile, TEXT(""));
            }
        }

        CheckErrorMCI(dw);
        return FALSE;
    }

    /* The open was successful, so retain the MCI device ID for later use */
    gwDeviceID = (UINT)mciOpen.wDeviceID;

    //
    //  now query the device and see what it can do
    //
    FindDeviceMCI();
    gwDeviceType = QueryDeviceTypeMCI(gwDeviceID);

    if (!(gwDeviceType & DTMCI_CANPLAY)) {
        Error(ghwndApp, IDS_DEVICECANNOTPLAY);
        CloseMCI(TRUE);
        return FALSE;
    }

    if (!(gwDeviceType & (DTMCI_TIMEMS|DTMCI_TIMEFRAMES))) {
        Error(ghwndApp, IDS_NOGOODTIMEFORMATS);
        CloseMCI(TRUE);
        return FALSE;
    }

    if (gwDeviceType & DTMCI_CANWINDOW) {
        GetDestRectMCI(&grcSize);
#ifdef NEW_MCI_DIALOG
        grcInitSize = grcSize;
        // HACK!! We want to pay attention to some MCIAVI registry default
        // sizes, so we'll read the registry and adjust the size of the movie
        // accordingly.
    	AlterRectUsingDefaults(&grcSize);
#endif /* NEW_MCI_DIALOG */
    } else
        SetRectEmpty(&grcSize);

    if (IsRectEmpty(&grcSize)) {
        DPF("NULL rectange in GetDestRect() assuming device cant window!\n");
        gwDeviceType &= ~DTMCI_CANWINDOW;
    }

    /* Turn on the update-display timer so the display is updated regularly */

    EnableTimer(TRUE);

    /*
    ** for devices that do windows, show the window right away.
    **
    ** !!! note when we support a built in window it will go here.
    */
    if (gfPlayOnly) {
        CreateWindowMCI();
        if (!IsIconic(ghwndApp))
            SetMPlayerSize(&grcSize);
    }
    else if (GetWindowMCI() && IsWindowVisible(ghwndApp)) {

        MCI_SEEK_PARMS  mciSeek;        /* parameter structure for MCI_SEEK */
        TCHAR           achReturn[40];

        PostMessage(ghwndApp, WM_QUERYNEWPALETTE, 0, 0);

        //
        // make sure the default window is the right size.
        //
        PutWindowMCI(NULL);

        //
        // center the default window above or below our window
        //
        SmartWindowPosition(GetWindowMCI(), ghwndApp, TRUE);

        //
        // make sure the default window is showing
        //
        ShowWindowMCI(TRUE);

        /* hack for MMP, do a seek to the start, it does not paint
           correctly for some reason if we just show the window!
           NOTE:  0 may not be the start of the media so this may
           fail, but OH WELL! We can't call UpdateMCI yet to set
           gdwMediaStart because we don't know the scale (time/frames)
           yet so UpdateMCI won't set gdwMediaLength properly, and
           I don't feel like calling UpdateMCI twice, so tough!!
           And we can't just SeekMCI(0) because UpdateDisplay will get
           called too soon so we hack everything!                      */

        mciSendString(aszInfoProduct, achReturn,
                      CHAR_COUNT(achReturn), NULL);
        if (!lstrcmpi(achReturn, aszMMPName)) {
            mciSeek.dwTo = 0;
            dw = mciSendCommand(gwDeviceID, MCI_SEEK, MCI_TO,
                                (DWORD_PTR)&mciSeek);
        }
    }

    /*
     * Remember to update the media information and the caption when
     * UpdateDisplay() is next called.  We don't set them until now
     * because we want the ReadDefaults() to be called which will set
     * gwCurScale to happen before UpdateDisplay calls UpdateMCI.
     */
    gfValidMediaInfo = FALSE;
    gfValidCaption = FALSE;

    return TRUE;
}

//
//  GetDeviceNameMCI()
//
// wLen is the size IN BYTES of szDevice buffer
void FAR PASCAL GetDeviceNameMCI(LPTSTR szDevice, UINT wLen)
{
    MCI_SYSINFO_PARMS   mciSysInfo;
    DWORD               dw;

    //
    // assume failure.
    //
    szDevice[0] = 0;

    mciSysInfo.dwCallback = 0L;
    mciSysInfo.lpstrReturn = szDevice;
    mciSysInfo.dwRetSize = wLen;
    mciSysInfo.dwNumber = 0;
    mciSysInfo.wDeviceType = 0;

    if (gwDeviceID) {
        dw = mciSendCommand(gwDeviceID, MCI_SYSINFO,
            MCI_SYSINFO_INSTALLNAME,
            (DWORD_PTR)(LPVOID)&mciSysInfo);
    }
}

//
//  QueryDevicesMCI
//
// wLen is the size IN BYTES of szDevice buffer
//
// Returns a list of devices in form "<device1>\0<device2>\0 ... <deviceN>\0\0"
void FAR PASCAL QueryDevicesMCI(LPTSTR szDevices, UINT wLen)
{
    MCI_SYSINFO_PARMS mciSysInfo;
    DWORD             dw;
    DWORD             i;
    DWORD_PTR         cDevices;     /* Total number of devices to enumerate */
    DWORD             BufferPos;    /* Index to end of buffer */

    //
    // assume failure.
    //
    szDevices[0] = 0;
    szDevices[1] = 0;

    mciSysInfo.dwCallback = 0L;
    mciSysInfo.lpstrReturn = szDevices;
    mciSysInfo.dwRetSize = wLen;
    mciSysInfo.dwNumber = 0;
    mciSysInfo.wDeviceType = MCI_ALL_DEVICE_ID;

    /* How many devices does mmsystem know about?
     */
    dw = mciSendCommand(MCI_ALL_DEVICE_ID,
                        MCI_SYSINFO,
                        MCI_SYSINFO_QUANTITY,
                        (DWORD_PTR)(LPVOID)&mciSysInfo);

    if (dw == 0) {

        /* Device count is returned in lpstrReturn!
         */
        cDevices = (DWORD_PTR)(LPVOID)*mciSysInfo.lpstrReturn;
        BufferPos = 0;

        /* Get the name of each device in turn.  N.B. Not zero-based!
         * Ensure there's room for the final (double) null terminator.
         */
        for (i = 1; i < (cDevices + 1) && BufferPos < (wLen - 1); i++) {

            mciSysInfo.lpstrReturn = &(szDevices[BufferPos]);
            mciSysInfo.dwRetSize = wLen - BufferPos; /* How much space left */
            mciSysInfo.dwNumber = i;

            dw = mciSendCommand(MCI_ALL_DEVICE_ID,
                                MCI_SYSINFO,
                                MCI_SYSINFO_NAME,
                                (DWORD_PTR)(LPVOID)&mciSysInfo);

            if (dw == 0) {
                DPF1("Found device: %"DTS"\n", &(szDevices[BufferPos]));
                BufferPos += (lstrlen(&(szDevices[BufferPos])) + 1);
            }
        }

        /* Not strictly required, since our buffer was allocated LMEM_ZEROINIT:
         */
        szDevices[BufferPos] = '\0';
    }
}



//
//  FindDeviceMCI()
//
//  Find the device the user just opened.  We normally should know what
//  was opened, but in the auto-open case MCI will pick a device for us.
//
//  Determines what device is associated with <gwDeviceID> and
//  sets the <gwCurDevice> global.
//
//  Called by OpenMCI() whenever a new device is opened successfully.
//
void FAR PASCAL FindDeviceMCI(void)
{
    UINT                w;
    TCHAR               achDevice[80];

    //
    // assume failure.
    //
    gwCurDevice = 0;

    GetDeviceNameMCI(achDevice, BYTE_COUNT(achDevice));

    for (w=1; w<=gwNumDevices; w++)
    {
        if (lstrcmpi(achDevice, garMciDevices[w].szDevice) == 0) {
            gwCurDevice  = w;
        }

        if (ghMenu)
            CheckMenuItem(ghMenu, IDM_DEVICE0+w, MF_BYCOMMAND |
                ((gwCurDevice == w) ? MF_CHECKED : MF_UNCHECKED));
    }

    if (gwCurDevice == 0)
    {
        DPF("FindDevice: Unable to find device\n");
    }
}

void FAR PASCAL CreateWindowMCI()
{
    RECT        rc;
    HWND        hwnd;

    if (IsWindow(ghwndMCI) || !gwDeviceID || !(gwDeviceType & DTMCI_CANWINDOW))
        return;

    /* Figure out how big the Playback window is, and make our MCI window */
    /* the same size.                                                     */

    hwnd = GetWindowMCI();

    if (hwnd != NULL)
        GetClientRect(hwnd, &rc);
    else
        rc = grcSize;  // use original size if error

    CreateWindowEx(gfdwFlagsEx,
                   MCI_WINDOW_CLASS,
                   TEXT(""),
                   WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                   rc.left,
                   rc.top,
                   rc.right  - rc.left,
                   rc.bottom - rc.top,
                   ghwndApp,
                   (HMENU)NULL,
                   ghInst,
                   NULL);
}

/*
 * SendStringMCI() - send a MCI string command to the device.
 *
 * the string is of the form "verb params" our device name is inserted
 * after the verb and sent to the device.
 *
 */
DWORD PASCAL SendStringMCI(PTSTR szCmd, PTSTR szReturn, UINT wLen /* Characters */)
{
    TCHAR ach[MCI_STRING_LENGTH + CHAR_COUNT(aszMPlayerAlias) + 1];
    TCHAR *pch;

    pch = ach;
    while (*szCmd && *szCmd != TEXT(' '))
        *pch++ = *szCmd++;

    *pch++ = TEXT(' ');
    lstrcpy(pch,aszMPlayerAlias);
    lstrcat(pch,szCmd);

    return mciSendString(ach, szReturn, wLen, ghwndApp);
}

/*
 * UpdateMCI()
 *
 * Update <gfCanEject>, <gdwMediaLength>, <gwNumTracks>, and <gadwTrackStart>
 * to agree with what MCI knows them to be.
 */
void FAR PASCAL UpdateMCI(void)
{
    MCI_STATUS_PARMS        mciStatus;    /* Structure for MCI_STATUS command */
    DWORD                   dw;
    HCURSOR                 hcurPrev;

    if (gfValidMediaInfo)
        return;

    /* If no device is currently open, then there's nothing to update */

    if (gwDeviceID == (UINT)0) {
        return;
    }

    /*
     * Show the hourglass cursor -- who knows how long this stuff will take
     */

    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    /*
     * This function may fail (due to I/O error etc.), but we might as
     * well say that the media information is valid now, because otherwise
     * we'll just get into an endless loop.
     *
     */

    gfValidMediaInfo = TRUE;

    gdwMediaStart = 0L;
    gdwMediaLength = 0L;
    gwNumTracks = 0;

    /* If things aren't valid anyway, give up. */
    if (gwStatus == MCI_MODE_OPEN || gwStatus == MCI_MODE_NOT_READY)
        goto exit;

    /* Find out how many tracks are present in the medium */

    mciStatus.dwItem = MCI_STATUS_NUMBER_OF_TRACKS;
    dw = mciSendCommand(gwDeviceID, MCI_STATUS, MCI_STATUS_ITEM,
                        (DWORD_PTR)&mciStatus);

#ifdef DEBUG
    DPF("MCI_STATUS (MCI_STATUS_NUMBER_OF_TRACKS) returned %lu,"
        " %d tracks\n", dw, mciStatus.dwReturn);
#endif

    /*
     * If the command retuned a value of zero, then the medium contains tracks,
     * so use the number of tracks returned in the parameter structure.
     * Otherwise, the medium does not contain tracks, so use a value of 0.
     *
     */

    if (dw == 0L)
        gwNumTracks = (UINT) mciStatus.dwReturn;

    /* Set the correct time format either frames or milliseconds */

    if (gwCurScale == ID_FRAMES && !(gwDeviceType & DTMCI_TIMEFRAMES))
        gwCurScale = ID_TIME;

    if (gwCurScale == ID_TRACKS && gwNumTracks <= 1)
        gwCurScale = ID_TIME;

    if (gwCurScale == ID_TIME && !(gwDeviceType & DTMCI_TIMEMS))
        gwCurScale = ID_FRAMES;

    /* set the time format, If this does not work, punt. */
    if (!SetTimeFormatMCI(gwCurScale == ID_FRAMES ? MCI_FORMAT_FRAMES : MCI_FORMAT_MILLISECONDS))
        goto exit;

    mciStatus.dwItem = MCI_STATUS_LENGTH;
    dw = mciSendCommand(gwDeviceID, MCI_STATUS, MCI_STATUS_ITEM,
                        (DWORD_PTR)&mciStatus);

    DPF("MCI_STATUS (MCI_STATUS_LENGTH) returned %lu, media length %ld\n", dw, mciStatus.dwReturn);

    /*
     * If the MCI command returned a nonzero value, then an error has
     * occurred, so alert the user, close the offending device, and return.
     *
     */

    if (dw != 0L)
        goto exit;

    /* Everything is OK, so retain the media length for later use */

    gdwMediaLength = (DWORD)mciStatus.dwReturn;

    mciStatus.dwItem = MCI_STATUS_POSITION;
    dw = mciSendCommand(gwDeviceID, MCI_STATUS,
        MCI_STATUS_START | MCI_STATUS_ITEM, (DWORD_PTR)&mciStatus);

#ifdef DEBUG
    DPF2("MCI_STATUS (MCI_STATUS_START) returned %lu, start %ld\n",dw, mciStatus.dwReturn);
#endif

    gdwMediaStart = (DWORD)mciStatus.dwReturn;

    if (dw != 0) {
        /* Error: forget about track display */
        gwNumTracks = 0;
    }

    if (gwNumTracks > 0) {

        UINT    wTrack;

        /* Free the track map if it already exists */

        if (gadwTrackStart != NULL)
            FreeMem(gadwTrackStart, sizeof(DWORD) * gwNumTracks);

        /* Allocate memory for the track map */

        gadwTrackStart = AllocMem(sizeof(DWORD) * gwNumTracks);
        if (gadwTrackStart == NULL) {

            /* AllocMem() failed - alert the user, close the device, return */

            Error(ghwndApp, IDS_OUTOFMEMORY);
            gwNumTracks = 0;
            goto exit;
        }

        /* See if there is a track zero */
        mciStatus.dwItem = MCI_STATUS_POSITION;
        mciStatus.dwTrack = (DWORD) 0;
        dw = mciSendCommand(gwDeviceID, MCI_STATUS,
            MCI_TRACK | MCI_STATUS_ITEM, (DWORD_PTR)&mciStatus);

#ifdef DEBUG
      DPF2("MCI_STATUS (MCI_STATUS_START for track %lu) returned %lu, start %ld\n", mciStatus.dwTrack, dw, mciStatus.dwReturn);
#endif

        if (dw == 0)
            gwFirstTrack = 0;
        else
            gwFirstTrack = 1;

        /* Get the track map from MCI */

        for (wTrack = 0; wTrack < gwNumTracks; wTrack++) {

            mciStatus.dwItem = MCI_STATUS_POSITION;
            mciStatus.dwTrack = (DWORD) wTrack + gwFirstTrack;
            dw = mciSendCommand(gwDeviceID, MCI_STATUS,
                MCI_TRACK | MCI_STATUS_ITEM, (DWORD_PTR)&mciStatus);

#ifdef DEBUG
            DPF2("MCI_STATUS (MCI_STATUS_START for track %lu) returned %lu, start %ld\n", mciStatus.dwTrack, dw,mciStatus.dwReturn);
#endif

            if (dw != 0) {
#if 1
                /* Error: forget about track display */
                gwNumTracks = 0;
                goto exit;
#else
                /* An error occurred - do the usual stuff */

                Error(ghwndApp, IDS_CANTACCESSFILEDEV);
                goto exit;
#endif
            }

            /* Add the start of this track to the track list */

            gadwTrackStart[wTrack] = (DWORD)mciStatus.dwReturn;
        }
    }

    /*
     * Invalidate the track map window so it will be redrawn with the
     * correct positions, etc.
     *
     */
exit:
#ifdef DEBUG
    DPF("Finished updating status: # tracks = %u, length = %lu\n", gwNumTracks, gdwMediaLength);
#endif

    SendMessage(ghwndTrackbar, TBM_SETRANGEMIN, (WPARAM)FALSE, gdwMediaStart);
    SendMessage(ghwndTrackbar, TBM_SETRANGEMAX, (WPARAM)FALSE, gdwMediaStart + gdwMediaLength);

    /* We must set the range before calling TBM_SETTIC (which is sent by
     * CalcTicsOfDoom()), since the common trackbar now tests the range
     * before accepting a new tic.
     * It would probably be better to set the range in CalcTicsOfDoom().
     */
    if (!gfCurrentCDNotAudio)
        CalcTicsOfDoom();

    SendMessage(ghwndTrackbar, TBM_SETSELSTART, (WPARAM)FALSE, -1);   // invalid selection
    SendMessage(ghwndTrackbar, TBM_SETSELEND, (WPARAM)TRUE, -1);

    if (hcurPrev)
        SetCursor(hcurPrev);
}

/*
 * CloseMCI(fUpdateDisplay)
 *
 * Close the currently-open MCI device (if any).  If <fUpdateDisplay>
 * is TRUE, then update the display as well.
 *
 * Closing the device merely relinquishes control of it so that the device
 * may be used by someone else. The device does not necessarily stop playing
 * or return to the start of the medium when this message is received - the
 * behaviour is device-dependent.
 *
 */

void FAR PASCAL CloseMCI(BOOL fUpdateDisplay)
{
    DWORD       dw;
    UINT        w;
    HWND        hwnd;

    if (!gfEmbeddedObject)
        gachCaption[0] = 0; // nuke the caption

    /* If no device is currently open, then there's nothing to close */
    if (gwDeviceID == (UINT)0)
        return;

    /*
     * Disable the display-update timer, as there's no longer any reason to
     * periodically update the display.
     */
    EnableTimer(FALSE);

////StopMCI();

    //
    // set either the owner or the WS_CHILD bit so it will
    // not act up because we have the palette bit set and cause the
    // desktop to steal the palette.
    //
    // because we are being run from client apps that dont deal
    // with palettes we dont want the desktop to hose the palette.
    //
    hwnd = GetWindowMCI();

    if ((hwnd != NULL) && gfRunWithEmbeddingFlag)
        SetParent(hwnd, ghwndApp);

    /* Send the MCI CLOSE message, and set the current device to NULL */
    dw = mciSendCommand(gwDeviceID, MCI_CLOSE, 0L, (DWORD_PTR)0);
    gwDeviceID = (UINT)0;
    gwDeviceType = 0;
    gwCurScale = ID_NONE;
    SetRectEmpty(&grcSize);

    /* Now close the MCI window AFTER we close the MCIDevice, so that the */
    /* SetMCIWindow(NULL) this does won't flash up a default playback win.*/
    if (ghwndMCI) {
        /*
        **  Don't pass the WM_CLOSE to the subclass window proc or it will
        **  spuriously issue and IDM_CLOSE again!
        */
        if (gfnMCIWndProc != NULL && ghwndSubclass == ghwndMCI) {
            SetWindowLongPtr(ghwndMCI, GWLP_WNDPROC, (LONG_PTR)gfnMCIWndProc);
            gfnMCIWndProc = NULL;
        }
        SendMessage(ghwndMCI, WM_CLOSE, 0, 0L);
    }

    /* Don't set gwCurDevice = 0 because if we were called by Open MCI, then */
    /* we won't remember what device we were opening.  So instead, we'll set */
    /* gwCurDevice = 0 after returning from CloseMCI if we so desire.  I know*/
    /* it sounds hacky, but Todd told me to do it this way. End disclamer.   */

    /* Uncheck the device menus */
    if (ghMenu) {
        for (w = 1; w <= gwNumDevices; w++)
            CheckMenuItem(ghMenu, IDM_DEVICE0 + w, MF_BYCOMMAND | MF_UNCHECKED);
    }

    DPF("MCI_CLOSE returned %lu\n", dw);

    /* Free up the resources used by the track map */

    if (gadwTrackStart != NULL)
    {
        FreeMem(gadwTrackStart, sizeof(DWORD) * gwNumTracks);
        gadwTrackStart = NULL;
    }

    /* If you have auto-repeat on and you load a new file in between the   */
    /* repeating, the new file may come up with no buttons or no scrollbar */
    /* because our JustPlayed code sets the old status to PLAY which avoids*/
    /* updating.                                                           */
    gfJustPlayed = FALSE;

    /*
     * If the display update flag was set, then update the display, taking
     * into account that the media information and caption are now inaccurate.
     */
    if (fUpdateDisplay) {
        gfValidCaption = FALSE;
        gfValidMediaInfo = FALSE;
        UpdateDisplay();
    }
}

/* Helper function to check return code from MCI functions. */
STATICFN BOOL NEAR PASCAL CheckErrorMCI(DWORD dwRet)
{
    TCHAR       ach[200];
    if (dwRet != 0 && dwRet != MCIERR_NONAPPLICABLE_FUNCTION) {
        mciGetErrorString(dwRet, ach, CHAR_COUNT(ach));
        Error1(ghwndApp, IDS_DEVICEERROR, ach);
//      CloseMCI(TRUE);
        return FALSE;
    }
    return TRUE;
}

/*
 * PlayMCI()
 *
 * Start the current device playing.  If the device is in a paused state,
 * un-pause it.
 * Maybe play the selection.
 *
#ifdef NEW_MCI_DIALOG
 * NOTE:  MCIAVI will automatically play fullscreen if that option is selected
 * in the registry.  We don't have to do anything.
#endif NEW_MCI_DIALOG
 *
 */

BOOL FAR PASCAL PlayMCI(DWORD_PTR dwFrom, DWORD_PTR dwTo)

{
    MCI_PLAY_PARMS      mciPlay;    /* structure used to pass parameters along
                                        with the MCI_PLAY command             */
    DWORD               dw;         /* variable holding the return value of
                                        the various MCI commands              */
    DWORD               dwflags = 0L;     /* play flags */

    /* If no device is currently open, then there's nothing to play */

    DPF("mciPlay:  From=%d   To=%d\n", dwFrom, dwTo);

    if (gwDeviceID == (UINT)0)
        return TRUE;

     if (gfInPlayMCI) {
         return(TRUE);
     }

     gfInPlayMCI = TRUE;

    /*
     * Send the MCI_PLAY message. This will start the device playing from
     * wherever the current position is within the medium. This message will
     * un-pause the player if it is currently in the paused state.
     *
     */

    mciPlay.dwCallback = (DWORD_PTR)(HWND) ghwndApp;
    if (dwFrom != dwTo) {
        mciPlay.dwFrom = (DWORD)dwFrom;
        mciPlay.dwTo = (DWORD)dwTo;
        dwflags = MCI_FROM | MCI_TO;
    }

    /* don't allow MCIAVI full screen mode --- force Windowing */
    if (gfPlayingInPlace && ((gwDeviceType & DTMCI_DEVICE) == DTMCI_AVIVIDEO))
        dwflags |= MCI_MCIAVI_PLAY_WINDOW;

    /* If auto-repeat is on, MCIAVI will bring the playback window to the */
    /* front every time it repeats, because that's what it does when you  */
    /* issue a play.  To avoid that, we'll just do a play repeat once.    */
    if (((gwDeviceType & DTMCI_DEVICE) == DTMCI_AVIVIDEO) &&
        (gwOptions & OPT_AUTOREP))
        dwflags |= MCI_DGV_PLAY_REPEAT;

    //
    // what if the MCI device brings up a error box?  We don't want MPlayer
    // to be allowed to exit.
    //
    gfErrorBox++;
    dw = mciSendCommand(gwDeviceID, MCI_PLAY, F_NOTIFY | dwflags, (DWORD_PTR)&mciPlay);
    DPF("MCI_PLAY returned %lu\n", dw);
    gfErrorBox--;

    /* In case it stops so soon we wouldn't notice this play command. */
    if (dw == 0)
        gfJustPlayed = TRUE;

    gfInPlayMCI = FALSE;

    return CheckErrorMCI(dw);
}


/*
 * SetTimeFormatMCI()
 *
 * sets the current time format
 *
 */

BOOL FAR PASCAL SetTimeFormatMCI(UINT wTimeFormat)
{
    MCI_SET_PARMS           mciSet;        /* Structure for MCI_SET command */
    DWORD                   dw;

    mciSet.dwTimeFormat = wTimeFormat;

    dw = mciSendCommand(gwDeviceID, MCI_SET, MCI_SET_TIME_FORMAT,
        (DWORD_PTR) (LPVOID) &mciSet);

    if (dw != 0) {
        mciSet.dwTimeFormat = MCI_FORMAT_MILLISECONDS;

        mciSendCommand(gwDeviceID, MCI_SET, MCI_SET_TIME_FORMAT,
            (DWORD_PTR)(LPVOID)&mciSet);
    }

    return (dw == 0);
}

/*
 * PauseMCI()
 *
 * Pause the current MCI device.
 *
 */

BOOL FAR PASCAL PauseMCI(void)

{
    MCI_GENERIC_PARMS   mciGeneric; /* General-purpose structure used to pass
                                        parameters along with various MCI
                                        commands                              */
    DWORD               dw;         /* variable holding the return value of
                                        the various MCI commands              */

    /* If no device is currently open, then there's nothing to pause */

    if (gwDeviceID == (UINT)0)
        return TRUE;

    /* Send the MCI_PAUSE message */

    mciGeneric.dwCallback = (DWORD_PTR)(HWND) ghwndApp;

    dw = mciSendCommand(gwDeviceID, MCI_PAUSE, F_NOTIFY, (DWORD_PTR)&mciGeneric);

    DPF("MCI_PAUSE returned %lu\n", dw);

    if (dw == MCIERR_UNSUPPORTED_FUNCTION) {
        /* Pause isn't supported.  Don't allow it any more. */
        gwDeviceType &= ~DTMCI_CANPAUSE;
    }

    return CheckErrorMCI(dw);
}

/*
 * SeekExactMCI()
 *
 * Set set exactly on or off
 *
 */

BOOL FAR PASCAL SeekExactMCI(BOOL fExact)
{
    DWORD dw;
    BOOL  fWasExact;
    MCI_STATUS_PARMS    mciStatus;

    if (gwDeviceID == (UINT)0 || !(gwDeviceType & DTMCI_CANSEEKEXACT))
        return FALSE;

    //
    // see if the device can seek exactly
    //
    dw = mciSendString(aszSeekExact, NULL, 0, NULL);

    if (dw != 0)
    {
        gwDeviceType &= ~DTMCI_CANSEEKEXACT;
        return FALSE;
    }

    //
    // get current value.
    //
    mciStatus.dwItem = MCI_DGV_STATUS_SEEK_EXACTLY;
    dw = mciSendCommand(gwDeviceID, MCI_STATUS, MCI_STATUS_ITEM,
                                    (DWORD_PTR) (LPVOID) &mciStatus);
    fWasExact = (dw == 0 && mciStatus.dwReturn != MCI_OFF) ? TRUE : FALSE;

    if (fExact)
        dw = mciSendString(aszSeekExactOn, NULL, 0, NULL);
    else
        dw = mciSendString(aszSeekExactOff, NULL, 0, NULL);

    return fWasExact;
}

/*
 * SetAudioMCI()
 *
 * Set audio for the current MCI device on/off.
 *
 */

BOOL FAR PASCAL SetAudioMCI(BOOL fAudioOn)

{
    MCI_SET_PARMS   mciSet;
    DWORD               dw;

    /* If no device is currently open, then there's nothing to do. */

    if (gwDeviceID == (UINT)0)
        return TRUE;

    /* Send the MCI_SET message */
    mciSet.dwAudio = MCI_SET_AUDIO_ALL;

    dw = mciSendCommand(gwDeviceID, MCI_SET,
                MCI_SET_AUDIO | (fAudioOn ? MCI_SET_ON : MCI_SET_OFF),
                (DWORD_PTR)&mciSet);

    DPF("MCI_SET returned %lu\n", dw);

    return CheckErrorMCI(dw);
}

/*
 * StopMCI()
 *
 * Stop the current MCI device.
 *
 */

BOOL FAR PASCAL StopMCI(void)

{
    MCI_GENERIC_PARMS   mciGeneric; /* General-purpose structure used to pass
                                       parameters along with various MCI
                                       commands                              */
    DWORD               dw;         /* variable holding the return value of
                                       the various MCI commands              */

    /* If no device is currently open, then there's nothing to stop */

    if (gwDeviceID == (UINT)0)
        return TRUE;

    /* Send the MCI_STOP message */

    mciGeneric.dwCallback = (DWORD_PTR)(HWND) ghwndApp;

    dw = mciSendCommand(gwDeviceID, MCI_STOP, F_NOTIFY,
                            (DWORD_PTR)&mciGeneric);

    DPF("MCI_STOP returned %lu\n", dw);

    return CheckErrorMCI(dw);
}


/*
 * EjectMCI(fOpen)
 *
 * Open the device door if <fOpen> is TRUE, otherwise close it.
 *
 * To do: When un-ejected, update track map, media length, etc.
 *
 */

BOOL FAR PASCAL EjectMCI(BOOL fOpen)

{
    MCI_GENERIC_PARMS   mciGeneric; /* General-purpose structure used to pass
                                       parameters along with various MCI
                                       commands                              */
    DWORD               dw;         /* variable holding the return value of
                                       the various MCI commands              */

    /* If no device is currently open, then there's nothing to eject */

    if (gwDeviceID == (UINT)0)
    return TRUE;

    /*
     * Send a message opening or closing the door depending on the state of
     * <fOpen>.
     *
     */

    mciGeneric.dwCallback = (DWORD_PTR)(HWND) ghwndApp;

    dw = mciSendCommand(gwDeviceID, MCI_SET,
         (fOpen ? MCI_SET_DOOR_OPEN : MCI_SET_DOOR_CLOSED) | F_NOTIFY,
         (DWORD_PTR)&mciGeneric);

    DPF("MCI_SET (MCI_SET_DOOR_%s) returned %lu\n",(LPSTR)(fOpen ? "OPEN" : "CLOSED"), dw);

    return CheckErrorMCI(dw);
}


/*
 * SeekMCI(dwPosition)
 *
 * Seek to position <dwPosition> (measured in milliseconds from 0L to
 * <gdwMediaLength> inclusive).
 *
 */
STATICDT BOOL sfSeeking = FALSE;

BOOL FAR PASCAL SeekMCI(DWORD_PTR dwPosition)
{
    DWORD               dw;         /* variable holding the return value of
                                       the various MCI commands              */
    static int          wStatus = -1;

    /*
     * If no device is currently open, then there's not much bloody point
     * in trying to seek to a new position, is there?
     *
     */

    if (gwDeviceID == (UINT)0)
    return TRUE;

    /*
    ** If we're seeking, decide whether to play from or seek to based on
    ** the status at the last time we seeked.  Otherwise, use the current
    ** status.
    */

    if (!sfSeeking)
        wStatus = gwStatus;

    /* Playing from end of media is broken in CD, so don't let it happen. */
    if (dwPosition >= gdwMediaStart + gdwMediaLength) {
        if (!StopMCI())
            return FALSE;
        wStatus = MCI_MODE_STOP;
    }

    if (wStatus == MCI_MODE_PLAY) {

        MCI_PLAY_PARMS  mciPlay;        /* parameter structure for MCI_PLAY */
        DWORD           dwflags = 0L;

        /*
         * If the player in in 'Play' mode, then we want to jump to the new
         * position and keep playing. This can be done by sending an MCI_PLAY
         * message and specifying the position which we wish to play from.
         *
         */

        mciPlay.dwFrom = (DWORD)dwPosition;
        mciPlay.dwCallback = (DWORD_PTR)(HWND) ghwndApp;

        /* don't allow MCIAVI full screen mode --- force Windowing */
        if (gfPlayingInPlace && ((gwDeviceType & DTMCI_DEVICE) == DTMCI_AVIVIDEO))
            dwflags |= MCI_MCIAVI_PLAY_WINDOW;

        dw = mciSendCommand(gwDeviceID, MCI_PLAY, MCI_FROM | F_NOTIFY | dwflags,
            (DWORD_PTR)&mciPlay);
        DPF("MCI_PLAY (from %lu) returned %lu\n", mciPlay.dwFrom, dw);

        /* In case it stops so soon we wouldn't notice this play command. */
        if (dw == 0)
            gfJustPlayed = TRUE;

    }
    else {

        MCI_SEEK_PARMS  mciSeek;        /* parameter structure for MCI_SEEK */

        /*
         * In any other state but 'Play', we want the player to go to the new
         * position and remain stopped. This is accomplished by sending an
         * MCI_SEEK message and specifying the position we want to seek to.
         *
         */

        mciSeek.dwTo = (DWORD)dwPosition;
        mciSeek.dwCallback = (DWORD_PTR)(HWND) ghwndApp;

        dw = mciSendCommand(gwDeviceID, MCI_SEEK, MCI_TO | F_NOTIFY,
            (DWORD_PTR)&mciSeek);
        DPF2("MCI_SEEK (to %lu) returned %lu\n", mciSeek.dwTo, dw);

    }

    /*
     * If no error occurred, save the position that is to be seeked to in
     * order to use that position in UpdateDisplay() if the device is in
     * seek mode.
     *
     */
    if (!dw)
        gdwLastSeekToPosition = (DWORD)dwPosition;

    /*
     * Because we've moved to a new position in the medium, the scrollbar
     * thumb is no longer positioned accurately. Call UpdateDisplay()
     * immediately to rectify this. (We could just wait for the next
     * automatic update, but this is friendlier).
     *
     */

    UpdateDisplay();

    return CheckErrorMCI(dw);
}


/* SeekToStartMCI( )
 *
 * Better than SeekMCI(gdwMediaStart) for CDAudio (like, it works).
 *
 */
BOOL FAR PASCAL SeekToStartMCI( )
{
    MCI_SEEK_PARMS  mciSeek;        /* parameter structure for MCI_SEEK */
    DWORD           dw;

    mciSeek.dwTo = 0;
    mciSeek.dwCallback = (DWORD_PTR)(HWND) ghwndApp;

    dw = mciSendCommand(gwDeviceID, MCI_SEEK, MCI_SEEK_TO_START,
                        (DWORD_PTR)&mciSeek);

    DPF2("MCI_SEEK_TO_START returned %lu\n", dw);

    return CheckErrorMCI(dw);
}


/*
 * SkipTrackMCI(iSkip)
 *
 * Skip to the beginning of track <iCur> + <iSkip>, where <iCur>
 * is the current track.
 *
 */

void FAR PASCAL SkipTrackMCI(int iSkip)
{
    MCI_STATUS_PARMS    mciStatus;     /* Structure used to pass parameters
                                         along with an MCI_STATUS command */
    DWORD               dw;            /* variable holding the return value
                                         of the various MCI commands      */
    int                 iTrack;        /* index of the track to skip to   */
    static int          iLastTrack = -1;

    /* If no device is currently open, then return */

    if (gwDeviceID == (UINT)0)
        return;

    /* Determine the track # of the current track */

    if (gfScrollTrack && gdwSeekPosition != 0) {
        iTrack = iLastTrack + iSkip;
    } else {
        mciStatus.dwItem = MCI_STATUS_CURRENT_TRACK;
        dw = mciSendCommand(gwDeviceID, MCI_STATUS, MCI_STATUS_ITEM,
            (DWORD_PTR)&mciStatus);

        DPF("MCI_STATUS (MCI_STATUS_CURRENT_TRACK) returned %lu, current track %ld\n", dw, mciStatus.dwReturn);

        if (dw != 0L) {

            /* Something went wrong, but it isn't catastrophic... */

            MessageBeep(0);
            return;
        }

        /* Compute the track # to which we wish to skip */

        iTrack = ((int) mciStatus.dwReturn) + iSkip;
    }

    /* Handle special case of seeking backward from middle first track */
    if (iTrack < (int)gwFirstTrack)
        iTrack = (int)gwFirstTrack;

    /* Don't do anything if <iTrack> is out of range */

    if ((iTrack < (int)gwFirstTrack) || (iTrack >= (int)gwNumTracks +
                                                (int)gwFirstTrack))
        return;

    /* Everything seems to be OK, so skip to the requested track */

    gdwSeekPosition = gadwTrackStart[iTrack - gwFirstTrack];
    iLastTrack = iTrack;

    /* Hack: Update global scroll position */
    SendMessage(ghwndTrackbar, TBM_SETPOS, TRUE, gadwTrackStart[iTrack-gwFirstTrack]);
}

STATICFN DWORD GetMode(MCI_STATUS_PARMS *pmciStatus)
{
    pmciStatus->dwItem = MCI_STATUS_MODE;
    if (0 != mciSendCommand(gwDeviceID, MCI_STATUS, MCI_STATUS_ITEM,
        (DWORD_PTR)pmciStatus)) {
        /* If the command returned a nonzero value, the mode is unknown */
        return MCI_MODE_NOT_READY;
    } else {
        return (UINT)pmciStatus->dwReturn;
    }
}

/*
 * wStatus = StatusMCI(pdwPosition)
 *
 * Query the status of the current device and return it.
 *
 * If <pdwPosition> is not NULL, then <*pdwPosition> is filled in with
 * the current position of the device within the medium (in milliseconds,
 * from 0 to <gdwMediaLength> *inclusive*).  <*pdwPosition> is not
 * necessarily filled in if MCI_MODE_NOT_READY is returned.
 *
 */

UINT FAR PASCAL StatusMCI(DWORD_PTR* pdwPosition)
{
    static UINT         swModeLast = MCI_MODE_NOT_READY;
    MCI_STATUS_PARMS    mciStatus;
    DWORD               dw;
    UINT                wMode;
    DWORD               dwPosition;

    /* If no device is currently open, return error. */

    if (gwDeviceID == (UINT)0)
        return MCI_MODE_NOT_READY;

    /* Determine what the current mode (status) of the device is */
    wMode = GetMode(&mciStatus);

    if ((gwDeviceType & DTMCI_CANPLAY) &&
        wMode != MCI_MODE_OPEN && wMode != MCI_MODE_NOT_READY) {
        /* Determine the current position within the medium */

        mciStatus.dwItem = MCI_STATUS_POSITION;
        dw = mciSendCommand(gwDeviceID, MCI_STATUS,     MCI_STATUS_ITEM,
            (DWORD_PTR)&mciStatus);

        DPF4("position = %lu (%lu)\n", mciStatus.dwReturn, dw);

        /* If an error occurred, set the current position to zero */

        if (dw == 0)
            dwPosition = (DWORD)mciStatus.dwReturn;
        else
            dwPosition = 0L;
    } else
        dwPosition = 0L;

    /*
     * If the current position is past the end of the medium, set it to be
     * equal to the end of the medium.
     *
     */

    if (dwPosition > gdwMediaLength + gdwMediaStart) {
        DPF("Position beyond end of media: truncating value\n");
        dwPosition = gdwMediaLength + gdwMediaStart;
    }

    if (dwPosition < gdwMediaStart) {
        DPF2("Position before beginning of media: adjusting value\n");
        dwPosition = gdwMediaStart;
    }

    sfSeeking = (wMode == MCI_MODE_SEEK);

    /*
     * If we were passed a valid position pointer, then return the current
     * position.
     *
     */

    if (pdwPosition != NULL)
        *pdwPosition = dwPosition;

    /* Return the status of the device */

    return wMode;
}

/*
 * wRet = QueryDeviceTypeMCI(wDeviceID)
 *
 * This routine determines whether or not the device given in <szDevice> uses
 * files and whether or not it can play anything at all.
 * It does so by opening the device in question and then querying its
 * capabilities.
 *
 * It returns a combination of DTMCI_ flags or DTMCI_ERROR
 *
 */
UINT FAR PASCAL QueryDeviceTypeMCI(UINT wDeviceID)
{
    MCI_GETDEVCAPS_PARMS    mciDevCaps; /* for the MCI_GETDEVCAPS command */
    MCI_SET_PARMS           mciSet;     /* for the MCI_SET command */
    MCI_ANIM_WINDOW_PARMS   mciWindow;  /* for the MCI_WINDOW command */
    DWORD                   dw;
    UINT                    wRet=0;
    TCHAR                   achDevice[40];
    DWORD                   i;

    //
    // determine if the device is simple or compound
    //
    mciDevCaps.dwItem = MCI_GETDEVCAPS_COMPOUND_DEVICE;
    dw = mciSendCommand(wDeviceID, MCI_GETDEVCAPS,
        MCI_GETDEVCAPS_ITEM, (DWORD_PTR)&mciDevCaps);

    DPF("MCI_GETDEVCAPS_COMPOUND_DEVICE: %lu  (ret=%lu)\n", dw, mciDevCaps.dwReturn);

    if (dw == 0 && mciDevCaps.dwReturn != 0)
        wRet |= DTMCI_COMPOUNDDEV;
    else
        wRet |= DTMCI_SIMPLEDEV;

    //
    // determine if the device handles files
    //
    if (wRet & DTMCI_COMPOUNDDEV) {
        mciDevCaps.dwItem = MCI_GETDEVCAPS_USES_FILES;
        dw = mciSendCommand(wDeviceID, MCI_GETDEVCAPS,
            MCI_GETDEVCAPS_ITEM, (DWORD_PTR)&mciDevCaps);

        DPF("MCI_GETDEVCAPS_USES_FILES: %lu  (ret=%lu)\n", dw, mciDevCaps.dwReturn);

        if (dw == 0 && mciDevCaps.dwReturn != 0)
            wRet |= DTMCI_FILEDEV;
    }

    //
    // determine if the device can play
    //
    mciDevCaps.dwItem = MCI_GETDEVCAPS_CAN_PLAY;
    dw = mciSendCommand(wDeviceID, MCI_GETDEVCAPS,
        MCI_GETDEVCAPS_ITEM, (DWORD_PTR)&mciDevCaps);

    if (dw == 0 && mciDevCaps.dwReturn != 0)
        wRet |= DTMCI_CANPLAY;

    //
    // determine if the device can pause
    //
    if (wRet & DTMCI_CANPLAY)
        wRet |= DTMCI_CANPAUSE;     // assume it can pause!!!

    //
    // determine if the device does frames
    //
    mciSet.dwTimeFormat = MCI_FORMAT_FRAMES;
    dw = mciSendCommand(wDeviceID, MCI_SET, MCI_SET_TIME_FORMAT, (DWORD_PTR)&mciSet);

    DPF("MCI_SET TIME FORMAT (frames) returned %lu\n", dw);

    if (dw == 0)
        wRet |= DTMCI_TIMEFRAMES;

    //
    // determine if the device does milliseconds
    //
    mciSet.dwTimeFormat = MCI_FORMAT_MILLISECONDS;
    dw = mciSendCommand(wDeviceID, MCI_SET, MCI_SET_TIME_FORMAT, (DWORD_PTR)&mciSet);

    DPF("MCI_SET TIME FORMAT (milliseconds) returned %lu\n", dw);

    if (dw == 0)
        wRet |= DTMCI_TIMEMS;

    //
    // determine if the device can eject.
    //
    mciDevCaps.dwItem = MCI_GETDEVCAPS_CAN_EJECT;
    dw = mciSendCommand(wDeviceID, MCI_GETDEVCAPS, MCI_GETDEVCAPS_ITEM, (DWORD_PTR)(LPVOID)&mciDevCaps);

    DPF("MCI_GETDEVCAPS (MCI_GETDEVCAPS_CAN_EJECT) returned %lu, can eject: %ld\n", dw, mciDevCaps.dwReturn);

    if (dw == 0 && mciDevCaps.dwReturn)
        wRet |= DTMCI_CANEJECT;

    //
    // determine if the device supports configuration
    //
    dw = mciSendCommand(wDeviceID, MCI_CONFIGURE, MCI_TEST, (DWORD_PTR)NULL);

    DPF("MCI_CONFIGURE (MCI_TEST) returned %lu\n", dw);

    if (dw == 0)
        wRet |= DTMCI_CANCONFIG;

    //
    //  test the device driver and see if it can config.
    //
    if (!(wRet & DTMCI_CANCONFIG)) {

        //!!! is this safe?

        dw = mciSendCommand(wDeviceID, DRV_QUERYCONFIGURE, 0, 0);

        if (dw == 1L)
            wRet |= DTMCI_CANCONFIG;
    }

    //
    // determine if the device supports the "set audio" command
    //
    mciSet.dwAudio = MCI_SET_AUDIO_ALL;
    dw = mciSendCommand(wDeviceID, MCI_SET, MCI_SET_AUDIO | MCI_SET_ON,(DWORD_PTR)(LPVOID)&mciSet);

    DPF("MCI_SET (audio all) returned %lu\n", dw);

    if (dw == 0)
        wRet |= DTMCI_CANMUTE;

    //
    // determine if the device supports the "window" command, by sending a
    // "window handle default" command
    //

#ifdef NEWSTUFF
    /* Uh oh, we don't want to do this, because it causes our MCIWnd to be
     * overridden by the default window:
     */

    if (MCIWndCanWindow(ghwndMCI) == TRUE);
        wRet |= DTMCI_CANWINDOW;
#else
    mciWindow.hWnd = MCI_ANIM_WINDOW_DEFAULT;
    dw = mciSendCommand(wDeviceID, MCI_WINDOW,MCI_ANIM_WINDOW_HWND|MCI_WAIT,
            (DWORD_PTR)(LPVOID)&mciWindow);

    DPF("MCI_WINDOW: (set default) dw=0x%08lx\n", dw);

    if (dw == 0)
        wRet |= DTMCI_CANWINDOW;

    //
    // determine if the device supports the "window" command, by sending a
    // "window state hide" command
    //
    if (!(wRet & DTMCI_CANWINDOW)) {
        mciWindow.nCmdShow = SW_HIDE;
        dw = mciSendCommand(wDeviceID, MCI_WINDOW,MCI_ANIM_WINDOW_STATE|MCI_WAIT,
                (DWORD_PTR)(LPVOID)&mciWindow);

        DPF("MCI_WINDOW: (hide) dw=0x%08lx\n", dw);

        if (dw == 0)
            wRet |= DTMCI_CANWINDOW;
    }
#endif /* NEWSTUFF */

    //
    // assume the device can seek exact.
    //
    wRet |= DTMCI_CANSEEKEXACT;     // assume it can seek exact

    //
    // Are we the MCIAVI device?
    //
    GetDeviceNameMCI(achDevice, BYTE_COUNT(achDevice));

    if (*achDevice)
    {
        for (i = 0; i < sizeof DevToDevIDMap / sizeof *DevToDevIDMap; i++)
        {
            if (!lstrcmpi(achDevice, DevToDevIDMap[i].pString))
            {
                wRet |= DevToDevIDMap[i].ID;
                DPF("Found device %"DTS"\n", DevToDevIDMap[i].pString);
                break;
            }
        }
    }


    mciDevCaps.dwItem = MCI_GETDEVCAPS_DEVICE_TYPE;
    dw = mciSendCommand(gwDeviceID, MCI_GETDEVCAPS,
                        MCI_GETDEVCAPS_ITEM, (DWORD_PTR)&mciDevCaps);
    if ((dw == 0)
       &&(mciDevCaps.dwReturn == MCI_DEVTYPE_CD_AUDIO))
        wRet |= DTMCI_CDAUDIO;

    return wRet;
}

BOOL FAR PASCAL SetWindowMCI(HWND hwnd)
{
    MCI_ANIM_WINDOW_PARMS   mciWindow;  /* for the MCI_WINDOW command */
    DWORD                   dw;

    if (gwDeviceID == (UINT)0 || !(gwDeviceType & DTMCI_CANWINDOW))
        return FALSE;

    mciWindow.hWnd = hwnd;

    dw = mciSendCommand(gwDeviceID, MCI_WINDOW,MCI_ANIM_WINDOW_HWND|MCI_WAIT,
            (DWORD_PTR)(LPVOID)&mciWindow);

    if (dw != 0)
        gwDeviceType &= ~DTMCI_CANWINDOW;

    return (dw == 0);
}

BOOL FAR PASCAL ShowWindowMCI(BOOL fShow)
{
    DWORD dw;

    if (fShow)
        dw = mciSendString(aszWindowShow, NULL, 0, NULL);
    else
        dw = mciSendString(aszWindowHide, NULL, 0, NULL);

    return dw == 0;
}

BOOL FAR PASCAL PutWindowMCI(LPRECT prc)
{
    RECT rc;
    HWND hwnd;
    UINT w;

    //
    // note we could use the "put window at x y dx dy client" command but it
    // may not work on all devices.
    //

    if (gwDeviceID == (UINT)0 || !(gwDeviceType & DTMCI_CANWINDOW))
        return FALSE;

    if (!(hwnd = GetWindowMCI()))
        return FALSE;

    //
    // either snap to the default size or use the given size *and* position.
    //
    if (prc == NULL || IsRectEmpty(prc))
        rc = grcSize;
    else
        rc = *prc;

    if (rc.left == 0 && rc.top == 0)
        w = SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE;
    else
        w = SWP_NOZORDER | SWP_NOACTIVATE;

    AdjustWindowRect(&rc, (DWORD)GetWindowLongPtr(hwnd, GWL_STYLE), GetMenu(hwnd) != NULL);
    SetWindowPos(hwnd, NULL, rc.left, rc.top, rc.right-rc.left,
       rc.bottom-rc.top,w);

    return TRUE;
}

HWND FAR PASCAL GetWindowMCI(void)
{
    DWORD               dw;
    TCHAR               ach[40];

    if (gwDeviceID == (UINT)0 || !(gwDeviceType & DTMCI_CANWINDOW))
        return NULL;

    dw = mciSendString(aszStatusWindow, ach, CHAR_COUNT(ach), NULL);

    if (dw != 0)
        gwDeviceType &= ~DTMCI_CANWINDOW;

    if (dw == 0)
        return (HWND)IntToPtr(ATOI(ach));
    else
        return NULL;
}

BOOL FAR PASCAL SetPaletteMCI(HPALETTE hpal)
{
    MCI_DGV_SETVIDEO_PARMS  mciVideo;
    DWORD       dw;

    if (gwDeviceID == (UINT)0 || !(gwDeviceType & DTMCI_CANWINDOW))
        return FALSE;

    //!!! bug should not send this.

    mciVideo.dwItem  = MCI_DGV_SETVIDEO_PALHANDLE;
    mciVideo.dwValue = (DWORD)(DWORD_PTR)(UINT_PTR)hpal;

    dw = mciSendCommand(gwDeviceID, MCI_SETVIDEO,
            MCI_DGV_SETVIDEO_ITEM|MCI_DGV_SETVIDEO_VALUE|MCI_WAIT,
            (DWORD_PTR)(LPVOID)&mciVideo);

    return (dw == 0);
}

/*
 * wRet = DeviceTypeMCI(szDevice)
 *
 * This routine determines whether or not the device given in <szDevice> uses
 * files and whether or not it can play anything at all.
 * It does so by opening the device in question and then querying its
 * capabilities.  It returns either DTMCI_FILEDEV, DTMCI_SIMPLEDEV,
 * DTMCI_CANTPLAY, or DTMCI_ERROR.
 *
 */

UINT FAR PASCAL DeviceTypeMCI(
    LPTSTR  szDevice,           /* name of the device to be opened (or "")        */
    LPTSTR  szDeviceName,       /* place to put device full-name */
    int     nBuf)               /* size of buffer IN CHARACTERS */

{
    MCI_OPEN_PARMS          mciOpen;    /* Structure used for MCI_OPEN */
    MCI_INFO_PARMS          mciInfo;    /* Structure used for MCI_INFO */
    DWORD                   dw;
    UINT                    wRet;

    if (szDeviceName && nBuf > 0)
        szDeviceName[0] = 0;

    /*
     * Open the device as a simple device. If the device is actually compound,
     * then the open should still succeed, but the only thing we'll be able to
     * go is query the device capabilities.
     */

    mciOpen.lpstrDeviceType = szDevice;
    dw = mciSendCommand((MCIDEVICEID)0, MCI_OPEN, MCI_OPEN_TYPE,(DWORD_PTR)&mciOpen);

    if (dw == MCIERR_MUST_USE_SHAREABLE)
        dw = mciSendCommand((MCIDEVICEID)0, MCI_OPEN, MCI_OPEN_TYPE | MCI_OPEN_SHAREABLE,
            (DWORD_PTR)(LPVOID)&mciOpen);

    DPF("MCI_OPEN(%"DTS") returned %lu, wDeviceID=%u\n", szDevice, dw, mciOpen.wDeviceID);

    /* If the open was unsuccessful, return */

    switch (dw)
    {
        case MCIERR_MUST_USE_SHAREABLE:
        case MCIERR_DEVICE_OPEN:
            return DTMCI_IGNOREDEVICE;

        case 0: // no error
            break;

        default:
            DPF("Unable to open device (%"DTS")\n", szDevice);
            return DTMCI_ERROR;
    }

    wRet = QueryDeviceTypeMCI(mciOpen.wDeviceID);

    //
    //  get the "name" of the device if the caller wants it
    //
    if (szDeviceName && nBuf > 0)
    {
        mciInfo.dwCallback  = 0;
        mciInfo.lpstrReturn = szDeviceName;
        mciInfo.dwRetSize   = nBuf;

        //
        // default the product name to the device name
        //
        lstrcpy(szDeviceName, szDevice);

        dw = mciSendCommand(mciOpen.wDeviceID, MCI_INFO,
            MCI_INFO_PRODUCT, (DWORD_PTR)(LPVOID)&mciInfo);

        if (dw != 0)
            lstrcpy(szDeviceName, szDevice);
    }

    /* Close the device, and exit */

    dw = mciSendCommand(mciOpen.wDeviceID, MCI_CLOSE, 0L, (DWORD_PTR)0);

    return wRet;
}

BOOL FAR PASCAL ConfigMCI(HWND hwnd)
{
    DWORD               dw;
    DRVCONFIGINFO       drvc;
    RECT                rc1,rc2;
#ifndef UNICODE
    WCHAR               waszMCI[sizeof(aszMCI)];
    WCHAR               wszDevice[40];
#endif

    if (gwDeviceID == (UINT)0)
        return TRUE;

    dw = mciSendCommand(gwDeviceID, MCI_CONFIGURE, MCI_TEST, (DWORD_PTR)0);

    if (dw == 0) {
        GetDestRectMCI(&rc1);

        dw = mciSendCommand(gwDeviceID, MCI_CONFIGURE, 0L, (DWORD_PTR)0);

        GetDestRectMCI(&rc2);

        //
        // get the new size from MCIAVI, because the user may have
        // chosen ZoomBy2 as default.
        //

//
// This won't happen anymore... it was fixed by an MCIAVI fix.
//
#ifdef NEW_MCI_DIALOG
        if (IsRectEmpty(&rc2))
        {
            /* On Windows 95, GetDestRectMCI() returns an empty rectangle
             * if you make a change in the configure dialog.
             * I don't know if this is a bug.
             */
            grcSize = grcInitSize;

            AlterRectUsingDefaults(&grcSize);

            SetDestRectMCI(&grcSize);
            SetMPlayerSize(&grcSize);
            //HACK: It doesn't always repaint properly.
            InvalidateRect(GetWindowMCI(), NULL, TRUE);
        }
        else
#endif
        if (!EqualRect(&rc1, &rc2) && !IsRectEmpty(&rc2))
            grcSize = rc2;

    } else if (dw != MCIERR_DEVICE_NOT_READY) {
        drvc.dwDCISize          = sizeof(drvc);
#ifdef UNICODE
        drvc.lpszDCISectionName = aszMCI;
        drvc.lpszDCIAliasName   = garMciDevices[gwCurDevice].szDevice;
        dw = mciSendCommand(gwDeviceID, DRV_CONFIGURE, (LONG_PTR) (UINT_PTR) hwnd,
            (DWORD_PTR) (DRVCONFIGINFO FAR *) &drvc);
#else
        // No ASCII->Unicode thunking exists for DRV_CONFIGURE.  We have
        // to pass unicode strings on the configure command.

        AnsiToUnicodeString(aszMCI, waszMCI, UNKNOWN_LENGTH);
        AnsiToUnicodeString(garMciDevices[gwCurDevice].szDevice, wszDevice, UNKNOWN_LENGTH);

        drvc.lpszDCISectionName = waszMCI;
        drvc.lpszDCIAliasName   = wszDevice;
#ifdef CHICAGO_PRODUCT
        dw = mciSendCommand(gwDeviceID, DRV_CONFIGURE, (LONG) (UINT) hwnd,
            (DWORD_PTR) (DRVCONFIGINFO FAR *) &drvc);
#else
        dw = mciSendCommandW(gwDeviceID, DRV_CONFIGURE, (LONG) (UINT) hwnd,
            (DWORD_PTR) (DRVCONFIGINFO FAR *) &drvc);
#endif
#endif

    }

    return dw == 0;
}

BOOL FAR PASCAL GetDestRectMCI(LPRECT lprc)
{
    MCI_ANIM_RECT_PARMS mciRect;
    DWORD               dw;

    /* get the size (rectangle) of the element */
    if (gwDeviceID != (UINT)0)
        dw = mciSendCommand(gwDeviceID, MCI_WHERE,
            MCI_ANIM_WHERE_DESTINATION | MCI_WAIT,
            (DWORD_PTR)(LPVOID)&mciRect);
    else
        dw = 1;

    DPF("MCI_WHERE (dest): dw0x%08lx [%d,%d,%d,%d]\n", dw, mciRect.rc);

    if (dw != 0) {
        SetRectEmpty(lprc);
        return FALSE;
    }
    else {
        *lprc = mciRect.rc;
        lprc->right += lprc->left;
        lprc->bottom += lprc->top;
        return TRUE;
    }
}

#if 0 /* This is never called */
BOOL FAR PASCAL GetSourceRectMCI(LPRECT lprc)
{
    MCI_ANIM_RECT_PARMS mciRect;
    DWORD               dw;

    /* get the size (rectangle) of the element */
    if (gwDeviceID != (UINT)0)
        dw = mciSendCommand(gwDeviceID, MCI_WHERE,
            MCI_ANIM_WHERE_SOURCE | MCI_WAIT,
            (DWORD_PTR)(LPVOID)&mciRect);
    else
        dw = 1;

    DPF("MCI_WHERE (source): dw0x%08lx [%d,%d,%d,%d]\n", dw, mciRect.rc);

    if (dw != 0) {
        SetRectEmpty(lprc);
        return FALSE;
    }
    else {
        *lprc = mciRect.rc;
        lprc->right += lprc->left;
        lprc->bottom += lprc->top;
        return TRUE;
    }
}
#endif

BOOL FAR PASCAL SetDestRectMCI(LPRECT lprc)
{
    MCI_ANIM_RECT_PARMS mciRect;
    DWORD               dw;

    mciRect.rc = *lprc;

    /* get the size (rectangle) of the element */

    mciRect.rc.right  = mciRect.rc.right  - mciRect.rc.left;
    mciRect.rc.bottom = mciRect.rc.bottom - mciRect.rc.top;

    dw = mciSendCommand(gwDeviceID, MCI_PUT,
            MCI_ANIM_RECT | MCI_ANIM_PUT_DESTINATION | MCI_WAIT,
            (DWORD_PTR)(LPVOID)&mciRect);

    if (dw != 0)
    {
        DPF0("mciSendCommand( MCI_PUT ) failed with error x%08x\n", dw);
    }

    DPF("MCI_PUT (dest): [%d,%d,%d,%d]\n", mciRect.rc);

    return (dw == 0);
}

#if 0
BOOL FAR PASCAL SetSourceRectMCI(LPRECT lprc)
{
    MCI_ANIM_RECT_PARMS mciRect;
    DWORD               dw;

    mciRect.rc = *lprc;

    mciRect.rc.right  = mciRect.rc.right  - mciRect.rc.left;
    mciRect.rc.bottom = mciRect.rc.bottom - mciRect.rc.top;

    dw = mciSendCommand(gwDeviceID, MCI_PUT,
            MCI_ANIM_RECT | MCI_ANIM_PUT_SOURCE | MCI_WAIT,
            (DWORD_PTR)(LPVOID)&mciRect);

    DPF("MCI_PUT (source): [%d,%d,%d,%d]\n", mciRect.rc);

    return (dw == 0);
}
#endif

HPALETTE FAR PASCAL PaletteMCI(void)
{
    MCI_STATUS_PARMS    mciStatus;
    DWORD               dw;

    if (gwDeviceID == (UINT)0 || !(gwDeviceType & DTMCI_CANWINDOW))
        return NULL;

    mciStatus.dwItem = MCI_ANIM_STATUS_HPAL;
    dw = mciSendCommand(gwDeviceID, MCI_STATUS, MCI_STATUS_ITEM,
        (DWORD_PTR)(LPVOID)&mciStatus);

    if (dw == 0 && mciStatus.dwReturn)
        return (HPALETTE)mciStatus.dwReturn;
    else
        return NULL;
}

HBITMAP FAR PASCAL BitmapMCI(void)
{
    MCI_ANIM_UPDATE_PARMS mciUpdate;
    HDC         hdc, hdcMem;
    HBITMAP     hbm, hbmT;
    HBRUSH      hbrOld;
    HANDLE      hfontOld;
    DWORD       dw;
    RECT        rc;
    int         xExt, yExt;                     // size of text area
    int         xOff = 0, yOff = 0;             // offset of text string
    int         xSize, ySize;                   // size of whole picture
    int         xIconOffset;                        // x Offset if drawing Icon.
    TCHAR       ach[20];
    RECT        rcSave;
    RECT        rcs;
    SIZE        TempSize;

    /* Minimum size of bitmap is icon size */
    int ICON_MINX = GetSystemMetrics(SM_CXICON);
    int ICON_MINY = GetSystemMetrics(SM_CYICON);

    /* Get size of a frame or an icon that we'll be drawing */
    rcs = grcSize;
    GetDestRectMCI(&grcSize);
    rc = grcSize;

    if (IsRectEmpty(&rc))
        SetRect(&rc, 0, 0, 3*ICON_MINX, ICON_MINY);

    /* Offset to title bar */
    yOff = rc.bottom;

    hdc = GetDC(NULL);
    if (hdc == NULL)
        return NULL;
    hdcMem = CreateCompatibleDC(NULL);
    if (hdcMem == NULL) {
        ReleaseDC(NULL, hdc);
        return NULL;
    }

    if (gwOptions & OPT_TITLE) {
        if (ghfontMap)
            hfontOld = SelectObject(hdcMem, ghfontMap);

        GetTextExtentPoint32(hdcMem, gachCaption, STRLEN(gachCaption), &TempSize);
        xExt = max(TempSize.cx + 4, ICON_MINX);
        yExt = TempSize.cy;

        if (yExt > TITLE_HEIGHT)        // don't let text be higher than bar
            yExt = TITLE_HEIGHT;
        if (xExt > rc.right) {
            rc.left = (xExt - rc.right) / 2;
            rc.right += rc.left;
        } else {
            xOff = (rc.right - xExt) /2;
            xExt = rc.right;
        }
        if (rc.bottom < ICON_MINY) {
            yOff = ICON_MINY;
            rc.top = (ICON_MINY - rc.bottom) / 2;
            rc.bottom += rc.top;
        }
        xSize = xExt; ySize = yOff + TITLE_HEIGHT;
    } else {
        if (rc.right < ICON_MINX) {
            rc.left = (ICON_MINX - rc.right) / 2;
            rc.right += rc.left;
        }
        if (rc.bottom < ICON_MINY) {
            rc.top = (ICON_MINY - rc.bottom) / 2;
            rc.bottom += rc.top;
        }
        xSize = max(rc.right, ICON_MINX);
        ySize = max(rc.bottom, ICON_MINY);
    }

    /* Big enough to hold text caption too, if necessary */
    hbm = CreateCompatibleBitmap(hdc, xSize, ySize);

    ReleaseDC(NULL, hdc);
    if (hbm == NULL) {
        DeleteDC(hdcMem);
        return NULL;
    }

    hbmT = SelectObject(hdcMem, hbm);

    hbrOld = SelectObject(hdcMem, hbrWindowColour);
    PatBlt(hdcMem, 0,0, xSize, ySize, PATCOPY);
    SelectObject(hdcMem, hbrOld);

    if (gwOptions & OPT_TITLE) {
        hbrOld = SelectObject(hdcMem, hbrButtonFace);
        PatBlt(hdcMem, 0, rc.bottom, xExt, TITLE_HEIGHT, PATCOPY);
        SetBkMode(hdcMem, TRANSPARENT);
        SetTextColor(hdcMem, rgbButtonText);
        /* Centre text vertically in title bar */
        TextOut(hdcMem, xOff + 2, yOff + (TITLE_HEIGHT - yExt) / 2,
                gachCaption, STRLEN(gachCaption));
        if (hbrOld)
            SelectObject(hdcMem, hbrOld);
        if (ghfontMap)
            SelectObject(hdcMem, hfontOld);
    }

    /* Use our ICON as the picture */
    if (gwDeviceID == (UINT)0 || !(gwDeviceType & DTMCI_CANWINDOW)) {
        xIconOffset = rc.left + (rc.right-rc.left-ICON_MINX)/2;
        xIconOffset = xIconOffset < 0 ? 0: xIconOffset;
        DrawIcon(hdcMem, xIconOffset, rc.top,
                 GetIconForCurrentDevice(GI_LARGE, IDI_DDEFAULT));

    /* Use a frame of our file */
    } else {
        LOADSTRING(IDS_NOPICTURE, ach);
        DrawText(hdcMem, ach, STRLEN(ach), &rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

        mciUpdate.hDC = hdcMem;

        mciUpdate.dwCallback = 0;
        SetRectEmpty(&mciUpdate.rc);

        /* NO matter what size our playback window is, we want to use the   */
        /* original size of the window as the picture we put on the clipbrd */
        SetViewportOrgEx(hdcMem, rc.left, rc.top, NULL);
        GetDestRectMCI(&rcSave);
        SetDestRectMCI(&grcSize);
        dw = mciSendCommand(gwDeviceID, MCI_UPDATE,
                MCI_ANIM_UPDATE_HDC | MCI_WAIT, (DWORD_PTR)(LPVOID)&mciUpdate);
        SetDestRectMCI(&rcSave);
        SetViewportOrgEx(hdcMem, 0, 0, NULL);
    }

    if (gwOptions & OPT_BORDER) {
        SetRect(&rc, 0, 0, xSize, ySize);
        FrameRect(hdcMem, &rc, GetStockObject(BLACK_BRUSH));

        if (gwOptions & OPT_TITLE) {
            SetRect(&rc, 0, ySize - TITLE_HEIGHT, xSize, ySize-TITLE_HEIGHT+1);
            FrameRect(hdcMem, &rc, GetStockObject(BLACK_BRUSH));
        }
    }

    if (hbmT)
        SelectObject(hdcMem, hbmT);
    DeleteDC(hdcMem);
    grcSize=rcs;

    return hbm;
}

//
//  if we are on a palette device, dither to the VGA colors
//  for apps that dont deal with palettes!
//
void FAR PASCAL DitherMCI(HANDLE hdib, HPALETTE hpal)
{
    LPBYTE      lpBits;
    int         i;
    LPBITMAPINFOHEADER  lpbi;

    DPF2("DitherMCI\n");

    lpbi = (LPVOID)GLOBALLOCK(hdib);

    if (lpbi == NULL)
        return;

    ////////////////////////////////////////////////////////////////////////
    //
    // HACK!!! patch the fake gamma-corrected colors to match the VGA's
    //
    ////////////////////////////////////////////////////////////////////////

    lpBits = (LPBYTE)(lpbi+1);

    for (i=0; i<8*4; i++)
    {
        if (lpBits[i] == 191)
            lpBits[i] = 128;
    }
    ////////////////////////////////////////////////////////////////////////

    lpBits = (LPBYTE)(lpbi+1) + 256 * sizeof(RGBQUAD);

    BltProp(lpbi,lpBits,0,0,(int)lpbi->biWidth,(int)lpbi->biHeight,
        lpbi,lpBits,0,0);

    GLOBALUNLOCK(hdib);
}


void FAR PASCAL CopyMCI(HWND hwnd)
{
    HBITMAP  hbm;
    HPALETTE hpal;
    HANDLE   hdib;
    HANDLE   hmfp;
    HDC      hdc;

    DPF2("CopyMCI\n");

    if (gwDeviceID == (UINT)0)
        return;

    if (hwnd) {
        if (!OpenClipboard(ghwndApp))
            return;

        EmptyClipboard();
    }

    hpal = PaletteMCI();
    hbm  = BitmapMCI();
    hdib = DibFromBitmap(hbm, hpal);
    hpal = CopyPalette(hpal);

    //
    //  if we are on a palette device. possibly dither to the VGA colors
    //  for apps that dont deal with palettes!
    //
    hdc = GetDC(NULL);
    if ((GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) &&
             (gwOptions & OPT_DITHER) && (gwDeviceType & DTMCI_CANWINDOW)) {
        DitherMCI(hdib, hpal);
        hpal = NULL;
    }
    ReleaseDC(NULL, hdc);

    hmfp = PictureFromDib(hdib, hpal);

    if (hmfp)
        SetClipboardData(CF_METAFILEPICT, hmfp);

    if (hdib)
        SetClipboardData(CF_DIB, hdib);

    if (hpal)
        SetClipboardData(CF_PALETTE, hpal);

//// we want people to pick the meta file always.
////if (hbm)
////     SetClipboardData(CF_BITMAP, hbm);
    if (hbm)
        DeleteObject(hbm);

    /* If not everything can be copied to the clipboard, error out and  */
    /* don't put anything up there.                                     */
    if (!hmfp || !hdib) {
        EmptyClipboard();
        Error(ghwndApp, IDS_CANTCOPY);
    }

    if (hwnd)
        CloseClipboard();
}


/* MCIWndProc()
 *
 * Window procedure for MCI element window.
 * This also initiates the the OLE2 drag-drop data transfer if required.
 */
LONG_PTR FAR PASCAL _EXPORT
MCIWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT     ps;             // information from BeginPaint()
    HDC             hdc;
    DWORD           dw;             // function return status
    MCI_ANIM_UPDATE_PARMS mciUpdate;
    RECT            rc;
    static BOOL fDragCapture = FALSE;
    static RECT rcWin;
    POINT       pt;

    switch (msg)
    {
//      case WM_NCHITTEST:
//              return HTTRANSPARENT;

        case WM_CREATE:
                ghwndMCI = hwnd;
                SetWindowMCI(hwnd);
                break;

        case WM_SIZE:
                GetClientRect(hwnd, &rc);
                SetDestRectMCI(&rc);
                break;

        case WM_CLOSE:
                SetWindowMCI(NULL);
                break;

        case WM_DESTROY:
                SetWindowMCI(NULL);
                ghwndMCI = NULL;
                CleanUpDrag();
                break;

        case WM_RBUTTONDOWN:
                PostMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_STOP, 0);
                break;

        case WM_LBUTTONDOWN:
                switch(gwStatus) {

            case MCI_MODE_PAUSE:
                PostMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_PLAY, 0);
                break;

            case MCI_MODE_PLAY:
            case MCI_MODE_SEEK:
                PostMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_PAUSE, 0);
                break;

            default:
                //Capture to initiate the drag drop operation.
                if (!gfOle2IPEditing) {
                    fDragCapture = TRUE;
                    SetCapture(hwnd);
                    GetClientRect(hwnd, (LPRECT)&rcWin);
                    MapWindowPoints(hwnd, NULL, (LPPOINT)&rcWin, 2);
                }
            }
            break;

        case WM_LBUTTONDBLCLK:
            SeekMCI(gdwMediaStart);
            PostMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_PLAY, 0);
            break;

        case WM_LBUTTONUP:
            if (!fDragCapture)
                break;
            fDragCapture = FALSE;
            ReleaseCapture();
            break;

        case WM_MOUSEMOVE:
            //Initiate drag drop if outside the window.
            if (!fDragCapture)
                break;
            LONG2POINT(lParam, pt);
            MapWindowPoints(hwnd, NULL, &pt, 1);

            if (!PtInRect((LPRECT)&rcWin, pt)) {

                ReleaseCapture();
                DoDrag();
                fDragCapture = FALSE;

            } else {

                SetCursor(LoadCursor(ghInst,MAKEINTRESOURCE(IDC_DRAG)));
            }
            break;

        case WM_PALETTECHANGED:
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case WM_QUERYNEWPALETTE:
            if (gwDeviceID && (gwDeviceType & DTMCI_CANWINDOW)) {
                mciSendCommand(gwDeviceID, MCI_REALIZE,
                MCI_ANIM_REALIZE_NORM, 0L);
            }
            break;

        case WM_ERASEBKGND:
                /* Don't erase the part we'll paint into cuz we'd flicker */
                /* and flicker is bad.                                    */
                if (gwDeviceID && (gwDeviceType & DTMCI_CANWINDOW)) {
                    GetDestRectMCI(&rc);
                    SaveDC((HDC)wParam);
                    ExcludeClipRect((HDC)wParam, rc.left, rc.top, rc.right,
                        rc.bottom);
                    DefWindowProc(hwnd, msg, wParam, lParam);
                    RestoreDC((HDC)wParam, -1);
                }
                return 0;

        case WM_PAINT:
                hdc = BeginPaint(hwnd, &ps);

                if (gwDeviceID)
                {
                    GetClientRect(hwnd, &rc);

                    if (gwDeviceType & DTMCI_CANWINDOW) {
                        mciUpdate.hDC = hdc;

/*!!! should we send  MCI_DGV_UPDATE_PAINT? to non dgv devices? */

                        dw = mciSendCommand(gwDeviceID, MCI_UPDATE,
                            MCI_ANIM_UPDATE_HDC | MCI_WAIT |
                            MCI_DGV_UPDATE_PAINT,
                            (DWORD_PTR)(LPVOID)&mciUpdate);

                        //
                        // if the update fails then erase
                        //
                        if (dw != 0)
                            DefWindowProc(hwnd, WM_ERASEBKGND, (WPARAM)hdc, 0);

                    }
                }
                EndPaint(hwnd, &ps);
                return 0;
        }

        return DefWindowProc(hwnd, msg, wParam, lParam);
}

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

HPALETTE CopyPalette(HPALETTE hpal)
{
    PLOGPALETTE ppal;
    int         nNumEntries = 0; // MUST initialise.  GetObject stores TWO bytes
    int         i;

    if (!hpal)
        return NULL;

    GetObject(hpal,sizeof(int),&nNumEntries);

    if (nNumEntries == 0)
        return NULL;

    ppal = AllocMem(sizeof(LOGPALETTE) + nNumEntries * sizeof(PALETTEENTRY));

    if (!ppal)
        return NULL;

    ppal->palVersion    = 0x300;
    ppal->palNumEntries = (USHORT)nNumEntries;

    GetPaletteEntries(hpal,0,nNumEntries,ppal->palPalEntry);

    for (i=0; i<nNumEntries; i++)
        ppal->palPalEntry[i].peFlags = 0;

    hpal = CreatePalette(ppal);

    FreeMem(ppal, sizeof(LOGPALETTE) + nNumEntries * sizeof(PALETTEENTRY));

    return hpal;
}


#ifdef UNUSED
HANDLE PictureFromBitmap(HBITMAP hbm, HPALETTE hpal)
{
    LPMETAFILEPICT  pmfp;
    HANDLE          hmfp;
    HANDLE          hmf;
    HANDLE          hdc;
    HDC             hdcMem;
    BITMAP          bm;
    HBITMAP         hbmT;

    if (!hbm)
        return NULL;

    GetObject(hbm, sizeof(bm), (LPVOID)&bm);

    hdcMem = CreateCompatibleDC(NULL);
    if (!hdcMem)
        return NULL;
    hbmT = SelectObject(hdcMem, hbm);

    hdc = CreateMetaFile(NULL);
    if (!hdc) {
        DeleteDC(hdcMem);
        return NULL;
    }

    SetWindowOrgEx (hdc, 0, 0, NULL);
    SetWindowExtEx (hdc, bm.bmWidth, bm.bmHeight, NULL);

    if (hpal)
    {
        SelectPalette(hdcMem,hpal,FALSE);
        RealizePalette(hdcMem);
        SelectPalette(hdc,hpal,FALSE);
        RealizePalette(hdc);
    }

    SetStretchBltMode(hdc, COLORONCOLOR);
    BitBlt(hdc,0,0,bm.bmWidth,bm.bmHeight,hdcMem,0,0,SRCCOPY);

    hmf = CloseMetaFile(hdc);

    SelectObject(hdcMem, hbmT);
    DeleteDC(hdcMem);

    if (hmfp = GlobalAlloc(GMEM_DDESHARE|GMEM_MOVEABLE, sizeof(METAFILEPICT)))
    {
        pmfp = (LPMETAFILEPICT)GLOBALLOCK(hmfp);

        hdc = GetDC(NULL);
#if 1
        pmfp->mm   = MM_ANISOTROPIC;
        pmfp->hMF  = hmf;
        pmfp->xExt = MulDiv(bm.bmWidth ,2540,GetDeviceCaps(hdc, LOGPIXELSX));
        pmfp->yExt = MulDiv(bm.bmHeight,2540,GetDeviceCaps(hdc, LOGPIXELSX));
#else
        pmfp->mm   = MM_TEXT;
        pmfp->hMF  = hmf;
        pmfp->xExt = bm.bmWidth;
        pmfp->yExt = bm.bmHeight;
#endif
        ReleaseDC(NULL, hdc);
    }
    else
    {
        DeleteMetaFile(hmf);
    }

    return hmfp;
}
#endif /* UNUSED */

HANDLE FAR PASCAL PictureFromDib(HANDLE hdib, HPALETTE hpal)
{
    LPMETAFILEPICT      pmfp;
    HANDLE              hmfp;
    HANDLE              hmf;
    HANDLE              hdc;
    LPBITMAPINFOHEADER  lpbi;

    if (!hdib)
        return NULL;

    lpbi = (LPVOID)GLOBALLOCK(hdib);
    if (lpbi->biClrUsed == 0 && lpbi->biBitCount <= 8)
        lpbi->biClrUsed = 1 << lpbi->biBitCount;

    hdc = CreateMetaFile(NULL);
    if (!hdc)
        return NULL;

    SetWindowOrgEx(hdc, 0, 0, NULL);
    SetWindowExtEx(hdc, (int)lpbi->biWidth, (int)lpbi->biHeight, NULL);

    if (hpal)
    {
        SelectPalette(hdc,hpal,FALSE);
        RealizePalette(hdc);
    }

    SetStretchBltMode(hdc, COLORONCOLOR);

    StretchDIBits(hdc,
        0,0,(int)lpbi->biWidth, (int)lpbi->biHeight,
        0,0,(int)lpbi->biWidth, (int)lpbi->biHeight,
        (LPBYTE)lpbi + (int)lpbi->biSize + (int)lpbi->biClrUsed * sizeof(RGBQUAD),
        (LPBITMAPINFO)lpbi,
        DIB_RGB_COLORS,
        SRCCOPY);

    if (hpal)
        SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), FALSE);

    hmf = CloseMetaFile(hdc);

    hmfp = GlobalAlloc(GMEM_DDESHARE|GMEM_MOVEABLE, sizeof(METAFILEPICT));

    if (hmfp)
    {
        pmfp = (LPMETAFILEPICT)GLOBALLOCK(hmfp);

        hdc = GetDC(NULL);
#if 1
        pmfp->mm   = MM_ANISOTROPIC;
        pmfp->hMF  = hmf;
        pmfp->xExt = MulDiv((int)lpbi->biWidth ,2540,GetDeviceCaps(hdc, LOGPIXELSX));
        pmfp->yExt = MulDiv((int)lpbi->biHeight,2540,GetDeviceCaps(hdc, LOGPIXELSY));
        extWidth   = pmfp->xExt;
        extHeight  = pmfp->yExt;
        DPF1("PictureFromDib: Bitmap %d x %d; metafile %d x %d\n", lpbi->biWidth, lpbi->biHeight, extWidth, extHeight);
#else
        pmfp->mm   = MM_TEXT;
        pmfp->hMF  = hmf;
        pmfp->xExt = (int)lpbi->biWidth;
        pmfp->yExt = (int)lpbi->biHeight;
#endif

        ReleaseDC(NULL, hdc);
    }
    else
    {
        DeleteMetaFile(hmf);
    }

    GLOBALUNLOCK(hdib);
    GLOBALUNLOCK(hmfp);

    return hmfp;
}

#define WIDTHBYTES(i)     ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */

/*
 *  DibFromBitmap()
 *
 *  Will create a global memory block in DIB format that represents the DDB
 *  passed in
 *
 */
HANDLE FAR PASCAL DibFromBitmap(HBITMAP hbm, HPALETTE hpal)
{
    BITMAP               bm;
    BITMAPINFOHEADER     bi;
    BITMAPINFOHEADER FAR *lpbi;
    DWORD                dw;
    HANDLE               hdib;
    HDC                  hdc;
    HPALETTE             hpalT;

    if (!hbm)
        return NULL;

    GetObject(hbm,sizeof(bm),&bm);

    bi.biSize               = sizeof(BITMAPINFOHEADER);
    bi.biWidth              = bm.bmWidth;
    bi.biHeight             = bm.bmHeight;
    bi.biPlanes             = 1;
    bi.biBitCount           = (bm.bmPlanes * bm.bmBitsPixel) > 8 ? 24 : 8;
    bi.biCompression        = BI_RGB;
    bi.biSizeImage          = (DWORD)WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;
    bi.biXPelsPerMeter      = 0;
    bi.biYPelsPerMeter      = 0;
    bi.biClrUsed            = bi.biBitCount == 8 ? 256 : 0;
    bi.biClrImportant       = 0;

    dw  = bi.biSize + bi.biClrUsed * sizeof(RGBQUAD) + bi.biSizeImage;

    hdib = GlobalAlloc(GHND | GMEM_DDESHARE, dw);

    if (!hdib)
        return NULL;

    lpbi = (LPBITMAPINFOHEADER)GLOBALLOCK(hdib);
    *lpbi = bi;

    hdc = CreateCompatibleDC(NULL);

    if (hpal && hdc)
    {
        hpalT = SelectPalette(hdc,hpal,FALSE);
        RealizePalette(hdc);
    }

    GetDIBits(hdc, hbm, 0, (UINT)bi.biHeight,
        (LPBYTE)lpbi + (int)lpbi->biSize + (int)lpbi->biClrUsed * sizeof(RGBQUAD),
        (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

    if (hpal)
        SelectPalette(hdc,hpalT,FALSE);

    if (hdc)
        DeleteDC(hdc);

    GLOBALUNLOCK(hdib);

    return hdib;
}

/* CreateSystemPalette()
 *
 * Return a palette which represents the system (physical) palette.
 * By selecting this palette into a screen DC and realizing the palette,
 * the exact physical mapping will be restored
 *
 * one use for this is when "snapping" the screen as a bitmap
 *
 * On error (e.g. out of memory), NULL is returned.
 */
HPALETTE FAR PASCAL CreateSystemPalette()
{
    HDC             hdc;                    // DC onto the screen
    int             iSizePalette;           // size of entire palette
    int             iFixedPalette;          // number of reserved colors
    int             i;

    struct {
        WORD         palVersion;
        WORD         palNumEntries;
        PALETTEENTRY palPalEntry[256];
    }   pal;

    hdc = GetDC(NULL);

    if (!(GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE))
    {
        ReleaseDC(NULL,hdc);
        return NULL;
    }

    iSizePalette = GetDeviceCaps(hdc, SIZEPALETTE);

    //
    // determine the number of 'static' system colors that
    // are currently reserved
    //
    if (GetSystemPaletteUse(hdc) == SYSPAL_STATIC)
        iFixedPalette = GetDeviceCaps(hdc, NUMCOLORS);
    else
        iFixedPalette = 2;

    //
    // create a logical palette containing the system colors;
    // this palette has all entries except fixed (system) colors
    // flagged as PC_NOCOLLAPSE
    //
    pal.palVersion = 0x300;
    pal.palNumEntries = (USHORT)iSizePalette;

    GetSystemPaletteEntries(hdc, 0, iSizePalette, pal.palPalEntry);

    ReleaseDC(NULL,hdc);

    for (i = iFixedPalette/2; i < iSizePalette-iFixedPalette/2; i++)
        pal.palPalEntry[i].peFlags = PC_NOCOLLAPSE;

    return CreatePalette((LPLOGPALETTE)&pal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\mci.h ===
/*-----------------------------------------------------------------------------+
| MCI.H                                                                        |
|                                                                              |
| Routines for dealing with MCI devices.                                       |
| These routines only support *one* open MCI device/file at a time.            |
|                                                                              |
| (C) Copyright Microsoft Corporation 1992.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

#define MCI_WINDOW_CLASS TEXT("MCIWindow")

BOOL FAR PASCAL InitMCI(HANDLE hPrev, HANDLE hInst);
BOOL FAR PASCAL OpenMCI(LPCTSTR szFile, LPCTSTR szDevice);
void LoadStatusStrings(void);
LPTSTR MapModeToStatusString( WORD Mode );
void FAR PASCAL UpdateMCI(void);
void FAR PASCAL CloseMCI(BOOL fUpdateDisplay);
BOOL FAR PASCAL PlayMCI(DWORD_PTR dwFrom, DWORD_PTR dwTo);
BOOL FAR PASCAL PauseMCI(void);
BOOL FAR PASCAL StopMCI(void);
BOOL FAR PASCAL EjectMCI(BOOL fOpen);
UINT FAR PASCAL StatusMCI(DWORD_PTR FAR *pdwPosition);
BOOL FAR PASCAL SeekMCI(DWORD_PTR dwPosition);
BOOL FAR PASCAL SeekToStartMCI(void);
void FAR PASCAL SkipTrackMCI(int iSkip);
BOOL FAR PASCAL SetWindowMCI(HWND hwnd);
HWND FAR PASCAL GetWindowMCI(void);
BOOL FAR PASCAL SetPaletteMCI(HPALETTE hpal);
BOOL FAR PASCAL SetTimeFormatMCI(UINT wTimeFormat);
BOOL FAR PASCAL SeekExactMCI(BOOL fExact);
void FAR PASCAL CreateWindowMCI(void);
void FAR PASCAL FindDeviceMCI(void);
void FAR PASCAL GetDeviceNameMCI(LPTSTR szDevice, UINT wLen);
void FAR PASCAL QueryDevicesMCI(LPTSTR szDevices, UINT wLen);

BOOL FAR PASCAL GetDestRectMCI(LPRECT lprc);
BOOL FAR PASCAL GetSourceRectMCI(LPRECT lprc);
BOOL FAR PASCAL SetDestRectMCI(LPRECT lprc);
BOOL FAR PASCAL SetSourceRectMCI(LPRECT lprc);

BOOL FAR PASCAL ShowWindowMCI(BOOL fShow);
BOOL FAR PASCAL PutWindowMCI(LPRECT prc);

#define MCI_STRING_LENGTH   128
DWORD PASCAL SendStringMCI(PTSTR szCmd, PTSTR szReturn, UINT wLen);

BOOL FAR PASCAL ConfigMCI(HWND hwnd);

HPALETTE FAR PASCAL PaletteMCI(void);
HBITMAP FAR PASCAL BitmapMCI(void);
void    FAR PASCAL CopyMCI(HWND hwnd);

#define WM_MCI_POSITION_CHANGE  (WM_USER+10)    // wParam = DeviceID, lParam = position
#define WM_MCI_MODE_CHANGE      (WM_USER+11)    // wParam = DeviceID, lParam = mode
#define WM_MCI_MEDIA_CHANGE     (WM_USER+12)    // wParam = DeviceID, lParam = 0


//
//  the following flags are returned by DeviceTypeMCI, and QueryDeviceMCI
//
UINT FAR PASCAL DeviceTypeMCI(LPTSTR szDevice, LPTSTR szDeviceName, int nBuf);
UINT FAR PASCAL QueryDeviceTypeMCI(UINT wDeviceID);

extern UINT gwDeviceType;

#define DTMCI_ERROR             0x0000
#define DTMCI_IGNOREDEVICE      0xFFFF

#define DTMCI_SIMPLEDEV         0x0001      // simple (not compound) device
#define DTMCI_FILEDEV           0x0002      // device does files
#define DTMCI_COMPOUNDDEV       0x0004      // compound (not simple) device
#define DTMCI_CANSEEKEXACT      0x0008      // can seek exactly
#define DTMCI_CANPLAY           0x0010      // device supports play
#define DTMCI_CANEJECT          0x0020      // device supports eject
#define DTMCI_CANCONFIG         0x0040      // device supports config
#define DTMCI_CANMUTE           0x0080      // device supports set audio
#define DTMCI_CANPAUSE          0x0100      // device supports config
#define DTMCI_CANWINDOW         0x0200      // device supports windows
#define DTMCI_TIMEFRAMES        0x0400      // device does frames
#define DTMCI_TIMEMS            0x0800      // device does milliseconds

// Known devices:
#define DTMCI_DEVICE            0xF000      // The following are mutually exclusive
#define DTMCI_AVIVIDEO          0x1000      // device is MCIAVI
#define DTMCI_CDAUDIO           0x2000      // device is CDAUDIO
#define DTMCI_SEQUENCER         0x3000      // device is MIDI sequencer
#define DTMCI_WAVEAUDIO         0x4000      // device is Wave audio
#define DTMCI_VIDEODISC         0x5000      // device is Video disc
#define DTMCI_VCR               0x6000      // device is Video cassette


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\menuids.h ===
/*-----------------------------------------------------------------------------+
| MENUIDS.H                                                                    |
|                                                                              |
| IDs of the menu items.                                                       |
|                                                                              |
| (C) Copyright Microsoft Corporation 1992.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

/* Menu Identifiers */

/* File */

#define IDM_OPEN                100     /* ID of the 'Open File' option       */
#define IDM_CLOSE               101     /* ID of the 'Close' option           */
#define IDM_EXIT                102     /* ID of the 'Exit' option            */

/* Edit */

#define IDM_COPY_OBJECT         110     /* copy ole object */
#define IDM_OPTIONS             111
#define IDM_SELECTION           112

/* Device */

#define IDM_CONFIG              120     /* do device config dialog */
#define IDM_VOLUME              121     /* do device config dialog */

/* Scale */

#define IDM_SCALE               131     /* Add to one of the below */
#define ID_NONE                 0       /* nothing                            */
#define ID_FRAMES               1       /* ID of the 'Frames' scale option    */
#define ID_TIME                 2       /* ID of the 'Time' scale option      */
#define ID_TRACKS               3       /* ID of the 'Tracks' scale option    */

/* Help */

#define IDM_HELPTOPICS          140     /* ID of the 'Help Topics' option     */
#define IDM_ABOUT               143     /* ID of the 'About' option           */


#define IDM_UPDATE              222

#define IDM_WINDOW              223     /* make MPlayer small/big */
#define IDM_DEFAULTSIZE         224     /* make MPlayer the default size */
#define IDM_MCISTRING           225

#define IDM_ZOOM                230
#define IDM_ZOOM1               231
#define IDM_ZOOM2               232
#define IDM_ZOOM3               233
#define IDM_ZOOM4               234

#define IDM_NONE                400
#define IDM_DEVICE0             400     /* ID of the first entry in the Device*/
                                        /* menu. No new menu items should be  */
                                        /* #defined with a number greater than*/
                                        /* this.                              */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\mplayer.h ===
/*-----------------------------------------------------------------------------+
| MPLAYER.H                                                                    |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/
#if (DBG || defined(DEBUG_RETAIL))
#ifndef DEBUG
#define DEBUG
#endif
#endif

#include <stdlib.h> // Make sure _MAX_PATH is defined if it's there
#include <malloc.h>

#include "dynalink.h"
#include "menuids.h"
#include "helpids.h"
#include "mci.h"
#include "unicode.h"
#include "alloc.h"


#ifndef CHICAGO_PRODUCT
#ifndef RC_INVOKED
#include <winuserp.h>
#endif
#endif
#include <commctrl.h>
#define TBM_SHOWTICS    (WM_USER+30)

/* Dialog style on Win4+
 */
#ifndef DS_CONTEXTHELP
#define DS_CONTEXTHELP 0
#endif

/* These macros were originally defined for 16-32 portability.
 * The code is now expected to build for Win32 only.
 */
#define LONG2POINT(l, pt)               ((pt).x = (SHORT)LOWORD(l), (pt).y = (SHORT)HIWORD(l))
#define GETWINDOWUINT(hwnd, index)      (UINT)GetWindowLongPtr(hwnd, index)
#define GETWINDOWID(hwnd)               GETWINDOWUINT((hwnd), GWL_ID)
#define GETHWNDINSTANCE(hwnd)           (HINSTANCE)GetWindowLongPtr((hwnd), GWLP_HINSTANCE)
#define SETWINDOWUINT(hwnd, index, ui)  (UINT)SetWindowLongPtr(hwnd, index, (LONG_PTR)(ui))
#define MMoveTo(hdc, x, y)               MoveToEx(hdc, x, y, NULL)
#define MSetViewportExt(hdc, x, y)       SetViewportExtEx(hdc, x, y, NULL)
#define MSetViewportOrg(hdc, x, y)       SetViewportOrgEx(hdc, x, y, NULL)
#define MSetWindowExt(hdc, x, y)         SetWindowExtEx(hdc, x, y, NULL)
#define MSetWindowOrg(hdc, x, y)         SetWindowOrgEx(hdc, x, y, NULL)
#define MGetCurrentTask                  (HANDLE)ULongToPtr(GetCurrentThreadId())
#define _EXPORT
BOOL WINAPI   MGetTextExtent(HDC hdc, LPSTR lpstr, INT cnt, INT *pcx, INT *pcy);


#ifndef RC_INVOKED
#pragma warning(disable: 4001)  // nonstandard extension 'single line comment' was used
#pragma warning(disable: 4201)  // nonstandard extension used : nameless struct/union
#pragma warning(disable: 4214)  // nonstandard extension used : bit field types other than int
#pragma warning(disable: 4103)  // used #pragma pack to change alignment (on Chicago)
#endif

#ifdef OLE1_HACK
/* Disgusting OLE1 hackery:
 */
void Ole1UpdateObject(void);
extern DWORD gDocVersion;
#define DOC_VERSION_NONE    0
#define DOC_VERSION_OLE1    1
#define DOC_VERSION_OLE2    2

VOID SetDocVersion( DWORD DocVersion );

#endif /* OLE1_HACK */

//
//  have the debug version show preview.
//
extern BOOL    gfShowPreview;


#define DEF_WIDTH       ((GetACP()==932)?600:400)

#define DEF_HEIGHT      124

#define CAPTION_LEN     80        // max length of caption

/* BOGUS constants for Layout() */
#define FSARROW_WIDTH            20        // width of one arrow bitmap for SB
#define FSARROW_HEIGHT           17        // height
#define FSTRACK_HEIGHT           30        // height of the scrollbar
#define LARGE_CONTROL_WIDTH     172        // Width of full transport toolbar
#define SMALL_CONTROL_WIDTH      73        // width with only 3 buttons

#define SB_XPOS                   4        // how far in to put scrollbar
#define SHOW_MARK_WIDTH         363        // when to drop mark buttons
#define MAP_HEIGHT               14        // height of trackmap window
#define FULL_TOOLBAR_WIDTH      307        // when to drop last 4 transport btns
#define MARK_WIDTH               52        // width of mark button toolbar
#define MAX_NORMAL_HEIGHT        73        // max size for non-windowed device
#define MIN_NORMAL_HEIGHT        27        // min size for anybody

#ifndef _MAX_PATH
#define _MAX_PATH    144        /* max. length of full pathname */
#endif

#ifndef MAX_DEVICE
#define MAX_DEVICE    40        /* max. length of full pathname */
#endif

#define TOOLBAR_HEIGHT      27
#define BUTTONWIDTH         25
#define BUTTONHEIGHT        23

#define SZCODE TCHAR

/* Strings that MUST be ANSI even if we're compiling Unicode
 * e.g. to pass to GetProcAddress, which is ANSI only:
 */
#define ANSI_SZCODE CHAR
#define ANSI_TEXT( quote )  quote

/* Macro for string replacement parameter in printf etc:
 * (Anyone know of a better way to do this?)
 */
#ifdef UNICODE
#define TS  L"ws"L
#ifdef DEBUG
#define DTS "ws"    /* For unicode args to ASCII API */
#endif
#else
#define TS  "s"
#ifdef DEBUG
#define DTS "s"
#endif
#endif /* UNICODE */


/* defines for set sel dlg box */
#define IDC_EDITALL     220        // these 3 are a group
#define IDC_EDITSOME    221
#define IDC_EDITNONE    222

#define IDC_EDITFROM    223
#define IDC_EDITTO      224
#define IDC_EDITNUM     225

#define IDC_SELECTG     226     /* Needed for Context sensitive help */
#define IDC_ETTEXT      227
#define IDC_ESTEXT      228

#define ARROWEDITDELTA  10      /* Add to arrow ID to get edit ID */

#define IDC_XARROWS     180
#define IDC_YARROWS     181
#define IDC_WARROWS     182
#define IDC_HARROWS     183

#define IDC_FARROWS     183
#define IDC_TARROWS     184
#define IDC_NARROWS     210

/* Controls for Selection range dialog */
#define IDC_MARKIN      150
#define IDC_MARKOUT     151

#define DLG_MCICOMMAND  942
#define IDC_MCICOMMAND  10
#define IDC_RESULT      11

/* Bit fields for the gwOptions */
// bottom two bits = Scale Mode (01 = FRAMES) (10 = TIME) (11 = TRACK)
#define OPT_SCALE       0x0003
#define OPT_TITLE       0x0004
#define OPT_BORDER      0x0008
#define OPT_PLAY        0x0010
#define OPT_BAR         0x0020
#define OPT_DITHER      0x0040
#define OPT_AUTORWD     0x0080
#define OPT_AUTOREP     0x0100
#define OPT_USEPALETTE  0x0200
#define OPT_DEFAULT     (ID_TIME|OPT_TITLE|OPT_BORDER|OPT_PLAY|OPT_BAR)

#define OPT_FIRST       OPT_TITLE
#if 1
#define OPT_LAST        OPT_AUTOREP
#else
#define OPT_LAST        OPT_USEPALETTE
#endif

#define IDC_CAPTIONTEXT 202
#define IDC_OLEOBJECT   203
#define IDC_TITLETEXT   160
#define TITLE_HEIGHT    TOOLBAR_HEIGHT  // height of title bar part of object picture

/* Options used when initial Open dialog is displayed:
 */
#define OPEN_NONE       (UINT)-1
#define OPEN_VFW        0
#define OPEN_MIDI       1
#define OPEN_WAVE       2

#define MCIWND_STYLE WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | \
                     MCIWNDF_NOPLAYBAR | MCIWNDF_NOMENU | MCIWNDF_SHOWNAME | \
                     MCIWNDF_NOTIFYALL

/* Parameters for GetIconForCurrentDevice:
 */
#define GI_LARGE    0
#define GI_SMALL    1


/* For mapping strings to device IDs
 */
typedef struct _STRING_TO_ID_MAP
{
    LPTSTR pString;
    UINT   ID;
}
STRING_TO_ID_MAP, *PSTRING_TO_ID_MAP;


/* global array of all mci devices */

typedef struct {
    UINT    wDeviceType;        // flags, DTMCI_*
    PTSTR   szDevice;           // name used to open device e.g. "WaveAudio"
    PTSTR   szDeviceName;       // name to display to user  e.g. "Wave Audio"
    PTSTR   szFileExt;          // file extensions used by device.
}   MCIDEVICE, *PMCIDEVICE;

#define MAX_MCI_DEVICES     50

extern UINT         gwCurDevice;       /* current device */
extern UINT         gwNumDevices;      /* number of available devices   */
extern MCIDEVICE    garMciDevices[];   /* array with info about a device */

/* global variables */
extern DWORD   gwPlatformId;           // Win95, NT etc
extern BOOL    gfEmbeddedObject;       // TRUE if editing embedded OLE object
extern BOOL    gfPlayingInPlace;       // TRUE if playing in place
extern BOOL    gfParentWasEnabled;     // TRUE if parent was enabled
extern BOOL    gfShowWhilePlaying;     //
extern BOOL    gfDirty;                //
extern int     gfErrorBox;             // TRUE if we have a message box active
extern BOOL    gfErrorDeath;           // Die when errorbox is up

extern BOOL gfOleInitialized;
extern BOOL gfOle2Open;
extern BOOL gfOle2IPEditing;
extern BOOL gfOle2IPPlaying;
extern RECT gInPlacePosRect;
extern HWND ghwndCntr;
extern HWND ghwndIPToolWindow;
extern HWND ghwndIPScrollWindow;

extern LPWSTR sz1Ole10Native;

extern UINT         gwOptions;         /* play options */
extern UINT         gwOpenOption;      /* Type of file to open */
extern BOOL         gfOpenDialog;      // If TRUE, put up open dialog
extern BOOL         gfCloseAfterPlaying;  // TRUE if we are to hide after play
extern BOOL         gfRunWithEmbeddingFlag; // TRUE if run with "-Embedding"
extern HMENU        ghMenu;            /* normal menu */
extern HICON        hiconApp;          /* the applicaiion's icon */
extern HANDLE       ghInst;            /* the application's instance handle   */
extern DWORD        gfdwFlagsEx;       /* the application's RTL status        */
extern HANDLE       ghInstPrev;        /* the application's instance handle   */
extern HFONT        ghfontMap;         /* font used for drawing the track map */
extern HWND         ghwndApp;          /* handle to the main dialog window    */
extern HWND         ghwndMap;          /* handle to the track map window      */
extern HWND         ghwndTrackbar;     /* handle to the horizontal track bar  */
extern HWND         ghwndToolbar;      /* handle to the toolbar               */
extern HWND         ghwndMark;         /* handle to the Mark buttons toolbar  */
extern HWND         ghwndFSArrows;     /* handle to the scrollbar arrows      */
extern HWND         ghwndStatic;       /* handle ot the static text window    */
extern HWND         ghwndMCI;          /* MCI window returned from MCIWndCreate */
extern HBRUSH       ghbrFillPat;       /* The selection fill pattern.         */
extern UINT         gwHeightAdjust;    /* Difference between client & non-c height */
extern LPTSTR       gszCmdLine;        /* null-terminated command line str.   */
extern int          giCmdShow;         /* show command                        */
extern UINT         gwDeviceID;        /* current MCI device ID (or NULL)     */
extern UINT         gwStatus;          /* status of current MCI device        */
extern UINT         gwNumTracks;       /* current # of tracks in the medium   */
extern UINT         gwFirstTrack;      /* number of first track                      */
extern BOOL         gfValidMediaInfo;  /* are we displaying valid media info? */
extern BOOL         gfValidCaption;    /* are we displaying a valid caption?  */
extern BOOL         gfPlayOnly;        /* play only window?  */
extern BOOL         gfJustPlayed;      /* Just sent a PlayMCI() command       */
extern DWORD        gdwLastSeekToPosition; /* Last requested seek position    */
extern DWORD        gdwMediaLength;    /* length of entire medium in msec.    */
extern DWORD        gdwMediaStart;     /* start of medium in msec.              */
extern DWORD NEAR * gadwTrackStart;    /* array of track start positions      */
extern UINT         gwOptions;               /* the options from the dlg box        */
extern SZCODE       aszIntl[];         /* string for international section */
extern TCHAR        gachAppName[];     /* string for holding the app. name  */
extern TCHAR        gachClassRoot[];   /* string for holding the class root OLE "Media Clip"*/
extern TCHAR        chDecimal;         /* Stores current decimal separator */
extern TCHAR        chTime;            /* Stores the current Time separator */
extern TCHAR        chLzero;           /* Stores if Leading Zero required for decimal numbers less than 1 */
extern TCHAR        aszNotReadyFormat[];
extern TCHAR        aszReadyFormat[];
extern TCHAR        gachFileDevice[_MAX_PATH];  /* string holding the current file or device name */
extern TCHAR        gachWindowTitle[_MAX_PATH]; /* string holding name */
extern TCHAR        gachCaption[_MAX_PATH];     /* string holding name */
extern TCHAR        gachOpenExtension[5];   /* Non-null if a device extension passed in */
extern TCHAR        gachOpenDevice[128];    /* Non-null if a device extension passed in */

extern TCHAR        gszHelpFileName[];/* name of the help file        */
extern TCHAR        gszHtmlHelpFileName[];/* name of the html help file */

extern DWORD        gdwSeekPosition;  /* Position to seek to after skipping track. */
extern BOOL         gfScrollTrack;    /* is user dragging the scrollbar thumb?  */
extern UINT         gwCurScale;       /* scale is TIME/TRACKS/FRAMES */
extern INT          gwCurZoom;        /* current zoom factor */

extern HWND         ghwndMCI;         /* current window for window objects */
extern RECT         grcSize;          /* size of MCI object */
extern BOOL         gfAppActive;      /* Our app active? (incl. playback win) */
extern LONG         glSelStart;       /* See if selection changes (dirty object)*/
extern LONG         glSelEnd;         /* See if selection changes (dirty object)*/

extern HPALETTE     ghpalApp;
extern BOOL     gfInClose;
extern BOOL     gfCurrentCDNotAudio;  /* TRUE when we have a CD that we can't play */
extern BOOL     gfWinIniChange;

extern DWORD        gdwPosition;      /* The Seek position we emedded */
extern BOOL         gfSeenPBCloseMsg;
extern int      giHelpContext;    /* Contains the context id for help */

extern HANDLE   heventDeviceMenuBuilt;/* Event will be signaled when device menu complete */
extern HANDLE   heventCmdLineScanned; /* Event will be signaled when command line scanned */

// strings for registration database
extern SZCODE aszKeyMID[];
extern SZCODE aszKeyRMI[];
extern SZCODE aszKeyAVI[];
extern SZCODE aszKeyMMM[];
extern SZCODE aszKeyWAV[];

extern SZCODE szCDAudio[];
extern SZCODE szVideoDisc[];
extern SZCODE szSequencer[];
extern SZCODE szVCR[];
extern SZCODE szWaveAudio[];
extern SZCODE szAVIVideo[];

/* constants */

#define DEVNAME_MAXLEN            40               /* the maximum length of a device name */

/* IDs of icons and dialog boxes */

#define APPICON                 10     /* ID of the application's icon        */
#define	IDI_DDEFAULT    11
#define	IDI_DSOUND		12
#define	IDI_DVIDEO		13
#define	IDI_DANI		14
#define	IDI_DMIDI		15
#define	IDI_DCDA		16
#define IDC_DRAG                17


#define MPLAYERBOX              11     /* ID of the main "MPlayer" dialog box */
#define MPLAYERACCEL             1

/* IDs of the MPLAYERBOX (main dialog box) controls */

#define ID_MAP                  20     /* ID of thetrack map                  */
#define ID_SB                   21     /* ID of the horizontal scrollbar      */
#define ID_STATIC               22     /* ID of the static text control       */
#define ID_PLAY                 23     /* Command   'Play'                    */
#define ID_PAUSE                24     /* Command   'Pause'                   */
#define ID_STOP                 25     /* Command   'Stop'                    */
#define ID_PLAYSEL              26     /* Command   'Play Selection'          */
#define ID_PLAYTOGGLE           27     /* For accelerator to toggle play/pause*/
#define ID_EJECT                28     /* Command   'Eject'                   */
#define ID_ESCAPE               29     /* Escape key was hit                  */

/* IDs of the string resources */

#define IDS_APPNAME             100    /* ID of the application name string   */
#define IDS_OPENTITLE           101    /* ID of the "Open Media File" str.    */
#define IDS_OUTOFMEMORY         102    /* ID of the "Out of memory" string    */
#define IDS_CANTOPENFILEDEV     103    /* ID of the "Cannot open file/dev" str*/
#define IDS_DEVICEINUSE         104    /* ID of the "Device is in use" string */
#define IDS_CANTOPENFILE        105    /* ID of the "Cannot open file" string */
#define IDS_CANTACCESSFILEDEV   106    /* ID of the "Cannot access..." str.   */
#define IDS_DEVICECANNOTPLAY    107    /* ID of the "Cannot play..." str.     */
#define IDS_SCALE               108    /* ID of the "Scale" string            */
#define IDS_CANTPLAY            109
#define IDS_CANTEDIT            110
#define IDS_CANTCOPY            111
#define IDS_FINDFILE            112
#define IDS_DEVICENOTINSTALLED  113
#define IDS_DEVICEERROR         114    /* ID of the "Device error" str.              */
#define IDS_CANTPLAYSOUND       115
#define IDS_CANTPLAYVIDEO       116
#define IDS_CANTPLAYMIDI        117
#define IDS_NOTSOUNDFILE        118
#define IDS_NOTVIDEOFILE        119
#define IDS_NOTMIDIFILE         120

#define IDS_TIMEMODE            121    /* Moved "Set Selection" strings from  */
#define IDS_FRAMEMODE           122    /* being embedded in DLGS.C !          */
#define IDS_TRACKMODE           123

#define IDS_SEC         124 /* "hrs", "min", "sec" and "msec" string ids. */
#define IDS_MIN         125
#define IDS_HRS         126
#define IDS_MSEC        127
#define IDS_FRAME       128 /* "frame" string id.               */

#define IDS_UPDATEOBJECT        129

#define IDS_NOTREADYFORMAT      132
#define IDS_READYFORMAT         133
#define IDS_DEVICEMENUCOMPOUNDFORMAT 134
#define IDS_DEVICEMENUSIMPLEFORMAT   135
#define IDS_ALLFILES            136
#define IDS_ANYDEVICE           137
#define IDS_CLASSROOT           138
#define IDS_NOGOODTIMEFORMATS   139

#define IDS_FRAMERANGE          140
#define IDS_INIFILE             141    /* ID of the private INI file name     */
#define IDS_HELPFILE            142    /* ID of help file name     */
#define IDS_HTMLHELPFILE        147    /* ID of HTML help file */

#define IDS_NOMCIDEVICES        143    /* no MCI devices are installed.  */
#define IDS_PLAYVERB            144
#define IDS_EDITVERB            145
#define IDS_CANTSTARTOLE        146

#define IDS_UNTITLED            149

#define IDS_CANTLOADLIB         151
#define IDS_CANTFINDPROC        152

#define IDS_MPLAYERWIDTH        200

#define IDS_CANTACCESSFILE		250

/* These macros and typedefs can be used to clarify whether we're talking about
 * numbers of characters or numbers of bytes in a given buffer.
 * Unfortunately C doesn't give us type checking to do this properly.
 */
#undef BYTE_COUNT
#define BYTE_COUNT( buf )   sizeof(buf)

#undef CHAR_COUNT
#define CHAR_COUNT( buf )   (sizeof(buf) / sizeof(TCHAR))

/* Find how many bytes are in a given string:
 */
#define STRING_BYTE_COUNT( str )    (STRLEN(str) * sizeof(TCHAR) + sizeof(TCHAR))
#define ANSI_STRING_BYTE_COUNT( str )   (strlen(str) * sizeof(CHAR) + sizeof(CHAR))

/* Check the length of a string or number of bytes where NULL is a valid
 * pointer which should give a length of 0:
 */
#define STRLEN_NULLOK( str )    ((str) ? STRLEN(str) : 0)
#define STRING_BYTE_COUNT_NULLOK( str ) ((str) ? STRING_BYTE_COUNT(str) : 0)

/* Use this macro for loading strings.  It make the parameter list tidier
 * and ensures we pass the buffer size in CHARACTERS, not bytes.
 * This assumes that the buffer is static, not dynamically allocated.
 */
#define LOADSTRING( id, buf )   LoadString(ghInst, (UINT)id, buf, CHAR_COUNT(buf))
#define LOADSTRINGFROM( inst, id, buf )   LoadString(inst, id, buf, CHAR_COUNT(buf))

/* track map scale values */

#define SCALE_HOURS             153    /* draw the scale in hours          */
#define SCALE_MINUTES           154    /* draw the scale in minutes        */
#define SCALE_SECONDS           155    /* draw the scale in seconds        */
#define SCALE_MSEC              156    /* draw it in milli vanilliseconds  */
#define SCALE_FRAMES            157    /* draw scale in 'frames'           */
#define SCALE_TRACKS            158
#define SCALE_NOTRACKS          159

#define IDS_CLOSE               160
#define IDS_UPDATE              161
#define IDS_NOPICTURE           162
#define IDS_EXIT                163
#define IDS_EXITRETURN          164

#define IDS_SSNOTREADY      170
#define IDS_SSPAUSED        171
#define IDS_SSPLAYING       172
#define IDS_SSSTOPPED       173
#define IDS_SSOPEN      174
#define IDS_SSPARKED        175
#define IDS_SSRECORDING     176
#define IDS_SSSEEKING       177
#define IDS_SSUNKNOWN       178

#define IDS_OLEVER      180
#define IDS_OLEINIT     181
#define IDS_OLENOMEM        182

//InPlace menu names.
#define IDS_EDITMENU        185
#define IDS_INSERTMENU      186
#define IDS_SCALEMENU       187
#define IDS_COMMANDMENU     188
#define IDS_HELPMENU        189
#define IDS_NONE                190

#define IDS_MSGFORMAT		191
#define IDS_FORMATEMBEDDEDTITLE 192
#define IDS_IS_RTL              193

// String for registry fix-up message
#define IDS_BADREG          195
#define IDS_FIXREGERROR     196

#define IDS_NETWORKERROR        197
#define IDS_UNKNOWNNETWORKERROR 198

#define IDS_INSERTAUDIODISC     199

/* macros for displaying error messages */

#define MB_ERROR    (MB_ICONEXCLAMATION | MB_OK)
#define Error(hwnd, idsFmt)                                               \
    ( ErrorResBox(hwnd, ghInst, MB_ERROR, IDS_APPNAME, (idsFmt)), FALSE )
#define Error1(hwnd, idsFmt, arg1)                                        \
    ( ErrorResBox(hwnd, ghInst, MB_ERROR, IDS_APPNAME, (idsFmt), (arg1)), \
        FALSE )
#define Error2(hwnd, idsFmt, arg1, arg2)                                  \
    ( ErrorResBox(hwnd, ghInst, MB_ERROR, IDS_APPNAME,  (idsFmt), (arg1), \
        (arg2)), FALSE )


/* app tabbing code */
BOOL IsDannyDialogMessage(HWND hwndApp, MSG msg);

/* calc where the tics belong on the scrollbar */
void FAR PASCAL CalcTicsOfDoom(void);

/* Layout the main window and the children */
void FAR PASCAL Layout(void);

/* prototypes from "errorbox.c" */
short FAR cdecl ErrorResBox(HWND hwnd, HANDLE hInst, UINT flags,
        UINT idAppName, UINT idErrorStr, ...);

/* function prototypes from "framebox.c" */
BOOL FAR PASCAL frameboxInit(HANDLE hInst, HANDLE hPrev);
/* function prototypes from "dlgs.c" */
BOOL FAR PASCAL mciDialog(HWND hwnd);
BOOL FAR PASCAL setselDialog(HWND hwnd);
BOOL FAR PASCAL optionsDialog(HWND hwnd);
/* function prototypes from "arrow.c" */
BOOL FAR PASCAL ArrowInit(HANDLE hInst);

/* function prototypes from "mplayer.c" */
void FAR PASCAL FormatTime(DWORD_PTR dwPosition, LPTSTR szNum, LPTSTR szBuf, BOOL fRound);
void FAR PASCAL UpdateDisplay(void);
void FAR PASCAL EnableTimer(BOOL fEnable);
LRESULT FAR PASCAL MPlayerWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
HICON GetIconForCurrentDevice(UINT Size, UINT DefaultID);
void SetMPlayerIcon(void);

/* function prototypes from "init.c" */
BOOL FAR PASCAL AppInit(HANDLE hInst, HANDLE hPrev, LPTSTR szCmdLine);
void FAR PASCAL InitMPlayerDialog(HWND hwnd);
BOOL FAR PASCAL GetIntlSpecs(void);

void FAR PASCAL SmartWindowPosition (HWND hWndDlg, HWND hWndShow, BOOL fForce);

void FAR PASCAL SizeMPlayer(void);
void FAR PASCAL SetMPlayerSize(LPRECT prc);

void FAR PASCAL InitDeviceMenu(void);
void WaitForDeviceMenu(void);

VOID FAR PASCAL CompleteOpenDialog(BOOL FileSelected);

/* function prototypes from "open.c" */

INT_PTR FAR PASCAL DoOpen(UINT wCurDevice, LPTSTR SzFileName);
BOOL FAR PASCAL DoChooseDevice(UINT wID);
void FAR PASCAL CheckDeviceMenu(void);
BOOL FAR PASCAL OpenMciDevice(LPCTSTR szFile, LPCTSTR szDevice);
UINT FAR PASCAL IsMCIDevice(LPCTSTR szDevice);

/* function prototype from "trackmap.c" */

LRESULT FAR PASCAL fnMPlayerTrackMap(HWND hwnd, UINT wMsg, WPARAM wParam,
    LPARAM lParam);

/* function prototype from init.c */
void FAR PASCAL WriteOutPosition(void);
void FAR PASCAL WriteOutOptions(void);
void FAR PASCAL ReadOptions(void);

void MapStatusString(LPTSTR lpstatusstr);

/* function prototype from "math.asm", if needed */

#define MULDIV32( number, numerator, denominator )  \
    MulDiv( (int)number, (int)numerator, (int)denominator )

/* function prototype from "doverb.c" */
LPTSTR FAR FileName(LPCTSTR);

/* constants */

#define WM_USER_DESTROY     (WM_USER+120)
#define WM_SEND_OLE_CHANGE  (WM_USER+122)
#define WM_STARTTRACK       (WM_USER+123)
#define WM_ENDTRACK         (WM_USER+124)
#define WM_BADREG           (WM_USER+125)
#define WM_DOLAYOUT         (WM_USER+126)
#define WM_GETDIB           (WM_USER+127)
#define WM_NOMCIDEVICES     (WM_USER+128)


/* constants */

#define SCROLL_GRANULARITY  ((gdwMediaLength+127)/128) /* granularity of the scrollbar  */
#define SCROLL_BIGGRAN      ((gdwMediaLength+15)/16)   /* gran. for page up/down in time mode */
#define UPDATE_TIMER        1                /* # of the timer being used     */
#define UPDATE_MSEC         500              /* msec between display updates  */
#define UPDATE_INACTIVE_MSEC 2000             /* msec betw. upds. when inactive*/
#define SKIPTRACKDELAY_MSEC 3000             /* max msec for double-page-left */

#define SetDlgFocus(hwnd) SendMessage(ghwndApp, WM_NEXTDLGCTL, (WPARAM)(hwnd), 1L)

#ifdef DEBUG
        #define STATICDT
        #define STATICFN
        int __iDebugLevel;

        extern void cdecl dprintf(LPSTR, ...);

        #define DPF0                         dprintf
        #define DPF  if (__iDebugLevel >  0) dprintf
        #define DPFI if (__iDebugLevel >= 1) dprintf
        #define DPF1 if (__iDebugLevel >= 1) dprintf
        #define DPF2 if (__iDebugLevel >= 2) dprintf
        #define DPF3 if (__iDebugLevel >= 3) dprintf
        #define DPF4 if (__iDebugLevel >= 4) dprintf
        #define CPF
#else
        #define STATICDT    static
        #define STATICFN    static
        #define DPF0       ; / ## /
        #define DPFI       ; / ## /
        #define DPF        ; / ## /
        #define DPF1        ; / ## /
        #define DPF2        ; / ## /
        #define DPF3        ; / ## /
        #define DPF4        ; / ## /

        #define CPF          / ## /
#endif

#ifdef DEBUG
LPVOID DbgGlobalLock(HGLOBAL hglbMem);
BOOL DbgGlobalUnlock(HGLOBAL hglbMem);
HGLOBAL DbgGlobalFree(HGLOBAL hglbMem);
#define GLOBALLOCK(hglbMem)     DbgGlobalLock(hglbMem)
#define GLOBALUNLOCK(hglbMem)   DbgGlobalUnlock(hglbMem);
#define GLOBALFREE(hglbMem)     DbgGlobalFree(hglbMem)
#else
#define GLOBALLOCK(hglbMem)     GlobalLock(hglbMem)
#define GLOBALUNLOCK(hglbMem)   GlobalUnlock(hglbMem);
#define GLOBALFREE(hglbMem)     GlobalFree(hglbMem)
#endif

/*----Constants--------------------------------------------------------------*/
    /* Push buttons */
#define psh15       0x040e
#define pshHelp     psh15
    /* Checkboxes */
#define chx1        0x0410
    /* Static text */
#define stc1        0x0440
#define stc2        0x0441
#define stc3        0x0442
#define stc4        0x0443
    /* Listboxes */
#define lst1        0x0460
#define lst2        0x0461
    /* Combo boxes */
#define cmb1        0x0470
#define cmb2        0x0471
    /* Edit controls */
#define edt1        0x0480


/**************************************************************************
***************************************************************************/

#define GetWS(hwnd)     GetWindowLongPtr(hwnd, GWL_STYLE)
#define PutWS(hwnd, f)  SetWindowLongPtr(hwnd, GWL_STYLE, f)
#define TestWS(hwnd,f)  (GetWS(hwnd) & f)
#define SetWS(hwnd, f)  ((PutWS(hwnd, GetWS(hwnd) | f) & (f)) != (f))
#define ClrWS(hwnd, f)  ((PutWS(hwnd, GetWS(hwnd) & ~(f)) & (f)) != 0)

#define GetWSEx(hwnd)    GetWindowLongPtr(hwnd, GWL_EXSTYLE)
#define PutWSEx(hwnd, f) SetWindowLongPtr(hwnd, GWL_EXSTYLE, f)
#define SetWSEx(hwnd, f) ((PutWSEx(hwnd, GetWSEx(hwnd) | f) & (f)) != (f))
#define ClrWSEx(hwnd, f) ((PutWSEx(hwnd, GetWSEx(hwnd) & ~(f)) & (f)) != 0)

// server related stuff.

void FAR PASCAL ServerUnblock(void);
void FAR PASCAL BlockServer(void);
void FAR PASCAL UnblockServer(void);
void FAR PASCAL PlayInPlace(HWND hwndApp, HWND hwndClient, LPRECT prc);
void FAR PASCAL EditInPlace(HWND hwndApp, HWND hwndClient, LPRECT prc);
void FAR PASCAL EndPlayInPlace(HWND hwndApp);
void FAR PASCAL EndEditInPlace(HWND hwndApp);
void FAR PASCAL DelayedFixLink(UINT verb, BOOL fShow, BOOL fActivate);
void DirtyObject(BOOL fDocStgChangeOnly);
void CleanObject(void);
void UpdateObject(void);
BOOL FAR PASCAL IsObjectDirty(void);
void FAR PASCAL TerminateServer(void);
void FAR PASCAL SetEmbeddedObjectFlag(BOOL flag);
HMENU GetInPlaceMenu(void);
void PostCloseMessage();
void FAR PASCAL InitDoc(BOOL fUntitled);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\mpole.h ===
/*---------------------------------------------------------------------------
|   MPOLE.H
|   This file is the header file that has most of the OLE2 specific
|   data structures.
|
|   Created By: Vij Rajarajan (VijR)
+---------------------------------------------------------------------------*/
#ifndef COBJMACROS
#define COBJMACROS
#endif
#ifdef MTN
#pragma warning(disable: 4103)  // used #pragma pack to change alignment (on Chicago)
#endif
#include <ole2.h>
#include <ole2ver.h>
#include <shlobj.h> /* For ResolveLink() */
#include "server.h"

#ifdef INCGUID
#include <initguid.h>
#endif

#define _NOHRESULT

#define INPLACE
#define DRAGDROP

#define RETURN_RESULT(sc) return(ResultFromScode(sc))

// number HIMETRIC units per inch
#define  HIMETRIC_PER_INCH  2540

#if (defined(DEBUG) || DBG)
BOOL WriteOLE2Class( );
#endif

/****  'lindex' related macros  ****/

#define DEF_LINDEX              -1

#define VERIFY_LINDEX(lindex) { \
    if (lindex != -1)    \
        return (ResultFromScode(E_INVALIDARG)); \
}

// Used to check for "-Embedding" on command line.
#define szEmbeddingFlag  "Embedding"


// Maximum length of a fully-qualified pathname.
#define cchFilenameMax  256

//OLE2 CLsids
DEFINE_OLEGUID(CLSID_MPlayer,           0x00022601, 0, 0);
#define CLSID_MPLAYER CLSID_MPlayer

//OLE1 clsid.
DEFINE_OLEGUID(CLSID_Ole1MPlayer,           0x0003000E, 0, 0);
#define CLSID_OLE1MPLAYER CLSID_Ole1MPlayer

extern TCHAR        gachProgID[];
extern CLSID        gClsID;
extern CLSID        gClsIDOLE1Compat;   /* This will be MPlayer's OLE1 class ID    */
                                        /* if we're servicing a Media Clip object, */
                                        /* otherwise it's the same as gClsID.      */

// Sizes of toolbar items
#define TOOLBAR_WIDTH           300
#define TOOL_WIDTH              26

/* Types */

// Document type

typedef enum
{
    doctypeNew,      // The document is untitled.
    doctypeFromFile, // The document exists in a file and may be linked.
    doctypeEmbedded, // The document is an embedded document.
} DOCTYPE;

// Verbs

typedef enum
{
   verbPlay = OLEIVERB_PRIMARY,
   verbEdit,
   verbOpen,
   verbNil
} VERB;


// Corresponds to the order of the menus in the .rc file.
enum {
    menuposFile,
    menuposEdit,
    menuposDevice,
    menuposScale,
    menuposHelp
};

#ifdef OLDSTUFF
/* Codes for CallBack events */
/* The first four of these are redefinitions on NT, and the others don't exist: */
typedef enum {
    OLE_CHANGED,            /* 0                                           */
    OLE_SAVED,              /* 1                                           */
    OLE_CLOSED,             /* 2                                           */
    OLE_RENAMED,            /* 3                                           */
    OLE_SAVEOBJ,            /* 4                                           */
    OLE_SIZECHG,            /* 5                                           */
    OLE_SHOWOBJ             /* 6                                           */
} OLE_NOTIFICATION;
#endif

typedef enum
{
    OLE_CHANGED,            /* 0                                             */
    OLE_SAVED,              /* 1                                             */
    OLE_CLOSED,             /* 2                                             */
    OLE_RENAMED,            /* 3                                             */
    OLE_QUERY_PAINT,        /* 4  Interruptible paint support                */
    OLE_RELEASE,            /* 5  Object is released(asynchronous operation  */
                            /*    is completed)                              */
    OLE_QUERY_RETRY        /* 6  Query for retry when server sends busy ACK */
} OLE_NOTIFICATION;
#define OLE_SAVEOBJ 7
#define OLE_SIZECHG 8
#define OLE_SHOWOBJ 9


// Server structure

typedef struct
{
    IClassFactory      olesrvr;        // This must be the first field so that
    BOOL               fEmbedding;     // was server launched for embedding
    int            cRef;           // ref count;
    int            cLock;          // Lock count
    DWORD          dwRegCF;
} SRVR, FAR *LPSRVR;

//InPlace data structure.
typedef struct tagINPLACEDATA {
    OLEMENUGROUPWIDTHS      menuWidths;
    HOLEMENU                holemenu;
    HMENU                   hmenuShared;
    LPOLEINPLACESITE        lpSite;
    LPOLEINPLACEUIWINDOW    lpUIWindow;
    LPOLEINPLACEFRAME       lpFrame;
    OLEINPLACEFRAMEINFO     frameInfo;
    BOOL                    fNoNotification;
    BOOL                    fInContextHelpMode;
} INPLACEDATA, * PINPLACEDATA, FAR* LPINPLACEDATA;


typedef struct DOC FAR* LPDOC;

// Document structure
typedef struct  DOC
{
    struct COleObjectImpl {
        IOleObjectVtbl FAR*             lpVtbl;
        LPDOC                                   lpdoc;
    } m_Ole;

    struct CDataObjectImpl {
        IDataObjectVtbl FAR*            lpVtbl;
        LPDOC                                   lpdoc;
    } m_Data;

    struct CPersistStorageImpl {
        IPersistStorageVtbl FAR* lpVtbl;
        LPDOC                                    lpdoc;
    } m_PersistStorage;

    struct COleInPlaceObjectImpl {
        IOleInPlaceObjectVtbl FAR* lpVtbl;
        LPDOC                                    lpdoc;
    } m_InPlace;

    struct COleInPlaceActiveObjectImpl {
        IOleInPlaceActiveObjectVtbl FAR* lpVtbl;
        LPDOC                                    lpdoc;
    } m_IPActive;

    struct CPersistFileImpl {
        IPersistFileVtbl FAR*   lpVtbl;
        LPDOC                                   lpdoc;
    } m_PersistFile;

    int             cRef;    // ref count.
    HWND                    hwnd;        // The object's own window
    LPTSTR           native; // Object data in native format
    LPOLECLIENTSITE         lpoleclient; // Client associated with the object
    LPDATAADVISEHOLDER      lpdaholder;  // util instance to hold data advises
    LPOLEADVISEHOLDER       lpoaholder;  // util instance to hold ole advises

    DOCTYPE                 doctype;     // Document type
    ATOM                    aDocName;    // Document name
    HWND            hwndParent;
    LPINPLACEDATA       lpIpData;
    int             cLock;

} DOC;


typedef struct ClipDragData CLIPDRAGDATA, FAR* LPCLIPDRAGDATA;
typedef struct ClipDragEnum CLIPDRAGENUM, FAR* LPCLIPDRAGENUM;

struct ClipDragData
{
    struct CDataObject {
        IDataObjectVtbl FAR*    lpVtbl;
        LPCLIPDRAGDATA                  lpclipdragdata;
    } m_IDataObject;
    struct CDropSource {
        IDropSourceVtbl FAR*    lpVtbl;
        LPCLIPDRAGDATA                  lpclipdragdata;
    } m_IDropSource;

    LPDOC                           lpdoc;
    int                 cRef;         // ref count
    LPCLIPDRAGENUM                  lpClipDragEnum;  // The enumerator
    BOOL                fClipData;      //Is this for Clipboard or Dragdrop
} ;

struct ClipDragEnum
{
    IEnumFORMATETCVtbl FAR* lpVtbl;

    int              cRef;    // ref count
    LPCLIPDRAGDATA           lpClipDragData;  // Obj to which enumerator blongs
    CLIPFORMAT           cfNext;      // Next format returned
};

#ifdef LATER
typedef struct _SCALE
{
    int num;    // Numerator
    int denom;  // Denominator
}
SCALE, *PSCALE;

extern SCALE        gscaleInitXY[2];   // Initial scale to use for inserting OLE objects
#define SCALE_X 0
#define SCALE_Y 1
#endif


/* Global variable declarations.  (See SrvrDemo.c for descriptions.) */
extern LPMALLOC         lpMalloc;
extern HMENU        hmenuMain;
extern SRVR             srvrMain;
extern DOC              docMain;
extern BOOL     fDocChanged;
extern TCHAR    szClient[];
extern TCHAR            szClientDoc[];
extern int extHeight;
extern int extWidth;
extern TCHAR dbs[];
extern int giXppli, giYppli;
extern BOOL SkipInPlaceEdit;
extern BOOL gfInPlaceResize;
extern BOOL gfOle1Client;
extern HWND ghwndIPHatch;
extern HANDLE ghClipData;
extern HANDLE ghClipMetafile;
extern HANDLE ghClipDib;
extern LONG   glCurrentVerb;
extern BOOL  gfPosRectChange;
extern RECT gPrevPosRect;

extern BOOL gfInPPViewer;

extern HWND  ghwndFrame;
extern HWND  ghwndFocusSave;

extern CLIPFORMAT   cfNative;
extern CLIPFORMAT       cfEmbedSource;
extern CLIPFORMAT   cfObjectDescriptor;
extern CLIPFORMAT   cfMPlayer;

extern IOleObjectVtbl                           oleVtbl;
extern IDataObjectVtbl              dataVtbl;
extern IEnumFORMATETCVtbl           ClipDragEnumVtbl;
extern IClassFactoryVtbl                        srvrVtbl;
extern IPersistStorageVtbl                      persistStorageVtbl;
extern IOleInPlaceObjectVtbl        ipVtbl;
extern IOleInPlaceActiveObjectVtbl      ipActiveVtbl;
extern IDataObjectVtbl         clipdragVtbl;
extern IDropSourceVtbl          dropsourceVtbl;
#ifdef LATER
extern IDropTargetVtbl          droptargetVtbl;
#endif

extern IPersistFileVtbl             persistFileVtbl;

/* Function Prototypes */

// Various functions

BOOL InitOLE (PBOOL pfInit, LPMALLOC *ppMalloc);
BOOL  CreateDocObjFromFile (LPCTSTR lpszDoc, LPDOC lpdoc);
BOOL  ReadObjFromFile(LPTSTR, LPDOC);
BOOL  InitNewDocObj (LPDOC lpdoc);
void  CutOrCopyObj (LPDOC lpobj);
void  DestroyDoc (LPDOC lpdoc);
void  DeviceToHiMetric (LPSIZEL lpsizel);
void  UpdateObject (void);
BOOL  InitServer (HWND hwnd, HANDLE hInst);
void  DestroyServer (LPSRVR lpsrvr);
BOOL  OpenDoc (UINT wid, LPTSTR lpsz);
BOOL  NewDoc (void);
SCODE SendDocMsg (LPDOC lpdoc, WORD wMessage);
BOOL  SetTitle (LPDOC lpdoc, LPCTSTR lpszDoc);
BOOL  ExitApplication ();
LPCLIPDRAGDATA  CreateClipDragDataObject ( LPDOC lpdoc, BOOL fClipData);
void SubClassMCIWindow(void);
void DoDrag(void);
void CleanUpDrag(void);
HANDLE  GetLink (VOID);
SCODE ItemSetData(LPBYTE);

STDMETHODIMP DoInPlaceEdit(LPDOC lpdoc, LPMSG lpmsg, LPOLECLIENTSITE pActiveSite, LONG verb, HWND FAR * lphwnd, LPRECT lprect);
void DoInPlaceDeactivate (LPDOC lpdoc);
STDMETHODIMP AssembleMenus (LPDOC lpdoc, BOOL fPlayOnly);
STDMETHODIMP DisassembleMenus (LPDOC lpdoc);

LPTSTR Abbrev (LPTSTR lpsz);

// Server methods
STDMETHODIMP  SrvrQueryInterface (LPCLASSFACTORY, REFIID, LPVOID    FAR  *);
STDMETHODIMP_(ULONG)    SrvrAddRef (LPCLASSFACTORY);
STDMETHODIMP_(ULONG)  SrvrRelease (LPCLASSFACTORY);
STDMETHODIMP  SrvrCreateInstance (LPCLASSFACTORY, LPUNKNOWN, REFIID, LPVOID FAR  *);
STDMETHODIMP  SrvrLockServer (LPCLASSFACTORY, BOOL);

STDMETHODIMP     UnkQueryInterface (LPUNKNOWN, REFIID, LPVOID FAR *);
STDMETHODIMP_(ULONG)     UnkAddRef (LPUNKNOWN);
STDMETHODIMP_(ULONG)     UnkRelease (LPUNKNOWN);

STDMETHODIMP     OleObjQueryInterface (LPOLEOBJECT, REFIID, LPVOID FAR *);
STDMETHODIMP_(ULONG)     OleObjAddRef (LPOLEOBJECT);
STDMETHODIMP_(ULONG)     OleObjRelease (LPOLEOBJECT);
STDMETHODIMP     OleObjSetClientSite (LPOLEOBJECT,  LPOLECLIENTSITE);
STDMETHODIMP     OleObjGetClientSite (LPOLEOBJECT,  LPOLECLIENTSITE FAR*);

STDMETHODIMP     OleObjSetHostNames (LPOLEOBJECT, LPCWSTR, LPCWSTR);
STDMETHODIMP     OleObjClose (LPOLEOBJECT, DWORD);
STDMETHODIMP     OleObjSetMoniker (LPOLEOBJECT, DWORD, LPMONIKER);
STDMETHODIMP     OleObjGetMoniker (LPOLEOBJECT, DWORD, DWORD, LPMONIKER FAR*);
STDMETHODIMP     OleObjInitFromData (LPOLEOBJECT, LPDATAOBJECT, BOOL, DWORD);
STDMETHODIMP     OleObjGetClipboardData (LPOLEOBJECT, DWORD, LPDATAOBJECT FAR*);
STDMETHODIMP     OleObjDoVerb (LPOLEOBJECT, LONG, LPMSG, LPOLECLIENTSITE, LONG, HWND, LPCRECT);

STDMETHODIMP     OleObjEnumVerbs(LPOLEOBJECT, IEnumOLEVERB FAR* FAR*);
STDMETHODIMP     OleObjUpdate(LPOLEOBJECT);
STDMETHODIMP     OleObjIsUpToDate(LPOLEOBJECT);
STDMETHODIMP     OleObjGetUserClassID (LPOLEOBJECT, CLSID FAR* pClsid);
STDMETHODIMP     OleObjGetUserType (LPOLEOBJECT, DWORD, LPWSTR FAR*);
STDMETHODIMP     OleObjSetExtent(LPOLEOBJECT, DWORD, LPSIZEL);
STDMETHODIMP     OleObjGetExtent(LPOLEOBJECT, DWORD, LPSIZEL);
STDMETHODIMP     OleObjAdvise(LPOLEOBJECT, LPADVISESINK, LPDWORD);
STDMETHODIMP     OleObjUnadvise(LPOLEOBJECT, DWORD);
STDMETHODIMP     OleObjEnumAdvise (LPOLEOBJECT, LPENUMSTATDATA FAR*);
STDMETHODIMP     OleObjGetMiscStatus (LPOLEOBJECT, DWORD, DWORD FAR*);
STDMETHODIMP     OleObjSetColorScheme (LPOLEOBJECT, LPLOGPALETTE);


STDMETHODIMP     DataObjQueryInterface (LPDATAOBJECT, REFIID, LPVOID FAR *);
STDMETHODIMP_(ULONG)     DataObjAddRef (LPDATAOBJECT);
STDMETHODIMP_(ULONG)     DataObjRelease (LPDATAOBJECT);
STDMETHODIMP     DataObjGetData (LPDATAOBJECT, LPFORMATETC, LPSTGMEDIUM);
STDMETHODIMP     DataObjGetDataHere (LPDATAOBJECT, LPFORMATETC, LPSTGMEDIUM);
STDMETHODIMP     DataObjQueryGetData (LPDATAOBJECT, LPFORMATETC);
STDMETHODIMP     DataObjGetCanonicalFormatEtc (LPDATAOBJECT, LPFORMATETC,
                            LPFORMATETC);
STDMETHODIMP     DataObjSetData (LPDATAOBJECT, LPFORMATETC, LPSTGMEDIUM, BOOL);
STDMETHODIMP     DataObjEnumFormatEtc (LPDATAOBJECT,  DWORD, LPENUMFORMATETC FAR*);
STDMETHODIMP     DataObjAdvise(LPDATAOBJECT, FORMATETC FAR*,
                            DWORD, IAdviseSink FAR*, DWORD FAR*);
STDMETHODIMP     DataObjUnadvise(LPDATAOBJECT, DWORD );
STDMETHODIMP     DataObjEnumAdvise(LPDATAOBJECT, LPENUMSTATDATA FAR*);


STDMETHODIMP     ClipDragEnumQueryInterface (LPENUMFORMATETC, REFIID, LPVOID FAR *);
STDMETHODIMP_(ULONG)     ClipDragEnumAddRef (LPENUMFORMATETC);
STDMETHODIMP_(ULONG)     ClipDragEnumRelease (LPENUMFORMATETC);
STDMETHODIMP     ClipDragEnumNext (LPENUMFORMATETC, ULONG, FORMATETC FAR[],
                                   ULONG FAR*);
STDMETHODIMP     ClipDragEnumSkip (LPENUMFORMATETC, ULONG);
STDMETHODIMP     ClipDragEnumReset (LPENUMFORMATETC);
STDMETHODIMP     ClipDragEnumClone (LPENUMFORMATETC, LPENUMFORMATETC FAR*);

STDMETHODIMP     ClipDragUnknownQueryInterface (LPCLIPDRAGDATA, REFIID, LPVOID FAR *);
STDMETHODIMP_(ULONG)     ClipDragUnknownAddRef (LPCLIPDRAGDATA);
STDMETHODIMP_(ULONG)     ClipDragUnknownRelease (LPCLIPDRAGDATA);

STDMETHODIMP     ClipDragQueryInterface (LPDATAOBJECT, REFIID, LPVOID FAR *);
STDMETHODIMP_(ULONG)     ClipDragAddRef (LPDATAOBJECT);
STDMETHODIMP_(ULONG)     ClipDragRelease (LPDATAOBJECT);
STDMETHODIMP     ClipDragGetData (LPDATAOBJECT, LPFORMATETC, LPSTGMEDIUM);
STDMETHODIMP     ClipDragGetDataHere (LPDATAOBJECT, LPFORMATETC, LPSTGMEDIUM);
STDMETHODIMP     ClipDragQueryGetData (LPDATAOBJECT, LPFORMATETC);
STDMETHODIMP     ClipDragGetCanonicalFormatEtc (LPDATAOBJECT,
                             LPFORMATETC, LPFORMATETC);
STDMETHODIMP     ClipDragSetData (LPDATAOBJECT,
                           LPFORMATETC, LPSTGMEDIUM, BOOL);
STDMETHODIMP     ClipDragEnumFormatEtc (LPDATAOBJECT,
                          DWORD, LPENUMFORMATETC FAR*);
STDMETHODIMP     ClipDragAdvise(LPDATAOBJECT, FORMATETC FAR*,
                      DWORD, IAdviseSink FAR*, DWORD FAR*);
STDMETHODIMP     ClipDragUnadvise(LPDATAOBJECT, DWORD );
STDMETHODIMP     ClipDragEnumAdvise(LPDATAOBJECT, LPENUMSTATDATA FAR*);

STDMETHODIMP     DropSourceQueryInterface (LPDROPSOURCE, REFIID, LPVOID FAR *);
STDMETHODIMP_(ULONG)     DropSourceAddRef (LPDROPSOURCE);
STDMETHODIMP_(ULONG)     DropSourceRelease (LPDROPSOURCE);
STDMETHODIMP     DropSourceQueryContinueDrag (LPDROPSOURCE, BOOL, DWORD );
STDMETHODIMP     DropSourceGiveFeedback (LPDROPSOURCE, DWORD );

STDMETHODIMP     PSQueryInterface (LPPERSISTSTORAGE, REFIID, LPVOID FAR *);
STDMETHODIMP_(ULONG)     PSAddRef (LPPERSISTSTORAGE);
STDMETHODIMP_(ULONG)     PSRelease (LPPERSISTSTORAGE);
STDMETHODIMP     PSGetClassID(LPPERSISTSTORAGE, CLSID FAR*);
STDMETHODIMP     PSIsDirty(LPPERSISTSTORAGE);
STDMETHODIMP     PSInitNew (LPPERSISTSTORAGE, LPSTORAGE);
STDMETHODIMP     PSLoad (LPPERSISTSTORAGE, LPSTORAGE);
STDMETHODIMP     PSSave (LPPERSISTSTORAGE, LPSTORAGE, BOOL);
STDMETHODIMP     PSSaveCompleted(LPPERSISTSTORAGE, LPSTORAGE );
STDMETHODIMP     PSHandsOffStorage(LPPERSISTSTORAGE);

STDMETHODIMP     IPObjQueryInterface (LPOLEINPLACEOBJECT,REFIID, LPVOID FAR*);
STDMETHODIMP_(ULONG)     IPObjAddRef (LPOLEINPLACEOBJECT);
STDMETHODIMP_(ULONG)     IPObjRelease (LPOLEINPLACEOBJECT);
STDMETHODIMP     IPObjGetWindow (LPOLEINPLACEOBJECT, HWND FAR*);
STDMETHODIMP     IPObjContextSensitiveHelp (LPOLEINPLACEOBJECT, BOOL);
STDMETHODIMP     IPObjInPlaceDeactivate (LPOLEINPLACEOBJECT);
STDMETHODIMP     IPObjUIDeactivate (LPOLEINPLACEOBJECT);
STDMETHODIMP     IPObjSetObjectRects (LPOLEINPLACEOBJECT, LPCRECT, LPCRECT);
STDMETHODIMP     IPObjReactivateAndUndo (LPOLEINPLACEOBJECT);

STDMETHODIMP     IPActiveQueryInterface (LPOLEINPLACEACTIVEOBJECT,REFIID, LPVOID FAR*);
STDMETHODIMP_(ULONG)     IPActiveAddRef (LPOLEINPLACEACTIVEOBJECT);
STDMETHODIMP_(ULONG)     IPActiveRelease (LPOLEINPLACEACTIVEOBJECT);
STDMETHODIMP     IPActiveGetWindow (LPOLEINPLACEACTIVEOBJECT, HWND FAR*);
STDMETHODIMP     IPActiveContextSensitiveHelp (LPOLEINPLACEACTIVEOBJECT, BOOL);
STDMETHODIMP     IPActiveTranslateAccelerator (LPOLEINPLACEACTIVEOBJECT, LPMSG);
STDMETHODIMP     IPActiveOnFrameWindowActivate (LPOLEINPLACEACTIVEOBJECT, BOOL);
STDMETHODIMP     IPActiveOnDocWindowActivate (LPOLEINPLACEACTIVEOBJECT, BOOL);
STDMETHODIMP     IPActiveResizeBorder (LPOLEINPLACEACTIVEOBJECT, LPCRECT, LPOLEINPLACEUIWINDOW,BOOL);
STDMETHODIMP     IPActiveEnableModeless (LPOLEINPLACEACTIVEOBJECT, BOOL);

STDMETHODIMP     PFQueryInterface (LPPERSISTFILE, REFIID, LPVOID FAR *);
STDMETHODIMP_(ULONG)     PFAddRef (LPPERSISTFILE);
STDMETHODIMP_(ULONG)     PFRelease (LPPERSISTFILE);
STDMETHODIMP     PFGetClassID(LPPERSISTFILE, CLSID FAR*);
STDMETHODIMP     PFIsDirty(LPPERSISTFILE);
STDMETHODIMP     PFLoad (LPPERSISTFILE, LPCWSTR, DWORD);
STDMETHODIMP     PFSave (LPPERSISTFILE, LPCWSTR, BOOL);
STDMETHODIMP     PFSaveCompleted(LPPERSISTFILE, LPCWSTR );
STDMETHODIMP     PFGetCurFile(LPPERSISTFILE, LPWSTR FAR*);


typedef enum
{
    OLE1_OLEOK,             /* 0   Function operated correctly         */

    OLE1_OLEWAIT_FOR_RELEASE,       /* 1   Command has been initiated, client      */
                /*     must wait for release. keep dispatching */
                /*     messages till OLE1_OLERELESE in callback    */

    OLE1_OLEBUSY,           /* 2   Tried to execute a method while another */
                /*     method is in progress.                  */

    OLE1_OLEERROR_PROTECT_ONLY,     /* 3   Ole APIs are called in real mode    */
    OLE1_OLEERROR_MEMORY,       /* 4   Could not alloc or lock memory      */
    OLE1_OLEERROR_STREAM,       /* 5  (OLESTREAM) stream error         */
    OLE1_OLEERROR_STATIC,       /* 6   Non static object expected          */
    OLE1_OLEERROR_BLANK,        /* 7   Critical data missing           */
    OLE1_OLEERROR_DRAW,         /* 8   Error while drawing             */
    OLE1_OLEERROR_METAFILE,     /* 9   Invalid metafile            */
    OLE1_OLEERROR_ABORT,        /* 10  Client chose to abort metafile drawing  */
    OLE1_OLEERROR_CLIPBOARD,        /* 11  Failed to get/set clipboard data    */
    OLE1_OLEERROR_FORMAT,       /* 12  Requested format is not available       */
    OLE1_OLEERROR_OBJECT,       /* 13  Not a valid object              */
    OLE1_OLEERROR_OPTION,       /* 14  Invalid option(link update / render)    */
    OLE1_OLEERROR_PROTOCOL,     /* 15  Invalid protocol            */
    OLE1_OLEERROR_ADDRESS,      /* 16  One of the pointers is invalid      */
    OLE1_OLEERROR_NOT_EQUAL,        /* 17  Objects are not equal           */
    OLE1_OLEERROR_HANDLE,       /* 18  Invalid handle encountered          */
    OLE1_OLEERROR_GENERIC,      /* 19  Some general error              */
    OLE1_OLEERROR_CLASS,        /* 20  Invalid class               */
    OLE1_OLEERROR_SYNTAX,       /* 21  Command syntax is invalid           */
    OLE1_OLEERROR_DATATYPE,     /* 22  Data format is not supported        */
    OLE1_OLEERROR_PALETTE,      /* 23  Invalid color palette           */
    OLE1_OLEERROR_NOT_LINK,     /* 24  Not a linked object             */
    OLE1_OLEERROR_NOT_EMPTY,        /* 25  Client doc contains objects.        */
    OLE1_OLEERROR_SIZE,         /* 26  Incorrect buffer size passed to the api */
                /*     that places some string in caller's     */
                /*     buffer                                  */

    OLE1_OLEERROR_DRIVE,        /* 27  Drive letter in doc name is invalid     */
    OLE1_OLEERROR_NETWORK,      /* 28  Failed to establish connection to a     */
                /*     network share on which the document     */
                /*     is located                              */

    OLE1_OLEERROR_NAME,         /* 29  Invalid name(doc name, object name),    */
                /*     etc.. passed to the APIs                */

    OLE1_OLEERROR_TEMPLATE,     /* 30  Server failed to load template      */
    OLE1_OLEERROR_NEW,          /* 31  Server failed to create new doc     */
    OLE1_OLEERROR_EDIT,         /* 32  Server failed to create embedded    */
                /*     instance                                */
    OLE1_OLEERROR_OPEN,         /* 33  Server failed to open document,     */
                /*     possible invalid link                   */

    OLE1_OLEERROR_NOT_OPEN,     /* 34  Object is not open for editing      */
    OLE1_OLEERROR_LAUNCH,       /* 35  Failed to launch server         */
    OLE1_OLEERROR_COMM,         /* 36  Failed to communicate with server       */
    OLE1_OLEERROR_TERMINATE,        /* 37  Error in termination            */
    OLE1_OLEERROR_COMMAND,      /* 38  Error in execute            */
    OLE1_OLEERROR_SHOW,         /* 39  Error in show               */
    OLE1_OLEERROR_DOVERB,       /* 40  Error in sending do verb, or invalid    */
                /*     verb                                    */
    OLE1_OLEERROR_ADVISE_NATIVE,    /* 41  Item could be missing           */
    OLE1_OLEERROR_ADVISE_PICT,      /* 42  Item could be missing or server doesn't */
                /*     this format.                            */

    OLE1_OLEERROR_ADVISE_RENAME,    /* 43  Server doesn't support rename           */
    OLE1_OLEERROR_POKE_NATIVE,      /* 44  Failure of poking native data to server */
    OLE1_OLEERROR_REQUEST_NATIVE,   /* 45  Server failed to render native data     */
    OLE1_OLEERROR_REQUEST_PICT,     /* 46  Server failed to render presentation    */
                /*     data                                    */
    OLE1_OLEERROR_SERVER_BLOCKED,   /* 47  Trying to block a blocked server or     */
                /*     trying to revoke a blocked server       */
                /*     or document                             */

    OLE1_OLEERROR_REGISTRATION,     /* 48  Server is not registered in regestation */
                /*     data base                               */
    OLE1_OLEERROR_ALREADY_REGISTERED,/*49  Trying to register same doc multiple    */
                 /*    times                                   */
    OLE1_OLEERROR_TASK,         /* 50  Server or client task is invalid    */
    OLE1_OLEERROR_OUTOFDATE,        /* 51  Object is out of date           */
    OLE1_OLEERROR_CANT_UPDATE_CLIENT,/* 52 Embed doc's client doesn't accept       */
                /*     updates                                 */
    OLE1_OLEERROR_UPDATE,       /* 53  erorr while trying to update        */
    OLE1_OLEERROR_SETDATA_FORMAT,   /* 54  Server app doesn't understand the       */
                /*     format given to its SetData method      */
    OLE1_OLEERROR_STATIC_FROM_OTHER_OS,/* 55 trying to load a static object created */
                   /*    on another Operating System           */

    /*  Following are warnings */
    OLE1_OLEWARN_DELETE_DATA = 1000 /*     Caller must delete the data when he is  */
                /*     done with it.                           */
} OLE1_OLESTATUS;


typedef OLE1_OLESTATUS (FAR PASCAL *OQOPROC)( LPVOID lpobj
                                       , HWND FAR* lphwnd
                                       , LPRECT lprc
                                       , LPRECT lprcWBounds
                                       );
OLE1_OLESTATUS (FAR PASCAL *OleQueryObjPos)(LPVOID lpobj, HWND FAR* lphwnd, LPRECT lprc, LPRECT lprcWBounds);

extern HMODULE hMciOle;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\nocrap.h ===
/*-----------------------------------------------------------------------------+
| NOCRAP.H                                                                     |
|                                                                              |
| (C) Copyright Microsoft Corporation 1992.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

//#define NOVIRTUALKEYCODES    // VK_*
//#define NOSYSMETRICS         // SM_*
#define NOICONS              // IDI_*
//#define NOSYSCOMMANDS        // SC_*
#define OEMRESOURCE          // OEM Resource values
#define NOATOM               // Atom Manager routines
//#define NOCLIPBOARD          // Clipboard routines
//#define NOCTLMGR             // Control and Dialog routines
#define NODRAWTEXT           // DrawText() and DT_*
//#define NOMETAFILE           // typedef METAFILEPICT
//#define NOMSG                // typedef MSG and associated routines
#define NOSOUND              // Sound driver routines
//#define NOWH                 // SetWindowsHook and WH_*
#define NOCOMM               // COMM driver routines
#define NOKANJI              // Kanji support stuff.
//#define NOHELP               // Help engine interface.
#define NOPROFILER           // Profiler interface.
//#define NODEFERWINDOWPOS     // DeferWindowPos routines

//#define NOWIN31              // New Windows 3.1 APIs
#define NOGDICAPMASKS        // CC_*, LC_*, PC_*, CP_*, TC_*, RC_
//#define NOWINMESSAGES        // WM_*, EM_*, LB_*, CB_*
//#define NOWINSTYLES          // WS_*, CS_*, ES_*, LBS_*, SBS_*, CBS_*
//#define NOMENUS              // MF_*
//#define NORASTEROPS          // Binary and Tertiary raster ops
//#define NOSHOWWINDOW         // SW_*
//#define NOCOLOR              // Screen colors
//#define NOGDI                // All GDI defines and routines
//#define NOKERNEL             // All KERNEL defines and routines
//#define NOUSER               // All USER defines and routines
//#define NOMB                 // MB_* and MessageBox()
//#define NOMEMMGR             // GMEM_*, LMEM_*, GHND, LHND, associated routines
//#define NOMINMAX             // Macros min(a,b) and max(a,b)
#define NOOPENFILE           // OpenFile(), OemToAnsi, AnsiToOem, and OF_*
//#define NOSCROLL             // SB_* and scrolling routines
//#define NOWINOFFSETS         // GWL_*, GCL_*, associated routines
//#define NODRIVERS            // Installable driver defines
//#define NODBCS               // DBCS support stuff.
#define NOSYSTEMPARAMSINFO   // SystemParameterInfo (SPI_*)
#define NOSCALABLEFONT       // Scalable font prototypes and data structures
//#define NOGDIOBJ             // GDI objects including pens, brushes and logfonts.
//#define NOBITMAP             // GDI bitmaps
#define NOLFILEIO            // _l* file I/O
#define NOLOGERROR           // LogError() and related definitions
#define NOPROFILER           // Profiler APIs


#define MMNOSOUND            // Sound support
//#define MMNOWAVE             // Waveform support
#define MMNOMIDI             // MIDI support
#define MMNOAUX              // Auxiliary output support
#define MMNOTIMER            // Timer support
#define MMNOJOY              // Joystick support
//#define MMNOMCI              // MCI support
//#define MMNODRV              // Installable driver support
//#define MMNOMMIO             // MMIO library support
//#define MMNOMMSYSTEM         // No mmsystem general functions

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\objfdbk.c ===
/*
 * OBJFDBK.C
 *
 * Miscellaneous API's to generate UI feedback effects for OLE objects. This
 * is part of the OLE 2.0 User Interface Support Library.
 * The following feedback effects are supported:
 *      1. Object selection handles (OleUIDrawHandles)
 *      2. Open Object window shading (OleUIDrawShading)
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#define STRICT  1
#include <windows.h>
#ifdef MTN
#pragma warning(disable: 4103)  // used #pragma pack to change alignment (on Chicago)
#endif
#include <ole2.h>
#include "ole2ui.h"

static void DrawHandle(HDC hdc, int x, int y, UINT cSize, BOOL bInvert, BOOL fDraw);

/*
 * OleUIDrawHandles
 *
 * Purpose:
 *  Draw handles or/and boundary around Container Object when selected
 *
 * Parameters:
 *  lpRect      Dimensions of Container Object
 *  hdc         HDC of Container Object (MM_TEXT mapping mode)
 *  dwFlags-
 *      Exclusive flags
 *          OLEUI_HANDLES_INSIDE    Draw handles on inside of rect
 *          OLEUI_HANDLES_OUTSIDE   Draw handles on outside of rect
 *      Optional flags
 *          OLEUI_HANDLES_NOBORDER  Draw handles only, no rect
 *          OLEUI_HANDLES_USEINVERSE
 *              use invert for handles and rect, o.t. use COLOR_WINDOWTEXT
 *  cSize       size of handle box
 *  fDraw       Draw if TRUE, erase if FALSE
 *
 * Return Value: null
 *
 */
STDAPI_(void) OleUIDrawHandles(
    LPRECT  lpRect,
    HDC     hdc,
    DWORD   dwFlags,
    UINT    cSize,
    BOOL    fDraw
)
{
    HBRUSH  hbr;
    RECT    rc;
    int     bkmodeOld;
    BOOL    bInvert = (BOOL) (dwFlags & OLEUI_HANDLES_USEINVERSE);

    CopyRect((LPRECT)&rc, lpRect);

    bkmodeOld = SetBkMode(hdc, TRANSPARENT);

    if (dwFlags & OLEUI_HANDLES_OUTSIDE)
        InflateRect((LPRECT)&rc, cSize - 1, cSize - 1);

    // Draw the handles inside the rectangle boundary
    DrawHandle(hdc, rc.left, rc.top, cSize, bInvert, fDraw);
    DrawHandle(hdc, rc.left, rc.top+(rc.bottom-rc.top-cSize)/2, cSize, bInvert, fDraw);
    DrawHandle(hdc, rc.left, rc.bottom-cSize, cSize, bInvert, fDraw);
    DrawHandle(hdc, rc.left+(rc.right-rc.left-cSize)/2, rc.top, cSize, bInvert, fDraw);
    DrawHandle(hdc, rc.left+(rc.right-rc.left-cSize)/2, rc.bottom-cSize, cSize, bInvert, fDraw);
    DrawHandle(hdc, rc.right-cSize, rc.top, cSize, bInvert, fDraw);
    DrawHandle(hdc, rc.right-cSize, rc.top+(rc.bottom-rc.top-cSize)/2, cSize, bInvert, fDraw);
    DrawHandle(hdc, rc.right-cSize, rc.bottom-cSize, cSize, bInvert, fDraw);

    if (!(dwFlags & OLEUI_HANDLES_NOBORDER)) {
        if (fDraw)
            hbr = GetStockObject(BLACK_BRUSH);
        else
            hbr = GetStockObject(WHITE_BRUSH);

        if (hbr)
            FrameRect(hdc, lpRect, hbr);
    }

    SetBkMode(hdc, bkmodeOld);
}



/*
 * DrawHandle
 *
 * Purpose:
 *  Draw a handle box at the specified coordinate
 *
 * Parameters:
 *  hdc         HDC to be drawn into
 *  x, y        upper left corner coordinate of the handle box
 *  cSize       size of handle box
 *  bInvert     use InvertRect() if TRUE, otherwise use Rectangle()
 *  fDraw       Draw if TRUE, erase if FALSE, ignored if bInvert is TRUE
 *
 * Return Value: null
 *
 */
static void DrawHandle(HDC hdc, int x, int y, UINT cSize, BOOL bInvert, BOOL fDraw)
{
    HBRUSH  hbr;
    HBRUSH  hbrOld;
    HPEN    hpen;
    HPEN    hpenOld;
    RECT    rc;


    if (!bInvert) {
        if (fDraw) {
            hpen = GetStockObject(BLACK_PEN);
            hbr = GetStockObject(BLACK_BRUSH);
        } else {
            hpen = GetStockObject(WHITE_PEN);
            hbr = GetStockObject(WHITE_PEN);
        }

        hpenOld = SelectObject(hdc, hpen);
        hbrOld = SelectObject(hdc, hbr);
        Rectangle(hdc, x, y, x+cSize, y+cSize);
        SelectObject(hdc, hpenOld);
        SelectObject(hdc, hbrOld);
    }
    else {
        rc.left = x;
        rc.top = y;
        rc.right = x + cSize;
        rc.bottom = y + cSize;
        InvertRect(hdc, (LPRECT)&rc);
    }
}


/*
 * OleUIDrawShading
 *
 * Purpose:
 *  Shade the object when it is in in-place editing. Borders are drawn
 *  on the Object rectangle. The right and bottom edge of the rectangle
 *  are excluded in the drawing.
 *
 * Parameters:
 *  lpRect      Dimensions of Container Object
 *  hdc         HDC for drawing
 *  dwFlags-
 *      Exclusive flags
 *          OLEUI_SHADE_FULLRECT    Shade the whole rectangle
 *          OLEUI_SHADE_BORDERIN    Shade cWidth pixels inside rect
 *          OLEUI_SHADE_BORDEROUT   Shade cWidth pixels outside rect
 *      Optional flags
 *          OLEUI_SHADE_USEINVERSE
 *              use PATINVERT instead of the hex value
 *  cWidth      width of border in pixel
 *
 * Return Value: null
 *
 */
STDAPI_(void) OleUIDrawShading(LPRECT lpRect, HDC hdc, DWORD dwFlags, UINT cWidth)
{
    HBRUSH  hbr;
    HBRUSH  hbrOld;
    HBITMAP hbm;
    RECT    rc;
    WORD    wHatchBmp[] = {0x11, 0x22, 0x44, 0x88, 0x11, 0x22, 0x44, 0x88};
    COLORREF cvText;
    COLORREF cvBk;

    hbm = CreateBitmap(8, 8, 1, 1, wHatchBmp);
    hbr = CreatePatternBrush(hbm);
    hbrOld = SelectObject(hdc, hbr);

    rc = *lpRect;

    if (dwFlags == OLEUI_SHADE_FULLRECT) {
        cvText = SetTextColor(hdc, RGB(255, 255, 255));
        cvBk = SetBkColor(hdc, RGB(0, 0, 0));
        PatBlt(hdc, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top,
            0x00A000C9L /* DPa */ );

    } else {    // either inside or outside rect

        if (dwFlags == OLEUI_SHADE_BORDEROUT)
            InflateRect((LPRECT)&rc, cWidth - 1, cWidth - 1);

        cvText = SetTextColor(hdc, RGB(255, 255, 255));
        cvBk = SetBkColor(hdc, RGB(0, 0, 0));
        PatBlt(hdc, rc.left, rc.top, rc.right - rc.left,
            cWidth, 0x00A000C9L /* DPa */);
        PatBlt(hdc, rc.left, rc.top, cWidth, rc.bottom - rc.top,
            0x00A000C9L /* DPa */);
        PatBlt(hdc, rc.right - cWidth, rc.top, cWidth,
            rc.bottom - rc.top, 0x00A000C9L /* DPa */);
        PatBlt(hdc, rc.left, rc.bottom - cWidth, rc.right-rc.left,
            cWidth, 0x00A000C9L /* DPa */);
    }

    SetTextColor(hdc, cvText);
    SetBkColor(hdc, cvBk);
    SelectObject(hdc, hbrOld);
    if (hbr)
        DeleteObject(hbr);
    if (hbm)
        DeleteObject(hbm);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\obj.c ===
/*---------------------------------------------------------------------------
|   OBJ.C
|   This file has the IUnknown, IOleObject, IStdMarshalInfo and IDataObject
|   interfaces of the  OLE2 object (docMain). it also has other helper functions
|
|   Created By: Vij Rajarajan (VijR)
+---------------------------------------------------------------------------*/
#define SERVERONLY
#include <Windows.h>
#include <shellapi.h>

#include "mpole.h"
#include "mplayer.h"

extern int FAR PASCAL  ReallyDoVerb (LPDOC, LONG, LPMSG, LPOLECLIENTSITE,
                     BOOL, BOOL);
extern BOOL FindRealFileName(LPTSTR szFile, int iLen);

// static functions.
HANDLE  PASCAL GetDib (VOID);

HANDLE  GetMetafilePict (VOID);
HANDLE  GetMPlayerIcon(void);

extern void FAR PASCAL SetEmbeddedObjectFlag(BOOL flag);
extern HPALETTE CopyPalette(HPALETTE hpal);
extern HBITMAP FAR PASCAL BitmapMCI(void);
extern HPALETTE FAR PASCAL PaletteMCI(void);
extern void DoInPlaceDeactivate(LPDOC lpdoc);
HANDLE FAR PASCAL PictureFromDib(HANDLE hdib, HPALETTE hpal);
HANDLE FAR PASCAL DibFromBitmap(HBITMAP hbm, HPALETTE hpal);
void FAR PASCAL DitherMCI(HANDLE hdib, HPALETTE hpal);



/* GetMetafilePict
 * ---------------
 *
 * RETURNS: A handle to the object's data in metafile format.
 */
HANDLE GetMetafilePict ( )
{

    HPALETTE hpal;
    HANDLE   hdib;
    HANDLE   hmfp;
    HDC      hdc;

    DPF("GetMetafilePict called on thread %d\n", GetCurrentThreadId());

    hdib = (HANDLE)SendMessage(ghwndApp, WM_GETDIB, 0, 0);

    /* If we're dithered, don't use a palette */
    hdc = GetDC(NULL);
    if ((GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
        && (gwOptions & OPT_DITHER))
        hpal = NULL;
    else
        hpal = PaletteMCI();

    if (hpal)
        hpal = CopyPalette(hpal);

    ReleaseDC(NULL, hdc);

    hmfp = PictureFromDib(hdib, hpal);

    if (hpal)
        DeleteObject(hpal);

    GLOBALFREE(hdib);

    return hmfp;
}


/**************************************************************************
//## Somebody wants a dib (OLE)
***************************************************************************/
HANDLE PASCAL GetDib( VOID )
{
    HBITMAP  hbm;
    HPALETTE hpal;
    HANDLE   hdib;
    HDC      hdc;

    DPF("GetDib\n");

    hbm  = BitmapMCI();
    hpal = PaletteMCI();

    hdib = DibFromBitmap(hbm, hpal);

    //
    //  if we are on a palette device. possibly dither to the VGA colors
    //  for apps that dont deal with palettes!
    //
    hdc = GetDC(NULL);
    if ((GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) &&
                       (gwOptions & OPT_DITHER))
    {
        DitherMCI(hdib, hpal);
        hpal = NULL;            // no longer working with a palette
    }
    ReleaseDC(NULL, hdc);

    if (hbm)
        DeleteObject(hbm);
    return hdib;
}


/**************************************************************************
* GetMPlayerIcon: This function extracts the our Icon and gives it out
* as a Metafile incase the client wants DVASPECT_ICON
***************************************************************************/
HANDLE GetMPlayerIcon (void)
{
    HICON           hicon;
    HDC             hdc;
    HANDLE          hmfp = NULL;
    LPMETAFILEPICT  pmfp=NULL;
    static int      cxIcon = 0;
    static int      cyIcon = 0;
    static int      cxIconHiMetric = 0;
    static int      cyIconHiMetric = 0;

    hicon = GetIconForCurrentDevice(GI_LARGE, IDI_DDEFAULT);

    if ((HICON)1==hicon || NULL==hicon)
        return NULL;

    if (!(hmfp = GlobalAlloc (GMEM_DDESHARE | GMEM_MOVEABLE,
                    sizeof(METAFILEPICT))))
        return NULL;

    pmfp = (METAFILEPICT FAR*) GLOBALLOCK (hmfp);

    if (0==cxIcon)
    {
        // In units of pixels
        cxIcon = GetSystemMetrics (SM_CXICON);
        cyIcon = GetSystemMetrics (SM_CYICON);

        // In units of .01 millimeter
        cxIconHiMetric = cxIcon * HIMETRIC_PER_INCH / giXppli;
        cyIconHiMetric = cyIcon * HIMETRIC_PER_INCH / giYppli;;
    }

    pmfp->mm   = MM_ANISOTROPIC;
    pmfp->xExt = cxIconHiMetric;
    pmfp->yExt = cyIconHiMetric;
    hdc = CreateMetaFile (NULL);

    SetWindowOrgEx (hdc, 0, 0, NULL);
    SetWindowExtEx (hdc, cxIcon, cyIcon, NULL);

    DrawIcon (hdc, 0, 0, hicon);
    pmfp->hMF = CloseMetaFile (hdc);

    GLOBALUNLOCK (hmfp);

    if (NULL == pmfp->hMF) {
        GLOBALFREE (hmfp);
        return NULL;
    }

    return hmfp;
}


#ifdef DEBUG

#define DBG_CHECK_GUID(guid)            \
        if (IsEqualIID(&guid, riidReq))  \
            return #guid

LPSTR DbgGetIIDString(REFIID riidReq)
{
    static CHAR UnknownIID[64];

    DBG_CHECK_GUID(IID_IUnknown);
    DBG_CHECK_GUID(IID_IClassFactory);
    DBG_CHECK_GUID(IID_IMalloc);
    DBG_CHECK_GUID(IID_IMarshal);
    DBG_CHECK_GUID(IID_IRpcChannel);
    DBG_CHECK_GUID(IID_IRpcStub);
    DBG_CHECK_GUID(IID_IStubManager);
    DBG_CHECK_GUID(IID_IRpcProxy);
    DBG_CHECK_GUID(IID_IProxyManager);
    DBG_CHECK_GUID(IID_IPSFactory);
    DBG_CHECK_GUID(IID_ILockBytes);
    DBG_CHECK_GUID(IID_IStorage);
    DBG_CHECK_GUID(IID_IStream);
    DBG_CHECK_GUID(IID_IEnumSTATSTG);
    DBG_CHECK_GUID(IID_IBindCtx);
    DBG_CHECK_GUID(IID_IMoniker);
    DBG_CHECK_GUID(IID_IRunningObjectTable);
    DBG_CHECK_GUID(IID_IInternalMoniker);
    DBG_CHECK_GUID(IID_IRootStorage);
    DBG_CHECK_GUID(IID_IDfReserved1);
    DBG_CHECK_GUID(IID_IDfReserved2);
    DBG_CHECK_GUID(IID_IDfReserved3);
    DBG_CHECK_GUID(IID_IMessageFilter);
    DBG_CHECK_GUID(CLSID_StdMarshal);
    DBG_CHECK_GUID(IID_IStdMarshalInfo);
    DBG_CHECK_GUID(IID_IExternalConnection);
    DBG_CHECK_GUID(IID_IEnumUnknown);
    DBG_CHECK_GUID(IID_IEnumString);
    DBG_CHECK_GUID(IID_IEnumMoniker);
    DBG_CHECK_GUID(IID_IEnumFORMATETC);
    DBG_CHECK_GUID(IID_IEnumOLEVERB);
    DBG_CHECK_GUID(IID_IEnumSTATDATA);
    DBG_CHECK_GUID(IID_IEnumGeneric);
    DBG_CHECK_GUID(IID_IEnumHolder);
    DBG_CHECK_GUID(IID_IEnumCallback);
    DBG_CHECK_GUID(IID_IPersistStream);
    DBG_CHECK_GUID(IID_IPersistStorage);
    DBG_CHECK_GUID(IID_IPersistFile);
    DBG_CHECK_GUID(IID_IPersist);
    DBG_CHECK_GUID(IID_IViewObject);
    DBG_CHECK_GUID(IID_IDataObject);
    DBG_CHECK_GUID(IID_IAdviseSink);
    DBG_CHECK_GUID(IID_IDataAdviseHolder);
    DBG_CHECK_GUID(IID_IOleAdviseHolder);
    DBG_CHECK_GUID(IID_IOleObject);
    DBG_CHECK_GUID(IID_IOleInPlaceObject);
    DBG_CHECK_GUID(IID_IOleWindow);
    DBG_CHECK_GUID(IID_IOleInPlaceUIWindow);
    DBG_CHECK_GUID(IID_IOleInPlaceFrame);
    DBG_CHECK_GUID(IID_IOleInPlaceActiveObject);
    DBG_CHECK_GUID(IID_IOleClientSite);
    DBG_CHECK_GUID(IID_IOleInPlaceSite);
    DBG_CHECK_GUID(IID_IParseDisplayName);
    DBG_CHECK_GUID(IID_IOleContainer);
    DBG_CHECK_GUID(IID_IOleItemContainer);
    DBG_CHECK_GUID(IID_IOleLink);
    DBG_CHECK_GUID(IID_IOleCache);
    DBG_CHECK_GUID(IID_IOleManager);
    DBG_CHECK_GUID(IID_IOlePresObj);
    DBG_CHECK_GUID(IID_IDropSource);
    DBG_CHECK_GUID(IID_IDropTarget);
    DBG_CHECK_GUID(IID_IDebug);
    DBG_CHECK_GUID(IID_IDebugStream);
    DBG_CHECK_GUID(IID_IAdviseSink2);
    DBG_CHECK_GUID(IID_IRunnableObject);
    DBG_CHECK_GUID(IID_IViewObject2);
    DBG_CHECK_GUID(IID_IOleCache2);
    DBG_CHECK_GUID(IID_IOleCacheControl);

    wsprintfA(UnknownIID, "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
              riidReq->Data1, riidReq->Data2, riidReq->Data3,
              riidReq->Data4[0], riidReq->Data4[1],
              riidReq->Data4[2], riidReq->Data4[3],
              riidReq->Data4[4], riidReq->Data4[5],
              riidReq->Data4[6], riidReq->Data4[7]);

    return UnknownIID;
}

#endif


/**************************************************************************
*****************   IUnknown INTERFACE IMPLEMENTATION.
**************************************************************************/

STDMETHODIMP UnkQueryInterface(
LPUNKNOWN         lpUnkObj,       // Unknown object ptr
REFIID            riidReq,        // IID required
LPVOID FAR *      lplpUnk         // pre for returning the interface
)
{
    LPDOC       lpdoc;

    lpdoc = ((struct COleObjectImpl FAR*)lpUnkObj)->lpdoc;

    DPF1("QueryInterface( %s )\n", DbgGetIIDString(riidReq));

    if (IsEqualIID(riidReq, &IID_IOleObject)) {
        *lplpUnk = (LPVOID) &lpdoc->m_Ole;
        lpdoc->cRef++;
        return NOERROR;

    } else if (IsEqualIID(riidReq, &IID_IDataObject)) {
        *lplpUnk = (LPVOID) &lpdoc->m_Data;
        lpdoc->cRef++;
        return NOERROR;

    } else if (IsEqualIID(riidReq, &IID_IUnknown)) {
        *lplpUnk = (LPVOID) &lpdoc->m_Ole;
        lpdoc->cRef++;
        return NOERROR;

    } else if (IsEqualIID(riidReq, &IID_IPersist) || IsEqualIID(riidReq, &IID_IPersistStorage)) {
        *lplpUnk = (LPVOID) &lpdoc->m_PersistStorage;
        lpdoc->cRef++;
        return NOERROR;

    } else if (IsEqualIID(riidReq, &IID_IPersistFile)) {
        *lplpUnk = (LPVOID) &lpdoc->m_PersistFile;
        lpdoc->cRef++;
        return NOERROR;

    } else if (IsEqualIID(riidReq, &IID_IOleWindow) || IsEqualIID(riidReq, &IID_IOleInPlaceObject)) {
        *lplpUnk = (LPVOID) &lpdoc->m_InPlace;
        lpdoc->cRef++;
        return NOERROR;

    } else if (IsEqualIID(riidReq, &IID_IOleInPlaceActiveObject)) {
        *lplpUnk = (LPVOID) &lpdoc->m_IPActive;
        lpdoc->cRef++;
        return NOERROR;

    } else {
        *lplpUnk = (LPVOID) NULL;
        DPF1("E_NOINTERFACE\n");
        RETURN_RESULT(E_NOINTERFACE);
    }
}

STDMETHODIMP_(ULONG) UnkAddRef(LPUNKNOWN    lpUnkObj)
{
    LPDOC   lpdoc;

    lpdoc = ((struct COleObjectImpl FAR*)lpUnkObj)->lpdoc;
    return ++lpdoc->cRef;
}

STDMETHODIMP_(ULONG) UnkRelease (LPUNKNOWN lpUnkObj)
{
    LPDOC   lpdoc;

    lpdoc = ((struct COleObjectImpl FAR*)lpUnkObj)->lpdoc;
    if (--lpdoc->cRef == 0)
    {
        DPF1("\n**^*^*^*^*^*^*^*^*^*^*^*^*Refcnt OK\n");
        if (!(gfOle2IPPlaying || gfOle2IPEditing) && srvrMain.cLock == 0)
            PostCloseMessage();
        return 0;
    }

    return lpdoc->cRef;
}

/**************************************************************************
*************   IOleObject INTERFACE IMPLEMENTATION
**************************************************************************/

//delegate to the common IUnknown Implemenation.
STDMETHODIMP OleObjQueryInterface(
LPOLEOBJECT   lpOleObj,      // ole object ptr
REFIID            riidReq,        // IID required
LPVOID FAR *      lplpUnk         // pre for returning the interface
)
{
    return( UnkQueryInterface((LPUNKNOWN)lpOleObj, riidReq, lplpUnk));
}


STDMETHODIMP_(ULONG) OleObjAddRef(
LPOLEOBJECT   lpOleObj      // ole object ptr
)
{
    return UnkAddRef((LPUNKNOWN) lpOleObj);
}


STDMETHODIMP_(ULONG) OleObjRelease (
LPOLEOBJECT   lpOleObj      // ole object ptr
)
{
    LPDOC    lpdoc;

    lpdoc = ((struct COleObjectImpl FAR*)lpOleObj)->lpdoc;

    return UnkRelease((LPUNKNOWN) lpOleObj);
}

//Save the Client site pointer.
STDMETHODIMP OleObjSetClientSite(
LPOLEOBJECT         lpOleObj,
LPOLECLIENTSITE     lpclientSite
)
{
    LPDOC   lpdoc;

    DPF("OleObjSetClientSite\n");

    lpdoc = ((struct COleObjectImpl FAR*)lpOleObj)->lpdoc;

    if (lpdoc->lpoleclient)
        IOleClientSite_Release(lpdoc->lpoleclient);

    lpdoc->lpoleclient = (LPOLECLIENTSITE) lpclientSite;

    // OLE2NOTE: to be able to hold onto clientSite pointer, we must AddRef it
    if (lpclientSite)
        IOleClientSite_AddRef(lpclientSite);

    return NOERROR;
}

STDMETHODIMP OleObjGetClientSite (
LPOLEOBJECT             lpOleObj,
LPOLECLIENTSITE FAR*    lplpclientSite
)
{
    DPF("OleObjGetClientSite\n");

    return NOERROR;
}


/* CheckIfInPPViewer
 *
 * Hack to stop PowerPoint viewer from crashing when we're trying to play in place.
 *
 * PP Viewer was written under the assumption that Media Player was not a full-blown
 * OLE2 server.  Much of the code was stubbed out to make the Viewer small.
 * Unfortunately this means it crashes when certain calls are made for in-place
 * activation.  These are the problem interface methods:
 *
 * OnInPlaceActivate/Deactivate
 * OnUIActivate/Deactivate
 * OnPosRectChange
 *
 * If we're in PP Viewer we simply do not make these calls.
 *
 * We detect that we're in PP Viewer by finding the parent of the window whose
 * handle is passed to DoVerb.  The window handle passed in to DoVerb is of
 * "ppSlideShowWin" class, which is the same as in PP Slide Show, which works
 * correctly.  However its parent's class is "PP4VDialog" (as distinct from
 * "PPApplicationClass").  So, if we find this class name, set a global flag
 * to test before making the troublesome calls.
 *
 * Andrew Bell (andrewbe) 11 May 1995
 *
 */
STATICFN void CheckIfInPPViewer(HWND hwndParent)
{
    HWND  hwndGrandParent;
    TCHAR ClassName[256];

    gfInPPViewer = FALSE;

    if (hwndParent)
    {
        hwndGrandParent = GetParent(hwndParent);

        if (hwndGrandParent)
        {
            if (GetClassName(hwndGrandParent, ClassName, CHAR_COUNT(ClassName)) > 0)
            {
                if (lstrcmp(ClassName, TEXT("PP4VDialog")) == 0)
                {
                    DPF0("Detected that we're in PP Viewer\n");
                    gfInPPViewer = TRUE;
                }
            }
        }
    }
}

//delegate to ReallyDoVerb.
STDMETHODIMP OleObjDoVerb(
LPOLEOBJECT             lpOleObj,
LONG                    lVerb,
LPMSG                   lpmsg,
LPOLECLIENTSITE         pActiveSite,
LONG                    lindex,
HWND            hwndParent,
LPCRECT         lprcPosRect
)
{
     LPDOC  lpdoc = ((struct COleObjectImpl FAR*)lpOleObj)->lpdoc;

     DPF("OleObjDoVerb\n");

     CheckIfInPPViewer(hwndParent);

     RETURN_RESULT( ReallyDoVerb(lpdoc, lVerb, lpmsg, pActiveSite, TRUE, TRUE));
}



STDMETHODIMP     OleObjEnumVerbs(
LPOLEOBJECT             lpOleObj,
IEnumOLEVERB FAR* FAR*  lplpenumOleVerb )
{
    DPF("OleObjEnumVerbs\n");

    *lplpenumOleVerb = NULL;
    RETURN_RESULT( OLE_S_USEREG); //Use the reg db.
}


STDMETHODIMP     OleObjUpdate(LPOLEOBJECT lpOleObj)
{
    DPF("OleObjUpdate\n");

    // we can't contain links so there is nothing to update
    return NOERROR;
}



STDMETHODIMP     OleObjIsUpToDate(LPOLEOBJECT lpOleObj)
{
    DPF("OleObjIsUpToDate\n");

    // we can't contain links so there is nothing to update
    return NOERROR;
}



/*
From OLE2HELP.HLP:

GetUserClassID returns the CLSID as the user knows it. For embedded objects,
this is always the CLSID that is persistently stored and is returned by
IPersist::GetClassID. For linked objects, this is the CLSID of the last
bound link source. If a Treat As operation is taking place, this is the CLSID
of the application being emulated (also the CLSID that will be written into storage).

I can't follow the logic here.  What if it's an embedded object and a Treat As
operation?  However, AlexGo tells me that my IOleObject interfaces should return
the OLE2 Class ID.
*/
STDMETHODIMP OleObjGetUserClassID
    (LPOLEOBJECT lpOleObj,
    CLSID FAR*      pClsid)
{
    DPF1("OleObjGetUserClassID\n");

    *pClsid = gClsID;

    return NOERROR;
}



/**************************************************************************
*   Set our UserTypeName to "Media Clip"
**************************************************************************/

STDMETHODIMP OleObjGetUserType
    (LPOLEOBJECT lpOleObj,
    DWORD dwFormOfType,
    LPWSTR FAR* pszUserType)
{
    LPMALLOC lpMalloc;
    LPWSTR lpstr;
    int clen;

    DPF1("OleObjGetUserType\n");

    *pszUserType = NULL;
    if(CoGetMalloc(MEMCTX_TASK,&lpMalloc) != 0)
        RETURN_RESULT(E_OUTOFMEMORY);
    clen = STRING_BYTE_COUNT(gachClassRoot);
#ifndef UNICODE
    clen *= (sizeof(WCHAR) / sizeof(CHAR));
#endif
    lpstr = IMalloc_Alloc(lpMalloc, clen);
    IMalloc_Release(lpMalloc);
#ifdef UNICODE
    lstrcpy(lpstr,gachClassRoot);
#else
    AnsiToUnicodeString(gachClassRoot, lpstr, -1);
#endif /* UNICODE */
    *pszUserType = lpstr;
    return NOERROR;
}

/**************************************************************************
*   Get the name of the client and set the title.
**************************************************************************/
STDMETHODIMP OleObjSetHostNames (
LPOLEOBJECT             lpOleObj,
LPCWSTR                 lpszClientAppW,
LPCWSTR                 lpszClientObjW
)
{
    LPDOC    lpdoc;
    LPTSTR   lpszClientApp;
    LPTSTR   lpszClientObj;

    DPF1("OleObjSetHostNames\n");

#ifdef UNICODE
    lpszClientApp = (LPTSTR)lpszClientAppW;
    lpszClientObj = (LPTSTR)lpszClientObjW;
#else
    lpszClientApp = AllocateAnsiString(lpszClientAppW);
    lpszClientObj = AllocateAnsiString(lpszClientObjW);
    if( !lpszClientApp || !lpszClientObj )
        RETURN_RESULT(E_OUTOFMEMORY);
#endif /* UNICODE */

    lpdoc = ((struct COleObjectImpl FAR*)lpOleObj)->lpdoc;

    // object is embedded.
    lpdoc->doctype = doctypeEmbedded;

    if (lpszClientObj == NULL)
        lpszClientObj = lpszClientApp;

    SetTitle(lpdoc, lpszClientObj);
    SetMPlayerIcon();
    lstrcpy (szClient, lpszClientApp);
    if (lpszClientObj)
    {
        LPTSTR lpszFileName = FileName(lpszClientObj);
        if (lpszFileName)
            lstrcpy (szClientDoc, lpszFileName);
    }

    // this is the only time we know the object will be an embedding
    SetEmbeddedObjectFlag(TRUE);

#ifndef UNICODE
    FreeAnsiString(lpszClientApp);
    FreeAnsiString(lpszClientObj);
#endif /* NOT UNICODE */

    return NOERROR;
}


/**************************************************************************
*   The client closed the object. The server will now shut down.
**************************************************************************/
STDMETHODIMP OleObjClose (
LPOLEOBJECT             lpOleObj,
DWORD           dwSaveOptions
)
{
    LPDOC   lpdoc;

    DPF1("OleObjClose\n");

    lpdoc = ((struct COleObjectImpl FAR*)lpOleObj)->lpdoc;

    /* Hack to stop PowerPoint crashing:
     *
     * Win95 bug #19848: Crash saving PowerPoint with out-of-place mplayer
     *
     * If we don't call IOleClientSite::SaveObject() at this point,
     * PowerPoint will crash under certain circumstances.
     *
     * This is an extract from mail I received from TuanN, the PPT dev:
     *
     * The fundamental problem is that PP expects to receive the
     * IAdviseSink::SaveObject() as a result of calling IOleObject::Close().
     * Since the Media Player did not send that notficiation in this test case,
     * PP tries to perform an Undo operation during the ensuing OnClose()
     * notification and thus erroneously destroys the embedded object.
     * The reason we throw away the object is because PP thinks that this
     * object is still virgin (no OnViewChange). Please refer to SaveObject(),
     * OnClose() in CtCommon.cpp and slide\sextern.c for more info. In the test
     * case, during OnClose(), the "revert" state is TRUE, PP will do a
     * Ex_REVERTED operation (stack calls: SClosePicts, SClear,
     * SSaveforUndo--> object deleted).
     *
     * AndrewBe, 6 December 1994
     */
    if (lpdoc->lpoleclient)
        IOleClientSite_SaveObject(lpdoc->lpoleclient);

    DoInPlaceDeactivate(lpdoc);
    SendDocMsg(lpdoc,OLE_CLOSED);
    DestroyDoc(lpdoc);
    ExitApplication();
    //CoDisconnectObject((LPUNKNOWN)lpdoc, NULL);
    SendMessage(ghwndApp, WM_COMMAND, (WPARAM)IDM_EXIT, 0L);
    return NOERROR;
}


STDMETHODIMP OleObjSetMoniker(LPOLEOBJECT lpOleObj,
    DWORD dwWhichMoniker, LPMONIKER pmk)
{
    DPF("OleObjSetMoniker\n");

    return NOERROR;
}


STDMETHODIMP OleObjGetMoniker(LPOLEOBJECT lpOleObj,
    DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* lplpmk)
{
    LPDOC   lpdoc;

    DPF("OleObjGetMoniker\n");

    *lplpmk = NULL;
    lpdoc = ((struct COleObjectImpl FAR*)lpOleObj)->lpdoc;

    if (lpdoc->lpoleclient != NULL)
    {
        return( IOleClientSite_GetMoniker(lpdoc->lpoleclient,
                dwAssign, dwWhichMoniker, lplpmk));
    }
    else if (lpdoc->doctype == doctypeFromFile)
    {
        // use file moniker

        WCHAR  sz[cchFilenameMax];

        if (GlobalGetAtomNameW(lpdoc->aDocName, sz, CHAR_COUNT(sz)) == 0)
            RETURN_RESULT( E_FAIL);

        return( (HRESULT)CreateFileMoniker(sz, lplpmk));
    }
    else
        RETURN_RESULT( E_FAIL);
}



STDMETHODIMP OleObjInitFromData (
LPOLEOBJECT         lpOleObj,
LPDATAOBJECT        lpDataObj,
BOOL                fCreation,
DWORD               dwReserved
)
{
    DPF("OleObjInitFromData - E_NOTIMPL\n");

    RETURN_RESULT( E_NOTIMPL);
}

STDMETHODIMP OleObjGetClipboardData (
LPOLEOBJECT         lpOleObj,
DWORD               dwReserved,
LPDATAOBJECT FAR*   lplpDataObj
)
{
    DPF("OleObjGetClipboardData - E_NOTIMPL\n");

    RETURN_RESULT( E_NOTIMPL);
}


STDMETHODIMP     OleObjSetExtent(
LPOLEOBJECT             lpOleObj,
DWORD                   dwAspect,
LPSIZEL                 lpsizel)
{
    DPF("OleObjSetExtent\n");

#ifdef LATER
    gscaleInitXY[SCALE_X].denom = lpsizel->cx;
    gscaleInitXY[SCALE_Y].denom = lpsizel->cy;
#endif

    return NOERROR;
}

//Get the object extent from the Metafile. GetMetafilePict saves the extents
// in extWidth and extHeight
STDMETHODIMP     OleObjGetExtent(
LPOLEOBJECT             lpOleObj,
DWORD                   dwAspect,
LPSIZEL                 lpSizel)
{
    HGLOBAL hTmpMF;
    LPDOC lpdoc;

    DPF("OleObjGetExtent\n");

    lpdoc = ((struct COleObjectImpl FAR*)lpOleObj)->lpdoc;

    if((dwAspect & (DVASPECT_CONTENT | DVASPECT_DOCPRINT)) == 0)
        RETURN_RESULT( E_INVALIDARG);
    // There may be a potential memory leak here -- hTmpMF contains a handle to a
    // metafile that must be deleted. See code in cdrag.c.
    // Not changed here at this time since I do not want to break anything.
    // SteveZ
    hTmpMF = GetMetafilePict();
    GLOBALUNLOCK(hTmpMF);
    GLOBALFREE(hTmpMF);
    lpSizel->cx = extWidth;
    lpSizel->cy = extHeight;

    return NOERROR;
}


STDMETHODIMP OleObjAdvise(LPOLEOBJECT lpOleObj, LPADVISESINK lpAdvSink, LPDWORD lpdwConnection)
{
    LPDOC    lpdoc;

    DPF("OleObjAdvise\n");

    lpdoc = ((struct COleObjectImpl FAR*)lpOleObj)->lpdoc;

    if (lpdoc->lpoaholder == NULL &&
        CreateOleAdviseHolder(&lpdoc->lpoaholder) != S_OK)
        RETURN_RESULT( E_OUTOFMEMORY);

    return( IOleAdviseHolder_Advise(lpdoc->lpoaholder, lpAdvSink, lpdwConnection));
}


STDMETHODIMP OleObjUnadvise(LPOLEOBJECT lpOleObj, DWORD dwConnection)
{
    LPDOC    lpdoc;

    DPF("OleObjUnadvise\n");

    lpdoc = ((struct COleObjectImpl FAR*)lpOleObj)->lpdoc;

    if (lpdoc->lpoaholder == NULL)
        RETURN_RESULT( E_FAIL);

    return( IOleAdviseHolder_Unadvise(lpdoc->lpoaholder, dwConnection));
}


STDMETHODIMP OleObjEnumAdvise(LPOLEOBJECT lpOleObj, LPENUMSTATDATA FAR* lplpenumAdvise)
{
    LPDOC    lpdoc;

    DPF("OleObjEnumAdvise\n");

    lpdoc = ((struct COleObjectImpl FAR*)lpOleObj)->lpdoc;

    if (lpdoc->lpoaholder == NULL)
        RETURN_RESULT( E_FAIL);

    return(IOleAdviseHolder_EnumAdvise(lpdoc->lpoaholder, lplpenumAdvise));
}


STDMETHODIMP OleObjGetMiscStatus
    (LPOLEOBJECT lpOleObj,
    DWORD dwAspect,
    DWORD FAR* pdwStatus)
{
    DPF("OleObjGetMiscStatus\n");

    RETURN_RESULT( OLE_S_USEREG);
}



STDMETHODIMP OleObjSetColorScheme(LPOLEOBJECT lpOleObj, LPLOGPALETTE lpLogPal)
{
    DPF("OleObjSetColorScheme\n");

    return NOERROR;
}

STDMETHODIMP OleObjLockObject(LPOLEOBJECT lpOleObj, BOOL fLock)
{
    LPDOC    lpdoc;

    DPF("OleObjLockObject\n");

    lpdoc = ((struct COleObjectImpl FAR*)lpOleObj)->lpdoc;

    if (fLock)
        lpdoc->cLock++;
    else
    {
        if (!lpdoc->cLock)
            RETURN_RESULT( E_FAIL);

        if (--lpdoc->cLock == 0)
            OleObjClose(lpOleObj, OLECLOSE_SAVEIFDIRTY);

        return NOERROR;
    }

    return NOERROR;
}



/**************************************************************************
*************   IDataObject INTERFACE IMPLEMENTATION.
**************************************************************************/

//Delegate to the common IUnknown implementation.
STDMETHODIMP     DataObjQueryInterface (
LPDATAOBJECT      lpDataObj,       // data object ptr
REFIID            riidReq,        // IID required
LPVOID FAR *      lplpUnk         // pre for returning the interface
)
{
    return( UnkQueryInterface((LPUNKNOWN)lpDataObj, riidReq, lplpUnk));
}


STDMETHODIMP_(ULONG) DataObjAddRef(
LPDATAOBJECT      lpDataObj      // data object ptr
)
{
    return UnkAddRef((LPUNKNOWN) lpDataObj);
}


STDMETHODIMP_(ULONG) DataObjRelease (
LPDATAOBJECT      lpDataObj      // data object ptr
)
{
    LPDOC    lpdoc;

    lpdoc = ((struct CDataObjectImpl FAR*)lpDataObj)->lpdoc;

    return UnkRelease((LPUNKNOWN) lpDataObj);
}


/**************************************************************************
*   DataObjGetData:
*   Provides the data for METAFILE and DIB formats.
**************************************************************************/
STDMETHODIMP    DataObjGetData (
LPDATAOBJECT            lpDataObj,
LPFORMATETC             lpformatetc,
LPSTGMEDIUM             lpMedium
)
{
   LPDOC        lpdoc;

   DPF1("DataObjGetData\n");

   if (lpMedium == NULL) RETURN_RESULT( E_FAIL);

   // null out in case of error
   lpMedium->tymed = TYMED_NULL;
   lpMedium->pUnkForRelease = NULL;
   lpMedium->hGlobal = NULL;

   lpdoc = ((struct CDataObjectImpl FAR*)lpDataObj)->lpdoc;

   VERIFY_LINDEX(lpformatetc->lindex);

   if (lpformatetc->dwAspect == DVASPECT_ICON)
   {
       if (lpformatetc->cfFormat != CF_METAFILEPICT)
           RETURN_RESULT( DATA_E_FORMATETC);
   }
   else
   {
       if (!(lpformatetc->dwAspect & (DVASPECT_CONTENT | DVASPECT_DOCPRINT)))
           RETURN_RESULT( DATA_E_FORMATETC); // we support only these 2 aspects
   }


   if (lpMedium->tymed != TYMED_NULL)
        // all the other formats we only give out in our own global block
       RETURN_RESULT( DATA_E_FORMATETC);

   lpMedium->tymed = TYMED_HGLOBAL;
   if (lpformatetc->cfFormat == CF_METAFILEPICT)
   {
      lpMedium->tymed = TYMED_MFPICT;

      DPF1("Before getmeta\n");
      if (lpformatetc->dwAspect == DVASPECT_ICON)
      lpMedium->hGlobal = GetMPlayerIcon ();
      else
      lpMedium->hGlobal = GetMetafilePict ();
      DPF1("After getmeta\n");

      if (!lpMedium->hGlobal)
      RETURN_RESULT( E_OUTOFMEMORY);

#ifdef DEBUG
      if (__iDebugLevel >= 1)
      {
          /* Useful check to validate what we're passing back to the container.
           */
          if (OpenClipboard(ghwndApp))
          {
              EmptyClipboard();
              SetClipboardData(CF_METAFILEPICT, lpMedium->hGlobal);
              CloseClipboard();
          }
      }
#endif
      return NOERROR;
   }

   if (lpformatetc->cfFormat == CF_DIB)
   {
      lpMedium->tymed = TYMED_HGLOBAL;
      lpMedium->hGlobal = (HANDLE)GetDib();
      if (!(lpMedium->hGlobal))
     RETURN_RESULT( E_OUTOFMEMORY);

#ifdef DEBUG
      if (__iDebugLevel >= 1)
      {
          /* Useful check to validate what we're passing back to the container.
           */
          if (OpenClipboard(ghwndApp))
          {
              EmptyClipboard();
              SetClipboardData(CF_DIB, lpMedium->hGlobal);
              CloseClipboard();
          }
      }
#endif
      return NOERROR;
   }
   RETURN_RESULT( DATA_E_FORMATETC);
}



STDMETHODIMP    DataObjGetDataHere (
LPDATAOBJECT            lpDataObj,
LPFORMATETC             lpformatetc,
LPSTGMEDIUM             lpMedium
)
{
    RETURN_RESULT( E_NOTIMPL);
}



STDMETHODIMP    DataObjQueryGetData (
LPDATAOBJECT            lpDataObj,
LPFORMATETC             lpformatetc
)
{ // this is only a query
    if ((lpformatetc->cfFormat == CF_METAFILEPICT) &&
        (lpformatetc->tymed & TYMED_MFPICT))
        return NOERROR;
    if ((lpformatetc->cfFormat == CF_DIB) &&
        (lpformatetc->tymed & TYMED_HGLOBAL))
        return NOERROR;
    RETURN_RESULT( DATA_E_FORMATETC);
}



STDMETHODIMP        DataObjGetCanonicalFormatEtc(
LPDATAOBJECT            lpDataObj,
LPFORMATETC             lpformatetc,
LPFORMATETC             lpformatetcOut
)
{
    RETURN_RESULT(DATA_S_SAMEFORMATETC);
}


STDMETHODIMP DataObjEnumFormatEtc(
LPDATAOBJECT            lpDataObj,
DWORD                   dwDirection,
LPENUMFORMATETC FAR*    lplpenumFormatEtc
)
{
    *lplpenumFormatEtc = NULL;
    RETURN_RESULT( OLE_S_USEREG);
}


STDMETHODIMP DataObjAdvise(LPDATAOBJECT lpDataObject,
                FORMATETC FAR* pFormatetc, DWORD advf,
                IAdviseSink FAR* pAdvSink, DWORD FAR* pdwConnection)
{
    LPDOC    lpdoc;

    lpdoc = ((struct CDataObjectImpl FAR*)lpDataObject)->lpdoc;

    VERIFY_LINDEX(pFormatetc->lindex);
    if (pFormatetc->cfFormat == 0 && pFormatetc->dwAspect == -1 &&
        pFormatetc->ptd == NULL && pFormatetc->tymed == -1)
        // wild card advise; don't check
        ;
    else

    if (DataObjQueryGetData(lpDataObject, pFormatetc) != S_OK)
        RETURN_RESULT( DATA_E_FORMATETC);

    if (lpdoc->lpdaholder == NULL &&
        CreateDataAdviseHolder(&lpdoc->lpdaholder) != S_OK)
        RETURN_RESULT( E_OUTOFMEMORY);

    return( IDataAdviseHolder_Advise(lpdoc->lpdaholder, lpDataObject,
            pFormatetc, advf, pAdvSink, pdwConnection));
}




STDMETHODIMP DataObjUnadvise(LPDATAOBJECT lpDataObject, DWORD dwConnection)
{
    LPDOC    lpdoc;

    lpdoc = ((struct CDataObjectImpl FAR*)lpDataObject)->lpdoc;

    if (lpdoc->lpdaholder == NULL)
        // no one registered
        RETURN_RESULT( E_INVALIDARG);

    return( IDataAdviseHolder_Unadvise(lpdoc->lpdaholder, dwConnection));
}

STDMETHODIMP DataObjEnumAdvise(LPDATAOBJECT lpDataObject,
                LPENUMSTATDATA FAR* ppenumAdvise)
{
    LPDOC    lpdoc;

    lpdoc = ((struct CDataObjectImpl FAR*)lpDataObject)->lpdoc;

    if (lpdoc->lpdaholder == NULL)
        RETURN_RESULT( E_FAIL);

    return( IDataAdviseHolder_EnumAdvise(lpdoc->lpdaholder, ppenumAdvise));
}


/**************************************************************************
*   DataObjSetData:
*   This should never be called.!! The data is actually fed through
*   IPersistStorage.
**************************************************************************/
STDMETHODIMP        DataObjSetData (
LPDATAOBJECT            lpDataObj,
LPFORMATETC             lpformatetc,
LPSTGMEDIUM             lpmedium,
BOOL                    fRelease
)
{
    LPVOID lpMem;
    LPSTR  lpnative;
    LPDOC lpdoc = ((struct CDataObjectImpl FAR *)lpDataObj)->lpdoc;
DPF1("*DOSETDATA");

    if(lpformatetc->cfFormat !=cfNative)
        RETURN_RESULT(DATA_E_FORMATETC);

    lpMem = GLOBALLOCK(lpmedium->hGlobal);


    if (lpMem)
    {
        SCODE scode;

        lpnative = lpMem;

        scode = ItemSetData((LPBYTE)lpnative);

        if(scode == S_OK)
            fDocChanged = FALSE;

        GLOBALUNLOCK(lpmedium->hGlobal);

        RETURN_RESULT(scode);
    }

    RETURN_RESULT(E_OUTOFMEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\mplayer.c ===
/*-----------------------------------------------------------------------------+
| MPLAYER.C                                                                    |
|                                                                              |
| This file contains the code that implements the "MPlayer" (main) dialog box. |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

/* include files */
#include "nocrap.h"
#include "stdio.h"

#include <windows.h>
#include <mmsystem.h>
#include <shellapi.h>
#include <windowsx.h>
#include <htmlhelp.h>
#include <tchar.h>
#define INCGUID
#include "mpole.h"

#include "mplayer.h"
#include "toolbar.h"
#include "fixreg.h"
#include "helpids.h"

//These include files for WM_DEVICECHANGE messages from the mixer
#include <dbt.h>
#include <cfgmgr32.h>
#include <initguid.h>
#include <mmddk.h>
#include <ks.h>
#include <ksmedia.h>

HDEVNOTIFY MixerEventContext = NULL;	//Event Context for WM_DEVICECHANGE messages related to mixer

BOOL DeviceChange_Init(HWND hWnd);
void DeviceChange_Cleanup();

//extern int FAR PASCAL ShellAbout(HWND hWnd, LPCTSTR szApp, LPCTSTR szOtherStuff, HICON hIcon);

/* in server.c, but not in a header file like it should be... */
extern PTSTR FAR FileName(LPCTSTR szPath);

/* globals */


// Used in converting units from pixels to Himetric and vice-versa
int    giXppli = 0;          // pixels per logical inch along width
int    giYppli = 0;          // pixels per logical inch along height

// Since this is a not an MDI app, there can be only one server and one doc.
CLSID      clsid;
SRVR   srvrMain;
DOC    docMain;
LPMALLOC    lpMalloc;

TCHAR  szClient[cchFilenameMax];
TCHAR  szClientDoc[cchFilenameMax];

// Has the user made changes to the document?
BOOL fDocChanged = FALSE;

/*********************************************************************
** OLE2NOTE: the very last thing an app must be do is properly shut
**    down OLE. This call MUST be guarded! it is only allowable to
**    call OleUninitialize if OleInitialize has been called.
*********************************************************************/

// Has OleInitialize been called? assume not.
BOOL    gfOleInitialized = FALSE;

// Clipboard formats
CLIPFORMAT   cfNative;
CLIPFORMAT   cfEmbedSource;
CLIPFORMAT   cfObjectDescriptor;
CLIPFORMAT   cfMPlayer;

LPWSTR sz1Ole10Native = L"\1Ole10Native";

/* in server.c, but not in a header file like it should be... */
extern LPTSTR FAR FileName(LPCTSTR szPath);
/* in init.c */
extern PTSTR     gpchFilter;
//extern HMREGNOTIFY  ghmrn;

/* globals */

DWORD   gwPlatformId;
UINT    gwPlaybarHeight=TOOLBAR_HEIGHT;/* Taken from server.c         */
UINT    gwOptions;              /* The object options from the dlg box */
BOOL    gfEmbeddedObject;       // TRUE if editing embedded OLE object
BOOL    gfRunWithEmbeddingFlag; // TRUE if we are run with "-Embedding"
BOOL    gfPlayingInPlace;       // TRUE if playing in place
BOOL    gfParentWasEnabled;     // TRUE if parent was enabled
BOOL    gfShowWhilePlaying;     //
BOOL    gfDirty;                //
int gfErrorBox;     // TRUE if we have a message box active
BOOL    gfErrorDeath;
BOOL    gfWinIniChange;

HHOOK    hHookMouse;            // Mouse hook handle.
HOOKPROC fpMouseHook;           // Mouse hook proc address.

HWND    ghwndFocusSave;         // saved focus window

BOOL    gfOpenDialog = FALSE;       // If TRUE, put up open dialog
BOOL    gfCloseAfterPlaying = FALSE;// TRUE if we are to hide after play
HICON   hiconApp;                   /* app icon */
HMENU   ghMenu;                     /* handle to the dialog's main menu       */
HMENU   ghDeviceMenu;               /* handle to the Device popup menu        */
HWND    ghwndApp;                   /* handle to the MPlayer (main) dialog box*/
HWND    ghwndMap;                   /* handle to the track map window         */
HWND    ghwndStatic;                /* handle to the static text window       */
HBRUSH  ghbrFillPat;                /* The selection fill pattern.         */
HWND    ghwndToolbar;               /* handle of the toolbar                  */
HWND    ghwndMark;                  /* handle of the mark buttons toolbar     */
HWND    ghwndFSArrows;              /* handle of the arrows to the scrollbar  */
HWND    ghwndTrackbar;              /* handle to the trackbar window          */
UINT    gwStatus = (UINT)(-1);      /* device status (if <gwDeviceID> != NULL)*/
DWORD   gdwSeekPosition;            /* Place to seek to next */
BOOL    gfValidMediaInfo;           /* are we displaying valid media info?    */
BOOL    gfValidCaption;             /* are we displaying a valid caption?     */
BOOL    gfScrollTrack;              /* is user dragging the scrollbar thumb?  */
BOOL    gfPlayOnly;                 /* play only window?  */
BOOL    gfJustPlayed = FALSE;       /* Just sent a PlayMCI() command          */
BOOL    gfJustPlayedSel = FALSE;    /* Just sent a ID_PLAYSEL command.        */
BOOL    gfUserStopped = FALSE;      /* user pressed stop - didn't happen itslf*/
DWORD_PTR   dwLastPageUpTime;           /* time of last page-left operation       */
UINT    gwCurScale = ID_NONE;       /* current scale style                    */
LONG    glSelStart = -1;            /* See if selection changes (dirty object)*/
LONG    glSelEnd = -1;              /* See if selection changes (dirty object)*/

int     gInc;                       /* how much to inc/dec spin arrows by     */

BOOL    gfAppActive = FALSE;        /* Are we the active application?         */
UINT    gwHeightAdjust;
HWND    ghwndFocus = NULL;          /* Who had the focus when we went inactive*/
BOOL    gfInClose = FALSE;          /* ack?*/
BOOL    gfCurrentCDChecked = FALSE; /* TRUE if we've checked whether it can play */
BOOL    gfCurrentCDNotAudio = FALSE;/* TRUE when we have a CD that we can't play */

extern BOOL gfInPlayMCI;

LPDATAOBJECT gpClipboardDataObject = NULL; /* If non-NULL, call OleFlushClipboard on exit */

HPALETTE     ghpalApp;

static    sfSeekExact;    // last state

UINT        gwCurDevice  = 0;                   /* current device */
UINT        gwNumDevices = 0;                   /* number of available media devices      */
MCIDEVICE   garMciDevices[MAX_MCI_DEVICES];     /* array with info about a device */


/* strings which get loaded in InitMplayerDialog in init.c, English version shown here
   All the sizes are much larger than needed, probably.  Maybe could save nearly 100 bytes!! :)
*/
extern TCHAR gszFrames[40];                          /* "frames" */
extern TCHAR gszHrs[20];                             /* "hrs" */
extern TCHAR gszMin[20];                             /* "min" */
extern TCHAR gszSec[20];                             /* "sec" */
extern TCHAR gszMsec[20];                            /* "msec" */


static SZCODE   aszNULL[] = TEXT("");
static BOOL     sfInLayout = FALSE;     // don't let Layout get re-entered

static SZCODE   szSndVol32[] = TEXT("sndvol32.exe");


static SZCODE   aszTitleFormat[] =  TEXT("%"TS" - %"TS"");

HANDLE  ghInst;                     /* handle to the application instance     */
HFONT   ghfontMap;                  /* handle to the font used for drawing
					the track map                         */
LPTSTR  gszCmdLine;                 /* string holding the command line parms  */
int     giCmdShow;                  /* command show                           */
TCHAR   gachFileDevice[MAX_PATH];   /* string holding the curr file or device */
TCHAR   gachWindowTitle[MAX_PATH];  /* string holding name we will display  */
TCHAR   gachCaption[MAX_PATH];      /* string holding name we will display  */

HACCEL   hAccel;
int      gcAccelEntries;

typedef struct _POS
{
    int x;
    int y;
    int cx; /* This field is non-0 if we're currently sizing/moving */
    int cy;
}
POS, *PPOS;

POS     posSizeMove = {0,0,0,0};    /* POS we want during size/move operations */



STRING_TO_ID_MAP DevToIconIDMap[] =
{
    { szCDAudio,    IDI_DCDA     },
    { szVideoDisc,  IDI_DDEFAULT },
    { szSequencer,  IDI_DMIDI    },
    { szVCR,        IDI_DDEFAULT },
    { szWaveAudio,  IDI_DSOUND   },
    { szAVIVideo,   IDI_DVIDEO   }
};


//CDA file processing///////////////////////////////////////////////////
//The following structure taken from deluxecd. This is used in processing
typedef struct {
    DWORD   dwRIFF;         // 'RIFF'
    DWORD   dwSize;         // Chunk size = (file size - 8)
    DWORD   dwCDDA;         // 'CDDA'
    DWORD   dwFmt;          // 'fmt '
    DWORD   dwCDDASize;     // Chunk size of 'fmt ' = 24
    WORD    wFormat;        // Format tag
    WORD    wTrack;         // Track number
    DWORD   DiscID;         // Unique disk id
    DWORD   lbnTrackStart;  // Track starting sector (LBN)
    DWORD   lbnTrackLength; // Track length (LBN count)
    DWORD   msfTrackStart;  // Track starting sector (MSF)
    DWORD   msfTrackLength; // Track length (MSF)
	}   RIFFCDA;

void HandleCDAFile(TCHAR *szFile);
BOOL IsTrackFileNameValid(LPTSTR lpstFileName, UINT *pUiTrackIndex);
void JumpToCDTrack(UINT trackno);

////////////////////////////////////////////////////////////////////////

/* private function prototypes */

//int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPSTR szCmdLine, int iCmdShow);
void CleanUpClipboard();
int GetHeightAdjust(HWND hwnd);
HANDLE PASCAL GetDib (VOID);


static HHOOK     fpfnOldMsgFilter;
static HOOKPROC  fpfnMsgHook;
//Data used for supporting context menu help
BOOL   bF1InMenu=FALSE;	//If true F1 was pressed on a menu item.
UINT   currMenuItem=0;	//The current menu item if any.


typedef void (FAR PASCAL *PENWINREGISTERPROC)(UINT, BOOL);

/* Define some constants to make parameters to CreateEvent a tad less obscure:
 */
#define EVENT_DEFAULT_SECURITY              NULL
#define EVENT_RESET_MANUAL                  TRUE
#define EVENT_RESET_AUTOMATIC               FALSE
#define EVENT_INITIAL_STATE_SIGNALED        TRUE
#define EVENT_INITIAL_STATE_NOT_SIGNALED    FALSE
#define EVENT_NO_NAME                       NULL

HANDLE heventCmdLineScanned;    /* Event will be signaled when command line scanned */
HANDLE heventDeviceMenuBuilt;   /* Event will be signaled when device menu complete */

#ifdef LATER
SCALE   gscaleInitXY[2] = { 0, 0, 0, 0 }; // Initial scale to use for inserting OLE objects
#endif



/*------------------------------------------------------+
| HelpMsgFilter - filter for F1 key in dialogs          |
|                                                       |
+------------------------------------------------------*/

DWORD FAR PASCAL HelpMsgFilter(int nCode, DWORD_PTR wParam, DWORD_PTR lParam)
{
  if (nCode >= 0){
      LPMSG    msg = (LPMSG)lParam;

      if ((msg->message == WM_KEYDOWN) && (msg->wParam == VK_F1))
	  {
		if(nCode == MSGF_MENU)
			bF1InMenu = TRUE;
		SendMessage(ghwndApp, WM_COMMAND, (WPARAM)IDM_HELPTOPICS, 0L);
	  }
  }
//  return DefHookProc(nCode, wParam, lParam, (HHOOK FAR *)&fpfnOldMsgFilter);
    return 0;
}

#ifdef CHICAGO_PRODUCT

BOOL IsBadSegmentedCodePtr(LPARAM lpPtr)
{
#define DSC_PRESENT         0x80
#define DSC_CODE_BIT    0x08
#define DSC_RW_BIT          0x02
#define DSC_DISCARDABLE 0x10

    WORD wSel;
    WORD wOff;
    BOOL fRet;

    wSel = HIWORD(lpPtr);
    wOff = LOWORD(lpPtr);

_asm {
	mov     ax, [wSel];
	lar     bx, ax;
	jnz     ValidDriverCallback_Failure     ; //Return TRUE for error

	mov     ch, DSC_CODE_BIT or DSC_RW_BIT or DSC_PRESENT  ;
	and     bh, ch;
	cmp     bh, ch;
	jne     ValidDriverCallback_Failure     ; //Not executable segment

	test    bl, DSC_DISCARDABLE ;
	jnz     ValidDriverCallback_Failure     ; //Not fixed segment

	lsl     cx, ax;                         ; //Get segment limit
	mov     bx, [wOff];
	cmp     bx, cx;
	jb      ValidDriverCallback_Success     ; //Valid offset

	jne     ValidDriverCallback_Failure     ; //Not executable segment

ValidDriverCallback_Failure:
    mov eax, 1;
    jmp ValidDriverCallback_Return;
ValidDriverCallback_Success:
    xor eax, eax;
ValidDriverCallback_Return:
    mov [fRet], eax;
    }
    return fRet;
}

#endif

/* RouteKeyPresses
 *
 * Reroutes cursor keys etc to track bar.
 */
void RouteKeyPresses(PMSG pMsg)
{
    /* Hack for PowerPoint
     *
     * Mail from PaulWa:
     *
     * --------
     * Here's a problem you might consider fixing.
     * Launching Media Player with certain keystrokes
     * doesn't work right (e.g. arrow keys, page up/down,
     * etc.).
     *
     * The problem is due to the fact that Media Player
     * handles key up events.  We use the key down event
     * to launch the server in slideshow, but then the key
     * up event is passed to the server.  It would probably
     * be best for Media Player to ignore key up events
     * unless it had previously received a key down.
     * If this is very difficult to fix in Media Player,
     * then we can fix it in PP by launching servers on
     * key up rather than key down.  However, other container
     * apps will see the same problem.
     * --------
     *
     * OK, in the spirit of cooperation, let's hack things
     * so our PowerPoint friends can carry on with their
     * dubious practices.
     */
    static WPARAM LastVKeyDown;

    /* On key down when we're embedded, remember what is was:
     */
    if (gfRunWithEmbeddingFlag && (pMsg->message == WM_KEYDOWN))
	LastVKeyDown = pMsg->wParam;

    /* Don't reroute if it's a key up that doesn't match
     * the last key down; this effectively ignores it:
     */
    if (gfRunWithEmbeddingFlag &&
	(pMsg->message == WM_KEYUP) && (pMsg->wParam != LastVKeyDown))
    {
	DPF0("Ignoring WM_KEYUP, since it doesn't match last WM_KEYDOWN.\n");
    }
    else
    {
	switch(pMsg->wParam)
	{
	case VK_UP:
	case VK_LEFT:
	case VK_DOWN:
	case VK_RIGHT:
	case VK_NEXT:
	case VK_PRIOR:
	case VK_HOME:
	case VK_END:
	    pMsg->hwnd = ghwndTrackbar;
	    break;

	default:
	    break;
	}
    }

    if (pMsg->message == WM_KEYUP)
	LastVKeyDown = 0;
}



/*
 * WinMain(hInst, hPrev, szCmdLine, iCmdShow)
 *
 * This is the main procedure for the application.  It performs initialization
 * and then enters a message-processing loop, where it remains until it
 * receives a WM_QUIT message (meaning the app was closed). This function
 * always returns TRUE..
 *
 */
int WINAPI WinMain( HINSTANCE hInst /* handle to the current instance of the application */
		  , HINSTANCE hPrev /* handle to the previous instance of the application */
		  , LPSTR szCmdLine /* null-terminated string holding the command line params */
		  , int iCmdShow    /* how the window should be initially displayed */
		  )
{
    MSG         rMsg;   /* variable used for holding a message */
    HWND        hwndFocus;
    HWND        hwndP;

    /* call the Pen Windows extensions to allow them to subclass our
       edit controls if they so wish
    */

    OSVERSIONINFO         OSVersionInfo;

#ifdef UNICODE
    LPTSTR      szUnicodeCmdLine;

    szUnicodeCmdLine = AllocateUnicodeString(szCmdLine);
#endif

    heventCmdLineScanned = CreateEvent( EVENT_DEFAULT_SECURITY,
					EVENT_RESET_MANUAL,
					EVENT_INITIAL_STATE_NOT_SIGNALED,
					EVENT_NO_NAME );

    heventDeviceMenuBuilt = CreateEvent( EVENT_DEFAULT_SECURITY,
					 EVENT_RESET_MANUAL,
					 EVENT_INITIAL_STATE_NOT_SIGNALED,
					 EVENT_NO_NAME );

    if (!heventCmdLineScanned || !heventDeviceMenuBuilt)
	return FALSE;

    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;

    GetVersionEx(&OSVersionInfo);

    gwPlatformId = OSVersionInfo.dwPlatformId;


    giCmdShow = iCmdShow;

#ifdef UNICODE
    if (!AppInit(hInst,hPrev,szUnicodeCmdLine))
#else
    if (!AppInit(hInst,hPrev,szCmdLine))
#endif
	return FALSE;

    /* Device Menu Initialization:
     *
     * If the user has requested an Open dialog (by supplying the /open
     * flag with no file name), we've already built the Device menu,
     * since the list of devices is required up front.
     *
     * If we're just playing in tiny mode, we don't need the device list.
     * It will be built if the user switches to full mode and then accesses
     * the Device menu or selects File.Open.
     *
     * Otherwise go for it.  The main window's already up now, so we
     * can build the list on a background thread.  Don't forget to wait
     * for the event to be signaled when the appropriate menu is accessed.
     */
    if (!gfOpenDialog && !gfPlayOnly)
	InitDeviceMenu();

#ifdef UNICODE
//  ScanCmdLine mangles it, so forget it
//  FreeUnicodeString(szUnicodeCmdLine);
#endif

    /* setup the message filter to handle grabbing F1 for this task */
    fpfnMsgHook = (HOOKPROC)MakeProcInstance((FARPROC)HelpMsgFilter, ghInst);
    fpfnOldMsgFilter = (HHOOK)SetWindowsHook(WH_MSGFILTER, fpfnMsgHook);

#ifdef DEBUG
    GdiSetBatchLimit(1);
#endif

    for (;;)
    {
	/* If we're ever still around after being destroyed, DIE! */
	if (!IsWindow(ghwndApp))
	    break;

	/* call the server code and let it unblock the server */
#ifdef OLE1_HACK
	ServerUnblock();
#endif /* OLE1_HACK */

	/* Polling messages from event queue */

	if (!GetMessage(&rMsg, NULL, 0, 0))
	    break;

	if (gfPlayingInPlace) {

	    // If focus ever gets to the client during play in place,
	    // be really nasty and force focus to us.   (Aldus BUG!!!!)
	    // Aldus Persuasion won't play in place without this.

	    hwndFocus = GetFocus();
	    hwndP = GetParent(ghwndApp);

	    if (!ghwndIPHatch && hwndFocus && hwndP &&
			GetWindowTask(hwndP) == GetWindowTask(hwndFocus))
		PostCloseMessage();
	}

	/* Hack: post END_SCROLL messages with lParam == -1 */

	if ((rMsg.hwnd==ghwndApp)
	     || (rMsg.hwnd && GetParent(rMsg.hwnd)==ghwndApp))
	{
	    /* Reroute arrow keys etc to track bar:
	     */
	    if (rMsg.message == WM_KEYDOWN || rMsg.message == WM_KEYUP)
		RouteKeyPresses(&rMsg);
	}


	if (IsWindow(ghwndApp)) {

	    if (gfRunWithEmbeddingFlag
	       && docMain.lpIpData
	       && docMain.lpIpData->lpFrame
	       && !IsAccelerator(hAccel, gcAccelEntries, &rMsg, NULL)
	       && OleTranslateAccelerator(docMain.lpIpData->lpFrame,
					  &docMain.lpIpData->frameInfo, &rMsg) == NOERROR) {
		continue;
	    }

	    if (hAccel && TranslateAccelerator(ghwndApp, hAccel, &rMsg))
		continue;

	}

	if (rMsg.message == WM_TIMER && rMsg.hwnd == NULL) {
#ifdef CHICAGO_PRODUCT
	    /* The reason for requiring the following test is now lost
	     * in the mists of time.  Now this app is 32-bit, these
	     * bogus timer callbacks (if they really do still occur)
	     * could be 16-bit, so we need to add yet more ugliness
	     * in the form of assembler to an app which is already
	     * hardly a paragon of pulchritude.
	     *
	     * A plea:
	     *
	     * If you add some obscure code such as below, to this or
	     * any other app, even if it has only the teeniest chance
	     * of being less blindingly obvious to someone else than
	     * it is to you at the time of writing, please please please
	     * add a f***ing comment.
	     *
	     * Respectfully,
	     * A Developer
	     */
	    if (IsBadSegmentedCodePtr(rMsg.lParam))
#else
	    if (IsBadCodePtr((FARPROC)rMsg.lParam))
#endif /* ~CHICAGO_PRODUCT */
	    {
		DPF0("Bad function pointer (%08lx) in WM_TIMER message\n", rMsg.lParam);
		rMsg.message = WM_NULL;
	    }
	}
	if (rMsg.message == WM_SYSCOMMAND
	    && (((0xFFF0 & rMsg.wParam) == SC_MOVE)|| ((0xFFF0 & rMsg.wParam) == SC_SIZE)) ) {
		// If ANY window owned by our thread is going into a modal
		// size or move loop then we need to force some repainting to
		// take place.  The cost of not doing so is that garbage can
		// be left lying around on the trackbar, e.g. bits of system
		// menu, or partially drawn sliders.
		UpdateWindow(ghwndApp);
	}
	TranslateMessage(&rMsg);
	DispatchMessage(&rMsg);
    }

    ghwndApp = NULL;

    /* Delete the track map font that we created earlier. */

    if (ghfontMap != NULL) {
	DeleteObject(ghfontMap);
	ghfontMap = NULL;
    }

    if (ghbrFillPat)
	DeleteObject(ghbrFillPat);

    if (ghpalApp)
	DeleteObject(ghpalApp);

    /* if the message hook was installed, remove it and free */
    /* up our proc instance for it.                          */
    if (fpfnOldMsgFilter){
	UnhookWindowsHook(WH_MSGFILTER, fpfnMsgHook);
    }

    ControlCleanup();

//  TermServer();

    /*********************************************************************
    ** OLE2NOTE: the very last thing an app must be do is properly shut
    **    down OLE. This call MUST be guarded! it is only allowable to
    **    call OleUninitialize if OleInitialize has been called.
    *********************************************************************/

    // Clean shutdown for OLE
    DPFI("*before oleunint");
    if (gfOleInitialized) {
	if (gpClipboardDataObject)
	    CleanUpClipboard();
	(void)OleUninitialize();
	IMalloc_Release(lpMalloc);
	lpMalloc = NULL;
	gfOleInitialized = FALSE;
	}


    if (hOLE32)
	FreeLibrary(hOLE32);

    /* End of program */

    return((int)rMsg.wParam);
}

void CleanUpClipboard()
{
    /* Check whether the DATAOBJECT we put on the clipboard is still there:
     */
    if (OleIsCurrentClipboard(gpClipboardDataObject) == S_OK)
    {
	LPDATAOBJECT pIDataObject;

	if (OleGetClipboard(&pIDataObject) == S_OK)
	{
	    OleFlushClipboard();
	    IDataObject_Release(pIDataObject);
	}
	else
	{
	    DPF0("OleGetClipboard failed\n");
	}
    }
    else
    {
	if(ghClipData)
	    GLOBALFREE(ghClipData);
	if(ghClipMetafile)
	    GLOBALFREE(ghClipMetafile);
	if(ghClipDib)
	    GLOBALFREE(ghClipDib);
    }
}

//
// cancel any active menus and close the app.
//
void PostCloseMessage()
{
    HWND hwnd;

    hwnd = GetWindowMCI();
    if (hwnd != NULL)
	SendMessage(hwnd, WM_CANCELMODE, 0, 0);
    SendMessage(ghwndApp, WM_CANCELMODE, 0, 0);
    PostMessage(ghwndApp, WM_CLOSE, 0, 0);
}

//
// If we have a dialog box up (gfErrorBox is set) or we're disabled (we have
// a dialog box up) or the MCI device's default window is disabled (it has a
// dialog box up) then closing us would result in our deaths.
//
BOOL ItsSafeToClose(void)
{
    HWND hwnd;

    if (gfErrorBox)
    return FALSE;
    if (!IsWindowEnabled(ghwndApp))
    return FALSE;
    hwnd = GetWindowMCI();
    if (hwnd && !IsWindowEnabled(hwnd))
    return FALSE;

    return TRUE;
}

/* ResolveLink
 *
 * This routine is called when the user drags and drops a shortcut
 * onto Media Player.  If it succeeds, it returns the full path
 * of the actual file in szResolved.
 */
BOOL ResolveLink(LPTSTR szPath, LPTSTR szResolved, LONG cbSize)
{
    IShellLink *psl = NULL;
    HRESULT hres;

    if (!InitOLE(&gfOleInitialized, &lpMalloc))
    {
	DPF0("Initialization of OLE FAILED!!  Can't resolve link.\n");
	return FALSE;
    }

    hres = (HRESULT)CoCreateInstance(&CLSID_ShellLink, NULL, CLSCTX_INPROC,
			    &IID_IShellLink, &psl);

    if (SUCCEEDED(hres))
    {
	IPersistFile *ppf;

	psl->lpVtbl->QueryInterface(psl, &IID_IPersistFile, &ppf);

	if (ppf)
	{
		WCHAR wszPath[MAX_PATH];
#ifdef UNICODE
		lstrcpy (wszPath, szPath);
#else
		AnsiToUnicodeString(szPath, wszPath, UNKNOWN_LENGTH);
#endif
		hres = ppf->lpVtbl->Load(ppf, wszPath, 0);
		ppf->lpVtbl->Release(ppf);

		if (FAILED(hres))
		{
		psl->lpVtbl->Release(psl);
		psl = NULL;
		}
	}
	else
	{
		psl->lpVtbl->Release(psl);
		psl = NULL;
	}
    }   

    if (psl)
    {
	psl->lpVtbl->Resolve(psl, NULL, SLR_NO_UI);
	psl->lpVtbl->GetPath(psl, szResolved, cbSize, NULL, 0);
	psl->lpVtbl->Release(psl);
    }

    return SUCCEEDED(hres);
}


/* ResolveIfLink
 *
 * Called to check whether a given file name is a shortcut
 * on Windows 95.
 *
 * Copies the resolved file name into the buffer provided,
 * overwriting the original name.
 *
 * Returns TRUE if the function succeeded, whether or not the
 * file name was changed.  FALSE indicates that an error occurred.
 *
 * Andrew Bell, 16 February 1995
 */
BOOL ResolveIfLink(PTCHAR szFileName)
{
    SHFILEINFO sfi;
    BOOL       rc = TRUE;

    if ((SHGetFileInfo(szFileName, 0, &sfi, sizeof sfi, SHGFI_ATTRIBUTES) == 1)
	&& ((sfi.dwAttributes & SFGAO_LINK) == SFGAO_LINK))
    {
	TCHAR szResolvedLink[MAX_PATH];

	if (ResolveLink(szFileName, szResolvedLink, CHAR_COUNT(szResolvedLink)))
	    lstrcpy(szFileName, szResolvedLink);
	else
	    rc = FALSE;
    }

    return rc;
}

/* JumpToCDTrack()
*
* Jumps to the appropriate track on the CD and updates the UI accordingly
*
*/
void JumpToCDTrack(UINT trackno)
{
	//If the track number is invalid just ignore.
	//Let the default behaviour take place, There is no need to give a message box
	//saying we couldn't jump to track.
	if(trackno > gwNumTracks)
		return;

	/* We MUST use PostMessage because the */
	/* SETPOS and ENDTRACK must happen one */
    /* immediately after the other         */
   	PostMessage(ghwndTrackbar, TBM_SETPOS, (WPARAM)TRUE, gadwTrackStart[trackno]);
   	PostMessage(ghwndApp, WM_HSCROLL, (WPARAM)TB_ENDTRACK, (LPARAM)ghwndTrackbar);
}

/*****************************Private*Routine******************************\
* IsTrackFileNameValid
*
* This routine copied from deluxecd and modified
*
* This function returns true if the specified filename is a valid CD track.

* On NT track filenames must be of the form:
*   d:\track(n).cda  where d: is the CD-Rom device and \track(n).cda
*                    is the index of the track to be played (starting from 1).
*
* On Chicago the track filename is actually a riff CDDA file which contains
* the track info that we require.
*
* If the filename is valid the function true and sets 
* piTrackIndex to the correct value.
*
* History:
* 29-09-94 - StephenE - Created
*
\**************************************************************************/
BOOL
IsTrackFileNameValid(
    LPTSTR lpstFileName,
    UINT *puiTrackIndex
    )
{
#define RIFF_RIFF 0x46464952
#define RIFF_CDDA 0x41444443

	
    RIFFCDA     cda;
    HANDLE          hFile;
    int         i;
    DWORD       cbRead;
    BOOL        fRead;
	
	// Open file and read in CDA info
	hFile = CreateFile (lpstFileName, GENERIC_READ, 
						FILE_SHARE_READ, NULL, 
						OPEN_EXISTING, 0, NULL);
	if (INVALID_HANDLE_VALUE == hFile) {
		return FALSE;
	}
	
    ZeroMemory (&cda, sizeof (cda));
	fRead = ReadFile(hFile, &cda, sizeof(cda), &cbRead, NULL);
	CloseHandle (hFile);

    if (!fRead)
        return FALSE;

    //
    // Make sure its a RIFF CDDA file
    //
    if ( (cda.dwRIFF != RIFF_RIFF) || (cda.dwCDDA != RIFF_CDDA) ) {
		
	return FALSE;
    }

    *puiTrackIndex = cda.wTrack - 1;

    return TRUE;
}

/* HandleCDAFile()
*
* Checks to see if the opened file is a CDA file and tries to jump to the appropriate track.
*
*/
void HandleCDAFile(TCHAR *szFile)
{
	UINT trackno;
	if(IsTrackFileNameValid(szFile, &trackno))
	{
		JumpToCDTrack(trackno);
	}
}


/* Process file drop/drag options. */
void PASCAL NEAR doDrop(HWND hwnd, HDROP hDrop)
{
    RECT    rc;

    if(DragQueryFile(hDrop,(UINT)(~0),NULL,0)){/* # of files dropped */
	TCHAR  szPath[MAX_PATH];

	/* If user dragged/dropped a file regardless of keys pressed
	 * at the time, open the first selected file from file
	 * manager.
	 */
	DragQueryFile(hDrop,0,szPath,sizeof(szPath)/sizeof(TCHAR));
	SetActiveWindow(hwnd);

	ResolveIfLink(szPath);

	if (OpenMciDevice(szPath, NULL)) {
	    SubClassMCIWindow();
	    PostMessage(hwnd, WM_COMMAND, (WPARAM)ID_PLAY, 0);
	    DirtyObject(FALSE);             // we're dirty now!
	    gfCloseAfterPlaying = FALSE;    // stay up from now on

		//If the CD Audio device was opened it must have been a *.cda file.
		//Try to jump to the track corresponding to the file opened.
		if ((gwDeviceType & DTMCI_DEVICE) == DTMCI_CDAUDIO)
		{
			HandleCDAFile(szPath);
		}
	}
	else
	{
		gwCurDevice = 0;// force next file open dialog to say
				// "all files" because CloseMCI won't.
		gwCurScale = ID_NONE;  // uncheck all scale types
		Layout(); // Make window snap back to smaller size
	}

	SetMPlayerIcon();

	/* Force WM_GETMINMAXINFO to be called so we'll snap to a */
	/* proper size.                                           */
	GetWindowRect(ghwndApp, &rc);
	MoveWindow(ghwndApp, rc.left, rc.top, rc.right - rc.left,
		    rc.bottom - rc.top, TRUE);
    }
    DragFinish(hDrop);     /* Delete structure alocated for WM_DROPFILES*/
}

/* Change the number in dwPosition to the proper format.  szNum contains the */
/* formatted number only "01 45:10" while szBuf contains units such as       */
/* "01 45:10 (min:sec)"                                                      */
/* If fRound is set, it will not always display millisecond accuracy, but    */
/* choose something useful like second accuracy or hundreth sec accuracy.    */
void FAR PASCAL FormatTime(DWORD_PTR dwPosition, LPTSTR szNum, LPTSTR szBuf, BOOL fRound)
{
    UINT w;
    UINT hrs;
    UINT min;
    UINT sec;
    UINT hsec;
    UINT msec;
    DWORD dwMaxSize = gdwMediaLength;
    static TCHAR framestr[40] = TEXT("");
    static TCHAR sec_str[40] = TEXT("");
    static TCHAR min_str[40] = TEXT("");
    static TCHAR hrs_str[40] = TEXT("");
    static TCHAR msec_str[40] = TEXT("");

	static SZCODE   aszLongDecimal[] = TEXT("%ld");
	static SZCODE   aszFrameFormat[] = TEXT("%"TS" %ld");
	static SZCODE   asz02Decimal[] = TEXT("%02d ");
	static SZCODE   aszTimeFormat1[] = TEXT("%02d%c%02d%c%02d");
	static SZCODE   aszTimeFormat2[] = TEXT("%02d%c%02d%c%02d%c%03d");
	static SZCODE   aszTimeFormat3[] = TEXT("%02d%c%02d%c%02d (%"TS"%c%"TS"%c%"TS")");
	static SZCODE   aszTimeFormat4[] = TEXT("%02d%c%02d%c%02d%c%03d (%"TS"%c%"TS"%c%"TS"%c%"TS")");
	static SZCODE   aszTimeFormat5[] = TEXT("%02d%c%02d");
	static SZCODE   aszTimeFormat6[] = TEXT("%02d%c%02d%c%03d");
	static SZCODE   aszTimeFormat7[] = TEXT("%02d%c%02d (%"TS"%c%"TS")");
	static SZCODE   aszTimeFormat8[] = TEXT("%02d%c%02d%c%03d (%"TS"%c%"TS"%c%"TS")");
	static SZCODE   aszTimeFormat9[] = TEXT("%c%02d");
	static SZCODE   aszTimeFormat10[] = TEXT("%c%03d");
	static SZCODE   aszTimeFormat11[] = TEXT("%02d%c%03d");
	static SZCODE   aszTimeFormat12[] = TEXT("%c%02d (%"TS")");
	static SZCODE   aszTimeFormat13[] = TEXT("%02d%c%02d (%"TS")");
	static SZCODE   aszTimeFormat14[] = TEXT("%c%03d (%"TS"%c%"TS")");
	static SZCODE   aszTimeFormat15[] = TEXT("%02d%c%03d (%"TS"%c%"TS")");


    //!!! LoadStrings at init time, dont hardcode...

    #define ONE_HOUR    (60ul*60ul*1000ul)
    #define ONE_MINUTE  (60ul*1000ul)
    #define ONE_SECOND  (1000ul)

    if (szBuf)
	*szBuf = 0;
    if (szNum)
	*szNum = 0;

    if (gwDeviceID == (UINT)0)
	return;

    if (gwStatus == MCI_MODE_NOT_READY || gwStatus == MCI_MODE_OPEN)
	return;

    switch (gwCurScale) {

    case ID_FRAMES:
	if (!STRLEN(framestr))
	    LOADSTRING(IDS_FRAME,framestr);
	if (szNum)
	    wsprintf(szNum, aszLongDecimal, (long)dwPosition);
	if (szBuf)
	    wsprintf(szBuf, aszFrameFormat, framestr, (long)dwPosition);
	gInc = 1;    // spin arrow inc/dec by one frame
	break;

    case ID_TRACKS:
	//
	//  find the track that contains this position
	//  also, find the longest track so we know if we should display
	//  hh:mm:ss or mm:ss or ss.sss or whatever.
	//

	if (gwNumTracks == 0)
	    return;

	dwMaxSize = 0;

	for (w=0; w<gwNumTracks-1; w++) {

	    if (gadwTrackStart[w+1] - gadwTrackStart[w] > dwMaxSize)
		dwMaxSize = gadwTrackStart[w+1] - gadwTrackStart[w];

	    /* When a CD is stopped, it's still spinning, and after we */
	    /* seek to the beginning of a track, it may return a value */
	    /* slightly less than the track start everyonce in a while.*/
	    /* So if we're within 200ms of the track start, let's just */
	    /* pretend we're exactly on the start of the track.        */

	    if (dwPosition < gadwTrackStart[w+1] &&
		gadwTrackStart[w+1] - dwPosition < 200)
		dwPosition = gadwTrackStart[w+1];

	    if (gadwTrackStart[w+1] > dwPosition)
		break;
	}

	if (szNum) {
	    wsprintf(szNum, asz02Decimal, gwFirstTrack + w);
	    szNum += 3;
	}
	if (szBuf) {
	    wsprintf(szBuf, asz02Decimal, gwFirstTrack + w);
	    szBuf += 3;
	}

	dwPosition -= gadwTrackStart[w];

	for (; w < gwNumTracks - 1; w++) {
	    if (gadwTrackStart[w+1] - gadwTrackStart[w] > dwMaxSize)
		dwMaxSize = gadwTrackStart[w+1] - gadwTrackStart[w];
	}

	// fall through

    case ID_TIME:
	if (!STRLEN(sec_str))
	{
	    LOADSTRING(IDS_SEC,sec_str);
	    LOADSTRING(IDS_HRS,hrs_str);
	    LOADSTRING(IDS_MIN,min_str);
	    LOADSTRING(IDS_MSEC,msec_str);
	}

	min  = (UINT)((dwPosition / ONE_MINUTE) % 60);
	sec  = (UINT)((dwPosition / ONE_SECOND) % 60);
	msec = (UINT)(dwPosition % 1000);

	if (dwMaxSize > ONE_HOUR) {

	    hrs  = (UINT)(dwPosition / ONE_HOUR);

	    if (szNum && fRound) {
		wsprintf(szNum, aszTimeFormat1,
			 hrs, chTime, min, chTime, sec);
	    } else if (szNum) {
		wsprintf(szNum, aszTimeFormat2,
			 hrs, chTime, min, chTime, sec, chDecimal, msec);
	    }

	    if (szBuf && fRound) {
		wsprintf(szBuf, aszTimeFormat3,
			 hrs, chTime, min, chTime, sec, hrs_str,
			 chTime, min_str, chTime, sec_str);
	    } else if (szBuf) {
		wsprintf(szBuf,
			 aszTimeFormat4,
			 hrs, chTime, min, chTime, sec, chDecimal, msec,
			 hrs_str,chTime, min_str,chTime,
			 sec_str, chDecimal, msec_str);
	    }

	    gInc = 1000;    // spin arrow inc/dec by seconds

	} else if (dwMaxSize > ONE_MINUTE) {

	    if (szNum && fRound) {
		wsprintf(szNum, aszTimeFormat5, min, chTime, sec);
	    } else if (szNum) {
		wsprintf(szNum, aszTimeFormat6, min, chTime, sec,
			 chDecimal, msec);
	    }

	    if (szBuf && fRound) {
		wsprintf(szBuf, aszTimeFormat7, min, chTime, sec,
			 min_str,chTime,sec_str);
	    } else if (szBuf) {
		wsprintf(szBuf, aszTimeFormat8,
			 min, chTime, sec, chDecimal, msec,
			 min_str,chTime,sec_str, chDecimal,
			 msec_str);
	    }

	    gInc = 1000;    // spin arrow inc/dec by seconds

	} else {

	    hsec = (UINT)((dwPosition % 1000) / 10);

	    if (szNum && fRound) {
		if (!sec && chLzero == TEXT('0'))
		    wsprintf(szNum, aszTimeFormat9, chDecimal, hsec);
		else
		    wsprintf(szNum, aszTimeFormat5, sec, chDecimal, hsec);

	    } else if (szNum) {
		if (!sec && chLzero == TEXT('0'))
		    wsprintf(szNum, aszTimeFormat10,  chDecimal, msec);
		else
		    wsprintf(szNum, aszTimeFormat11, sec, chDecimal, msec);
	    }

	    if (szBuf && fRound) {
		if (!sec && chLzero == TEXT('0'))
		    wsprintf(szBuf, aszTimeFormat12, chDecimal, hsec, sec_str);
		else
		    wsprintf(szBuf, aszTimeFormat13, sec, chDecimal, hsec, sec_str);

	    } else if (szBuf) {
		if (!sec && chLzero == TEXT('0'))
		    wsprintf(szBuf, aszTimeFormat14,  chDecimal,
			     msec, sec_str,chDecimal,msec_str);
		else
		    wsprintf(szBuf, aszTimeFormat15, sec, chDecimal,
			     msec, sec_str,chDecimal,msec_str);
	    }

	    gInc = 100;    // spin arrow inc/dec by 1/10 second
	}
    }
}


BOOL IsCdromDataOnly();


BOOL UpdateWindowText(HWND hwnd, LPTSTR Text)
{
    TCHAR CurrentText[80];

    GetWindowText(hwnd, CurrentText, CHAR_COUNT(CurrentText));

    if(lstrcmp(Text, CurrentText))
	return SetWindowText(hwnd, Text);
    else
	return TRUE;
}


/*
 * UpdateDisplay()
 *
 * Update the scrollbar, buttons, etc.  If the media information (media
 * length, no. tracks, etc.) is not currently valid, then update it first.
 *
 * The following table shows how the current status (value of <gwStatus>)
 * affects which windows are enabled:
 *
 *                      Play    Pause   Stop    Eject
 *    MCI_MODE_STOP     ENABLE  n/a             ENABLE
 *    MCI_MODE_PAUSE    ENABLE  n/a     ENABLE  ENABLE
 *    MCI_MODE_PLAY     n/a     ENABLE  ENABLE  ENABLE
 *    MCI_MODE_OPEN             n/a             ENABLE
 *    MCI_MODE_RECORD   ??????  ??????  ??????  ??????
 *    MCI_MODE_SEEK     ENABLE  n/a     ENABLE  ENABLE
 *
 *    MCI_MODE_NOT_READY  ALL DISABLED
 *
 * The eject button is always enabled if the medium can be ejected and
 * disabled otherwise.
 *
 * In open mode, either Play or Eject will cause the media door to close,
 * but Play will also begin play.  In any mode, Eject always does an
 * implicit Stop first.
 *
 * If <gwDeviceID> is NULL, then there is no current device and all four
 * of these buttons are disabled.
 *
 */
void FAR PASCAL UpdateDisplay(void)
{
    DWORD_PTR         dwPosition;         /* the current position within the medium */
    UINT          wStatusMCI;         /* status of the device according to MCI  */
#if 0
    TOOLBUTTON    tb;
#endif
    static BOOL   sfBlock = FALSE;    // keep SeekMCI from causing infinite loop

    /* Don't even think about updating the display if the trackbar's scrolling: */
    if (gfScrollTrack)
	return;

    /* We've been re-entered */
    if (sfBlock)
	return;

    /*
     * if for some reason we were closed, close now!
     */
    if (gfErrorDeath) {
	DPF("*** Trying to close window now!\n");
	PostMessage(ghwndApp, gfErrorDeath, 0, 0);
	return;
    }

    /*
     * If the track information is not valid (e.g. a CD was just inserted),
     * then update it.
     *
     */

    if (!gfValidMediaInfo)
	UpdateMCI();                /* update the appropriate global variables*/

    /*
     * Determine the current position and status ( stopped, playing, etc. )
     * as MCI believes them to be.
     *
     */

    wStatusMCI = StatusMCI(&dwPosition);



    /* The deal here is that the user can insert CDs, any of which may not be
     * playable because they contain no audio tracks.  So, as soon as we detect
     * that we have a CD we haven't checked, make sure we can play it.
     * If the current device is CD, and the door isn't open, check it.
     *
     */
    if (((gwDeviceType & DTMCI_DEVICE) == DTMCI_CDAUDIO) &&
	(wStatusMCI != MCI_MODE_OPEN))
    {
	if (!gfCurrentCDChecked)
	{
	    if (IsCdromDataOnly())
	    {
		gfCurrentCDNotAudio = TRUE;
		gwCurScale = ID_NONE;
		Error(ghwndApp, IDS_INSERTAUDIODISC);
	    }
	    else
		gfCurrentCDNotAudio = FALSE;

	    gfCurrentCDChecked = TRUE;
	}
    }
    else
    {
	gfCurrentCDChecked = FALSE; // Otherwise, make sure it gets cleared.
	gfCurrentCDNotAudio = FALSE;
    }


    /* Here's the problem:  If the medium is short, we'll send a Play command */
    /* but it'll stop before we notice it was ever playing.  So if we know    */
    /* that we just sent a PlayMCI command, but the status isn't PLAY, then   */
    /* force the last command to be PLAY.  Also, once we notice we are playing*/
    /* we can clear gfJustPlayed.                                             */

    if (wStatusMCI == MCI_MODE_PLAY && gfJustPlayed)
	gfJustPlayed = FALSE;
    if (((wStatusMCI == MCI_MODE_STOP) || (wStatusMCI == MCI_MODE_SEEK)) && gfJustPlayed) {
	gwStatus = MCI_MODE_PLAY;
	gfJustPlayed = FALSE;
    }

    if (wStatusMCI == MCI_MODE_SEEK) {
	// The second major problem is this.  During rewind the status
	// is SEEK.  If we detect MODE_SEEK we will not restart the play,
	// and it looks like the auto replay simply ended.  Seeking back to
	// the beginning can take a significant amount of time.  We allow
	// ourselves to wait for up to half a second to give the device,
	// particularly AVI from a CD or over the network, a chance to
	// catch up.  Any slower response and the autorepeat will terminate.
	dwPosition = gdwLastSeekToPosition;
	if (!gfUserStopped && (gwOptions&OPT_AUTOREP)) {
	    UINT n=15;
	    for (; n; --n) {

		Sleep(32);
		// If autorepeating and device is seeking, try the status
		// again in case it has got back to the beginning
		wStatusMCI = StatusMCI(&dwPosition);

		if (wStatusMCI != MCI_MODE_SEEK) {
		    wStatusMCI = MCI_MODE_STOP;
		    break; // Exit the FOR loop
		} else {
		    dwPosition = gdwLastSeekToPosition;
		}
	    }
	}
    }

    /*
     * The current device status has
     * changed from the way MPlayer last perceived it, so update the display
     * and make MPlayer agree with MCI again.
     *
     */

    // After we close, our last timer msg must gray stuff and execute this //
    if (!gwDeviceID || wStatusMCI != gwStatus) {
	DWORD    dwEndMedia, dwStartSel, dwEndSel, dwEndSelDelta;

	/* Auto-repeat and Rewind happen if you stop at the end of the media */
	/* (rewind to beginning) or if you stop at the end of the selection  */
	/* (rewind to beginning of selection).                               */

	dwEndMedia = MULDIV32(gdwMediaLength + gdwMediaStart, 99, 100L);
	dwStartSel = (DWORD)SendMessage(ghwndTrackbar, TBM_GETSELSTART, 0, 0);
	dwEndSel = (DWORD)SendMessage(ghwndTrackbar, TBM_GETSELEND, 0, 0);
	if (dwEndSel != -1) {
	    dwEndSelDelta = MULDIV32(dwEndSel, 99, 100L);
	} else {
	    dwEndSelDelta = 0; // force (dwPosition >= dwEndSelDelta) to FALSE
	}

	if ((wStatusMCI == MCI_MODE_STOP || wStatusMCI == MCI_MODE_PAUSE)
	  && ((dwPosition >= dwEndMedia) || (dwPosition==0) ||
		(dwPosition >= dwEndSelDelta && gfJustPlayedSel))
	  && dwPosition >= gdwMediaStart  // dwPosition may == the beginning
	  && !gfScrollTrack
	  && (gwStatus == MCI_MODE_PLAY || gwStatus == MCI_MODE_SEEK)) {

	    DPF("End of medium\n");

	    /* We're at the end of the entire media or at the end of  */
	    /* our selection now, and stopped automatically (not      */
	    /* by the user).  We were playing or seeking.  So         */
	    /* we can check the Auto Repeat and Auto Rewind flags.    */
	    /* CD players seem to return a length that's too big, so  */
	    /* we check for > 99% done.  Use semaphore to keep from   */
	    /* causing an infinite loop.                              */

	    if (!gfUserStopped && (gwOptions & OPT_AUTOREP)) {
		DPF("Auto-Repeat\n");
		sfBlock = TRUE;    // calls UpdateDisplay which will
				   // re-enter this code just before mode

		/* Repeat either the selection or whole thing.       */
		/* NOTE: Must send message while gwStatus is STOPPED.*/

		gwStatus = wStatusMCI;    // old status no longer valid
		if (gfJustPlayedSel && dwPosition >= dwEndSelDelta)
		{
		    SeekMCI(dwStartSel); // MCICDA doen't go to start w/out this.
		    SendMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_PLAYSEL, 0);
		}
		else
		{
		    SeekToStartMCI();
		    SendMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_PLAY, 0);
		}

		sfBlock = FALSE;    // switches to SEEK.
		gwStatus = (UINT)(-1);  // old status no longer valid
		return;                // because we are switching modes

	    } else if (!gfCloseAfterPlaying && !gfUserStopped &&
			(gwOptions & OPT_AUTORWD)) {
		DPF("Auto-Rewind to media start\n");
		//
		// set gwStatus so SeekMCI will just seek!
		sfBlock = TRUE;    // calls UpdateDisplay which will
		// re-enter this code just before mode
		// switches to SEEK.

		/* Rewind either the selection or whole thing. */
		gwStatus = wStatusMCI;    // or SeekMCI will play, too.
		if (gfJustPlayedSel && dwPosition >= dwEndSelDelta)
		    {
		    SeekMCI(dwStartSel);
			    }
		else
			    {
		    SeekToStartMCI();
			}
		sfBlock = FALSE;
		gwStatus = (UINT)(-1);  // old status no longer valid
		return;    // because we are switching modes
	    }
	    else if (gfCloseAfterPlaying)
		PostCloseMessage();
	}

	/*
	 * Enable or disable the various controls according to the new status,
	 * following the rules given in the header to this function.
	 *
	 */

	EnableWindow(ghwndTrackbar, TRUE); // Good to always have something enabled

	/* Show status bar if full mplayer and if device loaded */
	if (ghwndStatic && !gfPlayOnly)
	{
	    if (IsWindowVisible(ghwndStatic) != (gwDeviceID ? TRUE : FALSE))
	    {
		ShowWindow(ghwndStatic, gwDeviceID ? SW_SHOW : SW_HIDE);
		InvalidateRect(ghwndApp, NULL, TRUE);
	    }
	}

	if (gwDeviceID != (UINT)0 ) {

	    switch (wStatusMCI)
	    {
	    case MCI_MODE_PLAY:
		toolbarSetFocus(ghwndToolbar,BTN_PAUSE);
		break;

	    case MCI_MODE_PAUSE:
	    case MCI_MODE_STOP:
		toolbarSetFocus(ghwndToolbar,BTN_PLAY);
		break;
	    }
	}

	if (wStatusMCI == MCI_MODE_OPEN || wStatusMCI == MCI_MODE_NOT_READY ||
	    gwDeviceID == (UINT)0 ||
	    ((gwDeviceType & DTMCI_DEVICE) == DTMCI_CDAUDIO) && gfCurrentCDNotAudio) {
	    /* Try to modify both -- one of them should work */

	    toolbarModifyState(ghwndToolbar, BTN_PLAY, TBINDEX_MAIN, BTNST_GRAYED);
	    toolbarModifyState(ghwndToolbar, BTN_PAUSE, TBINDEX_MAIN, BTNST_GRAYED);

	    toolbarModifyState(ghwndToolbar, BTN_HOME, TBINDEX_MAIN, BTNST_GRAYED);
	    toolbarModifyState(ghwndToolbar, BTN_END, TBINDEX_MAIN, BTNST_GRAYED);
	    toolbarModifyState(ghwndToolbar, BTN_RWD, TBINDEX_MAIN, BTNST_GRAYED);
	    toolbarModifyState(ghwndToolbar, BTN_FWD, TBINDEX_MAIN, BTNST_GRAYED);

	    SendMessage(ghwndTrackbar, TBM_SETRANGEMIN, (WPARAM)FALSE, 0);
	    SendMessage(ghwndTrackbar, TBM_SETRANGEMAX, (WPARAM)FALSE, 0);
	    SendMessage(ghwndTrackbar, TBM_CLEARTICS, (WPARAM)FALSE, 0);
	    SendMessage(ghwndTrackbar, TBM_CLEARSEL, (WPARAM)TRUE, 0);

	    if (ghwndMark) {
		toolbarModifyState(ghwndMark, BTN_MARKIN, TBINDEX_MARK, BTNST_GRAYED);
		toolbarModifyState(ghwndMark, BTN_MARKOUT, TBINDEX_MARK, BTNST_GRAYED);
	    }

	    if (ghwndFSArrows) {
		toolbarModifyState(ghwndFSArrows, ARROW_NEXT, TBINDEX_ARROWS, BTNST_GRAYED);
		toolbarModifyState(ghwndFSArrows, ARROW_PREV, TBINDEX_ARROWS, BTNST_GRAYED);
	    }

	/* Enable transport and Mark buttons if we come from a state where */
	/* they were gray.  Layout will then re-gray the ones that         */
	/* shouldn't have been enabled because they don't fit.             */
	} else if (gwStatus == MCI_MODE_OPEN || gwStatus == MCI_MODE_NOT_READY
		   || gwStatus == -1 ) {

	    /* Only one of these buttons exists */
	    toolbarModifyState(ghwndToolbar, BTN_PLAY, TBINDEX_MAIN, BTNST_UP);
	    toolbarModifyState(ghwndToolbar, BTN_PAUSE, TBINDEX_MAIN, BTNST_UP);

	if (!gfPlayOnly || gfOle2IPEditing) {
		toolbarModifyState(ghwndToolbar, BTN_HOME, TBINDEX_MAIN, BTNST_UP);
		toolbarModifyState(ghwndToolbar, BTN_END, TBINDEX_MAIN, BTNST_UP);
		toolbarModifyState(ghwndToolbar, BTN_RWD, TBINDEX_MAIN, BTNST_UP);
		toolbarModifyState(ghwndToolbar, BTN_FWD, TBINDEX_MAIN, BTNST_UP);

		if (ghwndMark) {
		    toolbarModifyState(ghwndMark, BTN_MARKIN, TBINDEX_MARK, BTNST_UP);
		    toolbarModifyState(ghwndMark, BTN_MARKOUT, TBINDEX_MARK, BTNST_UP);
		}
		if (ghwndFSArrows) {
		    toolbarModifyState(ghwndFSArrows, ARROW_PREV, TBINDEX_ARROWS, BTNST_UP);
		    toolbarModifyState(ghwndFSArrows, ARROW_NEXT, TBINDEX_ARROWS, BTNST_UP);
		}
	    }
	    /* AND we need to call layout to gray the buttons that are too
	     * short to fit in this window right now.
	     */
	    Layout();
	}

	//
	// always have the stop button if we are playing in place
	//
	if ((gwDeviceID != (UINT)0) &&
	    (wStatusMCI == MCI_MODE_PAUSE ||
	    wStatusMCI == MCI_MODE_PLAY ||
	    wStatusMCI == MCI_MODE_SEEK || gfPlayingInPlace)) {

	    if (toolbarStateFromButton(ghwndToolbar, BTN_STOP, TBINDEX_MAIN) == BTNST_GRAYED)
		toolbarModifyState(ghwndToolbar, BTN_STOP, TBINDEX_MAIN, BTNST_UP);

	} else {
	    toolbarModifyState(ghwndToolbar, BTN_STOP, TBINDEX_MAIN, BTNST_GRAYED);
	}

    if (!gfPlayOnly || gfOle2IPEditing) {
	    if ((gwDeviceID != (UINT)0) && (gwDeviceType & DTMCI_CANEJECT))
		toolbarModifyState(ghwndToolbar, BTN_EJECT, TBINDEX_MAIN, BTNST_UP);
	    else
		toolbarModifyState(ghwndToolbar, BTN_EJECT, TBINDEX_MAIN, BTNST_GRAYED);

	    EnableWindow(ghwndMap, (gwDeviceID != (UINT)0));
    }

// WHO had the idea that setting focus back to play every
// time the status changes was a good idea ??
	/* Only set focus if we won't take activation by doing so */
	//VIJRif (gfAppActive) {
	    if (wStatusMCI == MCI_MODE_NOT_READY) {
		//if (gfAppActive)
		    //SetFocus(ghwndToolbar); //Setting focus messes up menu access
									  //using the ALT key
	    } else if (wStatusMCI != MCI_MODE_SEEK &&
		       gwStatus != MCI_MODE_SEEK) {
		if (wStatusMCI == MCI_MODE_PLAY) {
		    //VIJR SetFocus(ghwndToolbar); // give focus to PAUSE button
		    toolbarSetFocus(ghwndToolbar, BTN_PAUSE);
		} else {
		    //VIJR SetFocus(ghwndToolbar); // give focus to PLAY button
		    toolbarSetFocus(ghwndToolbar, BTN_PLAY);
		    if (wStatusMCI == MCI_MODE_OPEN || wStatusMCI == MCI_MODE_NOT_READY ||
				gwDeviceID == (UINT)0) {
				/* Try to modify both -- one of them should work */
				toolbarModifyState(ghwndToolbar, BTN_PLAY, TBINDEX_MAIN, BTNST_GRAYED);
		    }
		}
	    }
	//VIJR}

	if (wStatusMCI == MCI_MODE_OPEN || gwStatus == MCI_MODE_OPEN
		|| gwStatus == MCI_MODE_NOT_READY
		|| wStatusMCI == MCI_MODE_NOT_READY) {

	    /* Either the medium was just ejected, or it was just
	     * re-inserted -- in either case, the media information (length,
	     * # of tracks, etc.) is currently invalid and needs to be updated.
	     */

	    gfValidMediaInfo = FALSE;
	}

	/*
	 * Set <gwStatus> to agree with what MCI tells us, and update the
	 * display accordingly.
	 *
	 */

	gwStatus = wStatusMCI;
	gfValidCaption = FALSE;
    }

    /*
     * The previous code may have invalidated the Media again, so we'll update
     * now instead of waiting for the next UpdateDisplay call.
     *
     */

    if (!gfValidMediaInfo)
	UpdateMCI();                /* update the appropriate global variables*/

    /* If the caption is not valid, then update it */

    if (!gfValidCaption) {

	TCHAR  ach[_MAX_PATH * 2 + 60];   // string used for the window caption
	TCHAR  achWhatToPrint[_MAX_PATH * 2 + 40];  // room for doc title too

	if (gfPlayOnly) {
	    if (gwDeviceID == (UINT)0)
		lstrcpy(ach, gachAppName);      /* just use the app name */
	    else
		lstrcpy(ach, gachWindowTitle);  /* just use device */
	} else {
	    /* Latest style guide says title bars should have
	     * <object> - <appname>, so do that for anything
	     * other than NT:
	     */
	    if (gwPlatformId == VER_PLATFORM_WIN32_NT)
		wsprintf(achWhatToPrint, aszTitleFormat, gachAppName,
			 gachWindowTitle);
	    else
		wsprintf(achWhatToPrint, aszTitleFormat, gachWindowTitle,
			 gachAppName);

	    if (gwDeviceID == (UINT)0) {
		lstrcpy(ach, gachAppName);      /* just display the app name  */
	    } else if (gwStatus == MCI_MODE_NOT_READY) {
		wsprintf(ach, aszNotReadyFormat,
			 achWhatToPrint);   /*  the current file / device */
	    } else {
		wsprintf(ach, aszReadyFormat,
			 achWhatToPrint,    /*  the current file / device */
			 MapModeToStatusString((WORD)wStatusMCI));
	    }
	}

	if (gfEmbeddedObject) {
	    if (!SetTitle((LPDOC)&docMain, szClientDoc))
		UpdateWindowText(ghwndApp, ach);

	    SetMPlayerIcon();

	} else {
	    UpdateWindowText(ghwndApp, ach);
	}

	gfValidCaption = TRUE;

    }

    /* Update the scrollbar thumb position unless the user is dragging it */
    /* or the media is current seeking to a previously requested position. */

    if (!gfScrollTrack && gfValidMediaInfo && wStatusMCI != MCI_MODE_SEEK) {
	TCHAR ach[40];
		
	if (ghwndStatic) {
	    FormatTime(dwPosition, NULL, ach, TRUE);
	    WriteStatusMessage(ghwndStatic, ach);
	}
	SendMessage(ghwndTrackbar, TBM_SETPOS, (WPARAM)TRUE, dwPosition);
    }

    /* Finish any required window painting immediately */

    if (gfOle2IPEditing && wStatusMCI == MCI_MODE_STOP &&
	((gwDeviceType & DTMCI_DEVICE) == DTMCI_AVIVIDEO))
    {
	RedrawWindow(ghwndTrackbar, NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW);
    }
    UpdateWindow(ghwndApp);
}


/*
 * EnableTimer(fEnable)
 *
 * Enable the display-update timer if <fEnable> is TRUE.
 * Disable the timer if <fEnable> is FALSE.
 *
 */

void FAR PASCAL EnableTimer(BOOL fEnable)
{
    DPF("EnableTimer(%d)  %dms\n", fEnable, gfAppActive ? UPDATE_MSEC : UPDATE_INACTIVE_MSEC);

    if (fEnable)
	SetTimer(ghwndApp, UPDATE_TIMER,
		 gfAppActive ? UPDATE_MSEC : UPDATE_INACTIVE_MSEC, NULL);
    else
	KillTimer(ghwndApp, UPDATE_TIMER);
}


void FAR PASCAL Layout(void)
{
    RECT    rcClient, rc;
    int     iYOffset;
    UINT    wWidth;
    UINT    wFSArrowsWidth = 2 * FSARROW_WIDTH - 1; // 2 arrow buttons wide
    UINT    wFSArrowsHeight = FSARROW_HEIGHT;
    UINT    wFSTrackHeight = FSTRACK_HEIGHT;
    UINT    wFSTrackWidth;
    UINT    wToolbarWidth;
    UINT    wMinStatusWidth = 0;
    int     iYPosition;
    BOOL    fShowMark;
    BOOL    fShowTrackbar;
    BOOL    fShowStatus;
    HDWP    hdwp;
    int     nState;     // The status of the transport buttons (when visible)
    DWORD_PTR   dw;         // the current position within the medium
    UINT    wStatusMCI; // status of the device according to MCI
    UINT    wBaseUnits;
    BOOL    fRedrawFrame;
    SIZE    StatusTextExtent;
    BOOL    fRepaintToolbar;    // TRUE if we remove or add something to toolbar area

    /* OK to execute if we're hidden to set ourselves up for being shown */

    if (sfInLayout || IsIconic(ghwndApp))
	return;

    if (gfInPlayMCI) {
	DPF("Layout() called when in PlayMCI().  Posting message to Layout() later.\n");
	/* Don't allow this to happen, because Layout() may cause a call to
	 * MCI_PUT (via SetWindowPos(ghwndMCI)), which will result in a
	 * device-not-ready error, as the MCI_PLAY hasn't completed.
	 */
	PostMessage(ghwndApp, WM_DOLAYOUT, 0, 0);
	return;
    }

    sfInLayout = TRUE;

#ifdef DEBUG
    GetWindowRect(ghwndApp, &rc);
    DPF("***** Layout Window Rect *****  %d %d\n", rc.right - rc.left, rc.bottom - rc.top);
#endif

    if (gfPlayOnly) {

	extern UINT gwPlaybarHeight;    // in server.c

#define XSLOP   0
#define XOFF    2


	if (gfOle2IPEditing || gfOle2IPPlaying)
	{
	    /* Don't call GetClientrect, because the window may have a border,
	     * and this will cause us to shrink the window.
	     * Note this is a hack to get around the problem of the window
	     * changing size when it is in place, making some displays dither
	     * the video in a disgusting manner.
	     */
	    GetWindowRect(ghwndApp, &rc);
	    rc.right -= rc.left;
	    rc.bottom -= rc.top;
	    rc.left = rc.top = 0;
	}
	else
	    GetClientRect(ghwndApp, &rc);

	rc.bottom -= gwPlaybarHeight;

#if 0
	/* If we set WS_MAXIMIZE, user doesn't allow the window to be
	 * sized on NT.  What's the idea behind this code anyway?
	 */

	if (ghwndMCI && !EqualRect(&rc, &grcSize))
	    fRedrawFrame = SetWS(ghwndApp, WS_MAXIMIZE /* |WS_MAXIMIZEBOX */);
	else if (ghwndMCI)
	    fRedrawFrame = //SetWS(ghwndApp, WS_MAXIMIZEBOX) ||
			   ClrWS(ghwndApp, WS_MAXIMIZE);
	else
	    fRedrawFrame = ClrWS(ghwndApp, WS_MAXIMIZEBOX);
#endif
	fRedrawFrame = FALSE;

	/* Here's another horrible hack.
	 * When you try to Play an in-place video after an Open (OLE),
	 * the toolbar and trackbar don't get drawn correctly.
	 * I haven't figured out why this is, but forcing a redraw
	 * seems to fix it.  This code gets executed only when the window
	 * position changes, so it isn't too much of a hit.
	 */
	if (gfOle2IPEditing || gfOle2IPPlaying)
	    fRedrawFrame = TRUE;

	if (fRedrawFrame)
	    SetWindowPos(ghwndApp,
			 NULL,
			 0,
			 0,
			 0,
			 0,
	      SWP_DRAWFRAME|SWP_NOZORDER|SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE);

	if (ghwndMCI)
	    SetWindowPos(ghwndMCI,
			 NULL,
			 0,
			 0,
			 rc.right,
			 rc.bottom,
			 SWP_NOZORDER|SWP_NOACTIVATE);

	//  If we are inplace editing place controls on the ghwndIPToolWindow
	//  and the static window at the bottom of ghwndApp.
	if(gfOle2IPEditing) {

	    SendMessage(ghwndTrackbar, TBM_SHOWTICS, TRUE, FALSE);

	    SetWindowPos(ghwndStatic,
			 NULL,
			 3,
			 rc.bottom + 2 + (gwPlaybarHeight - TOOLBAR_HEIGHT)/2,
			 rc.right - rc.left - 8,
			 TOOLBAR_HEIGHT-7,
			 SWP_NOZORDER|SWP_NOACTIVATE);

	// Why are we getting the Status here when we have a global that
	// contains it?  Because gwStatus is set in UpdateDisplay, but
	// Layout() is called by UpdateDisplay, so the global is not always
	// set properly when this code runs.  BUT!  We must NOT pass a string
	// to StatusMCI() or it will think UpdateDisplay() called it, and
	// not tell UpdateDisplay() the proper mode next time it asks for it,
	// because it will think that it already knows it.

	    wStatusMCI = StatusMCI(NULL);
	    nState = (wStatusMCI == MCI_MODE_OPEN
		       || wStatusMCI == MCI_MODE_NOT_READY
		       || gwDeviceID == (UINT) 0)
		     ? BTNST_GRAYED
		     : BTNST_UP;

	    toolbarModifyState(ghwndToolbar, BTN_HOME, TBINDEX_MAIN, nState);
	    toolbarModifyState(ghwndToolbar, BTN_RWD, TBINDEX_MAIN, nState);
	    toolbarModifyState(ghwndToolbar, BTN_FWD, TBINDEX_MAIN, nState);
	    toolbarModifyState(ghwndToolbar, BTN_END, TBINDEX_MAIN, nState);

	    ShowWindow(ghwndTrackbar, SW_SHOW);
	    ShowWindow(ghwndToolbar, SW_SHOW);
	    ShowWindow(ghwndStatic, SW_SHOW);
	    ShowWindow(ghwndFSArrows, SW_SHOW);
	    ShowWindow(ghwndMark, SW_SHOW);
	    ShowWindow(ghwndMap, SW_SHOW);

	    if (ghwndIPToolWindow && (ghwndIPToolWindow != GetParent(ghwndTrackbar))
		      && (ghwndIPScrollWindow != GetParent(ghwndTrackbar)))
	    {
		SetParent(ghwndTrackbar,ghwndIPToolWindow);
		SetWindowPos(ghwndTrackbar, NULL,4,TOOL_WIDTH+2,
		     11*BUTTONWIDTH+3,FSTRACK_HEIGHT,SWP_NOZORDER | SWP_NOACTIVATE);
		SetParent(ghwndMap,ghwndIPToolWindow);
		SetWindowPos(ghwndMap, NULL,4,TOOL_WIDTH+FSTRACK_HEIGHT+2+2,
		     11*BUTTONWIDTH+50,MAP_HEIGHT,SWP_NOZORDER | SWP_NOACTIVATE);
	    }
	    CalcTicsOfDoom();

	} else {

#define LEFT_MARGIN 1

	    SendMessage(ghwndTrackbar, TBM_SHOWTICS, FALSE, FALSE);

	    SetWindowPos(ghwndToolbar,
			 NULL,
			 LEFT_MARGIN,
			 rc.bottom + 2 + (gwPlaybarHeight - TOOLBAR_HEIGHT)/2,
			 XSLOP + 2 * (BUTTONWIDTH - XOFF),
			 TOOLBAR_HEIGHT,
			 SWP_NOZORDER|SWP_NOACTIVATE);

	    SetWindowPos(ghwndTrackbar,
			 NULL,
			 XSLOP + 2 * (BUTTONWIDTH - XOFF) + LEFT_MARGIN,
			 rc.bottom + (gwPlaybarHeight - TOOLBAR_HEIGHT)/2 + 1,
			 rc.right-rc.left-(2 * XSLOP + 2 *(BUTTONWIDTH - XOFF) - LEFT_MARGIN),
			 TOOLBAR_HEIGHT - 1,
			 SWP_NOZORDER | SWP_NOACTIVATE);

	    // HACK!!!
	    // If we aren't visible, officially disable ourselves so that the
	    // trackbar shift code won't try and set selection

	    ShowWindow(ghwndTrackbar, gwPlaybarHeight > 0 ? SW_SHOW : SW_HIDE);
	    ShowWindow(ghwndToolbar, gwPlaybarHeight > 0 ? SW_SHOW : SW_HIDE);
	    ShowWindow(ghwndStatic, SW_HIDE);
	    ShowWindow(ghwndFSArrows, SW_HIDE);
	    ShowWindow(ghwndMark, SW_HIDE);
	    ShowWindow(ghwndMap, SW_HIDE);
	}

	goto Exit_Layout;
    }

    fRedrawFrame = ClrWS(ghwndApp, WS_MAXIMIZEBOX);

    if (fRedrawFrame)
	SetWindowPos(ghwndApp, NULL, 0, 0, 0, 0, SWP_DRAWFRAME|
	    SWP_NOZORDER|SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE);

    if (GetMenu(ghwndApp) != ghMenu)
	SetMenu(ghwndApp, ghMenu);

    wBaseUnits = LOWORD(GetDialogBaseUnits());  // prop. to size of system font

    /* If we're bigger than we're allowed to be then shrink us right now */
    GetWindowRect(ghwndApp, &rc);

    gwHeightAdjust = GetHeightAdjust(ghwndApp);

    DPF1("Layout: WindowRect = %x, %x, %x, %x\n", rc);

    if (rc.bottom - rc.top != (int)(MAX_NORMAL_HEIGHT + gwHeightAdjust)) {
	MoveWindow(ghwndApp,
		   rc.left,
		   rc.top,
		   rc.right - rc.left,
		   (int)(MAX_NORMAL_HEIGHT + gwHeightAdjust),
		   TRUE);
    }


    hdwp = BeginDeferWindowPos(6);

    if (!hdwp)
	goto Exit_Layout;

    GetClientRect(ghwndApp, &rcClient);    // get new size

    wWidth = rcClient.right;

    iYOffset = rcClient.bottom - MAX_NORMAL_HEIGHT + 2;    // start here

    /* ??? Hide the trackbar if it can't fit on completely ??? */
    iYPosition = iYOffset >= 0 ? iYOffset :
		((iYOffset >= - 9) ? iYOffset + 9 : 1000);

    fShowTrackbar = (iYOffset >= - 9);

    /* Focus in on trackbar which is about to go away */
    if (!fShowTrackbar && GetFocus() == ghwndTrackbar)
	SetFocus(ghwndToolbar);

    ShowWindow(ghwndToolbar, SW_SHOW);

/* The space that COMMCTRL puts to the left of the first toolbar button:
 */
#define SLOPLFT 0
#define XOFF1   8

    // how long did it end up being?
    wFSTrackWidth = wWidth - SB_XPOS - 1 - wFSArrowsWidth - SLOPLFT;

    DeferWindowPos(hdwp,
		   ghwndTrackbar,
		   HWND_TOP,
		   SB_XPOS,
		   iYPosition,
		   wFSTrackWidth,
		   wFSTrackHeight,
		   SWP_NOZORDER | SWP_NOREDRAW |
		       (fShowTrackbar ? SWP_SHOWWINDOW : SWP_HIDEWINDOW));


    /* Toolbar positioning:
     *
     * If the window is not wide enough to accommodate all the buttons
     * and status bar, here's what we do:
     *
     * If the status bar is invisible, first remove the mark buttons,
     * then use the small control width (with only three buttons).
     *
     * If the status bar is visible, give it priority over the mark
     * buttons and the extra controls, but remove it if there isn't
     * room for it and the small control width.
     */

    if (gwDeviceID)
    {
	fShowStatus = TRUE;

	if (GetStatusTextExtent(ghwndStatic, &StatusTextExtent))
	{
	    RECT rc;
	    LONG StatusWidth;   /* Total width of status window */
	    LONG TextAreaWidth; /* Width minus border and size grip */

	    /* Allow for the border around the status window:
	     */
	    GetWindowRect(ghwndStatic, &rc);
	    StatusWidth = rc.right - rc.left;

	    SendMessage(ghwndStatic, SB_GETRECT, 0, (LPARAM)&rc);
	    TextAreaWidth = rc.right - rc.left;

	    wMinStatusWidth = StatusTextExtent.cx + (StatusWidth - TextAreaWidth) + 16;
	}
    }
    else
    {
	fShowStatus = FALSE;
    }

    wToolbarWidth = LARGE_CONTROL_WIDTH + SLOPLFT;
    fShowMark = TRUE;

    if (wWidth < LARGE_CONTROL_WIDTH + SLOPLFT + MARK_WIDTH + XOFF1 + wMinStatusWidth)
    {
	fShowMark = FALSE;

	if (wWidth < LARGE_CONTROL_WIDTH + SLOPLFT + wMinStatusWidth)
	    wToolbarWidth = SMALL_CONTROL_WIDTH + SLOPLFT;

	if (wWidth < SMALL_CONTROL_WIDTH + SLOPLFT + wMinStatusWidth)
	    fShowStatus = FALSE;
    }

    fRepaintToolbar = FALSE;

    /* If we're adding or removing the mark buttons or the status window,
     * make sure we repaint things so that the separator bar corresponds.
     * (It should separate the status window from the buttons, but should
     * go away when the status window does.)
     */
    if (IsWindowVisible(ghwndStatic) != fShowStatus)
	fRepaintToolbar = TRUE;
    else if (IsWindowVisible(ghwndMark) != fShowMark)
	fRepaintToolbar = TRUE;

    ShowWindow(ghwndStatic, fShowStatus);

    /* Turn off the toolbar (for tabbing) if it's not going to be there */
    /* and if we're disabled, we better not keep the focus.             */
    if (!fShowMark) {
	if (GetFocus() == ghwndMark)
	    SetFocus(ghwndToolbar);  // can't give it to SB, might be gone too
	EnableWindow(ghwndMark, FALSE);
    } else
	EnableWindow(ghwndMark, TRUE);

    DeferWindowPos(hdwp,
		   ghwndFSArrows,
		   HWND_TOP,
		   SB_XPOS + wFSTrackWidth,
//                 wWidth - 1 - wFSArrowsWidth,
		   iYPosition + 2,
		   wFSArrowsWidth + SLOPLFT,
		   wFSArrowsHeight + 4, /* Er, 4 because it works */
		   SWP_NOZORDER);

    iYOffset += wFSTrackHeight;

    DeferWindowPos(hdwp,
		   ghwndMap,
		   HWND_TOP,
		   SB_XPOS,
		   iYOffset,
		   wWidth - SB_XPOS,
		   MAP_HEIGHT,
		   SWP_NOZORDER | SWP_NOREDRAW |
		      (fShowTrackbar ? SWP_SHOWWINDOW : SWP_HIDEWINDOW));
    iYOffset += MAP_HEIGHT;

    /* Do we show the last four buttons on the main toolbar? */
    /* If not, then disable them for tabs and such.          */
    if (wToolbarWidth == LARGE_CONTROL_WIDTH + SLOPLFT)
    {

	// Why are we getting the Status here when we have a global that
	// contains it?  Because gwStatus is set in UpdateDisplay, but
	// Layout() is called by UpdateDisplay, so the global is not always
	// set properly when this code runs.  BUT!  We must NOT pass a string
	// to StatusMCI() or it will think UpdateDisplay() called it, and
	// not tell UpdateDisplay() the proper mode next time it asks for it,
	// because it will think that it already knows it.

	wStatusMCI = StatusMCI(&dw);
	nState = (wStatusMCI == MCI_MODE_OPEN
		    || wStatusMCI == MCI_MODE_NOT_READY
		    || gwDeviceID == (UINT)0) ? BTNST_GRAYED : BTNST_UP;

	toolbarModifyState(ghwndToolbar, BTN_HOME, TBINDEX_MAIN, nState);
	toolbarModifyState(ghwndToolbar, BTN_RWD, TBINDEX_MAIN, nState);
	toolbarModifyState(ghwndToolbar, BTN_FWD, TBINDEX_MAIN, nState);
	toolbarModifyState(ghwndToolbar, BTN_END, TBINDEX_MAIN, nState);
	toolbarModifyState(ghwndToolbar, BTN_PLAY, TBINDEX_MAIN, nState);
    }
    else
    {
	toolbarModifyState(ghwndToolbar, BTN_HOME, TBINDEX_MAIN, BTNST_GRAYED);
	toolbarModifyState(ghwndToolbar, BTN_RWD, TBINDEX_MAIN, BTNST_GRAYED);
	toolbarModifyState(ghwndToolbar, BTN_FWD, TBINDEX_MAIN, BTNST_GRAYED);
	toolbarModifyState(ghwndToolbar, BTN_END, TBINDEX_MAIN, BTNST_GRAYED);
    }

    DeferWindowPos(hdwp,
		   ghwndToolbar,
		   HWND_TOP,
		   2,
		   iYOffset + 2,
		   wToolbarWidth,
		   TOOLBAR_HEIGHT,
		   SWP_NOZORDER);

    DeferWindowPos(hdwp,
		   ghwndMark,
		   HWND_TOP,
		   wToolbarWidth + XOFF1,
		   iYOffset + 2,
		   MARK_WIDTH,
		   TOOLBAR_HEIGHT,
		   SWP_NOZORDER | (fShowMark ? SWP_SHOWWINDOW : SWP_HIDEWINDOW));

#define ARBITRARY_Y_OFFSET  4

    DeferWindowPos(hdwp,
		   ghwndStatic,
		   HWND_TOP,
		   wToolbarWidth + (fShowMark ? MARK_WIDTH + XOFF1 : 0) + XOFF1,
		   iYOffset + ARBITRARY_Y_OFFSET,
		   wWidth - (wToolbarWidth + 3) -
		      (fShowMark ? MARK_WIDTH + XOFF1 : 0) - XOFF1,
		   TOOLBAR_HEIGHT - 6,
		   SWP_NOZORDER);

    EndDeferWindowPos(hdwp);

    if (fRepaintToolbar)
    {
	InvalidateRect(ghwndApp, NULL, TRUE);
    }

    CalcTicsOfDoom();

/* These little gems have just cost me about ten hours worth of debugging -
 * note the useful and descriptive comments...
 *
 * The Win32 problem caused by this only arises with CD Audio, when the disk is
 * ejected and then another one is inserted into the drive. At that point
 * the redrawing misses out the Trackmap FSArrows, the borders on the
 * Mark buttons, and various bits of the toolbar.
 *
 * I will leave this here on the assumption that whichever bout 
 * on Win16 they are intended to fix still exists - it certainly doesn't on
 * Win32.
 */


Exit_Layout:
    sfInLayout = FALSE;
    return;
}


/* What is the previous mark from our current spot? */
LONG_PTR CalcPrevMark(void)
{
    LONG_PTR lStart, lEnd, lPos, lTol, lTrack = -1, lTarget;
    LONG_PTR l;

    lStart = SendMessage(ghwndTrackbar, TBM_GETSELSTART, 0, 0);
    lEnd = SendMessage(ghwndTrackbar, TBM_GETSELEND, 0, 0);
    lPos = SendMessage(ghwndTrackbar, TBM_GETPOS, 0, 0);

    /* Find the next track we should go to (ignore selection markers) */
    if (gwCurScale == ID_TRACKS) {
	lTol = (LONG)gdwMediaLength / 2000;
	for (l = (LONG)gwNumTracks - 1; l >= 0; l--) {
	    if (gadwTrackStart[l] < (DWORD)lPos - lTol) {
		lTrack = gadwTrackStart[l];
		break;
	    }
	}
    }

    /* For msec mode:                                                     */
    /* Our current position fluctuates randomly and even if we're dead on */
    /* a selection mark, it might say we're a little before or after it.  */
    /* So we'll allow a margin for error so that you don't forever stay   */
    /* still while you hit PrevMark because it happens to be saying you're*/
    /* always past the mark you're at.  The margin of error will be       */
    /* half the width of the thumb.                                       */

    if (gwCurScale == ID_FRAMES)
	lTol = 0L;
    else
	lTol = 0L;//VIJR-TBTrackGetLogThumbWidth(ghwndTrackbar) / 2;

    if (lEnd != -1 && lPos > lEnd + lTol)
	lTarget = lEnd;
    else if (lStart != -1 && lPos > lStart + lTol)
	lTarget = lStart;
    else
	lTarget = 0;

    /* go to the either the selection mark or the next track (the closest) */
    if (lTrack != -1 && lTrack > lTarget)
	lTarget = lTrack;

    return lTarget;
}

/* What is the next mark from our current spot? */
LONG_PTR CalcNextMark(void)
{
    LONG_PTR lStart, lEnd, lPos, lTol, lTrack = -1, lTarget;
    UINT_PTR w;

    lStart = SendMessage(ghwndTrackbar, TBM_GETSELSTART, 0, 0);
    lEnd = SendMessage(ghwndTrackbar, TBM_GETSELEND, 0, 0);
    lPos = SendMessage(ghwndTrackbar, TBM_GETPOS, 0, 0);

    /* Find the next track we should go to (ignore selection markers) */
    if (gwCurScale == ID_TRACKS) {
	lTol = (LONG)gdwMediaLength / 2000;
	for (w = 0; w < gwNumTracks; w++) {
	    if (gadwTrackStart[w] > (DWORD)lPos + lTol) {
		lTrack = gadwTrackStart[w];
		break;
	    }
	}
    }

    /* For msec mode:                                                     */
    /* Our current position fluctuates randomly and even if we're dead on */
    /* a selection mark, it might say we're a little before or after it.  */
    /* So we'll allow a margin for error so that you don't forever stay   */
    /* still while you hit NextMark because it happens to be saying you're*/
    /* always before the mark you're at.  The margin of error will be     */
    /* half the width of the thumb.                                       */

    if (gwCurScale == ID_FRAMES)
	lTol = 0L;
    else
	lTol = 0L;//VIJR-TBTrackGetLogThumbWidth(ghwndTrackbar) / 2;

    /* Find the selection mark we should go to */
    if (lStart != -1 && lPos < lStart - lTol)
	lTarget = lStart;
    else if (lEnd != -1 && lPos < lEnd - lTol)
	lTarget = lEnd;
    else
	lTarget = gdwMediaStart + gdwMediaLength;

    /* go to the either the selection mark or the next track (the closest) */
    if (lTrack != -1 && lTrack < lTarget)
	lTarget = lTrack;

    return lTarget;
}


HICON GetIconFromProgID(LPTSTR szProgID)
{
    DWORD Status;
    HKEY  hkeyDefaultIcon;
    BOOL  rc = FALSE;
    DWORD Type;
    DWORD Size;
    TCHAR szProgIDDefaultIcon[128];
    TCHAR szDefaultIcon[MAX_PATH+4];    /* <path>,N */
    HICON hicon = NULL;
    LPTSTR pIconIndex;
    UINT  IconIndex;

    wsprintf(szProgIDDefaultIcon, TEXT("%s\\DefaultIcon"), szProgID);

    Status = RegOpenKeyEx( HKEY_CLASSES_ROOT, szProgIDDefaultIcon, 0,
			   KEY_READ, &hkeyDefaultIcon );

    if (Status == NO_ERROR)
    {
	Size = CHAR_COUNT(szDefaultIcon);

	Status = RegQueryValueEx( hkeyDefaultIcon,
				  aszNULL,
				  0,
				  &Type,
				  (LPBYTE)szDefaultIcon,
				  &Size );

	if (Status == NO_ERROR)
	{
	    /* Find a comma in the string.  After it comes the icon index:
	     */
	    pIconIndex = STRCHR(szDefaultIcon, TEXT(','));

	    if (pIconIndex)
	    {
		/* Null terminate the file name:
		 */
		*pIconIndex = TEXT('\0');

		/* Get the index that comes after the comma:
		 */
		IconIndex = ATOI(pIconIndex+1);

		DPF1("Extracting icon #%d from %"DTS"\n", IconIndex, szDefaultIcon);

		hicon = ExtractIcon(ghInst, szDefaultIcon, IconIndex);
	    }

	}
	else
	{
	    DPF0("Couldn't find Default Icon for %"DTS"\n", szProgID);
	}

	RegCloseKey(hkeyDefaultIcon);
    }

    return hicon;
}



/* GetIconForCurrentDevice
 *
 * Checks what device is currently selected, and returns a handle to the
 * appropriate icon of the specified size.  If there is no current device,
 * returns either the application's icon or the default icon for media
 * documents.
 *
 * Parameters:
 *
 *     Size - GI_SMALL (for title bar) or GI_LARGE (for in-place icon).
 *
 *     DefaultID - Default to use if no current device.  APPICON or IDI_DDEFAULT.
 *
 * Return:
 *
 *     Icon handle
 *
 *
 * Andrew Bell (andrewbe), 31 March 1995
 */
HICON GetIconForCurrentDevice(UINT Size, UINT DefaultID)
{
    TCHAR  DeviceName[256];
    DWORD  i;
    LPTSTR ImageID = NULL;
    int    cx;
    int    cy;
    HICON  hIcon;

    GetDeviceNameMCI(DeviceName, BYTE_COUNT(DeviceName));

    if (DeviceName[0])
    {
	for (i = 0; i < sizeof DevToIconIDMap / sizeof *DevToIconIDMap; i++)
	{
	    if (!lstrcmpi(DeviceName, DevToIconIDMap[i].pString))
	    {
		ImageID = MAKEINTRESOURCE(DevToIconIDMap[i].ID);
		break;
	    }
	}
    }

    else
    {
	if (Size == GI_LARGE)
	{

	    hIcon = GetIconFromProgID(gachProgID);

	    if (hIcon)
	    {
		return hIcon;
	    }
	}
    }

    if (ImageID == NULL)
	ImageID = MAKEINTRESOURCE(DefaultID);

    cx = (Size == GI_SMALL ? GetSystemMetrics(SM_CXSMICON) : 0);
    cy = (Size == GI_SMALL ? GetSystemMetrics(SM_CYSMICON) : 0);

    hIcon = (HICON)LoadImage(ghInst, ImageID, IMAGE_ICON,
			     cx, cy, LR_DEFAULTSIZE);

    return hIcon;
}


/* SetMPlayerIcon
 *
 * Sets the icon based upon the current device.  Uses default document
 * icon if embedded, otherwise the application icon.
 *
 * Andrew Bell (andrewbe), 31 March 1995
 */
void SetMPlayerIcon()
{
    UINT DefaultID;

    DefaultID = gfEmbeddedObject ? IDI_DDEFAULT : APPICON;

    SendMessage(ghwndApp, WM_SETICON, FALSE,
		(LPARAM)GetIconForCurrentDevice(GI_SMALL, DefaultID));
}


/*--------------------------------------------------------------+
| AskUpdate -     ask the user if they want to update the       |
|                 object (if we're dirty).                      |
|                 IDYES means yes, go ahead and update please.  |
|                 IDNO means don't update, but continue.        |
|                 IDCANCEL means don't update, and cancel what  |
|                    you were doing.                            |
+--------------------------------------------------------------*/
int NEAR PASCAL AskUpdate(void)
{
    UINT         w;

    /* Don't update object if no device is loaded into mplayer! */
    if (IsObjectDirty() && gfDirty != -1 && gfEmbeddedObject && gwDeviceID) {

	if((glCurrentVerb == OLEIVERB_PRIMARY) && !gfOle2IPEditing)
	    return IDNO;
	//
	//  if we are a hidden MPlayer (most likely doing a Play verb) then
	//  update without asking?
	//
	if (!IsWindowVisible(ghwndApp) || gfOle2IPEditing)
	    return IDYES;

	w = ErrorResBox(ghwndApp, ghInst,
		MB_YESNOCANCEL | MB_ICONQUESTION,
		IDS_APPNAME, IDS_UPDATEOBJECT, szClientDoc);

    } else
	w = IDNO;

    return w;
}

void SizePlaybackWindow(int dx, int dy)
{
    RECT rc;
    HWND hwndPlay;

    if (gfPlayOnly) {
	SetRect(&rc, 0, 0, dx, dy);
	SetMPlayerSize(&rc);
    }
    else {
	if (dx == 0 && dy == 0) {
	    SetMPlayerSize(NULL);   // size MPlayer to default size
	    dx = grcSize.right;     // then size the playback window too.
	    dy = grcSize.bottom;
	}
	hwndPlay = GetWindowMCI();

	if (hwndPlay != NULL) {

	    /* make sure that the play window isn't iconized */

	    if (IsIconic(hwndPlay))
		return;

	    GetClientRect(hwndPlay, &rc);
	    ClientToScreen(hwndPlay, (LPPOINT)&rc);
	    SetRect(&rc, rc.left, rc.top, rc.left+dx, rc.top+dy);
	    PutWindowMCI(&rc);
	    SetRect(&rc, 0, 0, dx, dy);
	    SetDestRectMCI(&rc);
	}
    }
}


/* StartSndVol
 *
 * Kicks off the Sound Volume app asynchronously so we don't hang the UI.
 */
VOID StartSndVol( )
{
    STARTUPINFO         StartupInfo;
    PROCESS_INFORMATION ProcessInformation;

    memset( &StartupInfo, 0, sizeof StartupInfo );
    StartupInfo.cb = sizeof(StartupInfo);
    StartupInfo.wShowWindow = SW_SHOW;

    CreateProcess( NULL, szSndVol32, NULL, NULL, FALSE, 0,
		   NULL, NULL, &StartupInfo, &ProcessInformation );

    ExitThread( 0 );
}


/* GetHeightAdjust
 *
 * Finds the real height adjustment needed, by subtracting the client
 * height from the main window height.  This allows for menus that
 * have wrapped.
 */
int GetHeightAdjust(HWND hwnd)
{
    RECT rcWindow;
    RECT rcClient;
    int  WindowHeight;
    int  ClientHeight;

    GetWindowRect(hwnd, &rcWindow);
    GetClientRect(hwnd, &rcClient);
    WindowHeight = rcWindow.bottom - rcWindow.top;
    ClientHeight = rcClient.bottom - rcClient.top;

    return WindowHeight - ClientHeight;
}


/* Message-cracking routines for MPlayerWndProc:
 */

BOOL MPlayer_OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
    InitMPlayerDialog(hwnd);

    /* set off a thread to check that the OLE registry stuff is not corrupted  */

#ifdef CHICAGO_PRODUCT
    /* If this is the Chicago Media Player, only mess with the registry
     * if we're actually running on that platform.
     * The guy may be running it on NT.
     */
    if (gwPlatformId != VER_PLATFORM_WIN32_WINDOWS)
	return TRUE;
#endif

    if (!IgnoreRegCheck())
	BackgroundRegCheck(hwnd);

	//Register for WM_DEVICECHANGE notification.
	DeviceChange_Init(hwnd);

    return TRUE;
}


void MPlayer_OnShowWindow(HWND hwnd, BOOL fShow, UINT status)
{
    if (fShow)
	Layout();    // we're about to be shown and want to set
}


void MPlayer_OnSize(HWND hwnd, UINT state, int cx, int cy)
{
    /* Don't waste time Layout()ing if we're not visible */
    if (state != SIZE_RESTORED || IsWindowVisible(hwnd)) {

	Layout();

	// If we are inplace editing, our size change must be informed
	// to the container, unless the size change was a result of a
	// OnPosRectChange sent to us by the container.
	if ((gfOle2IPEditing || gfOle2IPPlaying) && ghwndMCI) {

	    RECT rc;
	    RECT rcPrev;

	    rcPrev = gInPlacePosRect;
	    GetWindowRect(ghwndApp, &gInPlacePosRect);
	    gfInPlaceResize = TRUE;
	    rc = gInPlacePosRect;

	    /* Check that the previous rect wasn't empty, otherwise we send
	     * a bogus OLE_CHANGED on startup.
	     */
	    if (!gfPosRectChange /*&& !IsRectEmpty(&rcPrev)*/) {

		MapWindowPoints(NULL,ghwndCntr,(POINT FAR *)&rc,(UINT)2);

		DPF("IOleInPlaceSite::OnPosRectChange %d, %d, %d, %d\n", rc);
		if (!gfInPPViewer)
		    IOleInPlaceSite_OnPosRectChange(docMain.lpIpData->lpSite, &rc);
		fDocChanged = TRUE;
		SendDocMsg((LPDOC)&docMain, OLE_CHANGED);
	    }

	    gfPosRectChange = FALSE;
	}
    }
}


BOOL MPlayer_OnWindowPosChanging(HWND hwnd, LPWINDOWPOS lpwpos)
{
#define SNAPTOGOODSIZE
#ifdef SNAPTOGOODSIZE
    BOOL    wHeight;
#endif

    DPF2("ENTER OnWindowPosChanging: lpwpos = %x, %x, %x, %x\n", *((PPOS)&lpwpos->x));

    if (IsIconic(hwnd) || gfPlayOnly)
	return TRUE;

    /* posSizeMove contains the height we want to be when sizing.
     * Don't let the system tell us otherwise.
     */
    if (posSizeMove.cx != 0)
    {
	lpwpos->cy = posSizeMove.cy;
	posSizeMove = *(PPOS)&lpwpos->x;
    }

    else if (!(lpwpos->flags & SWP_NOSIZE)) {

#ifdef SNAPTOGOODSIZE
	/* We should also do things here to make the window
	** snap to good sizes */
	wHeight = lpwpos->cy - gwHeightAdjust;
//        if (lpwpos->cy >= (int) gwHeightAdjust + MAX_NORMAL_HEIGHT) {
//        } else if (lpwpos->cy < (int) gwHeightAdjust +
//                    ((MIN_NORMAL_HEIGHT + MAX_NORMAL_HEIGHT) / 2)) {
//            lpwpos->cy = (int) gwHeightAdjust + MIN_NORMAL_HEIGHT;
//        } else {
	    lpwpos->cy = (int) gwHeightAdjust + MAX_NORMAL_HEIGHT;
//        }
#endif
    }

    DPF2("EXIT  OnWindowPosChanging: lpwpos = %x, %x, %x, %x\n", *((PPOS)&lpwpos->x));

    return FALSE;
}


BOOL MPlayer_OnWindowPosChanged(HWND hwnd, LPWINDOWPOS lpwpos)
{
    if (!IsIconic(hwnd) && !gfPlayOnly && !gfOle2IPEditing && !gfOle2IPPlaying)
    {
	/* The problem here is that we want to modify the height of the
	 * window while tracking to take account of the menu height.
	 * In its wisdom, the system keeps trying to resize us back to the
	 * original height.  So, during tracking, we keep hold of the
	 * dimensions we want to be and ignore the height that we get
	 * passed on WM_WINDOWPOSCHANGING.
	 */
	if (posSizeMove.cx != 0)
	{
	    int NewHeightAdjust = GetHeightAdjust(hwnd);

	    if ((int)gwHeightAdjust != NewHeightAdjust)
	    {
		/* The total non-client height has changed, so it must
		 * be the menu that's wrapped or unwrapped.
		 * Modify our height adjustment accordingly and resize
		 * the window.
		 */
		DPF("Menu appears to have wrapped.  Changing window height.\n");

		posSizeMove.cy += ( NewHeightAdjust - gwHeightAdjust );
		gwHeightAdjust = NewHeightAdjust;
		MoveWindow(ghwndApp,
			   posSizeMove.x, posSizeMove.y,
			   posSizeMove.cx, posSizeMove.cy, TRUE);
		return FALSE;
	    }
	}

	if (ghwndStatic && IsWindowVisible(ghwndStatic))
	{
	    InvalidateRect(ghwndStatic, NULL, FALSE);
	}
    }

    FORWARD_WM_WINDOWPOSCHANGED(hwnd, lpwpos, DefWindowProc);

    return TRUE;
}


void MPlayer_OnPaletteChanged(HWND hwnd, HWND hwndPaletteChange)
{
    if (ghwndMCI && !IsIconic(hwnd))
	FORWARD_WM_PALETTECHANGED(ghwndMCI, hwndPaletteChange, SendMessage);
}


BOOL MPlayer_OnQueryNewPalette(HWND hwnd)
{
    HWND     hwndT;
    HPALETTE hpal, hpalT;
    HDC      hdc;
    UINT     PaletteEntries;

    if (IsIconic(hwnd))
	return FALSE;

    if (ghwndMCI)
	return FORWARD_WM_QUERYNEWPALETTE(ghwndMCI, SendMessage);

    hwndT = GetWindowMCI();
    hpal = PaletteMCI();

    if ((hwndT != NULL) && (hpal != NULL)) {
	hdc = GetDC(hwnd);
	hpalT = SelectPalette(hdc, hpal, FALSE);
	PaletteEntries = RealizePalette(hdc);
	SelectPalette(hdc, hpalT, FALSE);
	ReleaseDC(hwnd, hdc);

	if (PaletteEntries != GDI_ERROR) {
	    InvalidateRect(hwndT, NULL, TRUE);
	    return TRUE;
	}
    }

    return FALSE;
}


HBRUSH MPlayer_OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type)
{
    /* Only interested in the CTLCOLOR_STATIC messages.
     * On Win32, type should always equal CTLCOLOR_STATIC:
     */
    switch( type )
    {
    case CTLCOLOR_STATIC:
	SetBkColor(hdc, rgbButtonFace);
	SetTextColor(hdc, rgbButtonText);
    }

    return hbrButtonFace;
}


void MPlayer_OnWinIniChange(HWND hwnd, LPCTSTR lpszSectionName)
{
    if (!lpszSectionName || !lstrcmpi(lpszSectionName, (LPCTSTR)aszIntl))
	if (GetIntlSpecs())
	    InvalidateRect(ghwndMap, NULL, TRUE);

    if (!gfPlayOnly) {

	if (gwHeightAdjust != (WORD)(2 * GetSystemMetrics(SM_CYFRAME) +
		     GetSystemMetrics(SM_CYCAPTION) +
		     GetSystemMetrics(SM_CYBORDER) +
		     GetSystemMetrics(SM_CYMENU))) {

	    RECT rc;

	    gwHeightAdjust = 2 * GetSystemMetrics(SM_CYFRAME) +
			     GetSystemMetrics(SM_CYCAPTION) +
			     GetSystemMetrics(SM_CYBORDER) +
			     GetSystemMetrics(SM_CYMENU);
	    GetClientRect(hwnd, &rc);
	    gfWinIniChange = TRUE;
	    SetMPlayerSize(&rc);
	    gfWinIniChange = FALSE;
	}
    }
}


void MPlayer_OnMenuSelect(HWND hwnd, HMENU hmenu, int item, HMENU hmenuPopup, UINT flags)
{
	// Make sure that the container is still not displaying info. about
    // its own menu.
	
    if (gfOle2IPEditing && docMain.lpIpData->lpFrame) {

	//Should have some useful text later.
	IOleInPlaceFrame_SetStatusText(docMain.lpIpData->lpFrame, L"");
    }
	else
	{
		//Keep track of which menu bar item is currently popped up.
		//This will be used for displaying the appropriate help from the mplayer.hlp file
		//when the user presses the F1 key.
		currMenuItem = item;
	}
}


#define MVSIZEFIRST         1
#define MVMOVE              9
void MPlayer_OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest)
{
    RECT rc;

    if (gfPlayOnly && !IsIconic(hwnd) && IsZoomed(hwnd)) {

	if (codeHitTest >= HTSIZEFIRST && codeHitTest <= HTSIZELAST) {

	    SendMessage(hwnd, WM_SYSCOMMAND,
//                        (WPARAM)(SC_SIZE + (codeHitTest - HTSIZEFIRST + MVSIZEFIRST) ),
			(WPARAM)SC_SIZE,
			MAKELPARAM(x, y));
	    return;
	}

	GetWindowRect(hwnd, &rc);

	if (codeHitTest == HTCAPTION && (rc.left > 0 || rc.top > 0 ||
	    rc.right  < GetSystemMetrics(SM_CXSCREEN) ||
	    rc.bottom < GetSystemMetrics(SM_CYSCREEN))) {

	    SendMessage(hwnd, WM_SYSCOMMAND,
//                        (WPARAM)(SC_MOVE | MVMOVE),
			(WPARAM)SC_MOVE,
			MAKELPARAM(x, y));
	    return;
	}
    }

    FORWARD_WM_NCLBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, DefWindowProc);
}


void MPlayer_OnNCLButtonDblClk(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest)
{
    //
    // when the user dbl-clicks on the caption, toggle the play mode.
    //
    if (codeHitTest == HTCAPTION && !IsIconic(hwnd))
	SendMessage(hwnd, WM_COMMAND, (WPARAM)IDM_WINDOW, 0);
}


void MPlayer_OnInitMenu(HWND hwnd, HMENU hMenu)
{

    EnableMenuItem(hMenu, IDM_CLOSE,   gwDeviceID ? MF_ENABLED : MF_GRAYED);
//  EnableMenuItem(hMenu, IDM_UPDATE,  gwDeviceID && gfEmbeddedObject ? MF_ENABLED : MF_GRAYED);

    EnableMenuItem(hMenu, IDM_COPY_OBJECT, (gwDeviceID && (gwStatus != MCI_MODE_OPEN) && (gwStatus != MCI_MODE_NOT_READY)) ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hMenu, IDM_CONFIG, gwDeviceID && (gwDeviceType & DTMCI_CANCONFIG) ? MF_ENABLED : MF_GRAYED);

    CheckMenuItem(hMenu, IDM_SCALE + ID_TIME, gwCurScale == ID_TIME   ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem(hMenu, IDM_SCALE + ID_TRACKS, gwCurScale == ID_TRACKS ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem(hMenu, IDM_SCALE + ID_FRAMES, gwCurScale == ID_FRAMES ? MF_CHECKED : MF_UNCHECKED);

    EnableMenuItem(hMenu, IDM_SCALE + ID_TIME,   gwDeviceID && !gfCurrentCDNotAudio && (gwDeviceType & DTMCI_TIMEMS) ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hMenu, IDM_SCALE + ID_FRAMES, gwDeviceID && !gfCurrentCDNotAudio && (gwDeviceType & DTMCI_TIMEFRAMES) ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hMenu, IDM_SCALE + ID_TRACKS, gwDeviceID && !gfCurrentCDNotAudio && (gwNumTracks > 1) ? MF_ENABLED : MF_GRAYED);

    EnableMenuItem(hMenu, IDM_OPTIONS, gwDeviceID ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hMenu, IDM_SELECTION, gwDeviceID && gdwMediaLength ? MF_ENABLED : MF_GRAYED);

#ifdef DEBUG
    EnableMenuItem(hMenu, IDM_MCISTRING, gwDeviceID ? MF_ENABLED : MF_GRAYED);
#endif

/*
    EnableMenuItem(hMenu, IDM_PASTE_PICTURE , gwDeviceID &&
		(IsClipboardFormatAvailable(CF_METAFILEPICT) ||
		 IsClipboardFormatAvailable(CF_BITMAP) ||
		 IsClipboardFormatAvailable(CF_DIB))
		? MF_ENABLED : MF_GRAYED);

    //
    //  what is paste frame!
    //
    EnableMenuItem(hMenu, IDM_PASTE_FRAME, gwDeviceID &&
		   (gwDeviceType & DTMCI_CANCONFIG) ? MF_ENABLED : MF_GRAYED);
*/
}


void MPlayer_OnInitMenuPopup(HWND hwnd, HMENU hMenu, UINT item, BOOL fSystemMenu)
{
    static BOOL VolumeControlChecked = FALSE;

    /* Here we look to see whether the menu selected is the Device popup,
     * and, if it is the first time, search for the Sound Volume applet.
     * If we can't find it, grey out the menu item.
     */

    /* Caution:  When we're in place, there seems to be a discrepancy
     * in the value of parameter UINT item depending on which app is our
     * container.  If you use Spy to look at the parameters sent on
     * WM_INITMENUPOPUP, some apps seem to have zero-based menus (e.g.
     * ProgMan, PowerPoint, FileMan), which is what I would expect,
     * but others seem to have one-based menus (e.g. Word, Excel).
     * Why is this?  I don't know.  But it means that, when the
     * Insert Clip menu item is selected, the item parameter may be
     * either 2 or 3.  That's why I'm calling GetSubMenu, since hMenu
     * is always what I would expect.
     *
     * I sent some mail to the User and OLE guys to point this out,
     * but haven't heard anything yet.
     *
     * andrewbe, 28 February 1995
     */

    if (hMenu == GetSubMenu(ghMenu, menuposDevice))
    {
	HCURSOR hcurPrev;

	if(!VolumeControlChecked)
	{
	    /*
	    ** Check to see if the volume controller piglet can be found on
	    ** the path.
	    */
	    {
		TCHAR   chBuffer[8];
		LPTSTR  lptstr;

		if( SearchPath( NULL, szSndVol32, NULL, 8, chBuffer, &lptstr ) == 0L )
		    EnableMenuItem( hMenu, IDM_VOLUME, MF_GRAYED );

		VolumeControlChecked = TRUE;
	    }
	}

	/* On Device (or Insert Clip) menu start menu building if necessary
	 * (e.g. if we came up in tiny mode then switched to full size),
	 * and wait for the separate thread to complete.
	 */
	InitDeviceMenu();
	hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));
	WaitForDeviceMenu();
	SetCursor(hcurPrev);
    }

    /////////////////////////////////////////////////////////////////////////////
    // This code allows a window to by sized even when in the maximized state
    /////////////////////////////////////////////////////////////////////////////

    if (gfPlayOnly && !IsIconic(hwnd) && fSystemMenu && IsZoomed(hwnd))
	EnableMenuItem(hMenu, SC_SIZE,
		       !IsIconic(hwnd) ? MF_ENABLED : MF_GRAYED);
}


void MPlayer_OnGetMinMaxInfo(HWND hwnd, LPMINMAXINFO lpMinMaxInfo)
{
    RECT rc;

    if (gfPlayOnly) {
	SetRect(&rc, 0, 0, 0, TOOLBAR_HEIGHT);
	AdjustWindowRect(&rc, (DWORD)GetWindowLongPtr(hwnd, GWL_STYLE), FALSE);
	lpMinMaxInfo->ptMinTrackSize.y = rc.bottom - rc.top - 1;

	if (!gfPlayingInPlace &&
	    (gwDeviceID == (UINT)0 || !(gwDeviceType & DTMCI_CANWINDOW)))
	    lpMinMaxInfo->ptMaxTrackSize.y = lpMinMaxInfo->ptMinTrackSize.y;
    }
    else {
	lpMinMaxInfo->ptMinTrackSize.y = MAX_NORMAL_HEIGHT + gwHeightAdjust;
	lpMinMaxInfo->ptMaxTrackSize.y = MAX_NORMAL_HEIGHT + gwHeightAdjust;
    }
}


void MPlayer_OnPaint(HWND hwnd)
{
    PAINTSTRUCT ps;
    RECT        rc;
    int         x1, x2, y, y2;
    UINT        wParent;
    HBRUSH      hbrOld;

    BeginPaint(hwnd, &ps);

    if (gfPlayOnly) {

	extern UINT gwPlaybarHeight;    // in server.c

	/* Separate mci playback window from controls */
	if (gwDeviceType & DTMCI_CANWINDOW) {
	    SelectObject(ps.hdc, hbrButtonText);
	    GetClientRect(ghwndApp, &rc);
	    PatBlt(ps.hdc, 0, rc.bottom - gwPlaybarHeight, rc.right, 1, PATCOPY);
	}
    }
    else {
	hbrOld = SelectObject(ps.hdc, hbrButtonText);
	GetClientRect(ghwndApp, &rc);
	wParent = rc.right;

	y = rc.bottom - 27;   // where to paint borders around toolbar

	/* Line above trackbar */
#ifdef CHICAGO_PRODUCT
	y2 = rc.bottom - 74;
	/* This looks bad on NT */
	PatBlt(ps.hdc, 0, y2, wParent, 1, PATCOPY);
#else
	y2 = rc.bottom - 75;
#endif
	/* Lines around toolbars */
	PatBlt(ps.hdc, 0, y, wParent, 1, PATCOPY);
	GetClientRect(ghwndToolbar, &rc);
	x1 = rc.right;
	PatBlt(ps.hdc, x1, y, 1, TOOLBAR_HEIGHT + 3, PATCOPY);
	GetWindowRect(ghwndApp, &rc);
	x2 = rc.left;

	if (IsWindowVisible(ghwndStatic)) {
	    GetWindowRect(ghwndStatic, &rc);
	    MapWindowPoints(NULL, ghwndApp, (LPPOINT)&rc, 1);
	    x2 = rc.left - 2 - GetSystemMetrics(SM_CXFRAME);

	    PatBlt(ps.hdc, x2, y, 1, TOOLBAR_HEIGHT + 3, PATCOPY);
	}

	SelectObject(ps.hdc, hbrButtonHighLight);
	/* Line above trackbar */
	PatBlt(ps.hdc, 0, y2 + 1, wParent, 1, PATCOPY);
	/* Lines around toolbar */
	PatBlt(ps.hdc, 0, y + 1, wParent, 1, PATCOPY);
	PatBlt(ps.hdc, x1 + 1, y + 1, 1, TOOLBAR_HEIGHT + 2, PATCOPY);
	if (IsWindowVisible(ghwndStatic)) {
	    PatBlt(ps.hdc, x2 + 1, y + 1, 1,TOOLBAR_HEIGHT +2, PATCOPY);
	}
	SelectObject(ps.hdc, hbrOld);
    }

    EndPaint(hwnd, &ps);

}


void MPlayer_OnCommand_Toolbar_Play()
{
    /* This checks to see whether the ALT key is held down.
     * If so, the current selection (if it exists) is played,
     * otherwise the whole shooting match.
     * Note, this does not appear to be documented at present.
     */
    if (GetKeyState(VK_MENU) < 0)
	PostMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_PLAYSEL, 0);

    /* On WFW, pressing the play button when in place plays the
     * current selection, if there is one.  Do the same if we're
     * playing or editing in place.
     */
    else if (gfOle2IPPlaying || gfOle2IPEditing)
	PostMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_PLAYSEL, 0);
    else
	PostMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_PLAY, 0);
}

void MPlayer_OnCommand_Toolbar_Pause()
{
    PostMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_PAUSE, 0L);
}

void MPlayer_OnCommand_Toolbar_Stop()
{
    PostMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_STOP, 0L);
}

void MPlayer_OnCommand_Toolbar_Eject()
{
    PostMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_EJECT, 0L);
}

void MPlayer_OnCommand_Toolbar_Home()
{
    LONG_PTR lPos = CalcPrevMark();

    /* We MUST use PostMessage because the */
    /* SETPOS and ENDTRACK must happen one */
    /* immediately after the other         */

    PostMessage(ghwndTrackbar, TBM_SETPOS, (WPARAM)TRUE, lPos);

    PostMessage(ghwndApp, WM_HSCROLL, (WPARAM)TB_ENDTRACK, (LPARAM)ghwndTrackbar);
}

void MPlayer_OnCommand_Toolbar_End()
{
    LONG_PTR lPos = CalcNextMark();

    /* We MUST use PostMessage because the */
    /* SETPOS and ENDTRACK must happen one */
    /* immediately after the other         */

    PostMessage(ghwndTrackbar, TBM_SETPOS, (WPARAM)TRUE, lPos);

    PostMessage(ghwndApp, WM_HSCROLL, (WPARAM)TB_ENDTRACK, (LPARAM)ghwndTrackbar);
}

void MPlayer_OnCommand_Toolbar_Rwd(HWND hwndCtl)
{
    if (hwndCtl == (HWND)REPEAT_ID)
    {
	if (gwCurScale != ID_TRACKS)
	    PostMessage(ghwndApp, WM_HSCROLL, (WPARAM)TB_PAGEUP, 0L);
	else
	    PostMessage(ghwndApp, WM_HSCROLL, (WPARAM)TB_LINEUP, 0L);
    }
}

void MPlayer_OnCommand_Toolbar_Fwd(HWND hwndCtl)
{
    if (hwndCtl == (HWND)REPEAT_ID)
    {
	if (gwCurScale != ID_TRACKS)
	    PostMessage(ghwndApp, WM_HSCROLL, (WPARAM)TB_PAGEDOWN, 0L);
	else
	    PostMessage(ghwndApp, WM_HSCROLL, (WPARAM)TB_LINEDOWN, 0L);
    }
}

void MPlayer_OnCommand_Toolbar_MarkIn()
{
    SendMessage(ghwndTrackbar, TBM_SETSELSTART, (WPARAM)TRUE,
		SendMessage(ghwndTrackbar, TBM_GETPOS, 0, 0));

    DirtyObject(TRUE);
}

void MPlayer_OnCommand_Toolbar_MarkOut()
{
    SendMessage(ghwndTrackbar, TBM_SETSELEND, (WPARAM)TRUE,
		SendMessage(ghwndTrackbar, TBM_GETPOS, 0, 0));

    DirtyObject(TRUE);
}

void MPlayer_OnCommand_Toolbar_ArrowPrev(HWND hwndCtl)
{
    if (hwndCtl == (HWND)REPEAT_ID)
	SendMessage(ghwndApp, WM_HSCROLL, (WPARAM)TB_LINEUP, 0L);
}

void MPlayer_OnCommand_Toolbar_ArrowNext(HWND hwndCtl)
{
    if (hwndCtl == (HWND)REPEAT_ID)
	SendMessage(ghwndApp, WM_HSCROLL, (WPARAM)TB_LINEDOWN, 0L);
}

void MPlayer_OnCommand_Menu_CopyObject(HWND hwnd)
{
    if (gfPlayingInPlace)
    {
	DPF0("Mplayer WndProc: Can't cutorcopy\n");
	return;
    }

    DPF("Mplayer WndProc: Calling cutorcopy\n");

    if (!InitOLE(&gfOleInitialized, &lpMalloc))
    {
	/* How likely is this?  Do we need a dialog box?
	 */
	DPF0("Initialization of OLE FAILED!!  Can't do copy.\n");
    }

#ifdef OLE1_HACK
    CopyObject(hwnd);
#endif /* OLE1_HACK */
    CutOrCopyObj(&docMain);
}

void MPlayer_OnCommand_Menu_Config(HWND hwnd)
{
    RECT rcBefore;
    RECT rcAfter;

    if (gfPlayingInPlace)
	return;

    GetDestRectMCI (&rcBefore);

    ConfigMCI(hwnd);

    /* If the MCI window size changed, we need to resize */
    /* our reduced mplayer.                              */
    if (gfPlayOnly)
    {
	GetDestRectMCI (&rcAfter);

	if (!EqualRect(&rcBefore, &rcAfter) && (!IsRectEmpty(&rcAfter)))
	    SetMPlayerSize(&rcAfter);
    }
}


void MPlayer_OnCommand_Menu_Volume(HWND hwnd)
{
    HANDLE  hThread;
    DWORD   dwThreadId;

    hThread = CreateThread( NULL, 0L,
			    (LPTHREAD_START_ROUTINE)StartSndVol,
			    NULL, 0L, &dwThreadId );

    if ( hThread != NULL ) {
	CloseHandle( hThread );
    }
}


void MPlayer_OnCommand_PlayToggle(HWND hwnd)
{
    /* This is for the accelerator to toggle play and pause. */
    /* Ordinary play commands better not toggle.             */

    DPF2("MPlayer_OnCommand_PlayToggle: gwStatus == %x\n", gwStatus);

    switch(gwStatus) {

    case MCI_MODE_STOP:
    case MCI_MODE_PAUSE:
    case MCI_MODE_SEEK:
	PostMessage(hwnd, WM_COMMAND, (WPARAM)ID_PLAY, 0);
	break;

    case MCI_MODE_PLAY:
	PostMessage(hwnd, WM_COMMAND, (WPARAM)ID_PAUSE, 0);
	break;
    }
}

void MPlayer_OnCommand_PlaySel(HWND hwnd, HWND hwndCtl)
{
    DWORD_PTR dwPos, dwStart, dwEnd;
    BOOL f;
    dwPos = 0; // Make Prefix Happy..

    DPF2("MPlayer_OnCommand_PlaySel: gwStatus == %x\n", gwStatus);

    switch(gwStatus) {

    case MCI_MODE_OPEN:
    case MCI_MODE_NOT_READY:

	Error(ghwndApp, IDS_CANTPLAY);
	if (gfCloseAfterPlaying)    // get us out now!!
	    PostCloseMessage();

	break;

    default:

	/* If the shift key's being held down, make this the start
	 * of a selection:
	 */

	if((GetKeyState(VK_SHIFT) < 0)
	 &&(toolbarStateFromButton(ghwndMark, BTN_MARKIN, TBINDEX_MARK)
						   != BTNST_GRAYED))
	    SendMessage(hwnd, WM_COMMAND, IDT_MARKIN, 0);

	/* Start playing the medium */

	StatusMCI(&dwPos);   // get the REAL position
	dwStart = SendMessage(ghwndTrackbar, TBM_GETSELSTART, 0, 0);
	dwEnd = SendMessage(ghwndTrackbar, TBM_GETSELEND, 0, 0);

	/* If there is no valid selection, act like PLAY */
	if (dwStart == -1 || dwEnd == -1 || dwStart == dwEnd)
	    hwndCtl = (HWND)ID_PLAY;

	// Be nice and rewind automatically if we're at the end of the media.
	// Depending on the device, though, the end could be "start + len"
	// or "start + len - 1"
	if (hwndCtl == (HWND)ID_PLAY &&
			dwPos >= gdwMediaStart + gdwMediaLength - 1) {
	    if (!SeekMCI(gdwMediaStart))
		break;
	}

	if (hwndCtl == (HWND)ID_PLAYSEL) {
	    f = PlayMCI(dwStart, dwEnd);
	    gfJustPlayedSel = TRUE;
	} else {
	    f = PlayMCI(0, 0);
	    gfJustPlayedSel = FALSE;
	}

	// get us out NOW!! or focus goes to client
	if (!f && gfCloseAfterPlaying)
	    PostCloseMessage();

	/* No longer needed - reset for next time */
	gfUserStopped = FALSE;

	gwStatus = (UINT)(-1);    // force rewind if needed
	break;
    }
}

void MPlayer_OnCommand_Pause()
{
    /* Pause the medium, unless we are already paused */

    DPF2("MPlayer_OnCommand_Pause: gwStatus == %x\n", gwStatus);

    switch(gwStatus) {

    case MCI_MODE_PAUSE:
	PlayMCI(0, 0);
	break;

    case MCI_MODE_PLAY:
    case MCI_MODE_SEEK:
	PauseMCI();
	break;

    case MCI_MODE_STOP:
    case MCI_MODE_OPEN:
	break;
    }
}

void MPlayer_OnCommand_Stop()
{
    /* Stop the medium */

    DPF2("MPlayer_OnCommand_Stop: gwStatus == %x\n", gwStatus);

    switch(gwStatus) {

    case MCI_MODE_PAUSE:
    case MCI_MODE_PLAY:
    case MCI_MODE_STOP:
    case MCI_MODE_SEEK:

	StopMCI();		
	SeekToStartMCI();
	gfUserStopped = TRUE;        // we did this
	gfCloseAfterPlaying = FALSE; //stay up from now on

	UpdateDisplay();

	// Focus should go to PLAY button now
	toolbarSetFocus(ghwndToolbar, BTN_PLAY);
	break;

    case MCI_MODE_OPEN:
	break;
    }

    if (gfPlayingInPlace)
	PostCloseMessage();
}


void MPlayer_OnCommand_Eject()
{
    /*
     * Eject the medium if it currently isn't ejected. If it
     * is currently ejected, then load the new medium into
     * the device.
     *
     */

    switch(gwStatus) {

    case MCI_MODE_PLAY:
    case MCI_MODE_PAUSE:

	StopMCI();
	EjectMCI(TRUE);

	break;

    case MCI_MODE_STOP:
    case MCI_MODE_SEEK:
    case MCI_MODE_NOT_READY:

	EjectMCI(TRUE);

	break;

    case MCI_MODE_OPEN:

	EjectMCI(FALSE);

	break;
    }
}


void MPlayer_OnCommand_Escape()
{
    MPlayer_OnCommand_Stop();

    if( gfOle2IPEditing || gfOle2IPPlaying)
	PostCloseMessage();
}


void MPlayer_OnCommand_Menu_Open()
{
    UINT  wLastScale;
    UINT  wLastDeviceID;
    TCHAR szFile[256];
    RECT  rc;

    wLastScale = gwCurScale;  // save old scale
    wLastDeviceID = gwDeviceID;
    if (gfPlayingInPlace || gfOle2IPEditing || gfOle2IPPlaying)
	return;

    InitDeviceMenu();
    WaitForDeviceMenu();

    if (OpenDoc(gwCurDevice,szFile))
    {
	DirtyObject(FALSE);
	/* Force WM_GETMINMAXINFO to be called so we'll snap  */
	/* to a proper size.                                  */
	GetWindowRect(ghwndApp, &rc);
	MoveWindow(ghwndApp,
		   rc.left,
		   rc.top,
		   rc.right - rc.left,
		   rc.bottom - rc.top,
		   TRUE);

	if (gfOpenDialog)
	    CompleteOpenDialog(TRUE);
	else
	    gfCloseAfterPlaying = FALSE;    // stay up from now on

	//If the CD Audio device was opened it must have been a *.cda file.
	//Try to jump to the track corresponding to the file opened.
	if ((gwDeviceType & DTMCI_DEVICE) == DTMCI_CDAUDIO)
	{
		HandleCDAFile(szFile);
	}
    }
    else
    {
	if (gfOpenDialog)
	    CompleteOpenDialog(FALSE);

	/* The previous device may or may not still be open.
	 * If it is, make sure we have the right scale.
	 */
	if (gwDeviceID == wLastDeviceID)
	    gwCurScale = wLastScale;   // restore to last scale

	InvalidateRect(ghwndMap, NULL, TRUE); //erase map area
    }

    // put the focus on the Play button
    SetFocus(ghwndToolbar);    // give focus to PLAY button
    toolbarSetFocus(ghwndToolbar, BTN_PLAY);

    SetMPlayerIcon();
}

void MPlayer_OnCommand_Menu_Close(HWND hwnd)
{
    if (gfEmbeddedObject && !gfSeenPBCloseMsg) {
	// this is File.Update
#ifdef OLE1_HACK
	if( gDocVersion == DOC_VERSION_OLE1 )
	    Ole1UpdateObject();
	else
#endif /* OLE1_HACK */
	UpdateObject();
    }
    else
    {
	// this is File.Close
	gfSeenPBCloseMsg = TRUE;

	WriteOutOptions();
	InitDoc(TRUE);
	SetMPlayerIcon();
	gwCurDevice = 0;// force next file open dialog to say
			// "all files" because CloseMCI won't.

	gwCurScale = ID_NONE;  // uncheck all scale types

	Layout(); // Make window snap back to smaller size
		  // if it should.
		  // Don't leave us closed in play only mode

	if (gfPlayOnly)
	    SendMessage(hwnd, WM_COMMAND, (WPARAM)IDM_WINDOW, 0);
    }
}

void MPlayer_OnCommand_Menu_Exit()
{
    PostCloseMessage();
}

void MPlayer_OnCommand_Menu_Scale(UINT id)
{
    /*
     * Invalidate the track map window so it will be
     * redrawn with the correct positions, etc.
     */
    if (gwCurScale != id - IDM_SCALE) {

	// Restoring the selection doesn't work yet,
	// because UpdateMCI clears the selection,
	// plus we need to do some conversion.
//        int SelStart = SendMessage(ghwndTrackbar, TBM_GETSELSTART, 0, 0);
//        int SelEnd = SendMessage(ghwndTrackbar, TBM_GETSELEND, 0, 0);

	SendMessage(ghwndTrackbar, TBM_CLEARTICS, (WPARAM)FALSE, 0L);
	if (gwCurScale == ID_FRAMES || id - IDM_SCALE == ID_FRAMES)
	    gfValidMediaInfo = FALSE;

	gwCurScale = id - IDM_SCALE;
	DirtyObject(TRUE);    // change scale changes PAGE UP/DOWN
	CalcTicsOfDoom();

//        SendMessage(ghwndTrackbar, TBM_SETSELSTART, TRUE, SelStart);
//        SendMessage(ghwndTrackbar, TBM_SETSELEND, TRUE, SelEnd);
    }
}

void MPlayer_OnCommand_Menu_Selection(HWND hwnd)
{
    if (!gfPlayingInPlace)
	setselDialog(hwnd);
}


void MPlayer_OnCommand_Menu_Options(HWND hwnd)
{
    if (!gfPlayingInPlace)
	optionsDialog(hwnd);
}

void MPlayer_OnCommand_Menu_MCIString(HWND hwnd)
{
    if (!gfPlayingInPlace && gwDeviceID)
	mciDialog(hwnd);
}

void MPlayer_OnCommand_Menu_Window(HWND hwnd)
{
    //
    //  make MPlayer small/big
    //
    //!! dont do this if inside client document !!
    //!! or if we're not visible                !!

    if (!IsWindowVisible(ghwndApp) || gfPlayingInPlace || IsIconic(hwnd)
	|| gfOle2IPEditing)
	return;

    // allowed to get out of teeny mode when no file is open
    if (gwDeviceID != (UINT)0 || gfPlayOnly) {
	gfPlayOnly = !gfPlayOnly;
	SizeMPlayer();
    }
}

void MPlayer_OnCommand_Menu_Zoom(HWND hwnd, int id)
{
    int dx, dy;

    if (IsIconic(hwnd) ||gfPlayingInPlace || gfOle2IPPlaying || gfOle2IPEditing ||
		 !(gwDeviceType & DTMCI_CANWINDOW))
	return;

    dx = grcSize.right  * (id-IDM_ZOOM);
    dy = grcSize.bottom * (id-IDM_ZOOM);

    //
    // if the playback windows is now larger than the screen
    // maximize MPlayer, this only makes sence for Tiny mode.
    //
    if (gfPlayOnly &&
	(dx >= GetSystemMetrics(SM_CXSCREEN) ||
	 dy >= GetSystemMetrics(SM_CYSCREEN))) {
	ClrWS(hwnd, WS_MAXIMIZE);
	DefWindowProc(hwnd, WM_SYSCOMMAND, (WPARAM)SC_MAXIMIZE, 0);
    }
    else {
	SizePlaybackWindow(dx, dy);
    }
}

void DoHtmlHelp()
{
	//note, using ANSI version of function because UNICODE is foobar in NT5 builds
    char chDst[MAX_PATH];

	WideCharToMultiByte(CP_ACP, 0, gszHtmlHelpFileName, 
									-1, chDst, MAX_PATH, NULL, NULL); 
	HtmlHelpA(GetDesktopWindow(), chDst, HH_DISPLAY_TOPIC, 0);
}

void MPlayer_OnCommand_Menu_HelpTopics(HWND hwnd)
{
	static TCHAR HelpFile[] = TEXT("MPLAYER.HLP");
	
	//Handle context menu help
	if(bF1InMenu) 
	{
		switch(currMenuItem)
		{
		case IDM_OPEN:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_FILE_OPEN);
		break;
		case IDM_CLOSE:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_FILE_CLOSE);
		break;
		case IDM_EXIT:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_FILE_EXIT);
		break;
		case IDM_COPY_OBJECT:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_EDIT_COPY_OBJECT);
		break;
		case IDM_OPTIONS:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_EDIT_OPTIONS);
		break;
		case IDM_SELECTION:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_EDIT_SELECTION);
		break;
		case IDM_CONFIG:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_DEVICE_PROPERTIES);
		break;
		case IDM_VOLUME:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_DEVICE_VOLUME_CONTROL);
		break;
		case IDM_SCALE + ID_TIME:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_SCALE_TIME);
		break;
		case IDM_SCALE + ID_TRACKS:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_SCALE_TRACKS);
		break;
		case IDM_SCALE + ID_FRAMES:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_SCALE_FRAMES);
		break;
		case IDM_HELPTOPICS:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_HELP_HELP_TOPICS);
		break;
		case IDM_ABOUT:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_HELP_ABOUT);
		break;
		default://In the default case just display the HTML Help.
			DoHtmlHelp();
		}
		bF1InMenu = FALSE; //This flag will be set again if F1 is pressed in a menu.
	}
	else
		DoHtmlHelp();
}

void MPlayer_OnCommand_Menu_About(HWND hwnd)
{
    ShellAbout(hwnd, gachAppName, aszNULL, hiconApp);
}

void MPlayer_OnCommand_Default(HWND hwnd, int id)
{
    /*
     * Determine if the user selected one of the entries in
     * the Device menu.
     *
     */

    if (id > IDM_DEVICE0 &&
	(id <= (WORD)(IDM_DEVICE0 + gwNumDevices))
       ) {

	BOOL fHasWindow, fHadWindow, fHadDevice;

	fHadWindow = (gwDeviceID != (UINT)0) && (gwDeviceType & DTMCI_CANWINDOW);
	fHadDevice = (gwDeviceID != (UINT)0);

	//Choose and open a new device. If we are active inplace we have
	//to consider the effect of the change in device on the visual appearence.
	//For this we have to take into account whether the current and previous
	//device had a playback window or not. We also have to consider
	//whether this is the first device are opening.
	//After all the crazy munging send a messages to the container about
	//the changes.
	if (DoChooseDevice(id-IDM_DEVICE0))
	{
	    if (gfOpenDialog)
		CompleteOpenDialog(TRUE);

	    fHasWindow = (gwDeviceID != (UINT)0) && (gwDeviceType & DTMCI_CANWINDOW);
	    if(gfOle2IPEditing)
	    {
		if (fHasWindow && fHadWindow)
		{
		    GetWindowRect(ghwndApp, (LPRECT)&gInPlacePosRect);
		    gfInPlaceResize = TRUE;
		    SendDocMsg((LPDOC)&docMain, OLE_SIZECHG);
		    SendDocMsg((LPDOC)&docMain, OLE_CHANGED);
		}

		else
		{
		    RECT rc;
		    RECT rctmp;

		    ClrWS(ghwndApp,
			  WS_THICKFRAME|WS_CAPTION|WS_SYSMENU|WS_MINIMIZEBOX|WS_MAXIMIZEBOX|WS_BORDER);

		    if (gwOptions & OPT_BORDER)
			SetWS(ghwndApp, WS_BORDER);

		    GetWindowRect(ghwndApp, &rc);

		    if (!(gwDeviceType & DTMCI_CANWINDOW))
		    {
			HBITMAP  hbm;
			BITMAP   bm;

			if (!fHadDevice)
			GetWindowRect(ghwndIPHatch, &rc);
			hbm =  BitmapMCI();
			GetObject(hbm,sizeof(bm),&bm);
			rc.bottom = rc.top + bm.bmHeight;
			rc.right = rc.left + bm.bmWidth;
			DeleteObject(hbm);
		    }
		    else
		    {
			if(!fHadDevice)
			{
			rc.bottom -= (GetSystemMetrics(SM_CYCAPTION)-GetSystemMetrics(SM_CYBORDER));
			gwOptions |= OPT_BAR | OPT_TITLE;
			}
		      rc.bottom += gInPlacePosRect.top - rc.top - 4*GetSystemMetrics(SM_CYBORDER) - 4 ;
		      rc.right += gInPlacePosRect.left - rc.left- 4*GetSystemMetrics(SM_CXBORDER) - 4 ;
			rc.top = gInPlacePosRect.top;
			rc.left = gInPlacePosRect.left;
		    }
		    rctmp = gPrevPosRect;
		    MapWindowPoints( ghwndCntr, NULL, (LPPOINT)&rctmp,2);
		    OffsetRect((LPRECT)&rc, rctmp.left - rc.left, rctmp.top -rc.top);
		    gInPlacePosRect = rc;
		    gfInPlaceResize = TRUE;
		    if(!(gwDeviceType & DTMCI_CANWINDOW) && (gwOptions & OPT_BAR))
		    {
			rc.top = rc.bottom - gwPlaybarHeight;
		    }
		    EditInPlace(ghwndApp,ghwndIPHatch,&rc);
		    SendDocMsg((LPDOC)&docMain, OLE_SIZECHG);
		    SendDocMsg((LPDOC)&docMain, OLE_CHANGED);
		    if (!(gwDeviceType & DTMCI_CANWINDOW) && !(gwOptions &OPT_BAR))
			ShowWindow(ghwndApp, SW_HIDE);
		    else
			ShowWindow(ghwndApp, SW_SHOW);
		}
	    }

	    DirtyObject(FALSE);

	    if (!gfOpenDialog)
		gfCloseAfterPlaying = FALSE;  // stay up from now on

	    SetMPlayerIcon();
	}
	else
	    if (gfOpenDialog)
		CompleteOpenDialog(FALSE);
    }
}

#define HANDLE_COMMAND(id, call)    case (id): (call); break

void MPlayer_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id) {

    HANDLE_COMMAND(IDT_PLAY,              MPlayer_OnCommand_Toolbar_Play());
    HANDLE_COMMAND(IDT_PAUSE,             MPlayer_OnCommand_Toolbar_Pause());
    HANDLE_COMMAND(IDT_STOP,              MPlayer_OnCommand_Toolbar_Stop());
    HANDLE_COMMAND(IDT_EJECT,             MPlayer_OnCommand_Toolbar_Eject());
    HANDLE_COMMAND(IDT_HOME,              MPlayer_OnCommand_Toolbar_Home());
    HANDLE_COMMAND(IDT_END,               MPlayer_OnCommand_Toolbar_End());
    HANDLE_COMMAND(IDT_RWD,               MPlayer_OnCommand_Toolbar_Rwd(hwndCtl));
    HANDLE_COMMAND(IDT_FWD,               MPlayer_OnCommand_Toolbar_Fwd(hwndCtl));
    HANDLE_COMMAND(IDT_MARKIN,            MPlayer_OnCommand_Toolbar_MarkIn());
    HANDLE_COMMAND(IDT_MARKOUT,           MPlayer_OnCommand_Toolbar_MarkOut());
    HANDLE_COMMAND(IDT_ARROWPREV,         MPlayer_OnCommand_Toolbar_ArrowPrev(hwndCtl));
    HANDLE_COMMAND(IDT_ARROWNEXT,         MPlayer_OnCommand_Toolbar_ArrowNext(hwndCtl));
    HANDLE_COMMAND(IDM_COPY_OBJECT,       MPlayer_OnCommand_Menu_CopyObject(hwnd));
    HANDLE_COMMAND(IDM_CONFIG,            MPlayer_OnCommand_Menu_Config(hwnd));
    HANDLE_COMMAND(IDM_VOLUME,            MPlayer_OnCommand_Menu_Volume(hwnd));
    HANDLE_COMMAND(ID_PLAYTOGGLE,         MPlayer_OnCommand_PlayToggle(hwnd));
    HANDLE_COMMAND(ID_PLAY,               MPlayer_OnCommand_PlaySel(hwnd, (HWND)IntToPtr(id)));
    HANDLE_COMMAND(ID_PLAYSEL,            MPlayer_OnCommand_PlaySel(hwnd, (HWND)IntToPtr(id)));
    HANDLE_COMMAND(ID_PAUSE,              MPlayer_OnCommand_Pause());
    HANDLE_COMMAND(ID_STOP,               MPlayer_OnCommand_Stop());
    HANDLE_COMMAND(ID_EJECT,              MPlayer_OnCommand_Eject());
    HANDLE_COMMAND(ID_ESCAPE,             MPlayer_OnCommand_Escape());
    HANDLE_COMMAND(IDM_OPEN,              MPlayer_OnCommand_Menu_Open());
    HANDLE_COMMAND(IDM_CLOSE,             MPlayer_OnCommand_Menu_Close(hwnd));
    HANDLE_COMMAND(IDM_EXIT,              MPlayer_OnCommand_Menu_Exit());
    HANDLE_COMMAND(IDM_SCALE + ID_TIME,   MPlayer_OnCommand_Menu_Scale(id));
    HANDLE_COMMAND(IDM_SCALE + ID_TRACKS, MPlayer_OnCommand_Menu_Scale(id));
    HANDLE_COMMAND(IDM_SCALE + ID_FRAMES, MPlayer_OnCommand_Menu_Scale(id));
    HANDLE_COMMAND(IDM_SELECTION,         MPlayer_OnCommand_Menu_Selection(hwnd));
    HANDLE_COMMAND(IDM_OPTIONS,           MPlayer_OnCommand_Menu_Options(hwnd));
    HANDLE_COMMAND(IDM_MCISTRING,         MPlayer_OnCommand_Menu_MCIString(hwnd));
    HANDLE_COMMAND(IDM_WINDOW,            MPlayer_OnCommand_Menu_Window(hwnd));
    HANDLE_COMMAND(IDM_ZOOM1,             MPlayer_OnCommand_Menu_Zoom(hwnd, id));
    HANDLE_COMMAND(IDM_ZOOM2,             MPlayer_OnCommand_Menu_Zoom(hwnd, id));
    HANDLE_COMMAND(IDM_ZOOM3,             MPlayer_OnCommand_Menu_Zoom(hwnd, id));
    HANDLE_COMMAND(IDM_ZOOM4,             MPlayer_OnCommand_Menu_Zoom(hwnd, id));
    HANDLE_COMMAND(IDM_HELPTOPICS,        MPlayer_OnCommand_Menu_HelpTopics(hwnd));
    HANDLE_COMMAND(IDM_ABOUT,             MPlayer_OnCommand_Menu_About(hwnd));

    default:                              MPlayer_OnCommand_Default(hwnd, id);
    }

    UpdateDisplay();
}

void MPlayer_OnClose(HWND hwnd)
{
    int f;

    DPF("WM_CLOSE received\n");

    if (gfInClose) {
	DPF("*** \n");
	DPF("*** Trying to re-enter WM_CLOSE\n");
	DPF("*** \n");
	return;
    }


    // Ask if we want to update before we set gfInClose to TRUE or
    // we won't let the dialog box up.
    f = AskUpdate();
	if (f == IDYES)
	    UpdateObject();
    if (f == IDCANCEL) {
	    gfInClose = FALSE;
	    return;
	}

    gfInClose = TRUE;

    ExitApplication();
    if (gfPlayingInPlace)
       EndPlayInPlace(hwnd);
    if (gfOle2IPEditing)
       EndEditInPlace(hwnd);

    if (docMain.lpoleclient)
	IOleClientSite_OnShowWindow(docMain.lpoleclient, FALSE);

    SendDocMsg(&docMain,OLE_CLOSED);
    DestroyDoc(&docMain);
    ExitApplication();

    if (hMciOle)
    {
	FreeLibrary(hMciOle);
	hMciOle = NULL;
    }


    //
    // set either the owner or the WS_CHILD bit so it will
    // not act up because we have the palette bit set and cause the
    // desktop to steal the palette.
    //
    // because we are being run from client apps that dont deal
    // with palettes we dont want the desktop to hose the palette.
    //
    if (gfPlayOnly && gfCloseAfterPlaying && gfRunWithEmbeddingFlag)
	   SetWindowLongPtr(hwnd, GWLP_HWNDPARENT, (LPARAM)GetDesktopWindow() );

    if (!ItsSafeToClose()) {
	DPF("*** \n");
	DPF("*** Trying to close MPLAYER with a ErrorBox up\n");
	DPF("*** \n");
	gfErrorDeath = WM_CLOSE;
	gfInClose = FALSE;
	return;
    }

    f = AskUpdate();
    if (f == IDYES)
	UpdateObject();
    if (f == IDCANCEL) {
	gfInClose = FALSE;
	return;
    }

    PostMessage(ghwndApp, WM_USER_DESTROY, 0, 0);
    DPF("WM_DESTROY message sent\n");
}

void MPlayer_OnEndSession(HWND hwnd, BOOL fEnding)
{
    if (fEnding) {
	WriteOutPosition();
	WriteOutOptions();
	CloseMCI(FALSE);
    }
}

void MPlayer_OnDestroy(HWND hwnd)
{
    /*
     * Relinquish control of whatever MCI device we were using (if any). If
     * this device is not shareable, then performing this action allows
     * someone else to gain access to the device.
     *
     */

    /* Client might close us if he dies while we're Playing in Place */
    if (gfPlayingInPlace) {
	DPF("****\n");
	DPF("**** Window destroyed while in place!\n");
	DPF("****\n");
    }

	//Unregister the WM_DEVICECHANGE notification
	DeviceChange_Cleanup();

    WriteOutOptions();
    CloseMCI(FALSE);

    SetMenu(hwnd, NULL);

    if (ghMenu)
	DestroyMenu(ghMenu);

    ghMenu = NULL;

    WinHelp(hwnd, gszHelpFileName, HELP_QUIT, 0L);

    PostQuitMessage(0);

    if (IsWindow(ghwndFrame))
	SetFocus(ghwndFrame);
    else if (IsWindow(ghwndFocusSave))
	SetFocus(ghwndFocusSave);

    //Inform OLE that we are not taking any more calls.
    if (gfOleInitialized)
    {
#ifdef OLE1_HACK
	if( gDocVersion == DOC_VERSION_OLE1 )
	    TerminateServer();
	else
#endif /* OLE1_HACK */
	/* Verify that the server was initialised by checking that one
	 * of the fields in docMain is non-null:
	 */
	if( docMain.hwnd )
	    CoDisconnectObject((LPUNKNOWN)&docMain, 0);
	else
	    DPF0("An instance of the server was never created.\n");
    }
}


void MPlayer_OnTimer(HWND hwnd, UINT id)
{
    MSG msg;

    UpdateDisplay();
    PeekMessage(&msg, hwnd, WM_TIMER, WM_TIMER, PM_REMOVE);
}


#define MARK_START  -1
#define MARK_NONE    0
#define MARK_END     1
void UpdateSelection(HWND hwnd, INT_PTR pos, int *pPrevMark)
{
    INT_PTR SelStart;
    INT_PTR SelEnd;

    SelStart = SendMessage(ghwndTrackbar, TBM_GETSELSTART, 0, 0);
    SelEnd = SendMessage(ghwndTrackbar, TBM_GETSELEND, 0, 0);

    if (pos < SelStart)
    {
	SendMessage(hwnd, WM_COMMAND, IDT_MARKIN, 0);
	*pPrevMark = MARK_START;
    }
    else if (pos > SelEnd)
    {
	SendMessage(hwnd, WM_COMMAND, IDT_MARKOUT, 0);
	*pPrevMark = MARK_END;
    }
    else
    {
	if (*pPrevMark == MARK_START)
	    SendMessage(hwnd, WM_COMMAND, IDT_MARKIN, 0);
	else
	    SendMessage(hwnd, WM_COMMAND, IDT_MARKOUT, 0);
    }
}


void MPlayer_OnHScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos)
{
    DWORD_PTR dwPosition;       /* player's current position in the medium*/
    DWORD_PTR dwCurTime;        /* Time a page up/down is last made       */
    TCHAR ach[60];
    static int PrevMark;

    /* If the media has no size, we can't seek. */
    if (gdwMediaLength == 0L)
	return;

    dwPosition = SendMessage(ghwndTrackbar, TBM_GETPOS, 0, 0);

    if (!gfScrollTrack) {
	gfScrollTrack = TRUE;

	/* If the shift key's being held down, make this the start
	 * of a selection:
	 */

	if((GetKeyState(VK_SHIFT) < 0)
	 &&(toolbarStateFromButton(ghwndMark, BTN_MARKIN, TBINDEX_MARK)
						   != BTNST_GRAYED))
	{
	    SendMessage(ghwndTrackbar, TBM_CLEARSEL, (WPARAM)TRUE, 0);
	    SendMessage(hwnd, WM_COMMAND, IDT_MARKIN, 0);
	    SetFocus(ghwndTrackbar);    /* So that escape will go to
					   the trackbar's subclassed
					   winproc. */
	}

	sfSeekExact = SeekExactMCI(FALSE);
    }

    switch (code) {
	/*
	 * Set the new position within the medium to be
	 * slightly before/after the current position if the
	 * left/right scroll arrow was clicked on.
	 */
	case TB_LINEUP:                 /* left scroll arrow  */
	    dwPosition -= (gwCurScale == ID_FRAMES) ? 1L : SCROLL_GRANULARITY;
	    break;

	case TB_LINEDOWN:               /* right scroll arrow */
	    dwPosition += (gwCurScale == ID_FRAMES) ? 1L : SCROLL_GRANULARITY;
	    break;

	case TB_PAGEUP:                 /* page-left */

	    /*
	     * If the user just did a page-left a short time ago,
	     * then seek to the start of the previous track.
	     * Otherwise, seek to the start of this track.
	     *
	     */
	    if (gwCurScale != ID_TRACKS) {
		dwPosition -= SCROLL_BIGGRAN;
	    } else {
		dwCurTime = GetCurrentTime();
		if (dwCurTime - dwLastPageUpTime < SKIPTRACKDELAY_MSEC)
		    SkipTrackMCI(-1);
		else
		    SkipTrackMCI(0);

		dwLastPageUpTime = dwCurTime;
		goto BreakOut;    // avoid SETPOS
	    }

	    break;

	case TB_PAGEDOWN:               /* page-right */

	    if (gwCurScale != ID_TRACKS) {
		dwPosition += SCROLL_BIGGRAN;
	    } else {
	    /* Seek to the start of the next track */
		SkipTrackMCI(1);
		// Ensure next PageUp can't possibly do SkipTrackMCI(-1)
		// which will skip back too far if you page
		// left, right, left really quickly.
		dwLastPageUpTime = 0;
		goto BreakOut;    // avoid SETPOS
	    }

	    break;

	case TB_THUMBTRACK:             /* track thumb movement */
	    //!!! we should do a "set seek exactly off"
	    /* Only seek while tracking for windowed devices that */
	    /* aren't currently playing                           */
	    if ((gwDeviceType & DTMCI_CANWINDOW) &&
		!(gwStatus == MCI_MODE_PLAY)) {
		SeekMCI(dwPosition);
	    }

	    break;

	case TB_TOP:
	    dwPosition = gdwMediaStart;
	    break;

	case TB_BOTTOM:
	    dwPosition = gdwMediaStart + gdwMediaLength;
	    break;

	case TB_THUMBPOSITION:          /* thumb has been positioned */
	    break;

	case TB_ENDTRACK:              /* user let go of scroll */
	    DPF2("TB_ENDTRACK\n");

	    gfScrollTrack = FALSE;

	    /* New as of 2/7/91: Only seek on ENDTRACK */

	    /*
	     * Calculate the new position in the medium
	     * corresponding to the scrollbar position, and seek
	     * to this new position.
	     *
	     */

	    /* We really want to update our position */
	    if (hwndCtl) {
		if (gdwSeekPosition) {
		    dwPosition = gdwSeekPosition;
		    gdwSeekPosition = 0;
		}

		/* Go back to the seek mode we were in before */
		/* we started scrolling.                      */
		SeekExactMCI(sfSeekExact);
		SeekMCI(dwPosition);
	    }

	    PrevMark = MARK_NONE;

	    return;

	default:
	    return;
    }
    SendMessage(ghwndTrackbar, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)dwPosition);
    /* Clamp to a valid range */
    dwPosition = SendMessage(ghwndTrackbar, TBM_GETPOS, 0, 0);

BreakOut:

    if (GetKeyState(VK_SHIFT) < 0)
	UpdateSelection(hwnd, dwPosition, &PrevMark);

    if (ghwndStatic) {
	FormatTime(dwPosition, NULL, ach, TRUE);
	//VIJR-SBSetWindowText(ghwndStatic, ach);
	WriteStatusMessage(ghwndStatic, ach);
    }

// Dirty if you just move the thumb???
//  if (!IsObjectDirty() && !gfCloseAfterPlaying) // don't want playing to dirty
//  DirtyObject();
}

void MPlayer_OnSysCommand(HWND hwnd, UINT cmd, int x, int y)
{
    RECT rc;

    // The bottom four bits of wParam contain system information. They
    // must be masked off in order to work out the actual command.
    // See the comments section in the online help for WM_SYSCOMMAND.

    switch (cmd & 0xFFF0) {

    case SC_MINIMIZE:
	DPF("minimized -- turn off timer\n");
	ClrWS(hwnd, WS_MAXIMIZE);
	EnableTimer(FALSE);
	break;

    case SC_MAXIMIZE:
	if (gfPlayOnly && !IsIconic(hwnd)) {
	    (void)PostMessage(hwnd, WM_COMMAND, (WPARAM)IDM_ZOOM2, 0);
	    return;
	}

	break;

    case SC_RESTORE:
	if (gfPlayOnly && !IsIconic(hwnd)) {
	    GetWindowRect(hwnd, &rc);
	    if (rc.left > 0 || rc.top > 0)
		(void)PostMessage(hwnd, WM_COMMAND, (WPARAM)IDM_ZOOM1, 0);
		return;
	}

	if (gwDeviceID != (UINT)0) {
	    DPF("un-minimized -- turn timer back on\n");
	    EnableTimer(TRUE);
	}

	break;
    }

    FORWARD_WM_SYSCOMMAND(hwnd, cmd, x, y, DefWindowProc);
}


int MPlayer_OnMouseActivate(HWND hwnd, HWND hwndTopLevel, UINT codeHitTest, UINT msg)
{
    if (gfPlayingInPlace && !gfOle2IPPlaying)
	return MA_NOACTIVATE;
    else
	/* !!! Is this the right thing to do in this case? */
	return FORWARD_WM_MOUSEACTIVATE(hwnd, hwndTopLevel, codeHitTest, msg,
					DefWindowProc);
}


UINT MPlayer_OnNCHitTest(HWND hwnd, int x, int y)
{
    UINT Pos;

    Pos = FORWARD_WM_NCHITTEST(hwnd, x, y, DefWindowProc);

    if (gfPlayingInPlace && (Pos == HTCLIENT))
	Pos = HTNOWHERE;

    return Pos;
}


void MPlayer_OnActivate(HWND hwnd, UINT state, HWND hwndActDeact, BOOL fMinimized)
{
    HWND hwndT;

    gfAppActive = (state != WA_INACTIVE);

    // Put the playback window BEHIND us so it's kinda
    // visible, but not on top of us (annoying).
    if (gfAppActive && !ghwndMCI && !IsIconic(hwnd) &&
	((hwndT = GetWindowMCI()) != NULL))
    {
	SetWindowPos(hwndT, hwnd, 0, 0, 0, 0,
		     SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
    }

    if (gwDeviceID != (UINT)0)
	EnableTimer(TRUE);

    /* Remember who had focus if we're being de-activated. */
    /* Give focus back to him once we're re-activated.     */
    /* Don't remember a window that doesn't belong to us,  */
    /* or when we give focus back to it, we'll never be    */
    /* able to activate!                                   */

#if 0
    /* Commenting this out for now.  This code looks dubious.
     * wParam (as was) contains state and fMinimized, so, if we're minimized,
     * it will always be non-null.
     */

    if (wParam && ghwndFocus) {
	SetFocus(ghwndFocus);
    } else if (!wParam) {
	ghwndFocus = GetFocus();
    }
#endif

    FORWARD_WM_ACTIVATE(hwnd, state, hwndActDeact, fMinimized, DefWindowProc);
}

void MPlayer_OnSysColorChange(HWND hwnd)
{
    ControlCleanup();
    ControlInit(ghInst);

    FORWARD_WM_SYSCOLORCHANGE(ghwndToolbar, SendMessage);
    FORWARD_WM_SYSCOLORCHANGE(ghwndFSArrows, SendMessage);
    FORWARD_WM_SYSCOLORCHANGE(ghwndMark, SendMessage);
    FORWARD_WM_SYSCOLORCHANGE(ghwndTrackbar, SendMessage);
}


void MPlayer_OnDropFiles(HWND hwnd, HDROP hdrop)
{
    doDrop(hwnd, hdrop);
}


LRESULT MPlayer_OnNotify(HWND hwnd, int idFrom, NMHDR FAR* pnmhdr)
{
    LPTOOLTIPTEXT pTtt;
    LPTBNOTIFY    pTbn;
    TCHAR         ach[40];

    switch(pnmhdr->code) {

    case TTN_NEEDTEXT:

	pTtt = (LPTOOLTIPTEXT)pnmhdr;

	if (gfPlayOnly && (pTtt->hdr.idFrom != IDT_PLAY)
		       && (pTtt->hdr.idFrom != IDT_PAUSE)
		       && (pTtt->hdr.idFrom != IDT_STOP)
		       && !gfOle2IPEditing)
		    break;
	switch (pTtt->hdr.idFrom) {
	    case IDT_PLAY:
	    case IDT_PAUSE:
	    case IDT_STOP:
	    case IDT_EJECT:
	    case IDT_HOME:
	    case IDT_END:
	    case IDT_FWD:
	    case IDT_RWD:
	    case IDT_MARKIN:
	    case IDT_MARKOUT:
	    case IDT_ARROWPREV:
	    case IDT_ARROWNEXT:
		LOADSTRING(pTtt->hdr.idFrom, ach);
		lstrcpy(pTtt->szText, ach);
		break;
	    default:
		*pTtt->szText = TEXT('\0');
		break;
	}

	break;

    case TBN_BEGINDRAG:
	pTbn = (LPTBNOTIFY)pnmhdr;
	if(pTbn->iItem == IDT_ARROWPREV || pTbn->iItem == IDT_ARROWNEXT)
	    SendMessage(ghwndFSArrows, WM_STARTTRACK, (WPARAM)pTbn->iItem, 0L);
	else
	    SendMessage(ghwndToolbar, WM_STARTTRACK, (WPARAM)pTbn->iItem, 0L);
	break;

    case TBN_ENDDRAG:
	pTbn = (LPTBNOTIFY)pnmhdr;
	if(pTbn->iItem == IDT_ARROWPREV || pTbn->iItem == IDT_ARROWNEXT)
	    SendMessage(ghwndFSArrows, WM_ENDTRACK, (WPARAM)pTbn->iItem, 0L);
	else
	    SendMessage(ghwndToolbar, WM_ENDTRACK, (WPARAM)pTbn->iItem, 0L);
	break;
    }

    return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * DeviceChange_Init
// First time initialization for WM_DEVICECHANGE messages
// This is specific to NT5
////////////////////////////////////////////////////////////////////////////////////////////
BOOL DeviceChange_Init(HWND hWnd)
{
	DEV_BROADCAST_DEVICEINTERFACE dbi;

	dbi.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
    dbi.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    dbi.dbcc_reserved   = 0;
    dbi.dbcc_classguid  = KSCATEGORY_AUDIO;
    dbi.dbcc_name[0] = TEXT('\0');

    MixerEventContext = RegisterDeviceNotification(hWnd,
                                         (PVOID)&dbi,
										 DEVICE_NOTIFY_WINDOW_HANDLE);
	if(!MixerEventContext)
		return FALSE;
	
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * DeviceChange_Cleanup
// Unregister the device notification.
////////////////////////////////////////////////////////////////////////////////////////////
void DeviceChange_Cleanup()
{
   if (MixerEventContext) {
       UnregisterDeviceNotification(MixerEventContext);
       MixerEventContext = NULL;
       }

   return;
}


void DisplayNoMciDeviceError()
{
    DWORD ErrorID;

    if (!lstrcmpi(gachOpenExtension, aszKeyMID))
	ErrorID = IDS_CANTPLAYMIDI;

    else if (!lstrcmpi(gachOpenExtension, aszKeyAVI))
	ErrorID = IDS_CANTPLAYVIDEO;

    else if (!lstrcmpi(gachOpenExtension, aszKeyWAV))
	ErrorID = IDS_CANTPLAYSOUND;

    else
	ErrorID = IDS_NOMCIDEVICES;

    Error(ghwndApp, ErrorID);
}


/*
 * MPlayerWndProc(hwnd, wMsg, wParam, lParam)
 *
 * This is the message processing routine for the MPLAYERBOX (main) dialog.
 *
 */
//Harmless message-cracker because the user guys will not fix their
//windowsx.h macro which cause the irritating rip.
//This is also a wee bit faster because the message
//is forwarded only on select and not on deselects.     Also we do not care
//about the params
#define HANDLE_MPLAYER_WM_MENUSELECT(hwnd, message, fn)                  \
    case (message): if(lParam)  ((fn)((hwnd), (HMENU)(lParam), (UINT)LOWORD(wParam), 0L, 0L )); break;

LRESULT FAR PASCAL MPlayerWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    switch (wMsg) {

	HANDLE_MSG(hwnd, WM_CREATE,            MPlayer_OnCreate);
	HANDLE_MSG(hwnd, WM_SHOWWINDOW,        MPlayer_OnShowWindow);
	HANDLE_MSG(hwnd, WM_SIZE,              MPlayer_OnSize);
	HANDLE_MSG(hwnd, WM_WINDOWPOSCHANGING, MPlayer_OnWindowPosChanging);
	HANDLE_MSG(hwnd, WM_WINDOWPOSCHANGED,  MPlayer_OnWindowPosChanged);
	HANDLE_MSG(hwnd, WM_PALETTECHANGED,    MPlayer_OnPaletteChanged);
	HANDLE_MSG(hwnd, WM_QUERYNEWPALETTE,   MPlayer_OnQueryNewPalette);
	HANDLE_MSG(hwnd, WM_CTLCOLORSTATIC,    MPlayer_OnCtlColor);
	HANDLE_MSG(hwnd, WM_WININICHANGE,      MPlayer_OnWinIniChange);
	HANDLE_MPLAYER_WM_MENUSELECT(hwnd, WM_MENUSELECT,        MPlayer_OnMenuSelect);
	HANDLE_MSG(hwnd, WM_NCLBUTTONDOWN,     MPlayer_OnNCLButtonDown);
	HANDLE_MSG(hwnd, WM_NCLBUTTONDBLCLK,   MPlayer_OnNCLButtonDblClk);
	HANDLE_MSG(hwnd, WM_INITMENU,          MPlayer_OnInitMenu);
	HANDLE_MSG(hwnd, WM_INITMENUPOPUP,     MPlayer_OnInitMenuPopup);
	HANDLE_MSG(hwnd, WM_GETMINMAXINFO,     MPlayer_OnGetMinMaxInfo);
	HANDLE_MSG(hwnd, WM_PAINT,             MPlayer_OnPaint);
	HANDLE_MSG(hwnd, WM_COMMAND,           MPlayer_OnCommand);
	HANDLE_MSG(hwnd, WM_CLOSE,             MPlayer_OnClose);
	HANDLE_MSG(hwnd, WM_ENDSESSION,        MPlayer_OnEndSession);
	HANDLE_MSG(hwnd, WM_DESTROY,           MPlayer_OnDestroy);
	HANDLE_MSG(hwnd, WM_TIMER,             MPlayer_OnTimer);
	HANDLE_MSG(hwnd, WM_HSCROLL,           MPlayer_OnHScroll);
	HANDLE_MSG(hwnd, WM_SYSCOMMAND,        MPlayer_OnSysCommand);
	HANDLE_MSG(hwnd, WM_MOUSEACTIVATE,     MPlayer_OnMouseActivate);
	HANDLE_MSG(hwnd, WM_NCHITTEST,         MPlayer_OnNCHitTest);
	HANDLE_MSG(hwnd, WM_ACTIVATE,          MPlayer_OnActivate);
	HANDLE_MSG(hwnd, WM_SYSCOLORCHANGE,    MPlayer_OnSysColorChange);
	HANDLE_MSG(hwnd, WM_DROPFILES,         MPlayer_OnDropFiles);
	HANDLE_MSG(hwnd, WM_NOTIFY,            MPlayer_OnNotify);

	/* Other bits of stuff that need tidying up sometime:
	 */

	case WM_NOMCIDEVICES:
	    /* This was posted by the thread building the Device
	     * menu to tell us it couldn't find any MCI devices.
	     */
	    DisplayNoMciDeviceError();
	    PostMessage(ghwndApp, WM_CLOSE, 0, 0);
	    break;

	case WM_GETDIB:
	    return (LRESULT)GetDib();

	case WM_DEVICECHANGE :
	    {
			//if plug-and-play sends this, pass it along to the component
        	PDEV_BROADCAST_DEVICEINTERFACE bid = (PDEV_BROADCAST_DEVICEINTERFACE)lParam;

			//Check to see if this is a audio message
			if (!MixerEventContext || !bid ||
			bid->dbcc_devicetype != DBT_DEVTYP_DEVICEINTERFACE ||
			!IsEqualGUID(&KSCATEGORY_AUDIO, &bid->dbcc_classguid) ||
			!(*bid->dbcc_name))
			{
				break;
			}
			else
			{
				switch(wParam)
				{
					case DBT_DEVICEQUERYREMOVE:
						CloseMCI(TRUE);          //Close the MCI device
						break;
				
			        case DBT_DEVICEREMOVECOMPLETE:
						CloseMCI(TRUE);          //Close the MCI device
						break;

					default:
						break;
				}
			}
	    }

	case WM_ENTERSIZEMOVE:
	    if (!IsIconic(hwnd) && !gfPlayOnly && !gfOle2IPEditing && !gfOle2IPPlaying)
	    {
		/* Save the current window position in x, y, dx, dy format:
		 */
		GetWindowRect(hwnd, (PRECT)&posSizeMove);
		posSizeMove.cx -= posSizeMove.x;
		posSizeMove.cy -= posSizeMove.y;
	    }
	    break;

	case WM_EXITSIZEMOVE:
	    SetRectEmpty((PRECT)&posSizeMove);
	    break;

	case WM_DOLAYOUT:
	    Layout();
	    break;

	case WM_BADREG:
	    if ( IDYES == ErrorResBox(hwnd, NULL,
		MB_YESNO | MB_ICONEXCLAMATION, IDS_APPNAME, IDS_BADREG) )
		if (!SetRegValues())
		    Error(ghwndApp, IDS_FIXREGERROR);
	    break;

	case WM_SEND_OLE_CHANGE:
	    fDocChanged = TRUE;
	    SendDocMsg((LPDOC)&docMain,OLE_CHANGED);
	    break;

	case MM_MCINOTIFY:
#if 0
	    //
	    // don't do this because, some devices send notify failures
	    // where there really is not a error.
	    //
	    if ((WORD)wParam == MCI_NOTIFY_FAILURE) {
		Error(ghwndApp, IDS_NOTIFYFAILURE);
	    }
#endif
	    UpdateDisplay();
	    break;

#ifdef OLE1_HACK
    /* Actually do the FixLink, SetData and DoVerb we've been putting off */
    /* for so long.                                                       */
	case WM_DO_VERB:
	    /* This message comes from server.c (and goes back there too) */
	    DelayedFixLink(wParam, LOWORD(lParam), HIWORD(lParam));  //OK on NT. LKG
	    break;
#endif /* OLE1_HACK */

#ifdef LATER
	// We'll need to call RegisterWindowMessage and provide a message hook proc
	// for this on Win32.

	case WM_HELP:
	    WinHelp(hwnd, TEXT("MPLAYER.HLP"), HELP_PARTIALKEY,
			    (DWORD)aszNULL);
	    return TRUE;
#endif /* LATER */

	case WM_USER_DESTROY:
	    DPF("WM_USER_DESTROY received\n");

	    if (gfPlayingInPlace) {
		DPF("****\n");
		DPF("**** Window destroyed while in place!\n");
		DPF("****\n");
		EndPlayInPlace(hwnd);
	    }

	    if (gfOle2IPEditing) {
		EndEditInPlace(hwnd);
	    }

	    if (!ItsSafeToClose()) {
		DPF("*** \n");
		DPF("*** Trying to destroy MPLAYER with an ErrorBox up\n");
		DPF("*** \n");
		gfErrorDeath = WM_USER_DESTROY;
		return TRUE;
	    }

	    if (!gfRunWithEmbeddingFlag)
		WriteOutPosition();

	    DestroyWindow(hwnd);
	    DestroyIcon(hiconApp);
	    return TRUE;

	case WM_USER+500:
	    /*
	    ** This message is sent by the HookProc inside mciole32.dll when
	    ** it detects that it should stop playing in place of a WOW client
	    ** application.
	    **
	    ** Because the OleActivate originated in mciole16.dll,
	    ** mciole32.dll does not know the OLE Object that is being
	    ** played and therefore dose not know how to close that object.
	    ** Only mplay32.exe has the necessary information, hence
	    ** mciole32.dll sends this message to mplay32.exe.
	    */
	    if (gfPlayingInPlace) {
		EndPlayInPlace(hwnd);
	    }
	    PostMessage( hwnd, WM_CLOSE, 0L, 0L );
	    break;
    }

    return DefWindowProc(hwnd, wMsg, wParam, lParam);
}



/* InitInstance
 * ------------
 *
 * Create brushes used by the program, the main window, and
 * do any other per-instance initialization.
 *
 * HANDLE hInstance
 *
 * RETURNS: TRUE if successful
 *          FALSE otherwise.
 *
 * CUSTOMIZATION: Re-implement
 *
 */
BOOL InitInstance (HANDLE hInstance)
{
    HDC      hDC;

	static SZCODE   aszNative[] = TEXT("Native");
	static SZCODE   aszEmbedSrc[] = TEXT("Embed Source");
	static SZCODE   aszObjDesc[] = TEXT("Object Descriptor");
	static SZCODE   aszMplayer[] = TEXT("mplayer");
	static SZCODE   aszClientDoc[] = TEXT("Client Document");

    /* Why doesn't RegisterClipboardFormat return a value of type CLIPFORMAT (WORD)
     * instead of UINT?
     */
    cfNative           = (CLIPFORMAT)RegisterClipboardFormat (aszNative);
    cfEmbedSource      = (CLIPFORMAT)RegisterClipboardFormat (aszEmbedSrc);
    cfObjectDescriptor = (CLIPFORMAT)RegisterClipboardFormat (aszObjDesc);
    cfMPlayer          = (CLIPFORMAT)RegisterClipboardFormat (aszMplayer);

    szClient[0] = TEXT('\0');

    lstrcpy (szClientDoc, aszClientDoc);

    // Initialize global variables with LOGPIXELSX and LOGPIXELSY

    hDC    = GetDC (NULL);    // Get the hDC of the desktop window
    giXppli = GetDeviceCaps (hDC, LOGPIXELSX);
    giYppli = GetDeviceCaps (hDC, LOGPIXELSY);
    ReleaseDC (NULL, hDC);

    return TRUE;
}


#define COINIT_APARTMENTTHREADED 2

/* InitOLE
 *
 * This should be called only when we're certain that OLE is needed,
 * to avoid loading loads of unnecessary stuff.
 *
 */
BOOL InitOLE (PBOOL pfInit, LPMALLOC *ppMalloc)
{
    HRESULT  hr;

    if (*pfInit)
	return TRUE;

    hr = (HRESULT)OleInitialize(NULL);

    if (!SUCCEEDED (hr))
    {
	DPF0("OleInitialize failed with error 0x%08x\n", hr);
	Error(NULL, IDS_OLEINIT);
	return FALSE;
    }

    if (ppMalloc && (CoGetMalloc(MEMCTX_TASK, ppMalloc) != S_OK))
    {
	Error(NULL, IDS_OLENOMEM);
	OleUninitialize();
	return FALSE;
    }
    /*****************************************************************
    ** OLE2NOTE: we must remember the fact that OleInitialize has
    **    been called successfully. the very last thing an app must
    **    do is properly shut down OLE by calling
    **    OleUninitialize. This call MUST be guarded! it is only
    **    allowable to call OleUninitialize if OleInitialize has
    **    been called SUCCESSFULLY.
    *****************************************************************/

    *pfInit = TRUE;

    return TRUE;
}


// This function cleans up all the OLE2 stuff. It lets the container
// save the object and informs that it is closing.
BOOL ExitApplication ()
{

    DPFI("\n*******Exitapp\n");
    // if we registered class factory, we must revoke it
    if(gfOle2IPEditing || gfOle2IPPlaying)
	DoInPlaceDeactivate((LPDOC)&docMain);

    SendDocMsg((LPDOC)&docMain,OLE_CLOSED);
    if (srvrMain.fEmbedding) {
	HRESULT status;
	srvrMain.fEmbedding = FALSE;    // HACK--guard against revoking twice
	status = (HRESULT)CoRevokeClassObject (srvrMain.dwRegCF);
    }

    return TRUE;
}


#ifdef DEBUG

/* DbgGlobalLock
 *
 * Debug wrapper for GlobalLock
 *
 * Checks that the memory handle to be locked isn't already locked,
 * and checks the return code from GlobalLock.
 *
 * andrewbe, 1 March 1995
 */
LPVOID DbgGlobalLock(HGLOBAL hglbMem)
{
    LPVOID lpReturn;

    if (GlobalFlags(hglbMem) & GMEM_LOCKCOUNT)
	DPF0("Calling GlobalLock on already locked memory object %08x\n", hglbMem);

    lpReturn = GlobalLock(hglbMem);

    if (lpReturn == NULL)
	DPF0("GlobalLock(%08x) failed: Error %d\n", hglbMem, GetLastError());

    return lpReturn;
}


/* DbgGlobalUnlock
 *
 * Debug wrapper for GlobalUnlock
 *
 * Checks the return code from GlobalUnlock, and outputs appropriate
 * error messages
 *
 * andrewbe, 1 March 1995
 */
BOOL DbgGlobalUnlock(HGLOBAL hglbMem)
{
    BOOL boolReturn;

    boolReturn = GlobalUnlock(hglbMem);

    if ((boolReturn) && (GlobalFlags(hglbMem) & GMEM_LOCKCOUNT))
    {
	DPF0("Locks still outstanding on memory object %08x\n", hglbMem);
    }
    else
    {
	DWORD Error = GetLastError();

	if (Error == ERROR_NOT_LOCKED)
	{
	    DPF0("Attempt to unlock already unlocked memory object %08x\n", hglbMem);
	}
	else if (Error != NO_ERROR)
	{
	    DPF0("Error %d attempting to unlock memory object %08x\n", Error, hglbMem);
	}
    }

    return boolReturn;
}


/* DbgGlobalFree
 *
 * Debug wrapper for GlobalFree.
 *
 * Checks that the global handle has no locks before freeing,
 * then checks that the call succeeded.  Error messages output
 * as appropriate.
 *
 * andrewbe, 1 March 1995
 *
 */
HGLOBAL DbgGlobalFree(HGLOBAL hglbMem)
{
    HGLOBAL hglbReturn;

    if (GlobalFlags(hglbMem) & GMEM_LOCKCOUNT)
	DPF0("Freeing global memory object %08x still locked\n", hglbMem);

    hglbReturn = GlobalFree(hglbMem);

    if (hglbReturn != NULL)
	DPF0("GlobalFree(%08x) failed: Error %d\n", hglbMem, GetLastError());

    return hglbReturn;
}


#ifdef UNICODE
/* Note: This function assumes that szFormat strings are NOT unicode.
 * Unicode var params may, however, be passed, as long as %ws is specified
 * in the format string.
 */
#endif
void FAR cdecl dprintf(LPSTR szFormat, ...)
{
    CHAR ach[_MAX_PATH * 3]; // longest I think we need
    int  s,d;
    va_list va;

    va_start(va, szFormat);
    s = wvsprintfA(ach,szFormat, va);
    va_end(va);

#if 0
    strcat(ach,"\n");
    s++;
#endif
    for (d=sizeof(ach)-1; s>=0; s--)
    {
	if ((ach[d--] = ach[s]) == TEXT('\n'))
	    ach[d--] = TEXT('\r');
    }

    /* Not unicode */
    if (*(ach+d+1) != ' ')
	OutputDebugStringA("MPLAYER: ");
    OutputDebugStringA(ach+d+1);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\ole2ui.h ===
/* NOTE: This stuff was taken from the OLE2UI library.
 * If it gets ported to NT, we can get rid of it from Media Player
 */

/*************************************************************************
** OLE OBJECT FEEDBACK EFFECTS
*************************************************************************/

#define OLEUI_HANDLES_USEINVERSE    0x00000001L
#define OLEUI_HANDLES_NOBORDER      0x00000002L
#define OLEUI_HANDLES_INSIDE        0x00000004L
#define OLEUI_HANDLES_OUTSIDE       0x00000008L


#define OLEUI_SHADE_FULLRECT        1
#define OLEUI_SHADE_BORDERIN        2
#define OLEUI_SHADE_BORDEROUT       3

/* objfdbk.c function prototypes */
STDAPI_(void) OleUIDrawHandles(LPRECT lpRect, HDC hdc, DWORD dwFlags, UINT cSize, BOOL fDraw);
STDAPI_(void) OleUIDrawShading(LPRECT lpRect, HDC hdc, DWORD dwFlags, UINT cWidth);
STDAPI_(void) OleUIShowObject(LPCRECT lprc, HDC hdc, BOOL fIsLink);


/*************************************************************************
** Hatch window definitions and prototypes                              **
*************************************************************************/
#define DEFAULT_HATCHBORDER_WIDTH   4

STDAPI_(BOOL) RegisterHatchWindowClass(HINSTANCE hInst);
STDAPI_(HWND) CreateHatchWindow(HWND hWndParent, HINSTANCE hInst);
STDAPI_(UINT) GetHatchWidth(HWND hWndHatch);
STDAPI_(void) GetHatchRect(HWND hWndHatch, LPRECT lpHatchRect);
STDAPI_(void) SetHatchRect(HWND hWndHatch, LPRECT lprcHatchRect);
STDAPI_(void) SetHatchWindowSize(
        HWND        hWndHatch,
        LPCRECT     lprcIPObjRect,
        LPCRECT     lprcClipRect,
        LPPOINT     lpptOffset,
        BOOL        handle
);



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\registry.h ===
DWORD WriteRegistryData( LPTSTR pEntryNode,
                         LPTSTR pEntryName,
                         DWORD  Type,
                         LPBYTE pData,
                         DWORD  Size );

DWORD ReadRegistryData( LPTSTR pEntryNode,
                        LPTSTR pEntryName,
                        PDWORD pType,
                        LPBYTE pData,
                        DWORD  DataSize );

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\open.c ===
/*-----------------------------------------------------------------------------+
| OPEN.C                                                                       |
|                                                                              |
| This file contains the code that controls the 'Open Device or File' dialog.  |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

/* include files */

#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>
#include <mmsystem.h>
#include "mpole.h"
#include "mplayer.h"
#include "registry.h"
#include "regstr.h"
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

extern HMENU    ghMenu;                      /* handle to main menu           */
extern HMENU    ghDeviceMenu;                /* handle to the Device menu     */
extern UINT     gwNumDevices;                /* number of available devices   */
extern UINT     gwCurDevice;
extern PTSTR    gpchFilter;
LPTSTR          gpInitialDir = NULL;

extern SZCODE aszOptionsSection[];

static SZCODE   aszNULL[] = TEXT("");
static SZCODE   aszDirName[] = TEXT("%s Directory");

BOOL GetDefaultMediaDirectory(LPTSTR pDirectory, DWORD cbDirectory);

/*
 * fOK = DoOpen()
 *
 * Invoke the standard "File Open" dialog
 *
 * Return TRUE if and only if a new file is successfully opened.
 *
 */

INT_PTR FAR PASCAL DoOpen(UINT wCurDevice, LPTSTR szFileName)
{
    OPENFILENAME    ofn;
    TCHAR           achFile[MAX_PATH + 1];     /* file or device name buffer    */
    TCHAR           achTitle[80];   /* string holding the title bar name      */
    INT_PTR         f;
    TCHAR           DirectoryValue[80];

    ZeroMemory(&ofn, sizeof ofn);

    if (!LOADSTRING(IDS_OPENTITLE, achTitle)) {
        Error(ghwndApp, IDS_OUTOFMEMORY);
        return FALSE;
    }

    if (wCurDevice != 0)
    {
        /* Saving and restoring the current directory for the device:
         *
         * We remember the directory that the user just selected.
         * It is saved as the "<device> Directory" value under
         * \Software\Microsoft\Media Player\Options for the current user.
         * The next time the user goes to open another file via the same
         * Device menu, we present the same initial directory.
         * This directory is also presented in the case where the user
         * selects File.Open.
         */
        wsprintf(DirectoryValue, aszDirName, garMciDevices[wCurDevice].szDevice);
    } else {
        //
        // If you choose Open from File menu instead of Device menu,
        // we should use "<No Name>" value instead of "<device> Directory".
        //
        DirectoryValue[0] = '\0';
    }
    if (ReadRegistryData(aszOptionsSection, DirectoryValue, NULL, (LPBYTE)achFile,
                         BYTE_COUNT(achFile)) == NO_ERROR)
    {
        DWORD FileAttrs = GetFileAttributes(achFile);

        if ((FileAttrs != (DWORD)-1) && (FileAttrs & FILE_ATTRIBUTE_DIRECTORY))
        {
            if (gpInitialDir)
                FreeStr(gpInitialDir);

            gpInitialDir = AllocStr(achFile);
        }
    }


    /* Win95 and NT have a Media directory.  Use that by default.
     */
    if (!gpInitialDir)
    {
        if (GetDefaultMediaDirectory(achFile, BYTE_COUNT(achFile)))
        {
            if (gpInitialDir)
                FreeStr(gpInitialDir);

            gpInitialDir = AllocStr(achFile);
        }
    }

    *achFile = TEXT('\0');
    /* Display the dialog box */

    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = ghwndApp;
    ofn.hInstance = ghInst;
    ofn.lpstrFilter = gpchFilter;   // in init.c

    if (wCurDevice == 0)
        ofn.nFilterIndex = gwNumDevices+1;      // select "All Files"
    else
        ofn.nFilterIndex = wCurDevice;

    ofn.lpstrFile = achFile;
    ofn.nMaxFile = sizeof(achFile);
    ofn.lpstrInitialDir = gpInitialDir;
    ofn.lpstrTitle = achTitle;
    ofn.Flags = OFN_HIDEREADONLY |
                OFN_FILEMUSTEXIST |
                OFN_SHAREAWARE |
                OFN_PATHMUSTEXIST;

    f = GetOpenFileName(&ofn);
    StringCchCopy(szFileName, 256, achFile);

    if (f) {

        LPTSTR pLastBackslash;

        //
        // get the device selected in the dialog...
        //
        if (ofn.nFilterIndex == gwNumDevices+1)
            wCurDevice = 0;    // all files
        else
            wCurDevice = (UINT)ofn.nFilterIndex;

        f = OpenMciDevice(achFile, garMciDevices[wCurDevice].szDevice);

        /* Save the directory that the user selected the file in.
         * achFile contains the full path of the file, which must include
         * at least one backslash.
         */
        pLastBackslash = STRRCHR(achFile, TEXT('\\'));

        if (pLastBackslash)
        {
            *(pLastBackslash) = TEXT('\0');     /* Make character following last
                                                       backslash null terminator */
            if (gpInitialDir)
                FreeStr(gpInitialDir);

            gpInitialDir = AllocStr(achFile);

            if (wCurDevice != 0 && gpInitialDir)
            {
                /* Save the initial directory for this device:
                 */
                WriteRegistryData(aszOptionsSection, DirectoryValue, REG_SZ,
                                  (LPBYTE)gpInitialDir, STRING_BYTE_COUNT(gpInitialDir));
            }
        }
    }

    return f;
}


/* GetDefaultMediaDirectory
 *
 * Returns C:\WINNT\Media, or whatever it's called.
 *
 */
BOOL GetDefaultMediaDirectory(LPTSTR pDirectory, DWORD cbDirectory)
{
    static SZCODE szSetup[] = REGSTR_PATH_SETUP;
    static SZCODE szMedia[] = REGSTR_VAL_MEDIA;
    HKEY          hkeySetup;
    LONG          Result;

    Result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szSetup,
                          REG_OPTION_RESERVED,
                          KEY_QUERY_VALUE, &hkeySetup);

    if (Result == ERROR_SUCCESS)
    {
        Result = RegQueryValueEx(hkeySetup, szMedia, NULL, REG_NONE,
                                 (LPBYTE)pDirectory, &cbDirectory);

        RegCloseKey(hkeySetup);
    }

    return (Result == ERROR_SUCCESS);
}


BOOL FAR PASCAL OpenMciDevice(LPCTSTR szFile, LPCTSTR szDevice)
{
    HCURSOR         hcurPrev;       /* handle to the pre-hourglass cursor     */
    BOOL            f;
    BOOL            fWeWereActive;
    UINT            wDevice;

    if (szDevice == NULL && ((wDevice = IsMCIDevice(szFile)) != 0))
        return DoChooseDevice(wDevice);

    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    /* Avoid the appearance of a half-painted window - update it now */
    UpdateWindow(ghwndApp);

    fWeWereActive = gfAppActive;

    if (gwCurDevice)
        WriteOutOptions();  // save current options as default for the old device
                            // that is being closed before we open the new one.

    gwCurDevice = IsMCIDevice(szDevice);

    //
    // open the device/file
    //
    f = OpenMCI(szFile, szDevice);

    /* Give us activation back so UpdateDisplay can set focus to toolbar */
    if (f && fWeWereActive)
        SetActiveWindow(ghwndApp);

    //
    // only get the new options if:
    //
    //  we actually opened the device and we did not get the options
    //  from a OLE SetData!
    //
    if (f && (!gfRunWithEmbeddingFlag || gwOptions == 0))
        ReadOptions(); // Get the default options for this new device

    UpdateDisplay();

    SetCursor(hcurPrev);

    return f;
}

BOOL FAR PASCAL DoChooseDevice(UINT wID)
{
    BOOL    f;
    TCHAR   szFile[256];
    UINT    wOldDevice;
    UINT    wOldScale;

    //
    // is this a valid device id?
    //
    if (wID < 1 || wID > gwNumDevices)
        return FALSE;

    wOldDevice = gwCurDevice;
    wOldScale = gwCurScale;

    //
    // if this device does files, bring up the open dialog else just open it!
    //
    if (garMciDevices[wID].wDeviceType & DTMCI_FILEDEV)
        f = OpenDoc(wID, szFile);
    else
        f = OpenMciDevice(aszNULL, garMciDevices[wID].szDevice);

    /* NOTE: This needs to be above the UpdateDisplay() so that if no      */
    /* device was properly opened everything will be reset properly.       */
    /* If nothing was opened, reset the current device back to what it was */
    /* and uncheck everything in the scale menu.                           */
    /* Yes, but this surely won't work unless we reopen the old device!!   */
    /* Let's not bother with the previous device.                          */
    if (!f) {
//        gwCurDevice = wOldDevice;
//        gwCurScale = wOldScale;
        InvalidateRect(ghwndMap, NULL, TRUE);    // wipe out track area??
    }

    return f;
}


//
//  find the device, given a MCI device name.
//
UINT FAR PASCAL IsMCIDevice(LPCTSTR szDevice)
{
    UINT                w;

    if (szDevice == NULL || *szDevice == 0)
        return 0;

    for (w=1; w<=gwNumDevices; w++)
    {
        if (lstrcmpi(szDevice, garMciDevices[w].szDevice) == 0 ||
            lstrcmpi(szDevice, garMciDevices[w].szDeviceName) == 0)

            return w;
    }

    return 0;
}

INT_PTR FAR PASCAL FixLinkDialog(LPTSTR szFile, LPTSTR szDevice, int iLen)
{
    UINT        wDevice;
    TCHAR       achFile[_MAX_PATH + 1];  /* file or device name buffer  */
    TCHAR       achTitle[80];   /* string holding the title bar name    */
    HWND        hwndFocus;
    OPENFILENAME ofn;
    INT_PTR     f;

    static SZCODE   aszDialog[] = TEXT("MciOpenDialog"); // in open.c too.

    //
    // I GIVE UP!!!  Put up an open dlg box and let them find it themselves!
    //

    /* Ensure the device menu's built:
     */
    InitDeviceMenu();
    WaitForDeviceMenu();

    // find out the device number for the specifed device
    wDevice = IsMCIDevice(szDevice);

    LOADSTRING(IDS_FINDFILE, achFile);
    wsprintf(achTitle, achFile, gachClassRoot, FileName(szFile));  // title bar for locate dlg

    /* Start with the bogus file name */
    if (szFile)
    {
        LPTSTR szFileName = FileName(szFile);
        if (szFileName)
            lstrcpy(achFile, szFileName);
    }

    /* Set up the ofn struct */
    ofn.lStructSize = sizeof(OPENFILENAME);

    /* MUST use ActiveWindow to make user deal with us NOW in case of multiple*/
    /* broken links                                                           */
    ofn.hwndOwner = GetActiveWindow();

    ofn.hInstance = ghInst;
    ofn.lpstrFilter = gpchFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;

    if (wDevice == 0)
        ofn.nFilterIndex = gwNumDevices+1;      // select "All Files"
    else
        ofn.nFilterIndex = wDevice;

    ofn.lpstrFile       = achFile;
    ofn.nMaxFile        = CHAR_COUNT(achFile);
    ofn.lpstrFileTitle  = NULL;
    ofn.nMaxFileTitle   = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle      = achTitle;

    ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST |
                OFN_SHAREAWARE | OFN_PATHMUSTEXIST;

    ofn.nFileOffset     = 0;
    ofn.nFileExtension  = 0;
    ofn.lpstrDefExt     = NULL;
    ofn.lCustData       = 0;
    ofn.lpfnHook        = NULL;
    ofn.lpTemplateName  = NULL;

    // Show the cursor in case PowerPig is hiding it
    ShowCursor(TRUE);

    hwndFocus = GetFocus();

    /* Let the user pick a filename */
    f = GetOpenFileName(&ofn);
    if (f) {
        lstrcpyn(szFile, achFile, iLen);
        gfDirty = TRUE;       // make sure the object is dirty now
    }

    SetFocus(hwndFocus);

    // Put cursor back how it used to be
    ShowCursor(FALSE);

    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\registry.c ===
#include <windows.h>
#ifdef CHICAGO_PRODUCT
#include <regstr.h>
#endif
#include "mplayer.h"

#ifdef CHICAGO_PRODUCT
TCHAR szRegPath[] = TEXT(REGSTR_PATH_WINDOWSAPPLETS "\\Media Player");
#else
TCHAR szRegPath[] = TEXT("Software\\Microsoft\\Media Player");
#endif


/* WriteRegistryData
 *
 * Writes a bunch of information to the registry
 *
 * Parameters:
 *
 *     pEntryNode - The node under szRegPath which should be created
 *         or opened for this data.  If this is NULL, the value is
 *         written directly under szRegPath.
 *
 *     pEntryName - The name of the value under pEntryNode to be set.
 *
 *     Type - Type of data to read (e.g. REG_SZ).
 *
 *     pData - Pointer to the value data to be written.  If this is NULL,
 *         the value under pEntryNode is deleted.
 *
 *     Size - Size, in bytes, of the buffer pointed to by pData.
 *
 *
 * This routine is fairly generic, apart from the name of the top-level node.
 *
 * The data are stored in the following registry tree:
 *
 * HKEY_CURRENT_USER
 *  
 *   Software
 *      
 *       Microsoft
 *          
 *           Windows NT
 *              
 *               CurrentVersion
 *                  
 *                   Media Player
 *                      
 *                       AVIVideo
 *                      
 *                       DisplayPosition
 *                      
 *                       SysIni
 *
 *
 * Return:
 *
 *     Registry status return (NO_ERROR is good)
 *
 *
 * Andrew Bell (andrewbe) wrote it, 10 September 1992
 *
 */
DWORD WriteRegistryData( LPTSTR pEntryNode,
                         LPTSTR pEntryName,
                         DWORD  Type,
                         LPBYTE pData,
                         DWORD  Size )
{
    DWORD  Status;
    HKEY   hkeyRegPath;
    HKEY   hkeyEntryNode;

    /* Open or create the top-level node.  For Media Player this is:
     * "Software\\Microsoft\\Windows NT\\CurrentVersion\\Media Player"
     */
    Status = RegCreateKeyEx( HKEY_CURRENT_USER, szRegPath, 0,
                             NULL, 0, KEY_WRITE, NULL, &hkeyRegPath, NULL );

    if( Status == NO_ERROR )
    {
        /* Open or create the sub-node.
         */
        if( pEntryNode )
            Status = RegCreateKeyEx( hkeyRegPath, pEntryNode, 0,
                                     NULL, 0, KEY_WRITE, NULL, &hkeyEntryNode, NULL );
        else
            hkeyEntryNode = hkeyRegPath;

        if( Status == NO_ERROR )
        {
            if( pData )
            {
                Status = RegSetValueEx( hkeyEntryNode,
                                        pEntryName,
                                        0,
                                        Type,
                                        pData,
                                        Size );

                if( Status != NO_ERROR )
                {
                    DPF1( "RegSetValueEx (%"DTS") failed: Error = %d\n", pEntryName, Status );
                }
            }
            else
            {
                Status = RegDeleteValue( hkeyEntryNode, pEntryName );

                if( Status != NO_ERROR )
                {
                    DPF1( "RegDeleteValue (%"DTS") failed: Error = %d\n", pEntryName, Status );
                }
            }

            if( pEntryNode )
                RegCloseKey( hkeyEntryNode );
        }

        else
        {
            DPF1( "RegCreateKeyEx (%"DTS") failed: Error = %d\n", pEntryNode, Status );
        }

        RegCloseKey( hkeyRegPath );
    }

    else
    {
        DPF1( "RegCreateKeyEx (%"DTS") failed: Error = %d\n", szRegPath, Status );
    }

    return Status;
}


/* ReadRegistryData
 *
 * Reads information from the registry
 *
 * Parameters:
 *
 *     pEntryNode - The node under Media Player which should be opened
 *         for this data.  If this is NULL, the value is
 *         written directly under szRegPath.
 *
 *     pEntryName - The name of the value under pEntryNode to be retrieved.
 *
 *     pType - Pointer to a buffer to receive type of data read.  May be NULL.
 *
 *     pData - Pointer to a buffer to receive the value data.
 *
 *     Size - Size, in bytes, of the buffer pointed to by pData.
 *
 * Return:
 *
 *     Registry status return (NO_ERROR is good)
 *
 *
 * Andrew Bell (andrewbe) wrote it, 10 September 1992
 *
 */
DWORD ReadRegistryData( LPTSTR pEntryNode,
                        LPTSTR pEntryName,
                        PDWORD pType,
                        LPBYTE pData,
                        DWORD  DataSize )
{
    DWORD  Status;
    HKEY   hkeyRegPath;
    HKEY   hkeyEntryNode;
    DWORD  Size;

    /* Open the top-level node.  For Media Player this is:
     * "Software\\Microsoft\\Windows NT\\CurrentVersion\\Media Player"
     */
    Status = RegOpenKeyEx( HKEY_CURRENT_USER, szRegPath, 0,
                           KEY_READ, &hkeyRegPath );

    if( Status == NO_ERROR )
    {
        /* Open the sub-node:
         */
        if( pEntryNode )
            Status = RegOpenKeyEx( hkeyRegPath, pEntryNode, 0,
                                   KEY_READ, &hkeyEntryNode );
        else
            hkeyEntryNode = hkeyRegPath;

        if( Status == NO_ERROR )
        {
            Size = DataSize;

            /* Read the entry from the registry:
             */
            Status = RegQueryValueEx( hkeyEntryNode,
                                      pEntryName,
                                      0,
                                      pType,
                                      pData,
                                      &Size );

            if( pEntryNode )
                RegCloseKey( hkeyEntryNode );
        }

        else
        {
            DPF1( "RegOpenKeyEx (%"DTS") failed: Error = %d\n", pEntryNode, Status );
        }

        RegCloseKey( hkeyRegPath );
    }

    else
    {
        DPF1( "RegOpenKeyEx (%"DTS") failed: Error = %d\n", szRegPath, Status );
    }

    return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\server.c ===
/*---------------------------------------------------------------------------
|   SERVER.C
|   This file has the IClassFactory Interface implementation. It also has
|   the Vtbl initializations.
|
|   Created By: Vij Rajarajan (VijR)
+---------------------------------------------------------------------------*/
#define SERVERONLY
#include <windows.h>
#include "mpole.h"
#include "mplayer.h"

extern  IID     iidUnknownObject;
extern  IID iidClassFactory;

HMODULE hMciOle;


static SZCODE aszMCIOLE[]        = TEXT("MCIOLE32.DLL");       // WOW-proofing


static ANSI_SZCODE aszOleQueryObjPos[]   = ANSI_TEXT("OleQueryObjPos");

/**************************************************************************
*   The VTBLs are initialized here.
**************************************************************************/

// Method tables.
IClassFactoryVtbl           srvrVtbl=
{
   // IOleClassFactory method table
   /*   srvrVtbl.QueryInterface         = */    SrvrQueryInterface,
   /*   srvrVtbl.AddRef                 = */    SrvrAddRef,
   /*   srvrVtbl.Release                = */    SrvrRelease,
   /*   srvrVtbl.CreateInstance         = */    SrvrCreateInstance,
   /*   srvrVtbl.LockServer             = */    SrvrLockServer
};

IOleObjectVtbl              oleVtbl =
{
   // IOleObject method table
   /* oleVtbl.QueryInterface          = */ OleObjQueryInterface,
   /* oleVtbl.AddRef                  = */ OleObjAddRef,
   /* oleVtbl.Release                 = */ OleObjRelease,
   /* oleVtbl.SetClientSite           = */ OleObjSetClientSite,
   /* oleVtbl.GetClientSite           = */ OleObjGetClientSite,
   /* oleVtbl.SetHostNames            = */ OleObjSetHostNames,
   /* oleVtbl.Close                   = */ OleObjClose,
   /* oleVtbl.SetMoniker              = */ OleObjSetMoniker,
   /* oleVtbl.GetMoniker              = */ OleObjGetMoniker,
   /* oleVtbl.InitFromData            = */ OleObjInitFromData,
   /* oleVtbl.GetClipboardData        = */ OleObjGetClipboardData,
   /* oleVtbl.DoVerb                  = */ OleObjDoVerb,
   /* oleVtbl.EnumVerbs               = */ OleObjEnumVerbs,
   /* oleVtbl.Update                  = */ OleObjUpdate,
   /* oleVtbl.IsUpToDate              = */ OleObjIsUpToDate,
   /* oleVtbl.GetUserClassID          = */ OleObjGetUserClassID,
   /* oleVtbl.GetUserType             = */ OleObjGetUserType,
   /* oleVtbl.SetExtent               = */ OleObjSetExtent,
   /* oleVtbl.GetExtent               = */ OleObjGetExtent,
   /* oleVtbl.Advise                  = */ OleObjAdvise,
   /* oleVtbl.Unadvise                = */ OleObjUnadvise,
   /* oleVtbl.EnumAdvise              = */ OleObjEnumAdvise,
   /* oleVtbl.GetMiscStatus           = */ OleObjGetMiscStatus,
   /* oleVtbl.SetColorScheme          = */ OleObjSetColorScheme,
};

IDataObjectVtbl             dataVtbl =
{
   // IDataObject method table
   /* dataVtbl.QueryInterface          = */ DataObjQueryInterface,
   /* dataVtbl.AddRef                  = */ DataObjAddRef,
   /* dataVtbl.Release                 = */ DataObjRelease,
   /* dataVtbl.GetData                 = */ DataObjGetData,
   /* dataVtbl.GetDataHere             = */ DataObjGetDataHere,
   /* dataVtbl.QueryGetData            = */ DataObjQueryGetData,
   /* dataVtbl.GetCanonicalFormatEtc   = */ DataObjGetCanonicalFormatEtc,
   /* dataVtbl.SetData                 = */ DataObjSetData,
   /* dataVtbl.EnumFormatEtc           = */ DataObjEnumFormatEtc,
   /* dataVtbl.Advise                  = */ DataObjAdvise,
   /* dataVtbl.Unadvise                = */ DataObjUnadvise,
   /* dataVtbl.EnumAdvise              = */ DataObjEnumAdvise
};

IEnumFORMATETCVtbl      ClipDragEnumVtbl =
{

   // Clipboard dataobject's formatetc enumerator method table
   /* ClipDragEnumVtbl.QueryInterface      = */ ClipDragEnumQueryInterface,
   /* ClipDragEnumVtbl.AddRef          = */ ClipDragEnumAddRef,
   /* ClipDragEnumVtbl.Release         = */ ClipDragEnumRelease,
   /* ClipDragEnumVtbl.Next        = */ ClipDragEnumNext,
   /* ClipDragEnumVtbl.Skip        = */ ClipDragEnumSkip,
   /* ClipDragEnumVtbl.Reset           = */ ClipDragEnumReset,
   /* ClipDragEnumVtbl.Clone           = */ ClipDragEnumClone
};

IPersistStorageVtbl     persistStorageVtbl =
{
   /* persistStorageVtbl.QueryInterface          = */ PSQueryInterface,
   /* persistStorageVtbl.AddRef                  = */ PSAddRef,
   /* persistStorageVtbl.Release                 = */ PSRelease,
   /* persistStorageVtbl.GetClassID              = */ PSGetClassID,
   /* persistStorageVtbl.IsDirty                 = */ PSIsDirty,
   /* persistStorageVtbl.InitNew                 = */ PSInitNew,
   /* persistStorageVtbl.Load                    = */ PSLoad,
   /* persistStorageVtbl.Save            = */ PSSave,
   /* persistStorageVtbl.SaveCompleted       = */ PSSaveCompleted,
   /* persistStorageVtbl.HandsOffStorage     = */ PSHandsOffStorage
};

IOleInPlaceObjectVtbl       ipVtbl =
{

   // IOleInPlaceObject method table
   /* ipVtbl.QueryInterface          = */ IPObjQueryInterface,
   /* ipVtbl.AddRef                  = */ IPObjAddRef,
   /* ipVtbl.Release                 = */ IPObjRelease,
   /* ipVtbl.GetWindow               = */ IPObjGetWindow,
   /* ipVtbl.ContextSensitiveHelp    = */ IPObjContextSensitiveHelp,
   /* ipVtbl.InPlaceDeactivate       = */ IPObjInPlaceDeactivate,
   /* ipVtbl.UIDeactivate            = */ IPObjUIDeactivate,
   /* ipVtbl.SetObjectRects          = */ IPObjSetObjectRects,
   /* ipVtbl.ReactivateAndUndo       = */ IPObjReactivateAndUndo
};

IOleInPlaceActiveObjectVtbl ipActiveVtbl =
{
   // IOleInPlaceActiveObject method table
   /* ipActiveVtbl.QueryInterface          = */ IPActiveQueryInterface,
   /* ipActiveVtbl.AddRef                  = */ IPActiveAddRef,
   /* ipActiveVtbl.Release                 = */ IPActiveRelease,
   /* ipActiveVtbl.GetWindow               = */ IPActiveGetWindow,
   /* ipActiveVtbl.ContextSensitiveHelp    = */ IPActiveContextSensitiveHelp,
   /* ipActiveVtbl.TranslateAccelerator    = */ IPActiveTranslateAccelerator,
   /* ipActiveVtbl.OnFrameWindowActivate   = */ IPActiveOnFrameWindowActivate,
   /* ipActiveVtbl.OnDocWindowActivate     = */ IPActiveOnDocWindowActivate,
   /* ipActiveVtbl.ResizeBorder        = */ IPActiveResizeBorder,
   /* ipActiveVtbl.EnableModeless          = */ IPActiveEnableModeless
};




IDataObjectVtbl         clipdragVtbl =
{

   // ClipDrag IDataObject method table
   /* clipdragVtbl.QueryInterface      = */ ClipDragQueryInterface,
   /* clipdragVtbl.AddRef          = */ ClipDragAddRef,
   /* clipdragVtbl.Release         = */ ClipDragRelease,
   /* clipdragVtbl.GetData         = */ ClipDragGetData,
   /* clipdragVtbl.GetDataHere         = */ ClipDragGetDataHere,
   /* clipdragVtbl.QueryGetData        = */ ClipDragQueryGetData,
   /* clipdragVtbl.GetCanonicalFormatEtc   = */ ClipDragGetCanonicalFormatEtc,
   /* clipdragVtbl.SetData         = */ ClipDragSetData,
   /* clipdragVtbl.EnumFormatEtc       = */ ClipDragEnumFormatEtc,
   /* clipdragVtbl.Advise          = */ ClipDragAdvise,
   /* clipdragVtbl.Unadvise        = */ ClipDragUnadvise,
   /* clipdragVtbl.EnumAdvise          = */ ClipDragEnumAdvise
};

IDropSourceVtbl         dropsourceVtbl =
{
   // DragDrop IDropSource method table
   /* dropsourceVtbl.QueryInterface        = */ DropSourceQueryInterface,
   /* dropsourceVtbl.AddRef                = */ DropSourceAddRef,
   /* dropsourceVtbl.Release               = */ DropSourceRelease,
   /* dropsourceVtbl.QueryContinueDrag     = */ DropSourceQueryContinueDrag,
   /* dropsourceVtbl.GiveFeedback          = */ DropSourceGiveFeedback
};

#ifdef LATER
IDropTargetVtbl         droptargetVtbl =
{
   // DragDrop IDropTarget method table
   /* droptargetVtbl.QueryInterface        = */ DropTargetQueryInterface,
   /* droptargetVtbl.AddRef                = */ DropTargetAddRef,
   /* droptargetVtbl.Release               = */ DropTargetRelease,
   /* droptargetVtbl.DragEnter             = */ DropTargetDragEnter,
   /* droptargetVtbl.DragOver              = */ DropTargetDragOver,
   /* droptargetVtbl.DragLeave             = */ DropTargetDragLeave,
   /* droptargetVtbl.Drop                  = */ DropTargetDrop
};
#endif

IPersistFileVtbl            persistFileVtbl =
{

   /* persistFileVtbl.QueryInterface             = */ PFQueryInterface,
   /* persistFileVtbl.AddRef                     = */ PFAddRef,
   /* persistFileVtbl.Release                    = */ PFRelease,
   /* persistFileVtbl.GetClassID                 = */ PFGetClassID,
   /* persistFileVtbl.IsDirty                    = */ PFIsDirty,
   /* persistFileVtbl.Load                       = */ PFLoad,
   /* persistFileVtbl.Save                       = */ PFSave,
   /* persistFileVtbl.SaveCompleted              = */ PFSaveCompleted,
   /* persistFileVtbl.GetCurFile                 = */ PFGetCurFile
};

/**************************************************************************
***************   IClassFactory INTERFACE IMPLEMENTATION.
***************************************************************************/
STDMETHODIMP SrvrQueryInterface (
LPCLASSFACTORY        lpolesrvr,
REFIID                riid,
LPVOID   FAR          *lplpunkObj
)
{

    LPSRVR  lpsrvr;
DPF("*srvrqi");
    lpsrvr = (LPSRVR)lpolesrvr;

    if (IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IClassFactory)) {
        *lplpunkObj = (LPVOID)lpsrvr;
        lpsrvr->cRef++;
        return NOERROR;
    } else {
        *lplpunkObj = (LPVOID) NULL;
    RETURN_RESULT(  E_NOINTERFACE);
    }
}


STDMETHODIMP_(ULONG) SrvrAddRef(
LPCLASSFACTORY           lpolesrvr
)
{
    LPSRVR  lpsrvr;
DPF("*srvrAR");
    lpsrvr = (LPSRVR)lpolesrvr;

    return ++lpsrvr->cRef;
}


STDMETHODIMP_(ULONG)    SrvrRelease (
LPCLASSFACTORY           lpolesrvr
)
{
    LPSRVR      lpsrvr;
DPF("*srvrREL");
    lpsrvr = (LPSRVR)lpolesrvr;
    DPFI("* SRVR CREF: %d*",lpsrvr->cRef);
    if (--lpsrvr->cRef == 0) {
        DestroyServer(lpsrvr);
        return 0;
    }

    return lpsrvr->cRef;
}


STDMETHODIMP SrvrCreateInstance (
LPCLASSFACTORY       lpolesrvr,
LPUNKNOWN            lpUnkOuter,
REFIID               riid,
LPVOID FAR           *lplpunkObj
)
{
    static BOOL fInstanceCreated = FALSE;
        DPF("*srvrcreateinst");
    /*********************************************************************
    ** OLE2NOTE: this is an SDI app; it can only create and support one
    **    instance. After the instance is created, the OLE libraries
    **    should not call CreateInstance again. it is a good practise
    **    to specifically guard against this.
    *********************************************************************/

    if (fInstanceCreated)
        RETURN_RESULT( E_FAIL);
    else {
        fInstanceCreated = TRUE;
    }

    /*********************************************************************
    ** OLE2NOTE: create and initialize a new document instance. the     **
    **    document's refcnt should start out as 1.                      **
    *********************************************************************/

    if (!InitNewDocObj(&docMain))
    RETURN_RESULT( E_OUTOFMEMORY);

    *lplpunkObj = (LPUNKNOWN) &docMain;

    return NOERROR;
}

//Increment or decrement the lock count as required. The server should not
//quit when there is a lock on the server.
STDMETHODIMP SrvrLockServer(
LPCLASSFACTORY           lpolesrvr,
BOOL                     fLock
)
{
    LPSRVR      lpsrvr;
DPF("*srvrLOCKSERVER");
    lpsrvr = (LPSRVR)lpolesrvr;

    if (fLock)
    {
    lpsrvr->cLock++;
    DPFI("CLOCK =  %d\n", lpsrvr->cLock);
    }
    else if ((--lpsrvr->cLock == 0) && (docMain.cRef == 0))
    {
    DPFI("CLOCK UNLOCK ZERO =  %d\n", lpsrvr->cLock);
    PostCloseMessage();
    }
    return NOERROR;
}



/**************************************************************************
Stub routine if we can't find MCIOLE.DLL
***************************************************************************/

OLE1_OLESTATUS FAR PASCAL NullOleQueryObjPos(LPOLEOBJECT lpobj, HWND FAR* lphwnd, LPRECT lprc, LPRECT lprcWBounds)
{
    DPF("NullQueryObjPos called, MCIOLE.DLL was not loaded\n");

    return OLE1_OLEERROR_GENERIC;
}

#ifdef OLE1_HACK
BOOL FAR PASCAL InitOle1Server(HWND hwnd, HANDLE hInst);
#endif

/**************************************************************************
*   InitServer:
*   This function initializes the server object with the IClassFactory
*   Vtbl and also load the mciole.dll library to support OLE 1.0 apps.
**************************************************************************/
BOOL InitServer (HWND hwnd, HANDLE hInst)
{
    int err;
    OQOPROC fp;

    srvrMain.olesrvr.lpVtbl = &srvrVtbl;
    srvrMain.dwRegCF=0;
    srvrMain.cRef = 0;
    srvrMain.cLock = 0;
    err = SetErrorMode(SEM_NOOPENFILEERRORBOX);
    hMciOle = LoadLibrary(aszMCIOLE);
    SetErrorMode(err);

    fp = (OQOPROC)GetProcAddress(hMciOle, aszOleQueryObjPos);

    if (hMciOle && fp)
        OleQueryObjPos = fp;                           // Avoid cast on LVALUE!!
    else
        OleQueryObjPos = (OQOPROC)NullOleQueryObjPos;

#ifdef OLE1_HACK
    InitOle1Server(hwnd, hInst);
#endif

    return TRUE;
}



void DestroyServer (LPSRVR lpsrvr)
{
    lpsrvr->fEmbedding = FALSE;
}



/**************************************************************************
*   InitNewDocObj:
*   Initializes the the lpdoc structure.
**************************************************************************/
BOOL InitNewDocObj(LPDOC lpdoc)
{                 DPFI("*INITNEWDOCOBJ*");
    // Fill the fields in the object structure.
    if(gfOle2IPEditing)
        return TRUE;
    lpdoc->cRef                     = 1;
    lpdoc->doctype                  = doctypeNew;

    lpdoc->m_Ole.lpVtbl             = &oleVtbl;
    lpdoc->m_Ole.lpdoc              = lpdoc;

    lpdoc->m_Data.lpVtbl            = &dataVtbl;
    lpdoc->m_Data.lpdoc             = lpdoc;

    lpdoc->m_PersistStorage.lpVtbl  = &persistStorageVtbl;
    lpdoc->m_PersistStorage.lpdoc   = lpdoc;

    lpdoc->lpIpData                 = NULL;
    lpdoc->m_InPlace.lpVtbl         = &ipVtbl;
    lpdoc->m_InPlace.lpdoc          = lpdoc;

    lpdoc->m_IPActive.lpVtbl        = &ipActiveVtbl;
    lpdoc->m_IPActive.lpdoc         = lpdoc;

    lpdoc->m_PersistFile.lpVtbl     = &persistFileVtbl;
    lpdoc->m_PersistFile.lpdoc      = lpdoc;

    lpdoc->aDocName             = GlobalAddAtom (TEXT("(Untitled)"));
    lpdoc->lpoleclient          = NULL;
    lpdoc->lpdaholder           = NULL;

    lpdoc->hwnd     = ghwndApp;
    lpdoc->hwndParent   = NULL;

#ifdef OLE1_HACK
    SetDocVersion( DOC_VERSION_OLE2 );
#endif /* OLE1_HACK */

   return TRUE;
}


/**************************************************************************
*   DestroyDoc:
*   This function Releases the references we hold. This function is called
*   at the termination of our operation as a server.
**************************************************************************/
void DestroyDoc (LPDOC lpdoc)
{
    if (lpdoc->lpoleclient) {

        /******************************************************************
        ** OLE2NOTE: we no longer need the ClientSite ptr, so release it **
        ******************************************************************/

        IOleClientSite_Release(lpdoc->lpoleclient);
        lpdoc->lpoleclient = NULL;
    }

    if (lpdoc->lpoaholder)
    {
        IOleAdviseHolder_Release(lpdoc->lpoaholder);
        lpdoc->lpoaholder = NULL;
    }

    if (lpdoc->lpdaholder)
    {
        IDataAdviseHolder_Release(lpdoc->lpdaholder);
        lpdoc->lpdaholder = NULL;
    }

    if (lpdoc->aDocName)
    {
        GlobalDeleteAtom (lpdoc->aDocName);
        lpdoc->aDocName = (ATOM)0;
    }

#ifdef OLE1_HACK
    SetDocVersion( DOC_VERSION_NONE );
#endif /* OLE1_HACK */
}




/* SendDocMsg
 * ----------
 *
 * This function sends a message to a specific doc object.
 *
 * LPOBJ lpobj   - The object
 * WORD wMessage - The message to send
 *
 *
 */
SCODE SendDocMsg (LPDOC lpdoc, WORD wMessage)
{
   HRESULT        status = S_OK;

   // if no clients connected, no message.
   if (lpdoc->cRef == 0)
   {
    DPFI("*OLE_NOMSG");
    return S_OK;
    }

   switch (wMessage) {
   case    OLE_CLOSED:
      // tell the clients that the UI is shutting down for this obj
      DPFI("*OLE_CLOSED");
#if 0
      //NOTE: We have to SendOnCLose for all clients even OLE1. But
      //OLE2 has bug (or by design flaw) that causes the OLE1 client
      //doc. to be marked as changed because OLE2 always resaves
      //the object even if the object has not changed. So may be we
      //should not send the SendOnClose if we just Played in the OLE1 client.

      if (gfPlayingInPlace || gfOle1Client)
           break;
#endif
        DPFI("*SENDING ONCLOSE");
      if (lpdoc->lpoaholder)
          status = IOleAdviseHolder_SendOnClose(lpdoc->lpoaholder);
      break;

   case    OLE_SAVED:
      // inform clients that the object has been saved
      DPFI("*OLE_SAVED");
      if (lpdoc->lpoaholder)
          status = IOleAdviseHolder_SendOnSave(lpdoc->lpoaholder);
      break;

   case    OLE_SAVEOBJ:
      // ask the embedding client to save the object now
      //If we are just playing then don't send this message.
#if 0
      // Yes, do, so that broken links can be fixed.
      if(gfOle2IPPlaying || gfPlayingInPlace || glCurrentVerb == OLEIVERB_PRIMARY)
        break;
#endif
      DPFI("*OLE_SAVEOBJ");
      if (lpdoc->lpoleclient)
          status = IOleClientSite_SaveObject(lpdoc->lpoleclient);
      break;

   case OLE_SHOWOBJ:
    if(lpdoc->lpoleclient)
        status = IOleClientSite_ShowObject(lpdoc->lpoleclient);
    break;

   case   OLE_CHANGED:
      // send data changed notification if any have registered
      //If we are just playing then don't send this message.
#if 0
      // Yes, do, so that broken links can be fixed.
      if(gfOle2IPPlaying || gfPlayingInPlace)
        break;
#endif
      DPFI("*OLE_CHANGED");
      if (lpdoc->lpdaholder)
          status = IDataAdviseHolder_SendOnDataChange
              (lpdoc->lpdaholder, (LPDATAOBJECT)&lpdoc->m_Data, 0, 0);
      break;

   case OLE_SIZECHG:
      // Inform clients that the size of the object has changed.
      // This is relevant only if we are inplace Editing.
    DPFI("*OLE_SIZEOBJ");
    if (gfOle2IPEditing)
    {
        RECT rc = gInPlacePosRect;
        if (ghwndMCI && gfInPlaceResize)
        {
        DPFI("***In OLE_SIZECHG gfACTIVE***");
        gfInPlaceResize = FALSE;
        }
        else if(ghwndMCI)
        {
            /* gInPlacePosRect contains the size of the in-place window
             * including playbar, if there is one.
             * Don't include the playbar on the OnPosRectChange:
             */
            DPFI("***getextent gfNotActive***");
            if (gwOptions & OPT_BAR)
                rc.bottom -= TITLE_HEIGHT;
        }

        MapWindowPoints(NULL,ghwndCntr,(POINT FAR *)&rc,(UINT)2);

        DPF("IOleInPlaceSite::OnPosRectChange %d, %d, %d, %d\n", rc);

        if (!gfInPPViewer)
            IOleInPlaceSite_OnPosRectChange(lpdoc->lpIpData->lpSite, (LPRECT)&rc);
    }
    break;
   }
   return GetScode(status);
}



BOOL ItsSafeToClose(void);

void FAR PASCAL InitDoc(BOOL fUntitled)
{

    if (gfEmbeddedObject && IsObjectDirty())
    {
        CleanObject();
    }

    if (ItsSafeToClose())
        CloseMCI(TRUE);
    if (fUntitled)
    {
        LOADSTRING(IDS_UNTITLED, gachFileDevice);
    }
}


BOOL CreateDocObjFromFile (
LPCTSTR  lpszDoc,
LPDOC    lpdoc
)
{
    lpdoc->doctype = doctypeFromFile;

    // set file name atom
    if (lpdoc->aDocName)
        GlobalDeleteAtom (lpdoc->aDocName);
    lpdoc->aDocName = GlobalAddAtom(lpszDoc);

    //SetTitle(lpdoc, lpszDoc);

    // register as running
    return TRUE;
}

//Open a new document (file or media). Subclass the playback window if
// the device has one. This will be used for drag drop operations.
BOOL OpenDoc (UINT wid, LPTSTR lpsz)
{
   if (!DoOpen(wid,lpsz))
      return FALSE;
   /**********************************************************************
   ** OLE2NOTE: shut down current doc before openning a new one. this   **
   **    will send OLE_CLOSED to any clients if they exist.             **
   **********************************************************************/
   CreateDocObjFromFile (lpsz, &docMain);

   SubClassMCIWindow();
   return TRUE;
}




/* SetTitle
 * --------
 *
 * Sets the main window's title bar. The format of the title bar is as follows
 *
 * If embedded
 *        <Server App name> - <object type> in <client doc name>
 *
 *  Example:  "SNWBOARD.AVI - Media Clip in OLECLI.DOC"
 *                where OLECLI.DOC is a Winword document
 */
BOOL SetTitle (LPDOC lpdoc, LPCTSTR lpszDoc)
{
    TCHAR szBuf[cchFilenameMax];
    TCHAR szBuf1[cchFilenameMax];

    if (lpszDoc && lpszDoc[0])
    {
        // Change document name.
        if (lpdoc->aDocName)
            GlobalDeleteAtom (lpdoc->aDocName);
        lpdoc->aDocName = GlobalAddAtom (lpszDoc);
    }

    if (gfEmbeddedObject)
    {
        if (!(gwDeviceType & DTMCI_FILEDEV) && (gwCurDevice > 0))
        {
            lstrcpy(gachWindowTitle,garMciDevices[gwCurDevice].szDeviceName);
        }

        if (lpszDoc && lpszDoc[0])
        {
            /* Load "Media Clip in %s":
             */
            if(!LOADSTRING(IDS_FORMATEMBEDDEDTITLE, szBuf))
                return FALSE;

            if (gachWindowTitle[0])
            {
                /* Format with server app name:
                 */
                wsprintf (szBuf1, TEXT("%s - %s"), gachWindowTitle, szBuf);
                wsprintf (szBuf, szBuf1, gachClassRoot, FileName (lpszDoc));
            }
            else
            {
                /* Format without server app name:
                 */
                wsprintf (szBuf1, TEXT("%s"), szBuf);
                wsprintf (szBuf, szBuf1, gachClassRoot, FileName (lpszDoc));
            }
        }
        else
        {
           return FALSE;
        }

        SetWindowText (ghwndApp, szBuf);
    }

    return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\persist.c ===
/*---------------------------------------------------------------------------
|   PERS.C
|   This file has the IPersistStorage and IPersistfile interface implementation.
|
|   Created By: Vij Rajarajan (VijR)
+---------------------------------------------------------------------------*/
#define SERVERONLY
#include <Windows.h>
#include "mpole.h"
#include "mplayer.h"
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#define STGM_SALL (STGM_READWRITE | STGM_SHARE_EXCLUSIVE)

/**************************************************************************
***************   IPersistStorage INTERFACE IMPLEMENTATION.
**************************************************************************/
//delegate to the common IUnknown implementation.
STDMETHODIMP PSQueryInterface(
LPPERSISTSTORAGE      lpPersStg,      // persist storage object ptr
REFIID            riidReq,        // IID required
LPVOID FAR *      lplpUnk         // pre for returning the interface
)
{
    return UnkQueryInterface((LPUNKNOWN)lpPersStg, riidReq, lplpUnk);
}


STDMETHODIMP_(ULONG) PSAddRef(
LPPERSISTSTORAGE      lpPersStg      // persist storage object ptr
)
{
    return UnkAddRef((LPUNKNOWN) lpPersStg);
}


STDMETHODIMP_(ULONG) PSRelease (
LPPERSISTSTORAGE      lpPersStg      // persist storage object ptr
)
{
    return UnkRelease((LPUNKNOWN) lpPersStg);
}

STDMETHODIMP  PSGetClassID (
LPPERSISTSTORAGE    lpPersStg,
CLSID FAR*      pClsid
)
{
    DPF("PSGetClassID\n");

    /* Return the actual class ID that gets stored:
     */
    *pClsid = gClsIDOLE1Compat;

    return NOERROR;
}


STDMETHODIMP  PSIsDirty (
LPPERSISTSTORAGE    lpPersStg
)
{DPF("PSIsDirty\n");

    RETURN_RESULT( (fDocChanged && !(gfPlayingInPlace || gfOle2IPPlaying))
               ? S_OK : S_FALSE);
}

STDMETHODIMP PSInitNew (
LPPERSISTSTORAGE     lpPersStg,
LPSTORAGE           lpStorage
)
{
    return NOERROR;
}


/**************************************************************************
*   PSLoad:
*   The Load method reads the embedded data from the "\1Ole10Native"
*   stream of the IStorage passed as an argument. This is because
*   we always pretend to be an OLE1 server when transferring data.
*   ItemSetData is called with this embedded data to to run the required
*   object.
**************************************************************************/
STDMETHODIMP PSLoad (
LPPERSISTSTORAGE     lpPersStg,
LPSTORAGE           lpStorage
)
{
    LPDOC   lpdoc;
    SCODE   error;
    LPSTREAM pstm;
    ULONG   cbRead;
    DWORD size = 0;
    HGLOBAL hNative = NULL;
    LPTSTR  lpnative = NULL;

    DPF("\nPSLoad is being called\n");
    lpdoc = ((struct CPersistStorageImpl FAR*)lpPersStg)->lpdoc;

    error = GetScode(IStorage_OpenStream(lpStorage, sz1Ole10Native,
                                         NULL, STGM_SALL, 0, &pstm));
    if (error == S_OK)
    {
        error = GetScode(IStream_Read(pstm, &size, 4, &cbRead));
    }
    if (error == S_OK)
    {
        hNative = GlobalAlloc(GMEM_DDESHARE |GMEM_ZEROINIT, (LONG)size);
        if (hNative)
             lpdoc->native = GLOBALLOCK(hNative);
    }

    if(lpdoc->native )
    {
        error = GetScode(IStream_Read(pstm, lpdoc->native, size, &cbRead));

        if (cbRead != size) error = E_FAIL; // REVIEW SCODE stream size error
        IStream_Release(pstm);
    }
    else error = E_OUTOFMEMORY;

    if (error == S_OK)
    {
        error = ItemSetData((LPBYTE)lpdoc->native);
        fDocChanged = FALSE;
        lpdoc->doctype = doctypeEmbedded;
    }

    if(hNative)
    {
        GLOBALUNLOCK(hNative);
        GLOBALFREE(hNative);
    }

    RETURN_RESULT( error);
}

/**************************************************************************
*   PSSave:
*   The Save method saves the native data in "\1Ole10Native" stream.
*   This is because we always pretend to be an OLE1 server when transferring
*   data. This ensures backward compatibility. GetLink is called to get
*   the embedding data.
**************************************************************************/
STDMETHODIMP PSSave (
LPPERSISTSTORAGE     lpPersStg,
LPSTORAGE           lpStorage,
BOOL            fSameAsLoad
)
{
    LPDOC   lpdoc;
    SCODE   error;
    LPSTREAM pstm = NULL;
    ULONG   cbWritten;
    DWORD_PTR   size;
    HGLOBAL hNative = NULL;
    LPTSTR  lpnative = NULL;
    LPWSTR  lpszUserType;

    DPF("* in pssave *");
    lpdoc = ((struct CPersistStorageImpl FAR*)lpPersStg)->lpdoc;

#if 0
    // Allow saves if we're playing so that broken links can be fixed.
    if (fSameAsLoad && (gfOle2IPPlaying || gfPlayingInPlace))
        RETURN_RESULT(S_OK);
#endif

    //Mark as OLE1 mplayer object.
#ifndef UNICODE
    lpszUserType = AllocateUnicodeString(gachClassRoot);
#else
    lpszUserType = gachClassRoot;
#endif

    error = GetScode(WriteClassStg(lpStorage, &gClsIDOLE1Compat));

    error = GetScode(WriteFmtUserTypeStg(lpStorage, cfMPlayer, lpszUserType));
#ifndef UNICODE
    FreeUnicodeString(lpszUserType);
#endif

    if(error != S_OK)
        RETURN_RESULT(error);
    error = GetScode(IStorage_CreateStream(lpStorage, sz1Ole10Native,
                                           STGM_SALL | STGM_FAILIFTHERE, 0,0, &pstm));
    if (error == STG_E_FILEALREADYEXISTS)
    {
        error = GetScode(IStorage_OpenStream(lpStorage, sz1Ole10Native,
                                             NULL, STGM_SALL, 0,&pstm));
        DPF("*pssave--openstream*");
    }

    if(pstm && (error == S_OK))
        hNative = GetLink();

    if (hNative)
    {
        lpnative = GLOBALLOCK(hNative);
        size = GlobalSize(hNative);
    }
    else
        error = E_OUTOFMEMORY;

    if (lpnative && (size != 0L))
    {
        error = GetScode(IStream_Write(pstm, &size, 4, &cbWritten));
        error = GetScode(IStream_Write(pstm, lpnative, (ULONG)size, &cbWritten));

        DPF("\n*After pssave write");
        if (cbWritten != size) error = E_FAIL   ;   // REVIEW SCODE stream full error
        IStream_Release(pstm);
    }

    CleanObject();
    GLOBALUNLOCK(hNative);
    GLOBALFREE(hNative);
    RETURN_RESULT(error);
}

/* InPowerPointSlideView
 *
 * Check the class name of the container window to see if we're in PowerPoint.
 * This is to support the horrible hack to get around problem of PowerPoint
 * crashing if we delete an empty Media Clip.
 *
 */
STATICFN BOOL InPowerPointSlideView()
{
    TCHAR ClassName[256];

    if (GetClassName(ghwndCntr, ClassName, CHAR_COUNT(ClassName)) > 0)
    {
        if (lstrcmp(ClassName, TEXT("paneClassDC")) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}

STDMETHODIMP PSSaveCompleted (
LPPERSISTSTORAGE    lpPersStg,
LPSTORAGE           lpStorage
)
{
    LPDOC   lpdoc;
    DPF("\n**pssavecompleted**");
    lpdoc = ((struct CPersistStorageImpl FAR*)lpPersStg)->lpdoc;

    /* Win95 HOT bug #11142
     *
     * Stop PowerPoint crashing horribly:
     */
    if ((gwDeviceID == 0) && InPowerPointSlideView())
        SendDocMsg(lpdoc, OLE_CHANGED);

    // inform clients that the object has been saved
    return SendDocMsg (lpdoc, OLE_SAVED);
}

STDMETHODIMP PSHandsOffStorage (
LPPERSISTSTORAGE    lpPersStg
)
{
    return NOERROR;
}



/**************************************************************************
************   IPersistFile INTERFACE IMPLEMENTATION.
**************************************************************************/
//delegate to common IUnknown implementation.
STDMETHODIMP PFQueryInterface(
LPPERSISTFILE       lpPersFile,      // persist storage object ptr
REFIID            riidReq,        // IID required
LPVOID FAR *      lplpUnk         // pre for returning the interface
)
{
    return UnkQueryInterface((LPUNKNOWN)lpPersFile, riidReq, lplpUnk);
}


STDMETHODIMP_(ULONG) PFAddRef(
LPPERSISTFILE       lpPersFile      // persist storage object ptr
)
{
    return UnkAddRef((LPUNKNOWN) lpPersFile);
}


STDMETHODIMP_(ULONG) PFRelease (
LPPERSISTFILE       lpPersFile      // persist storage object ptr
)
{
    return UnkRelease((LPUNKNOWN) lpPersFile);
}


STDMETHODIMP  PFGetClassID (
LPPERSISTFILE       lpPersFile,
CLSID FAR*      pCid
)
{
    DPF("\n* PFGetclassid");

    /* The docs are confusing here, but apparently IPersist interfaces
     * should return the old class ID:
     */
    *pCid = gClsIDOLE1Compat;

    return NOERROR;
}


STDMETHODIMP  PFIsDirty (
LPPERSISTFILE       lpPersFile
)
{
    RETURN_RESULT( gfDirty ? S_OK : S_FALSE);
}



//This will be called when the user does a "Insert->Create from file".
//Open the file with OpenMciDevice and we will be ready to transfer the
//object.
STDMETHODIMP PFLoad (
LPPERSISTFILE       lpPersFile,
LPCWSTR             lpszFileName,
DWORD           grfMode
)
{
    size_t  nLen;
    LPDOC   lpdoc;
    TCHAR   szFileName[256];

	if(FAILED(StringCchLength(lpszFileName, 256, &nLen)))
        RETURN_RESULT(E_FAIL);

	//Don't even attempt to deal with file names greater then 256
	//Don't worry about nonUnincode so casting as LPTSTR
	if(nLen > 255)
		RETURN_RESULT(E_FAIL);

    lpdoc = ((struct CPersistStorageImpl FAR*)lpPersFile)->lpdoc;
    DPF("\n***IN PFLOAD: "DTS"\n", lpszFileName);
#if UNICODE
    lstrcpy(szFileName, lpszFileName);
#else
    UnicodeToAnsiString(lpszFileName, szFileName, UNKNOWN_LENGTH);
#endif
    if(OpenMciDevice(szFileName, NULL))
        RETURN_RESULT(S_OK);
    else
        RETURN_RESULT(E_FAIL);
}


STDMETHODIMP PFSave (
LPPERSISTFILE       lpPersFile,
LPCWSTR             lpszFileName,
BOOL                fRemember
)
{
    return NOERROR;
}



STDMETHODIMP PFSaveCompleted (
LPPERSISTFILE       lpPersFile,
LPCWSTR             lpszFileName
)
{
    LPDOC   lpdoc;

    lpdoc = ((struct CPersistStorageImpl FAR*)lpPersFile)->lpdoc;

    // inform clients that the object has been saved
    return SendDocMsg(lpdoc, OLE_SAVED);
}




STDMETHODIMP PFGetCurFile (
LPPERSISTFILE       lpPersFile,
LPWSTR FAR*         lplpszFileName
)
{
    RETURN_RESULT( E_NOTIMPL);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\server.h ===
/*-----------------------------------------------------------------------------+
| SERVER.H                                                                     |
|                                                                              |
| (C) Copyright Microsoft Corporation 1992.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

//
// this function is in MCIOLE.DLL
//

/* This is defined (as an enum) in ole.h:
 */
typedef UINT OLESTATUS;

//
//  global variables of doom!!
//
extern BOOL    gfEmbeddedObject;       // TRUE if editing embedded OLE object
extern BOOL    gfRunWithEmbeddingFlag; // TRUE if we are run with "-Embedding"
extern BOOL    gfCloseAfterPlaying;    // TRUE if we are to hide after play
extern BOOL    gfPlayingInPlace;       // TRUE if playing in place
extern BOOL    gfParentWasEnabled;     // TRUE if parent was enabled
extern BOOL    gfShowWhilePlaying;     //
extern BOOL    gfDirty;                //
extern int     gfErrorBox;             // TRUE if we have a message box active
extern BOOL    gfErrorDeath;           // Die when errorbox is up

// server related stuff.
#define SERVER_STUFF
#ifdef SERVER_STUFF
//typedef struct  _SRVR  *PSRVR;
//typedef struct  _SRVR  FAR *LPSRVR;
#endif /* SERVER_STUFF */

void FAR PASCAL ServerUnblock(void);
void FAR PASCAL BlockServer(void);
void FAR PASCAL UnblockServer(void);

void FAR PASCAL PlayInPlace(HWND hwndApp, HWND hwndClient, LPRECT prc);
void FAR PASCAL EndPlayInPlace(HWND hwndApp);
void FAR PASCAL DelayedFixLink(UINT verb, BOOL fShow, BOOL fActivate);

void CleanObject(void);
void UpdateObject(void);
BOOL FAR PASCAL IsObjectDirty(void);

#ifdef SERVER_STUFF
#ifdef REDEFINITION
typedef  struct _SRVR {
    OLESERVER     olesrvr;
    LHSERVER      lhsrvr;         // registration handle
    HWND          hwnd;           // corresponding server window
}SRVR;
#endif /* REDEFINITION */

//BOOL FAR PASCAL InitServer (HWND, HANDLE, LPTSTR);
void FAR PASCAL TermServer (void);

typedef struct _OLECLIENT FAR*  LPOLECLIENT;


#ifdef REDEFINITION
// server related stuff.
typedef struct  _DOC  *PDOC;

typedef  struct _DOC {
    OLESERVERDOC     oledoc;
    LHSERVERDOC      lhdoc;         // registration handle
    HWND             hwnd;          // corresponding server window
    ATOM             aName;         // docmnet name.
} DOC ;
#endif /* REDEFINITION */

#ifdef UNUSED

OLESTATUS FAR PASCAL  DocSave (LPOLESERVERDOC);
OLESTATUS FAR PASCAL  DocClose (LPOLESERVERDOC);
OLESTATUS FAR PASCAL  DocRelease (LPOLESERVERDOC);
OLESTATUS FAR PASCAL  DocGetObject (LPOLESERVERDOC, OLE_LPCSTR, LPOLEOBJECT FAR *, LPOLECLIENT);
OLESTATUS FAR PASCAL  DocSetDocDimensions (LPOLESERVERDOC, OLE_CONST RECT FAR*);
OLESTATUS FAR PASCAL  DocSetHostNames (LPOLESERVERDOC, OLE_LPCSTR, OLE_LPCSTR);
OLESTATUS FAR PASCAL  DocExecute (LPOLESERVERDOC, HANDLE);
OLESTATUS FAR PASCAL  DocSetColorScheme (LPOLESERVERDOC, OLE_CONST LOGPALETTE FAR*);

#endif /* UNUSED */

//typedef struct _ITEM     *PITEM;
//typedef struct _ITEM FAR *LPITEM;

//typedef struct _ITEM  {   /*OLEOBJECT*/
//    OLEOBJECT   oleobject;
//    LPOLECLIENT lpoleclient;
//    HWND        hwnd;
//}ITEM;

//OLESTATUS FAR PASCAL  ItemOpen (LPOLEOBJECT, BOOL);
//OLESTATUS FAR PASCAL  ItemDoVerb (LPOLEOBJECT, UINT, BOOL, BOOL);
//OLESTATUS FAR PASCAL  ItemRelease (LPOLEOBJECT);
//OLESTATUS FAR PASCAL  ItemGetData (LPOLEOBJECT, OLECLIPFORMAT, LPHANDLE);
//OLESTATUS FAR PASCAL  ItemSetData (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
//OLESTATUS FAR PASCAL  ItemSetTargetDevice (LPOLEOBJECT, HANDLE);
//OLECLIPFORMAT   FAR PASCAL ItemEnumFormats (LPOLEOBJECT, OLECLIPFORMAT);
//OLESTATUS FAR PASCAL  ItemSetColorScheme (LPOLEOBJECT, OLE_CONST LOGPALETTE FAR*);
//OLESTATUS FAR PASCAL  ItemSetBounds (LPOLEOBJECT, OLE_CONST RECT FAR*);

//!!extern SRVR gSrvr;
//!!extern DOC  gDoc;
//!!extern ITEM gItem;

int  FAR PASCAL SendChangeMsg(UINT options); //!!!

void FAR PASCAL TerminateServer(void);

//void FAR PASCAL NewDoc(BOOL fUntitled);
//BOOL FAR PASCAL RegisterDocument(LHSERVERDOC lhdoc, LPOLESERVERDOC FAR *lplpoledoc);
//void FAR PASCAL RevokeDocument(void);

/* ole.h:
 */
typedef WORD OLECLIPFORMAT;

extern OLECLIPFORMAT  cfLink;
extern OLECLIPFORMAT  cfOwnerLink;
extern OLECLIPFORMAT  cfNative;

void FAR PASCAL SetEmbeddedObjectFlag(BOOL flag);

void FAR PASCAL CopyObject(HWND hwnd);

#define WM_USER_DESTROY (WM_USER+120)
#define WM_DO_VERB      (WM_USER+121)     /* Perform the ItemSetData      */

#endif /* SERVER_STUFF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\toolbar.h ===
/*-----------------------------------------------------------------------------+
| TOOLBAR.H                                                                    |
|                                                                              |
| Program Description: Implements a generic toolbar.                           |
|                                                                              |
| Here's how to use it:                                                        |
|                                                                              |
|           Include the source files "toolbar.h" and "toolbar.c" in your       |
| application.                                                                 |
|                                                                              |
|           Include a line in your application's RC file that gives a file     |
| name with a resource id eg. IDBMP_BUTTONS.  This is a .BMP file that         |
| contains all of the pictures of the buttons you want on your toolbar.        |
| Also, make a define for your label with a unique value.  If your app has     |
| more than one toolbar, and all toolbars don't share a bitmap file, then      |
| you will need several defines.                                               |
|                                                                              |
| e.g.         IDBMP_BUTTONS     BITMAP     "buttons.bmp"                      |
|              IDBMP_ARROWS      BITMAP     "arrows.bmp"                       |
|                                                                              |
|           This file must have the different buttons across horizontally      |
| and the different states for these buttons vertically.  Change the           |
| defines in this header file to match the button names and state names of     |
| your buttons.  You must include the states listed here, and actually         |
| you probably won't need to change them at all.  The numbers for a button     |
| or state are indexes into the bitmap, so the pictures must match.            |
|                                                                              |
| STATE DESCRIPTIONS:                                                          |
|                      GRAYED:  The button cannot be pressed & is inactive     |
|                          UP:  The button is up                               |
|                        DOWN:  The button is down                             |
|                     FOCUSUP:  The button is up and is the one with focus     |
|                   FOCUSDOWN:  The button is down and is the one with focus   |
|                    FULLDOWN:  A checkbox button has this additional state    |
|                               where it is all the way down when pressed      |
|                               and when it is let go, it will go into         |
|                               either the UP or DOWN state (maybe focused)    |
|                                                                              |
| When you draw the pictures, make sure to get the right state in the right    |
| vertical position in the bitmap to match the #define's.                      |
|                                                                              |
| A button can also have a type associated with it:                            |
|                                                                              |
|                PUSH:  When pressed it goes down, when let go it bounces      |
|                       up.  Therefore, when you aren't currently holding      |
|                       the mouse button or space bar on it, it will           |
|                       ALWAYS be in the up position. It can be in any         |
|                       state except FULLDOWN, which is invalid.               |
|                                                                              |
|            CHECKBOX:  This button can be up or down.  When pushed, it        |
|                       toggles into the opposite state.  However, it          |
|                       is always in the FULLDOWN state when being held        |
|                       down with the mouse button or space bar, and when      |
|                       let go, it will go into the opposite state of what     |
|                       it was in before you pressed it.  E.G.  The button     |
|                       is up.  You press it, and it goes way down. You let    |
|                       go, and it comes up a bit, but it's still down.  You   |
|                       press it again, and it goes further down before        |
|                       popping all the way up.                                |
|                                                                              |
|               RADIO:  This is a group of buttons that can be up or down,     |
|                       and also have the intermediate step of being           |
|                       FULLDOWN when being held down.  But, when you          |
|                       push one of the radio buttons down, all other radio    |
|                       buttons in its group will pop up.  Any group can       |
|                       have only 1 down at a time, and 1 must be down.        |
|                                                                              |
|               CUSTOM: If your application is wierd, you can have a custom    |
|                       type button that does anything you want it to.         |
|                                                                              |
| First, your app must call:    toolbarInit(hInst, hPrev);                     |
| with the two instance parameters to register a toolbar window class.         |
| Then your app is free to call CreateWindow with a class of                   |
| szToolBarClass   to create one or more toolbar windows anywhere it wants     |
| and of any size it wants, presumably as the child window of another of the   |
| app's windows.  The file that creates the window must declare an             |
| extern char szToolBarClass[];   All messages about activity to a toolbar     |
| button will go to the parent window of the toolbar.                          |
|                                                                              |
| Next, call:     toolbarSetBitmap(HWND hwnd, HANDLE hInst, int ibmp,          |
|                                                       POINT ptSize);         |
| Pass it the resource ID (eg. IDBMP_BUTTONS) to tell the toolbar where to     |
| find the pictures for the buttons.  Also pass a point with the width and     |
| height of each button (eg. 24 X 22) so it knows how to find individual       |
| buttons in the bitmap file.                                                  |
|                                                                              |
| Next, call:     toolbarAddTool(HWND hwnd, TOOLBUTTON tb);                    |
| as many times as you want to add a button to the toolbar specified by        |
| hwnd.  You fill in the "tb" struct with the following information:           |
|                                                                              |
|      tb.rc        = the rect in the toolbar window to place the button       |
|                     based at 0,0 and measured in pixels.                     |
|      tb.iButton   = the ID of the button you wish the add (which is          |
|                     the horizontal offset into the bitmap of buttons).       |
|                     Only one of each button allowed.  Use one of the         |
|                     defines (BTN_??????).                                    |
|      tb.iState    = the initial state of the button (GRAYED, UP, DOWN).      |
|                     If you wish, you can specify a FOCUS'ed state to give    |
|                     any button you wish the focus.  By default, it's the     |
|                     one furthest left and tabbing order goes to the right.   |
|                     This is the vertical offset into the bitmap.             |
|                     Use one of the defines (BTNST_?????).                    |
|      tb.iType     = The type of button (BTNTYPE_???).  Either pushbutton,    |
|                     checkbox, or radio button. (or custom).  If it is a      |
|                     radio button, you can have many groups of radio btn's    |
|                     on the same toolbar.  Type BTNTYPE_RADIO is one group.   |
|                     Use BTNTYPE_RADIO+1 for another group, BTNTYPE_RADIO+2   |
|                     for a third group, etc.  You have thousands.             |
|      tb.iString   = The resource ID of a string to be associated with        |
|                     this button (if you'd like).                             |
|                                                                              |
|                                                                              |
|  At any time in the app, you can call toolbarAddTool to add more buttons     |
|  or toolbarRemoveTool to take some away.  To take one away, identify it      |
|  with it's button ID (horizontal offset in the bitmap).                      |
|                                                                              |
|  You can also call toolbarRetrieveTool to get the TOOLBUTTON struct back     |
|  from a button that is on the toolbar.  This is the way to change a          |
|  button's position.  Change the tb.rc and then Remove and Add the button     |
|  again so that the tabbing order will be re-calculated based on the new      |
|  rect of the tool.                                                           |
|                                                                              |
|  Now, all buttons will automatically behave properly.  They'll go up and     |
|  down as you press on them, or use the keyboard, groups of radio buttons     |
|  will pop up as you press a different one down, etc. etc. etc.               |
|  You don't have to do a thing!                                               |
|                                                                              |
|  The parent of the toolbar window will get a WM_COMMAND message with         |
|  a wParam of IDC_TOOLBAR  whenever anything happens to a button.             |
|  On Win16:                                                                   |
|    LOWORD(lParam) == hwnd of the toolbar window that has the button on it.   |
|    (HIWORD(lParam) & 0xFF) == the button ID of the button.                   |
|  On Win32:                                                                   |
|    lParam         == hwnd of the toolbar window that has the button on it.   |
|    (HIWORD(wParam) & 0xFF) == the button ID of the button.                   |
|    (This relies on a 32 bit button id being ACTUALLY only 16 bits            |
|     Someday this could go sour and need redesign).                           |
|                                                                              |
|  Remember to change IDC_TOOLBAR to something unique.                         |
|                                                                              |
|  The app can then call   toolbarIndexFromButton(hwnd, buttonID)              |
|  to get the index of the button (used for subsequent calls).                 |
|                                                                              |
|  Then call:      toolbarStateFromButton(hwnd, buttonID)                      |
|                                                                              |
|                  to get either BTNST_UP or BTNST_DOWN.  This is the          |
|                  NEW state of the button since the activity on the           |
|                  button.  It can also be BTNST_GRAYED, but you won't get     |
|                  any activity messages while it's grayed, unless it is a     |
|                  cutsom button.                                              |
|                                                                              |
|            Call  toolbarFullStateFromButton(hwnd, buttonID)                  |
|                                                                              |
|                  to get more detail about the state.  It can also return     |
|                  BTNST_FULLDOWN as well as the above states. In the case     |
|                  of BTNST_FULLDOWN, you'll have to call                      |
|                  toolbarPrevStateFromButton(hwnd, btn ID) to get the state   |
|                  before it went full down.                                   |
|                                                                              |
|                  toolbarPrevStateFromButton(hwnd, buttonID)                  |
|                                                                              |
|                  is only valid when the state is BTNST_FULLDOWN.             |
|                                                                              |
|                  toolbarActivityFromIndex(hwnd, buttonID)                    |
|                                                                              |
|                  tells you what just happened to the button.                 |
|                  BTNACT_KEYDOWN, BTNACT_MOUSEUP, etc. are possibilities.     |
|                  BTNACT_MOUSEMOUSEOFF means that they pressed it down and    |
|                  moved the mouse off of the button (  so it was re- drawn    |
|                  in its previous state before being pressed).                |
|                  BTNACT_MOUSEMOUSEON  means that the above happened and      |
|                  then the mouse moved back on top of the button again, so    |
|                  the button was re-drawn as if it was pushed again.          |
|                                                                              |
|                  For any of the above activities.......                      |
|                                                                              |
|  HIWORD & BTN_SHIFT     is set if this activity involves the right mouse     |
|                         button, or else it is clear.                         |
|  HIWORD & BTN_DBLCLICK  is set means that this mouse button down activity    |
|                         is really a double click (if you care).              |
|                                                                              |
|          If you are a custom button, you can also receive this message...    |
|                                                                              |
|  HIWORD & BTN_REPEAT    is set means that the button or key is being held    |
|                         down, and you are being sent many down messages      |
|                         in a row.  The first such message is sent with       |
|                         this flag clear, all others have this flag set.      |
|                         If you are a custom button, you will have to         |
|                         ignore messages that are repeats if you don't        |
|                         want to get many down messages in a row.             |
|                                                                              |
|                                                                              |
|                   toolbarStringFromIndex(hwnd, index)                        |
|                                                                              |
|                   will return you the string resource ID you gave when       |
|                   you registered this button.                                |
|                                                                              |
|                                                                              |
| IMPORTANT !!!!!!!!!!!!!!!!!!!                                                |
| =============================                                                |
|                                                                              |
| When you get the state of a button, it's already been changed by the         |
| activity so it's the NEW STATE!!!!!!!!!                                      |
|                                                                              |
|  EXCEPT!!!   for a custom button!  For a custom button, NOTHING WILL         |
|  happen, you have to do it all yourself!!!! So the state is going to be      |
|  the state BEFORE the activity and you have to call                          |
|  toolbarModifyState(hwnd, buttonID, newState) to change the state            |
|  yourself!!!!                                                                |
|                                                                              |
|  You also have toolbarGetNumButtons(hwnd) to tell you how many are on the    |
|  the toolbar.                                                                |
|  And... you have other routines you can use if you really want.              |
|                                                                              |
|  ENJOY!!                                                                     |
|                                                                              |
| P.S.  Don't forget to pass on WM_SYSCOLORCHANGE msgs to each toolbar.        |
|                                                                              |
|                                                                              |
| (C) Copyright Microsoft Corporation 1992.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
| Created by Danny Miller, based on David Maymudes' code                       |
|           which was based on Todd Laney's SBUTTON code                       |
|           and stuff from Eric Ledoux.  Did I miss any-                       |
|           body?                                                              |
|    Oct-1992 Laurie Griffiths converted it to 32/16 bit                       |
|             common code.  Mike Tricker reviewed it.                          |
|                                                                              |
+-----------------------------------------------------------------------------*/

#include "ctrls.h"

#define TOOLGROW        8                // power of 2

#define IDC_TOOLBAR   189                // wParam sent to Parent

/* We keep an array of these around (one for each button on the toolbar) */

typedef struct {
        RECT       rc;             // draw it at this postion in the toolbar
        int        iButton;        // it's this button
        int        iState;         // in this state
        int        iPrevState;     // for non-push buttons - last state
        int        iType;          // type of button
        int        iActivity;      // what just happened to button
        int        iString;        // string resource associated with button
} TOOLBUTTON, FAR *LPTOOLBUTTON;

HWND CreateStaticStatusWindow(HWND hwndParent,BOOL fSizeGrip);
BOOL WriteStatusMessage(HWND hwnd, LPTSTR szMsg);
BOOL GetStatusTextExtent(HWND hwnd, LPSIZE pTextExtent);

/* We keep an array of these around (one for each button on the toolbar) */

BOOL FAR PASCAL toolbarInit(void);
HWND FAR PASCAL toolbarCreateMain(HWND hwndParent);
HWND FAR PASCAL toolbarCreateMark(HWND hwndParent);
HWND FAR PASCAL toolbarCreateArrows(HWND hwndParent);
BOOL FAR PASCAL toolbarStateFromButton(HWND hwnd, int iButton, int tbIndex);
BOOL FAR PASCAL toolbarAddTool(HWND hwnd, int iButton, int tbIndex, int iState);
BOOL FAR PASCAL toolbarSwapTools(HWND hwnd, int iButton, int jButton, int tbIndex);
BOOL FAR PASCAL toolbarRemoveTool(HWND hwnd, int iButton, int tbIndex);
BOOL FAR PASCAL toolbarModifyState(HWND hwnd, int iButton, int tbIndex, int iState);
BOOL FAR PASCAL toolbarSetFocus(HWND hwnd, int iButton);


HBITMAP FAR PASCAL  LoadUIBitmap(
    HANDLE      hInstance,          // EXE file to load resource from
    LPCTSTR     szName,             // name of bitmap resource
    COLORREF    rgbText,            // color to use for "Button Text"
    COLORREF    rgbFace,            // color to use for "Button Face"
    COLORREF    rgbShadow,          // color to use for "Button Shadow"
    COLORREF    rgbHighlight,       // color to use for "Button Hilight"
    COLORREF    rgbWindow,          // color to use for "Window Color"
    COLORREF    rgbFrame);          // color to use for "Window Frame"

/* In a bitmap file, each button is the same size, and contains
 * the picture of a button.  Each column contains the picture of a distinct
 * button (e.g. BTN_REWIND, BTN_REVERSE, etc.) and each row contains
 * a specific button state (BTNST_UP, BTNST_DOWN,
 * BTNBAR_GRAYED, etc. just as an example).
 *
 */

#define TB_FIRST            -1
#define TB_LAST             -2

#define BTN_PLAY            0
#define BTN_PAUSE           1
#define BTN_STOP            2
#define BTN_EJECT           3
#define BTN_HOME            4
#define BTN_RWD             5
#define BTN_FWD             6
#define BTN_END             7

#define ARROW_PREV          0
#define ARROW_NEXT          1

#define BTN_MARKIN          0
#define BTN_MARKOUT         1

#define BTNST_GRAYED        0
#define BTNST_UP            1
#define BTNST_DOWN          2
#define BTNST_FOCUSUP       3
#define BTNST_FOCUSDOWN     4
#define BTNST_FULLDOWN      5

#define BTN_REPEAT          0x100        // add this to button index
#define BTN_SHIFT           0x200
#define BTN_DBLCLICK        0x400


/* constants */
#define MSEC_BUTTONREPEAT   200        // milliseconds for auto-repeat

/* timers */
#define TIMER_BUTTONREPEAT  1        // timer for button auto-repeat

/* bitmap resources */
#define IDBMP_TOOLBAR       100        // main toolbar
#define IDBMP_ARROWS        101        // arrows for scrollbar
#define IDBMP_MARK          102        // arrows for scrollbar
                                        // 103 and 104 used by track.h

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\track.c ===
/*-----------------------------------------------------------------------------+
| TRACK.C                                                                      |
|                                                                              |
| Contains the code which implements the track bar                             |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

#include <windows.h>
#include <mmsystem.h>
#include <windowsx.h>
#include "mplayer.h"
#include "toolbar.h"
#include "tracki.h"


WNDPROC fnTrackbarWndProc = NULL;


/* TB_OnKey
 *
 * Handles WM_KEYDOWN and WM_KEYUP messages.
 *
 * If the shift key is pressed while we're playing or scrolling
 * treat it as a start selection.  End the selection on the key-up
 * message.
 *
 * Clear any selection if the escape key is pressed.
 *
 */
void TB_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags)
{
    int cmd = -1;

    switch(vk)
    {
    case VK_SHIFT:
        /* Check that the key wasn't already down:
         */
        if (fDown && !(flags & 0x4000))
        {
            if(((gwStatus == MCI_MODE_PLAY) || gfScrollTrack)
             &&(toolbarStateFromButton(ghwndMark, BTN_MARKIN, TBINDEX_MARK)
                                                       != BTNST_GRAYED))
                SendMessage(hwnd, WM_COMMAND, IDT_MARKIN, 0);
        }

        /* If !fDown, it must be fUp:
         */
        else if (!fDown)
        {
            if (SendMessage(ghwndTrackbar, TBM_GETSELSTART, 0, 0) != -1)
                SendMessage(hwnd, WM_COMMAND, IDT_MARKOUT, 0);
        }
        break;

    case VK_ESCAPE:
        SendMessage(ghwndTrackbar, TBM_CLEARSEL, (WPARAM)TRUE, 0);
        break;

    default:
        if (fDown)
        {
//          Don't do this, because the common-control trackbar sends us
//          WM_HSCROLL in response to this, which causes us to increment twice:
//          FORWARD_WM_KEYDOWN(hwnd, vk, cRepeat, flags, fnTrackbarWndProc);

            switch (vk)
            {
            case VK_HOME:
                cmd = TB_TOP;
                break;

            case VK_END:
                cmd = TB_BOTTOM;
                break;

            case VK_PRIOR:
                cmd = TB_PAGEUP;
                break;

            case VK_NEXT:
                cmd = TB_PAGEDOWN;
                break;

            case VK_LEFT:
            case VK_UP:
                cmd = TB_LINEUP;
                break;

            case VK_RIGHT:
            case VK_DOWN:
                cmd = TB_LINEDOWN;
                break;

            default:
                break;
            }
        }
        else
        {
            FORWARD_WM_KEYUP(hwnd, vk, cRepeat, flags, fnTrackbarWndProc);
            return;
        }

        if (cmd != -1)
            SendMessage(GetParent(hwnd), WM_HSCROLL, MAKELONG(cmd, 0), (LPARAM)hwnd);
    }
}



/* Subclass the window so that we can handle the key presses
 * we're interested in.
 */


/* TBWndProc() */


LONG_PTR FAR PASCAL
SubClassedTrackbarWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        HANDLE_MSG(hwnd, WM_KEYDOWN, TB_OnKey);
        HANDLE_MSG(hwnd, WM_KEYUP,   TB_OnKey);

    /* HACK ALERT
     *
     * This is to get around a bug in the Chicago common control trackbar,
     * which is sending too many TB_ENDTRACK notifications.
     * It sends one when it receives WM_CAPTURECHANGED, even if it called
     * ReleaseCapture itself.
     * So, if we're not currently scrolling, ignore it.
     */
    case WM_CAPTURECHANGED:
        if (!gfScrollTrack)
            return 0;

    case TBM_SHOWTICS:
        /* If we're hiding the ticks, we want a chiseled thumb,
         * so make it TBS_BOTH as well as TBS_NOTICKS.
         */
        if (wParam == TRUE)
            SetWindowLongPtr(hwnd, GWL_STYLE,
                          (GetWindowLongPtr(hwnd, GWL_STYLE) & ~(TBS_NOTICKS | TBS_BOTH)));
        else
            SetWindowLongPtr(hwnd, GWL_STYLE,
                          (GetWindowLongPtr(hwnd, GWL_STYLE) | TBS_NOTICKS | TBS_BOTH));

        if (lParam == TRUE)
            InvalidateRect(hwnd, NULL, TRUE);

        return 0;

    }

    return CallWindowProc(fnTrackbarWndProc, hwnd, message, wParam, lParam);
}


void SubClassTrackbarWindow()
{
    if (!fnTrackbarWndProc)
        fnTrackbarWndProc = (WNDPROC)GetWindowLongPtr(ghwndTrackbar, GWLP_WNDPROC);
    if (ghwndTrackbar)
        SetWindowLongPtr(ghwndTrackbar, GWLP_WNDPROC, (LONG_PTR)SubClassedTrackbarWndProc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\track.h ===
/*-----------------------------------------------------------------------------+
| TRACK.H                                                                      |
|                                                                              |
| Contains the code which implements the track bar                             |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/
/*
    The trackbar messages:

    message         wParam  lParam  return

    TBM_GETPOS      ------  ------  Current logical position of trackbar.
    TBM_GETRANGEMIN ------  ------  Current logical minimum position allowed.
    TBM_GETRANGEMAX ------  ------  Current logical maximum position allowed.
    TBM_SETTIC
    TBM_SETPOS
    TBM_SETRANGEMIN
    TBM_SETRANGEMAX
*/

#ifdef  TRACKBAR_CLASS
#undef  TRACKBAR_CLASS
#endif
#define TRACKBAR_CLASS          TEXT("STrackBar")
BOOL   FAR  PASCAL TrackInit(HANDLE, HANDLE);
void   FAR  PASCAL TrackTerm(void);
LONG   FAR  PASCAL TrackGetLogThumbWidth(HWND hwnd);

/* Track bar styles */
#define TBS_TICS                0x8000L

#define TBM_GETPOS              (WM_USER)
#define TBM_GETRANGEMIN         (WM_USER+1)
#define TBM_GETRANGEMAX         (WM_USER+2)
#define TBM_GETTIC              (WM_USER+3)
#define TBM_SETTIC              (WM_USER+4)
#define TBM_SETPOS              (WM_USER+5)
#define TBM_SETRANGE            (WM_USER+6)
#define TBM_SETRANGEMIN         (WM_USER+7)
#define TBM_SETRANGEMAX         (WM_USER+8)
#define TBM_CLEARTICS           (WM_USER+9)
#define TBM_SETSEL              (WM_USER+10)
#define TBM_SETSELSTART         (WM_USER+11)
#define TBM_SETSELEND           (WM_USER+12)
#define TBM_SETTICTOK           (WM_USER+13)
#define TBM_GETPTICS            (WM_USER+14)
#define TBM_GETTICPOS           (WM_USER+15)
#define TBM_GETNUMTICS          (WM_USER+16)
#define TBM_GETSELSTART         (WM_USER+17)
#define TBM_GETSELEND           (WM_USER+18)
#define TBM_CLEARSEL            (WM_USER+19)
#define TBM_SHOWTICS            (WM_USER+30)

#define TB_LINEUP               0
#define TB_LINEDOWN             1
#define TB_PAGEUP               2
#define TB_PAGEDOWN             3
#define TB_THUMBPOSITION        4
#define TB_THUMBTRACK           5
#define TB_TOP                  6
#define TB_BOTTOM               7
#define TB_ENDTRACK             8
#define TB_STARTTRACK           9

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\utils.h ===
LPTSTR AllocString( LPTSTR pstr );
BOOL FreeString( LPTSTR pstr );

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\trackmap.c ===
/*-----------------------------------------------------------------------------+
| TRACKMAP.C                                                                   |
|                                                                              |
| This file contains the code that implements the "MPlayerTrackMap" control.   |
| The control displays the list of tracks contained in the current medium, or  |
| a time scale appropriate to the length of the medium, in such a way as to    |
| serve as a scale for the scrollbar.                                          |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

/* include files */

#include <windows.h>
#include <mmsystem.h>
#include "mplayer.h"
#include "toolbar.h"

typedef struct tagScale {
    DWORD   dwInterval;
    UINT    wScale;
} SCALE;

STATICDT SCALE aScale[] =
{
    { 1, SCALE_SECONDS },
    { 2, SCALE_SECONDS },
    { 5, SCALE_SECONDS },
    { 10, SCALE_SECONDS },
    { 25, SCALE_SECONDS },
    { 50, SCALE_SECONDS },
    { 100, SCALE_SECONDS },
    { 250, SCALE_SECONDS },
    { 500, SCALE_SECONDS },
    { 1000, SCALE_SECONDS },
    { 2000, SCALE_SECONDS },
    { 5000, SCALE_SECONDS },
    { 10000, SCALE_SECONDS },
    { 15000, SCALE_MINUTES },
    { 30000, SCALE_MINUTES },
    { 60000, SCALE_MINUTES },
    { 120000, SCALE_MINUTES },
    { 300000, SCALE_MINUTES },
    { 600000, SCALE_HOURS },
    { 1800000, SCALE_HOURS },
    { 3600000, SCALE_HOURS },
    { 7200000, SCALE_HOURS },
    { 18000000, SCALE_HOURS },
    { 36000000, SCALE_HOURS },
    { 72000000, SCALE_HOURS }
};

STATICDT SZCODE   aszNULL[] = TEXT("");
STATICDT SZCODE   aszOneDigit[] = TEXT("0");
STATICDT SZCODE   aszTwoDigits[] = TEXT("00");
STATICDT SZCODE   aszPositionFormat[] = TEXT("%0d");
STATICDT SZCODE   aszMSecFormat[] = TEXT("%d");
STATICDT SZCODE   aszHourFormat[] = TEXT("%d%c");
STATICDT SZCODE   aszMinuteFormat[] = TEXT("%d%c");
STATICDT SZCODE   aszSecondFormat[] = TEXT("%d%c");
STATICDT SZCODE   aszSecondFormatNoLzero[] = TEXT("%c");
STATICDT SZCODE   aszDecimalFormat[] = TEXT("%02d");
/*
 * fnMPlayerTrackMap()
 *
 * This is the window procedure for windows of class "MPlayerTrackMap".
 * This window shows the position of the start of each track of the
 * current medium or a time scale, displayed above the scrollbar which shows
 * the current play position within the medium.
 *
 */

void FAR PASCAL CalcTicsOfDoom(void);

extern UINT gwCurScale;  /* The current scale in which to draw the track map*/
extern BOOL gfCurrentCDNotAudio;/* TRUE when we have a CD that we can't play */

LRESULT FAR PASCAL fnMPlayerTrackMap(

HWND     hwnd,                 /*handle to a MPlayerTrackMap window*/
UINT     wMsg,                 /* message number                   */
WPARAM   wParam,               /* message-dependent parameter      */
LPARAM   lParam)               /* message-dependent parameter      */

{
    PAINTSTRUCT    ps;            /* paint structure for the window   */
    RECT           rc, rcSB;      /* dimensions of the windows        */
    POINT          ptExtent;      /* extent of the track marks        */
    TCHAR          szLabel[20];   /* string holding the current label */
    TCHAR          szLabel2[20];  /* string holding the current label */
    UINT           wNumTics,
                   wTicNo,
                   wTemp,
                   wHour,
                   wMin,
                   wSec,
                   wMsec;
    int            iOldPosition = -1000;
    int            iNewPosition;
    UINT           wScale;
    DWORD          dwMarkValue;
    int            iLargeMarkSize, iFit, iLastPos, iLen;
    BOOL           fForceTextDraw = FALSE;
    HBRUSH         hbr;

    switch (wMsg) {

        case WM_PAINT:

            BeginPaint(hwnd, &ps);

            GetClientRect(ghwndTrackbar, &rcSB);
            GetClientRect(hwnd, &rc);

            /* Set background and text colours */

            (VOID)SendMessage(ghwndApp, WM_CTLCOLORSTATIC,
                              (WPARAM)ps.hdc, (LONG_PTR)hwnd);

            /* Get the length of the scrollbar we're putting tics under */
            /* Use these numbers for size and position calculations     */
            GetClientRect(ghwndMap, &rc);

            /*
             * Check to see if we actually have a valid device loaded up;
             * if not, don't display anything
             *
             */

            if (gwDeviceID == 0
                    || gwStatus == MCI_MODE_OPEN
                    || gwStatus == MCI_MODE_NOT_READY || gdwMediaLength == 0
                    || !gfValidMediaInfo
                    || gfCurrentCDNotAudio) {
                EndPaint(hwnd,&ps);
                //VIJR-SBSetWindowText(ghwndStatic, aszNULL);
                WriteStatusMessage(ghwndStatic, (LPTSTR)aszNULL);
                return 0L;
            }

            /* Select the font to use */

            if (ghfontMap != NULL)
                SelectObject(ps.hdc, ghfontMap);

            /*
             * Because the scrollbar thumb takes up space in the inner part
             * of the scrollbar, compute its width so that we can compensate
             * for it while displaying the trackmap.
             *
             */

            /*
             * Get the child window rectangle and reduce it such that
             * it is the same width as the inner part of the scrollbar.
             *
             */
            //rc.left;  //!!! GetSystemMetrics(SM_CXHSCROLL);
            //rc.right; //!!!(GetSystemMetrics(SM_CXHSCROLL));

            /* Now, Put text underneath the TICS */
            if (gwCurScale == ID_TRACKS) {

                SIZE Size;

                GetTextExtentPoint32( ps.hdc, aszTwoDigits, 2, &Size );

                ptExtent.x = Size.cx;
                ptExtent.y = Size.cy;

                /*
                 * Based on the width of the child window, compute the positions
                 * to place the track markers.
                 *
                 */

                wNumTics = (UINT)SendMessage(ghwndTrackbar, TBM_GETNUMTICS, 0, 0L);

                /*
                 * TBM_GETNUMTICS returns the number of visible tics
                 * which includes the first and last tics not created
                 * by media player.  Subtract 2 to account for the
                 * the first and last tics.
                 *
                 */

                if (wNumTics >= 2)
                    wNumTics = wNumTics - 2;

                for(wTicNo = 0; wTicNo < wNumTics; wTicNo++) {

                    /* Get the position of the next tic */
                    iNewPosition = (int)SendMessage(ghwndTrackbar, TBM_GETTICPOS,
                                                    (WPARAM)wTicNo, 0L);
                    /* Centre it above the marker. */
                    iNewPosition -= ptExtent.x / 4;

                    /*
                     * Check to make sure that we are not overwriting the
                     * text from the previous marker.
                     *
                     */

                    if (iNewPosition > iOldPosition) {

                        wsprintf(szLabel, aszPositionFormat, wTicNo + gwFirstTrack);
                        TextOut(ps.hdc,
                                iNewPosition + rc.left,
                                0, szLabel,
                                (wTicNo + gwFirstTrack < 10) ? 1 : 2 );
                        /* Finish the end of the text string we just printed */
                        iOldPosition = iNewPosition +
                                       ((wTicNo + gwFirstTrack < 10)
                                       ? ptExtent.x / 2 : ptExtent.x);
                    }
                }
            } else {

                #define ONE_HOUR    (60ul*60ul*1000ul)
                #define ONE_MINUTE  (60ul*1000ul)
                #define ONE_SECOND  (1000ul)

                /*
                 * The scale is set to display time - find out what units
                 * (msec, sec, min, or hour) are most appropriate, for the
                 * scale. This requires us to look at both the overall length
                 * of the medium and the distance between markers (or
                 * granularity).
                 *
                 */

                /*
                 * Find the maximum number of markers that we can draw without
                 * cluttering the display too badly, and find the granularity
                 * between these markers.
                 *
                 */

                SIZE Size;

                GetTextExtentPoint32( ps.hdc, aszOneDigit, 1, &Size );

                ptExtent.x = Size.cx;
                ptExtent.y = Size.cy;

                if (gdwMediaLength < 10)
                    iLargeMarkSize = 1;
                else if (gdwMediaLength < 100)
                    iLargeMarkSize = 2;
                else if (gdwMediaLength < 1000)
                    iLargeMarkSize = 3;
                else if (gdwMediaLength < 10000)
                    iLargeMarkSize = 4;
                else
                    iLargeMarkSize = 5;

                wNumTics = (UINT)SendMessage(ghwndTrackbar, TBM_GETNUMTICS,
								0, 0L);

                /*
                 * TBM_GETNUMTICS returns the number of visible tics
                 * which includes the first and last tics not created
                 * by media player.  Subtract 2 to account for the
                 * the first and last tics.
                 *
                 */

                if (wNumTics >= 2)
                    wNumTics = wNumTics - 2;

                /* Where the text for the last mark will begin */
		if (wNumTics > 1) {
                    iLastPos = (int)SendMessage(ghwndTrackbar,
			TBM_GETTICPOS, (WPARAM)wNumTics - 1, 0L);
                    iLastPos -= ptExtent.x  / 2;    // centre 1st numeral
		}

                /* What scale do we use?  Hours, minutes, or seconds? */
                /* NOTE:  THIS MUST AGREE WITH WHAT FormatTime() does */
                /* in mplayer.c !!!                                   */
                if (gwCurScale == ID_FRAMES)
                    wScale = SCALE_FRAMES;
                else {
                    if (gdwMediaLength > ONE_HOUR)
                        wScale = SCALE_HOURS;
                    else if (gdwMediaLength > ONE_MINUTE)
                        wScale = SCALE_MINUTES;
                    else
                        wScale = SCALE_SECONDS;
                }

                for (wTicNo = 0; wTicNo < wNumTics; wTicNo++) {

                    /* The text for the last tic is always drawn */
                    if (wTicNo == wNumTics - 1)
                        fForceTextDraw = TRUE;

                    dwMarkValue = (DWORD)SendMessage(ghwndTrackbar, TBM_GETTIC,
                                          (WPARAM)wTicNo, 0L);
                    iNewPosition = (int)SendMessage(ghwndTrackbar, TBM_GETTICPOS,
                                                (WPARAM)wTicNo, 0L);


                    /*
                     * Get the text ready for printing and centre it above the
                     * marker.
                     *
                     */

                    switch ( wScale ) {

                        case SCALE_FRAMES:
                        case SCALE_MSEC:
                            wsprintf(szLabel, aszMSecFormat, dwMarkValue);
                            break;

                        case SCALE_HOURS:

                            wHour = (WORD)(dwMarkValue / 3600000);
                            wMin = (WORD)((dwMarkValue % 3600000) / 60000);
                            wsprintf(szLabel2,aszDecimalFormat,wMin);
                            wsprintf(szLabel,aszHourFormat,wHour, chTime);
                            lstrcat(szLabel,szLabel2);
                            break;

                        case SCALE_MINUTES :

                            wMin = (WORD)(dwMarkValue / 60000);
                            wSec = (WORD)((dwMarkValue % 60000) / 1000);
                            wsprintf(szLabel2,aszDecimalFormat,wSec);
                            wsprintf(szLabel,aszMinuteFormat,wMin,chTime);
                            lstrcat(szLabel,szLabel2);
                            break;

                        case SCALE_SECONDS :

                            wSec = (WORD)((dwMarkValue + 5) / 1000);
                            wMsec = (WORD)(((dwMarkValue + 5) % 1000) / 10);
                            wsprintf(szLabel2,aszDecimalFormat,wMsec);
                            if (!wSec && chLzero == TEXT('0'))
                                wsprintf(szLabel, aszSecondFormatNoLzero,  chDecimal);
                            else
                                wsprintf(szLabel, aszSecondFormat, wSec, chDecimal);
                            lstrcat(szLabel,szLabel2);
                            break;

                    }

                    wTemp = STRLEN(szLabel);
                    iNewPosition -= ptExtent.x  / 2;    // centre 1st numeral

                    /* The position after which text will be cut off the */
                    /* right edge of the window                          */
                    iFit = rc.right - rc.left - (ptExtent.x * iLargeMarkSize);

                    /* Calculate the length of the text we just printed. */
                    /* Leave a little space at the end, too.             */
                    iLen = (ptExtent.x * wTemp) + ptExtent.x / 2;

                    /* Display the mark if we can without overlapping either
                     * the previous mark or the final mark or going off the
                     * edge of the window. */
                    if (fForceTextDraw ||
                        (iNewPosition >= iOldPosition &&
                         iNewPosition <= iFit &&
                         iNewPosition + iLen <= iLastPos)) {
                        TextOut(ps.hdc, iNewPosition + rc.left, 0,
                                szLabel, wTemp );
                        /* Calculate the end pos of the text we just printed. */
                        iOldPosition = iNewPosition + iLen;

                    } else {

                        DPF("Didn't display mark: iNew = %d; iOld = %d; iFit = %d; iLen = %d, iLast = %d\n", iNewPosition, iOldPosition, iFit, iLen, iLastPos);
                    }
                }
            }
            EndPaint(hwnd, &ps);
            return 0L;

        case WM_ERASEBKGND:

            GetClientRect(hwnd, &rc);

            hbr = (HBRUSH)SendMessage(ghwndApp, WM_CTLCOLORSTATIC,
                                      wParam, (LONG_PTR)hwnd);

            if (hbr != NULL)
                FillRect((HDC)wParam, &rc, hbr);

            return TRUE;
    }

    /* Let DefWindowProc() process all other window messages */

    return DefWindowProc(hwnd, wMsg, wParam, lParam);

}

/* Gee thanks for the helpful spec for this routine! */

void FAR PASCAL CalcTicsOfDoom(void)
{
    UINT        wMarkNo;
    int         iTableIndex;
    DWORD       dwMarkValue,
                dwNewPosition;
    BOOL        fDidLastMark = FALSE;

    if (gfPlayOnly && !gfOle2IPEditing)
        return;

    DPF2("CalcTicsOfDoom\n");
    SendMessage(ghwndTrackbar, TBM_CLEARTICS, (WPARAM)FALSE, 0L);

    if (gwCurScale == ID_TRACKS) {

        /*
         * Based on the width of the child window, compute the positions
         * to place the track marker tics.
         *
         */

        for (wMarkNo = 0; wMarkNo < gwNumTracks; wMarkNo++) {

            /* If zero length, don't mark it, unless it is the end */
            if ((wMarkNo < gwNumTracks - 1) &&
                (gadwTrackStart[wMarkNo] == gadwTrackStart[wMarkNo + 1]))
                continue;

            /* Compute the centre point and place a marker there */

            if (gdwMediaLength == 0)
                dwNewPosition = 0;
            else
                dwNewPosition = gadwTrackStart[wMarkNo];

            SendMessage(ghwndTrackbar,
                        TBM_SETTIC,
                        (WPARAM)FALSE,
                        (LPARAM)dwNewPosition);

        }
    } else {

        /*
         * The scale is set to display time - find out what units
         * (msec, sec, min, or hour) are most appropriate, for the
         * scale. This requires us to look at both the overall length
         * of the medium and the distance between markers (or
         * granularity).
         *
         */

        /*
         * Find the maximum number of markers that we can draw without
         * cluttering the display too badly, and find the granularity
         * between these markers.
         *
         */

        UINT    wNumTicks;
        RECT    rc;

        if(!GetClientRect(ghwndMap, &rc)) {
            DPF0("GetClientRect failed in CalcTicsOfDoom: Error %d\n", GetLastError());
        }

        wNumTicks = rc.right / 60;

        if (0 == gdwMediaLength) {
            iTableIndex = 0;
        } else {

            DPF4("Checking the scale for media length = %d, tick count = %d\n", gdwMediaLength, wNumTicks);

            for (iTableIndex = (sizeof(aScale) / sizeof(SCALE)) -1;
                (int)iTableIndex >= 0;
                iTableIndex--) {

                DPF4("Index %02d: %d\n", aScale[iTableIndex].dwInterval * wNumTicks);

                if ((aScale[iTableIndex].dwInterval * wNumTicks)
                    <= gdwMediaLength)
                    break;
            }
        }
#ifdef DEBUG
        if ((int)iTableIndex == -1) {
            DPF("BAD TABLEINDEX\n");
            DebugBreak();
        }
#endif
        // We have enough room to show every tick.  Don't let our index wrap
        // around, or we won't see ANY ticks which would look odd.
        if (iTableIndex <0)
            iTableIndex = 0;

        dwMarkValue = gdwMediaStart;

        do {

            /* Compute the centre point and place a marker there */

            if (gdwMediaLength == 0)
                dwNewPosition = 0;
            else
                dwNewPosition = dwMarkValue; // HACK!! - gdwMediaStart;

            SendMessage(ghwndTrackbar,
                        TBM_SETTIC,
                        (WPARAM)FALSE,
                        (LPARAM)dwNewPosition);

            /* If this is the first mark, adjust so it's going
            /* by the right interval. */
            if (dwMarkValue == gdwMediaStart) {
                dwMarkValue += aScale[iTableIndex].dwInterval
                - (dwMarkValue % aScale[iTableIndex].dwInterval);
            } else {
                dwMarkValue += aScale[iTableIndex].dwInterval;
            }

            /* If we're almost done, do the final mark. */
            if ((dwMarkValue >= (gdwMediaLength + gdwMediaStart))
                && !(fDidLastMark)) {
                fDidLastMark = TRUE;
                dwMarkValue = gdwMediaLength + gdwMediaStart;
            }
        } while (dwMarkValue <= gdwMediaStart + gdwMediaLength);
    }

    InvalidateRect(ghwndTrackbar, NULL, FALSE);
    InvalidateRect(ghwndMap, NULL, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\tracki.h ===
/*-----------------------------------------------------------------------------+
| TRACKI.H                                                                     |
|                                                                              |
| Contains all the useful information for a trackbar.                          |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

#include "track.h"

static TCHAR szSTrackBarClass[] = TRACKBAR_CLASS;

typedef struct {
        HWND    hwnd;           // our window handle
        HDC     hdc;            // current DC

        LONG    lLogMin;        // Logical minimum
        LONG    lLogMax;        // Logical maximum
        LONG    lLogPos;        // Logical position

        LONG    lSelStart;      // Logical selection start
        LONG    lSelEnd;        // Logical selection end

        LONG    lTrackStart;    // Logical track start

        UINT    wThumbWidth;    // Width of the thumb
        UINT    wThumbHeight;   // Height of the thumb

        int     iSizePhys;      // Size of where thumb lives
        RECT    rc;             // track bar rect.

        RECT    Thumb;          // Rectangle we current thumb
        DWORD   dwDragPos;      // Logical position of mouse while dragging.

        UINT    Flags;          // Flags for our window
        int     Timer;          // Our timer.
        UINT    Cmd;            // The command we're repeating.

        int     nTics;          // number of ticks.
        PDWORD  pTics;          // the tick marks.

} TrackBar, *PTrackBar;

// Trackbar flags

#define TBF_NOTHUMB     0x0001  // No thumb because not wide enough.

/*
    useful constants.
*/

#define REPEATTIME      500     // mouse auto repeat 1/2 of a second
#define TIMER_ID        1

#define GWW_TRACKMEM        0               /* handle to track bar memory */
#define EXTRA_TB_BYTES      sizeof(HLOCAL)  /* Total extra bytes.   */

/*
    Useful defines.
*/

/* We allocate enough window words to store a pointer (not a handle), so the
   definition of EXTRA_TB_BYTES is slightly bad style.  Sorry.  On creation
   we allocate space for the TrackBar struct.  On destruction we free it.
   In between we just retrieve the pointer.
*/
#define CREATETRACKBAR(hwnd) SetWindowLongPtr( hwnd                                 \
                                             , GWW_TRACKMEM                         \
                                             , AllocMem(sizeof(TrackBar))           \
                                             )
#define DESTROYTRACKBAR(hwnd)   FreeMem( (LPVOID)GetWindowLongPtr(hwnd, GWW_TRACKMEM), \
                                         sizeof(TrackBar) )

#define GETTRACKBAR(hwnd)       (PTrackBar)GetWindowLongPtr(hwnd,GWW_TRACKMEM)

/*
    Function Prototypes
*/

void   FAR PASCAL DoTrack(PTrackBar, int, DWORD);
UINT   FAR PASCAL WTrackType(PTrackBar, LONG);
void   FAR PASCAL TBTrackInit(PTrackBar, LONG);
void   FAR PASCAL TBTrackEnd(PTrackBar, LONG);
void   FAR PASCAL TBTrack(PTrackBar, LONG);
void   FAR PASCAL DrawThumb(PTrackBar);
HBRUSH FAR PASCAL SelectColorObjects(PTrackBar, BOOL);
void   FAR PASCAL SetTBCaretPos(PTrackBar);

extern DWORD FAR PASCAL muldiv32(long, long, long);

/* objects from sbutton.c */

extern HBRUSH hbrButtonFace;
extern HBRUSH hbrButtonShadow;
extern HBRUSH hbrButtonText;
extern HBRUSH hbrButtonHighLight;
extern HBRUSH hbrWindowFrame; //???

extern HBITMAP FAR PASCAL  LoadUIBitmap(
    HANDLE      hInstance,          // EXE file to load resource from
    LPCTSTR     szName,             // name of bitmap resource
    COLORREF    rgbText,            // color to use for "Button Text"
    COLORREF    rgbFace,            // color to use for "Button Face"
    COLORREF    rgbShadow,          // color to use for "Button Shadow"
    COLORREF    rgbHighlight,       // color to use for "Button Hilight"
    COLORREF    rgbWindow,          // color to use for "Window Color"
    COLORREF    rgbFrame);          // color to use for "Window Frame"

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\g711\codec.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1998 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  codec.h
//
//  Description:
//      This file contains codec definitions, Win16/Win32 compatibility
//      definitions, and instance structure definitions.
//
//
//==========================================================================;

#ifndef _INC_CODEC
#define _INC_CODEC                  // #defined if codec.h has been included

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Driver Version:
//
//  the version is a 32 bit number that is broken into three parts as
//  follows:
//
//      bits 24 - 31:   8 bit _major_ version number
//      bits 16 - 23:   8 bit _minor_ version number
//      bits  0 - 15:   16 bit build number
//
//  this is then displayed as follows (in decimal form):
//
//      bMajor = (BYTE)(dwVersion >> 24)
//      bMinor = (BYTE)(dwVersion >> 16) &
//      wBuild = LOWORD(dwVersion)
//
//  VERSION_ACM_DRIVER is the version of this driver.
//  VERSION_MSACM is the version of the ACM that this driver
//  was designed for (requires).
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef _WIN32
//
//  32-bit versions
//
#if (WINVER >= 0x0400)
 #define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(4,  0, 0)
#else
 #define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(3, 50, 0)
#endif
#define VERSION_MSACM       MAKE_ACM_VERSION(3, 50, 0)

#else
//
//  16-bit versions
//
#define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(1, 0, 0)
#define VERSION_MSACM       MAKE_ACM_VERSION(2, 1, 0)

#endif

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 16/32 portability stuff...
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef _WIN32
    #ifndef FNLOCAL
        #define FNLOCAL     NEAR PASCAL
        #define FNCLOCAL    NEAR _cdecl
        #define FNGLOBAL    FAR PASCAL
        #define FNCGLOBAL   FAR _cdecl
    #ifdef _WINDLL
        #define FNWCALLBACK FAR PASCAL _loadds
        #define FNEXPORT    FAR PASCAL _export
    #else
        #define FNWCALLBACK FAR PASCAL
        #define FNEXPORT    FAR PASCAL _export
    #endif
    #endif

    //
    //
    //
    //
    #ifndef FIELD_OFFSET
    #define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
    #endif

    //
    //  based code makes since only in win 16 (to try and keep stuff out of
    //  our fixed data segment...
    //
    #define BCODE           _based(_segname("_CODE"))

    #define HUGE            _huge

    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef _TCHAR_DEFINED
        #define _TCHAR_DEFINED
        typedef char            TCHAR, *PTCHAR;
        typedef unsigned char   TBYTE, *PTUCHAR;

        typedef PSTR            PTSTR, PTCH;
        typedef LPSTR           LPTSTR, LPTCH;
        typedef LPCSTR          LPCTSTR;
    #endif

    #define TEXT(a)         a
    #define SIZEOF(x)       sizeof(x)
    #define SIZEOFACMSTR(x) sizeof(x)
#else
    #ifndef FNLOCAL
        #define FNLOCAL     _stdcall
        #define FNCLOCAL    _stdcall
        #define FNGLOBAL    _stdcall
        #define FNCGLOBAL   _stdcall
        #define FNWCALLBACK CALLBACK
        #define FNEXPORT    CALLBACK
    #endif

    #ifndef try
    #define try         __try
    #define leave       __leave
    #define except      __except
    #define finally     __finally
    #endif


    //
    //  there is no reason to have based stuff in win 32
    //
    #define BCODE

    #define HUGE
    #define HTASK                   HANDLE
    #define SELECTOROF(a)           (a)

    //
    //  for compiling Unicode
    //
    #ifdef UNICODE
        #define SIZEOF(x)   (sizeof(x)/sizeof(WCHAR))
    #else
        #define SIZEOF(x)   sizeof(x)
    #endif
    #define SIZEOFACMSTR(x)	(sizeof(x)/sizeof(WCHAR))
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  misc defines for misc sizes and things...
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  bilingual. this allows the same identifier to be used in resource files
//  and code without having to decorate the id in your code.
//
#ifdef RC_INVOKED
    #define RCID(id)    id
#else
    #define RCID(id)    MAKEINTRESOURCE(id)
#endif


//
//
//
#define SIZEOF_ARRAY(ar)            (sizeof(ar)/sizeof((ar)[0]))


//
//  macros to compute block alignment and convert between samples and bytes
//  of PCM data. note that these macros assume:
//
//      wBitsPerSample  =  8 or 16
//      nChannels       =  1 or 2
//
//  the pwf argument is a pointer to a PCMWAVEFORMAT structure.
//
#define PCM_BLOCKALIGNMENT(pwf)     (UINT)(((pwf)->wBitsPerSample >> 3) << ((pwf)->wf.nChannels >> 1))
#define PCM_AVGBYTESPERSEC(pwf)     (DWORD)((pwf)->wf.nSamplesPerSec * (pwf)->wf.nBlockAlign)
#define PCM_BYTESTOSAMPLES(pwf, dw) (DWORD)(dw / PCM_BLOCKALIGNMENT(pwf))
#define PCM_SAMPLESTOBYTES(pwf, dw) (DWORD)(dw * PCM_BLOCKALIGNMENT(pwf))



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef struct tDRIVERINSTANCE
{
    //
    //  although not required, it is suggested that the first two members
    //  of this structure remain as fccType and DriverProc _in this order_.
    //  the reason for this is that the driver will be easier to combine
    //  with other types of drivers (defined by AVI) in the future.
    //
    FOURCC          fccType;        // type of driver: 'audc'
    DRIVERPROC      fnDriverProc;   // driver proc for the instance

    //
    //  the remaining members of this structure are entirely open to what
    //  your driver requires.
    //
    HDRVR           hdrvr;          // driver handle we were opened with
    HINSTANCE       hinst;          // DLL module handle.
    DWORD           vdwACM;         // current version of ACM opening you
    DWORD           fdwOpen;        // flags from open description

    DWORD           fdwConfig;      // driver instance configuration flags

} DRIVERINSTANCE, *PDRIVERINSTANCE, FAR *LPDRIVERINSTANCE;



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;


//
//
//
//
typedef LRESULT (FNGLOBAL *STREAMCONVERTPROC)
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
);


//
//
//
//
typedef struct tSTREAMINSTANCE
{
    STREAMCONVERTPROC   fnConvert;  // stream instance conversion proc
    DWORD               fdwConfig;  // stream instance configuration flags

} STREAMINSTANCE, *PSTREAMINSTANCE, FAR *LPSTREAMINSTANCE;



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  resource id's
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define IDS_ACM_DRIVER_SHORTNAME    (1)     // ACMDRIVERDETAILS.szShortName
#define IDS_ACM_DRIVER_LONGNAME     (2)     // ACMDRIVERDETAILS.szLongName
#define IDS_ACM_DRIVER_COPYRIGHT    (3)     // ACMDRIVERDETAILS.szCopyright
#define IDS_ACM_DRIVER_LICENSING    (4)     // ACMDRIVERDETAILS.szLicensing
#define IDS_ACM_DRIVER_FEATURES     (5)     // ACMDRIVERDETAILS.szFeatures

#define IDS_ACM_DRIVER_TAG_NAME_ALAW    (20)    // ACMFORMATTAGDETAILS.szFormatTag
#define IDS_ACM_DRIVER_TAG_NAME_MULAW   (30)    // ACMFORMATTAGDETAILS.szFormatTag



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" {
#endif

#endif // _INC_CODEC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\g711\debug.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1996 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code yanked from several places to provide debug
//      support that works in win 16 and win 32.
//
//
//==========================================================================;

#ifdef DEBUG

#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#include "debug.h"


//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#ifndef _WIN32
    #define lstrcatA            lstrcat
    #define lstrlenA            lstrlen
    #define GetProfileIntA      GetProfileInt
    #define OutputDebugStringA  OutputDebugString
#endif

//
//
//
BOOL    __gfDbgEnabled          = TRUE;         // master enable
UINT    __guDbgLevel            = 0;            // current debug level


//--------------------------------------------------------------------------;
//  
//  void DbgVPrintF
//  
//  Description:
//  
//  
//  Arguments:
//      LPSTR szFormat:
//  
//      va_list va:
//  
//  Return (void):
//      No value is returned.
//  
//--------------------------------------------------------------------------;

void FAR CDECL DbgVPrintF
(
    LPSTR                   szFormat,
    va_list                 va
)
{
    char                ach[DEBUG_MAX_LINE_LEN];
    BOOL                fDebugBreak = FALSE;
    BOOL                fPrefix     = TRUE;
    BOOL                fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch (*szFormat)
        {
            case '!':
                fDebugBreak = TRUE;
                szFormat++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFormat++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFormat++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
    {
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");
    }

    wvsprintfA(ach + lstrlenA(ach), szFormat, va);

    if (fCRLF)
    {
        lstrcatA(ach, "\r\n");
    }

    OutputDebugStringA(ach);

    if (fDebugBreak)
    {
#if DBG
        DebugBreak();
#endif
    }
} // DbgVPrintF()


//--------------------------------------------------------------------------;
//  
//  void dprintf
//  
//  Description:
//      dprintf() is called by the DPF() macro if DEBUG is defined at compile
//      time. It is recommended that you only use the DPF() macro to call
//      this function--so you don't have to put #ifdef DEBUG around all
//      of your code.
//      
//  Arguments:
//      UINT uDbgLevel:
//  
//      LPSTR szFormat:
//  
//  Return (void):
//      No value is returned.
//
//--------------------------------------------------------------------------;

void FAR CDECL dprintf
(
    UINT                    uDbgLevel,
    LPSTR                   szFormat,
    ...
)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFormat);
    DbgVPrintF(szFormat, va);
    va_end(va);
} // dprintf()


//--------------------------------------------------------------------------;
//  
//  BOOL DbgEnable
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (BOOL):
//      Returns the previous debugging state.
//  
//--------------------------------------------------------------------------;

BOOL WINAPI DbgEnable
(
    BOOL                    fEnable
)
{
    BOOL                fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} // DbgEnable()


//--------------------------------------------------------------------------;
//  
//  UINT DbgSetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      UINT uLevel:
//  
//  Return (UINT):
//      Returns the previous debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgSetLevel
(
    UINT                    uLevel
)
{
    UINT                uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = uLevel;

    return (uOldLevel);
} // DbgSetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgGetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      None.
//  
//  Return (UINT):
//      Returns the current debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgGetLevel
(
    void
)
{
    return (__guDbgLevel);
} // DbgGetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgInitialize
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (UINT):
//      Returns the debugging level that was set.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize
(
    BOOL                    fEnable
)
{
    UINT                uLevel;

    uLevel = GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, (UINT)-1);
    if ((UINT)-1 == uLevel)
    {
        //
        //  if the debug key is not present, then force debug output to
        //  be disabled. this way running a debug version of a component
        //  on a non-debugging machine will not generate output unless
        //  the debug key exists.
        //
        uLevel  = 0;
        fEnable = FALSE;
    }

    DbgSetLevel(uLevel);
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\g711\codec.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1999 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  codec.c
//
//  Description:
//      This file contains the DriverProc and other routines which respond
//      to ACM messages.
//
//      Throughout this module, 'g711' refers to both the A-law and u-law
//      coding standards.  When the context requires that these coding
//      standards be differentiated we use 'alaw' and 'mulaw' or a similar
//      variation.
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include <memory.h>

#include "codec.h"
#include "g711.h"
#include "debug.h"


const UINT gauFormatTagIndexToTag[] =
{
    WAVE_FORMAT_PCM,
    WAVE_FORMAT_ALAW,
    WAVE_FORMAT_MULAW
};

#define ACM_DRIVER_MAX_FORMAT_TAGS  SIZEOF_ARRAY(gauFormatTagIndexToTag)
#define ACM_DRIVER_MAX_FILTER_TAGS  0


//
//  array of sample rates supported
//
//
const UINT gauFormatIndexToSampleRate[] =
{
    8000,
    11025,
    22050,
    44100
};


#define ACM_DRIVER_MAX_SAMPLE_RATES SIZEOF_ARRAY(gauFormatIndexToSampleRate)

#define ACM_DRIVER_MAX_CHANNELS     G711_MAX_CHANNELS


//
//  bits per sample supported
//
//
#define ACM_DRIVER_MAX_BITSPERSAMPLE_PCM    1       // only 16 bit
#define ACM_DRIVER_MAX_BITSPERSAMPLE_G711   1       // only 8 bit


//
//  number of formats we enumerate per channel is number of sample rates
//  times number of channels times number of types (bits per sample).
//
#define ACM_DRIVER_MAX_FORMATS_PCM  (ACM_DRIVER_MAX_SAMPLE_RATES *      \
                                     ACM_DRIVER_MAX_CHANNELS *          \
                                     ACM_DRIVER_MAX_BITSPERSAMPLE_PCM)

#define ACM_DRIVER_MAX_FORMATS_G711 (ACM_DRIVER_MAX_SAMPLE_RATES *      \
                                     ACM_DRIVER_MAX_CHANNELS *          \
                                     ACM_DRIVER_MAX_BITSPERSAMPLE_G711)



//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  int LoadStringCodec
//
//  Description:
//      This function should be used by all codecs to load resource strings
//      which will be passed back to the ACM.  It works correctly for all
//      platforms, as follows:
//
//          Win16:  Compiled to LoadString to load ANSI strings.
//
//          Win32:  The 32-bit ACM always expects Unicode strings.  Therefore,
//                  when UNICODE is defined, this function is compiled to
//                  LoadStringW to load a Unicode string.  When UNICODE is
//                  not defined, this function loads an ANSI string, converts
//                  it to Unicode, and returns the Unicode string to the
//                  codec.
//
//      Note that you may use LoadString for other strings (strings which
//      will not be passed back to the ACM), because these strings will
//      always be consistent with the definition of UNICODE.
//
//  Arguments:
//      Same as LoadString, except that it expects an LPSTR for Win16 and a
//      LPWSTR for Win32.
//
//  Return (int):
//      Same as LoadString.
//
//--------------------------------------------------------------------------;

#ifndef _WIN32
#define LoadStringCodec LoadString
#else

#ifdef UNICODE
#define LoadStringCodec LoadStringW
#else

int FNGLOBAL LoadStringCodec
(
 HINSTANCE  hinst,
 UINT	    uID,
 LPWSTR	    lpwstr,
 int	    cch)
{
    LPSTR   lpstr;
    int	    iReturn;

    lpstr = (LPSTR)GlobalAlloc(GPTR, cch);
    if (NULL == lpstr)
    {
	return 0;
    }

    iReturn = LoadStringA(hinst, uID, lpstr, cch);
    if (0 == iReturn)
    {
	if (0 != cch)
	{
	    lpwstr[0] = '\0';
	}
    }
    else
    {
    	MultiByteToWideChar( GetACP(), 0, lpstr, cch, lpwstr, cch );
    }

    GlobalFree((HGLOBAL)lpstr);

    return iReturn;
}

#endif  // UNICODE
#endif  // _WIN32


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL pcmIsValidFormat
//
//  Description:
//      This function verifies that a wave format header is a valid PCM
//      header that _this_ ACM driver can deal with.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL pcmIsValidFormat
(
    LPWAVEFORMATEX          pwfx
)
{
    if (NULL == pwfx)
        return (FALSE);

    if (WAVE_FORMAT_PCM != pwfx->wFormatTag)
        return (FALSE);

    //
    //  verify nChannels member is within the allowed range
    //
    if ((pwfx->nChannels < 1) || (pwfx->nChannels > ACM_DRIVER_MAX_CHANNELS))
        return (FALSE);

    //
    //  only allow the bits per sample that we can encode and decode with
    //
    if (16 != pwfx->wBitsPerSample)
        return (FALSE);

    //
    //  now verify that the block alignment is correct..
    //
    if (PCM_BLOCKALIGNMENT((LPPCMWAVEFORMAT)pwfx) != pwfx->nBlockAlign)
        return (FALSE);

    //
    //  finally, verify that avg bytes per second is correct
    //
    if (PCM_AVGBYTESPERSEC((LPPCMWAVEFORMAT)pwfx) != pwfx->nAvgBytesPerSec)
        return (FALSE);

    return (TRUE);
} // pcmIsValidFormat()


//--------------------------------------------------------------------------;
//
//  BOOL g711IsValidFormat
//
//  Description:
//      This function verifies that a wave format header is a valid
//      G711 format header that _this_ ACM driver can deal with.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL g711IsValidFormat
(
    LPWAVEFORMATEX          pwfx
)
{
    if (NULL == pwfx)
        return (FALSE);

    if ((WAVE_FORMAT_MULAW != pwfx->wFormatTag) &&
        (WAVE_FORMAT_ALAW  != pwfx->wFormatTag))
        return (FALSE);

    //
    //  check channels
    //
    if ((pwfx->nChannels < 1) || (pwfx->nChannels > ACM_DRIVER_MAX_CHANNELS))
        return (FALSE);


    //
    //  now verify that the block alignment is correct..
    //
#if 0
    if (G711_BLOCKALIGNMENT(pwfx) != (UINT)pwfx->nBlockAlign)
        return (FALSE);
#else
    //
    //  unfortunately there has been at least one company who didn't
    //  understand what the block alignment was really for and authored
    //  a bunch of files incorrectly. to allow those files to work, we
    //  will just make sure that whole samples remain...
    //
    //  this codec will only author G711 formats with correct block
    //  alignments however.
    //
    if (0 != (pwfx->nBlockAlign % G711_BLOCKALIGNMENT(pwfx)))
        return (FALSE);
#endif

    //
    //  verify that avg bytes per second is correct
    //
    if (G711_AVGBYTESPERSEC(pwfx) != pwfx->nAvgBytesPerSec)
        return (FALSE);

    //
    //  check wBitsPerSample
    //
    if (G711_BITS_PER_SAMPLE != pwfx->wBitsPerSample)
        return (FALSE);

    //
    //  cbSize must be validated also..
    //
    if (G711_WFX_EXTRA_BYTES != pwfx->cbSize)
        return (FALSE);

    return (TRUE);
} // g711IsValidFormat()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverOpen
//
//  Description:
//      This function is used to handle the DRV_OPEN message for the ACM
//      driver. The driver is 'opened' for many reasons with the most common
//      being in preperation for conversion work. It is very important that
//      the driver be able to correctly handle multiple open driver
//      instances.
//
//      Read the comments for this function carefully!
//
//      Note that multiple _streams_ can (and will) be opened on a single
//      open _driver instance_. Do not store/create instance data that must
//      be unique for each stream in this function. See the acmdStreamOpen
//      function for information on conversion streams.
//
//  Arguments:
//      HDRVR hdrvr: Driver handle that will be returned to caller of the
//      OpenDriver function. Normally, this will be the ACM--but this is
//      not guaranteed. For example, if an ACM driver is implemented within
//      a waveform driver, then the driver will be opened by both MMSYSTEM
//      and the ACM.
//
//      LPACMDRVOPENDESC paod: Open description defining how the ACM driver
//      is being opened. This argument may be NULL--see the comments below
//      for more information.
//
//  Return (LRESULT):
//      The return value is non-zero if the open is successful. A zero
//      return signifies that the driver cannot be opened.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverOpen
(
    HDRVR                   hdrvr,
    LPACMDRVOPENDESC        paod
)
{
    PDRIVERINSTANCE     pdi;

    //
    //  the [optional] open description that is passed to this driver can
    //  be from multiple 'managers.' for example, AVI looks for installable
    //  drivers that are tagged with 'vidc' and 'vcap'. we need to verify
    //  that we are being opened as an Audio Compression Manager driver.
    //
    //  if paod is NULL, then the driver is being opened for some purpose
    //  other than converting (that is, there will be no stream open
    //  requests for this instance of being opened). the most common case
    //  of this is the Control Panel's Drivers option checking for config
    //  support (DRV_[QUERY]CONFIGURE).
    //
    //  we want to succeed this open, but be able to know that this
    //  open instance is bogus for creating streams. for this purpose we
    //  leave most of the members of our instance structure that we
    //  allocate below as zero...
    //
    if (NULL != paod)
    {
        //
        //  refuse to open if we are not being opened as an ACM driver.
        //  note that we do NOT modify the value of paod->dwError in this
        //  case.
        //
        if (ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC != paod->fccType)
        {
            return (0L);
        }
    }


    //
    //  we are being opened as an installable driver--we can allocate some
    //  instance data to be returned in dwId argument of the DriverProc;
    //  or simply return non-zero to succeed the open.
    //
    //  this driver allocates a small instance structure. note that we
    //  rely on allocating the memory as zero-initialized!
    //
    pdi = (PDRIVERINSTANCE)LocalAlloc(LPTR, sizeof(*pdi));
    if (NULL == pdi)
    {
        //
        //  if this open attempt was as an ACM driver, then return the
        //  reason we are failing in the open description structure..
        //
        if (NULL != paod)
        {
            paod->dwError = MMSYSERR_NOMEM;
        }

        //
        //  fail to open
        //
        return (0L);
    }


    //
    //  fill in our instance structure... note that this instance data
    //  can be anything that the ACM driver wishes to maintain the
    //  open driver instance. this data should not contain any information
    //  that must be maintained per open stream since multiple streams
    //  can be opened on a single driver instance.
    //
    //  also note that we do _not_ check the version of the ACM opening
    //  us (paod->dwVersion) to see if it is at least new enough to work
    //  with this driver (for example, if this driver required Version 3.0
    //  of the ACM and a Version 2.0 installation tried to open us). the
    //  reason we do not fail is to allow the ACM to get the driver details
    //  which contains the version of the ACM that is _required_ by this
    //  driver. the ACM will examine that value (in padd->vdwACM) and
    //  do the right thing for this driver... like not load it and inform
    //  the user of the problem.
    //
    pdi->hdrvr          = hdrvr;
    pdi->hinst          = GetDriverModuleHandle(hdrvr);  // Module handle.

    if (NULL != paod)
    {
        pdi->fnDriverProc = NULL;
        pdi->fccType      = paod->fccType;
        pdi->vdwACM       = paod->dwVersion;
        pdi->fdwOpen      = paod->dwFlags;

        pdi->fdwConfig    = 0L;

        paod->dwError     = MMSYSERR_NOERROR;
    }


    //
    //  non-zero return is success for DRV_OPEN
    //
    return ((LRESULT)(UINT_PTR)pdi);
} // acmdDriverOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverClose
//
//  Description:
//      This function handles the DRV_CLOSE message for the ACM driver. The
//      driver receives a DRV_CLOSE message for each succeeded DRV_OPEN
//      message (see acmdDriverOpen). The driver will only receive a close
//      message for _successful_ opens.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//  Return (LRESULT):
//      The return value is non-zero if the open instance can be closed.
//      A zero return signifies that the ACM driver instance could not be
//      closed.
//
//      NOTE! It is _strongly_ recommended that the driver never fail to
//      close. Note that the ACM will never allow a driver instance to
//      be closed if there are open streams. An ACM driver does not need
//      to check for this case.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverClose
(
    PDRIVERINSTANCE         pdi
)
{
    //
    //  check to see if we allocated instance data. if we did not, then
    //  immediately succeed.
    //
    if (NULL != pdi)
    {
        //
        //  close down the driver instance. this driver simply needs
        //  to free the instance data structure... note that if this
        //  'free' fails, then this ACM driver probably trashed its
        //  heap; assume we didn't do that.
        //
        LocalFree((HLOCAL)pdi);
    }


    //
    //  non-zero return is success for DRV_CLOSE
    //
    return (1L);
} // acmdDriverClose()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverConfigure
//
//  Description:
//      This function is called to handle the DRV_[QUERY]CONFIGURE messages.
//      These messages are for 'configuration' support of the driver.
//      Normally this will be for 'hardware'--that is, a dialog should be
//      displayed to configure ports, IRQ's, memory mappings, etc if it
//      needs to. However, a software only ACM driver may also require
//      configuration for 'what is real time' or other quality vs time
//      issues.
//
//      The most common way that these messages are generated under Win 3.1
//      and NT Product 1 is from the Control Panel's Drivers option. Other
//      sources may generate these messages in future versions of Windows.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      HWND hwnd: Handle to parent window to use when displaying the
//      configuration dialog box. An ACM driver is _required_ to display a
//      modal dialog box using this hwnd argument as the parent. This
//      argument may be (HWND)-1 which tells the driver that it is only
//      being queried for configuration support.
//
//      LPDRVCONFIGINFO pdci: Pointer to optional DRVCONFIGINFO structure.
//      If this argument is NULL, then the ACM driver should invent its own
//      storage location.
//
//  Return (LRESULT):
//      If the driver is being 'queried' for configuration support (that is,
//      hwnd == (HWND)-1), then non-zero should be returned specifying
//      the driver does support a configuration dialog--or zero should be
//      returned specifying that no configuration dialog is supported.
//
//      If the driver is being called to display the configuration dialog
//      (that is, hwnd != (HWND)-1), then one of the following values
//      should be returned:
//
//      DRVCNF_CANCEL (0x0000): specifies that the dialog was displayed
//      and canceled by the user. this value should also be returned if
//      no configuration information was modified.
//
//      DRVCNF_OK (0x0001): specifies that the dialog was displayed and
//      the user pressed OK.  This value should be returned even if the
//      user didn't change anything - otherwise, the driver may not
//      install properly.
//
//      DRVCNF_RESTART (0x0002): specifies that the dialog was displayed
//      and some configuration information was changed that requires
//      Windows to be restarted before the changes take affect. the driver
//      should remain configured with current values until the driver
//      has been 'rebooted'.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverConfigure
(
    PDRIVERINSTANCE         pdi,
    HWND                    hwnd,
    LPDRVCONFIGINFO         pdci
)
{
    //
    //  first check to see if we are only being queried for configuration
    //  support. if hwnd == (HWND)-1 then we are being queried and should
    //  return zero for 'not supported' and non-zero for 'supported'.
    //
    if ((HWND)-1 == hwnd)
    {
        //
        //  this ACM driver does NOT support a configuration dialog box, so
        //  return zero...
        //
        return (0L);
    }


    //
    //  we are being asked to bring up our configuration dialog. if this
    //  driver supports a configuration dialog box, then after the dialog
    //  is dismissed we must return one of the following values:
    //
    //  DRVCNF_CANCEL (0x0000): specifies that the dialog was displayed
    //  and canceled by the user. this value should also be returned if
    //  no configuration information was modified.
    //
    //  DRVCNF_OK (0x0001): specifies that the dialog was displayed and
    //  the user pressed OK.  This value should be returned even if the
    //  user didn't change anything - otherwise, the driver may not
    //  install properly.
    //
    //  DRVCNF_RESTART (0x0002): specifies that the dialog was displayed
    //  and some configuration information was changed that requires
    //  Windows to be restarted before the changes take affect. the driver
    //  should remain configured with current values until the driver
    //  has been 'rebooted'.
    //
    //
    //  return DRVCNF_CANCEL--this ACM driver does not support configuration
    //
    return (DRVCNF_CANCEL);
} // acmdDriverConfigure()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverDetails
//
//  Description:
//      This function handles the ACMDM_DRIVER_DETAILS message. The ACM
//      driver is responsible for filling in the ACMDRIVERDETAILS structure
//      with various information.
//
//      NOTE! It is *VERY* important that you fill in your ACMDRIVERDETAILS
//      structure correctly. The ACM and applications must be able to
//      rely on this information.
//
//      WARNING! The _reserved_ bits of any fields of the ACMDRIVERDETAILS
//      structure are _exactly that_: RESERVED. Do NOT use any extra
//      flag bits, etc. for custom information. The proper way to add
//      custom capabilities to your ACM driver is this:
//
//      o   define a new message in the ACMDM_USER range.
//
//      o   an application that wishes to use one of these extra features
//          should then:
//
//          o   open the driver with acmDriverOpen.
//
//          o   check for the proper wMid and wPid using acmDriverDetails.
//
//          o   send the 'user defined' message with acmDriverMessage
//              to retrieve additional information, etc.
//
//          o   close the driver with acmDriverClose.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRIVERDETAILS padd: Pointer to ACMDRIVERDETAILS structure to
//      fill in for the caller. This structure may be larger or smaller than
//      the current definition of ACMDRIVERDETAILS--cbStruct specifies the
//      valid size.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) for success. Non-zero
//      signifies that the driver details could not be retrieved.
//
//      NOTE THAT THIS FUNCTION SHOULD NEVER FAIL! There are two possible
//      error conditions:
//
//      o   if padd is NULL or an invalid pointer.
//
//      o   if cbStruct is less than four; in this case, there is not enough
//          room to return the number of bytes filled in.
//
//      Because these two error conditions are easily defined, the ACM
//      will catch these errors. The driver does NOT need to check for these
//      conditions.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMDRIVERDETAILS      padd
)
{
    ACMDRIVERDETAILS    add;
    DWORD               cbStruct;

    //
    //  it is easiest to fill in a temporary structure with valid info
    //  and then copy the requested number of bytes to the destination
    //  buffer.
    //
    cbStruct            = min(padd->cbStruct, sizeof(ACMDRIVERDETAILS));
    add.cbStruct        = cbStruct;


    //
    //  for the current implementation of an ACM driver, the fccType and
    //  fccComp members *MUST* always be ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC
    //  ('audc') and ACMDRIVERDETAILS_FCCCOMP_UNDEFINED (0) respectively.
    //
    add.fccType         = ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC;
    add.fccComp         = ACMDRIVERDETAILS_FCCCOMP_UNDEFINED;


    //
    //  the manufacturer id (wMid) and product id (wPid) must be filled
    //  in with your company's _registered_ identifier's. for more
    //  information on these identifier's and how to get them registered
    //  contact Microsoft and get the Multimedia Developer Registration Kit:
    //
    //      Microsoft Corporation
    //      Multimedia Technology Group
    //      One Microsoft Way
    //      Redmond, WA 98052-6399
    //
    //      Developer Services Phone: (800) 227-4679 x11771
    //
    //  note that during the development phase or your ACM driver, you may
    //  use the reserved value of '0' for both wMid and wPid. however it
    //  is not acceptable to ship a driver with these values.
    //
    add.wMid            = MM_MICROSOFT;
    add.wPid            = MM_MSFT_ACM_G711;


    //
    //  the vdwACM and vdwDriver members contain version information for
    //  the driver.
    //
    //  vdwACM: must contain the version of the *ACM* that the driver was
    //  _designed_ for. this is the _minimum_ version number of the ACM
    //  that the driver will work with. this value must be >= V2.00.000.
    //
    //  vdwDriver: the version of this ACM driver.
    //
    //  ACM driver versions are 32 bit numbers broken into three parts as
    //  follows (note these parts are displayed as decimal values):
    //
    //      bits 24 - 31:   8 bit _major_ version number
    //      bits 16 - 23:   8 bit _minor_ version number
    //      bits  0 - 15:   16 bit build number
    //
    add.vdwACM          = VERSION_MSACM;
    add.vdwDriver       = VERSION_ACM_DRIVER;


    //
    //  the following flags are used to specify the type of conversion(s)
    //  that the ACM driver supports. note that a driver may support one or
    //  more of these flags in any combination.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CODEC: this flag is set if the driver
    //  supports conversions from one format tag to another format tag. for
    //  example, if a converter compresses or decompresses WAVE_FORMAT_PCM
    //  and WAVE_FORMAT_IMA_ADPCM, then this bit should be set. this is
    //  true even if the data is not actually changed in size--for example
    //  a conversion from u-Law to A-Law will still set this bit because
    //  the format tags differ.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CONVERTER: this flags is set if the
    //  driver supports conversions on the same format tag. as an example,
    //  the PCM converter that is built into the ACM sets this bit (and only
    //  this bit) because it converts only between PCM formats (bits, sample
    //  rate).
    //
    //  ACMDRIVERDETAILS_SUPPORTF_FILTER: this flag is set if the driver
    //  supports transformations on a single format tag but does change
    //  the base characteristics of the format (bit depth, sample rate, etc
    //  will remain the same). for example, a driver that changed the
    //  'volume' of PCM data or applied a low pass filter would set this bit.
    //
    add.fdwSupport      = ACMDRIVERDETAILS_SUPPORTF_CODEC;


    //
    //  the number of individual format tags this ACM driver supports. for
    //  example, if a driver uses the WAVE_FORMAT_IMA_ADPCM and
    //  WAVE_FORMAT_PCM format tags, then this value would be two. if the
    //  driver only supports filtering on WAVE_FORMAT_PCM, then this value
    //  would be one. if this driver supported WAVE_FORMAT_ALAW,
    //  WAVE_FORMAT_MULAW and WAVE_FORMAT_PCM, then this value would be
    //  three. etc, etc.
    //
    add.cFormatTags     = ACM_DRIVER_MAX_FORMAT_TAGS;

    //
    //  the number of individual filter tags this ACM driver supports. if
    //  a driver supports no filters (ACMDRIVERDETAILS_SUPPORTF_FILTER is
    //  NOT set in the fdwSupport member), then this value must be zero.
    //
    add.cFilterTags     = ACM_DRIVER_MAX_FILTER_TAGS;


    //
    //  the remaining members in the ACMDRIVERDETAILS structure are sometimes
    //  not needed. because of this we make a quick check to see if we
    //  should go through the effort of filling in these members.
    //
    if (FIELD_OFFSET(ACMDRIVERDETAILS, hicon) < cbStruct)
    {
        //
        //  fill in the hicon member will a handle to a custom icon for
        //  the ACM driver. this allows the driver to be represented by
        //  an application graphically (usually this will be a company
        //  logo or something). if a driver does not wish to have a custom
        //  icon displayed, then simply set this member to NULL and a
        //  generic icon will be displayed instead.
        //
        //  See the MSFILTER sample for a codec which contains a custom icon.
        //
        add.hicon = NULL;

        //
        //  the short name and long name are used to represent the driver
        //  in a unique description. the short name is intended for small
        //  display areas 