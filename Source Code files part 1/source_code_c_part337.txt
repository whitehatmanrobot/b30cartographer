ttern alignment
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    xPattern;
    LONG    yPattern;
    LONG    iLeftShift;
    LONG    iRightShift;
    LONG    xOld;
    LONG    yOld;
    LONG    i;
    BYTE    j;
    ULONG   ulHwForeMix;
    ULONG   ulHwBackMix;
    LONG    xLeft;
    LONG    yTop;
    ULONG   aulTmp[2];
    LONG    x;

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    xPattern = (pptlBrush->x + xOffset) & 7;
    yPattern = (pptlBrush->y + yOffset) & 7;

    // If the alignment isn't correct, we'll have to change it:

    if ((xPattern != rbc.prb->ptlBrush.x) || (yPattern != rbc.prb->ptlBrush.y))
    {
        // Remember that we've changed the alignment on our cached brush:

        xOld = rbc.prb->ptlBrush.x;
        yOld = rbc.prb->ptlBrush.y;

        rbc.prb->ptlBrush.x = xPattern;
        rbc.prb->ptlBrush.y = yPattern;

        // Now do the alignment:

        yPattern    = (yOld - yPattern);
        iRightShift = (xPattern - xOld) & 7;
        iLeftShift  = 8 - iRightShift;

        pjSrc = (BYTE*) &rbc.prb->aulPattern[0];
        pjDst = (BYTE*) &aulTmp[0];

        for (i = 0; i < 8; i++)
        {
            j = *(pjSrc + (yPattern++ & 7));
            *pjDst++ = (j << iLeftShift) | (j >> iRightShift);
        }

        rbc.prb->aulPattern[0] = aulTmp[0];
        rbc.prb->aulPattern[1] = aulTmp[1];
    }

    ulHwForeMix = gaul64HwMixFromRop2[(rop4 >> 2) & 0xf];
    ulHwBackMix = ((rop4 & 0xff00) == 0xaa00) ? LEAVE_ALONE : (ulHwForeMix >> 16);

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 14);
    M64_OD(pjMmBase, CONTEXT_LOAD_CNTL, CONTEXT_LOAD_CmdLoad | ppdev->iDefContext );
    M64_OD(pjMmBase, PAT_CNTL, PAT_CNTL_MonoEna);
    M64_OD(pjMmBase, DP_SRC, DP_SRC_MonoPattern | DP_SRC_FrgdClr << 8);
    M64_OD(pjMmBase, DP_MIX, ulHwBackMix | ulHwForeMix);
    M64_OD(pjMmBase, DP_FRGD_CLR, rbc.prb->ulForeColor);
    M64_OD(pjMmBase, DP_BKGD_CLR, rbc.prb->ulBackColor);
    M64_OD(pjMmBase, PAT_REG0, rbc.prb->aulPattern[0]);
    M64_OD(pjMmBase, PAT_REG1, rbc.prb->aulPattern[1]);
    // You must turn off DP_BYTE_PIX_ORDER, or else the pattern is incorrectly
    // aligned.  This took a long time to figure out.
    M64_OD(pjMmBase, DP_PIX_WIDTH, 0x00000202);

    while(TRUE)
    {
        xLeft = prcl->left;
        yTop  = prcl->top;
        x     = (xLeft + xOffset) * 3;

        M64_OD(pjMmBase, DST_CNTL,         0x83 | ((x/4 % 6) << 8));
        M64_OD(pjMmBase, DST_Y_X,          PACKXY(x,
                                                  yTop + yOffset));
        M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY((prcl->right - xLeft) * 3,
                                                  prcl->bottom - prcl->top));
        if (--c == 0)
            break;

        prcl++;
        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);
    }

    M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
    M64_OD(pjMmBase, DP_PIX_WIDTH, ppdev->ulMonoPixelWidth);
}

/******************************Public*Routine******************************\
* VOID vM64PatColorRealize
*
* This routine transfers an 8x8 pattern to off-screen display memory,
* so that it can be used by the Mach64 'general pattern with rotation'
* hardware.
*
* See Blt_DS_PCOL_ENG_8G_D0.
*
\**************************************************************************/

VOID vM64PatColorRealize(       // Type FNPATREALIZE
PDEV*   ppdev,
RBRUSH* prb)                    // Points to brush realization structure
{
    BRUSHENTRY* pbe;
    LONG        iBrushCache;
    SURFOBJ     soSrc;
    POINTL      ptlSrc;
    RECTL       rclDst;

    // We have to allocate a new off-screen cache brush entry for
    // the brush:

    iBrushCache = ppdev->iBrushCache;
    pbe         = &ppdev->abe[iBrushCache];

    iBrushCache = (iBrushCache + 1) & (TOTAL_BRUSH_COUNT - 1);

    ppdev->iBrushCache = iBrushCache;

    // Update our links:

    pbe->prbVerify           = prb;
    prb->apbe[IBOARD(ppdev)] = pbe;

    // pfnPutBits looks at only two fields in the SURFOBJ, and since we're
    // only going to download a single scan, we don't even have to set
    // 'lDelta'.

    soSrc.pvScan0 = &prb->aulPattern[0];

    ptlSrc.x = 0;
    ptlSrc.y = 0;

    rclDst.left   = pbe->x;
    rclDst.right  = pbe->x + TOTAL_BRUSH_SIZE;
    rclDst.top    = pbe->y;
    rclDst.bottom = pbe->y + 1;

    ppdev->pfnPutBits(ppdev, &soSrc, &rclDst, &ptlSrc);
}

/******************************Public*Routine******************************\
* VOID vM64FillPatColor
*
* This routine uses the pattern hardware to draw a patterned list of
* rectangles.
*
* See Blt_DS_PCOL_ENG_8G_D0 and Blt_DS_PCOL_ENG_8G_D1.
*
\**************************************************************************/

VOID vM64FillPatColor(          // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BRUSHENTRY* pbe;
    BYTE*       pjMmBase;
    LONG        xOffset;
    LONG        yOffset;
    LONG        xLeft;
    LONG        yTop;
    ULONG       ulSrc;

    // See if the brush has already been put into off-screen memory:

    pbe = rbc.prb->apbe[IBOARD(ppdev)];
    if ((pbe == NULL) || (pbe->prbVerify != rbc.prb))
    {
        vM64PatColorRealize(ppdev, rbc.prb);
        pbe = rbc.prb->apbe[IBOARD(ppdev)];
    }

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 11);
    M64_OD(pjMmBase, CONTEXT_LOAD_CNTL, CONTEXT_LOAD_CmdLoad | ppdev->iDefContext );
    M64_OD(pjMmBase, SRC_OFF_PITCH,      pbe->ulOffsetPitch);
    M64_OD(pjMmBase, DP_MIX,             gaul64HwMixFromRop2[(rop4 >> 2) & 0xf]);
    M64_OD(pjMmBase, SRC_CNTL,           SRC_CNTL_PatEna | SRC_CNTL_PatRotEna);
    M64_OD(pjMmBase, DP_SRC,             DP_SRC_Blit << 8);
    M64_OD(pjMmBase, SRC_Y_X_START,      0);
    M64_OD(pjMmBase, SRC_HEIGHT2_WIDTH2, PACKXY(8, 8));

    while (TRUE)
    {
        xLeft = prcl->left;
        yTop  = prcl->top;

        ulSrc = PACKXY_FAST((xLeft - pptlBrush->x) & 7,
                            (yTop  - pptlBrush->y) & 7);

        M64_OD(pjMmBase, SRC_Y_X,            ulSrc);
        M64_OD(pjMmBase, SRC_HEIGHT1_WIDTH1, PACKXY(8, 8) - ulSrc);
        M64_OD(pjMmBase, DST_Y_X,            PACKXY(xLeft + xOffset,
                                                    yTop  + yOffset));
        M64_OD(pjMmBase, DST_HEIGHT_WIDTH,   PACKXY(prcl->right - prcl->left,
                                                    prcl->bottom - prcl->top));
        if (--c == 0)
            break;

        prcl++;
        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 4);
    }
}

VOID vM64FillPatColor24(        // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BRUSHENTRY* pbe;
    BYTE*       pjMmBase;
    LONG        xOffset;
    LONG        yOffset;
    LONG        xLeft;
    LONG        yTop;
    ULONG       ulSrc;

    // See if the brush has already been put into off-screen memory:

    pbe = rbc.prb->apbe[IBOARD(ppdev)];
    if ((pbe == NULL) || (pbe->prbVerify != rbc.prb))
    {
        vM64PatColorRealize(ppdev, rbc.prb);
        pbe = rbc.prb->apbe[IBOARD(ppdev)];
    }

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 11);
    M64_OD(pjMmBase, CONTEXT_LOAD_CNTL, CONTEXT_LOAD_CmdLoad | ppdev->iDefContext );
    M64_OD(pjMmBase, SRC_OFF_PITCH,      pbe->ulOffsetPitch);
    M64_OD(pjMmBase, DP_MIX,             gaul64HwMixFromRop2[(rop4 >> 2) & 0xf]);
    M64_OD(pjMmBase, SRC_CNTL,           SRC_CNTL_PatEna | SRC_CNTL_PatRotEna);
    M64_OD(pjMmBase, DP_SRC,             DP_SRC_Blit << 8);
    M64_OD(pjMmBase, SRC_Y_X_START,      0);
    M64_OD(pjMmBase, SRC_HEIGHT2_WIDTH2, PACKXY(24, 8));

    while (TRUE)
    {
        xLeft = prcl->left;
        yTop  = prcl->top;

        ulSrc = PACKXY_FAST(((xLeft - pptlBrush->x) & 7) * 3,
                            (yTop  - pptlBrush->y) & 7);

        M64_OD(pjMmBase, SRC_Y_X,            ulSrc);
        M64_OD(pjMmBase, SRC_HEIGHT1_WIDTH1, PACKXY(24, 8) - ulSrc);
        M64_OD(pjMmBase, DST_Y_X,            PACKXY((xLeft + xOffset) * 3,
                                                    yTop  + yOffset));
        M64_OD(pjMmBase, DST_HEIGHT_WIDTH,   PACKXY((prcl->right - prcl->left) * 3,
                                                    prcl->bottom - prcl->top));
        if (--c == 0)
            break;

        prcl++;
        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 4);
    }
}

/******************************Public*Routine******************************\
* VOID vM64XferNative
*
* Transfers a bitmap that is the same colour depth as the display to
* the screen via the data transfer register, with no translation.
*
\**************************************************************************/

VOID vM64XferNative(    // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ULONG       rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Not used
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    ULONG   ulHwForeMix;
    LONG    dx;
    LONG    dy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    cy;
    LONG    cx;
    LONG    xBias;
    ULONG*  pulSrc;
    ULONG   culScan;
    LONG    lSrcSkip;
    LONG    i;
    ULONG   ulFifo;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;
    ulFifo   = 0;

    ulHwForeMix = gaul64HwMixFromRop2[rop4 & 0xf];

    M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 9, ulFifo);
    // default registers for hw bugs:
    M64_OD(pjMmBase, DP_WRITE_MASK, 0xFFFFFFFF);
    M64_OD(pjMmBase, CLR_CMP_CNTL,  0);
    M64_OD(pjMmBase, GUI_TRAJ_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);

    M64_OD(pjMmBase, DP_MIX, ulHwForeMix | (ulHwForeMix >> 16));
    M64_OD(pjMmBase, DP_SRC, (DP_SRC_Host << 8));

    // The host data pixel width is the same as that of the screen:

    M64_OD(pjMmBase, DP_PIX_WIDTH, ppdev->ulMonoPixelWidth |
                                   ((ppdev->ulMonoPixelWidth & 0xf) << 16));

    dx = (pptlSrc->x - prclDst->left) << ppdev->cPelSize;   // Bytes
    dy = pptlSrc->y - prclDst->top;

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    while (TRUE)
    {
        xLeft  = prcl->left;
        xRight = prcl->right;
        yTop   = prcl->top;
        cy     = prcl->bottom - yTop;

        M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(xLeft + xOffset, xRight + xOffset - 1));

        //
        // Convert pixels to bytes.
        //

        xLeft  <<= ppdev->cPelSize;
        xRight <<= ppdev->cPelSize;

        //
        // We compute 'xBias' in order to dword-align the source pointer.
        // This way, we don't have to do unaligned reads of the source,
        // and we're guaranteed not to read even a byte past the end of
        // the bitmap.
        //

        xBias  = (xLeft + dx) & 3;                      // Floor (bytes)
        xLeft -= xBias;                                 // Bytes
        cx     = (xRight - xLeft + 3) & ~3;             // Ceiling (bytes)

        M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST((xLeft >> ppdev->cPelSize) + xOffset, yTop + yOffset));
        M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx >> ppdev->cPelSize, cy));

        pulSrc   = (PULONG)(pjSrcScan0 + (yTop + dy) * lSrcDelta + xLeft + dx);
        culScan  = cx >> 2;                             // Dwords
        lSrcSkip = lSrcDelta - cx;                      // Bytes

        ASSERTDD(((ULONG_PTR)pulSrc & 3) == 0, "Source should be dword aligned");

        if (culScan && cy)
        {
            do
            {
                i = culScan;

                do
                {
                    M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 1, ulFifo);
                    M64_OD(pjMmBase, HOST_DATA0, *pulSrc);
                    pulSrc++;
                } while (--i != 0);

                pulSrc = (PULONG)((BYTE*)pulSrc + lSrcSkip);

            } while (--cy != 0);
        }

        if (--c == 0)
            break;

        prcl++;
        M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 3, ulFifo);
    }

    // Don't forget to reset the clip register and the default pixel width:

    M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 2, ulFifo);
    M64_OD(pjMmBase, DP_PIX_WIDTH,  ppdev->ulMonoPixelWidth);
    M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(0, M64_MAX_SCISSOR_R));
}

VOID vM64XferNative24(  // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ULONG       rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Not used
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    ULONG   ulHwForeMix;
    LONG    dx;
    LONG    dy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    cy;
    LONG    cx;
    LONG    xBias;
    ULONG*  pulSrc;
    ULONG   culScan;
    LONG    lSrcSkip;
    LONG    i;
    ULONG   ulFifo;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset * 3;
    yOffset  = ppdev->yOffset;
    ulFifo   = 0;

    ulHwForeMix = gaul64HwMixFromRop2[rop4 & 0xf];

    M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 9, ulFifo);
    // default registers for hw bugs:
    M64_OD(pjMmBase, DP_WRITE_MASK, 0xFFFFFFFF);
    M64_OD(pjMmBase, CLR_CMP_CNTL,  0);
    M64_OD(pjMmBase, GUI_TRAJ_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);

    M64_OD(pjMmBase, DP_MIX, ulHwForeMix | (ulHwForeMix >> 16));
    M64_OD(pjMmBase, DP_SRC, (DP_SRC_Host << 8));

    // The host data pixel width is the same as that of the screen:

    M64_OD(pjMmBase, DP_PIX_WIDTH, ppdev->ulMonoPixelWidth |
                                   ((ppdev->ulMonoPixelWidth & 0xf) << 16));

    dx = (pptlSrc->x - prclDst->left) * 3;          // Bytes
    dy = pptlSrc->y - prclDst->top;

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    while (TRUE)
    {
        xLeft  = prcl->left * 3;
        xRight = prcl->right * 3;
        yTop   = prcl->top;
        cy     = prcl->bottom - yTop;

        M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(xLeft + xOffset, xRight + xOffset - 1));

        //
        // We compute 'xBias' in order to dword-align the source pointer.
        // This way, we don't have to do unaligned reads of the source,
        // and we're guaranteed not to read even a byte past the end of
        // the bitmap.
        //

        xBias  = (xLeft + dx) & 3;              // Floor (bytes)
        xLeft -= xBias;                         // Bytes
        cx     = (xRight - xLeft + 3) & ~3;     // Ceiling (bytes)

        M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xLeft + xOffset, yTop + yOffset));
        M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

        pulSrc   = (PULONG)(pjSrcScan0 + (yTop + dy) * lSrcDelta + xLeft + dx);
        culScan  = cx >> 2;                     // Dwords
        lSrcSkip = lSrcDelta - cx;              // Bytes

        ASSERTDD(((ULONG_PTR)pulSrc & 3) == 0, "Source should be dword aligned");

        if (culScan && cy)
        {
            do
            {
                i = culScan;

                do
                {
                    M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 1, ulFifo);
                    M64_OD(pjMmBase, HOST_DATA0, *pulSrc);
                    pulSrc++;
                } while (--i != 0);

                pulSrc = (PULONG)((BYTE*)pulSrc + lSrcSkip);

            } while (--cy != 0);
        }

        if (--c == 0)
            break;

        prcl++;
        M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 3, ulFifo);
    }

    // Don't forget to reset the clip register and the default pixel width:

    M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 2, ulFifo);
    M64_OD(pjMmBase, DP_PIX_WIDTH,  ppdev->ulMonoPixelWidth);
    M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(0, M64_MAX_SCISSOR_R));
}

/******************************Public*Routine******************************\
* VOID vM64Xfer1bpp
*
* This routine colour expands a monochrome bitmap.
*
* See Blt_DS_S1_8G_D0 and Blt_DS_8G_D1.
*
\**************************************************************************/

VOID vM64Xfer1bpp(      // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ROP4        rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    ULONG*  pulXlate;
    ULONG   ulHwForeMix;
    LONG    dx;
    LONG    dy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    cy;
    LONG    cx;
    LONG    xBias;
    LONG    culScan;
    LONG    lSrcSkip;
    ULONG*  pulSrc;
    LONG    i;
    ULONG   ulFifo;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;
    ulFifo   = 0;

    ulHwForeMix = gaul64HwMixFromRop2[rop4 & 0xf];
    pulXlate    = pxlo->pulXlate;
    M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 8, ulFifo);
    M64_OD(pjMmBase, CONTEXT_LOAD_CNTL, CONTEXT_LOAD_CmdLoad | ppdev->iDefContext );
    M64_OD(pjMmBase, DP_BKGD_CLR, pulXlate[0]);
    M64_OD(pjMmBase, DP_FRGD_CLR, pulXlate[1]);
    M64_OD(pjMmBase, DP_MIX,      ulHwForeMix | (ulHwForeMix >> 16));
    M64_OD(pjMmBase, DP_SRC,      (DP_SRC_Host << 16) | (DP_SRC_FrgdClr << 8) |
                                  (DP_SRC_BkgdClr));

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;


    while (TRUE)
    {
        xLeft  = prcl->left;
        xRight = prcl->right;

        // The Mach64 'bit packs' monochrome transfers, but GDI gives
        // us monochrome bitmaps whose scans are always dword aligned.
        // Consequently, we use the Mach64's clip registers to make
        // our transfers a multiple of 32 to match the dword alignment:

        M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(xLeft + xOffset,
                                                 xRight + xOffset - 1));
        yTop = prcl->top;
        cy   = prcl->bottom - yTop;

        xBias  = (xLeft + dx) & 31;             // Floor
        xLeft -= xBias;
        cx     = (xRight - xLeft + 31) & ~31;   // Ceiling

        M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xLeft + xOffset,
                                              yTop  + yOffset));

        M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

        pulSrc   = (ULONG*) (pjSrcScan0 + (yTop + dy) * lSrcDelta
                                        + ((xLeft + dx) >> 3));
        culScan  = cx >> 5;
        lSrcSkip = lSrcDelta - (culScan << 2);

        ASSERTDD(((ULONG_PTR)pulSrc & 3) == 0, "Source should be dword aligned");

        do {
            i = culScan;
            do {
                M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 1, ulFifo);
                M64_OD(pjMmBase, HOST_DATA0, *pulSrc);
                pulSrc++;

            } while (--i != 0);

            pulSrc = (ULONG*) ((BYTE*) pulSrc + lSrcSkip);

        } while (--cy != 0);

        if (--c == 0)
            break;

        prcl++;
        M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 3, ulFifo);
    }

    // Don't forget to reset the clip register:

    M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 1, ulFifo);
    M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(0, M64_MAX_SCISSOR_R));
}

/******************************Public*Routine******************************\
* VOID vM64Xfer4bpp
*
* Does a 4bpp transfer from a bitmap to the screen.
*
* The reason we implement this is that a lot of resources are kept as 4bpp,
* and used to initialize DFBs, some of which we of course keep off-screen.
*
\**************************************************************************/

VOID vM64Xfer4bpp(      // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ULONG       rop4,       // Rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    cjPelSize;
    ULONG   ulHwForeMix;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    xBias;
    LONG    dx;
    LONG    dy;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjSrc;
    BYTE    jSrc;
    ULONG*  pulXlate;
    LONG    i;
    ULONG   ul;
    LONG    cjSrc;
    LONG    cwSrc;
    LONG    lSrcSkip;
    ULONG   ulFifo;

    ASSERTDD(psoSrc->iBitmapFormat == BMF_4BPP, "Source must be 4bpp");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(ppdev->iBitmapFormat != BMF_24BPP, "Can't handle 24bpp");

    pjMmBase  = ppdev->pjMmBase;
    xOffset   = ppdev->xOffset;
    yOffset   = ppdev->yOffset;
    cjPelSize = ppdev->cjPelSize;
    pulXlate  = pxlo->pulXlate;
    ulFifo    = 0;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    ulHwForeMix = gaul64HwMixFromRop2[rop4 & 0xf];
    M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 7, ulFifo);
    // Fix vanishing fills and various color problems:
    M64_OD(pjMmBase, CONTEXT_LOAD_CNTL, CONTEXT_LOAD_CmdLoad | ppdev->iDefContext );
    M64_OD(pjMmBase, DP_MIX, ulHwForeMix | (ulHwForeMix >> 16));
    M64_OD(pjMmBase, DP_SRC, (DP_SRC_Host << 8));

    // The host data pixel width is the same as that of the screen:

    M64_OD(pjMmBase, DP_PIX_WIDTH, ppdev->ulMonoPixelWidth |
                                   ((ppdev->ulMonoPixelWidth & 0xf) << 16));

    while(TRUE)
    {
        xLeft  = prcl->left;
        xRight = prcl->right;

        M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(xLeft + xOffset,
                                                 xRight + xOffset - 1));
        yTop = prcl->top;
        cy   = prcl->bottom - yTop;

        // We compute 'xBias' in order to dword-align the source pointer.
        // This way, we don't have to do unaligned reads of the source,
        // and we're guaranteed not to read even a byte past the end of
        // the bitmap.
        //
        // Note that this bias works at 24bpp, too:

        xBias  = (xLeft + dx) & 3;              // Floor
        xLeft -= xBias;
        cx     = (xRight - xLeft + 3) & ~3;     // Ceiling

        M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xLeft + xOffset,
                                              yTop  + yOffset));

        M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

        pjSrc    = pjSrcScan0 + (yTop + dy) * lSrcDelta
                              + ((xLeft + dx) >> 1);
        cjSrc    = cx >> 1;         // Number of source bytes touched
        lSrcSkip = lSrcDelta - cjSrc;

        if (cjPelSize == 1)
        {
            // This part handles 8bpp output:

            cwSrc = (cjSrc >> 1);    // Number of whole source words

            do {
                for (i = cwSrc; i != 0; i--)
                {
                    jSrc = *pjSrc++;
                    ul   = (pulXlate[jSrc >> 4]);
                    ul  |= (pulXlate[jSrc & 0xf] << 8);
                    jSrc = *pjSrc++;
                    ul  |= (pulXlate[jSrc >> 4] << 16);
                    ul  |= (pulXlate[jSrc & 0xf] << 24);
                    M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 1, ulFifo);
                    M64_OD(pjMmBase, HOST_DATA0, ul);
                }

                // Handle an odd end byte, if there is one:

                if (cjSrc & 1)
                {
                    jSrc = *pjSrc++;
                    ul   = (pulXlate[jSrc >> 4]);
                    ul  |= (pulXlate[jSrc & 0xf] << 8);
                    M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 1, ulFifo);
                    M64_OD(pjMmBase, HOST_DATA0, ul);
                }

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }
        else if (cjPelSize == 2)
        {
            // This part handles 16bpp output:

            do {
                i = cjSrc;
                do {
                    jSrc = *pjSrc++;
                    ul   = (pulXlate[jSrc >> 4]);
                    ul  |= (pulXlate[jSrc & 0xf] << 16);
                    M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 1, ulFifo);
                    M64_OD(pjMmBase, HOST_DATA0, ul);
                } while (--i != 0);

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }
        else
        {
            // This part handles 32bpp output:

            do {
                i = cjSrc;
                do {
                    jSrc = *pjSrc++;
                    M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 2, ulFifo);
                    M64_OD(pjMmBase, HOST_DATA0, pulXlate[jSrc >> 4]);
                    M64_OD(pjMmBase, HOST_DATA0, pulXlate[jSrc & 0xf]);
                } while (--i != 0);

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }

        if (--c == 0)
            break;

        prcl++;
        M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 3, ulFifo);
    }

    // Don't forget to reset the clip register and the default pixel width:

    M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 2, ulFifo);
    M64_OD(pjMmBase, DP_PIX_WIDTH,  ppdev->ulMonoPixelWidth);
    M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(0, M64_MAX_SCISSOR_R));
}

/******************************Public*Routine******************************\
* VOID vM64Xfer8bpp
*
* Does a 8bpp transfer from a bitmap to the screen.
*
* The reason we implement this is that a lot of resources are kept as 8bpp,
* and used to initialize DFBs, some of which we of course keep off-screen.
*
\**************************************************************************/

VOID vM64Xfer8bpp(         // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ULONG       rop4,       // Rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    cjPelSize;
    ULONG   ulHwForeMix;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    xBias;
    LONG    dx;
    LONG    dy;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjSrc;
    ULONG*  pulXlate;
    LONG    i;
    ULONG   ul;
    LONG    cdSrc;
    LONG    cwSrc;
    LONG    cxRem;
    LONG    lSrcSkip;
    ULONG   ulFifo;

    ASSERTDD(psoSrc->iBitmapFormat == BMF_8BPP, "Source must be 8bpp");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(ppdev->iBitmapFormat != BMF_24BPP, "Can't handle 24bpp");

    pjMmBase  = ppdev->pjMmBase;
    xOffset   = ppdev->xOffset;
    yOffset   = ppdev->yOffset;
    cjPelSize = ppdev->cjPelSize;
    pulXlate  = pxlo->pulXlate;
    ulFifo    = 0;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    ulHwForeMix = gaul64HwMixFromRop2[rop4 & 0xf];
    M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 7, ulFifo);
    // Fix vanishing fills and various color problems:
    M64_OD(pjMmBase, CONTEXT_LOAD_CNTL, CONTEXT_LOAD_CmdLoad | ppdev->iDefContext );
    M64_OD(pjMmBase, DP_MIX, ulHwForeMix | (ulHwForeMix >> 16));
    M64_OD(pjMmBase, DP_SRC, (DP_SRC_Host << 8));

    // The host data pixel width is the same as that of the screen:

    M64_OD(pjMmBase, DP_PIX_WIDTH, ppdev->ulMonoPixelWidth |
                                   ((ppdev->ulMonoPixelWidth & 0xf) << 16));

    while(TRUE)
    {
        xLeft  = prcl->left;
        xRight = prcl->right;

        M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(xLeft + xOffset,
                                                 xRight + xOffset - 1));
        yTop = prcl->top;
        cy   = prcl->bottom - yTop;

        // We compute 'xBias' in order to dword-align the source pointer.
        // This way, we don't have to do unaligned reads of the source,
        // and we're guaranteed not to read even a byte past the end of
        // the bitmap.
        //
        // Note that this bias works at 24bpp, too:

        xBias  = (xLeft + dx) & 3;              // Floor
        xLeft -= xBias;
        cx     = (xRight - xLeft + 3) & ~3;     // Ceiling

        M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xLeft + xOffset,
                                              yTop  + yOffset));

        M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

        pjSrc    = pjSrcScan0 + (yTop + dy) * lSrcDelta
                              + (xLeft + dx);
        lSrcSkip = lSrcDelta - cx;

        if (cjPelSize == 1)
        {
            // This part handles 8bpp output:

            cdSrc = (cx >> 2);
            cxRem = (cx & 3);

            do {
                for (i = cdSrc; i != 0; i--)
                {
                    ul  = (pulXlate[*pjSrc++]);
                    ul |= (pulXlate[*pjSrc++] << 8);
                    ul |= (pulXlate[*pjSrc++] << 16);
                    ul |= (pulXlate[*pjSrc++] << 24);
                    M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 1, ulFifo);
                    M64_OD(pjMmBase, HOST_DATA0, ul);
                }

                if (cxRem > 0)
                {
                    ul = (pulXlate[*pjSrc++]);
                    if (cxRem > 1)
                    {
                        ul |= (pulXlate[*pjSrc++] << 8);
                        if (cxRem > 2)
                        {
                            ul |= (pulXlate[*pjSrc++] << 16);
                        }
                    }
                    M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 1, ulFifo);
                    M64_OD(pjMmBase, HOST_DATA0, ul);
                }

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }
        else if (cjPelSize == 2)
        {
            // This part handles 16bpp output:

            cwSrc = (cx >> 1);
            cxRem = (cx & 1);

            do {
                for (i = cwSrc; i != 0; i--)
                {
                    ul  = (pulXlate[*pjSrc++]);
                    ul |= (pulXlate[*pjSrc++] << 16);
                    M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 1, ulFifo);
                    M64_OD(pjMmBase, HOST_DATA0, ul);
                }

                if (cxRem > 0)
                {
                    ul = (pulXlate[*pjSrc++]);
                    M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 1, ulFifo);
                    M64_OD(pjMmBase, HOST_DATA0, ul);
                }

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }
        else
        {
            // This part handles 32bpp output:

            do {
                i = cx;
                do {
                    ul = pulXlate[*pjSrc++];
                    M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 1, ulFifo);
                    M64_OD(pjMmBase, HOST_DATA0, ul);
                } while (--i != 0);

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }

        if (--c == 0)
            break;

        prcl++;
        M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 3, ulFifo);
    }

    // Don't forget to reset the clip register and the default pixel width:

    M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 2, ulFifo);
    M64_OD(pjMmBase, DP_PIX_WIDTH,  ppdev->ulMonoPixelWidth);
    M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(0, M64_MAX_SCISSOR_R));
}

/******************************Public*Routine******************************\
* VOID vM64CopyBlt
*
* Does a screen-to-screen blt of a list of rectangles.
*
* See Blt_DS_SS_ENG_8G_D0 and Blt_DS_SS_TLBR_ENG_8G_D1.
*
\**************************************************************************/

VOID vM64CopyBlt(   // Type FNCOPY
PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
ULONG   rop4,       // rop4
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst)    // Original unclipped destination rectangle
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    dx;
    LONG    dy;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    yBottom;
    LONG    cx;
    LONG    cy;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 11);
    M64_OD(pjMmBase, CONTEXT_LOAD_CNTL, CONTEXT_LOAD_CmdLoad | ppdev->iDefContext );
    M64_OD(pjMmBase, SRC_OFF_PITCH, ppdev->ulScreenOffsetAndPitch);
    M64_OD(pjMmBase, DP_SRC,        DP_SRC_Blit << 8);
    M64_OD(pjMmBase, DP_MIX,        gaul64HwMixFromRop2[rop4 & 0xf]);
    M64_OD(pjMmBase, SRC_CNTL,      0);

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    // The accelerator may not be as fast at doing right-to-left copies, so
    // only do them when the rectangles truly overlap:

    if (!OVERLAP(prclDst, pptlSrc))
        goto Top_Down_Left_To_Right;

    if (prclDst->top <= pptlSrc->y)
    {
        if (prclDst->left <= pptlSrc->x)
        {

Top_Down_Left_To_Right:

            while (TRUE)
            {
                xLeft = xOffset + prcl->left;
                yTop  = yOffset + prcl->top;
                cx    = prcl->right - prcl->left;
                cy    = prcl->bottom - prcl->top;

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xLeft, yTop));
                M64_OD(pjMmBase, SRC_Y_X, PACKXY_FAST(xLeft + dx, yTop + dy));
                M64_OD(pjMmBase, SRC_WIDTH1, cx);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

                if (--c == 0)
                    break;

                prcl++;
                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 4);
            }
        }
        else
        {
            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_YDir);

            while (TRUE)
            {
                xRight = xOffset + prcl->right - 1;
                yTop   = yOffset + prcl->top;
                cx     = prcl->right - prcl->left;
                cy     = prcl->bottom - prcl->top;

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xRight, yTop));
                M64_OD(pjMmBase, SRC_Y_X, PACKXY_FAST(xRight + dx, yTop + dy));
                M64_OD(pjMmBase, SRC_WIDTH1, cx);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

                if (--c == 0)
                    break;

                prcl++;
                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);
            }

            // Since we don't use a default context, we must restore registers:

            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
        }
    }
    else
    {
        if (prclDst->left <= pptlSrc->x)
        {
            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir);

            while (TRUE)
            {
                xLeft   = xOffset + prcl->left;
                yBottom = yOffset + prcl->bottom - 1;
                cx      = prcl->right - prcl->left;
                cy      = prcl->bottom - prcl->top;

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xLeft, yBottom));
                M64_OD(pjMmBase, SRC_Y_X, PACKXY_FAST(xLeft + dx, yBottom + dy));
                M64_OD(pjMmBase, SRC_WIDTH1, cx);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

                if (--c == 0)
                    break;

                prcl++;
                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);
            }

            // Since we don't use a default context, we must restore registers:

            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
        }
        else
        {
            M64_OD(pjMmBase, DST_CNTL, 0);

            while (TRUE)
            {
                xRight  = xOffset + prcl->right - 1;
                yBottom = yOffset + prcl->bottom - 1;
                cx      = prcl->right - prcl->left;
                cy      = prcl->bottom - prcl->top;

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xRight, yBottom));
                M64_OD(pjMmBase, SRC_Y_X, PACKXY_FAST(xRight + dx, yBottom + dy));
                M64_OD(pjMmBase, SRC_WIDTH1, cx);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

                if (--c == 0)
                    break;

                prcl++;
                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);
            }

            // Since we don't use a default context, we must restore registers:

            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
        }
    }
}

VOID vM64CopyBlt24( // Type FNCOPY
PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
ULONG   rop4,       // rop4
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst)    // Original unclipped destination rectangle
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    dx;
    LONG    dy;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    yBottom;
    LONG    cx;
    LONG    cy;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 11);
    M64_OD(pjMmBase, CONTEXT_LOAD_CNTL, CONTEXT_LOAD_CmdLoad | ppdev->iDefContext );
    M64_OD(pjMmBase, SRC_OFF_PITCH, ppdev->ulScreenOffsetAndPitch);
    M64_OD(pjMmBase, DP_SRC,        DP_SRC_Blit << 8);
    M64_OD(pjMmBase, DP_MIX,        gaul64HwMixFromRop2[rop4 & 0xf]);
    M64_OD(pjMmBase, SRC_CNTL,      0);

    dx = (pptlSrc->x - prclDst->left) * 3;
    dy = pptlSrc->y - prclDst->top;

    // The accelerator may not be as fast at doing right-to-left copies, so
    // only do them when the rectangles truly overlap:

    if (!OVERLAP(prclDst, pptlSrc))
        goto Top_Down_Left_To_Right;

    if (prclDst->top <= pptlSrc->y)
    {
        if (prclDst->left <= pptlSrc->x)
        {

Top_Down_Left_To_Right:

            while (TRUE)
            {
                xLeft = (xOffset + prcl->left) * 3;
                yTop  = yOffset + prcl->top;
                cx    = (prcl->right - prcl->left) * 3;
                cy    = prcl->bottom - prcl->top;

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xLeft, yTop));
                M64_OD(pjMmBase, SRC_Y_X, PACKXY_FAST(xLeft + dx, yTop + dy));
                M64_OD(pjMmBase, SRC_WIDTH1, cx);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

                if (--c == 0)
                    break;

                prcl++;
                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 4);
            }
        }
        else
        {
            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_YDir);

            while (TRUE)
            {
                xRight = (xOffset + prcl->right) * 3 - 1;
                yTop   = yOffset + prcl->top;
                cx     = (prcl->right - prcl->left) * 3;
                cy     = prcl->bottom - prcl->top;

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xRight, yTop));
                M64_OD(pjMmBase, SRC_Y_X, PACKXY_FAST(xRight + dx, yTop + dy));
                M64_OD(pjMmBase, SRC_WIDTH1, cx);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

                if (--c == 0)
                    break;

                prcl++;
                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);
            }

            // Since we don't use a default context, we must restore registers:

            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
        }
    }
    else
    {
        if (prclDst->left <= pptlSrc->x)
        {
            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir);

            while (TRUE)
            {
                xLeft   = (xOffset + prcl->left) * 3;
                yBottom = yOffset + prcl->bottom - 1;
                cx      = (prcl->right - prcl->left) * 3;
                cy      = prcl->bottom - prcl->top;

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xLeft, yBottom));
                M64_OD(pjMmBase, SRC_Y_X, PACKXY_FAST(xLeft + dx, yBottom + dy));
                M64_OD(pjMmBase, SRC_WIDTH1, cx);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

                if (--c == 0)
                    break;

                prcl++;
                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);
            }

            // Since we don't use a default context, we must restore registers:

            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
        }
        else
        {
            M64_OD(pjMmBase, DST_CNTL, 0);

            while (TRUE)
            {
                xRight  = (xOffset + prcl->right) * 3 - 1;
                yBottom = yOffset + prcl->bottom - 1;
                cx      = (prcl->right - prcl->left) * 3;
                cy      = prcl->bottom - prcl->top;

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xRight, yBottom));
                M64_OD(pjMmBase, SRC_Y_X, PACKXY_FAST(xRight + dx, yBottom + dy));
                M64_OD(pjMmBase, SRC_WIDTH1, cx);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

                if (--c == 0)
                    break;

                prcl++;
                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);
            }

            // Since we don't use a default context, we must restore registers:

            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
        }
    }
}

/******************************************************************************\
* Special versions to fix screen source FIFO bug in VT-A4 with 1 MB of SDRAM.
*
\******************************************************************************/

VOID vM64CopyBlt_VTA4(   // Type FNCOPY
PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
ULONG   rop4,       // rop4
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst)    // Original unclipped destination rectangle
{
    BOOL    reset_scissors = FALSE;
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    dx;
    LONG    dy;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    yBottom;
    LONG    cx;
    LONG    cy;
    LONG    remain = 32/ppdev->cjPelSize - 1;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 14);
    M64_OD(pjMmBase, CONTEXT_LOAD_CNTL, CONTEXT_LOAD_CmdLoad | ppdev->iDefContext );
    M64_OD(pjMmBase, SRC_OFF_PITCH, ppdev->ulScreenOffsetAndPitch);
    M64_OD(pjMmBase, DP_SRC,        DP_SRC_Blit << 8);
    M64_OD(pjMmBase, DP_MIX,        gaul64HwMixFromRop2[rop4 & 0xf]);
    M64_OD(pjMmBase, SRC_CNTL,      0);

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    // The accelerator may not be as fast at doing right-to-left copies, so
    // only do them when the rectangles truly overlap:

    if (!OVERLAP(prclDst, pptlSrc))
        goto Top_Down_Left_To_Right;

    if (prclDst->top <= pptlSrc->y)
    {
        if (prclDst->left <= pptlSrc->x)
        {
            LONG tmpLeft;

Top_Down_Left_To_Right:

            while (TRUE)
            {
                xLeft = xOffset + prcl->left;
                yTop  = yOffset + prcl->top;
                cx    = prcl->right - prcl->left;
                cy    = prcl->bottom - prcl->top;

                // 32-byte-align left:
                tmpLeft = xLeft + dx;
                if (tmpLeft & remain)
                {
                    M64_OD(pjMmBase, SC_LEFT, xLeft);
                    xLeft   -= (tmpLeft & remain);
                    cx      += (tmpLeft & remain);
                    tmpLeft &= ~remain;
                    reset_scissors = TRUE;
                }

                // 32-byte-align right:
                if (cx & remain)
                {
                    M64_OD(pjMmBase, SC_RIGHT, xLeft + cx - 1);
                    cx = (cx + remain)/(remain+1) * (remain+1);
                    reset_scissors = TRUE;
                }

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xLeft, yTop));
                M64_OD(pjMmBase, SRC_Y_X, PACKXY_FAST(tmpLeft, yTop + dy));
                M64_OD(pjMmBase, SRC_WIDTH1, cx);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

                if (reset_scissors)
                {
                    M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(0, M64_MAX_SCISSOR_R));
                    reset_scissors = FALSE;
                }

                if (--c == 0)
                    break;

                prcl++;
                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 7);
            }
        }
        else
        {
            LONG k, tmpRight;

            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_YDir);

            while (TRUE)
            {
                xRight = xOffset + prcl->right - 1;
                yTop   = yOffset + prcl->top;
                cx     = prcl->right - prcl->left;
                cy     = prcl->bottom - prcl->top;

                // 32-byte-align right:
                tmpRight = xRight + dx;
                if ((tmpRight+1) & remain)
                {
                    M64_OD(pjMmBase, SC_RIGHT, xRight);
                    k        = ((tmpRight+1) + remain)/(remain+1) * (remain+1) - 1;
                    xRight  += k - tmpRight;
                    cx      += k - tmpRight;
                    tmpRight = k;
                    reset_scissors = TRUE;
                }

                // 32-byte-align left:
                if (cx & remain)
                {
                    M64_OD(pjMmBase, SC_LEFT, xRight - cx + 1);
                    cx = (cx + remain)/(remain+1) * (remain+1);
                    reset_scissors = TRUE;
                }

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xRight, yTop));
                M64_OD(pjMmBase, SRC_Y_X, PACKXY_FAST(tmpRight, yTop + dy));
                M64_OD(pjMmBase, SRC_WIDTH1, cx);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

                if (reset_scissors)
                {
                    M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(0, M64_MAX_SCISSOR_R));
                    reset_scissors = FALSE;
                }

                if (--c == 0)
                    break;

                prcl++;
                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 8);
            }

            // Since we don't use a default context, we must restore registers:

            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
        }
    }
    else
    {
        if (prclDst->left <= pptlSrc->x)
        {
            LONG tmpLeft;

            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir);

            while (TRUE)
            {
                xLeft   = xOffset + prcl->left;
                yBottom = yOffset + prcl->bottom - 1;
                cx      = prcl->right - prcl->left;
                cy      = prcl->bottom - prcl->top;

                // 32-byte-align left:
                tmpLeft = xLeft + dx;
                if (tmpLeft & remain)
                {
                    M64_OD(pjMmBase, SC_LEFT, xLeft);
                    xLeft   -= (tmpLeft & remain);
                    cx      += (tmpLeft & remain);
                    tmpLeft &= ~remain;
                    reset_scissors = TRUE;
                }

                // 32-byte-align right:
                if (cx & remain)
                {
                    M64_OD(pjMmBase, SC_RIGHT, xLeft + cx - 1);
                    cx = (cx + remain)/(remain+1) * (remain+1);
                    reset_scissors = TRUE;
                }

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xLeft, yBottom));
                M64_OD(pjMmBase, SRC_Y_X, PACKXY_FAST(tmpLeft, yBottom + dy));
                M64_OD(pjMmBase, SRC_WIDTH1, cx);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

                if (reset_scissors)
                {
                    M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(0, M64_MAX_SCISSOR_R));
                    reset_scissors = FALSE;
                }

                if (--c == 0)
                    break;

                prcl++;
                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 8);
            }

            // Since we don't use a default context, we must restore registers:

            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
        }
        else
        {
            LONG k, tmpRight;

            M64_OD(pjMmBase, DST_CNTL, 0);

            while (TRUE)
            {
                xRight  = xOffset + prcl->right - 1;
                yBottom = yOffset + prcl->bottom - 1;
                cx      = prcl->right - prcl->left;
                cy      = prcl->bottom - prcl->top;

                // 32-byte-align right:
                tmpRight = xRight + dx;
                if ((tmpRight+1) & remain)
                {
                    M64_OD(pjMmBase, SC_RIGHT, xRight);
                    k        = ((tmpRight+1) + remain)/(remain+1) * (remain+1) - 1;
                    xRight  += k - tmpRight;
                    cx      += k - tmpRight;
                    tmpRight = k;
                    reset_scissors = TRUE;
                }

                // 32-byte-align left:
                if (cx & remain)
                {
                    M64_OD(pjMmBase, SC_LEFT, xRight - cx + 1);
                    cx = (cx + remain)/(remain+1) * (remain+1);
                    reset_scissors = TRUE;
                }

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xRight, yBottom));
                M64_OD(pjMmBase, SRC_Y_X, PACKXY_FAST(tmpRight, yBottom + dy));
                M64_OD(pjMmBase, SRC_WIDTH1, cx);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

                if (reset_scissors)
                {
                    M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(0, M64_MAX_SCISSOR_R));
                    reset_scissors = FALSE;
                }

                if (--c == 0)
                    break;

                prcl++;
                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 8);
            }

            // Since we don't use a default context, we must restore registers:

            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
        }
    }
}

VOID vM64CopyBlt24_VTA4( // Type FNCOPY
PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
ULONG   rop4,       // rop4
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst)    // Original unclipped destination rectangle
{
    BOOL    reset_scissors = FALSE;
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    dx;
    LONG    dy;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    yBottom;
    LONG    cx;
    LONG    cy;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 14);
    M64_OD(pjMmBase, CONTEXT_LOAD_CNTL, CONTEXT_LOAD_CmdLoad | ppdev->iDefContext );
    M64_OD(pjMmBase, SRC_OFF_PITCH, ppdev->ulScreenOffsetAndPitch);
    M64_OD(pjMmBase, DP_SRC,        DP_SRC_Blit << 8);
    M64_OD(pjMmBase, DP_MIX,        gaul64HwMixFromRop2[rop4 & 0xf]);
    M64_OD(pjMmBase, SRC_CNTL,      0);

    dx = (pptlSrc->x - prclDst->left) * 3;
    dy = pptlSrc->y - prclDst->top;

    // The accelerator may not be as fast at doing right-to-left copies, so
    // only do them when the rectangles truly overlap:

    if (!OVERLAP(prclDst, pptlSrc))
        goto Top_Down_Left_To_Right;

    if (prclDst->top <= pptlSrc->y)
    {
        if (prclDst->left <= pptlSrc->x)
        {
            LONG tmpLeft;

Top_Down_Left_To_Right:

            while (TRUE)
            {
                xLeft = (xOffset + prcl->left) * 3;
                yTop  = yOffset + prcl->top;
                cx    = (prcl->right - prcl->left) * 3;
                cy    = prcl->bottom - prcl->top;

                // 32-byte-align left:
                tmpLeft = xLeft + dx;
                if (tmpLeft & 31)
                {
                    M64_OD(pjMmBase, SC_LEFT, xLeft);
                    xLeft   -= (tmpLeft & 31);
                    cx      += (tmpLeft & 31);
                    tmpLeft &= ~31;
                    reset_scissors = TRUE;
                }

                // 32-byte-align right:
                if (cx & 31)
                {
                    M64_OD(pjMmBase, SC_RIGHT, xLeft + cx - 1);
                    cx = (cx + 31)/32 * 32;
                    reset_scissors = TRUE;
                }

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xLeft, yTop));
                M64_OD(pjMmBase, SRC_Y_X, PACKXY_FAST(tmpLeft, yTop + dy));
                M64_OD(pjMmBase, SRC_WIDTH1, cx);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

                if (reset_scissors)
                {
                    M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(0, M64_MAX_SCISSOR_R));
                    reset_scissors = FALSE;
                }

                if (--c == 0)
                    break;

                prcl++;
                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 7);
            }
        }
        else
        {
            LONG k, tmpRight;

            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_YDir);

            while (TRUE)
            {
                xRight = (xOffset + prcl->right) * 3 - 1;
                yTop   = yOffset + prcl->top;
                cx     = (prcl->right - prcl->left) * 3;
                cy     = prcl->bottom - prcl->top;

                // 32-byte-align right:
                tmpRight = xRight + dx;
                if ((tmpRight+1) & 31)
                {
                    M64_OD(pjMmBase, SC_RIGHT, xRight);
                    k        = ((tmpRight+1) + 31)/32 * 32 - 1;
                    xRight  += k - tmpRight;
                    cx      += k - tmpRight;
                    tmpRight = k;
                    reset_scissors = TRUE;
                }

                // 32-byte-align left:
                if (cx & 31)
                {
                    M64_OD(pjMmBase, SC_LEFT, xRight - cx + 1);
                    cx = (cx + 31)/32 * 32;
                    reset_scissors = TRUE;
                }

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xRight, yTop));
                M64_OD(pjMmBase, SRC_Y_X, PACKXY_FAST(tmpRight, yTop + dy));
                M64_OD(pjMmBase, SRC_WIDTH1, cx);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

                if (reset_scissors)
                {
                    M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(0, M64_MAX_SCISSOR_R));
                    reset_scissors = FALSE;
                }

                if (--c == 0)
                    break;

                prcl++;
                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 8);
            }

            // Since we don't use a default context, we must restore registers:

            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
        }
    }
    else
    {
        if (prclDst->left <= pptlSrc->x)
        {
            LONG tmpLeft;

            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir);

            while (TRUE)
            {
                xLeft   = (xOffset + prcl->left) * 3;
                yBottom = yOffset + prcl->bottom - 1;
                cx      = (prcl->right - prcl->left) * 3;
                cy      = prcl->bottom - prcl->top;

                // 32-byte-align left:
                tmpLeft = xLeft + dx;
                if (tmpLeft & 31)
                {
                    M64_OD(pjMmBase, SC_LEFT, xLeft);
                    xLeft   -= (tmpLeft & 31);
                    cx      += (tmpLeft & 31);
                    tmpLeft &= ~31;
                    reset_scissors = TRUE;
                }

                // 32-byte-align right:
                if (cx & 31)
                {
                    M64_OD(pjMmBase, SC_RIGHT, xLeft + cx - 1);
                    cx = (cx + 31)/32 * 32;
                    reset_scissors = TRUE;
                }

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xLeft, yBottom));
                M64_OD(pjMmBase, SRC_Y_X, PACKXY_FAST(tmpLeft, yBottom + dy));
                M64_OD(pjMmBase, SRC_WIDTH1, cx);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

                if (reset_scissors)
                {
                    M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(0, M64_MAX_SCISSOR_R));
                    reset_scissors = FALSE;
                }

                if (--c == 0)
                    break;

                prcl++;
                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 8);
            }

            // Since we don't use a default context, we must restore registers:

            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
        }
        else
        {
            LONG k, tmpRight;

            M64_OD(pjMmBase, DST_CNTL, 0);

            while (TRUE)
            {
                xRight  = (xOffset + prcl->right) * 3 - 1;
                yBottom = yOffset + prcl->bottom - 1;
                cx      = (prcl->right - prcl->left) * 3;
                cy      = prcl->bottom - prcl->top;

                // 32-byte-align right:
                tmpRight = xRight + dx;
                if ((tmpRight+1) & 31)
                {
                    M64_OD(pjMmBase, SC_RIGHT, xRight);
                    k        = ((tmpRight+1) + 31)/32 * 32 - 1;
                    xRight  += k - tmpRight;
                    cx      += k - tmpRight;
                    tmpRight = k;
                    reset_scissors = TRUE;
                }

                // 32-byte-align left:
                if (cx & 31)
                {
                    M64_OD(pjMmBase, SC_LEFT, xRight - cx + 1);
                    cx = (cx + 31)/32 * 32;
                    reset_scissors = TRUE;
                }

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xRight, yBottom));
                M64_OD(pjMmBase, SRC_Y_X, PACKXY_FAST(tmpRight, yBottom + dy));
                M64_OD(pjMmBase, SRC_WIDTH1, cx);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

                if (reset_scissors)
                {
                    M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(0, M64_MAX_SCISSOR_R));
                    reset_scissors = FALSE;
                }

                if (--c == 0)
                    break;

                prcl++;
                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 8);
            }

            // Since we don't use a default context, we must restore registers:

            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\bitblt.c ===
/******************************Module*Header*******************************\
* Module Name: bitblt.c
*
* Contains the high-level DrvBitBlt and DrvCopyBits functions.  The low-
* level stuff lives in the 'blt??.c' files.
*
* !!! Change note about 'iType'
*
* Note: Since we've implemented device-bitmaps, any surface that GDI passes
*       to us can have 3 values for its 'iType': STYPE_BITMAP, STYPE_DEVICE
*       or STYPE_DEVBITMAP.  We filter device-bitmaps that we've stored
*       as DIBs fairly high in the code, so after we adjust its 'pptlSrc',
*       we can treat STYPE_DEVBITMAP surfaces the same as STYPE_DEVICE
*       surfaces (e.g., a blt from an off-screen device bitmap to the screen
*       gets treated as a normal screen-to-screen blt).  So throughout
*       this code, we will compare a surface's 'iType' to STYPE_BITMAP:
*       if it's equal, we've got a true DIB, and if it's unequal, we have
*       a screen-to-screen operation.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#define gbdPunt FALSE        // global boolean define punt all BitBlt calls

/******************************Public*Table********************************\
* BYTE gajLeftMask[] and BYTE gajRightMask[]
*
* Edge tables for vXferScreenTo1bpp.
\**************************************************************************/

BYTE gajLeftMask[]  = { 0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01 };
BYTE gajRightMask[] = { 0xff, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe };

/******************************Public*Routine******************************\
* VOID vXferNativeSrccopy
*
* Does a SRCCOPY transfer of a bitmap to the screen using the frame
* buffer, because on the ATI it's faster than using the data transfer
* register.
*
\**************************************************************************/

VOID vXferNativeSrccopy(        // Type FNXFER
PDEV*       ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // List of destination rectangles, in relative
                                //   coordinates
ULONG       rop4,               // Not used
SURFOBJ*    psoSrc,             // Source surface
POINTL*     pptlSrc,            // Original unclipped source point
RECTL*      prclDst,            // Original unclipped destination rectangle
XLATEOBJ*   pxlo)               // Not used
{
    LONG    xOffset;
    LONG    yOffset;
    LONG    dx;
    LONG    dy;
    RECTL   rclDst;
    POINTL  ptlSrc;

    ASSERTDD((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL),
            "Can handle trivial xlate only");
    ASSERTDD(psoSrc->iBitmapFormat == ppdev->iBitmapFormat,
            "Source must be same colour depth as screen");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(rop4 == 0xcccc, "Must be a SRCCOPY rop");

    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    while (TRUE)
    {
        ptlSrc.x      = prcl->left   + dx;
        ptlSrc.y      = prcl->top    + dy;

        // 'pfnPutBits' takes only absolute coordinates, so add in the
        // off-screen bitmap offset here:

        rclDst.left   = prcl->left   + xOffset;
        rclDst.right  = prcl->right  + xOffset;
        rclDst.top    = prcl->top    + yOffset;
        rclDst.bottom = prcl->bottom + yOffset;

        ppdev->pfnPutBits(ppdev, psoSrc, &rclDst, &ptlSrc);

        if (--c == 0)
            return;

        prcl++;
    }
}

/******************************Public*Routine******************************\
* VOID vXferScreenTo1bpp
*
* Performs a SRCCOPY transfer from the screen (when it's 8bpp) to a 1bpp
* bitmap.
*
\**************************************************************************/

#if defined(_X86_)

VOID vXferScreenTo1bpp(         // Type FNXFER
PDEV*       ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // List of destination rectangles, in relative
                                //   coordinates
ULONG       ulHwMix,            // Not used
SURFOBJ*    psoDst,             // Destination surface
POINTL*     pptlSrc,            // Original unclipped source point
RECTL*      prclDst,            // Original unclipped destination rectangle
XLATEOBJ*   pxlo)               // Provides colour-compressions information
{
    LONG    cjPelSize;
    VOID*   pfnCompute;
    SURFOBJ soTmp;
    ULONG*  pulXlate;
    ULONG   ulForeColor;
    POINTL  ptlSrc;
    RECTL   rclTmp;
    BYTE*   pjDst;
    BYTE    jLeftMask;
    BYTE    jRightMask;
    BYTE    jNotLeftMask;
    BYTE    jNotRightMask;
    LONG    cjMiddle;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    LONG    cyTmpScans;
    LONG    cyThis;
    LONG    cyToGo;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(psoDst->iBitmapFormat == BMF_1BPP, "Only 1bpp destinations");
    ASSERTDD(TMP_BUFFER_SIZE >= (ppdev->cxMemory * ppdev->cjPelSize),
                "Temp buffer has to be larger than widest possible scan");

    // When the destination is a 1bpp bitmap, the foreground colour
    // maps to '1', and any other colour maps to '0'.

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // When the source is 8bpp or less, we find the forground colour
        // by searching the translate table for the only '1':

        pulXlate = pxlo->pulXlate;
        while (*pulXlate != 1)
            pulXlate++;

        ulForeColor = pulXlate - pxlo->pulXlate;
    }
    else
    {
        ASSERTDD((ppdev->iBitmapFormat == BMF_16BPP) ||
                 (ppdev->iBitmapFormat == BMF_32BPP),
                 "This routine only supports 8, 16 or 32bpp");

        // When the source has a depth greater than 8bpp, the foreground
        // colour will be the first entry in the translate table we get
        // from calling 'piVector':

        pulXlate = XLATEOBJ_piVector(pxlo);

        ulForeColor = 0;
        if (pulXlate != NULL)           // This check isn't really needed...
            ulForeColor = pulXlate[0];
    }

    // We use the temporary buffer to keep a copy of the source
    // rectangle:

    soTmp.pvScan0 = ppdev->pvTmpBuffer;

    do {
        // ptlSrc points to the upper-left corner of the screen rectangle
        // for the current batch:

        ptlSrc.x = prcl->left + (pptlSrc->x - prclDst->left);
        ptlSrc.y = prcl->top  + (pptlSrc->y - prclDst->top);

        // pfnGetBits takes absolute coordinates for the source point:

        ptlSrc.x += ppdev->xOffset;
        ptlSrc.y += ppdev->yOffset;

        pjDst = (BYTE*) psoDst->pvScan0 + (prcl->top * psoDst->lDelta)
                                        + (prcl->left >> 3);

        cjPelSize = ppdev->cjPelSize;

        soTmp.lDelta = (((prcl->right + 7L) & ~7L) - (prcl->left & ~7L))
                       * cjPelSize;

        // Our temporary buffer, into which we read a copy of the source,
        // may be smaller than the source rectangle.  In that case, we
        // process the source rectangle in batches.
        //
        // cyTmpScans is the number of scans we can do in each batch.
        // cyToGo is the total number of scans we have to do for this
        // rectangle.
        //
        // We take the buffer size less four so that the right edge case
        // can safely read one dword past the end:

        cyTmpScans = (TMP_BUFFER_SIZE - 4) / soTmp.lDelta;
        cyToGo     = prcl->bottom - prcl->top;

        ASSERTDD(cyTmpScans > 0, "Buffer too small for largest possible scan");

        // Initialize variables that don't change within the batch loop:

        rclTmp.top    = 0;
        rclTmp.left   = prcl->left & 7L;
        rclTmp.right  = (prcl->right - prcl->left) + rclTmp.left;

        // Note that we have to be careful with the right mask so that it
        // isn't zero.  A right mask of zero would mean that we'd always be
        // touching one byte past the end of the scan (even though we
        // wouldn't actually be modifying that byte), and we must never
        // access memory past the end of the bitmap (because we can access
        // violate if the bitmap end is exactly page-aligned).

        jLeftMask     = gajLeftMask[rclTmp.left & 7];
        jRightMask    = gajRightMask[rclTmp.right & 7];
        cjMiddle      = ((rclTmp.right - 1) >> 3) - (rclTmp.left >> 3) - 1;

        if (cjMiddle < 0)
        {
            // The blt starts and ends in the same byte:

            jLeftMask &= jRightMask;
            jRightMask = 0;
            cjMiddle   = 0;
        }

        jNotLeftMask  = ~jLeftMask;
        jNotRightMask = ~jRightMask;
        lDstDelta     = psoDst->lDelta - cjMiddle - 2;
                                // Delta from the end of the destination
                                //  to the start on the next scan, accounting
                                //  for 'left' and 'right' bytes

        lSrcDelta     = soTmp.lDelta - ((8 * (cjMiddle + 2)) * cjPelSize);
                                // Compute source delta for special cases
                                //  like when cjMiddle gets bumped up to '0',
                                //  and to correct aligned cases

        do {
            // This is the loop that breaks the source rectangle into
            // manageable batches.

            cyThis  = cyTmpScans;
            cyToGo -= cyThis;
            if (cyToGo < 0)
                cyThis += cyToGo;

            rclTmp.bottom = cyThis;

            ppdev->pfnGetBits(ppdev, &soTmp, &rclTmp, &ptlSrc);

            ptlSrc.y += cyThis;         // Get ready for next batch loop

            _asm {
                mov     eax,ulForeColor     ;eax = foreground colour
                                            ;ebx = temporary storage
                                            ;ecx = count of middle dst bytes
                                            ;dl  = destination byte accumulator
                                            ;dh  = temporary storage
                mov     esi,soTmp.pvScan0   ;esi = source pointer
                mov     edi,pjDst           ;edi = destination pointer

                ; Figure out the appropriate compute routine:

                mov     ebx,cjPelSize
                mov     pfnCompute,offset Compute_Destination_Byte_From_8bpp
                dec     ebx
                jz      short Do_Left_Byte
                mov     pfnCompute,offset Compute_Destination_Byte_From_16bpp
                dec     ebx
                jz      short Do_Left_Byte
                mov     pfnCompute,offset Compute_Destination_Byte_From_32bpp

            Do_Left_Byte:
                call    pfnCompute
                and     dl,jLeftMask
                mov     dh,jNotLeftMask
                and     dh,[edi]
                or      dh,dl
                mov     [edi],dh
                inc     edi
                mov     ecx,cjMiddle
                dec     ecx
                jl      short Do_Right_Byte

            Do_Middle_Bytes:
                call    pfnCompute
                mov     [edi],dl
                inc     edi
                dec     ecx
                jge     short Do_Middle_Bytes

            Do_Right_Byte:
                call    pfnCompute
                and     dl,jRightMask
                mov     dh,jNotRightMask
                and     dh,[edi]
                or      dh,dl
                mov     [edi],dh
                inc     edi

                add     edi,lDstDelta
                add     esi,lSrcDelta
                dec     cyThis
                jnz     short Do_Left_Byte

                mov     pjDst,edi               ;save for next batch

                jmp     All_Done

            Compute_Destination_Byte_From_8bpp:
                mov     bl,[esi]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 0

                mov     bl,[esi+1]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 1

                mov     bl,[esi+2]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 2

                mov     bl,[esi+3]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 3

                mov     bl,[esi+4]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 4

                mov     bl,[esi+5]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 5

                mov     bl,[esi+6]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 6

                mov     bl,[esi+7]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 7

                add     esi,8                   ;advance the source
                ret

            Compute_Destination_Byte_From_16bpp:
                mov     bx,[esi]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 0

                mov     bx,[esi+2]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 1

                mov     bx,[esi+4]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 2

                mov     bx,[esi+6]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 3

                mov     bx,[esi+8]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 4

                mov     bx,[esi+10]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 5

                mov     bx,[esi+12]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 6

                mov     bx,[esi+14]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 7

                add     esi,16                  ;advance the source
                ret

            Compute_Destination_Byte_From_32bpp:
                mov     ebx,[esi]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 0

                mov     ebx,[esi+4]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 1

                mov     ebx,[esi+8]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 2

                mov     ebx,[esi+12]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 3

                mov     ebx,[esi+16]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 4

                mov     ebx,[esi+20]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 5

                mov     ebx,[esi+24]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 6

                mov     ebx,[esi+28]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 7

                add     esi,32                  ;advance the source
                ret

            All_Done:
            }
        } while (cyToGo > 0);

        prcl++;
    } while (--c != 0);
}

#endif // i386

/******************************Public*Routine******************************\
* BOOL bPuntBlt
*
* Has GDI do any drawing operations that we don't specifically handle
* in the driver.
*
\**************************************************************************/

BOOL bPuntBlt(
SURFOBJ*    psoDst,
SURFOBJ*    psoSrc,
SURFOBJ*    psoMsk,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
ROP4        rop4)
{
    PDEV*    ppdev;

    if (psoDst->iType != STYPE_BITMAP)
        ppdev = (PDEV*) psoDst->dhpdev;
    else
        ppdev = (PDEV*) psoSrc->dhpdev;

    #if DBG
    {
        //////////////////////////////////////////////////////////////////////
        // Diagnostics
        //
        // Since calling the engine to do any drawing can be rather painful,
        // particularly when the source is an off-screen DFB (since GDI will
        // have to allocate a DIB and call us to make a temporary copy before
        // it can even start drawing), we'll try to avoid it as much as
        // possible.
        //
        // Here we simply spew out information describing the blt whenever
        // this routine gets called (checked builds only, of course):

        ULONG ulClip;
        PDEV* dbg_ppdev;

        if (psoDst->dhpdev != NULL)
            dbg_ppdev = (PDEV*) psoDst->dhpdev;
        else
            dbg_ppdev = (PDEV*) psoSrc->dhpdev;

        ulClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

        DISPDBG((15, ">> Punt << Dst format: %li Dst type: %li Clip: %li Rop: %lx",
            psoDst->iBitmapFormat, psoDst->iType, ulClip, rop4));

        if (psoSrc != NULL)
        {
            DISPDBG((15, "        << Src format: %li Src type: %li",
                psoSrc->iBitmapFormat, psoSrc->iType));

            if (psoSrc->iBitmapFormat == BMF_1BPP)
            {
                DISPDBG((15, "        << Foreground: %lx  Background: %lx",
                    pxlo->pulXlate[1], pxlo->pulXlate[0]));
            }
        }

        if ((pxlo != NULL) && !(pxlo->flXlate & XO_TRIVIAL) && (psoSrc != NULL))
        {
            if (((psoSrc->dhsurf == NULL) &&
                 (psoSrc->iBitmapFormat != dbg_ppdev->iBitmapFormat)) ||
                ((psoDst->dhsurf == NULL) &&
                 (psoDst->iBitmapFormat != dbg_ppdev->iBitmapFormat)))
            {
                // Don't bother printing the 'xlate' message when the source
                // is a different bitmap format from the destination -- in
                // those cases we know there always has to be a translate.
            }
            else
            {
                DISPDBG((15, "        << With xlate"));
            }
        }

        // If the rop4 requires a pattern, and it's a non-solid brush...

        if (((((rop4 >> 4) ^ (rop4)) & 0x0f0f) != 0) &&
            (pbo->iSolidColor == -1))
        {
            if (pbo->pvRbrush == NULL)
                DISPDBG((15, "        << With brush -- Not created"));
            else
                DISPDBG((15, "        << With brush -- Created Ok"));
        }
    }
    #endif

    if (DIRECT_ACCESS(ppdev))
    {
        //////////////////////////////////////////////////////////////////////
        // Banked Framebuffer bPuntBlt
        //
        // This section of code handles a PuntBlt when GDI can directly draw
        // on the framebuffer, but the drawing has to be done in banks:

        BANK     bnk;
        BOOL     b;
        HSURF    hsurfTmp;
        SURFOBJ* psoTmp;
        SIZEL    sizl;
        POINTL   ptlSrc;
        RECTL    rclTmp;
        RECTL    rclDst;

        // We copy the original destination rectangle, and use that in every
        // GDI call-back instead of the original because sometimes GDI is
        // sneaky and points 'prclDst' to '&pco->rclBounds'.  Because we
        // modify 'rclBounds', that would affect 'prclDst', which we don't
        // want to happen:

        rclDst = *prclDst;

        if ((psoSrc == NULL) || (psoSrc->iType == STYPE_BITMAP))
        {
            ASSERTDD(psoDst->iType != STYPE_BITMAP,
                     "Dest should be the screen when given a DIB source");

            // Do a memory-to-screen blt:

            vBankStart(ppdev, &rclDst, pco, &bnk);

            b = TRUE;
            do {
                b &= EngBitBlt(bnk.pso, psoSrc, psoMsk, bnk.pco, pxlo,
                               &rclDst, pptlSrc, pptlMsk, pbo, pptlBrush,
                               rop4);

            } while (bBankEnum(&bnk));
        }
        else
        {
            b = FALSE;  // Assume failure

            // The screen is the source (it may be the destination too...)

            ptlSrc.x = pptlSrc->x + ppdev->xOffset;
            ptlSrc.y = pptlSrc->y + ppdev->yOffset;

            if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
            {
                // We have to intersect the destination rectangle with
                // the clip bounds if there is one (consider the case
                // where the app asked to blt a really, really big
                // rectangle from the screen -- prclDst would be really,
                // really big but pco->rclBounds would be the actual
                // area of interest):

                rclDst.left   = max(rclDst.left,   pco->rclBounds.left);
                rclDst.top    = max(rclDst.top,    pco->rclBounds.top);
                rclDst.right  = min(rclDst.right,  pco->rclBounds.right);
                rclDst.bottom = min(rclDst.bottom, pco->rclBounds.bottom);

                // Correspondingly, we have to offset the source point:

                ptlSrc.x += (rclDst.left - prclDst->left);
                ptlSrc.y += (rclDst.top - prclDst->top);
            }

            // We're now either going to do a screen-to-screen or screen-to-DIB
            // blt.  In either case, we're going to create a temporary copy of
            // the source.  (Why do we do this when GDI could do it for us?
            // GDI would create a temporary copy of the DIB for every bank
            // call-back!)

            sizl.cx = rclDst.right  - rclDst.left;
            sizl.cy = rclDst.bottom - rclDst.top;

            // Don't forget to convert from relative to absolute coordinates
            // on the source!  (vBankStart takes care of that for the
            // destination.)

            rclTmp.right  = sizl.cx;
            rclTmp.bottom = sizl.cy;
            rclTmp.left   = 0;
            rclTmp.top    = 0;

            // GDI does guarantee us that the blt extents have already been
            // clipped to the surface boundaries (we don't have to worry
            // here about trying to read where there isn't video memory).
            // Let's just assert to make sure:

            ASSERTDD((ptlSrc.x >= 0) &&
                     (ptlSrc.y >= 0) &&
                     (ptlSrc.x + sizl.cx <= ppdev->cxMemory) &&
                     (ptlSrc.y + sizl.cy <= ppdev->cyMemory),
                     "Source rectangle out of bounds!");

            hsurfTmp = (HSURF) EngCreateBitmap(sizl,
                                               0,    // Let GDI choose ulWidth
                                               ppdev->iBitmapFormat,
                                               0,    // Don't need any options
                                               NULL);// Let GDI allocate

            if (hsurfTmp != 0)
            {
                psoTmp = EngLockSurface(hsurfTmp);

                if (psoTmp != NULL)
                {
                    ppdev->pfnGetBits(ppdev, psoTmp, &rclTmp, &ptlSrc);

                    if (psoDst->iType == STYPE_BITMAP)
                    {
                        // It was a Screen-to-DIB blt; now it's a DIB-to-DIB
                        // blt.  Note that the source point is (0, 0) in our
                        // temporary surface:

                        b = EngBitBlt(psoDst, psoTmp, psoMsk, pco, pxlo,
                                      &rclDst, (POINTL*) &rclTmp, pptlMsk,
                                      pbo, pptlBrush, rop4);
                    }
                    else
                    {
                        // It was a Screen-to-Screen blt; now it's a DIB-to-
                        // screen blt.  Note that the source point is (0, 0)
                        // in our temporary surface:

                        vBankStart(ppdev, &rclDst, pco, &bnk);

                        b = TRUE;
                        do {
                            b &= EngBitBlt(bnk.pso, psoTmp, psoMsk, bnk.pco,
                                           pxlo, &rclDst, (POINTL*) &rclTmp,
                                           pptlMsk, pbo, pptlBrush, rop4);

                        } while (bBankEnum(&bnk));
                    }

                    EngUnlockSurface(psoTmp);
                }

                EngDeleteSurface(hsurfTmp);
            }
        }

        return(b);
    }
    else
    {
        //////////////////////////////////////////////////////////////////////
        // Really Slow bPuntBlt
        //
        // Here we handle a PuntBlt when GDI can't draw directly on the
        // framebuffer (as on the Alpha, which can't do it because of its
        // 32 bit bus).  If you thought the banked version was slow, just
        // look at this one.  Guaranteed, there will be at least one bitmap
        // allocation and extra copy involved; there could be two if it's a
        // screen-to-screen operation.

        POINTL  ptlSrc;
        RECTL   rclDst;
        SIZEL   sizl;
        BOOL    bSrcIsScreen;
        HSURF   hsurfSrc;
        RECTL   rclTmp;
        BOOL    b;
        LONG    lDelta;
        BYTE*   pjBits;
        BYTE*   pjScan0;
        HSURF   hsurfDst;
        RECTL   rclScreen;

        b = FALSE;          // For error cases, assume we'll fail

        rclDst = *prclDst;
        if (pptlSrc != NULL)
            ptlSrc = *pptlSrc;

        if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
        {
            // We have to intersect the destination rectangle with
            // the clip bounds if there is one (consider the case
            // where the app asked to blt a really, really big
            // rectangle from the screen -- prclDst would be really,
            // really big but pco->rclBounds would be the actual
            // area of interest):

            rclDst.left   = max(rclDst.left,   pco->rclBounds.left);
            rclDst.top    = max(rclDst.top,    pco->rclBounds.top);
            rclDst.right  = min(rclDst.right,  pco->rclBounds.right);
            rclDst.bottom = min(rclDst.bottom, pco->rclBounds.bottom);

            ptlSrc.x += (rclDst.left - prclDst->left);
            ptlSrc.y += (rclDst.top  - prclDst->top);
        }

        sizl.cx = rclDst.right  - rclDst.left;
        sizl.cy = rclDst.bottom - rclDst.top;

        // We only need to make a copy from the screen if the source is
        // the screen, and the source is involved in the rop.  Note that
        // we have to check the rop before dereferencing 'psoSrc'
        // (because 'psoSrc' may be NULL if the source isn't involved):

        bSrcIsScreen = (((((rop4 >> 2) ^ (rop4)) & 0x3333) != 0) &&
                        (psoSrc->iType != STYPE_BITMAP));

        if (bSrcIsScreen)
        {
            // We need to create a copy of the source rectangle:

            hsurfSrc = (HSURF) EngCreateBitmap(sizl, 0, ppdev->iBitmapFormat,
                                               0, NULL);
            if (hsurfSrc == 0)
                goto Error_0;

            psoSrc = EngLockSurface(hsurfSrc);
            if (psoSrc == NULL)
                goto Error_1;

            rclTmp.left   = 0;
            rclTmp.top    = 0;
            rclTmp.right  = sizl.cx;
            rclTmp.bottom = sizl.cy;

            // pfnGetBits takes absolute coordinates for the source point:

            ptlSrc.x += ppdev->xOffset;
            ptlSrc.y += ppdev->yOffset;

            ppdev->pfnGetBits(ppdev, psoSrc, &rclTmp, &ptlSrc);

            // The source will now come from (0, 0) of our temporary source
            // surface:

            ptlSrc.x = 0;
            ptlSrc.y = 0;
        }

        if (psoDst->iType == STYPE_BITMAP)
        {
            b = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, &rclDst, &ptlSrc,
                          pptlMsk, pbo, pptlBrush, rop4);
        }
        else
        {
            // We need to create a temporary work buffer.  We have to do
            // some fudging with the offsets so that the upper-left corner
            // of the (relative coordinates) clip object bounds passed to
            // GDI will be transformed to the upper-left corner of our
            // temporary bitmap.

            // The alignment doesn't have to be as tight as this at 16bpp
            // and 32bpp, but it won't hurt:

            lDelta = (((rclDst.right + 3) & ~3L) - (rclDst.left & ~3L))
                   * ppdev->cjPelSize;

            // We're actually only allocating a bitmap that is 'sizl.cx' x
            // 'sizl.cy' in size:

            pjBits = AtiAllocMem(LMEM_FIXED, 0, lDelta * sizl.cy);
            if (pjBits == NULL)
                goto Error_2;

            // We now adjust the surface's 'pvScan0' so that when GDI thinks
            // it's writing to pixel (rclDst.top, rclDst.left), it will
            // actually be writing to the upper-left pixel of our temporary
            // bitmap:

            pjScan0 = pjBits - (rclDst.top * lDelta)
                             - ((rclDst.left & ~3L) * ppdev->cjPelSize);

            ASSERTDD((((ULONG_PTR) pjScan0) & 3) == 0,
                    "pvScan0 must be dword aligned!");

            // The checked build of GDI sometimes checks on blts that
            // prclDst->right <= pso->sizl.cx, so we lie to it about
            // the size of our bitmap:

            sizl.cx = rclDst.right;
            sizl.cy = rclDst.bottom;

            hsurfDst = (HSURF) EngCreateBitmap(
                        sizl,                   // Bitmap covers rectangle
                        lDelta,                 // Use this delta
                        ppdev->iBitmapFormat,   // Same colour depth
                        BMF_TOPDOWN,            // Must have a positive delta
                        pjScan0);               // Where (0, 0) would be

            if ((hsurfDst == 0) ||
                (!EngAssociateSurface(hsurfDst, ppdev->hdevEng, 0)))
                goto Error_3;

            psoDst = EngLockSurface(hsurfDst);
            if (psoDst == NULL)
                goto Error_4;

            // Make sure that the rectangle we Get/Put from/to the screen
            // is in absolute coordinates:

            rclScreen.left   = rclDst.left   + ppdev->xOffset;
            rclScreen.right  = rclDst.right  + ppdev->xOffset;
            rclScreen.top    = rclDst.top    + ppdev->yOffset;
            rclScreen.bottom = rclDst.bottom + ppdev->yOffset;

            // It would be nice to get a copy of the destination rectangle
            // only when the ROP involves the destination (or when the source
            // is an RLE), but we can't do that.  If the brush is truly NULL,
            // GDI will immediately return TRUE from EngBitBlt, without
            // modifying the temporary bitmap -- and we would proceed to
            // copy the uninitialized temporary bitmap back to the screen.

            ppdev->pfnGetBits(ppdev, psoDst, &rclDst, (POINTL*) &rclScreen);

            b = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, &rclDst, &ptlSrc,
                          pptlMsk, pbo, pptlBrush, rop4);

            ppdev->pfnPutBits(ppdev, psoDst, &rclScreen, (POINTL*) &rclDst);

            EngUnlockSurface(psoDst);

        Error_4:

            EngDeleteSurface(hsurfDst);

        Error_3:

            AtiFreeMem(pjBits);
        }

        Error_2:

        if (bSrcIsScreen)
        {
            EngUnlockSurface(psoSrc);

        Error_1:

            EngDeleteSurface(hsurfSrc);
        }

        Error_0:

        return(b);
    }
}

/******************************Public*Routine******************************\
* BOOL DrvBitBlt
*
* Implements the workhorse routine of a display driver.
*
\**************************************************************************/

BOOL DrvBitBlt(
SURFOBJ*    psoDst,
SURFOBJ*    psoSrc,
SURFOBJ*    psoMsk,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
ROP4        rop4)
{
    PDEV*           ppdev;
    DSURF*          pdsurfDst;
    DSURF*          pdsurfSrc;
    POINTL          ptlSrc;
    BYTE            jClip;
    OH*             poh;
    BOOL            bMore;
    CLIPENUM        ce;
    LONG            c;
    RECTL           rcl;
    BYTE            rop3;
    FNFILL*         pfnFill;
    RBRUSH_COLOR    rbc;        // Realized brush or solid colour
    FNXFER*         pfnXfer;
    ULONG           iSrcBitmapFormat;
    ULONG           iDir;
    BOOL            bRet;

    bRet = TRUE;                // Assume success

    pdsurfDst = (DSURF*) psoDst->dhsurf;    // May be NULL

    if ((psoSrc == NULL) && (gbdPunt == FALSE))
    {
        ///////////////////////////////////////////////////////////////////
        // Fills
        ///////////////////////////////////////////////////////////////////

        // Fills are this function's "raison d'etre", so we handle them
        // as quickly as possible:

        ASSERTDD(pdsurfDst != NULL,
                 "Expect only device destinations when no source");

        if (pdsurfDst->dt == DT_SCREEN)
        {
            ppdev = (PDEV*) psoDst->dhpdev;

            poh = pdsurfDst->poh;
            ppdev->xOffset = poh->x;
            ppdev->yOffset = poh->y;

            // Make sure it doesn't involve a mask (i.e., it's really a
            // Rop3):

            rop3 = (BYTE) rop4;

            if ((BYTE) (rop4 >> 8) == rop3)
            {
                // Since 'psoSrc' is NULL, the rop3 had better not indicate
                // that we need a source.

                ASSERTDD((((rop4 >> 2) ^ (rop4)) & 0x33) == 0,
                         "Need source but GDI gave us a NULL 'psoSrc'");

            Fill_It:

                pfnFill = ppdev->pfnFillSolid;   // Default to solid fill

                if ((((rop3 >> 4) ^ (rop3)) & 0xf) != 0)
                {
                    // The rop says that a pattern is truly required
                    // (blackness, for instance, doesn't need one):

                    rbc.iSolidColor = pbo->iSolidColor;
                    if (rbc.iSolidColor == -1)
                    {
                        // Try and realize the pattern brush; by doing
                        // this call-back, GDI will eventually call us
                        // again through DrvRealizeBrush:

                        rbc.prb = pbo->pvRbrush;
                        if (rbc.prb == NULL)
                        {
                            rbc.prb = BRUSHOBJ_pvGetRbrush(pbo);
                            if (rbc.prb == NULL)
                            {
                                // If we couldn't realize the brush, punt
                                // the call (it may have been a non 8x8
                                // brush or something, which we can't be
                                // bothered to handle, so let GDI do the
                                // drawing):

                                goto Punt_It;
                            }
                        }
                        pfnFill = rbc.prb->pfnFillPat;

                        if ((ppdev->FeatureFlags & EVN_SDRAM_1M) &&
                             (pfnFill == vM64FillPatColor || pfnFill == vM64FillPatColor24))
                        {
                            // The VTA4 can't handle color patterns correctly!!

                            goto Punt_It;
                        }
                    }
                }

                // Note that these 2 'if's are more efficient than
                // a switch statement:

                if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
                {
                    pfnFill(ppdev, 1, prclDst, rop4, rbc, pptlBrush);
                    goto All_Done;
                }
                else if (pco->iDComplexity == DC_RECT)
                {
                    if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                        pfnFill(ppdev, 1, &rcl, rop4, rbc, pptlBrush);
                    goto All_Done;
                }
                else
                {
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                    do {
                        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                        c = cIntersect(prclDst, ce.arcl, ce.c);

                        if (c != 0)
                            pfnFill(ppdev, c, ce.arcl, rop4, rbc, pptlBrush);

                    } while (bMore);
                    goto All_Done;
                }
            }
        }
    }

    jClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if ((psoSrc != NULL) && (psoSrc->dhsurf != NULL))
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        if (pdsurfSrc->dt == DT_DIB)
        {
            // Here we consider putting a DIB DFB back into off-screen
            // memory.  If there's a translate, it's probably not worth
            // moving since we won't be able to use the hardware to do
            // the blt (a similar argument could be made for weird rops
            // and stuff that we'll only end up having GDI simulate, but
            // those should happen infrequently enough that I don't care).

            if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
            {
                ppdev = (PDEV*) psoSrc->dhpdev;

                // See 'DrvCopyBits' for some more comments on how this
                // moving-it-back-into-off-screen-memory thing works:

                if (pdsurfSrc->iUniq == ppdev->iHeapUniq)
                {
                    if (--pdsurfSrc->cBlt == 0)
                    {
                        if (bMoveDibToOffscreenDfbIfRoom(ppdev, pdsurfSrc))
                            goto Continue_It;
                    }
                }
                else
                {
                    // Some space was freed up in off-screen memory,
                    // so reset the counter for this DFB:

                    pdsurfSrc->iUniq = ppdev->iHeapUniq;
                    pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
                }
            }

            psoSrc = pdsurfSrc->pso;

            // Handle the case where the source is a DIB DFB and the
            // destination is a regular bitmap:

            if (psoDst->dhsurf == NULL)
                goto EngBitBlt_It;

        }
    }

Continue_It:

    if (pdsurfDst != NULL)
    {
        if (pdsurfDst->dt == DT_DIB)
        {
            psoDst = pdsurfDst->pso;

            // If the destination is a DIB, we can only handle this
            // call if the source is not a DIB:

            if ((psoSrc == NULL) || (psoSrc->dhsurf == NULL))
                goto EngBitBlt_It;
        }
    }

    // At this point, we know that either the source or the destination is
    // not a DIB.  Check for a DFB to screen, DFB to DFB, or screen to DFB
    // case:

    if ((psoSrc != NULL) &&
        (psoDst->dhsurf != NULL) &&
        (psoSrc->dhsurf != NULL))
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        pdsurfDst = (DSURF*) psoDst->dhsurf;

        ASSERTDD(pdsurfSrc->dt == DT_SCREEN, "Expected screen source");
        ASSERTDD(pdsurfDst->dt == DT_SCREEN, "Expected screen destination");

        ptlSrc.x = pptlSrc->x - (pdsurfDst->poh->x - pdsurfSrc->poh->x);
        ptlSrc.y = pptlSrc->y - (pdsurfDst->poh->y - pdsurfSrc->poh->y);

        pptlSrc  = &ptlSrc;
    }

    if (psoDst->dhsurf != NULL)
    {
        pdsurfDst = (DSURF*) psoDst->dhsurf;
        ppdev     = (PDEV*)  psoDst->dhpdev;

        ppdev->xOffset = pdsurfDst->poh->x;
        ppdev->yOffset = pdsurfDst->poh->y;
    }
    else
    {
        DSURF * pTmpdsurfSrc = (DSURF*) psoSrc->dhsurf;
        ppdev     = (PDEV*)  psoSrc->dhpdev;

if (!pTmpdsurfSrc) {
    DISPDBG((0, "bad surf in psoSrc:%x, from %x\n", psoSrc, pdsurfSrc));
}

        ppdev->xOffset = pTmpdsurfSrc->poh->x;
        ppdev->yOffset = pTmpdsurfSrc->poh->y;
    }

    if (gbdPunt)
    {
        goto Punt_It;
    }

    if (((rop4 >> 8) & 0xff) == (rop4 & 0xff))
    {
        // Since we've already handled the cases where the ROP4 is really
        // a ROP3 and no source is required, we can assert...

        ASSERTDD((psoSrc != NULL) && (pptlSrc != NULL),
                 "Expected no-source case to already have been handled");

        ///////////////////////////////////////////////////////////////////
        // Bitmap transfers
        ///////////////////////////////////////////////////////////////////

        // Since the foreground and background ROPs are the same, we
        // don't have to worry about no stinking masks (it's a simple
        // Rop3).

        rop3 = (BYTE) rop4;     // Make it into a Rop3 (we keep the rop4
                                //  around in case we decide to punt)

        if (psoDst->dhsurf != NULL)
        {
            // The destination is the screen:

            if ((rop3 >> 4) == (rop3 & 0xf))
            {
                // The ROP3 doesn't require a pattern:

                if (psoSrc->dhsurf == NULL)
                {
                    //////////////////////////////////////////////////
                    // DIB-to-screen blt

                    iSrcBitmapFormat = psoSrc->iBitmapFormat;
                    if (iSrcBitmapFormat == BMF_1BPP)
                    {
                        //RKE: do this when we have time
                        if (ppdev->iBitmapFormat == BMF_24BPP)
                            goto Punt_It;

                        pfnXfer = ppdev->pfnXfer1bpp;
                        goto Xfer_It;
                    }
                    else if ((iSrcBitmapFormat == ppdev->iBitmapFormat) &&
                             ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
                    {
                        if ((rop3 & 0xf) != 0xc)
                        {
                            pfnXfer = ppdev->pfnXferNative;
                        }
                        else
                        {
                            // Plain SRCCOPY blts will be somewhat faster on
                            // the ATI if we go through the memory aperture:

                            pfnXfer = vXferNativeSrccopy;
                        }
                        goto Xfer_It;
                    }
                    else if (ppdev->iBitmapFormat != BMF_24BPP)
                    {
                        // I can't be bothered to write 4bpp or 8bpp
                        // expansion code when running at 24bpp:

                        if (iSrcBitmapFormat == BMF_4BPP)
                        {
                            pfnXfer = ppdev->pfnXfer4bpp;
                            goto Xfer_It;
                        }
                        else if (iSrcBitmapFormat == BMF_8BPP)
                        {
                            pfnXfer = ppdev->pfnXfer8bpp;
                            goto Xfer_It;
                        }
                    }
                }
                else // psoSrc->dhsurf != NULL
                {
                    if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
                    {
                        //////////////////////////////////////////////////
                        // Screen-to-screen blt with no translate

                        if (jClip == DC_TRIVIAL)
                        {
                            (ppdev->pfnCopyBlt)(ppdev, 1, prclDst, rop4,
                                                pptlSrc, prclDst);
                            goto All_Done;
                        }
                        else if (jClip == DC_RECT)
                        {
                            if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                            {
                                (ppdev->pfnCopyBlt)(ppdev, 1, &rcl, rop4,
                                                    pptlSrc, prclDst);
                            }
                            goto All_Done;
                        }
                        else
                        {
                            // Don't forget that we'll have to draw the
                            // rectangles in the correct direction:

                            if (pptlSrc->y >= prclDst->top)
                            {
                                if (pptlSrc->x >= prclDst->left)
                                    iDir = CD_RIGHTDOWN;
                                else
                                    iDir = CD_LEFTDOWN;
                            }
                            else
                            {
                                if (pptlSrc->x >= prclDst->left)
                                    iDir = CD_RIGHTUP;
                                else
                                    iDir = CD_LEFTUP;
                            }

                            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                               iDir, 0);

                            do {
                                bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                                      (ULONG*) &ce);

                                c = cIntersect(prclDst, ce.arcl, ce.c);

                                if (c != 0)
                                {
                                    (ppdev->pfnCopyBlt)(ppdev, c, ce.arcl,
                                            rop4, pptlSrc, prclDst);
                                }

                            } while (bMore);
                            goto All_Done;
                        }
                    }
                }
            }
        }
        else
        {
            #if defined(_X86_)
            {
                // We special case screen to monochrome blts because they
                // happen fairly often.  We only handle SRCCOPY rops and
                // monochrome destinations (to handle a true 1bpp DIB
                // destination, we would have to do near-colour searches
                // on every colour; as it is, the foreground colour gets
                // mapped to '1', and everything else gets mapped to '0'):

                if ((psoDst->iBitmapFormat == BMF_1BPP) &&
                    (rop3 == 0xcc) &&
                    (pxlo->flXlate & XO_TO_MONO) &&
                    (ppdev->iBitmapFormat != BMF_24BPP))
                {
                    pfnXfer = vXferScreenTo1bpp;
                    psoSrc  = psoDst;               // A misnomer, I admit
                    goto Xfer_It;
                }
            }
            #endif // i386
        }
    }

    else if ((psoMsk == NULL) && (rop4 == 0xaacc))
    {
        // The only time GDI will ask us to do a true rop4 using the brush
        // mask is when the brush is 1bpp, and the background rop is AA
        // (meaning it's a NOP):

        if (ppdev->flCaps & CAPS_MONOCHROME_PATTERNS)
        {
            // We only handle these if our ATI has hardware monochrome
            // pattern capabilities:

            rop3 = (BYTE) rop4;

            goto Fill_It;
        }
    }

    // Just fall through to Punt_It...

Punt_It:

    bRet = bPuntBlt(psoDst,
                    psoSrc,
                    psoMsk,
                    pco,
                    pxlo,
                    prclDst,
                    pptlSrc,
                    pptlMsk,
                    pbo,
                    pptlBrush,
                    rop4);
    goto All_Done;

//////////////////////////////////////////////////////////////////////
// Common bitmap transfer

Xfer_It:
    if (jClip == DC_TRIVIAL)
    {
        pfnXfer(ppdev, 1, prclDst, rop4, psoSrc, pptlSrc, prclDst, pxlo);
        goto All_Done;
    }
    else if (jClip == DC_RECT)
    {
        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
            pfnXfer(ppdev, 1, &rcl, rop4, psoSrc, pptlSrc, prclDst, pxlo);
        goto All_Done;
    }
    else
    {
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                           CD_ANY, 0);

        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                  (ULONG*) &ce);

            c = cIntersect(prclDst, ce.arcl, ce.c);

            if (c != 0)
            {
                pfnXfer(ppdev, c, ce.arcl, rop4, psoSrc,
                        pptlSrc, prclDst, pxlo);
            }

        } while (bMore);
        goto All_Done;
    }

////////////////////////////////////////////////////////////////////////
// Common DIB blt

EngBitBlt_It:

    // Our driver doesn't handle any blt's between two DIBs.  Normally
    // a driver doesn't have to worry about this, but we do because
    // we have DFBs that may get moved from off-screen memory to a DIB,
    // where we have GDI do all the drawing.  GDI does DIB drawing at
    // a reasonable speed (unless one of the surfaces is a device-
    // managed surface...)
    //
    // If either the source or destination surface in an EngBitBlt
    // call-back is a device-managed surface (meaning it's not a DIB
    // that GDI can draw with), GDI will automatically allocate memory
    // and call the driver's DrvCopyBits routine to create a DIB copy
    // that it can use.  So this means that this could handle all 'punts',
    // and we could conceivably get rid of bPuntBlt.  But this would have
    // a bad performance impact because of the extra memory allocations
    // and bitmap copies -- you really don't want to do this unless you
    // have to (or your surface was created such that GDI can draw
    // directly onto it) -- I've been burned by this because it's not
    // obvious that the performance impact is so bad.
    //
    // That being said, we only call EngBitBlt when all the surfaces
    // are DIBs:

    bRet = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst,
                     pptlSrc, pptlMsk, pbo, pptlBrush, rop4);

All_Done:
    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL DrvCopyBits
*
* Do fast bitmap copies.
*
* Note that GDI will (usually) automatically adjust the blt extents to
* adjust for any rectangular clipping, so we'll rarely see DC_RECT
* clipping in this routine (and as such, we don't bother special casing
* it).
*
* I'm not sure if the performance benefit from this routine is actually
* worth the increase in code size, since SRCCOPY BitBlts are hardly the
* most common drawing operation we'll get.  But what the heck.
*
* On the ATI it's faster to do straight SRCCOPY bitblt's through the
* memory aperture than to use the data transfer register; as such, this
* routine is the logical place to put this special case.
*
\**************************************************************************/

BOOL DrvCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    return(DrvBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst, pptlSrc, NULL,
                     NULL, NULL, 0xcccc));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\brush.c ===
/******************************Module*Header*******************************\
* Module Name: Brush.c
*
* Handles all brush/pattern initialization and realization.
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vRealizeDitherPattern
*
* Generates an 8x8 dither pattern, in our internal realization format, for
* the colour ulRGBToDither.  Note that the high byte of ulRGBToDither does
* not need to be set to zero, because vComputeSubspaces ignores it.
\**************************************************************************/

VOID vRealizeDitherPattern(
PDEV*       ppdev,
RBRUSH*     prb,
ULONG       ulRGBToDither)
{
    ULONG           ulNumVertices;
    VERTEX_DATA     vVertexData[4];
    VERTEX_DATA*    pvVertexData;
    LONG            i;

    // Calculate what colour subspaces are involved in the dither:

    pvVertexData = vComputeSubspaces(ulRGBToDither, vVertexData);

    // Now that we have found the bounding vertices and the number of
    // pixels to dither for each vertex, we can create the dither pattern

    ulNumVertices = (ULONG)(pvVertexData - vVertexData);
                      // # of vertices with more than zero pixels in the dither

    // Do the actual dithering:

    vDitherColor(&prb->aulPattern[0], vVertexData, pvVertexData, ulNumVertices);

    // Initialize the fields we need:

    prb->fl         = 0;
    prb->pfnFillPat = ppdev->pfnFillPatColor;

    for (i = 0; i < MAX_BOARDS; i++)
    {
        prb->apbe[i] = NULL;
    }
}

/******************************Public*Routine******************************\
* BOOL DrvRealizeBrush
*
* This function allows us to convert GDI brushes into an internal form
* we can use.  It may be called directly by GDI at SelectObject time, or
* it may be called by GDI as a result of us calling BRUSHOBJ_pvGetRbrush
* to create a realized brush in a function like DrvBitBlt.
*
* Note that we have no way of determining what the current Rop or brush
* alignment are at this point.
*
\**************************************************************************/

BOOL DrvRealizeBrush(
BRUSHOBJ*   pbo,
SURFOBJ*    psoDst,
SURFOBJ*    psoPattern,
SURFOBJ*    psoMask,
XLATEOBJ*   pxlo,
ULONG       iHatch)
{
    PDEV*       ppdev;
    ULONG       iPatternFormat;
    BYTE*       pjSrc;
    BYTE*       pjDst;
    LONG        lSrcDelta;
    LONG        cj;
    LONG        i;
    LONG        j;
    RBRUSH*     prb;
    ULONG*      pulXlate;
    SURFOBJ*    psoPunt;
    RECTL       rclDst;
    BOOL        b;

    ppdev = (PDEV*) psoDst->dhpdev;

    // We have a fast path for dithers when we set GCAPS_DITHERONREALIZE:

    if (iHatch & RB_DITHERCOLOR)
    {
        // Implementing DITHERONREALIZE increased our score on a certain
        // unmentionable benchmark by 0.4 million 'megapixels'.  Too bad
        // this didn't work in the first version of NT.

        prb = BRUSHOBJ_pvAllocRbrush(pbo,
              sizeof(RBRUSH) + (TOTAL_BRUSH_SIZE * ppdev->cjPelSize));
        if (prb == NULL)
            goto ReturnFalse;

        vRealizeDitherPattern(ppdev, prb, iHatch);
        goto ReturnTrue;
    }

    // We only accelerate 8x8 patterns.  Since Win3.1 and Chicago don't
    // support patterns of any other size, it's a safe bet that 99.9%
    // of the patterns we'll ever get will be 8x8:

    if ((psoPattern->sizlBitmap.cx != 8) ||
        (psoPattern->sizlBitmap.cy != 8))
        goto ReturnFalse;

    if (!(ppdev->flCaps & CAPS_COLOR_PATTERNS))
    {
        // If for whatever reason we can't support colour patterns in
        // this mode, the only alternative left is to support
        // monochrome patterns:

        if (!(ppdev->flCaps & CAPS_MONOCHROME_PATTERNS) ||
             (psoPattern->iBitmapFormat != BMF_1BPP))
            goto ReturnFalse;
    }

    iPatternFormat = psoPattern->iBitmapFormat;

    prb = BRUSHOBJ_pvAllocRbrush(pbo,
          sizeof(RBRUSH) + (TOTAL_BRUSH_SIZE * ppdev->cjPelSize));
    if (prb == NULL)
        goto ReturnFalse;

    // Initialize the fields we need:

    prb->fl         = 0;
    prb->pfnFillPat = ppdev->pfnFillPatColor;

    for (i = 0; i < MAX_BOARDS; i++)
    {
        prb->apbe[i] = NULL;
    }

    lSrcDelta = psoPattern->lDelta;
    pjSrc     = (BYTE*) psoPattern->pvScan0;
    pjDst     = (BYTE*) &prb->aulPattern[0];

    if ((ppdev->iBitmapFormat == iPatternFormat) &&
        ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
    {
        DISPDBG((1, "Realizing un-translated brush"));

        // The pattern is the same colour depth as the screen, and
        // there's no translation to be done:

        cj = (8 * ppdev->cjPelSize);   // Every pattern is 8 pels wide

        for (i = 8; i != 0; i--)
        {
            RtlCopyMemory(pjDst, pjSrc, cj);

            pjSrc += lSrcDelta;
            pjDst += cj;
        }
    }
    else if ((iPatternFormat == BMF_1BPP) &&
             (ppdev->flCaps & CAPS_MONOCHROME_PATTERNS))
    {
        DISPDBG((1, "Realizing 1bpp brush"));

        for (i = 8; i != 0; i--)
        {
            *pjDst = *pjSrc;
            pjDst++;
            pjSrc += lSrcDelta;
        }

        pulXlate         = pxlo->pulXlate;
        prb->fl         |= RBRUSH_2COLOR;
        prb->ulForeColor = pulXlate[1];
        prb->ulBackColor = pulXlate[0];
        prb->ptlBrush.x  = 0;
        prb->ptlBrush.y  = 0;
        prb->pfnFillPat  = ppdev->pfnFillPatMonochrome;
    }
    else if ((iPatternFormat == BMF_4BPP) && (ppdev->iBitmapFormat == BMF_8BPP))
    {
        DISPDBG((1, "Realizing 4bpp brush"));

        // The screen is 8bpp and the pattern is 4bpp:

        ASSERTDD((ppdev->iBitmapFormat == BMF_8BPP) &&
                 (iPatternFormat == BMF_4BPP),
                 "Messed up brush logic");

        pulXlate = pxlo->pulXlate;

        for (i = 8; i != 0; i--)
        {
            // Inner loop is repeated only 4 times because each loop
            // handles 2 pixels:

            for (j = 4; j != 0; j--)
            {
                *pjDst++ = (BYTE) pulXlate[*pjSrc >> 4];
                *pjDst++ = (BYTE) pulXlate[*pjSrc & 15];
                pjSrc++;
            }

            pjSrc += lSrcDelta - 4;
        }
    }
    else
    {
        // We've got a brush whose format we haven't special cased.  No
        // problem, we can have GDI convert it to our device's format.
        // We simply use a temporary surface object that was created with
        // the same format as the display, and point it to our brush
        // realization:

        DISPDBG((5, "Realizing funky brush"));

        psoPunt          = ppdev->psoBank;
        psoPunt->pvScan0 = pjDst;
        psoPunt->lDelta  = 8 * ppdev->cjPelSize;

        rclDst.left      = 0;
        rclDst.top       = 0;
        rclDst.right     = 8;
        rclDst.bottom    = 8;

        b = EngCopyBits(psoPunt, psoPattern, NULL, pxlo,
                        &rclDst, (POINTL*) &rclDst);

        if (!b)
        {
            goto ReturnFalse;
        }
    }

ReturnTrue:

    return(TRUE);

ReturnFalse:

    if (psoPattern != NULL)
    {
        DISPDBG((1, "Failed realization -- Type: %li Format: %li cx: %li cy: %li",
                    psoPattern->iType, psoPattern->iBitmapFormat,
                    psoPattern->sizlBitmap.cx, psoPattern->sizlBitmap.cy));
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bEnableBrushCache
*
* Allocates off-screen memory for storing the brush cache.
\**************************************************************************/

BOOL bEnableBrushCache(
PDEV*   ppdev)
{
    OH*         poh;
    BRUSHENTRY* pbe;
    LONG        i;
    LONG        x;
    LONG        y;
    ULONG       ulOffset;

    if ((ppdev->iMachType == MACH_MM_32) || (ppdev->iMachType == MACH_IO_32))
    {
        if (ppdev->iBitmapFormat == BMF_8BPP)
        {
            // All Mach8 and Mach32 cards can handle colour patterns in
            // the hardware when running at 8bpp:

            ppdev->flCaps |= CAPS_COLOR_PATTERNS;
        }

        if ((ppdev->iAsic == ASIC_68800_6) || (ppdev->iAsic == ASIC_68800AX))
        {
            // Some Mach32 ASICs can handle 8x8 monochrome patterns directly
            // in the hardware:

            ppdev->flCaps |= CAPS_MONOCHROME_PATTERNS;
        }
    }
    else
    {
        ASSERTDD(ppdev->iMachType == MACH_MM_64, "Weird other case?");

        // All Mach64's can handle 8x8 monochrome patterns directly:

        ppdev->flCaps |= CAPS_MONOCHROME_PATTERNS;

        // Allocate some off-screen memory for a brush cache:

        if (ppdev->cxMemory >= TOTAL_BRUSH_SIZE * TOTAL_BRUSH_COUNT)
        {
            poh = pohAllocate(ppdev, NULL, ppdev->cxMemory, 1,
                              FLOH_MAKE_PERMANENT);
            if (poh != NULL)
            {
                ppdev->flCaps |= CAPS_COLOR_PATTERNS;

                pbe = &ppdev->abe[0];   // Points to where we'll put the first
                                        //   brush cache entry
                x = poh->x;
                y = poh->y;

                for (i = TOTAL_BRUSH_COUNT; i != 0; i--)
                {
                    // If we hadn't allocated 'ppdev' so that it was zero
                    // initialized, we would have to initialize pbe->prbVerify
                    // too...

                    pbe->x = x;
                    pbe->y = y;

                    // !!! Test at 24bpp on banked Mach64!

                    ulOffset = ((y * ppdev->lDelta) + (x * ppdev->cjPelSize)
                                + ppdev->ulTearOffset) >> 3;

                    // The pitch of the brush is 8 pixels, and must be scaled
                    // up by 8:

                    if (ppdev->iBitmapFormat != BMF_24BPP)
                        pbe->ulOffsetPitch = PACKPAIR(ulOffset, 8 * 8);
                    else
                        pbe->ulOffsetPitch = PACKPAIR(ulOffset, 3 * 8 * 8);     // 24bpp is actually 8bpp internally

                    x += TOTAL_BRUSH_SIZE;
                    pbe++;
                }
            }
        }
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableBrushCache
*
* Cleans up anything done in bEnableBrushCache.
\**************************************************************************/

VOID vDisableBrushCache(PDEV* ppdev)
{
    // We ain't gotta do nothin'
}

/******************************Public*Routine******************************\
* VOID vAssertModeBrushCache
*
* Resets the brush cache when we exit out of full-screen.
\**************************************************************************/

VOID vAssertModeBrushCache(
PDEV*   ppdev,
BOOL    bEnable)
{
    BRUSHENTRY* pbe;
    LONG        i;

    if (bEnable)
    {
        // Invalidate the brush cache:

        pbe = &ppdev->abe[0];

        for (i = TOTAL_BRUSH_COUNT; i != 0; i--)
        {
            pbe->prbVerify = NULL;
            pbe++;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\blti32.c ===
/******************************Module*Header*******************************\
* Module Name: blti32.c
*
* Contains the low-level I/O blt functions for the Mach32.
*
* Hopefully, if you're basing your display driver on this code, to
* support all of DrvBitBlt and DrvCopyBits, you'll only have to implement
* the following routines.  You shouldn't have to modify much in
* 'bitblt.c'.  I've tried to make these routines as few, modular, simple,
* and efficient as I could, while still accelerating as many calls as
* possible that would be cost-effective in terms of performance wins
* versus size and effort.
*
* Note: In the following, 'relative' coordinates refers to coordinates
*       that haven't yet had the offscreen bitmap (DFB) offset applied.
*       'Absolute' coordinates have had the offset applied.  For example,
*       we may be told to blt to (1, 1) of the bitmap, but the bitmap may
*       be sitting in offscreen memory starting at coordinate (0, 768) --
*       (1, 1) would be the 'relative' start coordinate, and (1, 769)
*       would be the 'absolute' start coordinate'.
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vI32FillSolid
*
* Fills a list of rectangles with a solid colour.
*
\**************************************************************************/

VOID vI32FillSolid(             // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // Drawing colour is rbc.iSolidColor
POINTL*         pptlBrush)      // Not used
{
    BYTE*   pjIoBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    x;

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    pjIoBase = ppdev->pjIoBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 8);

    I32_OW(pjIoBase, FRGD_COLOR, rbc.iSolidColor);
    I32_OW(pjIoBase, ALU_FG_FN,  gaul32HwMixFromRop2[(rop4 >> 2) & 0xf]);
    I32_OW(pjIoBase, DP_CONFIG,  FG_COLOR_SRC_FG | WRITE | DRAW);

    while (TRUE)
    {
        x = xOffset + prcl->left;
        I32_OW(pjIoBase, CUR_X,        x);
        I32_OW(pjIoBase, DEST_X_START, x);
        I32_OW(pjIoBase, DEST_X_END,   xOffset + prcl->right);
        I32_OW(pjIoBase, CUR_Y,        yOffset + prcl->top);

        vI32QuietDown(ppdev, pjIoBase);

        I32_OW(pjIoBase, DEST_Y_END,   yOffset + prcl->bottom);

        if (--c == 0)
            return;

        prcl++;
        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 5);
    }
}

/******************************Public*Routine******************************\
* VOID vI32FillPatMonochrome
*
* This routine uses the pattern hardware to draw a monochrome patterned
* list of rectangles.
*
* See Blt_DS_P8x8_ENG_IO_66_D0 and Blt_DS_P8x8_ENG_IO_66_D1.
*
\**************************************************************************/

VOID vI32FillPatMonochrome(     // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BYTE*   pjIoBase;
    LONG    xOffset;
    LONG    yOffset;
    ULONG   ulHwForeMix;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    xPattern;
    LONG    yPattern;
    LONG    xOld;
    LONG    yOld;
    LONG    iLeftShift;
    LONG    iRightShift;
    LONG    i;
    BYTE    j;
    LONG    xLeft;
    ULONG   aulTmp[2];
    WORD*   pwPattern;

    ASSERTDD(ppdev->iAsic == ASIC_68800_6 || ppdev->iAsic == ASIC_68800AX,
             "Wrong ASIC type for monochrome 8x8 patterns");

    pjIoBase = ppdev->pjIoBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    xPattern = (pptlBrush->x + xOffset) & 7;
    yPattern = (pptlBrush->y + yOffset) & 7;

    // If the alignment isn't correct, we'll have to change it:

    if ((xPattern != rbc.prb->ptlBrush.x) || (yPattern != rbc.prb->ptlBrush.y))
    {
        // Remember that we've changed the alignment on our cached brush:

        xOld = rbc.prb->ptlBrush.x;
        yOld = rbc.prb->ptlBrush.y;

        rbc.prb->ptlBrush.x = xPattern;
        rbc.prb->ptlBrush.y = yPattern;

        // Now do the alignment:

        yPattern    = (yOld - yPattern);
        iRightShift = (xPattern - xOld) & 7;
        iLeftShift  = 8 - iRightShift;

        pjSrc = (BYTE*) &rbc.prb->aulPattern[0];
        pjDst = (BYTE*) &aulTmp[0];

        for (i = 0; i < 8; i++)
        {
            j = *(pjSrc + (yPattern++ & 7));
            *pjDst++ = (j << iLeftShift) | (j >> iRightShift);
        }

        rbc.prb->aulPattern[0] = aulTmp[0];
        rbc.prb->aulPattern[1] = aulTmp[1];
    }

    ulHwForeMix = gaul32HwMixFromRop2[(rop4 >> 2) & 0xf];

    I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 16);
    I32_OW(pjIoBase, DP_CONFIG,   FG_COLOR_SRC_FG | EXT_MONO_SRC_PATT | DRAW |
                                  WRITE);
    I32_OW(pjIoBase, ALU_FG_FN,   ulHwForeMix);
    I32_OW(pjIoBase, ALU_BG_FN,   ((rop4 & 0xff00) == 0xaa00) ? LEAVE_ALONE
                                                              : ulHwForeMix);

    I32_OW(pjIoBase, FRGD_COLOR,      rbc.prb->ulForeColor);
    I32_OW(pjIoBase, BKGD_COLOR,      rbc.prb->ulBackColor);
    I32_OW(pjIoBase, PATT_LENGTH,     128);
    I32_OW(pjIoBase, PATT_DATA_INDEX, 16);

    pwPattern = (WORD*) &rbc.prb->aulPattern[0];
    I32_OW(pjIoBase, PATT_DATA, *(pwPattern));
    I32_OW(pjIoBase, PATT_DATA, *(pwPattern + 1));
    I32_OW(pjIoBase, PATT_DATA, *(pwPattern + 2));
    I32_OW(pjIoBase, PATT_DATA, *(pwPattern + 3));

    while(TRUE)
    {
        xLeft = xOffset + prcl->left;
        I32_OW(pjIoBase, CUR_X,        xLeft);
        I32_OW(pjIoBase, DEST_X_START, xLeft);
        I32_OW(pjIoBase, DEST_X_END,   xOffset + prcl->right);
        I32_OW(pjIoBase, CUR_Y,        yOffset + prcl->top);
        I32_OW(pjIoBase, DEST_Y_END,   yOffset + prcl->bottom);

        if (--c == 0)
            break;

        prcl++;
        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 5);
    }
}

/******************************Public*Routine******************************\
* VOID vI32FillPatColor
*
* This routine uses the pattern hardware to draw a colour patterned list of
* rectangles.
*
* See Blt_DS_PCOL_ENG_IO_F0_D0 and Blt_DS_PCOL_ENG_IO_F0_D1.
*
\**************************************************************************/

VOID vI32FillPatColor(          // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BYTE*   pjIoBase;
    LONG    xOffset;
    LONG    yOffset;
    ULONG   ulHwMix;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    cy;
    LONG    cyVenetian;
    LONG    cyRoll;
    WORD*   pwPattern;
    LONG    xPattern;
    LONG    yPattern;

    ASSERTDD(ppdev->iBitmapFormat == BMF_8BPP,
             "Colour patterns work only at 8bpp");

    pjIoBase = ppdev->pjIoBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    ulHwMix = gaul32HwMixFromRop2[(rop4 >> 2) & 0xf];

    I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 9);
    I32_OW(pjIoBase, ALU_FG_FN,    ulHwMix);
    I32_OW(pjIoBase, SRC_Y_DIR,    1);
    I32_OW(pjIoBase, PATT_LENGTH,  7);          // 8 pixel wide pattern

    while (TRUE)
    {
        xLeft  = xOffset + prcl->left;
        xRight = xOffset + prcl->right;
        yTop   = yOffset + prcl->top;
        cy     = prcl->bottom - prcl->top;

        xPattern = (xLeft - pptlBrush->x - xOffset) & 7;
        yPattern = (yTop  - pptlBrush->y - yOffset) & 7;

        if (ulHwMix == OVERPAINT)
        {
            cyVenetian = min(cy, 8);
            cyRoll     = cy - cyVenetian;
        }
        else
        {
            cyVenetian = cy;
            cyRoll     = 0;
        }

        I32_OW(pjIoBase, DP_CONFIG,    FG_COLOR_SRC_PATT | DATA_WIDTH | DRAW | WRITE);
        I32_OW(pjIoBase, PATT_INDEX,   xPattern);
        I32_OW(pjIoBase, DEST_X_START, xLeft);
        I32_OW(pjIoBase, CUR_X,        xLeft);
        I32_OW(pjIoBase, DEST_X_END,   xRight);
        I32_OW(pjIoBase, CUR_Y,        yTop);

        do {
            // Each scan of the pattern is eight bytes:

            pwPattern = (WORD*) ((BYTE*) &rbc.prb->aulPattern[0]
                      + (yPattern << 3));
            yPattern  = (yPattern + 1) & 7;

            I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 6);
            I32_OW(pjIoBase, PATT_DATA_INDEX, 0);   // Reset index for download
            I32_OW(pjIoBase, PATT_DATA,  *(pwPattern));
            I32_OW(pjIoBase, PATT_DATA,  *(pwPattern + 1));
            I32_OW(pjIoBase, PATT_DATA,  *(pwPattern + 2));
            I32_OW(pjIoBase, PATT_DATA,  *(pwPattern + 3));
            yTop++;

            vI32QuietDown(ppdev, pjIoBase);

            I32_OW(pjIoBase, DEST_Y_END, yTop);

        } while (--cyVenetian != 0);

        if (cyRoll != 0)
        {
            // When the ROP is PATCOPY, we can take advantage of the fact
            // that we've just laid down an entire row of the pattern, and
            // can do a 'rolling' screen-to-screen blt to draw the rest:

            I32_CHECK_FIFO_SPACE(ppdev, pjIoBase,    7);
            I32_OW(pjIoBase, DP_CONFIG,       FG_COLOR_SRC_BLIT | DATA_WIDTH |
                                              DRAW | WRITE);
            I32_OW(pjIoBase, M32_SRC_X,       xLeft);
            I32_OW(pjIoBase, M32_SRC_X_START, xLeft);
            I32_OW(pjIoBase, M32_SRC_X_END,   xRight);
            I32_OW(pjIoBase, M32_SRC_Y,       yTop - 8);
            I32_OW(pjIoBase, CUR_Y,           yTop);

            vI32QuietDown(ppdev, pjIoBase);

            I32_OW(pjIoBase, DEST_Y_END,      yTop + cyRoll);
        }

        if (--c == 0)
            break;

        prcl++;
        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 6);
    }
}

/******************************Public*Routine******************************\
* VOID vI32Xfer1bpp
*
* This routine colour expands a monochrome bitmap, possibly with different
* Rop2's for the foreground and background.  It will be called in the
* following cases:
*
* 1) To colour-expand the monochrome text buffer for the vFastText routine.
* 2) To blt a 1bpp source with a simple Rop2 between the source and
*    destination.
* 3) To blt a true Rop3 when the source is a 1bpp bitmap that expands to
*    white and black, and the pattern is a solid colour.
* 4) To handle a true Rop4 that works out to be Rop2's between the pattern
*    and destination.
*
* Needless to say, making this routine fast can leverage a lot of
* performance.
*
\**************************************************************************/

VOID vI32Xfer1bpp(      // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ROP4        rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    BYTE*   pjIoBase;
    LONG    xOffset;
    LONG    yOffset;
    ULONG*  pulXlate;
    ULONG   ulHwForeMix;
    LONG    dx;
    LONG    dy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    cy;
    LONG    cx;
    LONG    xBias;
    LONG    culScan;
    LONG    lSrcSkip;
    ULONG*  pulSrc;
    LONG    i;
    ULONG   ulFifo;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    pjIoBase = ppdev->pjIoBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;
    ulFifo   = 0;

    ulHwForeMix = gaul32HwMixFromRop2[rop4 & 0xf];
    pulXlate    = pxlo->pulXlate;
    I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 12);
    I32_OW(pjIoBase, DP_CONFIG, (WORD)(FG_COLOR_SRC_FG | BG_COLOR_SRC_BG | BIT16 |
                            EXT_MONO_SRC_HOST | DRAW | WRITE | LSB_FIRST) );
    I32_OW(pjIoBase, ALU_FG_FN, (WORD) ulHwForeMix );
    I32_OW(pjIoBase, ALU_BG_FN, (WORD) ulHwForeMix );
    I32_OW(pjIoBase, BKGD_COLOR, (WORD) pulXlate[0]);
    I32_OW(pjIoBase, FRGD_COLOR, (WORD) pulXlate[1]);

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;


    while (TRUE)
    {
        xLeft  = prcl->left;
        xRight = prcl->right;

        // The Mach32 'bit packs' monochrome transfers, but GDI gives
        // us monochrome bitmaps whose scans are always dword aligned.
        // Consequently, we use the Mach32's clip registers to make
        // our transfers a multiple of 32 to match the dword alignment:

        I32_OW(pjIoBase, EXT_SCISSOR_L, (SHORT) (xLeft + xOffset) );
        I32_OW(pjIoBase, EXT_SCISSOR_R, (SHORT) (xRight + xOffset - 1) );

        yTop = prcl->top;
        cy   = prcl->bottom - yTop;

        xBias  = (xLeft + dx) & 31;             // Floor
        xLeft -= xBias;
        cx     = (xRight - xLeft + 31) & ~31;   // Ceiling

        I32_OW(pjIoBase, CUR_X,        (WORD) xLeft + xOffset );
        I32_OW(pjIoBase, DEST_X_START, (WORD) xLeft + xOffset );
        I32_OW(pjIoBase, DEST_X_END,   (WORD) (xLeft + xOffset + cx)  );
        I32_OW(pjIoBase, CUR_Y,        (WORD) yTop  + yOffset  );

        I32_OW(pjIoBase, DEST_Y_END, (WORD) (yTop + yOffset + cy) );

        pulSrc   = (ULONG*) (pjSrcScan0 + (yTop + dy) * lSrcDelta
                                        + ((xLeft + dx) >> 3));
        culScan  = cx >> 5;
        lSrcSkip = lSrcDelta - (culScan << 2);

        ASSERTDD(((ULONG_PTR)pulSrc & 3) == 0,"Source should be dword aligned");

        do {
            i = culScan;
            do {
                I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 2);
                I32_OW(pjIoBase, PIX_TRANS, *((USHORT*) pulSrc) );
                I32_OW(pjIoBase, PIX_TRANS, *((USHORT*) pulSrc + 1) );
                pulSrc++;

            } while (--i != 0);

            pulSrc = (ULONG*) ((BYTE*) pulSrc + lSrcSkip);

        } while (--cy != 0);

        if (--c == 0)
            break;

        prcl++;
        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 7);
    }

    // Don't forget to reset the clip register:

    I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 2);
    I32_OW(pjIoBase, EXT_SCISSOR_L, (SHORT) 0 );
    I32_OW(pjIoBase, EXT_SCISSOR_R, (SHORT) M32_MAX_SCISSOR );
}

/******************************Public*Routine******************************\
* VOID vI32XferNative
*
* Transfers a bitmap that is the same colour depth as the display to
* the screen via the data transfer register, with no translation.
*
\**************************************************************************/

VOID vI32XferNative(    // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ULONG       rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Not used
{
    BYTE*   pjIoBase;
    LONG    xOffset;
    LONG    yOffset;
    ULONG   ulHwForeMix;
    LONG    dx;
    LONG    dy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    cy;
    LONG    cx;
    LONG    xBias;
    ULONG*  pulSrc;
    ULONG   culScan;
    LONG    lSrcSkip;
    LONG    i;
    ULONG   ulFifo;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    pjIoBase = ppdev->pjIoBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;
    ulFifo   = 0;

    ulHwForeMix = gaul32HwMixFromRop2[rop4 & 0xf];
    I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 10);
    I32_OW(pjIoBase, DP_CONFIG, (WORD)(FG_COLOR_SRC_HOST | BIT16 |
                            DRAW | WRITE | LSB_FIRST) );
    I32_OW(pjIoBase, ALU_FG_FN, (WORD) ulHwForeMix );
    I32_OW(pjIoBase, ALU_BG_FN, (WORD) ulHwForeMix );

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;


    while (TRUE)
    {
        xLeft  = prcl->left;
        xRight = prcl->right;

        I32_OW(pjIoBase, EXT_SCISSOR_L, (SHORT) (xLeft + xOffset) );
        I32_OW(pjIoBase, EXT_SCISSOR_R, (SHORT) (xRight + xOffset - 1) );

        yTop = prcl->top;
        cy   = prcl->bottom - yTop;

        // We compute 'xBias' in order to dword-align the source pointer.
        // This way, we don't have to do unaligned reads of the source,
        // and we're guaranteed not to read even a byte past the end of
        // the bitmap.
        //
        // Note that this bias works at 24bpp, too:

        xBias  = (xLeft + dx) & 3;              // Floor
        xLeft -= xBias;
        cx     = (xRight - xLeft + 3) & ~3;     // Ceiling

        I32_OW(pjIoBase, CUR_X,        (WORD) xLeft + xOffset );
        I32_OW(pjIoBase, DEST_X_START, (WORD) xLeft + xOffset );
        I32_OW(pjIoBase, DEST_X_END,   (WORD) (xLeft + xOffset + cx)  );
        I32_OW(pjIoBase, CUR_Y,        (WORD) yTop  + yOffset  );

        I32_OW(pjIoBase, DEST_Y_END, (WORD) (yTop + yOffset + cy) );

        pulSrc   = (ULONG*) (pjSrcScan0 + (yTop + dy) * lSrcDelta
                                        + ((xLeft + dx) * ppdev->cjPelSize));
        culScan  = (cx * ppdev->cjPelSize) >> 2;
        lSrcSkip = lSrcDelta - (culScan << 2);

        ASSERTDD(((ULONG_PTR)pulSrc & 3) == 0, "Source should be dword aligned");

        if (cy && culScan)
            {
            do {
                i = culScan;
                do {
                    I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 2);
                    I32_OW(pjIoBase, PIX_TRANS, *((USHORT*) pulSrc) );
                    I32_OW(pjIoBase, PIX_TRANS, *((USHORT*) pulSrc + 1) );
                    pulSrc++;

                } while (--i != 0);

                pulSrc = (ULONG*) ((BYTE*) pulSrc + lSrcSkip);

            } while (--cy != 0);
        }
        if (--c == 0)
            break;

        prcl++;
        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 7);
    }

    // Don't forget to reset the clip register:

    I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 2);
    I32_OW(pjIoBase, EXT_SCISSOR_L, (SHORT) 0 );
    I32_OW(pjIoBase, EXT_SCISSOR_R, (SHORT) M32_MAX_SCISSOR );
}

/******************************Public*Routine******************************\
* VOID vI32Xfer4bpp
*
* Does a 4bpp transfer from a bitmap to the screen.
*
* The reason we implement this is that a lot of resources are kept as 4bpp,
* and used to initialize DFBs, some of which we of course keep off-screen.
*
\**************************************************************************/

VOID vI32Xfer4bpp(      // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ULONG       rop4,       // Rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    BYTE*   pjIoBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    cjPelSize;
    ULONG   ulHwForeMix;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    xBias;
    LONG    dx;
    LONG    dy;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjSrc;
    BYTE    jSrc;
    ULONG*  pulXlate;
    LONG    i;
    USHORT  uw;
    LONG    cjSrc;
    LONG    lSrcSkip;
    ULONG   ulFifo;

    ASSERTDD(psoSrc->iBitmapFormat == BMF_4BPP, "Source must be 4bpp");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(ppdev->iBitmapFormat != BMF_24BPP, "Can't handle 24bpp");

    pjIoBase  = ppdev->pjIoBase;
    xOffset   = ppdev->xOffset;
    yOffset   = ppdev->yOffset;
    cjPelSize = ppdev->cjPelSize;
    pulXlate  = pxlo->pulXlate;
    ulFifo    = 0;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    ulHwForeMix = gaul32HwMixFromRop2[rop4 & 0xf];
    I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 10);
    I32_OW(pjIoBase, DP_CONFIG, (WORD)(FG_COLOR_SRC_HOST | BIT16 |
                            DRAW | WRITE | LSB_FIRST) );
    I32_OW(pjIoBase, ALU_FG_FN, (WORD) ulHwForeMix );
    I32_OW(pjIoBase, ALU_BG_FN, (WORD) ulHwForeMix );


    while(TRUE)
    {
        xLeft  = prcl->left;
        xRight = prcl->right;

        I32_OW(pjIoBase, EXT_SCISSOR_L, (SHORT) (xLeft + xOffset) );
        I32_OW(pjIoBase, EXT_SCISSOR_R, (SHORT) (xRight + xOffset - 1) );

        yTop = prcl->top;
        cy   = prcl->bottom - yTop;

        // We compute 'xBias' in order to dword-align the source pointer.
        // This way, we don't have to do unaligned reads of the source,
        // and we're guaranteed not to read even a byte past the end of
        // the bitmap.
        //
        // Note that this bias works at 24bpp, too:

        xBias  = (xLeft + dx) & 3;              // Floor
        xLeft -= xBias;
        cx     = (xRight - xLeft + 3) & ~3;     // Ceiling

        I32_OW(pjIoBase, CUR_X,        (WORD) xLeft + xOffset );
        I32_OW(pjIoBase, DEST_X_START, (WORD) xLeft + xOffset );
        I32_OW(pjIoBase, DEST_X_END,   (WORD) (xLeft + xOffset + cx)  );
        I32_OW(pjIoBase, CUR_Y,        (WORD) yTop  + yOffset  );

        I32_OW(pjIoBase, DEST_Y_END, (WORD) (yTop + yOffset + cy) );

        pjSrc    = pjSrcScan0 + (yTop + dy) * lSrcDelta
                              + ((xLeft + dx) >> 1);
        cjSrc    = cx >> 1;         // Number of source bytes touched
        lSrcSkip = lSrcDelta - cjSrc;

        if (cjPelSize == 1)
        {
            // This part handles 8bpp output:

            do {
                i = cjSrc;
                do {
                    jSrc = *pjSrc++;
                    uw   = (USHORT) (pulXlate[jSrc >> 4]);
                    uw  |= (USHORT) (pulXlate[jSrc & 0xf] << 8);
                    I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 1);
                    I32_OW(pjIoBase, PIX_TRANS, uw );
                } while (--i != 0);

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }
        else if (cjPelSize == 2)
        {
            // This part handles 16bpp output:

            do {
                i = cjSrc;
                do {
                    I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 2);
                    jSrc = *pjSrc++;
                    uw   = (USHORT) (pulXlate[jSrc >> 4]);
                    I32_OW(pjIoBase, PIX_TRANS, uw );
                    uw   = (USHORT) (pulXlate[jSrc & 0xf]);
                    I32_OW(pjIoBase, PIX_TRANS, uw );
                } while (--i != 0);

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }

        if (--c == 0)
            break;

        prcl++;
        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 7);
    }

    // Don't forget to reset the clip register:

    I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 2);
    I32_OW(pjIoBase, EXT_SCISSOR_L, (SHORT) 0 );
    I32_OW(pjIoBase, EXT_SCISSOR_R, (SHORT) M32_MAX_SCISSOR );
}

/******************************Public*Routine******************************\
* VOID vI32Xfer8bpp
*
* Does a 8bpp transfer from a bitmap to the screen.
*
* The reason we implement this is that a lot of resources are kept as 8bpp,
* and used to initialize DFBs, some of which we of course keep off-screen.
*
\**************************************************************************/

VOID vI32Xfer8bpp(         // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ULONG       rop4,       // Rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    BYTE*   pjIoBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    cjPelSize;
    ULONG   ulHwForeMix;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    xBias;
    LONG    dx;
    LONG    dy;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjSrc;
    ULONG*  pulXlate;
    LONG    i;
    USHORT  uw;
    LONG    cwSrc;
    LONG    cxRem;
    LONG    lSrcSkip;
    ULONG   ulFifo;

    ASSERTDD(psoSrc->iBitmapFormat == BMF_8BPP, "Source must be 8bpp");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(ppdev->iBitmapFormat != BMF_24BPP, "Can't handle 24bpp");

    pjIoBase  = ppdev->pjIoBase;
    xOffset   = ppdev->xOffset;
    yOffset   = ppdev->yOffset;
    cjPelSize = ppdev->cjPelSize;
    pulXlate  = pxlo->pulXlate;
    ulFifo    = 0;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    ulHwForeMix = gaul32HwMixFromRop2[rop4 & 0xf];
    I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 10);
    I32_OW(pjIoBase, DP_CONFIG, (WORD)(FG_COLOR_SRC_HOST | BIT16 |
                            DRAW | WRITE | LSB_FIRST) );
    I32_OW(pjIoBase, ALU_FG_FN, (WORD) ulHwForeMix );
    I32_OW(pjIoBase, ALU_BG_FN, (WORD) ulHwForeMix );


    while(TRUE)
    {
        xLeft  = prcl->left;
        xRight = prcl->right;

        I32_OW(pjIoBase, EXT_SCISSOR_L, (SHORT) (xLeft + xOffset) );
        I32_OW(pjIoBase, EXT_SCISSOR_R, (SHORT) (xRight + xOffset - 1) );

        yTop = prcl->top;
        cy   = prcl->bottom - yTop;

        // We compute 'xBias' in order to dword-align the source pointer.
        // This way, we don't have to do unaligned reads of the source,
        // and we're guaranteed not to read even a byte past the end of
        // the bitmap.
        //
        // Note that this bias works at 24bpp, too:

        xBias  = (xLeft + dx) & 3;              // Floor
        xLeft -= xBias;
        cx     = (xRight - xLeft + 3) & ~3;     // Ceiling

        I32_OW(pjIoBase, CUR_X,        (WORD) xLeft + xOffset );
        I32_OW(pjIoBase, DEST_X_START, (WORD) xLeft + xOffset );
        I32_OW(pjIoBase, DEST_X_END,   (WORD) (xLeft + xOffset + cx)  );
        I32_OW(pjIoBase, CUR_Y,        (WORD) yTop  + yOffset  );

        I32_OW(pjIoBase, DEST_Y_END, (WORD) (yTop + yOffset + cy) );

        pjSrc    = pjSrcScan0 + (yTop + dy) * lSrcDelta
                              + (xLeft + dx);
        lSrcSkip = lSrcDelta - cx;

        if (cjPelSize == 1)
        {
            // This part handles 8bpp output:

            cwSrc = (cx >> 1);
            cxRem = (cx & 1);

            do {
                for (i = cwSrc; i != 0; i--)
                {
                    uw  = (USHORT) (pulXlate[*pjSrc++]);
                    uw |= (USHORT) (pulXlate[*pjSrc++] << 8);
                    I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 1);
                    I32_OW(pjIoBase, PIX_TRANS, uw );
                }

                if (cxRem > 0)
                {
                    uw  = (USHORT) (pulXlate[*pjSrc++]);
                    I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 1);
                    I32_OW(pjIoBase, PIX_TRANS, uw );
                }

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }
        else if (cjPelSize == 2)
        {
            // This part handles 16bpp output:

            do {
                for (i = cx; i != 0; i--)
                {
                    uw  = (USHORT) (pulXlate[*pjSrc++]);
                    I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 1);
                    I32_OW(pjIoBase, PIX_TRANS, uw );
                }

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }

        if (--c == 0)
            break;

        prcl++;
        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 7);
    }

    // Don't forget to reset the clip register:

    I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 2);
    I32_OW(pjIoBase, EXT_SCISSOR_L, (SHORT) 0 );
    I32_OW(pjIoBase, EXT_SCISSOR_R, (SHORT) M32_MAX_SCISSOR );
}

/******************************Public*Routine******************************\
* VOID vI32CopyBlt
*
* Does a screen-to-screen blt of a list of rectangles.
*
\**************************************************************************/

VOID vI32CopyBlt(   // Type FNCOPY
PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
ULONG   rop4,       // rop4
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst)    // Original unclipped destination rectangle
{
    BYTE*   pjIoBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    dx;
    LONG    dy;
    LONG    xLeft;
    LONG    yTop;
    LONG    cx;
    LONG    cy;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    pjIoBase = ppdev->pjIoBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 12);

    I32_OW(pjIoBase, DP_CONFIG, FG_COLOR_SRC_BLIT | DRAW | WRITE);
    I32_OW(pjIoBase, ALU_FG_FN, gaul32HwMixFromRop2[rop4 & 0xf]);

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    // The accelerator may not be as fast at doing right-to-left copies, so
    // only do them when the rectangles truly overlap:

    if (!OVERLAP(prclDst, pptlSrc))
    {
        I32_OW(pjIoBase, SRC_Y_DIR, 1);
        goto Top_Down_Left_To_Right;
    }

    I32_OW(pjIoBase, SRC_Y_DIR, (prclDst->top <= pptlSrc->y));

    if (prclDst->top <= pptlSrc->y)
    {
        if (prclDst->left <= pptlSrc->x)
        {

Top_Down_Left_To_Right:

            while (TRUE)
            {
                xLeft = xOffset + prcl->left + dx;  // Destination coordinates
                yTop  = yOffset + prcl->top  + dy;
                cx    = prcl->right - prcl->left;
                cy    = prcl->bottom - prcl->top;

                I32_OW(pjIoBase, M32_SRC_X,        xLeft);
                I32_OW(pjIoBase, M32_SRC_X_START,  xLeft);
                I32_OW(pjIoBase, M32_SRC_X_END,    xLeft + cx);
                I32_OW(pjIoBase, M32_SRC_Y,        yTop);

                xLeft -= dx;                        // Source coordinates
                yTop  -= dy;

                I32_OW(pjIoBase, CUR_X,            xLeft);
                I32_OW(pjIoBase, DEST_X_START,     xLeft);
                I32_OW(pjIoBase, DEST_X_END,       xLeft + cx);
                I32_OW(pjIoBase, CUR_Y,            yTop);

                vI32QuietDown(ppdev, pjIoBase);

                I32_OW(pjIoBase, DEST_Y_END,       yTop + cy);

                if (--c == 0)
                    break;

                prcl++;
                I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 9);
            }
        }
        else
        {
            while (TRUE)
            {
                xLeft = xOffset + prcl->left + dx;  // Destination coordinates
                yTop  = yOffset + prcl->top  + dy;
                cx    = prcl->right - prcl->left;
                cy    = prcl->bottom - prcl->top;

                I32_OW(pjIoBase, M32_SRC_X,        xLeft + cx);
                I32_OW(pjIoBase, M32_SRC_X_START,  xLeft + cx);
                I32_OW(pjIoBase, M32_SRC_X_END,    xLeft);
                I32_OW(pjIoBase, M32_SRC_Y,        yTop);

                xLeft -= dx;                        // Source coordinates
                yTop  -= dy;

                I32_OW(pjIoBase, CUR_X,            xLeft + cx);
                I32_OW(pjIoBase, DEST_X_START,     xLeft + cx);
                I32_OW(pjIoBase, DEST_X_END,       xLeft);
                I32_OW(pjIoBase, CUR_Y,            yTop);

                vI32QuietDown(ppdev, pjIoBase);

                I32_OW(pjIoBase, DEST_Y_END,       yTop + cy);

                if (--c == 0)
                    break;

                prcl++;
                I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 9);
            }
        }
    }
    else
    {
        if (prclDst->left <= pptlSrc->x)
        {
            while (TRUE)
            {
                xLeft = xOffset + prcl->left + dx;  // Destination coordinates
                yTop  = yOffset + prcl->top  + dy - 1;
                cx    = prcl->right - prcl->left;
                cy    = prcl->bottom - prcl->top;

                I32_OW(pjIoBase, M32_SRC_X,        xLeft);
                I32_OW(pjIoBase, M32_SRC_X_START,  xLeft);
                I32_OW(pjIoBase, M32_SRC_X_END,    xLeft + cx);
                I32_OW(pjIoBase, M32_SRC_Y,        yTop + cy);

                xLeft -= dx;                        // Source coordinates
                yTop  -= dy;

                I32_OW(pjIoBase, CUR_X,            xLeft);
                I32_OW(pjIoBase, DEST_X_START,     xLeft);
                I32_OW(pjIoBase, DEST_X_END,       xLeft + cx);
                I32_OW(pjIoBase, CUR_Y,            yTop + cy);

                vI32QuietDown(ppdev, pjIoBase);

                I32_OW(pjIoBase, DEST_Y_END,       yTop);

                if (--c == 0)
                    break;

                prcl++;
                I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 9);
            }
        }
        else
        {
            while (TRUE)
            {
                xLeft = xOffset + prcl->left + dx;  // Destination coordinates
                yTop  = yOffset + prcl->top  + dy - 1;
                cx    = prcl->right - prcl->left;
                cy    = prcl->bottom - prcl->top;

                I32_OW(pjIoBase, M32_SRC_X,        xLeft + cx);
                I32_OW(pjIoBase, M32_SRC_X_START,  xLeft + cx);
                I32_OW(pjIoBase, M32_SRC_X_END,    xLeft);
                I32_OW(pjIoBase, M32_SRC_Y,        yTop + cy);

                xLeft -= dx;                        // Source coordinates
                yTop  -= dy;

                I32_OW(pjIoBase, CUR_X,            xLeft + cx);
                I32_OW(pjIoBase, DEST_X_START,     xLeft + cx);
                I32_OW(pjIoBase, DEST_X_END,       xLeft);
                I32_OW(pjIoBase, CUR_Y,            yTop + cy);

                vI32QuietDown(ppdev, pjIoBase);

                I32_OW(pjIoBase, DEST_Y_END,       yTop);

                if (--c == 0)
                    break;

                prcl++;
                I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 9);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\color.c ===
/******************************Module*Header*******************************\
* Module Name: color.c
*
* This algorithm for color dithering is patent pending and its use is
* restricted to Microsoft products and drivers for Microsoft products.
* Use in non-Microsoft products or in drivers for non-Microsoft products
* is prohibited without the expressed written consent of Microsoft Corp.
*
* The patent application is the primary reference for the operation of the
* color dithering code.
*
* Note that in the comments and variable names, "vertex" means "vertex of
* either the inner (half intensity) or outer (full intensity) color cube."
* Vertices map to colors 0-7 and 9-15 of the Windows standard (required)
* 16-color palette, where vertices 0-7 are the vertices of the inner color
* cube, and 0 plus 9-15 are the vertices of the full color cube. Vertex 8 is
* 75% gray; this could be used in the dither, but that would break apps that
* depend on the exact Windows 3.1 dithering. This code is Window 3.1
* compatible.
*
* Note that as a result of the compatibility requirement, the dither
* produced by this algorithm is the exact same dither as that produced
* by the default Windows 3.1 16 color and 256 color VGA drivers.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
    PALETTEENTRY pal;
    ULONG ul;
} PAL_ULONG;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7,
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
    0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDword[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0xF8F8F8F8,
    0x07070707,
    0xF9F9F9F9,
    0xFAFAFAFA,
    0xFBFBFBFB,
    0xFCFCFCFC,
    0xFDFDFDFD,
    0xFEFEFEFE,
    0xFFFFFFFF
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity.
ULONG aulDitherOrder[] = {
  0, 36,  4, 32, 18, 54, 22, 50,
  2, 38,  6, 34, 16, 52, 20, 48,
  9, 45, 13, 41, 27, 63, 31, 59,
 11, 47, 15, 43, 25, 61, 29, 57,
  1, 37,  5, 33, 19, 55, 23, 51,
  3, 39,  7, 35, 17, 53, 21, 49,
  8, 44, 12, 40, 26, 62, 30, 58,
 10, 46, 14, 42, 24, 60, 28, 56,
};

// Array to convert to 256 color from 16 color. Maps from index that represents
// a 16-color vertex (color) to value that specifies the color index in the
// 256-color palette.
BYTE ajConvert[] =
{
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    248,
    7,
    249,
    250,
    251,
    252,
    253,
    254,
    255
};

/******************************Public*Routine******************************\
* vComputeSubspaces
*
* Calculates the subspace data associated with rgb, stores the data at
* pvVertexData, in the form of an array of VERTEX_DATA structures,
* suitable for vDitherColor. Returns a pointer to the byte after the
* last VERTEX_DATA structure.
*
* Ignores the high byte of rgb.
*
\**************************************************************************/

VERTEX_DATA* vComputeSubspaces(
ULONG           rgb,
VERTEX_DATA*    pvVertexData)
{
    ULONG   ulRedTemp, ulGreenTemp, ulBlueTemp, ulSymmetry;
    ULONG   ulRed, ulGre, ulBlu, ulTemp;
    ULONG   ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;

    // Split the color into red, green, and blue components
    ulRedTemp   = ((PAL_ULONG *)&rgb)->pal.peRed;
    ulGreenTemp   = ((PAL_ULONG *)&rgb)->pal.peGreen;
    ulBlueTemp   = ((PAL_ULONG *)&rgb)->pal.peBlue;

    // Sort the RGB so that the point is transformed into subspace 0, and
    // keep track of the swaps in ulSymmetry so we can unravel it again
    // later.  We want r >= g >= b (subspace 0).
    ulSymmetry = 0;
    if (ulBlueTemp > ulRedTemp) {
        SWAPTHEM(ulBlueTemp,ulRedTemp);
        ulSymmetry = SWAP_RB;
    }

    if (ulBlueTemp > ulGreenTemp) {
        SWAPTHEM(ulBlueTemp,ulGreenTemp);
        ulSymmetry |= SWAP_GB;
    }

    if (ulGreenTemp > ulRedTemp) {
        SWAPTHEM(ulGreenTemp,ulRedTemp);
        ulSymmetry |= SWAP_RG;
    }

    ulSymmetry <<= 4;   // for lookup purposes

    // Scale the values from 0-255 to 0-64. Note that the scaling is not
    // symmetric at the ends; this is done to match Windows 3.1 dithering
    ulRed = (ulRedTemp + 1) >> 2;
    ulGre = (ulGreenTemp + 1) >> 2;
    ulBlu = (ulBlueTemp + 1) >> 2;

    // Compute the subsubspace within subspace 0 in which the point lies,
    // then calculate the # of pixels to dither in the colors that are the
    // four vertexes of the tetrahedron bounding the color we're emulating.
    // Only vertices with more than zero pixels are stored, and the
    // vertices are stored in order of increasing intensity, saving us the
    // need to sort them later
    if ((ulRedTemp + ulGreenTemp) > 256) {
        // Subsubspace 2 or 3
        if ((ulRedTemp + ulBlueTemp) > 256) {
            // Subsubspace 3
            // Calculate the number of pixels per vertex, still in
            // subsubspace 3, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 3 is:
            // 7, 9, 0x0B, 0x0F
            if ((ulVertex0Temp = (64 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            ulVertex2Temp = ulGre - ulBlu;
            ulVertex3Temp = (ulRed - 64) + ulBlu;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
            }
        } else {
            // Subsubspace 2
            // Calculate the number of pixels per vertex, still in
            // subsubspace 2, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 2 is:
            // 3, 7, 9, 0x0B
            ulVertex1Temp = ulBlu << 1;
            ulVertex2Temp = ulRed - ulGre;
            ulVertex3Temp = (ulRed - 32) + (ulGre - 32);
            if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex1Temp != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
        }
    } else {
        // Subsubspace 0 or 1
        if (ulRedTemp > 128) {
            // Subsubspace 1
            // Calculate the number of pixels per vertex, still in
            // subsubspace 1, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 1 is:
            // 1, 3, 7, 9
            if ((ulVertex0Temp = ((32 - ulGre) + (32 - ulRed)) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex2Temp = ulBlu << 1;
            ulVertex3Temp = (ulRed - 32) << 1;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
        } else {
            // Subsubspace 0
            // Calculate the number of pixels per vertex, still in
            // subsubspace 0, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 0 is:
            // 0, 1, 3, 7
            if ((ulVertex0Temp = (32 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
            }
            if ((ulVertex1Temp = (ulRed - ulGre) << 1) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex3Temp = ulBlu << 1;
            if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex1Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
        }
    }

    return(pvVertexData);
}

/******************************Public*Routine******************************\
* vDitherColor
*
* Dithers the ulNumVertices vertices described by vVertexData into pulDest.
*
\**************************************************************************/

VOID vDitherColor(
ULONG*          pulDest,
VERTEX_DATA*    vVertexData,
VERTEX_DATA*    pvVertexDataEnd,
ULONG           ulNumVertices)
{
    ULONG ulTemp, ulNumPixels, ulColor;
    VERTEX_DATA *pvMaxVertex, *pvVertexData;
    ULONG  *pulDitherOrder;
    BYTE    jColor;
    BYTE   *pjDither = (BYTE *)pulDest;

    if (ulNumVertices > 2) {

        // There are 3 or 4 vertices in this dither
        if (ulNumVertices == 3) {

            // There are 3 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            } else {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            }

        } else {

            // There are 4 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            } else {
                pvMaxVertex = &vVertexData[3];
                ulTemp = vVertexData[3].ulCount;
            }
        }

        if (vVertexData[1].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[1];
            ulTemp = vVertexData[1].ulCount;
        }
        if (vVertexData[0].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[0];
        }

        // Prepare a dword version of the most common vertex number (color)
        ulColor = ulNibbleToDword[pvMaxVertex->ulVertex];

        // Mark that the vertex we're about to do doesn't need to be done
        // later
        pvMaxVertex->ulVertex = 0xFF;

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Now dither all the remaining vertices in order 0->2 or 0->3
        // (in order of increasing intensity)
        pulDitherOrder = aulDitherOrder;
        pvVertexData = vVertexData;
        do {
            if (pvVertexData->ulVertex == 0xFF) {
                // This is the max vertex, which we already did, but we
                // have to account for it in the dither order
                pulDitherOrder += pvVertexData->ulCount;
            } else {
                jColor = (BYTE) ajConvert[pvVertexData->ulVertex];
                ulNumPixels = pvVertexData->ulCount;
                switch (ulNumPixels & 3) {
                    case 3:
                        pjDither[*(pulDitherOrder+2)] = jColor;
                    case 2:
                        pjDither[*(pulDitherOrder+1)] = jColor;
                    case 1:
                        pjDither[*(pulDitherOrder+0)] = jColor;
                        pulDitherOrder += ulNumPixels & 3;
                    case 0:
                        break;
                }
                if ((ulNumPixels >>= 2) != 0) {
                    do {
                        pjDither[*pulDitherOrder] = jColor;
                        pjDither[*(pulDitherOrder+1)] = jColor;
                        pjDither[*(pulDitherOrder+2)] = jColor;
                        pjDither[*(pulDitherOrder+3)] = jColor;
                        pulDitherOrder += 4;
                    } while (--ulNumPixels);
                }
            }
        } while (++pvVertexData < pvVertexDataEnd);

    } else if (ulNumVertices == 2) {

        // There are exactly two vertices with more than zero pixels; fill
        // in the dither array as follows: block fill with vertex with more
        // points first, then dither in the other vertex
        if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
            // There are no more vertex 1 than vertex 0 pixels, so do
            // the block fill with vertex 0
            ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
            // Do the dither with vertex 1
            jColor = (BYTE) ajConvert[vVertexData[1].ulVertex];
            ulNumPixels = vVertexData[1].ulCount;
            // Set where to start dithering with vertex 1 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
        } else {
            // There are more vertex 1 pixels, so do the block fill
            // with vertex 1
            ulColor = ulNibbleToDword[vVertexData[1].ulVertex];
            // Do the dither with vertex 0
            jColor = (BYTE) ajConvert[vVertexData[0].ulVertex];
            ulNumPixels = vVertexData[0].ulCount;
            // Set where to start dithering with vertex 0 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder;
        }

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Dither in the less common vertex
        switch (ulNumPixels & 3) {
            case 3:
                pjDither[*(pulDitherOrder+2)] = jColor;
            case 2:
                pjDither[*(pulDitherOrder+1)] = jColor;
            case 1:
                pjDither[*(pulDitherOrder+0)] = jColor;
                pulDitherOrder += ulNumPixels & 3;
            case 0:
                break;
        }
        if ((ulNumPixels >>= 2) != 0) {
            do {
                pjDither[*pulDitherOrder] = jColor;
                pjDither[*(pulDitherOrder+1)] = jColor;
                pjDither[*(pulDitherOrder+2)] = jColor;
                pjDither[*(pulDitherOrder+3)] = jColor;
                pulDitherOrder += 4;
            } while (--ulNumPixels);
        }

    } else {

        // There is only one vertex in this dither

        // No sorting or dithering is needed for just one color; we can
        // just generate the final DIB directly
        ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;
    }
}

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA
* colours.
*
\**************************************************************************/

ULONG DrvDitherColor(
DHPDEV  dhpdev,
ULONG   iMode,
ULONG   rgb,
ULONG*  pul)
{
    ULONG   ulGrey, ulRed, ulGre, ulBlu, ulTemp;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;

    // Figure out if we need a full color dither or only a monochrome dither.

    // Note: we'll get colour dithers only at 8bpp, because that's the
    //       only colour depth at which we set GCAPS_COLOR_DITHER.

    if (iMode != DM_MONOCHROME)
    {
        // Full color dither

        // Calculate what color subspaces are involved in the dither
        pvVertexData = vComputeSubspaces(rgb, vVertexData);

        // Now that we have found the bounding vertices and the number of
        // pixels to dither for each vertex, we can create the dither pattern

        // Handle 1, 2, and 3 & 4 vertices per dither separately
        ulTemp=(ULONG)(pvVertexData-vVertexData);// # of vertices with more than
                                                //  zero pixels in the dither

        vDitherColor(pul, vVertexData, pvVertexData, ulTemp);
    }
    else
    {
        // Note: we can get monochrome dithers at any colour depth because
        //       we always set GCAPS_MONO_DITHER.

        // For monochrome we will only use the Intensity (grey level)

        RtlFillMemory((PVOID) pul, PATTERNSIZE/2, 0);  // zero the dither bits

        ulRed   = (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
        ulGre = (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
        ulBlu  = (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

        // I = .30R + .59G + .11B
        // For convience the following ratios are used:
        //
        //  77/256 = 30.08%
        // 151/256 = 58.98%
        //  28/256 = 10.94%

        ulGrey  = (((ulRed * 77) + (ulGre * 151) + (ulBlu * 28)) >> 8) & 255;

        // Convert the RGBI from 0-255 to 0-64 notation.

        ulGrey = (ulGrey + 1) >> 2;

        while(ulGrey) {
            ulGrey--;
            pul[ajByte[ulGrey]] |= ((ULONG) ajBits[ulGrey]);
        }
    }

    return(DCR_DRIVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\dci.c ===
/******************************Module*Header*******************************\
* Module Name: dci.c
*
* This module contains the functions required to support DCI.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/


#include "precomp.h"

#if (TARGET_BUILD == 351)
    /*
     * DCI support requires the use of structures and defined values
     * found in a header file that is only present in versions of
     * the DDK that support DCI, rather than having these items
     * in a DCI section of one of the standard header files. For this
     * reason, we can't do conditional compilation based on whether
     * the DCI-specific values are defined, because our first indication
     * would be an error due to the header file not being found.
     *
     * Explicit DCI support is only needed when building for NT 3.51,
     * since it was added for this version, but for version 4.0 (next
     * version) and above it is incorporated into Direct Draw rather
     * than being handled separately.
     *
     * Since this entire module depends on DCI being supported by the
     * build environment, null it out if this is not the case.
     */
#include <dciddi.h>
#include "dci.h"


/******************************Public*Routine******************************\
* DCIRVAL BeginAccess
*
* Map in the screen memory so that the DCI application can access it.

\**************************************************************************/

DCIRVAL BeginAccess(DCISURF* pDCISurf, LPRECT rcl)
{
    PDEV*                           ppdev;
    VIDEO_SHARE_MEMORY              shareMemory;
    VIDEO_SHARE_MEMORY_INFORMATION  shareMemoryInformation;
    DWORD                           returnedDataLength;

    DISPDBG((DEBUG_ENTRY_EXIT, "--> BeginAccess with pDCISurf %08lx", pDCISurf));

    ppdev = pDCISurf->ppdev;

    if (pDCISurf->SurfaceInfo.dwOffSurface != 0)
        {
        /*
         * We have already mapped in the frame buffer. All our
         * accelerators unmap the frame buffer in the
         * DestroySurface() call, so if this is the beginning
         * of the second or subsequent BeginAccess()/EndAccess()
         * pair since the surface was created, we don't need to
         * map the frame buffer again.
         *
         * Wait for any pending accelerator operations to complete before
         * yielding control, in case it affects the same screen region
         * that DCI wants.
         */
        if (ppdev->iMachType == MACH_MM_64)
            {
            vM64QuietDown(ppdev, ppdev->pjMmBase);
            }
        else if (ppdev->iMachType == MACH_MM_32)
            {
            vM32QuietDown(ppdev, ppdev->pjMmBase);
            }
        else    /* if (ppdev->iMachType == MACH_IO_32) */
            {
            vI32QuietDown(ppdev, ppdev->pjIoBase);
            }

        DISPDBG((DEBUG_ENTRY_EXIT, "<-- BeginAccess"));
        return(DCI_OK);
        }
    else
        {
        shareMemory.ProcessHandle           = EngGetProcessHandle();
        shareMemory.RequestedVirtualAddress = 0;
        shareMemory.ViewOffset              = pDCISurf->Offset;
        shareMemory.ViewSize                = pDCISurf->Size;

        /*
         * Wait for any pending accelerator operations to complete
         * before yielding control, in case it affects the same
         * screen region that DCI wants.
         */
        if (ppdev->iMachType == MACH_MM_64)
            {
            vM64QuietDown(ppdev, ppdev->pjMmBase);
            }
        else if (ppdev->iMachType == MACH_MM_32)
            {
            vM32QuietDown(ppdev, ppdev->pjMmBase);
            }
        else    /* if (ppdev->iMachType == MACH_IO_32) */
            {
            vI32QuietDown(ppdev, ppdev->pjIoBase);
            }

        /*
         * Now map the frame buffer into the caller's address space:
         *
         * Be careful when mixing VideoPortMapBankedMemory (i.e., vflatd)
         * access with explicit banking in the driver -- the two may get
         * out of sync with respect to what bank they think the hardware
         * is currently configured for.  The easiest way to avoid any
         * problem is to call VideoPortMapBankedMemory/VideoPortUnmapMemory
         * in the miniport for every BeginAccess/EndAccess pair, and to
         * always explicitly reset the bank after the EndAccess.
         * (VideoPortMapBankedMemory will always reset vflatd's current
         * bank.)
         */
        if (!AtiDeviceIoControl(pDCISurf->ppdev->hDriver,
                             IOCTL_VIDEO_SHARE_VIDEO_MEMORY,
                             &shareMemory,
                             sizeof(VIDEO_SHARE_MEMORY),
                             &shareMemoryInformation,
                             sizeof(VIDEO_SHARE_MEMORY_INFORMATION),
                             &returnedDataLength))
            {
            DISPDBG((DEBUG_ERROR, "BeginAccess: failed IOCTL_VIDEO_SHARE_VIDEO_MEMORY"));
            return(DCI_FAIL_GENERIC);
            }

        pDCISurf->SurfaceInfo.wSelSurface  = 0;
        pDCISurf->SurfaceInfo.dwOffSurface =
            (ULONG) shareMemoryInformation.VirtualAddress;

        /*
         * We return DCI_STATUS_POINTERCHANGED because we have
         * just created a new pointer to the frame buffer.
         * Repeated BeginAccess()/EndAccess() calls without
         * a call to DestroySurface() will hit this case on the
         * first call, but meet the "if" condition (buffer
         * already mapped) on subsequent calls.
         *
         * We would only need to map the DCI pointer on every
         * call to BeginAccess() and unmap it on every call
         * to EndAccess() if we couldn't support simultaneous
         * accelerator and frame buffer access. All our cards
         * with frame buffer capability support such access,
         * and it's GDI's responsibility to ensure that no
         * GDI call is made between the calls to BeginAccess()
         * and EndAccess(), so we don't need a critical section
         * to ensure that a GDI call doesn't change the page
         * while DCI is accessing the frame buffer if we are
         * using a banked aperture.
         */
#if DBG
        DISPDBG((DEBUG_ENTRY_EXIT, "<-- BeginAccess DCI_STATUS_POINTERCHANGED %08lx\n", pDCISurf));
#endif

        return(DCI_STATUS_POINTERCHANGED);
        }
}

/******************************Public*Routine******************************\
* VOID vUnmap
*
* Unmap the screen memory so that the DCI application can no longer access
* it.

\**************************************************************************/

VOID vUnmap(DCISURF* pDCISurf)
{
    PDEV*               ppdev;
    VIDEO_SHARE_MEMORY  shareMemory;
    DWORD               returnedDataLength;

    ppdev = pDCISurf->ppdev;

    /*
     * We no longer need to have the frame buffer mapped for DCI,
     * so unmap it.
     */
    shareMemory.ProcessHandle           = EngGetProcessHandle();
    shareMemory.ViewOffset              = 0;
    shareMemory.ViewSize                = 0;
    shareMemory.RequestedVirtualAddress =
        (VOID*) pDCISurf->SurfaceInfo.dwOffSurface;

    if (!AtiDeviceIoControl(pDCISurf->ppdev->hDriver,
                         IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY,
                         &shareMemory,
                         sizeof(VIDEO_SHARE_MEMORY),
                         NULL,
                         0,
                         &returnedDataLength))
        {
        DISPDBG((DEBUG_ERROR, "EndAccess failed IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY"));
        }
    else
        {
        /*
         * Be sure to signal to GDI that the surface is no longer mapped.
         */
        pDCISurf->SurfaceInfo.dwOffSurface = 0;
        }
}

/******************************Public*Routine******************************\
* DCIRVAL EndAccess
*
* Switch control of the frame buffer from DCI back to GDI.
\**************************************************************************/

DCIRVAL EndAccess(DCISURF* pDCISurf)
{
    PDEV*   ppdev;

    /*
     * We would only need to unmap the frame buffer at this
     * point if our cards couldn't support simultaneous frame
     * buffer and accelerator access. Since our cards with
     * frame buffer capability all support such access (provided
     * the two accesses refer to different parts of the screen,
     * since otherwise they'd corrupt each other, but it's
     * GDI's responsibility to ensure that this is the case),
     * this function only needs to ensure that no call to
     * EndAccess() is made without a corresponding call to
     * BeginAccess() having already been made.
     */

    DISPDBG((DEBUG_ENTRY_EXIT, "EndAccess with pDCISurf %08lx\n", pDCISurf));

    ASSERTDD(pDCISurf->SurfaceInfo.dwOffSurface != 0,
        "GDI should assure us that EndAccess can't be recursive");

    ppdev = pDCISurf->ppdev;

    return(DCI_OK);
}

/******************************Public*Routine******************************\
* VOID DestroySurface
*
* Destroy the DCI surface and free up any allocations.

\**************************************************************************/

VOID DestroySurface(DCISURF* pDCISurf)
{
    DISPDBG((DEBUG_ENTRY_EXIT, "DestroySurface with pDCISurf %08lx\n", pDCISurf));

    if (pDCISurf->SurfaceInfo.dwOffSurface != 0)
        {
        /*
         * Because we can support simultaneous frame buffer and
         * accelerator access, we optimized a bit by not unmapping
         * the frame buffer on every EndAccess() call, but we
         * finally have to do the unmap now. The dwOffSurface field
         * should always be nonzero (a frame buffer has been mapped),
         * but there's no harm in checking.
         */
        vUnmap(pDCISurf);
        }

    LocalFree(pDCISurf);
}

/******************************Public*Routine******************************\
* ULONG DCICreatePrimarySurface
*
* Create a DCI surface to provide access to the visible screen.

\**************************************************************************/

ULONG DCICreatePrimarySurface(PDEV* ppdev, ULONG cjIn, VOID* pvIn, ULONG cjOut, VOID* pvOut)
{
    DCISURF*         pDCISurf;
    LPDCICREATEINPUT pInput;
    LONG             lRet;


    #if defined(MIPS) || defined(_PPC_)
        {
        /*
         * !!! vflatd seems to currently have a bug on Mips and PowerPC:
         */
        return (ULONG) (DCI_FAIL_UNSUPPORTED);
        }
    #endif

    if( !(ppdev->FeatureFlags & EVN_DENSE_CAPABLE) )
        {
        /*
         * We don't support DCI on the Alpha when running in sparse
         * space, because we can't.
         */
        lRet = DCI_FAIL_UNSUPPORTED;
        }
    else
        {
        pInput = (DCICREATEINPUT*) pvIn;

        if (cjIn >= sizeof(DCICREATEINPUT))
            {
            pDCISurf = (DCISURF*) LocalAlloc(LMEM_ZEROINIT, sizeof(DCISURF));

            if (pDCISurf)
                {
                /*
                 * Initializate all public information about the primary
                 * surface.
                 */
                pDCISurf->SurfaceInfo.dwSize         = sizeof(DCISURFACEINFO);
                pDCISurf->SurfaceInfo.dwDCICaps      = DCI_PRIMARY | DCI_VISIBLE;
                pDCISurf->SurfaceInfo.BeginAccess    = BeginAccess;
                pDCISurf->SurfaceInfo.EndAccess      = EndAccess;
                pDCISurf->SurfaceInfo.DestroySurface = DestroySurface;
                pDCISurf->SurfaceInfo.dwMask[0]      = ppdev->flRed;
                pDCISurf->SurfaceInfo.dwMask[1]      = ppdev->flGreen;
                pDCISurf->SurfaceInfo.dwMask[2]      = ppdev->flBlue;
                pDCISurf->SurfaceInfo.dwBitCount     = ppdev->cBitsPerPel;
                pDCISurf->SurfaceInfo.dwWidth        = ppdev->cxScreen;
                pDCISurf->SurfaceInfo.dwHeight       = ppdev->cyScreen;
                pDCISurf->SurfaceInfo.lStride        = ppdev->lDelta;
                pDCISurf->SurfaceInfo.wSelSurface    = 0;
                pDCISurf->SurfaceInfo.dwOffSurface   = 0;

                if (pDCISurf->SurfaceInfo.dwBitCount <= 8)
                    {
                    pDCISurf->SurfaceInfo.dwCompression = BI_RGB;
                    }
                else
                    {
                    pDCISurf->SurfaceInfo.dwCompression = BI_BITFIELDS;
                    }

                /*
                 * Now initialize our private fields that we want associated
                 * with the DCI surface:
                 */
                pDCISurf->ppdev  = ppdev;
                pDCISurf->Offset = 0;

                /*
                 * Under NT, all mapping is done with a 64K granularity.
                 */
                pDCISurf->Size = ROUND_UP_TO_64K(ppdev->cyScreen * ppdev->lDelta);

                /*
                 * Return a pointer to the DCISURF to GDI by placing
                 * it in the 'pvOut' buffer.
                 */
                *((DCISURF**) pvOut) = pDCISurf;

                lRet = DCI_OK;
                }
            else
                {
                lRet = DCI_ERR_OUTOFMEMORY;
                }
            }
        else
            {
            lRet = DCI_FAIL_GENERIC;
            }
        }

    return(lRet);
}

#endif  /* TARGET_BUILD == 351 */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\ddraw.c ===
/******************************Module*Header*******************************\
* Module Name: ddraw64.c
*
* Implements all the common DirectDraw components for the
*  ATI MACH 64/32/32 Memory mapped driver.
*
* Copyright (c) 1995-1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

extern  BOOL DrvGetDirectDrawInfo32I( DHPDEV dhpdev,DD_HALINFO* pHalInfo,DWORD*  pdwNumHeaps,VIDEOMEMORY* pvmList,
                                                                        DWORD* pdwNumFourCC,DWORD* pdwFourCC);
extern  BOOL DrvGetDirectDrawInfo32M( DHPDEV dhpdev,DD_HALINFO* pHalInfo,DWORD*  pdwNumHeaps,VIDEOMEMORY* pvmList,
                                                                        DWORD* pdwNumFourCC,DWORD* pdwFourCC);
extern  BOOL DrvGetDirectDrawInfo64( DHPDEV dhpdev,DD_HALINFO* pHalInfo,DWORD*  pdwNumHeaps,VIDEOMEMORY* pvmList,
                                                                        DWORD* pdwNumFourCC,DWORD* pdwFourCC);

extern  VOID vGetDisplayDuration32I(PDEV* ppdev);
extern  DWORD DdBlt32I(PDD_BLTDATA lpBlt);
extern  DWORD DdFlip32I(PDD_FLIPDATA lpFlip);
extern  DWORD DdLock32I(PDD_LOCKDATA lpLock);
extern  DWORD DdGetBltStatus32I(PDD_GETBLTSTATUSDATA lpGetBltStatus);
extern  DWORD DdGetFlipStatus32I(PDD_GETFLIPSTATUSDATA lpGetFlipStatus);
extern  DWORD DdWaitForVerticalBlank32I(PDD_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank);
extern  DWORD DdGetScanLine32I(PDD_GETSCANLINEDATA lpGetScanLine);

extern  VOID  vGetDisplayDuration32M(PDEV* ppdev);
extern  DWORD DdBlt32M(PDD_BLTDATA lpBlt);
extern  DWORD DdFlip32M(PDD_FLIPDATA lpFlip);
extern  DWORD DdLock32M(PDD_LOCKDATA lpLock);
extern  DWORD DdGetBltStatus32M(PDD_GETBLTSTATUSDATA lpGetBltStatus);
extern  DWORD DdGetFlipStatus32M(PDD_GETFLIPSTATUSDATA lpGetFlipStatus);
extern  DWORD DdWaitForVerticalBlank32M(PDD_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank);
extern  DWORD DdGetScanLine32M(PDD_GETSCANLINEDATA lpGetScanLine);

extern  VOID  vGetDisplayDuration64(PDEV* ppdev);
extern  DWORD DdBlt64(PDD_BLTDATA lpBlt);
extern  DWORD DdFlip64(PDD_FLIPDATA lpFlip);
extern  DWORD DdLock64(PDD_LOCKDATA lpLock);
extern  DWORD DdGetBltStatus64(PDD_GETBLTSTATUSDATA lpGetBltStatus);
extern  DWORD DdGetFlipStatus64(PDD_GETFLIPSTATUSDATA lpGetFlipStatus);
extern  DWORD DdWaitForVerticalBlank64(PDD_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank);
extern  DWORD DdGetScanLine64(PDD_GETSCANLINEDATA lpGetScanLine);

/******************************Public*Routine******************************\
* DWORD DdMapMemory
*
* This is a new DDI call specific to Windows NT that is used to map
* or unmap all the application modifiable portions of the frame buffer
* into the specified process's address space.
*
\**************************************************************************/

DWORD DdMapMemory(
PDD_MAPMEMORYDATA lpMapMemory)
{
    PDEV*                           ppdev;
    VIDEO_SHARE_MEMORY              ShareMemory;
    VIDEO_SHARE_MEMORY_INFORMATION  ShareMemoryInformation;
    DWORD                           ReturnedDataLength;

    ppdev = (PDEV*) lpMapMemory->lpDD->dhpdev;

    if (lpMapMemory->bMap)
    {
        ShareMemory.ProcessHandle = lpMapMemory->hProcess;

        // 'RequestedVirtualAddress' isn't actually used for the SHARE IOCTL:

        ShareMemory.RequestedVirtualAddress = 0;

        // We map in starting at the top of the frame buffer:

        ShareMemory.ViewOffset = 0;

        // We map down to the end of the frame buffer.
        //
        // Note: There is a 64k granularity on the mapping (meaning that
        //       we have to round up to 64k).
        //
        // Note: If there is any portion of the frame buffer that must
        //       not be modified by an application, that portion of memory
        //       MUST NOT be mapped in by this call.  This would include
        //       any data that, if modified by a malicious application,
        //       would cause the driver to crash.  This could include, for
        //       example, any DSP code that is kept in off-screen memory.

        ShareMemory.ViewSize
                            = ROUND_UP_TO_64K(ppdev->cyMemory * ppdev->lDelta);

           DISPDBG((10, "Share memory size %x %d",ShareMemory.ViewSize,ShareMemory.ViewSize));

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SHARE_VIDEO_MEMORY,
                               &ShareMemory,
                               sizeof(VIDEO_SHARE_MEMORY),
                               &ShareMemoryInformation,
                               sizeof(VIDEO_SHARE_MEMORY_INFORMATION),
                               &ReturnedDataLength))
        {
            DISPDBG((10, "Failed IOCTL_VIDEO_SHARE_MEMORY"));

            lpMapMemory->ddRVal = DDERR_GENERIC;
            return(DDHAL_DRIVER_HANDLED);
        }

        lpMapMemory->fpProcess =(FLATPTR)ShareMemoryInformation.VirtualAddress;
    }
    else
    {
        ShareMemory.ProcessHandle           = lpMapMemory->hProcess;
        ShareMemory.ViewOffset              = 0;
        ShareMemory.ViewSize                = 0;
        ShareMemory.RequestedVirtualAddress = (VOID*) lpMapMemory->fpProcess;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY,
                               &ShareMemory,
                               sizeof(VIDEO_SHARE_MEMORY),
                               NULL,
                               0,
                               &ReturnedDataLength))
        {
            RIP("Failed IOCTL_VIDEO_UNSHARE_MEMORY");
        }
    }

    lpMapMemory->ddRVal = DD_OK;
    return(DDHAL_DRIVER_HANDLED);
}
/******************************Public*Routine******************************\
* BOOL DrvGetDirectDrawInfo
*
* Will be called before DrvEnableDirectDraw is called.
*
\**************************************************************************/

BOOL DrvGetDirectDrawInfo(
DHPDEV          dhpdev,
DD_HALINFO*     pHalInfo,
DWORD*          pdwNumHeaps,
VIDEOMEMORY*    pvmList,            // Will be NULL on first call
DWORD*          pdwNumFourCC,
DWORD*          pdwFourCC)          // Will be NULL on first call
{
    PDEV*       ppdev;

    ppdev = (PDEV*) dhpdev;

    // if no APERATURE then we are a MACH8 and have no DDraw support
    if (ppdev->iAperture == APERTURE_NONE)
    {
        return FALSE;
    }

    // we can't use DirectDraw on a banked device because of a conflict
    // over who owns the bank registers between VideoPortMapBankedMemory
    // and the display driver
    if (!(ppdev->flCaps & CAPS_LINEAR_FRAMEBUFFER))
    {
        return FALSE;
    }

    if (ppdev->iMachType == MACH_MM_32)
    {
        // Can do memory-mapped IO:
        return(DrvGetDirectDrawInfo32M(dhpdev,pHalInfo,pdwNumHeaps,pvmList,pdwNumFourCC,pdwFourCC));
    }
    else if (ppdev->iMachType == MACH_IO_32)
    {
        return(DrvGetDirectDrawInfo32I(dhpdev,pHalInfo,pdwNumHeaps,pvmList,pdwNumFourCC,pdwFourCC));
    }
    else
    {
        // MACH 64
        return(DrvGetDirectDrawInfo64(dhpdev,pHalInfo,pdwNumHeaps,pvmList,pdwNumFourCC,pdwFourCC));
    }

}

/******************************Public*Routine******************************\
* BOOL DrvEnableDirectDraw
*
* This function is called by GDI to enable DirectDraw when a DirectDraw
* program is started and DirectDraw is not already active.
*
\**************************************************************************/

BOOL DrvEnableDirectDraw(
DHPDEV                  dhpdev,
DD_CALLBACKS*           pCallBacks,
DD_SURFACECALLBACKS*    pSurfaceCallBacks,
DD_PALETTECALLBACKS*    pPaletteCallBacks)
{
    PDEV* ppdev;

    ppdev = (PDEV*) dhpdev;

    if (ppdev->iMachType == MACH_MM_32)
    {
        pSurfaceCallBacks->Blt           = DdBlt32M;
        pSurfaceCallBacks->Flip          = DdFlip32M;
        pSurfaceCallBacks->Lock          = DdLock32M;
        pSurfaceCallBacks->GetBltStatus  = DdGetBltStatus32M;
        pSurfaceCallBacks->GetFlipStatus = DdGetFlipStatus32M;
        if (ppdev->iBitmapFormat >= BMF_24BPP)
        {
            pSurfaceCallBacks->dwFlags = DDHAL_SURFCB32_LOCK;
        }
        else
        {
            pSurfaceCallBacks->dwFlags = DDHAL_SURFCB32_BLT
                                       | DDHAL_SURFCB32_FLIP
                                       | DDHAL_SURFCB32_LOCK
                                       | DDHAL_SURFCB32_GETBLTSTATUS
                                       | DDHAL_SURFCB32_GETFLIPSTATUS;
        }

        pCallBacks->WaitForVerticalBlank = DdWaitForVerticalBlank32M;
        pCallBacks->GetScanLine          = DdGetScanLine32M;
        pCallBacks->MapMemory            = DdMapMemory;
        pCallBacks->dwFlags              = DDHAL_CB32_WAITFORVERTICALBLANK
                                         | DDHAL_CB32_GETSCANLINE
                                         | DDHAL_CB32_MAPMEMORY;
    }
    else if (ppdev->iMachType == MACH_IO_32 )
    {
        pSurfaceCallBacks->Blt           = DdBlt32I;
        pSurfaceCallBacks->Flip          = DdFlip32I;
        pSurfaceCallBacks->Lock          = DdLock32I;
        pSurfaceCallBacks->GetBltStatus  = DdGetBltStatus32I;
        pSurfaceCallBacks->GetFlipStatus = DdGetFlipStatus32I;
        if (ppdev->iBitmapFormat >= BMF_24BPP)
        {
            pSurfaceCallBacks->dwFlags = DDHAL_SURFCB32_LOCK;
        }
        else
        {
            pSurfaceCallBacks->dwFlags = DDHAL_SURFCB32_BLT
                                       | DDHAL_SURFCB32_FLIP
                                       | DDHAL_SURFCB32_LOCK
                                       | DDHAL_SURFCB32_GETBLTSTATUS
                                       | DDHAL_SURFCB32_GETFLIPSTATUS;
        }

        pCallBacks->WaitForVerticalBlank = DdWaitForVerticalBlank32I;
        pCallBacks->GetScanLine          = DdGetScanLine32I;
        pCallBacks->MapMemory            = DdMapMemory;
        pCallBacks->dwFlags              = DDHAL_CB32_WAITFORVERTICALBLANK
                                         | DDHAL_CB32_GETSCANLINE
                                         | DDHAL_CB32_MAPMEMORY;
    }
    else
    {   // MACH 64
        pSurfaceCallBacks->Blt           = DdBlt64;
        pSurfaceCallBacks->Flip          = DdFlip64;
        pSurfaceCallBacks->Lock          = DdLock64;
        pSurfaceCallBacks->GetBltStatus  = DdGetBltStatus64;
        pSurfaceCallBacks->GetFlipStatus = DdGetFlipStatus64;
        if (ppdev->iBitmapFormat >= BMF_24BPP)
        {
            pSurfaceCallBacks->dwFlags = DDHAL_SURFCB32_LOCK;
        }
        else
        {
            pSurfaceCallBacks->dwFlags = DDHAL_SURFCB32_BLT
                                       | DDHAL_SURFCB32_FLIP
                                       | DDHAL_SURFCB32_LOCK
                                       | DDHAL_SURFCB32_GETBLTSTATUS
                                       | DDHAL_SURFCB32_GETFLIPSTATUS;
        }

        pCallBacks->WaitForVerticalBlank = DdWaitForVerticalBlank64;
        pCallBacks->GetScanLine          = DdGetScanLine64;
        pCallBacks->MapMemory            = DdMapMemory;
        pCallBacks->dwFlags              = DDHAL_CB32_WAITFORVERTICALBLANK
                                         | DDHAL_CB32_GETSCANLINE
                                         | DDHAL_CB32_MAPMEMORY;
    }

    // Note that we don't call 'vGetDisplayDuration' here, for a couple of
    // reasons:
    //
    //  o Because the system is already running, it would be disconcerting
    //    to pause the graphics for a good portion of a second just to read
    //    the refresh rate;
    //  o More importantly, we may not be in graphics mode right now.
    //
    // For both reasons, we always measure the refresh rate when we switch
    // to a new mode.

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL DrvDisableDirectDraw
*
* This function is called by GDI when the last active DirectDraw program
* is quit and DirectDraw will no longer be active.
*
\**************************************************************************/

VOID DrvDisableDirectDraw(
DHPDEV      dhpdev)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

    // DirectDraw is done with the display, so we can go back to using
    // all of off-screen memory ourselves:

    pohFree(ppdev, ppdev->pohDirectDraw);
    ppdev->pohDirectDraw = NULL;
}

/******************************Public*Routine******************************\
* VOID vAssertModeDirectDraw
*
* This function is called by enable.c when entering or leaving the
* DOS full-screen character mode.
*
\**************************************************************************/

VOID vAssertModeDirectDraw(
PDEV*   ppdev,
BOOL    bEnabled)
{
}

/******************************Public*Routine******************************\
* BOOL bEnableDirectDraw
*
* This function is called by enable.c when the mode is first initialized,
* right after the miniport does the mode-set.
*
\**************************************************************************/

BOOL bEnableDirectDraw(
PDEV*   ppdev)
{
    // if no APERATURE then we are a MACH8 and have no DDraw support
    if (ppdev->iAperture != APERTURE_NONE)
    {
        // Accurately measure the refresh rate for later:
        ppdev->bPassVBlank=TRUE;
        if (ppdev->iMachType == MACH_MM_32)
        {
            // Can do memory-mapped IO:
            vGetDisplayDuration32M(ppdev);
        }
        else if (ppdev->iMachType == MACH_IO_32 )
        {
            vGetDisplayDuration32I(ppdev);
        }
        else
        {   // MACH 64
            // we have a problem with VBLANK on high speed multiprocessors machines on GX-F
            // so right now will test the VBlank routine; if OK report FLIP capabilities, otherwise no.
            int j;
            LONGLONG Counter[2], Freq;

            EngQueryPerformanceFrequency(&Freq);

            for (j = 0; j < 10; j++)
            {
                EngQueryPerformanceCounter(&Counter[0]);
                while (IN_VBLANK_64( ppdev->pjMmBase))
                {
                    EngQueryPerformanceCounter(&Counter[1]);
                    if( (ULONG)(Counter[1]-Counter[0]) >= (ULONG)Freq )       // if we are here more than 1 sec
                    {
                        // we are stuck inside the VBlank routine
                        ppdev->bPassVBlank=FALSE;
                        goto ExitVBlankTest;
                    }
                }

                EngQueryPerformanceCounter(&Counter[0]);
                while (!(IN_VBLANK_64( ppdev->pjMmBase)))
                {
                    EngQueryPerformanceCounter(&Counter[1]);
                    if( (ULONG)(Counter[1]-Counter[0]) >= (ULONG)Freq)          // if we are here more than 1 sec
                    {
                        // we are stuck inside the VBlank routine
                        ppdev->bPassVBlank=FALSE;
                        goto ExitVBlankTest;
                    }
                }
            }
            ExitVBlankTest:
            vGetDisplayDuration64(ppdev);
        }
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableDirectDraw
*
* This function is called by enable.c when the driver is shutting down.
*
\**************************************************************************/

VOID vDisableDirectDraw(
PDEV*   ppdev)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\ddraw32m.c ===
/******************************Module*Header*******************************\
* Module Name: ddraw32M.c
*
* Implements all the DirectDraw components for the MACH 32 I/O driver.
*
* Copyright (c) 1995-1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

// NT is kind enough to pre-calculate the 2-d surface offset as a 'hint' so
// that we don't have to do the following, which would be 6 DIVs per blt:
//
//    y += (offset / pitch)
//    x += (offset % pitch) / bytes_per_pixel

#define convertToGlobalCord(x, y, surf) \
{                                       \
    y += (WORD)surf->yHint;             \
    x += (WORD)surf->xHint;             \
}

#define M32_CURRENT_VLINE(pjMmBase)  ((M32_IW(pjMmBase,VERT_LINE_CNTR) & 0x7ff))

//#define IN_VSYNC       ((M32_IW(pjMmBase,DISP_STATUS) & V_SYNC_TOGGLE_BIT) ^ syncToggleSide)


#define M32_WAIT_FOR_IDLE() \
{ \
    while (    M32_FIFO_SPACE_AVAIL(ppdev, pjMmBase, 16) \
    || (M32_IW(pjMmBase,GE_STAT) & GE_BUSY) \
    || (M32_IW(pjMmBase,EXT_GE_STATUS) & GE_ACTIVE) \
    )\
    ;\
}


#define SET_BLT_OFFSET(load,offset,pitch)\
{ \
    offset   >>=  2;\
    M32_OB( pjMmBase,SHADOW_SET+1,load); \
    M32_OW( pjMmBase,GE_OFFSET_HI,(WORD)((offset >> 16) & 0x000f));\
    M32_OW( pjMmBase,GE_OFFSET_LO,(WORD)(offset & 0xffff));\
    M32_OW( pjMmBase,GE_PITCH,(WORD)((pitch / pitchAdjuster) >> 3));\
}

#define SET_BLT_SOURCE_OFFSET(offset,pitch) SET_BLT_OFFSET(LOAD_SOURCE,offset,pitch)
#define SET_BLT_DEST_OFFSET(offset,pitch)   SET_BLT_OFFSET(LOAD_DEST,offset,pitch)


#define RESET_BLT_OFFSET()\
{ \
    M32_WAIT_FOR_IDLE(); \
    M32_OB( pjMmBase,SHADOW_SET+1, LOAD_SOURCE_AND_DEST);\
    M32_OW( pjMmBase,GE_OFFSET_HI, 0);\
    M32_OW( pjMmBase,GE_OFFSET_LO,0);\
    M32_OW( pjMmBase,GE_PITCH,(WORD)((sysPitch / pitchAdjuster) >> 3));\
}


#define SET_SOURCE_BLT(startX,startY,endX)\
{\
    M32_OW( pjMmBase, M32_SRC_X, startX);\
    M32_OW( pjMmBase, M32_SRC_Y, startY);\
    \
    M32_OW( pjMmBase, M32_SRC_X_START,startX);\
    M32_OW( pjMmBase, M32_SRC_X_END, endX);\
}

#define SET_DEST_BLT(startX,startY,endX,endY)\
{ \
    M32_OW( pjMmBase, CUR_X,startX); \
    M32_OW( pjMmBase, CUR_Y,startY); \
    \
    M32_OW( pjMmBase, DEST_X_START,startX);\
    M32_OW( pjMmBase, DEST_X_END,endX);\
    M32_OW( pjMmBase, DEST_Y_END,endY);\
}
// NT is kind enough to pre-calculate the 2-d surface offset as a 'hint' so
// that we don't have to do the following, which would be 6 DIVs per blt:
//
//    y += (offset / pitch)
//    x += (offset % pitch) / bytes_per_pixel


#define CONVERT_DEST_TO_ZERO_BASE_REFERENCE(surf)\
{\
    convertToGlobalCord(destX, destY, surf);\
    convertToGlobalCord(destXEnd, destYEnd, surf);\
}

#define CONVERT_SOURCE_TO_ZERO_BASE_REFERENCE(surf)\
{\
    convertToGlobalCord(srcX, srcY, surf);\
    convertToGlobalCord(srcXEnd, srcYEnd, surf);\
}

#define M32_DRAW_ENGINE_BUSY(ppdev, pjMmBase)  ( \
    M32_FIFO_SPACE_AVAIL(ppdev, pjMmBase, 16 ) \
    || (M32_IW(pjMmBase,GE_STAT) & GE_BUSY ) \
    || (M32_IW(pjMmBase,EXT_GE_STATUS) & GE_ACTIVE) \
)
/*
* currentScanLine
* safe get current scan line
*/
static __inline int currentScanLine(BYTE* pjMmBase)
{
    WORD lastValue    = M32_CURRENT_VLINE(pjMmBase);
    WORD currentValue = M32_CURRENT_VLINE(pjMmBase);

    while (lastValue != currentValue)
    {
        lastValue = currentValue;
        currentValue = M32_CURRENT_VLINE(pjMmBase);
    }

    return currentValue;
}

static __inline inVBlank(PDEV* ppdev, BYTE* pjMmBase)
{

    int temp;
    temp = currentScanLine(pjMmBase);
    return ((temp >= ppdev->flipRecord.wstartOfVBlank- 15) || temp < 15);
}


/******************************Public*Routine******************************\
* VOID vGetDisplayDuration32I
*
* Get the length, in EngQueryPerformanceCounter() ticks, of a refresh cycle.
*
* If we could trust the miniport to return back and accurate value for
* the refresh rate, we could use that.  Unfortunately, our miniport doesn't
* ensure that it's an accurate value.
*
\**************************************************************************/

#define NUM_VBLANKS_TO_MEASURE      1
#define NUM_MEASUREMENTS_TO_TAKE    8

VOID vGetDisplayDuration32M(PDEV* ppdev)
{
    BYTE*       pjMmBase;
    LONG        i;
    LONG        j;
    LONGLONG    li;
    LONGLONG    liMin;
    LONGLONG    aliMeasurement[NUM_MEASUREMENTS_TO_TAKE + 1];

    pjMmBase = ppdev->pjMmBase;

    ppdev->flipRecord.wstartOfVBlank = M32_IW(pjMmBase, R_V_DISP);

    // Warm up EngQUeryPerformanceCounter to make sure it's in the working
    // set:

    EngQueryPerformanceCounter(&li);

    // Unfortunately, since NT is a proper multitasking system, we can't
    // just disable interrupts to take an accurate reading.  We also can't
    // do anything so goofy as dynamically change our thread's priority to
    // real-time.
    //
    // So we just do a bunch of short measurements and take the minimum.
    //
    // It would be 'okay' if we got a result that's longer than the actual
    // VBlank cycle time -- nothing bad would happen except that the app
    // would run a little slower.  We don't want to get a result that's
    // shorter than the actual VBlank cycle time -- that could cause us
    // to start drawing over a frame before the Flip has occured.

    while (inVBlank( ppdev, pjMmBase))
        ;

    while (!(inVBlank( ppdev, pjMmBase)))
        ;

    for (i = 0; i < NUM_MEASUREMENTS_TO_TAKE; i++)
    {
        // We're at the start of the VBlank active cycle!

        EngQueryPerformanceCounter(&aliMeasurement[i]);

        // Okay, so life in a multi-tasking environment isn't all that
        // simple.  What if we had taken a context switch just before
        // the above EngQueryPerformanceCounter call, and now were half
        // way through the VBlank inactive cycle?  Then we would measure
        // only half a VBlank cycle, which is obviously bad.  The worst
        // thing we can do is get a time shorter than the actual VBlank
        // cycle time.
        //
        // So we solve this by making sure we're in the VBlank active
        // time before and after we query the time.  If it's not, we'll
        // sync up to the next VBlank (it's okay to measure this period --
        // it will be guaranteed to be longer than the VBlank cycle and
        // will likely be thrown out when we select the minimum sample).
        // There's a chance that we'll take a context switch and return
        // just before the end of the active VBlank time -- meaning that
        // the actual measured time would be less than the true amount --
        // but since the VBlank is active less than 1% of the time, this
        // means that we would have a maximum of 1% error approximately
        // 1% of the times we take a context switch.  An acceptable risk.
        //
        // This next line will cause us wait if we're no longer in the
        // VBlank active cycle as we should be at this point:

        while (!(inVBlank( ppdev, pjMmBase)))
            ;

        for (j = 0; j < NUM_VBLANKS_TO_MEASURE; j++)
        {
            while (inVBlank( ppdev, pjMmBase))
                ;
            while (!(inVBlank( ppdev, pjMmBase)))
                ;
        }
    }

    EngQueryPerformanceCounter(&aliMeasurement[NUM_MEASUREMENTS_TO_TAKE]);

    // Use the minimum:

    liMin = aliMeasurement[1] - aliMeasurement[0];

    DISPDBG((10, "Refresh count: %li - %li", 1, (ULONG) liMin));

    for (i = 2; i <= NUM_MEASUREMENTS_TO_TAKE; i++)
    {
        li = aliMeasurement[i] - aliMeasurement[i - 1];

        DISPDBG((10, "               %li - %li", i, (ULONG) li));

        if (li < liMin)
            liMin = li;
    }

    // Round the result:

    ppdev->flipRecord.liFlipDuration
        = (DWORD) (liMin + (NUM_VBLANKS_TO_MEASURE / 2)) / NUM_VBLANKS_TO_MEASURE;

    DISPDBG((10, "Frequency %li.%03li Hz",
        (ULONG) (EngQueryPerformanceFrequency(&li),
        li / ppdev->flipRecord.liFlipDuration),
        (ULONG) (EngQueryPerformanceFrequency(&li),
        ((li * 1000) / ppdev->flipRecord.liFlipDuration) % 1000)));

    ppdev->flipRecord.liFlipTime = aliMeasurement[NUM_MEASUREMENTS_TO_TAKE];
    ppdev->flipRecord.bFlipFlag  = FALSE;
    ppdev->flipRecord.fpFlipFrom = 0;
}

/******************************Public*Routine******************************\
* HRESULT vUpdateFlipStatus32M
*
* Checks and sees if the most recent flip has occurred.
*
\**************************************************************************/

HRESULT vUpdateFlipStatus32M(
                             PDEV*   ppdev,
                             FLATPTR fpVidMem)
{
    BYTE*       pjMmBase;
    LONGLONG    liTime;

    pjMmBase = ppdev->pjMmBase;

    if ((ppdev->flipRecord.bFlipFlag) &&
        ((fpVidMem == 0) || (fpVidMem == ppdev->flipRecord.fpFlipFrom)))
    {
        if (inVBlank( ppdev, pjMmBase))
        {
            if (ppdev->flipRecord.bWasEverInDisplay)
            {
                ppdev->flipRecord.bHaveEverCrossedVBlank = TRUE;

            }
        }
        else //In display
        {
            if( ppdev->flipRecord.bHaveEverCrossedVBlank )
            {
                ppdev->flipRecord.bFlipFlag = FALSE;
                return(DD_OK);
            }
            ppdev->flipRecord.bWasEverInDisplay = TRUE;
        }

        EngQueryPerformanceCounter(&liTime);

        if (liTime - ppdev->flipRecord.liFlipTime
            <= ppdev->flipRecord.liFlipDuration)
        {
            return(DDERR_WASSTILLDRAWING);
        }
        ppdev->flipRecord.bFlipFlag = FALSE;
    }
    return(DD_OK);
}

/******************************Public*Routine******************************\
* DWORD DdBlt32M
*
\**************************************************************************/


DWORD DdBlt32M(
               PDD_BLTDATA lpBlt)
{
    HRESULT     ddrval;
    DWORD       destOffset;
    WORD        destPitch;
    WORD        destX;
    WORD        destXEnd;
    WORD        destY;
    WORD        destYEnd;
    WORD        direction;
    WORD        remainder;
    DWORD       dwFlags;
    WORD        height;
    RECTL       rDest;
    RECTL       rSrc;
    BYTE        rop;
    DWORD       sourceOffset;
    WORD        srcPitch;
    WORD        srcX;
    WORD        srcXEnd;
    WORD        srcY;
    WORD        srcYEnd;
    WORD        pitchAdjuster;
    WORD        sysPitch;
    PDD_SURFACE_LOCAL   srcSurfx;
    PDD_SURFACE_GLOBAL  srcSurf;
    PDD_SURFACE_LOCAL   destSurfx;
    PDD_SURFACE_GLOBAL  destSurf;
    PDEV*           ppdev;
    BYTE*           pjMmBase;

    ppdev           = (PDEV*) lpBlt->lpDD->dhpdev;
    pjMmBase    = ppdev->pjMmBase;

    destSurfx       = lpBlt->lpDDDestSurface;
    destSurf    = destSurfx->lpGbl;
    sysPitch    = (WORD)ppdev->lDelta;
    pitchAdjuster = (WORD)(ppdev->cBitsPerPel) /8;
    /*
    * is a flip in progress?
    */
    ddrval = vUpdateFlipStatus32M(ppdev, destSurf->fpVidMem );
    if( ddrval != DD_OK )
    {
        lpBlt->ddRVal = ddrval;
        return DDHAL_DRIVER_HANDLED;
    }

    /*
    * If async, then only work if bltter isn't busy
    * This should probably be a little more specific to each call, but
    * waiting for 16 is pretty close
    */
    dwFlags = lpBlt->dwFlags;
    if( dwFlags & DDBLT_ASYNC )
    {
        if( M32_FIFO_SPACE_AVAIL(ppdev, pjMmBase, 16 ))
        {
            lpBlt->ddRVal = DDERR_WASSTILLDRAWING;
            return DDHAL_DRIVER_HANDLED;
        }
    }

    /*
    * copy src/dest rects
    */
    rDest = lpBlt->rDest;

    destX     = (WORD)rDest.left;
    destXEnd  = (WORD)rDest.right;
    destY     = (WORD)rDest.top;
    destYEnd  = (WORD)rDest.bottom;
    destPitch = (WORD)destSurf->lPitch;
    destOffset   = (DWORD)(destSurf->fpVidMem) ;

    if (!(dwFlags & DDBLT_ROP))
    {
        if( dwFlags & DDBLT_COLORFILL )
        {
            {
                M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 9);
                CONVERT_DEST_TO_ZERO_BASE_REFERENCE(destSurf);

                M32_OW( pjMmBase,DP_CONFIG,COLOR_FIL_BLT);
                M32_OW( pjMmBase,ALU_FG_FN,MIX_FN_S);
                M32_OW( pjMmBase, FRGD_COLOR,(WORD)lpBlt->bltFX.dwFillColor);
                SET_DEST_BLT(destX,destY,destXEnd,destYEnd);
            }

            lpBlt->ddRVal = DD_OK;
            return DDHAL_DRIVER_HANDLED;
        }
        else
        {
            return DDHAL_DRIVER_NOTHANDLED;
        }

    }

    //
    // Must be a SRCCOPY ROP if ew get here....
    //
    srcSurfx = lpBlt->lpDDSrcSurface;
    if (lpBlt->lpDDSrcSurface)
    {
        srcSurf   = srcSurfx->lpGbl;
        rSrc      = lpBlt->rSrc;
        srcX      = (WORD)rSrc.left;
        srcXEnd   = (WORD)rSrc.right;
        srcY      = (WORD)rSrc.top;
        srcYEnd   = (WORD)rSrc.bottom;
        srcPitch  = (WORD)srcSurf->lPitch;
        sourceOffset = (DWORD)(srcSurf->fpVidMem) ;

        direction = TOP_TO_BOTTOM;
        if (    (destSurf == srcSurf)
            && (srcXEnd  > destX)
            && (srcYEnd  > destY)
            && (destXEnd > srcX)
            && (destYEnd > srcY)
            && (
            ((srcY == destY) && (destX > srcX) )
            || ((srcY != destY) && (destY > srcY) )
            )
            )
        {
            direction = BOTTOM_TO_TOP;
            srcX      = (WORD)rSrc.right;
            srcXEnd   = (WORD)rSrc.left;
            srcY      = (WORD)rSrc.bottom-1;
            destX     = (WORD)rDest.right;
            destXEnd  = (WORD)rDest.left;
            destY     = (WORD)rDest.bottom-1;
            destYEnd  = (WORD)rDest.top-1;
        }
    }

    /*
    * get offset, width, and height for source
    */
    rop = (BYTE) (lpBlt->bltFX.dwROP >> 16);

    if( dwFlags & DDBLT_ROP )
    {
        if (rop == (SRCCOPY >> 16))
        {   // Transparent BLT
            if ( dwFlags & DDBLT_KEYDESTOVERRIDE )
            {
                CONVERT_SOURCE_TO_ZERO_BASE_REFERENCE(srcSurf);
                CONVERT_DEST_TO_ZERO_BASE_REFERENCE(destSurf);

                M32_CHECK_FIFO_SPACE(ppdev, pjMmBase,10);
                M32_OW( pjMmBase, DP_CONFIG, VID_MEM_BLT);
                M32_OW( pjMmBase, ALU_FG_FN, MIX_FN_S);
                M32_OW( pjMmBase, SRC_Y_DIR, direction);
                M32_OW( pjMmBase, MULTIFUNC_CNTL, PIXEL_CTRL | DEST_NOT_EQ_COLOR_CMP );
                M32_OW( pjMmBase, CMP_COLOR, lpBlt->bltFX.ddckDestColorkey.dwColorSpaceLowValue );

                SET_SOURCE_BLT(srcX,srcY,srcXEnd);

                M32_CHECK_FIFO_SPACE(ppdev, pjMmBase,10);
                SET_DEST_BLT(destX,destY,destXEnd,destYEnd);
//new
                RESET_BLT_OFFSET();
                M32_OW(pjMmBase, MULTIFUNC_CNTL,PIXEL_CTRL | DEST_ALWAY_OVERWRITE);
            }
            else
            {   // Not transparent

                CONVERT_DEST_TO_ZERO_BASE_REFERENCE(destSurf);
                CONVERT_SOURCE_TO_ZERO_BASE_REFERENCE(srcSurf);

                M32_CHECK_FIFO_SPACE(ppdev, pjMmBase,12);
                M32_OW( pjMmBase, DP_CONFIG,VID_MEM_BLT);
                M32_OW( pjMmBase, ALU_FG_FN,MIX_FN_S);
                M32_OW( pjMmBase, SRC_Y_DIR,direction);

                SET_SOURCE_BLT(srcX,srcY,srcXEnd);
                SET_DEST_BLT(destX,destY,destXEnd,destYEnd);
            }
        }
    }
    else
        return DDHAL_DRIVER_NOTHANDLED;

    lpBlt->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;

}
/******************************Public*Routine******************************\
* DWORD DdFlip32
*
\**************************************************************************/

DWORD DdFlip32M(
                PDD_FLIPDATA lpFlip)
{
    PDEV*       ppdev;
    BYTE*       pjMmBase;
    HRESULT     ddrval;
    WORD        highVidMem;
    WORD        lowVidMem;
    ULONG       ulMemoryOffset;

    ppdev    = (PDEV*) lpFlip->lpDD->dhpdev;
    pjMmBase = ppdev->pjMmBase;

    // Is the current flip still in progress?
    //
    // Don't want a flip to work until after the last flip is done,
    // so we ask for the general flip status and ignore the vmem.

    ddrval = vUpdateFlipStatus32M(ppdev, 0);

    if ((ddrval != DD_OK) || (M32_DRAW_ENGINE_BUSY( ppdev,pjMmBase)))
    {
        lpFlip->ddRVal = DDERR_WASSTILLDRAWING;
        return(DDHAL_DRIVER_HANDLED);
    }

    ulMemoryOffset = (ULONG)(lpFlip->lpSurfTarg->lpGbl->fpVidMem >> 2);

    // Make sure that the border/blanking period isn't active; wait if
    // it is.  We could return DDERR_WASSTILLDRAWING in this case, but
    // that will increase the odds that we can't flip the next time:
    while (inVBlank(ppdev, pjMmBase))
        ;

    // Do the flip

    highVidMem = M32_IW(pjMmBase,CRT_OFFSET_HI) & 0xfffc |  (WORD)(ulMemoryOffset >>16);
    lowVidMem  = (WORD)(ulMemoryOffset & 0xffff);
    if (inVBlank( ppdev, pjMmBase))
    {
        lpFlip->ddRVal = DDERR_WASSTILLDRAWING;
        return DDHAL_DRIVER_HANDLED;
    }

    M32_CHECK_FIFO_SPACE(ppdev, pjMmBase,2);
    M32_OW_DIRECT( pjMmBase,CRT_OFFSET_HI, highVidMem);
    M32_OW_DIRECT( pjMmBase,CRT_OFFSET_LO, lowVidMem);


    // Remember where and when we were when we did the flip:

    EngQueryPerformanceCounter(&ppdev->flipRecord.liFlipTime);

    ppdev->flipRecord.bFlipFlag              = TRUE;
    ppdev->flipRecord.bHaveEverCrossedVBlank = FALSE;
    ppdev->flipRecord.bWasEverInDisplay      = FALSE;

    ppdev->flipRecord.fpFlipFrom = lpFlip->lpSurfCurr->lpGbl->fpVidMem;

    if( inVBlank( ppdev, pjMmBase) )
    {
        ppdev->flipRecord.wFlipScanLine = 0;
    }
    else
    {
        ppdev->flipRecord.wFlipScanLine = currentScanLine(pjMmBase);
    }

    lpFlip->ddRVal = DD_OK;

    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdLock32M
*
\**************************************************************************/

DWORD DdLock32M(
                PDD_LOCKDATA lpLock)
{
    PDEV*   ppdev;
    HRESULT ddrval;

    ppdev = (PDEV*) lpLock->lpDD->dhpdev;
    // Check to see if any pending physical flip has occurred.
    // Don't allow a lock if a blt is in progress:

    ddrval = vUpdateFlipStatus32M(ppdev, lpLock->lpDDSurface->lpGbl->fpVidMem);

    if (ddrval != DD_OK)
    {
        lpLock->ddRVal = DDERR_WASSTILLDRAWING;
        return(DDHAL_DRIVER_HANDLED);
    }

    // Here's one of the places where the Windows 95 and Windows NT DirectDraw
    // implementations differ: on Windows NT, you should watch for
    // DDLOCK_WAIT and loop in the driver while the accelerator is busy.
    // On Windows 95, it doesn't really matter.
    //
    // (The reason is that Windows NT allows applications to draw directly
    // to the frame buffer even while the accelerator is running, and does
    // not synchronize everything on the Win16Lock.  Note that on Windows NT,
    // it is even possible for multiple threads to be holding different
    // DirectDraw surface locks at the same time.)

    if (lpLock->dwFlags & DDLOCK_WAIT)
    {

        do {} while (M32_DRAW_ENGINE_BUSY(ppdev, ppdev->pjMmBase));
    }
    else if (M32_DRAW_ENGINE_BUSY(ppdev, ppdev->pjMmBase))
    {
        lpLock->ddRVal = DDERR_WASSTILLDRAWING;
        return(DDHAL_DRIVER_HANDLED);
    }

    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdGetBltStatus32M
*
* Doesn't currently really care what surface is specified, just checks
* and goes.
*
\**************************************************************************/

DWORD DdGetBltStatus32M(
                        PDD_GETBLTSTATUSDATA lpGetBltStatus)
{
    PDEV*   ppdev;
    HRESULT ddRVal;

    ppdev = (PDEV*) lpGetBltStatus->lpDD->dhpdev;

    ddRVal = DD_OK;
    if (lpGetBltStatus->dwFlags == DDGBS_CANBLT)
    {
        // DDGBS_CANBLT case: can we add a blt?

        ddRVal = vUpdateFlipStatus32M(ppdev,
            lpGetBltStatus->lpDDSurface->lpGbl->fpVidMem);

        if (ddRVal == DD_OK)
        {
            // There was no flip going on, so is there room in the FIFO
            // to add a blt?

            if (M32_FIFO_SPACE_AVAIL(ppdev,ppdev->pjMmBase,15))  // Should match DdBlt//XXX
            {
                ddRVal = DDERR_WASSTILLDRAWING;
            }
        }
    }
    else
    {
        // DDGBS_ISBLTDONE case: is a blt in progress?

        if (M32_DRAW_ENGINE_BUSY( ppdev,ppdev->pjMmBase))
        {
            ddRVal = DDERR_WASSTILLDRAWING;
        }
    }

    lpGetBltStatus->ddRVal = ddRVal;
    return(DDHAL_DRIVER_HANDLED);
}
/******************************Public*Routine******************************\
* DWORD DdGetFlipStatus32M
*
* If the display has gone through one refresh cycle since the flip
* occurred, we return DD_OK.  If it has not gone through one refresh
* cycle we return DDERR_WASSTILLDRAWING to indicate that this surface
* is still busy "drawing" the flipped page.   We also return
* DDERR_WASSTILLDRAWING if the bltter is busy and the caller wanted
* to know if they could flip yet.
*
\**************************************************************************/

DWORD DdGetFlipStatus32M(
                         PDD_GETFLIPSTATUSDATA lpGetFlipStatus)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) lpGetFlipStatus->lpDD->dhpdev;

    // We don't want a flip to work until after the last flip is done,
    // so we ask for the general flip status and ignore the vmem:

    lpGetFlipStatus->ddRVal = vUpdateFlipStatus32M(ppdev, 0);

    // Check if the bltter is busy if someone wants to know if they can
    // flip:

    if (lpGetFlipStatus->dwFlags == DDGFS_CANFLIP)
    {
        if ((lpGetFlipStatus->ddRVal == DD_OK) && (M32_DRAW_ENGINE_BUSY( ppdev,ppdev->pjMmBase)))
        {
            lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
        }
    }

    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdWaitForVerticalBlank32M
*
\**************************************************************************/

DWORD DdWaitForVerticalBlank32M(
                                PDD_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank)
{
    PDEV*   ppdev;
    BYTE*   pjMmBase;

    ppdev    = (PDEV*) lpWaitForVerticalBlank->lpDD->dhpdev;
    pjMmBase = ppdev->pjMmBase;

    lpWaitForVerticalBlank->ddRVal = DD_OK;

    switch (lpWaitForVerticalBlank->dwFlags)
    {
    case DDWAITVB_I_TESTVB:

        // If TESTVB, it's just a request for the current vertical blank
        // status:

        if (inVBlank( ppdev,pjMmBase))
            lpWaitForVerticalBlank->bIsInVB = TRUE;
        else
            lpWaitForVerticalBlank->bIsInVB = FALSE;

        return(DDHAL_DRIVER_HANDLED);

    case DDWAITVB_BLOCKBEGIN:

        // If BLOCKBEGIN is requested, we wait until the vertical blank
        // is over, and then wait for the display period to end:

        while (inVBlank( ppdev,pjMmBase))
            ;
        while (!inVBlank( ppdev,pjMmBase))
            ;

        return(DDHAL_DRIVER_HANDLED);

    case DDWAITVB_BLOCKEND:

        // If BLOCKEND is requested, we wait for the vblank interval to end:

        while (!(inVBlank( ppdev,pjMmBase)))
            ;
        while (inVBlank( ppdev,pjMmBase))
            ;

        return(DDHAL_DRIVER_HANDLED);
    }

    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdGetScanLine32M
*
\**************************************************************************/

DWORD DdGetScanLine32M(
PDD_GETSCANLINEDATA lpGetScanLine)
{
    PDEV*   ppdev;
    BYTE*   pjMmBase;

    ppdev    = (PDEV*) lpGetScanLine->lpDD->dhpdev;
    pjMmBase = ppdev->pjMmBase;

    lpGetScanLine->dwScanLine = M32_CURRENT_VLINE(pjMmBase);
    lpGetScanLine->ddRVal = DD_OK;

    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* BOOL DrvGetDirectDrawInfo32M
*
* Will be called before DrvEnableDirectDraw is called.
*
\**************************************************************************/

BOOL DrvGetDirectDrawInfo32M(
                             DHPDEV          dhpdev,
                             DD_HALINFO*     pHalInfo,
                             DWORD*          pdwNumHeaps,
                             VIDEOMEMORY*    pvmList,            // Will be NULL on first call
                             DWORD*          pdwNumFourCC,
                             DWORD*          pdwFourCC)          // Will be NULL on first call
{
    BOOL        bCanFlip;
    PDEV*       ppdev;
    LONGLONG    li;
    OH          *poh;
    DWORD       i;

    ppdev = (PDEV*) dhpdev;

    DISPDBG((10,"DrvGetDirectDrawInfo M32"));

    pHalInfo->dwSize = sizeof(*pHalInfo);

    // Current primary surface attributes:

    pHalInfo->vmiData.pvPrimary       = ppdev->pjScreen;
    pHalInfo->vmiData.dwDisplayWidth  = ppdev->cxScreen;
    pHalInfo->vmiData.dwDisplayHeight = ppdev->cyScreen;
    pHalInfo->vmiData.lDisplayPitch   = ppdev->lDelta;

    pHalInfo->vmiData.ddpfDisplay.dwSize  = sizeof(DDPIXELFORMAT);
    pHalInfo->vmiData.ddpfDisplay.dwFlags = DDPF_RGB;

    pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount = ppdev->cBitsPerPel;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        pHalInfo->vmiData.ddpfDisplay.dwFlags |= DDPF_PALETTEINDEXED8;
    }

    // These masks will be zero at 8bpp:

    pHalInfo->vmiData.ddpfDisplay.dwRBitMask = ppdev->flRed;
    pHalInfo->vmiData.ddpfDisplay.dwGBitMask = ppdev->flGreen;
    pHalInfo->vmiData.ddpfDisplay.dwBBitMask = ppdev->flBlue;

    // We can't do any accelerations on the Mach32 above 16bpp -- the only
    // DirectDraw support we can provide is direct frame buffer access.

    if (ppdev->iBitmapFormat < BMF_24BPP)
    {
        // Set up the pointer to the first available video memory after
        // the primary surface:

        bCanFlip = FALSE;

        // Free up as much off-screen memory as possible:

        bMoveAllDfbsFromOffscreenToDibs(ppdev);

        // Now simply reserve the biggest chunks for use by DirectDraw:

        poh = ppdev->pohDirectDraw;

        if (poh == NULL)
        {
            poh = pohAllocate(ppdev,
                NULL,
                ppdev->heap.cxMax,
                ppdev->heap.cyMax,
                FLOH_MAKE_PERMANENT);

            ppdev->pohDirectDraw = poh;

        }

        // this will work as is if using the NT common 2-d heap code.

        if (poh != NULL)
        {
            *pdwNumHeaps = 1;

            // Check to see if we can allocate memory to the right of the visible
            // surface.
            // Fill in the list of off-screen rectangles if we've been asked
            // to do so:

            if (pvmList != NULL)
            {
                DISPDBG((10, "DirectDraw gets %li x %li surface at (%li, %li)",
                    poh->cx, poh->cy, poh->x, poh->y));

                pvmList->dwFlags        = VIDMEM_ISRECTANGULAR;
                pvmList->fpStart        = (poh->y * ppdev->lDelta)
                    + (poh->x * ppdev->cjPelSize);
                pvmList->dwWidth        = poh->cx * ppdev->cjPelSize;
                pvmList->dwHeight       = poh->cy;
                pvmList->ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
                if ((DWORD) ppdev->cyScreen <= pvmList->dwHeight)
                {
                    bCanFlip = TRUE;
                }
                DISPDBG((10,"CanFlip = %d", bCanFlip));
            }
        }

        pHalInfo->ddCaps.dwCaps = DDCAPS_BLT
                                | DDCAPS_COLORKEY
                                | DDCAPS_BLTCOLORFILL
                                | DDCAPS_READSCANLINE;

        pHalInfo->ddCaps.dwCKeyCaps = 0;

        pHalInfo->ddCaps.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN
                                        | DDSCAPS_PRIMARYSURFACE;
        if (bCanFlip)
        {
            pHalInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_FLIP;
        }
    }
    else
    {
        pHalInfo->ddCaps.dwCaps = DDCAPS_READSCANLINE;
    }

    // dword alignment must be guaranteed for off-screen surfaces:

    pHalInfo->vmiData.dwOffscreenAlign = 8;

    DISPDBG((10,"DrvGetDirectDrawInfo exit"));
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\ddraw32i.c ===
/******************************Module*Header*******************************\
* Module Name: ddraw32I.c
*
* Implements all the DirectDraw components for the MACH 32 I/O driver.
*
* Copyright (c) 1995-1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

// NT is kind enough to pre-calculate the 2-d surface offset as a 'hint' so
// that we don't have to do the following, which would be 6 DIVs per blt:
//
//    y += (offset / pitch)
//    x += (offset % pitch) / bytes_per_pixel

#define convertToGlobalCord(x, y, surf) \
{                                       \
    y += (WORD)surf->yHint;             \
    x += (WORD)surf->xHint;             \
}

#define I32_CURRENT_VLINE(pjIoBase)  ((I32_IW(pjIoBase,VERT_LINE_CNTR) & 0x7ff))

//#define IN_VSYNC       ((I32_IW(pjIoBase,DISP_STATUS) & V_SYNC_TOGGLE_BIT) ^ syncToggleSide)


#define I32_WAIT_FOR_IDLE() \
{ \
    while (    I32_FIFO_SPACE_AVAIL(ppdev, pjIoBase, 16) \
    || (I32_IW(pjIoBase,GE_STAT) & GE_BUSY) \
    || (I32_IW(pjIoBase,EXT_GE_STATUS) & GE_ACTIVE) \
    )\
    ;\
}


#define SET_BLT_OFFSET(load,offset,pitch)\
{ \
    offset   >>=  2;\
    I32_OB( pjIoBase,SHADOW_SET+1,load); \
    I32_OW( pjIoBase,GE_OFFSET_HI,(WORD)((offset >> 16) & 0x000f));\
    I32_OW( pjIoBase,GE_OFFSET_LO,(WORD)(offset & 0xffff));\
    I32_OW( pjIoBase,GE_PITCH,(WORD)((pitch / pitchAdjuster) >> 3));\
}

#define SET_BLT_SOURCE_OFFSET(offset,pitch) SET_BLT_OFFSET(LOAD_SOURCE,offset,pitch)
#define SET_BLT_DEST_OFFSET(offset,pitch)   SET_BLT_OFFSET(LOAD_DEST,offset,pitch)


#define RESET_BLT_OFFSET()\
{ \
    I32_WAIT_FOR_IDLE(); \
    I32_OB( pjIoBase,SHADOW_SET+1, LOAD_SOURCE_AND_DEST);\
    I32_OW( pjIoBase,GE_OFFSET_HI, 0);\
    I32_OW( pjIoBase,GE_OFFSET_LO,0);\
    I32_OW( pjIoBase,GE_PITCH,(WORD)((sysPitch / pitchAdjuster) >> 3));\
}


#define SET_SOURCE_BLT(startX,startY,endX)\
{\
    I32_OW( pjIoBase, M32_SRC_X, startX);\
    I32_OW( pjIoBase, M32_SRC_Y, startY);\
    \
    I32_OW( pjIoBase, M32_SRC_X_START,startX);\
    I32_OW( pjIoBase, M32_SRC_X_END, endX);\
}

#define SET_DEST_BLT(startX,startY,endX,endY)\
{ \
    I32_OW( pjIoBase, CUR_X,startX); \
    I32_OW( pjIoBase, CUR_Y,startY); \
    \
    I32_OW( pjIoBase, DEST_X_START,startX);\
    I32_OW( pjIoBase, DEST_X_END,endX);\
    I32_OW( pjIoBase, DEST_Y_END,endY);\
}
// NT is kind enough to pre-calculate the 2-d surface offset as a 'hint' so
// that we don't have to do the following, which would be 6 DIVs per blt:
//
//    y += (offset / pitch)
//    x += (offset % pitch) / bytes_per_pixel


#define CONVERT_DEST_TO_ZERO_BASE_REFERENCE(surf)\
{\
    convertToGlobalCord(destX, destY, surf);\
    convertToGlobalCord(destXEnd, destYEnd, surf);\
}

#define CONVERT_SOURCE_TO_ZERO_BASE_REFERENCE(surf)\
{\
    convertToGlobalCord(srcX, srcY, surf);\
    convertToGlobalCord(srcXEnd, srcYEnd, surf);\
}

#define I32_DRAW_ENGINE_BUSY(ppdev, pjIoBase)  ( \
    I32_FIFO_SPACE_AVAIL(ppdev, pjIoBase, 16 ) \
    || (I32_IW(pjIoBase,GE_STAT) & GE_BUSY ) \
    || (I32_IW(pjIoBase,EXT_GE_STATUS) & GE_ACTIVE) \
)
/*
* currentScanLine
* safe get current scan line
*/
static __inline int currentScanLine(BYTE* pjIoBase)
{
    WORD lastValue    = I32_CURRENT_VLINE(pjIoBase);
    WORD currentValue = I32_CURRENT_VLINE(pjIoBase);

    while (lastValue != currentValue)
    {
        lastValue = currentValue;
        currentValue = I32_CURRENT_VLINE(pjIoBase);
    }

    return currentValue;
}

static __inline inVBlank(PDEV* ppdev, BYTE* pjIoBase)
{

    int temp;
    temp = currentScanLine(pjIoBase);
    return ((temp >= ppdev->flipRecord.wstartOfVBlank- 15) || temp < 15);
}


/******************************Public*Routine******************************\
* VOID vGetDisplayDuration32I
*
* Get the length, in EngQueryPerformanceCounter() ticks, of a refresh cycle.
*
* If we could trust the miniport to return back and accurate value for
* the refresh rate, we could use that.  Unfortunately, our miniport doesn't
* ensure that it's an accurate value.
*
\**************************************************************************/

#define NUM_VBLANKS_TO_MEASURE      1
#define NUM_MEASUREMENTS_TO_TAKE    8

VOID vGetDisplayDuration32I(PDEV* ppdev)
{
    BYTE*       pjIoBase;
    LONG        i;
    LONG        j;
    LONGLONG    li;
    LONGLONG    liMin;
    LONGLONG    aliMeasurement[NUM_MEASUREMENTS_TO_TAKE + 1];

    pjIoBase = ppdev->pjIoBase;


    ppdev->flipRecord.wstartOfVBlank = I32_IW(pjIoBase, R_V_DISP);

    // Warm up EngQUeryPerformanceCounter to make sure it's in the working
    // set:

    EngQueryPerformanceCounter(&li);

    // Unfortunately, since NT is a proper multitasking system, we can't
    // just disable interrupts to take an accurate reading.  We also can't
    // do anything so goofy as dynamically change our thread's priority to
    // real-time.
    //
    // So we just do a bunch of short measurements and take the minimum.
    //
    // It would be 'okay' if we got a result that's longer than the actual
    // VBlank cycle time -- nothing bad would happen except that the app
    // would run a little slower.  We don't want to get a result that's
    // shorter than the actual VBlank cycle time -- that could cause us
    // to start drawing over a frame before the Flip has occured.

    while (inVBlank( ppdev, pjIoBase))
        ;

    while (!(inVBlank( ppdev, pjIoBase)))
        ;

    for (i = 0; i < NUM_MEASUREMENTS_TO_TAKE; i++)
    {
        // We're at the start of the VBlank active cycle!

        EngQueryPerformanceCounter(&aliMeasurement[i]);

        // Okay, so life in a multi-tasking environment isn't all that
        // simple.  What if we had taken a context switch just before
        // the above EngQueryPerformanceCounter call, and now were half
        // way through the VBlank inactive cycle?  Then we would measure
        // only half a VBlank cycle, which is obviously bad.  The worst
        // thing we can do is get a time shorter than the actual VBlank
        // cycle time.
        //
        // So we solve this by making sure we're in the VBlank active
        // time before and after we query the time.  If it's not, we'll
        // sync up to the next VBlank (it's okay to measure this period --
        // it will be guaranteed to be longer than the VBlank cycle and
        // will likely be thrown out when we select the minimum sample).
        // There's a chance that we'll take a context switch and return
        // just before the end of the active VBlank time -- meaning that
        // the actual measured time would be less than the true amount --
        // but since the VBlank is active less than 1% of the time, this
        // means that we would have a maximum of 1% error approximately
        // 1% of the times we take a context switch.  An acceptable risk.
        //
        // This next line will cause us wait if we're no longer in the
        // VBlank active cycle as we should be at this point:

        while (!(inVBlank( ppdev, pjIoBase)))
            ;

        for (j = 0; j < NUM_VBLANKS_TO_MEASURE; j++)
        {
            while (inVBlank( ppdev, pjIoBase))
                ;
            while (!(inVBlank( ppdev, pjIoBase)))
                ;
        }
    }

    EngQueryPerformanceCounter(&aliMeasurement[NUM_MEASUREMENTS_TO_TAKE]);

    // Use the minimum:

    liMin = aliMeasurement[1] - aliMeasurement[0];

    DISPDBG((10, "Refresh count: %li - %li", 1, (ULONG) liMin));

    for (i = 2; i <= NUM_MEASUREMENTS_TO_TAKE; i++)
    {
        li = aliMeasurement[i] - aliMeasurement[i - 1];

        DISPDBG((10, "               %li - %li", i, (ULONG) li));

        if (li < liMin)
            liMin = li;
    }

    // Round the result:

    ppdev->flipRecord.liFlipDuration
        = (DWORD) (liMin + (NUM_VBLANKS_TO_MEASURE / 2)) / NUM_VBLANKS_TO_MEASURE;

    DISPDBG((10, "Frequency %li.%03li Hz",
        (ULONG) (EngQueryPerformanceFrequency(&li),
        li / ppdev->flipRecord.liFlipDuration),
        (ULONG) (EngQueryPerformanceFrequency(&li),
        ((li * 1000) / ppdev->flipRecord.liFlipDuration) % 1000)));

    ppdev->flipRecord.liFlipTime = aliMeasurement[NUM_MEASUREMENTS_TO_TAKE];
    ppdev->flipRecord.bFlipFlag  = FALSE;
    ppdev->flipRecord.fpFlipFrom = 0;
}

/******************************Public*Routine******************************\
* HRESULT vUpdateFlipStatus32I
*
* Checks and sees if the most recent flip has occurred.
*
\**************************************************************************/

HRESULT vUpdateFlipStatus32I(
                             PDEV*   ppdev,
                             FLATPTR fpVidMem)
{
    BYTE*       pjIoBase;
    LONGLONG    liTime;

    pjIoBase = ppdev->pjIoBase;

    if ((ppdev->flipRecord.bFlipFlag) &&
        ((fpVidMem == 0) || (fpVidMem == ppdev->flipRecord.fpFlipFrom)))
    {
        if (inVBlank( ppdev, pjIoBase))
        {
            if (ppdev->flipRecord.bWasEverInDisplay)
            {
                ppdev->flipRecord.bHaveEverCrossedVBlank = TRUE;

            }
        }
        else //In display
        {
            if( ppdev->flipRecord.bHaveEverCrossedVBlank )
            {
                ppdev->flipRecord.bFlipFlag = FALSE;
                return(DD_OK);
            }
            ppdev->flipRecord.bWasEverInDisplay = TRUE;
        }

        EngQueryPerformanceCounter(&liTime);

        if (liTime - ppdev->flipRecord.liFlipTime
            <= ppdev->flipRecord.liFlipDuration)
        {
            return(DDERR_WASSTILLDRAWING);
        }
        ppdev->flipRecord.bFlipFlag = FALSE;
    }
    return(DD_OK);
}

/******************************Public*Routine******************************\
* DWORD DdBlt32I
*
\**************************************************************************/


DWORD DdBlt32I(
               PDD_BLTDATA lpBlt)
{
    HRESULT     ddrval;
    DWORD       destOffset;
    WORD        destPitch;
    WORD        destX;
    WORD        destXEnd;
    WORD        destY;
    WORD        destYEnd;
    WORD        direction;
    WORD        remainder;
    DWORD       dwFlags;
    WORD        height;
    RECTL       rDest;
    RECTL       rSrc;
    BYTE        rop;
    DWORD       sourceOffset;
    WORD        srcPitch;
    WORD        srcX;
    WORD        srcXEnd;
    WORD        srcY;
    WORD        srcYEnd;
    WORD        pitchAdjuster;
    WORD        sysPitch;
    PDD_SURFACE_LOCAL   srcSurfx;
    PDD_SURFACE_GLOBAL  srcSurf;
    PDD_SURFACE_LOCAL   destSurfx;
    PDD_SURFACE_GLOBAL  destSurf;
    PDEV*           ppdev;
    BYTE*           pjIoBase;

    ppdev           = (PDEV*) lpBlt->lpDD->dhpdev;
    pjIoBase    = ppdev->pjIoBase;

    destSurfx       = lpBlt->lpDDDestSurface;
    destSurf    = destSurfx->lpGbl;
    sysPitch    = (WORD)ppdev->lDelta;
    pitchAdjuster = (WORD)(ppdev->cBitsPerPel) /8;
    /*
    * is a flip in progress?
    */
    ddrval = vUpdateFlipStatus32I(ppdev, destSurf->fpVidMem );
    if( ddrval != DD_OK )
    {
        lpBlt->ddRVal = ddrval;
        return DDHAL_DRIVER_HANDLED;
    }

    /*
    * If async, then only work if bltter isn't busy
    * This should probably be a little more specific to each call, but
    * waiting for 16 is pretty close
    */
    dwFlags = lpBlt->dwFlags;
    if( dwFlags & DDBLT_ASYNC )
    {
        if( I32_FIFO_SPACE_AVAIL(ppdev, pjIoBase, 16 ))
        {
            lpBlt->ddRVal = DDERR_WASSTILLDRAWING;
            return DDHAL_DRIVER_HANDLED;
        }
    }

    /*
    * copy src/dest rects
    */
    rDest = lpBlt->rDest;

    destX     = (WORD)rDest.left;
    destXEnd  = (WORD)rDest.right;
    destY     = (WORD)rDest.top;
    destYEnd  = (WORD)rDest.bottom;
    destPitch = (WORD)destSurf->lPitch;
    destOffset   = (DWORD)(destSurf->fpVidMem) ;

    if (!(dwFlags & DDBLT_ROP))
    {
        if( dwFlags & DDBLT_COLORFILL )
        {
            {
                I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 9);
                CONVERT_DEST_TO_ZERO_BASE_REFERENCE(destSurf);

                I32_OW( pjIoBase,DP_CONFIG,COLOR_FIL_BLT);
                I32_OW( pjIoBase,ALU_FG_FN,MIX_FN_S);
                I32_OW( pjIoBase, FRGD_COLOR,(WORD)lpBlt->bltFX.dwFillColor);
                SET_DEST_BLT(destX,destY,destXEnd,destYEnd);
            }

            lpBlt->ddRVal = DD_OK;
            return DDHAL_DRIVER_HANDLED;
        }
        else
        {
            return DDHAL_DRIVER_NOTHANDLED;
        }

    }

    //
    // Must be a SRCCOPY ROP if ew get here....
    //
    srcSurfx = lpBlt->lpDDSrcSurface;
    if (lpBlt->lpDDSrcSurface)
    {
        srcSurf   = srcSurfx->lpGbl;
        rSrc      = lpBlt->rSrc;
        srcX      = (WORD)rSrc.left;
        srcXEnd   = (WORD)rSrc.right;
        srcY      = (WORD)rSrc.top;
        srcYEnd   = (WORD)rSrc.bottom;
        srcPitch  = (WORD)srcSurf->lPitch;
        sourceOffset = (DWORD)(srcSurf->fpVidMem) ;

        direction = TOP_TO_BOTTOM;
        if (    (destSurf == srcSurf)
            && (srcXEnd  > destX)
            && (srcYEnd  > destY)
            && (destXEnd > srcX)
            && (destYEnd > srcY)
            && (
            ((srcY == destY) && (destX > srcX) )
            || ((srcY != destY) && (destY > srcY) )
            )
            )
        {
            direction = BOTTOM_TO_TOP;
            srcX      = (WORD)rSrc.right;
            srcXEnd   = (WORD)rSrc.left;
            srcY      = (WORD)rSrc.bottom-1;
            destX     = (WORD)rDest.right;
            destXEnd  = (WORD)rDest.left;
            destY     = (WORD)rDest.bottom-1;
            destYEnd  = (WORD)rDest.top-1;
        }
    }

    /*
    * get offset, width, and height for source
    */
    rop = (BYTE) (lpBlt->bltFX.dwROP >> 16);

    if( dwFlags & DDBLT_ROP )
    {
        if (rop == (SRCCOPY >> 16))
        {   // Transparent BLT
            if ( dwFlags & DDBLT_KEYDESTOVERRIDE )
            {
                CONVERT_DEST_TO_ZERO_BASE_REFERENCE(destSurf);
                CONVERT_SOURCE_TO_ZERO_BASE_REFERENCE(srcSurf);
                I32_CHECK_FIFO_SPACE(ppdev, pjIoBase,12);

                I32_OW( pjIoBase, DP_CONFIG, VID_MEM_BLT);
                I32_OW( pjIoBase, ALU_FG_FN, MIX_FN_S);
                I32_OW( pjIoBase, SRC_Y_DIR, direction);
                I32_OW( pjIoBase, MULTIFUNC_CNTL, PIXEL_CTRL | DEST_NOT_EQ_COLOR_CMP );
                I32_OW( pjIoBase, CMP_COLOR, lpBlt->bltFX.ddckDestColorkey.dwColorSpaceLowValue );


                SET_SOURCE_BLT(srcX,srcY,srcXEnd);
                SET_DEST_BLT(destX,destY,destXEnd,destYEnd);
            }
            else
            {   // Not transparent
                CONVERT_DEST_TO_ZERO_BASE_REFERENCE(destSurf);
                CONVERT_SOURCE_TO_ZERO_BASE_REFERENCE(srcSurf);
                I32_CHECK_FIFO_SPACE(ppdev, pjIoBase,12);

                I32_OW( pjIoBase, DP_CONFIG,VID_MEM_BLT);
                I32_OW( pjIoBase, ALU_FG_FN,MIX_FN_S);
                I32_OW( pjIoBase, SRC_Y_DIR,direction);

                SET_SOURCE_BLT(srcX,srcY,srcXEnd);
                SET_DEST_BLT(destX,destY,destXEnd,destYEnd);
            }
        }
    }
    else
        return DDHAL_DRIVER_NOTHANDLED;

    lpBlt->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;

}
/******************************Public*Routine******************************\
* DWORD DdFlip32
*
\**************************************************************************/

DWORD DdFlip32I(
                PDD_FLIPDATA lpFlip)
{
    PDEV*       ppdev;
    BYTE*       pjIoBase;
    HRESULT     ddrval;
    WORD        highVidMem;
    WORD        lowVidMem;
    ULONG       ulMemoryOffset;

    ppdev    = (PDEV*) lpFlip->lpDD->dhpdev;
    pjIoBase = ppdev->pjIoBase;

    // Is the current flip still in progress?
    //
    // Don't want a flip to work until after the last flip is done,
    // so we ask for the general flip status and ignore the vmem.

    ddrval = vUpdateFlipStatus32I(ppdev, 0);

    if ((ddrval != DD_OK) || (I32_DRAW_ENGINE_BUSY( ppdev,pjIoBase)))
    {
        lpFlip->ddRVal = DDERR_WASSTILLDRAWING;
        return(DDHAL_DRIVER_HANDLED);
    }

    ulMemoryOffset = (ULONG)(lpFlip->lpSurfTarg->lpGbl->fpVidMem >> 2);

    // Make sure that the border/blanking period isn't active; wait if
    // it is.  We could return DDERR_WASSTILLDRAWING in this case, but
    // that will increase the odds that we can't flip the next time:
    while (inVBlank(ppdev, pjIoBase))
        ;

    // Do the flip

    highVidMem = I32_IW(pjIoBase,CRT_OFFSET_HI) & 0xfffc |  (WORD)(ulMemoryOffset >>16);
    lowVidMem  = (WORD)(ulMemoryOffset & 0xffff);
    if (inVBlank( ppdev, pjIoBase))
    {
        lpFlip->ddRVal = DDERR_WASSTILLDRAWING;
        return DDHAL_DRIVER_HANDLED;
    }

    I32_OW_DIRECT( pjIoBase,CRT_OFFSET_HI, highVidMem);
    I32_OW_DIRECT( pjIoBase,CRT_OFFSET_LO, lowVidMem);


    // Remember where and when we were when we did the flip:

    EngQueryPerformanceCounter(&ppdev->flipRecord.liFlipTime);

    ppdev->flipRecord.bFlipFlag              = TRUE;
    ppdev->flipRecord.bHaveEverCrossedVBlank = FALSE;
    ppdev->flipRecord.bWasEverInDisplay      = FALSE;

    ppdev->flipRecord.fpFlipFrom = lpFlip->lpSurfCurr->lpGbl->fpVidMem;

    if( inVBlank( ppdev, pjIoBase) )
    {
        ppdev->flipRecord.wFlipScanLine = 0;
    }
    else
    {
        ppdev->flipRecord.wFlipScanLine = currentScanLine(pjIoBase);
    }

    lpFlip->ddRVal = DD_OK;

    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdLock32I
*
\**************************************************************************/

DWORD DdLock32I(
                PDD_LOCKDATA lpLock)
{
    PDEV*   ppdev;
    HRESULT ddrval;

    ppdev = (PDEV*) lpLock->lpDD->dhpdev;
    // Check to see if any pending physical flip has occurred.
    // Don't allow a lock if a blt is in progress:

    ddrval = vUpdateFlipStatus32I(ppdev, lpLock->lpDDSurface->lpGbl->fpVidMem);

    if (ddrval != DD_OK)
    {
        lpLock->ddRVal = DDERR_WASSTILLDRAWING;
        return(DDHAL_DRIVER_HANDLED);
    }

    // Here's one of the places where the Windows 95 and Windows NT DirectDraw
    // implementations differ: on Windows NT, you should watch for
    // DDLOCK_WAIT and loop in the driver while the accelerator is busy.
    // On Windows 95, it doesn't really matter.
    //
    // (The reason is that Windows NT allows applications to draw directly
    // to the frame buffer even while the accelerator is running, and does
    // not synchronize everything on the Win16Lock.  Note that on Windows NT,
    // it is even possible for multiple threads to be holding different
    // DirectDraw surface locks at the same time.)

    if (lpLock->dwFlags & DDLOCK_WAIT)
    {
        do {} while (I32_DRAW_ENGINE_BUSY(ppdev, ppdev->pjIoBase));
    }
    else if (I32_DRAW_ENGINE_BUSY(ppdev, ppdev->pjIoBase))
    {
        lpLock->ddRVal = DDERR_WASSTILLDRAWING;
        return(DDHAL_DRIVER_HANDLED);
    }

    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdGetBltStatus32I
*
* Doesn't currently really care what surface is specified, just checks
* and goes.
*
\**************************************************************************/

DWORD DdGetBltStatus32I(
                        PDD_GETBLTSTATUSDATA lpGetBltStatus)
{
    PDEV*   ppdev;
    HRESULT ddRVal;

    ppdev = (PDEV*) lpGetBltStatus->lpDD->dhpdev;

    ddRVal = DD_OK;
    if (lpGetBltStatus->dwFlags == DDGBS_CANBLT)
    {
        // DDGBS_CANBLT case: can we add a blt?

        ddRVal = vUpdateFlipStatus32I(ppdev,
            lpGetBltStatus->lpDDSurface->lpGbl->fpVidMem);

        if (ddRVal == DD_OK)
        {
            // There was no flip going on, so is there room in the FIFO
            // to add a blt?

            if (I32_FIFO_SPACE_AVAIL(ppdev,ppdev->pjIoBase,12))  // Should match DdBlt//XXX
            {
                ddRVal = DDERR_WASSTILLDRAWING;
            }
        }
    }
    else
    {
        // DDGBS_ISBLTDONE case: is a blt in progress?

        if (I32_DRAW_ENGINE_BUSY( ppdev,ppdev->pjIoBase))
        {
            ddRVal = DDERR_WASSTILLDRAWING;
        }
    }

    lpGetBltStatus->ddRVal = ddRVal;
    return(DDHAL_DRIVER_HANDLED);
}
/******************************Public*Routine******************************\
* DWORD DdGetFlipStatus32I
*
* If the display has gone through one refresh cycle since the flip
* occurred, we return DD_OK.  If it has not gone through one refresh
* cycle we return DDERR_WASSTILLDRAWING to indicate that this surface
* is still busy "drawing" the flipped page.   We also return
* DDERR_WASSTILLDRAWING if the bltter is busy and the caller wanted
* to know if they could flip yet.
*
\**************************************************************************/

DWORD DdGetFlipStatus32I(
                         PDD_GETFLIPSTATUSDATA lpGetFlipStatus)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) lpGetFlipStatus->lpDD->dhpdev;

    // We don't want a flip to work until after the last flip is done,
    // so we ask for the general flip status and ignore the vmem:

    lpGetFlipStatus->ddRVal = vUpdateFlipStatus32I(ppdev, 0);

    // Check if the bltter is busy if someone wants to know if they can
    // flip:

    if (lpGetFlipStatus->dwFlags == DDGFS_CANFLIP)
    {
        if ((lpGetFlipStatus->ddRVal == DD_OK) && (I32_DRAW_ENGINE_BUSY( ppdev,ppdev->pjIoBase)))
        {
            lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
        }
    }

    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdWaitForVerticalBlank32I
*
\**************************************************************************/

DWORD DdWaitForVerticalBlank32I(
                                PDD_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank)
{
    PDEV*   ppdev;
    BYTE*   pjIoBase;

    ppdev    = (PDEV*) lpWaitForVerticalBlank->lpDD->dhpdev;
    pjIoBase = ppdev->pjIoBase;

    lpWaitForVerticalBlank->ddRVal = DD_OK;

    switch (lpWaitForVerticalBlank->dwFlags)
    {
    case DDWAITVB_I_TESTVB:

        // If TESTVB, it's just a request for the current vertical blank
        // status:

        if (inVBlank( ppdev,pjIoBase))
            lpWaitForVerticalBlank->bIsInVB = TRUE;
        else
            lpWaitForVerticalBlank->bIsInVB = FALSE;

        return(DDHAL_DRIVER_HANDLED);

    case DDWAITVB_BLOCKBEGIN:

        // If BLOCKBEGIN is requested, we wait until the vertical blank
        // is over, and then wait for the display period to end:

        while (inVBlank( ppdev,pjIoBase))
            ;
        while (!inVBlank( ppdev,pjIoBase))
            ;

        return(DDHAL_DRIVER_HANDLED);

    case DDWAITVB_BLOCKEND:

        // If BLOCKEND is requested, we wait for the vblank interval to end:

        while (!(inVBlank( ppdev,pjIoBase)))
            ;
        while (inVBlank( ppdev,pjIoBase))
            ;

        return(DDHAL_DRIVER_HANDLED);
    }

    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdGetScanLine32I
*
\**************************************************************************/

DWORD DdGetScanLine32I(
PDD_GETSCANLINEDATA lpGetScanLine)
{
    PDEV*   ppdev;
    BYTE*   pjIoBase;

    ppdev    = (PDEV*) lpGetScanLine->lpDD->dhpdev;
    pjIoBase = ppdev->pjIoBase;

    lpGetScanLine->dwScanLine = I32_CURRENT_VLINE(pjIoBase);
    lpGetScanLine->ddRVal = DD_OK;

    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* BOOL DrvGetDirectDrawInfo32I
*
* Will be called before DrvEnableDirectDraw is called.
*
\**************************************************************************/

BOOL DrvGetDirectDrawInfo32I(
                             DHPDEV          dhpdev,
                             DD_HALINFO*     pHalInfo,
                             DWORD*          pdwNumHeaps,
                             VIDEOMEMORY*    pvmList,            // Will be NULL on first call
                             DWORD*          pdwNumFourCC,
                             DWORD*          pdwFourCC)          // Will be NULL on first call
{
    BOOL        bCanFlip;
    PDEV*       ppdev;
    LONGLONG    li;
    OH          *poh;
    DWORD       i;

    ppdev = (PDEV*) dhpdev;

    DISPDBG((10,"DrvGetDirectDrawInfo I32"));

    pHalInfo->dwSize = sizeof(*pHalInfo);

    // Current primary surface attributes:

    pHalInfo->vmiData.pvPrimary       = ppdev->pjScreen;
    pHalInfo->vmiData.dwDisplayWidth  = ppdev->cxScreen;
    pHalInfo->vmiData.dwDisplayHeight = ppdev->cyScreen;
    pHalInfo->vmiData.lDisplayPitch   = ppdev->lDelta;

    pHalInfo->vmiData.ddpfDisplay.dwSize  = sizeof(DDPIXELFORMAT);
    pHalInfo->vmiData.ddpfDisplay.dwFlags = DDPF_RGB;

    pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount = ppdev->cBitsPerPel;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        pHalInfo->vmiData.ddpfDisplay.dwFlags |= DDPF_PALETTEINDEXED8;
    }

    // These masks will be zero at 8bpp:

    pHalInfo->vmiData.ddpfDisplay.dwRBitMask = ppdev->flRed;
    pHalInfo->vmiData.ddpfDisplay.dwGBitMask = ppdev->flGreen;
    pHalInfo->vmiData.ddpfDisplay.dwBBitMask = ppdev->flBlue;

    // We can't do any accelerations on the Mach32 above 16bpp -- the only
    // DirectDraw support we can provide is direct frame buffer access.

    if (ppdev->iBitmapFormat < BMF_24BPP)
    {
        // Set up the pointer to the first available video memory after
        // the primary surface:

        bCanFlip = FALSE;

        // Free up as much off-screen memory as possible:

        bMoveAllDfbsFromOffscreenToDibs(ppdev);

        // Now simply reserve the biggest chunks for use by DirectDraw:

        poh = ppdev->pohDirectDraw;

        if (poh == NULL)
        {
            poh = pohAllocate(ppdev,
                NULL,
                ppdev->heap.cxMax,
                ppdev->heap.cyMax,
                FLOH_MAKE_PERMANENT);

            ppdev->pohDirectDraw = poh;

        }

        // this will work as is if using the NT common 2-d heap code.

        if (poh != NULL)
        {
            *pdwNumHeaps = 1;

            // Check to see if we can allocate memory to the right of the visible
            // surface.
            // Fill in the list of off-screen rectangles if we've been asked
            // to do so:

            if (pvmList != NULL)
            {
                DISPDBG((10, "DirectDraw gets %li x %li surface at (%li, %li)",
                    poh->cx, poh->cy, poh->x, poh->y));

                pvmList->dwFlags        = VIDMEM_ISRECTANGULAR;
                pvmList->fpStart        = (poh->y * ppdev->lDelta)
                    + (poh->x * ppdev->cjPelSize);
                pvmList->dwWidth        = poh->cx * ppdev->cjPelSize;
                pvmList->dwHeight       = poh->cy;
                pvmList->ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
                if ((DWORD) ppdev->cyScreen <= pvmList->dwHeight)
                {
                    bCanFlip = TRUE;
                }
                DISPDBG((10,"CanFlip = %d", bCanFlip));
            }
        }

        pHalInfo->ddCaps.dwCaps = DDCAPS_BLT
                                | DDCAPS_COLORKEY
                                | DDCAPS_BLTCOLORFILL
                                | DDCAPS_READSCANLINE;

        pHalInfo->ddCaps.dwCKeyCaps = 0;

        pHalInfo->ddCaps.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN
                                        | DDSCAPS_PRIMARYSURFACE;
        if (bCanFlip)
        {
            pHalInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_FLIP;
        }
    }
    else
    {
        pHalInfo->ddCaps.dwCaps = DDCAPS_READSCANLINE;
    }

    // dword alignment must be guaranteed for off-screen surfaces:

    pHalInfo->vmiData.dwOffscreenAlign = 8;

    DISPDBG((10,"DrvGetDirectDrawInfo exit"));
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\debug.c ===
/******************************Module*Header*******************************\
* Module Name: debug.c
*
* Debug helper routines.
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

#if DBG

////////////////////////////////////////////////////////////////////////////
// DEBUGGING INITIALIZATION CODE
//
// When you're bringing up your display for the first time, you can
// recompile with 'DebugLevel' set to 100.  That will cause absolutely
// all DISPDBG messages to be displayed on the kernel debugger (this
// is known as the "PrintF Approach to Debugging" and is about the only
// viable method for debugging driver initialization code).

LONG DebugLevel = 0;            // Set to '100' to debug initialization code
                                //   (the default is '0')

////////////////////////////////////////////////////////////////////////////

LONG gcFifo = 0;                // Number of currently free FIFO entries

#define LARGE_LOOP_COUNT  10000000

////////////////////////////////////////////////////////////////////////////
// Miscellaneous Driver Debug Routines
////////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
DebugPrint(
    LONG  DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )
{
    va_list ap;
#if TARGET_BUILD <= 351
    char    buffer[128];
#endif

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel)
    {
#if TARGET_BUILD > 351
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
        EngDebugPrint("", "\n", ap);
#else
        vsprintf( buffer, DebugMessage, ap );
        OutputDebugString( buffer );
        OutputDebugString("\n");
#endif
    }

    va_end(ap);

} // DebugPrint()

/******************************Public*Routine******************************\
* VOID vCheckFifoWrite
\**************************************************************************/

VOID vCheckFifoWrite()
{
    gcFifo--;
    if (gcFifo < 0)
    {
        gcFifo = 0;
        RIP("Incorrect FIFO wait count");
    }
}

/******************************Public*Routine******************************\
* VOID vI32CheckFifoSpace
\**************************************************************************/

VOID vI32CheckFifoSpace(
PDEV*   ppdev,
VOID*   pbase,
LONG    level)
{
    LONG    i;

    ASSERTDD((level > 0) && (level <= 16), "Illegal wait level");
    ASSERTDD((ppdev->iMachType == MACH_IO_32) || (ppdev->iMachType == MACH_MM_32),
             "Wrong Mach type!");

    gcFifo = level;

    for (i = LARGE_LOOP_COUNT; i != 0; i--)
    {
        if (!(I32_IW(pbase, EXT_FIFO_STATUS) & (0x10000L >> (level))))
            return;         // There are 'level' entries free
    }

    RIP("vI32CheckFifoSpace timeout -- The hardware is in a funky state.");
}

/******************************Public*Routine******************************\
* VOID vM32CheckFifoSpace
\**************************************************************************/

VOID vM32CheckFifoSpace(
PDEV*   ppdev,
VOID*   pbase,
LONG    level)
{
    LONG    i;

    ASSERTDD((level > 0) && (level <= 16), "Illegal wait level");
    ASSERTDD(ppdev->iMachType == MACH_MM_32, "Wrong Mach type!");

    gcFifo = level;

    for (i = LARGE_LOOP_COUNT; i != 0; i--)
    {
        if (!(M32_IW(pbase, EXT_FIFO_STATUS) & (0x10000L >> (level))))
            return;         // There are 'level' entries free
    }

    RIP("vM32CheckFifoSpace timeout -- The hardware is in a funky state.");
}

/******************************Public*Routine******************************\
* VOID vM64CheckFifoSpace
\**************************************************************************/

VOID vM64CheckFifoSpace(
PDEV*   ppdev,
VOID*   pbase,
LONG    level)
{
    LONG    i;

    ASSERTDD((level > 0) && (level <= 16), "Illegal wait level");
    ASSERTDD(ppdev->iMachType == MACH_MM_64, "Wrong Mach type!");

    gcFifo = level;

    for (i = LARGE_LOOP_COUNT; i != 0; i--)
    {
        if (!(M64_ID((pbase), FIFO_STAT) & (0x10000L >> (level))))
            return;         // There are 'level' entries free
    }

    RIP("vM64CheckFifoSpace timeout -- The hardware is in a funky state.");
}

/******************************Public*Routine******************************\
* ULONG ulM64FastFifoCheck
\**************************************************************************/

ULONG ulM64FastFifoCheck(
PDEV*   ppdev,
VOID*   pbase,
LONG    level,
ULONG   ulFifo)
{
    LONG    i;
    ULONG   ulFree;
    LONG    cFree;

    ASSERTDD((level > 0) && (level <= 16), "Illegal wait level");
    ASSERTDD(ppdev->iMachType == MACH_MM_64, "Wrong Mach type!");

    i = LARGE_LOOP_COUNT;
    do {
        ulFifo = ~M64_ID((pbase), FIFO_STAT);       // Invert bits

        // Count the number of empty slots:

        ulFree = ulFifo;
        cFree  = 0;
        while (ulFree & 0x8000)
        {
            cFree++;
            ulFree <<= 1;
        }

        // Break if we've been looping a zillion times:

        if (--i == 0)
        {
            RIP("vM64CheckFifoSpace timeout -- The hardware is in a funky state.");
            break;
        }

    } while (cFree < level);

    gcFifo = cFree;

    // Account for the slots we're about to use:

    return(ulFifo << level);
}

////////////////////////////////////////////////////////////////////////////

#endif // DBG

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\dci.h ===
/*************************************************************************
 **                                                                     **
 **                             DCI.H                                   **
 **                                                                     **
 **     Copyright (c) 1992, ATI Technologies Inc.                       **
 *************************************************************************/

#define ROUND_UP_TO_64K(x)  (((ULONG)(x) + 0x10000 - 1) & ~(0x10000 - 1))

typedef struct _DCISURF
{
    // This union must appear at the beginning of the structure.  It
    // defines the public fields returned to GDI.

    union {
        DCISURFACEINFO SurfaceInfo;
        DCIOFFSCREEN   OffscreenInfo;
        DCIOVERLAY     OverlayInfo;
    };

    // The following are private fields we use to maintain the the
    // DCI surface.

    PDEV* ppdev;                    // To find our PDEV
    ULONG Offset;                   // Location of surface in memory.
    ULONG Size;                     // Size of surface in memory.
                                    //   This information could be changed
                                    //   to rectangles.
} DCISURF, *PDCISURF;

ULONG DCICreatePrimarySurface(PDEV *pdev, ULONG cjIn, VOID *pvIn, ULONG cjOut, VOID *pvOut);



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\debug.h ===
/***************************************************************************\
* Module Name: debug.h
*
* Commonly used debugging macros.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\***************************************************************************/

extern
VOID
DebugPrint(
    LONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

/*
 * Values used to enable and disable large numbers of debug print
 * statements at once.
 */
#define DEBUG_FATAL_ERROR    0  /* Error conditions - should always be enabled */
#define DEBUG_ERROR          1  /* Errors which will not cause the driver to abort */
#define DEBUG_DETAIL        99  /* Extreme detail for low-level debugging */
#define DEBUG_ENTRY_EXIT    50  /* Debug print statements at function entry and exit points */

#if DBG

VOID DebugLog(LONG, CHAR*, ...);

#define DISPDBG(arg) DebugPrint arg
#define STATEDBG(level) DebugState(level)
#if TARGET_BUILD > 351
#define RIP(x) { DebugPrint(0, x); EngDebugBreak();}
#else
#define RIP(x) { DebugPrint(0, x); DebugBreak();}
#endif
#define ASSERTDD(x, y) if (!(x)) RIP (y)

// If we are not in a debug environment, we want all of the debug
// information to be stripped out.

#else

#define DISPDBG(arg)
#define STATEDBG(level)
#define LOGDBG(arg)
#define RIP(x)
#define ASSERTDD(x, y)

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\ddraw64.c ===
/******************************Module*Header*******************************\
* Module Name: ddraw64.c
*
* Implements all the DirectDraw components for the MACH 64 driver.
*
* Copyright (c) 1995-1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vGetDisplayDuration64
*
* Get the length, in EngQueryPerformanceCounter() ticks, of a refresh cycle.
*
* If we could trust the miniport to return back and accurate value for
* the refresh rate, we could use that.  Unfortunately, our miniport doesn't
* ensure that it's an accurate value.
*
\**************************************************************************/

#define NUM_VBLANKS_TO_MEASURE      1
#define NUM_MEASUREMENTS_TO_TAKE    8

void  DeskScanCallback (PDEV* );


VOID vGetDisplayDuration64(PDEV* ppdev)
{
    BYTE*       pjMmBase;
    LONG        i;
    LONG        j;
    LONGLONG    li;
    LONGLONG    liMin;
    LONGLONG    aliMeasurement[NUM_MEASUREMENTS_TO_TAKE + 1];

    pjMmBase = ppdev->pjMmBase;

    memset(&ppdev->flipRecord, 0, sizeof(ppdev->flipRecord));

    // Warm up EngQUeryPerformanceCounter to make sure it's in the working
    // set:

    EngQueryPerformanceCounter(&li);

    // Sometimes the IN_VBLANK_STATUS will always return TRUE.  In this case,
    // we don't want to do the normal stuff here.  Instead, we will just
    // say that the flip duration is always 60Hz which should be the worst
    // case scenario.

    if (ppdev->bPassVBlank == FALSE)
    {
        LONGLONG liRate;

        EngQueryPerformanceFrequency(&liRate);
        liRate *= 167000;
        ppdev->flipRecord.liFlipDuration = liRate / 10000000;
        ppdev->flipRecord.liFlipTime = li;
        ppdev->flipRecord.bFlipFlag  = FALSE;
        ppdev->flipRecord.fpFlipFrom = 0;
        return;
    }

    // Unfortunately, since NT is a proper multitasking system, we can't
    // just disable interrupts to take an accurate reading.  We also can't
    // do anything so goofy as dynamically change our thread's priority to
    // real-time.
    //
    // So we just do a bunch of short measurements and take the minimum.
    //
    // It would be 'okay' if we got a result that's longer than the actual
    // VBlank cycle time -- nothing bad would happen except that the app
    // would run a little slower.  We don't want to get a result that's
    // shorter than the actual VBlank cycle time -- that could cause us
    // to start drawing over a frame before the Flip has occured.

    while (IN_VBLANK_64( pjMmBase))
        ;
    while (!(IN_VBLANK_64( pjMmBase)))
        ;

    for (i = 0; i < NUM_MEASUREMENTS_TO_TAKE; i++)
    {
        // We're at the start of the VBlank active cycle!

        EngQueryPerformanceCounter(&aliMeasurement[i]);

        // Okay, so life in a multi-tasking environment isn't all that
        // simple.  What if we had taken a context switch just before
        // the above EngQueryPerformanceCounter call, and now were half
        // way through the VBlank inactive cycle?  Then we would measure
        // only half a VBlank cycle, which is obviously bad.  The worst
        // thing we can do is get a time shorter than the actual VBlank
        // cycle time.
        //
        // So we solve this by making sure we're in the VBlank active
        // time before and after we query the time.  If it's not, we'll
        // sync up to the next VBlank (it's okay to measure this period --
        // it will be guaranteed to be longer than the VBlank cycle and
        // will likely be thrown out when we select the minimum sample).
        // There's a chance that we'll take a context switch and return
        // just before the end of the active VBlank time -- meaning that
        // the actual measured time would be less than the true amount --
        // but since the VBlank is active less than 1% of the time, this
        // means that we would have a maximum of 1% error approximately
        // 1% of the times we take a context switch.  An acceptable risk.
        //
        // This next line will cause us wait if we're no longer in the
        // VBlank active cycle as we should be at this point:

        while (!(IN_VBLANK_64( pjMmBase)))
            ;

        for (j = 0; j < NUM_VBLANKS_TO_MEASURE; j++)
        {
            while (IN_VBLANK_64( pjMmBase))
                ;
            while (!(IN_VBLANK_64( pjMmBase)))
                ;
        }
    }

    EngQueryPerformanceCounter(&aliMeasurement[NUM_MEASUREMENTS_TO_TAKE]);

    // Use the minimum, ignoring the POTENTIALLY BOGUS FIRST

    liMin = aliMeasurement[2] - aliMeasurement[1];

    DISPDBG((10, "Refresh count: %li - %li", 1, (ULONG) liMin));

    for (i = 3; i <= NUM_MEASUREMENTS_TO_TAKE; i++)
    {
        li = aliMeasurement[i] - aliMeasurement[i - 1];

       DISPDBG((10, "               %li - %li", i, (ULONG) li));

        if (li < liMin)
            liMin = li;
    }

    // Round the result:

    ppdev->flipRecord.liFlipDuration
        = (DWORD) (liMin + (NUM_VBLANKS_TO_MEASURE / 2)) / NUM_VBLANKS_TO_MEASURE;

    DISPDBG((10, "Frequency %li.%03li Hz",
        (ULONG) (EngQueryPerformanceFrequency(&li),
           li / ppdev->flipRecord.liFlipDuration),
        (ULONG) (EngQueryPerformanceFrequency(&li),
            ((li * 1000) / ppdev->flipRecord.liFlipDuration) % 1000)));

    ppdev->flipRecord.liFlipTime = aliMeasurement[NUM_MEASUREMENTS_TO_TAKE];
    ppdev->flipRecord.bFlipFlag  = FALSE;
    ppdev->flipRecord.fpFlipFrom = 0;

}

/******************************Public*Routine******************************\
* HRESULT vUpdateFlipStatus
*
* Checks and sees if the most recent flip has occurred.
*
\**************************************************************************/

static HRESULT vUpdateFlipStatus(
PDEV*   ppdev,
FLATPTR fpVidMem)
{
    BYTE*       pjMmBase;
    LONGLONG    liTime;

    pjMmBase = ppdev->pjMmBase;

    if ((ppdev->flipRecord.bFlipFlag) &&
        ((fpVidMem == 0) || (fpVidMem == ppdev->flipRecord.fpFlipFrom)))
    {
        if (ppdev->bPassVBlank)
        {
            if (IN_VBLANK_64( pjMmBase))
            {
                if (ppdev->flipRecord.bWasEverInDisplay)
                {
                    ppdev->flipRecord.bHaveEverCrossedVBlank = TRUE;
                }
            }
            else //if (IN_DISPLAY(pjMmBase))
            {
                if( ppdev->flipRecord.bHaveEverCrossedVBlank )
                {
                                ppdev->flipRecord.bFlipFlag = FALSE;
                    return(DD_OK);
                }
                ppdev->flipRecord.bWasEverInDisplay = TRUE;

                // If the current scan line is <= the scan line at flip
                //  time then we KNOW that the flip occurred!
                if ( CURRENT_VLINE_64(pjMmBase) < ppdev->flipRecord.wFlipScanLine)
                {
                    ppdev->flipRecord.bFlipFlag = FALSE;
                    return(DD_OK);
                }
            }
        }

        EngQueryPerformanceCounter(&liTime);

        if (liTime - ppdev->flipRecord.liFlipTime
                                <= ppdev->flipRecord.liFlipDuration)
        {
            return(DDERR_WASSTILLDRAWING);
        }

        ppdev->flipRecord.bFlipFlag = FALSE;
    }
    return(DD_OK);
}

/******************************Public*Routine******************************\
* DWORD DdBlt64
*
\**************************************************************************/

DWORD DdBlt64(
PDD_BLTDATA lpBlt)
{
    DWORD       scLeftRight;
    DWORD       scTopBottom;
    DWORD       dpPixWidth;
    DWORD       dpMix;
    DWORD       guiCntl;
    DWORD       srcOffPitch;
    DWORD       srcYX;
    DWORD       dstOffPitch;
    DWORD       dstYX;
    DWORD       RGBBitCount;
    LONG        lPitch;
    ULONG       dstOffPitchSave;
    DWORD       srcWidth, srcHeight;
    DWORD       dstWidth, dstHeight;
    DWORD       srcOffset, dstOffset;
    DWORD       frgdClr;
    RECTL       rSrc;
    RECTL       rDest;
    DWORD       dwFlags;
    PDEV*       ppdev;
    BYTE*       pjMmBase;
    BYTE        rop;
    HRESULT     ddrval;
    PDD_SURFACE_LOCAL   psrcsurfx;
    PDD_SURFACE_LOCAL   pdestsurfx;
    PDD_SURFACE_GLOBAL  psrcsurf;
    PDD_SURFACE_GLOBAL  pdestsurf;

    ppdev    = (PDEV*) lpBlt->lpDD->dhpdev;
    pjMmBase = ppdev->pjMmBase;

    pdestsurfx = lpBlt->lpDDDestSurface;
    pdestsurf = pdestsurfx->lpGbl;

    /*
     * is a flip in progress?
     */
    ddrval = vUpdateFlipStatus( ppdev, pdestsurf->fpVidMem );
    if( ddrval != DD_OK )
    {
                lpBlt->ddRVal = ddrval;
                return DDHAL_DRIVER_HANDLED;
    }

    dwFlags = lpBlt->dwFlags;

    /*
     * If async, then only work if bltter isn't busy
     * This should probably be a little more specific to each call, but
     * waiting for 16 is pretty close
     */

    if( dwFlags & DDBLT_ASYNC )
    {
        if( M64_FIFO_SPACE_AVAIL( ppdev, pjMmBase, 16 ) )
        {
            lpBlt->ddRVal = DDERR_WASSTILLDRAWING;
            return DDHAL_DRIVER_HANDLED;
         }
    }

    /*
     * copy src/dest rects
     */
    rSrc = lpBlt->rSrc;
    rDest = lpBlt->rDest;

    /*
     * get offset, width, and height for source
     */

        rop = (BYTE) (lpBlt->bltFX.dwROP >> 16);

        psrcsurfx = lpBlt->lpDDSrcSurface;
        if( psrcsurfx != NULL )
        {
            psrcsurf = psrcsurfx->lpGbl;
            srcOffset = (DWORD)(psrcsurf->fpVidMem);
            srcWidth = rSrc.right  - rSrc.left;
            srcHeight = rSrc.bottom - rSrc.top;
                RGBBitCount = ppdev->cjPelSize * 8;
            lPitch = psrcsurf->lPitch;
        }
        else
        {
            psrcsurf = NULL;
        }

    /*
     * setup dwSRC_LEFT_RIGHT, dwSRC_TOP_BOTTOM, and srcOffPitch
     */
    switch ( RGBBitCount )
    {
    case  8:
        srcOffPitch = (srcOffset >> 3) |
                          ((lPitch >> 3) << SHIFT_DST_PITCH);
        break;

    case 16:
        srcOffPitch = (srcOffset >> 3) |
                          ((lPitch >> 4) << SHIFT_DST_PITCH);
        break;

    case 24:
        srcOffPitch = (srcOffset >> 3 ) |
                          ((lPitch >> 3) << SHIFT_DST_PITCH);

        rSrc.left = rSrc.left * MUL24;
        rSrc.right = rSrc.right * MUL24;
        srcWidth = srcWidth * MUL24;
        break;
    }

    scTopBottom = ( DWORD )( ppdev->cyScreen - 1 ) << SHIFT_SC_BOTTOM;

    /*
     * get offset, width, and height for destination
     */
    dstOffset = (DWORD)(pdestsurf->fpVidMem);
    dstWidth    = rDest.right  - rDest.left;
    dstHeight = rDest.bottom - rDest.top;

    /*
     * get bpp and pitch for destination
     */
        RGBBitCount = ppdev->cjPelSize * 8;
    lPitch = pdestsurf->lPitch;

    /*
     * setup dstOffPitch, and dpPixWidth
     */
    switch ( RGBBitCount )
    {
    case  8:
        scLeftRight = (DWORD)(ppdev->cxScreen- 1) << SHIFT_SC_RIGHT;
        dstOffPitch = (dstOffset >> 3) |
            ((lPitch >> 3) << SHIFT_DST_PITCH);
        dpPixWidth  = DP_PIX_WIDTH_8BPP;
        break;

    case 16:
        scLeftRight = (DWORD)(ppdev->cxScreen- 1) << SHIFT_SC_RIGHT;
        dstOffPitch = (dstOffset >> 3) |
            ((lPitch >> 4) << SHIFT_DST_PITCH);
        dpPixWidth  = DP_PIX_WIDTH_15BPP;
        break;

    case 24:
        scLeftRight = (DWORD)(ppdev->cxScreen* MUL24 - 1) << SHIFT_SC_RIGHT;
        dstOffPitch = (dstOffset >> 3) |
            ((lPitch >> 3) << SHIFT_DST_PITCH);

        dpPixWidth = DP_PIX_WIDTH_24BPP;
        rDest.left = rDest.left  * MUL24;
        rDest.right = rDest.right * MUL24;
        dstWidth = dstWidth  * MUL24;
        break;
    }

    /*
    * setup guiCntl, srcYX and dstYX
    */
    guiCntl = DST_X_DIR | DST_Y_DIR; // unbounded Y, left-to-right, top-to-bottom
    srcYX = rSrc.top | (rSrc.left  << SHIFT_SRC_X);
    dstYX = rDest.top | (rDest.left << SHIFT_DST_X);

    /*
    * check if source and destination of blit are on the same surface; if
    * so, we may have to reverse the direction of blit
    */
    if( psrcsurf == pdestsurf )
    {
        if( rDest.top >= rSrc.top )
        {
            guiCntl &= ~DST_Y_DIR;
            srcYX = ( srcYX & 0xFFFF0000 ) | (rSrc.bottom-1);
            dstYX = ( dstYX & 0xFFFF0000 ) | (rDest.bottom-1);
        }

        if( rDest.left >= rSrc.left )
        {
            guiCntl &= ~DST_X_DIR;
            srcYX = (srcYX & 0x0000FFFF) | ((rSrc.right-1) << SHIFT_SRC_X);
            dstYX = (dstYX & 0x0000FFFF) | ((rDest.right-1) << SHIFT_DST_X);
        }
    }

    //
    //  ROP blts
    //
    //      NT only currently support SRCCOPY ROPS, so assume
    //  that any ROP is SRCCOPY
    //
    if( dwFlags & DDBLT_ROP )
    {
        dpMix = ( DP_MIX_S & DP_FRGD_MIX ) | ( DP_MIX_D & DP_BKGD_MIX );
        DISPDBG((10,"SRCCOPY...."));

        //
        // set up the blt
        //

        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 9);

        M64_OD( pjMmBase, DP_WRITE_MASK, 0xFFFFFFFF );
        M64_OD( pjMmBase, DP_PIX_WIDTH, dpPixWidth );
        M64_OD( pjMmBase, SC_LEFT_RIGHT, scLeftRight );
        M64_OD( pjMmBase, SC_TOP_BOTTOM, scTopBottom );
        M64_OD( pjMmBase, SRC_OFF_PITCH, srcOffPitch );
        M64_OD( pjMmBase, DST_OFF_PITCH, dstOffPitch );
        M64_OD( pjMmBase, SRC_HEIGHT1_WIDTH1,
            srcHeight | ( srcWidth << SHIFT_SRC_WIDTH1 ) );
        M64_OD( pjMmBase, DP_SRC, DP_FRGD_SRC & DP_SRC_VRAM );
        M64_OD( pjMmBase, DP_MIX, dpMix );


        if( dwFlags & (DDBLT_KEYSRCOVERRIDE|DDBLT_KEYDESTOVERRIDE) )
        {
            M64_CHECK_FIFO_SPACE( ppdev, pjMmBase, 7 );
            if ( dwFlags & DDBLT_KEYSRCOVERRIDE )
            {
                M64_OD( pjMmBase, CLR_CMP_CNTL, CLR_CMP_SRC | CLR_CMP_FCN_EQ );
                M64_OD( pjMmBase, CLR_CMP_MSK, 0xFFFFFFFF ); // enable all bit planes for comparision
                M64_OD( pjMmBase, CLR_CMP_CLR,
                    lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceLowValue );
            }
            else
            {
                M64_OD( pjMmBase, CLR_CMP_CNTL, CLR_CMP_FCN_NE );
                M64_OD( pjMmBase, CLR_CMP_MSK, 0xFFFFFFFF ); // enable all bit planes for comparision
                M64_OD( pjMmBase, CLR_CMP_CLR,
                    lpBlt->bltFX.ddckDestColorkey.dwColorSpaceLowValue );
            }
        }
        else
        {
            M64_CHECK_FIFO_SPACE( ppdev, pjMmBase, 5 );
            M64_OD( pjMmBase, CLR_CMP_CNTL, 0x00000000 ); // disable color key
            DISPDBG((10,"wr CLR_CMP_CNTL %x (DISABLE)",0));
        }

        M64_OD( pjMmBase, GUI_TRAJ_CNTL, guiCntl );
        M64_OD( pjMmBase, SRC_Y_X, srcYX );
        M64_OD( pjMmBase, DST_Y_X, dstYX );


        /*
        * DST_HEIGHT_WIDTH is an initiator, this actually starts the blit
        */
        M64_OD( pjMmBase, DST_HEIGHT_WIDTH, dstHeight | (dstWidth << SHIFT_DST_WIDTH) );

    }
    /*
    * color fill
    */
    else if( dwFlags & DDBLT_COLORFILL )
    {
        M64_CHECK_FIFO_SPACE ( ppdev,pjMmBase, 12 );

        M64_OD( pjMmBase, DP_WRITE_MASK, 0xFFFFFFFF );
        M64_OD( pjMmBase, DP_PIX_WIDTH, dpPixWidth );
        M64_OD( pjMmBase, CLR_CMP_CNTL, 0x00000000 ); /* disable */
        M64_OD( pjMmBase, SC_LEFT_RIGHT, scLeftRight );
        M64_OD( pjMmBase, SC_TOP_BOTTOM, scTopBottom );
        M64_OD( pjMmBase, DST_OFF_PITCH, dstOffPitch );

        M64_OD( pjMmBase, DP_SRC, DP_FRGD_SRC & DP_SRC_FRGD );
        M64_OD( pjMmBase, DP_MIX, (DP_MIX_S & DP_FRGD_MIX) |  /* frgd:paint, */
            (DP_MIX_D & DP_BKGD_MIX) ); /* bkgd:leave_alone */

        M64_OD( pjMmBase, DP_FRGD_CLR, lpBlt->bltFX.dwFillColor );
        M64_OD( pjMmBase, GUI_TRAJ_CNTL, guiCntl );
        M64_OD( pjMmBase, DST_Y_X, dstYX );

        /* DST_HEIGHT_WIDTH is an initiator, this actually starts the blit */
        M64_OD( pjMmBase, DST_HEIGHT_WIDTH,
            dstHeight | ( dstWidth << SHIFT_DST_WIDTH ) );

    }
    /*
    * don't handle
    */
    else
    {
        return DDHAL_DRIVER_NOTHANDLED;
    }

    // Don't forget to reset the clip register and the default pixel width:
        // The rest of the driver code assumes that this is set by default!
    M64_CHECK_FIFO_SPACE ( ppdev, pjMmBase, 8);
    M64_OD(pjMmBase, DST_OFF_PITCH, ppdev->ulScreenOffsetAndPitch );
    M64_OD(pjMmBase, SRC_OFF_PITCH, ppdev->ulScreenOffsetAndPitch );
    M64_OD(pjMmBase, DP_PIX_WIDTH,  ppdev->ulMonoPixelWidth);
    M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(0, M64_MAX_SCISSOR_R));
    M64_OD(pjMmBase, SC_TOP_BOTTOM, PACKPAIR(0, M64_MAX_SCISSOR_B));
    M64_OD( pjMmBase, CLR_CMP_CNTL, 0x00000000 ); /* disable */
    M64_OD( pjMmBase, GUI_TRAJ_CNTL, DST_X_DIR | DST_Y_DIR );

    lpBlt->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}

/******************************Public*Routine******************************\
* DWORD DdFlip64
*
\**************************************************************************/

DWORD DdFlip64(
PDD_FLIPDATA lpFlip)
{
    PDEV*       ppdev;
    BYTE*       pjMmBase;
    HRESULT     ddrval;
    ULONG       ulMemoryOffset;
    ULONG           uVal;
    static ULONG flipcnt = 0;

    DISPDBG((10, "Enter DDFlip64"));

    ppdev    = (PDEV*) lpFlip->lpDD->dhpdev;
    pjMmBase = ppdev->pjMmBase;
        flipcnt++;
    // Is the current flip still in progress?
    //
    // Don't want a flip to work until after the last flip is done,
    // so we ask for the general flip status and ignore the vmem.

    ddrval = vUpdateFlipStatus(ppdev, 0);
    if ((ddrval != DD_OK) || (DRAW_ENGINE_BUSY_64( ppdev,pjMmBase)))
    {
        lpFlip->ddRVal = DDERR_WASSTILLDRAWING;
        return(DDHAL_DRIVER_HANDLED);
    }

    // code for overlay support
    /*
     * Do we have a flipping overlay surface
     */

    if ( lpFlip->lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_OVERLAY )
      {
        ppdev->OverlayInfo16.dwFlags |= UPDATEOVERLAY;

        ppdev->OverlayInfo16.dwBuf0Start =
                            (DWORD)(lpFlip->lpSurfTarg->lpGbl->fpVidMem);
        ppdev->OverlayInfo16.dwBuf1Start =
                            (DWORD)(lpFlip->lpSurfTarg->lpGbl->fpVidMem);
        DeskScanCallback (ppdev );


        ppdev->OverlayInfo16.dwFlags &= ~UPDATEOVERLAY;

        if (ppdev->bPassVBlank)
        {
            while (IN_VBLANK_64(pjMmBase))
                ;
        }

        lpFlip->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
      }
      // end code for overlay support


    ulMemoryOffset = (ULONG)(lpFlip->lpSurfTarg->lpGbl->fpVidMem);

    uVal = M64_ID( pjMmBase, CRTC_OFF_PITCH );
    uVal &= 0xFFC00000;
    uVal |= (ulMemoryOffset >> 3);


    // Make sure that the border/blanking period isn't active; wait if
    // it is.  We could return DDERR_WASSTILLDRAWING in this case, but
    // that will increase the odds that we can't flip the next time:

    if (ppdev->bPassVBlank)
    {
        while (IN_VBLANK_64(pjMmBase))
            ;
    }

    // Do the flip

    M64_OD_DIRECT(pjMmBase, CRTC_OFF_PITCH, uVal );

    // Remember where and when we were when we did the flip:

    EngQueryPerformanceCounter(&ppdev->flipRecord.liFlipTime);

    ppdev->flipRecord.bFlipFlag              = TRUE;
    ppdev->flipRecord.bHaveEverCrossedVBlank = FALSE;
    ppdev->flipRecord.bWasEverInDisplay      = FALSE;

    ppdev->flipRecord.fpFlipFrom = lpFlip->lpSurfCurr->lpGbl->fpVidMem;

    if( IN_VBLANK_64( pjMmBase) && ppdev->bPassVBlank )
    {
        ppdev->flipRecord.wFlipScanLine = 0;
    }
    else
    {
        ppdev->flipRecord.wFlipScanLine = CURRENT_VLINE_64(pjMmBase);
        // if we have a context switch and we are returning in the middle of a VBlank, the current line will be invalid
        if( (ULONG)ppdev->flipRecord.wFlipScanLine > (ULONG)ppdev->cyScreen)
            {
            ppdev->flipRecord.wFlipScanLine = 0;
            }
    }

    lpFlip->ddRVal = DD_OK;

    DISPDBG((10, "Exit DDFlip64"));

    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdLock
*
\**************************************************************************/

DWORD DdLock64(
PDD_LOCKDATA lpLock)
{
    PDEV*   ppdev;
    HRESULT ddrval;

    ppdev = (PDEV*) lpLock->lpDD->dhpdev;

    // Check to see if any pending physical flip has occurred.
    // Don't allow a lock if a blt is in progress:

    ddrval = vUpdateFlipStatus(ppdev, lpLock->lpDDSurface->lpGbl->fpVidMem);
    if (ddrval != DD_OK)
    {
        lpLock->ddRVal = DDERR_WASSTILLDRAWING;
        return(DDHAL_DRIVER_HANDLED);
    }

    // Here's one of the places where the Windows 95 and Windows NT DirectDraw
    // implementations differ: on Windows NT, you should watch for
    // DDLOCK_WAIT and loop in the driver while the accelerator is busy.
    // On Windows 95, it doesn't really matter.
    //
    // (The reason is that Windows NT allows applications to draw directly
    // to the frame buffer even while the accelerator is running, and does
    // not synchronize everything on the Win16Lock.  Note that on Windows NT,
    // it is even possible for multiple threads to be holding different
    // DirectDraw surface locks at the same time.)

    if (lpLock->dwFlags & DDLOCK_WAIT)
    {
        do {} while (DRAW_ENGINE_BUSY_64(ppdev, ppdev->pjMmBase));
    }
    else if (DRAW_ENGINE_BUSY_64(ppdev, ppdev->pjMmBase))
    {
        lpLock->ddRVal = DDERR_WASSTILLDRAWING;
        return(DDHAL_DRIVER_HANDLED);
    }

    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdGetBltStatus64
*
* Doesn't currently really care what surface is specified, just checks
* and goes.
*
\**************************************************************************/

DWORD DdGetBltStatus64(
PDD_GETBLTSTATUSDATA lpGetBltStatus)
{
    PDEV*   ppdev;
    HRESULT ddRVal;

    ppdev = (PDEV*) lpGetBltStatus->lpDD->dhpdev;

    ddRVal = DD_OK;
    if (lpGetBltStatus->dwFlags == DDGBS_CANBLT)
    {
        // DDGBS_CANBLT case: can we add a blt?

        ddRVal = vUpdateFlipStatus(ppdev,
                        lpGetBltStatus->lpDDSurface->lpGbl->fpVidMem);

        if (ddRVal == DD_OK)
        {
            // There was no flip going on, so is there room in the FIFO
            // to add a blt?

            if (M64_FIFO_SPACE_AVAIL(ppdev,ppdev->pjMmBase,12))  // Should match DdBlt//XXX
            {
                ddRVal = DDERR_WASSTILLDRAWING;
            }
        }
    }
    else
    {
        // DDGBS_ISBLTDONE case: is a blt in progress?

        if (DRAW_ENGINE_BUSY_64( ppdev,ppdev->pjMmBase))
        {
            ddRVal = DDERR_WASSTILLDRAWING;
        }
    }
    lpGetBltStatus->ddRVal = ddRVal;
    return(DDHAL_DRIVER_HANDLED);
}


/******************************Public*Routine******************************\
* DWORD DdMapMemory64
*
* This is a new DDI call specific to Windows NT that is used to map
* or unmap all the application modifiable portions of the frame buffer
* into the specified process's address space.
*
\**************************************************************************/

DWORD DdMapMemory64(
PDD_MAPMEMORYDATA lpMapMemory)
{
    PDEV*                           ppdev;
    VIDEO_SHARE_MEMORY              ShareMemory;
    VIDEO_SHARE_MEMORY_INFORMATION  ShareMemoryInformation;
    DWORD                           ReturnedDataLength;

    ppdev = (PDEV*) lpMapMemory->lpDD->dhpdev;

    if (lpMapMemory->bMap)
    {
        ShareMemory.ProcessHandle = lpMapMemory->hProcess;

        // 'RequestedVirtualAddress' isn't actually used for the SHARE IOCTL:

        ShareMemory.RequestedVirtualAddress = 0;

        // We map in starting at the top of the frame buffer:

        ShareMemory.ViewOffset = 0;

        // We map down to the end of the frame buffer.
        //
        // Note: There is a 64k granularity on the mapping (meaning that
        //       we have to round up to 64k).
        //
        // Note: If there is any portion of the frame buffer that must
        //       not be modified by an application, that portion of memory
        //       MUST NOT be mapped in by this call.  This would include
        //       any data that, if modified by a malicious application,
        //       would cause the driver to crash.  This could include, for
        //       example, any DSP code that is kept in off-screen memory.

                //  ** NOTE ** : We must protect the graphics contexts from the user.
                //              The contexts are located at the high end of graphics memory.
                //              ppdev->cyMemory is adjusted when the contexts are allocated to
                //              'hide' this memory from heap allocation.  DDraw init also forces
                //              the offscreen memory passed to DDraw to end on a 64k boundary
                //              to fit within the ShareMemory.ViewSize.
                //

        ShareMemory.ViewSize
                            = ROUND_DOWN_TO_64K(ppdev->cyMemory * ppdev->lDelta);

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SHARE_VIDEO_MEMORY,
                               &ShareMemory,
                               sizeof(VIDEO_SHARE_MEMORY),
                               &ShareMemoryInformation,
                               sizeof(VIDEO_SHARE_MEMORY_INFORMATION),
                               &ReturnedDataLength))
        {

            lpMapMemory->ddRVal = DDERR_GENERIC;
            return(DDHAL_DRIVER_HANDLED);
        }

        lpMapMemory->fpProcess =(FLATPTR)ShareMemoryInformation.VirtualAddress;
    }
    else
    {
        ShareMemory.ProcessHandle           = lpMapMemory->hProcess;
        ShareMemory.ViewOffset              = 0;
        ShareMemory.ViewSize                = 0;
        ShareMemory.RequestedVirtualAddress = (VOID*) lpMapMemory->fpProcess;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY,
                               &ShareMemory,
                               sizeof(VIDEO_SHARE_MEMORY),
                               NULL,
                               0,
                               &ReturnedDataLength))
        {
            RIP("Failed IOCTL_VIDEO_UNSHARE_MEMORY");
        }
    }
    lpMapMemory->ddRVal = DD_OK;
    return(DDHAL_DRIVER_HANDLED);
}


/******************************Public*Routine******************************\
* DWORD DdGetFlipStatus64
*
* If the display has gone through one refresh cycle since the flip
* occurred, we return DD_OK.  If it has not gone through one refresh
* cycle we return DDERR_WASSTILLDRAWING to indicate that this surface
* is still busy "drawing" the flipped page.   We also return
* DDERR_WASSTILLDRAWING if the bltter is busy and the caller wanted
* to know if they could flip yet.
*
\**************************************************************************/

DWORD DdGetFlipStatus64(
PDD_GETFLIPSTATUSDATA lpGetFlipStatus)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) lpGetFlipStatus->lpDD->dhpdev;

    // We don't want a flip to work until after the last flip is done,
    // so we ask for the general flip status and ignore the vmem:

    lpGetFlipStatus->ddRVal = vUpdateFlipStatus(ppdev, 0);

    // Check if the bltter is busy if someone wants to know if they can
    // flip:

    if (lpGetFlipStatus->dwFlags == DDGFS_CANFLIP)
    {
        if ((lpGetFlipStatus->ddRVal == DD_OK) && (DRAW_ENGINE_BUSY_64( ppdev,ppdev->pjMmBase)))
        {
            lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
        }
    }

    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdWaitForVerticalBlank64
*
\**************************************************************************/

DWORD DdWaitForVerticalBlank64(
PDD_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank)
{
    PDEV*   ppdev;
    BYTE*   pjMmBase;

    ppdev    = (PDEV*) lpWaitForVerticalBlank->lpDD->dhpdev;
    pjMmBase = ppdev->pjMmBase;

    lpWaitForVerticalBlank->ddRVal = DD_OK;

    if (ppdev->bPassVBlank == FALSE)
    {
        lpWaitForVerticalBlank->bIsInVB = FALSE;
        return(DDHAL_DRIVER_HANDLED);
    }

    switch (lpWaitForVerticalBlank->dwFlags)
    {
    case DDWAITVB_I_TESTVB:

        // If TESTVB, it's just a request for the current vertical blank
        // status:

        if (IN_VBLANK_64( pjMmBase))
            lpWaitForVerticalBlank->bIsInVB = TRUE;
        else
            lpWaitForVerticalBlank->bIsInVB = FALSE;

        return(DDHAL_DRIVER_HANDLED);

    case DDWAITVB_BLOCKBEGIN:

        // If BLOCKBEGIN is requested, we wait until the vertical blank
        // is over, and then wait for the display period to end:

        while (IN_VBLANK_64( pjMmBase))
            ;
        while (!IN_VBLANK_64( pjMmBase))
            ;

        return(DDHAL_DRIVER_HANDLED);

    case DDWAITVB_BLOCKEND:

        // If BLOCKEND is requested, we wait for the vblank interval to end:

        while (!(IN_VBLANK_64( pjMmBase)))
            ;
        while (IN_VBLANK_64( pjMmBase))
            ;

        return(DDHAL_DRIVER_HANDLED);
    }

    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdGetScanLine64
*
\**************************************************************************/

DWORD DdGetScanLine64(
PDD_GETSCANLINEDATA lpGetScanLine)
{
    PDEV*   ppdev;
    BYTE*   pjMmBase;

    ppdev    = (PDEV*) lpGetScanLine->lpDD->dhpdev;
    pjMmBase = ppdev->pjMmBase;

    // If a vertical blank is in progress, the scan line is indeterminant.
    // If the scan line is indeterminant we return the error code
    // DDERR_VERTICALBLANKINPROGRESS.  Otherwise, we return the scan line
    // and a success code:

    if (IN_VBLANK_64(pjMmBase) && ppdev->bPassVBlank)
    {
        lpGetScanLine->ddRVal = DDERR_VERTICALBLANKINPROGRESS;
    }
    else
    {
        lpGetScanLine->dwScanLine = CURRENT_VLINE_64(pjMmBase);
        lpGetScanLine->ddRVal = DD_OK;
    }

    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* BOOL DrvGetDirectDrawInfo64
*
* Will be called before DrvEnableDirectDraw is called.
*
\**************************************************************************/
BOOL DrvGetDirectDrawInfo64(
DHPDEV          dhpdev,
DD_HALINFO*     pHalInfo,
DWORD*          pdwNumHeaps,
VIDEOMEMORY*    pvmList,            // Will be NULL on first call
DWORD*          pdwNumFourCC,
DWORD*          pdwFourCC)          // Will be NULL on first call
{
    BOOL        bCanFlip;
    PDEV*       ppdev;
    LONGLONG    li;
    OH          *poh;
    DWORD       i;

    ppdev = (PDEV*) dhpdev;

    DISPDBG((10,"DrvGetDirectDrawInfo64"));

    memset( pHalInfo, 0, sizeof(*pHalInfo));
    pHalInfo->dwSize = sizeof(*pHalInfo);

    if ((ppdev->iBitmapFormat == BMF_24BPP) && (ppdev->cxScreen == 1280) ||
        (ppdev->iBitmapFormat == BMF_24BPP) && (ppdev->cxScreen == 1152) ||
        (ppdev->iBitmapFormat == BMF_16BPP) && (ppdev->cxScreen == 1600)) {

        //
        // On some DAC/memory combinations, some modes which require more
        // than 2M of memory will have screen tearing at the 2M boundary.
        //
        // As a workaround, the display driver must start the framebuffer
        // at an offset which will put the 2M boundary at the start of a
        // scanline.
        //
        // IOCTL_VIDEO_SHARE_VIDEO_MEMORY is rejected in this case so don't
        // allow DDRAW to run with these modes.
        //

        return FALSE;
    }

    // Current primary surface attributes:

    pHalInfo->vmiData.pvPrimary       = ppdev->pjScreen;
    pHalInfo->vmiData.dwDisplayWidth  = ppdev->cxScreen;
    pHalInfo->vmiData.dwDisplayHeight = ppdev->cyScreen;
    pHalInfo->vmiData.lDisplayPitch   = ppdev->lDelta;

    pHalInfo->vmiData.ddpfDisplay.dwSize  = sizeof(DDPIXELFORMAT);
    pHalInfo->vmiData.ddpfDisplay.dwFlags = DDPF_RGB;

    pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount = ppdev->cBitsPerPel;
    DISPDBG((10,"Init pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount %x",pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount));

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        pHalInfo->vmiData.ddpfDisplay.dwFlags |= DDPF_PALETTEINDEXED8;
    }

    // These masks will be zero at 8bpp:

    pHalInfo->vmiData.ddpfDisplay.dwRBitMask = ppdev->flRed;
    pHalInfo->vmiData.ddpfDisplay.dwGBitMask = ppdev->flGreen;
    pHalInfo->vmiData.ddpfDisplay.dwBBitMask = ppdev->flBlue;

    // I've disabled DirectDraw accelerations (other than direct frame
    // buffer access) at 24bpp and 32bpp because we're close to shipping
    // and foxbear has a lot of drawing problems in those modes.

    if (ppdev->iBitmapFormat < BMF_24BPP)
    {
        // Set up the pointer to the first available video memory after
        // the primary surface:

        bCanFlip = FALSE;

        // Free up as much off-screen memory as possible:

        bMoveAllDfbsFromOffscreenToDibs(ppdev);

        // Now simply reserve the biggest chunks for use by DirectDraw:

        poh = ppdev->pohDirectDraw;

        if (poh == NULL)
        {
            LONG linesPer64k;
            LONG cyMax;

            // We need to force the allocation to end before a 64k boundary.
            // The graphic's contexts live at the end fo high memory and we MUST
            // protect this from DDraw by not mapping this 64k block into user space.
            // So we do not allocate the last 64k of graphics memory for DDraw use.

            linesPer64k = 0x10000/ppdev->lDelta;
            cyMax = ppdev->heap.cyMax - linesPer64k - 1;

            if (cyMax <= 0)
            {
                // In some modes in some memory configurations -- notably
                // 1152x864x256 on a 1MB card -- it's possible that the 64k
                // we have to reserve to protect the graphics contexts takes
                // up all of off-screen memory and extends into on-screen
                // memory.  For those modes, we have to disable DirectDraw
                // entirely.

                return(FALSE);
            }

            DISPDBG((10," *** Alloc Fix lp64k %d cy.Max %x newallocy %x",linesPer64k,ppdev->heap.cyMax,ppdev->heap.cyMax- linesPer64k-1));

            poh = pohAllocate(ppdev,
                              NULL,
                              ppdev->heap.cxMax,
                              cyMax,
                              FLOH_MAKE_PERMANENT);

            ppdev->pohDirectDraw = poh;
        }

        // this will work as is if using the NT common 2-d heap code.

        if (poh != NULL)
        {
            *pdwNumHeaps = 1;

            // Check to see if we can allocate memory to the right of the visible
            // surface.
            // Fill in the list of off-screen rectangles if we've been asked
            // to do so:

            if (pvmList != NULL)
            {
                DISPDBG((10, "DirectDraw gets %li x %li surface at (%li, %li)",
                        poh->cx, poh->cy, poh->x, poh->y));

                pvmList->dwFlags        = VIDMEM_ISRECTANGULAR;
                pvmList->fpStart        = (poh->y * ppdev->lDelta)
                                        + (poh->x * ppdev->cjPelSize);
                pvmList->dwWidth        = poh->cx * ppdev->cjPelSize;
                pvmList->dwHeight       = poh->cy;
                pvmList->ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
                if ((DWORD) ppdev->cyScreen <= pvmList->dwHeight)
                {
                    bCanFlip = TRUE;
                }
                DISPDBG((10,"CanFlip = %d", bCanFlip));
            }
        }

        // Capabilities supported:

        pHalInfo->ddCaps.dwCaps = DDCAPS_BLT
                                | DDCAPS_COLORKEY
                                | DDCAPS_BLTCOLORFILL
                                | DDCAPS_READSCANLINE;

        pHalInfo->ddCaps.dwCKeyCaps = DDCKEYCAPS_SRCBLT;

        pHalInfo->ddCaps.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN
                                        | DDSCAPS_PRIMARYSURFACE;
        if (bCanFlip)
        {
            pHalInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_FLIP;
        }
    }
    else
    {
        pHalInfo->ddCaps.dwCaps = DDCAPS_READSCANLINE;
    }

    // dword alignment must be guaranteed for off-screen surfaces:

    pHalInfo->vmiData.dwOffscreenAlign = 8;

    DISPDBG((10,"DrvGetDirectDrawInfo64 exit"));
    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\driver.h ===
/******************************Module*Header*******************************\
* Module Name: driver.h
*
* Contains prototypes for the display driver.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

//////////////////////////////////////////////////////////////////////
// Put all the conditional-compile constants here.  There had better
// not be many!

// Multi-board support can be enabled by setting this to 1:

#define MULTI_BOARDS            0

// This is the maximum number of boards we'll support in a single
// virtual driver:

#if MULTI_BOARDS
    #define MAX_BOARDS          16
    #define IBOARD(ppdev)       ((ppdev)->iBoard)
#else
    #define MAX_BOARDS          1
    #define IBOARD(ppdev)       0
#endif

//////////////////////////////////////////////////////////////////////
// Miscellaneous shared stuff

#define DLL_NAME                L"ati"      // Name of the DLL in UNICODE
#define STANDARD_DEBUG_PREFIX   "ATI: "     // All debug output is prefixed
                                            //   by this string
#define ALLOC_TAG               ' ITA'      // Four byte tag used for tracking
                                            //   memory allocations (characters
                                            //   are in reverse order)

#define CLIP_LIMIT          50  // We'll be taking 800 bytes of stack space

#define DRIVER_EXTRA_SIZE   0   // Size of the DriverExtra information in the
                                //   DEVMODE structure

#define TMP_BUFFER_SIZE     8192  // Size in bytes of 'pvTmpBuffer'.  Has to
                                  //   be at least enough to store an entire
                                  //   scan line (i.e., 6400 for 1600x1200x32).

#define ROUND8(x)   (((x)+7)&~7)

typedef struct _CLIPENUM {
    LONG    c;
    RECTL   arcl[CLIP_LIMIT];   // Space for enumerating complex clipping

} CLIPENUM;                         /* ce, pce */

typedef struct _PDEV PDEV;      // Handy forward declaration

// Basic Mach types:

typedef enum {
    MACH_IO_32,                 // Mach8 or Mach32
    MACH_MM_32,                 // Mach32 capable of memory-mapped I/O
    MACH_MM_64,                 // Mach64
} MACHTYPE;

// Specific ASIC types:

typedef enum {
    ASIC_38800_1,               // Mach8
    ASIC_68800_3,               // Mach32
    ASIC_68800_6,               // Mach32
    ASIC_68800AX,               // Mach32
    ASIC_88800GX,               // Mach64
    ASIC_COUNT
} ASIC;

// Frame buffer aperture types:

typedef enum {
    APERTURE_NONE,
    APERTURE_FULL,
    APERTURE_PAGE_SINGLE,
    APERTURE_PAGE_DOUBLE,
    APERTURE_COUNT
} APERTURE;


// NOTE: Must be kept in sync with miniport version of the structure!

#include "atint.h"


#if TARGET_BUILD > 351

#define AtiDeviceIoControl(handle,controlCode,inBuffer,inBufferSize,outBuffer,outBufferSize,bytesReturned) \
    (!EngDeviceIoControl(handle,controlCode,inBuffer,inBufferSize,outBuffer,outBufferSize,bytesReturned))

#define AtiAllocMem(a,b,allocSize)      EngAllocMem((b),allocSize,ALLOC_TAG)
#define AtiFreeMem(ptr)                 EngFreeMem(ptr)

#else

#define AtiDeviceIoControl(handle,controlCode,inBuffer,inBufferSize,outBuffer,outBufferSize,bytesReturned) \
    DeviceIoControl(handle,controlCode,inBuffer,inBufferSize,outBuffer,outBufferSize,bytesReturned,NULL)

#define AtiAllocMem(a,b,allocSize)      LocalAlloc((a),allocSize)
#define AtiFreeMem(ptr)                 LocalFree(ptr)

#endif


VOID vSetClipping(PDEV*, RECTL*);
VOID vResetClipping(PDEV*);

//////////////////////////////////////////////////////////////////////
// Text stuff

#define GLYPH_CACHE_CX      64  // Maximal width of glyphs that we'll consider
                                //   caching

#define GLYPH_CACHE_CY      64  // Maximum height of glyphs that we'll consider
                                //   caching

#define GLYPH_ALLOC_SIZE    8100
                                // Do all cached glyph memory allocations
                                //   in 8k chunks

#define HGLYPH_SENTINEL     ((ULONG) -1)
                                // GDI will never give us a glyph with a
                                //   handle value of 0xffffffff, so we can
                                //   use this as a sentinel for the end of
                                //   our linked lists

#define GLYPH_HASH_SIZE     256

#define GLYPH_HASH_FUNC(x)  ((x) & (GLYPH_HASH_SIZE - 1))

typedef struct _CACHEDGLYPH CACHEDGLYPH;
typedef struct _CACHEDGLYPH
{
    CACHEDGLYPH*    pcgNext;    // Points to next glyph that was assigned
                                //   to the same hash table bucket
    HGLYPH          hg;         // Handles in the bucket-list are kept in
                                //   increasing order
    POINTL          ptlOrigin;  // Origin of glyph bits

    // Device specific fields below here:

    LONG            cx;         // Width of the glyph
    LONG            cy;         // Height of the glyph
    LONG            cxy;        // Height and width encoded
    LONG            cw;         // Number of words in glyph
    LONG            cd;         // Number of dwords in glyph

    // Glyph bits follow here:

    ULONG           ad[1];      // Start of glyph bits
} CACHEDGLYPH;  /* cg, pcg */

typedef struct _GLYPHALLOC GLYPHALLOC;
typedef struct _GLYPHALLOC
{
    GLYPHALLOC*     pgaNext;    // Points to next glyph structure that
                                //   was allocated for this font
    CACHEDGLYPH     acg[1];     // This array is a bit misleading, because
                                //   the CACHEDGLYPH structures are actually
                                //   variable sized
} GLYPHAALLOC;  /* ga, pga */

typedef struct _CACHEDFONT
{
    GLYPHALLOC*     pgaChain;   // Points to start of allocated memory list
    CACHEDGLYPH*    pcgNew;     // Points to where in the current glyph
                                //   allocation structure a new glyph should
                                //   be placed
    LONG            cjAlloc;    // Bytes remaining in current glyph allocation
                                //   structure
    CACHEDGLYPH     cgSentinel; // Sentinel entry of the end of our bucket
                                //   lists, with a handle of HGLYPH_SENTINEL
    CACHEDGLYPH*    apcg[GLYPH_HASH_SIZE];
                                // Hash table for glyphs

} CACHEDFONT;   /* cf, pcf */

BOOL bEnableText(PDEV*);
VOID vDisableText(PDEV*);
VOID vAssertModeText(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////
// for overlay support
#if TARGET_BUILD > 351
// new stuff from overlay.c

#define UPDATEOVERLAY      0x01L
#define SETOVERLAYPOSITION 0x02L
#define DOUBLE_PITCH       0x04L
#define OVERLAY_ALLOCATED  0x08L
#define OVERLAY_VISIBLE    0x10L
#define CRTC_INTERLACE_EN 0x00000002L
#define CRTC_VLINE_CRNT_VLINE     0x04
#define CLOCK_CNTL                0x24

#define DD_RESERVED_DIFFERENTPIXELFORMAT    0x0001

typedef struct tagOVERLAYINFO16
  {
    DWORD dwFlags;
    RECTL rSrc;
    RECTL rDst;
    RECTL rOverlay;
    DWORD dwBuf0Start;
    LONG  lBuf0Pitch;
    DWORD dwBuf1Start;
    LONG  lBuf1Pitch;
    DWORD dwOverlayKeyCntl;
    DWORD dwHInc;
    DWORD dwVInc;
  }
OVERLAYINFO16;

/*****************************************************************************

                            VT - GT Registers

*****************************************************************************/

#define DD_OVERLAY_Y_X              0x00
#define DD_OVERLAY_Y_X_END          0x01
#define DD_OVERLAY_VIDEO_KEY_CLR    0x02
#define DD_OVERLAY_VIDEO_KEY_MSK    0x03
#define DD_OVERLAY_GRAPHICS_KEY_CLR 0x04
#define DD_OVERLAY_GRAPHICS_KEY_MSK 0x05
#define DD_OVERLAY_KEY_CNTL         0x06
#define DD_OVERLAY_SCALE_INC        0x08
#define DD_OVERLAY_SCALE_CNTL       0x09
#define DD_SCALER_HEIGHT_WIDTH      0x0A
#define DD_OVERLAY_TEST             0x0B
#define DD_SCALER_THRESHOLD         0x0C
#define DD_SCALER_BUF0_OFFSET       0x0D
#define DD_SCALER_BUF1_OFFSET       0x0E
#define DD_SCALER_BUF_PITCH         0x0F
#define DD_VIDEO_FORMAT             0x12
#define DD_VIDEO_CONFIG             0x13
#define DD_CAPTURE_CONFIG           0x14
#define DD_TRIG_CNTL                0x15
#define DD_VMC_CONFIG               0x18
#define DD_BUF0_OFFSET              0x20
#define DD_BUF0_PITCH               0x23
#define DD_BUF1_OFFSET              0x26
#define DD_BUF1_PITCH               0x29
// for RAGE III
#define  DD_SCALER_COLOUR_CNTL      0x54
#define  DD_SCALER_H_COEFF0     0x55
#define  DD_SCALER_H_COEFF1     0x56
#define  DD_SCALER_H_COEFF2     0x57
#define  DD_SCALER_H_COEFF3     0x58
#define  DD_SCALER_H_COEFF4     0x59

/*****************************************************************************/
// stuff from overlay.c

#define MAKE_FOURCC( ch0, ch1, ch2, ch3 )                       \
        ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
        ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )

#define FOURCC_YUY2  MAKE_FOURCC('Y','U','Y','2')
#define FOURCC_UYVY  MAKE_FOURCC('U','Y','V','Y')
#define FOURCC_YVYU  MAKE_FOURCC('Y','V','Y','U')
// end overlay support
#endif


//////////////////////////////////////////////////////////////////////
// Dither stuff

// Describes a single colour tetrahedron vertex for dithering:

typedef struct _VERTEX_DATA {
    ULONG ulCount;              // Number of pixels in this vertex
    ULONG ulVertex;             // Vertex number
} VERTEX_DATA;                      /* vd, pv */

VERTEX_DATA*    vComputeSubspaces(ULONG, VERTEX_DATA*);
VOID            vDitherColor(ULONG*, VERTEX_DATA*, VERTEX_DATA*, ULONG);

//////////////////////////////////////////////////////////////////////
// Brush stuff

#define TOTAL_BRUSH_COUNT       8   // We'll keep room for 8 brushes in our
                                    //   Mach64 off-screen brush cache.
                                    //   Must be a power of two.

#define TOTAL_BRUSH_SIZE        64  // We'll only ever handle 8x8 patterns,
                                    //   and this is the number of pels

#define RBRUSH_2COLOR           1   // For RBRUSH flags

typedef struct _BRUSHENTRY BRUSHENTRY;
typedef union _RBRUSH_COLOR RBRUSH_COLOR;

typedef VOID (FNFILL)(PDEV*, LONG, RECTL*, ULONG, RBRUSH_COLOR, POINTL*);

typedef struct _RBRUSH {
    FLONG       fl;             // Type flags
    ULONG       ulForeColor;    // Foreground colour if 1bpp
    ULONG       ulBackColor;    // Background colour if 1bpp
    POINTL      ptlBrush;       // Monochrome brush's alignment
    FNFILL*     pfnFillPat;     // Fill routine to be called for this brush
    BRUSHENTRY* apbe[MAX_BOARDS];// Points to brush-entry that keeps track
                                //   of the cached off-screen brush bits
    ULONG       aulPattern[1];  // Open-ended array for keeping copy of the
      // Don't put anything     //   actual pattern bits in case the brush
      //   after here, or       //   origin changes, or someone else steals
      //   you'll be sorry!     //   our brush entry (declared as a ULONG
                                //   for proper dword alignment)

} RBRUSH;                           /* rb, prb */

typedef struct _BRUSHENTRY {
    RBRUSH*     prbVerify;      // We never dereference this pointer to
                                //   find a brush realization; it is only
                                //   ever used in a compare to verify
                                //   that for a given realized brush, our
                                //   off-screen brush entry is still valid.
    LONG        x;              // x-position of cached pattern
    LONG        y;              // y-position of cached pattern
    ULONG       ulOffsetPitch;  // Packed offset and pitch of cached brush
                                //   in off-screen memory on the Mach64

} BRUSHENTRY;                       /* be, pbe */

typedef union _RBRUSH_COLOR {
    RBRUSH*     prb;
    ULONG       iSolidColor;
} RBRUSH_COLOR;                     /* rbc, prbc */

BOOL bEnableBrushCache(PDEV*);
VOID vDisableBrushCache(PDEV*);
VOID vAssertModeBrushCache(PDEV*, BOOL);

//////////////////////////////////////////////////////////////////////
// Stretch stuff

typedef struct _STR_BLT {
    PDEV*   ppdev;
    PBYTE   pjSrcScan;
    LONG    lDeltaSrc;
    LONG    XSrcStart;
    PBYTE   pjDstScan;
    LONG    lDeltaDst;
    LONG    XDstStart;
    LONG    XDstEnd;
    LONG    YDstStart;
    LONG    YDstCount;
    ULONG   ulXDstToSrcIntCeil;
    ULONG   ulXDstToSrcFracCeil;
    ULONG   ulYDstToSrcIntCeil;
    ULONG   ulYDstToSrcFracCeil;
    ULONG   ulXFracAccumulator;
    ULONG   ulYFracAccumulator;
} STR_BLT;

typedef VOID (*PFN_DIRSTRETCH)(STR_BLT*);
typedef BOOL (FN_STRETCHDIB)(PDEV*, VOID*, LONG, RECTL*, VOID*, LONG, RECTL*, RECTL*);

VOID vDirectStretch8Narrow(STR_BLT*);
VOID vM64DirectStretch8(STR_BLT*);
VOID vM64DirectStretch16(STR_BLT*);
VOID vM64DirectStretch32(STR_BLT*);
VOID vM32DirectStretch8(STR_BLT*);
VOID vM32DirectStretch16(STR_BLT*);
VOID vI32DirectStretch8(STR_BLT*);
VOID vI32DirectStretch16(STR_BLT*);

FN_STRETCHDIB   bM64StretchDIB;
FN_STRETCHDIB   bM32StretchDIB;
FN_STRETCHDIB   bI32StretchDIB;

/////////////////////////////////////////////////////////////////////////
// Heap stuff

typedef enum {
    OH_FREE = 0,        // The off-screen allocation is available for use
    OH_DISCARDABLE,     // The allocation is occupied by a discardable bitmap
                        //   that may be moved out of off-screen memory
    OH_PERMANENT,       // The allocation is occupied by a permanent bitmap
                        //   that cannot be moved out of off-screen memory
} OHSTATE;

typedef struct _DSURF DSURF;
typedef struct _OH OH;
typedef struct _OH
{
    OHSTATE  ohState;       // State of off-screen allocation
    LONG     x;             // x-coordinate of left edge of allocation
    LONG     y;             // y-coordinate of top edge of allocation
    LONG     cx;            // Width in pixels of allocation
    LONG     cy;            // Height in pixels of allocation
    LONG     cxReserved;    // Dimensions of original reserved rectangle;
    LONG     cyReserved;    //   zero if rectangle is not 'reserved'
    OH*      pohNext;       // When OH_FREE or OH_RESERVE, points to the next
                            //   free node, in ascending cxcy value.  This is
                            //   kept as a circular doubly-linked list with a
                            //   sentinel at the end.
                            // When OH_DISCARDABLE, points to the next most
                            //   recently created allocation.  This is kept as
                            //   a circular doubly-linked list.
    OH*      pohPrev;       // Opposite of 'pohNext'
    ULONG    cxcy;          // Width and height in a dword for searching
    OH*      pohLeft;       // Adjacent allocation when in-use or available
    OH*      pohUp;
    OH*      pohRight;
    OH*      pohDown;
    DSURF*   pdsurf;        // Points to our DSURF structure
    VOID*    pvScan0;       // Points to start of first scan-line
};                              /* oh, poh */

// This is the smallest structure used for memory allocations:

typedef struct _OHALLOC OHALLOC;
typedef struct _OHALLOC
{
    OHALLOC* pohaNext;
    OH       aoh[1];
} OHALLOC;                      /* oha, poha */

typedef struct _HEAP
{
    LONG     cxMax;         // Largest possible free space by area
    LONG     cyMax;
    OH       ohFree;        // Head of the free list, containing those
                            //   rectangles in off-screen memory that are
                            //   available for use.  pohNext points to
                            //   hte smallest available rectangle, and pohPrev
                            //   points to the largest available rectangle,
                            //   sorted by cxcy.
    OH       ohDiscardable; // Head of the discardable list that contains all
                            //   bitmaps located in offscreen memory that
                            //   are eligible to be tossed out of the heap.
                            //   It is kept in order of creation: pohNext
                            //   points to the most recently created; pohPrev
                            //   points to the least recently created.
    OH       ohPermanent;   // List of permanently allocated rectangles
    OH*      pohFreeList;   // List of OH node data structures available
    OHALLOC* pohaChain;     // Chain of allocations
} HEAP;                         /* heap, pheap */

typedef enum {
    DT_SCREEN,              // Surface is kept in screen memory
    DT_DIB                  // Surface is kept as a DIB
} DSURFTYPE;                    /* dt, pdt */

typedef struct _DSURF
{
    DSURFTYPE dt;           // DSURF status (whether off-screen or in a DIB)
    SIZEL     sizl;         // Size of the original bitmap (could be smaller
                            //   than poh->sizl)
    PDEV*     ppdev;        // Need this for deleting the bitmap
    union {
        OH*         poh;    // If DT_SCREEN, points to off-screen heap node
        SURFOBJ*    pso;    // If DT_DIB, points to locked GDI surface
    };

    // The following are used for DT_DIB only...

    ULONG     cBlt;         // Counts down the number of blts necessary at
                            //   the current uniqueness before we'll consider
                            //   putting the DIB back into off-screen memory
    ULONG     iUniq;        // Tells us whether there have been any heap
                            //   'free's since the last time we looked at
                            //   this DIB

} DSURF;                          /* dsurf, pdsurf */

// GDI expects dword alignment for any bitmaps on which it is expected
// to draw.  Since we occasionally ask GDI to draw directly on our off-
// screen bitmaps, this means that any off-screen bitmaps must be dword
// aligned in the frame buffer.  We enforce this merely by ensuring that
// all off-screen bitmaps are four-pel aligned (we may waste a couple of
// pixels at the higher colour depths):

#define HEAP_X_ALIGNMENT    4

// Number of blts necessary before we'll consider putting a DIB DFB back
// into off-screen memory:

#define HEAP_COUNT_DOWN     6

// Flags for 'pohAllocate':

typedef enum {
    FLOH_ONLY_IF_ROOM       = 0x0001,   // Don't kick stuff out of off-
                                        //   screen memory to make room
    FLOH_MAKE_PERMANENT     = 0x0002,   // Allocate a permanent entry
    FLOH_RESERVE            = 0x0004,   // Allocate an off-screen entry,
                                        //   but let it be used by discardable
                                        //   bitmaps until it's needed
} FLOH;

// Publicly callable heap APIs:

OH*  pohAllocate(PDEV*, POINTL*, LONG, LONG, FLOH);
BOOL bOhCommit(PDEV*, OH*, BOOL);
OH*  pohFree(PDEV*, OH*);

OH*  pohMoveOffscreenDfbToDib(PDEV*, OH*);
BOOL bMoveDibToOffscreenDfbIfRoom(PDEV*, DSURF*);
BOOL bMoveAllDfbsFromOffscreenToDibs(PDEV* ppdev);

BOOL bEnableOffscreenHeap(PDEV*);
VOID vDisableOffscreenHeap(PDEV*);
BOOL bAssertModeOffscreenHeap(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// Bank manager stuff

#define BANK_DATA_SIZE  80      // Number of bytes to allocate for the
                                //   miniport down-loaded bank code working
                                //   space

typedef struct _BANK
{
    // Private data:

    RECTL    rclDraw;           // Rectangle describing the remaining undrawn
                                //   portion of the drawing operation
    RECTL    rclSaveBounds;     // Saved from original CLIPOBJ for restoration
    BYTE     iSaveDComplexity;  // Saved from original CLIPOBJ for restoration
    BYTE     fjSaveOptions;     // Saved from original CLIPOBJ for restoration
    LONG     iBank;             // Current bank
    PDEV*    ppdev;             // Saved copy

    // Public data:

    SURFOBJ* pso;               // Surface wrapped around the bank.  Has to be
                                //   passed as the surface in any banked call-
                                //   back.
    CLIPOBJ* pco;               // Clip object that is the intersection of the
                                //   original clip object with the bounds of the
                                //   current bank.  Has to be passed as the clip
                                //   object in any banked call-back.

} BANK;                         /* bnk, pbnk */

// Note: BANK_MODE is duplicated in i386\strucs.inc!

typedef enum {
    BANK_OFF = 0,       // We've finished using the memory aperture
    BANK_ON,            // We're about to use the memory aperture
    BANK_ON_NO_WAIT,    // We're about to use the memory aperture, and are
                        //   doing our own hardware synchronization
    BANK_DISABLE,       // We're about to enter full-screen; shut down banking
    BANK_ENABLE,        // We've exited full-screen; re-enable banking

} BANK_MODE;                    /* bankm, pbankm */

typedef struct _BANKDATA {
    ULONG ulDumb; // !!!!!!!!

} BANKDATA;                      /* bd, pbd */

typedef VOID (FNBANKMAP)(PDEV*, BANKDATA*, LONG);
typedef VOID (FNBANKSELECTMODE)(PDEV*, BANKDATA*, BANK_MODE);
typedef VOID (FNBANKINITIALIZE)(PDEV*, BANKDATA*);
typedef BOOL (FNBANKCOMPUTE)(PDEV*, RECTL*, RECTL*, LONG*, LONG*);

VOID vBankStart(PDEV*, RECTL*, CLIPOBJ*, BANK*);
BOOL bBankEnum(BANK*);

FNBANKCOMPUTE bBankComputeNonPower2;
FNBANKCOMPUTE bBankComputePower2;

BOOL bEnableBanking(PDEV*);
VOID vDisableBanking(PDEV*);
VOID vAssertModeBanking(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// Pointer stuff

#define MONO_POINTER_UP     0x0001
#define NO_HARDWARE_CURSOR  0x0002

#define CURSOR_CY   64
#define CURSOR_CX   64

typedef struct  _CUROBJ
{
    POINTL  ptlHotSpot;                 // Pointer hot spot
    SIZEL   szlPointer;                 // Extent of the pointer
    POINTL  ptlLastPosition;            // Last position of pointer
    POINTL  ptlLastOffset;              // Last offset from 0,0 within cursor
    ULONG   flPointer;                  // Pointer specific flags.
    ULONG   mono_offset;                // Hardware cursor offset
    POINTL  hwCursor;
} CUROBJ, *PCUROBJ;

BOOL bEnablePointer(PDEV*);
VOID vDisablePointer(PDEV*);
VOID vAssertModePointer(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// Palette stuff

BOOL bEnablePalette(PDEV*);
VOID vDisablePalette(PDEV*);
VOID vAssertModePalette(PDEV*, BOOL);

BOOL bInitializePalette(PDEV*, DEVINFO*);
VOID vUninitializePalette(PDEV*);

#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))

#define REDSHIFT    ((ppdev->flRed & 1)?   0:((ppdev->flRed & 0x100)?   8:16))
#define GREENSHIFT  ((ppdev->flGreen & 1)? 0:((ppdev->flGreen & 0x100)? 8:16))
#define BLUESHIFT   ((ppdev->flBlue & 1)?  0:((ppdev->flBlue & 0x100)?  8:16))

//////////////////////////////////////////////////////////////////////
// Low-level blt function prototypes

typedef VOID (FNXFER)(PDEV*, LONG, RECTL*, ULONG, SURFOBJ*, POINTL*,
                      RECTL*, XLATEOBJ*);
typedef VOID (FNCOPY)(PDEV*, LONG, RECTL*, ULONG, POINTL*, RECTL*);
typedef BOOL (FNTEXTOUT)(PDEV*, STROBJ*, FONTOBJ*, CLIPOBJ*, RECTL*,
                         BRUSHOBJ*, BRUSHOBJ*);
typedef VOID (FNLINETOTRIVIAL)(PDEV*, LONG, LONG, LONG, LONG, ULONG, MIX, RECTL*);
typedef VOID (FNPATREALIZE)(PDEV*, RBRUSH*);

FNFILL              vI32FillPatColor;
FNFILL              vI32FillPatMonochrome;
FNFILL              vI32FillSolid;
FNXFER              vI32Xfer1bpp;
FNXFER              vI32Xfer4bpp;
FNXFER              vI32Xfer8bpp;
FNXFER              vI32XferNative;
FNCOPY              vI32CopyBlt;
FNLINETOTRIVIAL     vI32LineToTrivial;
FNTEXTOUT           bI32TextOut;

FNFILL              vM32FillPatColor;
FNFILL              vM32FillPatMonochrome;
FNFILL              vM32FillSolid;
FNXFER              vM32Xfer1bpp;
FNXFER              vM32Xfer4bpp;
FNXFER              vM32Xfer8bpp;
FNXFER              vM32XferNative;
FNCOPY              vM32CopyBlt;
FNLINETOTRIVIAL     vM32LineToTrivial;
FNTEXTOUT           bM32TextOut;

FNFILL              vM64FillPatColor;
FNFILL              vM64FillPatMonochrome;
FNFILL              vM64FillSolid;
FNXFER              vM64Xfer1bpp;
FNXFER              vM64Xfer4bpp;
FNXFER              vM64Xfer8bpp;
FNXFER              vM64XferNative;
FNCOPY              vM64CopyBlt;
FNCOPY              vM64CopyBlt_VTA4;
FNLINETOTRIVIAL     vM64LineToTrivial;
FNTEXTOUT           bM64TextOut;
FNPATREALIZE        vM64PatColorRealize;

FNFILL              vM64FillPatColor24;
FNFILL              vM64FillPatMonochrome24;
FNFILL              vM64FillSolid24;
FNXFER              vM64XferNative24;
FNCOPY              vM64CopyBlt24;
FNCOPY              vM64CopyBlt24_VTA4;
FNLINETOTRIVIAL     vM64LineToTrivial24;
FNTEXTOUT           bM64TextOut24;

typedef VOID (FNXFERBITS)(PDEV*, SURFOBJ*, RECTL*, POINTL*);

FNXFERBITS          vPutBits;
FNXFERBITS          vGetBits;
FNXFERBITS          vI32PutBits;
FNXFERBITS          vI32GetBits;

//////////////////////////////////////////////////////////////////////
// Low-level hardware cursor function prototypes

typedef VOID (FNSETCURSOROFFSET)(PDEV*);
typedef VOID (FNUPDATECURSOROFFSET)(PDEV*,LONG,LONG,LONG);
typedef VOID (FNUPDATECURSORPOSITION)(PDEV*,LONG,LONG);
typedef VOID (FNCURSOROFF)(PDEV*);
typedef VOID (FNCURSORON)(PDEV*,LONG);
typedef VOID (FNPOINTERBLIT)(PDEV*,LONG,LONG,LONG,LONG,BYTE*,LONG);

FNSETCURSOROFFSET       vM64SetCursorOffset;
FNUPDATECURSOROFFSET    vM64UpdateCursorOffset;
FNUPDATECURSORPOSITION  vM64UpdateCursorPosition;
FNCURSOROFF             vM64CursorOff;
FNCURSORON              vM64CursorOn;
FNSETCURSOROFFSET       vM64SetCursorOffset_TVP;
FNUPDATECURSOROFFSET    vM64UpdateCursorOffset_TVP;
FNUPDATECURSORPOSITION  vM64UpdateCursorPosition_TVP;
FNCURSOROFF             vM64CursorOff_TVP;
FNCURSORON              vM64CursorOn_TVP;
FNSETCURSOROFFSET       vM64SetCursorOffset_IBM514;
FNUPDATECURSOROFFSET    vM64UpdateCursorOffset_IBM514;
FNUPDATECURSORPOSITION  vM64UpdateCursorPosition_IBM514;
FNCURSOROFF             vM64CursorOff_IBM514;
FNCURSORON              vM64CursorOn_IBM514;
FNUPDATECURSOROFFSET    vM64UpdateCursorOffset_CT;
FNCURSOROFF             vM64CursorOff_CT;
FNCURSORON              vM64CursorOn_CT;
FNPOINTERBLIT           vM64PointerBlit;
FNPOINTERBLIT           vM64PointerBlit_TVP;
FNPOINTERBLIT           vM64PointerBlit_IBM514;

FNSETCURSOROFFSET       vI32SetCursorOffset;
FNUPDATECURSOROFFSET    vI32UpdateCursorOffset;
FNUPDATECURSORPOSITION  vI32UpdateCursorPosition;
FNCURSOROFF             vI32CursorOff;
FNCURSORON              vI32CursorOn;
FNPOINTERBLIT           vI32PointerBlit;

FNPOINTERBLIT           vPointerBlitLFB;

#if TARGET_BUILD > 351

///////////////////////////////////////////////////////////////////////
// DirectDraw stuff

typedef struct _FLIPRECORD
{
    FLATPTR         fpFlipFrom;
    LONGLONG        liFlipTime;
    LONGLONG        liFlipDuration;
    DWORD           wFlipScanLine;
    BOOL            bHaveEverCrossedVBlank;
    BOOL            bWasEverInDisplay;
    BOOL            bFlipFlag;
    WORD            wstartOfVBlank;// only used in MACH32

} FLIPRECORD;
typedef FLIPRECORD *LPFLIPRECORD;

#define ROUND_UP_TO_64K(x)  (((ULONG)(x) + 0x10000 - 1) & ~(0x10000 - 1))
#define ROUND_DOWN_TO_64K(x)  (((ULONG)(x) & 0xFFFF0000 ))

BOOL bEnableDirectDraw(PDEV*);
VOID vDisableDirectDraw(PDEV*);
VOID vAssertModeDirectDraw(PDEV*, BOOL);

#endif

////////////////////////////////////////////////////////////////////////
// Capabilities flags

typedef enum {
    CAPS_MONOCHROME_PATTERNS = 1,       // Hardware has 8x8 monochrome pattern
                                        //   capability in this mode
    CAPS_COLOR_PATTERNS      = 2,       // Capable of colour patterns.  I.e.,
                                        //   running at 8bpp on Mach32, and
                                        //   a brush cache has been allocated
                                        //   on the Mach64
    CAPS_LINEAR_FRAMEBUFFER  = 4,       // Frame buffer is mapped linearly
} CAPS;

// DIRECT_ACCESS returns TRUE if there is any sort of aperture that
// can be directly accessed:

#define DIRECT_ACCESS(ppdev)    (ppdev->iAperture != APERTURE_NONE)

////////////////////////////////////////////////////////////////////////
// The Physical Device data structure

typedef struct  _PDEV
{
#ifdef  OGLMCD     //start OGLMCD support

    DWORD   dwSize;    // size of PDEV structure; used by atimcd.dll

    // All the OpenGL MCD support in the PDEV must be at the begining of the structure
    // because atimcd.dll and ati.dll don't have to be in sync, but any additions to PDEV
    // that can affect the MCD used field's offset in the structure will break the MCD

    // new fields for MCDOGL containing revision no.
    BYTE        MCDMajorRev;
    BYTE        MCDMinorRev;


        ////////// This is only for OGL MCD support
        //functions pointers to ALLOC and FREE functions from heap.c
        // CJ PFN             pohAllocate;
        // CJ PFN             pohFree;
        OH*  (*pohAllocate)(PDEV*, POINTL*, LONG, LONG, FLOH);
        OH*  (*pohFree)(PDEV*, OH*);

    ULONG       iUniqueness;            // display uniqueness for tracking
                                        // resolution changes
    LONG        cDoubleBufferRef;       // Reference count for current number
                                        //   of RC's that have active double-
                                        //   buffers
    OH*         pohBackBuffer;          // Our 2-d heap allocation structure
                                        //   for the back-buffer
    ULONG       ulBackBuffer;           // Byte offset in the frame buffer
                                        //   to the start of the back-buffer
    LONG        cZBufferRef;            // Reference count for current number
                                        //   of RC's that have active z-buffers
                                        //   (which, on Athenta, is all RC's)
    OH*         pohZBuffer;             // Our 2-d heap allocation structure
                                        //   for the z-buffer
    ULONG       ulFrontZBuffer;         // Byte offset in the frame buffer
                                        //   to the start of the front z-buffer
                                        //   (the MGA sometimes has to have
                                        //   separate z-buffers for front and
                                        //   back)
    ULONG       ulBackZBuffer;          // Byte offset in the frame buffer
                                        //   to the start of the back z-buffer

    HANDLE      hMCD;                   // Handle to MCD engine dll
    MCDENGESCFILTERFUNC pMCDFilterFunc; // MCD engine filter function

    HANDLE          hMCD_ATI;                               // Handle to ATI MCD driver dll
    PFN                     pMCDrvGetEntryPoints;   // ATI MCD function for filling supported functions index

#endif                  // end OGLMCD

    LONG        xOffset;                // Pixel offset from (0, 0) to current
    LONG        yOffset;                //   DFB located in off-screen memory
    BYTE*       pjMmBase;               // Start of memory mapped I/O
    BYTE*       VideoRamBase;           // fixup for pjMmBase so that vDisableHardware can free it
    UCHAR*      pjIoBase;               // Start of I/O space (NULL on x86)
    BYTE*       pjScreen;               // Points to base screen address
    LONG        lDelta;                 // Distance from one scan to the next.
    LONG        cPelSize;               // 0 if 8bpp, 1 if 16bpp, 2 if 32bpp
    LONG        cjPelSize;              // 1 if 8bpp, 2 if 16bpp, 3 if 24bpp,
                                        //   4 if 32bpp
    ULONG       iBitmapFormat;          // BMF_8BPP or BMF_16BPP or BMF_32BPP
                                        //   (our current colour depth)
    LONG        iBoard;                 // Logical multi-board identifier
                                        //   (zero by default)

    // Important data for accessing the frame buffer.

    VOID*               pvBankData;         // Points to aulBankData[0]
    FNBANKSELECTMODE*   pfnBankSelectMode;  // Routine to enable or disable
                                            //   direct frame buffer access
    BANK_MODE           bankmOnOverlapped;  // BANK_ON or BANK_ON_NO_WAIT,
                                            //   depending on whether card
                                            //   can handle simulataneous
                                            //   frame buffer and accelerator
                                            //   access

    // -------------------------------------------------------------------
    // NOTE: Changes up to here in the PDEV structure must be reflected in
    // i386\strucs.inc (assuming you're on an x86, of course)!

    ASIC        iAsic;                  // Specific Mach ASIC type
    APERTURE    iAperture;              // Aperture type
    ULONG       ulTearOffset;           // For uneven scans in 1152 or 1280 in 24bpp, and 1600 in 16bpp (mach64 only)
    ULONG       ulVramOffset;           // ulTearOffset / 8
    ULONG       ulScreenOffsetAndPitch; // Screen offset and pitch for primary
                                        //   display
    ULONG       ulMonoPixelWidth;       // Default value of DP_PIX_WID register
    ULONG       SetGuiEngineDefault;    // new feature for Rage II+ and above

    CAPS        flCaps;                 // Capabilities flags
    BOOL        bEnabled;               // In graphics mode (not full-screen)

    HANDLE      hDriver;                // Handle to \Device\Screen
    HDEV        hdevEng;                // Engine's handle to PDEV
    HSURF       hsurfScreen;            // Engine's handle to screen surface
    DSURF*      pdsurfScreen;           // Our private DSURF for the screen
    HSURF       hsurfPunt;              // Just for 24bpp mach32 with linear aperture

    LONG        cxScreen;               // Visible screen width
    LONG        cyScreen;               // Visible screen height
    LONG        cxMemory;               // Width of Video RAM
    LONG        cyMemory;               // Height of Video RAM
    LONG        cBitsPerPel;            // Bits per pel (8, 15, 16, 24 or 32)
    ULONG       ulMode;                 // Mode the mini-port driver is in.

    FLONG       flHooks;                // What we're hooking from GDI
    ULONG       ulWhite;                // 0xff if 8bpp, 0xffff if 16bpp,
                                        //   0xffffffff if 32bpp
    VOID*       pvTmpBuffer;            // General purpose temporary buffer,
                                        //   TMP_BUFFER_SIZE bytes in size
                                        //   (Remember to synchronize if you
                                        //   use this for device bitmaps or
                                        //   async pointers)

    MACHTYPE    iMachType;              // Type of I/O to do based on Mach type
    ULONG       FeatureFlags;           // ENH_VERSION_NT FeatureFlags

    ATI_MODE_INFO *pModeInfo;           // ATI-specific mode information (see ATINT.H)

    ////////// Context stuff

    BYTE        *pjContextBase;
    ULONG       ulContextCeiling;       // Keep track of available contexts
    ULONG       iDefContext;            // Used to initialize graphics operations

    ////////// Low-level blt function pointers:

    FNFILL*           pfnFillSolid;
    FNFILL*           pfnFillPatColor;
    FNFILL*           pfnFillPatMonochrome;
    FNXFER*           pfnXfer1bpp;
    FNXFER*           pfnXfer4bpp;
    FNXFER*           pfnXfer8bpp;
    FNXFER*           pfnXferNative;
    FNCOPY*           pfnCopyBlt;
    FNTEXTOUT*        pfnTextOut;
    FNLINETOTRIVIAL*  pfnLineToTrivial;

    FNXFERBITS*       pfnGetBits;
    FNXFERBITS*       pfnPutBits;

    ////////// Palette stuff:

    PALETTEENTRY* pPal;                 // The palette if palette managed
    HPALETTE    hpalDefault;            // GDI handle to the default palette.
    FLONG       flRed;                  // Red mask for 16/32bpp bitfields
    FLONG       flGreen;                // Green mask for 16/32bpp bitfields
    FLONG       flBlue;                 // Blue mask for 16/32bpp bitfields
    ULONG       cPaletteShift;          // number of bits the 8-8-8 palette must
                                        // be shifted by to fit in the hardware
                                        // palette.
    ////////// Heap stuff:

    HEAP        heap;                   // All our off-screen heap data
    ULONG       iHeapUniq;              // Incremented every time room is freed
                                        //   in the off-screen heap
    SURFOBJ*    psoPunt;                // Wrapper surface for having GDI draw
                                        //   on off-screen bitmaps
    SURFOBJ*    psoPunt2;               // Another one for off-screen to off-
                                        //   screen blts
    OH*         pohScreen;              // Off-screen heap structure for the
                                        //   visible screen

    ////////// Banking stuff:

    LONG        cjBank;                 // Size of a bank, in bytes
    LONG        cPower2ScansPerBank;    // Used by 'bBankComputePower2'
    LONG        cPower2BankSizeInBytes; // Used by 'bBankComputePower2'
    CLIPOBJ*    pcoBank;                // Clip object for banked call backs
    SURFOBJ*    psoBank;                // Surface object for banked call backs
    ULONG       aulBankData[BANK_DATA_SIZE / 4];
                                        // Private work area for downloaded
                                        //   miniport banking code

    FNBANKMAP*      pfnBankMap;
    FNBANKCOMPUTE*  pfnBankCompute;

    ////////// Pointer stuff:

    CUROBJ  pointer1;                   // pointer double-buffering
    CUROBJ  pointer2;                   // pointer double-buffering
    CUROBJ *ppointer;
    BOOL    bAltPtrActive;

    FNSETCURSOROFFSET*      pfnSetCursorOffset;
    FNUPDATECURSOROFFSET*   pfnUpdateCursorOffset;
    FNUPDATECURSORPOSITION* pfnUpdateCursorPosition;
    FNCURSOROFF*            pfnCursorOff;
    FNCURSORON*             pfnCursorOn;
    FNPOINTERBLIT*          pfnPointerBlit;

    ////////// Brush stuff:

    LONG        iBrushCache;            // Index for next brush to be allcoated
    BRUSHENTRY  abe[TOTAL_BRUSH_COUNT]; // Keeps track of off-screen brush
                                        //   cache

    ////////// Text stuff:

    SURFOBJ*    psoText;                // 1bpp surface to which we will have
                                        //   GDI draw our glyphs for us

    ////////// Stretch stuff:

    FN_STRETCHDIB*          pfnStretchDIB;

    BYTE*       pjMmBase_Ext;               // Start of memory mapped I/O

 ////////// Palindrome stuff:
#if   PAL_SUPPORT
    //structure specific for pal support
    PPDEV_PAL_NT  pal_str;
#endif      // PALINDROME_SUPPORT

 ////////// Palindrome and Overlay common stuff:
DWORD   semph_overlay;              // this semaphore is used for allocating the overlay resource:
                                                        //  = 0 ; resource free
                                                        //  = 1 ; in use by DDraw
                                                        //  = 2 ; in use by Palindrome


#if TARGET_BUILD > 351
    ////////// DirectDraw stuff:
    BOOL  bPassVBlank;                    // flag used for detecting the VBlank hang on GX cards on high speed multiprocessors machines

    FLIPRECORD  flipRecord;             //  Used to track VBlank status
    OH*         pohDirectDraw;          //  Off-screen heap allocation for use
                                        //      by DirectDraw
    // STUFF FOR OVERLAY SUPPORT

    // this must be in ppdev
    OVERLAYINFO16 OverlayInfo16;
     // the following variables maybe should be in ppdev
    DWORD OverlayWidth,OverlayHeight; //the last updated overlay's width and height
    DWORD OverlayScalingDown;

    FLATPTR     fpVisibleOverlay;       // Frame buffer offset to currently
                                                        //   visible overlay; will be zero if
                                                        //   no overlay is visible
    DWORD       dwOverlayFlipOffset;    // Overlay flip offset
    // END STUFF FOR OVERLAY SUPP

#endif

} PDEV;

/////////////////////////////////////////////////////////////////////////
// Miscellaneous prototypes:

BOOL bIntersect(RECTL*, RECTL*, RECTL*);
LONG cIntersect(RECTL*, RECTL*, LONG);
DWORD getAvailableModes(HANDLE, PVIDEO_MODE_INFORMATION*, DWORD*);

BOOL bInitializeModeFields(PDEV*, GDIINFO*, DEVINFO*, DEVMODEW*);
BOOL bFastFill(PDEV*, LONG, POINTFIX*, ULONG, ULONG, RBRUSH*, POINTL*, RECTL*);

BOOL bEnableHardware(PDEV*);
VOID vDisableHardware(PDEV*);
BOOL bAssertModeHardware(PDEV*, BOOL);

extern BYTE gaRop3FromMix[];
extern ULONG gaul32HwMixFromMix[];
extern ULONG gaul64HwMixFromMix[];
extern ULONG gaul32HwMixFromRop2[];
extern ULONG gaul64HwMixFromRop2[];

/////////////////////////////////////////////////////////////////////////
// The x86 C compiler insists on making a divide and modulus operation
// into two DIVs, when it can in fact be done in one.  So we use this
// macro.
//
// Note: QUOTIENT_REMAINDER implicitly takes unsigned arguments.

#if defined(_X86_)

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    __asm mov eax, ulNumerator                                  \
    __asm sub edx, edx                                          \
    __asm div ulDenominator                                     \
    __asm mov ulQuotient, eax                                   \
    __asm mov ulRemainder, edx                                  \
}

#else

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    ulQuotient  = (ULONG) ulNumerator / (ULONG) ulDenominator;  \
    ulRemainder = (ULONG) ulNumerator % (ULONG) ulDenominator;  \
}

#endif

/////////////////////////////////////////////////////////////////////////
// OVERLAP - Returns TRUE if the same-size lower-right exclusive
//           rectangles defined by 'pptl' and 'prcl' overlap:

#define OVERLAP(prcl, pptl)                                             \
    (((prcl)->right  > (pptl)->x)                                   &&  \
     ((prcl)->bottom > (pptl)->y)                                   &&  \
     ((prcl)->left   < ((pptl)->x + (prcl)->right - (prcl)->left))  &&  \
     ((prcl)->top    < ((pptl)->y + (prcl)->bottom - (prcl)->top)))

/////////////////////////////////////////////////////////////////////////
// SWAP - Swaps the value of two variables, using a temporary variable

#define SWAP(a, b, tmp) { (tmp) = (a); (a) = (b); (b) = (tmp); }

//////////////////////////////////////////////////////////////////////
// These Mul prototypes are thunks for multi-board support:

ULONG   MulGetModes(HANDLE, ULONG, DEVMODEW*);
DHPDEV  MulEnablePDEV(DEVMODEW*, PWSTR, ULONG, HSURF*, ULONG, ULONG*,
                      ULONG, DEVINFO*, HDEV, PWSTR, HANDLE);
VOID    MulCompletePDEV(DHPDEV, HDEV);
HSURF   MulEnableSurface(DHPDEV);
BOOL    MulStrokePath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, XFORMOBJ*, BRUSHOBJ*,
                      POINTL*, LINEATTRS*, MIX);
BOOL    MulFillPath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*,
                    MIX, FLONG);
BOOL    MulBitBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                  RECTL*, POINTL*, POINTL*, BRUSHOBJ*, POINTL*, ROP4);
VOID    MulDisablePDEV(DHPDEV);
VOID    MulDisableSurface(DHPDEV);
BOOL    MulAssertMode(DHPDEV, BOOL);
VOID    MulMovePointer(SURFOBJ*, LONG, LONG, RECTL*);
ULONG   MulSetPointerShape(SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*, LONG,
                           LONG, LONG, LONG, RECTL*, FLONG);
ULONG   MulDitherColor(DHPDEV, ULONG, ULONG, ULONG*);
BOOL    MulSetPalette(DHPDEV, PALOBJ*, FLONG, ULONG, ULONG);
BOOL    MulCopyBits(SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*, POINTL*);
BOOL    MulTextOut(SURFOBJ*, STROBJ*, FONTOBJ*, CLIPOBJ*, RECTL*, RECTL*,
                   BRUSHOBJ*, BRUSHOBJ*, POINTL*, MIX);
VOID    MulDestroyFont(FONTOBJ*);
BOOL    MulPaint(SURFOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*, MIX);
BOOL    MulRealizeBrush(BRUSHOBJ*, SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*,
                        ULONG);
HBITMAP MulCreateDeviceBitmap(DHPDEV, SIZEL, ULONG);
VOID    MulDeleteDeviceBitmap(DHSURF);
BOOL    MulStretchBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                      COLORADJUSTMENT*, POINTL*, RECTL*, RECTL*, POINTL*,
                      ULONG);

// These Dbg prototypes are thunks for debugging:

VOID    DbgDisableDriver(VOID);
ULONG   DbgGetModes(HANDLE, ULONG, DEVMODEW*);
DHPDEV  DbgEnablePDEV(DEVMODEW*, PWSTR, ULONG, HSURF*, ULONG, ULONG*,
                      ULONG, DEVINFO*, HDEV, PWSTR, HANDLE);
VOID    DbgCompletePDEV(DHPDEV, HDEV);
HSURF   DbgEnableSurface(DHPDEV);
BOOL    DbgLineTo(SURFOBJ*, CLIPOBJ*, BRUSHOBJ*, LONG, LONG, LONG, LONG,
                  RECTL*, MIX);
BOOL    DbgStrokePath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, XFORMOBJ*, BRUSHOBJ*,
                      POINTL*, LINEATTRS*, MIX);
BOOL    DbgFillPath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*,
                    MIX, FLONG);
BOOL    DbgBitBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                  RECTL*, POINTL*, POINTL*, BRUSHOBJ*, POINTL*, ROP4);
VOID    DbgDisablePDEV(DHPDEV);
VOID    DbgDisableSurface(DHPDEV);
#if TARGET_BUILD > 351
BOOL    DbgAssertMode(DHPDEV, BOOL);
#else
VOID    DbgAssertMode(DHPDEV, BOOL);
#endif
VOID    DbgMovePointer(SURFOBJ*, LONG, LONG, RECTL*);
ULONG   DbgSetPointerShape(SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*, LONG,
                           LONG, LONG, LONG, RECTL*, FLONG);
ULONG   DbgDitherColor(DHPDEV, ULONG, ULONG, ULONG*);
BOOL    DbgSetPalette(DHPDEV, PALOBJ*, FLONG, ULONG, ULONG);
BOOL    DbgCopyBits(SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*, POINTL*);
BOOL    DbgTextOut(SURFOBJ*, STROBJ*, FONTOBJ*, CLIPOBJ*, RECTL*, RECTL*,
                   BRUSHOBJ*, BRUSHOBJ*, POINTL*, MIX);
VOID    DbgDestroyFont(FONTOBJ*);
BOOL    DbgPaint(SURFOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*, MIX);
BOOL    DbgRealizeBrush(BRUSHOBJ*, SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*,
                        ULONG);
HBITMAP DbgCreateDeviceBitmap(DHPDEV, SIZEL, ULONG);
VOID    DbgDeleteDeviceBitmap(DHSURF);
BOOL    DbgStretchBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                      COLORADJUSTMENT*, POINTL*, RECTL*, RECTL*, POINTL*,
                      ULONG);
ULONG   DbgEscape(SURFOBJ*, ULONG, ULONG, VOID*, ULONG, VOID*);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\fastfill.c ===
/******************************Module*Header*******************************\
* Module Name: fastfill.c
*
* Fast routine for drawing polygons that aren't complex in shape.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#define RIGHT 0
#define LEFT  1

typedef struct _TRAPEZOIDDATA TRAPEZOIDDATA;    // Handy forward declaration

typedef VOID (FNTRAPEZOID)(TRAPEZOIDDATA*, LONG, LONG);
                                                // Prototype for trapezoid
                                                //   drawing routines

typedef struct _EDGEDATA {
LONG      x;                // Current x position
LONG      dx;               // # pixels to advance x on each scan
LONG      lError;           // Current DDA error
LONG      lErrorUp;         // DDA error increment on each scan
LONG      dN;               // Signed delta-y in fixed point form (also known
                            //   as the DDA error adjustment, and used to be
                            //   called 'lErrorDown')
LONG      dM;               // Signed delta-x in fixed point form
POINTFIX* pptfx;            // Points to start of current edge
LONG      dptfx;            // Delta (in bytes) from pptfx to next point
LONG      cy;               // Number of scans to go for this edge
LONG      bNew;             // Set to TRUE when a new DDA must be started
                            //   for the edge.
} EDGEDATA;                         /* ed, ped */

typedef struct _TRAPEZOIDDATA {
FNTRAPEZOID*    pfnTrap;    // Pointer to appropriate trapezoid drawing routine,
                            //   or trapezoid clip routine
FNTRAPEZOID*    pfnTrapClip;// Pointer to appropriate trapezoid drawing routine
                            //   if doing clipping
PDEV*           ppdev;      // Pointer to PDEV
EDGEDATA        aed[2];     // DDA information for both edges
POINTL          ptlBrush;   // Brush alignment
LONG            yClipTop;   // Top of clip rectangle
LONG            yClipBottom;// Bottom of clip rectangle

// ATI specific fields follow:

RBRUSH*         prb;        // Pointer to realized brush
BOOL            bOverpaint; // For colour pattern copies, indicates whether
                            //   PATCOPY or not

} TRAPEZOIDDATA;                    /* td, ptd */

/******************************Public*Routine******************************\
* VOID vClipTrapezoid
*
* Clips a trapezoid.
*
* NOTE: This routine assumes that the polygon's dimensions are small
*       enough that its QUOTIENT_REMAINDER calculations won't overflow.
*       This means that large polygons must never make it here.
*
\**************************************************************************/

VOID vClipTrapezoid(
TRAPEZOIDDATA*  ptd,
LONG            yTrapTop,
LONG            cyTrapezoid)
{
    LONG    yTrapBottom;
    LONG    dN;
    LONG    lNum;
    LONG    xDelta;
    LONG    lError;

    yTrapBottom = yTrapTop + cyTrapezoid;

    if (yTrapTop < ptd->yClipTop)
    {
        if ((ptd->aed[LEFT].bNew) &&
            (yTrapBottom + ptd->aed[LEFT].cy > ptd->yClipTop))
        {
            dN   = ptd->aed[LEFT].dN;
            lNum = ptd->aed[LEFT].dM * (ptd->yClipTop - yTrapTop)
                 + (ptd->aed[LEFT].lError + dN);

            if (lNum >= 0)
            {
                QUOTIENT_REMAINDER(lNum, dN, xDelta, lError);
            }
            else
            {
                lNum = -lNum;

                QUOTIENT_REMAINDER(lNum, dN, xDelta, lError);

                xDelta = -xDelta;
                if (lError != 0)
                {
                    xDelta--;
                    lError = dN - lError;
                }
            }

            ptd->aed[LEFT].x     += xDelta;
            ptd->aed[LEFT].lError = lError - dN;
        }

        if ((ptd->aed[RIGHT].bNew) &&
            (yTrapBottom + ptd->aed[RIGHT].cy > ptd->yClipTop))
        {
            dN   = ptd->aed[RIGHT].dN;
            lNum = ptd->aed[RIGHT].dM * (ptd->yClipTop - yTrapTop)
                 + (ptd->aed[RIGHT].lError + dN);

            if (lNum >= 0)
            {
                QUOTIENT_REMAINDER(lNum, dN, xDelta, lError);
            }
            else
            {
                lNum = -lNum;

                QUOTIENT_REMAINDER(lNum, dN, xDelta, lError);

                xDelta = -xDelta;
                if (lError != 0)
                {
                    xDelta--;
                    lError = dN - lError;
                }
            }

            ptd->aed[RIGHT].x     += xDelta;
            ptd->aed[RIGHT].lError = lError - dN;
        }
    }

    // If this trapezoid vertically intersects our clip rectangle, draw it:

    if ((yTrapBottom > ptd->yClipTop) &&
        (yTrapTop    < ptd->yClipBottom))
    {
        if (yTrapTop <= ptd->yClipTop)
        {
            yTrapTop = ptd->yClipTop;

            // Have to let trapezoid drawer know that it has to load
            // its DDAs for very first trapezoid drawn:

            ptd->aed[RIGHT].bNew = TRUE;
            ptd->aed[LEFT].bNew  = TRUE;
        }

        if (yTrapBottom >= ptd->yClipBottom)
        {
            yTrapBottom = ptd->yClipBottom;
        }

        ptd->pfnTrapClip(ptd, yTrapTop, yTrapBottom - yTrapTop);
    }
}

/******************************Public*Routine******************************\
* VOID vI32SolidTrapezoid
*
* Draws a solid trapezoid using a software DDA.
*
\**************************************************************************/

VOID vI32SolidTrapezoid(
TRAPEZOIDDATA*  ptd,
LONG            yTrapezoid,
LONG            cyTrapezoid)
{
    PDEV*       ppdev;
    BYTE*       pjIoBase;
    LONG        xOffset;
    LONG        lLeftError;
    LONG        xLeft;
    LONG        lRightError;
    LONG        xRight;
    LONG        lTmp;
    EDGEDATA    edTmp;

    // Note that CUR_Y is already set...

    ppdev = ptd->ppdev;
    pjIoBase    = ppdev->pjIoBase;
    xOffset     = ppdev->xOffset;
    yTrapezoid += ppdev->yOffset;

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((ptd->aed[LEFT].lErrorUp | ptd->aed[RIGHT].lErrorUp) == 0) &&
        ((ptd->aed[LEFT].dx       | ptd->aed[RIGHT].dx) == 0))
    {
        /////////////////////////////////////////////////////////////////
        // Vertical-edge special case

        xLeft  = ptd->aed[LEFT].x + xOffset;
        xRight = ptd->aed[RIGHT].x + xOffset;
        if (xLeft > xRight)
        {
            SWAP(xLeft,          xRight,          lTmp);
            SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
        }

        if (xLeft < xRight)
        {
            I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 4);
            I32_OW(pjIoBase, CUR_X,        xLeft);
            I32_OW(pjIoBase, DEST_X_START, xLeft);
            I32_OW(pjIoBase, DEST_X_END,   xRight);
            I32_OW(pjIoBase, DEST_Y_END,   yTrapezoid + cyTrapezoid);
        }
        else
        {
            I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 1);
            I32_OW(pjIoBase, CUR_Y, yTrapezoid + cyTrapezoid);
        }
    }
    else
    {
        lLeftError  = ptd->aed[LEFT].lError;
        xLeft       = ptd->aed[LEFT].x + xOffset;
        lRightError = ptd->aed[RIGHT].lError;
        xRight      = ptd->aed[RIGHT].x + xOffset;

        while (TRUE)
        {
            /////////////////////////////////////////////////////////////////
            // Run the DDAs

            if (xLeft < xRight)
            {
                // Note that we don't need to set DEST_X_START because
                // we're always doing blts that are only one scan high.
                //
                // The ATI is nice enough to always automatically advance
                // CUR_Y to become DEST_Y_END after the blt is done, so we
                // never have to update it:

                I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 3);
                I32_OW(pjIoBase, CUR_X,      xLeft);
                I32_OW(pjIoBase, DEST_X_END, xRight);
                yTrapezoid++;
                I32_OW(pjIoBase, DEST_Y_END, yTrapezoid);
            }
            else if (xLeft > xRight)
            {
                // We don't bother optimizing this case because we should
                // rarely get self-intersecting polygons (if we're slow,
                // the app gets what it deserves).

                SWAP(xLeft,          xRight,          lTmp);
                SWAP(lLeftError,     lRightError,     lTmp);
                SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
                continue;
            }
            else
            {
                yTrapezoid++;
                I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 1);
                I32_OW(pjIoBase, CUR_Y, yTrapezoid);
            }

            // Advance the right wall:

            xRight      += ptd->aed[RIGHT].dx;
            lRightError += ptd->aed[RIGHT].lErrorUp;

            if (lRightError >= 0)
            {
                lRightError -= ptd->aed[RIGHT].dN;
                xRight++;
            }

            // Advance the left wall:

            xLeft      += ptd->aed[LEFT].dx;
            lLeftError += ptd->aed[LEFT].lErrorUp;

            if (lLeftError >= 0)
            {
                lLeftError -= ptd->aed[LEFT].dN;
                xLeft++;
            }

            cyTrapezoid--;
            if (cyTrapezoid == 0)
                break;
        }

        ptd->aed[LEFT].lError  = lLeftError;
        ptd->aed[LEFT].x       = xLeft - xOffset;
        ptd->aed[RIGHT].lError = lRightError;
        ptd->aed[RIGHT].x      = xRight - xOffset;
    }
}

/******************************Public*Routine******************************\
* VOID vI32ColorPatternTrapezoid
*
* Draws a patterned trapezoid using a software DDA.
*
\**************************************************************************/

VOID vI32ColorPatternTrapezoid(
TRAPEZOIDDATA*  ptd,
LONG            yTrapezoid,
LONG            cyTrapezoid)
{
    PDEV*       ppdev;
    BYTE*       pjIoBase;
    LONG        xOffset;
    LONG        lLeftError;
    LONG        xLeft;
    LONG        lRightError;
    LONG        xRight;
    LONG        lTmp;
    EDGEDATA    edTmp;
    BYTE*       pjPatternStart;
    WORD*       pwPattern;
    LONG        xBrush;
    LONG        yPattern;
    LONG        cyRoll;

    ppdev = ptd->ppdev;
    pjIoBase    = ppdev->pjIoBase;
    xOffset     = ppdev->xOffset;
    yTrapezoid += ppdev->yOffset;

    pjPatternStart = (BYTE*) &ptd->prb->aulPattern[0];

    // xBrush needs to be shifted by DFB alignment.

    xBrush      = ptd->ptlBrush.x + xOffset;

    // yTrapezoid has alread been aligned, but yPattern should _NOT_ be.

    yPattern       = yTrapezoid - ptd->ptlBrush.y - ppdev->yOffset;

    lLeftError  = ptd->aed[LEFT].lError;
    xLeft       = ptd->aed[LEFT].x + xOffset;
    lRightError = ptd->aed[RIGHT].lError;
    xRight      = ptd->aed[RIGHT].x + xOffset;

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    cyRoll = 0;
    if (((ptd->aed[LEFT].lErrorUp | ptd->aed[RIGHT].lErrorUp) == 0) &&
        ((ptd->aed[LEFT].dx       | ptd->aed[RIGHT].dx) == 0) &&
        (cyTrapezoid > 8) &&
        (ptd->bOverpaint))
    {
        /////////////////////////////////////////////////////////////////
        // Vertical-edge special case

        cyRoll = cyTrapezoid - 8;
        cyTrapezoid = 8;
    }

    while (TRUE)
    {
        /////////////////////////////////////////////////////////////////
        // Run the DDAs

        if (xLeft < xRight)
        {
            pwPattern = (WORD*) (pjPatternStart + ((yPattern & 7) << 3));
            yPattern++;

            I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 9);
            I32_OW(pjIoBase, PATT_INDEX,      (xLeft - xBrush) & 7);
            I32_OW(pjIoBase, CUR_X,           xLeft);
            I32_OW(pjIoBase, DEST_X_END,      xRight);
            I32_OW(pjIoBase, PATT_DATA_INDEX, 0);
            I32_OW(pjIoBase, PATT_DATA,       *(pwPattern));
            I32_OW(pjIoBase, PATT_DATA,       *(pwPattern + 1));
            I32_OW(pjIoBase, PATT_DATA,       *(pwPattern + 2));
            I32_OW(pjIoBase, PATT_DATA,       *(pwPattern + 3));
            yTrapezoid++;
            I32_OW(pjIoBase, DEST_Y_END,      yTrapezoid);
        }
        else if (xLeft > xRight)
        {
            // We don't bother optimizing this case because we should
            // rarely get self-intersecting polygons (if we're slow,
            // the app gets what it deserves).

            SWAP(xLeft,          xRight,          lTmp);
            SWAP(lLeftError,     lRightError,     lTmp);
            SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
            continue;
        }
        else
        {
            yTrapezoid++;
            yPattern++;
            I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 1);
            I32_OW(pjIoBase, CUR_Y, yTrapezoid);
        }

        // Advance the right wall:

        xRight      += ptd->aed[RIGHT].dx;
        lRightError += ptd->aed[RIGHT].lErrorUp;

        if (lRightError >= 0)
        {
            lRightError -= ptd->aed[RIGHT].dN;
            xRight++;
        }

        // Advance the left wall:

        xLeft      += ptd->aed[LEFT].dx;
        lLeftError += ptd->aed[LEFT].lErrorUp;

        if (lLeftError >= 0)
        {
            lLeftError -= ptd->aed[LEFT].dN;
            xLeft++;
        }

        cyTrapezoid--;
        if (cyTrapezoid == 0)
            break;
    }

    // The above has already insured that xLeft <= xRight for the vertical
    // edge case, but we still have to make sure it's not an empty
    // rectangle:

    if (cyRoll > 0)
    {
        if (xLeft < xRight)
        {
            // When the ROP is PATCOPY, we take advantage of the fact that
            // we've just laid down an entire row of the pattern, and can
            // do a 'rolling' screen-to-screen blt to draw the rest.
            //
            // What's interesting about this case is that sometimes this will
            // be done when a clipping rectangle has been set using the
            // hardware clip registers.  Fortunately, it's not a problem: we
            // started drawing at prclClip->top, which means we're assured we
            // won't try to replicate any vertical part that has been clipped
            // out; and the left and right edges aren't a problem because the
            // same clipping applies to this rolled part.

            I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 11);
            I32_OW(pjIoBase, DP_CONFIG,       FG_COLOR_SRC_BLIT | DATA_WIDTH |
                                              DRAW | DATA_ORDER | WRITE);
            I32_OW(pjIoBase, CUR_X,           xLeft);
            I32_OW(pjIoBase, DEST_X_START,    xLeft);
            I32_OW(pjIoBase, M32_SRC_X,       xLeft);
            I32_OW(pjIoBase, M32_SRC_X_START, xLeft);
            I32_OW(pjIoBase, M32_SRC_X_END,   xRight);
            I32_OW(pjIoBase, DEST_X_END,      xRight);
            I32_OW(pjIoBase, M32_SRC_Y,       yTrapezoid - 8);
            I32_OW(pjIoBase, CUR_Y,           yTrapezoid);
            I32_OW(pjIoBase, DEST_Y_END,      yTrapezoid + cyRoll);

            // Restore config register to default state for next trapezoid:

            I32_OW(pjIoBase, DP_CONFIG, FG_COLOR_SRC_PATT | DATA_WIDTH |
                                        DRAW | WRITE);
        }
        else
        {
            I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 1);
            I32_OW(pjIoBase, CUR_Y, yTrapezoid + cyRoll);
        }
    }

    ptd->aed[LEFT].lError  = lLeftError;
    ptd->aed[LEFT].x       = xLeft - xOffset;
    ptd->aed[RIGHT].lError = lRightError;
    ptd->aed[RIGHT].x      = xRight - xOffset;
}

/******************************Public*Routine******************************\
* VOID vI32TrapezoidSetup
*
* Initialize the hardware and some state for doing trapezoids.
*
\**************************************************************************/

VOID vI32TrapezoidSetup(
PDEV*           ppdev,
ULONG           rop4,
ULONG           iSolidColor,
RBRUSH*         prb,
POINTL*         pptlBrush,
TRAPEZOIDDATA*  ptd,
LONG            yStart,         // First scan for drawing
RECTL*          prclClip)       // NULL if no clipping
{
    BYTE*       pjIoBase;
    ULONG       ulHwForeMix;
    LONG        xOffset;

    pjIoBase = ppdev->pjIoBase;
    ptd->ppdev = ppdev;

    ulHwForeMix = gaul32HwMixFromRop2[(rop4 >> 2) & 0xf];

    if ((prclClip != NULL) && (prclClip->top > yStart))
        yStart = prclClip->top;

    if (iSolidColor != -1)
    {
        /////////////////////////////////////////////////////////////////
        // Setup for solid colours

        ptd->pfnTrap = vI32SolidTrapezoid;

        // We initialize the hardware for the colour, mix, pixel operation,
        // and the y position for the first scan:

        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 5);
        I32_OW(pjIoBase, FRGD_COLOR, iSolidColor);
        I32_OW(pjIoBase, ALU_FG_FN,  ulHwForeMix);
        I32_OW(pjIoBase, DP_CONFIG,  FG_COLOR_SRC_FG | WRITE | DRAW);
        I32_OW(pjIoBase, CUR_Y,      yStart + ppdev->yOffset);

        // Even though we will be drawing one-scan high rectangles and
        // theoretically don't need to set DEST_X_START, it turns out
        // that we have to make sure this value is less than DEST_X_END,
        // otherwise the rectangle is drawn in the wrong direction...

        I32_OW(pjIoBase, DEST_X_START, 0);
    }
    else
    {
        ASSERTDD(!(prb->fl & RBRUSH_2COLOR), "Can't handle monchrome for now");

        /////////////////////////////////////////////////////////////////
        // Setup for patterns

        ptd->pfnTrap    = vI32ColorPatternTrapezoid;
        ptd->prb        = prb;
        ptd->bOverpaint = (ulHwForeMix == OVERPAINT);
        ptd->ptlBrush.x = pptlBrush->x;
        ptd->ptlBrush.y = pptlBrush->y;

        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 6);
        I32_OW(pjIoBase, ALU_FG_FN,     ulHwForeMix);
        I32_OW(pjIoBase, SRC_Y_DIR,     1);
        I32_OW(pjIoBase, DP_CONFIG,     FG_COLOR_SRC_PATT | DATA_WIDTH |
                                        DRAW | WRITE);
        I32_OW(pjIoBase, PATT_LENGTH,   7);
        I32_OW(pjIoBase, CUR_Y,         yStart + ppdev->yOffset);
        I32_OW(pjIoBase, DEST_X_START,  0);     // See note above...
    }

    if (prclClip != NULL)
    {
        ptd->pfnTrapClip = ptd->pfnTrap;
        ptd->pfnTrap     = vClipTrapezoid;
        ptd->yClipTop    = prclClip->top;
        ptd->yClipBottom = prclClip->bottom;

        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 2);
        xOffset = ppdev->xOffset;
        I32_OW(pjIoBase, EXT_SCISSOR_L, xOffset + prclClip->left);
        I32_OW(pjIoBase, EXT_SCISSOR_R, xOffset + prclClip->right - 1);
    }
}

/******************************Public*Routine******************************\
* VOID vM32SolidTrapezoid
*
* Draws a solid trapezoid using a software DDA.
*
\**************************************************************************/

VOID vM32SolidTrapezoid(
TRAPEZOIDDATA*  ptd,
LONG            yTrapezoid,
LONG            cyTrapezoid)
{
    PDEV*       ppdev;
    BYTE*       pjMmBase;
    LONG        xOffset;
    LONG        lLeftError;
    LONG        xLeft;
    LONG        lRightError;
    LONG        xRight;
    LONG        lTmp;
    EDGEDATA    edTmp;

    // Note that CUR_Y is already set...

    ppdev = ptd->ppdev;
    pjMmBase    = ppdev->pjMmBase;
    xOffset     = ppdev->xOffset;
    yTrapezoid += ppdev->yOffset;

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((ptd->aed[LEFT].lErrorUp | ptd->aed[RIGHT].lErrorUp) == 0) &&
        ((ptd->aed[LEFT].dx       | ptd->aed[RIGHT].dx) == 0))
    {
        /////////////////////////////////////////////////////////////////
        // Vertical-edge special case

        xLeft  = ptd->aed[LEFT].x + xOffset;
        xRight = ptd->aed[RIGHT].x + xOffset;
        if (xLeft > xRight)
        {
            SWAP(xLeft,          xRight,          lTmp);
            SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
        }

        if (xLeft < xRight)
        {
            M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 4);
            M32_OW(pjMmBase, CUR_X,        xLeft);
            M32_OW(pjMmBase, DEST_X_START, xLeft);
            M32_OW(pjMmBase, DEST_X_END,   xRight);
            M32_OW(pjMmBase, DEST_Y_END,   yTrapezoid + cyTrapezoid);
        }
        else
        {
            M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
            M32_OW(pjMmBase, CUR_Y, yTrapezoid + cyTrapezoid);
        }
    }
    else
    {
        lLeftError  = ptd->aed[LEFT].lError;
        xLeft       = ptd->aed[LEFT].x + xOffset;
        lRightError = ptd->aed[RIGHT].lError;
        xRight      = ptd->aed[RIGHT].x + xOffset;

        while (TRUE)
        {
            /////////////////////////////////////////////////////////////////
            // Run the DDAs

            if (xLeft < xRight)
            {
                // Note that we don't need to set DEST_X_START because
                // we're always doing blts that are only one scan high.
                //
                // The ATI is nice enough to always automatically advance
                // CUR_Y to become DEST_Y_END after the blt is done, so we
                // never have to update it:

                M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 3);
                M32_OW(pjMmBase, CUR_X,      xLeft);
                M32_OW(pjMmBase, DEST_X_END, xRight);
                yTrapezoid++;
                M32_OW(pjMmBase, DEST_Y_END, yTrapezoid);
            }
            else if (xLeft > xRight)
            {
                // We don't bother optimizing this case because we should
                // rarely get self-intersecting polygons (if we're slow,
                // the app gets what it deserves).

                SWAP(xLeft,          xRight,          lTmp);
                SWAP(lLeftError,     lRightError,     lTmp);
                SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
                continue;
            }
            else
            {
                yTrapezoid++;
                M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
                M32_OW(pjMmBase, CUR_Y, yTrapezoid);
            }

            // Advance the right wall:

            xRight      += ptd->aed[RIGHT].dx;
            lRightError += ptd->aed[RIGHT].lErrorUp;

            if (lRightError >= 0)
            {
                lRightError -= ptd->aed[RIGHT].dN;
                xRight++;
            }

            // Advance the left wall:

            xLeft      += ptd->aed[LEFT].dx;
            lLeftError += ptd->aed[LEFT].lErrorUp;

            if (lLeftError >= 0)
            {
                lLeftError -= ptd->aed[LEFT].dN;
                xLeft++;
            }

            cyTrapezoid--;
            if (cyTrapezoid == 0)
                break;
        }

        ptd->aed[LEFT].lError  = lLeftError;
        ptd->aed[LEFT].x       = xLeft - xOffset;
        ptd->aed[RIGHT].lError = lRightError;
        ptd->aed[RIGHT].x      = xRight - xOffset;
    }
}

/******************************Public*Routine******************************\
* VOID vM32ColorPatternTrapezoid
*
* Draws a patterned trapezoid using a software DDA.
*
\**************************************************************************/

VOID vM32ColorPatternTrapezoid(
TRAPEZOIDDATA*  ptd,
LONG            yTrapezoid,
LONG            cyTrapezoid)
{
    PDEV*       ppdev;
    BYTE*       pjMmBase;
    LONG        xOffset;
    LONG        lLeftError;
    LONG        xLeft;
    LONG        lRightError;
    LONG        xRight;
    LONG        lTmp;
    EDGEDATA    edTmp;
    BYTE*       pjPatternStart;
    WORD*       pwPattern;
    LONG        xBrush;
    LONG        yPattern;
    LONG        cyRoll;

    ppdev = ptd->ppdev;
    pjMmBase    = ppdev->pjMmBase;
    xOffset     = ppdev->xOffset;
    yTrapezoid += ppdev->yOffset;

    pjPatternStart = (BYTE*) &ptd->prb->aulPattern[0];

    // xBrush needs to be shifted by DFB alignment.

    xBrush      = ptd->ptlBrush.x + xOffset;

    // yTrapezoid has already been aligned, but yPattern should _NOT_ be.

    yPattern    = yTrapezoid - ptd->ptlBrush.y - ppdev->yOffset;

    lLeftError  = ptd->aed[LEFT].lError;
    xLeft       = ptd->aed[LEFT].x + xOffset;
    lRightError = ptd->aed[RIGHT].lError;
    xRight      = ptd->aed[RIGHT].x + xOffset;

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    cyRoll = 0;
    if (((ptd->aed[LEFT].lErrorUp | ptd->aed[RIGHT].lErrorUp) == 0) &&
        ((ptd->aed[LEFT].dx       | ptd->aed[RIGHT].dx) == 0) &&
        (cyTrapezoid > 8) &&
        (ptd->bOverpaint))
    {
        /////////////////////////////////////////////////////////////////
        // Vertical-edge special case

        cyRoll = cyTrapezoid - 8;
        cyTrapezoid = 8;
    }

    while (TRUE)
    {
        /////////////////////////////////////////////////////////////////
        // Run the DDAs

        if (xLeft < xRight)
        {
            pwPattern = (WORD*) (pjPatternStart + ((yPattern & 7) << 3));
            yPattern++;

            M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 9);
            M32_OW(pjMmBase, PATT_INDEX,      (xLeft - xBrush) & 7);
            M32_OW(pjMmBase, CUR_X,           xLeft);
            M32_OW(pjMmBase, DEST_X_END,      xRight);
            M32_OW(pjMmBase, PATT_DATA_INDEX, 0);
            M32_OW(pjMmBase, PATT_DATA,       *(pwPattern));
            M32_OW(pjMmBase, PATT_DATA,       *(pwPattern + 1));
            M32_OW(pjMmBase, PATT_DATA,       *(pwPattern + 2));
            M32_OW(pjMmBase, PATT_DATA,       *(pwPattern + 3));
            yTrapezoid++;
            M32_OW(pjMmBase, DEST_Y_END,      yTrapezoid);
        }
        else if (xLeft > xRight)
        {
            // We don't bother optimizing this case because we should
            // rarely get self-intersecting polygons (if we're slow,
            // the app gets what it deserves).

            SWAP(xLeft,          xRight,          lTmp);
            SWAP(lLeftError,     lRightError,     lTmp);
            SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
            continue;
        }
        else
        {
            yTrapezoid++;
            yPattern++;
            M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
            M32_OW(pjMmBase, CUR_Y, yTrapezoid);
        }

        // Advance the right wall:

        xRight      += ptd->aed[RIGHT].dx;
        lRightError += ptd->aed[RIGHT].lErrorUp;

        if (lRightError >= 0)
        {
            lRightError -= ptd->aed[RIGHT].dN;
            xRight++;
        }

        // Advance the left wall:

        xLeft      += ptd->aed[LEFT].dx;
        lLeftError += ptd->aed[LEFT].lErrorUp;

        if (lLeftError >= 0)
        {
            lLeftError -= ptd->aed[LEFT].dN;
            xLeft++;
        }

        cyTrapezoid--;
        if (cyTrapezoid == 0)
            break;
    }

    // The above has already insured that xLeft <= xRight for the vertical
    // edge case, but we still have to make sure it's not an empty
    // rectangle:

    if (cyRoll > 0)
    {
        if (xLeft < xRight)
        {
            // When the ROP is PATCOPY, we take advantage of the fact that
            // we've just laid down an entire row of the pattern, and can
            // do a 'rolling' screen-to-screen blt to draw the rest.
            //
            // What's interesting about this case is that sometimes this will
            // be done when a clipping rectangle has been set using the
            // hardware clip registers.  Fortunately, it's not a problem: we
            // started drawing at prclClip->top, which means we're assured we
            // won't try to replicate any vertical part that has been clipped
            // out; and the left and right edges aren't a problem because the
            // same clipping applies to this rolled part.

            M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 11);
            M32_OW(pjMmBase, DP_CONFIG,       FG_COLOR_SRC_BLIT | DATA_WIDTH |
                                              DRAW | DATA_ORDER | WRITE);
            M32_OW(pjMmBase, CUR_X,           xLeft);
            M32_OW(pjMmBase, DEST_X_START,    xLeft);
            M32_OW(pjMmBase, M32_SRC_X,       xLeft);
            M32_OW(pjMmBase, M32_SRC_X_START, xLeft);
            M32_OW(pjMmBase, M32_SRC_X_END,   xRight);
            M32_OW(pjMmBase, DEST_X_END,      xRight);
            M32_OW(pjMmBase, M32_SRC_Y,       yTrapezoid - 8);
            M32_OW(pjMmBase, CUR_Y,           yTrapezoid);
            M32_OW(pjMmBase, DEST_Y_END,      yTrapezoid + cyRoll);

            // Restore config register to default state for next trapezoid:

            M32_OW(pjMmBase, DP_CONFIG, FG_COLOR_SRC_PATT | DATA_WIDTH |
                                        DRAW | WRITE);
        }
        else
        {
            M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
            M32_OW(pjMmBase, CUR_Y, yTrapezoid + cyRoll);
        }
    }

    ptd->aed[LEFT].lError  = lLeftError;
    ptd->aed[LEFT].x       = xLeft - xOffset;
    ptd->aed[RIGHT].lError = lRightError;
    ptd->aed[RIGHT].x      = xRight - xOffset;
}

/******************************Public*Routine******************************\
* VOID vM32TrapezoidSetup
*
* Initialize the hardware and some state for doing trapezoids.
*
\**************************************************************************/

VOID vM32TrapezoidSetup(
PDEV*           ppdev,
ULONG           rop4,
ULONG           iSolidColor,
RBRUSH*         prb,
POINTL*         pptlBrush,
TRAPEZOIDDATA*  ptd,
LONG            yStart,         // First scan for drawing
RECTL*          prclClip)       // NULL if no clipping
{
    BYTE*       pjMmBase;
    ULONG       ulHwForeMix;
    LONG        xOffset;

    pjMmBase = ppdev->pjMmBase;
    ptd->ppdev = ppdev;

    ulHwForeMix = gaul32HwMixFromRop2[(rop4 >> 2) & 0xf];

    if ((prclClip != NULL) && (prclClip->top > yStart))
        yStart = prclClip->top;

    if (iSolidColor != -1)
    {
        /////////////////////////////////////////////////////////////////
        // Setup for solid colours

        ptd->pfnTrap = vM32SolidTrapezoid;

        // We initialize the hardware for the colour, mix, pixel operation,
        // and the y position for the first scan:

        M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);
        M32_OW(pjMmBase, FRGD_COLOR, iSolidColor);
        M32_OW(pjMmBase, ALU_FG_FN,  ulHwForeMix);
        M32_OW(pjMmBase, DP_CONFIG,  FG_COLOR_SRC_FG | WRITE | DRAW);
        M32_OW(pjMmBase, CUR_Y,      yStart + ppdev->yOffset);

        // Even though we will be drawing one-scan high rectangles and
        // theoretically don't need to set DEST_X_START, it turns out
        // that we have to make sure this value is less than DEST_X_END,
        // otherwise the rectangle is drawn in the wrong direction...

        M32_OW(pjMmBase, DEST_X_START, 0);
    }
    else
    {
        ASSERTDD(!(prb->fl & RBRUSH_2COLOR), "Can't handle monchrome for now");

        /////////////////////////////////////////////////////////////////
        // Setup for patterns

        ptd->pfnTrap    = vM32ColorPatternTrapezoid;
        ptd->prb        = prb;
        ptd->bOverpaint = (ulHwForeMix == OVERPAINT);
        ptd->ptlBrush.x = pptlBrush->x;
        ptd->ptlBrush.y = pptlBrush->y;

        M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 6);
        M32_OW(pjMmBase, ALU_FG_FN,     ulHwForeMix);
        M32_OW(pjMmBase, SRC_Y_DIR,     1);
        M32_OW(pjMmBase, DP_CONFIG,     FG_COLOR_SRC_PATT | DATA_WIDTH |
                                        DRAW | WRITE);
        M32_OW(pjMmBase, PATT_LENGTH,   7);
        M32_OW(pjMmBase, CUR_Y,         yStart + ppdev->yOffset);
        M32_OW(pjMmBase, DEST_X_START,  0);     // See note above...
    }

    if (prclClip != NULL)
    {
        ptd->pfnTrapClip = ptd->pfnTrap;
        ptd->pfnTrap     = vClipTrapezoid;
        ptd->yClipTop    = prclClip->top;
        ptd->yClipBottom = prclClip->bottom;

        M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 2);
        xOffset = ppdev->xOffset;
        M32_OW(pjMmBase, EXT_SCISSOR_L, xOffset + prclClip->left);
        M32_OW(pjMmBase, EXT_SCISSOR_R, xOffset + prclClip->right - 1);
    }
}

/******************************Public*Routine******************************\
* VOID vM64SolidTrapezoid
*
* Draws a solid trapezoid using a software DDA.
*
\**************************************************************************/

VOID vM64SolidTrapezoid(
TRAPEZOIDDATA*  ptd,
LONG            yTrapezoid,
LONG            cyTrapezoid)
{
    PDEV*       ppdev;
    BYTE*       pjMmBase;
    LONG        xOffset;
    LONG        lLeftError;
    LONG        xLeft;
    LONG        lRightError;
    LONG        xRight;
    LONG        lTmp;
    EDGEDATA    edTmp;
    ULONG       ulFifo;

    ppdev = ptd->ppdev;
    pjMmBase = ppdev->pjMmBase;

    xOffset     = ppdev->xOffset;
    yTrapezoid += ppdev->yOffset;

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((ptd->aed[LEFT].lErrorUp | ptd->aed[RIGHT].lErrorUp) == 0) &&
        ((ptd->aed[LEFT].dx       | ptd->aed[RIGHT].dx) == 0))
    {
        /////////////////////////////////////////////////////////////////
        // Vertical-edge special case

        xLeft  = ptd->aed[LEFT].x + xOffset;
        xRight = ptd->aed[RIGHT].x + xOffset;
        if (xLeft > xRight)
        {
            SWAP(xLeft,          xRight,          lTmp);
            SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
        }

        if (xLeft < xRight)
        {
            M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 3);

            // Note that 'x' can be negative, but we can still use
            // 'PACKXY_FAST' because 'y' can't be negative:

            M64_OD(pjMmBase, DST_X,            xLeft);
            M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(xRight - xLeft,
                                                           cyTrapezoid));
            M64_OD(pjMmBase, DST_HEIGHT,  1);
        }
        else
        {
            M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
            M64_OD(pjMmBase, DST_Y, yTrapezoid + cyTrapezoid);
        }
    }
    else
    {
        yTrapezoid += cyTrapezoid + 1; // One past end scan

        lLeftError  = ptd->aed[LEFT].lError;
        xLeft       = ptd->aed[LEFT].x + xOffset;
        lRightError = ptd->aed[RIGHT].lError;
        xRight      = ptd->aed[RIGHT].x + xOffset;

        ulFifo = 0;     // Don't forget to initialize

        while (TRUE)
        {
            /////////////////////////////////////////////////////////////////
            // Run the DDAs

            if (xLeft < xRight)
            {
                M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 2, ulFifo);
                M64_OD(pjMmBase, DST_X,     xLeft);
                M64_OD(pjMmBase, DST_WIDTH, xRight - xLeft);
            }
            else if (xLeft > xRight)
            {
                // We don't bother optimizing this case because we should
                // rarely get self-intersecting polygons (if we're slow,
                // the app gets what it deserves).

                SWAP(xLeft,          xRight,          lTmp);
                SWAP(lLeftError,     lRightError,     lTmp);
                SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
                continue;
            }
            else
            {
                M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 1, ulFifo);
                M64_OD(pjMmBase, DST_Y, yTrapezoid - cyTrapezoid);
            }

            // Advance the right wall:

            xRight      += ptd->aed[RIGHT].dx;
            lRightError += ptd->aed[RIGHT].lErrorUp;

            if (lRightError >= 0)
            {
                lRightError -= ptd->aed[RIGHT].dN;
                xRight++;
            }

            // Advance the left wall:

            xLeft      += ptd->aed[LEFT].dx;
            lLeftError += ptd->aed[LEFT].lErrorUp;

            if (lLeftError >= 0)
            {
                lLeftError -= ptd->aed[LEFT].dN;
                xLeft++;
            }

            cyTrapezoid--;
            if (cyTrapezoid == 0)
                break;
        }

        ptd->aed[LEFT].lError  = lLeftError;
        ptd->aed[LEFT].x       = xLeft - xOffset;
        ptd->aed[RIGHT].lError = lRightError;
        ptd->aed[RIGHT].x      = xRight - xOffset;
    }
}

/******************************Public*Routine******************************\
* VOID vM64ColorPatternTrapezoid
*
* Draws a patterned trapezoid using a software DDA.
*
\**************************************************************************/

VOID vM64ColorPatternTrapezoid(
TRAPEZOIDDATA*  ptd,
LONG            yTrapezoid,
LONG            cyTrapezoid)
{
    PDEV*       ppdev;
    BYTE*       pjMmBase;
    LONG        yPattern;
    LONG        xBrush;
    LONG        xOffset;
    LONG        lLeftError;
    LONG        xLeft;
    LONG        lRightError;
    LONG        xRight;
    LONG        lTmp;
    EDGEDATA    edTmp;
    ULONG       ulSrc;
    ULONG       ulFifo;

    ppdev       = ptd->ppdev;
    pjMmBase    = ppdev->pjMmBase;

    yPattern = (yTrapezoid - ptd->ptlBrush.y) & 7;  // Must normalize for later
    xBrush   = ptd->ptlBrush.x;

    xOffset     = ppdev->xOffset;
    yTrapezoid += ppdev->yOffset;

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((ptd->aed[LEFT].lErrorUp | ptd->aed[RIGHT].lErrorUp) == 0) &&
        ((ptd->aed[LEFT].dx       | ptd->aed[RIGHT].dx) == 0))
    {
        /////////////////////////////////////////////////////////////////
        // Vertical-edge special case

        xLeft  = ptd->aed[LEFT].x + xOffset;
        xRight = ptd->aed[RIGHT].x + xOffset;
        if (xLeft > xRight)
        {
            SWAP(xLeft,          xRight,          lTmp);
            SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
        }

        if (xLeft < xRight)
        {
            M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);

            ulSrc = PACKXY_FAST(xLeft - xBrush, yPattern) & 0x70007;
            M64_OD(pjMmBase, SRC_Y_X,            ulSrc);
            M64_OD(pjMmBase, SRC_HEIGHT1_WIDTH1, 0x80008 - ulSrc);
            M64_OD(pjMmBase, DST_X,              xLeft);
            M64_OD(pjMmBase, DST_HEIGHT_WIDTH,   PACKXY_FAST(xRight - xLeft,
                                                             cyTrapezoid));
            M64_OD(pjMmBase, DST_HEIGHT,  1);
        }
        else
        {
            M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
            M64_OD(pjMmBase, DST_Y, yTrapezoid + cyTrapezoid);
        }
    }
    else
    {
        yTrapezoid += cyTrapezoid + 1; // One past end scan

        lLeftError  = ptd->aed[LEFT].lError;
        xLeft       = ptd->aed[LEFT].x + xOffset;
        lRightError = ptd->aed[RIGHT].lError;
        xRight      = ptd->aed[RIGHT].x + xOffset;

        ulFifo = 0;     // Don't forget to initialize

        while (TRUE)
        {
            /////////////////////////////////////////////////////////////////
            // Run the DDAs

            if (xLeft < xRight)
            {
                M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 4, ulFifo);

                // Note that we can use PACKXY_FAST because 'yPattern' will
                // never overflow 16 bits:

                ulSrc = PACKXY_FAST(xLeft - xBrush, yPattern) & 0x70007;
                yPattern++;
                M64_OD(pjMmBase, SRC_Y_X,            ulSrc);
                M64_OD(pjMmBase, SRC_HEIGHT1_WIDTH1, 0x80008 - ulSrc);
                M64_OD(pjMmBase, DST_X,              xLeft);
                M64_OD(pjMmBase, DST_WIDTH,          xRight - xLeft);
            }
            else if (xLeft > xRight)
            {
                // We don't bother optimizing this case because we should
                // rarely get self-intersecting polygons (if we're slow,
                // the app gets what it deserves).

                SWAP(xLeft,          xRight,          lTmp);
                SWAP(lLeftError,     lRightError,     lTmp);
                SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
                continue;
            }
            else
            {
                M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 1, ulFifo);
                M64_OD(pjMmBase, DST_Y, yTrapezoid - cyTrapezoid);
                yPattern++;
            }

            // Advance the right wall:

            xRight      += ptd->aed[RIGHT].dx;
            lRightError += ptd->aed[RIGHT].lErrorUp;

            if (lRightError >= 0)
            {
                lRightError -= ptd->aed[RIGHT].dN;
                xRight++;
            }

            // Advance the left wall:

            xLeft      += ptd->aed[LEFT].dx;
            lLeftError += ptd->aed[LEFT].lErrorUp;

            if (lLeftError >= 0)
            {
                lLeftError -= ptd->aed[LEFT].dN;
                xLeft++;
            }

            cyTrapezoid--;
            if (cyTrapezoid == 0)
                break;
        }

        ptd->aed[LEFT].lError  = lLeftError;
        ptd->aed[LEFT].x       = xLeft - xOffset;
        ptd->aed[RIGHT].lError = lRightError;
        ptd->aed[RIGHT].x      = xRight - xOffset;
    }
}

/******************************Public*Routine******************************\
* VOID vM64TrapezoidSetup
*
* Initialize the hardware and some state for doing trapezoids.
*
\**************************************************************************/

VOID vM64TrapezoidSetup(
PDEV*           ppdev,
ULONG           rop4,
ULONG           iSolidColor,
RBRUSH*         prb,
POINTL*         pptlBrush,
TRAPEZOIDDATA*  ptd,
LONG            yStart,         // First scan for drawing
RECTL*          prclClip)       // NULL if no clipping
{
    BYTE*       pjMmBase;
    BRUSHENTRY* pbe;
    LONG        xOffset;

    pjMmBase = ppdev->pjMmBase;
    ptd->ppdev = ppdev;

    if ((prclClip != NULL) && (prclClip->top > yStart))
        yStart = prclClip->top;

    if (iSolidColor != -1)
    {
        /////////////////////////////////////////////////////////////////
        // Setup for solid colours

        ptd->pfnTrap = vM64SolidTrapezoid;

        // We initialize the hardware for the colour, mix, pixel operation,
        // and the y position for the first scan:

        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 7);  // Don't forget SC_LEFT_RIGHT
        //M64_OD(pjMmBase, CONTEXT_LOAD_CNTL, CONTEXT_LOAD_CmdLoad | ppdev->iDefContext );

        M64_OD(pjMmBase, DP_FRGD_CLR, iSolidColor);
        M64_OD(pjMmBase, DP_SRC,      DP_SRC_FrgdClr << 8);
    }
    else
    {
        ASSERTDD(!(prb->fl & RBRUSH_2COLOR), "Can't handle monchrome for now");

        /////////////////////////////////////////////////////////////////
        // Setup for patterns

        ptd->pfnTrap    = vM64ColorPatternTrapezoid;
        ptd->ptlBrush.x = pptlBrush->x;
        ptd->ptlBrush.y = pptlBrush->y;

        // See if the brush has already been put into off-screen memory:

        pbe = prb->apbe[IBOARD(ppdev)];
        if ((pbe == NULL) || (pbe->prbVerify != prb))
        {
            vM64PatColorRealize(ppdev, prb);
            pbe = prb->apbe[IBOARD(ppdev)];
        }

        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 10); // Don't forget SC_LEFT_RIGHT
        //M64_OD(pjMmBase, CONTEXT_LOAD_CNTL, CONTEXT_LOAD_CmdLoad | ppdev->iDefContext );

        M64_OD(pjMmBase, SRC_OFF_PITCH,      pbe->ulOffsetPitch);
        M64_OD(pjMmBase, SRC_CNTL,           SRC_CNTL_PatEna | SRC_CNTL_PatRotEna);
        M64_OD(pjMmBase, DP_SRC,             DP_SRC_Blit << 8);
        M64_OD(pjMmBase, SRC_Y_X_START,      0);
        M64_OD(pjMmBase, SRC_HEIGHT2_WIDTH2, PACKXY(8, 8));
    }

    // We could make set DST_CNTL_YTile in the default state for DST_CNTL,
    // and thus save ourselves a write:

    M64_OD(pjMmBase, DP_MIX,      gaul64HwMixFromRop2[(rop4 >> 2) & 0xf]);
    M64_OD(pjMmBase, DST_Y,       yStart + ppdev->yOffset);
    M64_OD(pjMmBase, DST_HEIGHT,  1);
    M64_OD(pjMmBase, DST_CNTL,    DST_CNTL_XDir | DST_CNTL_YDir |
                                  DST_CNTL_YTile);

    if (prclClip != NULL)
    {
        ptd->pfnTrapClip = ptd->pfnTrap;
        ptd->pfnTrap     = vClipTrapezoid;
        ptd->yClipTop    = prclClip->top;
        ptd->yClipBottom = prclClip->bottom;

        xOffset = ppdev->xOffset;
        M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(xOffset + prclClip->left,
                                                 xOffset + prclClip->right - 1));
    }
}

/******************************Public*Routine******************************\
* BOOL bFastFill
*
* Draws a non-complex, unclipped polygon.  'Non-complex' is defined as
* having only two edges that are monotonic increasing in 'y'.  That is,
* the polygon cannot have more than one disconnected segment on any given
* scan.  Note that the edges of the polygon can self-intersect, so hourglass
* shapes are permissible.  This restriction permits this routine to run two
* simultaneous DDAs, and no sorting of the edges is required.
*
* Note that NT's fill convention is different from that of Win 3.1 or Win95.
* With the additional complication of fractional end-points, our convention
* is the same as in 'X-Windows'.  But a DDA is a DDA is a DDA, so once you
* figure out how we compute the DDA terms for NT, you're golden.
*
* This routine handles patterns only when the S3 hardware patterns can be
* used.  The reason for this is that once the S3 pattern initialization is
* done, pattern fills appear to the programmer exactly the same as solid
* fills (with the slight difference that different registers and commands
* are used).  Handling 'vM32FillPatSlow' style patterns in this routine
* would be non-trivial...
*
* We take advantage of the fact that the S3 automatically advances the
* current 'y' to the following scan whenever a rectangle is output so that
* we have to write to the accelerator three times for every scan: one for
* the new 'x', one for the new 'width', and one for the drawing command.
*
* Returns TRUE if the polygon was drawn; FALSE if the polygon was complex.
*
\**************************************************************************/

BOOL bFastFill(
PDEV*       ppdev,
LONG        cEdges,         // Includes close figure edge
POINTFIX*   pptfxFirst,
ULONG       rop4,
ULONG       iSolidColor,
RBRUSH*     prb,
POINTL*     pptlBrush,
RECTL*      prclClip)       // NULL if no clipping
{
    LONG      yTrapezoid;   // Top scan for next trapezoid
    LONG      cyTrapezoid;  // Number of scans in current trapezoid
    LONG      yStart;       // y-position of start point in current edge
    LONG      dM;           // Edge delta in FIX units in x direction
    LONG      dN;           // Edge delta in FIX units in y direction
    LONG      i;
    POINTFIX* pptfxLast;    // Points to the last point in the polygon array
    POINTFIX* pptfxTop;     // Points to the top-most point in the polygon
    POINTFIX* pptfxOld;     // Start point in current edge
    POINTFIX* pptfxScan;    // Current edge pointer for finding pptfxTop
    LONG      cScanEdges;   // Number of edges scanned to find pptfxTop
                            //  (doesn't include the closefigure edge)
    LONG      iEdge;
    LONG      lQuotient;
    LONG      lRemainder;

    TRAPEZOIDDATA   td;     // Edge data and stuff
    EDGEDATA*       ped;    // Points to current edge being processed

    /////////////////////////////////////////////////////////////////
    // See if the polygon is convex

    pptfxScan = pptfxFirst;
    pptfxTop  = pptfxFirst;                 // Assume for now that the first
                                            //  point in path is the topmost
    pptfxLast = pptfxFirst + cEdges - 1;

    if (cEdges <= 2)
        goto ReturnTrue;

    // 'pptfxScan' will always point to the first point in the current
    // edge, and 'cScanEdges' will the number of edges remaining, including
    // the current one:

    cScanEdges = cEdges - 1;     // The number of edges, not counting close figure

    if ((pptfxScan + 1)->y > pptfxScan->y)
    {
        // Collect all downs:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFillingCheck;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        // Collect all downs:

        pptfxTop = pptfxScan;

        do {
            if ((pptfxScan + 1)->y > pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        goto ReturnFalse;
    }
    else
    {
        // Collect all ups:

        do {
            pptfxTop++;                 // We increment this now because we
                                        //  want it to point to the very last
                                        //  point if we early out in the next
                                        //  statement...
            if (--cScanEdges == 0)
                goto SetUpForFilling;
        } while ((pptfxTop + 1)->y <= pptfxTop->y);

        // Collect all downs:

        pptfxScan = pptfxTop;
        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if ((pptfxScan + 1)->y < pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        goto ReturnFalse;
    }

SetUpForFillingCheck:

    // We check to see if the end of the current edge is higher
    // than the top edge we've found so far:

    if ((pptfxScan + 1)->y < pptfxTop->y)
        pptfxTop = pptfxScan + 1;

SetUpForFilling:

    /////////////////////////////////////////////////////////////////
    // Some Initialization

    td.aed[LEFT].pptfx  = pptfxTop;
    td.aed[RIGHT].pptfx = pptfxTop;

    yTrapezoid = (pptfxTop->y + 15) >> 4;

    // Make sure we initialize the DDAs appropriately:

    td.aed[LEFT].cy  = 0;
    td.aed[RIGHT].cy = 0;

    // Guess as to the ordering of the points:

    td.aed[LEFT].dptfx  = sizeof(POINTFIX);
    td.aed[RIGHT].dptfx = -(LONG) sizeof(POINTFIX);

    if (ppdev->iMachType == MACH_MM_64)
    {
        vM64TrapezoidSetup(ppdev, rop4, iSolidColor, prb, pptlBrush, &td,
                           yTrapezoid, prclClip);
    }
    else if (ppdev->iMachType == MACH_MM_32)
    {
        vM32TrapezoidSetup(ppdev, rop4, iSolidColor, prb, pptlBrush, &td,
                           yTrapezoid, prclClip);
    }
    else
    {
        vI32TrapezoidSetup(ppdev, rop4, iSolidColor, prb, pptlBrush, &td,
                           yTrapezoid, prclClip);
    }

NewTrapezoid:

    /////////////////////////////////////////////////////////////////
    // DDA initialization

    for (iEdge = 1; iEdge >= 0; iEdge--)
    {
        ped       = &td.aed[iEdge];
        ped->bNew = FALSE;
        if (ped->cy == 0)
        {
            // Our trapezoid drawing routine may want to be notified when
            // it will have to reset its DDA to start a new edge:

            ped->bNew = TRUE;

            // Need a new DDA:

            do {
                cEdges--;
                if (cEdges < 0)
                    goto ResetClippingAndReturnTrue;

                // Find the next left edge, accounting for wrapping:

                pptfxOld = ped->pptfx;
                ped->pptfx = (POINTFIX*) ((BYTE*) ped->pptfx + ped->dptfx);

                if (ped->pptfx < pptfxFirst)
                    ped->pptfx = pptfxLast;
                else if (ped->pptfx > pptfxLast)
                    ped->pptfx = pptfxFirst;

                // Have to find the edge that spans yTrapezoid:

                ped->cy = ((ped->pptfx->y + 15) >> 4) - yTrapezoid;

                // With fractional coordinate end points, we may get edges
                // that don't cross any scans, in which case we try the
                // next one:

            } while (ped->cy <= 0);

            // 'pptfx' now points to the end point of the edge spanning
            // the scan 'yTrapezoid'.

            dN = ped->pptfx->y - pptfxOld->y;
            dM = ped->pptfx->x - pptfxOld->x;

            ASSERTDD(dN > 0, "Should be going down only");

            // Compute the DDA increment terms:

            ped->dM = dM;                   // Not used for software trapezoid

            if (dM < 0)
            {
                dM = -dM;
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = -1;
                    ped->lErrorUp = dN - dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = -lQuotient;     // - dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                    if (ped->lErrorUp > 0)
                    {
                        ped->dx--;
                        ped->lErrorUp = dN - ped->lErrorUp;
                    }
                }
            }
            else
            {
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = 0;
                    ped->lErrorUp = dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = lQuotient;      // dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                }
            }

            ped->dN = dN; // DDA limit
            ped->lError     = -1; // Error is initially zero (add dN - 1 for
                                  //  the ceiling, but subtract off dN so that
                                  //  we can check the sign instead of comparing
                                  //  to dN)

            ped->x = pptfxOld->x;
            yStart = pptfxOld->y;

            if ((yStart & 15) != 0)
            {
                // Advance to the next integer y coordinate

                for (i = 16 - (yStart & 15); i != 0; i--)
                {
                    ped->x      += ped->dx;
                    ped->lError += ped->lErrorUp;
                    if (ped->lError >= 0)
                    {
                        ped->lError -= ped->dN;
                        ped->x++;
                    }
                }
            }

            if ((ped->x & 15) != 0)
            {
                ped->lError -= ped->dN * (16 - (ped->x & 15));
                ped->x += 15;       // We'll want the ceiling in just a bit...
            }

            // Chop off those fractional bits:

            ped->x      >>= 4;
            ped->lError >>= 4;
        }
    }

    cyTrapezoid = min(td.aed[LEFT].cy, td.aed[RIGHT].cy); // # of scans in this trap
    td.aed[LEFT].cy  -= cyTrapezoid;
    td.aed[RIGHT].cy -= cyTrapezoid;

    td.pfnTrap(&td, yTrapezoid, cyTrapezoid);

    yTrapezoid += cyTrapezoid;

    goto NewTrapezoid;

ResetClippingAndReturnTrue:

    if (prclClip != NULL)
    {
        vResetClipping(ppdev);
    }

ReturnTrue:

    if (ppdev->iMachType == MACH_MM_64)
    {
        // Since we don't use a default context, we must restore registers:

        M64_CHECK_FIFO_SPACE(ppdev, ppdev->pjMmBase, 1);
        M64_OD(ppdev->pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
    }
    return(TRUE);

ReturnFalse:

    if (ppdev->iMachType == MACH_MM_64)
    {
        // Since we don't use a default context, we must restore registers:

        M64_CHECK_FIFO_SPACE(ppdev, ppdev->pjMmBase, 1);
        M64_OD(ppdev->pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
    }
    return(FALSE);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\hw.h ===
/******************************Module*Header*******************************\
* Module Name: hw.h
*
* All the hardware specific driver file stuff.  Parts are mirrored in
* 'hw.inc'.
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

//////////////////////////////////////////////////////////////////////
// Alpha and PowerPC considerations
//
// Both the Alpha and the PowerPC do not guarantee that I/O to
// separate addresses will be executed in order.  The Alpha and
// PowerPC differ, however, in that the PowerPC guarantees that
// output to the same address will be executed in order, while the
// Alpha may cache and 'collapse' consecutive output to become only
// one output.
//
// Consequently, we use the following synchronization macros.  They
// are relatively expensive in terms of performance, so we try to avoid
// them whereever possible.
//
// CP_EIEIO() 'Ensure In-order Execution of I/O'
//    - Used to flush any pending I/O in situations where we wish to
//      avoid out-of-order execution of I/O to separate addresses.
//
// CP_MEMORY_BARRIER()
//    - Used to flush any pending I/O in situations where we wish to
//      avoid out-of-order execution or 'collapsing' of I/O to
//      the same address.  On the PowerPC, this will be defined as
//      a null operation.

#if defined(_PPC_)

    // On PowerPC, CP_MEMORY_BARRIER doesn't do anything.

    #define CP_EIEIO()          MEMORY_BARRIER()
    #define CP_MEMORY_BARRIER()

#else

    // On Alpha, CP_EIEIO is the same thing as a CP_MEMORY_BARRIER.
    // On other systems, both CP_EIEIO and CP_MEMORY_BARRIER don't do anything.

    #define CP_EIEIO()          MEMORY_BARRIER()
    #define CP_MEMORY_BARRIER() MEMORY_BARRIER()

#endif

////////////////////////////////////////////////////////////////////////////
// Mach32 Equates
////////////////////////////////////////////////////////////////////////////

#define NOT_SCREEN              0x00
#define LOGICAL_0               0x01
#define LOGICAL_1               0x02
#define LEAVE_ALONE             0x03
#define NOT_NEW                 0x04
#define SCREEN_XOR_NEW          0x05
#define NOT_SCREEN_XOR_NEW      0x06
#define OVERPAINT               0x07
#define NOT_SCREEN_OR_NOT_NEW   0x08
#define SCREEN_OR_NOT_NEW       0x09
#define NOT_SCREEN_OR_NEW       0x0A
#define SCREEN_OR_NEW           0x0B
#define SCREEN_AND_NEW          0x0C
#define NOT_SCREEN_AND_NEW      0x0D
#define SCREEN_AND_NOT_NEW      0x0E
#define NOT_SCREEN_AND_NOT_NEW  0x0F

#define SETUP_ID1            0x0100 // Setup Mode Identification (Byte 1)
#define SETUP_ID2            0x0101 // Setup Mode Identification (Byte 2)
#define SETUP_OPT            0x0102 // Setup Mode Option Select
#define ROM_SETUP            0x0103 //
#define SETUP_1              0x0104 //
#define SETUP_2              0x0105 //
#define DISP_STATUS          0x02E8 // Display Status
#define H_TOTAL              0x02E8 // Horizontal Total
#define DAC_MASK             0x02EA // DAC Mask
#define DAC_R_INDEX          0x02EB // DAC Read Index
#define DAC_W_INDEX          0x02EC // DAC Write Index
#define DAC_DATA             0x02ED // DAC Data
#define OVERSCAN_COLOR_8     0x02EE
#define OVERSCAN_BLUE_24     0x02EF
#define H_DISP               0x06E8 // Horizontal Displayed
#define OVERSCAN_GREEN_24    0x06EE
#define OVERSCAN_RED_24      0x06EF
#define H_SYNC_STRT          0x0AE8 // Horizontal Sync Start
#define CURSOR_OFFSET_LO     0x0AEE
#define H_SYNC_WID           0x0EE8 // Horizontal Sync Width
#define CURSOR_OFFSET_HI     0x0EEE
#define V_TOTAL              0x12E8 // Vertical Total
#define CONFIG_STATUS_1      0x12EE // Read only equivalent to HORZ_CURSOR_POSN
#define HORZ_CURSOR_POSN     0x12EE
#define V_DISP               0x16E8 // Vertical Displayed
#define CONFIG_STATUS_2      0x16EE // Read only equivalent to VERT_CURSOR_POSN
#define VERT_CURSOR_POSN     0x16EE
#define V_SYNC_STRT          0x1AE8 // Vertical Sync Start
#define CURSOR_COLOR_0       0x1AEE
#define FIFO_TEST_DATA       0x1AEE
#define CURSOR_COLOR_1       0x1AEF
#define V_SYNC_WID           0x1EE8 // Vertical Sync Width
#define HORZ_CURSOR_OFFSET   0x1EEE
#define VERT_CURSOR_OFFSET   0x1EEF
#define DISP_CNTL            0x22E8 // Display Control
#define CRT_PITCH            0x26EE
#define CRT_OFFSET_LO        0x2AEE
#define CRT_OFFSET_HI        0x2EEE
#define LOCAL_CONTROL        0x32EE
#define FIFO_OPT             0x36EE
#define MISC_OPTIONS         0x36EE
#define EXT_CURSOR_COLOR_0   0x3AEE
#define FIFO_TEST_TAG        0x3AEE
#define EXT_CURSOR_COLOR_1   0x3EEE
#define SUBSYS_CNTL          0x42E8 // Subsystem Control
#define SUBSYS_STAT          0x42E8 // Subsystem Status
#define MEM_BNDRY            0x42EE
#define SHADOW_CTL           0x46EE
#define ROM_PAGE_SEL         0x46E8 // ROM Page Select (not in manual)
#define ADVFUNC_CNTL         0x4AE8 // Advanced Function Control
#define CLOCK_SEL            0x4AEE
#define SCRATCH_PAD_0        0x52EE
#define SCRATCH_PAD_1        0x56EE
#define SHADOW_SET           0x5AEE
#define MEM_CFG              0x5EEE
#define EXT_GE_STATUS        0x62EE
#define HORZ_OVERSCAN        0x62EE
#define VERT_OVERSCAN        0x66EE
#define MAX_WAITSTATES       0x6AEE
#define GE_OFFSET_LO         0x6EEE
#define BOUNDS_LEFT          0x72EE
#define GE_OFFSET_HI         0x72EE
#define BOUNDS_TOP           0x76EE
#define GE_PITCH             0x76EE
#define BOUNDS_RIGHT         0x7AEE
#define EXT_GE_CONFIG        0x7AEE
#define BOUNDS_BOTTOM        0x7EEE
#define MISC_CNTL            0x7EEE
#define CUR_Y                0x82E8 // Current Y Position
#define PATT_DATA_INDEX      0x82EE
#define CUR_X                0x86E8 // Current X Position
#define M32_SRC_Y            0x8AE8 //
#define DEST_Y               0x8AE8 //
#define AXSTP                0x8AE8 // Destination Y Position
// Axial     Step Constant
#define M32_SRC_X            0x8EE8 //
#define DEST_X               0x8EE8 //
#define DIASTP               0x8EE8 // Destination X Position
// Diagonial Step Constant
#define PATT_DATA            0x8EEE
#define R_EXT_GE_CONFIG      0x8EEE
#define ERR_TERM             0x92E8 // Error Term
#define R_MISC_CNTL          0x92EE
#define MAJ_AXIS_PCNT        0x96E8 // Major Axis Pixel Count
#define BRES_COUNT           0x96EE
#define CMD                  0x9AE8 // Command
#define GE_STAT              0x9AE8 // Graphics Processor Status
#define EXT_FIFO_STATUS      0x9AEE
#define LINEDRAW_INDEX       0x9AEE
#define SHORT_STROKE         0x9EE8 // Short Stroke Vector Transfer
#define BKGD_COLOR           0xA2E8 // Background Color
#define LINEDRAW_OPT         0xA2EE
#define FRGD_COLOR           0xA6E8 // Foreground Color
#define DEST_X_START         0xA6EE
#define WRT_MASK             0xAAE8 // Write Mask
#define DEST_X_END           0xAAEE
#define RD_MASK              0xAEE8 // Read Mask
#define DEST_Y_END           0xAEEE
#define CMP_COLOR            0xB2E8 // Compare Color
#define R_H_TOTAL            0xB2EE
#define R_H_DISP             0xB2EE
#define M32_SRC_X_START      0xB2EE
#define BKGD_MIX             0xB6E8 // Background Mix
#define ALU_BG_FN            0xB6EE
#define R_H_SYNC_STRT        0xB6EE
#define FRGD_MIX             0xBAE8 // Foreground Mix
#define ALU_FG_FN            0xBAEE
#define R_H_SYNC_WID         0xBAEE
#define MULTIFUNC_CNTL       0xBEE8 // Multi-Function Control (mach 8) !!!!!! Requires MB
#define MIN_AXIS_PCNT        0xBEE8
#define SCISSOR_T            0xBEE8
#define SCISSOR_L            0xBEE8
#define SCISSOR_B            0xBEE8
#define SCISSOR_R            0xBEE8
#define M32_MEM_CNTL         0xBEE8
#define PATTERN_L            0xBEE8
#define PATTERN_H            0xBEE8
#define PIXEL_CNTL           0xBEE8
#define M32_SRC_X_END        0xBEEE
#define SRC_Y_DIR            0xC2EE
#define R_V_TOTAL            0xC2EE
#define EXT_SSV              0xC6EE // (used for MACH 8)
#define EXT_SHORT_STROKE     0xC6EE
#define R_V_DISP             0xC6EE
#define SCAN_X               0xCAEE
#define R_V_SYNC_STRT        0xCAEE
#define DP_CONFIG            0xCEEE
#define VERT_LINE_CNTR       0xCEEE
#define PATT_LENGTH          0xD2EE
#define R_V_SYNC_WID         0xD2EE
#define PATT_INDEX           0xD6EE
#define EXT_SCISSOR_L        0xDAEE // "extended" left scissor (12 bits precision)
#define R_SRC_X              0xDAEE
#define EXT_SCISSOR_T        0xDEEE // "extended" top scissor (12 bits precision)
#define R_SRC_Y              0xDEEE
#define PIX_TRANS            0xE2E8 // Pixel Data Transfer
#define PIX_TRANS_LO         0xE2E8
#define PIX_TRANS_HI         0xE2E9
#define EXT_SCISSOR_R        0xE2EE // "extended" right scissor (12 bits precision)
#define EXT_SCISSOR_B        0xE6EE // "extended" bottom scissor (12 bits precision)
#define SRC_CMP_COLOR        0xEAEE // (used for MACH 8)
#define DEST_CMP_FN          0xEEEE
#define LINEDRAW             0xFEEE // !!!!!! Requires MB

//---------------------------------------------------------
// macros (from 8514.inc)
//
//      I/O macros:
//
//mov if port NOT = to DX
//
//mov if port NOT = to DX
//
//
//
//Following are the FIFO checking macros:
//
//
//
//FIFO space check macro:
//
#define ONE_WORD             0x8000
#define TWO_WORDS            0xC000
#define THREE_WORDS          0xE000
#define FOUR_WORDS           0xF000
#define FIVE_WORDS           0xF800
#define SIX_WORDS            0xFC00
#define SEVEN_WORDS          0xFE00
#define EIGHT_WORDS          0xFF00
#define NINE_WORDS           0xFF80
#define TEN_WORDS            0xFFC0
#define ELEVEN_WORDS         0xFFE0
#define TWELVE_WORDS         0xFFF0
#define THIRTEEN_WORDS       0xFFF8
#define FOURTEEN_WORDS       0xFFFC
#define FIFTEEN_WORDS        0xFFFE
#define SIXTEEN_WORDS        0xFFFF
//
//
//
//---------------------------------------
//
//
// Draw Command (DRAW_COMMAND)    (from 8514regs.inc)
//      note: required by m32poly.asm
//
// opcode field
#define OP_CODE              0xE000
#define SHIFT_op_code        0x000D
#define DRAW_SETUP           0x0000
#define DRAW_LINE            0x2000
#define FILL_RECT_H1H4       0x4000
#define FILL_RECT_V1V2       0x6000
#define FILL_RECT_V1H4       0x8000
#define DRAW_POLY_LINE       0xA000
#define BITBLT_OP            0xC000
#define DRAW_FOREVER         0xE000
// swap field
#define LSB_FIRST            0x1000
// data width field
#define DATA_WIDTH           0x0200
#define BIT16                0x0200
#define BIT8                 0x0000
// CPU wait field
#define CPU_WAIT             0x0100
// octant field
#define OCTANT               0x00E0
#define SHIFT_octant         0x0005
#define YPOSITIVE            0x0080
#define YMAJOR               0x0040
#define XPOSITIVE            0x0020
// draw field
#define DRAW                 0x0010
// direction field
#define DIR_TYPE             0x0008
#define DEGREE               0x0008
#define XY                   0x0000
#define RECT_RIGHT_AND_DOWN  0x00E0 // quadrant 3
#define RECT_LEFT_AND_UP     0x0000 // quadrant 1
// last pel off field
#define SHIFT_last_pel_off   0x0002
#define LAST_PEL_OFF         0x0004
#define LAST_PEL_ON          0x0000
// pixel mode
#define PIXEL_MODE           0x0002
#define MULTI                0x0002
#define SINGLE               0x0000
// read/write
#define RW                   0x0001
#define WRITE                0x0001
#define READ                 0x0000
//
// ---------------------------------------------------------
//   8514 register definitions  (from vga1regs.inc)
//
// Internal registers (read only, for test purposes only)
#define _PAR_FIFO_DATA       0x1AEE
#define _PAR_FIFO_ADDR       0x3AEE
#define _MAJOR_DEST_CNT      0x42EE
#define _MAJOR_SRC_CNT       0x5EEE
#define _MINOR_DEST_CNT      0x66EE
#define _MINOR_SRC_CNT       0x8AEE
#define _HW_TEST             0x32EE
//
// Extended Graphics Engine Status (EXT_GE_STATUS)
// -rn- used in mach32.asm
//
#define POINTS_INSIDE        0x8000
#define EE_DATA_IN           0x4000
#define GE_ACTIVE            0x2000
#define CLIP_ABOVE           0x1000
#define CLIP_BELOW           0x0800
#define CLIP_LEFT            0x0400
#define CLIP_RIGHT           0x0200
#define CLIP_FLAGS           0x1E00
#define CLIP_INSIDE          0x0100
#define EE_CRC_VALID         0x0080
#define CLIP_OVERRUN         0x000F
//
// Datapath Configuration Register (DP_CONFIG)
//  note: some of the EQU is needed in m32poly.asm
#define FG_COLOR_SRC         0xE000
#define SHIFT_fg_color_src   0x000D
#define DATA_ORDER           0x1000
#define DATA_WIDTH           0x0200
#define BG_COLOR_SRC         0x0180
#define SHIFT_bg_color_src   0x0007
#define EXT_MONO_SRC         0x0060
#define SHIFT_ext_mono_src   0x0005
#define DRAW                 0x0010
#define READ_MODE            0x0004
#define POLY_FILL_MODE       0x0002
#define WRITE                0x0001
#define SRC_SWAP             0x0800
//
#define FG_COLOR_SRC_BG      0x0000 // Background Color Register
#define FG_COLOR_SRC_FG      0x2000 // Foreground Color Register
#define FG_COLOR_SRC_HOST    0x4000 // CPU Data Transfer Reg
#define FG_COLOR_SRC_BLIT    0x6000 // VRAM blit source
#define FG_COLOR_SRC_GS      0x8000 // Grey-scale mono blit
#define FG_COLOR_SRC_PATT    0xA000 // Color Pattern Shift Reg
#define FG_COLOR_SRC_CLUH    0xC000 // Color lookup of Host Data
#define FG_COLOR_SRC_CLUB    0xE000 // Color lookup of blit src
//
#define BG_COLOR_SRC_BG      0x0000 // Background Color Reg
#define BG_COLOR_SRC_FG      0x0080 // Foreground Color Reg
#define BG_COLOR_SRC_HOST    0x0100 // CPU Data Transfer Reg
#define BG_COLOR_SRC_BLIT    0x0180 // VRAM blit source
//
// Note that "EXT_MONO_SRC" and "MONO_SRC" are mutually destructive, but that
// "EXT_MONO_SRC" selects the ATI pattern registers.
//
#define EXT_MONO_SRC_ONE     0x0000 // Always '1'
#define EXT_MONO_SRC_PATT    0x0020 // ATI Mono Pattern Regs
#define EXT_MONO_SRC_HOST    0x0040 // CPU Data Transfer Reg
#define EXT_MONO_SRC_BLIT    0x0060 // VRAM Blit source plane
//
// Linedraw Options Register (LINEDRAW_OPT)
//
//  note: some of the EQUS are needed in m32poly.asm
#define CLIP_MODE            0x0600
#define SHIFT_clip_mode      0x0009
#define CLIP_MODE_DIS        0x0000
#define CLIP_MODE_LINE       0x0200
#define CLIP_MODE_PLINE      0x0400
#define CLIP_MODE_PATT       0x0600
#define BOUNDS_RESET         0x0100
#define OCTANT               0x00E0
#define SHIFT_ldo_octant     0x0005
#define YDIR                 0x0080
#define XMAJOR               0x0040
#define XDIR                 0x0020
#define DIR_TYPE             0x0008
#define DIR_TYPE_DEGREE      0x0008
#define DIR_TYPE_OCTANT      0x0000
#define LAST_PEL_OFF         0x0004
#define POLY_MODE            0x0002
//
#define FOREGROUND_COLOR     0x20
#define DATA_EXTENSION       0xA000
#define ALL_ONES             0x0000
#define CPU_DATA             0x0080
#define DISPLAY_MEMORY       0x00C0
//
// Blt defines
//
#define GE_BUSY                          0x0200

#define LOAD_SOURCE_AND_DEST 0
#define LOAD_DEST            1
#define LOAD_SOURCE          2
#define TOP_TO_BOTTOM          1
#define BOTTOM_TO_TOP          0
#define VID_MEM_BLT            0x6211
#define COLOR_FIL_BLT          0x2211
#define MIX_FN_D               3       //            page 8-24
#define MIX_FN_S               7       //            page 8-24

#define PIXEL_CTRL             0xa000  //            page 8-46
#define DEST_NOT_EQ_COLOR_CMP  0x0020
#define DEST_ALWAY_OVERWRITE   0

//
//
// ------------------------------------------------------------
//  Mach32 register equates (from m32regs.inc)
//
#define REVISION             0x0000
//HORIZONTAL_OVERSCAN     equ     062EEh
//VERTICAL_OVERSCAN       equ     066EEh

#define FL_MM_REGS      0x80000000  /* Memory Mapped registers are available */

#define M32_MAX_SCISSOR      2047   /* Maximum scissors value */

////////////////////////////////////////////////////////////////////////////
// Mach32 Port Access
////////////////////////////////////////////////////////////////////////////

#if !(defined(ALPHA) || defined(_AXP64_) || defined(AXP64) )

#define M32_IB_DIRECT(pbase,port)                                                          \
    READ_REGISTER_UCHAR((((port) & 0xFE) == 0xE8)                                   \
        ? ((BYTE*) pbase + 0x3FFE00 + ((((port) & 0xFC00) >> 8) | ((port) & 0x1)))  \
        : ((BYTE*) pbase + 0x3FFF00 + ((((port) & 0xFC00) >> 8) | ((port) & 0x1))))

#define M32_IW_DIRECT(pbase,port)                                                          \
    READ_REGISTER_USHORT((((port) & 0xFE) == 0xE8)                                  \
        ? ((BYTE*) pbase + 0x3FFE00 + ((((port) & 0xFC00) >> 8) | ((port) & 0x1)))  \
        : ((BYTE*) pbase + 0x3FFF00 + ((((port) & 0xFC00) >> 8) | ((port) & 0x1))))

#define M32_OB_DIRECT(pbase,port,val)                                                      \
    WRITE_REGISTER_UCHAR((((port) & 0xFE) == 0xE8)                                  \
        ? ((BYTE*) pbase + 0x3FFE00 + ((((port) & 0xFC00) >> 8) | ((port) & 0x1)))  \
        : ((BYTE*) pbase + 0x3FFF00 + ((((port) & 0xFC00) >> 8) | ((port) & 0x1))), \
        (UCHAR) (val))

#define M32_OW_DIRECT(pbase,port,val)                                                      \
    WRITE_REGISTER_USHORT((((port) & 0xFE) == 0xE8)                                 \
        ? ((BYTE*) pbase + 0x3FFE00 + ((((port) & 0xFC00) >> 8) | ((port) & 0x1)))  \
        : ((BYTE*) pbase + 0x3FFF00 + ((((port) & 0xFC00) >> 8) | ((port) & 0x1))), \
        (USHORT) (val))

#else

extern BOOL isDense;

#define M32_IB_DIRECT(pbase,port)                                                          \
    (isDense?                                                                       \
    *((((port) & 0xFE) == 0xE8)                                                     \
        ? ((BYTE*) pbase + 0x3FFE00 + ((((port) & 0xFC00) >> 8) | ((port) & 0x1)))  \
        : ((BYTE*) pbase + 0x3FFF00 + ((((port) & 0xFC00) >> 8) | ((port) & 0x1)))) : \
    READ_REGISTER_UCHAR((((port) & 0xFE) == 0xE8)                                   \
        ? ((BYTE*) pbase + 0x3FFE00 + ((((port) & 0xFC00) >> 8) | ((port) & 0x1)))  \
        : ((BYTE*) pbase + 0x3FFF00 + ((((port) & 0xFC00) >> 8) | ((port) & 0x1)))))

#define M32_IW_DIRECT(pbase,port)                                                          \
    (isDense?                                                                       \
    *((((port) & 0xFE) == 0xE8)                                                     \
        ? ((BYTE*) pbase + 0x3FFE00 + ((((port) & 0xFC00) >> 8) | ((port) & 0x1)))  \
        : ((BYTE*) pbase + 0x3FFF00 + ((((port) & 0xFC00) >> 8) | ((port) & 0x1)))) : \
    READ_REGISTER_USHORT((((port) & 0xFE) == 0xE8)                                  \
        ? ((BYTE*) pbase + 0x3FFE00 + ((((port) & 0xFC00) >> 8) | ((port) & 0x1)))  \
        : ((BYTE*) pbase + 0x3FFF00 + ((((port) & 0xFC00) >> 8) | ((port) & 0x1)))))

#define M32_OB_DIRECT(pbase,port,val)                                                      \
{                                                                                   \
    if (isDense)                                                                    \
    *((UCHAR*) ((((port) & 0xFE) == 0xE8)                                                     \
        ? ((BYTE*) pbase + 0x3FFE00 + ((((port) & 0xFC00) >> 8) | ((port) & 0x1)))  \
        : ((BYTE*) pbase + 0x3FFF00 + ((((port) & 0xFC00) >> 8) | ((port) & 0x1))))) \
        = (UCHAR) (val);                                                            \
    else {                                                                          \
    WRITE_REGISTER_UCHAR((((port) & 0xFE) == 0xE8)                                  \
        ? ((BYTE*) pbase + 0x3FFE00 + ((((port) & 0xFC00) >> 8) | ((port) & 0x1)))  \
        : ((BYTE*) pbase + 0x3FFF00 + ((((port) & 0xFC00) >> 8) | ((port) & 0x1))), \
        (UCHAR) (val)); }                                                           \
    CP_MEMORY_BARRIER();                                                            \
}

#define M32_OW_DIRECT(pbase,port,val)                                                      \
{                                                                                   \
    if (isDense)                                                                    \
    *((USHORT*) ((((port) & 0xFE) == 0xE8)                                                     \
        ? ((BYTE*) pbase + 0x3FFE00 + ((((port) & 0xFC00) >> 8) | ((port) & 0x1)))  \
        : ((BYTE*) pbase + 0x3FFF00 + ((((port) & 0xFC00) >> 8) | ((port) & 0x1))))) \
        = (USHORT) (val);                                                           \
    else {                                                                          \
    WRITE_REGISTER_USHORT((((port) & 0xFE) == 0xE8)                                 \
        ? ((BYTE*) pbase + 0x3FFE00 + ((((port) & 0xFC00) >> 8) | ((port) & 0x1)))  \
        : ((BYTE*) pbase + 0x3FFF00 + ((((port) & 0xFC00) >> 8) | ((port) & 0x1))), \
        (USHORT) (val)); }                                                          \
    CP_MEMORY_BARRIER();                                                            \
}

#endif

#if defined(_X86_) || defined(_IA64_)

    #define I32_IB_DIRECT(pbase,port)                                  \
        READ_PORT_UCHAR((BYTE*)port)

    #define I32_IW_DIRECT(pbase,port)                                  \
        READ_PORT_USHORT((BYTE*)port)

    #define I32_OB_DIRECT(pbase,port,val)                              \
        WRITE_PORT_UCHAR((BYTE*)port, val)

    #define I32_OW_DIRECT(pbase,port,val)                              \
        WRITE_PORT_USHORT((BYTE*)port, (USHORT)(val))

#else

    #define I32_IB_DIRECT(pbase,port)                                  \
        READ_PORT_UCHAR((BYTE*) pbase + (port))

    #define I32_IW_DIRECT(pbase,port)                                  \
        READ_PORT_USHORT((BYTE*) pbase + (port))

    #define I32_OB_DIRECT(pbase,port,val)                              \
        WRITE_PORT_UCHAR((BYTE*) pbase + (port), val)

    #define I32_OW_DIRECT(pbase,port,val)                              \
        WRITE_PORT_USHORT((BYTE*) pbase + (port), val)

#endif

/////////////////////////////////////////////////////////////////////////
// Mach32 FIFO access
//
// The following macros should be used for all accesses to FIFO registers.
// On checked builds, they enforce proper FIFO usage protocol; on free
// builds, they incur no overhead.

#define M32_IB(pbase,port)     (M32_IB_DIRECT(pbase,port))
#define M32_IW(pbase,port)     (M32_IW_DIRECT(pbase,port))
#define M32_OB(pbase,port,val) {CHECK_FIFO_WRITE(); M32_OB_DIRECT(pbase,port,val);}
#define M32_OW(pbase,port,val) {CHECK_FIFO_WRITE(); M32_OW_DIRECT(pbase,port,val);}
#define I32_IB(pbase,port)     (I32_IB_DIRECT(pbase,port))
#define I32_IW(pbase,port)     (I32_IW_DIRECT(pbase,port))
#define I32_OB(pbase,port,val) {CHECK_FIFO_WRITE(); I32_OB_DIRECT(pbase,port,val);}
#define I32_OW(pbase,port,val) {CHECK_FIFO_WRITE(); I32_OW_DIRECT(pbase,port,val);}

#if DBG

    VOID vCheckWriteFifo();
    VOID vI32CheckFifoSpace(PDEV*, VOID*, LONG);
    VOID vM32CheckFifoSpace(PDEV*, VOID*, LONG);

    #define CHECK_FIFO_WRITE()                          \
        vCheckFifoWrite()

    #define M32_CHECK_FIFO_SPACE(ppdev, pbase, level)   \
        vM32CheckFifoSpace(ppdev, pbase, level)

    #define I32_CHECK_FIFO_SPACE(ppdev, pbase, level)   \
        vI32CheckFifoSpace(ppdev, pbase, level)

#else

    #define M32_CHECK_FIFO_SPACE(ppdev, pbase, level)                   \
    {                                                                   \
        while (M32_IW(pbase, EXT_FIFO_STATUS) & (0x10000L >> (level)))  \
            ;                                                           \
    }

    #define I32_CHECK_FIFO_SPACE(ppdev, pbase, level)                   \
    {                                                                   \
        while (I32_IW(pbase, EXT_FIFO_STATUS) & (0x10000L >> (level)))  \
            ;                                                           \
    }

#endif


////////////////////////////////////////////////////////////////////////////
// Mach64 Equates
////////////////////////////////////////////////////////////////////////////

// CRTC IO Registers
#define ioCRTC_H_TOTAL_DISP     0x02EC
#define ioBASE                  ioCRTC_H_TOTAL_DISP

#define ioCRTC_H_SYNC_STRT_WID  0x06EC
#define ioCRTC_V_TOTAL_DISP     0x0AEC
#define ioCRTC_V_SYNC_STRT_WID  0x0EEC
#define ioCRTC_CRNT_VLINE       0x12EC
#define ioCRTC_OFF_PITCH        0x16EC
#define ioCRTC_INT_CNTL         0x1AEC
#define ioCRTC_GEN_CNTL         0x1EEC

#define ioOVR_CLR               0x22EC
#define ioOVR_WID_LEFT_RIGHT    0x26EC
#define ioOVR_WID_TOP_BOTTOM    0x2AEC

#define ioCUR_CLR0              0x2EEC
#define ioCUR_CLR1              0x32EC
#define ioCUR_OFFSET            0x36EC
#define ioCUR_HORZ_VERT_POSN    0x3AEC
#define ioCUR_HORZ_VERT_OFF     0x3EEC

#define ioSCRATCH0              0x42EC
#define ioSCRATCH1              0x46EC

#define ioCLOCK_SEL_CNTL        0x4AEC

#define ioBUS_CNTL              0x4EEC

#define ioMEM_CNTL              0x52EC
#define ioMEM_VGA_WP_SEL        0x56EC
#define ioMEM_VGA_RP_SEL        0x5AEC

#define ioDAC_REGS              0x5EEC

#define ioDAC_CNTL              0x62EC

#define ioGEN_TEST_CNTL         0x66EC

#define ioCONFIG_CNTL           0x6AEC
#define ioCONFIG_CHIP_ID        0x6EEC
#define ioCONFIG_STAT           0x72EC


// CRTC MEM Registers


#define CRTC_H_TOTAL_DISP       0x0000
#define CRTC_H_SYNC_STRT_WID    0x0001
#define CRTC_V_TOTAL_DISP       0x0002
#define CRTC_V_SYNC_STRT_WID    0x0003
#define CRTC_CRNT_VLINE         0x0004
#define CRTC_OFF_PITCH          0x0005
#define CRTC_INT_CNTL           0x0006
#define CRTC_GEN_CNTL           0x0007

#define OVR_CLR                 0x0010
#define OVR_WID_LEFT_RIGHT      0x0011
#define OVR_WID_TOP_BOTTOM      0x0012

#define CUR_CLR0                0x0018
#define CUR_CLR1                0x0019
#define CUR_OFFSET              0x001A
#define CUR_HORZ_VERT_POSN      0x001B
#define CUR_HORZ_VERT_OFF       0x001C

#define SCRATCH0                0x0020
#define SCRATCH1                0x0021

#define CLOCK_SEL_CNTL          0x0024

#define BUS_CNTL                0x0028
#define BUS_CNTL_FifoErrInt     0x00200000
#define BUS_CNTL_FifoErrAk      0x00200000
#define BUS_CNTL_HostErrInt     0x00800000
#define BUS_CNTL_HostErrAk      0x00800000

#define M64_MEM_CNTL            0x002C
#define MEM_CNTL_MemBndryMsk    0x00070000
#define MEM_CNTL_MemBndryEn     0x00040000
#define MEM_CNTL_MemBndry256k   0x00040000
#define MEM_CNTL_MemBndry512k   0x00050000
#define MEM_CNTL_MemBndry768k   0x00060000
#define MEM_CNTL_MemBndry1Mb    0x00070000

#define MEM_VGA_WP_SEL          0x002D
#define MEM_VGA_RP_SEL          0x002E

#define DAC_REGS                0x0030
#define DAC_CNTL                0x0031

#define GEN_TEST_CNTL           0x0034
#define GEN_TEST_CNTL_CursorEna 0x00000080
#define GEN_TEST_CNTL_GuiEna    0x00000100
#define GEN_TEST_CNTL_TestFifoEna 0x00010000
#define GEN_TEST_CNTL_GuiRegEna   0x00020000
#define GEN_TEST_CNTL_TestMode  0x00700000
#define GEN_TEST_CNTL_TestMode0 0x00000000
#define GEN_TEST_CNTL_TestMode1 0x00100000
#define GEN_TEST_CNTL_TestMode2 0x00200000
#define GEN_TEST_CNTL_TestMode3 0x00300000
#define GEN_TEST_CNTL_TestMode4 0x00400000
#define GEN_TEST_CNTL_MemWR       0x01000000
#define GEN_TEST_CNTL_MemStrobe   0x02000000
#define GEN_TEST_CNTL_DstSSEna    0x04000000
#define GEN_TEST_CNTL_DstSSStrobe 0x08000000
#define GEN_TEST_CNTL_SrcSSEna    0x10000000
#define GEN_TEST_CNTL_SrcSSStrobe 0x20000000

#define CONFIG_CHIP_ID          0x0038
#define CONFIG_STAT             0x0039


#define DST_OFF_PITCH           0x0040
#define DST_X                   0x0041
#define DST_Y                   0x0042
#define DST_Y_X                 0x0043
#define DST_WIDTH               0x0044
#define DST_WIDTH_Disable       0x80000000
#define DST_HEIGHT              0x0045
#define DST_HEIGHT_WIDTH        0x0046
#define DST_X_WIDTH             0x0047
#define DST_BRES_LNTH           0x0048
#define DST_BRES_ERR            0x0049
#define DST_BRES_INC            0x004A
#define DST_BRES_DEC            0x004B
#define DST_CNTL                0x004C
#define DST_CNTL_XDir           0x00000001
#define DST_CNTL_YDir           0x00000002
#define DST_CNTL_YMajor         0x00000004
#define DST_CNTL_XTile          0x00000008
#define DST_CNTL_YTile          0x00000010
#define DST_CNTL_LastPel        0x00000020
#define DST_CNTL_PolyEna        0x00000040
#define DST_CNTL_24_RotEna      0x00000080
#define DST_CNTL_24_Rot         0x00000700

#define SRC_OFF_PITCH           0x0060
#define M64_SRC_X               0x0061
#define M64_SRC_Y               0x0062
#define SRC_Y_X                 0x0063
#define SRC_WIDTH1              0x0064
#define SRC_HEIGHT1             0x0065
#define SRC_HEIGHT1_WIDTH1      0x0066
#define M64_SRC_X_START         0x0067
#define SRC_Y_START             0x0068
#define SRC_Y_X_START           0x0069
#define SRC_WIDTH2              0x006A
#define SRC_HEIGHT2             0x006B
#define SRC_HEIGHT2_WIDTH2      0x006C
#define SRC_CNTL                0x006D
#define SRC_CNTL_PatEna         0x0001
#define SRC_CNTL_PatRotEna      0x0002
#define SRC_CNTL_LinearEna      0x0004
#define SRC_CNTL_ByteAlign      0x0008
#define SRC_CNTL_LineXDir       0x0010

#define HOST_DATA0              0x0080
#define HOST_DATA1              0x0081
#define HOST_DATA2              0x0082
#define HOST_DATA3              0x0083
#define HOST_DATA4              0x0084
#define HOST_DATA5              0x0085
#define HOST_DATA6              0x0086
#define HOST_DATA7              0x0087
#define HOST_DATA8              0x0088
#define HOST_DATA9              0x0089
#define HOST_DATAA              0x008A
#define HOST_DATAB              0x008B
#define HOST_DATAC              0x008C
#define HOST_DATAD              0x008D
#define HOST_DATAE              0x008E
#define HOST_DATAF              0x008F
#define HOST_CNTL               0x0090
#define HOST_CNTL_ByteAlign     0x0001

#define PAT_REG0                0x00A0
#define PAT_REG1                0x00A1
#define PAT_CNTL                0x00A2
#define PAT_CNTL_MonoEna        0x0001
#define PAT_CNTL_Clr4x2Ena      0x0002
#define PAT_CNTL_Clr8x1Ena      0x0004

#define SC_LEFT                 0x00A8
#define SC_RIGHT                0x00A9
#define SC_LEFT_RIGHT           0x00AA
#define SC_TOP                  0x00AB
#define SC_BOTTOM               0x00AC
#define SC_TOP_BOTTOM           0x00AD

#define DP_BKGD_CLR             0x00B0
#define DP_FRGD_CLR             0x00B1
#define DP_WRITE_MASK           0x00B2
#define DP_CHAIN_MASK           0x00B3
#define DP_PIX_WIDTH            0x00B4
#define DP_PIX_WIDTH_Mono       0x00000000
#define DP_PIX_WIDTH_4bpp       0x00000001
#define DP_PIX_WIDTH_8bpp       0x00000002
#define DP_PIX_WIDTH_15bpp      0x00000003
#define DP_PIX_WIDTH_16bpp      0x00000004
#define DP_PIX_WIDTH_32bpp      0x00000006
#define DP_PIX_WIDTH_NibbleSwap 0x01000000
#define DP_MIX                  0x00B5
#define DP_SRC                  0x00B6
#define DP_SRC_BkgdClr          0x0000
#define DP_SRC_FrgdClr          0x0001
#define DP_SRC_Host             0x0002
#define DP_SRC_Blit             0x0003
#define DP_SRC_Pattern          0x0004
#define DP_SRC_Always1          0x00000000
#define DP_SRC_MonoPattern      0x00010000
#define DP_SRC_MonoHost         0x00020000
#define DP_SRC_MonoBlit         0x00030000

#define CLR_CMP_CLR             0x00C0
#define CLR_CMP_MSK             0x00C1
#define CLR_CMP_CNTL            0x00C2
#define CLR_CMP_CNTL_Source     0x01000000

#define FIFO_STAT               0x00C4

#define CONTEXT_MASK            0x00C8
#define CONTEXT_SAVE_CNTL       0x00CA
#define CONTEXT_LOAD_CNTL       0x00CB
#define CONTEXT_LOAD_Cmd        0x00030000
#define CONTEXT_LOAD_CmdLoad    0x00010000
#define CONTEXT_LOAD_CmdBlt     0x00020000
#define CONTEXT_LOAD_CmdLine    0x00030000
#define CONTEXT_LOAD_Disable    0x80000000

#define GUI_TRAJ_CNTL           0x00CC
#define GUI_STAT                0x00CE

// DDraw MACH 64 stuff
//
// GUI_STAT
#define GUI_ACTIVE             0x00000001L
#define DSTX_LT_SCISSOR_LEFT   0x00000100L
#define DSTX_GT_SCISSOR_RIGHT  0x00000200L
#define DSTY_LT_SCISSOR_TOP    0x00000400L
#define DSTY_GT_SCISSOR_BOTTOM 0x00000800L
// DST Shifts
#define SHIFT_DST_PITCH 22  // DST_OFF_PITCH
#define SHIFT_DST_X     16  // DST_Y_X
#define SHIFT_DST_WIDTH 16  // DST_HEIGHT_WIDTH DST_X_WIDTH
// DST_WIDTH
#define DST_WIDTH_FILL_DIS 0x80000000L
// SC Shifts
#define SHIFT_SC_RIGHT  16
#define SHIFT_SC_BOTTOM 16
// DP_PIX_WIDTH
#define DP_DST_PIX_WIDTH  0x00000007L
#define DP_SRC_PIX_WIDTH  0x00000700L
#define DP_HOST_PIX_WIDTH 0x00070000L
#define DP_BYTE_PIX_ORDER 0x01000000L

#define DP_PIX_WIDTH_MONO  0x00000000L
#define DP_PIX_WIDTH_4BPP  0x00010101L
#define DP_PIX_WIDTH_8BPP  0x00020202L
#define DP_PIX_WIDTH_15BPP 0x00030303L
#define DP_PIX_WIDTH_16BPP 0x00040404L
#define DP_PIX_WIDTH_24BPP 0x00020202L
#define DP_PIX_WIDTH_32BPP 0x00060606L
// DP_MIX
#define DP_BKGD_MIX 0x0000001FL
#define DP_FRGD_MIX 0x001F0000L

#define DP_MIX_Dn   0x00000000L
#define DP_MIX_0    0x00010001L
#define DP_MIX_1    0x00020002L
#define DP_MIX_D    0x00030003L
#define DP_MIX_Sn   0x00040004L
#define DP_MIX_DSx  0x00050005L
#define DP_MIX_DSxn 0x00060006L
#define DP_MIX_S    0x00070007L
#define DP_MIX_DSan 0x00080008L
#define DP_MIX_DSno 0x00090009L
#define DP_MIX_SDno 0x000A000AL
#define DP_MIX_DSo  0x000B000BL
#define DP_MIX_DSa  0x000C000CL
#define DP_MIX_SDna 0x000D000DL
#define DP_MIX_DSna 0x000E000EL
#define DP_MIX_DSon 0x000F000FL
#define DP_MIX_0x17 0x00170017L
// DP_SRC
#define DP_BKGD_SRC 0x00000007L
#define DP_FRGD_SRC 0x00000700L
#define DP_MONO_SRC 0x00030000L

#define DP_SRC_BKGD 0x00000000L
#define DP_SRC_FRGD 0x00000101L
#define DP_SRC_HOST 0x00020202L
#define DP_SRC_VRAM 0x00030303L
#define DP_SRC_PATT 0x00010404L
// CLR_CMP_CNTL
#define CLR_CMP_FCN 0x00000007L
#define CLR_CMP_SRC 0x01000000L

#define CLR_CMP_FCN_FALSE 0x00000000L
#define CLR_CMP_FCN_TRUE  0x00000001L
#define CLR_CMP_FCN_NE    0x00000004L
#define CLR_CMP_FCN_EQ    0x00000005L
// DST_CNTL
#define DST_X_DIR      0x00000001L
#define DST_Y_DIR      0x00000002L
#define DST_Y_MAJOR    0x00000004L
#define DST_X_TILE     0x00000008L
#define DST_Y_TILE     0x00000010L
#define DST_LAST_PEL   0x00000020L
#define DST_POLYGON_EN 0x00000040L
#define DST_24_ROT_EN  0x00000080L
#define DST_24_ROT     0x00000700L
#define DST_BRES_SIGN  0x00000800L
//  SRC Shifts
#define SHIFT_SRC_PITCH   22
#define SHIFT_SRC_X       16
#define SHIFT_SRC_WIDTH1  16
#define SHIFT_SRC_X_START 16
#define SHIFT_SRC_WIDTH2  16
// SRC_CNTL
#define SRC_PATT_EN     0x00000001L
#define SRC_PATT_ROT_EN 0x00000002L
#define SRC_LINEAR_EN   0x00000004L
#define SRC_BYTE_ALIGN  0x00000008L

#define ONE_WORD             0x8000
#define TWO_WORDS            0xC000
#define THREE_WORDS          0xE000
#define FOUR_WORDS           0xF000
#define FIVE_WORDS           0xF800
#define SIX_WORDS            0xFC00
#define SEVEN_WORDS          0xFE00
#define EIGHT_WORDS          0xFF00
#define NINE_WORDS           0xFF80
#define TEN_WORDS            0xFFC0
#define ELEVEN_WORDS         0xFFE0
#define TWELVE_WORDS         0xFFF0
#define THIRTEEN_WORDS       0xFFF8
#define FOURTEEN_WORDS       0xFFFC
#define FIFTEEN_WORDS        0xFFFE
#define SIXTEEN_WORDS        0xFFFF

#define REG_W                0  // DAC REGS offset for Write
#define REG_D                1  // DAC REGS offset for Data
#define REG_M                2  // DAC REGS offset for Mask
#define REG_R                3  // DAC REGS offset for Read
#define MAX_NEGX             4096

#define M64_MAX_SCISSOR_R    4095   /* Maximum right scissors value */
#define M64_MAX_SCISSOR_B    16383  /* Maximum bottom scissors value */

#define CRTC_VBLANK 0x00000001L
#define MUL24   3


////////////////////////////////////////////////////////////////////////////
// Mach64 Port Access
////////////////////////////////////////////////////////////////////////////

// NOTE: This macro must not be used if 'y' can be negative:

#define PACKXY(x, y)        (((x) << 16) | ((y) & 0xffff))
#define PACKXY_FAST(x, y)   (((x) << 16) | ((y) & 0xffff))
//#define PACKXY_FAST(x, y)   (((x) << 16) | (y))
#define PACKPAIR(a, b)      (((b) << 16) | (a))

#if !( defined(ALPHA) || defined(_AXP64_) || defined(AXP64) )

#define M64_ID_DIRECT(pbase,port)                   \
    READ_REGISTER_ULONG((ULONG*) pbase + (port))

#define M64_OD_DIRECT(pbase,port,val)                               \
    WRITE_REGISTER_ULONG((ULONG*) pbase + (port), (val));           \
    CP_EIEIO()

#else

extern BOOL isDense;

#define M64_ID_DIRECT(pbase,port)                                   \
    (isDense? *((ULONG*) pbase +                                    \
    (port)):READ_REGISTER_ULONG((ULONG*) pbase + (port)))

#define M64_OD_DIRECT(pbase,port,val)                               \
{                                                                   \
    if (isDense)                                                    \
        *((ULONG*) pbase + (port)) = (ULONG) (val);                 \
    else {                                                          \
        WRITE_REGISTER_ULONG((ULONG*) pbase + (port), (val)); }     \
    CP_MEMORY_BARRIER();                                            \
}

#endif

VOID vM64DataPortOutB(PDEV *ppdev, PBYTE pb, UINT count);

/////////////////////////////////////////////////////////////////////////
// Mach64 FIFO access
//
// The following macros should be used for all accesses to FIFO registers.
// On checked builds, they enforce proper FIFO usage protocol; on free
// builds, they incur no overhead.

#define M64_ID(pbase,port)     (M64_ID_DIRECT(pbase,port))
#define M64_OD(pbase,port,val) {CHECK_FIFO_WRITE(); M64_OD_DIRECT(pbase,port,val);}

#if DBG

    VOID  vCheckFifoWrite();
    VOID  vM64CheckFifoSpace(PDEV*, VOID*, LONG);
    ULONG ulM64FastFifoCheck(PDEV*, VOID*, LONG, ULONG);

    #define CHECK_FIFO_WRITE()                                  \
        vCheckFifoWrite()

    #define M64_CHECK_FIFO_SPACE(ppdev, pbase, level)           \
        vM64CheckFifoSpace(ppdev, pbase, level)

    #define M64_FAST_FIFO_CHECK(ppdev, pbase, level, ulFifo)    \
        (ulFifo) = ulM64FastFifoCheck(ppdev, pbase, level, ulFifo)

    #define I32_FIFO_SPACE_AVAIL(ppdev, pbase, level)             \
         (I32_IW((pbase), EXT_FIFO_STATUS) & (0x10000L >> (level)))                                                        \

    #define M32_FIFO_SPACE_AVAIL(ppdev, pbase, level)             \
         (M32_IW((pbase), EXT_FIFO_STATUS) & (0x10000L >> (level)))                                                        \

    #define M64_FIFO_SPACE_AVAIL(ppdev, pbase, level)             \
         (M64_ID((pbase), FIFO_STAT) & (0x10000L >> (level)))                                                        \


#else

    #define CHECK_FIFO_WRITE()

    #define M64_CHECK_FIFO_SPACE(ppdev, pbase, level)                   \
    {                                                                   \
        while (M64_ID((pbase), FIFO_STAT) & (0x10000L >> (level)))      \
            ;                                                           \
    }

    // This handy little macro is useful for amortizing the read cost of
    // the status register:

    #define M64_FAST_FIFO_CHECK(ppdev, pbase, level, ulFifo)            \
    {                                                                   \
        while (!((ulFifo) & (0x10000L >> (level))))                     \
        {                                                               \
            (ulFifo) = ~M64_ID((pbase), FIFO_STAT); /* Invert bits */   \
        }                                                               \
        (ulFifo) <<= (level);                                           \
    }

    #define M64_FIFO_SPACE_AVAIL(ppdev, pbase, level)             \
         (M64_ID((pbase), FIFO_STAT) & (0x10000L >> (level)))                                                        \

    #define I32_FIFO_SPACE_AVAIL(ppdev, pbase, level)             \
         (I32_IW((pbase), EXT_FIFO_STATUS) & (0x10000L >> (level)))                                                        \

    #define M32_FIFO_SPACE_AVAIL(ppdev, pbase, level)             \
         (M32_IW((pbase), EXT_FIFO_STATUS) & (0x10000L >> (level)))                                                        \

#endif


// Wait for engine idle.  These macros are used to work around timing
// problems due to flakey hardware.

#define vM64QuietDown(ppdev,pjBase) \
{ \
    M64_CHECK_FIFO_SPACE(ppdev, pjBase, 16);    \
    CP_EIEIO();                                    \
    do {} while (M64_ID(pjBase, GUI_STAT) & 1); \
}

#define vM32QuietDown(ppdev,pjBase) \
{ \
    M32_CHECK_FIFO_SPACE(ppdev, pjBase, 16); \
    do {} while (M32_IW(pjBase, EXT_GE_STATUS) & GE_ACTIVE); \
}

#define vI32QuietDown(ppdev,pjBase) \
{ \
    I32_CHECK_FIFO_SPACE(ppdev, pjBase, 16); \
    do {} while (I32_IW(pjBase, EXT_GE_STATUS) & GE_ACTIVE); \
}

// DDraw macros

#define IN_VBLANK_64( pjMmBase )(M64_ID (pjMmBase, CRTC_INT_CNTL ) & CRTC_VBLANK)
#define CURRENT_VLINE_64( pjMmBase)((WORD)(M64_ID(pjMmBase,CRTC_CRNT_VLINE)>>16))
#define DRAW_ENGINE_BUSY_64( ppdev, pjMmBase)   (((M64_FIFO_SPACE_AVAIL(ppdev,pjMmBase, 16 )) || ((M64_ID(pjMmBase, GUI_STAT)) & GUI_ACTIVE)))

// the next define is for overlay support
#define DD_WriteVTReg(port,val)     { \
             WRITE_REGISTER_ULONG((ULONG*) ppdev->pjMmBase_Ext + (port), (val));           \
            CP_MEMORY_BARRIER(); \
            }

// Special I/O routines to read DAC regs on the mach64 (for relocatable I/O)

#define rioIB(port)       READ_PORT_UCHAR((port))
#define rioOB(port, val)  WRITE_PORT_UCHAR((port), (val))

////////////////////////////////////////////////////////////////////////////////
// Context Stuff
//
// Default context used to initialize the hardware before graphics operations.
// Certain registers, such as DP_WRITE_MASK and CLR_CMP_CNTL, need to be reset
// because they fail to latch properly after a blit operation.  Mach64 only.

VOID vSetDefaultContext(PDEV * ppdev);
VOID vEnableContexts(PDEV * ppdev);

// For overlay support
/////////////////////////////////////////////////////////////////////////////
// DirectDraw stuff

#define IS_RGB15_R(flRed) \
        (flRed == 0x7c00)

#define IS_RGB15(this) \
        (((this)->dwRBitMask == 0x7c00) && \
         ((this)->dwGBitMask == 0x03e0) && \
         ((this)->dwBBitMask == 0x001f))

#define IS_RGB16(this) \
        (((this)->dwRBitMask == 0xf800) && \
         ((this)->dwGBitMask == 0x07e0) && \
         ((this)->dwBBitMask == 0x001f))

#define IS_RGB24(this) \
        (((this)->dwRBitMask == 0x00ff0000) && \
         ((this)->dwGBitMask == 0x0000ff00) && \
         ((this)->dwBBitMask == 0x000000ff))

#define IS_RGB32(this) \
        (((this)->dwRBitMask == 0x00ff0000) && \
         ((this)->dwGBitMask == 0x0000ff00) && \
         ((this)->dwBBitMask == 0x000000ff))

#define RGB15to32(c) \
        (((c & 0x7c00) << 9) | \
         ((c & 0x03e0) << 6) | \
         ((c & 0x001f) << 3))

#define RGB16to32(c) \
        (((c & 0xf800) << 8) | \
         ((c & 0x07e0) << 5) | \
         ((c & 0x001f) << 3))
// end macros for overlay support
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\enable.c ===
/******************************Module*Header*******************************\
* Module Name: enable.c
*
* This module contains the functions that enable and disable the
* driver, the pdev, and the surface.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#if defined(ALPHA)

/**************************************************************************\
* BOOL isDense
*
* This global is used to distinguish dense space from sparse space on the
* DEC Alpha in order to use the appropriate method of register access.
*
\**************************************************************************/

BOOL isDense = TRUE;

#endif

/******************************Public*Structure****************************\
* GDIINFO ggdiDefault
*
* This contains the default GDIINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

GDIINFO ggdiDefault = {
    GDI_DRIVER_VERSION,     // ulVersion
    DT_RASDISPLAY,          // ulTechnology
    0,                      // ulHorzSize (filled in later)
    0,                      // ulVertSize (filled in later)
    0,                      // ulHorzRes (filled in later)
    0,                      // ulVertRes (filled in later)
    0,                      // cBitsPixel (filled in later)
    0,                      // cPlanes (filled in later)
    20,                     // ulNumColors (palette managed)
    0,                      // flRaster (DDI reserved field)

    0,                      // ulLogPixelsX (filled in later)
    0,                      // ulLogPixelsY (filled in later)

    TC_RA_ABLE,             // flTextCaps -- If we had wanted console windows
                            //   to scroll by repainting the entire window,
                            //   instead of doing a screen-to-screen blt, we
                            //   would have set TC_SCROLLBLT (yes, the flag is
                            //   bass-ackwards).

    0,                      // ulDACRed (filled in later)
    0,                      // ulDACGreen (filled in later)
    0,                      // ulDACBlue (filled in later)

    0x0024,                 // ulAspectX
    0x0024,                 // ulAspectY
    0x0033,                 // ulAspectXY (one-to-one aspect ratio)

    1,                      // xStyleStep
    1,                      // yStyleSte;
    3,                      // denStyleStep -- Styles have a one-to-one aspect
                            //   ratio, and every 'dot' is 3 pixels long

    { 0, 0 },               // ptlPhysOffset
    { 0, 0 },               // szlPhysSize

    256,                    // ulNumPalReg

    // These fields are for halftone initialization.  The actual values are
    // a bit magic, but seem to work well on our display.

    {                       // ciDevice
       { 6700, 3300, 0 },   //      Red
       { 2100, 7100, 0 },   //      Green
       { 1400,  800, 0 },   //      Blue
       { 1750, 3950, 0 },   //      Cyan
       { 4050, 2050, 0 },   //      Magenta
       { 4400, 5200, 0 },   //      Yellow
       { 3127, 3290, 0 },   //      AlignmentWhite
       20000,               //      RedGamma
       20000,               //      GreenGamma
       20000,               //      BlueGamma
       0, 0, 0, 0, 0, 0     //      No dye correction for raster displays
    },

    0,                       // ulDevicePelsDPI (for printers only)
    PRIMARY_ORDER_CBA,       // ulPrimaryOrder
    HT_PATSIZE_4x4_M,        // ulHTPatternSize
    HT_FORMAT_8BPP,          // ulHTOutputFormat
    HT_FLAG_ADDITIVE_PRIMS,  // flHTFlags
    0,                       // ulVRefresh
    0,                       // ulPanningHorzRes
    0,                       // ulPanningVertRes
    0,                       // ulBltAlignment
};

/******************************Public*Structure****************************\
* DEVINFO gdevinfoDefault
*
* This contains the default DEVINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       FIXED_PITCH | FF_DONTCARE, L"Courier"}

DEVINFO gdevinfoDefault = {
    (GCAPS_OPAQUERECT       |
     GCAPS_DITHERONREALIZE  |
     GCAPS_PALMANAGED       |
     GCAPS_ALTERNATEFILL    |
     GCAPS_WINDINGFILL      |
#if TARGET_BUILD > 351
     GCAPS_DIRECTDRAW       |
#endif
     GCAPS_MONO_DITHER      |
     GCAPS_COLOR_DITHER     |
     GCAPS_ASYNCMOVE),          // NOTE: Only enable ASYNCMOVE if your code
                                //   and hardware can handle DrvMovePointer
                                //   calls at any time, even while another
                                //   thread is in the middle of a drawing
                                //   call such as DrvBitBlt.

                                                // flGraphicsFlags
    SYSTM_LOGFONT,                              // lfDefaultFont
    HELVE_LOGFONT,                              // lfAnsiVarFont
    COURI_LOGFONT,                              // lfAnsiFixFont
    0,                                          // cFonts
    BMF_8BPP,                                   // iDitherFormat
    8,                                          // cxDither
    8,                                          // cyDither
    0                                           // hpalDefault (filled in later)
};

/******************************Public*Structure****************************\
* DFVFN gadrvfn[]
*
* Build the driver function table gadrvfn with function index/address
* pairs.  This table tells GDI which DDI calls we support, and their
* location (GDI does an indirect call through this table to call us).
*
* Why haven't we implemented DrvSaveScreenBits?  To save code.
*
* When the driver doesn't hook DrvSaveScreenBits, USER simulates on-
* the-fly by creating a temporary device-format-bitmap, and explicitly
* calling DrvCopyBits to save/restore the bits.  Since we already hook
* DrvCreateDeviceBitmap, we'll end up using off-screen memory to store
* the bits anyway (which would have been the main reason for implementing
* DrvSaveScreenBits).  So we may as well save some working set.
\**************************************************************************/

#if MULTI_BOARDS

// Multi-board support has its own thunks...

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) MulEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) MulCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) MulDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) MulEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) MulDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) MulAssertMode         },
    {   INDEX_DrvMovePointer,           (PFN) MulMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) MulSetPointerShape    },
    {   INDEX_DrvDitherColor,           (PFN) MulDitherColor        },
    {   INDEX_DrvSetPalette,            (PFN) MulSetPalette         },
    {   INDEX_DrvCopyBits,              (PFN) MulCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) MulBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) MulTextOut            },
    {   INDEX_DrvGetModes,              (PFN) MulGetModes           },
    {   INDEX_DrvStrokePath,            (PFN) MulStrokePath         },
    {   INDEX_DrvFillPath,              (PFN) MulFillPath           },
    {   INDEX_DrvPaint,                 (PFN) MulPaint              },
    {   INDEX_DrvRealizeBrush,          (PFN) MulRealizeBrush       },
    {   INDEX_DrvDestroyFont,           (PFN) MulDestroyFont        },
#if TARGET_BUILD > 351
    {   INDEX_DrvGetDirectDrawInfo,     (PFN) DrvGetDirectDrawInfo  },
    {   INDEX_DrvEnableDirectDraw,      (PFN) DrvEnableDirectDraw   },
    {   INDEX_DrvDisableDirectDraw,     (PFN) DrvDisableDirectDraw  },
#endif
    {   INDEX_DrvDisableDriver,         (PFN) DrvDisableDriver      }
    // Note that we don't support DrvCreateDeviceBitmap for multi-boards
    // Note that we don't support DrvDeleteDeviceBitmap for multi-boards
    // Note that we don't support DrvStretchBlt for multi-boards
    // Note that we don't support DrvLineTo for multi-boards
    // Note that we don't support DrvEscape for multi-boards
};

#elif DBG

// On Checked builds, thunk everything through Dbg calls...

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DbgEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DbgCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DbgDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DbgEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DbgDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DbgAssertMode         },
    {   INDEX_DrvMovePointer,           (PFN) DbgMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) DbgSetPointerShape    },
    {   INDEX_DrvDitherColor,           (PFN) DbgDitherColor        },
    {   INDEX_DrvSetPalette,            (PFN) DbgSetPalette         },
    {   INDEX_DrvCopyBits,              (PFN) DbgCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) DbgBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) DbgTextOut            },
    {   INDEX_DrvGetModes,              (PFN) DbgGetModes           },
    {   INDEX_DrvStrokePath,            (PFN) DbgStrokePath         },
#if TARGET_BUILD > 351
    {   INDEX_DrvLineTo,                (PFN) DbgLineTo             },
#endif
    {   INDEX_DrvFillPath,              (PFN) DbgFillPath           },
    {   INDEX_DrvPaint,                 (PFN) DbgPaint              },
    {   INDEX_DrvStretchBlt,            (PFN) DbgStretchBlt         },
    {   INDEX_DrvRealizeBrush,          (PFN) DbgRealizeBrush       },
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DbgCreateDeviceBitmap },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DbgDeleteDeviceBitmap },
    {   INDEX_DrvDestroyFont,           (PFN) DbgDestroyFont        },
#if TARGET_BUILD > 351
    {   INDEX_DrvGetDirectDrawInfo,     (PFN) DrvGetDirectDrawInfo  },
    {   INDEX_DrvEnableDirectDraw,      (PFN) DrvEnableDirectDraw   },
    {   INDEX_DrvDisableDirectDraw,     (PFN) DrvDisableDirectDraw  },
#endif
    {   INDEX_DrvDisableDriver,         (PFN) DbgDisableDriver      }
};

#else

// On Free builds, directly call the appropriate functions...

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode         },
    {   INDEX_DrvMovePointer,           (PFN) DrvMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) DrvSetPointerShape    },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor        },
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette         },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut            },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes           },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath         },
#if TARGET_BUILD > 351
    {   INDEX_DrvLineTo,                (PFN) DrvLineTo             },
#endif
    {   INDEX_DrvFillPath,              (PFN) DrvFillPath           },
    {   INDEX_DrvPaint,                 (PFN) DrvPaint              },
    {   INDEX_DrvStretchBlt,            (PFN) DrvStretchBlt         },
    {   INDEX_DrvRealizeBrush,          (PFN) DrvRealizeBrush       },
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DrvCreateDeviceBitmap },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DrvDeleteDeviceBitmap },
    {   INDEX_DrvDestroyFont,           (PFN) DrvDestroyFont        },
#if TARGET_BUILD > 351
    {   INDEX_DrvGetDirectDrawInfo,     (PFN) DrvGetDirectDrawInfo  },
    {   INDEX_DrvEnableDirectDraw,      (PFN) DrvEnableDirectDraw   },
    {   INDEX_DrvDisableDirectDraw,     (PFN) DrvDisableDirectDraw  },
#endif
    {   INDEX_DrvDisableDriver,         (PFN) DrvDisableDriver      }
};

#endif

ULONG gcdrvfn = sizeof(gadrvfn) / sizeof(DRVFN);

/******************************Public*Routine******************************\
* BOOL DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

BOOL DrvEnableDriver(
ULONG          iEngineVersion,
ULONG          cj,
DRVENABLEDATA* pded)
{
    // Engine Version is passed down so future drivers can support previous
    // engine versions.  A next generation driver can support both the old
    // and new engine conventions if told what version of engine it is
    // working with.  For the first version the driver does nothing with it.

    // Fill in as much as we can.

    if (cj >= sizeof(DRVENABLEDATA))
        pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
        pded->c = gcdrvfn;

    // DDI version this driver was targeted for is passed back to engine.
    // Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
        pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID DrvDisableDriver
*
* Tells the driver it is being disabled. Release any resources allocated in
* DrvEnableDriver.
*
\**************************************************************************/

VOID DrvDisableDriver(VOID)
{
    return;
}

/******************************Public*Routine******************************\
* BOOL bInitializeATI
*
* Initializes some private ATI info.
*
\**************************************************************************/

BOOL bInitializeATI(PDEV* ppdev)
{
    ENH_VERSION_NT  info;
    ULONG           ReturnedDataLength;

    info.FeatureFlags     = 0;
    info.StructureVersion = 0;
    info.InterfaceVersion = 0;      // Miniport needs these to be zero

    // Get some adapter information via a private IOCTL call:

    if (!AtiDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_ATI_GET_VERSION,
                           &info,
                           sizeof(ENH_VERSION_NT),
                           &info,
                           sizeof(ENH_VERSION_NT),
                           &ReturnedDataLength))
    {
        DISPDBG((0, "bInitializeATI - Failed ATI_GET_VERSION"));
        goto ReturnFalse;
    }

    ppdev->FeatureFlags = info.FeatureFlags;

    ppdev->iAsic     = info.ChipIndex;
    ppdev->iAperture = info.ApertureType;
#if defined(ALPHA)
    if (!(ppdev->FeatureFlags & EVN_DENSE_CAPABLE))
    {
        // Can't use a sparse linear aperture.
        // Banked aperture is always sparse.
        // In either case, we execute no-aperture code...
        ppdev->iAperture = APERTURE_NONE;
        isDense = FALSE;
    }
#endif

    if (info.ChipIndex == ASIC_88800GX)
    {
        ppdev->iMachType = MACH_MM_64;
    }
    else if (info.BusFlag & FL_MM_REGS)
    {
        ppdev->iMachType = MACH_MM_32;
    }
    else
    {
        ppdev->iMachType = MACH_IO_32;
    }

    return(TRUE);

ReturnFalse:

    return(FALSE);
}

/******************************Public*Routine******************************\
* DHPDEV DrvEnablePDEV
*
* Initializes a bunch of fields for GDI, based on the mode we've been asked
* to do.  This is the first thing called after DrvEnableDriver, when GDI
* wants to get some information about us.
*
* (This function mostly returns back information; DrvEnableSurface is used
* for initializing the hardware and driver components.)
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
DEVMODEW*   pdm,            // Contains data pertaining to requested mode
PWSTR       pwszLogAddr,    // Logical address
ULONG       cPat,           // Count of standard patterns
HSURF*      phsurfPatterns, // Buffer for standard patterns
ULONG       cjCaps,         // Size of buffer for device caps 'pdevcaps'
ULONG*      pdevcaps,       // Buffer for device caps, also known as 'gdiinfo'
ULONG       cjDevInfo,      // Number of bytes in device info 'pdi'
DEVINFO*    pdi,            // Device information
#if TARGET_BUILD > 351
HDEV        hdev,           // Used for callbacks
#else
PWSTR       pwszDataFile,
#endif
PWSTR       pwszDeviceName, // Device name
HANDLE      hDriver)        // Kernel driver handle
{
    PDEV*   ppdev;

    // Future versions of NT had better supply 'devcaps' and 'devinfo'
    // structures that are the same size or larger than the current
    // structures:

    if ((cjCaps < sizeof(GDIINFO)) || (cjDevInfo < sizeof(DEVINFO)))
    {
        DISPDBG((0, "DrvEnablePDEV - Buffer size too small"));
        goto ReturnFailure0;
    }

    // Allocate a physical device structure.  Note that we definitely
    // rely on the zero initialization:

    ppdev = AtiAllocMem(LPTR, FL_ZERO_MEMORY, sizeof(PDEV));
    if (ppdev == NULL)
    {
        DISPDBG((0, "DrvEnablePDEV - Failed AtiAllocMem"));
        goto ReturnFailure0;
    }

    ppdev->hDriver = hDriver;

    // Do some private ATI-specific initialization:

    if (!bInitializeATI(ppdev))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializeATI"));
        goto ReturnFailure1;
    }

    // Get the current screen mode information.  Set up device caps and
    // devinfo:

    if (!bInitializeModeFields(ppdev, (GDIINFO*) pdevcaps, pdi, pdm))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializeModeFields"));
        goto ReturnFailure1;
    }

    // Initialize palette information.

    if (!bInitializePalette(ppdev, pdi))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializePalette"));
        goto ReturnFailure1;
    }

    return((DHPDEV) ppdev);

ReturnFailure1:
    DrvDisablePDEV((DHPDEV) ppdev);

ReturnFailure0:
    DISPDBG((0, "Failed DrvEnablePDEV"));

    return(0);
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
* Note that this function will be called when previewing modes in the
* Display Applet, but not at system shutdown.  If you need to reset the
* hardware at shutdown, you can do it in the miniport by providing a
* 'HwResetHw' entry point in the VIDEO_HW_INITIALIZATION_DATA structure.
*
* Note: In an error, we may call this before DrvEnablePDEV is done.
*
\**************************************************************************/

VOID DrvDisablePDEV(
DHPDEV  dhpdev)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

    vUninitializePalette(ppdev);
    AtiFreeMem(ppdev);
}

/******************************Public*Routine******************************\
* VOID DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    ((PDEV*) dhpdev)->hdevEng = hdev;
}


/******************************Public*Routine******************************\
* HSURF DrvEnableSurface
*
* Creates the drawing surface, initializes the hardware, and initializes
* driver components.  This function is called after DrvEnablePDEV, and
* performs the final device initialization.
*
\**************************************************************************/

HSURF DrvEnableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;
    HSURF   hsurf;
    SIZEL   sizl;
    DSURF*  pdsurf;
    VOID*   pvTmpBuffer;

    ppdev = (PDEV*) dhpdev;

    /////////////////////////////////////////////////////////////////////
    // First enable all the subcomponents.
    //
    // Note that the order in which these 'Enable' functions are called
    // may be significant in low off-screen memory conditions, because
    // the off-screen heap manager may fail some of the later
    // allocations...

    if (!bEnableHardware(ppdev))
        goto ReturnFailure;

    if (!bEnableBanking(ppdev))
        goto ReturnFailure;

    if (!bEnableOffscreenHeap(ppdev))
        goto ReturnFailure;

    if (!bEnablePointer(ppdev))
        goto ReturnFailure;

    if (!bEnableText(ppdev))
        goto ReturnFailure;

    if (!bEnableBrushCache(ppdev))
        goto ReturnFailure;

    if (!bEnablePalette(ppdev))
        goto ReturnFailure;

    if (!bEnableDirectDraw(ppdev))
        goto ReturnFailure;

    /////////////////////////////////////////////////////////////////////
    // Now create our private surface structure.
    //
    // Whenever we get a call to draw directly to the screen, we'll get
    // passed a pointer to a SURFOBJ whose 'dhpdev' field will point
    // to our PDEV structure, and whose 'dhsurf' field will point to the
    // following DSURF structure.
    //
    // Every device bitmap we create in DrvCreateDeviceBitmap will also
    // have its own unique DSURF structure allocated (but will share the
    // same PDEV).  To make our code more polymorphic for handling drawing
    // to either the screen or an off-screen bitmap, we have the same
    // structure for both.

    pdsurf = AtiAllocMem(LPTR, FL_ZERO_MEMORY, sizeof(DSURF));
    if (pdsurf == NULL)
    {
        DISPDBG((0, "DrvEnableSurface - Failed pdsurf AtiAllocMem"));
        goto ReturnFailure;
    }

    ppdev->pdsurfScreen = pdsurf;           // Remember it for clean-up
    pdsurf->poh     = ppdev->pohScreen;     // The screen is a surface, too
    pdsurf->dt      = DT_SCREEN;            // Not to be confused with a DIB
    pdsurf->sizl.cx = ppdev->cxScreen;
    pdsurf->sizl.cy = ppdev->cyScreen;
    pdsurf->ppdev   = ppdev;

    /////////////////////////////////////////////////////////////////////
    // Next, have GDI create the actual SURFOBJ.
    //
    // Our drawing surface is going to be 'device-managed', meaning that
    // GDI cannot draw on the framebuffer bits directly, and as such we
    // create the surface via EngCreateDeviceSurface.  By doing this, we ensure
    // that GDI will only ever access the bitmaps bits via the Drv calls
    // that we've HOOKed.
    //
    // If we could map the entire framebuffer linearly into main memory
    // (i.e., we didn't have to go through a 64k aperture), it would be
    // beneficial to create the surface via EngCreateBitmap, giving GDI a
    // pointer to the framebuffer bits.  When we pass a call on to GDI
    // where it can't directly read/write to the surface bits because the
    // surface is device managed, it has to create a temporary bitmap and
    // call our DrvCopyBits routine to get/set a copy of the affected bits.
    // Fer example, the OpenGL component prefers to be able to write on the
    // framebuffer bits directly.

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    // Let GDI manage 24bpp mach32 with linear aperture.
    if (ppdev->iBitmapFormat == BMF_24BPP &&
        ppdev->iAsic != ASIC_88800GX && ppdev->iAperture == APERTURE_FULL)
    {
        hsurf= ppdev->hsurfPunt;

        //
        // Also tell GDI that we don't want to be called back.
        //

        if (!EngAssociateSurface(hsurf, ppdev->hdevEng, 0))
        {
            DISPDBG((0, "DrvEnableSurface - Failed EngAssociateSurface"));
            goto ReturnFailure;
        }
    }
    else
    {
        hsurf = EngCreateDeviceSurface((DHSURF) pdsurf, sizl, ppdev->iBitmapFormat);
        if (hsurf == 0)
        {
            DISPDBG((0, "DrvEnableSurface - Failed EngCreateDeviceSurface"));
            goto ReturnFailure;
        }

        ppdev->hsurfScreen = hsurf;             // Remember it for clean-up
        ppdev->bEnabled = TRUE;                 // We'll soon be in graphics mode

        /////////////////////////////////////////////////////////////////////
        // Now associate the surface and the PDEV.
        //
        // We have to associate the surface we just created with our physical
        // device so that GDI can get information related to the PDEV when
        // it's drawing to the surface (such as, for example, the length of
        // styles on the device when simulating styled lines).
        //

        if (!EngAssociateSurface(hsurf, ppdev->hdevEng, ppdev->flHooks))
        {
            DISPDBG((0, "DrvEnableSurface - Failed EngAssociateSurface"));
            goto ReturnFailure;
        }
    }

    // Create our generic temporary buffer, which may be used by any
    // component.

    pvTmpBuffer = AtiAllocMem(LMEM_FIXED, 0, TMP_BUFFER_SIZE);
    if (pvTmpBuffer == NULL)
    {
        DISPDBG((0, "DrvEnableSurface - Failed VirtualAlloc"));
        goto ReturnFailure;
    }

    ppdev->pvTmpBuffer = pvTmpBuffer;

    DISPDBG((5, "Passed DrvEnableSurface"));

    return(hsurf);

ReturnFailure:
    DrvDisableSurface((DHPDEV) ppdev);

    DISPDBG((0, "Failed DrvEnableSurface"));

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
* Note that this function will be called when previewing modes in the
* Display Applet, but not at system shutdown.  If you need to reset the
* hardware at shutdown, you can do it in the miniport by providing a
* 'HwResetHw' entry point in the VIDEO_HW_INITIALIZATION_DATA structure.
*
* Note: In an error case, we may call this before DrvEnableSurface is
*       completely done.
*
\**************************************************************************/

VOID DrvDisableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

    // Note: In an error case, some of the following relies on the
    //       fact that the PDEV is zero-initialized, so fields like
    //       'hsurfScreen' will be zero unless the surface has been
    //       sucessfully initialized, and makes the assumption that
    //       EngDeleteSurface can take '0' as a parameter.

    vDisableDirectDraw(ppdev);
    vDisablePalette(ppdev);
    vDisableBrushCache(ppdev);
    vDisableText(ppdev);
    vDisablePointer(ppdev);
    vDisableOffscreenHeap(ppdev);
    vDisableBanking(ppdev);
    vDisableHardware(ppdev);

    AtiFreeMem(ppdev->pvTmpBuffer);
    EngDeleteSurface(ppdev->hsurfScreen);
    AtiFreeMem(ppdev->pdsurfScreen);
}

/******************************Public*Routine******************************\
* VOID DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

#if TARGET_BUILD > 351
BOOL DrvAssertMode(
#else
VOID DrvAssertMode(
#endif
DHPDEV  dhpdev,
BOOL    bEnable)
{
    PDEV* ppdev;

    ppdev = (PDEV*) dhpdev;

    if (!bEnable)
    {
        //////////////////////////////////////////////////////////////
        // Disable - Switch to full-screen mode

        vAssertModeDirectDraw(ppdev, FALSE);

        vAssertModePalette(ppdev, FALSE);

        vAssertModeBrushCache(ppdev, FALSE);

        vAssertModeText(ppdev, FALSE);

        vAssertModePointer(ppdev, FALSE);

        if (bAssertModeOffscreenHeap(ppdev, FALSE))
        {
            vAssertModeBanking(ppdev, FALSE);

            if (bAssertModeHardware(ppdev, FALSE))
            {
                ppdev->bEnabled = FALSE;

#if TARGET_BUILD > 351
                return(TRUE);
#else
                return;
#endif
            }

            //////////////////////////////////////////////////////////
            // We failed to switch to full-screen.  So undo everything:

            vAssertModeBanking(ppdev, TRUE);

            bAssertModeOffscreenHeap(ppdev, TRUE);  // We don't need to check
        }                                           //   return code with TRUE

        vAssertModePointer(ppdev, TRUE);

        vAssertModeText(ppdev, TRUE);

        vAssertModeBrushCache(ppdev, TRUE);

        vAssertModePalette(ppdev, TRUE);

        vAssertModeDirectDraw(ppdev, TRUE);
    }
    else
    {
        //////////////////////////////////////////////////////////////
        // Enable - Switch back to graphics mode

        // We have to enable every subcomponent in the reverse order
        // in which it was disabled:

#if TARGET_BUILD > 351
        if (!bAssertModeHardware(ppdev, TRUE))
        {
            return FALSE;
        }
#else
        bAssertModeHardware(ppdev, TRUE);
#endif

        vAssertModeBanking(ppdev, TRUE);

	bAssertModeOffscreenHeap(ppdev, TRUE);	// don't need the return

        vAssertModePointer(ppdev, TRUE);

        vAssertModeText(ppdev, TRUE);

        vAssertModeBrushCache(ppdev, TRUE);

        vAssertModePalette(ppdev, TRUE);

        vAssertModeDirectDraw(ppdev, TRUE);

        ppdev->bEnabled = TRUE;

#if TARGET_BUILD > 351
        return TRUE;
#endif

    }

#if TARGET_BUILD > 351
    return FALSE;           // If we get here, we've failed!
#endif
}

/******************************Public*Routine******************************\
* ULONG DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE      hDriver,
ULONG       cjSize,
DEVMODEW*   pdm)
{

    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    cModes = getAvailableModes(hDriver,
                            (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                            &cbModeSize);
    if (cModes == 0)
    {
        DISPDBG((0, "DrvGetModes failed to get mode information"));
        return(0);
    }

    if (pdm == NULL)
    {
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the
        // output buffer
        //

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do
        {
            if (pVideoTemp->Length != 0)
            {
                if (cOutputModes == 0)
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //

                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion = DM_SPECVERSION;
                pdm->dmDriverVersion = DM_SPECVERSION;

                //
                // We currently do not support Extra information in the driver
                //

                pdm->dmDriverExtra = DRIVER_EXTRA_SIZE;

                pdm->dmSize = sizeof(DEVMODEW);
                pdm->dmBitsPerPel = pVideoTemp->NumberOfPlanes *
                                    pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;

#if TARGET_BUILD > 351
                pdm->dmDisplayFlags     = 0;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS     ;
#else
                if (pVideoTemp->AttributeFlags & VIDEO_MODE_INTERLACED)
                {
                    pdm->dmDisplayFlags |= DM_INTERLACED;
                }
#endif
//DISPDBG((0, "pdm: %4li bpp, %4li x %4li, %4li Hz",
//pdm->dmBitsPerPel, pdm->dmPelsWidth, pdm->dmPelsHeight, pdm->dmDisplayFrequency ));

                //
                // Go to the next DEVMODE entry in the buffer.
                //

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((ULONG_PTR)pdm) + sizeof(DEVMODEW) +
                                                   DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

            }

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                (((PUCHAR)pVideoTemp) + cbModeSize);


        } while (--cModes);
    }

    AtiFreeMem(pVideoModeInformation);

    return(cbOutputSize);
}

/******************************Public*Routine******************************\
* BOOL bAssertModeHardware
*
* Sets the appropriate hardware state for graphics mode or full-screen.
*
\**************************************************************************/

BOOL bAssertModeHardware(
PDEV* ppdev,
BOOL  bEnable)
{
    DWORD ReturnedDataLength;
    ULONG ulReturn;

    if (bEnable)
    {
        // Call the miniport via an IOCTL to set the graphics mode.

        if (!AtiDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_SET_CURRENT_MODE,
                             &ppdev->ulMode,  // input buffer
                             sizeof(DWORD),
                             NULL,
                             0,
                             &ReturnedDataLength))
        {
            DISPDBG((0, "bAssertModeHardware - Failed set IOCTL"));
            return(FALSE);
        }

        vResetClipping(ppdev);

        // Set some Mach64 defaults:

        if (ppdev->iMachType == MACH_MM_64)
        {
            BYTE*   pjMmBase;

            pjMmBase = ppdev->pjMmBase;

            M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
            M64_OD(pjMmBase, DP_PIX_WIDTH, ppdev->ulMonoPixelWidth);

            vSetDefaultContext(ppdev);
        }
    }
    else
    {
        // Call the kernel driver to reset the device to a known state.
        // NTVDM will take things from there:

        if (!AtiDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_RESET_DEVICE,
                             NULL,
                             0,
                             NULL,
                             0,
                             &ulReturn))
        {
            DISPDBG((0, "bAssertModeHardware - Failed reset IOCTL"));
            return(FALSE);
        }
    }

    DISPDBG((5, "Passed bAssertModeHardware"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bEnableHardware
*
* Puts the hardware in the requested mode and initializes it.
*
* Note: Should be called before any access is done to the hardware from
*       the display driver.
*
\**************************************************************************/

BOOL bEnableHardware(
PDEV*   ppdev)
{
    BYTE*                       pjIoBase;
    VIDEO_PUBLIC_ACCESS_RANGES  VideoAccessRange[2];
    VIDEO_MEMORY                VideoMemory;
    VIDEO_MEMORY_INFORMATION    VideoMemoryInfo;
    DWORD                       ReturnedDataLength;

    ppdev->pjIoBase  = NULL;
    ppdev->pjMmBase  = NULL;

    // Map io ports into virtual memory:

    if (!AtiDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
                           NULL,                      // input buffer
                           0,
                           VideoAccessRange,          // output buffer
                           sizeof(VideoAccessRange),
                           &ReturnedDataLength))
    {
        DISPDBG((0, "bEnableHardware - Initialization error mapping IO port base"));
        goto ReturnFalse;
    }

    ppdev->pjIoBase     = (UCHAR*) VideoAccessRange[0].VirtualAddress;

    ppdev->pjMmBase_Ext = (BYTE*) VideoAccessRange[1].VirtualAddress;

    // ------------------------- ATI-specific ----------------------------
    // Call the miniport via an IOCTL to set the graphics mode.
    // Because of a hardware quirk, 4 BPP causes the mach64 to alter its
    // video memory size when you do a SET_CURRENT_MODE, so we do it here
    // first so that MAP_VIDEO_MEMORY maps the correct amount of memory.

    if (!AtiDeviceIoControl(ppdev->hDriver,
                            IOCTL_VIDEO_SET_CURRENT_MODE,
                            &ppdev->ulMode,  // input buffer
                            sizeof(DWORD),
                            NULL,
                            0,
                            &ReturnedDataLength))
    {
        DISPDBG((0, "bEnableHardware - Failed set IOCTL"));
        goto ReturnFalse;
    }

    ppdev->pModeInfo = AtiAllocMem( LPTR, FL_ZERO_MEMORY, sizeof (ATI_MODE_INFO) );
    if( ppdev->pModeInfo == NULL )
    {
        DISPDBG((0, "bEnableHardware - Failed memory allocation" ));
        goto ReturnFalse;
    }

    if( !AtiDeviceIoControl( ppdev->hDriver,
                          IOCTL_VIDEO_ATI_GET_MODE_INFORMATION,
                          ppdev->pModeInfo,
                          sizeof (ATI_MODE_INFO),
                          ppdev->pModeInfo,
                          sizeof (ATI_MODE_INFO),
                          &ReturnedDataLength
                          ) )
    {
        DISPDBG((0, "bEnableHardware - Failed to get ATI-specific mode information" ));
        goto ReturnFalse;
    }

    // Get the linear memory address range.

    VideoMemory.RequestedVirtualAddress = NULL;

    if (!AtiDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                           &VideoMemory,      // input buffer
                           sizeof(VIDEO_MEMORY),
                           &VideoMemoryInfo,  // output buffer
                           sizeof(VideoMemoryInfo),
                           &ReturnedDataLength))
    {
        DISPDBG((0, "bEnableHardware - Error mapping buffer address"));
        goto ReturnFalse;
    }

    // Record the Frame Buffer Linear Address.

    ppdev->cjBank       = VideoMemoryInfo.FrameBufferLength;
    // 128K VGA Aperture?
    if (ppdev->cjBank == 0x20000)
        {
        ppdev->cjBank = 0x10000;    // true banksize is 64K
        }

    ppdev->pjScreen     = (BYTE*) VideoMemoryInfo.FrameBufferBase;
    // So we can free it later in vDisableHardware...
    ppdev->VideoRamBase = (BYTE*) VideoMemoryInfo.VideoRamBase;

    if (ppdev->iMachType == MACH_MM_64)
    {
        ppdev->pjMmBase = (BYTE*) VideoMemoryInfo.VideoRamBase
                                + VideoMemoryInfo.FrameBufferLength
                                - 0x400;
    }
    else
    {
        ppdev->pjMmBase = (BYTE*) VideoMemoryInfo.FrameBufferBase;
    }

    pjIoBase = ppdev->pjIoBase;

    // We finally have enough information to calculate the dimensions
    // of on-screen and off-screen memory:

    ppdev->cxMemory = ppdev->lDelta / ppdev->cjPelSize;
    ppdev->cyMemory = VideoMemoryInfo.VideoRamLength / ppdev->lDelta;

    if (VideoMemoryInfo.VideoRamLength <= VideoMemoryInfo.FrameBufferLength)
    {
        ppdev->flCaps |= CAPS_LINEAR_FRAMEBUFFER;
    }

    ppdev->ulTearOffset = (ULONG)(ppdev->pjScreen - ppdev->VideoRamBase);
    ppdev->ulVramOffset = ppdev->ulTearOffset/8;

    if (ppdev->iBitmapFormat != BMF_24BPP)
        ppdev->ulScreenOffsetAndPitch = PACKPAIR(ppdev->ulVramOffset,
                                                 ppdev->cxMemory * 8);
    else
        ppdev->ulScreenOffsetAndPitch = PACKPAIR(ppdev->ulVramOffset,
                                                 (ppdev->cxMemory * 3) * 8);

    // The default pixel width is setup to have monochrome as the
    // host data path pixel width:

    switch (ppdev->iBitmapFormat)
    {
    case BMF_4BPP:  ppdev->ulMonoPixelWidth = 0x00000101; break;
    case BMF_8BPP:  ppdev->ulMonoPixelWidth = 0x00000202; break;
    case BMF_16BPP: ppdev->ulMonoPixelWidth = 0x00000404; break;
    case BMF_24BPP: ppdev->ulMonoPixelWidth = 0x01000202; break;
    case BMF_32BPP: ppdev->ulMonoPixelWidth = 0x00000606; break;
    }

    DISPDBG((1, "RamLength = %lxH, lDelta = %li",
            VideoMemoryInfo.VideoRamLength,
            ppdev->lDelta));

    if ((ppdev->iMachType == MACH_IO_32) || (ppdev->iMachType == MACH_MM_32))
    {
        // The Mach32 and Mach8 can't handle coordinates larger than 1535:

        ppdev->cyMemory = min(ppdev->cyMemory, 1535);
    }

    if (ppdev->iMachType == MACH_MM_32)
    {
        // Can do memory-mapped IO:

        ppdev->pfnFillSolid         = vM32FillSolid;
        ppdev->pfnFillPatColor      = vM32FillPatColor;
        ppdev->pfnFillPatMonochrome = vM32FillPatMonochrome;
        ppdev->pfnXfer1bpp          = vM32Xfer1bpp;
        ppdev->pfnXfer4bpp          = vM32Xfer4bpp;
        ppdev->pfnXfer8bpp          = vM32Xfer8bpp;
        ppdev->pfnXferNative        = vM32XferNative;
        ppdev->pfnCopyBlt           = vM32CopyBlt;
        ppdev->pfnLineToTrivial     = vM32LineToTrivial;
        if (ppdev->iAsic == ASIC_68800AX)   // Timing problem.
            ppdev->pfnTextOut           = bI32TextOut;
        else
            ppdev->pfnTextOut           = bM32TextOut;
        ppdev->pfnStretchDIB        = bM32StretchDIB;
    }
    else if (ppdev->iMachType == MACH_IO_32)
    {
        ppdev->pfnFillSolid         = vI32FillSolid;
        ppdev->pfnFillPatColor      = vI32FillPatColor;
        ppdev->pfnFillPatMonochrome = vI32FillPatMonochrome;
        ppdev->pfnXfer1bpp          = vI32Xfer1bpp;
        ppdev->pfnXfer4bpp          = vI32Xfer4bpp;
        ppdev->pfnXfer8bpp          = vI32Xfer8bpp;
        ppdev->pfnXferNative        = vI32XferNative;
        ppdev->pfnCopyBlt           = vI32CopyBlt;
        ppdev->pfnLineToTrivial     = vI32LineToTrivial;
        ppdev->pfnTextOut           = bI32TextOut;
        ppdev->pfnStretchDIB        = bI32StretchDIB;
    }
    else
    {
        // ppdev->iMachType == MACH_MM_64

        ppdev->pfnFillSolid         = vM64FillSolid;
        ppdev->pfnFillPatColor      = vM64FillPatColor;
        ppdev->pfnFillPatMonochrome = vM64FillPatMonochrome;
        ppdev->pfnXfer1bpp          = vM64Xfer1bpp;
        ppdev->pfnXfer4bpp          = vM64Xfer4bpp;
        ppdev->pfnXfer8bpp          = vM64Xfer8bpp;
        ppdev->pfnXferNative        = vM64XferNative;
        if (!(ppdev->FeatureFlags & EVN_SDRAM_1M))
        {
            ppdev->pfnCopyBlt           = vM64CopyBlt;
        }
        else
        {
            // Special version to fix screen source FIFO bug in VT-A4
            // with 1 MB of SDRAM.
            ppdev->pfnCopyBlt           = vM64CopyBlt_VTA4;
        }
        ppdev->pfnLineToTrivial     = vM64LineToTrivial;
        ppdev->pfnTextOut           = bM64TextOut;
        ppdev->pfnStretchDIB        = bM64StretchDIB;

        if (ppdev->iBitmapFormat == BMF_24BPP)
        {
            ppdev->pfnFillSolid         = vM64FillSolid24;
            ppdev->pfnFillPatColor      = vM64FillPatColor24;
            ppdev->pfnFillPatMonochrome = vM64FillPatMonochrome24;
            ppdev->pfnXferNative        = vM64XferNative24;
            if (!(ppdev->FeatureFlags & EVN_SDRAM_1M))
            {
                ppdev->pfnCopyBlt       = vM64CopyBlt24;
            }
            else
            {
                // Special version to fix screen source FIFO bug in VT-A4
                // with 1 MB of SDRAM.
                ppdev->pfnCopyBlt       = vM64CopyBlt24_VTA4;
            }
            ppdev->pfnLineToTrivial     = vM64LineToTrivial24;
            ppdev->pfnTextOut           = bM64TextOut24;
        }

        vEnableContexts(ppdev);
    }

    if ((ppdev->iAsic != ASIC_38800_1) &&
        ((ppdev->iAperture != APERTURE_NONE)||(ppdev->iMachType == MACH_MM_64)))
    {
        ppdev->pfnGetBits = vGetBits;
        ppdev->pfnPutBits = vPutBits;
    }
    else
    {
        ppdev->pfnGetBits = vI32GetBits;
        ppdev->pfnPutBits = vI32PutBits;
    }

    // Now we can set the mode, unlock the accelerator, and reset the
    // clipping:

    if (!bAssertModeHardware(ppdev, TRUE))
        goto ReturnFalse;

DISPDBG((0, "%li bpp, %li x %li, pjScreen = %lx, cjBank = %lxH, pjMmBase = %lx",
ppdev->cBitsPerPel, ppdev->cxMemory, ppdev->cyMemory, ppdev->pjScreen, ppdev->cjBank, ppdev->pjMmBase));

    DISPDBG((5, "Passed bEnableHardware"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bEnableHardware"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vDisableHardware
*
* Undoes anything done in bEnableHardware.
*
* Note: In an error case, we may call this before bEnableHardware is
*       completely done.
*
\**************************************************************************/

VOID vDisableHardware(
PDEV*   ppdev)
{
    DWORD        ReturnedDataLength;
    VIDEO_MEMORY VideoMemory[2];

    VideoMemory[0].RequestedVirtualAddress = ppdev->VideoRamBase;

    if (!AtiDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                           VideoMemory,
                           sizeof(VIDEO_MEMORY),
                           NULL,
                           0,
                           &ReturnedDataLength))
    {
        DISPDBG((0, "vDisableHardware failed IOCTL_VIDEO_UNMAP_VIDEO"));
    }

    VideoMemory[0].RequestedVirtualAddress = ppdev->pjIoBase;
    VideoMemory[1].RequestedVirtualAddress = ppdev->VideoRamBase;

    if (!AtiDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES,
                           VideoMemory,
                           sizeof(VideoMemory),
                           NULL,
                           0,
                           &ReturnedDataLength))
    {
        DISPDBG((0, "vDisableHardware failed IOCTL_VIDEO_FREE_PUBLIC_ACCESS"));
    }
}

/******************************Public*Routine******************************\
* BOOL bInitializeModeFields
*
* Initializes a bunch of fields in the pdev, devcaps (aka gdiinfo), and
* devinfo based on the requested mode.
*
\**************************************************************************/

BOOL bInitializeModeFields(
PDEV*     ppdev,
GDIINFO*  pgdi,
DEVINFO*  pdi,
DEVMODEW* pdm)
{
    ULONG                   cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer;
    PVIDEO_MODE_INFORMATION pVideoModeSelected;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    BOOL                    bSelectDefault;
    VIDEO_MODE_INFORMATION  VideoModeInformation;
    ULONG                   cbModeSize;

    // Call the miniport to get mode information

    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);
    if (cModes == 0)
        goto ReturnFalse;

    // Now see if the requested mode has a match in that table.

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    if ((pdm->dmPelsWidth        == 0) &&
        (pdm->dmPelsHeight       == 0) &&
        (pdm->dmBitsPerPel       == 0) &&
        (pdm->dmDisplayFrequency == 0))
    {
        DISPDBG((1, "Default mode requested"));
        bSelectDefault = TRUE;
    }
    else
    {
        DISPDBG((1, "Requested mode..."));
        DISPDBG((1, "   Screen width  -- %li", pdm->dmPelsWidth));
        DISPDBG((1, "   Screen height -- %li", pdm->dmPelsHeight));
        DISPDBG((1, "   Bits per pel  -- %li", pdm->dmBitsPerPel));
        DISPDBG((1, "   Frequency     -- %li", pdm->dmDisplayFrequency));

        bSelectDefault = FALSE;
    }

    while (cModes--)
    {
        if (pVideoTemp->Length != 0)
        {
            DISPDBG((8, "   Checking against miniport mode:"));
            DISPDBG((8, "      Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((8, "      Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((8, "      Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                                                      pVideoTemp->NumberOfPlanes));
            DISPDBG((8, "      Frequency     -- %li", pVideoTemp->Frequency));

            if (bSelectDefault ||
                ((pVideoTemp->VisScreenWidth  == pdm->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pdm->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                  pVideoTemp->NumberOfPlanes  == pdm->dmBitsPerPel) &&
                 (pVideoTemp->Frequency       == pdm->dmDisplayFrequency)))
            {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((1, "...Found a mode match!"));
                break;
            }
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);

    }

    // If no mode has been found, return an error

    if (pVideoModeSelected == NULL)
    {
        DISPDBG((1, "...Couldn't find a mode match!"));
        AtiFreeMem(pVideoBuffer);
        goto ReturnFalse;
    }

    // Punt all rev 3 VLB cards in 8bpp to the 8514/A driver.
    // Timing problems on "MIO" cards are impossible to deal with.
    // They only show up on 5% of all mach32 cards.
    if ((ppdev->FeatureFlags & EVN_MIO_BUG) && pVideoModeSelected->BitsPerPlane == 8)
    {
        AtiFreeMem(pVideoBuffer);
        goto ReturnFalse;
    }

    // We won't support 24bpp without a linear frame buffer.
    if (pVideoModeSelected->BitsPerPlane == 24 && ppdev->iAperture != APERTURE_FULL)
    {
        AtiFreeMem(pVideoBuffer);
        goto ReturnFalse;
    }

    // We have chosen the one we want.  Save it in a stack buffer and
    // get rid of allocated memory before we forget to free it.

    VideoModeInformation = *pVideoModeSelected;
    AtiFreeMem(pVideoBuffer);

    #if DEBUG_HEAP
        VideoModeInformation.VisScreenWidth  = 640;
        VideoModeInformation.VisScreenHeight = 480;
    #endif

    // Set up screen information from the mini-port:

    ppdev->ulMode           = VideoModeInformation.ModeIndex;
    ppdev->cxScreen         = VideoModeInformation.VisScreenWidth;
    ppdev->cyScreen         = VideoModeInformation.VisScreenHeight;
    ppdev->lDelta           = VideoModeInformation.ScreenStride;
    ppdev->cBitsPerPel      = VideoModeInformation.BitsPerPlane;

    DISPDBG((1, "ScreenStride: %lx", VideoModeInformation.ScreenStride));

    ppdev->flHooks          = (HOOK_BITBLT     |
                               HOOK_TEXTOUT    |
                               HOOK_FILLPATH   |
                               HOOK_COPYBITS   |
                               HOOK_STROKEPATH |
                               HOOK_STRETCHBLT |
                               #if TARGET_BUILD > 351
                               HOOK_LINETO     |
                               #endif
                               HOOK_PAINT);

    // Fill in the GDIINFO data structure with the default 8bpp values:

    *pgdi = ggdiDefault;

    // Now overwrite the defaults with the relevant information returned
    // from the kernel driver:

    pgdi->ulHorzSize        = VideoModeInformation.XMillimeter;
    pgdi->ulVertSize        = VideoModeInformation.YMillimeter;

    pgdi->ulHorzRes         = VideoModeInformation.VisScreenWidth;
    pgdi->ulVertRes         = VideoModeInformation.VisScreenHeight;
#if TARGET_BUILD > 351
    pgdi->ulPanningHorzRes  = VideoModeInformation.VisScreenWidth;
    pgdi->ulPanningVertRes  = VideoModeInformation.VisScreenHeight;
#else
    pgdi->ulDesktopHorzRes  = VideoModeInformation.VisScreenWidth;
    pgdi->ulDesktopVertRes  = VideoModeInformation.VisScreenHeight;
#endif

    pgdi->cBitsPixel        = VideoModeInformation.BitsPerPlane;
    pgdi->cPlanes           = VideoModeInformation.NumberOfPlanes;
    pgdi->ulVRefresh        = VideoModeInformation.Frequency;

    pgdi->ulDACRed          = VideoModeInformation.NumberRedBits;
    pgdi->ulDACGreen        = VideoModeInformation.NumberGreenBits;
    pgdi->ulDACBlue         = VideoModeInformation.NumberBlueBits;

    pgdi->ulLogPixelsX      = pdm->dmLogPixels;
    pgdi->ulLogPixelsY      = pdm->dmLogPixels;

    // Fill in the devinfo structure with the default 8bpp values:

    *pdi = gdevinfoDefault;

    if (VideoModeInformation.BitsPerPlane == 8)
    {
        ppdev->cPelSize        = 0;
        ppdev->cjPelSize       = 1;
        ppdev->iBitmapFormat   = BMF_8BPP;
        ppdev->ulWhite         = 0xff;

        // Assuming palette is orthogonal - all colors are same size.

        ppdev->cPaletteShift   = 8 - pgdi->ulDACRed;
        DISPDBG((3, "palette shift = %d\n", ppdev->cPaletteShift));
    }
    else if ((VideoModeInformation.BitsPerPlane == 16) ||
             (VideoModeInformation.BitsPerPlane == 15))
    {
        ppdev->cPelSize        = 1;
        ppdev->cjPelSize       = 2;
        ppdev->iBitmapFormat   = BMF_16BPP;
        ppdev->ulWhite         = 0xffff;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_16BPP;

        pdi->iDitherFormat     = BMF_16BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    }
    else if (VideoModeInformation.BitsPerPlane == 24)
    {
        ppdev->cPelSize        = 0;     // not used?!
        ppdev->cjPelSize       = 3;
        ppdev->iBitmapFormat   = BMF_24BPP;
        ppdev->ulWhite         = 0xffffff;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_24BPP;

        pdi->iDitherFormat     = BMF_24BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    }
    else
    {
        ASSERTDD(VideoModeInformation.BitsPerPlane == 32,
                 "This driver supports only 8, 16, 24 and 32bpp");

        ppdev->cPelSize        = 2;
        ppdev->cjPelSize       = 4;
        ppdev->iBitmapFormat   = BMF_32BPP;
        ppdev->ulWhite         = 0xffffffff;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_32BPP;

        pdi->iDitherFormat     = BMF_32BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    }

    DISPDBG((5, "Passed bInitializeModeFields"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializeModeFields"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* DWORD getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

DWORD getAvailableModes(
HANDLE                   hDriver,
PVIDEO_MODE_INFORMATION* modeInformation,       // Must be freed by caller
DWORD*                   cbModeSize)
{
    ULONG                   ulTemp;
    VIDEO_NUM_MODES         modes;
    PVIDEO_MODE_INFORMATION pVideoTemp;

    //
    // Get the number of modes supported by the mini-port
    //

    if (!AtiDeviceIoControl(hDriver,
                           IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
                           NULL,
                           0,
                           &modes,
                           sizeof(VIDEO_NUM_MODES),
                           &ulTemp))
    {
        DISPDBG((0, "getAvailableModes - Failed VIDEO_QUERY_NUM_AVAIL_MODES"));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //

    *modeInformation = AtiAllocMem(LPTR, FL_ZERO_MEMORY,
                                   modes.NumModes * modes.ModeInformationLength
                                   );

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((0, "getAvailableModes - Failed AtiAllocMem"));
        return 0;
    }

    //
    // Ask the mini-port to fill in the available modes.
    //

    if (!AtiDeviceIoControl(hDriver,
                           IOCTL_VIDEO_QUERY_AVAIL_MODES,
                           NULL,
                           0,
                           *modeInformation,
                           modes.NumModes * modes.ModeInformationLength,
                           &ulTemp))
    {

        DISPDBG((0, "getAvailableModes - Failed VIDEO_QUERY_AVAIL_MODES"));

        AtiFreeMem(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }

    //
    // Now see which of these modes are supported by the display driver.
    // As an internal mechanism, set the length to 0 for the modes we
    // DO NOT support.
    //

    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    //
    // Mode is rejected if it is not one plane, or not graphics, or is not
    // one of 8, 15, 16, 24 or 32 bits per pel.
    //

    while (ulTemp--)
    {
//DISPDBG((0, "pVideoTemp: %4li bpp, %4li x %4li, %4li Hz",
//pVideoTemp->BitsPerPlane * pVideoTemp->NumberOfPlanes,
//pVideoTemp->VisScreenWidth, pVideoTemp->VisScreenHeight,
//pVideoTemp->Frequency ));

        if ((pVideoTemp->NumberOfPlanes != 1 ) ||
            !(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
            ((pVideoTemp->BitsPerPlane != 8) &&
             (pVideoTemp->BitsPerPlane != 15) &&
             (pVideoTemp->BitsPerPlane != 16) &&
             (pVideoTemp->BitsPerPlane != 24) &&
             (pVideoTemp->BitsPerPlane != 32)))
        {
            DISPDBG((2, "Rejecting miniport mode:"));
            DISPDBG((2, "   Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((2, "   Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((2, "   Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                                                   pVideoTemp->NumberOfPlanes));
            DISPDBG((2, "   Frequency     -- %li", pVideoTemp->Frequency));

            pVideoTemp->Length = 0;
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    return(modes.NumModes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\escape.c ===
/************************************************************************/
/*                                                                      */
/*                              ESCAPE.C                                */
/*                                                                      */
/*  Copyright (c) 1994, 1995 ATI Technologies Incorporated.             */
/************************************************************************/


#include "precomp.h"

#if (TARGET_BUILD == 351)
    /*
     * DCI support requires the use of structures and defined values
     * found in a header file that is only present in versions of
     * the DDK that support DCI, rather than having these items
     * in a DCI section of one of the standard header files. For this
     * reason, we can't do conditional compilation based on whether
     * the DCI-specific values are defined, because our first indication
     * would be an error due to the header file not being found.
     *
     * Explicit DCI support is only needed when building for NT 3.51,
     * since it was added for this version, but for version 4.0 (next
     * version) and above it is incorporated into Direct Draw rather
     * than being handled separately.
     */
#include <dciddi.h>
#include "dci.h"
#endif



/**************************************************************************
 *
 * ULONG DrvEscape(pso, iEsc, cjIn, pvIn, cjOut, pvOut);
 *
 * SURFOBJ *pso;    Surface that the call is directed to
 * ULONG iEsc;      Specifies the particular function to be performed.
 *                  Currently, only the following are supported:
 *                  QUERYESCSUPPORT:
 *                      Determine if a function is supported
 *                  ESC_SET_POWER_MANAGEMENT:
 *                      Set the DPMS state
 *                  DCICOMMAND:
 *                      Command to allow apps direct access to video memory
 * ULONG cjIn;      Size, in bytes, of the buffer pointed to by pvIn
 * PVOID pvIn;      Input data for the call. Format depends on function
 *                  specified by iEsc
 * ULONG cjOut;     Size, in bytes, of the buffer pointed to by pvOut
 * PVOID pvOut;     Output buffer for the call. Format depends on function
 *                  specified by iEsc
 *
 * DESCRIPTION:
 *  Entry point for driver-defined functions.
 *
 * RETURN VALUE:
 *  ESC_IS_SUPPORTED    if successful
 *  ESC_NOT_IMPLEMENTED if QUERYESCSUPPORT called for unimplemented function
 *  ESC_NOT_SUPPORTED   if unimplemented function requested
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  This is an entry point
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

ULONG DrvEscape (SURFOBJ *pso,
                ULONG iEsc,
                ULONG cjIn,
                PVOID pvIn,
                ULONG cjOut,
                PVOID pvOut)
{
    ULONG RetVal;                       /* Value to be returned */
    PDEV *ppdev;                        /* Pointer to video PDEV */
    DWORD dwRet;                        /* Output bytes from DeviceIoControl() */
    VIDEO_POWER_MANAGEMENT DpmsData;    /* Structure used in DeviceIoControl() call */
#if (TARGET_BUILD == 351)
    DCICMD *pDciCmd;
#endif


    DISPDBG((DEBUG_ENTRY_EXIT, "--> DrvEscape"));

	RetVal = ESC_NOT_SUPPORTED;

    /*
     * Get the PDEV for the video card (used for calling IOCTLs).
     */
    ppdev = (PDEV *) pso->dhpdev;

    /*
     * Handle each case depending on which escape function was requested.
     */
    switch (iEsc)
        {
        /*
         * Check whether a given function is supported.
         */
        case  QUERYESCSUPPORT:
            /*
             * When querying escape support, the function in question
             * is passed in the ULONG passed in pvIn.
             */
            if(!pvIn)
                RetVal = ESC_NOT_IMPLEMENTED;
                break;

            switch (*(PULONG)pvIn)
                {
                case QUERYESCSUPPORT:
                    DISPDBG((DEBUG_DETAIL, "Querying QUERYESCSUPPORT"));
                    RetVal = ESC_IS_SUPPORTED;
                    break;

                case ESC_SET_POWER_MANAGEMENT:
                    DISPDBG((DEBUG_DETAIL, "Querying ESC_SET_POWER_MANAGEMENT"));
                    RetVal = ESC_IS_SUPPORTED;
                    break;

#if (TARGET_BUILD == 351)
                case DCICOMMAND:
                    DISPDBG((DEBUG_DETAIL, "Querying DCICOMMAND"));
                    RetVal = ESC_IS_SUPPORTED;
                    break;
#endif

#if   PAL_SUPPORT

    case     ESC_INIT_PAL_SUPPORT:
            {
            DWORD value;
            // the first time ATIPlayer is calling us
            DISPDBG( (DEBUG_ESC,"PAL:  ESC_INIT_PAL_SUPPORT " ));
            RetVal= DeallocOffscreenMem(ppdev) ;
            ppdev->pal_str.Palindrome_flag=FALSE;

            //init the VT regs in block 1 (BUS_CNTL)
                    MemR32(0x28,&value);
                    value=value|0x08000000;
                    MemW32(0x28,value);
            
            // initialize some overlay/scaler regs on RAGEIII
            if (ppdev->iAsic>=CI_M64_GTC_UMC)
                {
                 WriteVTReg(0x54, 0x101000);                //DD_SCALER_COLOUR_CNTL
                 WriteVTReg(0x55, 0x2000);                      //DD_SCALER_H_COEFF0
                 WriteVTReg(0x56, 0x0D06200D);              //DD_SCALER_H_COEFF1
                 WriteVTReg(0x57, 0x0D0A1C0D);              //DD_SCALER_H_COEFF2
                 WriteVTReg(0x58, 0x0C0E1A0C);              //DD_SCALER_H_COEFF3
                 WriteVTReg(0x59, 0x0C14140C);              //DD_SCALER_H_COEFF4
                }

            // problems with ACCESS DEVICE due to inconcistencies in Palindrome (Due to the fact that Palindrome is inconsistent in
            // using the same pointer to ACCESSDEVICE struct for QUERY, ALLOC and FREE) :
            (ppdev->pal_str.lpOwnerAccessStructConnector)=NULL;  // no owner at this time
            (ppdev->pal_str.lpOwnerAccessStructOverlay)=NULL;     // no owner at this time
            if(ppdev->semph_overlay==2)        //  = 0  resource free;     = 1  in use by DDraw;    = 2  in use by Palindrome;
                {
                ppdev->semph_overlay=0;
                }
            }
            break;

       //Functions for CWDDE support
        //Display mode group
    case    Control_DisplaymodeIsSupported:
            DISPDBG( (DEBUG_ESC,"PAL: Control_DisplaymodeIsSupported " ));
            RetVal=1;
            break;
    case    Control_DisplaymodeIsEnabled:
            DISPDBG( (DEBUG_ESC,"PAL: Control_DisplaymodeIsEnabled " ));
            RetVal=1;
            break;
    case    Control_GetDisplaymode:
            DISPDBG( (DEBUG_ESC," PAL: Control_GetDisplaymode" ));
            RetVal=GetDisplayMode(ppdev,pvOut)  ;
            break;
        //End display mode group


        // DCI control group
    case    Control_DCIIsSupported:
                DISPDBG( (DEBUG_ESC,"PAL: Control_DCIIsSupported " ));
                RetVal=1;
                break;
    case    Control_DCIIsEnabled:
                DISPDBG( (DEBUG_ESC,"PAL: Control_DCIIsEnabled " ));
                if(ppdev->pal_str.Flag_DCIIsEnabled)
                    RetVal=1;
                else
                    RetVal=0;
                break;
    case    Control_DCIEnable:
                DISPDBG( (DEBUG_ESC," PAL: Control_DCIEnable" ));
                // this flag will be also used for activation of the mode switch detection code
                // this function will be called in the case of mode switch
                ppdev->pal_str.CallBackFnct=(PVOID)pvIn;
                ppdev->pal_str.pData=(PVOID)pvOut;

                ppdev->pal_str.Flag_DCIIsEnabled=TRUE;
                ppdev->pal_str.Counter_DCIIsEnabled++;
                RetVal=1;
                break;
    case    Control_DCIDisable:
                DISPDBG( (DEBUG_ESC," PAL: Control_DCIDisable " ));
                if(ppdev->pal_str.Counter_DCIIsEnabled>0)
                    if(--ppdev->pal_str.Counter_DCIIsEnabled==0)
                            ppdev->pal_str.Flag_DCIIsEnabled=FALSE;
                RetVal=1;
                break;
    case    Control_DCIAccessDevice:
                DISPDBG( (DEBUG_ESC,"PAL: Control_DCIAccessDevice " ));
                RetVal=AccessDevice(ppdev,pvIn, pvOut);
                DISPDBG( (DEBUG_ESC,"PAL: EXIT Control_DCIAccessDevice " ));
                break;

    case    Control_DCIVideoCapture:
               DISPDBG( (DEBUG_ESC_2,"PAL: Control_DCIVideoCapture " ));
               RetVal=VideoCaptureFnct(ppdev,pvIn, pvOut);
               break;
    case    Control_ConfigIsSupported:
                DISPDBG( (DEBUG_ESC,"PAL:  Control_ConfigIsSupported" ));
                RetVal=1;
                break;
    case    Control_ConfigIsEnabled:
                DISPDBG( (DEBUG_ESC,"PAL:Control_ConfigIsEnabled " ));
                if(ppdev->pal_str.Flag_Control_ConfigIsEnabled)
                    RetVal=1;
                else
                    RetVal=0;
                break;
                //end of DCI feature group

         // Configuration Group
    case    Control_GetConfiguration:
                DISPDBG( (DEBUG_ESC,"PAL: Control_GetConfiguration " ));
                RetVal=GetConfiguration(ppdev,pvOut);
                break; //end GetConfiguration


       //Functions for direct palindrome support
    case    ESC_WRITE_REG:
                DISPDBG( (DEBUG_ESC," PAL: ESC_WRITE_REG" ));
                RetVal=WriteRegFnct(ppdev,pvIn);
                break;

    case    ESC_READ_REG:
                DISPDBG( (DEBUG_ESC,"PAL: ESC_READ_REG " ));
                RetVal=ReadRegFnct(ppdev,pvIn, pvOut);
                break;

    case    ESC_I2C_ACCESS:
                DISPDBG( (DEBUG_ESC,"PAL:ESC_I2C_ACCESS " ));
                I2CAccess_New(ppdev,(LPI2CSTRUCT_NEW)pvIn,(LPI2CSTRUCT_NEW)pvOut);
                RetVal=ESC_IS_SUPPORTED;
                break;

    case    ESC_ALLOC_OFFSCREEN:
                // this call is palindrome specific and it is seldomly used
                if(ppdev->pal_str.Palindrome_flag==FALSE)
                    {
                    ppdev->pal_str.Palindrome_flag=TRUE;
                    ppdev->pal_str.no_lines_allocated=0;      // number of lines already allocated by "alloc mem" in offscreen mem
                   //flags for palindrome
                   ppdev->pal_str.dos_flag=FALSE;
                   ppdev->pal_str.Realloc_mem_flag=FALSE;
                   ppdev->pal_str.Mode_Switch_flag=FALSE;
                   ppdev->pal_str.No_mem_allocated_flag=FALSE;
                   ppdev->pal_str.preg=NULL;
                    }
                 DISPDBG( (DEBUG_ESC,"PAL:ESC_ALLOC_OFFSCREEN " ));
                 RetVal=AllocOffscreenMem(ppdev, pvIn, pvOut);
                 break;

    case    ESC_DEALLOC_OFFSCREEN:
                    DISPDBG( (DEBUG_ESC,"PAL:  ESC_DEALLOC_OFFSCREEN " ));
                    RetVal= DeallocOffscreenMem(ppdev) ;
                    ppdev->pal_str.Palindrome_flag=FALSE;
                    break;

    // end escapes for palindrome support
#endif      //  PALINDROME_SUPPORT



                default:
                    DISPDBG((DEBUG_ERROR, "Querying unimplemented function"));
                    RetVal = ESC_NOT_IMPLEMENTED;
                    break;
                }
            break;


        /*
         * Switch into the specified DPMS state.
         */
        case ESC_SET_POWER_MANAGEMENT:
            DISPDBG((DEBUG_DETAIL, "Function ESC_SET_POWER_MANAGEMENT"));

            /*
             * The desired power management state is passed
             * in the ULONG passed in pvIn.
             */
            if(!pvIn)
                RetVal = ESC_NOT_IMPLEMENTED;
                break;

            switch (*(PULONG)pvIn)
                {
                case VideoPowerOn:
                    DISPDBG((DEBUG_DETAIL, "State selected = ON"));
                    RetVal = ESC_IS_SUPPORTED;
                    break;

                case VideoPowerStandBy:
                    DISPDBG((DEBUG_DETAIL, "State selected = STAND-BY"));
                    RetVal = ESC_IS_SUPPORTED;
                    break;

                case VideoPowerSuspend:
                    DISPDBG((DEBUG_DETAIL, "State selected = SUSPEND"));
                    RetVal = ESC_IS_SUPPORTED;
                    break;

                case VideoPowerOff:
                    DISPDBG((DEBUG_DETAIL, "State selected = OFF"));
                    RetVal = ESC_IS_SUPPORTED;
                    break;

                default:
                    DISPDBG((DEBUG_ERROR, "Invalid state selected"));
                    RetVal = ESC_NOT_SUPPORTED;
                    break;
                }

            DpmsData.Length = sizeof(struct _VIDEO_POWER_MANAGEMENT);
            DpmsData.DPMSVersion = 0;   /* Not used for "set" packet */
            DpmsData.PowerState = *(PULONG)pvIn;

            /*
             * Tell the miniport to set the DPMS mode. If the miniport
             * either doesn't support this packet, or reports that the
             * video card doesn't, tell the calling application that
             * we failed.
             */
            if (AtiDeviceIoControl( ppdev->hDriver,
                                 IOCTL_VIDEO_SET_POWER_MANAGEMENT,
                                 &DpmsData,
                                 sizeof (struct _VIDEO_POWER_MANAGEMENT),
                                 NULL,
                                 0,
                                 &dwRet) == FALSE)
                {
                DISPDBG((DEBUG_ERROR, "Unable to set desired state"));
                RetVal = ESC_NOT_SUPPORTED;
                }

            break;

#if (TARGET_BUILD == 351)
        case DCICOMMAND:
            pDciCmd = (DCICMD*) pvIn;

            if ((cjIn < sizeof(DCICMD)) || (pDciCmd->dwVersion != DCI_VERSION))
                {
                RetVal = (ULONG)DCI_FAIL_UNSUPPORTED;
                }
            else
                {
                switch(pDciCmd->dwCommand)
                    {
                    case DCICREATEPRIMARYSURFACE:
                        RetVal = DCICreatePrimarySurface(ppdev, cjIn, pvIn, cjOut, pvOut);
                        break;

                    default:
                        RetVal = (ULONG)DCI_FAIL_UNSUPPORTED;
                        break;
                    }
                }
            break;
#endif

        /*
         * Unimplemented function requested.
         */
        default:
            DISPDBG((DEBUG_ERROR, "Unimplemented function requested"));
            RetVal = ESC_NOT_SUPPORTED;
            break;

        }

    DISPDBG((DEBUG_ENTRY_EXIT, "<-- DrvEscape"));
    return RetVal;

}   /* DrvEscape() */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\heap.c ===
/******************************Module*Header*******************************\
* Module Name: heap.c
*
* This module contains the routines for a 2-d heap.  It is used primarily
* for allocating space for device-format-bitmaps in off-screen memory.
*
* Off-screen bitmaps are a big deal on NT because:
*
*    1) It reduces the working set.  Any bitmap stored in off-screen
*       memory is a bitmap that isn't taking up space in main memory.
*
*    2) There is a speed win by using the accelerator hardware for
*       drawing, in place of NT's GDI code.  NT's GDI is written entirely
*       in 'C++' and perhaps isn't as fast as it could be.
*
*    3) It leads naturally to nifty tricks that can take advantage of
*       the hardware, such as MaskBlt support and cheap double buffering
*       for OpenGL.
*
* The heap algorithm employed herein attempts to solve an unsolvable
* problem: the problem of keeping arbitrary sized bitmaps as packed as
* possible in a 2-d space, when the bitmaps can come and go at random.
*
* This problem is due entirely to the nature of the hardware for which this
* driver is written: the hardware treats everything as 2-d quantities.  If
* the hardware bitmap pitch could be changed so that the bitmaps could be
* packed linearly in memory, the problem would be infinitely easier (it is
* much easier to track the memory, and the accelerator can be used to re-pack
* the heap to avoid segmentation).
*
* If your hardware can treat bitmaps as one dimensional quantities (as can
* the XGA and ATI), by all means please implement a new off-screen heap.
*
* When the heap gets full, old allocations will automatically be punted
* from off-screen and copied to DIBs, which we'll let GDI draw on.
*
* Note that this heap manages reverse-L shape off-screen memory
* configurations (where the scan pitch is longer than the visible screen,
* such as happens at 800x600 when the scan length must be a multiple of
* 1024).
*
* NOTE: All heap operations must be done under some sort of synchronization,
*       whether it's controlled by GDI or explicitly by the driver.  All
*       the routines in this module assume that they have exclusive access
*       to the heap data structures; multiple threads partying in here at
*       the same time would be a Bad Thing.  (By default, GDI does NOT
*       synchronize drawing on device-created bitmaps.)
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#define OH_ALLOC_SIZE   4000        // Do all memory allocations in 4k chunks
#define OH_QUANTUM      4           // The minimum dimension of an allocation
#define CXCY_SENTINEL   0x7fffffff  // The sentinel at the end of the available
                                    //  list has this very large 'cxcy' value

// This macro results in the available list being maintained with a
// cx-major, cy-minor sort:

#define CXCY(cx, cy) (((cx) << 16) | (cy))

/******************************Public*Routine******************************\
* OH* pohNewNode
*
* Allocates a basic memory unit in which we'll pack our data structures.
*
* Since we'll have a lot of OH nodes, most of which we will be
* occasionally traversing, we do our own memory allocation scheme to
* keep them densely packed in memory.
*
* It would be the worst possible thing for the working set to simply
* call AtiAllocMem(sizeof(OH)) every time we needed a new node.  There
* would be no locality; OH nodes would get scattered throughout memory,
* and as we traversed the available list for one of our allocations,
* it would be far more likely that we would hit a hard page fault.
\**************************************************************************/

OH* pohNewNode(
PDEV*   ppdev)
{
    LONG     i;
    LONG     cOhs;
    OHALLOC* poha;
    OH*      poh;

    if (ppdev->heap.pohFreeList == NULL)
    {
        // We zero-init to initialize all the OH flags, and to help in
        // debugging (we can afford to do this since we'll be doing this
        // very infrequently):

        poha = AtiAllocMem(LPTR, FL_ZERO_MEMORY, OH_ALLOC_SIZE);
        if (poha == NULL)
            return(NULL);

        // Insert this OHALLOC at the begining of the OHALLOC chain:

        poha->pohaNext  = ppdev->heap.pohaChain;
        ppdev->heap.pohaChain = poha;

        // This has a '+ 1' because OHALLOC includes an extra OH in its
        // structure declaration:

        cOhs = (OH_ALLOC_SIZE - sizeof(OHALLOC)) / sizeof(OH) + 1;

        // The big OHALLOC allocation is simply a container for a bunch of
        // OH data structures in an array.  The new OH data structures are
        // linked together and added to the OH free list:

        poh = &poha->aoh[0];
        for (i = cOhs - 1; i != 0; i--)
        {
            poh->pohNext = poh + 1;
            poh          = poh + 1;
        }

        poh->pohNext      = NULL;
        ppdev->heap.pohFreeList = &poha->aoh[0];
    }

    poh = ppdev->heap.pohFreeList;
    ppdev->heap.pohFreeList = poh->pohNext;

    return(poh);
}

/******************************Public*Routine******************************\
* VOID vOhFreeNode
*
* Frees our basic data structure allocation unit by adding it to a free
* list.
*
\**************************************************************************/

VOID vOhFreeNode(
PDEV*   ppdev,
OH*     poh)
{
    if (poh == NULL)
        return;

    poh->pohNext            = ppdev->heap.pohFreeList;
    ppdev->heap.pohFreeList = poh;
    poh->ohState            = -1;
}

/******************************Public*Routine******************************\
* VOID vCalculateMaximumNonPermanent
*
* Traverses the list of in-use and available rectangles to find the one
* with the maximal area.
*
\**************************************************************************/

VOID vCalculateMaximumNonPermanent(
PDEV*   ppdev)
{
    OH*     poh;
    OH*     pohSentinel;
    LONG    lArea;
    LONG    lMaxArea;
    LONG    cxMax;
    LONG    cyMax;
    LONG    i;

    lMaxArea = 0;
    cxMax    = 0;
    cyMax    = 0;

    // First time through, loop through the list of free available
    // rectangles:

    pohSentinel = &ppdev->heap.ohFree;

    for (i = 2; i != 0; i--)
    {
        for (poh = pohSentinel->pohNext; poh != pohSentinel; poh = poh->pohNext)
        {
            ASSERTDD(poh->ohState != OH_PERMANENT,
                     "Permanent node in free or discardable list");

            // We don't have worry about this multiply overflowing
            // because we are dealing in physical screen coordinates,
            // which will probably never be more than 15 bits:

            lArea = poh->cx * poh->cy;
            if (lArea > lMaxArea)
            {
                cxMax    = poh->cx;
                cyMax    = poh->cy;
                lMaxArea = lArea;
            }
        }

        // Second time through, loop through the list of discardable
        // rectangles:

        pohSentinel = &ppdev->heap.ohDiscardable;
    }

    // All that we are interested in is the dimensions of the rectangle
    // that has the largest possible available area (and remember that
    // there might not be any possible available area):

    ppdev->heap.cxMax = cxMax;
    ppdev->heap.cyMax = cyMax;
}

/******************************Public*Routine******************************\
* OH* pohFree
*
* Frees an off-screen heap allocation.  The free space will be combined
* with any adjacent free spaces to avoid segmentation of the 2-d heap.
*
* Note: A key idea here is that the data structure for the upper-left-
*       most node must be kept at the same physical CPU memory so that
*       adjacency links are kept correctly (when two free spaces are
*       merged, the lower or right node can be freed).
*
\**************************************************************************/

OH* pohFree(
PDEV*   ppdev,
OH*     poh)
{
    ULONG   cxcy;
    OH*     pohBeside;
    OH*     pohNext;
    OH*     pohPrev;
    OHSTATE oldState;

    if (poh == NULL)
        return(NULL);

    DISPDBG((15, "Freeing %li x %li at (%li, %li)",
            poh->cx, poh->cy, poh->x, poh->y));

    #if DEBUG_HEAP
    {
        RECTL           rclBitmap;
        RBRUSH_COLOR    rbc;
        LONG            xOffset;
        LONG            yOffset;

        rclBitmap.left   = poh->x;
        rclBitmap.top    = poh->y;
        rclBitmap.right  = poh->x + poh->cx;
        rclBitmap.bottom = poh->y + poh->cy;

        xOffset = ppdev->xOffset;
        yOffset = ppdev->yOffset;

        ppdev->xOffset = 0;
        ppdev->yOffset = 0;

        ppdev->pfnFillSolid(ppdev, 1, &rclBitmap, LOGICAL_0, rbc,
                            NULL);

        ppdev->xOffset = xOffset;
        ppdev->yOffset = yOffset;
    }
    #endif

    oldState = poh->ohState;
    if (oldState != OH_DISCARDABLE)
    {
        // We can remove the 'reserved' status unless we are merely
        // deleting a discardable rectangle that was temporarily
        // placed in a reserve rectangle:

        poh->cxReserved = 0;
        poh->cyReserved = 0;
    }

    // Update the uniqueness to show that space has been freed, so that
    // we may decide to see if some DIBs can be moved back into off-screen
    // memory:

    ppdev->iHeapUniq++;

MergeLoop:

    // Try merging with the right sibling:

    pohBeside = poh->pohRight;
    if ((poh->cxReserved    != poh->cx)         &&
        (pohBeside->ohState == OH_FREE)         &&
        (pohBeside->cy      == poh->cy)         &&
        (pohBeside->pohUp   == poh->pohUp)      &&
        (pohBeside->pohDown == poh->pohDown)    &&
        (pohBeside->pohRight->pohLeft != pohBeside))
    {
        // Add the right rectangle to ours:

        poh->cx      += pohBeside->cx;
        poh->pohRight = pohBeside->pohRight;

        // Remove 'pohBeside' from the free list and free it:

        pohBeside->pohNext->pohPrev = pohBeside->pohPrev;
        pohBeside->pohPrev->pohNext = pohBeside->pohNext;

        vOhFreeNode(ppdev, pohBeside);
        goto MergeLoop;
    }

    // Try merging with the lower sibling:

    pohBeside = poh->pohDown;
    if ((poh->cyReserved     != poh->cy)        &&
        (pohBeside->ohState  == OH_FREE)        &&
        (pohBeside->cx       == poh->cx)        &&
        (pohBeside->pohLeft  == poh->pohLeft)   &&
        (pohBeside->pohRight == poh->pohRight)  &&
        (pohBeside->pohDown->pohUp != pohBeside))
    {
        poh->cy     += pohBeside->cy;
        poh->pohDown = pohBeside->pohDown;

        pohBeside->pohNext->pohPrev = pohBeside->pohPrev;
        pohBeside->pohPrev->pohNext = pohBeside->pohNext;

        vOhFreeNode(ppdev, pohBeside);
        goto MergeLoop;
    }

    // Don't do any more merge this rectangle into anything to the
    // top or to the left if it's reserved:

    if (!poh->cxReserved)
    {
        // Try merging with the left sibling:

        pohBeside = poh->pohLeft;
        if ((pohBeside->cxReserved != pohBeside->cx) &&
            (pohBeside->ohState    == OH_FREE)       &&
            (pohBeside->cy         == poh->cy)       &&
            (pohBeside->pohUp      == poh->pohUp)    &&
            (pohBeside->pohDown    == poh->pohDown)  &&
            (pohBeside->pohRight   == poh)           &&
            (poh->pohRight->pohLeft != poh))
        {
            // We add our rectangle to the one to the left:

            pohBeside->cx      += poh->cx;
            pohBeside->pohRight = poh->pohRight;

            // Remove 'poh' from whatever list it was in (if we were
            // asked to free a 'permanent' node, it will have been in
            // the permanent list) and free it:

            poh->pohNext->pohPrev = poh->pohPrev;
            poh->pohPrev->pohNext = poh->pohNext;

            vOhFreeNode(ppdev, poh);

            poh = pohBeside;
            goto MergeLoop;
        }

        // Try merging with the upper sibling:

        pohBeside = poh->pohUp;
        if ((pohBeside->cyReserved != pohBeside->cy) &&
            (pohBeside->ohState    == OH_FREE)       &&
            (pohBeside->cx         == poh->cx)       &&
            (pohBeside->pohLeft    == poh->pohLeft)  &&
            (pohBeside->pohRight   == poh->pohRight) &&
            (pohBeside->pohDown    == poh)           &&
            (poh->pohDown->pohUp != poh))
        {
            pohBeside->cy      += poh->cy;
            pohBeside->pohDown  = poh->pohDown;

            poh->pohNext->pohPrev = poh->pohPrev;
            poh->pohPrev->pohNext = poh->pohNext;

            vOhFreeNode(ppdev, poh);

            poh = pohBeside;
            goto MergeLoop;
        }
    }

    // Remove this node from whatever list it's in:

    poh->pohNext->pohPrev = poh->pohPrev;
    poh->pohPrev->pohNext = poh->pohNext;

    cxcy = CXCY(poh->cx, poh->cy);

    // Insert the node, in order, into the free list:

    pohNext = ppdev->heap.ohFree.pohNext;
    while (pohNext->cxcy < cxcy)
    {
        pohNext = pohNext->pohNext;
    }
    pohPrev = pohNext->pohPrev;

    pohPrev->pohNext = poh;
    pohNext->pohPrev = poh;
    poh->pohPrev     = pohPrev;
    poh->pohNext     = pohNext;
    poh->cxcy        = cxcy;
    poh->ohState     = OH_FREE;

    if (oldState == OH_PERMANENT)
    {
        // Removing the permanent entry means that we may be able to
        // enlarge the maximum possible rectangle we can allow:

        vCalculateMaximumNonPermanent(ppdev);
    }

    // Return the node pointer for the new and improved available rectangle:

    return(poh);
}

/******************************Public*Routine******************************\
* BOOL bDiscardEverythingInRectangle
*
* Throws out of the heap any discardable bitmaps that intersect with the
* specified rectangle.
*
\**************************************************************************/

BOOL bDiscardEverythingInRectangle(
PDEV*   ppdev,
LONG    x,
LONG    y,
LONG    cx,
LONG    cy)
{
    BOOL bRet;
    OH*  poh;
    OH*  pohNext;

    bRet = TRUE;        // Assume success

    poh = ppdev->heap.ohDiscardable.pohNext;
    while (poh != &ppdev->heap.ohDiscardable)
    {
        ASSERTDD(poh->ohState == OH_DISCARDABLE,
                 "Non-discardable node in discardable list");

        pohNext = poh->pohNext;

        if ((poh->x < x + cx) &&
            (poh->y < y + cy) &&
            (poh->x + poh->cx > x) &&
            (poh->y + poh->cy > y))
        {
            // The two rectangles intersect.  Give the boot to the
            // discardable bitmap:

            if (!pohMoveOffscreenDfbToDib(ppdev, poh))
                bRet = FALSE;
        }

        poh = pohNext;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL bFreeRightAndBottomSpace
*
* Given a free off-screen rectangle, allocates the upper-left part of
* the rectangle to hold the allocation request, and puts the two rectangles
* comprising the unused right and bottom portions on the free list.
*
\**************************************************************************/

BOOL bFreeRightAndBottomSpace(
PDEV*   ppdev,
OH*     pohThis,
LONG    cxThis,
LONG    cyThis,
BOOL    bQuantum)           // Set if inifitely small allocations should be
                            //   allowed
{
    ULONG cxcy;             // Temporary versions
    OH*   pohNext;
    OH*   pohPrev;
    LONG  cxRem;
    LONG  cyRem;
    OH*   pohBelow;
    LONG  cxBelow;
    LONG  cyBelow;
    OH*   pohBeside;
    LONG  cxBeside;
    LONG  cyBeside;
    LONG  cQuantum;

    // We're going to use the upper-left corner of our given rectangle,
    // and divide the unused remainder into two rectangles which will
    // go on the free list.

    // Compute the width of the unused rectangle to the right, and the
    // height of the unused rectangle below:

    cyRem = pohThis->cy - cyThis;
    cxRem = pohThis->cx - cxThis;

    // Given finite area, we wish to find the two rectangles that are
    // most square -- i.e., the arrangement that gives two rectangles
    // with the least perimiter:

    cyBelow  = cyRem;
    cxBeside = cxRem;

    if (cxRem <= cyRem)
    {
        cxBelow  = cxThis + cxRem;
        cyBeside = cyThis;
    }
    else
    {
        cxBelow  = cxThis;
        cyBeside = cyThis + cyRem;
    }

    // If 'bQuantum' is set, we only make new available rectangles of
    // the unused right and bottom portions if they're greater in
    // dimension than OH_QUANTUM (it hardly makes sense to do the
    // book-work to keep around a 2-pixel wide available space, for
    // example):

    cQuantum = (bQuantum) ? 1 : OH_QUANTUM;

    pohBeside = NULL;
    if (cxBeside >= cQuantum)
    {
        pohBeside = pohNewNode(ppdev);
        if (pohBeside == NULL)
            return(FALSE);
    }

    pohBelow = NULL;
    if (cyBelow >= cQuantum)
    {
        pohBelow = pohNewNode(ppdev);
        if (pohBelow == NULL)
        {
            vOhFreeNode(ppdev, pohBeside);
            return(FALSE);
        }

        // Insert this rectangle into the available list (which is
        // sorted on ascending cxcy):

        cxcy    = CXCY(cxBelow, cyBelow);
        pohNext = ppdev->heap.ohFree.pohNext;
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext   = pohBelow;
        pohNext->pohPrev   = pohBelow;
        pohBelow->pohPrev  = pohPrev;
        pohBelow->pohNext  = pohNext;

        // Now update the adjacency information:

        pohBelow->pohLeft  = pohThis->pohLeft;
        pohBelow->pohUp    = pohThis;
        pohBelow->pohRight = pohThis->pohRight;
        pohBelow->pohDown  = pohThis->pohDown;

        // Update the rest of the new node information:

        pohBelow->cxReserved = 0;
        pohBelow->cyReserved = 0;
        pohBelow->cxcy       = cxcy;
        pohBelow->ohState    = OH_FREE;
        pohBelow->x          = pohThis->x;
        pohBelow->y          = pohThis->y + cyThis;
        pohBelow->cx         = cxBelow;
        pohBelow->cy         = cyBelow;

        // Modify the current node to reflect the changes we've made:

        pohThis->cy = cyThis;
    }

    if (cxBeside >= cQuantum)
    {
        // Insert this rectangle into the available list (which is
        // sorted on ascending cxcy):

        cxcy    = CXCY(cxBeside, cyBeside);
        pohNext = ppdev->heap.ohFree.pohNext;
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext    = pohBeside;
        pohNext->pohPrev    = pohBeside;
        pohBeside->pohPrev  = pohPrev;
        pohBeside->pohNext  = pohNext;

        // Now update the adjacency information:

        pohBeside->pohUp    = pohThis->pohUp;
        pohBeside->pohLeft  = pohThis;
        pohBeside->pohDown  = pohThis->pohDown;
        pohBeside->pohRight = pohThis->pohRight;

        // Update the rest of the new node information:

        pohBeside->cxReserved = 0;
        pohBeside->cyReserved = 0;
        pohBeside->cxcy       = cxcy;
        pohBeside->ohState    = OH_FREE;
        pohBeside->x          = pohThis->x + cxThis;
        pohBeside->y          = pohThis->y;
        pohBeside->cx         = cxBeside;
        pohBeside->cy         = cyBeside;

        // Modify the current node to reflect the changes we've made:

        pohThis->cx = cxThis;
    }

    if (pohBelow != NULL)
    {
        pohThis->pohDown = pohBelow;
        if ((pohBeside != NULL) && (cyBeside == pohThis->cy))
            pohBeside->pohDown = pohBelow;
    }
    if (pohBeside != NULL)
    {
        pohThis->pohRight = pohBeside;
        if ((pohBelow != NULL) && (cxBelow == pohThis->cx))
            pohBelow->pohRight  = pohBeside;
    }

    pohThis->cxcy = CXCY(pohThis->cx, pohThis->cy);

    return(TRUE);
}

/******************************Public*Routine******************************\
* OH* pohMakeRoomAtLocation
*
* Attempts to allocate a rectangle at a specific position.
*
\**************************************************************************/

OH* pohMakeRoomAtLocation(
PDEV*   ppdev,
POINTL* pptl,               // Requested position for the rectangle
LONG    cxThis,             // Width of rectangle to be allocated
LONG    cyThis,             // Height of rectangle to be allocated
FLONG   floh)               // Allocation flags
{
    OH*     poh;
    OH*     pohTop;
    OH*     pohLeft;
    LONG    cxLeft;
    LONG    cyTop;

    if (!(floh & FLOH_ONLY_IF_ROOM))
    {
        // First off, discard any bitmaps that overlap the requested
        // rectangle, assuming we're allowed to:

        if (!bDiscardEverythingInRectangle(ppdev, pptl->x, pptl->y, cxThis, cyThis))
            return(NULL);
    }

    // Now see if there is a free rectangle that entirely contains the
    // requested rectangle.

    for (poh = ppdev->heap.ohFree.pohNext;
         poh != &ppdev->heap.ohFree;
         poh = poh->pohNext)
    {
        ASSERTDD(poh->ohState == OH_FREE, "Non-free node in free list");

        // See if the current free rectangle completely contains the
        // requested rectangle:

        if ((poh->x <= pptl->x) &&
            (poh->y <= pptl->y) &&
            (poh->x + poh->cx >= pptl->x + cxThis) &&
            (poh->y + poh->cy >= pptl->y + cyThis))
        {
            // We can't reserve this rectangle, or make it permanent, if it's
            // already been reserved:

            if ((!poh->cxReserved) ||
                ((floh & (FLOH_RESERVE | FLOH_MAKE_PERMANENT)) == 0))
            {
                // The 'poh' rectangle entirely contains the requested
                // rectangle.  We may have a situation like this, where
                // the smaller rectangle is the requested rectangle, and
                // the larger rectangle is the available rectangle:
                //
                //     +-------------------+
                //     |                   |
                //     |    +---------+    |
                //     |    |Requested|    |
                //     |    |         |    |
                //     |    +---------+    |
                //     |                   |
                //     +-------------------+
                //
                // We want to make the space to the left and to the top of
                // the requested rectangle available to the heap.  Our
                // free-space routine only knows how to free space to the
                // right and bottom of an allocation, though.  So we will
                // temporarily allocate temporary rectangles to subdivide
                // our rectangle like the following:
                //
                //     +-------------------+
                //     |Top                |
                //     +----+--------------+
                //     |Left|Free          |
                //     |    |              |
                //     |    |              |
                //     |    |              |
                //     +----+--------------+
                //
                // Then, in the resulting 'Free' space, we will allocate the
                // upper-left corner for our requested rectangle, after which
                // we will go back and free the 'Top' and 'Left' temporary
                // rectangles.

                pohTop  = NULL;
                pohLeft = NULL;
                cxLeft  = pptl->x - poh->x;
                cyTop   = pptl->y - poh->y;

                if (cyTop > 0)
                {
                    if (!bFreeRightAndBottomSpace(ppdev, poh, poh->cx, cyTop,
                                                  TRUE))
                    {
                        return(NULL);
                    }

                    pohTop = poh;
                    poh    = pohTop->pohDown;
                }

                if (cxLeft > 0)
                {
                    if (!bFreeRightAndBottomSpace(ppdev, poh, cxLeft, poh->cy,
                                                  TRUE))
                    {
                        pohFree(ppdev, pohTop);
                        return(NULL);
                    }

                    pohLeft = poh;
                    poh     = pohLeft->pohRight;
                }

                ASSERTDD((poh->x == pptl->x) &&
                         (poh->y == pptl->y) &&
                         (poh->x + poh->cx >= poh->x + cxThis) &&
                         (poh->y + poh->cy >= poh->y + cyThis),
                        "poh must properly fit requested rectangle");

                // Finally, we can subdivide to get our requested rectangle:

                if (!bFreeRightAndBottomSpace(ppdev, poh, cxThis, cyThis, FALSE))
                    poh = NULL;         // Fail this call

                // Free our temporary rectangles, if there are any:

                pohFree(ppdev, pohTop);
                pohFree(ppdev, pohLeft);

                return(poh);
            }
        }
    }

    // There was no free rectangle that completely contains the requested
    // rectangle:

    return(NULL);
}

/******************************Public*Routine******************************\
* OH* pohMakeRoomAnywhere
*
* Allocates space for an off-screen rectangle.  It will attempt to find
* the smallest available free rectangle, and will allocate the block out
* of its upper-left corner.  The remaining two rectangles will be placed
* on the available free space list.
*
* If the rectangle would have been large enough to fit into off-screen
* memory, but there is not enough available free space, we will boot
* bitmaps out of off-screen and into DIBs until there is enough room.
*
\**************************************************************************/

OH* pohMakeRoomAnywhere(
PDEV*   ppdev,
LONG    cxThis,             // Width of rectangle to be allocated
LONG    cyThis,             // Height of rectangle to be allocated
FLONG   floh)               // May have FLOH_ONLY_IF_ROOM set
{
    ULONG cxcyThis;         // Width and height search key
    OH*   pohThis;          // Points to found available rectangle we'll use

    ASSERTDD((cxThis > 0) && (cyThis > 0), "Illegal allocation size");

    // Increase the width to get the proper alignment (thus ensuring that all
    // allocations will be properly aligned):

    cxThis = (cxThis + (HEAP_X_ALIGNMENT - 1)) & ~(HEAP_X_ALIGNMENT - 1);

    // We can't succeed if the requested rectangle is larger than the
    // largest possible available rectangle:

    if ((cxThis > ppdev->heap.cxMax) || (cyThis > ppdev->heap.cyMax))
        return(NULL);

    // Find the first available rectangle the same size or larger than
    // the requested one:

    cxcyThis = CXCY(cxThis, cyThis);
    pohThis  = ppdev->heap.ohFree.pohNext;
    while (pohThis->cxcy < cxcyThis)
    {
        ASSERTDD(pohThis->ohState == OH_FREE, "Non-free node in free list");

        pohThis = pohThis->pohNext;
    }

    while (pohThis->cy < cyThis)
    {
        ASSERTDD(pohThis->ohState == OH_FREE, "Non-free node in free list");

        pohThis = pohThis->pohNext;
    }

    ASSERTDD(pohThis->ohState == OH_FREE, "Non-free node in free list");

    if (pohThis->cxcy == CXCY_SENTINEL)
    {
        // There was no space large enough...

        if (floh & FLOH_ONLY_IF_ROOM)
            return(NULL);

        DISPDBG((15, "> Making room for %li x %li allocation...", cxThis, cyThis));

        // We couldn't find an available rectangle that was big enough
        // to fit our request.  So throw things out of the heap until we
        // have room, oldest allocations first:

        do {
            pohThis = ppdev->heap.ohDiscardable.pohPrev;  // Least-recently created

            ASSERTDD(pohThis != &ppdev->heap.ohDiscardable,
                     "Ran out of discardable entries -- Max not set correctly");
            ASSERTDD(pohThis->ohState == OH_DISCARDABLE,
                     "Non-discardable node in discardable list");

            // We can safely exit here if we have to:

            pohThis = pohMoveOffscreenDfbToDib(ppdev, pohThis);
            if (pohThis == NULL)
                return(NULL);

        } while ((pohThis->cx < cxThis) || (pohThis->cy < cyThis));
    }

    if ((pohThis->cxReserved) && (floh & (FLOH_RESERVE | FLOH_MAKE_PERMANENT)))
    {
        // We can't reserve this rectangle, or make it permanent, if it's
        // already been reserved.  So throw absolutely everything out and
        // search the free list.
        //
        // NOTE: This is extremely painful!  A better approach would be to
        //       keep separate 'cxMax' and 'cyMax' variables kept for free
        //       rectangles that are not reserved (cxMax and cyMax
        //       currently include reserved free rectangles).

        if (!bDiscardEverythingInRectangle(ppdev, 0, 0,
                                           ppdev->cxMemory, ppdev->cyMemory))
        {
            return(NULL);
        }

        pohThis = &ppdev->heap.ohFree;
        do {
            pohThis = pohThis->pohNext;

            if (pohThis == &ppdev->heap.ohFree)
                return(NULL);

        } while ((pohThis->cxReserved)  ||
                 (pohThis->cx < cxThis) ||
                 (pohThis->cy < cyThis));
    }

    if (!bFreeRightAndBottomSpace(ppdev, pohThis, cxThis, cyThis, FALSE))
        return(NULL);

    return(pohThis);
}

/******************************Public*Routine******************************\
* OH* pohAllocate
*
* Allocates a rectangle in off-screen memory.
*
* Types:
*
*   FLOH_RESERVE
*
*     Reserves an off-screen rectangle.  The space may still be used by
*     discardable bitmaps until the rectangle is committed via 'bOhCommit'.
*
*   FLOH_MAKE_PERMANENT
*
*     Allocates an off-screen rectangle that can never be booted
*     of the heap.   It's the caller's responsibility to manage
*     the rectangle, which includes what to do with the memory in
*     DrvAssertMode when the display is changed to full-screen
*     mode.
*
*   Default
*
*     Allocates a 'discardable' off-screen rectangle for a DFB that may
*     be  kicked out of off-screen if the space is needed.
*
* Options:
*
*   FLOH_ONLY_IF_ROOM
*
*     Allocates an off-screen rectangle only if there is free space
*     available -- i.e., no discardable rectangles will be moved out of
*     off-screen to make room.
*
*   Default
*
*     May move discardable rectangles out of off-screen to make room.
*
* Arguments:
*
*   pptl
*
*     If NULL, the rectangle will be allocated anywhere in un-used offscreen
*     memory.
*
*     If non-NULL, is a requested position for the rectangle.
*
*     NOTE: The heap will quickly fragment if arbitrary positions are
*           requested.  This position option works best if there is only
*           one specific rectangle ever requested, or if the allocations
*           are always wider than they are high.
*
\**************************************************************************/

OH* pohAllocate(
PDEV*   ppdev,
POINTL* pptl,           // Optional requested position of rectangle
LONG    cxThis,         // Width of rectangle to be allocated
LONG    cyThis,         // Height of rectangle to be allocated
FLOH    floh)           // Allocation flags
{
    OH*     pohThis;    // Points to found available rectangle we'll use
    OH*     pohRoot;    // Point to root of list where we'll insert node
    ULONG   cxcy;
    OH*     pohNext;
    OH*     pohPrev;

    ASSERTDD((floh & (FLOH_RESERVE | FLOH_MAKE_PERMANENT))
             != (FLOH_RESERVE | FLOH_MAKE_PERMANENT),
             "Illegal flags -- can't set both FLOH_RESERVE and FLOH_MAKE_PERMANENT");

    if (pptl == NULL)
    {
        pohThis = pohMakeRoomAnywhere(ppdev, cxThis, cyThis, floh);
        if (pohThis == NULL)
            DISPDBG((15, "Can't allocate %li x %li with flags %li",
                        cxThis, cyThis, floh));
    }
    else
    {
        pohThis = pohMakeRoomAtLocation(ppdev, pptl, cxThis, cyThis, floh);
        if (pohThis == NULL)
            DISPDBG((15, "Can't allocate %li x %li at %li, %li with flags %li",
                        cxThis, cyThis, pptl->x, pptl->y, floh));
    }

    if (pohThis == NULL)
        return(NULL);

    // Calculate the effective start address for this bitmap in off-
    // screen memory:

    pohThis->pvScan0 = ppdev->pjScreen + (pohThis->y * ppdev->lDelta)
                                       + (pohThis->x * ppdev->cjPelSize);

    // The caller is responsible for setting this field:

    pohThis->pdsurf = NULL;

    // Our 'reserve' logic expects the node to have 'free' status:

    ASSERTDD(pohThis->ohState == OH_FREE, "Node not free after making room");
    ASSERTDD(((floh & (FLOH_RESERVE | FLOH_MAKE_PERMANENT)) == 0) ||
             (pohThis->cxReserved == 0),
             "Can't reserve a rectangle that's already reserved");

    if (floh & FLOH_RESERVE)
    {
        // A non-zero value for 'cxReserved' means it's reserved:

        pohThis->cxReserved = pohThis->cx;
        pohThis->cyReserved = pohThis->cy;

        // Remove this node from its place in the free list:

        pohThis->pohPrev->pohNext = pohThis->pohNext;
        pohThis->pohNext->pohPrev = pohThis->pohPrev;

        // Now insert the node, in order, back into the free list:

        cxcy = pohThis->cxcy;

        pohNext = ppdev->heap.ohFree.pohNext;
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext = pohThis;
        pohNext->pohPrev = pohThis;
        pohThis->pohPrev = pohPrev;
        pohThis->pohNext = pohNext;
    }
    else
    {
        // Remove this node from the free list:

        pohThis->pohPrev->pohNext = pohThis->pohNext;
        pohThis->pohNext->pohPrev = pohThis->pohPrev;

        if (floh & FLOH_MAKE_PERMANENT)
        {
            // Change status of node and insert into permanent list:

            pohThis->ohState = OH_PERMANENT;
            pohRoot = &ppdev->heap.ohPermanent;

            // Calculate the new maximum size rectangle available
            // for allocation:

            vCalculateMaximumNonPermanent(ppdev);
        }
        else
        {
            // Change status of node and insert into discardable list:

            pohThis->ohState = OH_DISCARDABLE;
            pohRoot = &ppdev->heap.ohDiscardable;
        }

        // Now insert the node at the head of the appropriate list:

        pohThis->pohNext = pohRoot->pohNext;
        pohThis->pohPrev = pohRoot;

        pohRoot->pohNext->pohPrev = pohThis;
        pohRoot->pohNext          = pohThis;
    }

    DISPDBG((15, "   Allocated (%li x %li) at (%li, %li) with flags %li",
                cxThis, cyThis, pohThis->x, pohThis->y, floh));

    return(pohThis);
}

/******************************Public*Routine******************************\
* BOOL bOhCommit
*
* If 'bCommit' is TRUE, converts a 'reserved' allocation to 'permanent,'
* moving from off-screen memory any discardable allocations that may have
* been using the space.
*
* If 'bCommit' is FALSE, converts a 'permanent' allocation to 'reserved,'
* allowing the space to be used by discardable allocations.
*
\**************************************************************************/

BOOL bOhCommit(
PDEV*   ppdev,
OH*     poh,
BOOL    bCommit)
{
    BOOL    bRet;
    ULONG   cxcy;
    OH*     pohRoot;
    OH*     pohNext;
    OH*     pohPrev;

    bRet = FALSE;       // Assume failure

    if (poh == NULL)
        return(bRet);

    if ((bCommit) && (poh->cxReserved))
    {
        if (bDiscardEverythingInRectangle(ppdev, poh->x, poh->y,
                                          poh->cxReserved, poh->cyReserved))
        {
            DISPDBG((15, "Commited %li x %li at (%li, %li)",
                        poh->cx, poh->cy, poh->x, poh->y));

            poh->ohState = OH_PERMANENT;

            // Remove this node from the free list:

            poh->pohPrev->pohNext = poh->pohNext;
            poh->pohNext->pohPrev = poh->pohPrev;

            // Now insert the node at the head of the permanent list:

            pohRoot = &ppdev->heap.ohPermanent;

            poh->pohNext = pohRoot->pohNext;
            poh->pohPrev = pohRoot;

            pohRoot->pohNext->pohPrev = poh;
            pohRoot->pohNext          = poh;

            bRet = TRUE;
        }
    }
    else if ((!bCommit) && (poh->ohState == OH_PERMANENT))
    {
        DISPDBG((15, "Decommited %li x %li at (%li, %li)",
                    poh->cx, poh->cy, poh->x, poh->y));

        poh->ohState    = OH_FREE;
        poh->cxReserved = poh->cx;
        poh->cyReserved = poh->cy;

        // Remove this node from the permanent list:

        poh->pohPrev->pohNext = poh->pohNext;
        poh->pohNext->pohPrev = poh->pohPrev;

        // Now insert the node, in order, into the free list:

        cxcy = poh->cxcy;

        pohNext = ppdev->heap.ohFree.pohNext;
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext    = poh;
        pohNext->pohPrev    = poh;
        poh->pohPrev        = pohPrev;
        poh->pohNext        = pohNext;

        bRet = TRUE;
    }

    // Recalculate the biggest rectangle available for allocation:

    vCalculateMaximumNonPermanent(ppdev);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL bMoveDibToOffscreenDfbIfRoom
*
* Converts the DIB DFB to an off-screen DFB, if there's room for it in
* off-screen memory.
*
* Returns: FALSE if there wasn't room, TRUE if successfully moved.
*
\**************************************************************************/

BOOL bMoveDibToOffscreenDfbIfRoom(
PDEV*   ppdev,
DSURF*  pdsurf)
{
    OH*         poh;
    SURFOBJ*    pso;
    RECTL       rclDst;
    POINTL      ptlSrc;
    HSURF       hsurf;

    ASSERTDD(pdsurf->dt == DT_DIB,
             "Can't move a bitmap off-screen when it's already off-screen");

    // If we're in full-screen mode, we can't move anything to off-screen
    // memory:

    if (!ppdev->bEnabled)
        return(FALSE);

    poh = pohAllocate(ppdev, NULL, pdsurf->sizl.cx, pdsurf->sizl.cy,
                      FLOH_ONLY_IF_ROOM);
    if (poh == NULL)
    {
        // There wasn't any free room.

        return(FALSE);
    }

    // 'pdsurf->sizl' is the actual bitmap dimension, not 'poh->cx' or
    // 'poh->cy'.

    rclDst.left   = poh->x;
    rclDst.top    = poh->y;
    rclDst.right  = rclDst.left + pdsurf->sizl.cx;
    rclDst.bottom = rclDst.top  + pdsurf->sizl.cy;

    ptlSrc.x      = 0;
    ptlSrc.y      = 0;

    ppdev->pfnPutBits(ppdev, pdsurf->pso, &rclDst, &ptlSrc);

    // Update the data structures to reflect the new off-screen node:

    pso           = pdsurf->pso;
    pdsurf->dt    = DT_SCREEN;
    pdsurf->poh   = poh;
    poh->pdsurf   = pdsurf;

    // Now free the DIB.  Get the hsurf from the SURFOBJ before we unlock
    // it (it's not legal to dereference psoDib when it's unlocked):

    hsurf = pso->hsurf;
    EngUnlockSurface(pso);
    EngDeleteSurface(hsurf);

    return(TRUE);
}

/******************************Public*Routine******************************\
* OH* pohMoveOffscreenDfbToDib
*
* Converts the DFB from being off-screen to being a DIB.
*
* Note: The caller does NOT have to call 'pohFree' on 'poh' after making
*       this call.
*
* Returns: NULL if the function failed (due to a memory allocation).
*          Otherwise, it returns a pointer to the coalesced off-screen heap
*          node that has been made available for subsequent allocations
*          (useful when trying to free enough memory to make a new
*          allocation).
\**************************************************************************/

OH* pohMoveOffscreenDfbToDib(
PDEV*   ppdev,
OH*     poh)
{
    DSURF*   pdsurf;
    HBITMAP  hbmDib;
    SURFOBJ* pso;
    RECTL    rclDst;
    POINTL   ptlSrc;

    DISPDBG((15, "Throwing out %li x %li at (%li, %li)!",
                 poh->cx, poh->cy, poh->x, poh->y));

    pdsurf = poh->pdsurf;

    ASSERTDD((poh->x != 0) || (poh->y != 0),
            "Can't make the visible screen into a DIB");
    ASSERTDD(pdsurf->dt != DT_DIB,
            "Can't make a DIB into even more of a DIB");

    hbmDib = EngCreateBitmap(pdsurf->sizl, 0, ppdev->iBitmapFormat,
                             BMF_TOPDOWN, NULL);
    if (hbmDib)
    {
        if (EngAssociateSurface((HSURF) hbmDib, ppdev->hdevEng, 0))
        {
            pso = EngLockSurface((HSURF) hbmDib);
            if (pso != NULL)
            {
                rclDst.left   = 0;
                rclDst.top    = 0;
                rclDst.right  = pdsurf->sizl.cx;
                rclDst.bottom = pdsurf->sizl.cy;

                ptlSrc.x      = poh->x;
                ptlSrc.y      = poh->y;

                ppdev->pfnGetBits(ppdev, pso, &rclDst, &ptlSrc);

                pdsurf->dt    = DT_DIB;
                pdsurf->pso   = pso;

                // Don't even bother checking to see if this DIB should
                // be put back into off-screen memory until the next
                // heap 'free' occurs:

                pdsurf->iUniq = ppdev->iHeapUniq;
                pdsurf->cBlt  = 0;

                // Remove this node from the off-screen DFB list, and free
                // it.  'pohFree' will never return NULL:

                return(pohFree(ppdev, poh));
            }
        }

        // Fail case:

        EngDeleteSurface((HSURF) hbmDib);
    }

    return(NULL);
}

/******************************Public*Routine******************************\
* BOOL bMoveEverythingFromOffscreenToDibs
*
* This function is used when we're about to enter full-screen mode, which
* would wipe all our off-screen bitmaps.  GDI can ask us to draw on
* device bitmaps even when we're in full-screen mode, and we do NOT have
* the option of stalling the call until we switch out of full-screen.
* We have no choice but to move all the off-screen DFBs to DIBs.
*
* Returns TRUE if all DSURFs have been successfully moved.
*
\**************************************************************************/

BOOL bMoveAllDfbsFromOffscreenToDibs(
PDEV*   ppdev)
{
    // Throw out any discardable bitmaps over the entire surface:

    return(bDiscardEverythingInRectangle(ppdev, 0, 0,
                                         ppdev->cxMemory, ppdev->cyMemory));
}

/******************************Public*Routine******************************\
* HBITMAP DrvCreateDeviceBitmap
*
* Function called by GDI to create a device-format-bitmap (DFB).  We will
* always try to allocate the bitmap in off-screen; if we can't, we simply
* fail the call and GDI will create and manage the bitmap itself.
*
* Note: We do not have to zero the bitmap bits.  GDI will automatically
*       call us via DrvBitBlt to zero the bits (which is a security
*       consideration).
*
\**************************************************************************/

HBITMAP DrvCreateDeviceBitmap(
DHPDEV  dhpdev,
SIZEL   sizl,
ULONG   iFormat)
{
    PDEV*   ppdev;
    OH*     poh;
    DSURF*  pdsurf;
    HBITMAP hbmDevice;
    FLONG   flHooks;

//return 0;   //RKE:
    ppdev = (PDEV*) dhpdev;

    // If we're in full-screen mode, we hardly have any off-screen memory
    // in which to allocate a DFB.  LATER: We could still allocate an
    // OH node and put the bitmap on the DIB DFB list for later promotion.

    if (!ppdev->bEnabled)
        return(0);

    // We only support device bitmaps that are the same colour depth
    // as our display.
    //
    // Actually, those are the only kind GDI will ever call us with,
    // but we may as well check.  Note that this implies you'll never
    // get a crack at 1bpp bitmaps.

    if (iFormat != ppdev->iBitmapFormat)
        return(0);

    // We don't want anything 8x8 or smaller -- they're typically brush
    // patterns which we don't particularly want to stash in off-screen
    // memory:

    if ((sizl.cx <= 8) && (sizl.cy <= 8))
        return(0);

    // Since 24bpp mach32 is GDI-managed, and we don't have access to
    // vGetBits and vPutBits as a consequence, we reject device bitmaps.
    if (iFormat == BMF_24BPP && ppdev->iAsic != ASIC_88800GX)
        return 0;

    poh = pohAllocate(ppdev, NULL, sizl.cx, sizl.cy, 0);
    if (poh != NULL)
    {
        pdsurf = AtiAllocMem(LMEM_FIXED, 0, sizeof(DSURF));
        if (pdsurf != NULL)
        {
            hbmDevice = EngCreateDeviceBitmap((DHSURF) pdsurf, sizl, iFormat);
            if (hbmDevice != NULL)
            {
                flHooks = ppdev->flHooks;

                // Setting the SYNCHRONIZEACCESS flag tells GDI that we
                // want all drawing to the bitmaps to be synchronized (GDI
                // is multi-threaded and by default does not synchronize
                // device bitmap drawing -- it would be a Bad Thing for us
                // to have multiple threads using the accelerator at the
                // same time):

                flHooks |= HOOK_SYNCHRONIZEACCESS;

                // It's a device-managed surface; make sure we don't set
                // HOOK_SYNCHRONIZE, otherwise we may confuse GDI:

                flHooks &= ~HOOK_SYNCHRONIZE;

                if (EngAssociateSurface((HSURF) hbmDevice, ppdev->hdevEng,
                                        flHooks))
                {
                    pdsurf->dt    = DT_SCREEN;
                    pdsurf->poh   = poh;
                    pdsurf->sizl  = sizl;
                    pdsurf->ppdev = ppdev;
                    poh->pdsurf   = pdsurf;

                    return(hbmDevice);
                }

                EngDeleteSurface((HSURF) hbmDevice);
            }
            AtiFreeMem(pdsurf);
        }
        pohFree(ppdev, poh);
    }

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDeleteDeviceBitmap
*
* Deletes a DFB.
*
\**************************************************************************/

VOID DrvDeleteDeviceBitmap(
DHSURF  dhsurf)
{
    DSURF*   pdsurf;
    PDEV*    ppdev;
    SURFOBJ* psoDib;
    HSURF    hsurfDib;

    pdsurf = (DSURF*) dhsurf;
    ppdev  = pdsurf->ppdev;

    if (pdsurf->dt == DT_SCREEN)
    {
        pohFree(ppdev, pdsurf->poh);
    }
    else
    {
        ASSERTDD(pdsurf->dt == DT_DIB, "Expected DIB type");

        psoDib = pdsurf->pso;

        // Get the hsurf from the SURFOBJ before we unlock it (it's not
        // legal to dereference psoDib when it's unlocked):

        hsurfDib = psoDib->hsurf;
        EngUnlockSurface(psoDib);
        EngDeleteSurface(hsurfDib);
    }

    AtiFreeMem(pdsurf);
}

/******************************Public*Routine******************************\
* BOOL bAssertModeOffscreenHeap
*
* This function is called whenever we switch in or out of full-screen
* mode.  We have to convert all the off-screen bitmaps to DIBs when
* we switch to full-screen (because we may be asked to draw on them even
* when in full-screen, and the mode switch would probably nuke the video
* memory contents anyway).
*
\**************************************************************************/

BOOL bAssertModeOffscreenHeap(
PDEV*   ppdev,
BOOL    bEnable)
{
    BOOL b = TRUE;

    if (!bEnable)
    {
	b = bMoveAllDfbsFromOffscreenToDibs(ppdev);
    }

    return b;
}

/******************************Public*Routine******************************\
* VOID vDisableOffscreenHeap
*
* Frees any resources allocated by the off-screen heap.
*
\**************************************************************************/

VOID vDisableOffscreenHeap(
PDEV*   ppdev)
{
    OHALLOC* poha;
    OHALLOC* pohaNext;
    SURFOBJ* psoPunt;
    HSURF    hsurf;

    psoPunt = ppdev->psoPunt;
    if (psoPunt != NULL)
    {
        hsurf = psoPunt->hsurf;
        EngUnlockSurface(psoPunt);
        EngDeleteSurface(hsurf);
    }

    psoPunt = ppdev->psoPunt2;
    if (psoPunt != NULL)
    {
        hsurf = psoPunt->hsurf;
        EngUnlockSurface(psoPunt);
        EngDeleteSurface(hsurf);
    }

    poha = ppdev->heap.pohaChain;
    while (poha != NULL)
    {
        pohaNext = poha->pohaNext;  // Grab the next pointer before it's freed
        AtiFreeMem(poha);
        poha = pohaNext;
    }
}

/******************************Public*Routine******************************\
* BOOL bEnableOffscreenHeap
*
* Initializes the off-screen heap using all available video memory,
* accounting for the portion taken by the visible screen.
*
* Input: ppdev->cxScreen
*        ppdev->cyScreen
*        ppdev->cxMemory
*        ppdev->cyMemory
*
\**************************************************************************/

BOOL bEnableOffscreenHeap(
PDEV*   ppdev)
{
    OH*         poh;
    SIZEL       sizl;
    HSURF       hsurf;
    POINTL      ptlScreen;

    DISPDBG((15, "Screen: %li x %li  Memory: %li x %li",
        ppdev->cxScreen, ppdev->cyScreen, ppdev->cxMemory, ppdev->cyMemory));

    ASSERTDD((ppdev->cxScreen <= ppdev->cxMemory) &&
             (ppdev->cyScreen <= ppdev->cyMemory),
             "Memory must not have smaller dimensions than visible screen!");

    ppdev->heap.pohaChain   = NULL;
    ppdev->heap.pohFreeList = NULL;

    // Initialize the available list, which will be a circular
    // doubly-linked list kept in ascending 'cxcy' order, with a
    // 'sentinel' at the end of the list:

    poh = pohNewNode(ppdev);
    if (poh == NULL)
        goto ReturnFalse;

    // The first node describes the entire video memory size:

    poh->pohNext      = &ppdev->heap.ohFree;
    poh->pohPrev      = &ppdev->heap.ohFree;
    poh->ohState      = OH_FREE;
    poh->x            = 0;
    poh->y            = 0;
    poh->cx           = ppdev->cxMemory;
    poh->cy           = ppdev->cyMemory;
    poh->cxcy         = CXCY(ppdev->cxMemory, ppdev->cyMemory);
    poh->pohLeft      = &ppdev->heap.ohFree;
    poh->pohUp        = &ppdev->heap.ohFree;
    poh->pohRight     = &ppdev->heap.ohFree;
    poh->pohDown      = &ppdev->heap.ohFree;
    poh->pvScan0      = ppdev->pjScreen;

    // The second node is our free list sentinel:

    ppdev->heap.ohFree.pohNext         = poh;
    ppdev->heap.ohFree.pohPrev         = poh;
    ppdev->heap.ohFree.cxcy            = CXCY_SENTINEL;
    ppdev->heap.ohFree.cx              = 0x7fffffff;
    ppdev->heap.ohFree.cy              = 0x7fffffff;
    ppdev->heap.ohFree.ohState         = OH_FREE;

    // Initialize the discardable list, which will be a circular
    // doubly-linked list kept in order, with a sentinel at the end.
    // This node is also used for the screen-surface, for its offset:

    ppdev->heap.ohDiscardable.pohNext = &ppdev->heap.ohDiscardable;
    ppdev->heap.ohDiscardable.pohPrev = &ppdev->heap.ohDiscardable;
    ppdev->heap.ohDiscardable.ohState = OH_DISCARDABLE;

    // Initialize the permanent list, which will be a circular
    // doubly-linked list kept in order, with a sentinel at the end.

    ppdev->heap.ohPermanent.pohNext = &ppdev->heap.ohPermanent;
    ppdev->heap.ohPermanent.pohPrev = &ppdev->heap.ohPermanent;
    ppdev->heap.ohPermanent.ohState = OH_PERMANENT;

    // For the moment, make the max really big so that the first
    // allocation we're about to do will succeed:

    ppdev->heap.cxMax = 0x7fffffff;
    ppdev->heap.cyMax = 0x7fffffff;

    ptlScreen.x = 0;
    ptlScreen.y = 0;

    // Finally, reserve the upper-left corner for the screen.  We can
    // actually throw away 'poh' because we'll never need it again
    // (not even for disabling the off-screen heap since everything is
    // freed using OHALLOCs):

    poh = pohAllocate(ppdev, &ptlScreen, ppdev->cxScreen, ppdev->cyScreen,
                      FLOH_MAKE_PERMANENT);

    ASSERTDD((poh != NULL) && (poh->x == 0) && (poh->y == 0) &&
             (poh->cx >= ppdev->cxScreen) && (poh->cy >= ppdev->cyScreen),
             "Screen allocation messed up");

    // Remember it so that we can associate the screen SURFOBJ with this
    // poh:

    ppdev->pohScreen = poh;

    // Allocate a 'punt' SURFOBJ we'll use when the device-bitmap is in
    // off-screen memory, but we want GDI to draw to it directly as an
    // engine-managed surface:

    sizl.cx = ppdev->cxMemory;
    sizl.cy = ppdev->cyMemory;

    // We want to create it with exactly the same hooks and capabilities
    // as our primary surface.  We will override the 'lDelta' and 'pvScan0'
    // fields later:

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    0xbadf00d,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    (VOID*) 0xbadf00d);

    if ((hsurf == 0)                                                  ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, ppdev->flHooks)) ||
        (!(ppdev->psoPunt = EngLockSurface(hsurf))))
    {
        DISPDBG((0, "Failed punt surface creation"));

        EngDeleteSurface(hsurf);
        goto ReturnFalse;
    }

    // We need another for doing DrvBitBlt and DrvCopyBits when both
    // surfaces are off-screen bitmaps:

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    0xbadf00d,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    (VOID*) 0xbadf00d);

    if ((hsurf == 0)                                                  ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, ppdev->flHooks)) ||
        (!(ppdev->psoPunt2 = EngLockSurface(hsurf))))
    {
        DISPDBG((0, "Failed punt surface creation"));

        EngDeleteSurface(hsurf);
        goto ReturnFalse;
    }

    DISPDBG((5, "Passed bEnableOffscreenHeap"));

    if (poh != NULL)
        return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bEnableOffscreenHeap"));

    return(FALSE);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\fillpath.c ===
/******************************Module*Header*******************************\
* Module Name: fillpath.c
*
* Contains the DrvFillPath routine.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit
// signed LONGLONGs and 64-bit unsigned DWORDLONGs.
//
// Int32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies
//      two 32-bit LONGs to produce a 64-bit LONGLONG result.
//      I use it because it is much faster than 64x64 multiplies.

#define UInt64Div32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define NUM_BUFFER_POINTS   96      // Maximum number of points in a path
                                    //   for which we'll attempt to join
                                    //   all the path records so that the
                                    //   path may still be drawn by FastFill

// Describe a single non-horizontal edge of a path to fill.
typedef struct _EDGE {
    PVOID pNext;
    INT iScansLeft;
    INT X;
    INT Y;
    INT iErrorTerm;
    INT iErrorAdjustUp;
    INT iErrorAdjustDown;
    INT iXWhole;
    INT iXDirection;
    INT iWindingDirection;
} EDGE, *PEDGE;

// Maximum number of rects we'll fill per call to
// the fill code
#define MAX_PATH_RECTS  50
#define RECT_BYTES      (MAX_PATH_RECTS * sizeof(RECTL))
#define EDGE_BYTES      (TMP_BUFFER_SIZE - RECT_BYTES)
#define MAX_EDGES       (EDGE_BYTES/sizeof(EDGE))

//MIX translation table. Translates a mix 1-16, into an old style Rop 0-255.
extern BYTE gaMix[];

VOID AdvanceAETEdges(EDGE *pAETHead);
VOID XSortAETEdges(EDGE *pAETHead);
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY);
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge, POINTFIX *ppfxEdgeStart,
        POINTFIX *ppfxEdgeEnd, RECTL *pClipRect);
BOOL ConstructGET(EDGE *pGETHead, EDGE *pFreeEdges, PATHOBJ *ppo,
        PATHDATA *pd, BOOL bMore, RECTL *pClipRect);
void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection);

/******************************Public*Routine******************************\
* DrvFillPath
*
* Fill the specified path with the specified brush and ROP.  This routine
* detects single convex polygons, and will call to separate faster convex
* polygon code for those cases.  This routine also detects polygons that
* are really rectangles, and handles those separately as well.
*
* Note: Multiple polygons in a path cannot be treated as being disjoint;
*       the fill must consider all the points in the path.  That is, if the
*       path contains multiple polygons, you cannot simply draw one polygon
*       after the other (unless they don't overlap).
*
* Note: This function is optional, but is recommended for good performance.
*       To get GDI to call this function, not only do you have to
*       HOOK_FILLPATH, you have to set GCAPS_ALTERNATEFILL and/or
*       GCAPS_WINDINGFILL.
*
\**************************************************************************/

BOOL DrvFillPath(
SURFOBJ*    pso,
PATHOBJ*    ppo,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
MIX         mix,
FLONG       flOptions)
{
    BYTE jClipping;     // clipping type
    EDGE *pCurrentEdge;
    EDGE AETHead;       // dummy head/tail node & sentinel for Active Edge Table
    EDGE *pAETHead;     // pointer to AETHead
    EDGE GETHead;       // dummy head/tail node & sentinel for Global Edge Table
    EDGE *pGETHead;     // pointer to GETHead
    EDGE *pFreeEdges;   // pointer to memory free for use to store edges
    ULONG ulNumRects;   // # of rectangles to draw currently in rectangle list
    RECTL *prclRects;   // pointer to start of rectangle draw list
    INT iCurrentY;      // scan line for which we're currently scanning out the
                        //  fill

    ULONG        rop4;              // rop4 for brush
    RBRUSH_COLOR rbc;               // Realized brush or solid color
    ULONG        iSolidColor;       // Copy of pbo->iSolidColor
    FNFILL      *pfnFill;           // Points to appropriate fill routine
    BOOL         bRealizeTransparent; // Need a transparent realization for Rop

    BOOL         bMore;
    PATHDATA     pd;
    RECTL        ClipRect;
    PDEV        *ppdev;
    DSURF       *pdsurf;
    RECTL*       prclClip;

    BOOL         bRetVal=FALSE;     // FALSE until proven TRUE
    BOOL         bMemAlloced=FALSE; // FALSE until proven TRUE

    FLONG        flFirstRecord;
    POINTFIX*    pptfxTmp;
    ULONG        cptfxTmp;
    RECTFX       rcfxBounds;
    POINTFIX     aptfxBuf[NUM_BUFFER_POINTS];

    // Set up the clipping
    if (pco == (CLIPOBJ *) NULL) {
        // No CLIPOBJ provided, so we don't have to worry about clipping
        jClipping = DC_TRIVIAL;
    } else {
        // Use the CLIPOBJ-provided clipping
        jClipping = pco->iDComplexity;
    }

    if (jClipping != DC_TRIVIAL) {
        if (jClipping != DC_RECT) {
            goto ReturnFalse;  // there is complex clipping; let GDI fill the path
        }
        // Clip to the clip rectangle
        ClipRect = pco->rclBounds;
    } else {
        // So the y-clipping code doesn't do any clipping
        // /16 so we don't blow the values out when we scale up to GIQ
        ClipRect.top = (LONG_MIN + 1) / 16; // +1 to avoid compiler problem
        ClipRect.bottom = LONG_MAX / 16;
    }

    // There's nothing to do if there are only one or two points
    if (ppo->cCurves <= 2) {
        goto ReturnTrue;
    }

    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt == DT_DIB)
    {
        return(EngFillPath(pdsurf->pso, ppo, pco, pbo, pptlBrush, mix,
                           flOptions));
    }

    // We'll be drawing to the screen or an off-screen DFB; copy the surface's
    // offset now so that we won't need to refer to the DSURF again:

    ppdev = (PDEV*) pso->dhpdev;
    ppdev->xOffset = pdsurf->poh->x;
    ppdev->yOffset = pdsurf->poh->y;

    pfnFill = ppdev->pfnFillSolid;
    iSolidColor = 0;                            // Assume we won't need a pattern
    bRealizeTransparent = FALSE;

    rop4 = (gaRop3FromMix[mix >> 8] << 8) | gaRop3FromMix[mix & 0xff];

    if (((rop4 >> 8) & 0xff) != (rop4 & 0xff) &&
        !(ppdev->flCaps & CAPS_MONOCHROME_PATTERNS))
    {
        // We're lazy and only do transparent monochrome patterns if we
        // can do 8x8 monochrome patterns using the hardware; otherwise,
        // we punt:

        return(FALSE);
    }

    if ((((rop4 & 0xff00) >> 8) != (rop4 & 0x00ff)) ||
        ((((rop4 >> 4) ^ (rop4)) & 0xf0f) != 0))  // Only do if we need a pattern
    {
        iSolidColor     = pbo->iSolidColor;
        rbc.iSolidColor = iSolidColor;
        if (iSolidColor == -1)
        {
            bRealizeTransparent = (((rop4 >> 8) & 0xff) != (rop4 & 0xff));
            rbc.prb = pbo->pvRbrush;
            if (rbc.prb == NULL)
            {
                rbc.prb = BRUSHOBJ_pvGetRbrush(pbo);
                if (rbc.prb == NULL)
                    return(FALSE);
            }
            pfnFill = rbc.prb->pfnFillPat;

            if ((ppdev->FeatureFlags & EVN_SDRAM_1M) && pfnFill == vM64FillPatColor)
            {
                // The VTA4 can't handle color patterns correctly!!

                return FALSE;
            }
        }
    }

    // Enumerate path here first time to check for special
    // cases (rectangles and monotone polygons)

    // It is too difficult to determine interaction between
    // multiple paths, if there is more than one, skip this

    bMore = PATHOBJ_bEnum(ppo, &pd);

    {
        prclClip = NULL;
        if (jClipping == DC_RECT)
        {
            prclClip = &ClipRect;

            // Our FastFill routine does cross products and intersection
            // calculations assuming it can use 32 bit math and not
            // overflow.  As such, we have to ensure that the bounds of
            // the polygon fit in a 15 bit space, including the 4 bit fix
            // point fraction.  Note that we don't have to do this check
            // for trivial clipping, because we'll assume the screen
            // dimensions are 2048 x 2048 or smaller.  Plus, since we're
            // using hardware clipping to handle 'x' clipping, we have to
            // ensure that the 'x' coordinates are within reasonable bounds:

            PATHOBJ_vGetBounds(ppo, &rcfxBounds);

            // Don't forget that coordinates are in 28.4 format, so multiply
            // constants by 16:

            if ((rcfxBounds.xLeft   < F * MIN_INTEGER_BOUND) ||
                (rcfxBounds.yTop    < F * MIN_INTEGER_BOUND) ||
                (rcfxBounds.xRight  > F * MAX_INTEGER_BOUND) ||
                (rcfxBounds.yBottom > F * MAX_INTEGER_BOUND))
                goto SkipFastFill;
        }

        if (bMore)
        {
            // FastFill only knows how to take a single contiguous buffer
            // of points.  Unfortunately, GDI sometimes hands us paths
            // that are split over multiple path data records.  Convex
            // figures such as Ellipses, Pies and RoundRects are almost
            // always given in multiple records.  Since probably 90% of
            // multiple record paths could still be done by FastFill, for
            // those cases we simply copy the points into a contiguous
            // buffer...

            // First make sure that the entire path would fit in the
            // temporary buffer, and make sure the path isn't comprised
            // of more than one subpath:

            if ((ppo->cCurves >= NUM_BUFFER_POINTS) ||
                (pd.flags & PD_ENDSUBPATH))
                goto SkipFastFill;

            pptfxTmp = &aptfxBuf[0];

            RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);

            pptfxTmp     += pd.count;
            cptfxTmp      = pd.count;
            flFirstRecord = pd.flags;       // Remember PD_BEGINSUBPATH flag

            do {
                bMore = PATHOBJ_bEnum(ppo, &pd);

                RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);
                cptfxTmp += pd.count;
                pptfxTmp += pd.count;
            } while (!(pd.flags & PD_ENDSUBPATH));

            // Fake up the path data record:

            pd.pptfx  = &aptfxBuf[0];
            pd.count  = cptfxTmp;
            pd.flags |= flFirstRecord;

            // If there's more than one subpath, we can't call FastFill:

            if (bMore)
                goto SkipFastFill;
        }

        // We haven't bothered to write monochrome fast fill code, because
        // it's very rare:

        if ((iSolidColor == -1) && (rbc.prb->fl & RBRUSH_2COLOR))
            goto SkipFastFill;

        // Our Mach64 fastfill pattern code uses RotEnable, which breaks
        // Guiman on some cards.  For now, just disable fastfill patterns
        // on Mach64:

        if ((iSolidColor == -1) && (ppdev->iMachType == MACH_MM_64))
            goto SkipFastFill;

        //RKE: do this when we have time
        if (ppdev->iBitmapFormat == BMF_24BPP)
            goto SkipFastFill;

        if (bFastFill(ppdev, pd.count, pd.pptfx, rop4, iSolidColor, rbc.prb,
                      pptlBrush, prclClip))
        {
            return(TRUE);
        }
    }

SkipFastFill:

    // Set up working storage in the temporary buffer

    prclRects = (RECTL*) ppdev->pvTmpBuffer; // storage for list of rectangles to draw

    if (!bMore) {

        RECTL *rectangle;
        INT cPoints = pd.count;

        // The count can't be less than three, because we got all the edges
        // in this subpath, and above we checked that there were at least
        // three edges

        // If the count is four, check to see if the polygon is really a
        // rectangle since we can really speed that up. We'll also check for
        // five with the first and last points the same, because under Win 3.1,
        // it was required to close polygons

        if ((cPoints == 4) ||
           ((cPoints == 5) &&
            (pd.pptfx[0].x == pd.pptfx[4].x) &&
            (pd.pptfx[0].y == pd.pptfx[4].y))) {

            rectangle = prclRects;

      /* we have to start somewhere so assume that most
         applications specify the top left point  first

         we want to check that the first two points are
         either vertically or horizontally aligned.  if
         they are then we check that the last point [3]
         is either horizontally or  vertically  aligned,
         and finally that the 3rd point [2] is  aligned
         with both the first point and the  last  point */

#define FIX_SHIFT 4L
#define FIX_MASK (- (1 << FIX_SHIFT))

         rectangle->top   = pd.pptfx[0].y - 1 & FIX_MASK;
         rectangle->left  = pd.pptfx[0].x - 1 & FIX_MASK;
         rectangle->right = pd.pptfx[1].x - 1 & FIX_MASK;

         if (rectangle->left ^ rectangle->right) {
            if (rectangle->top  ^ (pd.pptfx[1].y - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->left ^ (pd.pptfx[3].x - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->right ^ (pd.pptfx[2].x - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[2].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;
         }
         else {
            if (rectangle->top ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[1].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[2].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->right = pd.pptfx[2].x - 1 & FIX_MASK;
            if (rectangle->right ^ (pd.pptfx[3].x - 1 & FIX_MASK))
                goto not_rectangle;
         }

      /* if the left is greater than the right then
         swap them so the blt code doesn't wig  out */

         if (rectangle->left > rectangle->right) {
            FIX temp;

            temp = rectangle->left;
            rectangle->left = rectangle->right;
            rectangle->right = temp;
         }
         else {

         /* if left == right there's nothing to draw */

            if (rectangle->left == rectangle->right) {
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->left  = (rectangle->left  >> FIX_SHIFT) + 1;
         rectangle->right = (rectangle->right >> FIX_SHIFT) + 1;

         if (rectangle->top > rectangle->bottom) {
            FIX temp;

            temp = rectangle->top;
            rectangle->top = rectangle->bottom;
            rectangle->bottom = temp;
         }
         else {
            if (rectangle->top == rectangle->bottom) {
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->top    = (rectangle->top    >> FIX_SHIFT) + 1;
         rectangle->bottom = (rectangle->bottom >> FIX_SHIFT) + 1;

         // Finally, check for clipping
         if (jClipping == DC_RECT) {
            // Clip to the clip rectangle
            if (!bIntersect(rectangle, &ClipRect, rectangle)) {
                // Totally clipped, nothing to do
                goto ReturnTrue;
            }
         }

      /* if we get here then the polygon is a rectangle,
         set count to 1 and  goto  bottom  to  draw  it */

         ulNumRects = 1;
         goto draw_remaining_rectangles;
      }

not_rectangle:

        ;

    }

    // Do we have enough memory for all the edges?
    // LATER does cCurves include closure?
    if (ppo->cCurves > MAX_EDGES) {
        //
        // try to allocate enough memory
        //
        pFreeEdges = AtiAllocMem(LMEM_FIXED, 0, ppo->cCurves * sizeof(EDGE));

        if (pFreeEdges == NULL)
        {
            goto ReturnFalse;  // too many edges; let GDI fill the path
        }
        else
        {
            bMemAlloced = TRUE;
        }
    }
    else {
        pFreeEdges = (EDGE*) ((BYTE*) ppdev->pvTmpBuffer + RECT_BYTES);
            // use our handy temporary buffer (it's big enough)
    }

    // Initialize an empty list of rectangles to fill
    ulNumRects = 0;

    // Enumerate the path edges and build a Global Edge Table (GET) from them
    // in YX-sorted order.
    pGETHead = &GETHead;
    if (!ConstructGET(pGETHead, pFreeEdges, ppo, &pd, bMore, &ClipRect)) {
        goto ReturnFalse;  // outside GDI's 2**27 range
    }

    // Create an empty AET with the head node also a tail sentinel
    pAETHead = &AETHead;
    AETHead.pNext = pAETHead;  // mark that the AET is empty
    AETHead.X = 0x7FFFFFFF;    // this is greater than any valid X value, so
                               //  searches will always terminate

    // Top scan of polygon is the top of the first edge we come to
    iCurrentY = ((EDGE *)GETHead.pNext)->Y;

    // Loop through all the scans in the polygon, adding edges from the GET to
    // the Active Edge Table (AET) as we come to their starts, and scanning out
    // the AET at each scan into a rectangle list. Each time it fills up, the
    // rectangle list is passed to the filling routine, and then once again at
    // the end if any rectangles remain undrawn. We continue so long as there
    // are edges to be scanned out
    while (1) {

        // Advance the edges in the AET one scan, discarding any that have
        // reached the end (if there are any edges in the AET)
        if (AETHead.pNext != pAETHead) {
            AdvanceAETEdges(pAETHead);
        }

        // If the AET is empty, done if the GET is empty, else jump ahead to
        // the next edge in the GET; if the AET isn't empty, re-sort the AET
        if (AETHead.pNext == pAETHead) {
            if (GETHead.pNext == pGETHead) {
                // Done if there are no edges in either the AET or the GET
                break;
            }
            // There are no edges in the AET, so jump ahead to the next edge in
            // the GET
            iCurrentY = ((EDGE *)GETHead.pNext)->Y;
        } else {
            // Re-sort the edges in the AET by X coordinate, if there are at
            // least two edges in the AET (there could be one edge if the
            // balancing edge hasn't yet been added from the GET)
            if (((EDGE *)AETHead.pNext)->pNext != pAETHead) {
                XSortAETEdges(pAETHead);
            }
        }

        // Move any new edges that start on this scan from the GET to the AET;
        // bother calling only if there's at least one edge to add
        if (((EDGE *)GETHead.pNext)->Y == iCurrentY) {
            MoveNewEdges(pGETHead, pAETHead, iCurrentY);
        }

        // Scan the AET into rectangles to fill (there's always at least one
        // edge pair in the AET)
        pCurrentEdge = AETHead.pNext;   // point to the first edge
        do {

            INT iLeftEdge;

            // The left edge of any given edge pair is easy to find; it's just
            // wherever we happen to be currently
            iLeftEdge = pCurrentEdge->X;

            // Find the matching right edge according to the current fill rule
            if ((flOptions & FP_WINDINGMODE) != 0) {

                INT iWindingCount;

                // Do winding fill; scan across until we've found equal numbers
                // of up and down edges
                iWindingCount = pCurrentEdge->iWindingDirection;
                do {
                    pCurrentEdge = pCurrentEdge->pNext;
                    iWindingCount += pCurrentEdge->iWindingDirection;
                } while (iWindingCount != 0);
            } else {
                // Odd-even fill; the next edge is the matching right edge
                pCurrentEdge = pCurrentEdge->pNext;
            }

            // See if the resulting span encompasses at least one pixel, and
            // add it to the list of rectangles to draw if so
            if (iLeftEdge < pCurrentEdge->X) {

                // We've got an edge pair to add to the list to be filled; see
                // if there's room for one more rectangle
                if (ulNumRects >= MAX_PATH_RECTS) {
                    // No more room; draw the rectangles in the list and reset
                    // it to empty

                    (*pfnFill)(ppdev, ulNumRects, prclRects, rop4, rbc,
                               pptlBrush);

                    // Reset the list to empty
                    ulNumRects = 0;
                }

                // Add the rectangle representing the current edge pair
                if (jClipping == DC_RECT) {
                    // Clipped
                    // Clip to left
                    prclRects[ulNumRects].left = max(iLeftEdge, ClipRect.left);
                    // Clip to right
                    prclRects[ulNumRects].right =
                            min(pCurrentEdge->X, ClipRect.right);
                    // Draw only if not fully clipped
                    if (prclRects[ulNumRects].left <
                            prclRects[ulNumRects].right) {
                        prclRects[ulNumRects].top = iCurrentY;
                        prclRects[ulNumRects].bottom = iCurrentY+1;
                        ulNumRects++;
                    }
                }
                else
                {
                    // Unclipped
                    prclRects[ulNumRects].top = iCurrentY;
                    prclRects[ulNumRects].bottom = iCurrentY+1;
                    prclRects[ulNumRects].left = iLeftEdge;
                    prclRects[ulNumRects].right = pCurrentEdge->X;
                    ulNumRects++;
                }
            }
        } while ((pCurrentEdge = pCurrentEdge->pNext) != pAETHead);

        iCurrentY++;    // next scan
    }

/* draw the remaining rectangles,  if there are any */

draw_remaining_rectangles:

    if (ulNumRects > 0) {
        (*pfnFill)(ppdev, ulNumRects, prclRects, rop4, rbc, pptlBrush);
    }

ReturnTrue:
    bRetVal = TRUE; // done successfully

ReturnFalse:

    // bRetVal is originally false.  If you jumped to ReturnFalse from somewhere,
    // then it will remain false, and be returned.

    if (bMemAlloced)
    {
        //
        // we did allocate memory, so release it
        //
        AtiFreeMem (pFreeEdges);
    }

    return(bRetVal);
}

// Advance the edges in the AET to the next scan, dropping any for which we've
// done all scans. Assumes there is at least one edge in the AET.
VOID AdvanceAETEdges(EDGE *pAETHead)
{
    EDGE *pLastEdge, *pCurrentEdge;

    pLastEdge = pAETHead;
    pCurrentEdge = pLastEdge->pNext;
    do {

        // Count down this edge's remaining scans
        if (--pCurrentEdge->iScansLeft == 0) {
            // We've done all scans for this edge; drop this edge from the AET
            pLastEdge->pNext = pCurrentEdge->pNext;
        } else {
            // Advance the edge's X coordinate for a 1-scan Y advance
            // Advance by the minimum amount
            pCurrentEdge->X += pCurrentEdge->iXWhole;
            // Advance the error term and see if we got one extra pixel this
            // time
            pCurrentEdge->iErrorTerm += pCurrentEdge->iErrorAdjustUp;
            if (pCurrentEdge->iErrorTerm >= 0) {
                // The error term turned over, so adjust the error term and
                // advance the extra pixel
                pCurrentEdge->iErrorTerm -= pCurrentEdge->iErrorAdjustDown;
                pCurrentEdge->X += pCurrentEdge->iXDirection;
            }

            pLastEdge = pCurrentEdge;
        }
    } while ((pCurrentEdge = pLastEdge->pNext) != pAETHead);
}

// X-sort the AET, because the edges may have moved around relative to
// one another when we advanced them. We'll use a multipass bubble
// sort, which is actually okay for this application because edges
// rarely move relative to one another, so we usually do just one pass.
// Also, this makes it easy to keep just a singly-linked list. Assumes there
// are at least two edges in the AET.
VOID XSortAETEdges(EDGE *pAETHead)
{
    BOOL bEdgesSwapped;
    EDGE *pLastEdge, *pCurrentEdge, *pNextEdge;

    do {

        bEdgesSwapped = FALSE;
        pLastEdge = pAETHead;
        pCurrentEdge = pLastEdge->pNext;
        pNextEdge = pCurrentEdge->pNext;

        do {
            if (pNextEdge->X < pCurrentEdge->X) {

                // Next edge is to the left of the current edge; swap them
                pLastEdge->pNext = pNextEdge;
                pCurrentEdge->pNext = pNextEdge->pNext;
                pNextEdge->pNext = pCurrentEdge;
                bEdgesSwapped = TRUE;
                pCurrentEdge = pNextEdge;   // continue sorting before the edge
                                            //  we just swapped; it might move
                                            //  farther yet
            }
            pLastEdge = pCurrentEdge;
            pCurrentEdge = pLastEdge->pNext;
        } while ((pNextEdge = pCurrentEdge->pNext) != pAETHead);
    } while (bEdgesSwapped);
}

// Moves all edges that start on the current scan from the GET to the AET in
// X-sorted order. Parameters are pointer to head of GET and pointer to dummy
// edge at head of AET, plus current scan line. Assumes there's at least one
// edge to be moved.
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY)
{
    EDGE *pCurrentEdge = pAETHead;
    EDGE *pGETNext = pGETHead->pNext;

    do {

        // Scan through the AET until the X-sorted insertion point for this
        // edge is found. We can continue from where the last search left
        // off because the edges in the GET are in X sorted order, as is
        // the AET. The search always terminates because the AET sentinel
        // is greater than any valid X
        while (pGETNext->X > ((EDGE *)pCurrentEdge->pNext)->X) {
            pCurrentEdge = pCurrentEdge->pNext;
        }

        // We've found the insertion point; add the GET edge to the AET, and
        // remove it from the GET
        pGETHead->pNext = pGETNext->pNext;
        pGETNext->pNext = pCurrentEdge->pNext;
        pCurrentEdge->pNext = pGETNext;
        pCurrentEdge = pGETNext;    // continue insertion search for the next
                                    //  GET edge after the edge we just added
        pGETNext = pGETHead->pNext;

    } while (pGETNext->Y == iCurrentY);
}





// Build the Global Edge Table from the path. There must be enough memory in
// the free edge area to hold all edges. The GET is constructed in Y-X order,
// and has a head/tail/sentinel node at pGETHead.

BOOL ConstructGET(
   EDGE     *pGETHead,
   EDGE     *pFreeEdges,
   PATHOBJ  *ppo,
   PATHDATA *pd,
   BOOL      bMore,
   RECTL    *pClipRect)
{
   POINTFIX pfxPathStart;    // point that started the current subpath
   POINTFIX pfxPathPrevious; // point before the current point in a subpath;
                              //  starts the current edge

/* Create an empty GET with the head node also a tail sentinel */

   pGETHead->pNext = pGETHead; // mark that the GET is empty
   pGETHead->Y = 0x7FFFFFFF;   // this is greater than any valid Y value, so
                                //  searches will always terminate

/* PATHOBJ_vEnumStart is implicitly  performed  by  engine
   already and first path  is  enumerated  by  the  caller */

next_subpath:

/* Make sure the PATHDATA is not empty (is this necessary) */

   if (pd->count != 0) {

   /* If first point starts a subpath, remember it as such
      and go on to the next point,   so we can get an edge */

      if (pd->flags & PD_BEGINSUBPATH) {

      /* the first point starts the subpath;   remember it */


         pfxPathStart    = *pd->pptfx; /* the subpath starts here          */
         pfxPathPrevious = *pd->pptfx; /* this points starts the next edge */
         pd->pptfx++;                  /* advance to the next point        */
         pd->count--;                  /* count off this point             */
      }


   /* add edges in PATHDATA to GET,  in Y-X  sorted  order */

      while (pd->count--) {
        if ((pFreeEdges =
            AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious, pd->pptfx,
                         pClipRect)) == NULL) {
            goto ReturnFalse;
        }
        pfxPathPrevious = *pd->pptfx; /* current point becomes previous   */
        pd->pptfx++;                  /* advance to the next point        */
      }


   /* If last point ends the subpath, insert the edge that
      connects to first point  (is this built in already?) */

      if (pd->flags & PD_ENDSUBPATH) {
         if ((pFreeEdges = AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious,
                                   &pfxPathStart, pClipRect)) == NULL) {
            goto ReturnFalse;
        }
      }
   }

/* the initial loop conditions preclude a do, while or for */

   if (bMore) {
       bMore = PATHOBJ_bEnum(ppo, pd);
       goto next_subpath;
   }

    return(TRUE);   // done successfully

ReturnFalse:
    return(FALSE);  // failed
}

// Adds the edge described by the two passed-in points to the Global Edge
// Table, if the edge spans at least one pixel vertically.
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge,
        POINTFIX *ppfxEdgeStart, POINTFIX *ppfxEdgeEnd, RECTL *pClipRect)
{
    INT iYStart, iYEnd, iXStart, iXEnd, iYHeight, iXWidth;
    INT yJump, yTop;

    // Set the winding-rule direction of the edge, and put the endpoints in
    // top-to-bottom order
    iYHeight = ppfxEdgeEnd->y - ppfxEdgeStart->y;
    if (iYHeight == 0) {
        return(pFreeEdge);  // zero height; ignore this edge
    } else if (iYHeight >= 0) {
        iXStart = ppfxEdgeStart->x;
        iYStart = ppfxEdgeStart->y;
        iXEnd = ppfxEdgeEnd->x;
        iYEnd = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = 1;
    } else {
        iYHeight = -iYHeight;
        iXEnd = ppfxEdgeStart->x;
        iYEnd = ppfxEdgeStart->y;
        iXStart = ppfxEdgeEnd->x;
        iYStart = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = -1;
    }

    if (iYHeight & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    // Set the error term and adjustment factors, all in GIQ coordinates for
    // now
    iXWidth = iXEnd - iXStart;
    if (iXWidth >= 0) {
        // Left to right, so we change X as soon as we move at all
        pFreeEdge->iXDirection = 1;
        pFreeEdge->iErrorTerm = -1;
    } else {
        // Right to left, so we don't change X until we've moved a full GIQ
        // coordinate
        iXWidth = -iXWidth;
        pFreeEdge->iXDirection = -1;
        pFreeEdge->iErrorTerm = -iYHeight;
    }

    if (iXWidth & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    if (iXWidth >= iYHeight) {
        // Calculate base run length (minimum distance advanced in X for a 1-
        // scan advance in Y)
        pFreeEdge->iXWhole = iXWidth / iYHeight;
        // Add sign back into base run length if going right to left
        if (pFreeEdge->iXDirection == -1) {
            pFreeEdge->iXWhole = -pFreeEdge->iXWhole;
        }
        pFreeEdge->iErrorAdjustUp = iXWidth % iYHeight;
    } else {
        // Base run length is 0, because line is closer to vertical than
        // horizontal
        pFreeEdge->iXWhole = 0;
        pFreeEdge->iErrorAdjustUp = iXWidth;
    }
    pFreeEdge->iErrorAdjustDown = iYHeight;

    // Calculate the number of pixels spanned by this edge, accounting for
    // clipping

    // Top true pixel scan in GIQ coordinates
    // Shifting to divide and multiply by 16 is okay because the clip rect
    // always contains positive numbers
    yTop = max(pClipRect->top << 4, (iYStart + 15) & ~0x0F);
    pFreeEdge->Y = yTop >> 4;    // initial scan line on which to fill edge

    // Calculate # of scans to actually fill, accounting for clipping
    if ((pFreeEdge->iScansLeft = min(pClipRect->bottom, ((iYEnd + 15) >> 4))
            - pFreeEdge->Y) <= 0) {

        return(pFreeEdge);  // no pixels at all are spanned, so we can
                            // ignore this edge
    }

    // If the edge doesn't start on a pixel scan (that is, it starts at a
    // fractional GIQ coordinate), advance it to the first pixel scan it
    // intersects. Ditto if there's top clipping. Also clip to the bottom if
    // needed

    if (iYStart != yTop) {
        // Jump ahead by the Y distance in GIQ coordinates to the first pixel
        // to draw
        yJump = yTop - iYStart;

        // Advance x the minimum amount for the number of scans traversed
        iXStart += pFreeEdge->iXWhole * yJump;

        AdjustErrorTerm(&pFreeEdge->iErrorTerm, pFreeEdge->iErrorAdjustUp,
                        pFreeEdge->iErrorAdjustDown, yJump, &iXStart,
                        pFreeEdge->iXDirection);
    }
    // Turn the calculations into pixel rather than GIQ calculations

    // Move the X coordinate to the nearest pixel, and adjust the error term
    // accordingly
    // Dividing by 16 with a shift is okay because X is always positive
    pFreeEdge->X = (iXStart + 15) >> 4; // convert from GIQ to pixel coordinates

    // LATER adjust only if needed (if prestepped above)?
    if (pFreeEdge->iXDirection == 1) {
        // Left to right
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                (((iXStart + 15) & ~0x0F) - iXStart);
    } else {
        // Right to left
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                ((iXStart - 1) & 0x0F);
    }

    // Scale the error term down 16 times to switch from GIQ to pixels.
    // Shifts work to do the multiplying because these values are always
    // non-negative
    pFreeEdge->iErrorTerm >>= 4;

    // Insert the edge into the GET in YX-sorted order. The search always ends
    // because the GET has a sentinel with a greater-than-possible Y value
    while ((pFreeEdge->Y > ((EDGE *)pGETHead->pNext)->Y) ||
            ((pFreeEdge->Y == ((EDGE *)pGETHead->pNext)->Y) &&
            (pFreeEdge->X > ((EDGE *)pGETHead->pNext)->X))) {
        pGETHead = pGETHead->pNext;
    }

    pFreeEdge->pNext = pGETHead->pNext; // link the edge into the GET
    pGETHead->pNext = pFreeEdge;

    return(++pFreeEdge);    // point to the next edge storage location for next
                            //  time
}

// Adjust the error term for a skip ahead in y.

void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection)
{
    LONGLONG llErrorTerm;
    INT NumAdjustDowns;

    llErrorTerm = *pErrorTerm;

    // Adjust the error term up by the number of y coordinates we'll skip
    llErrorTerm += Int32x32To64(iErrorAdjustUp,yJump);

    // See if the error term turned over even once while skipping
    if (llErrorTerm >= 0) {
        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        NumAdjustDowns = (UInt64Div32To32(llErrorTerm,iErrorAdjustDown)) + 1;

        // Advance x appropriately for the # of times the error term
        // turned over
        if (iXDirection == 1) {
            *pXStart += NumAdjustDowns;
        } else {
            *pXStart -= NumAdjustDowns;
        }

        // Adjust the error term down to its proper post-skip value
        llErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
    }

    *pErrorTerm = (INT) llErrorTerm;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\lines.c ===
/*************************************************************************\
* Module Name: Lines.c
*
* Contains most of the required GDI line support.  Supports drawing
* lines in short 'strips' when clipping is complex or coordinates
* are too large to be drawn by the line hardware.
*
* Copyright (c) 1990-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

///////////////////////////////////////////////////////////////////////

// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit
// signed LONGLONGs and 64-bit unsigned DWORDLONGs.
//
// UUInt32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies
//      two 32-bit ULONGs to produce a 64-bit DWORDLONG result.
//
// UInt64By32To32 is our own macro to divide a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// UInt64Mod32To32 is our own macro to modulus a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// 64 bit divides are usually very expensive.  Since it's very rare
// that we'll get lines where the upper 32 bits of the 64 bit result
// are used, we can almost always use 32-bit ULONG divides.  We still
// must correctly handle the larger cases:

#define UInt64Div32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define UInt64Mod32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) % (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) % (ULONG)(b)))

#define SWAPL(x,y,t)        {t = x; x = y; y = t;}

FLONG gaflRound[] = {
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // no flips
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_V
    FL_V_ROUND_DOWN,                   // FL_FLIP_V | FL_FLIP_D
    FL_V_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE
    0xbaadf00d,                        // FL_FLIP_SLOPE_ONE | FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE | FL_FLIP_V
    0xbaadf00d                         // FL_FLIP_SLOPE_ONE | FL_FLIP_V | FL_FLIP_D
};

//////////////////////////////////////////////////////////////////////////
// General defines for bHardwareLine

BOOL bHardwareLine(PDEV*, POINTFIX*, POINTFIX*, LONG, MIX, RECTL*);

#define HW_FLIP_D           0x0001L     // Diagonal flip
#define HW_FLIP_V           0x0002L     // Vertical flip
#define HW_FLIP_H           0x0004L     // Horizontal flip
#define HW_FLIP_SLOPE_ONE   0x0008L     // Normalized line has exactly slope one
#define HW_FLIP_MASK        (HW_FLIP_D | HW_FLIP_V | HW_FLIP_H)

#define HW_X_ROUND_DOWN     0x0100L     // x = 1/2 rounds down in value
#define HW_Y_ROUND_DOWN     0x0200L     // y = 1/2 rounds down in value

LONG gaiDir[] = { 0, 1, 7, 6, 3, 2, 4, 5 };

FLONG gaflHardwareRound[] = {
    HW_X_ROUND_DOWN | HW_Y_ROUND_DOWN,  //           |        |        |
    HW_X_ROUND_DOWN | HW_Y_ROUND_DOWN,  //           |        |        | FLIP_D
    HW_X_ROUND_DOWN,                    //           |        | FLIP_V |
    HW_Y_ROUND_DOWN,                    //           |        | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    //           | FLIP_H |        |
    HW_X_ROUND_DOWN,                    //           | FLIP_H |        | FLIP_D
    0,                                  //           | FLIP_H | FLIP_V |
    0,                                  //           | FLIP_H | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    // SLOPE_ONE |        |        |
    0xffffffff,                         // SLOPE_ONE |        |        | FLIP_D
    HW_X_ROUND_DOWN,                    // SLOPE_ONE |        | FLIP_V |
    0xffffffff,                         // SLOPE_ONE |        | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    // SLOPE_ONE | FLIP_H |        |
    0xffffffff,                         // SLOPE_ONE | FLIP_H |        | FLIP_D
    HW_X_ROUND_DOWN,                    // SLOPE_ONE | FLIP_H | FLIP_V |
    0xffffffff                          // SLOPE_ONE | FLIP_H | FLIP_V | FLIP_D
};

//////////////////////////////////////////////////////////////////////////
// ATI specific defines

// The Mach32 hardware can have 12 bits of significance for the error and
// step terms:

#define NUM_DDA_BITS 12

LONG gai32Direction[] = {
    LAST_PEL_OFF | XPOSITIVE | YPOSITIVE |      0,   // Octant 0
    LAST_PEL_OFF | XPOSITIVE | YPOSITIVE | YMAJOR,   // Octant 1
    LAST_PEL_OFF | XPOSITIVE |         0 |      0,   // Octant 7
    LAST_PEL_OFF | XPOSITIVE |         0 | YMAJOR,   // Octant 6
    LAST_PEL_OFF |         0 | YPOSITIVE |      0,   // Octant 3
    LAST_PEL_OFF |         0 | YPOSITIVE | YMAJOR,   // Octant 2
    LAST_PEL_OFF |         0 |         0 |      0,   // Octant 4
    LAST_PEL_OFF |         0 |         0 | YMAJOR,   // Octant 5
};

LONG gai64Direction[] = {
    DST_CNTL_LastPel | DST_CNTL_XDir | DST_CNTL_YDir |               0,
    DST_CNTL_LastPel | DST_CNTL_XDir | DST_CNTL_YDir | DST_CNTL_YMajor,
    DST_CNTL_LastPel | DST_CNTL_XDir |             0 |               0,
    DST_CNTL_LastPel | DST_CNTL_XDir |             0 | DST_CNTL_YMajor,
    DST_CNTL_LastPel |             0 | DST_CNTL_YDir |               0,
    DST_CNTL_LastPel |             0 | DST_CNTL_YDir | DST_CNTL_YMajor,
    DST_CNTL_LastPel |             0 |             0 |               0,
    DST_CNTL_LastPel |             0 |             0 | DST_CNTL_YMajor,
};

/******************************Public*Routine******************************\
* BOOL bLines(ppdev, pptfxFirst, pptfxBuf, cptfx, pls,
*                   prclClip, apfn[], flStart)
*
* Computes the DDA for the line and gets ready to draw it.  Puts the
* pixel data into an array of strips, and calls a strip routine to
* do the actual drawing.
*
* Doing NT Lines Right
* --------------------
*
* In NT, all lines are given to the device driver in fractional
* coordinates, in a 28.4 fixed point format.  The lower 4 bits are
* fractional for sub-pixel positioning.
*
* Note that you CANNOT! just round the coordinates to integers
* and pass the results to your favorite integer Bresenham routine!!
* (Unless, of course, you have such a high resolution device that
* nobody will notice -- not likely for a display device.)  The
* fractions give a more accurate rendering of the line -- this is
* important for things like our Bezier curves, which would have 'kinks'
* if the points in its polyline approximation were rounded to integers.
*
* Unfortunately, for fractional lines there is more setup work to do
* a DDA than for integer lines.  However, the main loop is exactly
* the same (and can be done entirely with 32 bit math).
*
* If You've Got Hardware That Does Bresenham
* ------------------------------------------
*
* A lot of hardware limits DDA error terms to 'n' bits.  With fractional
* coordinates, 4 bits are given to the fractional part, letting
* you draw in hardware only those lines that lie entirely in a 2^(n-4)
* by 2^(n-4) pixel space.
*
* And you still have to correctly draw those lines with coordinates
* outside that space!  Remember that the screen is only a viewport
* onto a 28.4 by 28.4 space -- if any part of the line is visible
* you MUST render it precisely, regardless of where the end points lie.
* So even if you do it in software, somewhere you'll have to have a
* 32 bit DDA routine.
*
* Our Implementation
* ------------------
*
* We employ a run length slice algorithm: our DDA calculates the
* number of pixels that are in each row (or 'strip') of pixels.
*
* We've separated the running of the DDA and the drawing of pixels:
* we run the DDA for several iterations and store the results in
* a 'strip' buffer (which are the lengths of consecutive pixel rows of
* the line), then we crank up a 'strip drawer' that will draw all the
* strips in the buffer.
*
* We also employ a 'half-flip' to reduce the number of strip
* iterations we need to do in the DDA and strip drawing loops: when a
* (normalized) line's slope is more than 1/2, we do a final flip
* about the line y = (1/2)x.  So now, instead of each strip being
* consecutive horizontal or vertical pixel rows, each strip is composed
* of those pixels aligned in 45 degree rows.  So a line like (0, 0) to
* (128, 128) would generate only one strip.
*
* We also always draw only left-to-right.
*
* Styled lines may have arbitrary style patterns.  We specially
* optimize the default patterns (and call them 'masked' styles).
*
* The DDA Derivation
* ------------------
*
* Here is how I like to think of the DDA calculation.
*
* We employ Knuth's "diamond rule": rendering a one-pixel-wide line
* can be thought of as dragging a one-pixel-wide by one-pixel-high
* diamond along the true line.  Pixel centers lie on the integer
* coordinates, and so we light any pixel whose center gets covered
* by the "drag" region (John D. Hobby, Journal of the Association
* for Computing Machinery, Vol. 36, No. 2, April 1989, pp. 209-229).
*
* We must define which pixel gets lit when the true line falls
* exactly half-way between two pixels.  In this case, we follow
* the rule: when two pels are equidistant, the upper or left pel
* is illuminated, unless the slope is exactly one, in which case
* the upper or right pel is illuminated.  (So we make the edges
* of the diamond exclusive, except for the top and left vertices,
* which are inclusive, unless we have slope one.)
*
* This metric decides what pixels should be on any line BEFORE it is
* flipped around for our calculation.  Having a consistent metric
* this way will let our lines blend nicely with our curves.  The
* metric also dictates that we will never have one pixel turned on
* directly above another that's turned on.  We will also never have
* a gap; i.e., there will be exactly one pixel turned on for each
* column between the start and end points.  All that remains to be
* done is to decide how many pixels should be turned on for each row.
*
* So lines we draw will consist of varying numbers of pixels on
* successive rows, for example:
*
*       ******
*             *****
*                  ******
*                        *****
*
* We'll call each set of pixels on a row a "strip".
*
* (Please remember that our coordinate space has the origin as the
* upper left pixel on the screen; postive y is down and positive x
* is right.)
*
* Device coordinates are specified as fixed point 28.4 numbers,
* where the first 28 bits are the integer coordinate, and the last
* 4 bits are the fraction.  So coordinates may be thought of as
* having the form (x, y) = (M/F, N/F) where F is the constant scaling
* factor F = 2^4 = 16, and M and N are 32 bit integers.
*
* Consider the line from (M0/F, N0/F) to (M1/F, N1/F) which runs
* left-to-right and whose slope is in the first octant, and let
* dM = M1 - M0 and dN = N1 - N0.  Then dM >= 0, dN >= 0 and dM >= dN.
*
* Since the slope of the line is less than 1, the edges of the
* drag region are created by the top and bottom vertices of the
* diamond.  At any given pixel row y of the line, we light those
* pixels whose centers are between the left and right edges.
*
* Let mL(n) denote the line representing the left edge of the drag
* region.  On pixel row j, the column of the first pixel to be
* lit is
*
*       iL(j) = ceiling( mL(j * F) / F)
*
* Since the line's slope is less than one:
*
*       iL(j) = ceiling( mL([j + 1/2] F) / F )
*
* Recall the formula for our line:
*
*       n(m) = (dN / dM) (m - M0) + N0
*
*       m(n) = (dM / dN) (n - N0) + M0
*
* Since the line's slope is less than one, the line representing
* the left edge of the drag region is the original line offset
* by 1/2 pixel in the y direction:
*
*       mL(n) = (dM / dN) (n - F/2 - N0) + M0
*
* From this we can figure out the column of the first pixel that
* will be lit on row j, being careful of rounding (if the left
* edge lands exactly on an integer point, the pixel at that
* point is not lit because of our rounding convention):
*
*       iL(j) = floor( mL(j F) / F ) + 1
*
*             = floor( ((dM / dN) (j F - F/2 - N0) + M0) / F ) + 1
*
*             = floor( F dM j - F/2 dM - N0 dM + dN M0) / F dN ) + 1
*
*                      F dM j - [ dM (N0 + F/2) - dN M0 ]
*             = floor( ---------------------------------- ) + 1
*                                   F dN
*
*                      dM j - [ dM (N0 + F/2) - dN M0 ] / F
*             = floor( ------------------------------------ ) + 1       (1)
*                                     dN
*
*             = floor( (dM j + alpha) / dN ) + 1
*
* where
*
*       alpha = - [ dM (N0 + F/2) - dN M0 ] / F
*
* We use equation (1) to calculate the DDA: there are iL(j+1) - iL(j)
* pixels in row j.  Because we are always calculating iL(j) for
* integer quantities of j, we note that the only fractional term
* is constant, and so we can 'throw away' the fractional bits of
* alpha:
*
*       beta = floor( - [ dM (N0 + F/2) - dN M0 ] / F )                 (2)
*
* so
*
*       iL(j) = floor( (dM j + beta) / dN ) + 1                         (3)
*
* for integers j.
*
* Note if iR(j) is the line's rightmost pixel on row j, that
* iR(j) = iL(j + 1) - 1.
*
* Similarly, rewriting equation (1) as a function of column i,
* we can determine, given column i, on which pixel row j is the line
* lit:
*
*                       dN i + [ dM (N0 + F/2) - dN M0 ] / F
*       j(i) = ceiling( ------------------------------------ ) - 1
*                                       dM
*
* Floors are easier to compute, so we can rewrite this:
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F
*       j(i) = floor( ----------------------------------------------- ) - 1
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F - dM
*            = floor( ---------------------------------------------------- )
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 - 1 ] / F
*            = floor( ---------------------------------------- )
*                                       dM
*
* We can once again wave our hands and throw away the fractional bits
* of the remainder term:
*
*       j(i) = floor( (dN i + gamma) / dM )                             (4)
*
* where
*
*       gamma = floor( [ dM (N0 + F/2) - dN M0 - 1 ] / F )              (5)
*
* We now note that
*
*       beta = -gamma - 1 = ~gamma                                      (6)
*
* To draw the pixels of the line, we could evaluate (3) on every scan
* line to determine where the strip starts.  Of course, we don't want
* to do that because that would involve a multiply and divide for every
* scan.  So we do everything incrementally.
*
* We would like to easily compute c , the number of pixels on scan j:
*                                  j
*
*    c  = iL(j + 1) - iL(j)
*     j
*
*       = floor((dM (j + 1) + beta) / dN) - floor((dM j + beta) / dN)   (7)
*
* This may be rewritten as
*
*    c  = floor(i    + r    / dN) - floor(i  + r  / dN)                 (8)
*     j          j+1    j+1                j    j
*
* where i , i    are integers and r  < dN, r    < dN.
*        j   j+1                   j        j+1
*
* Rewriting (7) again:
*
*    c  = floor(i  + r  / dN + dM / dN) - floor(i  + r  / dN)
*     j          j    j                          j    j
*
*
*       = floor((r  + dM) / dN) - floor(r  / dN)
*                 j                      j
*
* This may be rewritten as
*
*    c  = dI + floor((r  + dR) / dN) - floor(r  / dN)
*     j                j                      j
*
* where dI + dR / dN = dM / dN, dI is an integer and dR < dN.
*
* r  is the remainder (or "error") term in the DDA loop: r  / dN
*  j                                                      j
* is the exact fraction of a pixel at which the strip ends.  To go
* on to the next scan and compute c    we need to know r   .
*                                  j+1                  j+1
*
* So in the main loop of the DDA:
*
*    c  = dI + floor((r  + dR) / dN) and r    = (r  + dR) % dN
*     j                j                  j+1     j
*
* and we know r  < dN, r    < dN, and dR < dN.
*              j        j+1
*
* We have derived the DDA only for lines in the first octant; to
* handle other octants we do the common trick of flipping the line
* to the first octant by first making the line left-to-right by
* exchanging the end-points, then flipping about the lines y = 0 and
* y = x, as necessary.  We must record the transformation so we can
* undo them later.
*
* We must also be careful of how the flips affect our rounding.  If
* to get the line to the first octant we flipped about x = 0, we now
* have to be careful to round a y value of 1/2 up instead of down as
* we would for a line originally in the first octant (recall that
* "In the case where two pels are equidistant, the upper or left
* pel is illuminated...").
*
* To account for this rounding when running the DDA, we shift the line
* (or not) in the y direction by the smallest amount possible.  That
* takes care of rounding for the DDA, but we still have to be careful
* about the rounding when determining the first and last pixels to be
* lit in the line.
*
* Determining The First And Last Pixels In The Line
* -------------------------------------------------
*
* Fractional coordinates also make it harder to determine which pixels
* will be the first and last ones in the line.  We've already taken
* the fractional coordinates into account in calculating the DDA, but
* the DDA cannot tell us which are the end pixels because it is quite
* happy to calculate pixels on the line from minus infinity to positive
* infinity.
*
* The diamond rule determines the start and end pixels.  (Recall that
* the sides are exclusive except for the left and top vertices.)
* This convention can be thought of in another way: there are diamonds
* around the pixels, and wherever the true line crosses a diamond,
* that pel is illuminated.
*
* Consider a line where we've done the flips to the first octant, and the
* floor of the start coordinates is the origin:
*
*        +-----------------------> +x
*        |
*        | 0                     1
*        |     0123456789abcdef
*        |
*        |   0 00000000?1111111
*        |   1 00000000 1111111
*        |   2 0000000   111111
*        |   3 000000     11111
*        |   4 00000    ** 1111
*        |   5 0000       ****1
*        |   6 000           1***
*        |   7 00             1  ****
*        |   8 ?                     ***
*        |   9 22             3         ****
*        |   a 222           33             ***
*        |   b 2222         333                ****
*        |   c 22222       3333                    **
*        |   d 222222     33333
*        |   e 2222222   333333
*        |   f 22222222 3333333
*        |
*        | 2                     3
*        v
*        +y
*
* If the start of the line lands on the diamond around pixel 0 (shown by
* the '0' region here), pixel 0 is the first pel in the line.  The same
* is true for the other pels.
*
* A little more work has to be done if the line starts in the
* 'nether-land' between the diamonds (as illustrated by the '*' line):
* the first pel lit is the first diamond crossed by the line (pixel 1 in
* our example).  This calculation is determined by the DDA or slope of
* the line.
*
* If the line starts exactly half way between two adjacent pixels
* (denoted here by the '?' spots), the first pixel is determined by our
* round-down convention (and is dependent on the flips done to
* normalize the line).
*
* Last Pel Exclusive
* ------------------
*
* To eliminate repeatedly lit pels between continuous connected lines,
* we employ a last-pel exclusive convention: if the line ends exactly on
* the diamond around a pel, that pel is not lit.  (This eliminates the
* checks we had in the old code to see if we were re-lighting pels.)
*
* The Half Flip
* -------------
*
* To make our run length algorithm more efficient, we employ a "half
* flip".  If after normalizing to the first octant, the slope is more
* than 1/2, we subtract the y coordinate from the x coordinate.  This
* has the effect of reflecting the coordinates through the line of slope
* 1/2.  Note that the diagonal gets mapped into the x-axis after a half
* flip.
*
* How Many Bits Do We Need, Anyway?
* ---------------------------------
*
* Note that if the line is visible on your screen, you must light up
* exactly the correct pixels, no matter where in the 28.4 x 28.4 device
* space the end points of the line lie (meaning you must handle 32 bit
* DDAs, you can certainly have optimized cases for lesser DDAs).
*
* We move the origin to (floor(M0 / F), floor(N0 / F)), so when we
* calculate gamma from (5), we know that 0 <= M0, N0 < F.  And we
* are in the first octant, so dM >= dN.  Then we know that gamma can
* be in the range [(-1/2)dM, (3/2)dM].  The DDI guarantees us that
* valid lines will have dM and dN values at most 31 bits (unsigned)
* of significance.  So gamma requires 33 bits of significance (we store
* this as a 64 bit number for convenience).
*
* When running through the DDA loop, r  + dR can have a value in the
*                                     j
* range 0 <= r  < 2 dN; thus the result must be a 32 bit unsigned value.
*             j
*
* Testing Lines
* -------------
*
* To be NT compliant, a display driver must exactly adhere to GIQ,
* which means that for any given line, the driver must light exactly
* the same pels as does GDI.  This can be tested using the Guiman tool
* provided elsewhere in the DDK, and 'ZTest', which draws random lines
* on the screen and to a bitmap, and compares the results.
*
* If You've Got Line Hardware
* ---------------------------
*
* If your hardware already adheres to GIQ, you're all set.  Otherwise
* you'll want to look at the sample code and read the following:
*
* 1) You'll want to special case integer-only lines, since they require
*    less processing time and are more common (CAD programs will probably
*    only ever give integer lines).  GDI does not provide a flag saying
*    that all lines in a path are integer lines; consequently, you will
*    have to explicitly check every line.
*
* 2) You are required to correctly draw any line in the 28.4 device
*    space that intersects the viewport.  If you have less than 32 bits
*    of significance in the hardware for the Bresenham terms, extremely
*    long lines would overflow the hardware.  For such (rare) cases, you
*    can fall back to strip-drawing code (or if your display is a frame
*    buffer, fall back to the engine).
*
* 3) If you can explicitly set the Bresenham terms in your hardware, you
*    can draw non-integer lines using the hardware.  If your hardware has
*    'n' bits of precision, you can draw GIQ lines that are up to 2^(n-5)
*    pels long (4 bits are required for the fractional part, and one bit is
*    used as a sign bit).  Note that integer lines don't require the 4
*    fractional bits, so if you special case them as in 1), you can do
*    integer lines that are up to 2^(n - 1) pels long.  See the
*    'bHardwareLine' routine for an example.
*
\**************************************************************************/

BOOL bLines(
PDEV*      ppdev,
POINTFIX*  pptfxFirst,  // Start of first line
POINTFIX*  pptfxBuf,    // Pointer to buffer of all remaining lines
RUN*       prun,        // Pointer to runs if doing complex clipping
ULONG      cptfx,       // Number of points in pptfxBuf or number of runs
                        // in prun
LINESTATE* pls,         // Colour and style info
RECTL*     prclClip,    // Pointer to clip rectangle if doing simple clipping
PFNSTRIP   apfn[],      // Array of strip functions
FLONG      flStart,     // Flags for each line, which is a combination of:
                        //      FL_SIMPLE_CLIP
                        //      FL_COMPLEX_CLIP
                        //      FL_STYLED
                        //      FL_LAST_PEL_INCLUSIVE
                        //        - Should be set only for all integer lines,
                        //          and can't be used with FL_COMPLEX_CLIP
LONG       iSolidColor,
MIX        mix)
{
    ULONG     M0;
    ULONG     dM;
    ULONG     N0;
    ULONG     dN;
    ULONG     dN_Original;
    FLONG     fl;
    LONG      x;
    LONG      y;

    LONGLONG  llBeta;
    LONGLONG  llGamma;
    LONGLONG  dl;
    LONGLONG  ll;

    ULONG     ulDelta;

    ULONG     x0;
    ULONG     y0;
    ULONG     x1;
    ULONG     cStylePels;    // Major length of line in pixels for styling
    ULONG     xStart;
    POINTL    ptlStart;
    STRIP     strip;
    PFNSTRIP  pfn;
    LONG      cPels;
    LONG*     plStrip;
    LONG*     plStripEnd;
    LONG      cStripsInNextRun;

    POINTFIX* pptfxBufEnd = pptfxBuf + cptfx; // Last point in path record
    STYLEPOS  spThis;                         // Style pos for this line

    do {

/***********************************************************************\
* Start the DDA calculations.                                           *
\***********************************************************************/

        M0 = (LONG) pptfxFirst->x;
        dM = (LONG) pptfxBuf->x;

        N0 = (LONG) pptfxFirst->y;
        dN = (LONG) pptfxBuf->y;

        fl = flStart;

        // Check for non-clipped, non-styled integer endpoint lines.
        //
        // 24bpp mach64 lines, clipped or otherwise, must always be handled here!
        // Can't use the strip drawer.

        if ((fl & (FL_CLIP | FL_STYLED)) == 0 || ppdev->iBitmapFormat == BMF_24BPP)
        {
            // Integer end-point lines will probably account for 90% of
            // all lines drawn (curves rendered by GDI will be an
            // exception, and will have fractional GIQ coordinates).
            //
            // As such, we try to special-case integer lines as soon as
            // possible.
            //
            // Unfortunately, the ATI's point-to-point line capability has
            // a rounding convention for rendering tie-breaker pixels that
            // doesn't match that of GDI's, so we can't use it for
            // arbitrary integer lines, otherwise we would fail HCTs.  But
            // since horizontal and vertical lines have no tie-breakers,
            // and probably account for 60% of all lines drawn, we special
            // case them here.  (The 'bHardwareLine' special case a little
            // lower down will handle arbitrary direction lines.)
            //
            // Note: If your hardware can't handle GIQ lines ala
            //       'bHardwareLine,' but can handle the correct rounding
            //       convention, I strongly recommend special-casing
            //       integer lines of arbitrary slope here, too.
            //
            // How can you tell if you have the correct rounding convention?
            // Implement integer lines (they're easy), run Guiman and draw a
            // bunch of Polyline lines in random directions, and then press
            // the 'X' xor button -- if you see random pixels lit up, you've
            // got the wrong convention...

            if (((M0 | dM | N0 | dN) & (F - 1)) == 0 && (fl & FL_CLIP) == 0)
            {
                // -1 for 'iSolidColor' denotes that the currently set
                // colour and mix should be kept:

                ppdev->pfnLineToTrivial(ppdev,
                                        (M0 >> 4) + ppdev->xOffset,
                                        (N0 >> 4) + ppdev->yOffset,
                                        (dM >> 4) + ppdev->xOffset,
                                        (dN >> 4) + ppdev->yOffset,
                                        // 24bpp is only available on the mach64:
                                        (ppdev->iBitmapFormat == BMF_24BPP)? iSolidColor:(ULONG) -1,
                                        mix,
                                        NULL);
                goto Next_Line;
            }

            // Check for fractional endpoint lines that are small enough
            // to use the hardware DDA:

            if (bHardwareLine(ppdev, pptfxFirst, pptfxBuf, iSolidColor, mix, prclClip))
                goto Next_Line;
        }

        if ((LONG) M0 > (LONG) dM)
        {
        // Ensure that we run left-to-right:

            register ULONG ulTmp;
            SWAPL(M0, dM, ulTmp);
            SWAPL(N0, dN, ulTmp);
            fl |= FL_FLIP_H;
        }

    // Compute the delta dx.  The DDI says we can never have a valid delta
    // with a magnitued more than 2^31 - 1, but GDI never actually checks
    // its transforms.  So we have to check for this case to avoid overflow:

        dM -= M0;
        if ((LONG) dM < 0)
        {
            goto Next_Line;
        }

        if ((LONG) dN < (LONG) N0)
        {
        // Line runs from bottom to top, so flip across y = 0:

            N0 = -(LONG) N0;
            dN = -(LONG) dN;
            fl |= FL_FLIP_V;
        }

        dN -= N0;

        if ((LONG) dN < 0)
        {
            goto Next_Line;
        }

    // We now have a line running left-to-right, top-to-bottom from (M0, N0)
    // to (M0 + dM, N0 + dN):

        if (dN >= dM)
        {
            if (dN == dM)
            {
            // Have to special case slopes of one:

                fl |= FL_FLIP_SLOPE_ONE;
            }
            else
            {
            // Since line has slope greater than 1, flip across x = y:

                register ULONG ulTmp;
                SWAPL(dM, dN, ulTmp);
                SWAPL(M0, N0, ulTmp);
                fl |= FL_FLIP_D;
            }
        }

        fl |= gaflRound[(fl & FL_ROUND_MASK) >> FL_ROUND_SHIFT];

        x = LFLOOR((LONG) M0);
        y = LFLOOR((LONG) N0);

        M0 = FXFRAC(M0);
        N0 = FXFRAC(N0);

    // Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ]:

        llGamma = UInt32x32To64(dM, N0 + F/2) - UInt32x32To64(M0, dN);
        if (fl & FL_V_ROUND_DOWN)   // Adjust so y = 1/2 rounds down
        {
            llGamma--;
        }

        llGamma >>= FLOG2;
        llBeta = ~llGamma;

/***********************************************************************\
* Figure out which pixels are at the ends of the line.                  *
\***********************************************************************/

    // The toughest part of GIQ is determining the start and end pels.
    //
    // Our approach here is to calculate x0 and x1 (the inclusive start
    // and end columns of the line respectively, relative to our normalized
    // origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
    // start point is easily calculated by plugging x0 into our line equation
    // (which takes care of whether y = 1/2 rounds up or down in value)
    // getting y0, and then undoing the normalizing flips to get back
    // into device space.
    //
    // We look at the fractional parts of the coordinates of the start and
    // end points, and call them (M0, N0) and (M1, N1) respectively, where
    // 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
    // to determine x0:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 ........?xxxxxxx
    //   |   1 ..........xxxxxx
    //   |   2 ...........xxxxx
    //   |   3 ............xxxx
    //   |   4 .............xxx
    //   |   5 ..............xx
    //   |   6 ...............x
    //   |   7 ................
    //   |   8 ................
    //   |   9 ......**........
    //   |   a ........****...x
    //   |   b ............****
    //   |   c .............xxx****
    //   |   d ............xxxx    ****
    //   |   e ...........xxxxx        ****
    //   |   f ..........xxxxxx
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one require a special case for both the start
    // and end.  For example, if the line ends such that (M1, N1) is (9, 1),
    // the line has gone exactly through (8, 0) -- which may be considered
    // to be part of 'x' because of rounding!  So slopes of exactly slope
    // one going through (8, 0) must also be considered as belonging in 'x'.
    //
    // For lines that go left-to-right, we have the following grid:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 xxxxxxxx?.......
    //   |   1 xxxxxxx.........
    //   |   2 xxxxxx..........
    //   |   3 xxxxx...........
    //   |   4 xxxx............
    //   |   5 xxx.............
    //   |   6 xx..............
    //   |   7 x...............
    //   |   8 x...............
    //   |   9 x.....**........
    //   |   a xx......****....
    //   |   b xxx.........****
    //   |   c xxxx............****
    //   |   d xxxxx...........    ****
    //   |   e xxxxxx..........        ****
    //   |   f xxxxxxx.........
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 0.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) - 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one must be handled similarly to the right-to-
    // left case.

        {

        // Calculate x0, x1

            ULONG N1 = FXFRAC(N0 + dN);
            ULONG M1 = FXFRAC(M0 + dM);

            x1 = LFLOOR(M0 + dM);

            if (fl & FL_LAST_PEL_INCLUSIVE)
            {
            // It sure is easy to compute the first pel when lines have only
            // integer coordinates and are last-pel inclusive:

                x0 = 0;
                y0 = 0;

            // Last-pel inclusive lines that are exactly one pixel long
            // have a 'delta-x' and 'delta-y' equal to zero.  The problem is
            // that our clip code assumes that 'delta-x' is always non-zero
            // (since it never happens with last-pel exclusive lines).  As
            // an inelegant solution, we simply modify 'delta-x' in this
            // case -- because the line is exactly one pixel long, changing
            // the slope will obviously have no effect on rasterization.

                if (x1 == 0)
                {
                    dM      = 1;
                    llGamma = 0;
                    llBeta  = ~llGamma;
                }
            }
            else
            {
                if (fl & FL_FLIP_H)
                {
                // ---------------------------------------------------------------
                // Line runs right-to-left:  <----

                // Compute x1:

                    if (N1 == 0)
                    {
                        if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                        {
                            x1++;
                        }
                    }
                    else if (abs((LONG) (N1 - F/2)) + M1 > F)
                    {
                        x1++;
                    }

                    if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                           == (FL_FLIP_SLOPE_ONE))
                    {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                        if ((N1 > 0) && (M1 == N1 + 8))
                            x1++;

                    // Don't you love special cases?  Is this a rhetorical question?

                        if ((N0 > 0) && (M0 == N0 + 8))
                        {
                            x0      = 2;
                            ulDelta = dN;
                            goto right_to_left_compute_y0;
                        }
                    }

                // Compute x0:

                    x0      = 1;
                    ulDelta = 0;
                    if (N0 == 0)
                    {
                        if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                        {
                            x0      = 2;
                            ulDelta = dN;
                        }
                    }
                    else if (abs((LONG) (N0 - F/2)) + M0 > F)
                    {
                        x0      = 2;
                        ulDelta = dN;
                    }


                // Compute y0:

                right_to_left_compute_y0:

                    y0 = 0;
                    ll = llGamma + (LONGLONG) ulDelta;

                    if (ll >= (LONGLONG) (2 * dM - dN))
                        y0 = 2;
                    else if (ll >= (LONGLONG) (dM - dN))
                        y0 = 1;
                }
                else
                {
                // ---------------------------------------------------------------
                // Line runs left-to-right:  ---->

                // Compute x1:

                    if (!(fl & FL_LAST_PEL_INCLUSIVE))
                        x1--;

                    if (M1 > 0)
                    {
                        if (N1 == 0)
                        {
                            if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                                x1++;
                        }
                        else if (abs((LONG) (N1 - F/2)) <= (LONG) M1)
                        {
                            x1++;
                        }
                    }

                    if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                           == (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                    {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                        if ((M1 > 0) && (N1 == M1 + 8))
                            x1--;

                        if ((M0 > 0) && (N0 == M0 + 8))
                        {
                            x0 = 0;
                            goto left_to_right_compute_y0;
                        }
                    }

                // Compute x0:

                    x0 = 0;
                    if (M0 > 0)
                    {
                        if (N0 == 0)
                        {
                            if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                                x0 = 1;
                        }
                        else if (abs((LONG) (N0 - F/2)) <= (LONG) M0)
                        {
                            x0 = 1;
                        }
                    }

                // Compute y0:

                left_to_right_compute_y0:

                    y0 = 0;
                    if (llGamma >= (LONGLONG) (dM - (dN & (-(LONG) x0))))
                    {
                        y0 = 1;
                    }
                }
            }
        }

        cStylePels = x1 - x0 + 1;
        if ((LONG) cStylePels <= 0)
            goto Next_Line;

        xStart = x0;

/***********************************************************************\
* Complex clipping.                                                     *
\***********************************************************************/

        if (fl & FL_COMPLEX_CLIP)
        {
            dN_Original = dN;

        Continue_Complex_Clipping:

            if (fl & FL_FLIP_H)
            {
            // Line runs right-to-left <-----

                x0 = xStart + cStylePels - prun->iStop - 1;
                x1 = xStart + cStylePels - prun->iStart - 1;
            }
            else
            {
            // Line runs left-to-right ----->

                x0 = xStart + prun->iStart;
                x1 = xStart + prun->iStop;
            }

            prun++;

        // Reset some variables we'll nuke a little later:

            dN          = dN_Original;
            pls->spNext = pls->spComplex;

        // No overflow since large integer math is used.  Both values
        // will be positive:

            dl = UInt32x32To64(x0, dN) + llGamma;

        // y0 = dl / dM:

            y0 = UInt64Div32To32(dl, dM);

            ASSERTDD((LONG) y0 >= 0, "y0 weird: Goofed up end pel calc?");
        }

/***********************************************************************\
* Simple rectangular clipping.                                          *
\***********************************************************************/

        if (fl & FL_SIMPLE_CLIP)
        {
            ULONG y1;
            LONG  xRight;
            LONG  xLeft;
            LONG  yBottom;
            LONG  yTop;

        // Note that y0 and y1 are actually the lower and upper bounds,
        // respectively, of the y coordinates of the line (the line may
        // have actually shrunk due to first/last pel clipping).
        //
        // Also note that x0, y0 are not necessarily zero.

            RECTL* prcl = &prclClip[(fl & FL_RECTLCLIP_MASK) >>
                                    FL_RECTLCLIP_SHIFT];

        // Normalize to the same point we've normalized for the DDA
        // calculations:

            xRight  = prcl->right  - x;
            xLeft   = prcl->left   - x;
            yBottom = prcl->bottom - y;
            yTop    = prcl->top    - y;

            if (yBottom <= (LONG) y0 ||
                xRight  <= (LONG) x0 ||
                xLeft   >  (LONG) x1)
            {
            Totally_Clipped:

                if (fl & FL_STYLED)
                {
                    pls->spNext += cStylePels;
                    if (pls->spNext >= pls->spTotal2)
                        pls->spNext %= pls->spTotal2;
                }

                goto Next_Line;
            }

            if ((LONG) x1 >= xRight)
                x1 = xRight - 1;

        // We have to know the correct y1, which we haven't bothered to
        // calculate up until now.  This multiply and divide is quite
        // expensive; we could replace it with code similar to that which
        // we used for computing y0.
        //
        // The reason why we need the actual value, and not an upper
        // bounds guess like y1 = LFLOOR(dM) + 2 is that we have to be
        // careful when calculating x(y) that y0 <= y <= y1, otherwise
        // we can overflow on the divide (which, needless to say, is very
        // bad).

            dl = UInt32x32To64(x1, dN) + llGamma;

        // y1 = dl / dM:

            y1 = UInt64Div32To32(dl, dM);

            if (yTop > (LONG) y1)
                goto Totally_Clipped;

            if (yBottom <= (LONG) y1)
            {
                y1 = yBottom;
                dl = UInt32x32To64(y1, dM) + llBeta;

            // x1 = dl / dN:

                x1 = UInt64Div32To32(dl, dN);
            }

        // At this point, we've taken care of calculating the intercepts
        // with the right and bottom edges.  Now we work on the left and
        // top edges:

            if (xLeft > (LONG) x0)
            {
                x0 = xLeft;
                dl = UInt32x32To64(x0, dN) + llGamma;

            // y0 = dl / dM;

                y0 = UInt64Div32To32(dl, dM);

                if (yBottom <= (LONG) y0)
                    goto Totally_Clipped;
            }

            if (yTop > (LONG) y0)
            {
                y0 = yTop;
                dl = UInt32x32To64(y0, dM) + llBeta;

            // x0 = dl / dN + 1;

                x0 = UInt64Div32To32(dl, dN) + 1;

                if (xRight <= (LONG) x0)
                    goto Totally_Clipped;
            }

            ASSERTDD(x0 <= x1, "Improper rectangle clip");
        }

/***********************************************************************\
* Done clipping.  Unflip if necessary.                                 *
\***********************************************************************/

        ptlStart.x = x + x0;
        ptlStart.y = y + y0;

        if (fl & FL_FLIP_D)
        {
            register LONG lTmp;
            SWAPL(ptlStart.x, ptlStart.y, lTmp);
        }


        if (fl & FL_FLIP_V)
        {
            ptlStart.y = -ptlStart.y;
        }

        cPels = x1 - x0 + 1;

/***********************************************************************\
* Style calculations.                                                   *
\***********************************************************************/

        if (fl & FL_STYLED)
        {
            STYLEPOS sp;

            spThis       = pls->spNext;
            pls->spNext += cStylePels;

            {
                if (pls->spNext >= pls->spTotal2)
                    pls->spNext %= pls->spTotal2;

                if (fl & FL_FLIP_H)
                    sp = pls->spNext - x0 + xStart;
                else
                    sp = spThis + x0 - xStart;

                ASSERTDD(fl & FL_STYLED, "Oops");

            // Normalize our target style position:

                if ((sp < 0) || (sp >= pls->spTotal2))
                {
                    sp %= pls->spTotal2;

                // The modulus of a negative number is not well-defined
                // in C -- if it's negative we'll adjust it so that it's
                // back in the range [0, spTotal2):

                    if (sp < 0)
                        sp += pls->spTotal2;
                }

            // Since we always draw the line left-to-right, but styling is
            // always done in the direction of the original line, we have
            // to figure out where we are in the style array for the left
            // edge of this line.

                if (fl & FL_FLIP_H)
                {
                // Line originally ran right-to-left:

                    sp = -sp;
                    if (sp < 0)
                        sp += pls->spTotal2;

                    pls->ulStyleMask = ~pls->ulStartMask;
                    pls->pspStart    = &pls->aspRtoL[0];
                    pls->pspEnd      = &pls->aspRtoL[pls->cStyle - 1];
                }
                else
                {
                // Line originally ran left-to-right:

                    pls->ulStyleMask = pls->ulStartMask;
                    pls->pspStart    = &pls->aspLtoR[0];
                    pls->pspEnd      = &pls->aspLtoR[pls->cStyle - 1];
                }

                if (sp >= pls->spTotal)
                {
                    sp -= pls->spTotal;
                    if (pls->cStyle & 1)
                        pls->ulStyleMask = ~pls->ulStyleMask;
                }

                pls->psp = pls->pspStart;
                while (sp >= *pls->psp)
                    sp -= *pls->psp++;

                ASSERTDD(pls->psp <= pls->pspEnd,
                        "Flew off into NeverNeverLand");

                pls->spRemaining = *pls->psp - sp;
                if ((pls->psp - pls->pspStart) & 1)
                    pls->ulStyleMask = ~pls->ulStyleMask;
            }
        }

        plStrip    = &strip.alStrips[0];
        plStripEnd = &strip.alStrips[STRIP_MAX];    // Is exclusive
        cStripsInNextRun   = 0x7fffffff;

        strip.ptlStart = ptlStart;

        if (2 * dN > dM &&
            !(fl & FL_STYLED))
        {
        // Do a half flip!  Remember that we may doing this on the
        // same line multiple times for complex clipping (meaning the
        // affected variables should be reset for every clip run):

            fl |= FL_FLIP_HALF;

            llBeta  = llGamma - (LONGLONG) ((LONG) dM);
            dN = dM - dN;
            y0 = x0 - y0;       // Note this may overflow, but that's okay
        }

    // Now, run the DDA starting at (ptlStart.x, ptlStart.y)!

        strip.flFlips = fl;
        pfn           = apfn[(fl & FL_STRIP_MASK) >> FL_STRIP_SHIFT];

    // Now calculate the DDA variables needed to figure out how many pixels
    // go in the very first strip:

        {
            register LONG  i;
            register ULONG dI;
            register ULONG dR;
                     ULONG r;

            if (dN == 0)
                i = 0x7fffffff;
            else
            {
                dl = UInt32x32To64(y0 + 1, dM) + llBeta;

                ASSERTDD(dl >= 0, "Oops!");

            // i = (dl / dN) - x0 + 1;
            // r = (dl % dN);

                i = UInt64Div32To32(dl, dN);
                r = UInt64Mod32To32(dl, dN);
                i = i - x0 + 1;

                dI = dM / dN;
                dR = dM % dN;               // 0 <= dR < dN

                ASSERTDD(dI > 0, "Weird dI");
            }

            ASSERTDD(i > 0 && i <= 0x7fffffff, "Weird initial strip length");
            ASSERTDD(cPels > 0, "Zero pel line");

/***********************************************************************\
* Run the DDA!                                                          *
\***********************************************************************/

            while(TRUE)
            {
                cPels -= i;
                if (cPels <= 0)
                    break;

                *plStrip++ = i;

                if (plStrip == plStripEnd)
                {
                    strip.cStrips = (LONG)(plStrip - &strip.alStrips[0]);
                    (*pfn)(ppdev, &strip, pls);
                    plStrip = &strip.alStrips[0];
                }

                i = dI;
                r += dR;

                if (r >= dN)
                {
                    r -= dN;
                    i++;
                }
            }

            *plStrip++ = cPels + i;

            strip.cStrips = (LONG)(plStrip - &strip.alStrips[0]);
            (*pfn)(ppdev, &strip, pls);
        }

    Next_Line:

        if (fl & FL_COMPLEX_CLIP)
        {
            cptfx--;
            if (cptfx != 0)
                goto Continue_Complex_Clipping;

            break;
        }
        else
        {
            pptfxFirst = pptfxBuf;
            pptfxBuf++;
        }

    } while (pptfxBuf < pptfxBufEnd);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bHardwareLine(ppdev, pptfxStart, pptfxEnd, iSolidColor, mix, prclClip)
*
* This routine is useful for folks who have line drawing hardware where
* they can explicitly set the Bresenham terms -- they can use this routine
* to draw fractional coordinate GIQ lines with the hardware.
*
* Fractional coordinate lines require an extra 4 bits of precision in the
* Bresenham terms.  For example, if your hardware has 13 bits of precision
* for the terms, you can only draw GIQ lines up to 255 pels long using this
* routine.
*
* Input:
*   pptfxStart  - Points to GIQ coordinate of start of line
*   pptfxEnd    - Points to GIQ coordinate of end of line
*   NUM_DDA_BITS- The number of bits of precision your hardware can support.
*
* Output:
*   returns     - TRUE if the line was drawn.
*                 FALSE if the line is too long, and the strips code must be
*                 used.
*
* DDALINE:
*   iDir        - Direction of the line, as an octant numbered as follows:
*
*                    \ 5 | 6 /
*                     \  |  /
*                    4 \ | / 7
*                       \ /
*                   -----+-----
*                       /|\
*                    3 / | \ 0
*                     /  |  \
*                    / 2 | 1 \
*
*   ptlStart    - Start pixel of line.
*   cPels       - # of pels in line.  *NOTE* You must check if this is <= 0!
*   dMajor      - Major axis delta.
*   dMinor      - Minor axis delta.
*   lErrorTerm  - Error term.
*
* What you do with the last 3 terms may be a little tricky.  They are
* actually the terms for the formula of the normalized line
*
*                     dMinor * x + (lErrorTerm + dMajor)
*       y(x) = floor( ---------------------------------- )
*                                  dMajor
*
* where y(x) is the y coordinate of the pixel to be lit as a function of
* the x-coordinate.
*
* Every time the line advances one in the major direction 'x', dMinor
* gets added to the current error term.  If the resulting value is >= 0,
* we know we have to move one pixel in the minor direction 'y', and
* dMajor must be subtracted from the current error term.
*
* If you're trying to figure out what this means for your hardware, you can
* think of the DDALINE terms as having been computed equivalently as
* follows:
*
*     dMinor     = 2 * (minor axis delta)
*     dMajor     = 2 * (major axis delta)
*     lErrorTerm = - (major axis delta) - fixup
*
* That is, if your documentation tells you that for integer lines, a
* register is supposed to be initialized with the value
* '2 * (minor axis delta)', you'll actually use dMinor.
*
* Example: Setting up the 8514
*
*     AXSTPSIGN is supposed to be the axial step constant register, defined
*     as 2 * (minor axis delta).  You set:
*
*           AXSTPSIGN = dMinor
*
*     DGSTPSIGN is supposed to be the diagonal step constant register,
*     defined as 2 * (minor axis delta) - 2 * (major axis delta).  You set:
*
*           DGSTPSIGN = dMinor - dMajor
*
*     ERR_TERM is supposed to be the adjusted error term, defined as
*     2 * (minor axis delta) - (major axis delta) - fixup.  You set:
*
*           ERR_TERM = lErrorTerm + dMinor
*
* Implementation:
*
*     You'll want to special case integer lines before calling this routine
*     (since they're very common, take less time to the computation of line
*     terms, and can handle longer lines than this routine because 4 bits
*     aren't being given to the fraction).
*
*     If a GIQ line is too long to be handled by this routine, you can just
*     use the slower strip routines for that line.  Note that you cannot
*     just fail the call -- you must be able to accurately draw any line
*     in the 28.4 device space when it intersects the viewport.
*
* Testing:
*
*     Use Guiman, or some other test that draws random fractional coordinate
*     lines and compares them to what GDI itself draws to a bitmap.
*
\**************************************************************************/

BOOL bHardwareLine(
PDEV*     ppdev,
POINTFIX* pptfxStart,       // Start of line
POINTFIX* pptfxEnd,         // End of line
LONG iSolidColor,           // 24bpp solid color
MIX mix,                    // 24bpp mix
RECTL* prclClip)            // 24bpp clipping rectangle
{
    FLONG fl;    // Various flags
    ULONG M0;    // Normalized fractional unit x start coordinate (0 <= M0 < F)
    ULONG N0;    // Normalized fractional unit y start coordinate (0 <= N0 < F)
    ULONG M1;    // Normalized fractional unit x end coordinate (0 <= M1 < F)
    ULONG N1;    // Normalized fractional unit x end coordinate (0 <= N1 < F)
    ULONG dM;    // Normalized fractional unit x-delta (0 <= dM)
    ULONG dN;    // Normalized fractional unit y-delta (0 <= dN <= dM)
    LONG  x;     // Normalized x coordinate of origin
    LONG  y;     // Normalized y coordinate of origin
    LONG  x0;    // Normalized x offset from origin to start pixel (inclusive)
    LONG  y0;    // Normalized y offset from origin to start pixel (inclusive)
    LONG  x1;    // Normalized x offset from origin to end pixel (inclusive)
    LONG  lGamma;// Bresenham error term at origin
    LONG  cPels; // Number of pixels in line
    BYTE* pjMmBase;
    BYTE* pjIoBase;

/***********************************************************************\
* Normalize line to the first octant.
\***********************************************************************/

    fl = 0;

    M0 = pptfxStart->x;
    dM = pptfxEnd->x;

    if ((LONG) dM < (LONG) M0)
    {
    // Line runs from right to left, so flip across x = 0:

        M0 = -(LONG) M0;
        dM = -(LONG) dM;
        fl |= HW_FLIP_H;
    }

// Compute the delta.  The DDI says we can never have a valid delta
// with a magnitude more than 2^31 - 1, but the engine never actually
// checks its transforms.  To ensure that we'll never puke on our shoes,
// we check for that case and simply refuse to draw the line:

    dM -= M0;
    // 24bpp Bresenham is guaranteed to draw ALL lines.
    if (ppdev->iBitmapFormat != BMF_24BPP)
    {
        if ((LONG) dM < 0)
            return(FALSE);
    }

    N0 = pptfxStart->y;
    dN = pptfxEnd->y;

    if ((LONG) dN < (LONG) N0)
    {
    // Line runs from bottom to top, so flip across y = 0:

        N0 = -(LONG) N0;
        dN = -(LONG) dN;
        fl |= HW_FLIP_V;
    }

// Compute another delta:

    dN -= N0;
    // 24bpp Bresenham is guaranteed to draw ALL lines.
    if (ppdev->iBitmapFormat != BMF_24BPP)
    {
        if ((LONG) dN < 0)
            return(FALSE);
    }

    if (dN >= dM)
    {
        if (dN == dM)
        {
        // Have to special case slopes of one:

            fl |= HW_FLIP_SLOPE_ONE;
        }
        else
        {
        // Since line has slope greater than 1, flip across x = y:

            register ULONG ulTmp;
            ulTmp = dM; dM = dN; dN = ulTmp;
            ulTmp = M0; M0 = N0; N0 = ulTmp;
            fl |= HW_FLIP_D;
        }
    }

// Figure out if we can do the line in hardware, given that we have a
// limited number of bits of precision for the Bresenham terms.
//
// Remember that one bit has to be kept as a sign bit:

    // 24bpp Bresenham is guaranteed to draw ALL lines.
    if (ppdev->iBitmapFormat != BMF_24BPP)
    {
        if ((LONG) dM >= (1L << (NUM_DDA_BITS - 1)))
            return(FALSE);
    }

    fl |= gaflHardwareRound[fl];

/***********************************************************************\
* Calculate the error term at pixel 0.
\***********************************************************************/

    x = LFLOOR((LONG) M0);
    y = LFLOOR((LONG) N0);

    M0 = FXFRAC(M0);
    N0 = FXFRAC(N0);

// NOTE NOTE NOTE: If this routine were to handle any line in the 28.4
// space, it will overflow its math (the following part requires 36 bits
// of precision)!  But we get here for lines that the hardware can handle
// (see the expression (dM >= (1L << (NUM_DDA_BITS - 1))) above?), so if
// cBits is less than 28, we're safe.
//
// If you're going to use this routine to handle all lines in the 28.4
// device space, you will HAVE to make sure the math doesn't overflow,
// otherwise you won't be NT compliant!  (See 'bHardwareLine' for an example
// how to do that.  You don't have to worry about this if you simply
// default to the strips code for long lines, because those routines
// already do the math correctly.)

// Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ].  Note
// that M0 and N0 have at most 4 bits of significance (and if the
// arguments are properly ordered, on a 486 each multiply would be no
// more than 13 cycles):

    lGamma = (N0 + F/2) * dM - M0 * dN;

    if (fl & HW_Y_ROUND_DOWN)
        lGamma--;

    lGamma >>= FLOG2;

/***********************************************************************\
* Figure out which pixels are at the ends of the line.
\***********************************************************************/

// The toughest part of GIQ is determining the start and end pels.
//
// Our approach here is to calculate x0 and x1 (the inclusive start
// and end columns of the line respectively, relative to our normalized
// origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
// start point is easily calculated by plugging x0 into our line equation
// (which takes care of whether y = 1/2 rounds up or down in value)
// getting y0, and then undoing the normalizing flips to get back
// into device space.
//
// We look at the fractional parts of the coordinates of the start and
// end points, and call them (M0, N0) and (M1, N1) respectively, where
// 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
// to determine x0:
//
//   +-----------------------> +x
//   |
//   | 0                     1
//   |     0123456789abcdef
//   |
//   |   0 ........?xxxxxxx
//   |   1 ..........xxxxxx
//   |   2 ...........xxxxx
//   |   3 ............xxxx
//   |   4 .............xxx
//   |   5 ..............xx
//   |   6 ...............x
//   |   7 ................
//   |   8 ................
//   |   9 ......**........
//   |   a ........****...x
//   |   b ............****
//   |   c .............xxx****
//   |   d ............xxxx    ****
//   |   e ...........xxxxx        ****
//   |   f ..........xxxxxx
//   |
//   | 2                     3
//   v
//
//   +y
//
// This grid accounts for the appropriate rounding of GIQ and last-pel
// exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
// on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
// depending on what flips have been done to normalize the line.
//
// For the end point, if (M1, N1) lands on an 'x', x1 =
// floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
// floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
// depending on what flips have been done to normalize the line.
//
// Lines of exactly slope one require a special case for both the start
// and end.  For example, if the line ends such that (M1, N1) is (9, 1),
// the line has gone exactly through (8, 0) -- which may be considered
// to be part of 'x' because of rounding!  So slopes of exactly slope
// one going through (8, 0) must also be considered as belonging in 'x'
// when an x value of 1/2 is supposed to round up in value.

// Calculate x0, x1:

    N1 = FXFRAC(N0 + dN);
    M1 = FXFRAC(M0 + dM);

    x1 = LFLOOR(M0 + dM);

// Line runs left-to-right:

// Compute x1:

    x1--;
    if (M1 > 0)
    {
        if (N1 == 0)
        {
            if (LROUND(M1, fl & HW_X_ROUND_DOWN))
                x1++;
        }
        else if (abs((LONG) (N1 - F/2)) <= (LONG) M1)
        {
            x1++;
        }
    }

    if ((fl & (HW_FLIP_SLOPE_ONE | HW_X_ROUND_DOWN))
           == (HW_FLIP_SLOPE_ONE | HW_X_ROUND_DOWN))
    {
    // Have to special-case diagonal lines going through our
    // the point exactly equidistant between two horizontal
    // pixels, if we're supposed to round x=1/2 down:

        if ((M1 > 0) && (N1 == M1 + 8))
            x1--;

        if ((M0 > 0) && (N0 == M0 + 8))
        {
            x0 = 0;
            goto left_to_right_compute_y0;
        }
    }

// Compute x0:

    x0 = 0;
    if (M0 > 0)
    {
        if (N0 == 0)
        {
            if (LROUND(M0, fl & HW_X_ROUND_DOWN))
                x0 = 1;
        }
        else if (abs((LONG) (N0 - F/2)) <= (LONG) M0)
        {
            x0 = 1;
        }
    }

left_to_right_compute_y0:

/***********************************************************************\
* Calculate the start pixel.
\***********************************************************************/

// We now compute y0 and adjust the error term.  We know x0, and we know
// the current formula for the pixels to be lit on the line:
//
//                     dN * x + lGamma
//       y(x) = floor( --------------- )
//                           dM
//
// The remainder of this expression is the new error term at (x0, y0).
// Since x0 is going to be either 0 or 1, we don't actually have to do a
// multiply or divide to compute y0.  Finally, we subtract dM from the
// new error term so that it is in the range [-dM, 0).

    y0      = 0;
    lGamma += (dN & (-x0));
    lGamma -= dM;
    if (lGamma >= 0)
    {
        y0      = 1;
        lGamma -= dM;
    }

// Undo our flips to get the start coordinate:

    x += x0;
    y += y0;

    if (fl & HW_FLIP_D)
    {
        register LONG lTmp;
        lTmp = x; x = y; y = lTmp;
    }

    if (fl & HW_FLIP_V)
    {
        y = -y;
    }

    if (fl & HW_FLIP_H)
    {
        x = -x;
    }

/***********************************************************************\
* Return the Bresenham terms:
\***********************************************************************/

    // iDir       = gaiDir[fl & HW_FLIP_MASK];
    // ptlStart.x = x;
    // ptlStart.y = y;
    // cPels      = x1 - x0 + 1;  // NOTE: You'll have to check if cPels <= 0!
    // dMajor     = dM;
    // dMinor     = dN;
    // lErrorTerm = lGamma;

/***********************************************************************\
* Draw the line.  ATI specific code follows:
\***********************************************************************/

    cPels = x1 - x0 + 1;
    if (cPels > 0)
    {
        pjMmBase = ppdev->pjMmBase;
        x       += ppdev->xOffset;
        y       += ppdev->yOffset;

        if (ppdev->iMachType == MACH_MM_64)
        {
            if (ppdev->iBitmapFormat != BMF_24BPP)
            {
                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 6);

                M64_OD(pjMmBase, DST_Y_X,       PACKXY(x, y));
                M64_OD(pjMmBase, DST_CNTL,      gai64Direction[fl & HW_FLIP_MASK]);
                M64_OD(pjMmBase, DST_BRES_ERR,  dN + lGamma);
                M64_OD(pjMmBase, DST_BRES_INC,  dN);
                M64_OD(pjMmBase, DST_BRES_DEC,  dN - dM);
                M64_OD(pjMmBase, DST_BRES_LNTH, cPels);
            }
            else
            {
                FLONG flQuadrant;

                flQuadrant = gai64Direction[fl & HW_FLIP_MASK];

                if (pptfxStart->y == pptfxEnd->y &&
                    cPels < 0x2000 && x >= 0 && y > 0 && y < 0x4000)  // Horizontal line
                {
                    flQuadrant &= 3;    // clean the flags of Bresenham

                    x  *= 3;
                    cPels *= 3;

                    if (! (flQuadrant & DST_CNTL_XDir))
                        x += 2;     // From right to left, start with the Blue byte.

                    if (prclClip) vSetClipping(ppdev, prclClip);

                    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 4);

                    M64_OD(pjMmBase,  DP_SRC, DP_SRC_FrgdClr << 8 );
                    M64_OD(pjMmBase,  DST_CNTL, flQuadrant | DST_CNTL_24_RotEna | ((x/4 % 6) << 8) );

                    M64_OD(pjMmBase,  DST_Y_X,          PACKXY(x, y) );
                    M64_OD(pjMmBase,  DST_HEIGHT_WIDTH, PACKPAIR(1, cPels) );

                    if (prclClip) vResetClipping(ppdev);
                }
                else if (pptfxStart->x == pptfxEnd->x &&
                    cPels < 0x8000 && y > 0 && y < 0x4000)  // Vertical line
                {
                    flQuadrant &= 3;    // clean the flags of Bresenham

                    x *= 3;

                    if (prclClip) vSetClipping(ppdev, prclClip);

                    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 4);

                    M64_OD(pjMmBase,  DP_SRC, DP_SRC_FrgdClr << 8 );
                    M64_OD(pjMmBase,  DST_CNTL, flQuadrant | DST_CNTL_24_RotEna | ((x/4 % 6) << 8) );

                    M64_OD(pjMmBase,  DST_Y_X,          PACKXY(x, y) );
                    M64_OD(pjMmBase,  DST_HEIGHT_WIDTH, PACKPAIR(cPels, 3) );

                    if (prclClip) vResetClipping(ppdev);
                }
                else
                {
                    BYTE *pjDest, *pjScreen;
                    BYTE red, green, blue;
                    LONG bres_err, bres_inc, bres_dec, bres_len;
                    LONG lDelta;
                    MIX  hw_mix;

                    pjScreen = ppdev->pjScreen;
                    lDelta   = ppdev->lDelta;
                    hw_mix = gaul64HwMixFromMix[mix & 0xf] >> 16;

                    bres_err = dN + lGamma;
                    bres_inc = dN;
                    bres_dec = dN - dM;
                    bres_len = cPels;

                    // Separate into color bytes.
                    red   = (BYTE) ((iSolidColor & ppdev->flRed)   >> REDSHIFT);
                    green = (BYTE) ((iSolidColor & ppdev->flGreen) >> GREENSHIFT);
                    blue  = (BYTE) ((iSolidColor & ppdev->flBlue)  >> BLUESHIFT);

                    vM64QuietDown(ppdev, pjMmBase);

                    // Execute 24bpp Bresenham algorithm.
                    while (bres_len-- > 0)
                    {
                        // Write pel.  Check for clipping.  Last pel enabled.
                        if (prclClip == NULL
                        ||  x >= prclClip->left
                        &&  x <  prclClip->right
                        &&  y >= prclClip->top
                        &&  y <  prclClip->bottom )
                        {
                            pjDest = pjScreen + y*lDelta + x*3;
                            switch (hw_mix)
                            {
                            case 0:     // NOT dst
                                *pjDest = ~*pjDest++;
                                *pjDest = ~*pjDest++;
                                *pjDest = ~*pjDest;
                                break;
                            case 1:     // "0"
                                *pjDest++ = 0;
                                *pjDest++ = 0;
                                *pjDest   = 0;
                                break;
                            case 2:     // "1"
                                *pjDest++ = 0xFF;
                                *pjDest++ = 0xFF;
                                *pjDest   = 0xFF;
                                break;
                            case 3:     // dst
                                break;
                            case 4:     // NOT src
                                *pjDest++ = ~blue;
                                *pjDest++ = ~green;
                                *pjDest   = ~red;
                                break;
                            case 5:     // dst XOR src
                                *pjDest++ ^= blue;
                                *pjDest++ ^= green;
                                *pjDest   ^= red;
                                break;
                            case 6:     // NOT dst XOR src
                                *pjDest = ~*pjDest++ ^ blue;
                                *pjDest = ~*pjDest++ ^ green;
                                *pjDest = ~*pjDest   ^ red;
                                break;
                            case 7:     // src
                                *pjDest++ = blue;
                                *pjDest++ = green;
                                *pjDest   = red;
                                break;
                            case 8:     // NOT dst OR NOT src
                                *pjDest = ~*pjDest++ | ~blue;
                                *pjDest = ~*pjDest++ | ~green;
                                *pjDest = ~*pjDest   | ~red;
                                break;
                            case 9:     // dst OR NOT src
                                *pjDest++ |= ~blue;
                                *pjDest++ |= ~green;
                                *pjDest   |= ~red;
                                break;
                            case 0xA:   // NOT dst OR src
                                *pjDest = ~*pjDest++ | blue;
                                *pjDest = ~*pjDest++ | green;
                                *pjDest = ~*pjDest   | red;
                                break;
                            case 0xB:   // dst OR src
                                *pjDest++ |= blue;
                                *pjDest++ |= green;
                                *pjDest   |= red;
                                break;
                            case 0xC:   // dst AND src
                                *pjDest++ &= blue;
                                *pjDest++ &= green;
                                *pjDest   &= red;
                                break;
                            case 0xD:   // NOT dst AND src
                                *pjDest = ~*pjDest++ & blue;
                                *pjDest = ~*pjDest++ & green;
                                *pjDest = ~*pjDest   & red;
                                break;
                            case 0xE:   // dst AND NOT src
                                *pjDest++ &= ~blue;
                                *pjDest++ &= ~green;
                                *pjDest   &= ~red;
                                break;
                            case 0xF:   // NOT dst AND NOT src
                                *pjDest = ~*pjDest++ & ~blue;
                                *pjDest = ~*pjDest++ & ~green;
                                *pjDest = ~*pjDest   & ~red;
                                break;
                            case 0x17:
                                *pjDest = ((*pjDest++) + blue)/2;
                                *pjDest = ((*pjDest++) + green)/2;
                                *pjDest = (*pjDest     + red)/2;
                                break;
                            }
                        }

                        if (flQuadrant & DST_CNTL_YMajor)
                        {
                            if (flQuadrant & DST_CNTL_YDir)
                                y++;
                            else
                                y--;

                            if (bres_err >= 0)
                            {
                                bres_err += bres_dec;
                                if (flQuadrant & DST_CNTL_XDir)
                                    x++;
                                else
                                    x--;
                            }
                            else
                                bres_err += bres_inc;
                        }
                        else
                        {
                            if (flQuadrant & DST_CNTL_XDir)
                                x++;
                            else
                                x--;

                            if (bres_err >= 0)
                            {
                                bres_err += bres_dec;
                                if (flQuadrant & DST_CNTL_YDir)
                                    y++;
                                else
                                    y--;
                            }
                            else
                                bres_err += bres_inc;
                        }
                    }
                }
            }
        }
        else if (ppdev->iMachType == MACH_MM_32)
        {
            M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 7);

            // Note that gai32Direction must have 'LAST_PEL_OFF' set so
            // that we don't change the state for the strip drawers:

            M32_OW(pjMmBase, CUR_X,        x);
            M32_OW(pjMmBase, CUR_Y,        y);
            M32_OW(pjMmBase, LINEDRAW_OPT, gai32Direction[fl & HW_FLIP_MASK]);
            M32_OW(pjMmBase, ERR_TERM,     dN + lGamma);
            M32_OW(pjMmBase, AXSTP,        dN);
            M32_OW(pjMmBase, DIASTP,       dN - dM);
            M32_OW(pjMmBase, BRES_COUNT,   cPels);
        }
        else
        {
            pjIoBase = ppdev->pjIoBase;

            I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 7);

            // Note that gai32Direction must have 'LAST_PEL_OFF' set so
            // that we don't change the state for the strip drawers:

            I32_OW(pjIoBase, CUR_X,        x);
            I32_OW(pjIoBase, CUR_Y,        y);
            I32_OW(pjIoBase, LINEDRAW_OPT, gai32Direction[fl & HW_FLIP_MASK]);
            I32_OW(pjIoBase, ERR_TERM,     dN + lGamma);
            I32_OW(pjIoBase, AXSTP,        dN);
            I32_OW(pjIoBase, DIASTP,       dN - dM);
            I32_OW(pjIoBase, BRES_COUNT,   cPels);
        }
    }

    return(TRUE);
}

/*******************************Public*Table*******************************\
* gapfnI32Strip
*
* Look-up table for DrvStrokePath to find which strip routines to call.
*
\**************************************************************************/

VOID (*gapfnI32Strip[])(PDEV*, STRIP*, LINESTATE*) = {
    vI32StripSolidHorizontal,
    vI32StripSolidVertical,
    vI32StripSolidDiagonal,
    vI32StripSolidDiagonal,

    vI32StripStyledHorizontal,
    vI32StripStyledVertical,
    NULL,
    NULL,
};

VOID (*gapfnM64Strip[])(PDEV*, STRIP*, LINESTATE*) = {
    vM64StripSolidHorizontal,
    vM64StripSolidVertical,
    vM64StripSolidDiagonal,
    vM64StripSolidDiagonal,

    vM64StripStyledHorizontal,
    vM64StripStyledVertical,
    NULL,
    NULL,
};

// Style array for alternate style (alternates one pixel on, one pixel off):

STYLEPOS gaspAlternateStyle[] = { 1 };

/******************************Public*Routine******************************\
* BOOL DrvStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix)
*
* Strokes the path.
*
\**************************************************************************/

BOOL DrvStrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)
{
    STYLEPOS  aspLtoR[STYLE_MAX_COUNT];
    STYLEPOS  aspRtoL[STYLE_MAX_COUNT];
    LINESTATE ls;
    PFNSTRIP* apfn;
    FLONG     fl;
    PDEV*     ppdev;
    DSURF*    pdsurf;
    OH*       poh;
    RECTL     arclClip[4];                  // For rectangular clipping
    BYTE*     pjMmBase;
    BYTE*     pjIoBase;
    RECTL*    prclClip;
    ULONG     ulLinePattern;
    BOOL      bRet;

    // for punting 24bpp:
    BANK bnk;
    RECTFX rectfx;
    RECTL rclTrg;

    ASSERTDD(((mix >> 8) & 0xff) == (mix & 0xff),
             "GDI gave us an improper mix");

// Pass the surface off to GDI if it's a device bitmap that we've
// converted to a DIB:

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt == DT_DIB)
    {
        return(EngStrokePath(pdsurf->pso, ppo, pco, pxo, pbo, pptlBrush,
                             pla, mix));
    }

// We'll be drawing to the screen or an off-screen DFB; copy the surface's
// offset now so that we won't need to refer to the DSURF again:

    poh   = pdsurf->poh;
    ppdev = (PDEV*) pso->dhpdev;
    ppdev->xOffset = poh->x;
    ppdev->yOffset = poh->y;

    bRet = TRUE;

    pjMmBase = ppdev->pjMmBase;
    pjIoBase = ppdev->pjIoBase;
//goto Punt_It;   //RKE:

    prclClip      = NULL;
    fl            = 0;
    ulLinePattern = (ULONG) -1;

// Look after styling initialization:

    if (pla->fl & LA_ALTERNATE)
    {
        if (ppdev->iAsic == ASIC_88800GX && ppdev->iBitmapFormat == BMF_24BPP)
        {
            goto Punt_It;
        }

        ls.cStyle      = 1;
        ls.spTotal     = 1;
        ls.spTotal2    = 2;
        ls.spRemaining = 1;
        ls.aspRtoL     = &gaspAlternateStyle[0];
        ls.aspLtoR     = &gaspAlternateStyle[0];
        ls.spNext      = HIWORD(pla->elStyleState.l);
        ls.xyDensity   = 1;
        fl            |= FL_STYLED;
        ls.ulStartMask = 0L;
    }
    else if (pla->pstyle != (FLOAT_LONG*) NULL)
    {
        PFLOAT_LONG pstyle;
        STYLEPOS*   pspDown;
        STYLEPOS*   pspUp;

        if (ppdev->iAsic == ASIC_88800GX && ppdev->iBitmapFormat == BMF_24BPP)
        {
            goto Punt_It;
        }

        pstyle = &pla->pstyle[pla->cstyle];

        ls.xyDensity = STYLE_DENSITY;
        ls.spTotal   = 0;
        while (pstyle-- > pla->pstyle)
        {
            ls.spTotal += pstyle->l;
        }
        ls.spTotal *= STYLE_DENSITY;
        ls.spTotal2 = 2 * ls.spTotal;

    // Compute starting style position (this is guaranteed not to overflow):

        ls.spNext = HIWORD(pla->elStyleState.l) * STYLE_DENSITY +
                    LOWORD(pla->elStyleState.l);

        fl        |= FL_STYLED;
        ls.cStyle  = pla->cstyle;
        ls.aspRtoL = aspRtoL;
        ls.aspLtoR = aspLtoR;

        if (pla->fl & LA_STARTGAP)
            ls.ulStartMask = 0xffffffffL;
        else
            ls.ulStartMask = 0L;

        pstyle  = pla->pstyle;
        pspDown = &ls.aspRtoL[ls.cStyle - 1];
        pspUp   = &ls.aspLtoR[0];

        while (pspDown >= &ls.aspRtoL[0])
        {
            *pspDown = pstyle->l * STYLE_DENSITY;
            *pspUp   = *pspDown;

            pspUp++;
            pspDown--;
            pstyle++;
        }
    }

    if (pco->iDComplexity == DC_RECT)
    {
        fl |= FL_SIMPLE_CLIP;

        arclClip[0]        =  pco->rclBounds;

    // FL_FLIP_D:

        arclClip[1].top    =  pco->rclBounds.left;
        arclClip[1].left   =  pco->rclBounds.top;
        arclClip[1].bottom =  pco->rclBounds.right;
        arclClip[1].right  =  pco->rclBounds.bottom;

    // FL_FLIP_V:

        arclClip[2].top    = -pco->rclBounds.bottom + 1;
        arclClip[2].left   =  pco->rclBounds.left;
        arclClip[2].bottom = -pco->rclBounds.top + 1;
        arclClip[2].right  =  pco->rclBounds.right;

    // FL_FLIP_V | FL_FLIP_D:

        arclClip[3].top    =  pco->rclBounds.left;
        arclClip[3].left   = -pco->rclBounds.bottom + 1;
        arclClip[3].bottom =  pco->rclBounds.right;
        arclClip[3].right  = -pco->rclBounds.top + 1;

        prclClip = arclClip;
    }


//////////////////////////////////////////////////////////////////////
// ATI specific initialization:

    if (ppdev->iMachType == MACH_MM_64)
    {
        //
        // gmvideo9.scr fails guiman if this path is executed at 24bpp, so punt.
        //

        if (ppdev->iBitmapFormat == BMF_24BPP)
            goto Punt_It;

        apfn = &gapfnM64Strip[4 * ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT)];
        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 3);
        //M64_OD(pjMmBase, CONTEXT_LOAD_CNTL, CONTEXT_LOAD_CmdLoad | iDefContext );
        M64_OD(pjMmBase, DP_MIX,      gaul64HwMixFromMix[mix & 0xf]);
        M64_OD(pjMmBase, DP_FRGD_CLR, pbo->iSolidColor);
        M64_OD(pjMmBase, DP_SRC,      DP_SRC_Always1 | DP_SRC_FrgdClr << 8);
    }
    else if (ppdev->iMachType == MACH_MM_32)
    {
        apfn = &gapfnI32Strip[4 * ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT)];
        M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);
        M32_OW(pjMmBase, DP_CONFIG,      FG_COLOR_SRC_FG | DRAW | WRITE);
        M32_OW(pjMmBase, FRGD_MIX,       FOREGROUND_COLOR | gaul32HwMixFromMix[mix & 0xf]);
        M32_OW(pjMmBase, FRGD_COLOR,     pbo->iSolidColor);
        M32_OW(pjMmBase, MULTIFUNC_CNTL, DATA_EXTENSION | ALL_ONES);
        M32_OW(pjMmBase, LINEDRAW_OPT,   LAST_PEL_OFF); // For strip drawers
    }
    else
    {
        apfn = &gapfnI32Strip[4 * ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT)];
        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 5);
        I32_OW(pjIoBase, DP_CONFIG,      FG_COLOR_SRC_FG | DRAW | WRITE);
        I32_OW(pjIoBase, FRGD_MIX,       FOREGROUND_COLOR | gaul32HwMixFromMix[mix & 0xf]);
        I32_OW(pjIoBase, FRGD_COLOR,     pbo->iSolidColor);
        I32_OW(pjIoBase, MULTIFUNC_CNTL, DATA_EXTENSION | ALL_ONES);
        I32_OW(pjIoBase, LINEDRAW_OPT,   LAST_PEL_OFF); // For strip drawers
    }

//////////////////////////////////////////////////////////////////////
// Set up to enumerate the path:

    if (pco->iDComplexity != DC_COMPLEX)
    {
        PATHDATA  pd;
        BOOL      bMore;
        ULONG     cptfx;
        POINTFIX  ptfxStartFigure;
        POINTFIX  ptfxLast;
        POINTFIX* pptfxFirst;
        POINTFIX* pptfxBuf;

        pd.flags = 0;

        do {
            bMore = PATHOBJ_bEnum(ppo, &pd);

            cptfx = pd.count;
            if (cptfx == 0)
                break;

            if (pd.flags & PD_BEGINSUBPATH)
            {
                ptfxStartFigure  = *pd.pptfx;
                pptfxFirst       = pd.pptfx;
                pptfxBuf         = pd.pptfx + 1;
                cptfx--;
            }
            else
            {
                pptfxFirst       = &ptfxLast;
                pptfxBuf         = pd.pptfx;
            }

            if (pd.flags & PD_RESETSTYLE)
                ls.spNext = 0;

            if (cptfx > 0)
            {
                bRet &= bLines(ppdev,
                               pptfxFirst,
                               pptfxBuf,
                               (RUN*) NULL,
                               cptfx,
                               &ls,
                               prclClip,
                               apfn,
                               fl, pbo->iSolidColor, mix);
            }

            ptfxLast = pd.pptfx[pd.count - 1];

            if (pd.flags & PD_CLOSEFIGURE)
            {
                bRet &= bLines(ppdev,
                               &ptfxLast,
                               &ptfxStartFigure,
                               (RUN*) NULL,
                               1,
                               &ls,
                               prclClip,
                               apfn,
                               fl, pbo->iSolidColor, mix);
            }
        } while (bMore);

        if (fl & FL_STYLED)
        {
        // Save the style state:

            ULONG ulHigh;
            ULONG ulLow;

        // Masked styles don't normalize the style state.  It's a good
        // thing to do, so let's do it now:

            if ((ULONG) ls.spNext >= (ULONG) ls.spTotal2)
                ls.spNext = (ULONG) ls.spNext % (ULONG) ls.spTotal2;

            ulHigh = ls.spNext / ls.xyDensity;
            ulLow  = ls.spNext % ls.xyDensity;

            pla->elStyleState.l = MAKELONG(ulLow, ulHigh);
        }
    }
    else if (ppdev->iBitmapFormat != BMF_24BPP)
    {
    // Local state for path enumeration:

        BOOL bMore;
        union {
            BYTE     aj[offsetof(CLIPLINE, arun) + RUN_MAX * sizeof(RUN)];
            CLIPLINE cl;
        } cl;

        fl |= FL_COMPLEX_CLIP;

    // We use the clip object when non-simple clipping is involved:

        PATHOBJ_vEnumStartClipLines(ppo, pco, pso, pla);

        do {
            bMore = PATHOBJ_bEnumClipLines(ppo, sizeof(cl), &cl.cl);
            if (cl.cl.c != 0)
            {
                if (fl & FL_STYLED)
                {
                    ls.spComplex = HIWORD(cl.cl.lStyleState) * ls.xyDensity
                                 + LOWORD(cl.cl.lStyleState);
                }
                bRet &= bLines(ppdev,
                               &cl.cl.ptfxA,
                               &cl.cl.ptfxB,
                               &cl.cl.arun[0],
                               cl.cl.c,
                               &ls,
                               (RECTL*) NULL,
                               apfn,
                               fl, pbo->iSolidColor, mix);
            }
        } while (bMore);
    }
    else    // punt complex clipping in 24bpp
    {
Punt_It:
        PATHOBJ_vGetBounds( ppo, &rectfx );
        rclTrg.left   = (rectfx.xLeft >> 4);
        rclTrg.top    = (rectfx.yTop  >> 4);
        rclTrg.right  = min( ((rectfx.xRight  + 0xF) >> 4) + 1, (LONG) ppdev->cxMemory );
        rclTrg.bottom = min( ((rectfx.yBottom + 0xF) >> 4) + 1, (LONG) ppdev->cyMemory );

        vBankStart(ppdev, &rclTrg, pco, &bnk);

        do {
          bRet &= EngStrokePath(bnk.pso, ppo, bnk.pco, pxo, pbo, pptlBrush, pla, mix);
        } while (bBankEnum(&bnk));
    }

    if (ppdev->iMachType == MACH_MM_64)
    {
        // Since we don't use a default context, we must restore registers:

        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
        M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\lines.h ===
/******************************Module*Header*******************************\
* Module Name: lines.h
*
* Line drawing constants and structures.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

typedef struct _PDEV PDEV;      // Handy forward declaration

// We have to be careful that we don't overflow any registers when using
// the hardware to draw lines (as opposed to going through the strips
// routines, which will never overflow).  We accomplish this by simply
// checking the bounds of the path; if it is so large that any of the
// hardware terms may overflow, we punt the entire path to the strips
// code (should be pretty rare).

#define MAX_INTEGER_BOUND  (1535)   // ATI's line length term is limited to
#define MIN_INTEGER_BOUND  (-512)   //   a maximum value of 2047

typedef LONG STYLEPOS;

#define STYLE_MAX_COUNT     16
#define STYLE_MAX_VALUE     0x3fffL
#define RUN_MAX             20
#define STRIP_MAX           100
#define STYLE_DENSITY       3

// Flip and round flags:

#define FL_H_ROUND_DOWN         0x00000080L     // .... .... 1... ....
#define FL_V_ROUND_DOWN         0x00008000L     // 1... .... .... ....

#define FL_FLIP_D               0x00000005L     // .... .... .... .1.1
#define FL_FLIP_V               0x00000008L     // .... .... .... 1...
#define FL_FLIP_SLOPE_ONE       0x00000010L     // .... .... ...1 ....
#define FL_FLIP_HALF            0x00000002L     // .... .... .... ..1.
#define FL_FLIP_H               0x00000200L     // .... ..1. .... ....

#define FL_ROUND_MASK           0x0000001CL     // .... .... ...1 11..
#define FL_ROUND_SHIFT          2

#define FL_RECTLCLIP_MASK       0x0000000CL     // .... .... .... 11..
#define FL_RECTLCLIP_SHIFT      2

#define FL_STRIP_MASK           0x00000003L     // .... .... .... ..11
#define FL_STRIP_SHIFT          0

#define FL_SIMPLE_CLIP          0x00000020      // .... .... ..1. ....
#define FL_COMPLEX_CLIP         0x00000040      // .... .... .1.. ....
#define FL_CLIP                (FL_SIMPLE_CLIP | FL_COMPLEX_CLIP)

#define FL_STYLED               0x00000400L     // .... .1.. .... ....
#define FL_ALTERNATESTYLED      0x00001000L     // ...1 .... .... ....

#define FL_STYLE_MASK           0x00000400L
#define FL_STYLE_SHIFT          10

#define FL_LAST_PEL_INCLUSIVE   0x00002000L     // ..1. .... .... ....

// Miscellaneous DDA defines:

#define LROUND(x, flRoundDown) (((x) + F/2 - ((flRoundDown) > 0)) >> 4)
#define F                     16
#define FLOG2                 4
#define LFLOOR(x)             ((x) >> 4)
#define FXFRAC(x)             ((x) & (F - 1))

////////////////////////////////////////////////////////////////////////////
// NOTE: The following structures must exactly match those declared in
//       lines.inc!

typedef struct _STRIP {
    LONG   cStrips;               // # of strips in array
    LONG   flFlips;               // Indicates if line goes up or down
    POINTL ptlStart;              // first point
    LONG   alStrips[STRIP_MAX];   // Array of strips
} STRIP;

typedef struct _LINESTATE {
    STYLEPOS*       pspStart;       // Pointer to start of style array
    STYLEPOS*       pspEnd;         // Pointer to end of style array
    STYLEPOS*       psp;            // Pointer to current style entry

    STYLEPOS        spRemaining;    // To go in current style
    STYLEPOS        spTotal;        // Sum of style array
    STYLEPOS        spTotal2;       // Twice sum of style array
    STYLEPOS        spNext;         // Style state at start of next line
    STYLEPOS        spComplex;      // Style state at start of complex clip line

    STYLEPOS*       aspRtoL;        // Style array in right-to-left order
    STYLEPOS*       aspLtoR;        // Style array in left-to-right order

    ULONG           ulStyleMask;    // Are we working on a gap in the style?
                                    // 0xff if yes, 0x0 if not
    ULONG           xyDensity;      // Density of style
    ULONG           cStyle;         // Size of style array

    ULONG           ulStyleMaskLtoR;// Original style mask, left-to-right order
    ULONG           ulStyleMaskRtoL;// Original style mask, right-to-left order

    BOOL            ulStartMask;    // Determines if first element in style
                                    // array is for a gap or a dash

} LINESTATE;                        /* ls */

// Strip drawer prototype:

typedef VOID (*PFNSTRIP)(PDEV*, STRIP*, LINESTATE*);

// Strip drawers:

VOID vI32StripSolidHorizontal(PDEV*, STRIP*, LINESTATE*);
VOID vI32StripSolidVertical(PDEV*, STRIP*, LINESTATE*);
VOID vI32StripSolidDiagonal(PDEV*, STRIP*, LINESTATE*);
VOID vI32StripStyledHorizontal(PDEV*, STRIP*, LINESTATE*);
VOID vI32StripStyledVertical(PDEV*, STRIP*, LINESTATE*);

VOID vM64StripSolidHorizontal(PDEV*, STRIP*, LINESTATE*);
VOID vM64StripSolidVertical(PDEV*, STRIP*, LINESTATE*);
VOID vM64StripSolidDiagonal(PDEV*, STRIP*, LINESTATE*);
VOID vM64StripStyledHorizontal(PDEV*, STRIP*, LINESTATE*);
VOID vM64StripStyledVertical(PDEV*, STRIP*, LINESTATE*);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\lineto.c ===
/******************************Module*Header*******************************\
* Module Name: Lineto.c
*
* Implements DrvLineTo.
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

LONG gai32LineBias[] = { 0, 0, 0, 1, 1, 1, 0, 1 };
LONG gai64LineBias[] = { 0, 0, 1, 1, 0, 1, 0, 1 };

/******************************Public*Routine******************************\
* VOID vM64LineToTrivial
*
* Draws a single solid integer-only unclipped cosmetic line for the mach64.
*
\**************************************************************************/

VOID vM64LineToTrivial(
PDEV*       ppdev,
LONG        x,              // Passed in x1
LONG        y,              // Passed in y1
LONG        dx,             // Passed in x2
LONG        dy,             // Passed in y2
ULONG       iSolidColor,    // -1 means hardware is already set up
MIX         mix,
RECTL*      prclClip)       // not used
{
    BYTE*   pjMmBase;
    FLONG   flQuadrant;

    pjMmBase = ppdev->pjMmBase;

    if (iSolidColor == (ULONG) -1)
    {
        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 7);
    }
    else
    {
        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 10);

        M64_OD(pjMmBase, DP_MIX, gaul64HwMixFromMix[mix & 0xf]);
        M64_OD(pjMmBase, DP_FRGD_CLR, iSolidColor);
        M64_OD(pjMmBase, DP_SRC, DP_SRC_Always1 | DP_SRC_FrgdClr << 8);
    }

    M64_OD(pjMmBase, DST_Y_X, PACKXY(x, y));

    flQuadrant = (DST_CNTL_XDir | DST_CNTL_YDir);

    dx -= x;
    if (dx < 0)
    {
        dx = -dx;
        flQuadrant &= ~DST_CNTL_XDir;
    }

    dy -= y;
    if (dy < 0)
    {
        dy = -dy;
        flQuadrant &= ~DST_CNTL_YDir;
    }

    if (dy > dx)
    {
        register LONG l;

        l  = dy;
        dy = dx;
        dx = l;                     // Swap 'dx' and 'dy'
        flQuadrant |= DST_CNTL_YMajor;
    }

    M64_OD(pjMmBase, DST_CNTL,      flQuadrant | DST_CNTL_LastPel);
    M64_OD(pjMmBase, DST_BRES_ERR,  (dy + dy - dx - gai64LineBias[flQuadrant]) >> 1);
    M64_OD(pjMmBase, DST_BRES_INC,  dy);
    M64_OD(pjMmBase, DST_BRES_DEC,  dy - dx);
    M64_OD(pjMmBase, DST_BRES_LNTH, dx);

    // Since we don't use a default context, we must restore registers:

    M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
}

VOID vM64LineToTrivial24(
PDEV*       ppdev,
LONG        x,              // Passed in x1
LONG        y,              // Passed in y1
LONG        dx,             // Passed in x2
LONG        dy,             // Passed in y2
ULONG       iSolidColor,    // -1 means hardware is already set up
MIX         mix,
RECTL*      prclClip)       // required for Bresenham algorithm
{
    BYTE*   pjMmBase = ppdev->pjMmBase;
    FLONG   flQuadrant;
    LONG    x2 = dx, y2 = dy;

    if (iSolidColor != (ULONG) -1)
    {
        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 3);

        M64_OD(pjMmBase, DP_MIX, gaul64HwMixFromMix[mix & 0xf]);
        M64_OD(pjMmBase, DP_FRGD_CLR, iSolidColor);
        M64_OD(pjMmBase, DP_SRC, DP_SRC_Always1 | DP_SRC_FrgdClr << 8);
    }

    flQuadrant = (DST_CNTL_XDir | DST_CNTL_YDir);

    dx -= x;
    if (dx < 0)
    {
        dx = -dx;
        flQuadrant &= ~DST_CNTL_XDir;
    }

    dy -= y;
    if (dy < 0)
    {
        dy = -dy;
        flQuadrant &= ~DST_CNTL_YDir;
    }

    if (dy > dx)
    {
        register LONG l;

        l  = dy;
        dy = dx;
        dx = l;                     // Swap 'dx' and 'dy'
        flQuadrant |= DST_CNTL_YMajor;
    }

    if (y == y2)        // Horizontal line
    {
        x  *= 3;
        dx *= 3;

        if (! (flQuadrant & DST_CNTL_XDir))
            x += 2;     // From right to left, start with the Blue byte.

        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);

        M64_OD(pjMmBase,  DP_SRC, DP_SRC_FrgdClr << 8 );
        M64_OD(pjMmBase,  DST_CNTL, flQuadrant | DST_CNTL_24_RotEna | ((x/4 % 6) << 8) );

        M64_OD(pjMmBase,  DST_Y_X,          PACKXY(x, y) );
        M64_OD(pjMmBase,  DST_HEIGHT_WIDTH, PACKPAIR(1, dx) );

        // Since we don't use a default context, we must restore registers:
        M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
    }
    else if (x == x2)   // Vertical line
    {
        x *= 3;

        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);

        M64_OD(pjMmBase,  DP_SRC, DP_SRC_FrgdClr << 8 );
        M64_OD(pjMmBase,  DST_CNTL, flQuadrant | DST_CNTL_24_RotEna | ((x/4 % 6) << 8) );

        M64_OD(pjMmBase,  DST_Y_X,          PACKXY(x, y) );
        M64_OD(pjMmBase,  DST_HEIGHT_WIDTH, PACKPAIR(dx, 3) );

        // Since we don't use a default context, we must restore registers:
        M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
    }
    else
    {
        BYTE *pjDest, *pjScreen = ppdev->pjScreen;
        BYTE red, green, blue;
        LONG bres_err, bres_inc, bres_dec, bres_len;
        LONG lDelta = ppdev->lDelta;
        MIX  hw_mix;

        hw_mix = gaul64HwMixFromMix[mix & 0xf] >> 16;

        bres_err = (dy + dy - dx - gai64LineBias[flQuadrant]) >> 1;
        bres_inc = dy;
        bres_dec = dy - dx;
        bres_len = dx;

        // Separate into color bytes.
        red   = (BYTE) ((iSolidColor & ppdev->flRed)   >> REDSHIFT);
        green = (BYTE) ((iSolidColor & ppdev->flGreen) >> GREENSHIFT);
        blue  = (BYTE) ((iSolidColor & ppdev->flBlue)  >> BLUESHIFT);

        vM64QuietDown(ppdev, pjMmBase);

        // Execute 24bpp Bresenham algorithm.
        while (bres_len-- > 0)
        {
            // Write pel.  Check for clipping.  Last pel enabled.
            if (prclClip == NULL
            ||  x >= prclClip->left
            &&  x <  prclClip->right
            &&  y >= prclClip->top
            &&  y <  prclClip->bottom )
            {
                pjDest = pjScreen + y*lDelta + x*3;
                switch (hw_mix)
                {
                case 0:     // NOT dst
                    *pjDest = ~*pjDest++;
                    *pjDest = ~*pjDest++;
                    *pjDest = ~*pjDest;
                    break;
                case 1:     // "0"
                    *pjDest++ = 0;
                    *pjDest++ = 0;
                    *pjDest   = 0;
                    break;
                case 2:     // "1"
                    *pjDest++ = 0xFF;
                    *pjDest++ = 0xFF;
                    *pjDest   = 0xFF;
                    break;
                case 3:     // dst
                    break;
                case 4:     // NOT src
                    *pjDest++ = ~blue;
                    *pjDest++ = ~green;
                    *pjDest   = ~red;
                    break;
                case 5:     // dst XOR src
                    *pjDest++ ^= blue;
                    *pjDest++ ^= green;
                    *pjDest   ^= red;
                    break;
                case 6:     // NOT dst XOR src
                    *pjDest = ~*pjDest++ ^ blue;
                    *pjDest = ~*pjDest++ ^ green;
                    *pjDest = ~*pjDest   ^ red;
                    break;
                case 7:     // src
                    *pjDest++ = blue;
                    *pjDest++ = green;
                    *pjDest   = red;
                    break;
                case 8:     // NOT dst OR NOT src
                    *pjDest = ~*pjDest++ | ~blue;
                    *pjDest = ~*pjDest++ | ~green;
                    *pjDest = ~*pjDest   | ~red;
                    break;
                case 9:     // dst OR NOT src
                    *pjDest++ |= ~blue;
                    *pjDest++ |= ~green;
                    *pjDest   |= ~red;
                    break;
                case 0xA:   // NOT dst OR src
                    *pjDest = ~*pjDest++ | blue;
                    *pjDest = ~*pjDest++ | green;
                    *pjDest = ~*pjDest   | red;
                    break;
                case 0xB:   // dst OR src
                    *pjDest++ |= blue;
                    *pjDest++ |= green;
                    *pjDest   |= red;
                    break;
                case 0xC:   // dst AND src
                    *pjDest++ &= blue;
                    *pjDest++ &= green;
                    *pjDest   &= red;
                    break;
                case 0xD:   // NOT dst AND src
                    *pjDest = ~*pjDest++ & blue;
                    *pjDest = ~*pjDest++ & green;
                    *pjDest = ~*pjDest   & red;
                    break;
                case 0xE:   // dst AND NOT src
                    *pjDest++ &= ~blue;
                    *pjDest++ &= ~green;
                    *pjDest   &= ~red;
                    break;
                case 0xF:   // NOT dst AND NOT src
                    *pjDest = ~*pjDest++ & ~blue;
                    *pjDest = ~*pjDest++ & ~green;
                    *pjDest = ~*pjDest   & ~red;
                    break;
                case 0x17:
                    *pjDest = ((*pjDest++) + blue)/2;
                    *pjDest = ((*pjDest++) + green)/2;
                    *pjDest = (*pjDest     + red)/2;
                    break;
                }
            }

            if (flQuadrant & DST_CNTL_YMajor)
            {
                if (flQuadrant & DST_CNTL_YDir)
                    y++;
                else
                    y--;

                if (bres_err >= 0)
                {
                    bres_err += bres_dec;
                    if (flQuadrant & DST_CNTL_XDir)
                        x++;
                    else
                        x--;
                }
                else
                    bres_err += bres_inc;
            }
            else
            {
                if (flQuadrant & DST_CNTL_XDir)
                    x++;
                else
                    x--;

                if (bres_err >= 0)
                {
                    bres_err += bres_dec;
                    if (flQuadrant & DST_CNTL_YDir)
                        y++;
                    else
                        y--;
                }
                else
                    bres_err += bres_inc;
            }
        }
    }
}

/******************************Public*Routine******************************\
* VOID vM32LineToTrivial
*
* Draws a single solid integer-only unclipped cosmetic line for the mach32
* using memory-mapped I/O.
*
* See vSetStrips and bIntgerLine_M8 from the old driver.
*
\**************************************************************************/

VOID vM32LineToTrivial(
PDEV*       ppdev,
LONG        x,              // Passed in x1
LONG        y,              // Passed in y1
LONG        dx,             // Passed in x2
LONG        dy,             // Passed in y2
ULONG       iSolidColor,    // -1 means hardware is already set up
MIX         mix,
RECTL*      prclClip)       // not used
{
    BYTE*   pjMmBase;
    FLONG   flQuadrant;

    pjMmBase = ppdev->pjMmBase;

    if (iSolidColor == (ULONG) -1)
    {
        M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 7);
    }
    else
    {
        M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 11);

        M32_OW(pjMmBase, DP_CONFIG,      FG_COLOR_SRC_FG | DRAW | WRITE);
        M32_OW(pjMmBase, FRGD_MIX,       FOREGROUND_COLOR | gaul32HwMixFromMix[mix & 0xf]);
        M32_OW(pjMmBase, FRGD_COLOR,     iSolidColor);
        M32_OW(pjMmBase, MULTIFUNC_CNTL, DATA_EXTENSION | ALL_ONES);
    }

    M32_OW(pjMmBase, CUR_X, x);
    M32_OW(pjMmBase, CUR_Y, y);

    flQuadrant = (XPOSITIVE | YPOSITIVE);

    dx -= x;
    if (dx < 0)
    {
        dx = -dx;
        flQuadrant &= ~XPOSITIVE;
    }

    dy -= y;
    if (dy < 0)
    {
        dy = -dy;
        flQuadrant &= ~YPOSITIVE;
    }

    if (dy > dx)
    {
        register LONG l;

        l  = dy;
        dy = dx;
        dx = l;                     // Swap 'dx' and 'dy'
        flQuadrant |= YMAJOR;
    }

    M32_OW(pjMmBase, LINEDRAW_OPT, flQuadrant | LAST_PEL_OFF);
    M32_OW(pjMmBase, ERR_TERM,     (dy + dy - dx - gai32LineBias[flQuadrant >> 5]) >> 1);
    M32_OW(pjMmBase, AXSTP,        dy);
    M32_OW(pjMmBase, DIASTP,       dy - dx);
    M32_OW(pjMmBase, BRES_COUNT,   dx);
}

/******************************Public*Routine******************************\
* VOID vI32LineToTrivial
*
* Draws a single solid integer-only unclipped cosmetic line for the mach32
* using I/O-mapped registers.
*
* See vSetStrips and bIntgerLine_M8 from the old driver.
*
\**************************************************************************/

VOID vI32LineToTrivial(
PDEV*       ppdev,
LONG        x,              // Passed in x1
LONG        y,              // Passed in y1
LONG        dx,             // Passed in x2
LONG        dy,             // Passed in y2
ULONG       iSolidColor,    // -1 means hardware is already set up
MIX         mix,
RECTL*      prclClip)       // not used
{
    BYTE*   pjIoBase;
    FLONG   flQuadrant;

    pjIoBase = ppdev->pjIoBase;

    if (iSolidColor == (ULONG) -1)
    {
        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 7);
    }
    else
    {
        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 11);

        I32_OW(pjIoBase, DP_CONFIG,      FG_COLOR_SRC_FG | DRAW | WRITE);
        I32_OW(pjIoBase, FRGD_MIX,       FOREGROUND_COLOR | gaul32HwMixFromMix[mix & 0xf]);
        I32_OW(pjIoBase, FRGD_COLOR,     iSolidColor);
        I32_OW(pjIoBase, MULTIFUNC_CNTL, DATA_EXTENSION | ALL_ONES);
    }

    I32_OW(pjIoBase, CUR_X, x);
    I32_OW(pjIoBase, CUR_Y, y);

    flQuadrant = (XPOSITIVE | YPOSITIVE);

    dx -= x;
    if (dx < 0)
    {
        dx = -dx;
        flQuadrant &= ~XPOSITIVE;
    }

    dy -= y;
    if (dy < 0)
    {
        dy = -dy;
        flQuadrant &= ~YPOSITIVE;
    }

    if (dy > dx)
    {
        register LONG l;

        l  = dy;
        dy = dx;
        dx = l;                     // Swap 'dx' and 'dy'
        flQuadrant |= YMAJOR;
    }

    I32_OW(pjIoBase, LINEDRAW_OPT, flQuadrant | LAST_PEL_OFF);
    I32_OW(pjIoBase, ERR_TERM,     (dy + dy - dx - gai32LineBias[flQuadrant >> 5]) >> 1);
    I32_OW(pjIoBase, AXSTP,        dy);
    I32_OW(pjIoBase, DIASTP,       dy - dx);
    I32_OW(pjIoBase, BRES_COUNT,   dx);
}

/******************************Public*Routine******************************\
* BOOL DrvLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix)
*
* Draws a single solid integer-only cosmetic line.
*
\**************************************************************************/

#if TARGET_BUILD > 351
BOOL DrvLineTo(
SURFOBJ*    pso,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
LONG        x1,
LONG        y1,
LONG        x2,
LONG        y2,
RECTL*      prclBounds,
MIX         mix)
{
    PDEV*   ppdev;
    DSURF*  pdsurf;
    OH*     poh;
    LONG    xOffset;
    LONG    yOffset;
    BOOL    bRet;

    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt == DT_DIB)
    {
        return(EngLineTo(pdsurf->pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix));
    }

    // We'll be drawing to the screen or an off-screen DFB; copy the surface's
    // offset now so that we won't need to refer to the DSURF again:

    poh   = pdsurf->poh;
    ppdev = (PDEV*) pso->dhpdev;

    xOffset = poh->x;
    yOffset = poh->y;

    x1 += xOffset;
    x2 += xOffset;
    y1 += yOffset;
    y2 += yOffset;

    bRet = TRUE;

    if (pco == NULL)
    {
        ppdev->pfnLineToTrivial(ppdev, x1, y1, x2, y2, pbo->iSolidColor, mix, NULL);
    }
    else if ((pco->iDComplexity <= DC_RECT) &&
             (prclBounds->left   >= MIN_INTEGER_BOUND) &&
             (prclBounds->top    >= MIN_INTEGER_BOUND) &&
             (prclBounds->right  <= MAX_INTEGER_BOUND) &&
             (prclBounds->bottom <= MAX_INTEGER_BOUND))
    {
        ppdev->xOffset = xOffset;
        ppdev->yOffset = yOffset;

        vSetClipping(ppdev, &pco->rclBounds);
        // may need rclBounds for clipping in 24bpp:
        ppdev->pfnLineToTrivial(ppdev, x1, y1, x2, y2, pbo->iSolidColor, mix, &pco->rclBounds);
        vResetClipping(ppdev);
    }
    else
    {
        bRet = FALSE;
    }

    return(bRet);
}
#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\overlay.c ===
#include "precomp.h"

// this will be compiled only for NT40 and greater
#if TARGET_BUILD > 351

void ModifyOverlayPosition (PDEV* , LPRECTL , LPDWORD );



/* This procedure writes the Overlay pitch*/
__inline void WriteVTOverlayPitch (PDEV* ppdev, DWORD Pitch)
{
    DD_WriteVTReg ( DD_BUF0_PITCH, Pitch );
    DD_WriteVTReg ( DD_BUF1_PITCH, Pitch );
}



void  DeskScanCallback (PDEV* ppdev  )
  {
    RECTL rPhysOverlay;
    DWORD dwBuf0Offset, dwBuf1Offset;
    DWORD dwVInc = ppdev->OverlayInfo16.dwVInc;
    DWORD dwHInc = ppdev->OverlayInfo16.dwHInc;

    static DWORD dwOldVInc = 0, dwOldHInc = 0;
    static WORD  wOldX = 0xFFFF, wOldY = 0xFFFF;
    static RECTL rOldPhysOverlay = { 0, 0, 0, 0 };

    /*
     * If we have not allocated the overlay then we better not do
     * anything or we might collide with the video capture stuff
     */

    if ( ! ( ppdev->OverlayInfo16.dwFlags & OVERLAY_ALLOCATED ) )
      {
        return;
      }


    dwBuf0Offset = ppdev->OverlayInfo16.dwBuf0Start;
    dwBuf1Offset = ppdev->OverlayInfo16.dwBuf1Start;

    rPhysOverlay.top    = ppdev->OverlayInfo16.rDst.top;
    rPhysOverlay.bottom = ppdev->OverlayInfo16.rDst.bottom ;

    rPhysOverlay.left   = ppdev->OverlayInfo16.rDst.left ;
    rPhysOverlay.right  =  ppdev->OverlayInfo16.rDst.right ;

    /*
     * Turn off keyer if overlay has moved off the screen.
     */

    if ( rPhysOverlay.right  < 0 ||
         rPhysOverlay.bottom < 0 ||
         rPhysOverlay.left   > ppdev->cxScreen - 1 ||
         rPhysOverlay.top    > ppdev->cyScreen - 1 )
      {
        DD_WriteVTReg ( DD_OVERLAY_KEY_CNTL, 0x00000110L );
        return;
      }


    /*
     * Adjust Offsets if overlay source rectangle is clipped
     */

    if ( ppdev->OverlayInfo16.dwFlags & UPDATEOVERLAY )
      {
        if ( ppdev->OverlayInfo16.rSrc.left > 0 )
          {
            dwBuf0Offset += ppdev->OverlayInfo16.rSrc.left * 2;
            dwBuf1Offset += ppdev->OverlayInfo16.rSrc.left * 2;
          }

        if ( ppdev->OverlayInfo16.rSrc.top > 0 )
          {
            if ( ppdev->OverlayInfo16.dwFlags & DOUBLE_PITCH )
              {
                dwBuf0Offset +=
                        ppdev->OverlayInfo16.rSrc.top * ppdev->OverlayInfo16.lBuf0Pitch * 2;
                dwBuf1Offset +=
                        ppdev->OverlayInfo16.rSrc.top * ppdev->OverlayInfo16.lBuf1Pitch * 2;
              }
            else
              {
                dwBuf0Offset +=
                        ppdev->OverlayInfo16.rSrc.top * ppdev->OverlayInfo16.lBuf0Pitch;
                dwBuf1Offset +=
                        ppdev->OverlayInfo16.rSrc.top * ppdev->OverlayInfo16.lBuf1Pitch;
              }
          }
      }

    if ( M64_ID_DIRECT(ppdev->pjMmBase, CRTC_GEN_CNTL ) & CRTC_INTERLACE_EN )
        ModifyOverlayPosition (ppdev, &rPhysOverlay, &dwVInc );

    if ( dwVInc != dwOldVInc || dwHInc != dwOldHInc )
        DD_WriteVTReg ( DD_OVERLAY_SCALE_INC, ( dwHInc << 16 ) | dwVInc );

    /*
     * Try not to write new position at a bad time!
     */

   // if ((ppdev->iAsic ==CI_M64_VTA)||(ppdev->iAsic ==CI_M64_GTA))
   //    {
        if ( rPhysOverlay.top    != rOldPhysOverlay.top    ||
             rPhysOverlay.bottom != rOldPhysOverlay.bottom ||
             rPhysOverlay.left   != rOldPhysOverlay.left   ||
             rPhysOverlay.right  != rOldPhysOverlay.right )

        //((M64_ID(ppdev->pjMmBase, CRTC_VLINE_CRNT_VLINE)&0x07FF0000L)>>16L)

        if ( (LONG)((M64_ID_DIRECT(ppdev->pjMmBase, CRTC_VLINE_CRNT_VLINE)&0x07FF0000L)>>16L)>= rOldPhysOverlay.top )
            while ( (LONG)((M64_ID_DIRECT(ppdev->pjMmBase, CRTC_VLINE_CRNT_VLINE)&0x07FF0000L)>>16L)  <= rOldPhysOverlay.bottom );

    //  }

    /*
     * Hit the registers with the new overlay information.
     */

    DD_WriteVTReg ( DD_BUF0_OFFSET, dwBuf0Offset );
    DD_WriteVTReg ( DD_BUF1_OFFSET, dwBuf1Offset );

    DD_WriteVTReg ( DD_OVERLAY_Y_X, (DWORD)(
                 ( (DWORD)rPhysOverlay.left << 16L ) |
                 ( (DWORD)rPhysOverlay.top ) | (0x80000000) ) );

    DD_WriteVTReg ( DD_OVERLAY_Y_X_END, (DWORD)(
                 ( (DWORD)rPhysOverlay.right << 16L ) |
                 ( (DWORD)rPhysOverlay.bottom ) ) );


    if ( ppdev->OverlayInfo16.dwFlags & UPDATEOVERLAY )
      {
        DD_WriteVTReg ( DD_OVERLAY_KEY_CNTL, ppdev->OverlayInfo16.dwOverlayKeyCntl );
      }

    dwOldVInc = dwVInc;
    dwOldHInc = dwHInc;
    rOldPhysOverlay.top    = max ( rPhysOverlay.top, 0 );
    rOldPhysOverlay.bottom = min ( rPhysOverlay.bottom, (LONG)ppdev->cyScreen - 1 );
    rOldPhysOverlay.left   = rPhysOverlay.left;
    rOldPhysOverlay.right  = rPhysOverlay.right;
  }






void ModifyOverlayPosition (PDEV* ppdev, LPRECTL lprOverlay, LPDWORD lpdwVInc )
  {
    DWORD dwVInc;
    DWORD dwScaleChange;
    DWORD dwHeight;
    DWORD dwTop, dwBottom;

    lprOverlay->top -= 3;

    if ( lprOverlay->top < 0 )
        {
        lprOverlay->top += M64_ID(ppdev->pjMmBase, CRTC_V_TOTAL_DISP )& 0x07FFL;
        }

    if ( lprOverlay->top != 0 )
      {
        if ( lprOverlay->top % 2 == 0 )
            lprOverlay->top++;

        if ( lprOverlay->top == 1 )
            lprOverlay->top = 0;
      }

    if ( lprOverlay->bottom%2 == 1 )
        lprOverlay->bottom++;

    lprOverlay->bottom = min ( lprOverlay->bottom,
                               (LONG) ppdev->cyScreen - 2 );

    /*
     * Adjust scaling factor so we don't get the "green line" at the
     * bottom of the overlay if we are moving the overlay off the top
     * of the screen
     */

    dwVInc   = ppdev->OverlayInfo16.dwVInc;
    dwBottom = lprOverlay->bottom;
    dwTop    = lprOverlay->top;
    if ( (LONG)dwTop > ppdev->cyScreen - 1 )
        dwTop = 0L;

    dwHeight = dwBottom - dwTop;

    if ( dwHeight != 0 )
        dwScaleChange = ( ( dwHeight - 1 ) << 12 ) / ( dwHeight );
	else
		dwScaleChange = 0;

    if ( dwScaleChange != 0 )
        dwVInc = ( dwVInc * dwScaleChange ) >> 12;

    *lpdwVInc = dwVInc;
  }



  void TurnOnVTRegisters ( PDEV* ppdev )
    {
      DWORD dwBusCntl;

      dwBusCntl  = M64_ID_DIRECT(ppdev->pjMmBase, BUS_CNTL );
      dwBusCntl |= 0x08000000U;
      M64_OD_DIRECT(ppdev->pjMmBase, BUS_CNTL, dwBusCntl );

    }
  void TurnOffVTRegisters ( PDEV* ppdev )
    {
      DWORD dwBusCntl;

      dwBusCntl  = M64_ID(ppdev->pjMmBase, BUS_CNTL );
      dwBusCntl &= ~0x08000000U;
      M64_CHECK_FIFO_SPACE(ppdev,ppdev-> pjMmBase, 2);
      M64_OD(ppdev->pjMmBase, BUS_CNTL, dwBusCntl );
    }



DWORD DdSetColorKey(PDD_SETCOLORKEYDATA lpSetColorKey)
{
    PDEV*               ppdev;
    BYTE*               pjIoBase;
    BYTE*               pjMmBase;
    DD_SURFACE_GLOBAL*  lpSurface;
    DWORD               dwKeyLow;
    DWORD               dwKeyHigh;

    ppdev = (PDEV*) lpSetColorKey->lpDD->dhpdev;


    pjMmBase  = ppdev->pjMmBase;
    lpSurface = lpSetColorKey->lpDDSurface->lpGbl;

    // We don't have to do anything for normal blt source colour keys:

    if (lpSetColorKey->dwFlags & DDCKEY_SRCBLT)
    {
        lpSetColorKey->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);
    }
    else if (lpSetColorKey->dwFlags & DDCKEY_DESTOVERLAY)
    {
        dwKeyLow = lpSetColorKey->ckNew.dwColorSpaceLowValue;
/*
        if (lpSurface->ddpfSurface.dwFlags & DDPF_PALETTEINDEXED8)
        {
            dwKeyLow = dwGetPaletteEntry(ppdev, dwKeyLow);
        }
        else
        {
            ASSERTDD(lpSurface->ddpfSurface.dwFlags & DDPF_RGB,
                "Expected only RGB cases here");

            // We have to transform the colour key from its native format
            // to 8-8-8:

            if (lpSurface->ddpfSurface.dwRGBBitCount == 16)
            {
                if (IS_RGB15_R(lpSurface->ddpfSurface.dwRBitMask))
                    dwKeyLow = RGB15to32(dwKeyLow);
                else
                    dwKeyLow = RGB16to32(dwKeyLow);
            }
            else
            {
                ASSERTDD((lpSurface->ddpfSurface.dwRGBBitCount == 32),
                    "Expected the primary surface to be either 8, 16, or 32bpp");
            }
        }
  */

        DD_WriteVTReg ( DD_OVERLAY_GRAPHICS_KEY_CLR, dwKeyLow );
        ppdev->OverlayInfo16.dwOverlayKeyCntl &= 0xFFFFFF8FL;
        ppdev->OverlayInfo16.dwOverlayKeyCntl |= 0x00000050L;
        DD_WriteVTReg ( DD_OVERLAY_KEY_CNTL, ppdev->OverlayInfo16.dwOverlayKeyCntl );

        lpSetColorKey->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);
    }

    DISPDBG((0, "DdSetColorKey: Invalid command"));
    return(DDHAL_DRIVER_NOTHANDLED);
}



/******************************Public*Routine******************************\
* DWORD DdCanCreateSurface
*
\**************************************************************************/

DWORD DdCanCreateSurface( PDD_CANCREATESURFACEDATA lpCanCreateSurface)
{
    PDEV*           ppdev;
    DWORD           dwRet;
    LPDDSURFACEDESC lpSurfaceDesc;

    ppdev = (PDEV*) lpCanCreateSurface->lpDD->dhpdev;
    lpSurfaceDesc = lpCanCreateSurface->lpDDSurfaceDesc;

    dwRet = DDHAL_DRIVER_NOTHANDLED;

    if (!lpCanCreateSurface->bIsDifferentPixelFormat)
    {
        // It's trivially easy to create plain surfaces that are the same
        // type as the primary surface:

        dwRet = DDHAL_DRIVER_HANDLED;
    }
    else  if (ppdev->iAsic >=CI_M64_VTA)
    {
        // When using the Streams processor, we handle only overlays of
        // different pixel formats -- not any off-screen memory:

        if (lpSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
        {

            // We handle two types of YUV overlay surfaces:

            if (lpSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_FOURCC)
            {
                // Check first for a supported YUV type:

             if ( (lpSurfaceDesc->ddpfPixelFormat.dwFourCC == FOURCC_UYVY) || (lpSurfaceDesc->ddpfPixelFormat.dwFourCC ==  FOURCC_YUY2) )
                {
                    lpSurfaceDesc->ddpfPixelFormat.dwYUVBitCount = 16;
                    dwRet = DDHAL_DRIVER_HANDLED;
                }
            }

            // We handle 16bpp and 32bpp RGB overlay surfaces:
            else if ((lpSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_RGB) &&
                    !(lpSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8))
            {
                if (lpSurfaceDesc->ddpfPixelFormat.dwRGBBitCount == 16)
                {
                    if (IS_RGB15(&lpSurfaceDesc->ddpfPixelFormat) ||
                        IS_RGB16(&lpSurfaceDesc->ddpfPixelFormat))
                    {
                        dwRet = DDHAL_DRIVER_HANDLED;
                    }
                }
            else if (lpSurfaceDesc->ddpfPixelFormat.dwRGBBitCount == 32)
           {
               if (IS_RGB32(&lpSurfaceDesc->ddpfPixelFormat))
               {
                   dwRet = DDHAL_DRIVER_HANDLED;
               }
           }


            }
        }
    }
    // Print some spew if this was a surface we refused to create:

    if (dwRet == DDHAL_DRIVER_NOTHANDLED)
    {
        if (lpSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_RGB)
        {
            DISPDBG((10, "Failed creation of %libpp RGB surface %lx %lx %lx",
                lpSurfaceDesc->ddpfPixelFormat.dwRGBBitCount,
                lpSurfaceDesc->ddpfPixelFormat.dwRBitMask,
                lpSurfaceDesc->ddpfPixelFormat.dwGBitMask,
                lpSurfaceDesc->ddpfPixelFormat.dwBBitMask));
        }
        else
        {
            DISPDBG((10, "Failed creation of type 0x%lx YUV 0x%lx surface",
                lpSurfaceDesc->ddpfPixelFormat.dwFlags,
                lpSurfaceDesc->ddpfPixelFormat.dwFourCC));
        }
    }

    lpCanCreateSurface->ddRVal = DD_OK;
    return(dwRet);
}


/******************************Public*Routine******************************\
* DWORD DdCreateSurface
*
\**************************************************************************/

DWORD DdCreateSurface(
PDD_CREATESURFACEDATA lpCreateSurface)
{
    PDEV*               ppdev;
    DD_SURFACE_LOCAL*   lpSurfaceLocal;
    DD_SURFACE_GLOBAL*  lpSurfaceGlobal;
    LPDDSURFACEDESC     lpSurfaceDesc;
    DWORD               dwByteCount;
    LONG                lLinearPitch;
    DWORD               dwHeight;
    OH*                 poh;
    FLATPTR         fpVidMem;

    DISPDBG((10, " Enter Create Surface"));
    ppdev = (PDEV*) lpCreateSurface->lpDD->dhpdev;

    // On Windows NT, dwSCnt will always be 1, so there will only ever
    // be one entry in the 'lplpSList' array:

    lpSurfaceLocal  = lpCreateSurface->lplpSList[0];
    lpSurfaceGlobal = lpSurfaceLocal->lpGbl;
    lpSurfaceDesc   = lpCreateSurface->lpDDSurfaceDesc;

    // We repeat the same checks we did in 'DdCanCreateSurface' because
    // it's possible that an application doesn't call 'DdCanCreateSurface'
    // before calling 'DdCreateSurface'.

    ASSERTDD(lpSurfaceGlobal->ddpfSurface.dwSize == sizeof(DDPIXELFORMAT), "NT is supposed to guarantee that ddpfSurface.dwSize is valid");

    // DdCanCreateSurface already validated whether the hardware supports
    // the surface, so we don't need to do any validation here.  We'll
    // just go ahead and allocate it.
    //
    //
    // Note that on NT, an overlay can be created only if the driver
    // okay's it here in this routine.  Under Win95, the overlay will be
    // created automatically if it's the same pixel format as the primary
    // display.

    if ((lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY)   ||
        (lpSurfaceGlobal->ddpfSurface.dwFlags & DDPF_FOURCC) ||
        (lpSurfaceGlobal->ddpfSurface.dwYUVBitCount != (DWORD) 8 * ppdev->cjPelSize) ||
        (lpSurfaceGlobal->ddpfSurface.dwRBitMask != ppdev->flRed))
    {
        if (lpSurfaceGlobal->wWidth <= (DWORD) ppdev->cxMemory)
        {
            if (lpSurfaceGlobal->ddpfSurface.dwFlags & DDPF_FOURCC)
            {
                //dwByteCount = (lpSurfaceGlobal->ddpfSurface.dwFourCC == FOURCC_UYVY)? 2 : 1;
                dwByteCount =2;
                // We have to fill in the bit-count for FourCC surfaces:

                lpSurfaceGlobal->ddpfSurface.dwYUVBitCount = 8 * dwByteCount;

                DISPDBG((10, "Created YUV: %li x %li",
                    lpSurfaceGlobal->wWidth, lpSurfaceGlobal->wHeight));
            }
            else
            {
                dwByteCount = lpSurfaceGlobal->ddpfSurface.dwRGBBitCount >> 3;

                DISPDBG((10, "Created RGB %libpp: %li x %li Red: %lx",
                    8 * dwByteCount, lpSurfaceGlobal->wWidth, lpSurfaceGlobal->wHeight,
                    lpSurfaceGlobal->ddpfSurface.dwRBitMask));


                // we support 15,16  and 32 bits
                if (((dwByteCount < 2)||(dwByteCount ==3)) &&
                    (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY))
                {
                    lpCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    return(DDHAL_DRIVER_HANDLED);
                }
            }

            // We want to allocate a linear surface to store the FourCC
            // surface, but our driver is using a 2-D heap-manager because
            // the rest of our surfaces have to be 2-D.  So here we have to
            // convert the linear size to a 2-D size.
            //
           
            lLinearPitch = (lpSurfaceGlobal->wWidth * dwByteCount ) ; // + 7) & ~7;    // The stride has to be a qword multiple.


            dwHeight = ( (lpSurfaceGlobal->wHeight * lLinearPitch + ppdev->lDelta - 1) / ppdev->lDelta) ; /// ppdev->cjPelSize;        // in pixels

            // Free up as much off-screen memory as possible:
    
            bMoveAllDfbsFromOffscreenToDibs(ppdev);
    

            poh = pohAllocate(ppdev, NULL, ppdev->cxMemory, dwHeight, FLOH_MAKE_PERMANENT);
            if (poh != NULL)
            {
                fpVidMem = (poh->y * ppdev->lDelta) + (poh->x ) * ppdev->cjPelSize;  // poh->x must be 0 in this case


                    lpSurfaceGlobal->dwReserved1  = (ULONG_PTR)poh;
                    lpSurfaceGlobal->xHint        = poh->x;
                    lpSurfaceGlobal->yHint        = poh->y;
                    lpSurfaceGlobal->fpVidMem     = fpVidMem;
                    lpSurfaceGlobal->lPitch       = lLinearPitch;

                    lpSurfaceDesc->lPitch =   lLinearPitch;
                    lpSurfaceDesc->dwFlags |= DDSD_PITCH;

                    // We handled the creation entirely ourselves, so we have to
                    // set the return code and return DDHAL_DRIVER_HANDLED:

                    lpCreateSurface->ddRVal = DD_OK;
                      DISPDBG((10, " Exit Create Surface 1: Created YUV surface at poh X=%d, Y=%d", poh->x, poh->y));
                    return(DDHAL_DRIVER_HANDLED);
            }



            /*
            // Now fill in enough stuff to have the DirectDraw heap-manager
            // do the allocation for us:

            lpSurfaceGlobal->fpVidMem     = DDHAL_PLEASEALLOC_BLOCKSIZE;
            lpSurfaceGlobal->dwBlockSizeX = ppdev->lDelta; // Specified in bytes
            lpSurfaceGlobal->dwBlockSizeY = dwHeight;
            lpSurfaceGlobal->lPitch       = lLinearPitch;
            lpSurfaceGlobal->dwReserved1  = DD_RESERVED_DIFFERENTPIXELFORMAT;

            lpSurfaceDesc->lPitch   = lLinearPitch;
            lpSurfaceDesc->dwFlags |= DDSD_PITCH;
            */
        }
        else
        {
            DISPDBG((10, "Refused to create surface with large width"));
        }
    }
else
    {
    if (lpSurfaceGlobal->wWidth <= (DWORD) ppdev->cxMemory)
        {

         if(lpSurfaceGlobal->ddpfSurface.dwRBitMask == ppdev->flRed)
            {
            DISPDBG((10, "Surface with the same pixel format as primary"));
                dwByteCount = lpSurfaceGlobal->ddpfSurface.dwRGBBitCount >> 3;
                lLinearPitch = ppdev->lDelta ; 
    
    
                dwHeight = lpSurfaceGlobal->wHeight ;
    
                // Free up as much off-screen memory as possible:
        
                bMoveAllDfbsFromOffscreenToDibs(ppdev);
        
                DISPDBG((10, "Try to allocate Cx=%d,  Cy=%d", ppdev->cxMemory, dwHeight));
                if((ULONG)lpSurfaceGlobal->wWidth*dwByteCount < (ULONG)ppdev->lDelta)
                    poh = pohAllocate(ppdev, NULL, ( (lpSurfaceGlobal->wWidth*dwByteCount + 8) / (ppdev->cjPelSize) ) +1, dwHeight, FLOH_MAKE_PERMANENT);
               else
                    poh = pohAllocate(ppdev, NULL, (lpSurfaceGlobal->wWidth*dwByteCount )/ppdev->cjPelSize , dwHeight, FLOH_MAKE_PERMANENT);

                if (poh != NULL)
                    {
                    if((ULONG)lpSurfaceGlobal->wWidth*dwByteCount < (ULONG)ppdev->lDelta)
                        fpVidMem =( ( (poh->y * ppdev->lDelta) + ((poh->x ) * ppdev->cjPelSize) + 7 )&~7 );  // poh->x must be 0 in this case
                    else
                        fpVidMem = (poh->y * ppdev->lDelta) + ((poh->x ) * ppdev->cjPelSize) ;

                    // no allocation for flip surfaces beyond 4MB
                    if (( (LONG)lpSurfaceGlobal->wWidth  < ppdev->cxScreen) ||
                        ( (LONG)lpSurfaceGlobal->wHeight < ppdev->cyScreen) ||
                        (fpVidMem < 0x400000))
                        {
                            lpSurfaceGlobal->dwReserved1=(ULONG_PTR)poh;
                            lpSurfaceGlobal->xHint        = poh->x;
                            lpSurfaceGlobal->yHint        = poh->y;
                            lpSurfaceGlobal->fpVidMem     = fpVidMem;
                            lpSurfaceGlobal->lPitch       = ppdev->lDelta;
                
                            lpSurfaceDesc->lPitch   = ppdev->lDelta;
                            lpSurfaceDesc->dwFlags |= DDSD_PITCH;
                
                            // We handled the creation entirely ourselves, so we have to
                            // set the return code and return DDHAL_DRIVER_HANDLED:
                            DISPDBG((10, " Exit Create Surface 2: Created RGB surface at poh X=%d, Y=%d", poh->x, poh->y));
                
                            lpCreateSurface->ddRVal = DD_OK;
                            return(DDHAL_DRIVER_HANDLED);
                        }
                    // dealocate the poh  because The allocation is beyond 4MB for a flip surface: cx = cxScreen ; cy = cyScreen
                    // bMoveAllDfbsFromOffscreenToDibs(ppdev);        // avoid fragmentation
                    pohFree(ppdev, poh);
                    DISPDBG((10, " The allocation is beyond 4MB, so  we deallocate; for a flip surface: cx = cxScreen ; cy = cyScreen"));
                    }
                DISPDBG((10, " Cannot allocate poh"));
                }
        }
    }
    DISPDBG((10, " Exit Create Surface NOTOK"));

    return(DDHAL_DRIVER_NOTHANDLED);
}


/******************************Public*Routine******************************\
* DWORD DdUpdateOverlay
*
\**************************************************************************/

DWORD DdUpdateOverlay(PDD_UPDATEOVERLAYDATA lpUpdateOverlay)
{
    PDEV*               ppdev;
    BYTE*               pjIoBase;
    BYTE*               pjMmBase;
    DD_SURFACE_GLOBAL*  lpSource;
    DD_SURFACE_GLOBAL*  lpDestination;
    DWORD               dwStride;
    LONG                srcWidth;
    LONG                srcHeight;
    LONG                dstWidth;
    LONG                dstHeight;
    DWORD               dwBitCount;
    DWORD               dwStart;
    DWORD               dwTmp;
    BOOL                bColorKey;
    DWORD               dwKeyLow;
    DWORD               dwKeyHigh;
    DWORD               dwBytesPerPixel;

    DWORD               dwSecCtrl;
    DWORD               dwBlendCtrl;
    LONG                  dwVInc;
    LONG                  dwHInc;

    DWORD SrcBufOffset,Temp;
    BYTE  bPLLAddr,bFatPixel;
    RECTL rSrc,rDst,rOverlay;
    DWORD myval;

    DWORD   g_dwGamma=0;        // Used to set the gamma correction for the overlay.
    DWORD value;

    ppdev = (PDEV*) lpUpdateOverlay->lpDD->dhpdev;

    pjMmBase = ppdev->pjMmBase;

    // 'Source' is the overlay surface, 'destination' is the surface to
    // be overlayed:

    lpSource = lpUpdateOverlay->lpDDSrcSurface->lpGbl;

    if (lpUpdateOverlay->dwFlags & DDOVER_HIDE)
    {
        if (lpSource->fpVidMem == ppdev->fpVisibleOverlay)
        {
        ppdev->semph_overlay=0;             //  = 0 ; resource free
         //WAIT_FOR_VBLANK(pjIoBase);
        ppdev->OverlayInfo16.dwFlags         |= UPDATEOVERLAY;
        ppdev->OverlayInfo16.dwFlags         &= ~OVERLAY_VISIBLE;
        ppdev->OverlayInfo16.dwOverlayKeyCntl = 0x00000110L;
        DeskScanCallback (ppdev );
        ppdev->OverlayInfo16.dwFlags &= ~UPDATEOVERLAY;
        ppdev->fpVisibleOverlay = 0;
        }

        lpUpdateOverlay->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);
    }

    // Dereference 'lpDDDestSurface' only after checking for the DDOVER_HIDE
    // case:

    lpDestination = lpUpdateOverlay->lpDDDestSurface->lpGbl;

    if (lpSource->fpVidMem != ppdev->fpVisibleOverlay)
    {
        if (lpUpdateOverlay->dwFlags & DDOVER_SHOW)
        {
            if (ppdev->fpVisibleOverlay != 0)
            {
                // Some other overlay is already visible:

                DISPDBG((10, "DdUpdateOverlay: An overlay is already visible"));

                lpUpdateOverlay->ddRVal = DDERR_OUTOFCAPS;
                return(DDHAL_DRIVER_HANDLED);
            }
            else
            {
                // first we have to verify if the overlay resource is in use
                if(ppdev->semph_overlay==0)             //  = 0 ; resource free
                                                                            //  = 1 ; in use by DDraw
                                                                            //  = 2 ; in use by Palindrome
                    {
                    // We're going to make the overlay visible, so mark it as
                    // such:
                    ppdev->semph_overlay = 1;
                    ppdev->fpVisibleOverlay = lpSource->fpVidMem;
                    }
               else
                   {
                   // Palindrome is using the overlay :
                   DISPDBG((10, "DdUpdateOverlay: An overlay is already visible (used byPalindrome) "));
   
                   lpUpdateOverlay->ddRVal = DDERR_OUTOFCAPS;
                   return(DDHAL_DRIVER_HANDLED);
                   }
            }
        }
        else
        {
            // The overlay isn't visible, and we haven't been asked to make
            // it visible, so this call is trivially easy:

            lpUpdateOverlay->ddRVal = DD_OK;
            return(DDHAL_DRIVER_HANDLED);
        }
    }

    dwStride =  lpSource->lPitch;
    srcWidth =  lpUpdateOverlay->rSrc.right   - lpUpdateOverlay->rSrc.left;
    srcHeight = lpUpdateOverlay->rSrc.bottom  - lpUpdateOverlay->rSrc.top;
    dstWidth =  lpUpdateOverlay->rDest.right  - lpUpdateOverlay->rDest.left;
    dstHeight = lpUpdateOverlay->rDest.bottom - lpUpdateOverlay->rDest.top;

    if ( dstHeight < srcHeight || lpUpdateOverlay->rSrc.top > 0 )
         ppdev->OverlayScalingDown = 1;
    else
         ppdev->OverlayScalingDown = 0;
     /*
     * Determine scaling factors for the hardware. These factors will
     * be modified based on either "fat pixel" mode or interlace mode.
     */

    dwHInc = ( srcWidth  << 12L ) / ( dstWidth );

    /*
     * Determine if VT/GT is in FAT PIXEL MODE
     */

    /* Get current PLL reg so we can restore. */
    value=M64_ID_DIRECT(ppdev->pjMmBase, CLOCK_CNTL );

    /* Set PLL reg 5 for reading. This is where the "fat pixel" bit is */
    M64_OD_DIRECT(ppdev->pjMmBase, CLOCK_CNTL, (value&0xFFFF00FF)|0x1400);

    /* Get the "fat pixel" bit from PLL reg */
    bFatPixel =(BYTE)( (M64_ID_DIRECT(ppdev->pjMmBase, CLOCK_CNTL )&0x00FF0000)>>16 ) & 0x30;

    /* Restore original register pointer in PLL reg */
     M64_OD_DIRECT( ppdev->pjMmBase, CLOCK_CNTL, value);
    /* adjust horizontal scaling if necessary */
    if ( bFatPixel )
        dwHInc *= 2;
        /*
     * We can't clip overlays, so we must make sure the co-ord, are within
     * the bounds of the screen.
     */

    rOverlay.top    = max ( 0,lpUpdateOverlay->rDest.top  );
    rOverlay.left   = max ( 0, lpUpdateOverlay->rDest.left );
    rOverlay.bottom = min ( (DWORD)ppdev->cyScreen - 1,
                            (DWORD)lpUpdateOverlay->rDest.bottom );
    rOverlay.right  = min ( (DWORD)ppdev->cxScreen  - 1,
                            (DWORD)lpUpdateOverlay->rDest.right );

    /*
     * Modify overlay destination based on wether we are in inerlace mode.
     * If we are in interlace dwVInc must be multiplied by 2.
     */

    dwVInc = ( srcHeight << 12L ) / ( dstHeight );

    if ( M64_ID_DIRECT(ppdev->pjMmBase, CRTC_GEN_CNTL ) & CRTC_INTERLACE_EN )
      {
        ppdev->OverlayScalingDown = 1; /* Always replicate UVs in this case */
        dwVInc *= 2;
      }

        /*
         * Overlay destination must be primary, so we will check current
         * pixel depth of the screen.
         */

        // here we have to turn on the second block of regs

        switch ( ppdev->cBitsPerPel) //Screen BPP
          {
            case 8:
                DD_WriteVTReg ( DD_OVERLAY_GRAPHICS_KEY_MSK, 0x000000FFL );
                break;

            case 16:
                DD_WriteVTReg ( DD_OVERLAY_GRAPHICS_KEY_MSK, 0x0000FFFFL );
                break;

            case 24:
            case 32:
                DD_WriteVTReg ( DD_OVERLAY_GRAPHICS_KEY_MSK, 0x00FFFFFFL );
                break;

            default:
                DD_WriteVTReg ( DD_OVERLAY_GRAPHICS_KEY_MSK, 0x0000FFFFL );
                break;
          }

        /* Scaler */

        DD_WriteVTReg ( DD_SCALER_HEIGHT_WIDTH, ( srcWidth << 16L ) |
                                        ( srcHeight ) );



    // Overlay input data format:

    if (lpSource->ddpfSurface.dwFlags & DDPF_FOURCC)
    {
        dwBitCount = lpSource->ddpfSurface.dwYUVBitCount;

        switch (lpSource->ddpfSurface.dwFourCC)
        {
         case FOURCC_UYVY: /* YVYU in VT Specs */
                        WriteVTOverlayPitch (ppdev, lpUpdateOverlay->lpDDSrcSurface->lpGbl->lPitch /2);      //Check's to see if it's VTB or not.
                        DD_WriteVTReg ( DD_VIDEO_FORMAT, 0x000C000CL );
                        DD_WriteVTReg ( DD_OVERLAY_VIDEO_KEY_MSK, 0x0000FFFF );
                        ppdev->OverlayInfo16.dwFlags &= ~DOUBLE_PITCH;
                        break;

        case FOURCC_YUY2: /* VYUY in VT Specs */
                        WriteVTOverlayPitch (ppdev,  lpUpdateOverlay->lpDDSrcSurface->lpGbl->lPitch /2 );      //Check's to see if it's VTB or not.
                        DD_WriteVTReg ( DD_VIDEO_FORMAT, 0x000B000BL );
                        DD_WriteVTReg ( DD_OVERLAY_VIDEO_KEY_MSK, 0x0000FFFF );
                        ppdev->OverlayInfo16.dwFlags &= ~DOUBLE_PITCH;
                        break;
            
        default:
                        WriteVTOverlayPitch (ppdev, lpUpdateOverlay->lpDDSrcSurface->lpGbl->lPitch);      //Check's to see if it's VTB or not.
                        DD_WriteVTReg ( DD_VIDEO_FORMAT, 0x000B000BL );
                        DD_WriteVTReg ( DD_OVERLAY_VIDEO_KEY_MSK, 0x0000FFFF );
                        ppdev->OverlayInfo16.dwFlags &= ~DOUBLE_PITCH;
                        break;
        }
    }
    else
    {
        ASSERTDD(lpSource->ddpfSurface.dwFlags & DDPF_RGB,
            "Expected us to have created only RGB or YUV overlays");

        // The overlay surface is in RGB format:

        dwBitCount = lpSource->ddpfSurface.dwRGBBitCount;
         switch ( lpSource->ddpfSurface.dwRGBBitCount )
                  {
                    case 16:
                        /***********
                        *
                        * Are we 5:5:5 or 5:6:5?
                        *
                        ************/

                        if ( lpUpdateOverlay->lpDDSrcSurface->lpGbl->ddpfSurface.dwRBitMask & 0x00008000L )
                            {
                            DD_WriteVTReg ( DD_VIDEO_FORMAT, 0x00040004L );
                            }
                         else
                             {
                             DD_WriteVTReg ( DD_VIDEO_FORMAT, 0x00030003L );
                             }

                        WriteVTOverlayPitch (ppdev, lpUpdateOverlay->lpDDSrcSurface->lpGbl->lPitch /2);
                        DD_WriteVTReg ( DD_OVERLAY_VIDEO_KEY_MSK, 0x0000FFFF );
                        ppdev->OverlayInfo16.dwFlags &= ~DOUBLE_PITCH;
                        break;

                    case 32:
                        WriteVTOverlayPitch (ppdev, lpUpdateOverlay->lpDDSrcSurface->lpGbl->lPitch /4);
                        DD_WriteVTReg ( DD_VIDEO_FORMAT, 0x00060006L );
                        DD_WriteVTReg ( DD_OVERLAY_VIDEO_KEY_MSK, 0xFFFFFFFF );
                        ppdev->OverlayInfo16.dwFlags &= ~DOUBLE_PITCH;
                        break;

                    default:
                        WriteVTOverlayPitch (ppdev, lpUpdateOverlay->lpDDSrcSurface->lpGbl->lPitch /2);      //Check's to see if it's VTB or not.
                        DD_WriteVTReg ( DD_VIDEO_FORMAT, 0x00030003L );
                        DD_WriteVTReg ( DD_OVERLAY_VIDEO_KEY_MSK, 0x0000FFFF );
                        ppdev->OverlayInfo16.dwFlags &= ~DOUBLE_PITCH;
                        break;
                  }

    }

    // Calculate start of video memory in QWORD boundary

    dwBytesPerPixel = dwBitCount >> 3;

    dwStart = (lpUpdateOverlay->rSrc.top * dwStride)
            + (lpUpdateOverlay->rSrc.left * dwBytesPerPixel);

    dwStart = dwStart - (dwStart & 0x7);

    ppdev->dwOverlayFlipOffset = dwStart;     // Save for flip
    dwStart += (DWORD)lpSource->fpVidMem;

    // Set overlay filter characteristics:
        /*
         * This register write enables the overlay and scaler registers
         */
        //gwRedTemp =0 ; //gamma control
        if(0)       //if ( gwRedTemp )
            {
            DD_WriteVTReg ( DD_OVERLAY_SCALE_CNTL, 0xC0000001L | g_dwGamma );
            }
        else
            {
            DD_WriteVTReg ( DD_OVERLAY_SCALE_CNTL, 0xC0000003L | g_dwGamma );
            }

    /*
     * Get offset of buffer, if we are using a YUV Planar Overlay we
     * must extract the address from another field (dwReserved1).
     */

    SrcBufOffset = (DWORD)(lpUpdateOverlay->lpDDSrcSurface->lpGbl->fpVidMem);  //- (FLATPTR)ppdev->pjScreen;

    ppdev->OverlayInfo16.dwBuf0Start = SrcBufOffset;
    ppdev->OverlayInfo16.dwBuf1Start = SrcBufOffset;

    /*
     * Set up the colour keying, if any?
     */


    if ( lpUpdateOverlay->dwFlags & DDOVER_KEYSRC          ||
         lpUpdateOverlay->dwFlags & DDOVER_KEYSRCOVERRIDE  ||
         lpUpdateOverlay->dwFlags & DDOVER_KEYDEST         ||
         lpUpdateOverlay->dwFlags & DDOVER_KEYDESTOVERRIDE )
      {
        ppdev->OverlayInfo16.dwOverlayKeyCntl = 0;

        if ( lpUpdateOverlay->dwFlags & DDOVER_KEYSRC ||
             lpUpdateOverlay->dwFlags & DDOVER_KEYSRCOVERRIDE )
          {
            //Set source colour key
            if ( lpUpdateOverlay->dwFlags & DDOVER_KEYSRC )
              {
                Temp=lpUpdateOverlay->lpDDDestSurface->ddckCKSrcOverlay.dwColorSpaceLowValue;
              }
            else
              {
                Temp=lpUpdateOverlay->overlayFX.dckSrcColorkey.dwColorSpaceLowValue;
              }
             DD_WriteVTReg ( DD_OVERLAY_VIDEO_KEY_CLR, Temp );
             //ppdev->OverlayInfo16.dwOverlayKeyCntl &= 0xFFFFFEE8;
             if(ppdev->iAsic ==CI_M64_VTA)
                 {
                 ppdev->OverlayInfo16.dwOverlayKeyCntl &= 0xFFFFF0E8;
                 ppdev->OverlayInfo16.dwOverlayKeyCntl |= 0x00000c14;
                 }
             else
                 {
                ppdev->OverlayInfo16.dwOverlayKeyCntl &= 0xFFFFFEE8;
                ppdev->OverlayInfo16.dwOverlayKeyCntl |= 0x00000114;
                 }
          }

        if ( lpUpdateOverlay->dwFlags & DDOVER_KEYDEST ||
             lpUpdateOverlay->dwFlags & DDOVER_KEYDESTOVERRIDE )
          {
            //Set destination colour key
            if ( lpUpdateOverlay->dwFlags & DDOVER_KEYDEST )
              {
                Temp=lpUpdateOverlay->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceLowValue;
              }
            else
              {
                Temp=lpUpdateOverlay->overlayFX.dckDestColorkey.dwColorSpaceLowValue;
                if ( Temp == 0 && ppdev->cBitsPerPel == 32 )
                    Temp = 0x00FF00FF;
              }
            DD_WriteVTReg ( DD_OVERLAY_GRAPHICS_KEY_CLR, Temp );
            ppdev->OverlayInfo16.dwOverlayKeyCntl &= 0xFFFFFF8FL;
            ppdev->OverlayInfo16.dwOverlayKeyCntl |= 0x00000050L;
          }
      }
    else
      {
        //No source or destination colour keying
        DD_WriteVTReg ( DD_OVERLAY_GRAPHICS_KEY_CLR, 0x00000000 );
        ppdev->OverlayInfo16.dwOverlayKeyCntl = 0x8000211L;
      }

    /*
     * Now set the stretch factor and  overlay position.
     */
      ppdev->OverlayWidth = rOverlay.right - rOverlay.left;
      ppdev->OverlayHeight = rOverlay.bottom - rOverlay.top;



    //LastOverlayPos=OverlayRect;

    ppdev->OverlayInfo16.dwFlags |= OVERLAY_ALLOCATED;
    ppdev->OverlayInfo16.dwFlags |= UPDATEOVERLAY;
    ppdev->OverlayInfo16.dwFlags |= OVERLAY_VISIBLE;
    ppdev->OverlayInfo16.rOverlay = rOverlay;
    ppdev->OverlayInfo16.dwVInc = dwVInc;
    ppdev->OverlayInfo16.dwHInc = dwHInc;
    // new for DeskScanCallback
    ppdev->OverlayInfo16.rDst = rOverlay;
    ppdev->OverlayInfo16.rSrc = lpUpdateOverlay->rSrc;


    DeskScanCallback (ppdev );

    ppdev->OverlayInfo16.dwFlags &= ~UPDATEOVERLAY;
    
    /*
     * return to DirectDraw.
     */


    lpUpdateOverlay->ddRVal = DD_OK;
    return(DDHAL_DRIVER_HANDLED);
}





  /*
   * structure for passing information to DDHAL SetOverlayPosition
   */
  DWORD  DdSetOverlayPosition (PDD_SETOVERLAYPOSITIONDATA  lpSetOverlayPosition )
    {
      RECTL rOverlay;
      PDEV* ppdev;

      ppdev = (PDEV*) lpSetOverlayPosition->lpDD->dhpdev;

      rOverlay.left   = lpSetOverlayPosition->lXPos;
      rOverlay.top    = lpSetOverlayPosition->lYPos;
      rOverlay.right  = ppdev->OverlayWidth + lpSetOverlayPosition->lXPos;
      rOverlay.bottom = ppdev->OverlayHeight + lpSetOverlayPosition->lYPos;

      

      /*
       * We can't clip overlays, so we must make sure the co-ord, are within the
       * boundaries of the screen.
       */

      rOverlay.top    = max ( 0, rOverlay.top  );
      rOverlay.left   = max ( 0, rOverlay.left );
      rOverlay.bottom = min ( (DWORD)ppdev->cyScreen -1 ,
                              (DWORD) rOverlay.bottom );
      rOverlay.right  = min ( (DWORD)ppdev->cxScreen  -1 ,
                              (DWORD) rOverlay.right );

      /*
       *Set overlay position
       */
      M64_CHECK_FIFO_SPACE(ppdev,ppdev-> pjMmBase, 1);

      ppdev->OverlayWidth =rOverlay.right - rOverlay.left;
      ppdev->OverlayHeight = rOverlay.bottom - rOverlay.top;


      ppdev->OverlayInfo16.dwFlags  |= SETOVERLAYPOSITION;
      ppdev->OverlayInfo16.rOverlay  = rOverlay;
      ppdev->OverlayInfo16.rDst = rOverlay;

      DeskScanCallback (ppdev );

      ppdev->OverlayInfo16.dwFlags  &= ~SETOVERLAYPOSITION;

      /*
       * return to DirectDraw
       */

      lpSetOverlayPosition->ddRVal =    DD_OK;
      return DDHAL_DRIVER_HANDLED;
    }


/******************************Public*Routine******************************\
* DWORD DdDestroySurface
*
* Note that if DirectDraw did the allocation, DDHAL_DRIVER_NOTHANDLED
* should be returned.
*
\**************************************************************************/

DWORD DdDestroySurface(
PDD_DESTROYSURFACEDATA lpDestroySurface)
{
    PDEV*               ppdev;
    DD_SURFACE_GLOBAL*  lpSurface;
    LONG                lPitch;
    OH*                 poh;

    DISPDBG((10, " Enter Destroy Surface"));
    ppdev = (PDEV*) lpDestroySurface->lpDD->dhpdev;
    lpSurface = lpDestroySurface->lpDDSurface->lpGbl;
    poh= (OH*)( lpSurface->dwReserved1);

    if( (ULONG)lpSurface->dwReserved1 != (ULONG_PTR) NULL )
        {
        // let's see first if the value in reserved field is indeed an poh and not a cookie
        // because I don't know if ddraw is using also this value for system memory surfaces
        if(poh->ohState==OH_PERMANENT)
            {
            // bMoveAllDfbsFromOffscreenToDibs(ppdev);        // avoid fragmentation
            pohFree(ppdev, poh);
    
            // Since we did the original allocation ourselves, we have to
            // return DDHAL_DRIVER_HANDLED here:
    
            lpDestroySurface->ddRVal = DD_OK;
              DISPDBG((10, " Exit Destroy Surface OK; deallocate poh X=%d, Y=%d ", poh->x, poh->y));
            return(DDHAL_DRIVER_HANDLED);
            }
        DISPDBG((10, " Exit Destroy Surface Not OK : The Reserved1 is not a poh"));
        }

    DISPDBG((10, " Exit Destroy Surface Not OK : The Reserved1 is NULL"));
    return(DDHAL_DRIVER_NOTHANDLED);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\paint.c ===
/******************************Module*Header*******************************\
* Module Name: paint.c
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Data*********************************\
* MIX translation table
*
* Translates a mix 1-16, into an old style Rop 0-255.
*
\**************************************************************************/

BYTE gaMix[] =
{
    0xFF,  // R2_WHITE        - Allow rop = gaMix[mix & 0x0F]
    0x00,  // R2_BLACK
    0x05,  // R2_NOTMERGEPEN
    0x0A,  // R2_MASKNOTPEN
    0x0F,  // R2_NOTCOPYPEN
    0x50,  // R2_MASKPENNOT
    0x55,  // R2_NOT
    0x5A,  // R2_XORPEN
    0x5F,  // R2_NOTMASKPEN
    0xA0,  // R2_MASKPEN
    0xA5,  // R2_NOTXORPEN
    0xAA,  // R2_NOP
    0xAF,  // R2_MERGENOTPEN
    0xF0,  // R2_COPYPEN
    0xF5,  // R2_MERGEPENNOT
    0xFA,  // R2_MERGEPEN
    0xFF   // R2_WHITE        - Allow rop = gaMix[mix & 0xFF]
};

/******************************Public*Routine******************************\
* BOOL DrvPaint
*
\**************************************************************************/

BOOL DrvPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix)
{
    ROP4 rop4;

    rop4 = ((MIX) gaMix[mix >> 8] << 8) | gaMix[mix & 0xf];

    // Since our DrvFillPath routine handles almost all fills, DrvPaint
    // won't get called all that much (mainly via PaintRgn, FillRgn, or
    // complex clipped polygons).  As such, we save some code and simply
    // punt to DrvBitBlt:

    return(DrvBitBlt(pso, NULL, NULL, pco, NULL, &pco->rclBounds, NULL,
                     NULL, pbo, pptlBrush, rop4));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\palette.c ===
/******************************Module*Header*******************************\
* Module Name: palette.c
*
* Palette support.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

// Global Table defining the 20 Window default colours.  For 256 colour
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.

PALETTEENTRY gapalBase[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};

/******************************Public*Routine******************************\
* BOOL bInitializePalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bInitializePalette(
PDEV*    ppdev,
DEVINFO* pdi)
{
    PALETTEENTRY*   ppal;
    PALETTEENTRY*   ppalTmp;
    ULONG           ulLoop;
    BYTE            jRed;
    BYTE            jGre;
    BYTE            jBlu;
    HPALETTE        hpal;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // Allocate our palette:

        ppal = AtiAllocMem(LPTR, FL_ZERO_MEMORY, sizeof(PALETTEENTRY) * 256);
        if (ppal == NULL)
            goto ReturnFalse;

        ppdev->pPal = ppal;

        // Generate 256 (8*4*4) RGB combinations to fill the palette

        jRed = 0;
        jGre = 0;
        jBlu = 0;

        ppalTmp = ppal;

        for (ulLoop = 256; ulLoop != 0; ulLoop--)
        {
            ppalTmp->peRed   = jRed;
            ppalTmp->peGreen = jGre;
            ppalTmp->peBlue  = jBlu;
            ppalTmp->peFlags = 0;

            ppalTmp++;

            if (!(jRed += 32))
                if (!(jGre += 32))
                    jBlu += 64;
        }

        // Fill in Windows reserved colours from the WIN 3.0 DDK
        // The Window Manager reserved the first and last 10 colours for
        // painting windows borders and for non-palette managed applications.

        for (ulLoop = 0; ulLoop < 10; ulLoop++)
        {
            // First 10

            ppal[ulLoop]       = gapalBase[ulLoop];

            // Last 10

            ppal[246 + ulLoop] = gapalBase[ulLoop+10];
        }

        // Create handle for palette.

        hpal = EngCreatePalette(PAL_INDEXED, 256, (ULONG*) ppal, 0, 0, 0);
    }
    else
    {
        ASSERTDD((ppdev->iBitmapFormat == BMF_16BPP) ||
                 (ppdev->iBitmapFormat == BMF_24BPP) ||
                 (ppdev->iBitmapFormat == BMF_32BPP),
                 "This case handles only 16, 24 or 32bpp");

        hpal = EngCreatePalette(PAL_BITFIELDS, 0, NULL,
                                ppdev->flRed, ppdev->flGreen, ppdev->flBlue);
    }

    ppdev->hpalDefault = hpal;
    pdi->hpalDefault   = hpal;

    if (hpal == 0)
        goto ReturnFalse;

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializePalette"));
    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vUninitializePalette
*
* Frees resources allocated by bInitializePalette.
*
* Note: In an error case, this may be called before bInitializePalette.
*
\**************************************************************************/

VOID vUninitializePalette(PDEV* ppdev)
{
    // Delete the default palette if we created one:

    if (ppdev->hpalDefault != 0)
        EngDeletePalette(ppdev->hpalDefault);

    if (ppdev->pPal != (PALETTEENTRY*) NULL)
        AtiFreeMem(ppdev->pPal);
}

/******************************Public*Routine******************************\
* BOOL bEnablePalette
*
* Initialize the hardware's 8bpp palette registers.
*
\**************************************************************************/

BOOL bEnablePalette(PDEV* ppdev)
{
    BYTE        ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT pScreenClut;
    ULONG       ulReturnedDataLength;
    ULONG       cColors;
    PVIDEO_CLUTDATA pScreenClutData;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // Fill in pScreenClut header info:

        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        // Copy colours in:

        cColors = 256;
        pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

        while(cColors--)
        {
            pScreenClutData[cColors].Red =    ppdev->pPal[cColors].peRed >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Green =  ppdev->pPal[cColors].peGreen >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue =   ppdev->pPal[cColors].peBlue >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }

        // Set palette registers:

        if (!AtiDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_COLOR_REGISTERS,
                               pScreenClut,
                               MAX_CLUT_SIZE,
                               NULL,
                               0,
                               &ulReturnedDataLength))
        {
            DISPDBG((0, "Failed bEnablePalette"));
            return(FALSE);
        }
    }

    DISPDBG((5, "Passed bEnablePalette"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisablePalette
*
* Undoes anything done in bEnablePalette.
*
\**************************************************************************/

VOID vDisablePalette(
PDEV*   ppdev)
{
    // Nothin' to do
}

/******************************Public*Routine******************************\
* VOID vAssertModePalette
*
* Sets/resets the palette in preparation for full-screen/graphics mode.
*
\**************************************************************************/

VOID vAssertModePalette(
PDEV*   ppdev,
BOOL    bEnable)
{
    // USER immediately calls DrvSetPalette after switching out of
    // full-screen, so we don't have to worry about resetting the
    // palette here.
}

/******************************Public*Routine******************************\
* BOOL DrvSetPalette
*
* DDI entry point for manipulating the palette.
*
\**************************************************************************/

BOOL DrvSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BYTE            ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT     pScreenClut;
    PVIDEO_CLUTDATA pScreenClutData;
    PDEV*           ppdev;

    UNREFERENCED_PARAMETER(fl);

    ppdev = (PDEV*) dhpdev;

    // Fill in pScreenClut header info:

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = (USHORT) cColors;
    pScreenClut->FirstEntry = (USHORT) iStart;

    pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

    if (cColors != PALOBJ_cGetColors(ppalo, iStart, cColors,
                                     (ULONG*) pScreenClutData))
    {
        DISPDBG((0, "DrvSetPalette failed PALOBJ_cGetColors"));
        return (FALSE);
    }

    // Set the high reserved byte in each palette entry to 0.
    // Do the appropriate palette shifting to fit in the DAC.

    if (ppdev->cPaletteShift)
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Red >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Green >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }
    }
    else
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Unused = 0;
        }
    }

    // Set palette registers

    if (!AtiDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_SET_COLOR_REGISTERS,
                           pScreenClut,
                           MAX_CLUT_SIZE,
                           NULL,
                           0,
                           &cColors))
    {
        DISPDBG((0, "DrvSetPalette failed SET_COLOR_REGISTERS"));
        return (FALSE);
    }

    return(TRUE);

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\pal_supp.c ===
#include "precomp.h"

#if   PAL_SUPPORT



void  Init3D_Info(PDEV*,PVOID);
ULONG GetDisplayMode(PDEV* ,PVOID ) ;
ULONG AccessDevice(PDEV* , PVOID, PVOID ) ;
ULONG  GetConfiguration(PDEV* ,PVOID )  ;
ULONG WriteRegFnct(PDEV* ,PVOID )  ;
ULONG  ReadRegFnct(PDEV* ,PVOID , PVOID)  ;
void  I2CAccess_New(PDEV* ,LPI2CSTRUCT_NEW , LPI2CSTRUCT_NEW )  ;
BYTE ReverseByte(BYTE )  ;
WORD Ack(PDEV*, WORD , BOOL )   ;
void Start(PDEV*, WORD )  ;
void Stop(PDEV*, WORD )   ;
void I2CDelay(PDEV*, WORD)     ;
void WriteByteI2C(PDEV*, WORD , BYTE )  ;
BYTE ReadByteI2C(PDEV*,WORD ) ;
BOOL DisableOvl(PDEV* ) ;
ULONG AllocOffscreenMem(PDEV* , PVOID , PVOID)  ;
ULONG DeallocOffscreenMem(PDEV* ) ;
ULONG AllocOffscreenMem(PDEV* , PVOID , PVOID )   ;
void WriteVT264Reg(PDEV* , WORD , BYTE , DWORD  );
DWORD ReadVT264Reg(PDEV* , WORD , BYTE ) ;
void WriteI2CData(PDEV* , WORD , BYTE );
ULONG ReallocMemory(PDEV* ) ;
void SetI2CDataDirection(PDEV* , WORD, BOOL ) ;
void WriteI2CClock(PDEV* , WORD , BYTE ) ;
VOID  DbgExtRegsDump(PDEV* );
VOID TempFnct(PDEV* );
VOID DeallocDirectDraw(PDEV* ) ;
VOID  ResetPalindrome(PDEV* ,PDEV* );





REGSBT819INFO  RegsBT819[NUM_BT819_REGS] = {                                                                           /* Register's Name*/
        { 1,  STATUS,      0, 0x7F,   0,    0,     0, 0 },      // 0 - PRES
        { 1,  STATUS,      1, 0xBF,   0,    0,     0, 0 },      // 1 - HLOC
        { 1,  STATUS,      2, 0xDF,   0,    0,     0, 0 },      // 2 - FIELD
        { 1,  STATUS,      3, 0xEF,   0,    0,     0, 0 },      // 3 - NUML
        { 1,  STATUS,      4, 0xF7,   0,    0,     0, 0 },      // 4 - CSEL
        { 1,  STATUS,      6, 0xFD,   0,    0,     0, 0 },      // 5 - LOF
        { 1,  STATUS,      7, 0xFE,   0,    0,     0, 0 },      // 6 - COF

        { 1,  IFORM,       0, 0x7F,   0,    0,     0, 0  },     // 7 -  HACTIVE_I
        { 2,  IFORM,       1, 0x9F,   0,    0,     0, 0  },     // 8 -  MUXEL
        { 2,  IFORM,       3, 0xE7,   0,    0,     0, 0  },     // 9 -  XTSEL
        { 2,  IFORM,       6, 0xFC,   0,    0,     0, 0  },     // 10 - FORMAT

        { 1,  TDEC,        0,  0x7F,  0,     0,    0, 0 },      // 11 - DEC_FIELD
        { 7,  TDEC,        1,  0x80,  0,     0,    0, 0 },      // 12 - DEC_RAT

        { 10, VDELAY_LO,   0,  0x00,  CROP,      0,      0x3F, 0 },      // 13 - VDELAY
        { 10, VACTIVE_LO,  0,  0x00,  CROP,      2,      0xCF, 0 },      // 14 - VACTIVE
        { 10, HDELAY_LO,   0,  0x00,  CROP,      4,      0xF3, 0 },      // 15 - HDELAY
        { 10, HACTIVE_LO,  0,  0x00,  CROP,      6,      0xFC, 0 },      // 16 - HACTIVE

        { 16, HSCALE_LO,   0,  0x00,  HSCALE_HI, 0,      0x00, 0 },      // 17 - HSCALE

        { 8,  BRIGHT,      0,  0x00,  0,      0,   0, 0 },      // 18 - BRIGHT

        { 1, CONTROL,      0,  0x7F,  0,      0,   0, 0 },       // 19 - LNOTCH
        { 1, CONTROL,      1,  0xBF,  0,      0,   0, 0 },       // 20 - COMP
        { 1, CONTROL,      2,  0xDF,  0,      0,   0, 0 },       // 21 - LDEC
        { 1, CONTROL,      3,  0xEF,  0,      0,   0, 0 },       // 22 - CBSENSE
        { 1, CONTROL,      4,  0xF7,  0,      0,   0, 0 },       // 23 - INTERP
        { 9, CONTRAST_LO,  0,  0x00,  CONTROL,   5,      0xFB, 0 },       // 24 - CON
        { 9, SAT_U_LO,     0,  0x00,  CONTROL,   6,      0xFD, 0 },       // 25 - SAT_U
        { 9, SAT_V_LO,     0,  0x00,  CONTROL,   7,      0xFE, 0 },       // 26 - SAT_V

        { 8, HUE,          0,  0x00,  0,      0,   0, 0 },       // 27 - HUE

        { 1, OFORM,        0,  0x7F,   0,      0,   0, 0 },       // 28 - RANGE
        { 2, OFORM,        1,  0x9F,   0,      0,   0, 0 },       // 29 - RND
        { 1, OFORM,        3,  0xEF,   0,      0,   0, 0 },       // 30 - FIFO_BURST
        { 1, OFORM,        4,  0xF7,   0,      0,   0, 0 },       // 31 - CODE
        { 1, OFORM,        5,  0xFB,   0,      0,   0, 0 },       // 32 - LEN
        { 1, OFORM,        6,  0xFD,   0,      0,   0, 0 },       // 33 - SPI
        { 1, OFORM,        7,  0xFE,   0,      0,   0, 0 },       // 34 - FULL

        { 1, VSCALE_HI,    0,  0x7F,   0,      0,   0, 0 },       // 35 - LINE
        { 1, VSCALE_HI,    1,  0xBF,   0,      0,   0, 0 },       // 36 - COMB
        { 1, VSCALE_HI,    2,  0xDF,   0,      0,   0, 0 },       // 37 - INT

        { 13,VSCALE_LO,    0,  0x00,   VSCALE_HI, 3,      0xE0, 0 },       // 38 - VSCALE

        { 1, VPOLE,        0,  0x7F,   0,      0,   0, 0 },        // 39 - OUTEN
        { 1, VPOLE,        1,  0xBF,   0,      0,   0, 0 },        // 40 - VALID_PIN
        { 1, VPOLE,        2,  0xDF,   0,      0,   0, 0 },        // 41 - AFF_PIN
        { 1, VPOLE,        3,  0xEF,   0,      0,   0, 0 },        // 42 - CBFLAG_PIN
        { 1, VPOLE,        4,  0xF7,   0,      0,   0, 0 },        // 43 - FIELD_PIN
        { 1, VPOLE,        5,  0xFB,   0,      0,   0, 0 },        // 44 - ACTIVE_PIN
        { 1, VPOLE,        6,  0xFD,   0,      0,   0, 0 },        // 45 - HRESET_PIN
        { 1, VPOLE,        7,  0xFE,   0,      0,   0, 0 },        // 46 - VRESET_PIN

        { 4, IDCODE,       0,  0,   0,      0,   0, READONLY }, // 47 - PART_ID
        { 4, IDCODE,       4,  0,   0,      0,   0, READONLY }, // 48 - PART_REV

        { 8, ADELAY,       0,  0x00,   0,      0,   0, 0 },        // 49 - ADELAY
        { 8, BDELAY,       0,  0x00,   0,      0,   0, 0 },        // 50 - BDELAY


        { 2, ADC,          0,  0x3F,   0,      0,   0, 0 },        // 51 - CLAMP
        { 1, ADC,          2,  0xDF,   0,      0,   0, 0 },        // 52 - SYNC_T
        { 1, ADC,          3,  0xEF,   0,      0,   0, 0 },        // 53 - AGC_EN
        { 1, ADC,          4,  0xF7,   0,      0,   0, 0 },        // 54 - CLK_SLEEP
        { 1, ADC,          5,  0xFB,   0,      0,   0, 0 },        // 55 - Y_SLEEP
        { 1, ADC,          6,  0xFD,   0,      0,   0, 0 },        // 56 - C_SLEEP

        { 8, SRESET,       0,  0x00,   0,      0,   0, 0 },        // 57 - SRESET
};


// enable, disable the hardware for video capture, query the maximum width of the capture
ULONG VideoCaptureFnct(PDEV* ppdev,PVOID pvIn, PVOID pvOut)
{
VIDEOCAPTUREDATA   * pBiosCapture, *pBiosCaptureOut;

VIDEO_CAPTURE   VideoCaptureDataIn, VideoCaptureDataOut;
DWORD   ReturnedDataLength ;

pBiosCapture= ( VIDEOCAPTUREDATA *)pvIn;
VideoCaptureDataIn.dwSubFunct= pBiosCapture->dwSubFunc;
VideoCaptureDataIn.dwCaptureWidth=0;
VideoCaptureDataIn.dwCaptureMode=pBiosCapture->dwCaptureMode;

switch( pBiosCapture->dwSubFunc)
     {
     case 0:
        DISPDBG((DEBUG_ESC_2, "IOCTL_VIDEO_CAPTURE: requested subfunct = ENABLE"));
         break;
     case 1:
        DISPDBG((DEBUG_ESC_2, "IOCTL_VIDEO_CAPTURE: requested subfunct = DISABLE"));
         break;
    case 2:
        DISPDBG((DEBUG_ESC_2, "IOCTL_VIDEO_CAPTURE: requested subfunct = QUERY"));
        DISPDBG((DEBUG_ESC_2, "IOCTL_VIDEO_CAPTURE: requested  mode = %d", pBiosCapture->dwCaptureMode));
    break;
    default:
        DISPDBG((DEBUG_ESC_2, "IOCTL_VIDEO_CAPTURE: requested subfunct = Wrong Parameter"));
     }

if (!AtiDeviceIoControl(ppdev->hDriver,
                          IOCTL_VIDEO_ATI_CAPTURE,
                          &VideoCaptureDataIn,
                          sizeof(VIDEO_CAPTURE),
                          &VideoCaptureDataOut,
                          sizeof(VIDEO_CAPTURE),
                          &ReturnedDataLength))
        {
        DISPDBG((0, "bInitializeATI - Failed IOCTL_VIDEO_ATI_CAPTURE"));
        return 0; // the CWDDE is require a -1, but in win32 we have the return type ULONG
        }
DISPDBG((DEBUG_ESC_2, "IOCTL_VIDEO_CAPTURE: maximum capture width returned= %d", VideoCaptureDataOut.dwCaptureWidth));
pBiosCaptureOut= ( VIDEOCAPTUREDATA *)pvOut;
if( pBiosCapture->dwSubFunc==2)
        pBiosCaptureOut->dwCaptureWidth=VideoCaptureDataOut.dwCaptureWidth;
else
       pBiosCaptureOut->dwCaptureWidth=pBiosCapture->dwCaptureWidth;

pBiosCaptureOut ->dwSubFunc=pBiosCapture->dwSubFunc;
pBiosCaptureOut ->dwSize=pBiosCapture->dwSize;
pBiosCaptureOut ->dwCaptureHeight=pBiosCapture->dwCaptureHeight;
pBiosCaptureOut ->fccFormat=pBiosCapture->fccFormat;
pBiosCaptureOut ->dwBitMasks[1]=pBiosCapture->dwBitMasks[1];
pBiosCaptureOut ->dwBitMasks[2]=pBiosCapture->dwBitMasks[2];
pBiosCaptureOut ->dwBitMasks[3]=pBiosCapture->dwBitMasks[3];
pBiosCaptureOut ->dwCaptureMode=pBiosCapture->dwCaptureMode;

return 1 ;
}


// this function is requested for 3D driver init
void  Init3D_Info(PDEV* ppdev,PVOID pvOut)
{
    PHX2DHWINFO *pphx;                 /* Pointer to the structure containing info for 3D driver */

    pphx = (PHX2DHWINFO *) pvOut;
    // initialize the structure
    memset( pvOut, 0, sizeof(PHX2DHWINFO));
    // set size
    pphx->dwSize=sizeof(PHX2DHWINFO);
    // set ASIC type
    pphx->dwChipID=ppdev->iAsic;
    // set the asic revision
    // not implemented for the moment
    // detect if it's GT and set the flag
    if( ppdev->iAsic>=CI_M64_GTA )
        {
        pphx->b3DAvail = TRUE;
        pphx->dwFIFOSize = 32;
        }
    else
        {
        pphx->b3DAvail = FALSE;
        }
     // linear address of the aperture
     pphx->dwVideoBaseAddr=(ULONG)(ppdev->pjScreen);
     // linear address of the registers
     pphx->dwRegisterBaseAddr=(ULONG)(ppdev->pjMmBase);
     // linear address of the offscreen memory start
     pphx->dwOffScreenAddr=((ULONG)(ppdev->pjScreen) +
            ((ppdev->cxScreen)*(ppdev->cyScreen)*(ppdev->cBitsPerPel))/8);
     // offscreen size
     pphx->dwOffScreenSize=((ppdev->cyMemory)*ppdev->lDelta) -
            ((ppdev->cxScreen)*(ppdev->cyScreen)*(ppdev->cBitsPerPel))/8;
     // RAM size
     pphx->dwTotalRAM= ((ppdev->cyMemory)*ppdev->lDelta) ;
     // screen info
     pphx->dwScreenWidth=ppdev->cxScreen;
     pphx->dwScreenHeight=ppdev->cyScreen;
     pphx->dwScreenPitch=ppdev->cyScreen;
     pphx->dwBpp=ppdev->cBitsPerPel;
     if(pphx->dwBpp==16)
        {
        if(ppdev->flGreen==0x3e00)
            {
            pphx->dwAlphaBitMask=0x8000;
            pphx->dwRedBitMask=0x7c00;
            pphx->dwGreenBitMask=0x03e0;
            pphx->dwBlueBitMask=0x001f;
            }
        else
            {
            pphx->dwAlphaBitMask=0;
            pphx->dwRedBitMask=0xf800;
            pphx->dwGreenBitMask=0x07e0;
            pphx->dwBlueBitMask=0x001f;
            }
        }
     else
        {
        pphx->dwAlphaBitMask=0;
        pphx->dwRedBitMask=0;
        pphx->dwGreenBitMask=0;
        pphx->dwBlueBitMask=0;
        }
}

// the following functions are requested for palindrome support
 ULONG GetDisplayMode(PDEV* ppdev,PVOID pvOut)
{
ULONG  RetVal;
ModeInfo*       pModeInfo;

pModeInfo=(ModeInfo*)pvOut;
RetVal=sizeof(ModeInfo);

#ifndef  DYNAMIC_REZ_AND_COLOUR_CHANGE  // palindrome support for on the fly rez and colour depth
    pModeInfo->ScreenWidth= ppdev->cxScreen;
    pModeInfo->ScreenHeight=ppdev->cyScreen;
#else  // these values are used for dynamic resolution and colour depth support
    pModeInfo->ScreenWidth=1280;    //ppdev->cxScreen;
    pModeInfo->ScreenHeight=1024;   //ppdev->cyScreen;
#endif

//pModeInfo->ScreenColorFormat
if (ppdev->cBitsPerPel == 4)
         pModeInfo->ScreenColorFormat=ATIConfig_ColorFmt_4_Packed;
else if (ppdev->cBitsPerPel == 8)
         pModeInfo->ScreenColorFormat=ATIConfig_ColorFmt_8;
else if (ppdev->cBitsPerPel == 16)
         pModeInfo->ScreenColorFormat=ATIConfig_ColorFmt_RGB565;
else if (ppdev->cBitsPerPel == 24)
         pModeInfo->ScreenColorFormat=ATIConfig_ColorFmt_RGB888;
else if (ppdev->cBitsPerPel == 32)
         pModeInfo->ScreenColorFormat=ATIConfig_ColorFmt_aRGB8888;
else
         pModeInfo->ScreenColorFormat=-1;

pModeInfo->DesctopWidth=ppdev->cxScreen;
pModeInfo->DesctopHeight=ppdev->cyScreen;
pModeInfo->SystemColorFormat=pModeInfo->ScreenColorFormat;
return (RetVal);
}


ULONG AccessDevice(PDEV* ppdev,PVOID pvIn, PVOID pvOut)
       {
       ULONG RetVal;
       ACCESSDEVICEDATA*   pstrAccessDeviceData;
       DWORD*   pstrAccessDeviceDataOut;

       RetVal=1;
       pstrAccessDeviceDataOut=(DWORD*)pvOut;
       pstrAccessDeviceData=(ACCESSDEVICEDATA*)pvIn;

       if(pstrAccessDeviceData->dwAccessDeviceCode==ACCESSDEVICECODE_CONNECTOR)
       {
           switch(pstrAccessDeviceData->dwSubFunc)
           {
           case    ACCESSDEVICEDATA_SUBFUNC_ALLOC:
               if((ppdev->pal_str.lpOwnerAccessStructConnector)==NULL)
               {   //the device is not allocated
                   (ppdev->pal_str.lpOwnerAccessStructConnector)=pstrAccessDeviceData;
                   (*pstrAccessDeviceDataOut) = (DWORD)pstrAccessDeviceData;
               }
               else
               {   // the device is allocated to another owner
                   (*pstrAccessDeviceDataOut) = (DWORD)(ppdev->pal_str.lpOwnerAccessStructConnector);
               }
               break;
            case   ACCESSDEVICEDATA_SUBFUNC_FREE:
               if((ppdev->pal_str.lpOwnerAccessStructConnector)!=NULL)
                 { //the device is allocated
                     if((ppdev->pal_str.lpOwnerAccessStructConnector)==pstrAccessDeviceData)   //if the owner wants to free  the device
                     {
                       (*pstrAccessDeviceDataOut) = (DWORD)NULL;
                       (ppdev->pal_str.lpOwnerAccessStructConnector)=NULL;  // no owner at this time
                     }
                     else
                     {      /*
                            //other process is the owner, so fail
                          (*pstrAccessDeviceDataOut) = (DWORD)pstrAccessDeviceData;
                           */
                           // Due to the fact that Palindrome is inconsistent in using the same pointer to ACCESSDEVICE struct
                           // for QUERY, ALLOC and FREE,  we have to force the dealocation anyway
                          (*pstrAccessDeviceDataOut) = (DWORD)NULL;
                          (ppdev->pal_str.lpOwnerAccessStructConnector)=NULL;  // no owner at this time
        
                     }
                  }
                 else
                 {   // the device is not allocated , so we can free it anyway
                     (*pstrAccessDeviceDataOut) =(DWORD) NULL;
                     (ppdev->pal_str.lpOwnerAccessStructConnector)=NULL;
                 }

               break;
           case    ACCESSDEVICEDATA_SUBFUNC_QUERY:
               if(( ppdev->pal_str.lpOwnerAccessStructConnector)==NULL)  // if the device is free
               {
                   (*pstrAccessDeviceDataOut) = (DWORD)NULL;
               }
               else
               {   // if the device is owned already
                  (*pstrAccessDeviceDataOut) = (DWORD)(ppdev->pal_str.lpOwnerAccessStructConnector);
               }

               break;
           default:
               RetVal=0xffffffff;
           }
       }
       else
       {
        if(pstrAccessDeviceData->dwAccessDeviceCode==ACCESSDEVICECODE_OVERLAY)
          {
              switch(pstrAccessDeviceData->dwSubFunc)
              {
              case     ACCESSDEVICEDATA_SUBFUNC_ALLOC:
                  if((ppdev->pal_str.lpOwnerAccessStructOverlay)==NULL)
                  {
                        //the device is not allocated by an external client
                        // but first verify if DDraw is not using it
                      if(ppdev->semph_overlay==0)             //  = 0  resource free;     = 1  in use by DDraw;    = 2  in use by Palindrome;
                          {
                          (ppdev->pal_str.lpOwnerAccessStructOverlay)=pstrAccessDeviceData;
                          (*pstrAccessDeviceDataOut) =(DWORD) pstrAccessDeviceData;
                          ppdev->semph_overlay=2;
                          }
                      else
                          {
                           // the overlay is used by DDraw, so let's try to do this:
                          (*pstrAccessDeviceDataOut) =(DWORD)NULL;
                          }

                  }
                  else
                  {    // the device is allocated to another owner
                      (*pstrAccessDeviceDataOut) =(DWORD) (ppdev->pal_str.lpOwnerAccessStructOverlay);
                  }
                  break;
               case    ACCESSDEVICEDATA_SUBFUNC_FREE:
                  if((ppdev->pal_str.lpOwnerAccessStructOverlay)!=NULL)
                    {  //the device is allocated
                        if((ppdev->pal_str.lpOwnerAccessStructOverlay)==pstrAccessDeviceData)   //if the owner wants to free  the device
                        {
                          (*pstrAccessDeviceDataOut) = (DWORD)NULL;
                          (ppdev->pal_str.lpOwnerAccessStructOverlay)=NULL;     // no owner at this time
                          ppdev->semph_overlay=0;
                        }
                        else
                        {       //other process is the owner, so we are supposed to fail
                           // (*pstrAccessDeviceDataOut) = (DWORD)pstrAccessDeviceData;

                           // but due to the fact that the palindrome code it's not consistently using the same pointer to the ACCESSDEVICEDATA structure
                           // inside a session of allocation/deallocation, we are failing the owner test so that we will free the overlay anyway if it's used by palindrome
                            if(ppdev->semph_overlay==2)
                                {
                                (*pstrAccessDeviceDataOut) = (DWORD)NULL;
                                (ppdev->pal_str.lpOwnerAccessStructOverlay)=NULL;     // no owner at this time
                                ppdev->semph_overlay=0;
                                }
                            else // DDraw is using the overlay; very improbable at this moment
                                {
                                (*pstrAccessDeviceDataOut) = (DWORD)pstrAccessDeviceData;
                                }
                        }
                     }
                    else
                    {
                    if( (ppdev->semph_overlay==0) || (ppdev->semph_overlay==2))             //  = 0  resource free;     = 1  in use by DDraw;    = 2  in use by Palindrome;
                        {
                        // the device is not allocated to another process than palindrome, so we can free it anyway
                        (*pstrAccessDeviceDataOut) = (DWORD)NULL;
                        (ppdev->pal_str.lpOwnerAccessStructOverlay)=NULL;
                        }
                     else
                         {
                        // the overlay is used by DDraw, but no external app
                        (*pstrAccessDeviceDataOut) = (DWORD)pstrAccessDeviceData;
                        (ppdev->pal_str.lpOwnerAccessStructOverlay)=NULL;
                         }
                    }

                  break;
                case     ACCESSDEVICEDATA_SUBFUNC_QUERY:
                  if( (ppdev->pal_str.lpOwnerAccessStructOverlay)==NULL)  // if the device is free
                  {
                        //the device is not allocated by an external client
                        // but first verify if DDraw is not using it
                      if(ppdev->semph_overlay==0)             //  = 0  resource free;     = 1  in use by DDraw;    = 2  in use by Palindrome;
                          {
                          (*pstrAccessDeviceDataOut) =(DWORD) NULL;
                          }
                      else
                          {
                           // the overlay is used by DDraw, so let's try to do this (return its own access structure):
                          (*pstrAccessDeviceDataOut) =(DWORD)pstrAccessDeviceData;
                          }

                   }
                  else
                  {    // if the device is owned already
                     (*pstrAccessDeviceDataOut) = (DWORD)(ppdev->pal_str.lpOwnerAccessStructOverlay);
                  }

                  break;
                default:
                  RetVal=0xffffffff;
              }
           }
           else
           {
               RetVal=0xffffffff;
           }
       }
   return (RetVal);
   }


ULONG  GetConfiguration(PDEV* ppdev,PVOID pvOut)
{
          ULONG RetVal;
          ATIConfig*      pATIConfig;

         pATIConfig=( ATIConfig*)pvOut;
         strcpy(pATIConfig->ATISig,"761295520\x0");
         strcpy(pATIConfig->DriverName, "ati\x0\x0\x0\x0\x0\x0");
         pATIConfig->dwMajorVersion=2;
         pATIConfig->dwMinorVersion=1;
         pATIConfig->dwDesktopWidth=ppdev->cxScreen;
         pATIConfig->dwDesktopHeight=ppdev->cyScreen;
         pATIConfig->dwEnginePitch=ppdev->lDelta;
         pATIConfig->dwRealRamAvail=(ppdev->cyMemory)*(ppdev->lDelta);
         pATIConfig->dwBpp=ppdev->cBitsPerPel;
         pATIConfig->dwBoardBpp=ppdev->cBitsPerPel;
        if (ppdev->cBitsPerPel == 4)
                 pATIConfig->dwColorFormat=ATIConfig_ColorFmt_4_Packed;
       else if (ppdev->cBitsPerPel == 8)
                 pATIConfig->dwColorFormat=ATIConfig_ColorFmt_8;
       else if (ppdev->cBitsPerPel == 16)
                 pATIConfig->dwColorFormat=ATIConfig_ColorFmt_RGB555;
       else if (ppdev->cBitsPerPel == 24)
                 pATIConfig->dwColorFormat=ATIConfig_ColorFmt_RGB888;
       else if (ppdev->cBitsPerPel == 32)
                 pATIConfig->dwColorFormat=ATIConfig_ColorFmt_aRGB8888;
       else
        pATIConfig->dwColorFormat=0xffffffff;
        pATIConfig->dwAlphaBitMask=0;
        pATIConfig->dwConfigBits=0;
        switch(ppdev->iAsic)
        {
        case    CI_38800_1:
            pATIConfig->dwBoardType=1;
            break;
        case    CI_68800_3:
        case    CI_68800_6:
        case    CI_68800_AX:
            pATIConfig->dwBoardType=2;
            break;
        case    CI_M64_GENERIC:
            pATIConfig->dwBoardType=3;
            break;
        default:
            pATIConfig->dwBoardType=0;
        }

      switch(ppdev->iAperture)
      {
      case      ENGINE_ONLY :
          pATIConfig->dwApertureType=1;
          break;
      case       AP_LFB:
          pATIConfig->dwApertureType=3;
          break;
      case      AP_VGA_SINGLE:
      case      FL_VGA_SPLIT:
          pATIConfig->dwApertureType=2;
          break;
      default:
          pATIConfig->dwApertureType=0;
       }

RetVal=sizeof(ATIConfig);
return (RetVal);
}


ULONG WriteRegFnct(PDEV* ppdev,PVOID pvIn)
{
 ULONG RetVal;
DISPDBG( (DEBUG_ESC," reg_block: %u ",((RW_REG_STRUCT*)pvIn)->reg_block ));
DISPDBG( (DEBUG_ESC," reg_offset: 0x%X ",((RW_REG_STRUCT*)pvIn)->reg_offset ));
DISPDBG( (DEBUG_ESC," write_data: 0x%lX " ,((RW_REG_STRUCT*)pvIn)->data    ));

//parameters validation for increase roboustness (limited access to certain registers and certaines fields)
 if( ((((RW_REG_STRUCT*)pvIn)->reg_block)!=0)&&((((RW_REG_STRUCT*)pvIn)->reg_block)!=1) )
    {
    RetVal=ESC_FAILED;
    DISPDBG( (DEBUG_ESC," Write failed: wrong block no."));
    return (RetVal);
    }
 if( ((RW_REG_STRUCT*)pvIn)->reg_offset>255 )
    {
     RetVal=ESC_FAILED;
     DISPDBG( (DEBUG_ESC," Write failed : wrong offsett value"));
     return (RetVal);
    }
 // end of parameters validation

 //what kind of write?
 if((((RW_REG_STRUCT*)pvIn)->reg_block)==1)  //block 1
    {
    if( ( (RW_REG_STRUCT*)pvIn)->reg_offset<0x30 )
        {
        if(ppdev->pal_str.Mode_Switch_flag==TRUE)     //if a mode switch intercepts writes to the buffers and use the values stored in ppdev->pal_str
            {
            switch(((RW_REG_STRUCT*)pvIn)->reg_offset)
                {
                DWORD key_clr;
                DWORD key_mask;

                case 0x4:
                    switch(ppdev->cBitsPerPel)
                        {
                        case 8:
                            key_clr=0xFD;
                            break;
                        case 15:
                            key_clr=0x7C1F;
                            break;
                        case 16:
                            key_clr=0xF81F;
                            break;
                        case 24:
                            key_clr=0xFF00FF;
                            break;
                        case 32:
                            key_clr=0xFF00FF; //?
                            break;
                        }
                    WriteVTReg(0x4,key_clr);
                    break;
                case 0x5:
                    switch(ppdev->cBitsPerPel)
                        {
                        case 8:
                            key_mask=0xFF;
                            break;
                        case 15:
                            key_mask=0xFFFF;
                            break;
                        case 16:
                            key_mask=0xFFFF;
                            break;
                        case 24:
                            key_mask=0xFFFFFF;
                            break;
                        case 32:
                            key_mask=0xFFFFFF;    //?
                            break;
                        }
                    WriteVTReg(0x5,key_mask);
                    break;
                case 0x20:
                    if( ppdev->iAsic>=CI_M64_GTB )
                        {
                        WriteVTReg(0x20,ppdev->pal_str.Buf0_Offset);
                        WriteVTReg(0x22,ppdev->pal_str.Buf0_Offset);
                        }
                    else
                        {
                        WriteVTReg(0x20,ppdev->pal_str.Buf0_Offset);
                        }
                     break;
                case 0x22:
                    if ((ppdev->iAsic == CI_M64_VTB)||(ppdev->iAsic >= CI_M64_GTB))
                         {
                         WriteVTReg(0x22,ppdev->pal_str.Buf0_Offset);
                         }
                     break;
                case 0xe:
                    if ((ppdev->iAsic == CI_M64_VTB)||(ppdev->iAsic >= CI_M64_GTB))
                         {
                         WriteVTReg(0xe,ppdev->pal_str.Buf0_Offset);
                         }
                     break;
                case 0x26:
                    if ((ppdev->iAsic ==CI_M64_VTA)||(ppdev->iAsic ==CI_M64_GTA))
                         {
                         WriteVTReg(0x26,ppdev->pal_str.Buf0_Offset);
                         }
                     break;
                case 0x2B:
                     if ((ppdev->iAsic ==CI_M64_VTA)||(ppdev->iAsic ==CI_M64_GTA))
                          {
                          WriteVTReg(0x2B,ppdev->pal_str.Buf0_Offset);
                          }
                     break;
                case 0x2C:
                    if ((ppdev->iAsic ==CI_M64_VTA)||(ppdev->iAsic ==CI_M64_GTA))
                         {
                         WriteVTReg(0x2C,ppdev->pal_str.Buf0_Offset);
                         }
                    break;

                default:
                    WriteVTReg(((RW_REG_STRUCT*)pvIn)->reg_offset,((RW_REG_STRUCT*)pvIn)->data);
                }

            }
        else
            {
            WriteVTReg(((RW_REG_STRUCT*)pvIn)->reg_offset,((RW_REG_STRUCT*)pvIn)->data);

            // bug in Palindrome application for VTB, GTB: the capture is set in CAPTURE_CONFIG for Continuous Even, One Shot , but without setting
           // the ONESHOT_BUF_OFFSET. So I set this reg like CAP_BUF0_OFFSET.
           #define CAP_BUF_BUG
           #ifdef    CAP_BUF_BUG
           if ( (((RW_REG_STRUCT*)pvIn)->reg_offset==0x20) && (ppdev->iAsic>=CI_M64_GTB) )  //CAPTURE_BUF0_OFFSET
                     {
                     //write also the same value for ONESHOT_BUFFER
                     WriteVTReg(0x22,((RW_REG_STRUCT*)pvIn)->data);
                     }
            #endif

            }

 #if    1       // start debug statements for registers monitoring
        if(((RW_REG_STRUCT*)pvIn)->reg_offset==0x06)
       {
        DISPDBG( (DEBUG_ESC_2," Write OVERLAY_KEY_CNTL: 0x%lX ",((RW_REG_STRUCT*)pvIn)->data));
       }
       if(((RW_REG_STRUCT*)pvIn)->reg_offset==0x02)
       {
        DISPDBG( (DEBUG_ESC_2," Write OVERLAY_VIDEO_KEY_CLR: 0x%lX ",((RW_REG_STRUCT*)pvIn)->data));
       }
       if(((RW_REG_STRUCT*)pvIn)->reg_offset==0x03)
       {
        DISPDBG( (DEBUG_ESC_2," Write OVERLAY_VIDEO_KEY_MSK: 0x%lX ",((RW_REG_STRUCT*)pvIn)->data));
       }
       if(((RW_REG_STRUCT*)pvIn)->reg_offset==0x04)
       {
        DISPDBG( (DEBUG_ESC_2," Write OVERLAY_GRAPHICS_KEY_CLR: 0x%lX ",((RW_REG_STRUCT*)pvIn)->data));
       }
       if(((RW_REG_STRUCT*)pvIn)->reg_offset==0x05)
       {
        DISPDBG( (DEBUG_ESC_2," Write OVERLAY_GRAPHICS_KEY_MSK: 0x%lX ",((RW_REG_STRUCT*)pvIn)->data));
       }

        // debug info for buffer offset and pitch
       if(((RW_REG_STRUCT*)pvIn)->reg_offset==0x20)
       {
        DISPDBG( (DEBUG_ESC_2," Write BUFF0_OFFSET: 0x%lX ",((RW_REG_STRUCT*)pvIn)->data));
       }
       if(((RW_REG_STRUCT*)pvIn)->reg_offset==0x23)
       {
       DISPDBG( (DEBUG_ESC_2," Write BUFF0_PITCH: 0x%lX ",((RW_REG_STRUCT*)pvIn)->data));
       }
#endif     // end debug statements

    }
  else
    {
     RIP(("Protected Register in block 1"));
     }
  }
else    //block 0
  {
// #define NO_VERIFICATION
#ifndef  NO_VERIFICATION
//  we verify the writings
    switch(((RW_REG_STRUCT*)pvIn)->reg_offset)
        {
        DWORD value;
        case 0x1e:
            MemR32(((RW_REG_STRUCT*)pvIn)->reg_offset,&value);
            value=((value&0x0)|( (((RW_REG_STRUCT*)pvIn)->data)&0xffffffff ));
            MemW32(((RW_REG_STRUCT*)pvIn)->reg_offset, value);
            break;
        case 0x34:
            if ((ppdev->iAsic ==CI_M64_VTA)||(ppdev->iAsic ==CI_M64_GTA))
                {
                MemR32(((RW_REG_STRUCT*)pvIn)->reg_offset,&value);
                value=((value&0xffffff80)|( (((RW_REG_STRUCT*)pvIn)->data)&0x3d ));
                MemW32(((RW_REG_STRUCT*)pvIn)->reg_offset, value);
                }
            break;
        case 0x31:
                MemR32(((RW_REG_STRUCT*)pvIn)->reg_offset,&value);
                value=((value&0x80ffbfff)|( (((RW_REG_STRUCT*)pvIn)->data)&0x3f004000 ));
                MemW32(((RW_REG_STRUCT*)pvIn)->reg_offset, value);
            break;
        case 0x1f:
            // bug in GTA hardware
            if (ppdev->iAsic == CI_M64_GTA)
               {
               DWORD local_value;
               DWORD HTotal;
               MemR32( 0x7 ,&local_value);
               MemW32(0x7,(local_value&0xffbfffff));
               MemR32(0x0,&HTotal);
               MemW32(0x7,local_value);

               MemW32(((RW_REG_STRUCT*)pvIn)->reg_offset,((RW_REG_STRUCT*)pvIn)->data);

               MemR32( 0x7 ,&local_value);
               MemW32(0x7,(local_value&0xffbfffff));
               MemW32(0x0,HTotal);
               MemW32(0x7,local_value);
                }
          else
              {
              if (ppdev->iAsic ==CI_M64_VTA)
                    {
                    MemW32(((RW_REG_STRUCT*)pvIn)->reg_offset,((RW_REG_STRUCT*)pvIn)->data);
                    }
              }
          break;
        case 0x28:
           MemR32(((RW_REG_STRUCT*)pvIn)->reg_offset,&value);
           value=((value&0xf7ffffff)|( (((RW_REG_STRUCT*)pvIn)->data)&0x08000000 ));
           // the following line of code is necessary because we cannot allow user code to turn off block1
           // due to the fact that this block is also used by DDraw (for this case anyway we are sharing and arbitrating resources)
           // and more important by MCD OGL; so we only allow to turn on block1.
           value=value | 0x08000000;
           MemW32(((RW_REG_STRUCT*)pvIn)->reg_offset, value);
           break;

        #define   NO_ACCESS
        #ifdef      NO_ACCESS
        case 0x07:   // maybe access to this register is not necessary
           MemW32(((RW_REG_STRUCT*)pvIn)->reg_offset,((RW_REG_STRUCT*)pvIn)->data);
           break;
        case 0x24:     // maybe access to this register is not necessary
           MemW32(((RW_REG_STRUCT*)pvIn)->reg_offset,((RW_REG_STRUCT*)pvIn)->data);
           break;
        #endif  // NO_ACCESS

        default:
           RetVal=ESC_FAILED;
           RIP(("Protected Register in block 0"));
            DISPDBG( (DEBUG_ESC," Write failed : this register is protected"));
           break;
        }
 #else
        // we don't verify the writings
        {
        // bug in hardware on GTA
        if (((RW_REG_STRUCT*)pvIn)->reg_offset==0x1f)
            {
            DWORD local_value;
            DWORD HTotal;
            MemR32( 0x7 ,&local_value);
            MemW32(0x7,(local_value&0xffbfffff));
            MemR32(0x0,&HTotal);
            MemW32(0x7,local_value);

            MemW32(((RW_REG_STRUCT*)pvIn)->reg_offset,((RW_REG_STRUCT*)pvIn)->data);

            MemR32( 0x7 ,&local_value);
            MemW32(0x7,(local_value&0xffbfffff));
            MemW32(0x0,HTotal);
            MemW32(0x7,local_value);
            }
        else
            MemW32(((RW_REG_STRUCT*)pvIn)->reg_offset,((RW_REG_STRUCT*)pvIn)->data);

        }
#endif    // End NO_VERIFICATION
  }
RetVal=ESC_OK;
DISPDBG( (DEBUG_ESC," Write OK"));
DISPDBG( (DEBUG_ESC," "));
//DebugBreak() ;
return (RetVal);
}


ULONG  ReadRegFnct(PDEV* ppdev,PVOID pvIn, PVOID pvOut)
{
    ULONG RetVal;
   DISPDBG( (DEBUG_ESC," reg_block: %u ",((RW_REG_STRUCT*)pvIn)->reg_block ));
   DISPDBG( (DEBUG_ESC," reg_offset: 0x%X ",((RW_REG_STRUCT*)pvIn)->reg_offset ));


//parameters validation
if( ((((RW_REG_STRUCT*)pvIn)->reg_block)!=0)&&((((RW_REG_STRUCT*)pvIn)->reg_block)!=1) )
   {
   RetVal=ESC_FAILED;
   DISPDBG( (DEBUG_ESC," Write failed: wrong block no."));
   return (RetVal);
   }
if( ((RW_REG_STRUCT*)pvIn)->reg_offset>255 )
   {
    RetVal=ESC_FAILED;
    DISPDBG( (DEBUG_ESC," Write failed: wrong offset."));
    return (RetVal);
   }
// end of parameters validation
//what kind of read?
 if((((RW_REG_STRUCT*)pvIn)->reg_block)==1)
     {
     ReadVTReg(((RW_REG_STRUCT*)pvIn)->reg_offset,(DWORD*)pvOut);
     }
 else
    {
    MemR32(((RW_REG_STRUCT*)pvIn)->reg_offset,(DWORD*)pvOut);
    }

 RetVal=ESC_OK;
 DISPDBG( (DEBUG_ESC," read_data: 0x%lX " , *((DWORD*)pvOut)  ));
 DISPDBG( (DEBUG_ESC,"Read OK."));
 DISPDBG( (DEBUG_ESC," "));
 //DebugBreak() ;
 return (RetVal);
 }



 /*^^*
  * Function:    I2CAccess
  *
  * Purpose:             To complete an I2C packet.
  *
  * Inputs:              str:    LPI2CSTRUCT
  *
  * Outputs:             void.
  *^^*/
 void  I2CAccess_New(PDEV* ppdev,LPI2CSTRUCT_NEW str,LPI2CSTRUCT_NEW str_out)
 {
 unsigned char i = 0;

         str_out->wError = 0;
         /*
          * Implement WRITE request
          */
         if (str->wWriteCount) {
                 Start(ppdev, str->wCard);

                 // Write Chip Address (for WRITE)
                 WriteByteI2C(ppdev, str->wCard, (BYTE)(str->wChipID & 0xfe));
                 // Acc the previous write...
                 if (!Ack(ppdev, str->wCard, FALSE)) str_out->wError |= I2C_ACK_WR_ERROR;

                 for (i = 0;i < str->wWriteCount;i++) {
                         // Write the required data
                         WriteByteI2C(ppdev, str->wCard, str->lpWrData[i]);
                         // Acc the previous write...
                         if (!Ack(ppdev, str->wCard, FALSE)) str_out->wError |= I2C_ACK_WR_ERROR;
                 }
                 Stop(ppdev, str->wCard);
         }
         /*
          * Implement READ request
          */
         if (str->wReadCount) {
                 Start(ppdev, str->wCard);

                 // Write Chip Address (for READ)
                 WriteByteI2C(ppdev, str->wCard, (BYTE)(str->wChipID & 0xfe | 0x01));

                 //!!    Can't do an Ack here with ATI hardware.
                 //!!    SIS claims that they always do one. Don't
                 //!!    know why there would be a difference.
                 if (!Ack(ppdev, str->wCard, FALSE)) str_out->wError |= I2C_ACK_RD_ERROR;

             for (i = 0;i < str->wReadCount;i++) {
                         // Read the required data
                         if (i) Ack(ppdev, str->wCard, TRUE);
                         str_out->lpRdData[i] = ReadByteI2C(ppdev, str->wCard);
                 }
                 Stop(ppdev, str->wCard);
         }

DISPDBG( (DEBUG_ESC_I2C," PAL : I2C Access"));
DISPDBG( (DEBUG_ESC_I2C," Card no: 0x%X " , str->wCard  ));
DISPDBG( (DEBUG_ESC_I2C," Chip ID: 0x%X " , str->wChipID  ));
DISPDBG( (DEBUG_ESC_I2C," Error: 0x%X" , str->wError  ));
DISPDBG( (DEBUG_ESC_I2C," Write Count: 0x%X " , str->wWriteCount  ));
DISPDBG( (DEBUG_ESC_I2C," Read Count: 0x%X " , str->wReadCount ));
for (i = 0;i < str->wWriteCount;i++)
    {
    DISPDBG( (DEBUG_ESC_I2C," WriteData[%u]: 0x%X " , i, str->lpWrData[0]  ));
     }
for (i = 0;i < str->wReadCount;i++)
    {
    DISPDBG( (DEBUG_ESC_I2C," ReadData[%u]: 0x%X " , i, str->lpRdData[0]  ));
     }

 DISPDBG( (DEBUG_ESC_I2C," "));
 //DebugBreak() ;
 }
 // end of I2CAccess_New


////// Functions for I2C support

/*^^*
 * Function:    ReadI2CData
 *
 * Purpose:             To read a bit from the I2C data line.
 *
 * Inputs:              PDEV*, wCard:          WORD, the card number to write to.
 *
 * Outputs:             BYTE, the read data bit.
 *^^*/
BYTE ReadI2CData(PDEV* ppdev, WORD wCard)
{
        //return (BYTE) ReadVT264Reg(ppdev, wCard,vtf_GEN_GIO2_DATA_IN);

        if ((ppdev->iAsic == CI_M64_VTA)||(ppdev->iAsic == CI_M64_GTA))
                return (BYTE) ReadVT264Reg(ppdev, wCard,vtf_GEN_GIO2_DATA_IN);

        if ((ppdev->iAsic == CI_M64_VTB)||(ppdev->iAsic >= CI_M64_GTB))
                return (BYTE) ReadVT264Reg(ppdev, wCard,vtf_GP_IO_4);

}


/*^^*
 * Function:    ReadAnyReg
 *
 * Purpose:             To waste a small amount of time in order to
 *                              ensure the I2C bus timing.
 *
 * Inputs:              PDEV*, wCard:          WORD, the card number to write to.
 *
 * Outputs:             none.
 *^^*/
void ReadAnyReg(PDEV* ppdev, WORD wCard)
{
        ReadVT264Reg(ppdev, wCard, vtf_CFG_CHIP_FND_ID);
}


/*^^*
 * Function:    SetI2CDataDirection
 *
 * Purpose:             To set the data direction of the I2C
 *                              controller chip to allow for reads and/or
 *                              writes to the I2C bus.
 *
 * Inputs:              PDEV*, wCard:          WORD, the card number to write to.
 *
 * Outputs:             none.
 *
 * Note:                Some chips may allow read and/or writes without
 *                              any state change. For these chips this should be
 *                              implemented as a NULL function.
 *^^*/
 void SetI2CDataDirection(PDEV* ppdev, WORD wCard, BOOL fWrite)
{
        //WriteVT264Reg(ppdev, wCard, vtf_GEN_GIO2_WRITE, fWrite?1:0);
    if ((ppdev->iAsic == CI_M64_VTA)||(ppdev->iAsic == CI_M64_GTA))
            WriteVT264Reg(ppdev, wCard, vtf_GEN_GIO2_WRITE, fWrite?1:0);
    if ((ppdev->iAsic == CI_M64_VTB)||(ppdev->iAsic >= CI_M64_GTB))
            WriteVT264Reg(ppdev, wCard, vtf_GP_IO_DIR_4, fWrite?1:0);

}


 /*^^*
  * Function:    WriteI2CClock
  *
  * Purpose:             To set the state of the I2C clock line.
  *
  * Inputs:              PDEV*, wCard:  WORD, the card number to write to.
  *                              cClock: BYTE, the new clock state.
  *
  * Outputs:             none.
  *^^*/
 void WriteI2CClock(PDEV* ppdev, WORD wCard, BYTE cClock)
 {
         //WriteVT264Reg(ppdev, wCard, vtf_DAC_GIO_STATE_1, (DWORD)cClock);
         if ((ppdev->iAsic == CI_M64_VTA)||(ppdev->iAsic == CI_M64_GTA))
             WriteVT264Reg(ppdev, wCard, vtf_DAC_GIO_STATE_1, (DWORD)cClock);
        if ((ppdev->iAsic == CI_M64_VTB)||(ppdev->iAsic >= CI_M64_GTB))
            WriteVT264Reg(ppdev, wCard, vtf_GP_IO_B, (DWORD)cClock);
 }


 /*^^*
  * Function:    WriteI2CData
  *
  * Purpose:             To set the state of the I2C data line.
  *
  * Inputs:              PDEV*, wCard:          WORD, the card number to write to.
  *                              cDataBit:       BYTE, the new data value.
  *
  * Outputs:             none.
  *^^*/
 void WriteI2CData(PDEV* ppdev, WORD wCard, BYTE cDataBit)
 {
         //WriteVT264Reg(ppdev, wCard, vtf_GEN_GIO2_DATA_OUT, (DWORD)cDataBit);
         if ((ppdev->iAsic == CI_M64_VTA)||(ppdev->iAsic == CI_M64_GTA))
                WriteVT264Reg(ppdev, wCard, vtf_GEN_GIO2_DATA_OUT, (DWORD)cDataBit);
        if ((ppdev->iAsic == CI_M64_VTB)||(ppdev->iAsic >= CI_M64_GTB))
                WriteVT264Reg(ppdev, wCard, vtf_GP_IO_4, (DWORD)cDataBit);

 }


/*^^*
 * Function:    ReverseByte
 *
 * Purpose:             To reverse the bit order of a byte.
 *
 * Inputs:              wData:          BYTE, The data to be reversed.
 *
 * Outputs:             WORD, the reversed word.
 *
 *^^*/
 BYTE ReverseByte(BYTE wData)
{
BYTE    result = 0;
BYTE    x, y;

        // x shifts up through all possible bits (8)
        // y shifts down through all possible bits (8)
        // if 'x' bit is set the set 'y' bit.
        for (x=0x01, y=0x80; y; x<<=1, y>>=1) if (wData & x) result |= y;

        return (result);
}
// end of ReverseByte()


/*^^*
 * Function:    Ack
 *
 * Purpose:             To ask the I2C bus for an acknowledge.
 *
 * Inputs:              PDEV*, wCard: WORD, the card number to write.
 *
 * Outputs:             void.
 *^^*/
 WORD Ack(PDEV* ppdev, WORD wCard, BOOL fPut)
{
WORD    ack = 0;

        if (fPut) {
                // Push Ack onto I2C bus

                // Enable I2C writes
                SetI2CDataDirection(ppdev, wCard, I2C_WRITE);
                // Drive data line low
                WriteI2CData(ppdev, wCard, I2C_LOW);
                I2CDelay(ppdev, wCard);
                // Drive I2C clock line high
                WriteI2CClock(ppdev, wCard, I2C_HIGH);
            I2CDelay(ppdev, wCard);
                // Write acknowledge from I2C bus
                WriteI2CClock(ppdev, wCard, I2C_LOW);
            I2CDelay(ppdev, wCard);
                // Disable I2C writes
                SetI2CDataDirection(ppdev, wCard, I2C_READ);
        } else {
                // Receive Ack from I2C bus

                // Disable I2C writes
                SetI2CDataDirection(ppdev, wCard, I2C_READ);
                I2CDelay(ppdev, wCard);
                // Drive I2C clock line high
                WriteI2CClock(ppdev, wCard, I2C_HIGH);
            I2CDelay(ppdev, wCard);
                // Read acknowledge from I2C bus
                ack = (BYTE) ReadI2CData(ppdev, wCard);
                // Drive I2C clock low
                WriteI2CClock(ppdev, wCard, I2C_LOW);
            I2CDelay(ppdev, wCard);
        }
    // Clock is LOW
    // Data is tristate
        return (!ack);
}
// end of Ack()


/*^^*
 * Function:    Start
 *
 * Purpose:             To start a transfer on the I2C bus.
 *
 * Inputs:              PDEV*, wCard: WORD, the card number to write.
 *
 * Outputs:             void.
 *^^*/
 void Start(PDEV* ppdev, WORD wCard)
{
        // Enable I2C writes
        SetI2CDataDirection(ppdev, wCard, I2C_WRITE);
    // Drive data high
        WriteI2CData(ppdev, wCard, I2C_HIGH);
        I2CDelay(ppdev, wCard);
        // Drive clock high
        WriteI2CClock(ppdev, wCard, I2C_HIGH);
        I2CDelay(ppdev, wCard);
        // Drive data low
        WriteI2CData(ppdev, wCard, I2C_LOW);
        I2CDelay(ppdev, wCard);
        // Drive clock low
        WriteI2CClock(ppdev, wCard, I2C_LOW);
        I2CDelay(ppdev, wCard);

        // Clock is LOW
        // Data is LOW
}
// end of Start


/*^^*
 * Function:    Stop
 *
 * Purpose:             To stop a transfer on the I2C bus.
 *
 * Inputs:              PDEV*, wCard: WORD, the card number to write.
 *
 * Outputs:             void.
 *^^*/
 void Stop(PDEV* ppdev, WORD wCard)
{
        // Enable I2C writes
        SetI2CDataDirection(ppdev, wCard, I2C_WRITE);
        // Drive data low
        WriteI2CData(ppdev, wCard, I2C_LOW);
        I2CDelay(ppdev, wCard);
        // Drive clock high
        WriteI2CClock(ppdev, wCard, I2C_HIGH);
        I2CDelay(ppdev, wCard);
        // Drive data high
        WriteI2CData(ppdev, wCard, I2C_HIGH);
        I2CDelay(ppdev, wCard);
        // Disable I2C writes
        SetI2CDataDirection(ppdev, wCard, I2C_READ);

        // Clock is HIGH
        // Data is tri-state
}
// end of Stop


/*^^*
 * Function:    WriteByteI2C
 *
 * Purpose:             To write a byte of data to the I2C bus.
 *
 * Inputs:              PDEV*, wCard:  WORD, the card the I2C bus is on.
 *                              cData:  BYTE, the data to write
 *
 * Outputs:             void.
 *^^*/
 void WriteByteI2C(PDEV* ppdev, WORD wCard, BYTE cData)
{
WORD    x;

        cData = ReverseByte(cData);

        // Enable I2C writes
        SetI2CDataDirection(ppdev, wCard, I2C_WRITE);

        for (x=0; x<8; x++, cData>>=1) {
                // Put data bit on I2C bus
                WriteI2CData(ppdev, wCard, (BYTE) (cData&1));
                I2CDelay(ppdev, wCard);
                // Drive I2C clock high
                WriteI2CClock(ppdev, wCard, I2C_HIGH);
                I2CDelay(ppdev, wCard);
                // Drive I2C clock low
                WriteI2CClock(ppdev, wCard, I2C_LOW);
                I2CDelay(ppdev, wCard);
        }

        // Clock is LOW
        // Data is driven (LSB)
}
// end of WriteByteI2C


/*^^*
 * Function:    ReadByteI2C
 *
 * Purpose:             To read a byte of data from the I2C bus.
 *
 * Inputs:              none.
 *
 * Outputs:             BYTE, the data that was read.
 *^^*/
 BYTE ReadByteI2C(PDEV* ppdev, WORD wCard)
{
BYTE    cData = 0;
WORD    x;

        // Disable write on the I2C bus
        SetI2CDataDirection(ppdev, wCard, I2C_READ);

        for (x=0; x<8; x++) {
                // Drive I2C clock high
                WriteI2CClock(ppdev, wCard, I2C_HIGH);
                I2CDelay(ppdev, wCard);
                // Pull data bit from I2C bus
                cData = (cData << 1) | (BYTE) ReadI2CData(ppdev, wCard);
                // Drive I2C clock low
                WriteI2CClock(ppdev, wCard, I2C_LOW);
                I2CDelay(ppdev, wCard);
        }
        return (cData);

        // Clock is LOW
        // Data is tri-state
}
// end of ReadByteI2C


/*^^*
 * Function:    I2CDelay
 *
 * Purpose:             To delay the accesses to the I2C bus long enough
 *                              to ensure the correct timimg.
 *
 * Inputs:              PDEV*, wCard:  WORD the card to wait on.
 *
 * Outputs:             none.
 *^^*/
 void I2CDelay(PDEV* ppdev, WORD wCard)
{
BYTE x;

        // To ensure correct I2C bus timing, read a register a bunch of times.
        for (x=0; x<I2C_TIME_DELAY; x++) ReadAnyReg(ppdev, wCard);
}
// end of I2CDelay


////// End functions for I2C support

//c code for disable overlay and scaler
BOOL DisableOvl(PDEV* ppdev)
{
HLOCAL pbuff;
// just for test:
// ULONG   temp;
int  i;
DWORD value;
VIDEO_CAPTURE   VideoCaptureDataIn, VideoCaptureDataOut;
DWORD   ReturnedDataLength ;


 DISPDBG( (DEBUG_ESC_1,"Enter in DisableOverlay"));
// code for context save (all the regs in block1)
if(ppdev->pal_str.dos_flag)
{
    DISPDBG( (DEBUG_ESC_1,"DOS_Flag = TRUE"));
    ppdev->pal_str.dos_flag=FALSE;
    pbuff = AtiAllocMem(LPTR ,FL_ZERO_MEMORY,1072); // 1072 to accomodate also 6 regs from block 0

    if(pbuff!=NULL)
    {
        ppdev->pal_str.preg=(DWORD*)pbuff;
        for(i=0;i<256;i++)
        {
        ReadVTReg(i,(ppdev->pal_str.preg+i));
        if(i<0x31)
            DISPDBG( (DEBUG_ESC_1,"DOS switch: reg 0x%X = 0x%Xl ",i,(DWORD)*(ppdev->pal_str.preg+i)));
        //TempFnct(ppdev);
        }
    }
    else
        return FALSE;
}
// disable capture
            WriteVTReg(TRIG_CNTL,0x0);
            WriteVTReg(CAPTURE_CONFIG, 0x0);

// code for overlay and scaler disable
        // fisrt the scaler
        WriteVTReg(SCALER_HEIGHT_WIDTH,0x00010001);
        WriteVTReg(OVERLAY_SCALE_INC, 0x10001000);
        ReadVTReg(OVERLAY_SCALE_CNTL,&value);
        value=value&0x7fffffff;
        WriteVTReg(OVERLAY_SCALE_CNTL,value);

        // the overlay
        WriteVTReg(OVERLAY_Y_X,0x0);
        WriteVTReg(OVERLAY_Y_X_END,0x00010001);

        WriteVTReg(OVERLAY_KEY_CNTL,0x00000100);
        WriteVTReg(OVERLAY_SCALE_CNTL,0x0);
         // disable the settings in hardware for videocapture
         VideoCaptureDataIn.dwSubFunct= 0x00000001;
         VideoCaptureDataIn.dwCaptureWidth=0;
         VideoCaptureDataIn.dwCaptureMode=0;

         if (!AtiDeviceIoControl(ppdev->hDriver,
                                  IOCTL_VIDEO_ATI_CAPTURE,
                                  &VideoCaptureDataIn,
                                  sizeof(VIDEO_CAPTURE),
                                  &VideoCaptureDataOut,
                                  sizeof(VIDEO_CAPTURE),
                                  &ReturnedDataLength))
                {
                DISPDBG((0, "bInitializeATI - Failed IOCTL_VIDEO_ATI_CAPTURE"));
                }

 // save the content of the few registers used in block 0 by Palindrome
           MemR32(0x1E,(ppdev->pal_str.preg+i));
           DISPDBG( (DEBUG_ESC_1,"DOS switch: reg_blk_0 0x%X = 0x%Xl ",i,(DWORD)*(ppdev->pal_str.preg+i)));
           i++;
           MemR32(0x28,(ppdev->pal_str.preg+i));
           DISPDBG( (DEBUG_ESC_1,"DOS switch: reg_blk_0 0x%X = 0x%Xl ",i,(DWORD)*(ppdev->pal_str.preg+i)));
           i++;
           MemR32(0x31,(ppdev->pal_str.preg+i));
           DISPDBG( (DEBUG_ESC_1,"DOS switch: reg_blk_0 0x%X = 0x%Xl ",i,(DWORD)*(ppdev->pal_str.preg+i)));
           i++;

           if ((ppdev->iAsic ==CI_M64_VTA)||(ppdev->iAsic ==CI_M64_GTA))
               {
               MemR32(0x1F,(ppdev->pal_str.preg+i));
               DISPDBG( (DEBUG_ESC_1,"DOS switch: reg_blk_0 0x%X = 0x%Xl ",i,(DWORD)*(ppdev->pal_str.preg+i)));
               i++;
               MemR32(0x34,(ppdev->pal_str.preg+i));
               DISPDBG( (DEBUG_ESC_1,"DOS switch: reg_blk_0 0x%X = 0x%Xl ",i,(DWORD)*(ppdev->pal_str.preg+i)));
               i++;
               #define EXCLUDE_READ
               #ifndef    EXCLUDE_READ
               MemR32(0x07,(ppdev->pal_str.preg+i));
               DISPDBG( (DEBUG_ESC_1,"DOS switch: reg_blk_0 0x%X = 0x%Xl ",i,(DWORD)*(ppdev->pal_str.preg+i)));
               i++;
               MemR32(0x24,(ppdev->pal_str.preg+i));
               DISPDBG( (DEBUG_ESC_1,"DOS switch: reg_blk_0 0x%X = 0x%Xl ",i,(DWORD)*(ppdev->pal_str.preg+i)));
               #endif
               }

//#define TEST_SWITCH_1
#ifndef TEST_SWITCH_1
// disable the block 1 of registers
        MemR32(0x28,&value);
        MemW32(0x28,value&0xf7ffffff);
        return TRUE;

#else
        value;
#endif
}


//code for reinitialization of overlay after a mode switch
void EnableOvl(PDEV* ppdev)
{

int i;
DWORD value;
VIDEO_CAPTURE   VideoCaptureDataIn, VideoCaptureDataOut;
DWORD   ReturnedDataLength ;

DISPDBG( (DEBUG_ESC_1,"Enter in EnableOverlay"));

// enable the settings in hardware for video capture
 VideoCaptureDataIn.dwSubFunct= 0x00000000;
 VideoCaptureDataIn.dwCaptureWidth=0;
 VideoCaptureDataIn.dwCaptureMode=0;

 if (!AtiDeviceIoControl(ppdev->hDriver,
                          IOCTL_VIDEO_ATI_CAPTURE,
                          &VideoCaptureDataIn,
                          sizeof(VIDEO_CAPTURE),
                          &VideoCaptureDataOut,
                          sizeof(VIDEO_CAPTURE),
                          &ReturnedDataLength))
   {
       DISPDBG((0, "bInitializeATI - Failed IOCTL_VIDEO_ATI_CAPTURE"));
   }

//#define TEST_SWITCH

#ifndef TEST_SWITCH
//init the VT regs in block 1 (BUS_CNTL)
        MemR32(0x28,&value);
        value=value|0x08000000;
        MemW32(0x28,value);

// initialize some overlay/scaler regs on RAGEIII
if (ppdev->iAsic>=CI_M64_GTC_UMC)
    {
     WriteVTReg(0x54, 0x101000);                //DD_SCALER_COLOUR_CNTL
     WriteVTReg(0x55, 0x2000);                      //DD_SCALER_H_COEFF0
     WriteVTReg(0x56, 0x0D06200D);              //DD_SCALER_H_COEFF1
     WriteVTReg(0x57, 0x0D0A1C0D);              //DD_SCALER_H_COEFF2
     WriteVTReg(0x58, 0x0C0E1A0C);              //DD_SCALER_H_COEFF3
     WriteVTReg(0x59, 0x0C14140C);              //DD_SCALER_H_COEFF4
    }

//connect video  (GP_IO_CNTL)
if (ppdev->iAsic == CI_M64_GTA)
    {
    // Hardware bug in GTA: Black screen after writing 0x1f
    DWORD local_value;
    DWORD HTotal;
    MemR32( 0x7 ,&local_value);
    MemW32(0x7,(local_value&0xffbfffff));
    MemR32(0x0,&HTotal);
    MemW32(0x7,local_value);

     MemW32(0x1F, 0x0);

     // for fixing the above hardware bug
     MemR32( 0x7 ,&local_value);
     MemW32(0x7,(local_value&0xffbfffff));
     MemW32(0x0,HTotal);
     MemW32(0x7,local_value);
      }
  else
      {
      if((ppdev->iAsic==CI_M64_VTA)||(ppdev->iAsic==CI_M64_VTB))
      MemW32(0x1F, 0x0);
      }


 // Enable I2C output.
        WriteVT264Reg(ppdev, 0, vtf_GEN_GIO2_EN, 1);
        // Disable DAC feature connector
        WriteVT264Reg(ppdev, 0, vtf_DAC_FEA_CON_EN, 0);
        // Enable I2C clock output pin
        WriteVT264Reg(ppdev,0, vtf_DAC_GIO_DIR_1, 1);
        // Set data direction of I2C bus
        SetI2CDataDirection(ppdev, 0, I2C_READ);
        // Set I2C Clock High
        WriteI2CClock(ppdev, 0, I2C_HIGH);
        I2CDelay(ppdev, 0);
#else
        i;
        value;
#endif


#ifndef TEST_SWITCH

if(ppdev->pal_str.preg!=NULL)
{
    for(i=0;i<256;i++)
    {
    if(((i<0x1a)||(i>0x1e))&&(i<0x30))
           {
            // some registers return a different value at read in respect with write
            switch(i)
                {
                 DWORD temp;
                case 0x09:      //OVERLAY_SCALE_CNTL
                        temp=  (DWORD)(*(ppdev->pal_str.preg+i))&0xfbffffff;
                        WriteVTReg(i,temp);
                        break;
                case 0x14:      //CAPTURE_CONFIG
                        temp=(DWORD)(*(ppdev->pal_str.preg+i))&0xffffffbf;
                        WriteVTReg(i,temp);
                        break;
                case 0x15:      //TRIG_CNTL
                        temp=  (DWORD)(*(ppdev->pal_str.preg+i))&0xfffffff0;
                        WriteVTReg(i,temp);
                        break;
                    default:
                        WriteVTReg(i,(DWORD)(*(ppdev->pal_str.preg+i)));

                }

           }
    }
    // now restore the content of registers in block 0
            value=(DWORD)(*(ppdev->pal_str.preg+i));
            MemW32(0x1E, value);
            i++;
            MemR32(0x28,&value);
            value=((value&0xf7ffffff)|( (DWORD)(*(ppdev->pal_str.preg+i))&0x08000000 ));
            MemW32(0x28, value);
            i++;
            MemR32(0x31,&value);
            if ((ppdev->iAsic ==CI_M64_VTA)||(ppdev->iAsic ==CI_M64_GTA))
                value=((value&0x80ffbfff)|( (DWORD)(*(ppdev->pal_str.preg+i))&0x3f004000 ));
            else
                value=((value&0xffffbfff)|( (DWORD)(*(ppdev->pal_str.preg+i))&0x00004000 ));
            MemW32(0x31, value);
            i++;

            if ((ppdev->iAsic ==CI_M64_VTA)||(ppdev->iAsic ==CI_M64_GTA))
              {
               if (ppdev->iAsic == CI_M64_GTA)
                      {
                       // Hardware bug in GTA: Black screen after writing 0x1f
                       DWORD local_value;
                       DWORD HTotal;
                       MemR32( 0x7 ,&local_value);
                       MemW32(0x7,(local_value&0xffbfffff));
                       MemR32(0x0,&HTotal);
                       MemW32(0x7,local_value);

                        MemW32(0x1F, *(ppdev->pal_str.preg+i));

                        // for fixing the above hardware bug
                        MemR32( 0x7 ,&local_value);
                        MemW32(0x7,(local_value&0xffbfffff));
                        MemW32(0x0,HTotal);
                        MemW32(0x7,local_value);
                       }
                else
                      {
                      MemW32(0x1F, *(ppdev->pal_str.preg+i));
                      }
                i++;

                MemR32(0x34,&value);
                value=((value&0xffffffc2)|( (DWORD)(*(ppdev->pal_str.preg+i))&0x3d ));
                MemW32(0x34, value);
                i++;
                #define     EXCLUDE_WRITE
                #ifndef      EXCLUDE_WRITE
                MemW32(0x07, *(ppdev->pal_str.preg+i));
                i++;
                MemW32(0x24, *(ppdev->pal_str.preg+i));
                #endif
              }
}
#endif
AtiFreeMem((HLOCAL)ppdev->pal_str.preg) ;
}


ULONG ReallocMemory(PDEV* ppdev)
{
    ULONG RetVal;
    OFFSCREEN       OffSize;                        //  overlay structure
    OVERLAY_LOCATION    Overlay;         // pointer in linear memory to the begining of the overlay (top-left)
    int     i,j;
    DWORD key_clr;
    DWORD key_mask;

    RetVal=1;
    j=ppdev->pal_str.alloc_cnt;
    ppdev->pal_str.alloc_cnt =0;
    ppdev->pal_str.no_lines_allocated=0;

    //set the flag for mode switch
    ppdev->pal_str.Mode_Switch_flag=TRUE;

    // set the colour key and mask after a mode switch
    switch(ppdev->cBitsPerPel)
           {
           case 8:
               key_clr=0xFD;
               key_mask=0xFF;
               break;
           case 15:
               key_clr=0x7C1F;
               key_mask=0xFFFF;
               break;
           case 16:
               key_clr=0xF81F;
               key_mask=0xFFFF;
               break;
           case 24:
               key_clr=0xFF00FF;
               key_mask=0xFFFFFF;
               break;
           case 32:
               key_clr=0xFF00FF; //?
               key_mask=0xFFFFFF;     //?
               break;
           }

    *(ppdev->pal_str.preg+0x4)=(DWORD)key_clr;
    *(ppdev->pal_str.preg+0x5)=(DWORD)key_mask;

    for (i=0;i<j; i++)
        {
        OffSize.cx=ppdev->pal_str.alloc_hist[ppdev->pal_str.alloc_cnt].x_bits ;
        OffSize.cy=ppdev->pal_str.alloc_hist[ppdev->pal_str.alloc_cnt].y_bits  ;
        ppdev->pal_str.Realloc_mem_flag=TRUE;
        RetVal=AllocOffscreenMem(ppdev, &OffSize, &Overlay);
        if(RetVal==ESC_ALLOC_FAIL)
            {
            ppdev->pal_str.alloc_cnt=j;
            RetVal=0;
            return RetVal;
            }
        if(i==0) //update the buffer registers with the new values
            {
            // save the offset value in the ppdev->pal_str
            ppdev->pal_str.Buf0_Offset =(DWORD)(Overlay.app_offset);

            //set CAPTURE_BUF0_OFFSET
            *(ppdev->pal_str.preg+0x20)=(DWORD)(Overlay.app_offset);
             if ((ppdev->iAsic ==CI_M64_VTB)||(ppdev->iAsic >=CI_M64_GTB))
                 {
                //set the SCALER_BUF0_OFFSET
                *(ppdev->pal_str.preg+0x0e)=(DWORD)(Overlay.app_offset);
                //set ONESHOT_BUFF_OFFSET
                *(ppdev->pal_str.preg+0x22)=(DWORD)(Overlay.app_offset);
                 }
             else
                 { //GTA or VTA
                    *(ppdev->pal_str.preg+0x26)=(DWORD)(Overlay.app_offset);
                    *(ppdev->pal_str.preg+0x2B)=(DWORD)(Overlay.app_offset);
                    *(ppdev->pal_str.preg+0x2C)=(DWORD)(Overlay.app_offset);
                 }
            }

        #if     0 // for the moment we are not using double buffering at this moment
        if(i==1)
            {
            //set the SCALER_BUF1_OFFSET
            *(ppdev->pal_str.preg+0xe)=(DWORD)(Overlay.app_offset);
            //set CAPTURE_BUF1_OFFSET
            *(ppdev->pal_str.preg+0x21)=(DWORD)(Overlay.app_offset);
            }
        #endif
        }
    RetVal=1;
    return RetVal;
}


ULONG AllocOffscreenMem(PDEV* ppdev, PVOID pvIn, PVOID pvOut)
    {
    //OFFSCREEN   OffSize;
    OFFSCREEN* pOffSize;                // pointer to the offscreen area size for overlay structure
    OVERLAY_LOCATION* pOverlay;         // pointer in linear memory to the begining of the overlay (top-left)
    LONG x_size;
    LONG y_size;
    LONG x_size_orig;                      // for history purposes
    LONG y_size_orig;                      // for history purposes
    LONG x_bits;                               // for history purposes
    LONG y_bits;                               // for history purposes
    int temp_alloc_lines_cnt;
    ULONG RetVal;

    // If LINEAR is defined then we allocate the memory for the buffer as a contiguous zone (no as a rectangle). This will imply
    // that the BUFF PITCH = width of the capture  (for rectangle approach the pitch can be equal with the screen pitch)
    #define LINEAR

    #ifdef LINEAR
    POINTL req;
    #endif

    DISPDBG( (DEBUG_ESC_2,"PAL : AllocOffscreenMem "));
    //DebugBreak() ;

    //NEW APPROACH FOR MEM MANAGEMENT

    // If LINEAR is defined then we allocate the memory for the buffer as a contiguous zone (no as a rectangle). This will imply
    // that the BUFF PITCH = width of the capture  (for rectangle approach the pitch can be equal with the screen pitch)
    #ifndef LINEAR
    //allocate memory for the overlay
    pOffSize=(OFFSCREEN*)pvIn;
    //the size is assumed to be in bits
    //we add 64 for alingment provision
    if((ULONG)(pOffSize->cx)<=(ULONG)((ppdev->cxScreen)-64l))
        {
        x_size=(((pOffSize->cx)+63)&(0xfffffffc))/(ppdev->cBitsPerPel);
        }
    else
        {
        //since the maximum width for source is 384 pixels is very improbable that "else" case will be hit
        x_size=(pOffSize->cx)/(ppdev->cBitsPerPel);
        }
    y_size=(pOffSize->cy);
    DISPDBG( (DEBUG_ESC_2," Rectangular allocation : x=%u  (RGB pels)    y=%u (no of lines)", x_size, y_size));

    (ppdev->pal_str.poh)=NULL;
     // the following statement is for the new architecture for display driver
    pohAllocate(ppdev, NULL, x_size, y_size, FLOH_MAKE_PERMANENT);
#else
   // linear allocation
#if   TARGET_BUILD > 351
   // first thing, dealloc Heap allocated by DDraw
   if(ppdev->pohDirectDraw!=NULL)
       {
       pohFree(ppdev, ppdev->pohDirectDraw);
       ppdev->pohDirectDraw = NULL;
       }
#endif
    pOffSize=(OFFSCREEN*)pvIn;
   //the size is assumed to be in bits of RGB pixels at the current resolution
   //(the palindrome is making the conversion: RGB pixels=UYV pixels*16/ current bpp )
       //x_size=(pOffSize->cx)/(ppdev->cBitsPerPel);    // now we have pixels (this was introduced because in the palindrome code we have made width=width*16)
       x_size=(pOffSize->cx);
       y_size=(pOffSize->cy);
       x_size_orig=((pOffSize->cx)*16)/(ppdev->cBitsPerPel);
       y_size_orig=(pOffSize->cy);
       if(ppdev->pal_str.Realloc_mem_flag==TRUE)
            {
            x_bits= (pOffSize->cx);
            y_bits=  (pOffSize->cy);
            }
        else
            {
            x_bits=(pOffSize->cx)*(ppdev->cBitsPerPel);
            y_bits= (pOffSize->cy);
            }
   // First we will see if it's a real allocation or , if the x,y_size=0, it's a deallocation of the last surface allocated
    if((x_size==0)||(y_size==0))
    {
        if(ppdev->pal_str.No_mem_allocated_flag==TRUE)
            {
            RetVal=ESC_IS_SUPPORTED;
            // in build 1358 we have problems if we return  ESC_ALLOC_FAIL
            //RetVal=ESC_ALLOC_FAIL;
            DISPDBG( (DEBUG_ESC_2,"Offscreen memory deallocation failed: ppdev->pal_str.poh==NULL  "));
            DISPDBG( (DEBUG_ESC_2," "));
            return (RetVal);
            }
        if(ppdev->pal_str.poh==NULL)
        {
            RetVal=ESC_IS_SUPPORTED;
            // in build 1358 we have problems if we return  ESC_ALLOC_FAIL
            //RetVal=ESC_ALLOC_FAIL;
            DISPDBG( (DEBUG_ESC_2,"Offscreen memory deallocation failed: ppdev->pal_str.poh==NULL  "));
            DISPDBG( (DEBUG_ESC_2," "));
            return (RetVal);

        }
        //Debug info about OH
     DISPDBG( (DEBUG_ESC_2," Memory  deallocation  (0,0 params) for the surface starting at x=%d, y=%d; width=%d, heigth=%d", ppdev->pal_str.poh->x, \
     ppdev->pal_str.poh->y, ppdev->pal_str.poh->cx, ppdev->pal_str.poh->cy));
     DISPDBG( (DEBUG_ESC_2," Status of allocation:"));
     switch(ppdev->pal_str.poh->ohState)
     {
     case   0:
         DISPDBG( (DEBUG_ESC_2," OH_FREE"));
         break;
     case 1:
         DISPDBG( (DEBUG_ESC_2," OH_DISCARDABLE"));
         break;
     case 2:
         DISPDBG( (DEBUG_ESC_2," OH_PERMANENT"));
         break;
     default:
         DISPDBG( (DEBUG_ESC_2," Unknown status!!"));
     }
    // end debug info

        // deallocation of the last poh
        pohFree(ppdev,(ppdev->pal_str.poh));
#ifndef  ALLOC_RECT_ANYWHERE
        //decrement the no. of allocated lines  with the no. of lines alocated lately
        ppdev->pal_str.no_lines_allocated-=ppdev->pal_str.alloc_hist[(ppdev->pal_str.alloc_cnt)-1].y_lines;
#endif
        // decrement the allocation counter
        ppdev->pal_str.alloc_cnt--;
        // NULL the pointer to poh
        ppdev->pal_str.poh=NULL;
        // set the overlay_offset to 0
        pOverlay=(OVERLAY_LOCATION*)pvOut;//&overlay_xy;
        pOverlay->app_offset=0L;
        // exit and return OK
        DISPDBG( (DEBUG_ESC_2,"Offscreen memory deallocation OK  "));
        DISPDBG( (DEBUG_ESC_2," "));
        RetVal=ESC_IS_SUPPORTED;
        return (RetVal);
    }

         // compute the total pixels
       if(ppdev->pal_str.Realloc_mem_flag==TRUE)
           {
           // if we are reallocating memory due to mode switch, see how much
           x_size=(x_size*y_size)/(ppdev->cBitsPerPel) +1;
           ppdev->pal_str.Realloc_mem_flag=FALSE;
           }
       else
           {
           x_size=x_size*y_size;
           }
 // how big is y if we'll use as x the total screen width (except in 800x600 in 8bpp, where cxMemory=832 and we have some problems)
#ifdef      BUG_800x600_8BPP
        //800x600 8bpp bug
       if(ppdev->cxMemory==832)
          y_size=(x_size/ppdev->cxScreen)+1;
      else
#endif
           y_size=(x_size/ppdev->cxMemory)+1;

       DISPDBG( (DEBUG_ESC_2," Linear  allocation: x=%u (total x*y in RGB pixels)      y=%u (lines at current resolution)",x_size, y_size));

       (ppdev->pal_str.poh)=NULL;
       // we want the allocation starting here:
       req.x=0;
       req.y=ppdev->cyScreen + 10 + ppdev->pal_str.no_lines_allocated;     //10 lines after the ending of visible screen + no. of lines already allocated before by this fnct.
       DISPDBG( (DEBUG_ESC_2," Visible memory width: x=%u     Visible memory height y=%u ",ppdev->cxScreen ,ppdev->cyScreen));
       DISPDBG( (DEBUG_ESC_2," Total Memory width: x=%u     Total Memory height y=%u     Bpp= %u",ppdev->cxMemory ,ppdev->cyMemory, ppdev->cBitsPerPel));
       DISPDBG( (DEBUG_ESC_2,"Parameters for poh alloc : address x=%u  y=%u \n x_dim=%u   y_dim=%u ",req.x,req.y,ppdev->cxMemory, y_size));
       // move everything to system memory  (this function is absolutely necessary)
       if(!bMoveAllDfbsFromOffscreenToDibs(ppdev))
       {
           DISPDBG( (DEBUG_ESC_2,"bMoveAllDfbsFromOffscreenToDibs failed "));
       }
       //the actual allocation fnct.
#ifdef      BUG_800x600_8BPP
       //800x600 8bpp bug
       if(ppdev->cxMemory==832)
           {
#ifndef  ALLOC_RECT_ANYWHERE
               (ppdev->pal_str.poh)=pohAllocate(ppdev,&req,ppdev->cxScreen,y_size, FLOH_MAKE_PERMANENT);
#else
                (ppdev->pal_str.poh)=pohAllocate(ppdev,NULL,ppdev->cxScreen,y_size, FLOH_MAKE_PERMANENT);
#endif
           }
       else
#endif
            {
#ifndef  ALLOC_RECT_ANYWHERE
                (ppdev->pal_str.poh)=pohAllocate(ppdev,&req,ppdev->cxMemory,y_size, FLOH_MAKE_PERMANENT);
#else
                (ppdev->pal_str.poh)=pohAllocate(ppdev,NULL,ppdev->cxMemory,y_size, FLOH_MAKE_PERMANENT);
#endif
            }
       if(ppdev->pal_str.poh==NULL)
       {
#ifndef  ALLOC_RECT_ANYWHERE             //jump over loop
            DISPDBG( (DEBUG_ESC_2," Loop for detecting free heap zone"));
            // use a counter for eventually allocated lines
            temp_alloc_lines_cnt=0;
           do
               {
#ifndef  ALLOC_RECT_ANYWHERE
                temp_alloc_lines_cnt++;
                ppdev->pal_str.no_lines_allocated+=1;
                req.y=ppdev->cyScreen + 10 + ppdev->pal_str.no_lines_allocated;
#endif
#ifdef      BUG_800x600_8BPP
                //800x600 8bpp bug
                if(ppdev->cxMemory==832)
                    {
#ifndef  ALLOC_RECT_ANYWHERE
               (ppdev->pal_str.poh)=pohAllocate(ppdev,&req,ppdev->cxScreen,y_size, FLOH_MAKE_PERMANENT);
#else
                (ppdev->pal_str.poh)=pohAllocate(ppdev,NULL,ppdev->cxScreen,y_size, FLOH_MAKE_PERMANENT);
#endif
                    }
                else
#endif
                    {
#ifndef  ALLOC_RECT_ANYWHERE
                (ppdev->pal_str.poh)=pohAllocate(ppdev,&req,ppdev->cxMemory,y_size, FLOH_MAKE_PERMANENT);
#else
                (ppdev->pal_str.poh)=pohAllocate(ppdev,NULL,ppdev->cxMemory,y_size, FLOH_MAKE_PERMANENT);
#endif
                    }
               }
          while(((ppdev->pal_str.poh)==NULL)&&(req.y<((ppdev->cyMemory)-y_size))) ;
#endif                     // jump over loop
          if((req.y>=((ppdev->cyMemory)-y_size)))
          {
                    ppdev->pal_str.poh=NULL;
                    ppdev->pal_str.no_lines_allocated=ppdev->pal_str.no_lines_allocated - temp_alloc_lines_cnt;
                    DISPDBG( (DEBUG_ESC_2," End loop. Not enough space in off-screen memory"));
          }
         else
                  DISPDBG( (DEBUG_ESC_2," End loop. The free zone starts at %u line",req.y));
       }

#endif
   DISPDBG( (DEBUG_ESC_2," allocation initialy requested (by ESC call): x=%u (in bits)     y=%u (in lines)",pOffSize->cx,pOffSize->cy));
    if((ppdev->pal_str.poh)==NULL)
    {
        RetVal=ESC_ALLOC_FAIL;
        //initialize de pointer
        #if 0
        pOverlay=(OVERLAY_LOCATION*)pvOut;
        pOverlay->app_offset= 0L;
        #endif
        DISPDBG( (DEBUG_ESC_2,"Offscreen memory allocation failed "));
         DISPDBG( (DEBUG_ESC_2," "));
        return (RetVal);
    }
    // save info about alloc
    ppdev->pal_str.alloc_hist[ppdev->pal_str.alloc_cnt].x=x_size_orig;    //ppdev->cxMemory;
    ppdev->pal_str.alloc_hist[ppdev->pal_str.alloc_cnt].y=y_size_orig;
    ppdev->pal_str.alloc_hist[ppdev->pal_str.alloc_cnt].y_lines=y_size;    // no of lines allocated at current memory width
    ppdev->pal_str.alloc_hist[ppdev->pal_str.alloc_cnt].poh=ppdev->pal_str.poh;
    ppdev->pal_str.no_lines_allocated+=y_size; // total no of lines already allocated at this moment
    // two new fields for 4.0 because the colour depth can be changed on the fly, and we need the original dimensions in bits
    ppdev->pal_str.alloc_hist[ppdev->pal_str.alloc_cnt].x_bits= x_bits;
    ppdev->pal_str.alloc_hist[ppdev->pal_str.alloc_cnt].y_bits= y_bits;

    //Debug info about OH
    DISPDBG( (DEBUG_ESC_2," Memory  allocation for the surface starting at x=%d, y=%d; width=%d, heigth=%d", ppdev->pal_str.alloc_hist[ppdev->pal_str.alloc_cnt].poh->x, \
     ppdev->pal_str.alloc_hist[ppdev->pal_str.alloc_cnt].poh->y, ppdev->pal_str.alloc_hist[ppdev->pal_str.alloc_cnt].poh->cx, ppdev->pal_str.alloc_hist[ppdev->pal_str.alloc_cnt].poh->cy));
     DISPDBG( (DEBUG_ESC_2," Status of allocation:"));
     switch(ppdev->pal_str.alloc_hist[ppdev->pal_str.alloc_cnt].poh->ohState)
     {
     case   0:
         DISPDBG( (DEBUG_ESC_2," OH_FREE"));
         break;
     case 1:
         DISPDBG( (DEBUG_ESC_2," OH_DISCARDABLE"));
         break;
     case 2:
         DISPDBG( (DEBUG_ESC_2," OH_PERMANENT"));
         break;
     default:
         DISPDBG( (DEBUG_ESC_2," Unknown status!!"));
     }
    // end debug info
     // increment the alloc counter
    ppdev->pal_str.alloc_cnt++;

    //send back the info about where the allocated memory is
    //initialize de pointer
    pOverlay=(OVERLAY_LOCATION*)pvOut;//&overlay_xy;
    //compute the location for the off_screen memory enforcing the alingment at 64 bits
    // I abandoned this approach in the new stream code for the display driver
    pOverlay->app_offset=(ULONG)((ppdev->pal_str.poh->y*ppdev->lDelta) +(ppdev->pal_str.poh->x*ppdev->cjPelSize) ) &(ULONG)(0x0fffffff8);
    DISPDBG( (DEBUG_ESC_2," Memory  allocation OK at 0x%lX, no. of lines totally allocated %u", pOverlay->app_offset, ppdev->pal_str.no_lines_allocated));
    DISPDBG( (DEBUG_ESC_2," "));
    RetVal=ESC_IS_SUPPORTED;
    return (RetVal);
    }


ULONG DeallocOffscreenMem(PDEV* ppdev)
{
    ULONG RetVal;
    int i;
    // support for off-screen memory management for PALINDROME
    // function for deallocation of off-screen memory used by the overlay
    //Seems that we don't need to keep a record with the allocated poh because all of them will be erased in bulk
    // {see ddthunk.c in the original palindrome code)


 //relase all the allocated off_screen space
    DISPDBG( (DEBUG_ESC_2," Memory  deallocation for %u surfaces in offscreen mem", ppdev->pal_str.alloc_cnt));
    DISPDBG( (DEBUG_ESC_2," "));

if(ppdev->pal_str.No_mem_allocated_flag==FALSE)
    {
     for(i=0;i<ppdev->pal_str.alloc_cnt; i++ )
         {
         //debug info
         DISPDBG( (DEBUG_ESC_2," Memory  deallocation for the surface starting at x=%d, y=%d; width=%d, heigth=%d", ppdev->pal_str.alloc_hist[ppdev->pal_str.alloc_cnt].poh->x, \
         ppdev->pal_str.alloc_hist[ppdev->pal_str.alloc_cnt].poh->y, ppdev->pal_str.alloc_hist[ppdev->pal_str.alloc_cnt].poh->cx, ppdev->pal_str.alloc_hist[ppdev->pal_str.alloc_cnt].poh->cy));
         DISPDBG( (DEBUG_ESC_2," Status of allocation:"));
         switch(ppdev->pal_str.alloc_hist[ppdev->pal_str.alloc_cnt].poh->ohState)
             {
             case   0:
                 DISPDBG( (DEBUG_ESC_2," OH_FREE"));
                 break;
             case 1:
                 DISPDBG( (DEBUG_ESC_2," OH_DISCARDABLE"));
                 break;
             case 2:
                 DISPDBG( (DEBUG_ESC_2," OH_PERMANENT"));
                 break;
             default:
                 DISPDBG( (DEBUG_ESC_2," Unknown status!!"));
             }
         // end debug info
          // deallocate only if the poh is valid
          if((ppdev->pal_str.alloc_hist[ppdev->pal_str.alloc_cnt].poh->x>ppdev->cxScreen) &&(ppdev->pal_str.alloc_hist[ppdev->pal_str.alloc_cnt].poh->x<ppdev->cxMemory) \
              &&(ppdev->pal_str.alloc_hist[ppdev->pal_str.alloc_cnt].poh->y>ppdev->cyScreen)&&(ppdev->pal_str.alloc_hist[ppdev->pal_str.alloc_cnt].poh->y<ppdev->cyMemory) )
                {
                 pohFree(ppdev,(ppdev->pal_str.alloc_hist[ppdev->pal_str.alloc_cnt].poh));
                }
              else
                  {
                  DISPDBG( (DEBUG_ESC_2," Unvalid poh for DeAllocation"));
                  }
        }
    }
else
    {
    // reset the flag   if it was TRUE
    ppdev->pal_str.No_mem_allocated_flag=FALSE;
    }
 // reset the alloc counter
 ppdev->pal_str.alloc_cnt=0;
 ppdev->pal_str.no_lines_allocated=0;
 ppdev->pal_str.poh=NULL;

  RetVal=ESC_IS_SUPPORTED;
  return (RetVal);
 }


/*^^*
 * Function:    WriteVT264Reg
 *
 * Purpose:             To write to a VT register.
 *
 * Inputs:              PPDEV*, wCard:  WORD, the card to write to
 *                              bField: BYTE, the field to write to.
 *                              dwData: DWORD, The data to write.
 *
 * Outputs:             void.
 */
void WriteVT264Reg(PDEV* ppdev, WORD wCard, BYTE bField, DWORD dwData )
{
DWORD           dwMask;
DWORD           dwRegValue;
DWORD           dwRegOff;
BYTE            bShift;

        switch(bField) {

        case vtf_GP_IO_4:
                bShift = 4;
                dwMask = 0xffffffef;
                dwRegOff = 0x1e;
                break;

        case vtf_GP_IO_DIR_4:
                bShift = 20;
                dwMask = 0xffefffff;
                dwRegOff = 0x1e;
                break;

        case vtf_GP_IO_7:
                bShift = 7;
                dwMask = 0xffffff7f;
                dwRegOff = 0x1e;
                break;

        case vtf_GP_IO_B:
                bShift = 11;
                dwMask = 0xfffff7ff;
                dwRegOff = 0x1e;
                break;

        case vtf_GP_IO_DIR_B:
                    bShift = 27;
                    dwMask = 0xf7ffffff;
                    dwRegOff = 0x1e;
                    break;

        case vtf_GEN_GIO2_DATA_OUT:
                dwMask = 0xfffffffe;
                bShift = 0;
                dwRegOff = 52;
                break;

        case vtf_GEN_GIO2_WRITE:
                bShift = 5;
                dwMask = 0xffffffdf;
                dwRegOff = 52;
                break;

        case vtf_GEN_GIO3_DATA_OUT:
                bShift = 2;
                dwMask = 0xfffffffb;
                dwRegOff = 52;
                break;

        case vtf_GEN_GIO2_EN:
                bShift = 4;
                dwMask = 0xffffffef;
                dwRegOff = 52;
                break;

        case vtf_DAC_GIO_STATE_1:
                bShift = 24;
                dwMask = 0xfeffffff;
                dwRegOff = 49;
                break;

        case vtf_DAC_FEA_CON_EN:
                bShift = 14;
                dwMask = 0xffffbfff;
                dwRegOff = 49;
                break;

        case vtf_DAC_GIO_DIR_1:
                bShift = 27;
                dwMask = 0xf7ffffff;
                dwRegOff = 49;
                break;
        }

        dwData = dwData << bShift;

        MemR32(dwRegOff,&dwRegValue);

        dwRegValue &= dwMask;
        dwRegValue |= dwData;

        MemW32(dwRegOff,dwRegValue);
}

// end of WriteVT264Reg

/*^^*
 * Function:    ReadVT264Reg
 *
 * Purpose:             To read a register on the VT
 *
 * Inputs:              PPDEV*, wCard:  WORD, the card to read from.
 *                              bField: BYTE, the field to read.
 *
 * Outputs:             DWORD, the value read.
 *^^*/
DWORD ReadVT264Reg(PDEV* ppdev, WORD wCard, BYTE bField )
{
DWORD           dwMask;
DWORD           dwRegOff;
DWORD           dwRegValue;
DWORD           dwFldValue;
BYTE            bShift;

        switch(bField) {
        case vtf_GEN_GIO2_DATA_IN:
                bShift = 3;
                dwMask = 0x00000008;
                dwRegOff = 52;
                break;

        case vtf_CFG_CHIP_FND_ID:
                bShift = 27;
                dwMask = 0x38000000;
                dwRegOff = 56;
                break;

        case vtf_CFG_CHIP_MAJOR:
                bShift = 24;
                dwMask = 0x03000000;
                dwRegOff = 0x38;
                break;

        case vtf_GP_IO_4:
                bShift = 4;
                dwMask = 0x00000010;
                dwRegOff = 0x1e;
                break;

        }
        MemR32(dwRegOff,&dwRegValue);

        dwFldValue = dwRegValue & dwMask;
        dwFldValue = dwFldValue >> bShift;

        return(dwFldValue);
}
// end of ReadVT264Reg


VOID  DbgExtRegsDump(PDEV* ppdev)
{
    DWORD value;
    int i;

    for(i=0;i<256;i++)
       {
       ReadVTReg(i,&value);
       DISPDBG( (DEBUG_DUMP,"ExtRegs: reg 0x%X = 0x%Xl ",i,value));
       TempFnct(ppdev);
       }

}


VOID TempFnct(PDEV* ppdev)
{
    int i;
    for (i=0;i<800;i++)
        {
        ReadVT264Reg(ppdev, 0, vtf_CFG_CHIP_FND_ID);
        }
}

VOID DeallocDirectDraw(PDEV* ppdev)
{
#if TARGET_BUILD > 351
    if(ppdev->pohDirectDraw!=NULL)
          {
          pohFree(ppdev, ppdev->pohDirectDraw);
          ppdev->pohDirectDraw = NULL;
          }
#endif
}


VOID  ResetPalindrome(
PDEV* ppdevOld,
PDEV* ppdevNew)
{
    ULONG RetVal;

// save the pal structure in the new ppdev
    ppdevNew->pal_str=ppdevOld->pal_str;

    if((ppdevNew->pal_str.dos_flag==TRUE)&&(ppdevNew->pal_str.Palindrome_flag==TRUE))
         {
           RetVal=0;
           #if      1 // do not disable the following debug statements, they solve a bug
           DISPDBG( (DEBUG_DUMP,"The content of the Extended Registers after DrvResetPDEV"));
           DbgExtRegsDump(ppdevNew);
           #endif

          #ifdef  DYNAMIC_REZ_AND_COLOUR_CHANGE   // palindrome support for on the fly rez and colour depth
                #define  ALWAYS_REALLOC_MEM //always realloc memory for buffers after mode switch or exiting DOS with ALT+ENTER
          #endif

          #ifndef   ALWAYS_REALLOC_MEM
          //see if we are exiting DOS full screen with ALT+ENTER or is a mode switch
           if((ppdevNew->cBitsPerPel!=ppdevOld->cBitsPerPel)||(ppdevNew->cxScreen!=ppdevOld->cxScreen)||(ppdevNew->cyScreen!=ppdevOld->cyScreen))
                {
                // mode switch
                #if     0   //no more scaler and overlay after a mode switch
                RetVal=ReallocMemory(ppdevNew);
                #endif
                RetVal=0;
                }
           else
               {
               // exit dos full screen mode by ALT+ENTER
               bAssertModeOffscreenHeap(ppdevNew, FALSE);
               DeallocDirectDraw(ppdevNew);
               RetVal=ReallocMemory(ppdevNew);
               }
           #else
               bAssertModeOffscreenHeap(ppdevNew, FALSE); //not necessary
                DeallocDirectDraw(ppdevNew);                          // not necessary
                RetVal=ReallocMemory(ppdevNew);
           #endif

            if(RetVal==1)
               {
               vM64QuietDown(ppdevNew, ppdevNew->pjMmBase);
               EnableOvl(ppdevNew);
               ppdevNew->pal_str.dos_flag=FALSE;
               ppdevNew->pal_str.No_mem_allocated_flag=FALSE;
               vM64QuietDown(ppdevNew, ppdevNew->pjMmBase);

               #if      1
               DISPDBG( (DEBUG_DUMP,"The content of the Extended Registers after DrvResetPDEV"));
               DbgExtRegsDump(ppdevNew);
               #endif
               }
           else
               {
               ppdevNew->pal_str.Mode_Switch_flag=FALSE;
               ppdevNew->pal_str.dos_flag=FALSE;
               ppdevNew->pal_str.No_mem_allocated_flag=TRUE;
               // disable mem allocation in pal structure
                ppdevNew->pal_str.no_lines_allocated=0;
                ppdevNew->pal_str.alloc_cnt=0;
                ppdevNew->pal_str.poh=NULL;
               }
         }
}

// end of functions for palindrome support

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\misc.c ===
/******************************Module*Header*******************************\
* Module Name: misc.c
*
* Miscellaneous common routines.
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Table********************************\
* ULONG gaul32HwMixFromRop2[]
*
* Table to convert from a Source and Destination Rop2 to the Mach32's
* hardware mix.
\**************************************************************************/

ULONG gaul32HwMixFromRop2[] = {
    LOGICAL_0,                      // 00 -- 0      BLACKNESS
    NOT_SCREEN_AND_NOT_NEW,         // 11 -- DSon   NOTSRCERASE
    SCREEN_AND_NOT_NEW,             // 22 -- DSna
    NOT_NEW,                        // 33 -- Sn     NOSRCCOPY
    NOT_SCREEN_AND_NEW,             // 44 -- SDna   SRCERASE
    NOT_SCREEN,                     // 55 -- Dn     DSTINVERT
    SCREEN_XOR_NEW,                 // 66 -- DSx    SRCINVERT
    NOT_SCREEN_OR_NOT_NEW,          // 77 -- DSan
    SCREEN_AND_NEW,                 // 88 -- DSa    SRCAND
    NOT_SCREEN_XOR_NEW,             // 99 -- DSxn
    LEAVE_ALONE,                    // AA -- D
    SCREEN_OR_NOT_NEW,              // BB -- DSno   MERGEPAINT
    OVERPAINT,                      // CC -- S      SRCCOPY
    NOT_SCREEN_OR_NEW,              // DD -- SDno
    SCREEN_OR_NEW,                  // EE -- DSo    SRCPAINT
    LOGICAL_1                       // FF -- 1      WHITENESS
};

/******************************Public*Table********************************\
* ULONG gaul32HwMixFromMix[]
*
* Table to convert from a GDI mix value to the Mach32's hardware mix.
*
* Ordered so that the mix may be calculated from gaul32HwMixFromMix[mix & 0xf]
* or gaul32HwMixFromMix[mix & 0xff].
\**************************************************************************/

ULONG gaul32HwMixFromMix[] = {
    LOGICAL_1,                      // 0  -- 1
    LOGICAL_0,                      // 1  -- 0
    NOT_SCREEN_AND_NOT_NEW,         // 2  -- DPon
    SCREEN_AND_NOT_NEW,             // 3  -- DPna
    NOT_NEW,                        // 4  -- Pn
    NOT_SCREEN_AND_NEW,             // 5  -- PDna
    NOT_SCREEN,                     // 6  -- Dn
    SCREEN_XOR_NEW,                 // 7  -- DPx
    NOT_SCREEN_OR_NOT_NEW,          // 8  -- DPan
    SCREEN_AND_NEW,                 // 9  -- DPa
    NOT_SCREEN_XOR_NEW,             // 10 -- DPxn
    LEAVE_ALONE,                    // 11 -- D
    SCREEN_OR_NOT_NEW,              // 12 -- DPno
    OVERPAINT,                      // 13 -- P
    NOT_SCREEN_OR_NEW,              // 14 -- PDno
    SCREEN_OR_NEW,                  // 15 -- DPo
    LOGICAL_1                       // 16 -- 1
};

/******************************Public*Table********************************\
* ULONG gaul64HwMixFromRop2[]
*
* Table to convert from a Source and Destination Rop2 to the Mach64's
* foreground hardware mix.
\**************************************************************************/

ULONG gaul64HwMixFromRop2[] = {
    LOGICAL_0 << 16,                // 00 -- 0      BLACKNESS
    NOT_SCREEN_AND_NOT_NEW << 16,   // 11 -- DSon   NOTSRCERASE
    SCREEN_AND_NOT_NEW << 16,       // 22 -- DSna
    NOT_NEW << 16,                  // 33 -- Sn     NOSRCCOPY
    NOT_SCREEN_AND_NEW << 16,       // 44 -- SDna   SRCERASE
    NOT_SCREEN << 16,               // 55 -- Dn     DSTINVERT
    SCREEN_XOR_NEW << 16,           // 66 -- DSx    SRCINVERT
    NOT_SCREEN_OR_NOT_NEW << 16,    // 77 -- DSan
    SCREEN_AND_NEW << 16,           // 88 -- DSa    SRCAND
    NOT_SCREEN_XOR_NEW << 16,       // 99 -- DSxn
    LEAVE_ALONE << 16,              // AA -- D
    SCREEN_OR_NOT_NEW << 16,        // BB -- DSno   MERGEPAINT
    OVERPAINT << 16,                // CC -- S      SRCCOPY
    NOT_SCREEN_OR_NEW << 16,        // DD -- SDno
    SCREEN_OR_NEW << 16,            // EE -- DSo    SRCPAINT
    LOGICAL_1 << 16                 // FF -- 1      WHITENESS
};

/******************************Public*Table********************************\
* ULONG gaul64HwMixFromMix[]
*
* Table to convert from a GDI mix value to the Mach64's foreground hardware
* mix.
*
* Ordered so that the mix may be calculated from gaul64HwMixFromMix[mix & 0xf]
* or gaul64HwMixFromMix[mix & 0xff].
\**************************************************************************/

ULONG gaul64HwMixFromMix[] = {
    LOGICAL_1 << 16,                // 0  -- 1
    LOGICAL_0 << 16,                // 1  -- 0
    NOT_SCREEN_AND_NOT_NEW << 16,   // 2  -- DPon
    SCREEN_AND_NOT_NEW << 16,       // 3  -- DPna
    NOT_NEW << 16,                  // 4  -- Pn
    NOT_SCREEN_AND_NEW << 16,       // 5  -- PDna
    NOT_SCREEN << 16,               // 6  -- Dn
    SCREEN_XOR_NEW << 16,           // 7  -- DPx
    NOT_SCREEN_OR_NOT_NEW << 16,    // 8  -- DPan
    SCREEN_AND_NEW << 16,           // 9  -- DPa
    NOT_SCREEN_XOR_NEW << 16,       // 10 -- DPxn
    LEAVE_ALONE << 16,              // 11 -- D
    SCREEN_OR_NOT_NEW << 16,        // 12 -- DPno
    OVERPAINT << 16,                // 13 -- P
    NOT_SCREEN_OR_NEW << 16,        // 14 -- PDno
    SCREEN_OR_NEW << 16,            // 15 -- DPo
    LOGICAL_1 << 16                 // 16 -- 1
};

/******************************Public*Data*********************************\
* MIX translation table
*
* Translates a mix 1-16, into an old style Rop 0-255.
*
\**************************************************************************/

BYTE gaRop3FromMix[] =
{
    0xFF,  // R2_WHITE          - Allow rop = gaRop3FromMix[mix & 0x0F]
    0x00,  // R2_BLACK
    0x05,  // R2_NOTMERGEPEN
    0x0A,  // R2_MASKNOTPEN
    0x0F,  // R2_NOTCOPYPEN
    0x50,  // R2_MASKPENNOT
    0x55,  // R2_NOT
    0x5A,  // R2_XORPEN
    0x5F,  // R2_NOTMASKPEN
    0xA0,  // R2_MASKPEN
    0xA5,  // R2_NOTXORPEN
    0xAA,  // R2_NOP
    0xAF,  // R2_MERGENOTPEN
    0xF0,  // R2_COPYPEN
    0xF5,  // R2_MERGEPENNOT
    0xFA,  // R2_MERGEPEN
    0xFF   // R2_WHITE          - Allow rop = gaRop3FromMix[mix & 0xFF]
};

/******************************Public*Routine******************************\
* BOOL bIntersect
*
* If 'prcl1' and 'prcl2' intersect, has a return value of TRUE and returns
* the intersection in 'prclResult'.  If they don't intersect, has a return
* value of FALSE, and 'prclResult' is undefined.
*
\**************************************************************************/

BOOL bIntersect(
RECTL*  prcl1,
RECTL*  prcl2,
RECTL*  prclResult)
{
    prclResult->left  = max(prcl1->left,  prcl2->left);
    prclResult->right = min(prcl1->right, prcl2->right);

    if (prclResult->left < prclResult->right)
    {
        prclResult->top    = max(prcl1->top,    prcl2->top);
        prclResult->bottom = min(prcl1->bottom, prcl2->bottom);

        if (prclResult->top < prclResult->bottom)
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* LONG cIntersect
*
* This routine takes a list of rectangles from 'prclIn' and clips them
* in-place to the rectangle 'prclClip'.  The input rectangles don't
* have to intersect 'prclClip'; the return value will reflect the
* number of input rectangles that did intersect, and the intersecting
* rectangles will be densely packed.
*
\**************************************************************************/

LONG cIntersect(
RECTL*  prclClip,
RECTL*  prclIn,         // List of rectangles
LONG    c)              // Can be zero
{
    LONG    cIntersections;
    RECTL*  prclOut;

    cIntersections = 0;
    prclOut        = prclIn;

    for (; c != 0; prclIn++, c--)
    {
        prclOut->left  = max(prclIn->left,  prclClip->left);
        prclOut->right = min(prclIn->right, prclClip->right);

        if (prclOut->left < prclOut->right)
        {
            prclOut->top    = max(prclIn->top,    prclClip->top);
            prclOut->bottom = min(prclIn->bottom, prclClip->bottom);

            if (prclOut->top < prclOut->bottom)
            {
                prclOut++;
                cIntersections++;
            }
        }
    }

    return(cIntersections);
}

/******************************Public*Routine******************************\
* VOID vResetClipping
\**************************************************************************/

VOID vResetClipping(
PDEV*   ppdev)
{
    BYTE*   pjMmBase;
    BYTE*   pjIoBase;

    if (ppdev->iMachType == MACH_MM_64)
    {
        pjMmBase = ppdev->pjMmBase;

        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 2);
        M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(0, M64_MAX_SCISSOR_R));
        M64_OD(pjMmBase, SC_TOP_BOTTOM, PACKPAIR(0, ppdev->cyMemory));
    }
    else if (ppdev->iMachType == MACH_MM_32)
    {
        pjMmBase = ppdev->pjMmBase;

        M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 4);
        M32_OW(pjMmBase, EXT_SCISSOR_L, 0);
        M32_OW(pjMmBase, EXT_SCISSOR_R, M32_MAX_SCISSOR);
        M32_OW(pjMmBase, EXT_SCISSOR_T, 0);
        M32_OW(pjMmBase, EXT_SCISSOR_B, M32_MAX_SCISSOR);
    }
    else
    {
        pjIoBase = ppdev->pjIoBase;

        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 4);
        I32_OW(pjIoBase, EXT_SCISSOR_L, 0);
        I32_OW(pjIoBase, EXT_SCISSOR_R, M32_MAX_SCISSOR);
        I32_OW(pjIoBase, EXT_SCISSOR_T, 0);
        I32_OW(pjIoBase, EXT_SCISSOR_B, M32_MAX_SCISSOR);
    }
}

/******************************Public*Routine******************************\
* VOID vSetClipping
\**************************************************************************/

VOID vSetClipping(
PDEV*   ppdev,
RECTL*  prclClip)           // In relative coordinates
{
    LONG    xOffset;
    LONG    yOffset;
    BYTE*   pjMmBase;
    BYTE*   pjIoBase;

    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    if (ppdev->iMachType == MACH_MM_64)
    {
        pjMmBase = ppdev->pjMmBase;

        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 2);
        if (ppdev->iBitmapFormat != BMF_24BPP)
        {
            M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(xOffset + prclClip->left,
                                                     xOffset + prclClip->right - 1));
        }
        else
        {
            M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR((xOffset + prclClip->left) * 3,
                                                     (xOffset + prclClip->right) * 3 - 1));
        }
        M64_OD(pjMmBase, SC_TOP_BOTTOM, PACKPAIR(yOffset + prclClip->top,
                                                 yOffset + prclClip->bottom - 1));
    }
    else if (ppdev->iMachType == MACH_MM_32)
    {
        pjMmBase = ppdev->pjMmBase;

        M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 4);
        M32_OW(pjMmBase, EXT_SCISSOR_L, xOffset + prclClip->left);
        M32_OW(pjMmBase, EXT_SCISSOR_R, xOffset + prclClip->right - 1);
        M32_OW(pjMmBase, EXT_SCISSOR_T, yOffset + prclClip->top);
        M32_OW(pjMmBase, EXT_SCISSOR_B, yOffset + prclClip->bottom - 1);
    }
    else
    {
        pjIoBase = ppdev->pjIoBase;

        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 4);
        I32_OW(pjIoBase, EXT_SCISSOR_L, xOffset + prclClip->left);
        I32_OW(pjIoBase, EXT_SCISSOR_R, xOffset + prclClip->right - 1);
        I32_OW(pjIoBase, EXT_SCISSOR_T, yOffset + prclClip->top);
        I32_OW(pjIoBase, EXT_SCISSOR_B, yOffset + prclClip->bottom - 1);
    }
}

////////////////////////////////////////////////////////////////////////////////
// For mach8 cards only...
//

VOID vI32DataPortIn(PDEV *ppdev, WORD *pw, UINT count)
{
    BYTE *pjIoBase = ppdev->pjIoBase;
    UINT i;

    for (i=0; i < count; i++)
        {
        *((USHORT UNALIGNED *)pw)++ = I32_IW(pjIoBase, PIX_TRANS);
        }

}

VOID vI32GetBits( PDEV *ppdev,
                  SURFOBJ *psoDst,
                  RECTL *prclDst,
                  POINTL *pptlSrc
                  )
{
    LONG    xPunt, yPunt,
            cxPunt, cyPunt, nwords;
    LONG    lDeltaDst = psoDst->lDelta;
    PBYTE   pjPunt, pjIoBase = ppdev->pjIoBase;
    PWORD   pw;
    WORD    Cmd;


    // pptlSrc gives the starting point on the screen.
    xPunt = pptlSrc->x;
    yPunt = pptlSrc->y;

    // prclDst gives the region size.
    cxPunt = prclDst->right - prclDst->left;
    cyPunt = prclDst->bottom - prclDst->top;

    // Do not optimize for word alignment if prclDst points to beginning of scan.
    if ((prclDst->left) && (xPunt & 0x1))
        {
        xPunt--;
        cxPunt++;
        pjPunt = (PBYTE) psoDst->pvScan0 + (prclDst->top * lDeltaDst) + prclDst->left - 1;
        }
    else
        pjPunt = (PBYTE) psoDst->pvScan0 + (prclDst->top * lDeltaDst) + prclDst->left;

    // Make sure the cx is an even number of words.
    if (cxPunt & 0x1)
        {
        cxPunt++;
        }

     // Set the engine up for the copy.

     Cmd = READ | FG_COLOR_SRC_HOST | DATA_WIDTH | DATA_ORDER | DRAW;

     I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 7);

     I32_OW(pjIoBase, DP_CONFIG, Cmd );
     I32_OW(pjIoBase, WRT_MASK, 0xffff );
     I32_OW(pjIoBase, CUR_X, (SHORT) xPunt );
     I32_OW(pjIoBase, CUR_Y, (SHORT) yPunt );
     I32_OW(pjIoBase, DEST_X_START, (SHORT) xPunt );
     I32_OW(pjIoBase, DEST_X_END, (SHORT) (xPunt + cxPunt) );
     I32_OW(pjIoBase, DEST_Y_END, (SHORT) (yPunt + cyPunt) );

    // Wait for the Data Available.

    while (!(I32_IW(pjIoBase, GE_STAT) & 0x100));

    // Now transfer the data from the screen to the host memory bitmap.

    pw = (PWORD) pjPunt;

    nwords = (cxPunt + 1)/2;

    while (cyPunt-- > 0)
        {
        vI32DataPortIn(ppdev, pw, nwords);
        ((PBYTE) pw) += lDeltaDst;
        }
}

VOID vI32DataPortOut(PDEV *ppdev, WORD *pw, UINT count)
{
    BYTE *pjIoBase = ppdev->pjIoBase;
    UINT i;

    for (i=0; i < count; i++)
        {
        if (i % 8 == 0)
            I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 10);

        I32_OW(pjIoBase, PIX_TRANS, *((USHORT UNALIGNED *)pw)++);
        }
}

VOID vI32PutBits( PDEV *ppdev,
                  SURFOBJ *psoSrc,
                  RECTL *prclDst,
                  POINTL *pptlSrc
                  )
{
    BOOL    leftScissor = FALSE, rightScissor = FALSE;
    LONG    xPunt, yPunt,
            cxPunt, cyPunt, nwords;
    LONG    lDeltaSrc = psoSrc->lDelta;
    PBYTE   pjPunt, pjIoBase = ppdev->pjIoBase;
    PWORD   pw;
    WORD    Cmd;


    // prclDst gives the starting point on the screen.
    xPunt = prclDst->left;
    yPunt = prclDst->top;

    // prclDst gives the region size.
    cxPunt = min( prclDst->right, (LONG) ppdev->cxMemory ) - xPunt;
    cyPunt = prclDst->bottom - yPunt;

    // Do not optimize for word alignment if pptlSrc points to beginning of scan.
    if ((pptlSrc->x) && (xPunt & 0x1))
        {
        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 1);
        I32_OW(pjIoBase, EXT_SCISSOR_L, (SHORT) xPunt );
        xPunt--;
        cxPunt++;
        leftScissor = TRUE;
        pjPunt = (PBYTE) psoSrc->pvScan0 + (pptlSrc->y * lDeltaSrc) + pptlSrc->x - 1;
        }
    else
        pjPunt = (PBYTE) psoSrc->pvScan0 + (pptlSrc->y * lDeltaSrc) + pptlSrc->x;

    // Make sure the cx is an even number of words.
    if (cxPunt & 0x1)
        {
        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 1);
        I32_OW(pjIoBase, EXT_SCISSOR_R, (SHORT) (xPunt + cxPunt - 1) );
        cxPunt++;
        rightScissor = TRUE;
        }

    // Set the engine up for the copy.

    Cmd = FG_COLOR_SRC_HOST | DATA_ORDER | DATA_WIDTH | DRAW | WRITE;

    I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 9);

    I32_OW(pjIoBase, DP_CONFIG, Cmd );
    I32_OW(pjIoBase, WRT_MASK, 0xffff );
    I32_OW(pjIoBase, ALU_FG_FN, OVERPAINT );
    I32_OW(pjIoBase, ALU_BG_FN, OVERPAINT );

    I32_OW(pjIoBase, CUR_X, (SHORT) xPunt );
    I32_OW(pjIoBase, CUR_Y, (SHORT) yPunt );
    I32_OW(pjIoBase, DEST_X_START, (SHORT) xPunt );
    I32_OW(pjIoBase, DEST_X_END, (SHORT) (xPunt + cxPunt) );
    I32_OW(pjIoBase, DEST_Y_END, (SHORT) (yPunt + cyPunt) );

    // Now transfer the data, from the host memory bitmap to the screen.

    pw = (PWORD) pjPunt;

    nwords = (cxPunt + 1)/2;

    while (cyPunt-- > 0)
        {
        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 1);
        vI32DataPortOut(ppdev, pw, nwords);
        ((PBYTE) pw) += lDeltaSrc;
        }

    if (leftScissor)
        {
        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 1);
        I32_OW(pjIoBase, EXT_SCISSOR_L, 0 );
        }
    if (rightScissor)
        {
        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 1);
        I32_OW(pjIoBase, EXT_SCISSOR_R, (SHORT) M32_MAX_SCISSOR );
        }
}

////////////////////////////////////////////////////////////////////////////////
// Context Stuff
//

#define _bit(x)                 (1 << (x))
#define CONTEXT_ADDR(ppdev,p)   (ppdev->pjContextBase - (((p)+1) * 0x100))

#define cxtCONTEXT_MASK         0

#define cxtDST_OFF_PITCH        2
#define cxtDST_Y_X              3
#define cxtDST_HEIGHT_WIDTH     4
#define cxtDST_BRES_ERR         5
#define cxtDST_BRES_INC         6
#define cxtDST_BRES_DEC         7

#define cxtSRC_OFF_PITCH        8
#define cxtSRC_Y_X              9
#define cxtSRC_HEIGHT1_WIDTH1   10
#define cxtSRC_Y_X_START        11
#define cxtSRC_HEIGHT2_WIDTH2   12
#define cxtPAT_REG0             13
#define cxtPAT_REG1             14
#define cxtSC_LEFT_RIGHT        15

#define cxtSC_TOP_BOTTOM        16
#define cxtDP_BKGD_CLR          17
#define cxtDP_FRGD_CLR          18
#define cxtDP_WRITE_MASK        19
#define cxtDP_CHAIN_MASK        20
#define cxtDP_PIX_WIDTH         21
#define cxtDP_MIX               22
#define cxtDP_SRC               23

#define cxtCLR_CMP_CLR          24
#define cxtCLR_CMP_MASK         25
#define cxtCLR_CMP_CNTL         26
#define cxtGUI_TRAJ_CNTL        27
#define cxtCONTEXT_LOAD_CNTL    28


BYTE *ContextBaseAddress(PDEV *ppdev)
{
    ULONG context_addr = 0;
    DWORD mem_cntl;

    mem_cntl = M64_ID(ppdev->pjMmBase, M64_MEM_CNTL);

    switch (mem_cntl & 7)
        {
        case 0:
            context_addr = 0x80000;     // 512 K
            break;
        case 1:
            context_addr = 0x100000;    // 1 M
            break;
        case 2:
            context_addr = 0x200000;
            break;
        case 3:
            context_addr = 0x400000;
            break;
        case 4:
            context_addr = 0x600000;
            break;
        case 5:
            context_addr = 0x800000;
            break;
        }
    return (BYTE *) context_addr;
}

VOID SetContextWorkspace( PDEV *ppdev, DWORD *context_regs,
                  DWORD context_mask, DWORD context_load_cntl )
{
    BYTE* pjMmBase = ppdev->pjMmBase;
    INT i;

    for (i = 0; i < 64; i++)
        context_regs[i] = 0;

    context_regs[ 0] = context_mask;
    if (context_mask & 0x00000004)
        *(context_regs+ 2) = M64_ID(pjMmBase, DST_OFF_PITCH);
    if (context_mask & 0x00000008)
        *(context_regs+ 3) = M64_ID(pjMmBase, DST_Y_X);
    if (context_mask & 0x00000010)
        *(context_regs+ 4) = M64_ID(pjMmBase, DST_HEIGHT_WIDTH);
    if (context_mask & 0x00000020)
        *(context_regs+ 5) = M64_ID(pjMmBase, DST_BRES_ERR);
    if (context_mask & 0x00000040)
        *(context_regs+ 6) = M64_ID(pjMmBase, DST_BRES_INC);
    if (context_mask & 0x00000080)
        *(context_regs+ 7) = M64_ID(pjMmBase, DST_BRES_DEC);
    if (context_mask & 0x00000100)
        *(context_regs+ 8) = M64_ID(pjMmBase, SRC_OFF_PITCH);
    if (context_mask & 0x00000200)
        *(context_regs+ 9) = M64_ID(pjMmBase, SRC_Y_X);
    if (context_mask & 0x00000400)
        *(context_regs+10) = M64_ID(pjMmBase, SRC_HEIGHT1_WIDTH1);
    if (context_mask & 0x00000800)
        *(context_regs+11) = M64_ID(pjMmBase, SRC_Y_X_START);
    if (context_mask & 0x00001000)
        *(context_regs+12) = M64_ID(pjMmBase, SRC_HEIGHT2_WIDTH2);
    if (context_mask & 0x00002000)
        *(context_regs+13) = M64_ID(pjMmBase, PAT_REG0);
    if (context_mask & 0x00004000)
        *(context_regs+14) = M64_ID(pjMmBase, PAT_REG1);
    if (context_mask & 0x00008000)
        *(context_regs+15) = M64_ID(pjMmBase, SC_LEFT_RIGHT);
    if (context_mask & 0x00010000)
        *(context_regs+16) = M64_ID(pjMmBase, SC_TOP_BOTTOM);
    if (context_mask & 0x00020000)
        *(context_regs+17) = M64_ID(pjMmBase, DP_BKGD_CLR);
    if (context_mask & 0x00040000)
        *(context_regs+18) = M64_ID(pjMmBase, DP_FRGD_CLR);
    if (context_mask & 0x00080000)
        *(context_regs+19) = M64_ID(pjMmBase, DP_WRITE_MASK);
    if (context_mask & 0x00100000)
        *(context_regs+20) = M64_ID(pjMmBase, DP_CHAIN_MASK);
    if (context_mask & 0x00200000)
        *(context_regs+21) = M64_ID(pjMmBase, DP_PIX_WIDTH);
    if (context_mask & 0x00400000)
        *(context_regs+22) = M64_ID(pjMmBase, DP_MIX);
    if (context_mask & 0x00800000)
        *(context_regs+23) = M64_ID(pjMmBase, DP_SRC);
    if (context_mask & 0x01000000)
        *(context_regs+24) = M64_ID(pjMmBase, CLR_CMP_CLR);
    if (context_mask & 0x02000000)
        *(context_regs+25) = M64_ID(pjMmBase, CLR_CMP_MSK);
    if (context_mask & 0x04000000)
        *(context_regs+26) = M64_ID(pjMmBase, CLR_CMP_CNTL);
    if (context_mask & 0x08000000)
        *(context_regs+27) = M64_ID(pjMmBase, GUI_TRAJ_CNTL);
    context_regs[28] = context_load_cntl;

}

VOID UploadContext( PDEV *ppdev, DWORD *context_regs, BYTE *context_addr )
{
    BYTE* pjMmBase = ppdev->pjMmBase;

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 10);
    M64_OD(pjMmBase,  CLR_CMP_CNTL, 0 );
    M64_OD(pjMmBase,  SC_LEFT_RIGHT, (255) << 16 );
    M64_OD(pjMmBase,  SC_TOP_BOTTOM, 0 );
    M64_OD(pjMmBase,  DP_SRC, DP_SRC_Host << 8 );
    M64_OD(pjMmBase,  DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir );
    M64_OD(pjMmBase,  DP_MIX, OVERPAINT << 16 );
    M64_OD(pjMmBase,  DP_PIX_WIDTH, DP_PIX_WIDTH_8bpp | (DP_PIX_WIDTH_8bpp << 16) );
    M64_OD(pjMmBase,  DST_OFF_PITCH,
            (ULONG)((ULONG_PTR) context_addr/8 | (256 << 19) ));
    M64_OD(pjMmBase,  DST_Y_X, 0 );
    M64_OD(pjMmBase,  DST_HEIGHT_WIDTH, 0x01000001 );     // 256x1

    vM64DataPortOutB(ppdev, (BYTE *)context_regs, 256);

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 4);
    M64_OD(pjMmBase,  DST_OFF_PITCH, ppdev->ulScreenOffsetAndPitch );
    M64_OD(pjMmBase,  DP_PIX_WIDTH,  ppdev->ulMonoPixelWidth );
    M64_OD(pjMmBase,  SC_LEFT_RIGHT, M64_MAX_SCISSOR_R << 16 );
    M64_OD(pjMmBase,  SC_TOP_BOTTOM, ppdev->cyMemory << 16 );
}

VOID vSetDefaultContext(PDEV * ppdev)
{
    DWORD work_context [64];

    SetContextWorkspace( ppdev, work_context,
                _bit(cxtCONTEXT_MASK) |
                _bit(cxtDP_WRITE_MASK) |
                _bit(cxtCLR_CMP_CNTL) |
                _bit(cxtGUI_TRAJ_CNTL),
                0);
    // Fix vanishing text and fills, as well as other color problems:
    work_context[cxtDP_WRITE_MASK] = 0xFFFFFFFF;
    work_context[cxtCLR_CMP_CNTL]  = 0;
    // Fix frizzy text and RGB ordering problems:
    work_context[cxtGUI_TRAJ_CNTL] = DST_CNTL_XDir | DST_CNTL_YDir;
    UploadContext( ppdev, work_context, CONTEXT_ADDR(ppdev,ppdev->iDefContext) );
}

VOID vEnableContexts(PDEV * ppdev)
{
    ppdev->pjContextBase = ContextBaseAddress(ppdev);
    if (ppdev->cjBank == (LONG)((ULONG_PTR)ppdev->pjContextBase))
        ppdev->ulContextCeiling =(ULONG)((ULONG_PTR)ppdev->pjContextBase - 1024);
    else
        ppdev->ulContextCeiling = (ULONG)((ULONG_PTR) ppdev->pjContextBase);

    // Compute ALL context pointers needed in the driver.
    ppdev->iDefContext = (ULONG)((ULONG_PTR)ppdev->pjContextBase
                               - (ULONG_PTR)ppdev->ulContextCeiling)/256;
    ppdev->ulContextCeiling -= 256;

    // In general, you need to check whether a context allocation will decrease
    // cyMemory.  Here, we only have the one and FIRST allocation, so decrement cyMemory.
    ppdev->cyMemory--;
}

////////////////////////////////////////////////////////////////////////////////
// DataPortOutB routine for the mach64
//

VOID vM64DataPortOutB(PDEV *ppdev, PBYTE pb, UINT count)
{
    PBYTE pjMmBase = ppdev->pjMmBase;
    UINT i, DWLeft, LastBytes;
    DWORD UNALIGNED *pdw;
    PBYTE Byte_in_Dword;
    DWORD Buffer;

#define THRESH 14

    pdw = (DWORD*)pb;
    DWLeft = (count + 3)/4;
    LastBytes =  count % 4;

    while ( DWLeft > 0 )
    {
        if (DWLeft < THRESH || (DWLeft == THRESH && LastBytes != 0))
        {
            M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, DWLeft);

            if (LastBytes > 0)
            {
                for (i=0; i< DWLeft-1 ; i++)
                    M64_OD(pjMmBase, HOST_DATA0, *(pdw+i));

                Byte_in_Dword = (PBYTE) (pdw+i);
                Buffer = 0;
                for (i=0; i < LastBytes; i++)
                {
                    Buffer |= (*Byte_in_Dword) << (i*8);
                    Byte_in_Dword++;
                }

                M64_OD(pjMmBase, HOST_DATA0, Buffer);
            }
            else
            {
                for (i=0; i< DWLeft ; i++)
                    M64_OD(pjMmBase, HOST_DATA0, *(pdw+i));
            }

            pdw += DWLeft;
            DWLeft = 0;
        }
        else
        {
            M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);

            /* Inline coded for greater performance */

            M64_OD(pjMmBase, HOST_DATA0, *(pdw));       // 1 Word
            M64_OD(pjMmBase, HOST_DATA0, *(pdw+1));     // 2 Words
            M64_OD(pjMmBase, HOST_DATA0, *(pdw+2));     // 3 Words
            M64_OD(pjMmBase, HOST_DATA0, *(pdw+3));     // 4 Words
            M64_OD(pjMmBase, HOST_DATA0, *(pdw+4));     // 5 Words
            M64_OD(pjMmBase, HOST_DATA0, *(pdw+5));     // 6 Words
            M64_OD(pjMmBase, HOST_DATA0, *(pdw+6));     // 7 Words
            M64_OD(pjMmBase, HOST_DATA0, *(pdw+7));     // 8 Words
            M64_OD(pjMmBase, HOST_DATA0, *(pdw+8));     // 9 Words
            M64_OD(pjMmBase, HOST_DATA0, *(pdw+9));     // 10 Words
            M64_OD(pjMmBase, HOST_DATA0, *(pdw+10));    // 11 Words
            M64_OD(pjMmBase, HOST_DATA0, *(pdw+11));    // 12 Words
            M64_OD(pjMmBase, HOST_DATA0, *(pdw+12));    // 13 Words
            M64_OD(pjMmBase, HOST_DATA0, *(pdw+13));    // 14 Words

            pdw += 14;
            DWLeft -= THRESH;
        } /*if*/
    } /* while */

#undef THRESH

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\multi.c ===
/******************************Module*Header*******************************\
* Module Name: multi.c
*
* Supports multiple display boards as a single virtual desktop.
*
* This is implemented by presenting to GDI a single large virtual
* display and adding a layer between GDI and the driver's Drv functions.
* For the most part, the rest of the driver outside of multi.c doesn't
* have to change much, subject to the requirements below.
*
* This implementation requires that each board have the same virtual
* resolution and colour depth (e.g., all be running 1024x768x256), and
* that the boards be arranged in a rectangular configuration.
*
* Each board has its own PDEV, and completely manages its surface
* independently, down to glyph and bitmap caching.  The Mul
* routine intercepts the DDI call, and for each board dispatches
* a Drv call with the appropriate PDEV and clip object modifications.
*
* The following support in the main driver is required:
*
* 1) The driver should be able to handle a per-surface offset.  For
*    example, if two 1024x768 displays are pasted side-by-side, the
*    right board will get drawing operations in the range (1024, 768) -
*    (2048, 768).  The driver has a (-1024, 0) surface offset to convert
*    the actual drawing on the right board to the expected (0, 0) -
*    (1024, 768).
*
*    The current driver already uses this notion to support device-format
*    bitmaps drawn in off-screen memory.
*
*    Another option would be to handle the surface offsets in this layer,
*    but then all parameters including clip objects, paths and glyph
*    enumerations would have to be adjusted here as well.
*
* 2) The main driver must be able to share realized pattern information
*    between board instances.  That is, with the current DDI specification
*    GDI entirely handles brush memory allocation via pvAllocRBrush,
*    and the driver doesn't get notified when the brush is destroyed, so
*    the driver has to keep all information about the brush for all the
*    boards in the one brush realization.  This isn't too onerous.
*
* Problems:
*
* 1) DrvSetPointerShape requires that support be consistent between all
*    board instances -- for example, one board instance cannot accept
*    a h/w cursor and the other fail it, because GDI doesn't know it would
*    have to simulate on one area of the screen and not the other.
*
* 2) CompatibleBitmaps would have to be shared between board instances.
*    This becomes a problem when the bitmaps are kept by the driver in off-
*    screen memory.
*
* Status:
*
*    This code is officially untested.  However, I know of no outstanding
*    bugs -- everything seems to just work.
*
*    Note that I haven't addressed any initialization issues; to adapt this
*    code, you will need to solve some of those problems (such as proper
*    miniport support, and a nice method for the user to control the board
*    configurations and geometry).
*
* Disclaimer:
*
*    This code is provided as sample code only.  It is not intended to
*    represent Microsoft's endorsed solution for multiple screen support.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#if MULTI_BOARDS

// We change the active board to the home board after every drawing
// operation.  We do this only because the Metheus BIOS does not reset
// the active board on a soft-reset, and so the initial POST text
// would come up on whatever happened to be the last board drawn to.

#define GO_HOME(pmdev)       vSelectBoard(pmdev, pmdev->pmbHome)
#define GO_BOARD(pmdev, pmb) vSelectBoard(pmdev, pmb)

struct _MULTI_BOARD;

typedef struct _MULTI_BOARD MULTI_BOARD;    /* mb */

struct _MULTI_BOARD
{
    LONG            iHwBoard;       // Hardware board number
    LONG            iBoard;         // Sequentially allocated board number
    RECTL           rcl;            // Board's coordinates
    MULTI_BOARD*    pmbNext;        // For traversing the entire list of boards
    MULTI_BOARD*    pmbLeft;        // For traversing by direction
    MULTI_BOARD*    pmbUp;
    MULTI_BOARD*    pmbRight;
    MULTI_BOARD*    pmbDown;

    PDEV*           ppdev;          // Pointer to the board's PDEV
    SURFOBJ*        pso;            // Surface representing the board
    HSURF           hsurf;          // Handle to surface
};                                          /* mb, pmb */

typedef struct _MDEV
{
    MULTI_BOARD*    pmb;            // Where to start enumerating
    MULTI_BOARD*    pmbHome;        // Board used for full-screen
    MULTI_BOARD*    pmbUpperLeft;   // Board in upper-left corner
    MULTI_BOARD*    pmbUpperRight;
    MULTI_BOARD*    pmbLowerLeft;
    MULTI_BOARD*    pmbLowerRight;
    LONG            cxBoards;       // Number of boards per row
    LONG            cyBoards;       // Number of boards per column
    LONG            cBoards;        // Total number of boards

    MULTI_BOARD*    pmbPointer;     // Board where cursor is currently visible
    MULTI_BOARD*    pmbCurrent;     // Currently selected board (needed for
                                    //   DrvRealizeBrush)
    HDEV            hdev;           // Handle that GDI knows us by
    HSURF           hsurf;          // Handle to our virtual surface
    CLIPOBJ*        pco;            // A temporary CLIPOBJ that we can modify
    ULONG           iBitmapFormat;  // Current colour depth
    FLONG           flHooks;        // Those functions that the main driver
                                    //   is hooking

} MDEV;                                     /* mdev, pmdev */

typedef struct _PVCONSUMER
{
    PVOID       pvConsumer;
} PVCONSUMER;

typedef struct _FONT_CONSUMER
{
    LONG        cConsumers;         // Total number of boards
    PVCONSUMER  apvc[MAX_BOARDS];   // Array of structures cConsumers in length
} FONT_CONSUMER;                            /* fc, pfc */

typedef struct _BITBLTDATA
{
    RECTL       rclBounds;
    MDEV*       pmdev;

    SURFOBJ*    psoDst;
    SURFOBJ*    psoSrc;
    SURFOBJ*    psoMask;
    CLIPOBJ*    pco;
    XLATEOBJ*   pxlo;
    RECTL*      prclDst;
    POINTL*     pptlSrc;
    POINTL*     pptlMask;
    BRUSHOBJ*   pbo;
    POINTL*     pptlBrush;
    ROP4        rop4;
} BITBLTDATA;                               /* bb, pbb */

/******************************Public*Routine******************************\
* bFindBoard
*
* Returns in ppmb a pointer to the board containing the upper-left
* corner of prcl.
*
* Returns TRUE if prcl is entirely containing on one board; FALSE if
* prcl spans multiple boards.
*
\**************************************************************************/

BOOL bFindBoard(MDEV* pmdev, RECTL* prcl, MULTI_BOARD** ppmb)
{
    MULTI_BOARD* pmb;

    pmb = pmdev->pmbUpperLeft;

    // It should never happen that GDI will give us a call whose bounds
    // don't intersect the virtual screen.  But so that we don't crash
    // should it ever happen, we'll return an intersection with the first
    // board -- we can assume GDI at least said the clipping was non-
    // trivial, in which case that board's display routine will realize
    // nothing had to be done:

    *ppmb = pmb;

    // First find the row:

    while (prcl->top >= pmb->rcl.bottom)
    {
        pmb = pmb->pmbDown;
        if (pmb == NULL)
            return(FALSE);      // This is a case where the bounds doesn't
                                //  intercept the virtual screen
    }

    // Now find the column:

    while (prcl->left >= pmb->rcl.right)
    {
        pmb = pmb->pmbRight;
        if (pmb == NULL)
            return(FALSE);      // This is a case where the bounds doesn't
                                //  intercept the virtual screen
    }

    // So we found the first board:

    *ppmb = pmb;

    return(prcl->right  <= pmb->rcl.right &&
           prcl->bottom <= pmb->rcl.bottom);
}

/******************************Public*Routine******************************\
* bNextBoard
*
* Returns in ppmb a pointer to the next board after intersecting prcl, going
* left-to-right then top-to-bottom.
*
* Returns TRUE if all boards intersecting prcl have been enumerated; FALSE
* if there are more boards.
*
\**************************************************************************/

BOOL bNextBoard(RECTL* prcl, MULTI_BOARD** ppmb)
{
    MULTI_BOARD* pmb;

    pmb = *ppmb;

    // We'll do all the boards in a row first, remembering that the
    // bounds rectangle can extend past the end of our virtual screen:

    if ((prcl->right > pmb->rcl.right) && (pmb->pmbRight != NULL))
    {
        *ppmb = pmb->pmbRight;
        return(TRUE);
    }

    // Go to next row if need be, starting at the rcl.left:

    if ((prcl->bottom > pmb->rcl.bottom) && (pmb->pmbDown != NULL))
    {
        pmb = pmb->pmbDown;
        while ((prcl->left < pmb->rcl.left) && (pmb->pmbLeft != NULL))
        {
            pmb = pmb->pmbLeft;
        }
        *ppmb = pmb;
        return(TRUE);
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* vIntersect
*
* Returns in prclOut the intersection of rectangles prcl1 and prcl2.
*
\**************************************************************************/

VOID vIntersect(RECTL* prcl1, RECTL* prcl2, RECTL* prclOut)
{
    prclOut->left   = max(prcl1->left,   prcl2->left);
    prclOut->top    = max(prcl1->top,    prcl2->top);
    prclOut->right  = min(prcl1->right,  prcl2->right);
    prclOut->bottom = min(prcl1->bottom, prcl2->bottom);
}

/******************************Public*Routine******************************\
* bVeryTemporaryInitializationCode
*
\**************************************************************************/

BOOL bVeryTemporaryInitializationCode(MDEV* pmdev)
{
    MULTI_BOARD* pmb1 = NULL;
    MULTI_BOARD* pmb2 = NULL;

    pmb1 = AtiAllocMem(LPTR, FL_ZERO_MEMORY, sizeof(MULTI_BOARD));
    pmb2 = AtiAllocMem(LPTR, FL_ZERO_MEMORY, sizeof(MULTI_BOARD));

    if ((pmb1 == NULL) || (pmb2 == NULL))
    {
        AtiFreeMem(pmb1);
        AtiFreeMem(pmb2);
        return(FALSE);
    }

    // Only this initialization part is hard-coded to have two monitors,
    // side-by-side.

    // Board one:

    pmb1->iHwBoard         = 0;
    pmb1->iBoard           = 0;
    pmb1->pmbNext          = pmb2;
    pmb1->pmbRight         = pmb2;

    pmdev->pmb             = pmb1;
    pmdev->pmbUpperLeft    = pmb1;
    pmdev->pmbLowerLeft    = pmb1;
    pmdev->pmbHome         = pmb1;

    // Board two:

    pmb2->iHwBoard         = 1;
    pmb2->iBoard           = 1;
    pmb2->pmbLeft          = pmb1;

    pmdev->pmbUpperRight   = pmb2;
    pmdev->pmbLowerRight   = pmb2;

    pmdev->cxBoards        = 2;
    pmdev->cyBoards        = 1;
    pmdev->cBoards         = 2;

    // Assume that the currently active board is the 'home' board:

    pmdev->pmbCurrent      = pmdev->pmbHome;

    return(TRUE);
}

/******************************Public*Routine******************************\
* vSelectBoard
*
* Selects board pmb for drawing.  We can have only one Metheus board active
* at any time, so we have to disable the old board before enabling the new.
*
* Obviously, your hardware implementation may not require this entire
* function.  For example, you probably won't have to do this if you can
* have each board's accelerator registers mapped into separate address
* spaces.  NOTE: You'll still have to set pmdev->pmbCurrent, however,
* for DrvRealizeBrush to work!
*
\**************************************************************************/

VOID vSelectBoard(MDEV* pmdev, MULTI_BOARD* pmb)
{
    LONG iOldHwBoard;

    ASSERTDD(pmdev->pmbCurrent != NULL, "Can't have NULL pmbCurrent");

    // LATER: Expand this to handle more than 8 Metheus boards.

    iOldHwBoard = pmdev->pmbCurrent->iHwBoard;
    if (pmb->iHwBoard != iOldHwBoard)
    {
        OUTP(ppdev->pjIoBase, 0x220, iOldHwBoard);           // Disable old board
        OUTP(ppdev->pjIoBase, 0x220, (8 | pmb->iHwBoard));   // Enable new one
        pmdev->pmbCurrent = pmb;                             // Remember new board
    }

}

/******************************Public*Routine******************************\
* bBoardCopy
*
* Given the BitBlt parameters in pbb, bitblt's the part of the rectangle
* on the pmbSrc board that must bitblt'ed to the pmbDst board.  Bails
* out quickly if nothing actually has to be copied.
*
* Will do a screen-to-screen blt if pmbSrc and pmbDst are the same board;
* otherwise it uses the psoTmp bitmap as temporary storage for transferring
* between the two boards.
*
* NOTE: If your hardware allows you to have all the frame buffers mapped
*       into memory simultaneously, you can avoid the 'psoTmp' bitmap
*       allocation and extra copy!
*
\**************************************************************************/

BOOL bBoardCopy(
BITBLTDATA*  pbb,
SURFOBJ*     psoTmp,
MULTI_BOARD* pmbDst,
MULTI_BOARD* pmbSrc)
{
    BOOL     b;
    RECTL    rclDst;
    LONG     dx;
    LONG     dy;
    RECTL    rclTmp;
    POINTL   ptlSrc;

    // If there's really no source board, we're guaranteed not to
    // have to copy anything from it:

    if (pmbSrc == NULL)
        return(TRUE);

    dx = pbb->prclDst->left - pbb->pptlSrc->x;
    dy = pbb->prclDst->top  - pbb->pptlSrc->y;

    // Pretend we're going to copy the entire source board's screen.
    // rclDst would be the destination rectangle:

    rclDst.left   = pmbSrc->rcl.left   + dx;
    rclDst.right  = pmbSrc->rcl.right  + dx;
    rclDst.top    = pmbSrc->rcl.top    + dy;
    rclDst.bottom = pmbSrc->rcl.bottom + dy;

    // We really want to copy only the part that overlaps the
    // destination board's screen:

    vIntersect(&pmbDst->rcl, &rclDst, &rclDst);

    // Plus we really only want to copy anything to what is contained
    // in the original destination rectangle:

    vIntersect(&pbb->rclBounds, &rclDst, &rclDst);

    // rclDst is now the destination rectangle for our call.  We'll
    // need a temporary bitmap for copying, so compute its extents:

    rclTmp.left   = 0;
    rclTmp.top    = 0;
    rclTmp.right  = rclDst.right  - rclDst.left;
    rclTmp.bottom = rclDst.bottom - rclDst.top;

    // If it's empty, we're outta here:

    if ((rclTmp.right <= 0) || (rclTmp.bottom <= 0))
        return(TRUE);

    if (pmbDst == pmbSrc)
    {
        // If the source and destination are the same board, we don't
        // need a temporary bitmap:

        psoTmp = pmbSrc->pso;
        ptlSrc = *pbb->pptlSrc;
    }
    else
    {
        ASSERTDD(psoTmp != NULL, "Need non-null bitmap");
        ASSERTDD(psoTmp->sizlBitmap.cx >= rclTmp.right, "Bitmap too small in x");
        ASSERTDD(psoTmp->sizlBitmap.cy >= rclTmp.bottom, "Bitmap too small in y");

        // Figure out the upper-left source corner corresponding to our
        // upper-left destination corner:

        ptlSrc.x = rclDst.left - dx;
        ptlSrc.y = rclDst.top  - dy;

        // Copy the rectangle from the source to the temporary bitmap:

        GO_BOARD(pbb->pmdev, pmbSrc);
        b = DrvCopyBits(psoTmp, pmbSrc->pso, NULL, NULL, &rclTmp, &ptlSrc);

        // Then get ready to do the copy from the temporary bitmap to
        // the destination:

        ptlSrc.x = pbb->prclDst->left - rclDst.left;
        ptlSrc.y = pbb->prclDst->top  - rclDst.top;
    }

    pbb->pco->rclBounds = rclDst;
    GO_BOARD(pbb->pmdev, pmbDst);
    b &= DrvBitBlt(pmbDst->pso, psoTmp, pbb->psoMask, pbb->pco, pbb->pxlo,
                   pbb->prclDst, &ptlSrc, pbb->pptlMask, pbb->pbo,
                   pbb->pptlBrush, pbb->rop4);

    return(b);
}

/******************************Public*Routine******************************\
* bBitBltBetweenBoards
*
* Handles screen-to-screen blts across multiple boards.
*
\**************************************************************************/

BOOL bBitBltBetweenBoards(
SURFOBJ*     psoDst,
SURFOBJ*     psoSrc,
SURFOBJ*     psoMask,
CLIPOBJ*     pco,
XLATEOBJ*    pxlo,
RECTL*       prclDst,
POINTL*      pptlSrc,
POINTL*      pptlMask,
BRUSHOBJ*    pbo,
POINTL*      pptlBrush,
ROP4         rop4,
RECTL*       prclUnion,     // Rectangular union of source and destination
MULTI_BOARD* pmbUnion)      // Board containing upper-left corner of prclUnion
{
    BOOL         b = TRUE;
    BITBLTDATA   bb;
    RECTL        rclOriginalBounds;
    SIZEL        sizlBoard;
    SIZEL        sizlDst;
    SIZEL        sizl;
    MULTI_BOARD* pmbSrc;
    MULTI_BOARD* pmbDst;
    LONG         dx;
    LONG         dy;
    RECTL        rclStart;

    SURFOBJ*     pso0 = NULL;   // Initialize these first off in case we
    SURFOBJ*     pso1 = NULL;   //   early-out
    SURFOBJ*     pso2 = NULL;
    SURFOBJ*     pso3 = NULL;
    HSURF        hsurf0 = 0;
    HSURF        hsurf1 = 0;

    bb.pmdev     = (MDEV*) psoDst->dhpdev;
    bb.psoDst    = psoDst;
    bb.psoSrc    = psoSrc;
    bb.psoMask   = psoMask;
    bb.pxlo      = pxlo;
    bb.prclDst   = prclDst;
    bb.pptlSrc   = pptlSrc;
    bb.pptlMask  = pptlMask;
    bb.pbo       = pbo;
    bb.pptlBrush = pptlBrush;
    bb.rop4      = rop4;
    bb.pco       = pco;
    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
        bb.pco = bb.pmdev->pco;

    vIntersect(&bb.pco->rclBounds, prclDst, &bb.rclBounds);
    rclOriginalBounds = bb.pco->rclBounds;

    sizlDst.cx = bb.rclBounds.right - bb.rclBounds.left;
    sizlDst.cy = bb.rclBounds.bottom - bb.rclBounds.top;

    // This really should never happen, but we'll be paranoid:

    if ((sizlDst.cx <= 0) || (sizlDst.cy <= 0))
        return(TRUE);

    // Compute delta from source to destination:

    dx = prclDst->left - pptlSrc->x;
    dy = prclDst->top  - pptlSrc->y;

    // Figure out the size of a board:

    sizlBoard.cx = bb.pmdev->pmbUpperLeft->rcl.right;
    sizlBoard.cy = bb.pmdev->pmbUpperLeft->rcl.bottom;

    // We use temporary bitmaps as intermediaries for copying from one
    // board to another.  Note that it is much more efficient to allocate
    // on the fly, rather than keeping a dedicated bitmap around that
    // would have to be swapped in and out.

    // When the destination is close to the source, we can accomplish
    // most of the blt using screen-to-screen copies, and will need
    // only two small temporary bitmaps to temporarily hold the bits
    // that must be transferred from one board to another:

    if ((abs(dx) < (sizlBoard.cx >> 1)) && (abs(dy) < (sizlBoard.cy >> 1)))
    {
        // Create a temporary bitmap for the horizontal delta only if
        // the blt actually spans boards in the x-direction:

        if ((dx != 0) && (prclUnion->right > pmbUnion->rcl.right))
        {
            sizl.cx = min(sizlDst.cx, abs(dx));
            sizl.cy = min(sizlDst.cy, sizlBoard.cy - abs(dy));

            hsurf0 = (HSURF) EngCreateBitmap(sizl, 0, bb.pmdev->iBitmapFormat,
                                             0, NULL);
            pso1 = EngLockSurface(hsurf0);
            if (pso1 == NULL)
                return(FALSE);

            // Can use same temporary bitmap for section '3':

            pso3 = pso1;
        }

        // Similarly for the vertical delta:

        if ((dy != 0) && (prclUnion->bottom > pmbUnion->rcl.bottom))
        {
            sizl.cx = min(sizlDst.cx, sizlBoard.cx - abs(dx));
            sizl.cy = min(sizlDst.cy, abs(dy));

            hsurf1 = (HSURF) EngCreateBitmap(sizl, 0, bb.pmdev->iBitmapFormat,
                                             0, NULL);
            pso2 = EngLockSurface(hsurf1);
            if (pso2 == NULL)
            {
                b = FALSE;
                goto OuttaHere;
            }
        }
    }
    else
    {
        // Make the bitmap the size of a board, or the size of the
        // destination rectangle, which ever is smaller:

        sizl.cx = min(sizlDst.cx, sizlBoard.cx);
        sizl.cy = min(sizlDst.cy, sizlBoard.cy);

        hsurf0 = (HSURF) EngCreateBitmap(sizl, 0, bb.pmdev->iBitmapFormat,
                                         0, NULL);
        pso0 = EngLockSurface(hsurf0);
        if (pso0 == NULL)
            return(FALSE);

        pso1 = pso0;
        pso2 = pso0;
        pso3 = pso0;
    }

    if ((dx <= 0) && (dy <= 0))
    {
        // Move the rectangle up and to the left:

        // Find the board containing the upper-left corner of the destination:

        pmbDst = bb.pmdev->pmbUpperLeft;
        while (pmbDst->rcl.right <= bb.rclBounds.left)
            pmbDst = pmbDst->pmbRight;
        while (pmbDst->rcl.bottom <= bb.rclBounds.top)
            pmbDst = pmbDst->pmbDown;

        // Find the upper-left of the four source boards' rectangles which
        // can potentially overlap our destination board's rectangle:

        rclStart.left = pmbDst->rcl.left - dx;
        rclStart.top  = pmbDst->rcl.top  - dy;

        pmbSrc = pmbDst;
        while (pmbSrc->rcl.right <= rclStart.left)
            pmbSrc = pmbSrc->pmbRight;
        while (pmbSrc->rcl.bottom <= rclStart.top)
            pmbSrc = pmbSrc->pmbDown;

        while (TRUE)
        {
            b &= bBoardCopy(&bb, pso0, pmbDst, pmbSrc);
            b &= bBoardCopy(&bb, pso1, pmbDst, pmbSrc->pmbRight);
            b &= bBoardCopy(&bb, pso2, pmbDst, pmbSrc->pmbDown);
            if (pmbSrc->pmbDown != NULL)
                b &= bBoardCopy(&bb, pso3, pmbDst, pmbSrc->pmbDown->pmbRight);

            if (pmbDst->rcl.right < bb.rclBounds.right)
            {
                // Move right in the row of boards:

                pmbDst = pmbDst->pmbRight;
                pmbSrc = pmbSrc->pmbRight;
            }
            else
            {
                // We may be all done:

                if (pmbDst->rcl.bottom >= bb.rclBounds.bottom)
                    break;

                // Nope, have to go down to left side of next lower row:

                while (pmbDst->rcl.left > bb.rclBounds.left)
                {
                    pmbDst = pmbDst->pmbLeft;
                    pmbSrc = pmbSrc->pmbLeft;
                }

                pmbDst = pmbDst->pmbDown;
                pmbSrc = pmbSrc->pmbDown;
            }
        }
    }
    else if ((dx >= 0) && (dy >= 0))
    {
        // Move the rectangle down and to the right:

        // Find the board containing the lower-right corner of the destination:

        pmbDst = bb.pmdev->pmbLowerRight;
        while (pmbDst->rcl.left >= bb.rclBounds.right)
            pmbDst = pmbDst->pmbLeft;
        while (pmbDst->rcl.top >= bb.rclBounds.bottom)
            pmbDst = pmbDst->pmbUp;

        // Find the lower-right of the four source boards' rectangles which
        // can potentially overlap our destination board's rectangle:

        rclStart.right = pmbDst->rcl.right - dx;
        rclStart.bottom = pmbDst->rcl.bottom - dy;

        pmbSrc = pmbDst;
        while (pmbSrc->rcl.left >= rclStart.right)
            pmbSrc = pmbSrc->pmbLeft;
        while (pmbSrc->rcl.top >= rclStart.bottom)
            pmbSrc = pmbSrc->pmbUp;

        while (TRUE)
        {
            b &= bBoardCopy(&bb, pso0, pmbDst, pmbSrc);
            b &= bBoardCopy(&bb, pso1, pmbDst, pmbSrc->pmbLeft);
            b &= bBoardCopy(&bb, pso2, pmbDst, pmbSrc->pmbUp);
            if (pmbSrc->pmbUp != NULL)
                b &= bBoardCopy(&bb, pso3, pmbDst, pmbSrc->pmbUp->pmbLeft);

            if (pmbDst->rcl.left > bb.rclBounds.left)
            {
                // Move left in the row of boards:

                pmbDst = pmbDst->pmbLeft;
                pmbSrc = pmbSrc->pmbLeft;
            }
            else
            {
                // We may be all done:

                if (pmbDst->rcl.top <= bb.rclBounds.top)
                    break;

                // Nope, have to go up to right side of next upper row:

                while (pmbDst->rcl.right < bb.rclBounds.right)
                {
                    pmbDst = pmbDst->pmbRight;
                    pmbSrc = pmbSrc->pmbRight;
                }

                pmbDst = pmbDst->pmbUp;
                pmbSrc = pmbSrc->pmbUp;
            }
        }
    }
    else if ((dx >= 0) && (dy <= 0))
    {
        // Move the rectangle up and to the right:

        // Find the board containing the upper-right corner of the destination:

        pmbDst = bb.pmdev->pmbUpperRight;
        while (pmbDst->rcl.left >= bb.rclBounds.right)
            pmbDst = pmbDst->pmbLeft;
        while (pmbDst->rcl.bottom <= bb.rclBounds.top)
            pmbDst = pmbDst->pmbDown;

        // Find the upper-right of the four source boards' rectangles which
        // can potentially overlap our destination board's rectangle:

        rclStart.right = pmbDst->rcl.right - dx;
        rclStart.top   = pmbDst->rcl.top   - dy;

        pmbSrc = pmbDst;
        while (pmbSrc->rcl.left >= rclStart.right)
            pmbSrc = pmbSrc->pmbLeft;
        while (pmbSrc->rcl.bottom <= rclStart.top)
            pmbSrc = pmbSrc->pmbDown;

        while (TRUE)
        {
            b &= bBoardCopy(&bb, pso0, pmbDst, pmbSrc);
            b &= bBoardCopy(&bb, pso1, pmbDst, pmbSrc->pmbLeft);
            b &= bBoardCopy(&bb, pso2, pmbDst, pmbSrc->pmbDown);
            if (pmbSrc->pmbDown != NULL)
                b &= bBoardCopy(&bb, pso3, pmbDst, pmbSrc->pmbDown->pmbLeft);

            if (pmbDst->rcl.left > bb.rclBounds.left)
            {
                // Move left in the row of boards:

                pmbDst = pmbDst->pmbLeft;
                pmbSrc = pmbSrc->pmbLeft;
            }
            else
            {
                // We may be all done:

                if (pmbDst->rcl.bottom >= bb.rclBounds.bottom)
                    break;

                // Nope, have to go down to right side of next lower row:

                while (pmbDst->rcl.right < bb.rclBounds.right)
                {
                    pmbDst = pmbDst->pmbRight;
                    pmbSrc = pmbSrc->pmbRight;
                }

                pmbDst = pmbDst->pmbDown;
                pmbSrc = pmbSrc->pmbDown;
            }
        }
    }
    else
    {
        // Move the rectangle down and to the left:

        // Find the board containing the lower-left corner of the destination:

        pmbDst = bb.pmdev->pmbLowerLeft;
        while (pmbDst->rcl.right <= bb.rclBounds.left)
            pmbDst = pmbDst->pmbRight;
        while (pmbDst->rcl.top >= bb.rclBounds.bottom)
            pmbDst = pmbDst->pmbUp;

        // Find the lower-left of the four source boards' rectangles which
        // can potentially overlap our destination board's rectangle:

        rclStart.left   = pmbDst->rcl.left   - dx;
        rclStart.bottom = pmbDst->rcl.bottom - dy;

        pmbSrc = pmbDst;
        while (pmbSrc->rcl.right <= rclStart.left)
            pmbSrc = pmbSrc->pmbRight;
        while (pmbSrc->rcl.top >= rclStart.bottom)
            pmbSrc = pmbSrc->pmbUp;

        while (TRUE)
        {
            b &= bBoardCopy(&bb, pso0, pmbDst, pmbSrc);
            b &= bBoardCopy(&bb, pso1, pmbDst, pmbSrc->pmbRight);
            b &= bBoardCopy(&bb, pso2, pmbDst, pmbSrc->pmbUp);
            if (pmbSrc->pmbUp != NULL)
                b &= bBoardCopy(&bb, pso3, pmbDst, pmbSrc->pmbUp->pmbRight);

            if (pmbDst->rcl.right < bb.rclBounds.right)
            {
                // Move right in the row of boards:

                pmbDst = pmbDst->pmbRight;
                pmbSrc = pmbSrc->pmbRight;
            }
            else
            {
                // We may be all done:

                if (pmbDst->rcl.top <= bb.rclBounds.top)
                    break;

                // Nope, have to up down to left side of next upper row:

                while (pmbDst->rcl.left > bb.rclBounds.left)
                {
                    pmbDst = pmbDst->pmbLeft;
                    pmbSrc = pmbSrc->pmbLeft;
                }

                pmbDst = pmbDst->pmbUp;
                pmbSrc = pmbSrc->pmbUp;
            }
        }
    }

    GO_HOME(bb.pmdev);
    bb.pco->rclBounds = rclOriginalBounds;

OuttaHere:

    // In one case, pso0 == pso1 == pso2 == pso3, and we don't want to
    // unlock the same surface twice:

    if (pso1 != pso2)
        EngUnlockSurface(pso1);

    EngUnlockSurface(pso2);
    EngDeleteSurface(hsurf0);
    EngDeleteSurface(hsurf1);

    return(b);
}

/******************************Public*Routine******************************\
* MulGetModes
*
\**************************************************************************/

ULONG MulGetModes(
HANDLE    hDriver,
ULONG     cjSize,
DEVMODEW* pdm)
{
    ULONG ulRet;

    ulRet = DrvGetModes(hDriver, cjSize, pdm);

    return(ulRet);
}

/******************************Public*Routine******************************\
* MulEnablePDEV
*
\**************************************************************************/

DHPDEV MulEnablePDEV(
DEVMODEW* pDevmode,
PWSTR     pwszLogAddress,
ULONG     cPatterns,
HSURF*    ahsurfPatterns,
ULONG     cjGdiInfo,
ULONG*    pGdiInfo,
ULONG     cjDevInfo,
DEVINFO*  pDevInfo,
HDEV      hdev,
PWSTR     pwszDeviceName,
HANDLE    hDriver)
{
    MDEV*        pmdev;                // Multi-board PDEV
    PDEV*        ppdev;                // Per-board PDEV
    MULTI_BOARD* pmb;
    LONG         cx;
    LONG         cy;

    // Note that we depend on the zero initialization:

    pmdev = AtiAllocMem(LPTR, FL_ZERO_MEMORY, sizeof(MDEV));
    if (pmdev == NULL)
        goto ReturnFailure0;

    if (!bVeryTemporaryInitializationCode(pmdev))
        goto ReturnFailure1;

    // For every board, we'll create our own PDEV and surface:

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        // Initialize each board and create a surface to go with it:

        ppdev = (PDEV*) DrvEnablePDEV(pDevmode,     pwszLogAddress,
                                      cPatterns,    ahsurfPatterns,
                                      cjGdiInfo,    pGdiInfo,
                                      cjDevInfo,    pDevInfo,
                                      hdev,         pwszDeviceName,
                                      hDriver);
        if (ppdev == NULL)
            goto ReturnFailure1;

        pmb->ppdev = ppdev;
    }

    // Choose a board, any board:

    pmb = pmdev->pmbLowerLeft;

    // Get a copy of what functions we're supposed to hook, sans
    // HOOK_STRETCHBLT because I can't be bothered to write its
    // MulStretchBlt function:

    pmdev->flHooks       = pmb->ppdev->flHooks & ~HOOK_STRETCHBLT;
    pmdev->iBitmapFormat = pmb->ppdev->iBitmapFormat;

    // As part of our hard-coded initialization hack, we will simply
    // take whatever resolution was requested via the Control Panel
    // and create a two board virtual desktop, where the screens are
    // side-by-side.
    //
    // The DrvEnablePDEV function for any board has already figured
    // out what the requested mode was:

    cx = ((GDIINFO*) pGdiInfo)->ulHorzRes;
    cy = ((GDIINFO*) pGdiInfo)->ulVertRes;

    // Set up bounds for left board:

    pmb->rcl.left       = 0;
    pmb->rcl.top        = 0;
    pmb->rcl.right      = cx;
    pmb->rcl.bottom     = cy;

    // Set up bounds for right board:

    pmb = pmb->pmbRight;

    pmb->rcl.left       = cx;
    pmb->rcl.top        = 0;
    pmb->rcl.right      = 2 * cx;
    pmb->rcl.bottom     = cy;

    // Adjust the stuff we return back to GDI to reflect that our
    // virtual surface size is now twice as wide:

    ((GDIINFO*) pGdiInfo)->ulPanningHorzRes  *= 2;
    ((GDIINFO*) pGdiInfo)->ulHorzSize        *= 2;

    // With the Metheus board, since only one board can be mapped in
    // at one time, we cannot allow asynchronous pointers:

    pDevInfo->flGraphicsCaps &= ~(GCAPS_ASYNCMOVE | GCAPS_ASYNCCHANGE);

    return((DHPDEV) pmdev);

ReturnFailure1:
    MulDisablePDEV((DHPDEV) pmdev);

ReturnFailure0:
    DISPDBG((0, "Failed MulEnablePDEV"));

    return(0);
}

/******************************Public*Routine******************************\
* MulCompletePDEV
*
\**************************************************************************/

VOID MulCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    MDEV*         pmdev;
    MULTI_BOARD*  pmb;

    pmdev = (MDEV*) dhpdev;
    pmdev->hdev = hdev;

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        GO_BOARD(pmdev, pmb);
        DrvCompletePDEV((DHPDEV) pmb->ppdev, hdev);
    }
}

/******************************Public*Routine******************************\
* MulEnableSurface
*
\**************************************************************************/

HSURF MulEnableSurface(DHPDEV dhpdev)
{
    MDEV*         pmdev;
    MULTI_BOARD*  pmb;
    SIZEL         sizlVirtual;
    HSURF         hsurfBoard;               // Gnarly, dude!
    SURFOBJ*      psoBoard;
    DSURF*        pdsurfBoard;
    HSURF         hsurfVirtual;
    CLIPOBJ*      pco;

    pmdev = (MDEV*) dhpdev;
    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        GO_BOARD(pmdev, pmb);

        hsurfBoard = DrvEnableSurface((DHPDEV) pmb->ppdev);
        if (hsurfBoard == 0)
            goto ReturnFailure;

        pmb->hsurf = hsurfBoard;

        // Every time we draw on a particular board, we'll refer to it
        // using this surface:

        psoBoard = EngLockSurface(hsurfBoard);
        if (psoBoard == NULL)
            goto ReturnFailure;

        pmb->pso = psoBoard;

        // There are a few things in the board's data instances that we
        // have to modify:

        pdsurfBoard = (DSURF*) psoBoard->dhsurf;

        pmb->ppdev->iBoard  =  pmb->iBoard;
        pdsurfBoard->poh->x = -pmb->rcl.left;
        pdsurfBoard->poh->y = -pmb->rcl.top;

        // This is sort of a hack.  Whenever we pass a call on to a board's
        // Drv function using 'pmb->pso', it has to be able to retrieve
        // it's own PDEV pointer from 'dhpdev':

        pmb->pso->dhpdev = (DHPDEV) pmb->ppdev;
    }

    // Now create the surface which the engine will use to refer to our
    // entire multi-board virtual screen:

    sizlVirtual.cx = pmdev->pmbLowerRight->rcl.right;
    sizlVirtual.cy = pmdev->pmbLowerRight->rcl.bottom;

    hsurfVirtual = EngCreateDeviceSurface((DHSURF) pmdev, sizlVirtual,
                                          pmdev->iBitmapFormat);
    if (hsurfVirtual == 0)
        goto ReturnFailure;

    pmdev->hsurf = hsurfVirtual;

    if (!EngAssociateSurface(hsurfVirtual, pmdev->hdev, pmdev->flHooks))
        goto ReturnFailure;

    // Create a temporary clip object that we can use when a drawing
    // operation spans multiple boards:

    pco = EngCreateClip();
    if (pco == NULL)
        goto ReturnFailure;

    pmdev->pco = pco;

    pmdev->pco->iDComplexity      = DC_RECT;
    pmdev->pco->iMode             = TC_RECTANGLES;
    pmdev->pco->rclBounds.left    = 0;
    pmdev->pco->rclBounds.top     = 0;
    pmdev->pco->rclBounds.right   = pmdev->pmbLowerRight->rcl.right;
    pmdev->pco->rclBounds.bottom  = pmdev->pmbLowerRight->rcl.bottom;

    return(hsurfVirtual);

ReturnFailure:
    MulDisableSurface((DHPDEV) pmdev);

    DISPDBG((0, "Failed MulEnableSurface"));

    return(0);
}

/******************************Public*Routine******************************\
* MulStrokePath
*
\**************************************************************************/

BOOL MulStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrush,
LINEATTRS* pla,
MIX        mix)
{
    RECTFX       rcfxBounds;
    RECTL        rclBounds;
    MDEV*        pmdev;
    RECTL        rclOriginalBounds;
    MULTI_BOARD* pmb;
    BOOL         b;
    FLOAT_LONG   elStyleState;

    // Get the path bounds and make it lower-right exclusive:

    PATHOBJ_vGetBounds(ppo, &rcfxBounds);

    rclBounds.left   = (rcfxBounds.xLeft   >> 4);
    rclBounds.top    = (rcfxBounds.yTop    >> 4);
    rclBounds.right  = (rcfxBounds.xRight  >> 4) + 2;
    rclBounds.bottom = (rcfxBounds.yBottom >> 4) + 2;

    pmdev = (MDEV*) pso->dhpdev;
    if (bFindBoard(pmdev, &rclBounds, &pmb))
    {
        GO_BOARD(pmdev, pmb);
        b = DrvStrokePath(pmb->pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix);
    }
    else
    {
        if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
        {
            // If the CLIPOBJ doesn't have at least DC_RECT complexity,
            // substitute one that does:

            pco = pmdev->pco;
        }

        rclOriginalBounds = pco->rclBounds;
        elStyleState = pla->elStyleState;

        b = TRUE;
        do {
            // For each board, make sure the style state gets reset and
            // the path enumeration gets restarted:

            pla->elStyleState = elStyleState;
            PATHOBJ_vEnumStart(ppo);

            if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
            {
                GO_BOARD(pmdev, pmb);
                b &= DrvStrokePath(pmb->pso, ppo, pco, pxo, pbo, pptlBrush, pla,
                                   mix);
            }

        } while (bNextBoard(&rclBounds, &pmb));

        // Restore the original clip bounds:

        pco->rclBounds = rclOriginalBounds;
    }

    GO_HOME(pmdev);

    return(b);
}

/******************************Public*Routine******************************\
* MulFillPath
*
\**************************************************************************/

BOOL MulFillPath(
SURFOBJ*  pso,
PATHOBJ*  ppo,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix,
FLONG     flOptions)
{
    RECTFX       rcfxBounds;
    RECTL        rclBounds;
    MDEV*        pmdev;
    RECTL        rclOriginalBounds;
    MULTI_BOARD* pmb;
    BOOL         b;

    // Get the path bounds and make it lower-right exclusive:

    PATHOBJ_vGetBounds(ppo, &rcfxBounds);

    rclBounds.left   = (rcfxBounds.xLeft   >> 4);
    rclBounds.top    = (rcfxBounds.yTop    >> 4);
    rclBounds.right  = (rcfxBounds.xRight  >> 4) + 2;
    rclBounds.bottom = (rcfxBounds.yBottom >> 4) + 2;

    pmdev = (MDEV*) pso->dhpdev;
    if (bFindBoard(pmdev, &rclBounds, &pmb))
    {
        GO_BOARD(pmdev, pmb);
        b = DrvFillPath(pmb->pso, ppo, pco, pbo, pptlBrush, mix, flOptions);
    }
    else
    {
        if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
        {
            // If the CLIPOBJ doesn't have at least DC_RECT complexity,
            // substitute one that does:

            pco = pmdev->pco;
        }

        rclOriginalBounds = pco->rclBounds;

        b = TRUE;
        do {
            // Make sure we restart the path enumeration if need be:

            PATHOBJ_vEnumStart(ppo);
            if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
            {
                GO_BOARD(pmdev, pmb);
                b &= DrvFillPath(pmb->pso, ppo, pco, pbo, pptlBrush, mix,
                                 flOptions);
            }

        } while (bNextBoard(&rclBounds, &pmb));

        // Restore the original clip bounds:

        pco->rclBounds = rclOriginalBounds;
    }

    GO_HOME(pmdev);

    return(b);
}

/******************************Public*Routine******************************\
* MulBitBlt
*
\**************************************************************************/

BOOL MulBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL         bFromScreen;
    BOOL         bToScreen;
    MDEV*        pmdev;
    MULTI_BOARD* pmb;
    RECTL        rclOriginalBounds;
    BOOL         b;
    RECTL        rclBounds;
    LONG         xOffset;
    LONG         yOffset;
    RECTL        rclDstBounds;
    RECTL        rclDst;

    bFromScreen = ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE));
    bToScreen   = ((psoDst != NULL) && (psoDst->iType == STYPE_DEVICE));

    // We copy the prclDst rectangle here because sometimes GDI will
    // simply point prclDst to the same rectangle in pco->rclBounds,
    // and we'll be mucking with pco->rclBounds...

    rclDst = *prclDst;

    if (bToScreen && bFromScreen)
    {
        ///////////////////////////////////////////////////////////////
        // Screen-to-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoDst->dhpdev;

        // rclBounds is the union of the source and destination rectangles:

        rclBounds.left   = min(rclDst.left, pptlSrc->x);
        rclBounds.top    = min(rclDst.top,  pptlSrc->y);
        rclBounds.right  = max(rclDst.right,
                               pptlSrc->x + (rclDst.right - rclDst.left));
        rclBounds.bottom = max(rclDst.bottom,
                               pptlSrc->y + (rclDst.bottom - rclDst.top));

        if (bFindBoard(pmdev, &rclBounds, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvBitBlt(pmb->pso, pmb->pso, psoMask, pco, pxlo, &rclDst,
                          pptlSrc, pptlMask, pbo, pptlBrush, rop4);
        }
        else
        {
            return(bBitBltBetweenBoards(psoDst, psoSrc, psoMask, pco, pxlo,
                                        &rclDst, pptlSrc, pptlMask, pbo,
                                        pptlBrush, rop4, &rclBounds, pmb));
        }
    }
    else if (bToScreen)
    {
        ///////////////////////////////////////////////////////////////
        // To-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoDst->dhpdev;
        if (bFindBoard(pmdev, &rclDst, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvBitBlt(pmb->pso, psoSrc, psoMask, pco, pxlo, &rclDst,
                          pptlSrc, pptlMask, pbo, pptlBrush, rop4);
        }
        else
        {
            if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
            {
                // If the CLIPOBJ doesn't have at least DC_RECT complexity,
                // substitute one that does:

                pco = pmdev->pco;
            }

            rclOriginalBounds = pco->rclBounds;

            b = TRUE;
            do {
                if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
                {
                    GO_BOARD(pmdev, pmb);
                    b &= DrvBitBlt(pmb->pso, psoSrc, psoMask, pco, pxlo, &rclDst,
                                   pptlSrc, pptlMask, pbo, pptlBrush, rop4);
                }

            } while (bNextBoard(&rclDst, &pmb));

            // Restore the original clip bounds:

            pco->rclBounds = rclOriginalBounds;
        }
    }
    else
    {
        ///////////////////////////////////////////////////////////////
        // From-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoSrc->dhpdev;

        // rclBounds is the source rectangle:

        rclBounds.left   = pptlSrc->x;
        rclBounds.top    = pptlSrc->y;
        rclBounds.right  = pptlSrc->x + (rclDst.right - rclDst.left);
        rclBounds.bottom = pptlSrc->y + (rclDst.bottom - rclDst.top);

        if (bFindBoard(pmdev, &rclBounds, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvBitBlt(psoDst, pmb->pso, psoMask, pco, pxlo, &rclDst,
                          pptlSrc, pptlMask, pbo, pptlBrush, rop4);
        }
        else
        {
            if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
            {
                // If the CLIPOBJ doesn't have at least DC_RECT complexity,
                // substitute one that does:

                pco = pmdev->pco;
            }

            rclOriginalBounds = pco->rclBounds;

            // Offset to transform from source rectangle to destination
            // rectangle:

            xOffset = rclDst.left - pptlSrc->x;
            yOffset = rclDst.top  - pptlSrc->y;

            b = TRUE;
            do {
                // Since the screen is the source, but the clip bounds applies
                // to the destination, we have to convert our board clipping
                // information to destination coordinates:

                rclDstBounds.left   = pmb->rcl.left   + xOffset;
                rclDstBounds.right  = pmb->rcl.right  + xOffset;
                rclDstBounds.top    = pmb->rcl.top    + yOffset;
                rclDstBounds.bottom = pmb->rcl.bottom + yOffset;

                if (bIntersect(&rclOriginalBounds, &rclDstBounds, &pco->rclBounds))
                {
                    GO_BOARD(pmdev, pmb);
                    b &= DrvBitBlt(psoDst, pmb->pso, psoMask, pco, pxlo, &rclDst,
                                   pptlSrc, pptlMask, pbo, pptlBrush, rop4);
                }

            } while (bNextBoard(&rclBounds, &pmb));

            // Restore the original clip bounds:

            pco->rclBounds = rclOriginalBounds;
        }
    }

    GO_HOME(pmdev);

    return(b);
}

/******************************Public*Routine******************************\
* MulDisablePDEV
*
* Note: May be called before MulEnablePDEV successfully completed!
*
\**************************************************************************/

VOID MulDisablePDEV(DHPDEV dhpdev)
{
    MULTI_BOARD* pmb;
    MDEV*        pmdev;

    pmdev = (MDEV*) dhpdev;

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        if (pmb->ppdev != NULL)
        {
            GO_BOARD(pmdev, pmb);
            DrvDisablePDEV((DHPDEV) pmb->ppdev);
        }
    }

    GO_HOME(pmdev);

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        AtiFreeMem(pmb);         // Undo 'bVeryTemporaryInitializationCode'
    }                           //   allocation

    AtiFreeMem(pmdev);

}

/******************************Public*Routine******************************\
* MulDisableSurface
*
* Note: May be called before MulEnableSurface successfully completed!
*
\**************************************************************************/

VOID MulDisableSurface(DHPDEV dhpdev)
{
    MULTI_BOARD* pmb;
    MDEV*        pmdev;

    pmdev = (MDEV*) dhpdev;

    if (pmdev->pco != NULL)
        EngDeleteClip(pmdev->pco);

    EngDeleteSurface(pmdev->hsurf);

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        GO_BOARD(pmdev, pmb);

        EngUnlockSurface(pmb->pso);

        DrvDisableSurface((DHPDEV) pmb->ppdev);
    }

    GO_HOME(pmdev);
}

/******************************Public*Routine******************************\
* MulAssertMode
*
\**************************************************************************/

BOOL MulAssertMode(
DHPDEV dhpdev,
BOOL   bEnable)
{
    MDEV*         pmdev;
    MULTI_BOARD*  pmb;

    pmdev = (MDEV*) dhpdev;

    if (!bEnable)
    {
        // When switching to full-screen mode, PatBlt blackness over
        // all the inactive screens (otherwise it looks goofy when
        // the desktop is frozen on the inactive screens and the user
        // can't do anything with it):

        for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
        {
            if (pmb != pmdev->pmbHome)
            {
                GO_BOARD(pmdev, pmb);
                DrvBitBlt(pmb->pso, NULL, NULL, NULL, NULL, &pmb->rcl, NULL,
                          NULL, NULL, NULL, 0);
            }
        }
    }

    // We use the 'home' board for full-screen switching:

    GO_BOARD(pmdev, pmdev->pmbHome);
    return (DrvAssertMode((DHPDEV) pmdev->pmbHome->ppdev, bEnable));
}

/******************************Public*Routine******************************\
* MulMovePointer
*
\**************************************************************************/

VOID MulMovePointer(
SURFOBJ* pso,
LONG     x,
LONG     y,
RECTL*   prcl)
{
    MDEV*        pmdev;
    MULTI_BOARD* pmbPointer;
    RECTL        rclPointer;

    pmdev     = (MDEV*) pso->dhpdev;
    pmbPointer = pmdev->pmbPointer;

    if (pmbPointer != NULL)
    {
        // The most common case is when the pointer is moved to a spot
        // on the same board:

        if ((x >= pmbPointer->rcl.left)  &&
            (x <  pmbPointer->rcl.right) &&
            (y >= pmbPointer->rcl.top)   &&
            (y <  pmbPointer->rcl.bottom))
        {
            GO_BOARD(pmdev, pmbPointer);
            DrvMovePointer(pmbPointer->pso, x, y, prcl);
            GO_HOME(pmdev);

            return;
        }

        // Tell the old board to erase its cursor:

        GO_BOARD(pmdev, pmbPointer);
        DrvMovePointer(pmbPointer->pso, -1, -1, NULL);
    }

    if (x == -1)
    {
        pmdev->pmbPointer = NULL;
        GO_HOME(pmdev);

        return;
    }

    // Find the new board and tell it to draw its new cursor:

    rclPointer.left   = x;
    rclPointer.right  = x;
    rclPointer.top    = y;
    rclPointer.bottom = y;

    bFindBoard(pmdev, &rclPointer, &pmbPointer);

    GO_BOARD(pmdev, pmbPointer);
    DrvMovePointer(pmbPointer->pso, x, y, prcl);

    pmdev->pmbPointer = pmbPointer;

    GO_HOME(pmdev);
}

/******************************Public*Routine******************************\
* MulSetPointerShape
*
\**************************************************************************/

ULONG MulSetPointerShape(
SURFOBJ*  pso,
SURFOBJ*  psoMask,
SURFOBJ*  psoColor,
XLATEOBJ* pxlo,
LONG      xHot,
LONG      yHot,
LONG      x,
LONG      y,
RECTL*    prcl,
FLONG     fl)
{
    MULTI_BOARD* pmb;
    MDEV*        pmdev;
    ULONG        ulRetPrevious = (ULONG) -1;
    ULONG        ulRet;
    RECTL        rclPointer;
    MULTI_BOARD* pmbPointer;             // Board on which cursor is visible

    pmdev = (MDEV*) pso->dhpdev;

    // Find out which board that the cursor is visible on, if any:

    pmbPointer = NULL;
    if (x != -1)
    {
        rclPointer.left   = x;
        rclPointer.right  = x;
        rclPointer.top    = y;
        rclPointer.bottom = y;

        bFindBoard(pmdev, &rclPointer, &pmbPointer);
    }
    pmdev->pmbPointer = pmbPointer;

    // LATER: Fix the case for when some boards may fail the call, and others
    //        won't.

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        // We notify all boards of the new cursor shape, but only the board
        // on which the cursor is visible is told to draw it:

        GO_BOARD(pmdev, pmb);

        if (pmb == pmbPointer)
        {
            ulRet = DrvSetPointerShape(pmb->pso, psoMask, psoColor, pxlo,
                                       xHot, yHot, x, y, prcl, fl);
        }
        else
        {
            ulRet = DrvSetPointerShape(pmb->pso, psoMask, psoColor, pxlo,
                                       xHot, yHot, -1, y, NULL, fl);
        }

        if ((ulRetPrevious != (ULONG) -1) && (ulRetPrevious != ulRet))
        {
            RIP("MulSetPointerShape not all DrvSetPointerShapes same\n");
        }

        ulRetPrevious = ulRet;
    }

    GO_HOME(pmdev);

    return(ulRetPrevious);
}

/******************************Public*Routine******************************\
* MulDitherColor
*
\**************************************************************************/

ULONG MulDitherColor(
DHPDEV dhpdev,
ULONG  iMode,
ULONG  rgb,
ULONG* pul)
{
    PDEV* ppdev;
    ULONG ulRet;

    // Let the first board's driver do the dithering:

    ppdev = ((MDEV*) dhpdev)->pmb->ppdev;
    ulRet = DrvDitherColor((DHPDEV) ppdev, iMode, rgb, pul);

    return(ulRet);
}

/******************************Public*Routine******************************\
* MulSetPalette
*
\**************************************************************************/

BOOL MulSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    MULTI_BOARD* pmb;
    MDEV*        pmdev;
    BOOL         bRet = TRUE;

    // Notify all boards of the palette change:

    pmdev = (MDEV*) dhpdev;
    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        GO_BOARD(pmdev, pmb);
        bRet &= DrvSetPalette((DHPDEV) pmb->ppdev, ppalo, fl, iStart, cColors);
    }

    GO_HOME(pmdev);

    return(bRet);
}

/******************************Public*Routine******************************\
* MulCopyBits
*
\**************************************************************************/

BOOL MulCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    BOOL         bFromScreen;
    BOOL         bToScreen;
    MDEV*        pmdev;
    MULTI_BOARD* pmb;
    RECTL        rclOriginalBounds;
    BOOL         b;
    RECTL        rclBounds;
    RECTL        rclDst;

    bFromScreen = ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE));
    bToScreen   = ((psoDst != NULL) && (psoDst->iType == STYPE_DEVICE));

    // We copy the prclDst rectangle here because sometimes GDI will
    // simply point prclDst to the same rectangle in pco->rclBounds,
    // and we'll be mucking with pco->rclBounds...

    rclDst = *prclDst;

    if (bToScreen && bFromScreen)
    {
        ///////////////////////////////////////////////////////////////
        // Screen-to-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoDst->dhpdev;

        // rclBounds is the union of the source and destination rectangles:

        rclBounds.left   = min(rclDst.left, pptlSrc->x);
        rclBounds.top    = min(rclDst.top,  pptlSrc->y);
        rclBounds.right  = max(rclDst.right,
                               pptlSrc->x + (rclDst.right - rclDst.left));
        rclBounds.bottom = max(rclDst.bottom,
                               pptlSrc->y + (rclDst.bottom - rclDst.top));

        if (bFindBoard(pmdev, &rclBounds, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvCopyBits(pmb->pso, pmb->pso, pco, pxlo, &rclDst, pptlSrc);
        }
        else
        {
            return(bBitBltBetweenBoards(psoDst, psoSrc, NULL, pco, pxlo,
                                        &rclDst, pptlSrc, NULL, NULL,
                                        NULL, 0x0000cccc, &rclBounds, pmb));
        }
    }
    else if (bToScreen)
    {
        ///////////////////////////////////////////////////////////////
        // To-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoDst->dhpdev;
        if (bFindBoard(pmdev, &rclDst, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvCopyBits(pmb->pso, psoSrc, pco, pxlo, &rclDst, pptlSrc);
        }
        else
        {
            if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
            {
                // If the CLIPOBJ doesn't have at least DC_RECT complexity,
                // substitute one that does:

                pco = pmdev->pco;
            }

            rclOriginalBounds = pco->rclBounds;

            b = TRUE;
            do {
                if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
                {
                    GO_BOARD(pmdev, pmb);
                    b &= DrvCopyBits(pmb->pso, psoSrc, pco, pxlo, &rclDst,
                                     pptlSrc);
                }

            } while (bNextBoard(&rclDst, &pmb));

            // Restore the original clip bounds:

            pco->rclBounds = rclOriginalBounds;
        }
    }
    else
    {
        ///////////////////////////////////////////////////////////////
        // From-screen
        ///////////////////////////////////////////////////////////////

        // This rarely happens, so save some code space:

        return(MulBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst,
                              pptlSrc, NULL, NULL, NULL, 0x0000cccc));
    }

    GO_HOME(pmdev);

    return(b);
}

/******************************Public*Routine******************************\
* MulTextOut
*
\**************************************************************************/

BOOL MulTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlOrg,
MIX       mix)
{
    MDEV*          pmdev;
    MULTI_BOARD*   pmb;
    RECTL          rclOriginalBounds;
    BYTE           fjOriginalOptions;
    BOOL           b;
    RECTL*         prclBounds;
    FONT_CONSUMER* pfcArray;

    pmdev = (MDEV*) pso->dhpdev;

    // In keeping with our philosophy for multiple board support, we handle
    // multiple consumers of the same font at this level.  We do this by
    // monitoring pfo->pvConsumer, and the first time a board sets the
    // field, we take control of pfo->pvConsumer.  We use it to allocate
    // a pvConsumer array where we can keep track of every board's
    // individual pvConsumer.

    pfcArray = pfo->pvConsumer;

    prclBounds = (prclOpaque != NULL) ? prclOpaque : &pstro->rclBkGround;

    bFindBoard(pmdev, prclBounds, &pmb);

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        // If the CLIPOBJ doesn't have at least DC_RECT complexity,
        // substitute one that does:

        pco = pmdev->pco;
    }

    rclOriginalBounds = pco->rclBounds;
    fjOriginalOptions = pco->fjOptions;

    // OR in the OC_BANK_CLIP flag to let GDI know that we may be calling
    // EngTextOut multiple times with the same parameters (EngTextOut
    // is destructive in that it modifies that parameters passed to it,
    // unless this bit is set):

    pco->fjOptions |= OC_BANK_CLIP;

    b = TRUE;
    do {
        if (pfcArray != NULL)
            pfo->pvConsumer = pfcArray->apvc[pmb->iBoard].pvConsumer;

        // Make sure we restart the glyph enumeration if need be:

        STROBJ_vEnumStart(pstro);
        if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
        {
            GO_BOARD(pmdev, pmb);
            b &= DrvTextOut(pmb->pso, pstro, pfo, pco, prclExtra, prclOpaque,
                            pboFore, pboOpaque, pptlOrg, mix);
        }

        if (pfcArray != NULL)
        {
            // Copy the pvConsumer, in case the last DrvTextOut changed
            // it:

            pfcArray->apvc[pmb->iBoard].pvConsumer = pfo->pvConsumer;
        }
        else
        {
            if (pfo->pvConsumer != NULL)
            {
                // The board allocated a new consumer, so create our array
                // to keep track of consumers for every board:

                pfcArray = AtiAllocMem(LPTR, FL_ZERO_MEMORY, sizeof(FONT_CONSUMER));
                if (pfcArray == NULL)
                    DrvDestroyFont(pfo);
                else
                {
                    pfcArray->cConsumers = pmdev->cBoards;
                    pfcArray->apvc[pmb->iBoard].pvConsumer = pfo->pvConsumer;

                }
            }
        }
    } while (bNextBoard(prclBounds, &pmb));

    // Restore the original clip bounds:

    pco->rclBounds = rclOriginalBounds;
    pco->fjOptions = fjOriginalOptions;

    // Make sure we restore/set the font's pvConsumer:

    pfo->pvConsumer = pfcArray;

    GO_HOME(pmdev);

    return(b);
}

/******************************Public*Routine******************************\
* MulDestroyFont
*
\**************************************************************************/

VOID MulDestroyFont(FONTOBJ *pfo)
{
    FONT_CONSUMER* pfcArray;
    LONG           i;
    PVOID          pvConsumer;

    if (pfo->pvConsumer != NULL)
    {
        pfcArray = pfo->pvConsumer;
        for (i = 0; i < pfcArray->cConsumers; i++)
        {
            pvConsumer = pfcArray->apvc[i].pvConsumer;
            if (pvConsumer != NULL)
            {
                pfo->pvConsumer = pvConsumer;
                DrvDestroyFont(pfo);
            }
        }

        AtiFreeMem(pfcArray);
        pfo->pvConsumer = NULL;
    }

}

/******************************Public*Routine******************************\
* MulPaint
*
\**************************************************************************/

BOOL MulPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix)
{
    MDEV*        pmdev;
    RECTL        rclOriginalBounds;
    MULTI_BOARD* pmb;
    BOOL         b;

    pmdev = (MDEV*) pso->dhpdev;
    if (bFindBoard(pmdev, &pco->rclBounds, &pmb))
    {
        GO_BOARD(pmdev, pmb);
        b = DrvPaint(pmb->pso, pco, pbo, pptlBrush, mix);
    }
    else
    {
        rclOriginalBounds = pco->rclBounds;

        b = TRUE;
        do {
            if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
            {
                GO_BOARD(pmdev, pmb);
                b &= DrvPaint(pmb->pso, pco, pbo, pptlBrush, mix);
            }

        } while (bNextBoard(&rclOriginalBounds, &pmb));

        // Restore the original clip bounds:

        pco->rclBounds = rclOriginalBounds;
    }

    GO_HOME(pmdev);

    return(b);
}

/******************************Public*Routine******************************\
* MulRealizeBrush
*
\**************************************************************************/

BOOL MulRealizeBrush(
BRUSHOBJ* pbo,
SURFOBJ*  psoTarget,
SURFOBJ*  psoPattern,
SURFOBJ*  psoMask,
XLATEOBJ* pxlo,
ULONG     iHatch)
{
    MDEV*        pmdev;
    BOOL         b;

    pmdev = (MDEV*) psoTarget->dhpdev;

    // DrvRealizeBrush is only ever calling from within a Drv function.
    // 'psoTarget' points to our multi-board surface, but we have to point
    // it to the surface of the board for which the DrvBitBlt call was made.

    b = DrvRealizeBrush(pbo, pmdev->pmbCurrent->pso, psoPattern, psoMask,
                        pxlo, iHatch);

    return(b);
}

#endif // MULTI_BOARDS

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\precomp.h ===
/******************************Module*Header*******************************\
* Module Name: precomp.h
*
* Common headers used throughout the display driver.  This entire include
* file will typically be pre-compiled.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <windef.h>
#include <wingdi.h>
#include <winddi.h>
#include <winerror.h>
#include <devioctl.h>
#include <ntddvdeo.h>
#include <ioaccess.h>
//
// Some intrinsic functions like abs() are X86 32 bits only. In order to
// make these code working for Merced for now, we have to include math.h to
// use abs() function there
//
#include <math.h>

#include "lines.h"
#include "driver.h"
#include "hw.h"
#include "debug.h"

#if TARGET_BUILD <= 351
#include <stdio.h>
#include <windows.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\str.c ===
/******************************Module*Header*******************************\
* Module Name: str.c
*
* Contains the 'C' versions of some inner-loop routines for the
* partially hardware accelerated StretchBlt.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch8
*
* Routine Description:
*
*   Stretch blt 8->8
*
* NOTE: This routine doesn't handle cases where the blt stretch starts
*       and ends in the same destination dword!  vDirectStretchNarrow
*       is expected to have been called for that case.
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vM64DirectStretch8(
STR_BLT* pStrBlt)
{
    BYTE*   pjSrc;
    BYTE*   pjDstEnd;
    LONG    WidthXAln;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    ULONG   yTmp;
    BYTE*   pjOldScan;
    LONG    cyDuplicate;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = pStrBlt->pjSrcScan + xSrc;
    BYTE*   pjDst       = pStrBlt->pjDstScan + xDst;
    LONG    yDst        = pStrBlt->YDstStart + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    ULONG   StartAln    = (ULONG)((ULONG_PTR)pjDst & 0x03);
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   EndAln      = (ULONG)((ULONG_PTR)(pjDst + WidthX) & 0x03);
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    ULONG   yInt        = 0;
    LONG    lDstStride  = pStrBlt->lDeltaDst - WidthX;

    BYTE    jSrc0,jSrc1,jSrc2,jSrc3;
    BYTE*   pjMmBase    = ppdev->pjMmBase;

    xDst += ppdev->xOffset;

    WidthXAln = WidthX - EndAln - ((- (LONG) StartAln) & 0x03);

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)
    {
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    //
    // loop drawing each scan line
    //
    //
    // at least 7 wide (DST) blt
    //

    do {
        pjSrc   = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        //
        // a single src scan line is being written
        //

        switch (StartAln) {
        case 1:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        }

        pjDstEnd  = pjDst + WidthXAln;

        while (pjDst != pjDstEnd)
        {
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);

            jSrc1 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt + (xAccum < xTmp);

            jSrc2 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);

            jSrc3 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt + (xAccum < xTmp);

            ulDst = (jSrc3 << 24) | (jSrc2 << 16) | (jSrc1 << 8) | jSrc0;

            *(PULONG)pjDst = ulDst;
            pjDst += 4;
        }

        switch (EndAln) {
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 1:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
        }

        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pjDst = (pjDst + lDstStride);
        yDst++;
        yCount--;

        if ((yCount != 0) && (pjSrcScan == pjOldScan))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pjDst = (pjDst + pStrBlt->lDeltaDst);
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            // The scan is to be copied 'cyDuplicate' times using the
            // hardware.

            M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 4);
            M64_OD(pjMmBase, SRC_Y_X, (yDst - 1) | (xDst << 16) );
            M64_OD(pjMmBase, DST_Y_X, yDst | (xDst << 16) );
            M64_OD(pjMmBase, SRC_HEIGHT1_WIDTH1, 1 | (WidthX << 16) );
            M64_OD(pjMmBase, DST_HEIGHT_WIDTH, cyDuplicate | (WidthX << 16) );

            yDst += cyDuplicate;
        }
    } while (yCount != 0);
}

VOID vM32DirectStretch8(
STR_BLT* pStrBlt)
{
    BYTE*   pjSrc;
    BYTE*   pjDstEnd;
    LONG    WidthXAln;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    ULONG   yTmp;
    BYTE*   pjOldScan;
    LONG    cyDuplicate;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = pStrBlt->pjSrcScan + xSrc;
    BYTE*   pjDst       = pStrBlt->pjDstScan + xDst;
    LONG    yDst        = pStrBlt->YDstStart + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    ULONG   StartAln    = (ULONG)((ULONG_PTR)pjDst & 0x03);
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   EndAln      = (ULONG)((ULONG_PTR)(pjDst + WidthX) & 0x03);
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    ULONG   yInt        = 0;
    LONG    lDstStride  = pStrBlt->lDeltaDst - WidthX;

    BYTE    jSrc0,jSrc1,jSrc2,jSrc3;
    BYTE*   pjMmBase    = ppdev->pjMmBase;

    xDst += ppdev->xOffset;

    WidthXAln = WidthX - EndAln - ((- (LONG) StartAln) & 0x03);

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)
    {
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    //
    // loop drawing each scan line
    //
    //
    // at least 7 wide (DST) blt
    //

    do {
        pjSrc   = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        //
        // a single src scan line is being written
        //

        switch (StartAln) {
        case 1:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        }

        pjDstEnd  = pjDst + WidthXAln;

        while (pjDst != pjDstEnd)
        {
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);

            jSrc1 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt + (xAccum < xTmp);

            jSrc2 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);

            jSrc3 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt + (xAccum < xTmp);

            ulDst = (jSrc3 << 24) | (jSrc2 << 16) | (jSrc1 << 8) | jSrc0;

            *(PULONG)pjDst = ulDst;
            pjDst += 4;
        }

        switch (EndAln) {
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 1:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
        }

        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pjDst = (pjDst + lDstStride);
        yDst++;
        yCount--;

        // 32 to fix bizarre hardware bug (?) -- totally heuristic

        if ((yCount != 0) && (pjSrcScan == pjOldScan) && (WidthX >= 32))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pjDst = (pjDst + pStrBlt->lDeltaDst);
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            // The scan is to be copied 'cyDuplicate' times using the
            // hardware.

            M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 9);
            M32_OW(pjMmBase, M32_SRC_X,       (SHORT) xDst );
            M32_OW(pjMmBase, M32_SRC_X_START, (SHORT) xDst );
            M32_OW(pjMmBase, M32_SRC_X_END,   (SHORT) (xDst + WidthX) );
            M32_OW(pjMmBase, M32_SRC_Y,       (SHORT) (yDst - 1) );    // the line to replicate

            M32_OW(pjMmBase, CUR_X,        (SHORT) xDst );
            M32_OW(pjMmBase, DEST_X_START, (SHORT) xDst );
            M32_OW(pjMmBase, DEST_X_END,   (SHORT) (xDst + WidthX) );
            M32_OW(pjMmBase, CUR_Y,        (SHORT) yDst );

            vM32QuietDown(ppdev, pjMmBase);
            M32_OW(pjMmBase, DEST_Y_END, (SHORT) (yDst + cyDuplicate) );

            yDst += cyDuplicate;
        }
    } while (yCount != 0);
}

VOID vI32DirectStretch8(
STR_BLT* pStrBlt)
{
    BYTE*   pjSrc;
    BYTE*   pjDstEnd;
    LONG    WidthXAln;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    ULONG   yTmp;
    BYTE*   pjOldScan;
    LONG    cyDuplicate;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = pStrBlt->pjSrcScan + xSrc;
    BYTE*   pjDst       = pStrBlt->pjDstScan + xDst;
    LONG    yDst        = pStrBlt->YDstStart + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    ULONG   StartAln    = (ULONG)((ULONG_PTR)pjDst & 0x03);
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   EndAln      = (ULONG)((ULONG_PTR)(pjDst + WidthX) & 0x03);
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    ULONG   yInt        = 0;
    LONG    lDstStride  = pStrBlt->lDeltaDst - WidthX;

    BYTE    jSrc0,jSrc1,jSrc2,jSrc3;
    BYTE*   pjIoBase    = ppdev->pjIoBase;

    xDst += ppdev->xOffset;

    WidthXAln = WidthX - EndAln - ((- (LONG) StartAln) & 0x03);

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)
    {
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    //
    // loop drawing each scan line
    //
    //
    // at least 7 wide (DST) blt
    //

    do {
        pjSrc   = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        //
        // a single src scan line is being written
        //

        switch (StartAln) {
        case 1:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        }

        pjDstEnd  = pjDst + WidthXAln;

        while (pjDst != pjDstEnd)
        {
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);

            jSrc1 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt + (xAccum < xTmp);

            jSrc2 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);

            jSrc3 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt + (xAccum < xTmp);

            ulDst = (jSrc3 << 24) | (jSrc2 << 16) | (jSrc1 << 8) | jSrc0;

            *(PULONG)pjDst = ulDst;
            pjDst += 4;
        }

        switch (EndAln) {
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 1:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
        }

        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pjDst = (pjDst + lDstStride);
        yDst++;
        yCount--;

        // 32 to fix bizarre hardware bug (?) -- totally heuristic

        if ((yCount != 0) && (pjSrcScan == pjOldScan) && (WidthX >= 32))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pjDst = (pjDst + pStrBlt->lDeltaDst);
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            // The scan is to be copied 'cyDuplicate' times using the
            // hardware.

            I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 9);
            I32_OW(pjIoBase, M32_SRC_X,       (SHORT) xDst );
            I32_OW(pjIoBase, M32_SRC_X_START, (SHORT) xDst );
            I32_OW(pjIoBase, M32_SRC_X_END,   (SHORT) (xDst + WidthX) );
            I32_OW(pjIoBase, M32_SRC_Y,       (SHORT) (yDst - 1) );    // the line to replicate

            I32_OW(pjIoBase, CUR_X,        (SHORT) xDst );
            I32_OW(pjIoBase, DEST_X_START, (SHORT) xDst );
            I32_OW(pjIoBase, DEST_X_END,   (SHORT) (xDst + WidthX) );
            I32_OW(pjIoBase, CUR_Y,        (SHORT) yDst );

            vI32QuietDown(ppdev, pjIoBase);
            I32_OW(pjIoBase, DEST_Y_END, (SHORT) (yDst + cyDuplicate) );

            yDst += cyDuplicate;
        }
    } while (yCount != 0);
}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch16
*
* Routine Description:
*
*   Stretch blt 16->16
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vM64DirectStretch16(
STR_BLT* pStrBlt)
{
    BYTE*   pjOldScan;
    USHORT* pusSrc;
    USHORT* pusDstEnd;
    LONG    WidthXAln;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    ULONG   yTmp;
    LONG    cyDuplicate;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = (pStrBlt->pjSrcScan) + xSrc * 2;
    USHORT* pusDst      = (USHORT*)(pStrBlt->pjDstScan) + xDst;
    LONG    yDst        = pStrBlt->YDstStart + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    ULONG   StartAln    = (ULONG)(((ULONG_PTR)pusDst & 0x02) >> 1);
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   EndAln      = (ULONG)(((ULONG_PTR)(pusDst + WidthX) & 0x02) >> 1);
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    LONG    lDstStride  = pStrBlt->lDeltaDst - 2 * WidthX;
    ULONG   yInt        = 0;

    USHORT  usSrc0,usSrc1;
    BYTE*   pjMmBase    = ppdev->pjMmBase;

    xDst += ppdev->xOffset;

    WidthXAln = WidthX - EndAln - StartAln;

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)
    {
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    // Loop stretching each scan line

    do {
        pusSrc  = (USHORT*) pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        // A single source scan line is being written:

        if (StartAln)
        {
            usSrc0    = *pusSrc;
            xTmp      = xAccum + xFrac;
            pusSrc    = pusSrc + xInt + (xTmp < xAccum);
            *pusDst++ = usSrc0;
            xAccum    = xTmp;
        }

        pusDstEnd  = pusDst + WidthXAln;

        while (pusDst != pusDstEnd)
        {

            usSrc0 = *pusSrc;
            xTmp   = xAccum + xFrac;
            pusSrc = pusSrc + xInt + (xTmp < xAccum);

            usSrc1 = *pusSrc;
            xAccum = xTmp + xFrac;
            pusSrc = pusSrc + xInt + (xAccum < xTmp);

            ulDst = (ULONG)((usSrc1 << 16) | usSrc0);

            *(ULONG*)pusDst = ulDst;
            pusDst+=2;
        }

        if (EndAln)
        {
            usSrc0    = *pusSrc;
            xTmp      = xAccum + xFrac;
            pusSrc    = pusSrc + xInt + (xTmp < xAccum);
            *pusDst++ = usSrc0;
        }

        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pusDst = (USHORT*) ((BYTE*) pusDst + lDstStride);
        yDst++;
        yCount--;

        if ((yCount != 0) && (pjSrcScan == pjOldScan))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pusDst = (USHORT*) ((BYTE*) pusDst + pStrBlt->lDeltaDst);
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            // The scan is to be copied 'cyDuplicate' times using the
            // hardware.

            M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 4);
            M64_OD(pjMmBase, SRC_Y_X, (yDst - 1) | (xDst << 16) );
            M64_OD(pjMmBase, DST_Y_X, yDst | (xDst << 16) );
            M64_OD(pjMmBase, SRC_HEIGHT1_WIDTH1, 1 | (WidthX << 16) );
            M64_OD(pjMmBase, DST_HEIGHT_WIDTH, cyDuplicate | (WidthX << 16) );

            yDst += cyDuplicate;
        }
    } while (yCount != 0);
}

VOID vM32DirectStretch16(
STR_BLT* pStrBlt)
{
    BYTE*   pjOldScan;
    USHORT* pusSrc;
    USHORT* pusDstEnd;
    LONG    WidthXAln;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    ULONG   yTmp;
    LONG    cyDuplicate;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = (pStrBlt->pjSrcScan) + xSrc * 2;
    USHORT* pusDst      = (USHORT*)(pStrBlt->pjDstScan) + xDst;
    LONG    yDst        = pStrBlt->YDstStart + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    ULONG   StartAln    = (ULONG)(((ULONG_PTR)pusDst & 0x02) >> 1);
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   EndAln      = (ULONG)(((ULONG_PTR)(pusDst + WidthX) & 0x02) >> 1);
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    LONG    lDstStride  = pStrBlt->lDeltaDst - 2 * WidthX;
    ULONG   yInt        = 0;

    USHORT  usSrc0,usSrc1;
    BYTE*   pjMmBase    = ppdev->pjMmBase;

    xDst += ppdev->xOffset;

    WidthXAln = WidthX - EndAln - StartAln;

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)
    {
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    // Loop stretching each scan line

    do {
        pusSrc  = (USHORT*) pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        // A single source scan line is being written:

        if (StartAln)
        {
            usSrc0    = *pusSrc;
            xTmp      = xAccum + xFrac;
            pusSrc    = pusSrc + xInt + (xTmp < xAccum);
            *pusDst++ = usSrc0;
            xAccum    = xTmp;
        }

        pusDstEnd  = pusDst + WidthXAln;

        while (pusDst != pusDstEnd)
        {

            usSrc0 = *pusSrc;
            xTmp   = xAccum + xFrac;
            pusSrc = pusSrc + xInt + (xTmp < xAccum);

            usSrc1 = *pusSrc;
            xAccum = xTmp + xFrac;
            pusSrc = pusSrc + xInt + (xAccum < xTmp);

            ulDst = (ULONG)((usSrc1 << 16) | usSrc0);

            *(ULONG*)pusDst = ulDst;
            pusDst+=2;
        }

        if (EndAln)
        {
            usSrc0    = *pusSrc;
            xTmp      = xAccum + xFrac;
            pusSrc    = pusSrc + xInt + (xTmp < xAccum);
            *pusDst++ = usSrc0;
        }

        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pusDst = (USHORT*) ((BYTE*) pusDst + lDstStride);
        yDst++;
        yCount--;

        // 32 to fix bizarre hardware bug (?) -- totally heuristic

        if ((yCount != 0) && (pjSrcScan == pjOldScan) && (WidthX >= 32))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pusDst = (USHORT*) ((BYTE*) pusDst + pStrBlt->lDeltaDst);
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            // The scan is to be copied 'cyDuplicate' times using the
            // hardware.

            M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 9);
            M32_OW(pjMmBase, M32_SRC_X,       (SHORT) xDst );
            M32_OW(pjMmBase, M32_SRC_X_START, (SHORT) xDst );
            M32_OW(pjMmBase, M32_SRC_X_END,   (SHORT) (xDst + WidthX) );
            M32_OW(pjMmBase, M32_SRC_Y,       (SHORT) (yDst - 1) );    // the line to replicate

            M32_OW(pjMmBase, CUR_X,        (SHORT) xDst );
            M32_OW(pjMmBase, DEST_X_START, (SHORT) xDst );
            M32_OW(pjMmBase, DEST_X_END,   (SHORT) (xDst + WidthX) );
            M32_OW(pjMmBase, CUR_Y,        (SHORT) yDst );

            vM32QuietDown(ppdev, pjMmBase);
            M32_OW(pjMmBase, DEST_Y_END, (SHORT) (yDst + cyDuplicate) );

            yDst += cyDuplicate;
        }
    } while (yCount != 0);
}

VOID vI32DirectStretch16(
STR_BLT* pStrBlt)
{
    BYTE*   pjOldScan;
    USHORT* pusSrc;
    USHORT* pusDstEnd;
    LONG    WidthXAln;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    ULONG   yTmp;
    LONG    cyDuplicate;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = (pStrBlt->pjSrcScan) + xSrc * 2;
    USHORT* pusDst      = (USHORT*)(pStrBlt->pjDstScan) + xDst;
    LONG    yDst        = pStrBlt->YDstStart + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    ULONG   StartAln    = (ULONG)(((ULONG_PTR)pusDst & 0x02) >> 1);
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   EndAln      = (ULONG)(((ULONG_PTR)(pusDst + WidthX) & 0x02) >> 1);
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    LONG    lDstStride  = pStrBlt->lDeltaDst - 2 * WidthX;
    ULONG   yInt        = 0;

    USHORT  usSrc0,usSrc1;
    BYTE*   pjIoBase    = ppdev->pjIoBase;

    xDst += ppdev->xOffset;

    WidthXAln = WidthX - EndAln - StartAln;

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)
    {
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    // Loop stretching each scan line

    do {
        pusSrc  = (USHORT*) pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        // A single source scan line is being written:

        if (StartAln)
        {
            usSrc0    = *pusSrc;
            xTmp      = xAccum + xFrac;
            pusSrc    = pusSrc + xInt + (xTmp < xAccum);
            *pusDst++ = usSrc0;
            xAccum    = xTmp;
        }

        pusDstEnd  = pusDst + WidthXAln;

        while (pusDst != pusDstEnd)
        {

            usSrc0 = *pusSrc;
            xTmp   = xAccum + xFrac;
            pusSrc = pusSrc + xInt + (xTmp < xAccum);

            usSrc1 = *pusSrc;
            xAccum = xTmp + xFrac;
            pusSrc = pusSrc + xInt + (xAccum < xTmp);

            ulDst = (ULONG)((usSrc1 << 16) | usSrc0);

            *(ULONG*)pusDst = ulDst;
            pusDst+=2;
        }

        if (EndAln)
        {
            usSrc0    = *pusSrc;
            xTmp      = xAccum + xFrac;
            pusSrc    = pusSrc + xInt + (xTmp < xAccum);
            *pusDst++ = usSrc0;
        }

        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pusDst = (USHORT*) ((BYTE*) pusDst + lDstStride);
        yDst++;
        yCount--;

        // 32 to fix bizarre hardware bug (?) -- totally heuristic

        if ((yCount != 0) && (pjSrcScan == pjOldScan) && (WidthX >= 32))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pusDst = (USHORT*) ((BYTE*) pusDst + pStrBlt->lDeltaDst);
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            // The scan is to be copied 'cyDuplicate' times using the
            // hardware.

            I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 9);
            I32_OW(pjIoBase, M32_SRC_X,       (SHORT) xDst );
            I32_OW(pjIoBase, M32_SRC_X_START, (SHORT) xDst );
            I32_OW(pjIoBase, M32_SRC_X_END,   (SHORT) (xDst + WidthX) );
            I32_OW(pjIoBase, M32_SRC_Y,       (SHORT) (yDst - 1) );    // the line to replicate

            I32_OW(pjIoBase, CUR_X,        (SHORT) xDst );
            I32_OW(pjIoBase, DEST_X_START, (SHORT) xDst );
            I32_OW(pjIoBase, DEST_X_END,   (SHORT) (xDst + WidthX) );
            I32_OW(pjIoBase, CUR_Y,        (SHORT) yDst );

            vI32QuietDown(ppdev, pjIoBase);
            I32_OW(pjIoBase, DEST_Y_END, (SHORT) (yDst + cyDuplicate) );

            yDst += cyDuplicate;
        }
    } while (yCount != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\stretch.c ===
/******************************Module*Header*******************************\
* Module Name: stretch.c
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#define STRETCH_MAX_EXTENT 32767

typedef DWORDLONG ULONGLONG;

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch8Narrow
*
* Routine Description:
*
*   Stretch blt 8->8 when the width is 7 or less
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch8Narrow(
STR_BLT* pStrBlt)
{
    BYTE*   pjSrc;
    ULONG   xAccum;
    ULONG   xTmp;

    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = pStrBlt->pjSrcScan + xSrc;
    BYTE*   pjDst       = pStrBlt->pjDstScan + xDst;
    LONG    yCount      = pStrBlt->YDstCount;
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    LONG    lDstStride  = pStrBlt->lDeltaDst - WidthX;
    ULONG   yInt        = 0;

    yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;

    //
    // Narrow blt
    //

    do {

        ULONG  yTmp = yAccum + yFrac;
        BYTE   jSrc0;
        BYTE*  pjDstEndNarrow = pjDst + WidthX;

        pjSrc   = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        do {
            jSrc0    = *pjSrc;
            xTmp     = xAccum + xFrac;
            pjSrc    = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum   = xTmp;
        } while (pjDst != pjDstEndNarrow);

        pjSrcScan += yInt;

        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }

        yAccum = yTmp;
        pjDst += lDstStride;

    } while (--yCount);

}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch32
*
* Routine Description:
*
*   Stretch blt 32->32
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vM64DirectStretch32(
STR_BLT* pStrBlt)
{
    BYTE*   pjOldScan;
    ULONG*  pulSrc;
    ULONG*  pulDstEnd;
    ULONG   xAccum;
    ULONG   xTmp;
    ULONG   yTmp;
    LONG    cyDuplicate;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = pStrBlt->pjSrcScan + xSrc * 4;
    ULONG*  pulDst      = (ULONG*)(pStrBlt->pjDstScan) + xDst;
    LONG    yDst        = pStrBlt->YDstStart + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    LONG    lDstStride  = pStrBlt->lDeltaDst - 4*WidthX;
    ULONG   yInt        = 0;

    ULONG   ulSrc;
    BYTE*   pjMmBase    = ppdev->pjMmBase;

    xDst += ppdev->xOffset;

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)
    {
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    do {
        pulSrc  = (ULONG*) pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        //
        // a single src scan line is being written
        //

        pulDstEnd  = pulDst + WidthX;

        while (pulDst != pulDstEnd)
        {

            ulSrc  = *pulSrc;
            xTmp   = xAccum + xFrac;
            pulSrc = pulSrc + xInt + (xTmp < xAccum);
            *(ULONG*)pulDst = ulSrc;
            pulDst++;
            xAccum = xTmp;
        }

        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pulDst = (ULONG*) ((BYTE*) pulDst + lDstStride);
        yDst++;
        yCount--;

        if ((yCount != 0) && (pjSrcScan == pjOldScan))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pulDst = (ULONG*) ((BYTE*) pulDst + pStrBlt->lDeltaDst);
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            // The scan is to be copied 'cyDuplicate' times using the
            // hardware.

            M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 4);
            M64_OD(pjMmBase, SRC_Y_X, (yDst - 1) | (xDst << 16) );
            M64_OD(pjMmBase, DST_Y_X, yDst | (xDst << 16) );
            M64_OD(pjMmBase, SRC_HEIGHT1_WIDTH1, 1 | (WidthX << 16) );
            M64_OD(pjMmBase, DST_HEIGHT_WIDTH, cyDuplicate | (WidthX << 16) );

            yDst += cyDuplicate;
        }
    } while (yCount != 0);
}

/******************************Public*Routine******************************\
*
* Routine Description:
*
*   StretchBlt using integer math. Must be from one surface to another
*   surface of the same format.
*
* Arguments:
*
*   ppdev           -   PDEV for device
*   pvDst           -   Pointer to start of dst bitmap
*   lDeltaDst       -   Bytes from start of dst scan line to start of next
*   DstCx           -   Width of Dst Bitmap in pixels
*   DstCy           -   Height of Dst Bitmap in pixels
*   prclDst         -   Pointer to rectangle of Dst extents
*   pvSrc           -   Pointer to start of Src bitmap
*   lDeltaSrc       -   Bytes from start of Src scan line to start of next
*   SrcCx           -   Width of Src Bitmap in pixels
*   SrcCy           -   Height of Src Bitmap in pixels
*   prclSrc         -   Pointer to rectangle of Src extents
*   prclSClip       -   Clip Dest to this rect
*
* Return Value:
*
*   Status
*
\**************************************************************************/

BOOL bM64StretchDIB(
PDEV*   ppdev,
VOID*   pvDst,
LONG    lDeltaDst,
RECTL*  prclDst,
VOID*   pvSrc,
LONG    lDeltaSrc,
RECTL*  prclSrc,
RECTL*  prclClip)
{
    STR_BLT StrBlt;
    ULONG   ulXDstToSrcIntCeil;
    ULONG   ulXDstToSrcFracCeil;
    ULONG   ulYDstToSrcIntCeil;
    ULONG   ulYDstToSrcFracCeil;
    ULONG   ulXFracAccumulator;
    ULONG   ulYFracAccumulator;
    LONG    LeftClipDistance;
    LONG    TopClipDistance;
    BOOL    bStretch;
    BYTE*   pjMmBase = ppdev->pjMmBase;

    union {
        LARGE_INTEGER   large;
        ULONGLONG       li;
    } liInit;

    PFN_DIRSTRETCH      pfnStr;

    //
    // Calculate exclusive start and end points:
    //

    LONG    WidthDst  = prclDst->right  - prclDst->left;
    LONG    HeightDst = prclDst->bottom - prclDst->top;
    LONG    WidthSrc  = prclSrc->right  - prclSrc->left;
    LONG    HeightSrc = prclSrc->bottom - prclSrc->top;

    LONG    XSrcStart = prclSrc->left;
    LONG    XSrcEnd   = prclSrc->right;
    LONG    XDstStart = prclDst->left;
    LONG    XDstEnd   = prclDst->right;
    LONG    YSrcStart = prclSrc->top;
    LONG    YSrcEnd   = prclSrc->bottom;
    LONG    YDstStart = prclDst->top;
    LONG    YDstEnd   = prclDst->bottom;

    //
    // Validate parameters:
    //

    ASSERTDD(pvDst != (VOID*)NULL, "Bad destination bitmap pointer");
    ASSERTDD(pvSrc != (VOID*)NULL, "Bad source bitmap pointer");
    ASSERTDD(prclDst != (RECTL*)NULL, "Bad destination rectangle");
    ASSERTDD(prclSrc != (RECTL*)NULL, "Bad source rectangle");
    ASSERTDD((WidthDst > 0) && (HeightDst > 0) &&
             (WidthSrc > 0) && (HeightSrc > 0),
             "Can't do mirroring or empty rectangles here");
    ASSERTDD((WidthDst  <= STRETCH_MAX_EXTENT) &&
             (HeightDst <= STRETCH_MAX_EXTENT) &&
             (WidthSrc  <= STRETCH_MAX_EXTENT) &&
             (HeightSrc <= STRETCH_MAX_EXTENT), "Stretch exceeds limits");
    ASSERTDD(prclClip != NULL, "Bad clip rectangle");

    //
    // Calculate X Dst to Src mapping
    //
    //
    // dst->src =  ( CEIL( (2k*WidthSrc)/WidthDst) ) / 2k
    //
    //          =  ( FLOOR(  (2k*WidthSrc -1) / WidthDst) + 1) / 2k
    //
    // where 2k = 2 ^ 32
    //

    {
        ULONGLONG   liWidthSrc;
        ULONGLONG   liQuo;
        ULONG       ulTemp;

        //
        // Work around a compiler bug dealing with the assignment
        // 'liHeightSrc = (((LONGLONG)HeightSrc) << 32) - 1':
        //

        liInit.large.LowPart = (ULONG) -1;
        liInit.large.HighPart = WidthSrc - 1;
        liWidthSrc = liInit.li;

        liQuo = liWidthSrc / (ULONGLONG) WidthDst;

        ulXDstToSrcIntCeil  = (ULONG)(liQuo >> 32);
        ulXDstToSrcFracCeil = (ULONG)liQuo;

        //
        // Now add 1, use fake carry:
        //

        ulTemp = ulXDstToSrcFracCeil + 1;

        ulXDstToSrcIntCeil += (ulTemp < ulXDstToSrcFracCeil);
        ulXDstToSrcFracCeil = ulTemp;
    }

    //
    // Calculate Y Dst to Src mapping
    //
    //
    // dst->src =  ( CEIL( (2k*HeightSrc)/HeightDst) ) / 2k
    //
    //          =  ( FLOOR(  (2k*HeightSrc -1) / HeightDst) + 1) / 2k
    //
    // where 2k = 2 ^ 32
    //

    {
        ULONGLONG   liHeightSrc;
        ULONGLONG   liQuo;
        ULONG       ulTemp;

        //
        // Work around a compiler bug dealing with the assignment
        // 'liHeightSrc = (((LONGLONG)HeightSrc) << 32) - 1':
        //

        liInit.large.LowPart = (ULONG) -1;
        liInit.large.HighPart = HeightSrc - 1;
        liHeightSrc = liInit.li;

        liQuo = liHeightSrc / (ULONGLONG) HeightDst;

        ulYDstToSrcIntCeil  = (ULONG)(liQuo >> 32);
        ulYDstToSrcFracCeil = (ULONG)liQuo;

        //
        // Now add 1, use fake carry:
        //

        ulTemp = ulYDstToSrcFracCeil + 1;

        ulYDstToSrcIntCeil += (ulTemp < ulYDstToSrcFracCeil);
        ulYDstToSrcFracCeil = ulTemp;
    }

    //
    // Now clip Dst in X, and/or calc src clipping effect on dst
    //
    // adjust left and right edges if needed, record
    // distance adjusted for fixing the src
    //

    if (XDstStart < prclClip->left)
    {
        XDstStart = prclClip->left;
    }

    if (XDstEnd > prclClip->right)
    {
        XDstEnd = prclClip->right;
    }

    //
    // Check for totally clipped out destination:
    //

    if (XDstEnd <= XDstStart)
    {
        return(TRUE);
    }

    LeftClipDistance = XDstStart - prclDst->left;

    {
        ULONG   ulTempInt;
        ULONG   ulTempFrac;

        //
        // Calculate displacement for .5 in destination and add:
        //

        ulTempFrac = (ulXDstToSrcFracCeil >> 1) | (ulXDstToSrcIntCeil << 31);
        ulTempInt  = (ulXDstToSrcIntCeil >> 1);

        XSrcStart += ulTempInt;
        ulXFracAccumulator = ulTempFrac;

        if (LeftClipDistance != 0)
        {
            ULONGLONG ullFraction;
            ULONG     ulTmp;

            ullFraction = UInt32x32To64(ulXDstToSrcFracCeil, LeftClipDistance);

            ulTmp = ulXFracAccumulator;
            ulXFracAccumulator += (ULONG) (ullFraction);
            if (ulXFracAccumulator < ulTmp)
                XSrcStart++;

            XSrcStart += (ulXDstToSrcIntCeil * LeftClipDistance)
                       + (ULONG) (ullFraction >> 32);
        }
    }

    //
    // Now clip Dst in Y, and/or calc src clipping effect on dst
    //
    // adjust top and bottom edges if needed, record
    // distance adjusted for fixing the src
    //

    if (YDstStart < prclClip->top)
    {
        YDstStart = prclClip->top;
    }

    if (YDstEnd > prclClip->bottom)
    {
        YDstEnd = prclClip->bottom;
    }

    //
    // Check for totally clipped out destination:
    //

    if (YDstEnd <= YDstStart)
    {
        return(TRUE);
    }

    TopClipDistance = YDstStart - prclDst->top;

    {
        ULONG   ulTempInt;
        ULONG   ulTempFrac;

        //
        // Calculate displacement for .5 in destination and add:
        //

        ulTempFrac = (ulYDstToSrcFracCeil >> 1) | (ulYDstToSrcIntCeil << 31);
        ulTempInt  = ulYDstToSrcIntCeil >> 1;

        YSrcStart += (LONG)ulTempInt;
        ulYFracAccumulator = ulTempFrac;

        if (TopClipDistance != 0)
        {
            ULONGLONG ullFraction;
            ULONG     ulTmp;

            ullFraction = UInt32x32To64(ulYDstToSrcFracCeil, TopClipDistance);

            ulTmp = ulYFracAccumulator;
            ulYFracAccumulator += (ULONG) (ullFraction);
            if (ulYFracAccumulator < ulTmp)
                YSrcStart++;

            YSrcStart += (ulYDstToSrcIntCeil * TopClipDistance)
                       + (ULONG) (ullFraction >> 32);
        }
    }

    //
    // Warm up the hardware if doing an expanding stretch in 'y':
    //

    bStretch = (HeightDst > HeightSrc);
    if (bStretch)
    {
        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 4);
        //M64_OD(pjMmBase, CONTEXT_LOAD_CNTL, CONTEXT_LOAD_CmdLoad | ppdev->iDefContext );
        M64_OD(pjMmBase, SRC_OFF_PITCH, ppdev->ulScreenOffsetAndPitch);
        M64_OD(pjMmBase, DP_MIX, OVERPAINT << 16 );
        M64_OD(pjMmBase, DP_SRC, DP_SRC_Blit << 8 );
        M64_OD(pjMmBase, SRC_CNTL, SRC_CNTL_PatEna );
    }

    //
    // Fill out blt structure, then call format-specific stretch code
    //

    StrBlt.ppdev     = ppdev;
    StrBlt.XDstEnd   = XDstEnd;
    StrBlt.YDstStart = YDstStart;
    StrBlt.YDstCount = YDstEnd - YDstStart;

    if (StrBlt.YDstCount > 0)
    {
        //
        // Caclulate starting scan line address.  Since the inner loop
        // routines are format dependent, they must add XDstStart/XSrcStart
        // to pjDstScan/pjSrcScan to get the actual starting pixel address.
        //

        StrBlt.pjSrcScan           = (BYTE*) pvSrc + (YSrcStart * lDeltaSrc);
        StrBlt.pjDstScan           = (BYTE*) pvDst + (YDstStart * lDeltaDst);

        StrBlt.lDeltaSrc           = lDeltaSrc;
        StrBlt.XSrcStart           = XSrcStart;
        StrBlt.XDstStart           = XDstStart;
        StrBlt.lDeltaDst           = lDeltaDst;
        StrBlt.ulXDstToSrcIntCeil  = ulXDstToSrcIntCeil;
        StrBlt.ulXDstToSrcFracCeil = ulXDstToSrcFracCeil;
        StrBlt.ulYDstToSrcIntCeil  = ulYDstToSrcIntCeil;
        StrBlt.ulYDstToSrcFracCeil = ulYDstToSrcFracCeil;
        StrBlt.ulXFracAccumulator  = ulXFracAccumulator;
        StrBlt.ulYFracAccumulator  = ulYFracAccumulator;

        if (ppdev->iBitmapFormat == BMF_8BPP)
        {
            if ((XDstEnd - XDstStart) < 7)
                pfnStr = vDirectStretch8Narrow;
            else
                pfnStr = vM64DirectStretch8;
        }
        else if (ppdev->iBitmapFormat == BMF_16BPP)
        {
            pfnStr = vM64DirectStretch16;
        }
        else
        {
            ASSERTDD(ppdev->iBitmapFormat == BMF_32BPP,
                     "Only handle stretchs at 8, 16 and 32bpp");

            pfnStr = vM64DirectStretch32;
        }

        (*pfnStr)(&StrBlt);
    }

    return(TRUE);
}

BOOL bM32StretchDIB(
PDEV*   ppdev,
VOID*   pvDst,
LONG    lDeltaDst,
RECTL*  prclDst,
VOID*   pvSrc,
LONG    lDeltaSrc,
RECTL*  prclSrc,
RECTL*  prclClip)
{
    STR_BLT StrBlt;
    ULONG   ulXDstToSrcIntCeil;
    ULONG   ulXDstToSrcFracCeil;
    ULONG   ulYDstToSrcIntCeil;
    ULONG   ulYDstToSrcFracCeil;
    ULONG   ulXFracAccumulator;
    ULONG   ulYFracAccumulator;
    LONG    LeftClipDistance;
    LONG    TopClipDistance;
    BOOL    bStretch;
    BYTE*   pjMmBase = ppdev->pjMmBase;

    union {
        LARGE_INTEGER   large;
        ULONGLONG       li;
    } liInit;

    PFN_DIRSTRETCH      pfnStr;

    //
    // Calculate exclusive start and end points:
    //

    LONG    WidthDst  = prclDst->right  - prclDst->left;
    LONG    HeightDst = prclDst->bottom - prclDst->top;
    LONG    WidthSrc  = prclSrc->right  - prclSrc->left;
    LONG    HeightSrc = prclSrc->bottom - prclSrc->top;

    LONG    XSrcStart = prclSrc->left;
    LONG    XSrcEnd   = prclSrc->right;
    LONG    XDstStart = prclDst->left;
    LONG    XDstEnd   = prclDst->right;
    LONG    YSrcStart = prclSrc->top;
    LONG    YSrcEnd   = prclSrc->bottom;
    LONG    YDstStart = prclDst->top;
    LONG    YDstEnd   = prclDst->bottom;

    //
    // Validate parameters:
    //

    ASSERTDD(pvDst != (VOID*)NULL, "Bad destination bitmap pointer");
    ASSERTDD(pvSrc != (VOID*)NULL, "Bad source bitmap pointer");
    ASSERTDD(prclDst != (RECTL*)NULL, "Bad destination rectangle");
    ASSERTDD(prclSrc != (RECTL*)NULL, "Bad source rectangle");
    ASSERTDD((WidthDst > 0) && (HeightDst > 0) &&
             (WidthSrc > 0) && (HeightSrc > 0),
             "Can't do mirroring or empty rectangles here");
    ASSERTDD((WidthDst  <= STRETCH_MAX_EXTENT) &&
             (HeightDst <= STRETCH_MAX_EXTENT) &&
             (WidthSrc  <= STRETCH_MAX_EXTENT) &&
             (HeightSrc <= STRETCH_MAX_EXTENT), "Stretch exceeds limits");
    ASSERTDD(prclClip != NULL, "Bad clip rectangle");

    //
    // Calculate X Dst to Src mapping
    //
    //
    // dst->src =  ( CEIL( (2k*WidthSrc)/WidthDst) ) / 2k
    //
    //          =  ( FLOOR(  (2k*WidthSrc -1) / WidthDst) + 1) / 2k
    //
    // where 2k = 2 ^ 32
    //

    {
        ULONGLONG   liWidthSrc;
        ULONGLONG   liQuo;
        ULONG       ulTemp;

        //
        // Work around a compiler bug dealing with the assignment
        // 'liHeightSrc = (((LONGLONG)HeightSrc) << 32) - 1':
        //

        liInit.large.LowPart = (ULONG) -1;
        liInit.large.HighPart = WidthSrc - 1;
        liWidthSrc = liInit.li;

        liQuo = liWidthSrc / (ULONGLONG) WidthDst;

        ulXDstToSrcIntCeil  = (ULONG)(liQuo >> 32);
        ulXDstToSrcFracCeil = (ULONG)liQuo;

        //
        // Now add 1, use fake carry:
        //

        ulTemp = ulXDstToSrcFracCeil + 1;

        ulXDstToSrcIntCeil += (ulTemp < ulXDstToSrcFracCeil);
        ulXDstToSrcFracCeil = ulTemp;
    }

    //
    // Calculate Y Dst to Src mapping
    //
    //
    // dst->src =  ( CEIL( (2k*HeightSrc)/HeightDst) ) / 2k
    //
    //          =  ( FLOOR(  (2k*HeightSrc -1) / HeightDst) + 1) / 2k
    //
    // where 2k = 2 ^ 32
    //

    {
        ULONGLONG   liHeightSrc;
        ULONGLONG   liQuo;
        ULONG       ulTemp;

        //
        // Work around a compiler bug dealing with the assignment
        // 'liHeightSrc = (((LONGLONG)HeightSrc) << 32) - 1':
        //

        liInit.large.LowPart = (ULONG) -1;
        liInit.large.HighPart = HeightSrc - 1;
        liHeightSrc = liInit.li;

        liQuo = liHeightSrc / (ULONGLONG) HeightDst;

        ulYDstToSrcIntCeil  = (ULONG)(liQuo >> 32);
        ulYDstToSrcFracCeil = (ULONG)liQuo;

        //
        // Now add 1, use fake carry:
        //

        ulTemp = ulYDstToSrcFracCeil + 1;

        ulYDstToSrcIntCeil += (ulTemp < ulYDstToSrcFracCeil);
        ulYDstToSrcFracCeil = ulTemp;
    }

    //
    // Now clip Dst in X, and/or calc src clipping effect on dst
    //
    // adjust left and right edges if needed, record
    // distance adjusted for fixing the src
    //

    if (XDstStart < prclClip->left)
    {
        XDstStart = prclClip->left;
    }

    if (XDstEnd > prclClip->right)
    {
        XDstEnd = prclClip->right;
    }

    //
    // Check for totally clipped out destination:
    //

    if (XDstEnd <= XDstStart)
    {
        return(TRUE);
    }

    LeftClipDistance = XDstStart - prclDst->left;

    {
        ULONG   ulTempInt;
        ULONG   ulTempFrac;

        //
        // Calculate displacement for .5 in destination and add:
        //

        ulTempFrac = (ulXDstToSrcFracCeil >> 1) | (ulXDstToSrcIntCeil << 31);
        ulTempInt  = (ulXDstToSrcIntCeil >> 1);

        XSrcStart += ulTempInt;
        ulXFracAccumulator = ulTempFrac;

        if (LeftClipDistance != 0)
        {
            ULONGLONG ullFraction;
            ULONG     ulTmp;

            ullFraction = UInt32x32To64(ulXDstToSrcFracCeil, LeftClipDistance);

            ulTmp = ulXFracAccumulator;
            ulXFracAccumulator += (ULONG) (ullFraction);
            if (ulXFracAccumulator < ulTmp)
                XSrcStart++;

            XSrcStart += (ulXDstToSrcIntCeil * LeftClipDistance)
                       + (ULONG) (ullFraction >> 32);
        }
    }

    //
    // Now clip Dst in Y, and/or calc src clipping effect on dst
    //
    // adjust top and bottom edges if needed, record
    // distance adjusted for fixing the src
    //

    if (YDstStart < prclClip->top)
    {
        YDstStart = prclClip->top;
    }

    if (YDstEnd > prclClip->bottom)
    {
        YDstEnd = prclClip->bottom;
    }

    //
    // Check for totally clipped out destination:
    //

    if (YDstEnd <= YDstStart)
    {
        return(TRUE);
    }

    TopClipDistance = YDstStart - prclDst->top;

    {
        ULONG   ulTempInt;
        ULONG   ulTempFrac;

        //
        // Calculate displacement for .5 in destination and add:
        //

        ulTempFrac = (ulYDstToSrcFracCeil >> 1) | (ulYDstToSrcIntCeil << 31);
        ulTempInt  = ulYDstToSrcIntCeil >> 1;

        YSrcStart += (LONG)ulTempInt;
        ulYFracAccumulator = ulTempFrac;

        if (TopClipDistance != 0)
        {
            ULONGLONG ullFraction;
            ULONG     ulTmp;

            ullFraction = UInt32x32To64(ulYDstToSrcFracCeil, TopClipDistance);

            ulTmp = ulYFracAccumulator;
            ulYFracAccumulator += (ULONG) (ullFraction);
            if (ulYFracAccumulator < ulTmp)
                YSrcStart++;

            YSrcStart += (ulYDstToSrcIntCeil * TopClipDistance)
                       + (ULONG) (ullFraction >> 32);
        }
    }

    //
    // Warm up the hardware if doing an expanding stretch in 'y':
    //

    bStretch = (HeightDst > HeightSrc);
    if (bStretch)
    {
        M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 3);
        M32_OW(pjMmBase, DP_CONFIG, 0x6011 );
        M32_OW(pjMmBase, ALU_FG_FN, OVERPAINT );
        M32_OW(pjMmBase, SRC_Y_DIR, 1 );
    }

    //
    // Fill out blt structure, then call format-specific stretch code
    //

    StrBlt.ppdev     = ppdev;
    StrBlt.XDstEnd   = XDstEnd;
    StrBlt.YDstStart = YDstStart;
    StrBlt.YDstCount = YDstEnd - YDstStart;

    if (StrBlt.YDstCount > 0)
    {
        //
        // Caclulate starting scan line address.  Since the inner loop
        // routines are format dependent, they must add XDstStart/XSrcStart
        // to pjDstScan/pjSrcScan to get the actual starting pixel address.
        //

        StrBlt.pjSrcScan           = (BYTE*) pvSrc + (YSrcStart * lDeltaSrc);
        StrBlt.pjDstScan           = (BYTE*) pvDst + (YDstStart * lDeltaDst);

        StrBlt.lDeltaSrc           = lDeltaSrc;
        StrBlt.XSrcStart           = XSrcStart;
        StrBlt.XDstStart           = XDstStart;
        StrBlt.lDeltaDst           = lDeltaDst;
        StrBlt.ulXDstToSrcIntCeil  = ulXDstToSrcIntCeil;
        StrBlt.ulXDstToSrcFracCeil = ulXDstToSrcFracCeil;
        StrBlt.ulYDstToSrcIntCeil  = ulYDstToSrcIntCeil;
        StrBlt.ulYDstToSrcFracCeil = ulYDstToSrcFracCeil;
        StrBlt.ulXFracAccumulator  = ulXFracAccumulator;
        StrBlt.ulYFracAccumulator  = ulYFracAccumulator;

        if (ppdev->iBitmapFormat == BMF_8BPP)
        {
            if ((XDstEnd - XDstStart) < 7)
                pfnStr = vDirectStretch8Narrow;
            else
                pfnStr = vM32DirectStretch8;
        }
        else if (ppdev->iBitmapFormat == BMF_16BPP)
        {
            pfnStr = vM32DirectStretch16;
        }
        else
        {
            return FALSE;   // should never come here.
        }

        (*pfnStr)(&StrBlt);
    }

    return(TRUE);
}

BOOL bI32StretchDIB(
PDEV*   ppdev,
VOID*   pvDst,
LONG    lDeltaDst,
RECTL*  prclDst,
VOID*   pvSrc,
LONG    lDeltaSrc,
RECTL*  prclSrc,
RECTL*  prclClip)
{
    STR_BLT StrBlt;
    ULONG   ulXDstToSrcIntCeil;
    ULONG   ulXDstToSrcFracCeil;
    ULONG   ulYDstToSrcIntCeil;
    ULONG   ulYDstToSrcFracCeil;
    ULONG   ulXFracAccumulator;
    ULONG   ulYFracAccumulator;
    LONG    LeftClipDistance;
    LONG    TopClipDistance;
    BOOL    bStretch;
    BYTE*   pjIoBase = ppdev->pjIoBase;

    union {
        LARGE_INTEGER   large;
        ULONGLONG       li;
    } liInit;

    PFN_DIRSTRETCH      pfnStr;

    //
    // Calculate exclusive start and end points:
    //

    LONG    WidthDst  = prclDst->right  - prclDst->left;
    LONG    HeightDst = prclDst->bottom - prclDst->top;
    LONG    WidthSrc  = prclSrc->right  - prclSrc->left;
    LONG    HeightSrc = prclSrc->bottom - prclSrc->top;

    LONG    XSrcStart = prclSrc->left;
    LONG    XSrcEnd   = prclSrc->right;
    LONG    XDstStart = prclDst->left;
    LONG    XDstEnd   = prclDst->right;
    LONG    YSrcStart = prclSrc->top;
    LONG    YSrcEnd   = prclSrc->bottom;
    LONG    YDstStart = prclDst->top;
    LONG    YDstEnd   = prclDst->bottom;

    //
    // Validate parameters:
    //

    ASSERTDD(pvDst != (VOID*)NULL, "Bad destination bitmap pointer");
    ASSERTDD(pvSrc != (VOID*)NULL, "Bad source bitmap pointer");
    ASSERTDD(prclDst != (RECTL*)NULL, "Bad destination rectangle");
    ASSERTDD(prclSrc != (RECTL*)NULL, "Bad source rectangle");
    ASSERTDD((WidthDst > 0) && (HeightDst > 0) &&
             (WidthSrc > 0) && (HeightSrc > 0),
             "Can't do mirroring or empty rectangles here");
    ASSERTDD((WidthDst  <= STRETCH_MAX_EXTENT) &&
             (HeightDst <= STRETCH_MAX_EXTENT) &&
             (WidthSrc  <= STRETCH_MAX_EXTENT) &&
             (HeightSrc <= STRETCH_MAX_EXTENT), "Stretch exceeds limits");
    ASSERTDD(prclClip != NULL, "Bad clip rectangle");

    //
    // Calculate X Dst to Src mapping
    //
    //
    // dst->src =  ( CEIL( (2k*WidthSrc)/WidthDst) ) / 2k
    //
    //          =  ( FLOOR(  (2k*WidthSrc -1) / WidthDst) + 1) / 2k
    //
    // where 2k = 2 ^ 32
    //

    {
        ULONGLONG   liWidthSrc;
        ULONGLONG   liQuo;
        ULONG       ulTemp;

        //
        // Work around a compiler bug dealing with the assignment
        // 'liHeightSrc = (((LONGLONG)HeightSrc) << 32) - 1':
        //

        liInit.large.LowPart = (ULONG) -1;
        liInit.large.HighPart = WidthSrc - 1;
        liWidthSrc = liInit.li;

        liQuo = liWidthSrc / (ULONGLONG) WidthDst;

        ulXDstToSrcIntCeil  = (ULONG)(liQuo >> 32);
        ulXDstToSrcFracCeil = (ULONG)liQuo;

        //
        // Now add 1, use fake carry:
        //

        ulTemp = ulXDstToSrcFracCeil + 1;

        ulXDstToSrcIntCeil += (ulTemp < ulXDstToSrcFracCeil);
        ulXDstToSrcFracCeil = ulTemp;
    }

    //
    // Calculate Y Dst to Src mapping
    //
    //
    // dst->src =  ( CEIL( (2k*HeightSrc)/HeightDst) ) / 2k
    //
    //          =  ( FLOOR(  (2k*HeightSrc -1) / HeightDst) + 1) / 2k
    //
    // where 2k = 2 ^ 32
    //

    {
        ULONGLONG   liHeightSrc;
        ULONGLONG   liQuo;
        ULONG       ulTemp;

        //
        // Work around a compiler bug dealing with the assignment
        // 'liHeightSrc = (((LONGLONG)HeightSrc) << 32) - 1':
        //

        liInit.large.LowPart = (ULONG) -1;
        liInit.large.HighPart = HeightSrc - 1;
        liHeightSrc = liInit.li;

        liQuo = liHeightSrc / (ULONGLONG) HeightDst;

        ulYDstToSrcIntCeil  = (ULONG)(liQuo >> 32);
        ulYDstToSrcFracCeil = (ULONG)liQuo;

        //
        // Now add 1, use fake carry:
        //

        ulTemp = ulYDstToSrcFracCeil + 1;

        ulYDstToSrcIntCeil += (ulTemp < ulYDstToSrcFracCeil);
        ulYDstToSrcFracCeil = ulTemp;
    }

    //
    // Now clip Dst in X, and/or calc src clipping effect on dst
    //
    // adjust left and right edges if needed, record
    // distance adjusted for fixing the src
    //

    if (XDstStart < prclClip->left)
    {
        XDstStart = prclClip->left;
    }

    if (XDstEnd > prclClip->right)
    {
        XDstEnd = prclClip->right;
    }

    //
    // Check for totally clipped out destination:
    //

    if (XDstEnd <= XDstStart)
    {
        return(TRUE);
    }

    LeftClipDistance = XDstStart - prclDst->left;

    {
        ULONG   ulTempInt;
        ULONG   ulTempFrac;

        //
        // Calculate displacement for .5 in destination and add:
        //

        ulTempFrac = (ulXDstToSrcFracCeil >> 1) | (ulXDstToSrcIntCeil << 31);
        ulTempInt  = (ulXDstToSrcIntCeil >> 1);

        XSrcStart += ulTempInt;
        ulXFracAccumulator = ulTempFrac;

        if (LeftClipDistance != 0)
        {
            ULONGLONG ullFraction;
            ULONG     ulTmp;

            ullFraction = UInt32x32To64(ulXDstToSrcFracCeil, LeftClipDistance);

            ulTmp = ulXFracAccumulator;
            ulXFracAccumulator += (ULONG) (ullFraction);
            if (ulXFracAccumulator < ulTmp)
                XSrcStart++;

            XSrcStart += (ulXDstToSrcIntCeil * LeftClipDistance)
                       + (ULONG) (ullFraction >> 32);
        }
    }

    //
    // Now clip Dst in Y, and/or calc src clipping effect on dst
    //
    // adjust top and bottom edges if needed, record
    // distance adjusted for fixing the src
    //

    if (YDstStart < prclClip->top)
    {
        YDstStart = prclClip->top;
    }

    if (YDstEnd > prclClip->bottom)
    {
        YDstEnd = prclClip->bottom;
    }

    //
    // Check for totally clipped out destination:
    //

    if (YDstEnd <= YDstStart)
    {
        return(TRUE);
    }

    TopClipDistance = YDstStart - prclDst->top;

    {
        ULONG   ulTempInt;
        ULONG   ulTempFrac;

        //
        // Calculate displacement for .5 in destination and add:
        //

        ulTempFrac = (ulYDstToSrcFracCeil >> 1) | (ulYDstToSrcIntCeil << 31);
        ulTempInt  = ulYDstToSrcIntCeil >> 1;

        YSrcStart += (LONG)ulTempInt;
        ulYFracAccumulator = ulTempFrac;

        if (TopClipDistance != 0)
        {
            ULONGLONG ullFraction;
            ULONG     ulTmp;

            ullFraction = UInt32x32To64(ulYDstToSrcFracCeil, TopClipDistance);

            ulTmp = ulYFracAccumulator;
            ulYFracAccumulator += (ULONG) (ullFraction);
            if (ulYFracAccumulator < ulTmp)
                YSrcStart++;

            YSrcStart += (ulYDstToSrcIntCeil * TopClipDistance)
                       + (ULONG) (ullFraction >> 32);
        }
    }

    //
    // Warm up the hardware if doing an expanding stretch in 'y':
    //

    bStretch = (HeightDst > HeightSrc);
    if (bStretch)
    {
        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 3);
        I32_OW(pjIoBase, DP_CONFIG, 0x6011 );
        I32_OW(pjIoBase, ALU_FG_FN, OVERPAINT );
        I32_OW(pjIoBase, SRC_Y_DIR, 1 );
    }

    //
    // Fill out blt structure, then call format-specific stretch code
    //

    StrBlt.ppdev     = ppdev;
    StrBlt.XDstEnd   = XDstEnd;
    StrBlt.YDstStart = YDstStart;
    StrBlt.YDstCount = YDstEnd - YDstStart;

    if (StrBlt.YDstCount > 0)
    {
        //
        // Caclulate starting scan line address.  Since the inner loop
        // routines are format dependent, they must add XDstStart/XSrcStart
        // to pjDstScan/pjSrcScan to get the actual starting pixel address.
        //

        StrBlt.pjSrcScan           = (BYTE*) pvSrc + (YSrcStart * lDeltaSrc);
        StrBlt.pjDstScan           = (BYTE*) pvDst + (YDstStart * lDeltaDst);

        StrBlt.lDeltaSrc           = lDeltaSrc;
        StrBlt.XSrcStart           = XSrcStart;
        StrBlt.XDstStart           = XDstStart;
        StrBlt.lDeltaDst           = lDeltaDst;
        StrBlt.ulXDstToSrcIntCeil  = ulXDstToSrcIntCeil;
        StrBlt.ulXDstToSrcFracCeil = ulXDstToSrcFracCeil;
        StrBlt.ulYDstToSrcIntCeil  = ulYDstToSrcIntCeil;
        StrBlt.ulYDstToSrcFracCeil = ulYDstToSrcFracCeil;
        StrBlt.ulXFracAccumulator  = ulXFracAccumulator;
        StrBlt.ulYFracAccumulator  = ulYFracAccumulator;

        if (ppdev->iBitmapFormat == BMF_8BPP)
        {
            if ((XDstEnd - XDstStart) < 7)
                pfnStr = vDirectStretch8Narrow;
            else
                pfnStr = vI32DirectStretch8;
        }
        else if (ppdev->iBitmapFormat == BMF_16BPP)
        {
            pfnStr = vI32DirectStretch16;
        }
        else
        {
            return FALSE;   // should never come here.
        }

        (*pfnStr)(&StrBlt);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bBankedStretch
*
\**************************************************************************/

BOOL bBankedStretch(
PDEV*   ppdev,
VOID*   pvDst,
LONG    lDeltaDst,
RECTL*  prclDst,
VOID*   pvSrc,
LONG    lDeltaSrc,
RECTL*  prclSrc,
RECTL*  prclClip)
{
    BANK    bnk;
    BOOL    b;
    RECTL   rclDst;

    b = TRUE;
    if (bIntersect(prclDst, prclClip, &rclDst))
    {
        vBankStart(ppdev, &rclDst, NULL, &bnk);

        do {
            b &= ppdev->pfnStretchDIB(ppdev,
                             bnk.pso->pvScan0,
                             lDeltaDst,
                             prclDst,
                             pvSrc,
                             lDeltaSrc,
                             prclSrc,
                             &bnk.pco->rclBounds);

        } while (bBankEnum(&bnk));
    }

    return(b);
}

/******************************Public*Routine******************************\
* BOOL DrvStretchBlt
*
\**************************************************************************/

#if defined(ALPHA)
    #define DENSE(ppdev)        (ppdev->FeatureFlags & EVN_DENSE_CAPABLE)
#else
    #define DENSE(ppdev)        (ppdev->iAperture != APERTURE_NONE)
#endif

BOOL DrvStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMsk,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMsk,
ULONG               iMode)
{
    DSURF*  pdsurfSrc;
    DSURF*  pdsurfDst;
    PDEV*   ppdev;
    OH*     poh;

    // GDI guarantees us that for a StretchBlt the destination surface
    // will always be a device surface, and not a DIB:

    ppdev = (PDEV*) psoDst->dhpdev;

    // It's quicker for GDI to do a StretchBlt when the source surface
    // is not a device-managed surface, because then it can directly
    // read the source bits without having to allocate a temporary
    // buffer and call DrvCopyBits to get a copy that it can use.

    if (psoSrc->iType == STYPE_DEVBITMAP)
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        if (pdsurfSrc->dt == DT_SCREEN)
            goto Punt_It;

        ASSERTDD(pdsurfSrc->dt == DT_DIB, "Can only handle DIB DFBs here");

        psoSrc = pdsurfSrc->pso;
    }

    pdsurfDst = (DSURF*) psoDst->dhsurf;
    if (pdsurfDst->dt == DT_DIB)
    {
        // The destination was a device bitmap that we just converted
        // to a DIB:

        psoDst = pdsurfDst->pso;
        goto Punt_It;
    }

    poh             = pdsurfDst->poh;
    ppdev->xOffset  = poh->x;
    ppdev->yOffset  = poh->y;

    // Our special-case StretchBlt code assumes a dense frame buffer
    // space, so this code can't be executed when using sparse space
    // on the Alpha.  Note that since we don't read from the frame
    // buffer, we can allow this to go through even when
    // CAPS_NO_DIRECT_ACCESS is set on the PPC.
    //
    // Also, because of the VTA4 screen source FIFO problem, we punt
    // stretch blits for the VTA4.

    if (DENSE(ppdev) && !(ppdev->FeatureFlags & EVN_SDRAM_1M))
    {
        RECTL       rclClip;
        RECTL*      prclClip;
        ULONG       cxDst;
        ULONG       cyDst;
        ULONG       cxSrc;
        ULONG       cySrc;
        BOOL        bMore;
        CLIPENUM    ce;
        LONG        c;
        LONG        i;

        if ((psoSrc->iType == STYPE_BITMAP) &&
            (psoMsk == NULL) &&
            ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)) &&
            ((psoSrc->iBitmapFormat == ppdev->iBitmapFormat)) &&
            (ppdev->iBitmapFormat != BMF_24BPP))
        {
            cxDst = prclDst->right - prclDst->left;
            cyDst = prclDst->bottom - prclDst->top;
            cxSrc = prclSrc->right - prclSrc->left;
            cySrc = prclSrc->bottom - prclSrc->top;

            // Our 'bStretchDIB' routine requires that the stretch be
            // non-inverting, within a certain size, to have no source
            // clipping, and to have no empty rectangles (the latter is the
            // reason for the '- 1' on the unsigned compare here):

            if (((cxSrc - 1) < STRETCH_MAX_EXTENT)         &&
                ((cySrc - 1) < STRETCH_MAX_EXTENT)         &&
                ((cxDst - 1) < STRETCH_MAX_EXTENT)         &&
                ((cyDst - 1) < STRETCH_MAX_EXTENT)         &&
                (prclSrc->left   >= 0)                     &&
                (prclSrc->top    >= 0)                     &&
                (prclSrc->right  <= psoSrc->sizlBitmap.cx) &&
                (prclSrc->bottom <= psoSrc->sizlBitmap.cy))
            {
                // Our snazzy routine only does COLORONCOLOR.  But for
                // stretching blts, BLACKONWHITE and WHITEONBLACK are also
                // equivalent to COLORONCOLOR:

                if ((iMode == COLORONCOLOR) ||
                    ((iMode < COLORONCOLOR) && (cxSrc <= cxDst) && (cySrc <= cyDst)))
                {
                    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
                    {
                        rclClip.left   = 0;
                        rclClip.top    = 0;
                        rclClip.right  = poh->cx;
                        rclClip.bottom = poh->cy;   // Extents of surface
                        prclClip = &rclClip;

                    StretchSingleClipRect:

                        if (bBankedStretch(ppdev,
                                        NULL,
                                        ppdev->lDelta,
                                        prclDst,
                                        psoSrc->pvScan0,
                                        psoSrc->lDelta,
                                        prclSrc,
                                        prclClip))
                        {
                            return(TRUE);
                        }
                    }
                    else if (pco->iDComplexity == DC_RECT)
                    {
                        prclClip = &pco->rclBounds;
                        goto StretchSingleClipRect;
                    }
                    else
                    {
                        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                        do {
                            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                            c = cIntersect(prclDst, ce.arcl, ce.c);

                            if (c != 0)
                            {
                                for (i = 0; i < c; i++)
                                {
                                    if (!bBankedStretch(ppdev,
                                                     NULL,
                                                     ppdev->lDelta,
                                                     prclDst,
                                                     psoSrc->pvScan0,
                                                     psoSrc->lDelta,
                                                     prclSrc,
                                                     &ce.arcl[i]))
                                    {
                                        goto Punt_It;
                                    }
                                }
                            }

                        } while (bMore);

                        return(TRUE);
                    }
                }
            }
        }
    }

Punt_It:

    // GDI is nice enough to handle the cases where 'psoDst' and/or 'psoSrc'
    // are device-managed surfaces, but it ain't gonna be fast...

    return(EngStretchBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca, pptlHTOrg,
                         prclDst, prclSrc, pptlMsk, iMode));
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\pointer.c ===
/******************************Module*Header*******************************\
* Module Name: pointer.c
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

//
// This will disable the sync with vertical retrace. Stress tests are failing with v-sync enabled.
//

#define NO_VERTICAL_SYNC

BOOL flag_shape;
BYTE HardWareCursorShape [CURSOR_CX][CURSOR_CY] ;

// BEGIN MACH32 ----------------------------------------------------------------

VOID vI32SetCursorOffset(PDEV *ppdev)
{
    BYTE    mem;
    BYTE    bytes_pp;
    ULONG   vga_mem;
    LONG    width;
    LONG    height;
    LONG    depth;

    height = ppdev->ppointer->hwCursor.y;
    depth = ppdev->cBitsPerPel;
    width = ppdev->lDelta / depth;

    mem = (BYTE) I32_IB(ppdev->pjIoBase, MEM_BNDRY);

    if(mem&0x10)
    {
        vga_mem=(ULONG)(mem&0xf);
        vga_mem=0x40000*vga_mem;   /* vga boundary is enabled */
    }
    else
    {
        vga_mem=0;
    }

    switch(depth)
    {
    case    32:
        bytes_pp=8;
        break;

    case    24:
        bytes_pp=6;
        break;

    case    16:
        bytes_pp=4;
        break;

    case    8:
        bytes_pp=2;
        break;

    case    4:
        bytes_pp=1;
        break;
    }

    ppdev->ppointer->mono_offset = (vga_mem +
                         ((ULONG)height*(ULONG)width*(ULONG)bytes_pp));
#if 0
    DbgOut("Height %x\n", height);
    DbgOut("Height %x\n", width);
    DbgOut("Height %x\n", bytes_pp);
    DbgOut("Mono Offset %x\n", ppdev->ppointer->mono_offset);
#endif
}

VOID  vI32UpdateCursorOffset(
PDEV *ppdev,
LONG lXOffset,
LONG lYOffset,
LONG lCurOffset)
{
    PBYTE pjIoBase = ppdev->pjIoBase;

    I32_OW_DIRECT(pjIoBase, CURSOR_OFFSET_HI, 0) ;
    I32_OW_DIRECT(pjIoBase, HORZ_CURSOR_OFFSET, (lXOffset & 0xff) | (lYOffset << 8));
    I32_OW_DIRECT(pjIoBase, CURSOR_OFFSET_LO, (WORD)lCurOffset) ;
    I32_OW_DIRECT(pjIoBase, CURSOR_OFFSET_HI, (lCurOffset >> 16) | 0x8000) ;
}

VOID  vI32UpdateCursorPosition(
PDEV *ppdev,
LONG x,
LONG y)
{
    PBYTE pjIoBase = ppdev->pjIoBase;

    I32_OW_DIRECT(pjIoBase, HORZ_CURSOR_POSN, x);      /* set base of cursor to X */
    I32_OW_DIRECT(pjIoBase, VERT_CURSOR_POSN, y);      /* set base of cursor to Y */
}

VOID vI32CursorOff(PDEV *ppdev)
{
    I32_OW_DIRECT(ppdev->pjIoBase, CURSOR_OFFSET_HI, 0);
}

VOID vI32CursorOn(PDEV *ppdev, LONG lCurOffset)
{
    I32_OW_DIRECT(ppdev->pjIoBase, CURSOR_OFFSET_HI, (lCurOffset >> 16) | 0x8000) ;
}

VOID vI32PointerBlit(
PDEV* ppdev,
LONG x,
LONG y,
LONG cx,
LONG cy,
PBYTE pbsrc,
LONG lDelta)
{
    BYTE* pjIoBase = ppdev->pjIoBase;
    WORD wCmd;
    WORD wWords;
    WORD wPixels;
    UINT i;

    wWords = (WORD)(cx + 15) / 16;
    wPixels = (WORD) (wWords*16L/ppdev->cBitsPerPel);

    wCmd = FG_COLOR_SRC_HOST | DRAW | WRITE | DATA_WIDTH | LSB_FIRST;

    I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 7);
    I32_OW(pjIoBase, ALU_FG_FN, OVERPAINT);
    I32_OW(pjIoBase, DP_CONFIG, wCmd);

    I32_OW(pjIoBase, DEST_X_START, LOWORD(x));
    I32_OW(pjIoBase, CUR_X, LOWORD(x));
    I32_OW(pjIoBase, DEST_X_END, LOWORD(x) + wPixels);

    I32_OW(pjIoBase, CUR_Y, LOWORD(y));
    I32_OW(pjIoBase, DEST_Y_END, (LOWORD(y) + 1));

    for (i=0; i < (UINT) wWords; i++)
    {
        if (i % 8 == 0)
            I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 10);

        I32_OW(pjIoBase, PIX_TRANS, *((USHORT UNALIGNED *)pbsrc)++ );
    }
}

VOID vPointerBlitLFB(
PDEV* ppdev,
LONG x,
LONG y,
LONG cx,
LONG cy,
PBYTE pbsrc,
LONG lDelta)
{
    BYTE* pjDst;

    ASSERTDD(ppdev->iBitmapFormat == BMF_24BPP, "BMF should be 24 here\n");

    pjDst = ppdev->pjScreen + ppdev->lDelta * y + x * 3;

    //
    // Set cx equal to number of bytes.
    //

    cx >>= 3;

    while (cy-- > 0)
    {
        memcpy( pjDst, pbsrc, cx);
        pjDst += cx;
        pbsrc += lDelta;
    }
}

// END MACH32 ------------------------------------------------------------------

// BEGIN MACH64 ----------------------------------------------------------------

BOOLEAN flag_enable=FALSE;

/*
----------------------------------------------------------------------
--  NAME: vDacRegs
--
--  DESCRIPTION:
--      Calculate DAC regsiter I/O locations
--
----------------------------------------------------------------------
*/

_inline VOID vDacRegs(PDEV* ppdev, UCHAR** ucReg, UCHAR** ucCntl)
{
    if (ppdev->FeatureFlags & EVN_PACKED_IO)
        {
        *ucReg  = (ppdev->pjIoBase + DAC_REGS*4);
        *ucCntl = (ppdev->pjIoBase + DAC_CNTL*4);
        }
    else
        {
        *ucReg  = (ppdev->pjIoBase + ioDAC_REGS - ioBASE);
        *ucCntl = (ppdev->pjIoBase + ioDAC_CNTL - ioBASE);
        }
}

VOID  vM64SetCursorOffset(PDEV* ppdev)
{
    LONG    bytes_pp;
    LONG    width;
    LONG    height;
    LONG    depth;

    height = ppdev->ppointer->hwCursor.y;
    depth = ppdev->cBitsPerPel;
    width = ppdev->lDelta / depth;


    switch(depth)
    {
    case    32:
        bytes_pp=8;
        break;

    case    24:
        bytes_pp=6;
        break;

    case    16:
        bytes_pp=4;
        break;

    case    8:
        bytes_pp=2;
        break;

    case    4:
        bytes_pp=1;
        break;
    }

    ppdev->ppointer->mono_offset = (ULONG)height*(ULONG)width*(ULONG)bytes_pp;
    ppdev->ppointer->mono_offset += ppdev->ulVramOffset*2;
}

VOID  vM64UpdateCursorOffset(
PDEV* ppdev,
LONG lXOffset,
LONG lYOffset,
LONG lCurOffset)
{
    BYTE* pjMmBase = ppdev->pjMmBase;

    ppdev->pfnCursorOff(ppdev);
    M64_OD_DIRECT(pjMmBase,CUR_OFFSET, lCurOffset >> 1);
    M64_OD_DIRECT(pjMmBase,CUR_HORZ_VERT_OFF, lXOffset | (lYOffset << 16));
    ppdev->pfnCursorOn(ppdev, lCurOffset);
}

VOID  vM64UpdateCursorPosition(
PDEV* ppdev,
LONG x,
LONG y)
{
    M64_OD_DIRECT(ppdev->pjMmBase, CUR_HORZ_VERT_POSN, x | (y << 16));
}

VOID vM64CursorOff(PDEV* ppdev)
{
    BYTE* pjMmBase = ppdev->pjMmBase;
    ULONG ldata;

#ifndef NO_VERTICAL_SYNC

    ULONG ldata1;

    // Read the no. of total verticales lines (including the overscan)
    ldata1 = M64_ID(pjMmBase,CRTC_V_TOTAL_DISP);
    ldata1 = ldata1&0x7ff;

again:
    //read the current verticale line
    ldata = M64_ID(pjMmBase,CRTC_CRNT_VLINE);
    ldata = (ldata&0x7ff0000)>>16;

    //synchronise the drawing with the vertical line
    if (ldata >= (ldata1-3))
    {

#endif  // !NO_VERTICAL_SYNC

        //Disable the hardware cursor
        ldata = M64_ID(pjMmBase,GEN_TEST_CNTL);
        M64_OD_DIRECT(pjMmBase, GEN_TEST_CNTL, ldata  & ~GEN_TEST_CNTL_CursorEna);

#ifndef NO_VERTICAL_SYNC

    }
    else
    {
        goto again;
    }

#endif  // !NO_VERTICAL_SYNC

}

VOID vM64CursorOn(PDEV* ppdev, LONG lCurOffset)
{
    BYTE* pjMmBase = ppdev->pjMmBase;
    ULONG ldata;

#ifndef NO_VERTICAL_SYNC

    ULONG ldata1;

#endif  // !NO_VERTICAL_SYNC

    if (!flag_enable)
        {
        flag_enable=TRUE;
        ldata = M64_ID(pjMmBase,GEN_TEST_CNTL);
        M64_OD_DIRECT(pjMmBase, GEN_TEST_CNTL, ldata  | GEN_TEST_CNTL_CursorEna);
        }

#ifndef NO_VERTICAL_SYNC

    /*
     * Read the no. of total vertical lines (including the overscan)
     */
    ldata1 = M64_ID(pjMmBase,CRTC_V_TOTAL_DISP);
    ldata1 = ldata1&0x7ff;

    again:
    /*
     * read the current vertical line
     */
    ldata = M64_ID(pjMmBase,CRTC_CRNT_VLINE);
    ldata = (ldata&0x7ff0000)>>16;

    /*
     * Synchronise the drawing of cursor
     */
    if (ldata >= (ldata1-3))
    {

#endif  // !NO_VERTICAL_SYNC

        ppdev->pfnUpdateCursorPosition(ppdev,ppdev->ppointer->ptlLastPosition.x+0,ppdev->ppointer->ptlLastPosition.y+0);
        ldata = M64_ID(pjMmBase,GEN_TEST_CNTL);
        M64_OD_DIRECT(pjMmBase, GEN_TEST_CNTL, ldata  | GEN_TEST_CNTL_CursorEna);

#ifndef NO_VERTICAL_SYNC

    }
    else
    {
        goto again;
    }

#endif  // !NO_VERTICAL_SYNC

}

VOID  vM64SetCursorOffset_TVP(PDEV* ppdev)
{
}

VOID  vM64UpdateCursorOffset_TVP(
PDEV* ppdev,
LONG lXOffset,
LONG lYOffset,
LONG lCurOffset)
{
    ppdev->ppointer->ptlLastOffset.x=lXOffset;
    ppdev->ppointer->ptlLastOffset.y=lYOffset;

    /* Change the offset... used in UpdateCursorPosition */
}

VOID  vM64UpdateCursorPosition_TVP(
PDEV* ppdev,
LONG x,
LONG y)
{
    BYTE* pjMmBase = ppdev->pjMmBase;
    ULONG dacRead;

    //DbgOut("\nvUpdateCursorPosition_TVP_M64 called");

    ppdev->ppointer->ptlLastPosition.y=y;
    ppdev->ppointer->ptlLastPosition.x=x;

    // Note: SetCursorOffset, UpdateCursorOffset must set ptlLastOffset
    x+= 64-ppdev->ppointer->ptlLastOffset.x;
    y+= 64-ppdev->ppointer->ptlLastOffset.y;

    // check for coordinate violations
    if (x < 0) x = 0;
    if (y < 0) y = 0;

    dacRead = M64_ID(pjMmBase,DAC_CNTL);
    M64_OD_DIRECT(pjMmBase, DAC_CNTL, (dacRead & 0xfffffffc) | 3);
    M64_OD_DIRECT(pjMmBase, DAC_REGS+REG_W, (y<<16) | x);
    dacRead = M64_ID(pjMmBase,DAC_CNTL);
    M64_OD_DIRECT(pjMmBase, DAC_CNTL, dacRead & 0xfffffffc);
}

VOID vM64CursorOff_TVP(PDEV* ppdev)
{
    UCHAR * ucDacReg;
    UCHAR * ucDacCntl;

    // Initialize DAC registers
    vDacRegs(ppdev, &ucDacReg, &ucDacCntl);

    rioOB(ucDacCntl, rioIB(ucDacCntl) & 0xfc);
    rioOB(ucDacReg+REG_W, 6);                 // register 6
    rioOB(ucDacCntl, (rioIB(ucDacCntl) & 0xfc) | 2);
    rioOB(ucDacReg+REG_M, 0);              // (+Mask) disable
    rioOB(ucDacCntl, rioIB(ucDacCntl) & 0xfc);
}

VOID vM64CursorOn_TVP(PDEV* ppdev, LONG lCurOffset)
{
    UCHAR * ucDacReg;
    UCHAR * ucDacCntl;

    /*
     * Initialize DAC registers
    */
    vDacRegs(ppdev, &ucDacReg, &ucDacCntl);

    /*
     * Access cursor control register
     */
    rioOB(ucDacCntl, rioIB(ucDacCntl) & 0xfc);
    rioOB(ucDacReg+REG_W, 6);                 // register 6
    rioOB(ucDacCntl, (rioIB(ucDacCntl) & 0xfc) | 2);
    rioOB(ucDacReg+REG_M, 2);  // XGA cursor type
    rioOB(ucDacCntl, rioIB(ucDacCntl) & 0xfc);
}

VOID  vM64SetCursorOffset_IBM514(PDEV* ppdev)
{
}

VOID  vM64UpdateCursorOffset_IBM514(
PDEV* ppdev,
LONG lXOffset,
LONG lYOffset,
LONG lCurOffset)
{
    ppdev->ppointer->ptlLastOffset.x=lXOffset   ;//-64;
    ppdev->ppointer->ptlLastOffset.y=lYOffset   ;//-64;
    /*
     * These two statements have been introduced in order to solve the ghost cursor on IBM Dac cards
     */
    ppdev->pfnUpdateCursorPosition(ppdev,ppdev->ppointer->ptlLastPosition.x+0,ppdev->ppointer->ptlLastPosition.y+0);
    ppdev->pfnCursorOn(ppdev, lCurOffset);

    /* Change the offset... used in UpdateCursorPosition */
}

VOID  vM64UpdateCursorPosition_IBM514(
PDEV* ppdev,
LONG x,
LONG y)
{
    UCHAR * ucDacReg;
    UCHAR * ucDacCntl;

    // Initialize DAC registers
    vDacRegs(ppdev, &ucDacReg, &ucDacCntl);

    ppdev->ppointer->ptlLastPosition.y=y;
    ppdev->ppointer->ptlLastPosition.x=x;


    // Note: SetCursorOffset, UpdateCursorOffset must set ptlLastOffset
    x-= ppdev->ppointer->ptlLastOffset.x;
    y-= ppdev->ppointer->ptlLastOffset.y;


    rioOB(ucDacCntl, (rioIB(ucDacCntl) & 0xfc)| 1);
    rioOB(ucDacReg+REG_R, 1);
    rioOB(ucDacReg+REG_W, 0x31);

    rioOB(ucDacReg+REG_D, 0);
    rioOB(ucDacReg+REG_M, x&0xFF);
    rioOB(ucDacReg+REG_M, (UCHAR)(x>>8));
    rioOB(ucDacReg+REG_M, y&0xFF);
    rioOB(ucDacReg+REG_M, (UCHAR)(y>>8));
    rioOB(ucDacCntl, rioIB(ucDacCntl) & 0xfc);
}

VOID vM64CursorOff_IBM514(PDEV* ppdev)     // DONE
{
    BYTE* pjMmBase = ppdev->pjMmBase;
    UCHAR * ucDacReg;
    UCHAR * ucDacCntl;

#ifndef NO_VERTICAL_SYNC

    ULONG ldata;
    ULONG ldata1;

    /*
     * Read the no. of total vertical lines (including the overscan)
     */
    ldata1 = M64_ID(pjMmBase,CRTC_V_TOTAL_DISP);
    ldata1 = ldata1&0x7ff;

again:
    /*
     * Read the current vertical line
     */
    ldata = M64_ID(pjMmBase,CRTC_CRNT_VLINE);
    ldata = (ldata&0x7ff0000)>>16;

    /*
     * Synchronise the drawing with the vertical line
     */
    if (ldata >= (ldata1-3))
    {

#endif  // !NO_VERTICAL_SYNC

        /*
         * Initialize DAC registers
         */
        vDacRegs(ppdev, &ucDacReg, &ucDacCntl);

        rioOB(ucDacCntl, (rioIB(ucDacCntl) & 0xfc)|1);
        rioOB(ucDacReg+REG_R, 1);
        rioOB(ucDacReg+REG_W, 0x30);
        rioOB(ucDacReg+REG_D, 0);              // (+Data)
        rioOB(ucDacReg+REG_M, 0);              // (+Mask)
        rioOB(ucDacCntl, rioIB(ucDacCntl) & 0xfc);

#ifndef NO_VERTICAL_SYNC

    }
    else
    {
        goto again;
    }

#endif  // !NO_VERTICAL_SYNC

}

VOID vM64CursorOn_IBM514(PDEV* ppdev, LONG lCurOffset) //DONE
{
    BYTE* pjMmBase = ppdev->pjMmBase;
    UCHAR * ucDacReg;
    UCHAR * ucDacCntl;

#ifndef NO_VERTICAL_SYNC

    ULONG ldata;
    ULONG ldata1;

    /*
     * Read the no. of total vertical lines (including the overscan)
     */
    ldata1 = M64_ID(pjMmBase,CRTC_V_TOTAL_DISP);
    ldata1 = ldata1&0x7ff;

again:
    /*
     * Read the current verticale line
     */
    ldata = M64_ID(pjMmBase,CRTC_CRNT_VLINE);
    ldata = (ldata&0x7ff0000)>>16;

    /*
     * Synchronise the drawing of cursor
     */
    if (ldata >= (ldata1-3))
    {

#endif  // !NO_VERTICAL_SYNC

        // Initialize DAC registers
        vDacRegs(ppdev, &ucDacReg, &ucDacCntl);

        // access cursor control register
        rioOB(ucDacCntl, (rioIB(ucDacCntl) & 0xfc) | 1);
        rioOB(ucDacReg+REG_R, 1);
        rioOB(ucDacReg+REG_W, 0x30);
        rioOB(ucDacReg+REG_D, 0);                 // register 6
        rioOB(ucDacReg+REG_M, 0xE);                 // register 6
        rioOB(ucDacCntl, rioIB(ucDacCntl) & 0xfc);

#ifndef NO_VERTICAL_SYNC

    }
    else
    {
        goto again;
    }

#endif  // !NO_VERTICAL_SYNC

}

VOID  vM64UpdateCursorOffset_CT(
PDEV* ppdev,
LONG lXOffset,
LONG lYOffset,
LONG lCurOffset)
{
    BYTE* pjMmBase = ppdev->pjMmBase;

    ppdev->pfnCursorOff(ppdev);
    M64_OD_DIRECT(pjMmBase, CUR_OFFSET, lCurOffset >> 1);
    M64_OD_DIRECT(pjMmBase, CUR_HORZ_VERT_OFF, lXOffset | (lYOffset << 16));

    ppdev->pfnCursorOn(ppdev, lCurOffset);
}

VOID vM64CursorOff_CT(PDEV* ppdev)
{
    BYTE* pjMmBase = ppdev->pjMmBase;

#ifndef NO_VERTICAL_SYNC

    ULONG ldata;
    ULONG ldata1;

    // Read the no. of total verticales lines (including the overscan)
    ldata1 = M64_ID(pjMmBase,CRTC_V_TOTAL_DISP);
    ldata1 = ldata1&0x7ff;

again:
    //read the current verticale line
    ldata = M64_ID(pjMmBase,CRTC_CRNT_VLINE);
    ldata = (ldata&0x7ff0000)>>16;

    //synchronise the drawing with the vertical line
    if (ldata >= (ldata1-3))
    {

#endif  // !NO_VERTICAL_SYNC

        ppdev->pfnUpdateCursorPosition(ppdev, -1, -1);

#ifndef NO_VERTICAL_SYNC

    }
    else
    {
        goto again;
    }

#endif  // !NO_VERTICAL_SYNC

}

VOID vM64CursorOn_CT(PDEV* ppdev, LONG lCurOffset)
{
    BYTE* pjMmBase = ppdev->pjMmBase;
    ULONG ldata;

#ifndef NO_VERTICAL_SYNC

    ULONG ldata1;

#endif  // !NO_VERTICAL_SYNC

    if (!flag_enable)
    {
        flag_enable=TRUE;
        ldata = M64_ID(pjMmBase,GEN_TEST_CNTL);
        M64_OD_DIRECT(pjMmBase, GEN_TEST_CNTL, ldata  | GEN_TEST_CNTL_CursorEna);
    }

#ifndef NO_VERTICAL_SYNC

    /*
     * Read the no. of total vertical lines (including the overscan)
     */
    ldata1 = M64_ID(pjMmBase,CRTC_V_TOTAL_DISP);
    ldata1 = ldata1&0x7ff;

again:
    /*
     * read the current vertical line
     */
    ldata = M64_ID(pjMmBase,CRTC_CRNT_VLINE);
    ldata = (ldata&0x7ff0000)>>16;

    /*
     * Synchronise the drawing of cursor
     */
    if (ldata >= (ldata1-3))
    {

#endif  // !NO_VERTICAL_SYNC

        ppdev->pfnUpdateCursorPosition(ppdev,ppdev->ppointer->ptlLastPosition.x+0,ppdev->ppointer->ptlLastPosition.y+0);

#ifndef NO_VERTICAL_SYNC

    }
    else
    {
        goto again;
    }

#endif  // !NO_VERTICAL_SYNC

}

VOID vM64PointerBlit(
PDEV *ppdev,
LONG x,
LONG y,
LONG cx,
LONG cy,
PBYTE pbsrc,
LONG lDelta)
{
    BYTE* pjMmBase = ppdev->pjMmBase;
    LONG cxbytes;

    cxbytes = cx / 8;

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 7);
    //M64_OD(pjMmBase, CONTEXT_LOAD_CNTL, CONTEXT_LOAD_CmdLoad | ppdev->iDefContext );

    M64_OD(pjMmBase,DP_PIX_WIDTH, 0x020202); // assert 8 bpp
    M64_OD(pjMmBase,DST_OFF_PITCH,(ppdev->ulVramOffset + ((y*ppdev->lDelta) >> 3)) |
                               (ROUND8(cxbytes) << 19));

    if (cxbytes >= (LONG)ppdev->cxScreen)
        {
        M64_OD(pjMmBase,SC_RIGHT, cxbytes);
        }

    M64_OD(pjMmBase,DP_MIX, (OVERPAINT << 16));
    M64_OD(pjMmBase,DP_SRC, DP_SRC_Host << 8);

    M64_OD(pjMmBase,DST_Y_X, 0L);
    M64_OD(pjMmBase,DST_HEIGHT_WIDTH, 1 | (cxbytes << 16));

    vM64DataPortOutB(ppdev, pbsrc, cxbytes);

    // Fix a timing problem that leaves a remnant line segment in the lower right
    // of the 64x64 cursor.
    vM64QuietDown(ppdev, pjMmBase);

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 3);
    M64_OD(pjMmBase, DP_PIX_WIDTH, ppdev->ulMonoPixelWidth);
    M64_OD(pjMmBase, DST_OFF_PITCH, ppdev->ulScreenOffsetAndPitch);
    M64_OD(pjMmBase, SC_RIGHT, M64_MAX_SCISSOR_R);
}

VOID vM64PointerBlit_TVP(
PDEV *ppdev,
LONG x,
LONG y,
LONG cx,
LONG cy,
PBYTE pbsrc,
LONG lDelta)
{
    PBYTE cur_data;
    ULONG i;
    UCHAR * ucDacReg;
    UCHAR * ucDacCntl;

    // Initialize DAC registers
    vDacRegs(ppdev, &ucDacReg, &ucDacCntl);

    cur_data=pbsrc;

    rioOB(ucDacCntl, rioIB(ucDacCntl) & 0xfc);    // Disable cursor
    rioOB(ucDacReg+REG_W, 6);                 // register 6
    rioOB(ucDacCntl, (rioIB(ucDacCntl) & 0xfc) | 2);
    rioOB(ucDacReg+REG_M, 0);              // (+Mask) disable


    // set cursor RAM write address to 0
    rioOB(ucDacCntl, rioIB(ucDacCntl) & 0xfc);
    rioOB(ucDacReg+REG_W, 0);



    // select cursor RAM data register - auto increments with each write
    rioOB(ucDacCntl, (rioIB(ucDacCntl) & 0xfc) | 2);


    for (i = 0; i < 1024; i++)
    {
        rioOB(ucDacReg+REG_R, *cur_data++);
    }

    // select default palette registers
    rioOB(ucDacCntl, rioIB(ucDacCntl) & 0xfc);


    rioOB(ucDacReg+REG_W, 6);                 // register 6
    rioOB(ucDacCntl, (rioIB(ucDacCntl) & 0xfc) | 2);
    rioOB(ucDacReg+REG_M, 2);  // XGA cursor type
    rioOB(ucDacCntl, rioIB(ucDacCntl) & 0xfc);
}

VOID vM64PointerBlit_IBM514(
PDEV *ppdev,
LONG x,
LONG y,
LONG cx,
LONG cy,
PBYTE pbsrc,
LONG lDelta)
{
    PBYTE cur_data, pjMmBase = ppdev->pjMmBase;
    ULONG i;
    UCHAR * ucDacReg;
    UCHAR * ucDacCntl;

#ifndef NO_VERTICAL_SYNC

    ULONG ldata;
    ULONG ldata1;

#endif  // !NO_VERTICAL_SYNC

    // Initialize DAC registers
    vDacRegs(ppdev, &ucDacReg, &ucDacCntl);

    cur_data=pbsrc;

#ifndef NO_VERTICAL_SYNC

    /*
     * Read the no. of total vertical lines (including the overscan)
     */
    ldata1 = M64_ID(pjMmBase, CRTC_V_TOTAL_DISP);
    ldata1 = ldata1&0x7ff;

again:
    /*
     * Read the current vertical line
     */
    ldata = M64_ID(pjMmBase, CRTC_CRNT_VLINE);
    ldata = (ldata&0x7ff0000)>>16;

    // synchronise the drawing of cursor
    if (ldata >= (ldata1-3))
    {

#endif  // !NO_VERTICAL_SYNC

        rioOB(ucDacCntl, (rioIB(ucDacCntl) & 0xfc)|1);    // Disable cursor
        rioOB(ucDacReg+REG_R, 1);
        rioOB(ucDacReg+REG_W, 0);
        rioOB(ucDacReg+REG_D, 1);

#ifndef NO_VERTICAL_SYNC

    }
    else
    {
        goto again;
    }

#endif  // !NO_VERTICAL_SYNC

    // select cursor RAM data register - auto increments with each write


    for (i = 0; i < 1024; i++)
    {
        rioOB(ucDacReg+REG_M, *cur_data++);
    }

    /* Set HOT SPOT registers..     RSL Important?  */
    rioOB(ucDacReg+REG_W, 0x35);
    rioOB(ucDacReg+REG_D, 0);
    rioOB(ucDacReg+REG_M, 0);
    rioOB(ucDacReg+REG_M, 0);
    rioOB(ucDacCntl, rioIB(ucDacCntl) & 0xfc);
}

// END MACH64 ------------------------------------------------------------------

/******************************Public*Routine******************************\
*  CopyMonoCursor
*
* Copies two monochrome masks into a 2bpp bitmap.  Returns TRUE if it
* can make a hardware cursor, FALSE if not.
*
*  modified by Wendy Yee -1992-10-16- to accomodate 68800
\**************************************************************************/

BOOLEAN CopyMonoCursor(PDEV *ppdev, BYTE *pjSrcAnd, BYTE *pjSrcOr)
{
    BYTE jSrcAnd;
    BYTE jSrcOr;
    LONG count;
    BYTE *pjDest;
    BYTE jDest = 0;
    LONG nbytes;


    pjDest = (PBYTE) HardWareCursorShape;

    if ( ppdev->FeatureFlags & EVN_TVP_DAC_CUR)
        {
        nbytes=CURSOR_CX*CURSOR_CY/8;

        for (count = 0; count < nbytes; count++)
            {
            *(pjDest       )= *pjSrcOr;   // Gives outline!
            *(pjDest+nbytes)= *pjSrcAnd;

            pjDest++;
            pjSrcOr++;
            pjSrcAnd++;

            }
        for (;count < 512; count++)
            {
            *pjDest=0;
            *(pjDest+nbytes)=0xFF;
            }

        return(TRUE);
        }

    for (count = 0; count < (CURSOR_CX * CURSOR_CY);)
        {
        if (!(count & 0x07))          // need new src byte every 8th count;
            {                         // each byte = 8 pixels
            jSrcAnd = *(pjSrcAnd++);
            jSrcOr = *(pjSrcOr++);
            }

        if (jSrcAnd & 0x80)         // AND mask's white-1 background
            {
            if (jSrcOr & 0x80)          // XOR mask's white-1 outline
                jDest |= 0xC0;      // Complement
            else
                jDest |= 0x80;      // Set destination to Transparent
            }
        else
            {                    // AND mask's cursor silhouette in black-0
            if (jSrcOr & 0x80)
                jDest |= 0x40; // Color 1 - white
            else
                jDest |= 0x00; // Color 0 - black
            }
        count++;

        if (!(count & 0x3))     // New DestByte every 4 times for 4 pixels per byte
            {
            *pjDest = jDest;    // save pixel after rotating to right 3x
            pjDest++;
            jDest = 0;
            }
        else
            {
            jDest >>= 2;   // Next Pixel
            }

        jSrcOr  <<= 1;
        jSrcAnd <<= 1;
        }

    while (count++ < 64*64)
        if (!(count & 0x3))           // need new src byte every 8th count;
            {                         // each byte = 8 pixels
            *pjDest =0xaa;
            pjDest++;
            }

    return(TRUE);
}

ULONG lSetMonoHwPointerShape(
        SURFOBJ     *pso,
        SURFOBJ     *psoMask,
        SURFOBJ     *psoColor,
        XLATEOBJ    *pxlo,
        LONG        xHot,
        LONG        yHot,
        LONG        x,
        LONG        y,
        RECTL       *prcl,
        FLONG       fl)
{
    LONG    count;
    ULONG   cy;
    PBYTE   pjSrcAnd, pjSrcXor;
    LONG    lDeltaSrc, lDeltaDst;
    LONG    lSrcWidthInBytes;
    ULONG   cxSrc = pso->sizlBitmap.cx;
    ULONG   cySrc = pso->sizlBitmap.cy;
    ULONG   cxSrcBytes;
    BYTE    AndMask[CURSOR_CX][CURSOR_CX/8];
    BYTE    XorMask[CURSOR_CY][CURSOR_CY/8];
    PBYTE   pjDstAnd = (PBYTE)AndMask;
    PBYTE   pjDstXor = (PBYTE)XorMask;
    PDEV*   ppdev;
    PCUROBJ ppointer;

    ppdev=(PDEV*)pso->dhpdev;
    ppointer = ppdev->ppointer;

    // If the mask is NULL this implies the pointer is not
    // visible.

    if (psoMask == NULL)
    {
        if (ppointer->flPointer & MONO_POINTER_UP)
        {
            //DbgOut("\nThe cursor was disabled because of psoMask");
            ppdev->pfnCursorOff(ppdev);
            ppointer->flPointer &= ~MONO_POINTER_UP;
        }
        return (SPS_ACCEPT_NOEXCLUDE) ;
    }

    // Get the bitmap dimensions.

    cxSrc = psoMask->sizlBitmap.cx ;
    cySrc = psoMask->sizlBitmap.cy ;

    // set the dest and mask to 0xff

    memset(pjDstAnd, 0xFFFFFFFF, CURSOR_CX/8 * CURSOR_CY);

    // Zero the dest XOR mask

    memset(pjDstXor, 0, CURSOR_CX/8 * CURSOR_CY);

    cxSrcBytes = (cxSrc + 7) / 8;

    if ((lDeltaSrc = psoMask->lDelta) < 0)
        lSrcWidthInBytes = -lDeltaSrc;
    else
        lSrcWidthInBytes = lDeltaSrc;

    pjSrcAnd = (PBYTE) psoMask->pvScan0;

    // Height of just AND mask

    cySrc = cySrc / 2;

    // Point to XOR mask

    pjSrcXor = pjSrcAnd + (cySrc * lDeltaSrc);

    // Offset from end of one dest scan to start of next

    lDeltaDst = CURSOR_CX/8;

    for (cy = 0; cy < cySrc; ++cy)
    {
        memcpy(pjDstAnd, pjSrcAnd, cxSrcBytes);
        memcpy(pjDstXor, pjSrcXor, cxSrcBytes);

        // Point to next source and dest scans

        pjSrcAnd += lDeltaSrc;
        pjSrcXor += lDeltaSrc;
        pjDstAnd += lDeltaDst;
        pjDstXor += lDeltaDst;
    }


    if (CopyMonoCursor(ppdev, (PBYTE)AndMask, (PBYTE)XorMask))
    {
        // Down load the pointer shape to the engine.

        count = CURSOR_CX * CURSOR_CY * 2;
        if (ppdev->iAsic == ASIC_88800GX)
        {
            // double buffering used for Ghost EPR
            if (!ppdev->bAltPtrActive)
            {
                ppointer = ppdev->ppointer = &ppdev->pointer1;
                ppdev->pointer1.ptlHotSpot     = ppdev->pointer2.ptlHotSpot;
                ppdev->pointer1.ptlLastPosition= ppdev->pointer2.ptlLastPosition;
                ppdev->pointer1.ptlLastOffset  = ppdev->pointer2.ptlLastOffset;
                ppdev->pointer1.flPointer      = ppdev->pointer2.flPointer;
                ppdev->pointer1.szlPointer     = ppdev->pointer2.szlPointer;
            }
            else
            {
                ppointer = ppdev->ppointer = &ppdev->pointer2;
                ppdev->pointer2.ptlHotSpot     = ppdev->pointer1.ptlHotSpot;
                ppdev->pointer2.ptlLastPosition= ppdev->pointer1.ptlLastPosition;
                ppdev->pointer2.ptlLastOffset  = ppdev->pointer1.ptlLastOffset;
                ppdev->pointer2.flPointer      = ppdev->pointer1.flPointer;
                ppdev->pointer2.szlPointer     = ppdev->pointer1.szlPointer;
            }
            ppdev->bAltPtrActive = !ppdev->bAltPtrActive;
        }
        ppdev->pfnSetCursorOffset(ppdev);
        ppdev->pfnPointerBlit(ppdev,
                             ppointer->hwCursor.x,
                             ppointer->hwCursor.y,
                             count,
                             1L,
                             (PBYTE) &HardWareCursorShape,
                             0L);
    }
    else
        return(SPS_ERROR);


    // Set the position of the cursor.
    if (fl & SPS_ANIMATEUPDATE)
    {
        //DbgOut("animate cursor\n");
        if ( (ppointer->ptlLastPosition.x < 0) ||
             (ppointer->ptlLastPosition.y < 0) )
        {
            ppointer->ptlLastPosition.x = x - CURSOR_CX;
            ppointer->ptlLastPosition.y = y - CURSOR_CY;
        }
    }
    else
    {
        ppointer->ptlLastPosition.x = -x - 2;
        ppointer->ptlLastPosition.y = -y - 2;
        // DbgOut("See what last position we set in DrvSetPointerShape: x=%d   y=%d\n",ppointer->ptlLastPosition.x,ppointer->ptlLastPosition.y);
    }

    if  (x == -1)
    {
        ppointer->ptlLastPosition.x = x;
        ppointer->ptlLastPosition.y = y;
        return (SPS_ACCEPT_NOEXCLUDE) ;
    }

    //flag for enforcing a special approach from DrvMovePointer
    flag_shape=TRUE;
    DrvMovePointer(pso, x, y, NULL) ;

    if (!(ppointer->flPointer & MONO_POINTER_UP))
    {
        ppointer->ptlLastPosition.x = x;
        ppointer->ptlLastPosition.y = y;
        ppdev->pfnCursorOn(ppdev, ppointer->mono_offset);
        ppointer->flPointer |= MONO_POINTER_UP;
    }

    return (SPS_ACCEPT_NOEXCLUDE) ;
}

/******************************Public*Routine******************************\
* VOID DrvSetPointerShape
*
* Sets the new pointer shape.
*
\**************************************************************************/

ULONG DrvSetPointerShape(
SURFOBJ*    pso,
SURFOBJ*    psoMask,
SURFOBJ*    psoColor,
XLATEOBJ*   pxlo,
LONG        xHot,
LONG        yHot,
LONG        x,
LONG        y,
RECTL*      prcl,
FLONG       fl)
{
    ULONG   ulRet ;
    PDEV*   ppdev ;
    LONG    lX ;
    PCUROBJ ppointer;

    ppdev=(PDEV*)pso->dhpdev;
    ppointer = ppdev->ppointer;

    // Save the position and hot spot in pdev

    ppointer->ptlHotSpot.x = xHot ;
    ppointer->ptlHotSpot.y = yHot ;

    ppointer->szlPointer.cx = psoMask->sizlBitmap.cx ;
    ppointer->szlPointer.cy = psoMask->sizlBitmap.cy / 2;

    // The pointer may be larger than we can handle.
    // We don't want to draw colour cursors either - let GDI do it
    // If it is we must cleanup the screen and let the engine
    // take care of it.

    if (psoMask->sizlBitmap.cx > CURSOR_CX ||
        psoMask->sizlBitmap.cy > CURSOR_CY ||
        psoColor != NULL ||
        ppointer->flPointer & NO_HARDWARE_CURSOR)
    {
        // Disable the mono hardware pointer.
        if (ppointer->flPointer & MONO_POINTER_UP)
        {
            ppdev->pfnCursorOff(ppdev);
            ppointer->flPointer &= ~MONO_POINTER_UP;
        }

        return (SPS_DECLINE);
    }

    // odd cursor positions not displayed in 1280 mode

    lX = x-xHot;
    if (ppdev->cxScreen == 0x500)
        lX &= 0xfffffffe;

    if(ppdev->iAsic == ASIC_88800GX)
    {
        //disable the hardware cursor
        ppdev->pfnCursorOff(ppdev);

#if MULTI_BOARDS
        {
            OH*  poh;

            if (x != -1)
            {
                poh = ((DSURF*) pso->dhsurf)->poh;
                x += poh->x;
                y += poh->y;
            }
        }
#endif
    }

    // Take care of the monochrome pointer.
    ulRet = lSetMonoHwPointerShape(pso, psoMask, psoColor, pxlo,
                                         xHot, yHot, x, y, prcl, fl) ;

    return (ulRet) ;
}

/******************************Public*Routine******************************\
* VOID DrvMovePointer
*
* NOTE: Because we have set GCAPS_ASYNCMOVE, this call may occur at any
*       time, even while we're executing another drawing call!
*
*       Consequently, we have to explicitly synchronize any shared
*       resources.  In our case, since we touch the CRTC register here
*       and in the banking code, we synchronize access using a critical
*       section.
*
\**************************************************************************/

VOID DrvMovePointer(
SURFOBJ*    pso,
LONG        x,
LONG        y,
RECTL*      prcl)
{
    PDEV*   ppdev ;
    PCUROBJ ppointer;

    LONG    lXOffset, lYOffset;
    LONG    lCurOffset;
    BOOL    bUpdatePtr = FALSE;
    BOOL    bUpdateOffset = FALSE;

    ppdev=(PDEV*)pso->dhpdev;
    ppointer = ppdev->ppointer;

    // If x is -1 then take down the cursor.

    if (x == -1)
    {
        ppointer->ptlLastPosition.x=-1;
        ppointer->ptlLastPosition.y=y;
        ppdev->pfnCursorOff(ppdev);
        ppointer->flPointer &= ~MONO_POINTER_UP;
        return;
    }

#if MULTI_BOARDS
    if (flag_shape!=TRUE)
    {
        OH* poh;

        poh = ((DSURF*) pso->dhsurf)->poh;
        x += poh->x;
        y += poh->y;
    }
#endif

    // Adjust the actual pointer position depending upon
    // the hot spot.

    x -= ppointer->ptlHotSpot.x ;
    y -= ppointer->ptlHotSpot.y ;

    // odd cursor positions not displayed in 1280 mode

    if (ppdev->cxScreen == 0x500)
        x &= 0xfffffffe;

    // get current offsets
    lXOffset = ppointer->ptlLastOffset.x;
    lYOffset = ppointer->ptlLastOffset.y;
    lCurOffset = ppointer->mono_offset;

    /*
    ;
    ;Deal with changes in X:
    ;
    */
    if (x!=ppointer->ptlLastPosition.x)   /* did our X coordinate change? */
    {
        bUpdatePtr = TRUE;
        if (x<0)    /* is cursor negative? */
        {
            bUpdateOffset = TRUE;
            lXOffset = -x;         /* reset size of cursor to < original */
            x = 0;                 /* set cursor to origin */
        }
        else if (ppointer->ptlLastPosition.x<=0)
        {
            bUpdateOffset = TRUE;   /* reset size of cursor to original */
            lXOffset = 0;
        }
    }

    /*
    ;
    ;Deal with changes in Y
    ;
    */
    if (y!=ppointer->ptlLastPosition.y)
    {
        bUpdatePtr = TRUE;
        if (y<0)
        {
            // Move start pointer of cursor down and cursor base up to
            // compensate. The (-4) is the pitch if the cursor in dwords
            bUpdateOffset = TRUE;
            lYOffset = -y;      /* reset size of cursor to < original */
            lCurOffset -= 4*y;

            y = 0;              /* set base of cursor to Y */
        }
        else if (ppointer->ptlLastPosition.y<=0)
        {
            bUpdateOffset = TRUE; /* reset size of cursor to original */
            lYOffset = 0;
        }
    }

    if(ppdev->iAsic != ASIC_88800GX)
    {
        flag_shape=FALSE;
    }

    if (flag_shape)
    {
        flag_shape=FALSE;
        ppointer->ptlLastPosition.x=x;
        ppointer->ptlLastPosition.y=y;

        if (bUpdateOffset)
        {
            ppdev->pfnUpdateCursorOffset(ppdev, lXOffset, lYOffset, lCurOffset);
            ppointer->ptlLastOffset.x=lXOffset;
            ppointer->ptlLastOffset.y=lYOffset;
            ppointer->flPointer |= MONO_POINTER_UP;
        }
        else
        {
            if (ppdev->iAsic == ASIC_88800GX)
            {
                //this is a new statement imposed by double buffering
                ppdev->pfnUpdateCursorOffset(ppdev, lXOffset, lYOffset, lCurOffset);
                ppointer->flPointer |= MONO_POINTER_UP;
                //only for no double buffering
                //ppdev->_vCursorOn(ppdev, lCurOffset);
            }
        }
    }
    else
    {
        ppointer->ptlLastPosition.x=x;
        ppointer->ptlLastPosition.y=y;

        if (bUpdateOffset)
        {
            ppdev->pfnUpdateCursorOffset(ppdev, lXOffset, lYOffset, lCurOffset);
            ppointer->ptlLastOffset.x=lXOffset;
            ppointer->ptlLastOffset.y=lYOffset;
            ppointer->flPointer |= MONO_POINTER_UP;
        }

        if (bUpdatePtr)
        {
            ppdev->pfnUpdateCursorPosition(ppdev, x, y);
        }
    }
}

/******************************Public*Routine******************************\
* VOID vDisablePointer
*
\**************************************************************************/

VOID vDisablePointer(
PDEV*   ppdev)
{
    // Nothing to do, really
}

/******************************Public*Routine******************************\
* VOID vAssertModePointer
*
\**************************************************************************/

VOID vAssertModePointer(
PDEV*   ppdev,
BOOL    bEnable)
{
    if (!bEnable)
    {
        ppdev->pfnCursorOff(ppdev);
        ppdev->ppointer->flPointer &= ~MONO_POINTER_UP;
    }
    else
    {
        flag_enable = FALSE;      // force initial cursor enable
    }
}

/******************************Public*Routine******************************\
* BOOL bEnablePointer
*
\**************************************************************************/

BOOL bEnablePointer(
PDEV*   ppdev)
{
    OH* poh;

    ppdev->ppointer = &ppdev->pointer1;
    ppdev->bAltPtrActive = FALSE;

    // Allocate first buffer
    poh = pohAllocate(ppdev, NULL,
                        ppdev->cxMemory,
                        (1024+(ppdev->lDelta-1))/ppdev->lDelta,
                        FLOH_MAKE_PERMANENT);
    if (poh != NULL)
    {
        ppdev->ppointer->hwCursor.x = poh->x;
        ppdev->ppointer->hwCursor.y = poh->y;

        // Allocate second buffer
        poh = pohAllocate(ppdev, NULL,
                            ppdev->cxMemory,
                            (1024+(ppdev->lDelta-1))/ppdev->lDelta,
                            FLOH_MAKE_PERMANENT);
        if (poh != NULL)
        {
            ppdev->pointer2.hwCursor.x = poh->x;
            ppdev->pointer2.hwCursor.y = poh->y;

            if (ppdev->iMachType == MACH_MM_32 || ppdev->iMachType == MACH_IO_32)
            {
                ppdev->pfnSetCursorOffset       = vI32SetCursorOffset;
                ppdev->pfnUpdateCursorOffset    = vI32UpdateCursorOffset;
                ppdev->pfnUpdateCursorPosition  = vI32UpdateCursorPosition;
                ppdev->pfnCursorOff             = vI32CursorOff;
                ppdev->pfnCursorOn              = vI32CursorOn;
                // 24bpp on mach32 is only available with linear frame buffer.
                // vI32PointerBlit can't handle 24bpp.
                if (ppdev->iBitmapFormat == BMF_24BPP)
                    ppdev->pfnPointerBlit           = vPointerBlitLFB;
                else
                    ppdev->pfnPointerBlit           = vI32PointerBlit;
            }
            else
            {
                if (ppdev->FeatureFlags & EVN_TVP_DAC_CUR)
                {
                    /* TVP DAC Hardware Cursor is Buggy in Hardware */
                    ppdev->pfnSetCursorOffset       = vM64SetCursorOffset_TVP;
                    ppdev->pfnUpdateCursorOffset    = vM64UpdateCursorOffset_TVP;
                    ppdev->pfnUpdateCursorPosition  = vM64UpdateCursorPosition_TVP;
                    ppdev->pfnCursorOff             = vM64CursorOff_TVP;
                    ppdev->pfnCursorOn              = vM64CursorOn_TVP;

                    ppdev->pfnPointerBlit           = vM64PointerBlit_TVP;
                }
                else if (ppdev->FeatureFlags & EVN_IBM514_DAC_CUR)
                {
                    /*
                     * On the DEC Alpha, the hardware cursor on the IBM 514
                     * DAC does not work properly.
                     */
                    #if defined(ALPHA)
                    ppdev->ppointer->flPointer |= NO_HARDWARE_CURSOR;
                    #endif
                    ppdev->pfnSetCursorOffset       = vM64SetCursorOffset_IBM514;
                    ppdev->pfnUpdateCursorOffset    = vM64UpdateCursorOffset_IBM514;
                    ppdev->pfnUpdateCursorPosition  = vM64UpdateCursorPosition_IBM514;
                    ppdev->pfnCursorOff             = vM64CursorOff_IBM514;
                    ppdev->pfnCursorOn              = vM64CursorOn_IBM514;
                    ppdev->pfnPointerBlit           = vM64PointerBlit_IBM514;
                }
                else if (ppdev->FeatureFlags & EVN_INT_DAC_CUR)
                {
                    ppdev->pfnSetCursorOffset       = vM64SetCursorOffset;
                    ppdev->pfnUpdateCursorOffset    = vM64UpdateCursorOffset_CT;
                    ppdev->pfnUpdateCursorPosition  = vM64UpdateCursorPosition;
                    ppdev->pfnCursorOff             = vM64CursorOff_CT;
                    ppdev->pfnCursorOn              = vM64CursorOn_CT;
                    ppdev->pfnPointerBlit           = vM64PointerBlit;
                }
                else
                {
                    ppdev->pfnSetCursorOffset       = vM64SetCursorOffset;
                    ppdev->pfnUpdateCursorOffset    = vM64UpdateCursorOffset;
                    ppdev->pfnUpdateCursorPosition  = vM64UpdateCursorPosition;
                    ppdev->pfnCursorOff             = vM64CursorOff;
                    ppdev->pfnCursorOn              = vM64CursorOn;
                    ppdev->pfnPointerBlit           = vM64PointerBlit;
                }
            }

            if (ppdev->pModeInfo->ModeFlags & AMI_ODD_EVEN ||
                ppdev->iAsic == ASIC_38800_1)
            {
                ppdev->ppointer->flPointer |= NO_HARDWARE_CURSOR;
            }

            return TRUE;
        }
    }

    ppdev->ppointer->flPointer |= NO_HARDWARE_CURSOR;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\pal_supp.h ===
#if   PAL_SUPPORT

//
// ATIConfig
//
#ifndef      PALSUPP_INC_
#define     PALSUPP_INC_

// #define         BUG_800x600_8BPP      //if this is defined, in 800x600 8bpp the memory allocation is
                                                            // done in rectangles with the width 800 not 832 (the actual cxMemory in this mode)

// #define  ALLOC_RECT_ANYWHERE      // if this is defined, then the allocation will be made anywhere in the heap, not  starting
                                                            // at a requested location
// #define  DYNAMIC_REZ_AND_COLOUR_CHANGE   // palindrome support for on the fly rez and colour depth



#define ACCESSDEVICEDATA_SUBFUNC_ALLOC          (DWORD)0x00000001
#define ACCESSDEVICEDATA_SUBFUNC_FREE           (DWORD)0x00000002
#define ACCESSDEVICEDATA_SUBFUNC_QUERY          (DWORD)0x00000003

#define ACCESSDEVICECODE_CONNECTOR              (DWORD)0x00000001
#define ACCESSDEVICECODE_OVERLAY                (DWORD)0x00000002


// structure used for the size of off-screen memory alloc
typedef struct tag_OFFSCEREEN {
    LONG  cx;  //width
    LONG  cy;  //height
} OFFSCREEN;

//structure for retriving the info about where the allocated off_screen memory is allocated
typedef struct tag_OVERLAY_LOCATION {
    LONG  x;   //x coordinate in pixels from the begining of the aperture
    LONG  y;   //y coordinate in pixels from the begining of the aperture
    ULONG app_offset;//pointer to the begining of the allocated memory in the liniar memory
} OVERLAY_LOCATION;


typedef struct tag_RW_REG_STRUCT{
    BYTE    reg_block;
    WORD    reg_offset;
    DWORD   data;
} RW_REG_STRUCT;




typedef struct struct_ATIConfig
{
    BYTE  ATISig[10];
    BYTE  Filler1[2];
    BYTE  DriverName[9];
    BYTE  Filler2[3];
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwDesktopWidth;
    DWORD dwDesktopHeight;
    DWORD dwEnginePitch;
    DWORD dwRealRamAvail;
    DWORD VGABoundary;
    DWORD dwBpp;
    DWORD dwBoardBpp;
    DWORD dwColorFormat;
    DWORD dwAlphaBitMask;
    DWORD dwConfigBits;
    DWORD dwAsicRevision;
    DWORD dwROMVersion;
    DWORD dwBoardType;
    DWORD dwApertureType;
    DWORD AperturePtr;
    DWORD DisplayOffset;
    DWORD MemRegPtr;
    DWORD dwExtDevice[8];
    DWORD MemReg1Ptr;
}
ATIConfig;





#define       ATIConfig_ColorFmt_4               0x0000        //4  bpp
#define       ATIConfig_ColorFmt_4_Packed        0x0001         //4  bpp
#define       ATIConfig_ColorFmt_8               0x0002         //8  bpp
#define       ATIConfig_ColorFmt_RGB332          0x0003         //8  bpp
#define       ATIConfig_ColorFmt_Crystal8        0x0004         //8  bpp
#define       ATIConfig_ColorFmt_RGB555          0x0005         //16 bpp
#define       ATIConfig_ColorFmt_RGB565          0x0006         //16 bpp
#define       ATIConfig_ColorFmt_RGB655          0x0007         //16 bpp
#define       ATIConfig_ColorFmt_RGB664          0x0008         //16 bpp
#define       ATIConfig_ColorFmt_RGB888          0x0009         //24 bpp
#define       ATIConfig_ColorFmt_BGR888          0x000A         //24 bpp
#define       ATIConfig_ColorFmt_aRGB8888        0x000B         //32 bpp
#define       ATIConfig_ColorFmt_RGBa8888        0x000C         //32 bpp
#define       ATIConfig_ColorFmt_aBGR8888        0x000D         //32 bpp
#define       ATIConfig_ColorFmt_BGRa8888        0x000E         //32 bpp

#define       ATIConfig_ColorFmtBIT_4            0x00000001
#define       ATIConfig_ColorFmtBIT_4_Packed     0x00000002
#define       ATIConfig_ColorFmtBIT_8            0x00000004
#define       ATIConfig_ColorFmtBIT_RGB332       0x00000008
#define       ATIConfig_ColorFmtBIT_Crystal8     0x00000010
#define       ATIConfig_ColorFmtBIT_RGB555       0x00000020
#define       ATIConfig_ColorFmtBIT_RGB565      0x 00000040
#define       ATIConfig_ColorFmtBIT_RGB655       0x00000080
#define       ATIConfig_ColorFmtBIT_RGB664       0x00000100
#define       ATIConfig_ColorFmtBIT_RGB888       0x00000200
#define       ATIConfig_ColorFmtBIT_BGR888       0x00000400
#define       ATIConfig_ColorFmtBIT_aRGB8888     0x00000800
#define       ATIConfig_ColorFmtBIT_RGBa8888     0x00001000
#define       ATIConfig_ColorFmtBIT_aBGR8888     0x00002000
#define       ATIConfig_ColorFmtBIT_BGRa8888     0x00004000

// these two struct def have been moved into driver.h
/*
typedef struct tag_alloc_history{
    ULONG   x;
    ULONG   y;
    OH*        poh;
} alloc_history;


typedef struct tagACCESSDEVICEDATA
{
DWORD dwSize;
DWORD dwSubFunc;
DWORD dwAccessDeviceCode;
DWORD lpAccessCallbackFuncPtr;
}ACCESSDEVICEDATA, *pACCESSDEVICEDATA;
*/

typedef DWORD           FOURCC;         /* a four character code */

typedef struct tagVIDEOCAPTUREDATA{
        DWORD   dwSize;
        DWORD   dwSubFunc;
        DWORD   dwCaptureWidth;
        DWORD   dwCaptureHeight;
        FOURCC  fccFormat;
        DWORD   dwBitMasks[3];
        DWORD   dwCaptureMode;

}VIDEOCAPTUREDATA, FAR *LPVIDEOCAPTUREDATA;

/* Gone into atint.h

 typedef struct tag_VIDEO_CAPTURE{
     DWORD    dwSubFunct;           // On , Off or return the capture width
     DWORD    dwCaptureWidth;  // maximum width of the capture at the current resolution, color depth and refresh rate
     DWORD    dwCaptureMode;     // Continuous capture  or single capture (host mode)
 } VIDEO_CAPTURE;
*/

#define VIDEOCAPTUREDATA_SUBFUNC_ENABLE                         0x00000000
#define VIDEOCAPTUREDATA_SUBFUNC_DISABLE                        0x00000001
#define VIDEOCAPTUREDATA_SUBFUNC_QUERY                          0x00000002

#define VIDEOCAPTUREDATA_CAPTURE_HOSTTRIGGED            0x00000000
#define VIDEOCAPTUREDATA_CAPTURE_CONTINUOUS                     0x00000001


typedef struct
{
 long ScreenWidth;
 long ScreenHeight;
 long ScreenColorFormat;
 long DesctopWidth;
 long DesctopHeight;
 long SystemColorFormat;
}ModeInfo;

#define Control_DisplaymodeIsSupported  0x73A0
#define Control_DisplaymodeIsEnabled    0x73A1
#define Control_GetDisplaymode          0x73A3

#define Control_TimewarpIsSupported     0x7340
#define Control_TimewarpIsEnabled       0x7341
#define Control_TimewarpEnable          0x7342
#define Control_TimewarpDisable         0x7343

#define Control_DCIIsSupported                  0x73E0
#define Control_DCIIsEnabled                    0x73E1
#define Control_DCIAccessDevice                 0x73EC
#define Control_DCIEnable                           0x73e2
#define Control_DCIDisable              0x73e3
#define Control_DCIVideoCapture     0x73ee

#define Control_ConfigIsSupported       0x7300
#define Control_ConfigIsEnabled         0x7301
#define Control_GetConfiguration        0x7302




typedef struct {
        WORD    wCard;
        WORD    wChipID;
        WORD    wError;
        WORD    wWriteCount;
        WORD    wReadCount;
        BYTE  lpWrData[10];
        BYTE  lpRdData[10];
} I2CSTRUCT_NEW,  *LPI2CSTRUCT_NEW;

//
// VT Scaler and Overlay Registers
//

#define OVERLAY_Y_X              (0x0000 )//* 4)
#define OVERLAY_Y_X_END          (0x0001 )//* 4)
#define OVERLAY_VIDEO_KEY_CLR    (0x0002 )//* 4)
#define OVERLAY_VIDEO_KEY_MSK    (0x0003 )//* 4)
#define OVERLAY_GRAPHICS_KEY_CLR (0x0004 )//* 4)
#define OVERLAY_GRAPHICS_KEY_MSK (0x0005 )//* 4)
#define OVERLAY_KEY_CNTL         (0x0006 )//* 4)
#define OVERLAY_SCALE_INC        (0x0008 )//* 4)
#define OVERLAY_SCALE_CNTL       (0x0009 )//* 4)
#define SCALER_HEIGHT_WIDTH      (0x000A )//* 4)
#define OVERLAY_TEST             (0x000B )//* 4)
#define SCALER_THRESHOLD         (0x000C )//* 4)
#define CAPTURE_Y_X              (0x0010 )//* 4)
#define CAPTURE_HEIGHT_WIDTH     (0x0011 )//* 4)
#define VIDEO_FORMAT             (0x0012 )//* 4)
#define VIDEO_CONFIG             (0x0013 )//* 4)
#define CAPTURE_CONFIG           (0x0014 )//* 4)
#define TRIG_CNTL                (0x0015 )//* 4)
#define VMC_CONFIG               (0x0018 )//* 4)
#define BUF0_OFFSET              (0x0020 )//* 4)
#define BUF0_PITCH               (0x0023 )//* 4)
#define BUF1_OFFSET              (0x0026 )//* 4)
#define BUF1_PITCH               (0x0029 )//* 4)


//
// Handle private interface between the 3D driver and the 2D GDI
// driver
//
typedef struct {
    DWORD   dwSize;                 // size of this struct
    DWORD   dwVideoBaseAddr;        // linear address to aperture
    DWORD   dwRegisterBaseAddr;     // linear address to registers
    DWORD   dwOffScreenAddr;        // linear address to offscreen memory
    DWORD   dwOffScreenSize;        // size of offscreen memory
    DWORD   dwTotalRAM;             // amount of RAM on the card
    DWORD   dwFIFOSize;             // size of FIFO, (tbfl)
    DWORD   dwScreenWidth;          // screen width
    DWORD   dwScreenHeight;         // screen height
    DWORD   dwScreenPitch;          // screen pitch
    DWORD   dwBpp;                  // bits per pixel
                                    //   1
                                    //   4
                                    //   8
                                    //  15 = 1555 format
                                    //  16 = 565  format
                                    //  24
                                    //  32
    BOOL    b3DAvail;               // driver supports 3D operations
    DWORD   dwChipID;               // 3D chip id code
    DWORD   dwChipRevision;         // 3D chip revision
    DWORD   dwAlphaBitMask;         // Alpha bit mask
    DWORD   dwRedBitMask;           // Red Bit Mask
    DWORD   dwGreenBitMask;         // Green Bit Mask
    DWORD   dwBlueBitMask;          // Blue Bit Mask
} PHX2DHWINFO, PPHX2DHWINFO;


// defines and structures for Brooktree819
#define LINE_STORE_ENABLE 0
#define MAX_POSSIB_CARDS 4

//void FAR        WriteBT819Reg                           (WORD wCard, BYTE bReg, WORD wData );
//WORD FAR        ReadBT819Reg                            (WORD wCard, BYTE bReg );

//Physical Registers' Description
typedef struct tagMAPBT819INFO {
    BYTE     bFunctionality;   // multifunctional - 1, monofunctional - 0, 2 - read only
    BYTE     bReserved;        // reserved - 1, active - 0
    BYTE     bData;            // data (a byte)

}MAPBT819INFO;


typedef MAPBT819INFO *MAPBT819;





//Logical Registers' Description
typedef struct tagREGSBT819INFO
{
    BYTE     bSize;         // size of the register in bits
    BYTE     bAddrLSBs;    // register's LSBs address (0 - 31)
    BYTE     bOffsetLSBs;   // register's LSB offset   (0 -  7)
    BYTE     bMaskLSBs;     // mask for LSBs           (0x0 - 0xFF)
    BYTE     bAddrMSBs;    // register's MSBs address  - for the registers longer than 1 byte
    BYTE     bOffsetMSBs;   // register's MSB offset    - for the registers longer than 1 byte
    BYTE     bMaskMSBs;     // mask for MSBs            - for the registers longer than 1 byte
    BYTE     RegStatus;     // read only - 1, otherwise - 0

}REGSBT819INFO;


typedef WORD REGSBT819DEF;

// BT819  MAP BOUNDARIES' FLAGS
#define   RESERVED     (BYTE)  1
#define   ACTIVE       (BYTE)  0
#define   MULTIFUNC    (BYTE)  1
#define   MONOFUNC     (BYTE)  0
#define   READONLY     (BYTE)  2


// INDEX OF BT819 PHYSICAL REGISTERS - 1K  BOUNDRIES OF THE 32K BT819 REGISTER MAP:

#define   STATUS       (BYTE)   0x0
#define   IFORM        (BYTE)   0x1
#define   TDEC         (BYTE)   0x2
#define   CROP         (BYTE)   0x3
#define   VDELAY_LO    (BYTE)   0x4
#define   VACTIVE_LO   (BYTE)   0x5
#define   HDELAY_LO    (BYTE)   0x6
#define   HACTIVE_LO   (BYTE)   0x7
#define   HSCALE_HI    (BYTE)   0x8
#define   HSCALE_LO    (BYTE)   0x9
#define   BRIGHT       (BYTE)   0xA
#define   CONTROL      (BYTE)   0xB
#define   CONTRAST_LO  (BYTE)   0xC
#define   SAT_U_LO     (BYTE)   0xD
#define   SAT_V_LO     (BYTE)   0xE
#define   HUE          (BYTE)   0xF
#define   RESERV_1     (BYTE)   0x10 //reserved byte
#define   RESERV_2     (BYTE)   0x11 //reserved byte
#define   OFORM        (BYTE)   0x12
#define   VSCALE_HI    (BYTE)   0x13
#define   VSCALE_LO    (BYTE)   0x14
#define   TEST         (BYTE)   0x15
#define   VPOLE        (BYTE)   0x16
#define   IDCODE       (BYTE)   0x17
#define   ADELAY       (BYTE)   0x18
#define   BDELAY       (BYTE)   0x19
#define   ADC          (BYTE)   0x1A
#define   RESERV_3     (BYTE)   0x1B //reserved byte
#define   RESERV_4     (BYTE)   0x1C //reserved byte
#define   RESERV_5     (BYTE)   0x1D //reserved byte
#define   RESERV_6     (BYTE)   0x1E //reserved byte
#define   SRESET       (BYTE)   0x1F

#define   NUM_BT819_BNDS (BYTE) 32

// END

//LIST OF LOGICAL REGISTERS:

enum tagBT819LOGREGS
{

  reg819_PRES,
  reg819_HLOC,
  reg819_FIELD,
  reg819_NUML,
  reg819_CSEL,
  reg819_LOF,
  reg819_COF,
  reg819_HACTIVE_I,
  reg819_MUXSEL,
  reg819_XTSEL,
  reg819_FORMAT,
  reg819_DEC_FIELD,
  reg819_DEC_RAT,
  reg819_VDELAY,
  reg819_VACTIVE,
  reg819_HDELAY,
  reg819_HACTIVE,
  reg819_HSCALE,
  reg819_BRIGHT,
  reg819_LNOTCH,
  reg819_COMP,
  reg819_LDEC,
  reg819_CBSENSE,
  reg819_INTERP,
  reg819_CON,
  reg819_SAT_U,
  reg819_SAT_V,
  reg819_HUE,
  reg819_RANGE,
  reg819_RND,
  reg819_FIFO_BURST,
  reg819_CODE,
  reg819_LEN,
  reg819_SPI,
  reg819_FULL,
  reg819_LINE,
  reg819_COMB,
  reg819_INT,
  reg819_VSCALE,
  reg819_OUTEN,
  reg819_VALID_PIN,
  reg819_AFF_PIN,
  reg819_CBFLAG_PIN,
  reg819_FIELD_PIN,
  reg819_ACTIVE_PIN,
  reg819_HRESET_PIN,
  reg819_VRESET_PIN,
  reg819_PART_ID,
  reg819_PART_REV,
  reg819_ADELAY,
  reg819_BDELAY,
  reg819_CLAMP,
  reg819_SYNC_T,
  reg819_AGC_EN,
  reg819_CLK_SLEEP,
  reg819_Y_SLEEP,
  reg819_C_SLEEP,
  reg819_SRESET

}BT819LOGREGS;

#define   NUM_BT819_REGS  (BYTE) 58


#define  reg819_PRES_DEF              (WORD) 0x0000
#define  reg819_HLOC_DEF              (WORD) 0x0000
#define  reg819_FIELD_DEF             (WORD) 0x0000
#define  reg819_NUML_DEF              (WORD) 0x0000
#define  reg819_CSEL_DEF              (WORD) 0x0000
#define  reg819_LOF_DEF               (WORD) 0x0000
#define  reg819_COF_DEF               (WORD) 0x0000
#define  reg819_HACTIVE_I_DEF_DEF     (WORD) 0x0000
#define  reg819_MUXSEL_DEF            (WORD) 0x0002
#define  reg819_XTSEL_DEF             (WORD) 0x0003
#define  reg819_FORMAT_DEF            (WORD) 0x0000
#define  reg819_DEC_FIELD_DEF         (WORD) 0x0000
#define  reg819_DEC_RAT_DEF           (WORD) 0x0000
#define  reg819_VDELAY_DEF            (WORD) 0x0016
#define  reg819_VACTIVE_DEF           (WORD) 0x01E0
#define  reg819_HDELAY_DEF            (WORD) 0x0078
#define  reg819_HACTIVE_DEF           (WORD) 0x0280
#define  reg819_HSCALE_DEF            (WORD) 0x02AC
#define  reg819_BRIGHT_DEF            (WORD) 0x0000
#define  reg819_LNOTCH_DEF            (WORD) 0x0000
#define  reg819_COMP_DEF              (WORD) 0x0000
#define  reg819_LDEC_DEF              (WORD) 0x0001
#define  reg819_CBSENSE_DEF           (WORD) 0x0000
#define  reg819_INTERP_DEF            (WORD) 0x0000
#define  reg819_CON_DEF               (WORD) 0x00D8
#define  reg819_SAT_U_DEF             (WORD) 0x00FE
#define  reg819_SAT_V_DEF             (WORD) 0x00B4
#define  reg819_HUE_DEF               (WORD) 0x0000
#define  reg819_RANGE_DEF             (WORD) 0x0000
#define  reg819_RND_DEF               (WORD) 0x0000
#define  reg819_FIFO_BURST_DEF        (WORD) 0x0000
#define  reg819_CODE_DEF_DEF          (WORD) 0x0000
#define  reg819_LEN_DEF               (WORD) 0x0001
#define  reg819_SPI_DEF               (WORD) 0x0001
#define  reg819_FULL_DEF              (WORD) 0x0000
#define  reg819_LINE_DEF              (WORD) 0x0000
#define  reg819_COMB_DEF              (WORD) 0x0001
#define  reg819_INT_DEF               (WORD) 0x0001
#define  reg819_VSCALE_DEF            (WORD) 0x0000
#define  reg819_OUTEN_DEF             (WORD) 0x0000
#define  reg819_VALID_PIN_DEF         (WORD) 0x0000
#define  reg819_AFF_PIN_DEF           (WORD) 0x0000
#define  reg819_CBFLAG_PIN_DEF        (WORD) 0x0000
#define  reg819_FIELD_PIN_DEF         (WORD) 0x0000
#define  reg819_ACTIVE_PIN_DEF        (WORD) 0x0000
#define  reg819_HRESET_PIN_DEF        (WORD) 0x0000
#define  reg819_VRESET_PIN_DEF        (WORD) 0x0000
#define  reg819_PART_ID_DEF           (WORD) 0x0000  /*Unknown, read only register*/
#define  reg819_PART_REV_DEF          (WORD) 0x0000  /*Unknown, read only register*/
#define  reg819_ADELAY_DEF            (WORD) 0x0068
#define  reg819_BDELAY_DEF            (WORD) 0x005D
#define  reg819_CLAMP_DEF             (WORD) 0x0002
#define  reg819_SYNC_T_DEF            (WORD) 0x0000
#define  reg819_AGC_EN_DEF            (WORD) 0x0000
#define  reg819_CLK_SLEEP_DEF         (WORD) 0x0000
#define  reg819_Y_SLEEP_DEF           (WORD) 0x0000
#define  reg819_C_SLEEP_DEF           (WORD) 0x0001
#define  reg819_SRESET_DEF            (WORD) 0x0000




/**************************************************************************************************************************************/




static MAPBT819INFO MapBT819DEF[NUM_BT819_BNDS] = /*default value*/
{
        { MULTIFUNC,    ACTIVE,      0x0 },   //STATUS
        { MULTIFUNC,    ACTIVE,      0x58},   //IFORM
        { MULTIFUNC,    ACTIVE,      0x0},    //TDEC
        { MULTIFUNC,    ACTIVE,      0x12},   //CROP
        { MONOFUNC,     ACTIVE,      0x16},   //VDELAY_LO
        { MONOFUNC,     ACTIVE,      0xE0},   //VACTIVE_LO
        { MONOFUNC,     ACTIVE,      0x78},   //HDELAY_LO
        { MONOFUNC,     ACTIVE,      0x80},   //HACTIVE_LO
        { MONOFUNC,     ACTIVE,      0x2},    //HSCALE_HI
        { MONOFUNC,     ACTIVE,      0xAC},   //HSCALE_LO
        { MONOFUNC,     ACTIVE,      0x0},    //BRIGHT
        { MULTIFUNC,    ACTIVE,      0x20},   //CONTROL
        { MONOFUNC,     ACTIVE,      0xD8},   //CONTRAST_LO
        { MONOFUNC,     ACTIVE,      0xFE},   //SAT_U_LO,
        { MONOFUNC,     ACTIVE,      0xB4},   //SAT_V_LO,
        { MONOFUNC,     ACTIVE,      0x0},    //HUE,
        { MONOFUNC,     RESERVED,    0x0},    //RESERV_1,
        { MONOFUNC,     RESERVED,    0x0},    //RESERV_2,
        { MULTIFUNC,    ACTIVE,      0x6},    //OFORM,
        { MULTIFUNC,    ACTIVE,      0x60},   //VSCALE_HI,
        { MONOFUNC,     ACTIVE,      0x0},    //VSCALE_LO,
        { MONOFUNC,     RESERVED,    0x1},    //TEST,
        { MULTIFUNC,    ACTIVE,      0x0},    //VPOLE,
        { MULTIFUNC,    READONLY,    0},      //IDCODE,
        { MONOFUNC,     ACTIVE,      0x68},   //ADELAY,
        { MONOFUNC,     ACTIVE,      0x5D},   //BDELAY,
        { MULTIFUNC,    ACTIVE,      0x82},   //ADC,
        { MONOFUNC,     RESERVED,    0x0},    //RESERV_3,
        { MONOFUNC,     RESERVED,    0x0},    //RESERV_4,
        { MONOFUNC,     RESERVED,    0x0},    //RESERV_5,
        { MONOFUNC,     RESERVED,    0x0},    //RESERV_6,
        { MONOFUNC,     ACTIVE,      0x0}     //SRESET,
};

// this array is initialized in pal_supp.c
#if 0
REGSBT819INFO  RegsBT819[NUM_BT819_REGS] = {                                                                           /* Register's Name*/
        { 1,  STATUS,      0, 0x7F,   0,    0,     0, 0 },      // 0 - PRES
        { 1,  STATUS,      1, 0xBF,   0,    0,     0, 0 },      // 1 - HLOC
        { 1,  STATUS,      2, 0xDF,   0,    0,     0, 0 },      // 2 - FIELD
        { 1,  STATUS,      3, 0xEF,   0,    0,     0, 0 },      // 3 - NUML
        { 1,  STATUS,      4, 0xF7,   0,    0,     0, 0 },      // 4 - CSEL
        { 1,  STATUS,      6, 0xFD,   0,    0,     0, 0 },      // 5 - LOF
        { 1,  STATUS,      7, 0xFE,   0,    0,     0, 0 },      // 6 - COF

        { 1,  IFORM,       0, 0x7F,   0,    0,     0, 0  },     // 7 -  HACTIVE_I
        { 2,  IFORM,       1, 0x9F,   0,    0,     0, 0  },     // 8 -  MUXEL
        { 2,  IFORM,       3, 0xE7,   0,    0,     0, 0  },     // 9 -  XTSEL
        { 2,  IFORM,       6, 0xFC,   0,    0,     0, 0  },     // 10 - FORMAT

        { 1,  TDEC,        0,  0x7F,  0,     0,    0, 0 },      // 11 - DEC_FIELD
        { 7,  TDEC,        1,  0x80,  0,     0,    0, 0 },      // 12 - DEC_RAT

        { 10, VDELAY_LO,   0,  0x00,  CROP,      0,      0x3F, 0 },      // 13 - VDELAY
        { 10, VACTIVE_LO,  0,  0x00,  CROP,      2,      0xCF, 0 },      // 14 - VACTIVE
        { 10, HDELAY_LO,   0,  0x00,  CROP,      4,      0xF3, 0 },      // 15 - HDELAY
        { 10, HACTIVE_LO,  0,  0x00,  CROP,      6,      0xFC, 0 },      // 16 - HACTIVE

        { 16, HSCALE_LO,   0,  0x00,  HSCALE_HI, 0,      0x00, 0 },      // 17 - HSCALE

        { 8,  BRIGHT,      0,  0x00,  0,      0,   0, 0 },      // 18 - BRIGHT

        { 1, CONTROL,      0,  0x7F,  0,      0,   0, 0 },       // 19 - LNOTCH
        { 1, CONTROL,      1,  0xBF,  0,      0,   0, 0 },       // 20 - COMP
        { 1, CONTROL,      2,  0xDF,  0,      0,   0, 0 },       // 21 - LDEC
        { 1, CONTROL,      3,  0xEF,  0,      0,   0, 0 },       // 22 - CBSENSE
        { 1, CONTROL,      4,  0xF7,  0,      0,   0, 0 },       // 23 - INTERP
        { 9, CONTRAST_LO,  0,  0x00,  CONTROL,   5,      0xFB, 0 },       // 24 - CON
        { 9, SAT_U_LO,     0,  0x00,  CONTROL,   6,      0xFD, 0 },       // 25 - SAT_U
        { 9, SAT_V_LO,     0,  0x00,  CONTROL,   7,      0xFE, 0 },       // 26 - SAT_V

        { 8, HUE,          0,  0x00,  0,      0,   0, 0 },       // 27 - HUE

        { 1, OFORM,        0,  0x7F,   0,      0,   0, 0 },       // 28 - RANGE
        { 2, OFORM,        1,  0x9F,   0,      0,   0, 0 },       // 29 - RND
        { 1, OFORM,        3,  0xEF,   0,      0,   0, 0 },       // 30 - FIFO_BURST
        { 1, OFORM,        4,  0xF7,   0,      0,   0, 0 },       // 31 - CODE
        { 1, OFORM,        5,  0xFB,   0,      0,   0, 0 },       // 32 - LEN
        { 1, OFORM,        6,  0xFD,   0,      0,   0, 0 },       // 33 - SPI
        { 1, OFORM,        7,  0xFE,   0,      0,   0, 0 },       // 34 - FULL

        { 1, VSCALE_HI,    0,  0x7F,   0,      0,   0, 0 },       // 35 - LINE
        { 1, VSCALE_HI,    1,  0xBF,   0,      0,   0, 0 },       // 36 - COMB
        { 1, VSCALE_HI,    2,  0xDF,   0,      0,   0, 0 },       // 37 - INT

        { 13,VSCALE_LO,    0,  0x00,   VSCALE_HI, 3,      0xE0, 0 },       // 38 - VSCALE

        { 1, VPOLE,        0,  0x7F,   0,      0,   0, 0 },        // 39 - OUTEN
        { 1, VPOLE,        1,  0xBF,   0,      0,   0, 0 },        // 40 - VALID_PIN
        { 1, VPOLE,        2,  0xDF,   0,      0,   0, 0 },        // 41 - AFF_PIN
        { 1, VPOLE,        3,  0xEF,   0,      0,   0, 0 },        // 42 - CBFLAG_PIN
        { 1, VPOLE,        4,  0xF7,   0,      0,   0, 0 },        // 43 - FIELD_PIN
        { 1, VPOLE,        5,  0xFB,   0,      0,   0, 0 },        // 44 - ACTIVE_PIN
        { 1, VPOLE,        6,  0xFD,   0,      0,   0, 0 },        // 45 - HRESET_PIN
        { 1, VPOLE,        7,  0xFE,   0,      0,   0, 0 },        // 46 - VRESET_PIN

        { 4, IDCODE,       0,  0,   0,      0,   0, READONLY }, // 47 - PART_ID
        { 4, IDCODE,       4,  0,   0,      0,   0, READONLY }, // 48 - PART_REV

        { 8, ADELAY,       0,  0x00,   0,      0,   0, 0 },        // 49 - ADELAY
        { 8, BDELAY,       0,  0x00,   0,      0,   0, 0 },        // 50 - BDELAY


        { 2, ADC,          0,  0x3F,   0,      0,   0, 0 },        // 51 - CLAMP
        { 1, ADC,          2,  0xDF,   0,      0,   0, 0 },        // 52 - SYNC_T
        { 1, ADC,          3,  0xEF,   0,      0,   0, 0 },        // 53 - AGC_EN
        { 1, ADC,          4,  0xF7,   0,      0,   0, 0 },        // 54 - CLK_SLEEP
        { 1, ADC,          5,  0xFB,   0,      0,   0, 0 },        // 55 - Y_SLEEP
        { 1, ADC,          6,  0xFD,   0,      0,   0, 0 },        // 56 - C_SLEEP

        { 8, SRESET,       0,  0x00,   0,      0,   0, 0 },        // 57 - SRESET
};
#endif
// The following array contains default values for BT819 logical registers
static REGSBT819DEF  RegsBT819Def[NUM_BT819_REGS] = {
             reg819_PRES_DEF,
             reg819_HLOC_DEF,
             reg819_FIELD_DEF,
             reg819_NUML_DEF,
             reg819_CSEL_DEF,
             reg819_LOF_DEF,
             reg819_COF_DEF,
             reg819_HACTIVE_I_DEF_DEF,
             reg819_MUXSEL_DEF,
             reg819_XTSEL_DEF,
             reg819_FORMAT_DEF,
             reg819_DEC_FIELD_DEF,
             reg819_DEC_RAT_DEF,
             reg819_VDELAY_DEF,
             reg819_VACTIVE_DEF,
             reg819_HDELAY_DEF,
             reg819_HACTIVE_DEF,
             reg819_HSCALE_DEF,
             reg819_BRIGHT_DEF,
             reg819_LNOTCH_DEF,
             reg819_COMP_DEF,
             reg819_LDEC_DEF,
             reg819_CBSENSE_DEF,
             reg819_INTERP_DEF,
             reg819_CON_DEF,
             reg819_SAT_U_DEF,
             reg819_SAT_V_DEF,
             reg819_HUE_DEF,
             reg819_RANGE_DEF,
             reg819_RND_DEF,
             reg819_FIFO_BURST_DEF,
             reg819_CODE_DEF_DEF,
             reg819_LEN_DEF,
             reg819_SPI_DEF,
             reg819_FULL_DEF,
             reg819_LINE_DEF,
             reg819_COMB_DEF,
             reg819_INT_DEF,
             reg819_VSCALE_DEF,
             reg819_OUTEN_DEF,
             reg819_VALID_PIN_DEF,
             reg819_AFF_PIN_DEF,
             reg819_CBFLAG_PIN_DEF,
             reg819_FIELD_PIN_DEF,
             reg819_ACTIVE_PIN_DEF,
             reg819_HRESET_PIN_DEF,
             reg819_VRESET_PIN_DEF,
             reg819_PART_ID_DEF,
             reg819_PART_REV_DEF,
             reg819_ADELAY_DEF,
             reg819_BDELAY_DEF,
             reg819_CLAMP_DEF,
             reg819_SYNC_T_DEF,
             reg819_AGC_EN_DEF,
             reg819_CLK_SLEEP_DEF,
             reg819_Y_SLEEP_DEF,
             reg819_C_SLEEP_DEF,
             reg819_SRESET_DEF
};



// end defines and structures for Brooktree819

// defines for I2C support

//#define ATIAPI

#define I2C_ACK_WR_ERROR                0x01
#define I2C_ACK_RD_ERROR                0x02
#define I2C_COLIDE                              0x04

/*
  I2C Bus constants
 */
#define      I2C_HIGH                (BYTE) 1
#define        I2C_LOW               (BYTE) 0
#define        I2C_TIME_DELAY  (BYTE)  5
#define        I2C_WRITE             (BOOL)TRUE
#define        I2C_READ              ( BOOL) FALSE

// end for I2C support

  /*

void  Init3D_Info(PDEV*,PVOID);
ULONG GetDisplayMode(PDEV* ,PVOID ) ;
ULONG AccessDevice(PDEV* , PVOID, PVOID ) ;
ULONG  GetConfiguration(PDEV* ,PVOID )  ;
ULONG WriteRegFnct(PDEV* ,PVOID )  ;
ULONG  ReadRegFnct(PDEV* ,PVOID , PVOID)  ;
void  I2CAccess_New(PDEV* ,LPI2CSTRUCT_NEW ,LPI2CSTRUCT_NEW )  ;
BYTE ReverseByte(BYTE )  ;
WORD Ack(PDEV*, WORD , BOOL )   ;
void Start(PDEV*, WORD )  ;
void Stop(PDEV*, WORD )   ;
void I2CDelay(PDEV*, WORD)     ;
void WriteByteI2C(PDEV*, WORD , BYTE )  ;
BYTE ReadByteI2C(PDEV*,WORD ) ;
BOOL DisableOvl(PDEV* ) ;
ULONG AllocOffscreenMem(PDEV* , PVOID , PVOID)  ;
ULONG DeallocOffscreenMem(PDEV* ) ;
ULONG AllocOffscreenMem(PDEV* , PVOID , PVOID )   ;
void WriteVT264Reg(PDEV* , WORD , BYTE , DWORD  );
DWORD ReadVT264Reg(PDEV* , WORD , BYTE ) ;
void WriteI2CData(PDEV* , WORD , BYTE );

*/


/*
 * VT registers that matter for the I2C bus
 */
#define vtf_GEN_GIO2_DATA_OUT   1
#define vtf_GEN_GIO2_WRITE          2
#define vtf_DAC_GIO_STATE_1         3
#define vtf_GEN_GIO2_DATA_IN        4
#define vtf_CFG_CHIP_FND_ID         5
#define vtf_GEN_GIO3_DATA_OUT   6
#define vtf_GEN_GIO2_EN                 7
#define vtf_DAC_FEA_CON_EN          8
#define vtf_DAC_GIO_DIR_1               9
// for VTB, GTB support
#define    vtf_GP_IO_4                      10
#define    vtf_GP_IO_DIR_4              11
#define    vtf_GP_IO_B                      12
#define    vtf_GP_IO_7                      13
#define    vtf_GP_IO_DIR_B              14
#define    vtf_CFG_CHIP_MAJOR       15

#endif

#if 0             // the structure was moved in driver.h
// this structure is used (as a static and global structure) instead of the ppdev structure for keeping the values for
// pal support in NT4.0 since returning from DOS full screen with Alt+Enter will reinitialize the pdev    and will lose
// all the info
typedef struct _ppdev_pal_type
{
    ULONG     no_lines_allocated;      // number of lines already allocated by "alloc mem" in offscreen mem
   //flags for palindrome
   BOOL    dos_flag;
   BOOL     Palindrome_flag;
   BOOL     Realloc_mem_flag;
   BOOL     Mode_Switch_flag;
   BOOL     No_mem_allocated_flag;

   DWORD*  preg;

   //storage for buffers values (needed after a mode switch; ATIPlayer doesn't know that the mode was changed)
   DWORD  Buf0_Offset;
   //DWORD  Buf_Scaler1;       //for the moment this is the same as the previous

   //globals for CWDDE
       ACCESSDEVICEDATA*    lpOwnerAccessStructConnector;
       ACCESSDEVICEDATA*    lpOwnerAccessStructOverlay;
       BOOL        Flag_DCIIsEnabled;
       ULONG     Counter_DCIIsEnabled;
       BOOL        Flag_Control_ConfigIsEnabled;

   // for offscreen allocation history for palindrome
       int      alloc_cnt;
       alloc_history        alloc_hist[8];

    // global value for the pointer to the permanent node (off-screen memory allocation)
       OH*   poh;
       // for DCIEnable CWDDE call
       PVOID    pData;
       PVOID    CallBackFnct;
 }  PPDEV_PAL_NT;
 #endif

 // structure used in mode switch by DCIEnable

 typedef struct tagDCICB
 {
 DWORD      dwDCICB_FuncCode;
 LPVOID      lpDCICB_FuncData;
 } DCICB;

 #endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\strips.c ===
/******************************Module*Header*******************************\
* Module Name: Strips.c
*
* These are the line rendering routines of last resort, and are called
* by 'bLines' when a line is clipped or otherwise cannot be drawn
* directly by the hardware.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vI32StripSolidHorizontal
*
* Draws left-to-right x-major near-horizontal lines using radial lines.
*
\**************************************************************************/

VOID vI32StripSolidHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjIoBase;
    LONG    x;
    LONG    y;
    LONG    yDir;
    LONG*   pStrips;
    LONG    cStrips;
    LONG    i;

    pjIoBase = ppdev->pjIoBase;

    x = pStrip->ptlStart.x + ppdev->xOffset;
    y = pStrip->ptlStart.y + ppdev->yOffset;

    yDir    = (pStrip->flFlips & FL_FLIP_V) ? -1 : 1;
    pStrips = pStrip->alStrips;
    cStrips = pStrip->cStrips;

    for (i = cStrips; i != 0; i--)
    {
        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 5);
        I32_OW(pjIoBase, LINEDRAW_INDEX, 0);
        I32_OW(pjIoBase, LINEDRAW, x);
        I32_OW(pjIoBase, LINEDRAW, y);
        x += *pStrips++;
        I32_OW(pjIoBase, LINEDRAW, x);
        I32_OW(pjIoBase, LINEDRAW, y);
        y += yDir;
    }

    pStrip->ptlStart.x = x - ppdev->xOffset;
    pStrip->ptlStart.y = y - ppdev->yOffset;
}

/******************************Public*Routine******************************\
* VOID vI32StripSolidVertical
*
* Draws left-to-right y-major near-vertical lines using radial lines.
*
\**************************************************************************/

VOID vI32StripSolidVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjIoBase;
    LONG    x;
    LONG    y;
    LONG    yDir;
    LONG*   pStrips;
    LONG    cStrips;
    LONG    i;

    pjIoBase = ppdev->pjIoBase;

    x = pStrip->ptlStart.x + ppdev->xOffset;
    y = pStrip->ptlStart.y + ppdev->yOffset;

    yDir    = (pStrip->flFlips & FL_FLIP_V) ? -1 : 1;
    pStrips = pStrip->alStrips;
    cStrips = pStrip->cStrips;

    for (i = cStrips; i != 0; i--)
    {
        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 5);
        I32_OW(pjIoBase, LINEDRAW_INDEX, 0);
        I32_OW(pjIoBase, LINEDRAW, x);
        I32_OW(pjIoBase, LINEDRAW, y);
        y += (yDir > 0) ? *pStrips : -*pStrips;
        pStrips++;
        I32_OW(pjIoBase, LINEDRAW, x);
        I32_OW(pjIoBase, LINEDRAW, y);
        x++;
    }

    pStrip->ptlStart.x = x - ppdev->xOffset;
    pStrip->ptlStart.y = y - ppdev->yOffset;
}

/******************************Public*Routine******************************\
* VOID vI32StripSolidDiagonal
*
* Draws left-to-right near-diagonal lines using radial lines.
*
\**************************************************************************/

VOID vI32StripSolidDiagonal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjIoBase;
    LONG    x;
    LONG    y;
    LONG    yDir;
    LONG*   pStrips;
    LONG    cStrips;
    LONG    i;
    LONG    xDec;
    LONG    yDec;

    pjIoBase = ppdev->pjIoBase;

    x = pStrip->ptlStart.x + ppdev->xOffset;
    y = pStrip->ptlStart.y + ppdev->yOffset;

    yDir    = (pStrip->flFlips & FL_FLIP_V) ? -1 : 1;
    pStrips = pStrip->alStrips;
    cStrips = pStrip->cStrips;

    if (pStrip->flFlips & FL_FLIP_D)
    {
        // The line is y-major:

        yDec = 0;
        xDec = 1;
    }
    else
    {
        // The line is x-major:

        yDec = yDir;
        xDec = 0;
    }

    for (i = cStrips; i != 0; i--)
    {
        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 5);
        I32_OW(pjIoBase, LINEDRAW_INDEX, 0);
        I32_OW(pjIoBase, LINEDRAW, x);
        I32_OW(pjIoBase, LINEDRAW, y);
        x += *pStrips;
        y += (yDir > 0) ? *pStrips : -*pStrips;
        pStrips++;
        I32_OW(pjIoBase, LINEDRAW, x);
        I32_OW(pjIoBase, LINEDRAW, y);
        x -= xDec;
        y -= yDec;
    }

    pStrip->ptlStart.x = x - ppdev->xOffset;
    pStrip->ptlStart.y = y - ppdev->yOffset;
}

/******************************Public*Routine******************************\
* VOID vI32StripStyledHorizontal
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles x-major lines that run left-to-right,
* and are comprised of horizontal strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vI32StripStyledHorizontal(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    BYTE*   pjIoBase;
    LONG    x;
    LONG    y;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;

    pjIoBase = ppdev->pjIoBase;

    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 90 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going up):

        dy = -1;
    }
    else
    {
        // The minor direction of the line is 270 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going down):

        dy = 1;
    }

    cStrips = pstrip->cStrips;      // Total number of strips we'll do
    plStrip = pstrip->alStrips;     // Points to current strip
    x       = pstrip->ptlStart.x + ppdev->xOffset;
                                    // x position of start of first strip
    y       = pstrip->ptlStart.y + ppdev->yOffset;
                                    // y position of start of first strip

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        x += cThis;

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip:

        goto OutputADash;
    }

    // We've finished with the current strip:

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 5);
        I32_OW(pjIoBase, LINEDRAW_INDEX, 0);
        I32_OW(pjIoBase, LINEDRAW, x);
        I32_OW(pjIoBase, LINEDRAW, y);
        x += cThis;
        I32_OW(pjIoBase, LINEDRAW, x);
        I32_OW(pjIoBase, LINEDRAW, y);

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x - ppdev->xOffset;
    pstrip->ptlStart.y = y - ppdev->yOffset;
}

/******************************Public*Routine******************************\
* VOID vI32StripStyledVertical
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles y-major lines that run left-to-right,
* and are comprised of vertical strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vI32StripStyledVertical(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    BYTE*   pjIoBase;
    LONG    x;
    LONG    y;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;

    pjIoBase = ppdev->pjIoBase;

    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 90 (it's a left-to-right y-major line going up):

        dy = -1;
    }
    else
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 270 (it's a left-to-right y-major line going down):

        dy = 1;
    }

    cStrips = pstrip->cStrips;      // Total number of strips we'll do
    plStrip = pstrip->alStrips;     // Points to current strip
    x       = pstrip->ptlStart.x + ppdev->xOffset;
                                    // x position of start of first strip
    y       = pstrip->ptlStart.y + ppdev->yOffset;
                                    // y position of start of first strip

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        y += (dy > 0) ? cThis : -cThis;

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip:

        goto OutputADash;
    }

    // We've finished with the current strip:

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 5);
        I32_OW(pjIoBase, LINEDRAW_INDEX, 0);
        I32_OW(pjIoBase, LINEDRAW, x);
        I32_OW(pjIoBase, LINEDRAW, y);
        y += (dy > 0) ? cThis : -cThis;
        I32_OW(pjIoBase, LINEDRAW, x);
        I32_OW(pjIoBase, LINEDRAW, y);

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x - ppdev->xOffset;
    pstrip->ptlStart.y = y - ppdev->yOffset;
}

/******************************Public*Routine******************************\
* VOID vM64StripSolidHorizontal
*
* Draws left-to-right x-major near-horizontal lines using radial lines.
*
\**************************************************************************/

VOID vM64StripSolidHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjMmBase;
    LONG    x;
    LONG    y;
    LONG    yDir;
    LONG*   pStrips;
    LONG    cStrips;
    LONG    i;

    pjMmBase = ppdev->pjMmBase;

    x = pStrip->ptlStart.x + ppdev->xOffset;
    y = pStrip->ptlStart.y + ppdev->yOffset;

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
    M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);

    yDir    = (pStrip->flFlips & FL_FLIP_V) ? -1 : 1;
    pStrips = pStrip->alStrips;
    cStrips = pStrip->cStrips;

    for (i = cStrips; i != 0; i--)
    {
        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 2);
        M64_OD(pjMmBase, DST_Y_X,          PACKXY_FAST(x, y));
        M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(*pStrips, 1));
        x += *pStrips++;
        y += yDir;
    }

    pStrip->ptlStart.x = x - ppdev->xOffset;
    pStrip->ptlStart.y = y - ppdev->yOffset;
}

/******************************Public*Routine******************************\
* VOID vM64StripSolidVertical
*
* Draws left-to-right y-major near-vertical lines using radial lines.
*
\**************************************************************************/

VOID vM64StripSolidVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjMmBase;
    LONG    x;
    LONG    y;
    LONG    yDir;
    LONG*   pStrips;
    LONG    cStrips;
    LONG    i;

    pjMmBase = ppdev->pjMmBase;

    x = pStrip->ptlStart.x + ppdev->xOffset;
    y = pStrip->ptlStart.y + ppdev->yOffset;

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
    if (pStrip->flFlips & FL_FLIP_V)
    {
        yDir = -1;
        M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir);
    }
    else
    {
        yDir = 1;
        M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
    }

    pStrips = pStrip->alStrips;
    cStrips = pStrip->cStrips;

    for (i = cStrips; i != 0; i--)
    {
        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 2);
        M64_OD(pjMmBase, DST_Y_X,          PACKXY_FAST(x, y));
        M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(1, *pStrips));
        y += (yDir > 0) ? *pStrips : -*pStrips;
        pStrips++;
        x++;
    }

    pStrip->ptlStart.x = x - ppdev->xOffset;
    pStrip->ptlStart.y = y - ppdev->yOffset;
}

/******************************Public*Routine******************************\
* VOID vM64StripSolidDiagonal
*
* Draws left-to-right near-diagonal lines using radial lines.
*
\**************************************************************************/

VOID vM64StripSolidDiagonal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjMmBase;
    LONG    x;
    LONG    y;
    LONG    yDir;
    LONG*   pStrips;
    LONG    cStrips;
    LONG    i;
    LONG    xDec;
    LONG    yDec;

    pjMmBase = ppdev->pjMmBase;

    x = pStrip->ptlStart.x + ppdev->xOffset;
    y = pStrip->ptlStart.y + ppdev->yOffset;

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 4);
    M64_OD(pjMmBase, DST_BRES_ERR, 1);
    M64_OD(pjMmBase, DST_BRES_INC, 1);
    M64_OD(pjMmBase, DST_BRES_DEC, 0);

    if (pStrip->flFlips & FL_FLIP_V)
    {
        yDir = -1;
        M64_OD(pjMmBase, DST_CNTL, DST_CNTL_LastPel | DST_CNTL_XDir);
    }
    else
    {
        yDir = 1;
        M64_OD(pjMmBase, DST_CNTL, DST_CNTL_LastPel | DST_CNTL_XDir | DST_CNTL_YDir);
    }

    if (pStrip->flFlips & FL_FLIP_D)
    {
        // The line is y-major:

        yDec = 0;
        xDec = 1;
    }
    else
    {
        // The line is x-major:

        yDec = yDir;
        xDec = 0;
    }

    yDir    = (pStrip->flFlips & FL_FLIP_V) ? -1 : 1;
    pStrips = pStrip->alStrips;
    cStrips = pStrip->cStrips;

    for (i = cStrips; i != 0; i--)
    {
        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 2);
        M64_OD(pjMmBase, DST_Y_X,       PACKXY_FAST(x, y));
        M64_OD(pjMmBase, DST_BRES_LNTH, *pStrips);
        x += *pStrips;
        y += (yDir > 0) ? *pStrips : -*pStrips;
        pStrips++;
        y -= yDec;
        x -= xDec;
    }

    pStrip->ptlStart.x = x - ppdev->xOffset;
    pStrip->ptlStart.y = y - ppdev->yOffset;
}

/******************************Public*Routine******************************\
* VOID vM64StripStyledHorizontal
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles x-major lines that run left-to-right,
* and are comprised of horizontal strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vM64StripStyledHorizontal(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    BYTE*   pjMmBase;
    LONG    x;
    LONG    y;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;

    pjMmBase = ppdev->pjMmBase;

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
    M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);

    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 90 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going up):

        dy = -1;
    }
    else
    {
        // The minor direction of the line is 270 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going down):

        dy = 1;
    }

    cStrips = pstrip->cStrips;      // Total number of strips we'll do
    plStrip = pstrip->alStrips;     // Points to current strip
    x       = pstrip->ptlStart.x + ppdev->xOffset;
                                    // x position of start of first strip
    y       = pstrip->ptlStart.y + ppdev->yOffset;
                                    // y position of start of first strip

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        x += cThis;

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip:

        goto OutputADash;
    }

    // We've finished with the current strip:

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 2);
        M64_OD(pjMmBase, DST_Y_X,          PACKXY_FAST(x, y));
        M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cThis, 1));
        x += cThis;

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x - ppdev->xOffset;
    pstrip->ptlStart.y = y - ppdev->yOffset;
}

/******************************Public*Routine******************************\
* VOID vM64StripStyledVertical
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles y-major lines that run left-to-right,
* and are comprised of vertical strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vM64StripStyledVertical(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    BYTE*   pjMmBase;
    LONG    x;
    LONG    y;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;

    pjMmBase = ppdev->pjMmBase;

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 90 (it's a left-to-right y-major line going up):

        dy = -1;
        M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir);
    }
    else
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 270 (it's a left-to-right y-major line going down):

        dy = 1;
        M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
    }

    cStrips = pstrip->cStrips;      // Total number of strips we'll do
    plStrip = pstrip->alStrips;     // Points to current strip
    x       = pstrip->ptlStart.x + ppdev->xOffset;
                                    // x position of start of first strip
    y       = pstrip->ptlStart.y + ppdev->yOffset;
                                    // y position of start of first strip

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        y += (dy > 0) ? cThis : -cThis;

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip:

        goto OutputADash;
    }

    // We've finished with the current strip:

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 2);
        M64_OD(pjMmBase, DST_Y_X,          PACKXY_FAST(x, y));
        M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(1, cThis));
        y += (dy > 0) ? cThis : -cThis;

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x - ppdev->xOffset;
    pstrip->ptlStart.y = y - ppdev->yOffset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\textout.c ===
/******************************Module*Header*******************************\
* Module Name: textout.c
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

BYTE gajBit[] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };
                                // Converts bit index to set bit

/******************************Public*Routine******************************\
* VOID vClipSolid
*
* Fills the specified rectangle with the specified colour, honouring
* the requested clipping.
*
\**************************************************************************/

VOID vClipSolid(
PDEV*       ppdev,
RECTL*      prcl,
ULONG       iColor,
CLIPOBJ*    pco)
{
    BOOL            bMore;              // Flag for clip enumeration
    CLIPENUM        ce;                 // Clip enumeration object
    LONG            c;                  // Count of non-empty rectangles
    RBRUSH_COLOR    rbc;                // For passing colour to vFillSolid

    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_RIGHTDOWN, 0);

    // Scan through all the clip rectangles, looking for intersects
    // of fill areas with region rectangles:

    rbc.iSolidColor = iColor;

    do {
        // Get a batch of region rectangles:

        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (VOID*) &ce);

        c = cIntersect(prcl, ce.arcl, ce.c);

        if (c != 0)
            ppdev->pfnFillSolid(ppdev, c, ce.arcl, 0xf0f0, rbc, NULL);

    } while (bMore);
}

/******************************Public*Routine******************************\
* CACHEDFONT* pcfAllocateCachedFont()
*
* Initializes our font data structure.
*
\**************************************************************************/

CACHEDFONT* pcfAllocateCachedFont(
PDEV*   ppdev)
{
    CACHEDFONT*     pcf;
    CACHEDGLYPH**   ppcg;
    LONG            i;

    pcf = AtiAllocMem(LPTR, FL_ZERO_MEMORY, sizeof(CACHEDFONT));

    if (pcf != NULL)
    {
        // Note that we rely on FL_ZERO_MEMORY to zero 'pgaChain' and
        // 'cjAlloc':

        pcf->cgSentinel.hg = HGLYPH_SENTINEL;

        // Initialize the hash table entries to all point to our sentinel:

        for (ppcg = &pcf->apcg[0], i = GLYPH_HASH_SIZE; i != 0; i--, ppcg++)
        {
            *ppcg = &pcf->cgSentinel;
        }
    }

    return(pcf);
}

/******************************Public*Routine******************************\
* VOID vFreeCachedFont()
*
* Frees all memory associated with the cache we kept for this font.
*
\**************************************************************************/

VOID vFreeCachedFont(
CACHEDFONT* pcf)
{
    GLYPHALLOC* pga;
    GLYPHALLOC* pgaNext;


    pga = pcf->pgaChain;
    while (pga != NULL)
    {
        pgaNext = pga->pgaNext;
        AtiFreeMem(pga);
        pga = pgaNext;
    }

    AtiFreeMem(pcf);
}

/******************************Public*Routine******************************\
* VOID vTrimAndPackGlyph
*
\**************************************************************************/

// expandto3 - expand one (monochrome) byte to three (24bpp) bytes, while
// flipping the bits backwards.

#define expandto3(a,b) \
{   \
    if ((a) & 0x80) *(b) |= 0x07; \
    if ((a) & 0x40) *(b) |= 0x38; \
    if ((a) & 0x20) {*(b) |= 0xC0; *((b)+1) |= 0x01;} \
    if ((a) & 0x10) *((b)+1) |= 0x0E; \
    if ((a) & 0x08) *((b)+1) |= 0x70; \
    if ((a) & 0x04) {*((b)+1) |= 0x80; *((b)+2) |= 0x03;} \
    if ((a) & 0x02) *((b)+2) |= 0x1C; \
    if ((a) & 0x01) *((b)+2) |= 0xE0; \
}

VOID vTrimAndPackGlyph(
PDEV*   ppdev,
BYTE*   pjBuf,          // Note: Routine may touch preceding byte!
BYTE*   pjGlyph,
LONG*   pcxGlyph,
LONG*   pcyGlyph,
POINTL* pptlOrigin)
{
    LONG    cxGlyph;
    LONG    cyGlyph;
    POINTL  ptlOrigin;
    LONG    cAlign;
    LONG    lDelta;
    BYTE*   pj;
    BYTE    jBit;
    LONG    cjSrcWidth;
    LONG    lSrcSkip;
    LONG    lDstSkip;
    LONG    cRem;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    i;
    LONG    j;
    BYTE    jSrc;

    ///////////////////////////////////////////////////////////////
    // Trim the glyph

    cyGlyph   = *pcyGlyph;
    cxGlyph   = *pcxGlyph;
    ptlOrigin = *pptlOrigin;
    cAlign    = 0;

    lDelta = (cxGlyph + 7) >> 3;

    // Trim off any zero rows at the bottom of the glyph:

    pj = pjGlyph + cyGlyph * lDelta;    // One past last byte in glyph
    while (cyGlyph > 0)
    {
        i = lDelta;
        do {
            if (*(--pj) != 0)
                goto Done_Bottom_Trim;
        } while (--i != 0);

        // The entire last row has no lit pixels, so simply skip it:

        cyGlyph--;
    }

    ASSERTDD(cyGlyph == 0, "cyGlyph should only be zero here");

    // We found a space character.  Set both dimensions to zero, so
    // that it's easy to special-case later:

    cxGlyph = 0;

Done_Bottom_Trim:

    // If cxGlyph != 0, we know that the glyph has at least one non-zero
    // row and column.  By exploiting this knowledge, we can simplify our
    // end-of-loop tests, because we don't have to check to see if we've
    // decremented either 'cyGlyph' or 'cxGlyph' to zero:

    if (cxGlyph != 0)
    {
        // Trim off any zero rows at the top of the glyph:

        pj = pjGlyph;                       // First byte in glyph
        while (TRUE)
        {
            i = lDelta;
            do {
                if (*(pj++) != 0)
                    goto Done_Top_Trim;
            } while (--i != 0);

            // The entire first row has no lit pixels, so simply skip it:

            cyGlyph--;
            ptlOrigin.y++;
            pjGlyph = pj;
        }

Done_Top_Trim:

        // Trim off any zero columns at the right edge of the glyph:

        while (TRUE)
        {
            j    = cxGlyph - 1;

            pj   = pjGlyph + (j >> 3);      // Last byte in first row of glyph
            jBit = gajBit[j & 0x7];
            i    = cyGlyph;

            do {
                if ((*pj & jBit) != 0)
                    goto Done_Right_Trim;

                pj += lDelta;
            } while (--i != 0);

            // The entire last column has no lit pixels, so simply skip it:

            cxGlyph--;
        }

Done_Right_Trim:

        // Trim off any zero columns at the left edge of the glyph:

        while (TRUE)
        {
            pj   = pjGlyph;                 // First byte in first row of glyph
            jBit = gajBit[cAlign];
            i    = cyGlyph;

            do {
                if ((*pj & jBit) != 0)
                    goto Done_Left_Trim;

                pj += lDelta;
            } while (--i != 0);

            // The entire first column has no lit pixels, so simply skip it:

            ptlOrigin.x++;
            cxGlyph--;
            cAlign++;
            if (cAlign >= 8)
            {
                cAlign = 0;
                pjGlyph++;
            }
        }
    }

Done_Left_Trim:

    ///////////////////////////////////////////////////////////////
    // Pack the glyph
    //
    // N.B.:  The glyph bits are packed in pjBuf backwards.
    // Failure to understand this cost me nearly a week's effort,
    // and gave me a whopping migraine.  (This was for 24bpp.)

    if (ppdev->iBitmapFormat != BMF_24BPP)
    {
        cjSrcWidth  = (cxGlyph + cAlign + 7) >> 3;
        lSrcSkip    = lDelta - cjSrcWidth;
        lDstSkip    = ((cxGlyph + 7) >> 3) - cjSrcWidth - 1;
        cRem        = ((cxGlyph - 1) & 7) + 1;   // 0 -> 8

        pjSrc       = pjGlyph;
        pjDst       = pjBuf;

        // Zero the buffer, because we're going to 'or' stuff into it:

        memset(pjBuf, 0, (cxGlyph * cyGlyph + 7) >> 3);

        // cAlign used to indicate which bit in the first byte of the unpacked
        // glyph was the first non-zero pixel column.  Now, we flip it to
        // indicate which bit in the packed byte will receive the next non-zero
        // glyph bit:

        cAlign = (-cAlign) & 0x7;
        if (cAlign > 0)
        {
            // It would be bad if our trimming calculations were wrong, because
            // we assume any bits to the left of the 'cAlign' bit will be zero.
            // As a result of this decrement, we will 'or' those zero bits into
            // whatever byte precedes the glyph bits array:

            pjDst--;

            ASSERTDD((*pjSrc >> cAlign) == 0, "Trimmed off too many bits");
        }

        for (i = cyGlyph; i != 0; i--)
        {
            for (j = cjSrcWidth; j != 0; j--)
            {
                // Note that we may modify a byte past the end of our
                // destination buffer, which is why we reserved an
                // extra byte:

                jSrc = *pjSrc;
                *(pjDst)     |= (jSrc >> (cAlign));
                *(pjDst + 1) |= (jSrc << (8 - cAlign));
                pjSrc++;
                pjDst++;
            }

            pjSrc  += lSrcSkip;
            pjDst  += lDstSkip;
            cAlign += cRem;

            if (cAlign >= 8)
            {
                cAlign -= 8;
                pjDst++;
            }
        }
    }
    else
    {
        BYTE cur_byte, last_byte, last_byte2, next_byte;

        cjSrcWidth  = (cxGlyph + cAlign + 7) >> 3;
        lSrcSkip    = lDelta - cjSrcWidth;
        lDstSkip    = (((cxGlyph + 7) >> 3) - cjSrcWidth - 1) * 3;
        cRem        = ((cxGlyph - 1) & 7) + 1;   // 0 -> 8

        pjSrc       = pjGlyph;
        pjDst       = pjBuf;

        // Zero the buffer, because we're going to 'or' stuff into it:

        memset(pjBuf, 0, (3 * cxGlyph * cyGlyph + 7) >> 3);

        // cAlign used to indicate which bit in the first byte of the unpacked
        // glyph was the first non-zero pixel column.  Now, we flip it to
        // indicate which bit in the packed byte will receive the next non-zero
        // glyph bit:

        cAlign = (-cAlign) & 0x7;
        if (cAlign > 0)
        {
            // It would be bad if our trimming calculations were wrong, because
            // we assume any bits to the left of the 'cAlign' bit will be zero.
            // As a result of this decrement, we will 'or' those zero bits into
            // whatever bytes precedes the glyph bits array:

            pjDst -= 3;

            ASSERTDD((*pjSrc >> cAlign) == 0, "Trimmed off too many bits");
        }

        cur_byte = last_byte = 0;
        for (i = cyGlyph; i != 0; i--)
        {
            for (j = cjSrcWidth; j != 0; j--)
            {
                // Note that we may modify a byte past the end of our
                // destination buffer, which is why we reserved an
                // extra three bytes:

                jSrc = *pjSrc;
                cur_byte |= (jSrc >> (cAlign));
                expandto3(cur_byte, pjDst);

                next_byte = (jSrc << (8 - cAlign));
                expandto3(next_byte, pjDst+3);

                pjSrc++;
                pjDst     += 3;
                last_byte2 = last_byte;
                last_byte  = cur_byte;
                cur_byte   = next_byte;
            }

            pjSrc   += lSrcSkip;
            pjDst   += lDstSkip;    // can be -3 or -6 (if cAlign is big enough) !!
            cAlign  += cRem;
            cur_byte = (lDstSkip != -3)? last_byte2:last_byte;

            if (cAlign >= 8)
            {
                cAlign  -= 8;
                pjDst   += 3;
                cur_byte = (lDstSkip != -3)? last_byte:next_byte;
            }
        }

        cxGlyph *= 3;
    }

    ///////////////////////////////////////////////////////////////
    // Return results

    *pcxGlyph   = cxGlyph;
    *pcyGlyph   = cyGlyph;
    *pptlOrigin = ptlOrigin;
}

/******************************Public*Routine******************************\
* VOID vPutGlyphInCache
*
* Figures out where to be a glyph in off-screen memory, copies it
* there, and fills in any other data we'll need to display the glyph.
*
* This routine is rather device-specific, and will have to be extensively
* modified for other display adapters.
*
* Returns TRUE if successful; FALSE if there wasn't enough room in
* off-screen memory.
*
\**************************************************************************/

VOID vPutGlyphInCache(
PDEV*           ppdev,
CACHEDGLYPH*    pcg,
GLYPHBITS*      pgb)
{
    BYTE*   pjGlyph;
    LONG    cxGlyph;
    LONG    cyGlyph;
    POINTL  ptlOrigin;

    pjGlyph   = pgb->aj;
    cyGlyph   = pgb->sizlBitmap.cy;
    cxGlyph   = pgb->sizlBitmap.cx;
    ptlOrigin = pgb->ptlOrigin;

    vTrimAndPackGlyph(ppdev, (BYTE*) &pcg->ad, pjGlyph, &cxGlyph, &cyGlyph, &ptlOrigin);

    ///////////////////////////////////////////////////////////////
    // Initialize the glyph fields

    pcg->ptlOrigin     = ptlOrigin;
    pcg->cx            = cxGlyph;
    pcg->cy            = cyGlyph;
    pcg->cxy           = pcg->cy | (pcg->cx << 16);
    pcg->cw            = (cxGlyph * cyGlyph + 15) >> 4;
    pcg->cd            = (pcg->cw + 1) >> 1;
}

/******************************Public*Routine******************************\
* CACHEDGLYPH* pcgNew()
*
* Creates a new CACHEDGLYPH structure for keeping track of the glyph in
* off-screen memory.  bPutGlyphInCache is called to actually put the glyph
* in off-screen memory.
*
* This routine should be reasonably device-independent, as bPutGlyphInCache
* will contain most of the code that will have to be modified for other
* display adapters.
*
\**************************************************************************/

CACHEDGLYPH* pcgNew(
PDEV*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgp)
{
    GLYPHBITS*      pgb;
    GLYPHALLOC*     pga;
    CACHEDGLYPH*    pcg;
    LONG            cjCachedGlyph;
    HGLYPH          hg;
    LONG            iHash;
    CACHEDGLYPH*    pcgFind;

    // First, calculate the amount of storage we'll need for this glyph:

    pgb = pgp->pgdf->pgb;

    if (ppdev->iBitmapFormat != BMF_24BPP)
    {
        cjCachedGlyph = sizeof(CACHEDGLYPH)
                      + ((pgb->sizlBitmap.cx * pgb->sizlBitmap.cy + 7) >> 3);

        // Reserve an extra byte at the end for temporary usage by our pack
        // routine:

        cjCachedGlyph++;
    }
    else
    {
        cjCachedGlyph = sizeof(CACHEDGLYPH)
                      + ((3 * pgb->sizlBitmap.cx * pgb->sizlBitmap.cy + 7) >> 3);

        // Reserve 3 extra bytes at the end for temporary usage by our pack
        // routine:

        cjCachedGlyph += 3;
    }

    // We need to dword align it too:

    cjCachedGlyph = (cjCachedGlyph + 3) & ~3L;

    if (cjCachedGlyph > pcf->cjAlloc)
    {
        // Have to allocate a new glyph allocation structure:

        pga = AtiAllocMem(LPTR, FL_ZERO_MEMORY, GLYPH_ALLOC_SIZE);
        if (pga == NULL)
        {
            // It's safe to return at this time because we haven't
            // fatally altered any of our data structures:

            return(NULL);
        }

        // Add this allocation to the front of the allocation linked list,
        // so that we can free it later:

        pga->pgaNext  = pcf->pgaChain;
        pcf->pgaChain = pga;

        // Now we've got a chunk of memory where we can store our cached
        // glyphs:

        pcf->pcgNew  = &pga->acg[0];
        pcf->cjAlloc = GLYPH_ALLOC_SIZE - (sizeof(*pga) - sizeof(pga->acg[0]));

        // It would be bad if we let in any glyphs that would be bigger
        // than our basic allocation size:

        ASSERTDD(cjCachedGlyph <= GLYPH_ALLOC_SIZE, "Woah, this is one big glyph!");
    }

    pcg = pcf->pcgNew;

    // We only need to ensure 'dword' alignment of the next structure:

    pcf->pcgNew   = (CACHEDGLYPH*) ((BYTE*) pcg + cjCachedGlyph);
    pcf->cjAlloc -= cjCachedGlyph;

    ///////////////////////////////////////////////////////////////
    // Insert the glyph, in-order, into the list hanging off our hash
    // bucket:

    hg = pgp->hg;

    pcg->hg = hg;
    iHash   = GLYPH_HASH_FUNC(hg);
    pcgFind = pcf->apcg[iHash];

    if (pcgFind->hg > hg)
    {
        pcf->apcg[iHash] = pcg;
        pcg->pcgNext     = pcgFind;
    }
    else
    {
        // The sentinel will ensure that we never fall off the end of
        // this list:

        while (pcgFind->pcgNext->hg < hg)
            pcgFind = pcgFind->pcgNext;

        // 'pcgFind' now points to the entry to the entry after which
        // we want to insert our new node:

        pcg->pcgNext     = pcgFind->pcgNext;
        pcgFind->pcgNext = pcg;
    }

    vPutGlyphInCache(ppdev, pcg, pgp->pgdf->pgb);

    return(pcg);
}

/******************************Public*Routine******************************\
* BOOL bI32CachedProportionalText
*
* Draws proportionally spaced glyphs via glyph caching.
*
\**************************************************************************/

BOOL bI32CachedProportionalText(
PDEV*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgp,
LONG        cGlyph)
{
    BYTE*           pjIoBase;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    LONG            xOffset;
    LONG            yOffset;
    LONG            x;
    LONG            y;
    LONG            cw;
    WORD*           pw;

    pjIoBase = ppdev->pjIoBase;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    do {
        hg  = pgp->hg;
        pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

        while (pcg->hg < hg) {
            pcg = pcg->pcgNext;
        }

        if (pcg->hg > hg)
        {
            // This will hopefully not be the common case (that is,
            // we will have a high cache hit rate), so if I were
            // writing this in Asm I would have this out-of-line
            // to avoid the jump around for the common case.
            // But the Pentium has branch prediction, so what the
            // heck.

            pcg = pcgNew(ppdev, pcf, pgp);
            if (pcg == NULL)
                return(FALSE);
        }

        // Space glyphs are trimmed to a height of zero, and we don't
        // even have to touch the hardware for them:

        if (pcg->cx != 0)
        {
            // The glyph's origin y-coordinate may often be negative, so we
            // can't compute this as follows:
            //
            // x = pgp->ptl.x + pcg->ptlOrigin.x;
            // y = pgp->ptl.y + pcg->ptlOrigin.y;

            ASSERTDD((pgp->ptl.y + pcg->ptlOrigin.y) >= 0,
                "Can't have negative 'y' coordinates here");

            I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 5);

            x = xOffset + pgp->ptl.x + pcg->ptlOrigin.x;
            I32_OW(pjIoBase, CUR_X,        x);
            I32_OW(pjIoBase, DEST_X_START, x);
            I32_OW(pjIoBase, DEST_X_END,   x + pcg->cx);

            y = yOffset + pgp->ptl.y + pcg->ptlOrigin.y;
            I32_OW(pjIoBase, CUR_Y,        y);
            I32_OW(pjIoBase, DEST_Y_END,   y + pcg->cy);

            // Take advantage of wait-stated I/O:

            pw = (WORD*) &pcg->ad[0];
            cw = pcg->cw;

            I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 10);

            do {
                I32_OW_DIRECT(pjIoBase, PIX_TRANS, *pw);
            } while (pw++, --cw != 0);
        }

    } while (pgp++, --cGlyph != 0);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bI32CachedFixedText
*
* Draws fixed spaced glyphs via glyph caching.
*
\*************************************************************************/

BOOL bI32CachedFixedText(
PDEV*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgp,
LONG        cGlyph,
ULONG       ulCharInc)
{
    BYTE*           pjIoBase;
    LONG            xGlyph;
    LONG            yGlyph;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    LONG            x;
    LONG            y;
    WORD*           pw;
    LONG            cw;

    pjIoBase = ppdev->pjIoBase;

    // Convert to absolute coordinates:

    xGlyph = pgp->ptl.x + ppdev->xOffset;
    yGlyph = pgp->ptl.y + ppdev->yOffset;

    do {
        hg  = pgp->hg;
        pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

        while (pcg->hg < hg) {
            pcg = pcg->pcgNext;
        }

        if (pcg->hg > hg)
        {
            // This will hopefully not be the common case (that is,
            // we will have a high cache hit rate), so if I were
            // writing this in Asm I would have this out-of-line
            // to avoid the jump around for the common case.
            // But the Pentium has branch prediction, so what the
            // heck.

            pcg = pcgNew(ppdev, pcf, pgp);
            if (pcg == NULL)
                return(FALSE);
        }

        // Space glyphs are trimmed to a height of zero, and we don't
        // even have to touch the hardware for them:

        if (pcg->cx != 0)
        {
            x = xGlyph + pcg->ptlOrigin.x;
            y = yGlyph + pcg->ptlOrigin.y;

            I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 5);

            I32_OW(pjIoBase, CUR_X,        x);
            I32_OW(pjIoBase, DEST_X_START, x);
            I32_OW(pjIoBase, DEST_X_END,   x + pcg->cx);
            I32_OW(pjIoBase, CUR_Y,        y);
            I32_OW(pjIoBase, DEST_Y_END,   y + pcg->cy);

            // Take advantage of wait-stated I/O:

            pw = (WORD*) &pcg->ad[0];
            cw = pcg->cw;

            I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 10);

            do {
                I32_OW_DIRECT(pjIoBase, PIX_TRANS, *pw);
            } while (pw++, --cw != 0);
        }

        xGlyph += ulCharInc;

    } while (pgp++, --cGlyph != 0);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bI32CachedClippedText
*
* Draws clipped text via glyph caching.
*
\**************************************************************************/

BOOL bI32CachedClippedText(
PDEV*       ppdev,
CACHEDFONT* pcf,
STROBJ*     pstro,
CLIPOBJ*    pco)
{
    BOOL            bRet;
    BYTE*           pjIoBase;
    LONG            xOffset;
    LONG            yOffset;
    BOOL            bMoreGlyphs;
    ULONG           cGlyphOriginal;
    ULONG           cGlyph;
    BOOL            bClippingSet;
    GLYPHPOS*       pgpOriginal;
    GLYPHPOS*       pgp;
    LONG            xGlyph;
    LONG            yGlyph;
    LONG            x;
    LONG            y;
    LONG            xRight;
    LONG            yBottom;
    LONG            cy;
    BOOL            bMore;
    CLIPENUM        ce;
    RECTL*          prclClip;
    ULONG           ulCharInc;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    WORD*           pw;
    LONG            cw;

    ASSERTDD((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL),
             "Don't expect trivial clipping in this function");

    bRet      = TRUE;
    pjIoBase    = ppdev->pjIoBase;
    xOffset   = ppdev->xOffset;
    yOffset   = ppdev->yOffset;
    ulCharInc = pstro->ulCharInc;

    do {
      if (pstro->pgp != NULL)
      {
        // There's only the one batch of glyphs, so save ourselves
        // a call:

        pgpOriginal    = pstro->pgp;
        cGlyphOriginal = pstro->cGlyphs;
        bMoreGlyphs    = FALSE;
      }
      else
      {
        bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
      }

      if (cGlyphOriginal > 0)
      {
        if (pco->iDComplexity == DC_RECT)
        {
          // We could call 'cEnumStart' and 'bEnum' when the clipping is
          // DC_RECT, but the last time I checked, those two calls took
          // more than 150 instructions to go through GDI.  Since
          // 'rclBounds' already contains the DC_RECT clip rectangle,
          // and since it's such a common case, we'll special case it:

          bMore    = FALSE;
          ce.c     = 1;
          prclClip = &pco->rclBounds;

          goto SingleRectangle;
        }

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do {
          bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

          for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
          {

          SingleRectangle:

            // We don't always simply set the clipping rectangle here
            // because it may actually end up that no text intersects
            // this clip rectangle, so it would be for naught.  This
            // actually happens a lot when using NT's analog clock set
            // to always-on-top, with a round shape:

            bClippingSet = FALSE;

            pgp    = pgpOriginal;
            cGlyph = cGlyphOriginal;

            // We can't yet convert to absolute coordinates by adding
            // in 'xOffset' or 'yOffset' here because we have yet to
            // compare the coordinates to 'prclClip':

            xGlyph = pgp->ptl.x;
            yGlyph = pgp->ptl.y;

            // Loop through all the glyphs for this rectangle:

            while (TRUE)
            {
              hg  = pgp->hg;
              pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

              while (pcg->hg < hg)
                pcg = pcg->pcgNext;

              if (pcg->hg > hg)
              {
                // This will hopefully not be the common case (that is,
                // we will have a high cache hit rate), so if I were
                // writing this in Asm I would have this out-of-line
                // to avoid the jump around for the common case.
                // But the Pentium has branch prediction, so what the
                // heck.

                pcg = pcgNew(ppdev, pcf, pgp);
                if (pcg == NULL)
                {
                  bRet = FALSE;
                  goto AllDone;
                }
              }

              // Space glyphs are trimmed to a height of zero, and we don't
              // even have to touch the hardware for them:

              cy = pcg->cy;
              if (cy != 0)
              {
                y       = pcg->ptlOrigin.y + yGlyph;
                x       = pcg->ptlOrigin.x + xGlyph;
                xRight  = pcg->cx + x;
                yBottom = pcg->cy + y;

                // Do trivial rejection:

                if ((prclClip->right  > x) &&
                    (prclClip->bottom > y) &&
                    (prclClip->left   < xRight) &&
                    (prclClip->top    < yBottom))
                {
                  // Lazily set the hardware clipping:

                  if (!bClippingSet)
                  {
                    bClippingSet = TRUE;
                    vSetClipping(ppdev, prclClip);
                  }

                  I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 5);

                  I32_OW(pjIoBase, CUR_X,        xOffset + x);
                  I32_OW(pjIoBase, DEST_X_START, xOffset + x);
                  I32_OW(pjIoBase, DEST_X_END,   xOffset + xRight);
                  I32_OW(pjIoBase, CUR_Y,        yOffset + y);
                  I32_OW(pjIoBase, DEST_Y_END,   yOffset + yBottom);

                  I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 10);

                  pw = (WORD*) &pcg->ad[0];
                  cw = pcg->cw;

                  do {
                      I32_OW_DIRECT(pjIoBase, PIX_TRANS, *pw);
                  } while (pw++, --cw != 0);
                }
              }

              if (--cGlyph == 0)
                break;

              // Get ready for next glyph:

              pgp++;

              if (ulCharInc == 0)
              {
                xGlyph = pgp->ptl.x;
                yGlyph = pgp->ptl.y;
              }
              else
              {
                xGlyph += ulCharInc;
              }
            }
          }
        } while (bMore);
      }
    } while (bMoreGlyphs);

AllDone:

    vResetClipping(ppdev);

    return(bRet);
}

VOID vI32DataPortOutB(PDEV *ppdev, PBYTE pb, UINT count)
{
    BYTE *pjIoBase = ppdev->pjIoBase;
    UINT i;

    for (i=0; i < count; i++)
        {
        if (i % 8 == 0)
            I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 10);

        I32_OB(pjIoBase, PIX_TRANS + 1, *((PUCHAR)pb)++);
        }
}

 /******************************Public*Routine******************************\
* BOOL bI32GeneralText
*
\**************************************************************************/

BOOL bI32GeneralText(
PDEV*     ppdev,
STROBJ*   pstro,
CLIPOBJ*  pco)
{
    BYTE*       pjIoBase;
    BYTE        iDComplexity;
    BOOL        bMoreGlyphs;
    ULONG       cGlyphOriginal;
    ULONG       cGlyph;
    GLYPHPOS*   pgpOriginal;
    GLYPHPOS*   pgp;
    GLYPHBITS*  pgb;
    POINTL      ptlOrigin;
    BOOL        bMore;
    CLIPENUM    ce;
    RECTL*      prclClip;
    ULONG       ulCharInc;
    LONG        cxGlyph;
    LONG        cyGlyph;
    LONG        xBiasL = 0;
    LONG        xBiasR = 0;
    LONG        yBiasT = 0;
    LONG        cy = 0;
    LONG        cx = 0;
    BYTE*       pjGlyph;
    LONG        xLeft;
    LONG        yTop;
    LONG        xRight;
    LONG        yBottom;
    RECTL       NoClip;
    LONG        x;
    LONG        y;

    pjIoBase = ppdev->pjIoBase;

    /* Define Default Clipping area to be full video ram */
    NoClip.top    = 0;
    NoClip.left   = 0;
    NoClip.right  = ppdev->cxScreen;
    NoClip.bottom = ppdev->cyScreen;

    if (pco == NULL)
        iDComplexity = DC_TRIVIAL;
    else
        iDComplexity = pco->iDComplexity;

    do {

      if (pstro->pgp != NULL)
      {
        // There's only the one batch of glyphs, so save ourselves
        // a call:

        pgpOriginal    = pstro->pgp;
        cGlyphOriginal = pstro->cGlyphs;
        bMoreGlyphs    = FALSE;
      }
      else
      {
        bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
      }

      if (cGlyphOriginal > 0)
      {
        ulCharInc = pstro->ulCharInc;

        if (iDComplexity != DC_COMPLEX)
        {
            // We could call 'cEnumStart' and 'bEnum' when the clipping is
            // DC_RECT, but the last time I checked, those two calls took
            // more than 150 instructions to go through GDI.  Since
            // 'rclBounds' already contains the DC_RECT clip rectangle,
            // and since it's such a common case, we'll special case it:

            bMore = FALSE;
            ce.c  = 1;

            if (iDComplexity == DC_TRIVIAL)
                prclClip = &NoClip;
            else
                prclClip = &pco->rclBounds;

            goto SingleRectangle;

        }

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do {

          bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

          for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
          {

          SingleRectangle:

            pgp    = pgpOriginal;
            cGlyph = cGlyphOriginal;
            pgb    = pgp->pgdf->pgb;

            ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
            ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

            vSetClipping(ppdev, prclClip);
            //ppdev->lRightScissor = rclRealClip.right;  ???

            // Loop through all the glyphs for this rectangle:

            while (TRUE)
            {
              cxGlyph  = pgb->sizlBitmap.cx;
              cyGlyph  = pgb->sizlBitmap.cy;
              pjGlyph = (BYTE*) pgb->aj;


              if ((prclClip->left   <= ptlOrigin.x) &&
                  (prclClip->top    <= ptlOrigin.y) &&
                  (prclClip->right  >= ptlOrigin.x + cxGlyph) &&
                  (prclClip->bottom >= ptlOrigin.y + cyGlyph))
              {
                //-----------------------------------------------------
                // Unclipped glyph

                I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 6);

                x = ppdev->xOffset + ptlOrigin.x;
                I32_OW(pjIoBase, CUR_X, LOWORD(x));
                I32_OW(pjIoBase, DEST_X_START, LOWORD(x));
                I32_OW(pjIoBase, DEST_X_END, LOWORD(x) + ROUND8(cxGlyph) );
                I32_OW(pjIoBase, SCISSOR_R, LOWORD(x) + cxGlyph-1);

                y = ppdev->yOffset + ptlOrigin.y;
                I32_OW(pjIoBase, CUR_Y, LOWORD(y));

                I32_OW(pjIoBase, DEST_Y_END, (LOWORD(y) + cyGlyph));

                vI32DataPortOutB(ppdev, pjGlyph, (ROUND8(cxGlyph) * cyGlyph) >> 3);

                /*
                _vBlit_DSC_SH1UP(ppdev,ptlOrigin.x, ptlOrigin.y,
                               cxGlyph, cyGlyph, pjGlyph,
                               (ROUND8(cxGlyph) * cyGlyph) >> 3);
                */

              }
              else
              {
                //-----------------------------------------------------
                // Clipped glyph

                // Find the intersection of the glyph rectangle
                // and the clip rectangle:

                xLeft   = max(prclClip->left,   ptlOrigin.x);
                yTop    = max(prclClip->top,    ptlOrigin.y);
                xRight  = min(prclClip->right,  ptlOrigin.x + cxGlyph);
                yBottom = min(prclClip->bottom, ptlOrigin.y + cyGlyph);

                // Check for trivial rejection:

                if ( ( ptlOrigin.x <= prclClip->left ) &&
                     (ppdev->pModeInfo->ModeFlags & AMI_TEXTBAND) )
                    {
                    vResetClipping(ppdev);
                    return FALSE;
                    }

                if (((cx = xRight - xLeft) > 0) &&
                    ((cy = yBottom - yTop) > 0))
                {

                  /* Do software clipping */

                  /* Calculated the Bias in pixels */

                  yBiasT = (yTop - ptlOrigin.y);

                  /*  change address of pjGlyph to point +yBiasT
                      scan lines into the Glyph */

                  pjGlyph += (yBiasT * (ROUND8(cxGlyph) >> 3));

                  I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 6);

                  x = ppdev->xOffset + ptlOrigin.x;
                  I32_OW(pjIoBase, CUR_X, LOWORD(x));
                  I32_OW(pjIoBase, DEST_X_START, LOWORD(x));
                  I32_OW(pjIoBase, DEST_X_END, LOWORD(x) + ROUND8(cxGlyph) );
                  I32_OW(pjIoBase, SCISSOR_R, LOWORD(x) + cxGlyph-1);

                  y = ppdev->yOffset + ptlOrigin.y;
                  I32_OW(pjIoBase, CUR_Y, LOWORD(y+yBiasT));

                  I32_OW(pjIoBase, DEST_Y_END, (LOWORD(y+yBiasT) + cy));

                  vI32DataPortOutB(ppdev, pjGlyph, (ROUND8(cxGlyph) >> 3) * cy);

                  /*
                  _vBlit_DSC_SH1UP(ppdev,ptlOrigin.x,ptlOrigin.y+yBiasT,
                                 cxGlyph, cy, pjGlyph,
                                 (ROUND8(cxGlyph) >>3) * cy);
                  */

                } /*if*/

              }

              if (--cGlyph == 0)
                break;

              // Get ready for next glyph:

              pgp++;
              pgb = pgp->pgdf->pgb;

              if (ulCharInc == 0)
              {
                ptlOrigin.x = pgp->ptl.x + pgb->ptlOrigin.x;
                ptlOrigin.y = pgp->ptl.y + pgb->ptlOrigin.y;
              }
              else
              {
                ptlOrigin.x += ulCharInc;
              }

            }
          }
        } while (bMore);
      }
    } while (bMoreGlyphs);

    vResetClipping(ppdev);

    return TRUE;
}

/******************************Public*Routine******************************\
* BOOL bI32TextOut
*
\**************************************************************************/

BOOL bI32TextOut(
PDEV*       ppdev,
STROBJ*     pstro,
FONTOBJ*    pfo,
CLIPOBJ*    pco,
RECTL*      prclOpaque,
BRUSHOBJ*   pboFore,
BRUSHOBJ*   pboOpaque)
{
    BYTE*           pjIoBase;
    LONG            xOffset;
    LONG            yOffset;
    ULONG           cGlyph;
    BOOL            bMoreGlyphs;
    GLYPHPOS*       pgp;
    BYTE            iDComplexity;
    CACHEDFONT*     pcf;
    RECTL           rclOpaque;
    BOOL            bTextPerfectFit;

    pjIoBase = ppdev->pjIoBase;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if (prclOpaque != NULL)
    {
      ////////////////////////////////////////////////////////////
      // Opaque Initialization
      ////////////////////////////////////////////////////////////

      if (iDComplexity == DC_TRIVIAL)
      {

      DrawOpaqueRect:

        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 8);

        I32_OW(pjIoBase, FRGD_COLOR,   pboOpaque->iSolidColor);
        I32_OW(pjIoBase, ALU_FG_FN,    OVERPAINT);
        I32_OW(pjIoBase, DP_CONFIG,    FG_COLOR_SRC_FG | WRITE | DRAW);
        I32_OW(pjIoBase, CUR_X,        xOffset + prclOpaque->left);
        I32_OW(pjIoBase, DEST_X_START, xOffset + prclOpaque->left);
        I32_OW(pjIoBase, DEST_X_END,   xOffset + prclOpaque->right);
        I32_OW(pjIoBase, CUR_Y,        yOffset + prclOpaque->top);

        vI32QuietDown(ppdev, pjIoBase);

        I32_OW(pjIoBase, DEST_Y_END,   yOffset + prclOpaque->bottom);
      }
      else if (iDComplexity == DC_RECT)
      {
        if (bIntersect(prclOpaque, &pco->rclBounds, &rclOpaque))
        {
          prclOpaque = &rclOpaque;
          goto DrawOpaqueRect;
        }
      }
      else
      {
        vClipSolid(ppdev, prclOpaque, pboOpaque->iSolidColor, pco);
      }

      bTextPerfectFit = (pstro->flAccel & (SO_ZERO_BEARINGS |
              SO_FLAG_DEFAULT_PLACEMENT | SO_MAXEXT_EQUAL_BM_SIDE |
              SO_CHAR_INC_EQUAL_BM_BASE)) ==
              (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
              SO_MAXEXT_EQUAL_BM_SIDE | SO_CHAR_INC_EQUAL_BM_BASE);

      if (bTextPerfectFit)
      {
        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 5);
        I32_OW(pjIoBase, ALU_BG_FN,  OVERPAINT);
        I32_OW(pjIoBase, BKGD_COLOR, pboOpaque->iSolidColor);
        goto SkipTransparentInitialization;
      }
    }

    ////////////////////////////////////////////////////////////
    // Transparent Initialization
    ////////////////////////////////////////////////////////////

    I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 4);
    I32_OW(pjIoBase, ALU_BG_FN, LEAVE_ALONE);

SkipTransparentInitialization:

    I32_OW(pjIoBase, DP_CONFIG,   EXT_MONO_SRC_HOST | DRAW | WRITE |
                                  FG_COLOR_SRC_FG | BG_COLOR_SRC_BG |
                                  LSB_FIRST | BIT16);
    I32_OW(pjIoBase, ALU_FG_FN,   OVERPAINT);
    I32_OW(pjIoBase, FRGD_COLOR,  pboFore->iSolidColor);

    if ((pfo->cxMax <= GLYPH_CACHE_CX) &&
        ((pstro->rclBkGround.bottom - pstro->rclBkGround.top) <= GLYPH_CACHE_CY))
    {
      pcf = (CACHEDFONT*) pfo->pvConsumer;

      if (pcf == NULL)
      {
        pcf = pcfAllocateCachedFont(ppdev);
        if (pcf == NULL)
          return(FALSE);

        pfo->pvConsumer = pcf;
      }

      // Use our glyph cache:

      if (iDComplexity == DC_TRIVIAL)
      {
        do {
          if (pstro->pgp != NULL)
          {
            // There's only the one batch of glyphs, so save ourselves
            // a call:

            pgp         = pstro->pgp;
            cGlyph      = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
          }
          else
          {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
          }

          if (cGlyph > 0)
          {
            if (pstro->ulCharInc == 0)
            {
              if (!bI32CachedProportionalText(ppdev, pcf, pgp, cGlyph))
                return(FALSE);
            }
            else
            {
              if (!bI32CachedFixedText(ppdev, pcf, pgp, cGlyph, pstro->ulCharInc))
                return(FALSE);
            }
          }
        } while (bMoreGlyphs);
      }
      else
      {
        if (!bI32CachedClippedText(ppdev, pcf, pstro, pco))
          return(FALSE);
      }
    }
    else
    {
      DISPDBG((4, "Text too big to cache: %li x %li",
             pfo->cxMax, pstro->rclBkGround.bottom - pstro->rclBkGround.top));

      I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 1);
      I32_OW(pjIoBase, DP_CONFIG, EXT_MONO_SRC_HOST | DRAW | WRITE |
                                  FG_COLOR_SRC_FG | BG_COLOR_SRC_BG);

      return bI32GeneralText(ppdev, pstro, pco);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bM32CachedProportionalText
*
* Draws proportionally spaced glyphs via glyph caching.
*
\**************************************************************************/

BOOL bM32CachedProportionalText(
PDEV*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgp,
LONG        cGlyph)
{
    BYTE*           pjMmBase;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    LONG            xOffset;
    LONG            yOffset;
    LONG            x;
    LONG            y;
    LONG            cw;
    WORD*           pw;

    pjMmBase = ppdev->pjMmBase;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    do {
        hg  = pgp->hg;
        pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

        while (pcg->hg < hg) {
            pcg = pcg->pcgNext;
        }

        if (pcg->hg > hg)
        {
            // This will hopefully not be the common case (that is,
            // we will have a high cache hit rate), so if I were
            // writing this in Asm I would have this out-of-line
            // to avoid the jump around for the common case.
            // But the Pentium has branch prediction, so what the
            // heck.

            pcg = pcgNew(ppdev, pcf, pgp);
            if (pcg == NULL)
                return(FALSE);
        }

        // Space glyphs are trimmed to a height of zero, and we don't
        // even have to touch the hardware for them:

        if (pcg->cx != 0)
        {
            // The glyph's origin y-coordinate may often be negative, so we
            // can't compute this as follows:
            //
            // x = pgp->ptl.x + pcg->ptlOrigin.x;
            // y = pgp->ptl.y + pcg->ptlOrigin.y;

            ASSERTDD((pgp->ptl.y + pcg->ptlOrigin.y) >= 0,
                "Can't have negative 'y' coordinates here");

            M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);

            x = xOffset + pgp->ptl.x + pcg->ptlOrigin.x;
            M32_OW(pjMmBase, CUR_X,        x);
            M32_OW(pjMmBase, DEST_X_START, x);
            M32_OW(pjMmBase, DEST_X_END,   x + pcg->cx);

            y = yOffset + pgp->ptl.y + pcg->ptlOrigin.y;
            M32_OW(pjMmBase, CUR_Y,        y);
            M32_OW(pjMmBase, DEST_Y_END,   y + pcg->cy);

            // Take advantage of wait-stated I/O:

            pw = (WORD*) &pcg->ad[0];
            cw = pcg->cw;

            M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 10);

            do {
                M32_OW_DIRECT(pjMmBase, PIX_TRANS, *pw);
            } while (pw++, --cw != 0);
        }

    } while (pgp++, --cGlyph != 0);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bM32CachedFixedText
*
* Draws fixed spaced glyphs via glyph caching.
*
\*************************************************************************/

BOOL bM32CachedFixedText(
PDEV*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgp,
LONG        cGlyph,
ULONG       ulCharInc)
{
    BYTE*           pjMmBase;
    LONG            xGlyph;
    LONG            yGlyph;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    LONG            x;
    LONG            y;
    WORD*           pw;
    LONG            cw;

    pjMmBase = ppdev->pjMmBase;

    // Convert to absolute coordinates:

    xGlyph = pgp->ptl.x + ppdev->xOffset;
    yGlyph = pgp->ptl.y + ppdev->yOffset;

    do {
        hg  = pgp->hg;
        pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

        while (pcg->hg < hg) {
            pcg = pcg->pcgNext;
        }

        if (pcg->hg > hg)
        {
            // This will hopefully not be the common case (that is,
            // we will have a high cache hit rate), so if I were
            // writing this in Asm I would have this out-of-line
            // to avoid the jump around for the common case.
            // But the Pentium has branch prediction, so what the
            // heck.

            pcg = pcgNew(ppdev, pcf, pgp);
            if (pcg == NULL)
                return(FALSE);
        }

        // Space glyphs are trimmed to a height of zero, and we don't
        // even have to touch the hardware for them:

        if (pcg->cx != 0)
        {
            x = xGlyph + pcg->ptlOrigin.x;
            y = yGlyph + pcg->ptlOrigin.y;

            M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);

            M32_OW(pjMmBase, CUR_X,        x);
            M32_OW(pjMmBase, DEST_X_START, x);
            M32_OW(pjMmBase, DEST_X_END,   x + pcg->cx);
            M32_OW(pjMmBase, CUR_Y,        y);
            M32_OW(pjMmBase, DEST_Y_END,   y + pcg->cy);

            // Take advantage of wait-stated I/O:

            pw = (WORD*) &pcg->ad[0];
            cw = pcg->cw;

            M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 10);

            do {
                M32_OW_DIRECT(pjMmBase, PIX_TRANS, *pw);
            } while (pw++, --cw != 0);
        }

        xGlyph += ulCharInc;

    } while (pgp++, --cGlyph != 0);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bM32CachedClippedText
*
* Draws clipped text via glyph caching.
*
\**************************************************************************/

BOOL bM32CachedClippedText(
PDEV*       ppdev,
CACHEDFONT* pcf,
STROBJ*     pstro,
CLIPOBJ*    pco)
{
    BOOL            bRet;
    BYTE*           pjMmBase;
    LONG            xOffset;
    LONG            yOffset;
    BOOL            bMoreGlyphs;
    ULONG           cGlyphOriginal;
    ULONG           cGlyph;
    BOOL            bClippingSet;
    GLYPHPOS*       pgpOriginal;
    GLYPHPOS*       pgp;
    LONG            xGlyph;
    LONG            yGlyph;
    LONG            x;
    LONG            y;
    LONG            xRight;
    LONG            yBottom;
    LONG            cy;
    BOOL            bMore;
    CLIPENUM        ce;
    RECTL*          prclClip;
    ULONG           ulCharInc;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    WORD*           pw;
    LONG            cw;

    ASSERTDD((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL),
             "Don't expect trivial clipping in this function");

    bRet      = TRUE;
    pjMmBase    = ppdev->pjMmBase;
    xOffset   = ppdev->xOffset;
    yOffset   = ppdev->yOffset;
    ulCharInc = pstro->ulCharInc;

    do {
      if (pstro->pgp != NULL)
      {
        // There's only the one batch of glyphs, so save ourselves
        // a call:

        pgpOriginal    = pstro->pgp;
        cGlyphOriginal = pstro->cGlyphs;
        bMoreGlyphs    = FALSE;
      }
      else
      {
        bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
      }

      if (cGlyphOriginal > 0)
      {
        if (pco->iDComplexity == DC_RECT)
        {
          // We could call 'cEnumStart' and 'bEnum' when the clipping is
          // DC_RECT, but the last time I checked, those two calls took
          // more than 150 instructions to go through GDI.  Since
          // 'rclBounds' already contains the DC_RECT clip rectangle,
          // and since it's such a common case, we'll special case it:

          bMore    = FALSE;
          ce.c     = 1;
          prclClip = &pco->rclBounds;

          goto SingleRectangle;
        }

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do {
          bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

          for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
          {

          SingleRectangle:

            // We don't always simply set the clipping rectangle here
            // because it may actually end up that no text intersects
            // this clip rectangle, so it would be for naught.  This
            // actually happens a lot when using NT's analog clock set
            // to always-on-top, with a round shape:

            bClippingSet = FALSE;

            pgp    = pgpOriginal;
            cGlyph = cGlyphOriginal;

            // We can't yet convert to absolute coordinates by adding
            // in 'xOffset' or 'yOffset' here because we have yet to
            // compare the coordinates to 'prclClip':

            xGlyph = pgp->ptl.x;
            yGlyph = pgp->ptl.y;

            // Loop through all the glyphs for this rectangle:

            while (TRUE)
            {
              hg  = pgp->hg;
              pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

              while (pcg->hg < hg)
                pcg = pcg->pcgNext;

              if (pcg->hg > hg)
              {
                // This will hopefully not be the common case (that is,
                // we will have a high cache hit rate), so if I were
                // writing this in Asm I would have this out-of-line
                // to avoid the jump around for the common case.
                // But the Pentium has branch prediction, so what the
                // heck.

                pcg = pcgNew(ppdev, pcf, pgp);
                if (pcg == NULL)
                {
                  bRet = FALSE;
                  goto AllDone;
                }
              }

              // Space glyphs are trimmed to a height of zero, and we don't
              // even have to touch the hardware for them:

              cy = pcg->cy;
              if (cy != 0)
              {
                y       = pcg->ptlOrigin.y + yGlyph;
                x       = pcg->ptlOrigin.x + xGlyph;
                xRight  = pcg->cx + x;
                yBottom = pcg->cy + y;

                // Do trivial rejection:

                if ((prclClip->right  > x) &&
                    (prclClip->bottom > y) &&
                    (prclClip->left   < xRight) &&
                    (prclClip->top    < yBottom))
                {
                  // Lazily set the hardware clipping:

                  if (!bClippingSet)
                  {
                    bClippingSet = TRUE;
                    vSetClipping(ppdev, prclClip);
                  }

                  M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);

                  M32_OW(pjMmBase, CUR_X,        xOffset + x);
                  M32_OW(pjMmBase, DEST_X_START, xOffset + x);
                  M32_OW(pjMmBase, DEST_X_END,   xOffset + xRight);
                  M32_OW(pjMmBase, CUR_Y,        yOffset + y);
                  M32_OW(pjMmBase, DEST_Y_END,   yOffset + yBottom);

                  M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 10);

                  pw = (WORD*) &pcg->ad[0];
                  cw = pcg->cw;

                  do {
                      M32_OW_DIRECT(pjMmBase, PIX_TRANS, *pw);
                  } while (pw++, --cw != 0);
                }
              }

              if (--cGlyph == 0)
                break;

              // Get ready for next glyph:

              pgp++;

              if (ulCharInc == 0)
              {
                xGlyph = pgp->ptl.x;
                yGlyph = pgp->ptl.y;
              }
              else
              {
                xGlyph += ulCharInc;
              }
            }
          }
        } while (bMore);
      }
    } while (bMoreGlyphs);

AllDone:

    vResetClipping(ppdev);

    return(bRet);
}

VOID vM32DataPortOutB(PDEV *ppdev, PBYTE pb, UINT count)
{
    BYTE *pjMmBase = ppdev->pjMmBase;
    UINT i;

    for (i=0; i < count; i++)
        {
        if (i % 8 == 0)
            M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 10);

        M32_OB(pjMmBase, PIX_TRANS + 1, *((PUCHAR)pb)++);
        }
}

 /******************************Public*Routine******************************\
* BOOL bM32GeneralText
*
\**************************************************************************/

BOOL bM32GeneralText(
PDEV*     ppdev,
STROBJ*   pstro,
CLIPOBJ*  pco)
{
    BYTE*       pjMmBase;
    BYTE        iDComplexity;
    BOOL        bMoreGlyphs;
    ULONG       cGlyphOriginal;
    ULONG       cGlyph;
    GLYPHPOS*   pgpOriginal;
    GLYPHPOS*   pgp;
    GLYPHBITS*  pgb;
    POINTL      ptlOrigin;
    BOOL        bMore;
    CLIPENUM    ce;
    RECTL*      prclClip;
    ULONG       ulCharInc;
    LONG        cxGlyph;
    LONG        cyGlyph;
    LONG        xBiasL = 0;
    LONG        xBiasR = 0;
    LONG        yBiasT = 0;
    LONG        cy = 0;
    LONG        cx = 0;
    BYTE*       pjGlyph;
    LONG        xLeft;
    LONG        yTop;
    LONG        xRight;
    LONG        yBottom;
    RECTL       NoClip;
    LONG        x;
    LONG        y;

    pjMmBase = ppdev->pjMmBase;

    /* Define Default Clipping area to be full video ram */
    NoClip.top    = 0;
    NoClip.left   = 0;
    NoClip.right  = ppdev->cxScreen;
    NoClip.bottom = ppdev->cyScreen;

    if (pco == NULL)
        iDComplexity = DC_TRIVIAL;
    else
        iDComplexity = pco->iDComplexity;

    do {

      if (pstro->pgp != NULL)
      {
        // There's only the one batch of glyphs, so save ourselves
        // a call:

        pgpOriginal    = pstro->pgp;
        cGlyphOriginal = pstro->cGlyphs;
        bMoreGlyphs    = FALSE;
      }
      else
      {
        bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
      }

      if (cGlyphOriginal > 0)
      {
        ulCharInc = pstro->ulCharInc;

        if (iDComplexity != DC_COMPLEX)
        {
            // We could call 'cEnumStart' and 'bEnum' when the clipping is
            // DC_RECT, but the last time I checked, those two calls took
            // more than 150 instructions to go through GDI.  Since
            // 'rclBounds' already contains the DC_RECT clip rectangle,
            // and since it's such a common case, we'll special case it:

            bMore = FALSE;
            ce.c  = 1;

            if (iDComplexity == DC_TRIVIAL)
                prclClip = &NoClip;
            else
                prclClip = &pco->rclBounds;

            goto SingleRectangle;

        }

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do {

          bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

          for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
          {

          SingleRectangle:

            pgp    = pgpOriginal;
            cGlyph = cGlyphOriginal;
            pgb    = pgp->pgdf->pgb;

            ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
            ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

            vSetClipping(ppdev, prclClip);
            //ppdev->lRightScissor = rclRealClip.right;  ???

            // Loop through all the glyphs for this rectangle:

            while (TRUE)
            {
              cxGlyph  = pgb->sizlBitmap.cx;
              cyGlyph  = pgb->sizlBitmap.cy;
              pjGlyph = (BYTE*) pgb->aj;


              if ((prclClip->left   <= ptlOrigin.x) &&
                  (prclClip->top    <= ptlOrigin.y) &&
                  (prclClip->right  >= ptlOrigin.x + cxGlyph) &&
                  (prclClip->bottom >= ptlOrigin.y + cyGlyph))
              {
                //-----------------------------------------------------
                // Unclipped glyph

                M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 6);

                x = ppdev->xOffset + ptlOrigin.x;
                M32_OW(pjMmBase, CUR_X, LOWORD(x));
                M32_OW(pjMmBase, DEST_X_START, LOWORD(x));
                M32_OW(pjMmBase, DEST_X_END, LOWORD(x) + ROUND8(cxGlyph) );
                M32_OW(pjMmBase, SCISSOR_R, LOWORD(x) + cxGlyph-1);

                y = ppdev->yOffset + ptlOrigin.y;
                M32_OW(pjMmBase, CUR_Y, LOWORD(y));

                M32_OW(pjMmBase, DEST_Y_END, (LOWORD(y) + cyGlyph));

                vM32DataPortOutB(ppdev, pjGlyph, (ROUND8(cxGlyph) * cyGlyph) >> 3);

                /*
                _vBlit_DSC_SH1UP(ppdev,ptlOrigin.x, ptlOrigin.y,
                               cxGlyph, cyGlyph, pjGlyph,
                               (ROUND8(cxGlyph) * cyGlyph) >> 3);
                */

              }
              else
              {
                //-----------------------------------------------------
                // Clipped glyph

                // Find the intersection of the glyph rectangle
                // and the clip rectangle:

                xLeft   = max(prclClip->left,   ptlOrigin.x);
                yTop    = max(prclClip->top,    ptlOrigin.y);
                xRight  = min(prclClip->right,  ptlOrigin.x + cxGlyph);
                yBottom = min(prclClip->bottom, ptlOrigin.y + cyGlyph);

                // Check for trivial rejection:

                if ( ( ptlOrigin.x <= prclClip->left ) &&
                     (ppdev->pModeInfo->ModeFlags & AMI_TEXTBAND) )
                    {
                    vResetClipping(ppdev);
                    return FALSE;
                    }

                if (((cx = xRight - xLeft) > 0) &&
                    ((cy = yBottom - yTop) > 0))
                {

                  /* Do software clipping */

                  /* Calculated the Bias in pixels */

                  yBiasT = (yTop - ptlOrigin.y);

                  /*  change address of pjGlyph to point +yBiasT
                      scan lines into the Glyph */

                  pjGlyph += (yBiasT * (ROUND8(cxGlyph) >> 3));

                  M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 6);

                  x = ppdev->xOffset + ptlOrigin.x;
                  M32_OW(pjMmBase, CUR_X, LOWORD(x));
                  M32_OW(pjMmBase, DEST_X_START, LOWORD(x));
                  M32_OW(pjMmBase, DEST_X_END, LOWORD(x) + ROUND8(cxGlyph) );
                  M32_OW(pjMmBase, SCISSOR_R, LOWORD(x) + cxGlyph-1);

                  y = ppdev->yOffset + ptlOrigin.y;
                  M32_OW(pjMmBase, CUR_Y, LOWORD(y+yBiasT));

                  M32_OW(pjMmBase, DEST_Y_END, (LOWORD(y+yBiasT) + cy));

                  vM32DataPortOutB(ppdev, pjGlyph, (ROUND8(cxGlyph) >> 3) * cy);

                  /*
                  _vBlit_DSC_SH1UP(ppdev,ptlOrigin.x,ptlOrigin.y+yBiasT,
                                 cxGlyph, cy, pjGlyph,
                                 (ROUND8(cxGlyph) >>3) * cy);
                  */

                } /*if*/

              }

              if (--cGlyph == 0)
                break;

              // Get ready for next glyph:

              pgp++;
              pgb = pgp->pgdf->pgb;

              if (ulCharInc == 0)
              {
                ptlOrigin.x = pgp->ptl.x + pgb->ptlOrigin.x;
                ptlOrigin.y = pgp->ptl.y + pgb->ptlOrigin.y;
              }
              else
              {
                ptlOrigin.x += ulCharInc;
              }

            }
          }
        } while (bMore);
      }
    } while (bMoreGlyphs);

    vResetClipping(ppdev);

    return TRUE;
}

/******************************Public*Routine******************************\
* BOOL bM32TextOut
*
\**************************************************************************/

BOOL bM32TextOut(
PDEV*       ppdev,
STROBJ*     pstro,
FONTOBJ*    pfo,
CLIPOBJ*    pco,
RECTL*      prclOpaque,
BRUSHOBJ*   pboFore,
BRUSHOBJ*   pboOpaque)
{
    BYTE*           pjMmBase;
    LONG            xOffset;
    LONG            yOffset;
    ULONG           cGlyph;
    BOOL            bMoreGlyphs;
    GLYPHPOS*       pgp;
    BYTE            iDComplexity;
    CACHEDFONT*     pcf;
    RECTL           rclOpaque;
    BOOL            bTextPerfectFit;

    pjMmBase = ppdev->pjMmBase;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if (prclOpaque != NULL)
    {
      ////////////////////////////////////////////////////////////
      // Opaque Initialization
      ////////////////////////////////////////////////////////////

      if (iDComplexity == DC_TRIVIAL)
      {

      DrawOpaqueRect:

        M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 8);

        M32_OW(pjMmBase, FRGD_COLOR,   pboOpaque->iSolidColor);
        M32_OW(pjMmBase, ALU_FG_FN,    OVERPAINT);
        M32_OW(pjMmBase, DP_CONFIG,    FG_COLOR_SRC_FG | WRITE | DRAW);
        M32_OW(pjMmBase, CUR_X,        xOffset + prclOpaque->left);
        M32_OW(pjMmBase, DEST_X_START, xOffset + prclOpaque->left);
        M32_OW(pjMmBase, DEST_X_END,   xOffset + prclOpaque->right);
        M32_OW(pjMmBase, CUR_Y,        yOffset + prclOpaque->top);

        vM32QuietDown(ppdev, pjMmBase);

        M32_OW(pjMmBase, DEST_Y_END,   yOffset + prclOpaque->bottom);
      }
      else if (iDComplexity == DC_RECT)
      {
        if (bIntersect(prclOpaque, &pco->rclBounds, &rclOpaque))
        {
          prclOpaque = &rclOpaque;
          goto DrawOpaqueRect;
        }
      }
      else
      {
        vClipSolid(ppdev, prclOpaque, pboOpaque->iSolidColor, pco);
      }

      bTextPerfectFit = (pstro->flAccel & (SO_ZERO_BEARINGS |
              SO_FLAG_DEFAULT_PLACEMENT | SO_MAXEXT_EQUAL_BM_SIDE |
              SO_CHAR_INC_EQUAL_BM_BASE)) ==
              (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
              SO_MAXEXT_EQUAL_BM_SIDE | SO_CHAR_INC_EQUAL_BM_BASE);

      if (bTextPerfectFit)
      {
        M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);
        M32_OW(pjMmBase, ALU_BG_FN,  OVERPAINT);
        M32_OW(pjMmBase, BKGD_COLOR, pboOpaque->iSolidColor);
        goto SkipTransparentInitialization;
      }
    }

    ////////////////////////////////////////////////////////////
    // Transparent Initialization
    ////////////////////////////////////////////////////////////

    M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 4);
    M32_OW(pjMmBase, ALU_BG_FN, LEAVE_ALONE);

SkipTransparentInitialization:

    M32_OW(pjMmBase, DP_CONFIG,   EXT_MONO_SRC_HOST | DRAW | WRITE |
                                  FG_COLOR_SRC_FG | BG_COLOR_SRC_BG |
                                  LSB_FIRST | BIT16);
    M32_OW(pjMmBase, ALU_FG_FN,   OVERPAINT);
    M32_OW(pjMmBase, FRGD_COLOR,  pboFore->iSolidColor);

    if ((pfo->cxMax <= GLYPH_CACHE_CX) &&
        ((pstro->rclBkGround.bottom - pstro->rclBkGround.top) <= GLYPH_CACHE_CY))
    {
      pcf = (CACHEDFONT*) pfo->pvConsumer;

      if (pcf == NULL)
      {
        pcf = pcfAllocateCachedFont(ppdev);
        if (pcf == NULL)
          return(FALSE);

        pfo->pvConsumer = pcf;
      }

      // Use our glyph cache:

      if (iDComplexity == DC_TRIVIAL)
      {
        do {
          if (pstro->pgp != NULL)
          {
            // There's only the one batch of glyphs, so save ourselves
            // a call:

            pgp         = pstro->pgp;
            cGlyph      = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
          }
          else
          {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
          }

          if (cGlyph > 0)
          {
            if (pstro->ulCharInc == 0)
            {
              if (!bM32CachedProportionalText(ppdev, pcf, pgp, cGlyph))
                return(FALSE);
            }
            else
            {
              if (!bM32CachedFixedText(ppdev, pcf, pgp, cGlyph, pstro->ulCharInc))
                return(FALSE);
            }
          }
        } while (bMoreGlyphs);
      }
      else
      {
        if (!bM32CachedClippedText(ppdev, pcf, pstro, pco))
          return(FALSE);
      }
    }
    else
    {
      DISPDBG((4, "Text too big to cache: %li x %li",
             pfo->cxMax, pstro->rclBkGround.bottom - pstro->rclBkGround.top));

      M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
      M32_OW(pjMmBase, DP_CONFIG, EXT_MONO_SRC_HOST | DRAW | WRITE |
                                  FG_COLOR_SRC_FG | BG_COLOR_SRC_BG);

      return bM32GeneralText(ppdev, pstro, pco);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bM64CachedProportionalText
*
* Draws proportionally spaced glyphs via glyph caching.
*
\**************************************************************************/

BOOL bM64CachedProportionalText(
PDEV*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgp,
LONG        cGlyph)
{
    BYTE*           pjMmBase;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    LONG            xOffset;
    LONG            yOffset;
    LONG            x;
    LONG            y;
    LONG            cd;
    DWORD*          pd;
    LONG            cFifo;

    pjMmBase  = ppdev->pjMmBase;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;
    cFifo   = 0;

    do {
        hg  = pgp->hg;
        pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

        while (pcg->hg < hg) {
            pcg = pcg->pcgNext;
        }

        if (pcg->hg > hg)
        {
            // This will hopefully not be the common case (that is,
            // we will have a high cache hit rate), so if I were
            // writing this in Asm I would have this out-of-line
            // to avoid the jump around for the common case.
            // But the Pentium has branch prediction, so what the
            // heck.

            pcg = pcgNew(ppdev, pcf, pgp);
            if (pcg == NULL)
                return(FALSE);
        }

        // Space glyphs are trimmed to a height of zero, and we don't
        // even have to touch the hardware for them:

        if (pcg->cx != 0)
        {
            // The glyph's origin y-coordinate may often be negative, so we
            // can't compute this as follows:
            //
            // x = pgp->ptl.x + pcg->ptlOrigin.x;
            // y = pgp->ptl.y + pcg->ptlOrigin.y;

            ASSERTDD((pgp->ptl.y + pcg->ptlOrigin.y) >= 0,
                "Can't have negative 'y' coordinates here");

            cFifo -= 2;
            if (cFifo < 0)
            {
                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
                cFifo = 14;
            }

            x = xOffset + pgp->ptl.x + pcg->ptlOrigin.x;
            y = yOffset + pgp->ptl.y + pcg->ptlOrigin.y;

            M64_OD(pjMmBase, DST_Y_X,          PACKXY_FAST(x, y));
            M64_OD(pjMmBase, DST_HEIGHT_WIDTH, pcg->cxy);

            pd = (DWORD*) &pcg->ad[0];
            cd = pcg->cd;

            do {
                if (--cFifo < 0)
                {
                    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
                    cFifo = 15;
                }

                M64_OD(pjMmBase, HOST_DATA0, *pd);

            } while (pd++, --cd != 0);
        }

    } while (pgp++, --cGlyph != 0);

    return(TRUE);
}

BOOL bM64CachedProportionalText24(
PDEV*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgp,
LONG        cGlyph)
{
    BYTE*           pjMmBase;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    LONG            xOffset;
    LONG            yOffset;
    LONG            x;
    LONG            y;
    LONG            cd;
    DWORD*          pd;
    LONG            cFifo;

    pjMmBase  = ppdev->pjMmBase;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;
    cFifo   = 0;

    do {
        hg  = pgp->hg;
        pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

        while (pcg->hg < hg) {
            pcg = pcg->pcgNext;
        }

        if (pcg->hg > hg)
        {
            // This will hopefully not be the common case (that is,
            // we will have a high cache hit rate), so if I were
            // writing this in Asm I would have this out-of-line
            // to avoid the jump around for the common case.
            // But the Pentium has branch prediction, so what the
            // heck.

            pcg = pcgNew(ppdev, pcf, pgp);
            if (pcg == NULL)
                return(FALSE);
        }

        // Space glyphs are trimmed to a height of zero, and we don't
        // even have to touch the hardware for them:

        if (pcg->cx != 0)
        {
            // The glyph's origin y-coordinate may often be negative, so we
            // can't compute this as follows:
            //
            // x = pgp->ptl.x + pcg->ptlOrigin.x;
            // y = pgp->ptl.y + pcg->ptlOrigin.y;

            ASSERTDD((pgp->ptl.y + pcg->ptlOrigin.y) >= 0,
                "Can't have negative 'y' coordinates here");

            cFifo -= 3;
            if (cFifo < 0)
            {
                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
                cFifo = 13;
            }

            x = (xOffset + pgp->ptl.x + pcg->ptlOrigin.x) * 3;
            y = yOffset + pgp->ptl.y + pcg->ptlOrigin.y;

            M64_OD(pjMmBase, DST_CNTL,         0x83 | (((x + MAX_NEGX*3)/4 % 6) << 8));
            M64_OD(pjMmBase, DST_Y_X,          PACKXY_FAST(x, y));
            M64_OD(pjMmBase, DST_HEIGHT_WIDTH, pcg->cxy);

            pd = (DWORD*) &pcg->ad[0];
            cd = pcg->cd;

            do {
                if (--cFifo < 0)
                {
                    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
                    cFifo = 15;
                }

                M64_OD(pjMmBase, HOST_DATA0, *pd);

            } while (pd++, --cd != 0);
        }

    } while (pgp++, --cGlyph != 0);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bM64CachedFixedText
*
* Draws fixed spaced glyphs via glyph caching.
*
\*************************************************************************/

BOOL bM64CachedFixedText(
PDEV*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgp,
LONG        cGlyph,
ULONG       ulCharInc)
{
    BYTE*           pjMmBase;
    LONG            xGlyph;
    LONG            yGlyph;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    LONG            x;
    LONG            y;
    DWORD*          pd;
    LONG            cd;
    LONG            cFifo;

    pjMmBase = ppdev->pjMmBase;
    cFifo  = 0;

    // Convert to absolute coordinates:

    xGlyph = pgp->ptl.x + ppdev->xOffset;
    yGlyph = pgp->ptl.y + ppdev->yOffset;

    do {
        hg  = pgp->hg;
        pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

        while (pcg->hg < hg) {
            pcg = pcg->pcgNext;
        }

        if (pcg->hg > hg)
        {
            // This will hopefully not be the common case (that is,
            // we will have a high cache hit rate), so if I were
            // writing this in Asm I would have this out-of-line
            // to avoid the jump around for the common case.
            // But the Pentium has branch prediction, so what the
            // heck.

            pcg = pcgNew(ppdev, pcf, pgp);
            if (pcg == NULL)
                return(FALSE);
        }

        // Space glyphs are trimmed to a height of zero, and we don't
        // even have to touch the hardware for them:

        if (pcg->cx != 0)
        {
            x = xGlyph + pcg->ptlOrigin.x;
            y = yGlyph + pcg->ptlOrigin.y;

            cFifo -= 2;
            if (cFifo < 0)
            {
                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
                cFifo = 14;
            }

            M64_OD(pjMmBase, DST_Y_X,          PACKXY_FAST(x, y));
            M64_OD(pjMmBase, DST_HEIGHT_WIDTH, pcg->cxy);

            pd = (DWORD*) &pcg->ad[0];
            cd = pcg->cd;

            do {
                if (--cFifo < 0)
                {
                    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
                    cFifo = 15;
                }

                M64_OD(pjMmBase, HOST_DATA0, *pd);

            } while (pd++, --cd != 0);
        }

        xGlyph += ulCharInc;

    } while (pgp++, --cGlyph != 0);

    return(TRUE);
}

BOOL bM64CachedFixedText24(
PDEV*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgp,
LONG        cGlyph,
ULONG       ulCharInc)
{
    BYTE*           pjMmBase;
    LONG            xGlyph;
    LONG            yGlyph;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    LONG            x;
    LONG            y;
    DWORD*          pd;
    LONG            cd;
    LONG            cFifo;

    pjMmBase = ppdev->pjMmBase;
    cFifo  = 0;

    // Convert to absolute coordinates:

    xGlyph = pgp->ptl.x + ppdev->xOffset;
    yGlyph = pgp->ptl.y + ppdev->yOffset;

    do {
        hg  = pgp->hg;
        pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

        while (pcg->hg < hg) {
            pcg = pcg->pcgNext;
        }

        if (pcg->hg > hg)
        {
            // This will hopefully not be the common case (that is,
            // we will have a high cache hit rate), so if I were
            // writing this in Asm I would have this out-of-line
            // to avoid the jump around for the common case.
            // But the Pentium has branch prediction, so what the
            // heck.

            pcg = pcgNew(ppdev, pcf, pgp);
            if (pcg == NULL)
                return(FALSE);
        }

        // Space glyphs are trimmed to a height of zero, and we don't
        // even have to touch the hardware for them:

        if (pcg->cx != 0)
        {
            x = (xGlyph + pcg->ptlOrigin.x) * 3;
            y = yGlyph + pcg->ptlOrigin.y;

            cFifo -= 3;
            if (cFifo < 0)
            {
                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
                cFifo = 13;
            }

            M64_OD(pjMmBase, DST_CNTL,         0x83 | (((x + MAX_NEGX*3)/4 % 6) << 8));
            M64_OD(pjMmBase, DST_Y_X,          PACKXY_FAST(x, y));
            M64_OD(pjMmBase, DST_HEIGHT_WIDTH, pcg->cxy);

            pd = (DWORD*) &pcg->ad[0];
            cd = pcg->cd;

            do {
                if (--cFifo < 0)
                {
                    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
                    cFifo = 15;
                }

                M64_OD(pjMmBase, HOST_DATA0, *pd);

            } while (pd++, --cd != 0);
        }

        xGlyph += ulCharInc;

    } while (pgp++, --cGlyph != 0);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bM64CachedClippedText
*
* Draws clipped text via glyph caching.
*
\**************************************************************************/

BOOL bM64CachedClippedText(
PDEV*       ppdev,
CACHEDFONT* pcf,
STROBJ*     pstro,
CLIPOBJ*    pco)
{
    BOOL            bRet;
    BYTE*           pjMmBase;
    LONG            xOffset;
    LONG            yOffset;
    BOOL            bMoreGlyphs;
    ULONG           cGlyphOriginal;
    ULONG           cGlyph;
    BOOL            bClippingSet;
    GLYPHPOS*       pgpOriginal;
    GLYPHPOS*       pgp;
    LONG            xGlyph;
    LONG            yGlyph;
    LONG            x;
    LONG            y;
    LONG            xRight;
    LONG            yBottom;
    LONG            cy;
    BOOL            bMore;
    CLIPENUM        ce;
    RECTL*          prclClip;
    ULONG           ulCharInc;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    DWORD*          pd;
    LONG            cd;
    LONG            cFifo;

    ASSERTDD((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL),
             "Don't expect trivial clipping in this function");

    bRet      = TRUE;
    pjMmBase    = ppdev->pjMmBase;
    xOffset   = ppdev->xOffset;
    yOffset   = ppdev->yOffset;
    ulCharInc = pstro->ulCharInc;
    cFifo     = 0;

    do {
      if (pstro->pgp != NULL)
      {
        // There's only the one batch of glyphs, so save ourselves
        // a call:

        pgpOriginal    = pstro->pgp;
        cGlyphOriginal = pstro->cGlyphs;
        bMoreGlyphs    = FALSE;
      }
      else
      {
        bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
      }

      if (cGlyphOriginal > 0)
      {
        if (pco->iDComplexity == DC_RECT)
        {
          // We could call 'cEnumStart' and 'bEnum' when the clipping is
          // DC_RECT, but the last time I checked, those two calls took
          // more than 150 instructions to go through GDI.  Since
          // 'rclBounds' already contains the DC_RECT clip rectangle,
          // and since it's such a common case, we'll special case it:

          bMore    = FALSE;
          ce.c     = 1;
          prclClip = &pco->rclBounds;

          goto SingleRectangle;
        }

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do {
          bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

          for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
          {

          SingleRectangle:

            // We don't always simply set the clipping rectangle here
            // because it may actually end up that no text intersects
            // this clip rectangle, so it would be for naught.  This
            // actually happens a lot when using NT's analog clock set
            // to always-on-top, with a round shape:

            bClippingSet = FALSE;

            pgp    = pgpOriginal;
            cGlyph = cGlyphOriginal;

            // We can't yet convert to absolute coordinates by adding
            // in 'xOffset' or 'yOffset' here because we have yet to
            // compare the coordinates to 'prclClip':

            xGlyph = pgp->ptl.x;
            yGlyph = pgp->ptl.y;

            // Loop through all the glyphs for this rectangle:

            while (TRUE)
            {
              hg  = pgp->hg;
              pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

              while (pcg->hg < hg)
                pcg = pcg->pcgNext;

              if (pcg->hg > hg)
              {
                // This will hopefully not be the common case (that is,
                // we will have a high cache hit rate), so if I were
                // writing this in Asm I would have this out-of-line
                // to avoid the jump around for the common case.
                // But the Pentium has branch prediction, so what the
                // heck.

                pcg = pcgNew(ppdev, pcf, pgp);
                if (pcg == NULL)
                {
                  bRet = FALSE;
                  goto AllDone;
                }
              }

              // Space glyphs are trimmed to a height of zero, and we don't
              // even have to touch the hardware for them:

              cy = pcg->cy;
              if (cy != 0)
              {
                y       = pcg->ptlOrigin.y + yGlyph;
                x       = pcg->ptlOrigin.x + xGlyph;
                xRight  = pcg->cx + x;
                yBottom = pcg->cy + y;

                // Do trivial rejection:

                if ((prclClip->right  > x) &&
                    (prclClip->bottom > y) &&
                    (prclClip->left   < xRight) &&
                    (prclClip->top    < yBottom))
                {
                  // Lazily set the hardware clipping:

                  if (!bClippingSet)
                  {
                    bClippingSet = TRUE;
                    vSetClipping(ppdev, prclClip);
                    cFifo = 0;              // Have to initialize count
                  }

                  cFifo -= 2;
                  if (cFifo < 0)
                  {
                    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
                    cFifo = 14;
                  }

                  M64_OD(pjMmBase, DST_Y_X,          PACKXY(xOffset + x, yOffset + y));
                  M64_OD(pjMmBase, DST_HEIGHT_WIDTH, pcg->cxy);

                  pd = (DWORD*) &pcg->ad[0];
                  cd = pcg->cd;

                  do {
                    if (--cFifo < 0)
                    {
                      M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
                      cFifo = 15;
                    }

                    M64_OD(pjMmBase, HOST_DATA0, *pd);

                  } while (pd++, --cd != 0);
                }
              }

              if (--cGlyph == 0)
                break;

              // Get ready for next glyph:

              pgp++;

              if (ulCharInc == 0)
              {
                xGlyph = pgp->ptl.x;
                yGlyph = pgp->ptl.y;
              }
              else
              {
                xGlyph += ulCharInc;
              }
            }
          }
        } while (bMore);
      }
    } while (bMoreGlyphs);

AllDone:

    vResetClipping(ppdev);

    return(bRet);
}

BOOL bM64CachedClippedText24(
PDEV*       ppdev,
CACHEDFONT* pcf,
STROBJ*     pstro,
CLIPOBJ*    pco)
{
    BOOL            bRet;
    BYTE*           pjMmBase;
    LONG            xOffset;
    LONG            yOffset;
    BOOL            bMoreGlyphs;
    ULONG           cGlyphOriginal;
    ULONG           cGlyph;
    BOOL            bClippingSet;
    GLYPHPOS*       pgpOriginal;
    GLYPHPOS*       pgp;
    LONG            xGlyph;
    LONG            yGlyph;
    LONG            x;
    LONG            y;
    LONG            xRight;
    LONG            yBottom;
    LONG            cy;
    BOOL            bMore;
    CLIPENUM        ce;
    RECTL*          prclClip;
    ULONG           ulCharInc;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    DWORD*          pd;
    LONG            cd;
    LONG            cFifo;
    LONG            xTmp;

    ASSERTDD((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL),
             "Don't expect trivial clipping in this function");

    bRet      = TRUE;
    pjMmBase    = ppdev->pjMmBase;
    xOffset   = ppdev->xOffset;
    yOffset   = ppdev->yOffset;
    ulCharInc = pstro->ulCharInc;
    cFifo     = 0;

    do {
      if (pstro->pgp != NULL)
      {
        // There's only the one batch of glyphs, so save ourselves
        // a call:

        pgpOriginal    = pstro->pgp;
        cGlyphOriginal = pstro->cGlyphs;
        bMoreGlyphs    = FALSE;
      }
      else
      {
        bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
      }

      if (cGlyphOriginal > 0)
      {
        if (pco->iDComplexity == DC_RECT)
        {
          // We could call 'cEnumStart' and 'bEnum' when the clipping is
          // DC_RECT, but the last time I checked, those two calls took
          // more than 150 instructions to go through GDI.  Since
          // 'rclBounds' already contains the DC_RECT clip rectangle,
          // and since it's such a common case, we'll special case it:

          bMore    = FALSE;
          ce.c     = 1;
          prclClip = &pco->rclBounds;

          goto SingleRectangle;
        }

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do {
          bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

          for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
          {

          SingleRectangle:

            // We don't always simply set the clipping rectangle here
            // because it may actually end up that no text intersects
            // this clip rectangle, so it would be for naught.  This
            // actually happens a lot when using NT's analog clock set
            // to always-on-top, with a round shape:

            bClippingSet = FALSE;

            pgp    = pgpOriginal;
            cGlyph = cGlyphOriginal;

            // We can't yet convert to absolute coordinates by adding
            // in 'xOffset' or 'yOffset' here because we have yet to
            // compare the coordinates to 'prclClip':

            xGlyph = pgp->ptl.x;
            yGlyph = pgp->ptl.y;

            // Loop through all the glyphs for this rectangle:

            while (TRUE)
            {
              hg  = pgp->hg;
              pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

              while (pcg->hg < hg)
                pcg = pcg->pcgNext;

              if (pcg->hg > hg)
              {
                // This will hopefully not be the common case (that is,
                // we will have a high cache hit rate), so if I were
                // writing this in Asm I would have this out-of-line
                // to avoid the jump around for the common case.
                // But the Pentium has branch prediction, so what the
                // heck.

                pcg = pcgNew(ppdev, pcf, pgp);
                if (pcg == NULL)
                {
                  bRet = FALSE;
                  goto AllDone;
                }
              }

              // Space glyphs are trimmed to a height of zero, and we don't
              // even have to touch the hardware for them:

              cy = pcg->cy;
              if (cy != 0)
              {
                y       = pcg->ptlOrigin.y + yGlyph;
                x       = pcg->ptlOrigin.x + xGlyph;
                xRight  = pcg->cx + x;
                yBottom = pcg->cy + y;

                // Do trivial rejection:

                if ((prclClip->right  > x) &&
                    (prclClip->bottom > y) &&
                    (prclClip->left   < xRight) &&
                    (prclClip->top    < yBottom))
                {
                  // Lazily set the hardware clipping:

                  if (!bClippingSet)
                  {
                    bClippingSet = TRUE;
                    vSetClipping(ppdev, prclClip);
                    cFifo = 0;              // Have to initialize count
                  }

                  cFifo -= 3;
                  if (cFifo < 0)
                  {
                    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
                    cFifo = 13;
                  }

                  xTmp = (xOffset + x) * 3;
                  M64_OD(pjMmBase, DST_CNTL,         0x83 | (((xTmp + MAX_NEGX*3)/4 % 6) << 8));
                  M64_OD(pjMmBase, DST_Y_X,          PACKXY(xTmp, yOffset + y));
                  M64_OD(pjMmBase, DST_HEIGHT_WIDTH, pcg->cxy);

                  pd = (DWORD*) &pcg->ad[0];
                  cd = pcg->cd;

                  do {
                    if (--cFifo < 0)
                    {
                      M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
                      cFifo = 15;
                    }

                    M64_OD(pjMmBase, HOST_DATA0, *pd);

                  } while (pd++, --cd != 0);
                }
              }

              if (--cGlyph == 0)
                break;

              // Get ready for next glyph:

              pgp++;

              if (ulCharInc == 0)
              {
                xGlyph = pgp->ptl.x;
                yGlyph = pgp->ptl.y;
              }
              else
              {
                xGlyph += ulCharInc;
              }
            }
          }
        } while (bMore);
      }
    } while (bMoreGlyphs);

AllDone:

    vResetClipping(ppdev);

    return(bRet);
}

 /******************************Public*Routine******************************\
* BOOL bM64GeneralText
*
\**************************************************************************/

BOOL bM64GeneralText(
PDEV*     ppdev,
STROBJ*   pstro,
CLIPOBJ*  pco)
{
    BYTE*       pjMmBase;
    BYTE        iDComplexity;
    BOOL        bMoreGlyphs;
    ULONG       cGlyphOriginal;
    ULONG       cGlyph;
    GLYPHPOS*   pgpOriginal;
    GLYPHPOS*   pgp;
    GLYPHBITS*  pgb;
    POINTL      ptlOrigin;
    BOOL        bMore;
    CLIPENUM    ce;
    RECTL*      prclClip;
    ULONG       ulCharInc;
    LONG        cxGlyph;
    LONG        cyGlyph;
    LONG        xBiasL = 0;
    LONG        xBiasR = 0;
    LONG        yBiasT = 0;
    LONG        cy = 0;
    LONG        cx = 0;
    BYTE*       pjGlyph;
    LONG        xLeft;
    LONG        yTop;
    LONG        xRight;
    LONG        yBottom;
    RECTL       NoClip;

    pjMmBase = ppdev->pjMmBase;

    /* Define Default Clipping area to be full video ram */
    NoClip.top    = 0;
    NoClip.left   = 0;
    NoClip.right  = ppdev->cxScreen;
    NoClip.bottom = ppdev->cyScreen;

    if (pco == NULL)
        iDComplexity = DC_TRIVIAL;
    else
        iDComplexity = pco->iDComplexity;

    do {

      if (pstro->pgp != NULL)
      {
        // There's only the one batch of glyphs, so save ourselves
        // a call:

        pgpOriginal    = pstro->pgp;
        cGlyphOriginal = pstro->cGlyphs;
        bMoreGlyphs    = FALSE;
      }
      else
      {
        bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
      }

      if (cGlyphOriginal > 0)
      {
        ulCharInc = pstro->ulCharInc;

        if (iDComplexity != DC_COMPLEX)
        {
            // We could call 'cEnumStart' and 'bEnum' when the clipping is
            // DC_RECT, but the last time I checked, those two calls took
            // more than 150 instructions to go through GDI.  Since
            // 'rclBounds' already contains the DC_RECT clip rectangle,
            // and since it's such a common case, we'll special case it:

            bMore = FALSE;
            ce.c  = 1;

            if (iDComplexity == DC_TRIVIAL)
                prclClip = &NoClip;
            else
                prclClip = &pco->rclBounds;

            goto SingleRectangle;

        }

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do {

          bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

          for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
          {

          SingleRectangle:

            pgp    = pgpOriginal;
            cGlyph = cGlyphOriginal;
            pgb    = pgp->pgdf->pgb;

            ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
            ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

            vSetClipping(ppdev, prclClip);
            //ppdev->lRightScissor = rclRealClip.right;  ???

            // Loop through all the glyphs for this rectangle:

            while (TRUE)
            {
              cxGlyph  = pgb->sizlBitmap.cx;
              cyGlyph  = pgb->sizlBitmap.cy;
              pjGlyph = (BYTE*) pgb->aj;


              if ((prclClip->left   <= ptlOrigin.x) &&
                  (prclClip->top    <= ptlOrigin.y) &&
                  (prclClip->right  >= ptlOrigin.x + cxGlyph) &&
                  (prclClip->bottom >= ptlOrigin.y + cyGlyph))
              {
                //-----------------------------------------------------
                // Unclipped glyph

                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 3);

                M64_OD(pjMmBase, HOST_CNTL, 1);

                M64_OD(pjMmBase, DST_Y_X, ((ppdev->yOffset+ptlOrigin.y) & 0xffff) |
                                          ((ppdev->xOffset+ptlOrigin.x) << 16));
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, cyGlyph | cxGlyph << 16);

                vM64DataPortOutB(ppdev, pjGlyph, (ROUND8(cxGlyph) * cyGlyph) >> 3);

                /*
                _vBlit_DSC_SH1UP(ppdev,ptlOrigin.x, ptlOrigin.y,
                               cxGlyph, cyGlyph, pjGlyph,
                               (ROUND8(cxGlyph) * cyGlyph) >> 3);
                */

              }
              else
              {
                //-----------------------------------------------------
                // Clipped glyph

                // Find the intersection of the glyph rectangle
                // and the clip rectangle:

                xLeft   = max(prclClip->left,   ptlOrigin.x);
                yTop    = max(prclClip->top,    ptlOrigin.y);
                xRight  = min(prclClip->right,  ptlOrigin.x + cxGlyph);
                yBottom = min(prclClip->bottom, ptlOrigin.y + cyGlyph);

                // Check for trivial rejection:

                if ( ( ptlOrigin.x <= prclClip->left ) &&
                     (ppdev->pModeInfo->ModeFlags & AMI_TEXTBAND) )
                    {
                    vResetClipping(ppdev);
                    return FALSE;
                    }

                if (((cx = xRight - xLeft) > 0) &&
                    ((cy = yBottom - yTop) > 0))
                {

                  /* Do software clipping */

                  /* Calculated the Bias in pixels */

                  yBiasT = (yTop - ptlOrigin.y);

                  /*  change address of pjGlyph to point +yBiasT
                      scan lines into the Glyph */

                  pjGlyph += (yBiasT * (ROUND8(cxGlyph) >> 3));

                  M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 3);

                  M64_OD(pjMmBase, HOST_CNTL, 1);

                  M64_OD(pjMmBase, DST_Y_X, ((ppdev->yOffset+ptlOrigin.y+yBiasT) & 0xffff) |
                                            ((ppdev->xOffset+ptlOrigin.x) << 16));
                  M64_OD(pjMmBase, DST_HEIGHT_WIDTH, cy | cxGlyph << 16);

                  vM64DataPortOutB(ppdev, pjGlyph, (ROUND8(cxGlyph) >> 3) * cy);

                  /*
                  _vBlit_DSC_SH1UP(ppdev,ptlOrigin.x,ptlOrigin.y+yBiasT,
                                 cxGlyph, cy, pjGlyph,
                                 (ROUND8(cxGlyph) >>3) * cy);
                  */

                } /*if*/

              }

              if (--cGlyph == 0)
                break;

              // Get ready for next glyph:

              pgp++;
              pgb = pgp->pgdf->pgb;

              if (ulCharInc == 0)
              {
                ptlOrigin.x = pgp->ptl.x + pgb->ptlOrigin.x;
                ptlOrigin.y = pgp->ptl.y + pgb->ptlOrigin.y;
              }
              else
              {
                ptlOrigin.x += ulCharInc;
              }

            }
          }
        } while (bMore);
      }
    } while (bMoreGlyphs);

    vResetClipping(ppdev);

    // We must reset the HOST_CNTL register, or else BAD things happen when
    // rendering text in the OTHER functions.
    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
    M64_OD(pjMmBase, HOST_CNTL, 0);

    return TRUE;
}

VOID vM64DataPortOutD_24bppmono(PDEV* ppdev, PBYTE pb, UINT count, LONG pitch)
{
    BYTE* pjMmBase = ppdev->pjMmBase;
    UINT i,j;
    DWORD hostdata, remainder;
    UINT l;
    LONG data24;
    unsigned char data8;

    hostdata = 0;
    l = 0;

    for (i = 0; i < count; i++)
    {
        switch (l)
            {
            case 0:
                // expand 8 to 24bpp
                data24 = 0;
                data8 = *pb++;
                for (j = 0; j < 8; j++)
                {
                    data24 <<= 3;
                    if ((data8 >> j) & 1)
                        {
                        data24 |= 7;
                        }
                }
                hostdata = data24;

                // expand 8 to 24bpp
                data24 = 0;
                data8 = *pb++;
                for (j = 0; j < 8; j++)
                {
                    data24 <<= 3;
                    if ((data8 >> j) & 1)
                        {
                        data24 |= 7;
                        }
                }
                remainder = data24;

                hostdata = hostdata | (remainder << 24);
                break;

            case 1:
                data24 = 0;
                data8 = *pb++;
                for (j = 0; j < 8; j++)
                {
                    data24 <<= 3;
                    if ((data8 >> j) & 1)
                        {
                        data24 |= 7;
                        }
                }
                remainder = data24;

                hostdata = (hostdata >> 8) | (remainder << 16);
                break;

            case 2:
                data24 = 0;
                data8 = *pb++;
                for (j = 0; j < 8; j++)
                {
                    data24 <<= 3;
                    if ((data8 >> j) & 1)
                        {
                        data24 |= 7;
                        }
                }
                remainder = data24;

                hostdata = (hostdata >> 16) | (remainder << 8);
                break;
            }

        if ((i % 14) == 0)
            {
            M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
            }
        M64_OD(pjMmBase, HOST_DATA0, hostdata);

        hostdata = remainder;

        // 24 bpp alignment variable handling
        l = (l+1) % 3;
    }
}

BOOL bM64GeneralText24(
PDEV*     ppdev,
STROBJ*   pstro,
CLIPOBJ*  pco)
{
    BYTE*       pjMmBase;
    BYTE        iDComplexity;
    BOOL        bMoreGlyphs;
    ULONG       cGlyphOriginal;
    ULONG       cGlyph;
    GLYPHPOS*   pgpOriginal;
    GLYPHPOS*   pgp;
    GLYPHBITS*  pgb;
    POINTL      ptlOrigin;
    BOOL        bMore;
    CLIPENUM    ce;
    RECTL*      prclClip;
    ULONG       ulCharInc;
    LONG        cxGlyph;
    LONG        cyGlyph;
    LONG        xBiasL = 0;
    LONG        xBiasR = 0;
    LONG        yBiasT = 0;
    LONG        cy = 0;
    LONG        cx = 0;
    BYTE*       pjGlyph;
    LONG        xLeft;
    LONG        yTop;
    LONG        xRight;
    LONG        yBottom;
    RECTL       NoClip;
    BOOLEAN     resetScissor;
    LONG        x;
    DWORD       dwCount;

    pjMmBase = ppdev->pjMmBase;

    /* Define Default Clipping area to be full video ram */
    NoClip.top    = 0;
    NoClip.left   = 0;
    NoClip.right  = ppdev->cxScreen;
    NoClip.bottom = ppdev->cyScreen;

    if (pco == NULL)
        iDComplexity = DC_TRIVIAL;
    else
        iDComplexity = pco->iDComplexity;

    do {

      if (pstro->pgp != NULL)
      {
        // There's only the one batch of glyphs, so save ourselves
        // a call:

        pgpOriginal    = pstro->pgp;
        cGlyphOriginal = pstro->cGlyphs;
        bMoreGlyphs    = FALSE;
      }
      else
      {
        bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
      }

      if (cGlyphOriginal > 0)
      {
        ulCharInc = pstro->ulCharInc;

        if (iDComplexity != DC_COMPLEX)
        {
            // We could call 'cEnumStart' and 'bEnum' when the clipping is
            // DC_RECT, but the last time I checked, those two calls took
            // more than 150 instructions to go through GDI.  Since
            // 'rclBounds' already contains the DC_RECT clip rectangle,
            // and since it's such a common case, we'll special case it:

            bMore = FALSE;
            ce.c  = 1;

            if (iDComplexity == DC_TRIVIAL)
                prclClip = &NoClip;
            else
                prclClip = &pco->rclBounds;

            goto SingleRectangle;

        }

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do {

          bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

          for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
          {

          SingleRectangle:

            pgp    = pgpOriginal;
            cGlyph = cGlyphOriginal;
            pgb    = pgp->pgdf->pgb;

            ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
            ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

            vSetClipping(ppdev, prclClip);
            //ppdev->lRightScissor = rclRealClip.right;  ???

            // Loop through all the glyphs for this rectangle:

            while (TRUE)
            {
              cxGlyph  = pgb->sizlBitmap.cx;
              cyGlyph  = pgb->sizlBitmap.cy;
              pjGlyph = (BYTE*) pgb->aj;


              if ((prclClip->left   <= ptlOrigin.x) &&
                  (prclClip->top    <= ptlOrigin.y) &&
                  (prclClip->right  >= ptlOrigin.x + cxGlyph) &&
                  (prclClip->bottom >= ptlOrigin.y + cyGlyph))
              {
                //-----------------------------------------------------
                // Unclipped glyph
                x = ppdev->xOffset+ptlOrigin.x;
                resetScissor = FALSE;

                if ((prclClip->right * 3) - 1 > (x - ppdev->xOffset + cxGlyph) * 3 - 1)
                {
                    resetScissor = TRUE;
                    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 4);
                    M64_OD(pjMmBase, SC_RIGHT, (x + cxGlyph) * 3 - 1);
                }
                else
                {
                    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 3);
                }

                M64_OD(pjMmBase, DST_CNTL, 0x83 | (((x + MAX_NEGX)*3/4 % 6) << 8));
                M64_OD(pjMmBase, DST_Y_X, ((ppdev->yOffset+ptlOrigin.y) & 0xffff) |
                                          (x*3 << 16));
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, cyGlyph | (ROUND8(cxGlyph) * 3) << 16);

                dwCount = (ROUND8(cxGlyph) * 3 * cyGlyph + 31) / 32;
                vM64DataPortOutD_24bppmono(ppdev, pjGlyph, dwCount, cxGlyph);

                if (resetScissor)
                {
                    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
                    M64_OD(pjMmBase, SC_RIGHT, (ppdev->xOffset + prclClip->right) * 3 - 1);
                }

              }
              else
              {
                //-----------------------------------------------------
                // Clipped glyph

                // Find the intersection of the glyph rectangle
                // and the clip rectangle:

                xLeft   = max(prclClip->left,   ptlOrigin.x);
                yTop    = max(prclClip->top,    ptlOrigin.y);
                xRight  = min(prclClip->right,  ptlOrigin.x + cxGlyph);
                yBottom = min(prclClip->bottom, ptlOrigin.y + cyGlyph);

                // Check for trivial rejection:

                if ( ( ptlOrigin.x <= prclClip->left ) &&
                     (ppdev->pModeInfo->ModeFlags & AMI_TEXTBAND) )
                    {
                    vResetClipping(ppdev);
                    return FALSE;
                    }

                if (((cx = xRight - xLeft) > 0) &&
                    ((cy = yBottom - yTop) > 0))
                {
                    /* Do software clipping */

                    /* Calculated the Bias in pixels */

                    yBiasT = (yTop - ptlOrigin.y);

                    /*  change address of pjGlyph to point +yBiasT
                        scan lines into the Glyph */

                    pjGlyph += (yBiasT * (ROUND8(cxGlyph) >> 3));

                    x = ppdev->xOffset+ptlOrigin.x;
                    resetScissor = FALSE;

                    if ((prclClip->right * 3) - 1 > (x - ppdev->xOffset + cxGlyph) * 3 - 1)
                    {
                        resetScissor = TRUE;
                        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 4);
                        M64_OD(pjMmBase, SC_RIGHT, (x + cxGlyph) * 3 - 1);
                    }
                    else
                    {
                        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 3);
                    }

                    M64_OD(pjMmBase, DST_CNTL, 0x83 | (((x + MAX_NEGX)*3/4 % 6) << 8));
                    M64_OD(pjMmBase, DST_Y_X, ((ppdev->yOffset+ptlOrigin.y+yBiasT) & 0xffff) |
                                              (x*3 << 16));
                    M64_OD(pjMmBase, DST_HEIGHT_WIDTH, cy | (ROUND8(cxGlyph) * 3) << 16);

                    dwCount = (ROUND8(cxGlyph) * 3 * cy + 31) / 32;
                    vM64DataPortOutD_24bppmono(ppdev, pjGlyph, dwCount, cxGlyph);

                    if (resetScissor)
                    {
                        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
                        M64_OD(pjMmBase, SC_RIGHT, (ppdev->xOffset + prclClip->right) * 3 - 1);
                    }

                } /*if*/

              }

              if (--cGlyph == 0)
                break;

              // Get ready for next glyph:

              pgp++;
              pgb = pgp->pgdf->pgb;

              if (ulCharInc == 0)
              {
                ptlOrigin.x = pgp->ptl.x + pgb->ptlOrigin.x;
                ptlOrigin.y = pgp->ptl.y + pgb->ptlOrigin.y;
              }
              else
              {
                ptlOrigin.x += ulCharInc;
              }

            }
          }
        } while (bMore);
      }
    } while (bMoreGlyphs);

    vResetClipping(ppdev);

    return TRUE;
}

/******************************Public*Routine******************************\
* BOOL bM64TextOut
*
\**************************************************************************/

BOOL bM64TextOut(
PDEV*       ppdev,
STROBJ*     pstro,
FONTOBJ*    pfo,
CLIPOBJ*    pco,
RECTL*      prclOpaque,
BRUSHOBJ*   pboFore,
BRUSHOBJ*   pboOpaque)
{
    BYTE*           pjMmBase;
    LONG            xOffset;
    LONG            yOffset;
    ULONG           cGlyph;
    BOOL            bMoreGlyphs;
    GLYPHPOS*       pgp;
    BYTE            iDComplexity;
    CACHEDFONT*     pcf;
    RECTL           rclOpaque;

    pjMmBase  = ppdev->pjMmBase;

    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if (prclOpaque != NULL)
    {
      ////////////////////////////////////////////////////////////
      // Opaque Initialization
      ////////////////////////////////////////////////////////////

      if (iDComplexity == DC_TRIVIAL)
      {

      DrawOpaqueRect:

        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);

        M64_OD(pjMmBase, DP_MIX,        (OVERPAINT << 16));
        M64_OD(pjMmBase, DP_FRGD_CLR,   pboOpaque->iSolidColor);
        M64_OD(pjMmBase, DP_SRC,        DP_SRC_FrgdClr << 8);
        M64_OD(pjMmBase, DST_Y_X,       PACKXY_FAST(xOffset + prclOpaque->left,
                                                    yOffset + prclOpaque->top));
        M64_OD(pjMmBase, DST_HEIGHT_WIDTH,
                            PACKXY_FAST(prclOpaque->right - prclOpaque->left,
                                        prclOpaque->bottom - prclOpaque->top));
      }
      else if (iDComplexity == DC_RECT)
      {
        if (bIntersect(prclOpaque, &pco->rclBounds, &rclOpaque))
        {
          prclOpaque = &rclOpaque;
          goto DrawOpaqueRect;
        }
      }
      else
      {
        vClipSolid(ppdev, prclOpaque, pboOpaque->iSolidColor, pco);
      }

      // I didn't observe any performance difference between setting
      // the ATI to opaque or transparent mode (when the font allowed
      // it -- some don't).
    }

    ////////////////////////////////////////////////////////////
    // Transparent Initialization
    ////////////////////////////////////////////////////////////

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);
    M64_OD(pjMmBase, CONTEXT_LOAD_CNTL, CONTEXT_LOAD_CmdLoad | ppdev->iDefContext );

    M64_OD(pjMmBase, DP_MIX,      (OVERPAINT << 16) | LEAVE_ALONE);
    M64_OD(pjMmBase, DP_FRGD_CLR, pboFore->iSolidColor);
    M64_OD(pjMmBase, DP_SRC,      (DP_SRC_Host << 16) | (DP_SRC_FrgdClr << 8) |
                                  (DP_SRC_BkgdClr));
    // For some reason, the SRC color depth must be monochrome.
    // Otherwise, it will cause wait-for-idle to hang.
    M64_OD(pjMmBase, DP_PIX_WIDTH, ppdev->ulMonoPixelWidth & 0xFFFF00FF);

    if ((pfo->cxMax <= GLYPH_CACHE_CX) &&
        ((pstro->rclBkGround.bottom - pstro->rclBkGround.top) <= GLYPH_CACHE_CY))
    {
      pcf = (CACHEDFONT*) pfo->pvConsumer;

      if (pcf == NULL)
      {
        pcf = pcfAllocateCachedFont(ppdev);
        if (pcf == NULL)
           goto ReturnFalse;

        pfo->pvConsumer = pcf;
      }

      // Use our glyph cache:

      if (iDComplexity == DC_TRIVIAL)
      {
        do {
          if (pstro->pgp != NULL)
          {
            // There's only the one batch of glyphs, so save ourselves
            // a call:

            pgp         = pstro->pgp;
            cGlyph      = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
          }
          else
          {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
          }

          if (cGlyph > 0)
          {
            if (pstro->ulCharInc == 0)
            {
              if (!bM64CachedProportionalText(ppdev, pcf, pgp, cGlyph))
                 goto ReturnFalse;
            }
            else
            {
              if (!bM64CachedFixedText(ppdev, pcf, pgp, cGlyph, pstro->ulCharInc))
                 goto ReturnFalse;
            }
          }
        } while (bMoreGlyphs);
      }
      else
      {
        if (!bM64CachedClippedText(ppdev, pcf, pstro, pco))
           goto ReturnFalse;
      }
    }
    else
    {
      DISPDBG((4, "Text too big to cache: %li x %li",
            pfo->cxMax, pstro->rclBkGround.bottom - pstro->rclBkGround.top));

      if (!bM64GeneralText(ppdev, pstro, pco))
         goto ReturnFalse;
    }

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
    M64_OD(pjMmBase, DP_PIX_WIDTH, ppdev->ulMonoPixelWidth);
    return(TRUE);

ReturnFalse:
    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
    M64_OD(pjMmBase, DP_PIX_WIDTH, ppdev->ulMonoPixelWidth);
    return(FALSE);
}

BOOL bM64TextOut24(
PDEV*       ppdev,
STROBJ*     pstro,
FONTOBJ*    pfo,
CLIPOBJ*    pco,
RECTL*      prclOpaque,
BRUSHOBJ*   pboFore,
BRUSHOBJ*   pboOpaque)
{
    BYTE*           pjMmBase;
    LONG            xOffset;
    LONG            yOffset;
    ULONG           cGlyph;
    BOOL            bMoreGlyphs;
    GLYPHPOS*       pgp;
    BYTE            iDComplexity;
    CACHEDFONT*     pcf;
    RECTL           rclOpaque;
    LONG            x;

    pjMmBase  = ppdev->pjMmBase;

    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if (prclOpaque != NULL)
    {
      ////////////////////////////////////////////////////////////
      // Opaque Initialization
      ////////////////////////////////////////////////////////////

      if (iDComplexity == DC_TRIVIAL)
      {

      DrawOpaqueRect:
        x = (xOffset + prclOpaque->left) * 3;

        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 6);

        M64_OD(pjMmBase, DST_CNTL,      0x83 | ((x/4 % 6) << 8));
        M64_OD(pjMmBase, DP_MIX,        (OVERPAINT << 16));
        M64_OD(pjMmBase, DP_FRGD_CLR,   pboOpaque->iSolidColor);
        M64_OD(pjMmBase, DP_SRC,        DP_SRC_FrgdClr << 8);
        M64_OD(pjMmBase, DST_Y_X,       PACKXY_FAST(x,
                                                    yOffset + prclOpaque->top));
        M64_OD(pjMmBase, DST_HEIGHT_WIDTH,
                            PACKXY_FAST((prclOpaque->right - prclOpaque->left) * 3,
                                        prclOpaque->bottom - prclOpaque->top));
      }
      else if (iDComplexity == DC_RECT)
      {
        if (bIntersect(prclOpaque, &pco->rclBounds, &rclOpaque))
        {
          prclOpaque = &rclOpaque;
          goto DrawOpaqueRect;
        }
      }
      else
      {
        vClipSolid(ppdev, prclOpaque, pboOpaque->iSolidColor, pco);
      }

      // I didn't observe any performance difference between setting
      // the ATI to opaque or transparent mode (when the font allowed
      // it -- some don't).
    }

    ////////////////////////////////////////////////////////////
    // Transparent Initialization
    ////////////////////////////////////////////////////////////

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);
    M64_OD(pjMmBase, CONTEXT_LOAD_CNTL, CONTEXT_LOAD_CmdLoad | ppdev->iDefContext );

    M64_OD(pjMmBase, DP_MIX,      (OVERPAINT << 16) | LEAVE_ALONE);
    M64_OD(pjMmBase, DP_FRGD_CLR, pboFore->iSolidColor);
    M64_OD(pjMmBase, DP_SRC,      (DP_SRC_Host << 16) | (DP_SRC_FrgdClr << 8) |
                                  (DP_SRC_BkgdClr));
    // For some reason, the SRC color depth must be monochrome.
    // Otherwise, it will cause wait-for-idle to hang.
    M64_OD(pjMmBase, DP_PIX_WIDTH, ppdev->ulMonoPixelWidth & 0xFFFF00FF);

    if ((pfo->cxMax <= GLYPH_CACHE_CX) &&
        ((pstro->rclBkGround.bottom - pstro->rclBkGround.top) <= GLYPH_CACHE_CY))
    {
      pcf = (CACHEDFONT*) pfo->pvConsumer;

      if (pcf == NULL)
      {
        pcf = pcfAllocateCachedFont(ppdev);
        if (pcf == NULL)
           goto ReturnFalse;

        pfo->pvConsumer = pcf;
      }

      // Use our glyph cache:

      if (iDComplexity == DC_TRIVIAL)
      {
        do {
          if (pstro->pgp != NULL)
          {
            // There's only the one batch of glyphs, so save ourselves
            // a call:

            pgp         = pstro->pgp;
            cGlyph      = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
          }
          else
          {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
          }

          if (cGlyph > 0)
          {
            if (pstro->ulCharInc == 0)
            {
              if (!bM64CachedProportionalText24(ppdev, pcf, pgp, cGlyph))
                 goto ReturnFalse;
            }
            else
            {
              if (!bM64CachedFixedText24(ppdev, pcf, pgp, cGlyph, pstro->ulCharInc))
                 goto ReturnFalse;
            }
          }
        } while (bMoreGlyphs);
      }
      else
      {
        if (!bM64CachedClippedText24(ppdev, pcf, pstro, pco))
           goto ReturnFalse;
      }
    }
    else
    {
      DISPDBG((4, "Text too big to cache: %li x %li",
            pfo->cxMax, pstro->rclBkGround.bottom - pstro->rclBkGround.top));

      if (!bM64GeneralText24(ppdev, pstro, pco))
         goto ReturnFalse;
    }

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 2);
    M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
    M64_OD(pjMmBase, DP_PIX_WIDTH, ppdev->ulMonoPixelWidth);
    return(TRUE);

ReturnFalse:
    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 2);
    M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
    M64_OD(pjMmBase, DP_PIX_WIDTH, ppdev->ulMonoPixelWidth);
    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL DrvTextOut
*
\**************************************************************************/

BOOL DrvTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,    // If we had set GCAPS_HORIZSTRIKE, we would have
                        //   to fill these extra rectangles (it is used
                        //   largely for underlines).  It's not a big
                        //   performance win (GDI will call our DrvBitBlt
                        //   to draw the extra rectangles).
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlBrush,    // Always unused, unless GCAPS_ARBRUSHOPAQUE set
MIX       mix)          // Always a copy mix (0x0d0d)
{
    PDEV*   ppdev;
    DSURF*  pdsurf;
    OH*     poh;

    // The DDI spec says we'll only ever get foreground and background
    // mixes of R2_COPYPEN:

    ASSERTDD(mix == 0x0d0d, "GDI should only give us a copy mix");

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt != DT_DIB)
    {
      poh            = pdsurf->poh;
      ppdev          = (PDEV*) pso->dhpdev;
      ppdev->xOffset = poh->x;
      ppdev->yOffset = poh->y;

      if (!ppdev->pfnTextOut(ppdev, pstro, pfo, pco, prclOpaque, pboFore,
                             pboOpaque))
      {
          if (DIRECT_ACCESS(ppdev))
          {
              BANK bnk;

              vBankStart(ppdev,
                         (prclOpaque != NULL) ? prclOpaque : &pstro->rclBkGround,
                         pco,
                         &bnk);

              do {
                EngTextOut(bnk.pso, pstro, pfo, bnk.pco, prclExtra, prclOpaque,
                           pboFore, pboOpaque, pptlBrush, mix);

              } while (bBankEnum(&bnk));
          }
          else
          {
              BOOL      b;
              BYTE*     pjBits;
              BYTE*     pjScan0;
              HSURF     hsurfDst;
              LONG      lDelta;
              RECTL     rclDst;
              RECTL     rclScreen;
              SIZEL     sizl;
              SURFOBJ*  psoTmp;


              b = FALSE;          // For error cases, assume we'll fail

              /*
              rclDst.left   = 0;
              rclDst.top    = 0;
              rclDst.right  = pdsurf->sizl.cx;
              rclDst.bottom = pdsurf->sizl.cy;
              */
              rclDst = (prclOpaque != NULL) ? *prclOpaque : pstro->rclBkGround;

              if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
              {
                  rclDst.left   = max(rclDst.left,   pco->rclBounds.left);
                  rclDst.top    = max(rclDst.top,    pco->rclBounds.top);
                  rclDst.right  = min(rclDst.right,  pco->rclBounds.right);
                  rclDst.bottom = min(rclDst.bottom, pco->rclBounds.bottom);
              }

              sizl.cx = rclDst.right  - rclDst.left;
              sizl.cy = rclDst.bottom - rclDst.top;

              {
                  // We need to create a temporary work buffer.  We have to do
                  // some fudging with the offsets so that the upper-left corner
                  // of the (relative coordinates) clip object bounds passed to
                  // GDI will be transformed to the upper-left corner of our
                  // temporary bitmap.

                  // The alignment doesn't have to be as tight as this at 16bpp
                  // and 32bpp, but it won't hurt:

                  lDelta = (((rclDst.right + 3) & ~3L) - (rclDst.left & ~3L))
                         * ppdev->cjPelSize;

                  // We're actually only allocating a bitmap that is 'sizl.cx' x
                  // 'sizl.cy' in size:

                  pjBits = AtiAllocMem(LMEM_FIXED, 0, lDelta * sizl.cy);
                  if (pjBits == NULL)
                      goto Error_2;

                  // We now adjust the surface's 'pvScan0' so that when GDI thinks
                  // it's writing to pixel (rclDst.top, rclDst.left), it will
                  // actually be writing to the upper-left pixel of our temporary
                  // bitmap:

                  pjScan0 = pjBits - (rclDst.top * lDelta)
                                   - ((rclDst.left & ~3L) * ppdev->cjPelSize);

                  ASSERTDD((((ULONG_PTR) pjScan0) & 3) == 0,
                          "pvScan0 must be dword aligned!");

                  hsurfDst = (HSURF) EngCreateBitmap(
                              sizl,                   // Bitmap covers rectangle
                              lDelta,                 // Use this delta
                              ppdev->iBitmapFormat,   // Same colour depth
                              BMF_TOPDOWN,            // Must have a positive delta
                              pjScan0);               // Where (0, 0) would be

                  if ((hsurfDst == 0) ||
                      (!EngAssociateSurface(hsurfDst, ppdev->hdevEng, 0)))
                      goto Error_3;

                  psoTmp = EngLockSurface(hsurfDst);
                  if (psoTmp == NULL)
                      goto Error_4;

                  // Make sure that the rectangle we Get/Put from/to the screen
                  // is in absolute coordinates:

                  rclScreen.left   = rclDst.left   + ppdev->xOffset;
                  rclScreen.right  = rclDst.right  + ppdev->xOffset;
                  rclScreen.top    = rclDst.top    + ppdev->yOffset;
                  rclScreen.bottom = rclDst.bottom + ppdev->yOffset;

                  ppdev->pfnGetBits(ppdev, psoTmp, &rclDst, (POINTL*) &rclScreen);

                  b = EngTextOut(psoTmp, pstro, pfo, pco, prclExtra, prclOpaque,
                             pboFore, pboOpaque, pptlBrush, mix);

                  ppdev->pfnPutBits(ppdev, psoTmp, &rclScreen, (POINTL*) &rclDst);

                  EngUnlockSurface(psoTmp);

              Error_4:

                  EngDeleteSurface(hsurfDst);

              Error_3:

                  AtiFreeMem(pjBits);
              }

              Error_2:

              return(b);
          }
      }
    }
    else
    {
      // We're drawing to a DFB we've converted to a DIB, so just call GDI
      // to handle it:

      return(EngTextOut(pdsurf->pso, pstro, pfo, pco, prclExtra, prclOpaque,
                        pboFore, pboOpaque, pptlBrush, mix));
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bEnableText
*
* Performs the necessary setup for the text drawing subcomponent.
*
\**************************************************************************/

BOOL bEnableText(
PDEV*   ppdev)
{
    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableText
*
* Performs the necessary clean-up for the text drawing subcomponent.
*
\**************************************************************************/

VOID vDisableText(PDEV* ppdev)
{
}

/******************************Public*Routine******************************\
* VOID vAssertModeText
*
* Disables or re-enables the text drawing subcomponent in preparation for
* full-screen entry/exit.
*
\**************************************************************************/

VOID vAssertModeText(
PDEV*   ppdev,
BOOL    bEnable)
{
    // If we were to do off-screen glyph caching, we would probably want
    // to invalidate our cache here, because it will get destroyed when
    // we switch to full-screen.
}

/******************************Public*Routine******************************\
* VOID DrvDestroyFont
*
* We're being notified that the given font is being deallocated; clean up
* anything we've stashed in the 'pvConsumer' field of the 'pfo'.
*
\**************************************************************************/

VOID DrvDestroyFont(
FONTOBJ*    pfo)
{
    CACHEDFONT* pcf;

    pcf = pfo->pvConsumer;
    if (pcf != NULL)
    {
        vFreeCachedFont(pcf);
        pfo->pvConsumer = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\thunk.c ===
/******************************Module*Header*******************************\
* Module Name: thunk.c
*
* This module exists solely for testing, to make it is easy to instrument
* all the driver's Drv calls.
*
* Note that most of this stuff will only be compiled in a checked (debug)
* build.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

////////////////////////////////////////////////////////////////////////////

#if DBG

// This entire module is only enabled for Checked builds, or when we
// have to explicitly synchronize bitmap access ourselves.

////////////////////////////////////////////////////////////////////////////
// By default, GDI does not synchronize drawing to device-bitmaps.  Since
// our hardware dictates that only one thread can access the accelerator
// at a time, we have to synchronize bitmap access.
//
// If we're running on Windows NT 3.5, we can ask GDI to do it by setting
// HOOK_SYNCHRONIZEACCESS when we associate a device-bitmap surface.

// These macros are merely for testing that GDI's HOOK_SYNCHRONIZEACCESS
// actually works:

#define SYNCH_ENTER()
#define SYNCH_LEAVE()

////////////////////////////////////////////////////////////////////////////

BOOL gbNull = FALSE;    // Set to TRUE with the debugger to test the speed
                        //   of NT with an infinitely fast display driver
                        //   (actually, almost infinitely fast since we're
                        //   not hooking all the calls we could be)

VOID DbgDisableDriver(VOID)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvDisableDriver"));

    DrvDisableDriver();

    DISPDBG((6, "DrvDisableDriver done"));
    SYNCH_LEAVE();
}

DHPDEV DbgEnablePDEV(
DEVMODEW*   pDevmode,
PWSTR       pwszLogAddress,
ULONG       cPatterns,
HSURF*      ahsurfPatterns,
ULONG       cjGdiInfo,
ULONG*      pGdiInfo,
ULONG       cjDevInfo,
DEVINFO*    pDevInfo,
HDEV        hdev,
PWSTR       pwszDeviceName,
HANDLE      hDriver)
{
    DHPDEV bRet;

    SYNCH_ENTER();
    DISPDBG((5, "DrvEnablePDEV"));

    bRet = DrvEnablePDEV(
                pDevmode,
                pwszLogAddress,
                cPatterns,
                ahsurfPatterns,
                cjGdiInfo,
                pGdiInfo,
                cjDevInfo,
                pDevInfo,
                hdev,
                pwszDeviceName,
                hDriver);

    DISPDBG((6, "DrvEnablePDEV done"));
    SYNCH_LEAVE();

    return(bRet);
}

VOID DbgCompletePDEV(
DHPDEV dhpdev,
HDEV  hdev)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvCompletePDEV"));

    DrvCompletePDEV(
                dhpdev,
                hdev);

    DISPDBG((6, "DrvCompletePDEV done"));
    SYNCH_LEAVE();
}

VOID DbgDisablePDEV(DHPDEV dhpdev)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvDisable"));

    DrvDisablePDEV(dhpdev);

    DISPDBG((6, "DrvDisable done"));
    SYNCH_LEAVE();
}

HSURF DbgEnableSurface(DHPDEV dhpdev)
{
    HSURF h;

    SYNCH_ENTER();
    DISPDBG((5, "DrvEnableSurface"));

    h = DrvEnableSurface(dhpdev);

    DISPDBG((6, "DrvEnableSurface done"));
    SYNCH_LEAVE();

    return(h);
}

VOID DbgDisableSurface(DHPDEV dhpdev)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvDisableSurface"));

    DrvDisableSurface(dhpdev);

    DISPDBG((6, "DrvDisableSurface done"));
    SYNCH_LEAVE();
}

#if TARGET_BUILD > 351

BOOL DbgAssertMode(
DHPDEV dhpdev,
BOOL   bEnable)
{
    BOOL b;

    SYNCH_ENTER();
    DISPDBG((5, "DrvAssertMode"));

    b = DrvAssertMode(dhpdev,bEnable);

    DISPDBG((6, "DrvAssertMode done"));
    SYNCH_LEAVE();

    return b;
}

#else

VOID  DbgAssertMode(
DHPDEV dhpdev,
BOOL   bEnable)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvAssertMode"));

    DrvAssertMode(dhpdev,bEnable);

    DISPDBG((6, "DrvAssertMode done"));
    SYNCH_LEAVE();
}

#endif

//
// We do not SYNCH_ENTER since we have not initalized the driver.
// We just want to get the list of modes from the miniport.
//

ULONG DbgGetModes(
HANDLE    hDriver,
ULONG     cjSize,
DEVMODEW* pdm)
{
    ULONG u;

    DISPDBG((5, "DrvGetModes"));

    u = DrvGetModes(
                hDriver,
                cjSize,
                pdm);

    DISPDBG((6, "DrvGetModes done"));

    return(u);
}

VOID DbgMovePointer(SURFOBJ *pso,LONG x,LONG y,RECTL *prcl)
{
    if (gbNull)
        return;

    // Note: Because we set GCAPS_ASYNCMOVE, we don't want to do a
    //       SYNCH_ENTER/LEAVE here.

    DISPDBG((99, "DrvMovePointer"));

    DrvMovePointer(pso,x,y,prcl);

    DISPDBG((100, "DrvMovePointer done"));
}

ULONG DbgSetPointerShape(
SURFOBJ*  pso,
SURFOBJ*  psoMask,
SURFOBJ*  psoColor,
XLATEOBJ* pxlo,
LONG      xHot,
LONG      yHot,
LONG      x,
LONG      y,
RECTL*    prcl,
FLONG     fl)
{
    ULONG u;

    if (gbNull)
        return(SPS_ACCEPT_NOEXCLUDE);

    SYNCH_ENTER();
    DISPDBG((99, "DrvSetPointerShape"));

    u = DrvSetPointerShape(
                pso,
                psoMask,
                psoColor,
                pxlo,
                xHot,
                yHot,
                x,
                y,
                prcl,
                fl);

    DISPDBG((100, "DrvSetPointerShape done"));
    SYNCH_LEAVE();

    return(u);
}

ULONG DbgDitherColor(
DHPDEV dhpdev,
ULONG  iMode,
ULONG  rgb,
ULONG* pul)
{
    ULONG u;

    if (gbNull)
        return(DCR_DRIVER);

    //
    // No need to Synchronize Dither color.
    //

    DISPDBG((5, "DrvDitherColor"));

    u = DrvDitherColor(
                dhpdev,
                iMode,
                rgb,
                pul);

    DISPDBG((6, "DrvDitherColor done"));

    return(u);
}

BOOL DbgSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvSetPalette"));

    u = DrvSetPalette(
                dhpdev,
                ppalo,
                fl,
                iStart,
                cColors);

    DISPDBG((6, "DrvSetPalette done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((11, "DrvCopyBits"));

    u = DrvCopyBits(
                psoDst,
                psoSrc,
                pco,
                pxlo,
                prclDst,
                pptlSrc);

    DISPDBG((12, "DrvCopyBits done"));
    SYNCH_LEAVE();

    return(u);
}


BOOL DbgBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((11, "DrvBitBlt"));

    u = DrvBitBlt(
                psoDst,
                psoSrc,
                psoMask,
                pco,
                pxlo,
                prclDst,
                pptlSrc,
                pptlMask,
                pbo,
                pptlBrush,
                rop4);

    DISPDBG((12, "DrvBitBlt done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlOrg,
MIX       mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((11, "DrvTextOut"));

    u = DrvTextOut(
                pso,
                pstro,
                pfo,
                pco,
                prclExtra,
                prclOpaque,
                pboFore,
                pboOpaque,
                pptlOrg,
                mix);

    DISPDBG((12, "DrvTextOut done"));
    SYNCH_LEAVE();

    return(u);
}

#if TARGET_BUILD > 351
BOOL DbgLineTo(
SURFOBJ*    pso,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
LONG        x1,
LONG        y1,
LONG        x2,
LONG        y2,
RECTL*      prclBounds,
MIX         mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((11, "DrvLineTo"));

    u = DrvLineTo(
                pso,
                pco,
                pbo,
                x1,
                y1,
                x2,
                y2,
                prclBounds,
                mix);

    DISPDBG((12, "DrvLineTo done"));
    SYNCH_LEAVE();

    return(u);
}
#endif

BOOL DbgStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrushOrg,
LINEATTRS* plineattrs,
MIX        mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((11, "DrvStrokePath"));

    u = DrvStrokePath(
                pso,
                ppo,
                pco,
                pxo,
                pbo,
                pptlBrushOrg,
                plineattrs,
                mix);

    DISPDBG((12, "DrvStrokePath done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgFillPath(
SURFOBJ*  pso,
PATHOBJ*  ppo,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix,
FLONG     flOptions)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((11, "DrvFillPath"));

    u = DrvFillPath(pso,
                ppo,
                pco,
                pbo,
                pptlBrushOrg,
                mix,
                flOptions);

    DISPDBG((12, "DrvFillPath done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((11, "DrvPaint"));

    u = DrvPaint(
                pso,
                pco,
                pbo,
                pptlBrushOrg,
                mix);

    DISPDBG((12, "DrvPaint done"));
    SYNCH_LEAVE();

    return(u);
}

ULONG DbgEscape(
SURFOBJ*    pso,
ULONG       iEsc,
ULONG       cjIn,
VOID*       pvIn,
ULONG       cjOut,
VOID*       pvOut)
{
    ULONG u;

    if (gbNull)
        return(TRUE);

    // Most escapes are not synchronized by GDI...

    DISPDBG((5, "DrvEscape"));

    u = DrvEscape(pso,
                  iEsc,
                  cjIn,
                  pvIn,
                  cjOut,
                  pvOut);

    DISPDBG((6, "DrvEscape done"));

    return(u);
}

BOOL DbgRealizeBrush(
BRUSHOBJ* pbo,
SURFOBJ*  psoTarget,
SURFOBJ*  psoPattern,
SURFOBJ*  psoMask,
XLATEOBJ* pxlo,
ULONG     iHatch)
{
    BOOL u;

    // Note: The only time DrvRealizeBrush is called by GDI is when we've
    //       called BRUSHOBJ_pvGetRbrush in the middle of a DrvBitBlt
    //       call, and GDI had to call us back.  Since we're still in the
    //       middle of DrvBitBlt, synchronization has already taken care of.
    //       For the same reason, this will never be called when 'gbNull'
    //       is TRUE, so it doesn't even make sense to check gbNull...

    DISPDBG((5, "DrvRealizeBrush"));

    u = DrvRealizeBrush(
                pbo,
                psoTarget,
                psoPattern,
                psoMask,
                pxlo,
                iHatch);

    DISPDBG((6, "DrvRealizeBrush done"));

    return(u);
}

HBITMAP DbgCreateDeviceBitmap(DHPDEV dhpdev, SIZEL sizl, ULONG iFormat)
{
    HBITMAP hbm;

    if (gbNull)                     // I would pretend to have created a
        return(FALSE);              //   bitmap when gbNull is set, by we
                                    //   would need some code to back this
                                    //   up so that the system wouldn't
                                    //   crash...

    SYNCH_ENTER();
    DISPDBG((11, "DrvCreateDeviceBitmap"));

    hbm = DrvCreateDeviceBitmap(dhpdev, sizl, iFormat);

    DISPDBG((12, "DrvCreateDeviceBitmap done"));
    SYNCH_LEAVE();

    return(hbm);
}

VOID DbgDeleteDeviceBitmap(DHSURF dhsurf)
{
    SYNCH_ENTER();
    DISPDBG((11, "DrvDeleteDeviceBitmap"));

    DrvDeleteDeviceBitmap(dhsurf);

    DISPDBG((12, "DrvDeleteDeviceBitmap done"));
    SYNCH_LEAVE();
}

BOOL DbgStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMask,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMask,
ULONG               iMode)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvStretchBlt"));

    // Our DrvStretchBlt routine calls back to EngStretchBlt, which
    // calls back to our DrvCopyBits routine -- so we have to be
    // re-entrant for synchronization...

    SYNCH_LEAVE();

    u = DrvStretchBlt(psoDst, psoSrc, psoMask, pco, pxlo, pca, pptlHTOrg,
                      prclDst, prclSrc, pptlMask, iMode);

    SYNCH_ENTER();
    DISPDBG((6, "DrvStretchBlt done"));
    SYNCH_LEAVE();

    return(u);
}

VOID DbgDestroyFont(FONTOBJ *pfo)
{
    DISPDBG((5, "DbgDestroyFont"));

    DrvDestroyFont(pfo);

    DISPDBG((6, "DbgDestroyFont done"));
}

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\amach.h ===
//*************************************************************************
//**                                                                     **
//**                             AMACH.H                                 **
//**                                                                     **
//**     Copyright (c) 1993, ATI Technologies Inc.                       **
//*************************************************************************
//   
//  Created from the 68800.H and 68801.H in the Windows NT Group
//      as a simple merging of the files so ALL Mach8 and Mach32 defines
//      are located in one H file.
//
//  Created the 68800.inc file which includes equates, macros, etc 
//       from the following include files:    
//       8514vesa.inc, vga1regs.inc,  m32regs.inc,  8514.inc
//
// supplement Defines and values to the 68800 Family.
//
// This is a "C" only file and is NOT derived from any Assembler INC files.

  
/**********************       PolyTron RCS Utilities

   $Revision:   1.2  $
   $Date:   23 Dec 1994 10:48:28  $
   $Author:   ASHANMUG  $
   $Log:   S:/source/wnt/ms11/miniport/vcs/amach.h  $
 * 
 *    Rev 1.2   23 Dec 1994 10:48:28   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.1   20 May 1994 13:55:52   RWOLFF
 * Ajith's change: removed unused register SRC_CMP_COLOR from enumeration.
 * 
 *    Rev 1.0   31 Jan 1994 11:26:18   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.4   14 Jan 1994 15:15:30   RWOLFF
 * Added offsets of VGA registers from start of VGA_BASE_IO_PORT and
 * VGA_END_BREAK_PORT blocks, definition for bit in MISC_OPTIONS to
 * enable block write.
 * 
 *    Rev 1.3   15 Dec 1993 15:23:14   RWOLFF
 * Removed EISA configuration registers and (implied) placeholder for
 * linear framebuffer from register enumeration.
 * 
 *    Rev 1.2   10 Nov 1993 19:20:18   RWOLFF
 * Added definitions for DATA_READY bit of GE_STAT (ready to read from
 * PIX_TRANS in screen-to-host blit) and READ_WRITE bit of DP_CONFIG (indicates
 * whether we are reading from or writing to drawing trajectory).
 * 
 *    Rev 1.1   08 Oct 1993 10:58:52   RWOLFF
 * Added definitions for bit fields in MISC_OPTIONS and EXT_GE_CONFIG.
 * 
 *    Rev 1.0   03 Sep 1993 14:25:54   RWOLFF
 * Initial revision.
	
	   Rev 1.4   06 Jul 1993 15:53:42   RWOLFF
	Added definitions for ATI 68860 and AT&T 491 DACs.
	
	   Rev 1.3   07 Jun 1993 12:57:32   BRADES
	add EXT_SRC_Y, EXT_CUR_Y for Mach8 512k minimum mode.
	add enums for 24 and 32 bpp formats.
	
	   Rev 1.2   30 Apr 1993 15:57:06   BRADES
	fix DISP_STATUS, SEQ_IND and 1CE registers to use table.
	
	   Rev 1.0   14 Apr 1993 15:38:38   BRADES
	Initial revision.
	
	   Rev 1.6   15 Mar 1993 22:22:12   BRADES
	add mode_table.m_screen_pitch for the # pixels on a display line.
	Used with Mach8 800 by 600 where pitch is 896.
	
	   Rev 1.5   08 Mar 1993 19:58:10   BRADES
	added DEC Alpha and update to Build 390.  Thsi is from Miniport source.
	
	   Rev 1.3   15 Jan 1993 10:19:32   Robert_Wolff
	Added definitions for video card type, amount of video memory,
	and resolutions supported (formerly in VIDFIND.H).
	
	   Rev 1.2   17 Dec 1992 18:09:10   Robert_Wolff
	Added definitions for various bits in the CMD and GE_STAT registers.
	Definitions originally were in the now-obsolete S3.H for the
	engine-only driver.
	
	   Rev 1.1   13 Nov 1992 13:29:48   Robert_Wolff
	Fixed list of memory types (based on table on p. 9-66 of Programmer's
	Guide to the Mach 32 Registers, release 1.2, which swapped 2 types and
	omitted the second flavour of 256kx4 VRAM).
	
	   Rev 1.0   13 Nov 1992 09:31:02   Chris_Brady
	Initial revision.


End of PolyTron RCS section                             *****************/


#define REVISION             0x0002             // No one should use this


//-------------------------------------------------------------------------
//                 REGISTER PORT ADDRESSES
//
//  PS/2  POS registers
#define SETUP_ID1            0x0100 // Setup Mode Identification (Byte 1)
#define SETUP_ID2            0x0101 // Setup Mode Identification (Byte 2)
#define SETUP_OPT            0x0102 // Setup Mode Option Select
#define ROM_SETUP            0x0103 // 
#define SETUP_1              0x0104 //
#define SETUP_2              0x0105 //


//   Lowest and highest I/O ports used by the VGAWonder. 
#define VGA_BASE_IO_PORT        0x03B0
#define VGA_START_BREAK_PORT    0x03BB
#define VGA_END_BREAK_PORT      0x03C0
#define VGA_MAX_IO_PORT         0x03DF

// Registers used in reading/writing EEPROM
#define IO_SEQ_IND     0x03C4           // Sequencer index register 
#define IO_HI_SEQ_ADDR IO_SEQ_IND       // word register
#define IO_SEQ_DATA    0x03C5           // Sequencer data register 

/*
 * Offsets for VGA registers from regVGA_BASE_IO_PORT or
 * regVGA_END_BREAK_PORT (depending on which block they're in)
 */
#define GENMO_OFFSET        0x0002      /* 0x03C2 */
#define DAC_W_INDEX_OFFSET  0x0008      /* 0x03C8 */
#define DAC_DATA_OFFSET     0x0009      /* 0x03C9 */
#define CRTX_COLOUR_OFFSET  0x0014      /* 0x03D4 */
#define GENS1_COLOUR_OFFSET 0x001A      /* 0x03DA */



// define registers in IO space
#define IO_DAC_MASK             0x02EA // DAC Mask
#define IO_DAC_R_INDEX          0x02EB // DAC Read Index
#define IO_DAC_W_INDEX          0x02EC // DAC Write Index
#define IO_DAC_DATA             0x02ED // DAC Data

#define IO_DISP_STATUS          0x02E8 // Display Status
#define IO_H_TOTAL              0x02E8 // Horizontal Total
#define IO_OVERSCAN_COLOR_8     0x02EE 
#define IO_OVERSCAN_BLUE_24     0x02EF 
#define IO_H_DISP               0x06E8 // Horizontal Displayed
#define IO_OVERSCAN_GREEN_24    0x06EE 
#define IO_OVERSCAN_RED_24      0x06EF 
#define IO_H_SYNC_STRT          0x0AE8 // Horizontal Sync Start
#define IO_CURSOR_OFFSET_LO     0x0AEE 
#define IO_H_SYNC_WID           0x0EE8 // Horizontal Sync Width
#define IO_CURSOR_OFFSET_HI     0x0EEE 
#define IO_V_TOTAL              0x12E8 // Vertical Total
#define IO_CONFIG_STATUS_1      0x12EE // Read only equivalent to HORZ_CURSOR_POSN 
#define IO_HORZ_CURSOR_POSN     0x12EE 
#define IO_V_DISP               0x16E8 // Vertical Displayed
#define IO_CONFIG_STATUS_2      0x16EE // Read only equivalent to VERT_CURSOR_POSN
#define IO_VERT_CURSOR_POSN     0x16EE 
#define IO_V_SYNC_STRT          0x1AE8 // Vertical Sync Start
#define IO_CURSOR_COLOR_0       0x1AEE 
#define IO_FIFO_TEST_DATA       0x1AEE 
#define IO_CURSOR_COLOR_1       0x1AEF 
#define IO_V_SYNC_WID           0x1EE8 // Vertical Sync Width
#define IO_HORZ_CURSOR_OFFSET   0x1EEE 
#define IO_VERT_CURSOR_OFFSET   0x1EEF 
#define IO_DISP_CNTL            0x22E8 // Display Control 
#define IO_CRT_PITCH            0x26EE 
#define IO_CRT_OFFSET_LO        0x2AEE 
#define IO_CRT_OFFSET_HI        0x2EEE 
#define IO_LOCAL_CONTROL        0x32EE 
#define IO_FIFO_OPT             0x36EE 
#define IO_MISC_OPTIONS         0x36EE 
#define IO_EXT_CURSOR_COLOR_0   0x3AEE 
#define IO_FIFO_TEST_TAG        0x3AEE 
#define IO_EXT_CURSOR_COLOR_1   0x3EEE 
#define IO_SUBSYS_CNTL          0x42E8 // Subsystem Control
#define IO_SUBSYS_STAT          0x42E8 // Subsystem Status
#define IO_MEM_BNDRY            0x42EE 
#define IO_SHADOW_CTL           0x46EE 
#define IO_ROM_PAGE_SEL         0x46E8 // ROM Page Select (not in manual)
#define IO_ADVFUNC_CNTL         0x4AE8 // Advanced Function Control
#define IO_CLOCK_SEL            0x4AEE 
	
#define IO_ROM_ADDR_1           0x52EE 
#define IO_ROM_ADDR_2           0x56EE 
#define IO_SCRATCH_PAD_0        0x52EE 
#define IO_SCRATCH_PAD_1        0x56EE 
	
#define IO_SHADOW_SET           0x5AEE 
#define IO_MEM_CFG              0x5EEE 
#define IO_EXT_GE_STATUS        0x62EE 
	
#define IO_HORZ_OVERSCAN        0x62EE 
#define IO_VERT_OVERSCAN        0x66EE 
	
#define IO_MAX_WAITSTATES       0x6AEE 
#define IO_GE_OFFSET_LO         0x6EEE 
#define IO_BOUNDS_LEFT          0x72EE 
#define IO_GE_OFFSET_HI         0x72EE 
#define IO_BOUNDS_TOP           0x76EE 
#define IO_GE_PITCH             0x76EE 
#define IO_BOUNDS_RIGHT         0x7AEE 
#define IO_EXT_GE_CONFIG        0x7AEE 
#define IO_BOUNDS_BOTTOM        0x7EEE 
#define IO_MISC_CNTL            0x7EEE 
#define IO_CUR_Y                0x82E8 // Current Y Position
#define IO_PATT_DATA_INDEX      0x82EE 
#define IO_CUR_X                0x86E8 // Current X Position
#define IO_SRC_Y                0x8AE8 //
#define IO_DEST_Y               0x8AE8 //
#define IO_AXSTP                0x8AE8 // Destination Y Position
#define IO_SRC_X                0x8EE8 // Axial     Step Constant
#define IO_DEST_X               0x8EE8 //
#define IO_DIASTP               0x8EE8 // Destination X Position
#define IO_PATT_DATA            0x8EEE 
#define IO_R_EXT_GE_CONFIG      0x8EEE 
#define IO_ERR_TERM             0x92E8 // Error Term
#define IO_R_MISC_CNTL          0x92EE 
#define IO_MAJ_AXIS_PCNT        0x96E8 // Major Axis Pixel Count
#define IO_BRES_COUNT           0x96EE 
#define IO_CMD                  0x9AE8 // Command
#define IO_GE_STAT              0x9AE8 // Graphics Processor Status
#define IO_EXT_FIFO_STATUS      0x9AEE 
#define IO_LINEDRAW_INDEX       0x9AEE 
#define IO_SHORT_STROKE         0x9EE8 // Short Stroke Vector Transfer
#define IO_BKGD_COLOR           0xA2E8 // Background Color
#define IO_LINEDRAW_OPT         0xA2EE 
#define IO_FRGD_COLOR           0xA6E8 // Foreground Color
#define IO_DEST_X_START         0xA6EE 
#define IO_WRT_MASK             0xAAE8 // Write Mask
#define IO_DEST_X_END           0xAAEE 
#define IO_RD_MASK              0xAEE8 // Read Mask
#define IO_DEST_Y_END           0xAEEE 
#define IO_CMP_COLOR            0xB2E8 // Compare Color
#define IO_R_H_TOTAL            0xB2EE 
#define IO_R_H_DISP             0xB2EE 
#define IO_SRC_X_START          0xB2EE 
#define IO_BKGD_MIX             0xB6E8 // Background Mix
#define IO_ALU_BG_FN            0xB6EE 
#define IO_R_H_SYNC_STRT        0xB6EE 
#define IO_FRGD_MIX             0xBAE8 // Foreground Mix
#define IO_ALU_FG_FN            0xBAEE 
#define IO_R_H_SYNC_WID         0xBAEE 
#define IO_MULTIFUNC_CNTL       0xBEE8 // Multi-Function Control (mach 8)
#define IO_MIN_AXIS_PCNT        0xBEE8 
#define IO_SCISSOR_T            0xBEE8 
#define IO_SCISSOR_L            0xBEE8 
#define IO_SCISSOR_B            0xBEE8 
#define IO_SCISSOR_R            0xBEE8 
#define IO_MEM_CNTL             0xBEE8 
#define IO_PATTERN_L            0xBEE8 
#define IO_PATTERN_H            0xBEE8 
#define IO_PIXEL_CNTL           0xBEE8 
#define IO_SRC_X_END            0xBEEE 
#define IO_SRC_Y_DIR            0xC2EE 
#define IO_R_V_TOTAL            0xC2EE 
#define IO_EXT_SSV              0xC6EE // (used for MACH 8)
#define IO_EXT_SHORT_STROKE     0xC6EE 
#define IO_R_V_DISP             0xC6EE 
#define IO_SCAN_X               0xCAEE 
#define IO_R_V_SYNC_STRT        0xCAEE 
#define IO_DP_CONFIG            0xCEEE 
#define IO_VERT_LINE_CNTR       0xCEEE 
#define IO_PATT_LENGTH          0xD2EE 
#define IO_R_V_SYNC_WID         0xD2EE 
#define IO_PATT_INDEX           0xD6EE 
#define IO_EXT_SCISSOR_L        0xDAEE // "extended" left scissor (12 bits precision)
#define IO_R_SRC_X              0xDAEE 
#define IO_EXT_SCISSOR_T        0xDEEE // "extended" top scissor (12 bits precision)
#define IO_R_SRC_Y              0xDEEE 
#define IO_PIX_TRANS            0xE2E8 // Pixel Data Transfer
#define IO_PIX_TRANS_HI         0xE2E9 // Pixel Data Transfer
#define IO_EXT_SCISSOR_R        0xE2EE // "extended" right scissor (12 bits precision)
#define IO_EXT_SCISSOR_B        0xE6EE // "extended" bottom scissor (12 bits precision)
#define IO_SRC_CMP_COLOR        0xEAEE // (used for MACH 8)
#define IO_DEST_CMP_FN          0xEEEE 
#define IO_EXT_CUR_Y            0xF6EE // Mach8 only
#define IO_ASIC_ID              0xFAEE // Mach32 rev 6
#define IO_LINEDRAW             0xFEEE 



// Internal registers (read only, for test purposes only)
#define IO__PAR_FIFO_DATA       0x1AEE 
#define IO__PAR_FIFO_ADDR       0x3AEE 
#define IO__MAJOR_DEST_CNT      0x42EE 
#define IO__MAJOR_SRC_CNT       0x5EEE 
#define IO__MINOR_DEST_CNT      0x66EE 
#define IO__MINOR_SRC_CNT       0x8AEE 
#define IO__HW_TEST             0x32EE 
	

//---------------------------------------------------------
// define the registers locations in Memory Mapped space
// take the IO address and and with 0xFC00 works for offset

//---     IF    (port AND 0FFh) EQ 0E8h
//---           mov word ptr seg:[edx+(3FFE00h+((port AND 0FC00h)shr 8))],ax
//---     ELSE
//---       IF  (port AND 0FFh) EQ 0EEh
//---           mov word ptr seg:[edx+(3FFF00h+((port AND 0FC00h)shr 8))],ax
//---   0x3FFE00

#define MM_DISP_STATUS          (IO_DISP_STATUS      & 0xFC00) >> 8
#define MM_DISP_CNTL            (IO_DISP_CNTL        & 0xFC00) >> 8
#define MM_SUBSYS_CNTL          (IO_SUBSYS_CNTL      & 0xFC00) >> 8
#define MM_SUBSYS_STAT          (IO_SUBSYS_STAT      & 0xFC00) >> 8
#define MM_ADVFUNC_CNTL         (IO_ADVFUNC_CNTL     & 0xFC00) >> 8
#define MM_CUR_Y                (IO_CUR_Y            & 0xFC00) >> 8
#define MM_CUR_X                (IO_CUR_X            & 0xFC00) >> 8
#define MM_SRC_Y                (IO_SRC_Y            & 0xFC00) >> 8
#define MM_DEST_Y               (IO_DEST_Y           & 0xFC00) >> 8
#define MM_AXSTP                (IO_AXSTP            & 0xFC00) >> 8
#define MM_SRC_X                (IO_SRC_X            & 0xFC00) >> 8
#define MM_DEST_X               (IO_DEST_X           & 0xFC00) >> 8
#define MM_DIASTP               (IO_DIASTP           & 0xFC00) >> 8
#define MM_ERR_TERM             (IO_ERR_TERM         & 0xFC00) >> 8
#define MM_MAJ_AXIS_PCNT        (IO_MAJ_AXIS_PCNT    & 0xFC00) >> 8
#define MM_GE_STAT              (IO_GE_STAT          & 0xFC00) >> 8
#define MM_SHORT_STROKE         (IO_SHORT_STROKE     & 0xFC00) >> 8
#define MM_BKGD_COLOR           (IO_BKGD_COLOR       & 0xFC00) >> 8
#define MM_FRGD_COLOR           (IO_FRGD_COLOR       & 0xFC00) >> 8
#define MM_WRT_MASK             (IO_WRT_MASK         & 0xFC00) >> 8
#define MM_RD_MASK              (IO_RD_MASK          & 0xFC00) >> 8
#define MM_CMP_COLOR            (IO_CMP_COLOR        & 0xFC00) >> 8
#define MM_BKGD_MIX             (IO_BKGD_MIX         & 0xFC00) >> 8
#define MM_FRGD_MIX             (IO_FRGD_MIX         & 0xFC00) >> 8
#define MM_MULTIFUNC_CNTL       (IO_MULTIFUNC_CNTL   & 0xFC00) >> 8
#define MM_MIN_AXIS_PCNT        (IO_MIN_AXIS_PCNT    & 0xFC00) >> 8
//---   #define MM_MEM_CNTL     (IO_MEM_CNTL         & 0xFC00) >> 8
#define MM_PIXEL_CNTL           (IO_PIXEL_CNTL       & 0xFC00) >> 8
#define MM_PIX_TRANS            (IO_PIX_TRANS        & 0xFC00) >> 8
#define MM_PIX_TRANS_HI         (IO_PIX_TRANS_HI     & 0xFC00) >> 8


#define MM_CURSOR_OFFSET_LO     0x100+((IO_CURSOR_OFFSET_LO     & 0xFC00) >> 8) + (IO_CURSOR_OFFSET_LO     & 1) 
#define MM_CURSOR_OFFSET_HI     0x100+((IO_CURSOR_OFFSET_HI     & 0xFC00) >> 8) + (IO_CURSOR_OFFSET_HI     & 1) 
#define MM_CONFIG_STATUS_1      0x100+((IO_CONFIG_STATUS_1      & 0xFC00) >> 8) + (IO_CONFIG_STATUS_1      & 1) 
#define MM_HORZ_CURSOR_POSN     0x100+((IO_HORZ_CURSOR_POSN     & 0xFC00) >> 8) + (IO_HORZ_CURSOR_POSN     & 1) 
#define MM_CONFIG_STATUS_2      0x100+((IO_CONFIG_STATUS_2      & 0xFC00) >> 8) + (IO_CONFIG_STATUS_2      & 1)
#define MM_VERT_CURSOR_POSN     0x100+((IO_VERT_CURSOR_POSN     & 0xFC00) >> 8) + (IO_VERT_CURSOR_POSN     & 1)
#define MM_CURSOR_COLOR_0       0x100+((IO_CURSOR_COLOR_0       & 0xFC00) >> 8) + (IO_CURSOR_COLOR_0       & 1)
#define MM_CURSOR_COLOR_1       0x100+((IO_CURSOR_COLOR_1       & 0xFC00) >> 8) + (IO_CURSOR_COLOR_1       & 1)
#define MM_HORZ_CURSOR_OFFSET   0x100+((IO_HORZ_CURSOR_OFFSET   & 0xFC00) >> 8) + (IO_HORZ_CURSOR_OFFSET   & 1)
#define MM_VERT_CURSOR_OFFSET   0x100+((IO_VERT_CURSOR_OFFSET   & 0xFC00) >> 8) + (IO_VERT_CURSOR_OFFSET   & 1)
#define MM_CRT_PITCH            0x100+((IO_CRT_PITCH            & 0xFC00) >> 8) + (IO_CRT_PITCH            & 1)
#define MM_CRT_OFFSET_LO        0x100+((IO_CRT_OFFSET_LO        & 0xFC00) >> 8) + (IO_CRT_OFFSET_LO        & 1)
#define MM_CRT_OFFSET_HI        0x100+((IO_CRT_OFFSET_HI        & 0xFC00) >> 8) + (IO_CRT_OFFSET_HI        & 1)
#define MM_MISC_OPTIONS         0x100+((IO_MISC_OPTIONS         & 0xFC00) >> 8) + (IO_MISC_OPTIONS         & 1)
#define MM_EXT_CURSOR_COLOR_0   0x100+((IO_EXT_CURSOR_COLOR_0   & 0xFC00) >> 8) + (IO_EXT_CURSOR_COLOR_0   & 1)
#define MM_EXT_CURSOR_COLOR_1   0x100+((IO_EXT_CURSOR_COLOR_1   & 0xFC00) >> 8) + (IO_EXT_CURSOR_COLOR_1   & 1)
#define MM_CLOCK_SEL            0x100+((IO_CLOCK_SEL            & 0xFC00) >> 8) + (IO_CLOCK_SEL            & 1)
#define MM_EXT_GE_STATUS        0x100+((IO_EXT_GE_STATUS        & 0xFC00) >> 8) + (IO_EXT_GE_STATUS        & 1)
#define MM_GE_OFFSET_LO         0x100+((IO_GE_OFFSET_LO         & 0xFC00) >> 8) + (IO_GE_OFFSET_LO         & 1)
#define MM_BOUNDS_LEFT          0x100+((IO_BOUNDS_LEFT          & 0xFC00) >> 8) + (IO_BOUNDS_LEFT          & 1)
#define MM_GE_OFFSET_HI         0x100+((IO_GE_OFFSET_HI         & 0xFC00) >> 8) + (IO_GE_OFFSET_HI         & 1)
#define MM_BOUNDS_TOP           0x100+((IO_BOUNDS_TOP           & 0xFC00) >> 8) + (IO_BOUNDS_TOP           & 1)
#define MM_GE_PITCH             0x100+((IO_GE_PITCH             & 0xFC00) >> 8) + (IO_GE_PITCH             & 1)
#define MM_BOUNDS_RIGHT         0x100+((IO_BOUNDS_RIGHT         & 0xFC00) >> 8) + (IO_BOUNDS_RIGHT         & 1)
#define MM_EXT_GE_CONFIG        0x100+((IO_EXT_GE_CONFIG        & 0xFC00) >> 8) + (IO_EXT_GE_CONFIG        & 1)
#define MM_BOUNDS_BOTTOM        0x100+((IO_BOUNDS_BOTTOM        & 0xFC00) >> 8) + (IO_BOUNDS_BOTTOM        & 1)
#define MM_MISC_CNTL            0x100+((IO_MISC_CNTL            & 0xFC00) >> 8) + (IO_MISC_CNTL            & 1)
#define MM_PATT_DATA_INDEX      0x100+((IO_PATT_DATA_INDEX      & 0xFC00) >> 8) + (IO_PATT_DATA_INDEX      & 1)
#define MM_PATT_DATA            0x100+((IO_PATT_DATA            & 0xFC00) >> 8) + (IO_PATT_DATA            & 1)
#define MM_BRES_COUNT           0x100+((IO_BRES_COUNT           & 0xFC00) >> 8) + (IO_BRES_COUNT           & 1)
#define MM_EXT_FIFO_STATUS      0x100+((IO_EXT_FIFO_STATUS      & 0xFC00) >> 8) + (IO_EXT_FIFO_STATUS      & 1)
#define MM_LINEDRAW_INDEX       0x100+((IO_LINEDRAW_INDEX       & 0xFC00) >> 8) + (IO_LINEDRAW_INDEX       & 1)
#define MM_LINEDRAW_OPT         0x100+((IO_LINEDRAW_OPT         & 0xFC00) >> 8) + (IO_LINEDRAW_OPT         & 1)
#define MM_DEST_X_START         0x100+((IO_DEST_X_START         & 0xFC00) >> 8) + (IO_DEST_X_START         & 1)
#define MM_DEST_X_END           0x100+((IO_DEST_X_END           & 0xFC00) >> 8) + (IO_DEST_X_END           & 1)
#define MM_DEST_Y_END           0x100+((IO_DEST_Y_END           & 0xFC00) >> 8) + (IO_DEST_Y_END           & 1)
#define MM_SRC_X_START          0x100+((IO_SRC_X_START          & 0xFC00) >> 8) + (IO_SRC_X_START          & 1)
#define MM_ALU_BG_FN            0x100+((IO_ALU_BG_FN            & 0xFC00) >> 8) + (IO_ALU_BG_FN            & 1)
#define MM_ALU_FG_FN            0x100+((IO_ALU_FG_FN            & 0xFC00) >> 8) + (IO_ALU_FG_FN            & 1)
#define MM_SRC_X_END            0x100+((IO_SRC_X_END            & 0xFC00) >> 8) + (IO_SRC_X_END            & 1)
#define MM_SRC_Y_DIR            0x100+((IO_SRC_Y_DIR            & 0xFC00) >> 8) + (IO_SRC_Y_DIR            & 1)
#define MM_EXT_SSV              0x100+((IO_EXT_SSV              & 0xFC00) >> 8) + (IO_EXT_SSV              & 1)
#define MM_EXT_SHORT_STROKE     0x100+((IO_EXT_SHORT_STROKE     & 0xFC00) >> 8) + (IO_EXT_SHORT_STROKE     & 1)
#define MM_SCAN_X               0x100+((IO_SCAN_X               & 0xFC00) >> 8) + (IO_SCAN_X               & 1)
#define MM_DP_CONFIG            0x100+((IO_DP_CONFIG            & 0xFC00) >> 8) + (IO_DP_CONFIG            & 1)
#define MM_VERT_LINE_CNTR       0x100+((IO_VERT_LINE_CNTR       & 0xFC00) >> 8) + (IO_VERT_LINE_CNTR       & 1)
#define MM_PATT_LENGTH          0x100+((IO_PATT_LENGTH          & 0xFC00) >> 8) + (IO_PATT_LENGTH          & 1)
#define MM_PATT_INDEX           0x100+((IO_PATT_INDEX           & 0xFC00) >> 8) + (IO_PATT_INDEX           & 1)
#define MM_EXT_SCISSOR_L        0x100+((IO_EXT_SCISSOR_L        & 0xFC00) >> 8) + (IO_EXT_SCISSOR_L        & 1)
#define MM_EXT_SCISSOR_T        0x100+((IO_EXT_SCISSOR_T        & 0xFC00) >> 8) + (IO_EXT_SCISSOR_T        & 1)
#define MM_EXT_SCISSOR_R        0x100+((IO_EXT_SCISSOR_R        & 0xFC00) >> 8) + (IO_EXT_SCISSOR_R        & 1)
#define MM_EXT_SCISSOR_B        0x100+((IO_EXT_SCISSOR_B        & 0xFC00) >> 8) + (IO_EXT_SCISSOR_B        & 1)
#define MM_SRC_CMP_COLOR        0x100+((IO_SRC_CMP_COLOR        & 0xFC00) >> 8) + (IO_SRC_CMP_COLOR        & 1)
#define MM_DEST_CMP_FN          0x100+((IO_DEST_CMP_FN          & 0xFC00) >> 8) + (IO_DEST_CMP_FN          & 1)
#define MM_EXT_CUR_Y            0x100+((IO_EXT_CUR_Y            & 0xFC00) >> 8) + (IO_ASIC_ID              & 1)
#define MM_LINEDRAW             0x100+((IO_LINEDRAW             & 0xFC00) >> 8) + (IO_LINEDRAW             & 1)
													     
													     
//---------------------------------------------------------
// define the registers as subscripts to an array
// this order MATCHES  SETUP_M.H  Driver<space type>Range_m[] structures
// all entries are in INCREASING IO address.
//                                      // Alternate names AT same IO address
enum    {
    DAC_MASK=0           ,
    DAC_R_INDEX          ,        
    DAC_W_INDEX          ,        
    DAC_DATA             ,        
    DISP_STATUS          ,              //    H_TOTAL
    OVERSCAN_COLOR_8     ,              // OVERSCAN_BLUE_24 at 2EF
    H_DISP               ,
    OVERSCAN_GREEN_24    ,              // OVERSCAN_RED_24  at 6EF
    H_SYNC_STRT          ,
    CURSOR_OFFSET_LO     ,
    H_SYNC_WID           ,
    CURSOR_OFFSET_HI     ,
    V_TOTAL              ,
    CONFIG_STATUS_1      ,              //    HORZ_CURSOR_POSN     
    V_DISP               ,
    CONFIG_STATUS_2      ,              //    VERT_CURSOR_POSN     
    V_SYNC_STRT          ,
    CURSOR_COLOR_0       ,              //    FIFO_TEST_DATA       
    CURSOR_COLOR_1       ,
    V_SYNC_WID           ,
    HORZ_CURSOR_OFFSET   ,
    VERT_CURSOR_OFFSET   ,
    DISP_CNTL            ,
    CRT_PITCH            ,
    CRT_OFFSET_LO        ,
    CRT_OFFSET_HI        ,
    LOCAL_CONTROL        ,
    FIFO_OPT             ,              //    MISC_OPTIONS         
    EXT_CURSOR_COLOR_0   ,              //    FIFO_TEST_TAG        
    EXT_CURSOR_COLOR_1   ,
    SUBSYS_CNTL          ,              //    SUBSYS_STAT          
    MEM_BNDRY            ,
    ROM_PAGE_SEL         ,
    SHADOW_CTL           ,
    ADVFUNC_CNTL         ,
    CLOCK_SEL            ,
    ROM_ADDR_1           ,              //    SCRATCH_PAD_0        
    ROM_ADDR_2           ,              //    SCRATCH_PAD_1        
    SHADOW_SET           ,
    MEM_CFG              ,
    EXT_GE_STATUS        ,              //    HORZ_OVERSCAN        
    VERT_OVERSCAN        ,
    MAX_WAITSTATES       ,
    GE_OFFSET_LO         ,
    BOUNDS_LEFT          ,              //    GE_OFFSET_HI         
    BOUNDS_TOP           ,              //    GE_PITCH             
    BOUNDS_RIGHT         ,              //    EXT_GE_CONFIG        
    BOUNDS_BOTTOM        ,              //    MISC_CNTL            
    CUR_Y                ,
    PATT_DATA_INDEX      ,
    CUR_X                ,
    SRC_Y                ,              //    DEST_Y    AXSTP 
    SRC_X                ,              //    DEST_X    DIASTP  
    PATT_DATA            ,              //    R_EXT_GE_CONFIG   
    ERR_TERM             ,
    R_MISC_CNTL          ,
    MAJ_AXIS_PCNT        ,
    BRES_COUNT           ,
    CMD                  ,              //    GE_STAT       
    LINEDRAW_INDEX       ,              //    EXT_FIFO_STATUS
    SHORT_STROKE         ,
    BKGD_COLOR           ,
    LINEDRAW_OPT         ,
    FRGD_COLOR           ,
    DEST_X_START         ,
    WRT_MASK             ,
    DEST_X_END           ,
    RD_MASK              ,
    DEST_Y_END           ,
    CMP_COLOR            ,
    SRC_X_START          ,              //   R_H_TOTAL   R_H_DISP  
    BKGD_MIX             ,
    ALU_BG_FN            ,              //    R_H_SYNC_STRT      
    FRGD_MIX             ,
    ALU_FG_FN            ,              //   R_H_SYNC_WID  
    MULTIFUNC_CNTL       ,              // MIN_AXIS_PCNT SCISSOR_T SCISSOR_L  
					// SCISSOR_B SCISSOR_R MEM_CNTL 
					// PATTERN_L PATTERN_H PIXEL_CNTL 
    SRC_X_END            ,
    SRC_Y_DIR            ,              // R_V_TOTAL 
    EXT_SSV              ,              //  EXT_SHORT_STROKE    R_V_DISP 
    SCAN_X               ,              //  R_V_SYNC_STRT        
    DP_CONFIG            ,              //    VERT_LINE_CNTR       
    PATT_LENGTH          ,              // R_V_SYNC_WID      
    PATT_INDEX           ,
    EXT_SCISSOR_L        ,              //    R_SRC_X              
    EXT_SCISSOR_T        ,              //    R_SRC_Y              
    PIX_TRANS            ,
    PIX_TRANS_HI         ,
    EXT_SCISSOR_R        ,
    EXT_SCISSOR_B        ,
    DEST_CMP_FN          ,
    ASIC_ID              ,
    LINEDRAW             ,
    SEQ_IND              ,
    HI_SEQ_ADDR          ,
    SEQ_DATA             ,
    regVGA_BASE_IO_PORT  ,
    regVGA_END_BREAK_PORT,
    reg1CE               ,              // ati_reg == 0x1CE
    reg1CF               ,              // ati_reg == 0x1CF
    EXT_CUR_Y            ,
    reg3CE               ,              // 

// Internal registers (read only, for test purposes only)
    _PAR_FIFO_DATA       ,
    _PAR_FIFO_ADDR       ,
    _MAJOR_DEST_CNT      ,
    _MAJOR_SRC_CNT       ,
    _MINOR_DEST_CNT      ,
    _MINOR_SRC_CNT       ,
    _HW_TEST             
    };

// define the registers located at the same I/O addresses
#define    H_TOTAL                      DISP_STATUS          
#define    HORZ_CURSOR_POSN             CONFIG_STATUS_1      
#define    VERT_CURSOR_POSN             CONFIG_STATUS_2      
#define    FIFO_TEST_DATA               CURSOR_COLOR_0       
#define    MISC_OPTIONS                 FIFO_OPT             
#define    FIFO_TEST_TAG                EXT_CURSOR_COLOR_0   
#define    SUBSYS_STAT                  SUBSYS_CNTL          
#define    SCRATCH_PAD_0                ROM_ADDR_1           
#define    SCRATCH_PAD_1                ROM_ADDR_2           
#define    HORZ_OVERSCAN                EXT_GE_STATUS        
#define    GE_STAT                      CMD
#define    GE_OFFSET_HI                 BOUNDS_LEFT          
#define    GE_PITCH                     BOUNDS_TOP           
#define    EXT_GE_CONFIG                BOUNDS_RIGHT         
#define    MISC_CNTL                    BOUNDS_BOTTOM        
#define    DEST_Y                       SRC_Y                
#define    AXSTP                        SRC_Y                
#define    DEST_X                       SRC_X                
#define    DIASTP                       SRC_X                
#define    R_EXT_GE_CONFIG              PATT_DATA            
#define    EXT_FIFO_STATUS              LINEDRAW_INDEX       
#define    R_H_TOTAL                    SRC_X_START          
#define    R_H_DISP                     SRC_X_START          
#define    R_H_SYNC_STRT                ALU_BG_FN           
#define    R_H_SYNC_WID                 ALU_FG_FN            
#define    MEM_CNTL                     MULTIFUNC_CNTL       
#define    R_V_TOTAL                    SRC_Y_DIR            
#define    EXT_SHORT_STROKE             EXT_SSV              
#define    R_V_DISP                     EXT_SSV              
#define    R_V_SYNC_STRT                SCAN_X               
#define    VERT_LINE_CNTR               DP_CONFIG            
#define    R_V_SYNC_WID                 PATT_LENGTH          
#define    R_SRC_X                      EXT_SCISSOR_L        
#define    R_SRC_Y                      EXT_SCISSOR_T        
#define    EXT_SRC_Y                    ASIC_ID



//---------------------------------------------------------
//---------------------------------------------------------
//  Define the ASIC revisions into something Useful
//  Values are reported by the ASIC_ID register.

#define MACH32_REV3             0
#define MACH32_REV5             1               // not in production
#define MACH32_REV6             2


//---------------------------------------------------------
//

#define MIX_FN_NOT_D         0x0000 //NOT dest
#define MIX_FN_ZERO          0x0001 //dest = 0
#define MIX_FN_ONE           0x0002 //dest = 1
#define MIX_FN_LEAVE_ALONE   0x0003 //dest
#define MIX_FN_NOT_S         0x0004 //NOT source
#define MIX_FN_XOR           0x0005 //source XOR dest
#define MIX_FN_XNOR          0x0006 //source XOR  NOT dest
#define MIX_FN_PAINT         0x0007 //source
#define MIX_FN_NAND          0x0008 //NOT source OR NOT dest
#define MIX_FN_D_OR_NOT_S    0x0009 //NOT source OR     dest
#define MIX_FN_NOT_D_OR_S    0x000A //source OR NOT dest
#define MIX_FN_OR            0x000B //source OR  dest
#define MIX_FN_AND           0x000C //dest AND source
#define MIX_FN_NOT_D_AND_S   0x000D //NOT dest AND source
#define MIX_FN_D_AND_NOT_S   0x000E //dest AND NOT source
#define MIX_FN_NOR           0x000F //NOT dest AND NOT source
#define MIX_FN_MIN           0x0010 //minimum
#define MIX_FN_SUBSZ         0x0011 //(dest - source), with saturate
#define MIX_FN_SUBDZ         0x0012 //(source - dest), with saturate
#define MIX_FN_ADDS          0x0013 //add with saturation
#define MIX_FN_MAX           0x0014 //maximum

//
//
//---------------------------------------------------------
//
//Following are the FIFO checking macros:
//
#define ONE_WORD             0x8000 
#define TWO_WORDS            0xC000 
#define THREE_WORDS          0xE000 
#define FOUR_WORDS           0xF000 
#define FIVE_WORDS           0xF800 
#define SIX_WORDS            0xFC00 
#define SEVEN_WORDS          0xFE00 
#define EIGHT_WORDS          0xFF00 
#define NINE_WORDS           0xFF80 
#define TEN_WORDS            0xFFC0 
#define ELEVEN_WORDS         0xFFE0 
#define TWELVE_WORDS         0xFFF0 
#define THIRTEEN_WORDS       0xFFF8 
#define FOURTEEN_WORDS       0xFFFC 
#define FIFTEEN_WORDS        0xFFFE 
#define SIXTEEN_WORDS        0xFFFF 
//
//
//
//---------------------------------------
//
//
// Draw Command (IBM 8514 compatible CMD register)
//
// opcode field
#define OP_CODE              0xE000 
#define SHIFT_op_code        0x000D 
#define DRAW_SETUP           0x0000 
#define DRAW_LINE            0x2000 
#define FILL_RECT_H1H4       0x4000 
#define FILL_RECT_V1V2       0x6000 
#define FILL_RECT_V1H4       0x8000 
#define DRAW_POLY_LINE       0xA000 
#define BITBLT_OP            0xC000 
#define DRAW_FOREVER         0xE000 
// swap field
#define LSB_FIRST            0x1000 
// data width field
#define DATA_WIDTH           0x0200 
#define BIT16                0x0200 
#define BIT8                 0x0000 
// CPU wait field
#define CPU_WAIT             0x0100 
// octant field
#define OCTANT               0x00E0 
#define SHIFT_octant         0x0005 
#define YPOSITIVE            0x0080 
#define YMAJOR               0x0040 
#define XPOSITIVE            0x0020 
// draw field
#define DRAW                 0x0010 
// direction field
#define DIR_TYPE             0x0008 
#define DEGREE               0x0008 
#define XY                   0x0000 
#define RECT_RIGHT_AND_DOWN  0x00E0 // quadrant 3
#define RECT_LEFT_AND_UP     0x0000 // quadrant 1
// last pel off field
#define SHIFT_last_pel_off   0x0002 
#define LAST_PEL_OFF         0x0004 
#define LAST_PEL_ON          0x0000 
#define LAST_PIXEL_OFF       0x0004
#define LAST_PIXEL_ON        0x0000
#define MULTIPLE_PIXELS      0x0002
#define SINGLE_PIXEL         0x0000

// pixel mode
#define PIXEL_MODE           0x0002 
#define MULTI                0x0002 
#define SINGLE               0x0000 
// read/write
#define RW                   0x0001 
#define WRITE                0x0001 
#define READ                 0x0000 
//
// ---------------------------------------------------------
//


//
// GE_STAT (9AE8) is set if the engine is busy.
//
#define HARDWARE_BUSY   0x0200
#define DATA_READY      0x0100

/*
 * Miscelaneous Options (MISC_OPTIONS)
 */
#define MEM_SIZE_ALIAS      0x0000C
#define MEM_SIZE_STRIPPED   0x0FFF3
#define MEM_SIZE_512K       0x00000
#define MEM_SIZE_1M         0x00004
#define MEM_SIZE_2M         0x00008
#define MEM_SIZE_4M         0x0000C
#define BLK_WR_ENA          0x00400

//
// Extended Graphics Engine Status (EXT_GE_STATUS)
//
#define POINTS_INSIDE        0x8000 
#define EE_DATA_IN           0x4000 
#define GE_ACTIVE            0x2000 
#define CLIP_ABOVE           0x1000 
#define CLIP_BELOW           0x0800 
#define CLIP_LEFT            0x0400 
#define CLIP_RIGHT           0x0200 
#define CLIP_FLAGS           0x1E00 
#define CLIP_INSIDE          0x0100 
#define EE_CRC_VALID         0x0080 
#define CLIP_OVERRUN         0x000F 

/*
 * Extended Graphics Engine Configuration (EXT_GE_CONFIG)
 */
#define PIX_WIDTH_4BPP      0x0000
#define PIX_WIDTH_8BPP      0x0010
#define PIX_WIDTH_16BPP     0x0020
#define PIX_WIDTH_24BPP     0x0030
#define ORDER_16BPP_555     0x0000
#define ORDER_16BPP_565     0x0040
#define ORDER_16BPP_655     0x0080
#define ORDER_16BPP_664     0x00C0
#define ORDER_24BPP_RGB     0x0000
#define ORDER_24BPP_RGBx    0x0200
#define ORDER_24BPP_BGR     0x0400
#define ORDER_24BPP_xBGR    0x0600


//
// Datapath Configuration Register (DP_CONFIG) 
#define FG_COLOR_SRC         0xE000 
#define SHIFT_fg_color_src   0x000D 
#define DATA_ORDER           0x1000 
#define DATA_WIDTH           0x0200 
#define BG_COLOR_SRC         0x0180 
#define SHIFT_bg_color_src   0x0007 
#define EXT_MONO_SRC         0x0060 
#define SHIFT_ext_mono_src   0x0005 
#define DRAW                 0x0010 
#define READ_MODE            0x0004 
#define POLY_FILL_MODE       0x0002 
#define READ_WRITE           0x0001
#define SRC_SWAP             0x0800 
//
#define FG_COLOR_SRC_BG      0x0000 // Background Color Register
#define FG_COLOR_SRC_FG      0x2000 // Foreground Color Register
#define FG_COLOR_SRC_HOST    0x4000 // CPU Data Transfer Reg
#define FG_COLOR_SRC_BLIT    0x6000 // VRAM blit source
#define FG_COLOR_SRC_GS      0x8000 // Grey-scale mono blit
#define FG_COLOR_SRC_PATT    0xA000 // Color Pattern Shift Reg
#define FG_COLOR_SRC_CLUH    0xC000 // Color lookup of Host Data
#define FG_COLOR_SRC_CLUB    0xE000 // Color lookup of blit src
//
#define BG_COLOR_SRC_BG      0x0000 // Background Color Reg
#define BG_COLOR_SRC_FG      0x0080 // Foreground Color Reg
#define BG_COLOR_SRC_HOST    0x0100 // CPU Data Transfer Reg
#define BG_COLOR_SRC_BLIT    0x0180 // VRAM blit source

//
// Note that "EXT_MONO_SRC" and "MONO_SRC" are mutually destructive, but that
// "EXT_MONO_SRC" selects the ATI pattern registers.
//
#define EXT_MONO_SRC_ONE     0x0000 // Always '1'
#define EXT_MONO_SRC_PATT    0x0020 // ATI Mono Pattern Regs
#define EXT_MONO_SRC_HOST    0x0040 // CPU Data Transfer Reg
#define EXT_MONO_SRC_BLIT    0x0060 // VRAM Blit source plane

//
// Linedraw Options Register (LINEDRAW_OPT) 
//
#define CLIP_MODE            0x0600 
#define SHIFT_clip_mode      0x0009 
#define CLIP_MODE_DIS        0x0000 
#define CLIP_MODE_LINE       0x0200 
#define CLIP_MODE_PLINE      0x0400 
#define CLIP_MODE_PATT       0x0600 
#define BOUNDS_RESET         0x0100 
#define OCTANT               0x00E0 
#define SHIFT_ldo_octant     0x0005 
#define YDIR                 0x0080 
#define XMAJOR               0x0040 
#define XDIR                 0x0020 
#define DIR_TYPE             0x0008 
#define DIR_TYPE_DEGREE      0x0008 
#define DIR_TYPE_OCTANT      0x0000 
#define LAST_PEL_OFF         0x0004 
#define POLY_MODE            0x0002 
//
//

//--------------  was in 68801.H    --------------------------------------



//*** 8514  EEPROM command codes *************************************
//      format is     0111 1100 0000b
#define EE_READ             0x0600  // read address
#define EE_ERASE            0x0700  // erase address
#define EE_WRITE            0x0500  // write address
#define EE_ENAB             0x0980  // enable EEPROM
#define EE_DISAB            0x0800  // disable EEPROM


//-------------------------------------------------------------------------
//                 REGISTER  bit definitions


// Configuration Status   1  (CONFIG_STATUS_1)
// 
//
#define ROM_LOCATION         0xFE00 
#define SHIFT_rom_location   0x0009 
#define ROM_PAGE_ENA         0x0100 
#define ROM_ENA              0x0080 
#define MEM_INSTALLED        0x0060 
#define SHIFT_mem_installed  0x0005 
#define MEM_INSTALLED_128k   0x0000 
#define MEM_INSTALLED_256k   0x0020 
#define MEM_INSTALLED_512k   0x0040 
#define MEM_INSTALLED_1024k  0x0060 
#define DRAM_ENA             0x0010 
#define EEPROM_ENA           0x0008 
#define MC_BUS               0x0004 
#define BUS_16               0x0002 
#define CLK_MODE             0x0001 
//
//
// Configuration Status 2 (CONFIG_STATUS_2)
// 
//
//
#define FLASH_ENA            0x0010 
#define WRITE_PER_BIT        0x0008 
#define EPROM16_ENA          0x0004 
#define HIRES_BOOT           0x0002 
#define SHARE_CLOCK          0x0001 





//-------------------------------------------------------------------------
//  For the Mach32 - 68800 class of adapters,  the eeprom location
//  is different for an 8514/Ultra in an 8 bit bus, 16 bit bus, and 68800.
//
#define EE_DATA_IN         0x4000       // Inputs are OK

// Mach 32 values
#define EE_SELECT_M32      8
#define EE_CS_M32          4
#define EE_CLK_M32         2
#define EE_DATA_OUT_M32    1

// Mach 8 values  in a 16 bit bus
#define EE_SELECT_M8_16    0x8000
#define EE_CS_M8_16        0x4000
#define EE_CLK_M8_16       0x2000
#define EE_DATA_OUT_M8_16  0x1000

// Mach 8 values  in an 8 bit bus  OR jumpered to 8 bit I/O operation
#define EE_SELECT_M8_8     0x80
#define EE_CS_M8_8         0x04
#define EE_CLK_M8_8        0x02
#define EE_DATA_OUT_M8_8   0x01


//-------------------------------------------------------------------------
//  Context indices 
//
#define PATT_COLOR_INDEX      0
#define PATT_MONO_INDEX       16
#define PATT_INDEX_INDEX      19
#define DP_CONFIG_INDEX       27
#define LINEDRAW_OPTION_INDEX 26


//**********************   end  of  AMACH.H   ****************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\amachcx.h ===
//*************************************************************************
//**                                                                     **
//**                             AMACHCX.H                               **
//**                                                                     **
//**     Copyright (c) 1993, ATI Technologies Inc.                       **
//*************************************************************************
//
//  Created from the CH0.H 68800CX header file to get CX and standard
//      register definitions in the same format.
//
//  Created from the 68800.H and 68801.H in the Windows NT Group
//      as a simple merging of the files so ALL Mach8 and Mach32 defines
//      are located in one H file.
//
//  Created the 68800.inc file which includes equates, macros, etc 
//       from the following include files:    
//       8514vesa.inc, vga1regs.inc,  m32regs.inc,  8514.inc
//
// supplement Defines and values to the 68800 Family.
//
// This is a "C" only file and is NOT derived from any Assembler INC files.

  
/**********************       PolyTron RCS Utilities

   $Revision:   1.17  $
   $Date:   15 Apr 1996 16:57:28  $
   $Author:   RWolff  $
   $Log:   S:/source/wnt/ms11/miniport/archive/amachcx.h_v  $
 * 
 *    Rev 1.17   15 Apr 1996 16:57:28   RWolff
 * Added definitions for various revisions of the GX and CX ASICs
 * 
 *    Rev 1.16   01 Mar 1996 12:09:48   RWolff
 * VGA Graphics Index and Graphics Data are now handled as separate
 * registers rather than as offsets into the block of VGA registers.
 * 
 *    Rev 1.15   22 Sep 1995 16:47:08   RWolff
 * Added definitions for AL values of accelerator BIOS functions to
 * allow switching on the low byte of the function.
 * 
 *    Rev 1.14   24 Aug 1995 15:41:12   RWolff
 * Changed detection of block I/O cards to match Microsoft's
 * standard for plug-and-play.
 * 
 *    Rev 1.13   24 Feb 1995 12:28:36   RWOLFF
 * Added definitions used for relocatable I/O and 24BPP text banding
 * 
 *    Rev 1.12   20 Feb 1995 18:00:34   RWOLFF
 * Added definition for GX rev. E ASIC.
 * 
 *    Rev 1.11   23 Dec 1994 10:48:02   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.10   18 Nov 1994 11:52:12   RWOLFF
 * Register name change to CLOCK_CNTL to match latest documents, added
 * some new bitfield definitions for registers.
 * 
 *    Rev 1.9   14 Sep 1994 15:20:58   RWOLFF
 * Added definitions for all 32BPP colour orderings.
 * 
 *    Rev 1.8   31 Aug 1994 16:11:08   RWOLFF
 * Removed VGA_SLEEP from enumeration of registers used on Mach 64
 * (we don't access it, and it conflicts with DigiBoard), added
 * support for BGRx in 32BPP (used by TVP3026 DAC).
 * 
 *    Rev 1.7   20 Jul 1994 12:59:38   RWOLFF
 * Added support for multiple I/O base addresses for accelerator registers.
 * 
 *    Rev 1.6   12 May 1994 11:21:22   RWOLFF
 * Added masks for pitch and pixel depth fields of ECX for BIOS_LOAD_CRTC
 * call.
 * 
 *    Rev 1.5   05 May 1994 13:40:40   RWOLFF
 * Added definitions for chip identification register fields.
 * 
 *    Rev 1.4   04 May 1994 10:58:48   RWOLFF
 * Added definitions for MEM_SIZE field in MEM_CNTL register.
 * 
 *    Rev 1.3   27 Apr 1994 13:57:28   RWOLFF
 * Added definitions for offsets of graphics index and graphics data
 * registers from start of block of VGA registers.
 * 
 *    Rev 1.2   14 Mar 1994 16:31:58   RWOLFF
 * Added offset and pitch masks for SRC_OFF_PITCH register.
 * 
 *    Rev 1.1   03 Mar 1994 12:36:40   ASHANMUG
 * Correct GAMMA bit
 * 
 *    Rev 1.0   31 Jan 1994 11:26:34   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.4   24 Jan 1994 18:00:52   RWOLFF
 * Added new definitions for fields introduced in 94/01/19 BIOS document.
 * 
 *    Rev 1.3   14 Jan 1994 15:17:18   RWOLFF
 * Added definition for bit in GEN_TEST_CNTL to enable block write,
 * BIOS function codes now take AH value from a single definition
 * to allow single-point change of all codes, updated function codes
 * to match BIOS version 0.13.
 * 
 *    Rev 1.2   30 Nov 1993 18:09:14   RWOLFF
 * Fixed enumeration of register names, added definitions for more fields in
 * more registers, removed redundant definitions.
 * 
 *    Rev 1.1   05 Nov 1993 13:21:24   RWOLFF
 * Defined and enumerated values now use same naming conventions as AMACH.H
 * 
 *    Rev 1.0   03 Sep 1993 14:26:46   RWOLFF
 * Initial revision.


End of PolyTron RCS section				*****************/


#define REVISION             0x0002             // No one should use this

/*
 * Offsets from start of linear aperture to start of memory-mapped
 * registers on 4M and 8M cards, and offset from start of address
 * space to start of memory-mapped registers when VGA is enabled.
 */
#define OFFSET_4M   0x3FFC00
#define OFFSET_8M   0x7FFC00
#define OFFSET_VGA  0x0BFC00


/*
 * Base addresses for Mach 64 accelerator registers.
 */
#define M64_STD_BASE_ADDR       0x02EC
#define M64_ALT_BASE_ADDR_1     0x01C8
#define M64_ALT_BASE_ADDR_2     0x01CC
#define NUM_BASE_ADDRESSES      3

/*
 * CRTC I/O registers. Only the variable portion
 * of the register is given here. To get the full
 * register, add the base address.
 */

#define IO_CRTC_H_TOTAL_DISP    0x0000
#define IO_CRTC_H_SYNC_STRT_WID 0x0400
#define IO_CRTC_V_TOTAL_DISP    0x0800
#define IO_CRTC_V_SYNC_STRT_WID 0x0C00
#define IO_CRTC_CRNT_VLINE      0x1000
#define IO_CRTC_OFF_PITCH       0x1400
#define IO_CRTC_INT_CNTL        0x1800
#define IO_CRTC_GEN_CNTL        0x1C00

#define IO_OVR_CLR              0x2000
#define IO_OVR_WID_LEFT_RIGHT   0x2400
#define IO_OVR_WID_TOP_BOTTOM   0x2800

#define IO_CUR_CLR0             0x2C00
#define IO_CUR_CLR1             0x3000
#define IO_CUR_OFFSET           0x3400
#define IO_CUR_HORZ_VERT_POSN   0x3800
#define IO_CUR_HORZ_VERT_OFF    0x3C00

#define IO_SCRATCH_REG0         0x4000
#define IO_SCRATCH_REG1         0x4400

#define IO_CLOCK_CNTL           0x4800

#define IO_BUS_CNTL             0x4C00

#define IO_MEM_CNTL             0x5000
#define IO_MEM_VGA_WP_SEL       0x5400
#define IO_MEM_VGA_RP_SEL       0x5800

#define IO_DAC_REGS             0x5C00
#define IO_DAC_CNTL             0x6000

#define IO_GEN_TEST_CNTL        0x6400

#define IO_CONFIG_CNTL          0x6800
#define IO_CONFIG_CHIP_ID       0x6C00
#define IO_CONFIG_STAT0         0x7000
#define IO_CONFIG_STAT1         0x7400


// CRTC MEM Registers


#define MM_CRTC_H_TOTAL_DISP    0x0000
#define MM_CRTC_H_SYNC_STRT_WID 0x0001
#define MM_CRTC_V_TOTAL_DISP    0x0002
#define MM_CRTC_V_SYNC_STRT_WID 0x0003
#define MM_CRTC_CRNT_VLINE      0x0004
#define MM_CRTC_OFF_PITCH       0x0005
#define MM_CRTC_INT_CNTL        0x0006
#define MM_CRTC_GEN_CNTL        0x0007

#define MM_OVR_CLR              0x0010
#define MM_OVR_WID_LEFT_RIGHT   0x0011
#define MM_OVR_WID_TOP_BOTTOM   0x0012

#define MM_CUR_CLR0             0x0018
#define MM_CUR_CLR1             0x0019
#define MM_CUR_OFFSET           0x001A
#define MM_CUR_HORZ_VERT_POSN   0x001B
#define MM_CUR_HORZ_VERT_OFF    0x001C

#define MM_SCRATCH_REG0         0x0020
#define MM_SCRATCH_REG1         0x0021

#define MM_CLOCK_CNTL           0x0024

#define MM_BUS_CNTL             0x0028

#define MM_MEM_CNTL             0x002C
#define MM_MEM_VGA_WP_SEL       0x002D
#define MM_MEM_VGA_RP_SEL       0x002E

#define MM_DAC_REGS             0x0030
#define MM_DAC_CNTL             0x0031

#define MM_GEN_TEST_CNTL        0x0034

/*
 * This register does not exist in memory-mapped form,
 * but on cards with relocatable I/O, the I/O index of
 * each register matches its memory-mapped index. This
 * register was assigned an otherwise unused index for
 * this purpose.
 */
#define MM_CONFIG_CNTL          0x0037

#define MM_CONFIG_CHIP_ID       0x0038
#define MM_CONFIG_STAT0         0x0039
#define MM_CONFIG_STAT1         0x003A




#define MM_DST_OFF_PITCH        0x0040
#define MM_DST_X                0x0041
#define MM_DST_Y                0x0042
#define MM_DST_Y_X              0x0043
#define MM_DST_WIDTH            0x0044
#define MM_DST_HEIGHT           0x0045
#define MM_DST_HEIGHT_WIDTH     0x0046
#define MM_DST_X_WIDTH          0x0047
#define MM_DST_BRES_LNTH        0x0048
#define MM_DST_BRES_ERR         0x0049
#define MM_DST_BRES_INC         0x004A
#define MM_DST_BRES_DEC         0x004B
#define MM_DST_CNTL             0x004C

#define MM_SRC_OFF_PITCH        0x0060
#define MM_SRC_X                0x0061
#define MM_SRC_Y                0x0062
#define MM_SRC_Y_X              0x0063
#define MM_SRC_WIDTH1           0x0064
#define MM_SRC_HEIGHT1          0x0065
#define MM_SRC_HEIGHT1_WIDTH1   0x0066
#define MM_SRC_X_START          0x0067
#define MM_SRC_Y_START          0x0068
#define MM_SRC_Y_X_START        0x0069
#define MM_SRC_WIDTH2           0x006A
#define MM_SRC_HEIGHT2          0x006B
#define MM_SRC_HEIGHT2_WIDTH2   0x006C
#define MM_SRC_CNTL             0x006D

#define MM_HOST_DATA0           0x0080
#define MM_HOST_DATA1           0x0081
#define MM_HOST_DATA2           0x0082
#define MM_HOST_DATA3           0x0083
#define MM_HOST_DATA4           0x0084
#define MM_HOST_DATA5           0x0085
#define MM_HOST_DATA6           0x0086
#define MM_HOST_DATA7           0x0087
#define MM_HOST_DATA8           0x0088
#define MM_HOST_DATA9           0x0089
#define MM_HOST_DATA10          0x008A
#define MM_HOST_DATA11          0x008B
#define MM_HOST_DATA12          0x008C
#define MM_HOST_DATA13          0x008D
#define MM_HOST_DATA14          0x008E
#define MM_HOST_DATA15          0x008F
#define MM_HOST_CNTL            0x0090

#define MM_PAT_REG0             0x00A0
#define MM_PAT_REG1             0x00A1
#define MM_PAT_CNTL             0x00A2

#define MM_SC_LEFT              0x00A8
#define MM_SC_RIGHT             0x00A9
#define MM_SC_LEFT_RIGHT        0x00AA
#define MM_SC_TOP               0x00AB
#define MM_SC_BOTTOM            0x00AC
#define MM_SC_TOP_BOTTOM        0x00AD

#define MM_DP_BKGD_CLR          0x00B0
#define MM_DP_FRGD_CLR          0x00B1
#define MM_DP_WRITE_MASK        0x00B2
#define MM_DP_CHAIN_MASK        0x00B3
#define MM_DP_PIX_WIDTH         0x00B4
#define MM_DP_MIX               0x00B5
#define MM_DP_SRC               0x00B6

#define MM_CLR_CMP_CLR          0x00C0
#define MM_CLR_CMP_MSK          0x00C1
#define MM_CLR_CMP_CNTL         0x00C2

#define MM_FIFO_STAT            0x00C4

#define MM_CONTEXT_MASK         0x00C8
#define MM_CONTEXT_SAVE_CNTL    0x00CA
#define MM_CONTEXT_LOAD_CNTL    0x00CB

#define MM_GUI_TRAJ_CNTL        0x00CC
#define MM_GUI_STAT             0x00CE

/*
 * VGAWonder-compatible registers (all in I/O space).
 */
#define IO_VGA_SLEEP            0x0102
#define IO_VGA_BASE_IO_PORT     0x03B0
#define IO_VGA_START_BREAK_PORT 0x03BB
#define IO_VGA_END_BREAK_PORT   0x03C0
#define IO_VGA_MAX_IO_PORT      0x03DF

/*
 * VGA Sequencer index/data registers (most frequently used
 * of VGAWonder-compatible registers).
 */
#define IO_VGA_SEQ_IND          0x03C4
#define IO_VGA_SEQ_DATA         0x03C5

/*
 * VGA Graphics index/data registers (another frequently used
 * VGA register pair)
 */
#define IO_VGA_GRAX_IND         0x03CE
#define IO_VGA_GRAX_DATA        0x03CF

/*
 * ATI extended registers
 */
#define IO_reg1CE               0x01CE
#define IO_reg1CF               0x01CF



/*
 * Define the registers as subscripts to an array
 */
enum {
    VGA_BASE_IO_PORT=0      ,
    VGA_END_BREAK_PORT      ,
    VGA_SEQ_IND             ,
    VGA_SEQ_DATA            ,
    VGA_GRAX_IND            ,
    VGA_GRAX_DATA           ,
    reg1CE                  ,
    reg1CF                  ,
    CRTC_H_TOTAL_DISP       ,
    CRTC_H_SYNC_STRT_WID    ,
    CRTC_V_TOTAL_DISP       ,
    CRTC_V_SYNC_STRT_WID    ,
    CRTC_CRNT_VLINE         ,
    CRTC_OFF_PITCH          ,
    CRTC_INT_CNTL           ,
    CRTC_GEN_CNTL           ,
    OVR_CLR                 ,
    OVR_WID_LEFT_RIGHT      ,
    OVR_WID_TOP_BOTTOM      ,
    CUR_CLR0                ,
    CUR_CLR1                ,
    CUR_OFFSET              ,
    CUR_HORZ_VERT_POSN      ,
    CUR_HORZ_VERT_OFF       ,
    SCRATCH_REG0            ,
    SCRATCH_REG1            ,
    CLOCK_CNTL              ,
    BUS_CNTL                ,
    MEM_CNTL                ,
    MEM_VGA_WP_SEL          ,
    MEM_VGA_RP_SEL          ,
    DAC_REGS                ,
    DAC_CNTL                ,
    GEN_TEST_CNTL           ,
    CONFIG_CNTL             ,
    CONFIG_CHIP_ID          ,
    CONFIG_STAT0            ,
    CONFIG_STAT1            ,
    DST_OFF_PITCH           ,
    DST_X                   ,
    DST_Y                   ,
    DST_Y_X                 ,
    DST_WIDTH               ,
    DST_HEIGHT              ,
    DST_HEIGHT_WIDTH        ,
    DST_X_WIDTH             ,
    DST_BRES_LNTH           ,
    DST_BRES_ERR            ,
    DST_BRES_INC            ,
    DST_BRES_DEC            ,
    DST_CNTL                ,
    SRC_OFF_PITCH           ,
    SRC_X                   ,
    SRC_Y                   ,
    SRC_Y_X                 ,
    SRC_WIDTH1              ,
    SRC_HEIGHT1             ,
    SRC_HEIGHT1_WIDTH1      ,
    SRC_X_START             ,
    SRC_Y_START             ,
    SRC_Y_X_START           ,
    SRC_WIDTH2              ,
    SRC_HEIGHT2             ,
    SRC_HEIGHT2_WIDTH2      ,
    SRC_CNTL                ,
    HOST_DATA0              ,
    HOST_DATA1              ,
    HOST_DATA2              ,
    HOST_DATA3              ,
    HOST_DATA4              ,
    HOST_DATA5              ,
    HOST_DATA6              ,
    HOST_DATA7              ,
    HOST_DATA8              ,
    HOST_DATA9              ,
    HOST_DATA10             ,
    HOST_DATA11             ,
    HOST_DATA12             ,
    HOST_DATA13             ,
    HOST_DATA14             ,
    HOST_DATA15             ,
    HOST_CNTL               ,
    PAT_REG0                ,
    PAT_REG1                ,
    PAT_CNTL                ,
    SC_LEFT                 ,
    SC_RIGHT                ,
    SC_LEFT_RIGHT           ,
    SC_TOP                  ,
    SC_BOTTOM               ,
    SC_TOP_BOTTOM           ,
    DP_BKGD_CLR             ,
    DP_FRGD_CLR             ,
    DP_WRITE_MASK           ,
    DP_CHAIN_MASK           ,
    DP_PIX_WIDTH            ,
    DP_MIX                  ,
    DP_SRC                  ,
    CLR_CMP_CLR             ,
    CLR_CMP_MSK             ,
    CLR_CMP_CNTL            ,
    FIFO_STAT               ,
    CONTEXT_MASK            ,
    CONTEXT_SAVE_CNTL       ,
    CONTEXT_LOAD_CNTL       ,
    GUI_TRAJ_CNTL           ,
    GUI_STAT
};


/*
 * Bit fields used in the registers.
 *
 * CRT Offset and Pitch
 */
#define CRTC_OFF_PITCH_Offset   0x000FFFFF
#define CRTC_OFF_PITCH_Pitch    0xFFC00000

/*
 * CRT General Control
 */
#define CRTC_GEN_CNTL_DblScan   0x00000001
#define CRTC_GEN_CNTL_Interlace 0x00000002
#define CRTC_GEN_CNTL_HSynDisab 0x00000004
#define CRTC_GEN_CNTL_VSynDisab 0x00000008
#define CRTC_GEN_CNTL_CompSync  0x00000010
#define CRTC_GEN_CNTL_MuxMode   0x00000020
#define CRTC_GEN_CNTL_DispDisab 0x00000040
#define CRTC_GEN_CNTL_DepthMask 0x00000700
#define CRTC_GEN_CNTL_Dep4      0x00000100
#define CRTC_GEN_CNTL_Dep8      0x00000200
#define CRTC_GEN_CNTL_Dep15_555 0x00000300
#define CRTC_GEN_CNTL_Dep16_565 0x00000400
#define CRTC_GEN_CNTL_Dep24     0x00000500
#define CRTC_GEN_CNTL_Dep32     0x00000600
#define CRTC_GEN_CNTL_ShowVga   0x00000000
#define CRTC_GEN_CNTL_ShowAcc   0x01000000
#define CRTC_GEN_CNTL_CrtcEna   0x02000000

/*
 * Clock control
 */
#define CLOCK_CNTL_ClockStrobe  0x00000040

/*
 * Memory Control
 */
#define MEM_CNTL_MemSizeMsk     0x00000007
#define MEM_CNTL_MemSize512k    0x00000000
#define MEM_CNTL_MemSize1Mb     0x00000001
#define MEM_CNTL_MemSize2Mb     0x00000002
#define MEM_CNTL_MemSize4Mb     0x00000003
#define MEM_CNTL_MemSize6Mb     0x00000004
#define MEM_CNTL_MemSize8Mb     0x00000005
#define MEM_CNTL_MemBndryMsk    0x00070000
#define MEM_CNTL_MemBndryEn     0x00040000
#define MEM_CNTL_MemBndry0k     0x00000000
#define MEM_CNTL_MemBndry256k   0x00010000
#define MEM_CNTL_MemBndry512k   0x00020000
#define MEM_CNTL_MemBndry1Mb    0x00030000

/*
 * DAC control
 */
#define DAC_CNTL_ExtSelMask     0x00000003
#define DAC_CNTL_ExtSelStrip    ~DAC_CNTL_ExtSelMask
#define DAC_CNTL_ExtSelRS2      0x00000001
#define DAC_CNTL_ExtSelRS3      0x00000002
#define DAC_CNTL_VgaAddrEna     0x00002000

/*
 * General and Test control
 */
#define GEN_TEST_CNTL_CursorEna     0x00000080
#define GEN_TEST_CNTL_GuiEna        0x00000100
#define GEN_TEST_CNTL_BlkWrtEna     0x00000200
#define GEN_TEST_CNTL_GuiRegEna     0x00020000
#define GEN_TEST_CNTL_TestMode      0x00700000
#define GEN_TEST_CNTL_TestMode0     0x00000000
#define GEN_TEST_CNTL_TestMode1     0x00100000
#define GEN_TEST_CNTL_TestMode2     0x00200000
#define GEN_TEST_CNTL_TestMode3     0x00300000
#define GEN_TEST_CNTL_TestMode4     0x00400000
#define GEN_TEST_CNTL_MemWR         0x01000000
#define GEN_TEST_CNTL_MemStrobe     0x02000000
#define GEN_TEST_CNTL_DstSSEna      0x04000000
#define GEN_TEST_CNTL_DstSSStrobe   0x08000000
#define GEN_TEST_CNTL_SrcSSEna      0x10000000
#define GEN_TEST_CNTL_SrcSSStrobe   0x20000000

/*
 * Configuration Control
 */
#define CONFIG_CNTL_LinApDisab      0x00000000
#define CONFIG_CNTL_LinAp4M         0x00000001
#define CONFIG_CNTL_LinAp8M         0x00000002
#define CONFIG_CNTL_LinApMask       0x00000003
#define CONFIG_CNTL_VgaApDisab      0x00000000
#define CONFIG_CNTL_VgaApEnab       0x00000004
#define CONFIG_CNTL_LinApLocMask    0x00003FF0
#define CONFIG_CNTL_LinApLocShift       4
#define CONFIG_CNTL_CardIDMask      0x00070000
#define CONFIG_CNTL_VgaEnabled      0x00000000
#define CONFIG_CNTL_VgaDisabled     0x00080000

/*
 * Chip identification
 */
#define CONFIG_CHIP_ID_TypeMask     0x0000FFFF
#define CONFIG_CHIP_ID_ClassMask    0x00FF0000
#define CONFIG_CHIP_ID_RevMask      0xFF000000
#define CONFIG_CHIP_ID_TypeGX       0x000000D7
#define CONFIG_CHIP_ID_TypeCX       0x00000057
#define CONFIG_CHIP_ID_RevC         0x00000000
#define CONFIG_CHIP_ID_RevD         0x01000000
#define CONFIG_CHIP_ID_RevE         0x02000000
#define CONFIG_CHIP_ID_RevF         0x03000000
#define CONFIG_CHIP_ID_GXRevC       CONFIG_CHIP_ID_TypeGX | CONFIG_CHIP_ID_RevC
#define CONFIG_CHIP_ID_GXRevD       CONFIG_CHIP_ID_TypeGX | CONFIG_CHIP_ID_RevD
#define CONFIG_CHIP_ID_GXRevE       CONFIG_CHIP_ID_TypeGX | CONFIG_CHIP_ID_RevE
#define CONFIG_CHIP_ID_GXRevF       CONFIG_CHIP_ID_TypeGX | CONFIG_CHIP_ID_RevF


//
// ASIC IDs (upper byte of CONFIG_CHIP_ID)
//
#define ASIC_ID_NEC_VT_A3           0x08000000
#define ASIC_ID_NEC_VT_A4           0x48000000
#define ASIC_ID_SGS_VT_A4           0x40000000

/*
 * Configuration status register 0
 */
#define CONFIG_STAT0_BusMask        0x00000007
#define CONFIG_STAT0_MemTypeMask    0x00000038
#define CONFIG_STAT0_DRAM256x4      0x00000000
#define CONFIG_STAT0_VRAM256xAny    0x00000008
#define CONFIG_STAT0_VRAM256x16ssr  0x00000010
#define CONFIG_STAT0_DRAM256x16     0x00000018
#define CONFIG_STAT0_GDRAM256x16    0x00000020
#define CONFIG_STAT0_EVRAM256xAny   0x00000028
#define CONFIG_STAT0_EVRAM256x16ssr 0x00000030
#define CONFIG_STAT0_MemTypeShift       3
#define CONFIG_STAT0_DualCasEna     0x00000040
#define CONFIG_STAT0_LocalBusOpt    0x00000180
#define CONFIG_STAT0_DacTypeMask    0x00000E00
#define CONFIG_STAT0_DacTypeShift       9
#define CONFIG_STAT0_CardId         0x00007000
#define CONFIG_STAT0_NoTristate     0x00008000
#define CONFIG_STAT0_ExtRomAddr     0x003F0000
#define CONFIG_STAT0_RomDisab       0x00400000
#define CONFIG_STAT0_VgaEna         0x00800000
#define CONFIG_STAT0_VlbCfg         0x01000000
#define CONFIG_STAT0_ChipEna        0x02000000
#define CONFIG_STAT0_NoReadDelay    0x04000000
#define CONFIG_STAT0_RomOption      0x08000000
#define CONFIG_STAT0_BusOption      0x10000000
#define CONFIG_STAT0_LBDacWriteEna  0x20000000
#define CONFIG_STAT0_VlbRdyDisab    0x40000000
#define CONFIG_STAT0_Ap4GigRange    0x80000000

/*
 * Destination width
 */
#define DST_WIDTH_Disable       0x80000000

/*
 * Destination control
 */
#define DST_CNTL_XDir           0x00000001
#define DST_CNTL_YDir           0x00000002
#define DST_CNTL_YMajor         0x00000004
#define DST_CNTL_XTile          0x00000008
#define DST_CNTL_YTile          0x00000010
#define DST_CNTL_LastPel        0x00000020
#define DST_CNTL_PolyEna        0x00000040
#define DST_CNTL_24_RotEna      0x00000080
#define DST_CNTL_24_Rot         0x00000700

/*
 * Source offset and pitch
 */
#define SRC_OFF_PITCH_Offset    0x000FFFFF
#define SRC_OFF_PITCH_Pitch     0xFFC00000

/*
 * Source control
 */
#define SRC_CNTL_PatEna         0x0001
#define SRC_CNTL_PatRotEna      0x0002
#define SRC_CNTL_LinearEna      0x0004
#define SRC_CNTL_ByteAlign      0x0008
#define SRC_CNTL_LineXDir       0x0010

/*
 * Host control
 */
#define HOST_CNTL_ByteAlign     0x0001

/*
 * Pattern control
 */
#define PAT_CNTL_MonoEna        0x0001
#define PAT_CNTL_Clr4x2Ena      0x0002
#define PAT_CNTL_Clr8x1Ena      0x0004

/*
 * Datapath Source selections
 */
#define DP_SRC_BkgdClr          0x0000
#define DP_SRC_FrgdClr          0x0001
#define DP_SRC_Host             0x0002
#define DP_SRC_Blit             0x0003
#define DP_SRC_Pattern          0x0004
#define DP_SRC_Always1          0x00000000
#define DP_SRC_MonoPattern      0x00010000
#define DP_SRC_MonoHost         0x00020000
#define DP_SRC_MonoBlit         0x00030000

/*
 * Colour Comparison control
 */
#define CLR_CMP_CNTL_Source     0x00010000

/*
 * Context load and store pointers
 */
#define CONTEXT_LOAD_Cmd        0x00030000
#define CONTEXT_LOAD_CmdLoad    0x00010000
#define CONTEXT_LOAD_CmdBlt     0x00020000
#define CONTEXT_LOAD_CmdLine    0x00030000
#define CONTEXT_LOAD_Disable    0x80000000

//---------------------------------------------------------
//---------------------------------------------------------
//  Define the ASIC revisions into something Useful

#define MACH32_REV3             0
#define MACH32_REV5             1               // not in production
#define MACH32_REV6             2
#define MACH32_CX               4


//---------------------------------------------------------
//  Mix functions

#define MIX_FN_NOT_D         0x0000 //NOT dest
#define MIX_FN_ZERO          0x0001 //dest = 0
#define MIX_FN_ONE           0x0002 //dest = 1
#define MIX_FN_LEAVE_ALONE   0x0003 //dest
#define MIX_FN_NOT_S         0x0004 //NOT source
#define MIX_FN_XOR           0x0005 //source XOR dest
#define MIX_FN_XNOR          0x0006 //source XOR  NOT dest
#define MIX_FN_PAINT         0x0007 //source
#define MIX_FN_NAND          0x0008 //NOT source OR NOT dest
#define MIX_FN_D_OR_NOT_S    0x0009 //NOT source OR     dest
#define MIX_FN_NOT_D_OR_S    0x000A //source OR NOT dest
#define MIX_FN_OR            0x000B //source OR  dest
#define MIX_FN_AND           0x000C //dest AND source
#define MIX_FN_NOT_D_AND_S   0x000D //NOT dest AND source
#define MIX_FN_D_AND_NOT_S   0x000E //dest AND NOT source
#define MIX_FN_NOR           0x000F //NOT dest AND NOT source
#define MIX_FN_AVG           0x0017 // (dest+source)/2

//
//
//---------------------------------------------------------
//

/*
 * Values for DP_PIX_WIDTH register
 */
#define DP_PIX_WIDTH_Mono       0x00000000
#define DP_PIX_WIDTH_4bpp       0x00000001
#define DP_PIX_WIDTH_8bpp       0x00000002
#define DP_PIX_WIDTH_15bpp      0x00000003
#define DP_PIX_WIDTH_16bpp      0x00000004
#define DP_PIX_WIDTH_32bpp      0x00000006
#define DP_PIX_WIDTH_NibbleSwap 0x01000000

/*
 * Values for DP_SRC register
 */
#define DP_BKGD_SRC_BG      0x00000000  // Background Color Reg
#define DP_BKGD_SRC_FG      0x00000001  // Foreground Color Reg
#define DP_BKGD_SRC_HOST    0x00000002  // Host data
#define DP_BKGD_SRC_BLIT    0x00000003  // VRAM blit source
#define DP_BKGD_SRC_PATT    0x00000004  // Pattern registers
//
#define DP_FRGD_SRC_BG      0x00000000  // Background Color Register
#define DP_FRGD_SRC_FG      0x00000100  // Foreground Color Register
#define DP_FRGD_SRC_HOST    0x00000200  // Host data
#define DP_FRGD_SRC_BLIT    0x00000300  // VRAM blit source
#define DP_FRGD_SRC_PATT    0x00000400  // Pattern registers
//
#define DP_MONO_SRC_ONE     0x00000000  // Always '1'
#define DP_MONO_SRC_PATT    0x00010000  // Pattern registers
#define DP_MONO_SRC_HOST    0x00020000  // Host data
#define DP_MONO_SRC_BLIT    0x00030000  // Blit source

/*
 * Values for FIFO_STAT register
 */
#define ONE_WORD            0x00008000  /* One free FIFO entry */
#define TWO_WORDS           0x0000C000
#define THREE_WORDS         0x0000E000
#define FOUR_WORDS          0x0000F000
#define FIVE_WORDS          0x0000F800
#define SIX_WORDS           0x0000FC00
#define SEVEN_WORDS         0x0000FE00
#define EIGHT_WORDS         0x0000FF00
#define NINE_WORDS          0x0000FF80
#define TEN_WORDS           0x0000FFC0
#define ELEVEN_WORDS        0x0000FFE0
#define TWELVE_WORDS        0x0000FFF0
#define THIRTEEN_WORDS      0x0000FFF8
#define FOURTEEN_WORDS      0x0000FFFC
#define FIFTEEN_WORDS       0x0000FFFE
#define SIXTEEN_WORDS       0x0000FFFF  /* Sixteen free FIFO entries */
#define FIFO_ERR            0x80000000  /* FIFO overrun error */

/*
 * Fields in GUI_TRAJ_CNTL register
 */
#define GUI_TRAJ_CNTL_DxtXDir       0x00000001  // 1=left to right
#define GUI_TRAJ_CNTL_DstYDir       0x00000002  // 1=top to bottom
#define GUI_TRAJ_CNTL_DstYMajor     0x00000004  // 1=Y-major line
#define GUI_TRAJ_CNTL_DstXTile      0x00000008  // Enable tiling in X direction
#define GUI_TRAJ_CNTL_DstYTile      0x00000010  // Enable tiling in Y direction
#define GUI_TRAJ_CNTL_DstLastPel    0x00000020  // Draw last pixel
#define GUI_TRAJ_CNTL_DstPolygonEna 0x00000040  // Polygon outline/fill enable
#define GUI_TRAJ_CNTL_SrcPattEna    0x00010000  // Enable pattern source
#define GUI_TRAJ_CNTL_SrcPattRotEna 0x00020000  // Enable pattern source rotation
#define GUI_TRAJ_CNTL_SrcLinearEna  0x00040000  // Source advanced linearly in memory
#define GUI_TRAJ_CNTL_SrcByteAlign  0x00080000  // Source is byte aligned
#define GUI_TRAJ_CNTL_SrcLineXDir   0x00100000  // Source X direction during Bresenham linedraw
#define GUI_TRAJ_CNTL_PattMonoEna   0x01000000  // Monochrome 8x8 pattern enable
#define GUI_TRAJ_CNTL_PattClr4x2Ena 0x02000000  // Colour 4x2 pattern enable
#define GUI_TRAJ_CNTL_PattClr8x1Ena 0x04000000  // Colour 8x1 pattern enable
#define GUI_TRAJ_CNTL_HostByteAlign 0x10000000  // Host data is byte aligned

/*
 * Fields in GUI_STAT register
 */
#define GUI_STAT_GuiActive          0x00000001  /* Engine busy */


/*
 * Extended BIOS services. Word values are function selectors, doubleword
 * values are bit flags which may be ORed with each other for "write"
 * calls or extracted for "read" calls.
 */
#define BIOS_PREFIX_VGA_ENAB    0xA000  /* Accelerator BIOS prefix with VGA enabled */
#define BIOS_PREFIX_MAX_DISAB   0xAF00  /* Highest allowed BIOS prefix with VGA disabled */
#define BIOS_PREFIX_INCREMENT   0x0100  /* Step between BIOS prefixes */
#define BIOS_PREFIX_UNASSIGNED  0xFF00  /* Flag to show this card's BIOS prefix is not yet known */


#define BIOS_LOAD_CRTC_LB       0x00
#define BIOS_LOAD_CRTC      phwDeviceExtension->BiosPrefix | BIOS_LOAD_CRTC_LB

#define BIOS_DEPTH_MASK         0x00000007
#define BIOS_DEPTH_4BPP         0x00000001
#define BIOS_DEPTH_8BPP         0x00000002
#define BIOS_DEPTH_15BPP_555    0x00000003
#define BIOS_DEPTH_16BPP_565    0x00000004
#define BIOS_DEPTH_24BPP        0x00000005
#define BIOS_DEPTH_32BPP        0x00000006
#define BIOS_ORDER_32BPP_MASK   0x00000028
#define BIOS_DEPTH_ORDER_MASK   BIOS_DEPTH_MASK | BIOS_ORDER_32BPP_MASK
#define BIOS_ORDER_32BPP_RGBx   0x00000000
#define BIOS_ORDER_32BPP_xRGB   0x00000008
#define BIOS_ORDER_32BPP_BGRx   0x00000020
#define BIOS_ORDER_32BPP_xBGR   0x00000028
#define BIOS_DEPTH_32BPP_RGBx   BIOS_DEPTH_32BPP | BIOS_ORDER_32BPP_RGBx
#define BIOS_DEPTH_32BPP_xRGB   BIOS_DEPTH_32BPP | BIOS_ORDER_32BPP_xRGB
#define BIOS_DEPTH_32BPP_BGRx   BIOS_DEPTH_32BPP | BIOS_ORDER_32BPP_BGRx
#define BIOS_DEPTH_32BPP_xBGR   BIOS_DEPTH_32BPP | BIOS_ORDER_32BPP_xBGR
#define BIOS_ENABLE_GAMMA       0x00000010  /* Enable gamma correction */
#define BIOS_PITCH_MASK         0x000000C0
#define BIOS_PITCH_1024         0x00000000  /* Screen pitch 1024 pixels */
#define BIOS_PITCH_UNCHANGED    0x00000040  /* Don't change screen pitch */
#define BIOS_PITCH_HOR_RES      0x00000080  /* Screen pitch is horizontal resolution */
#define BIOS_RES_MASK           0x0000FF00
#define BIOS_RES_640x480        0x00001200
#define BIOS_RES_800x600        0x00006A00
#define BIOS_RES_1024x768       0x00005500
#define BIOS_RES_EEPROM         0x00008000  /* Load table from EEPROM */
#define BIOS_RES_BUFFER         0x00008100  /* Load table from buffer in first 1M */
#define BIOS_RES_HIGH_BUFFER    0x00009100  /* Load table from unrestricted buffer */
#define BIOS_RES_OEM            0x00008200  /* OEM-specific mode */
#define BIOS_RES_1280x1024      0x00008300
#define BIOS_RES_1600x1200      0x00008400

#define BIOS_SET_MODE_LB        0x01
#define BIOS_SET_MODE       phwDeviceExtension->BiosPrefix | BIOS_SET_MODE_LB

#define BIOS_MODE_VGA           0x00000000
#define BIOS_MODE_COPROCESSOR   0x00000001

#define BIOS_LOAD_SET_LB        0x02
#define BIOS_LOAD_SET       phwDeviceExtension->BiosPrefix | BIOS_LOAD_SET_LB
#define BIOS_READ_EEPROM_LB     0x03
#define BIOS_READ_EEPROM    phwDeviceExtension->BiosPrefix | BIOS_READ_EEPROM_LB
#define BIOS_WRITE_EEPROM_LB    0x04
#define BIOS_WRITE_EEPROM   phwDeviceExtension->BiosPrefix | BIOS_WRITE_EEPROM_LB
#define BIOS_APERTURE_LB        0x05
#define BIOS_APERTURE       phwDeviceExtension->BiosPrefix | BIOS_APERTURE_LB

#define BIOS_DISABLE_APERTURE   0x00000000
#define BIOS_LINEAR_APERTURE    0x00000001
#define BIOS_VGA_APERTURE       0x00000004

#define BIOS_SHORT_QUERY_LB     0x06
#define BIOS_SHORT_QUERY    phwDeviceExtension->BiosPrefix | BIOS_SHORT_QUERY_LB

#define BIOS_AP_DISABLED        0x00000000
#define BIOS_AP_4M              0x00000001
#define BIOS_AP_8M              0x00000002
#define BIOS_AP_16M             0x00000003
#define BIOS_AP_SIZEMASK        0x00000003
#define BIOS_AP_SETTABLE        0x00000000  /* User can set aperture */
#define BIOS_AP_FIXED           0x00000040  /* Aperture location is fixed */
#define BIOS_AP_RNG_128M        0x00000000  /* Aperture must be below 128M */
#define BIOS_AP_RNG_4G          0x00000080  /* Aperture can be anywhere */

#define BIOS_CAP_LIST_LB        0x07
#define BIOS_CAP_LIST       phwDeviceExtension->BiosPrefix | BIOS_CAP_LIST_LB
#define BIOS_GET_QUERY_SIZE_LB  0x08
#define BIOS_GET_QUERY_SIZE phwDeviceExtension->BiosPrefix | BIOS_GET_QUERY_SIZE_LB
#define BIOS_QUERY_LB           0x09
#define BIOS_QUERY          phwDeviceExtension->BiosPrefix | BIOS_QUERY_LB

/*
 * The following values are used for both BIOS_GET_QUERY_SIZE
 * and BIOS_QUERY
 */
#define BIOS_QUERY_HEADER       0x00000000  /* Get header information only */
#define BIOS_QUERY_FULL         0x00000001  /* Also get mode tables */

#define BIOS_GET_CLOCK_LB       0x0A
#define BIOS_GET_CLOCK      phwDeviceExtension->BiosPrefix | BIOS_GET_CLOCK_LB
#define BIOS_SET_CLOCK_LB       0x0B
#define BIOS_SET_CLOCK      phwDeviceExtension->BiosPrefix | BIOS_SET_CLOCK_LB
#define BIOS_SET_DPMS_LB        0x0C
#define BIOS_SET_DPMS       phwDeviceExtension->BiosPrefix | BIOS_SET_DPMS_LB
#define BIOS_GET_DPMS_LB        0x0D
#define BIOS_GET_DPMS       phwDeviceExtension->BiosPrefix | BIOS_GET_DPMS_LB

#define BIOS_DPMS_ACTIVE        0x00000000
#define BIOS_DPMS_STANDBY       0x00000001
#define BIOS_DPMS_SUSPEND       0x00000002
#define BIOS_DPMS_OFF           0x00000003
#define BIOS_DPMS_BLANK_SCREEN  0x00000004

/*
 * Set and return Graphics Controller's power management state.
 */
#define BIOS_SET_PM_LB      0x0E
#define BIOS_SET_PM         phwDeviceExtension->BiosPrefix | BIOS_SET_PM_LB
#define BIOS_GET_PM_LB      0x0F
#define BIOS_GET_PM         phwDeviceExtension->BiosPrefix | BIOS_GET_PM_LB
#define BIOS_RAMDAC_STATE_LB        0x10
#define BIOS_RAMDAC_STATE   phwDeviceExtension->BiosPrefix | BIOS_RAMDAC_STATE_LB

#define BIOS_RAMDAC_NORMAL      0x00000000
#define BIOS_RAMDAC_SLEEP       0x00000001

#define BIOS_STORAGE_INFO_LB        0x11   /* Get external storage device info */
#define BIOS_STORAGE_INFO   phwDeviceExtension->BiosPrefix | BIOS_STORAGE_INFO_LB

#define BIOS_DEVICE_TYPE        0x0000000F
#define BIOS_READ_WRITE         0x00000000
#define BIOS_RDONLY             0x00000010
#define BIOS_NO_READ_WRITE      0x00000030
#define BIOS_READ_WRITE_APP     0x00000040
#define BIOS_NO_EXT_STORAGE     0x00000080
#define BIOS_NUM_16BIT_ENTRIES  0x0000FF00
#define BIOS_CRTC_TABLE_OFFSET  0x000000FF
#define BIOS_CRTC_TABLE_SIZE    0x0000FF00

#define BIOS_QUERY_IOBASE_LB        0x12   /* Get I/O base address */
#define BIOS_QUERY_IOBASE   phwDeviceExtension->BiosPrefix | BIOS_QUERY_IOBASE_LB
#define BIOS_DDC_SUPPORT_LB     0x13   /* Get Display Data Channel support information */
#define BIOS_DDC_SUPPORT    phwDeviceExtension->BiosPrefix | BIOS_DDC_SUPPORT_LB


#define REG_BLOCK_0             0x00000100
#define GP_IO                   (REG_BLOCK_0 | 0x1E)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\atint.h ===
/*************************************************************************
 **                                                                     **
 **                             ATINT.H                                 **
 **                                                                     **
 **     Copyright (c) 1992, ATI Technologies Inc.                       **
 *************************************************************************
    
  Contains information specific to Windows NT, and is common between
  the Install application ANTPANEL, and the Display and Miniport drivers.
 
  $Revision:   1.18  $
  $Date:   25 Apr 1996 14:21:40  $
  $Author:   RWolff  $
  $Log:   S:/source/wnt/ms11/miniport/archive/atint.h_v  $
 * 
 *    Rev 1.18   25 Apr 1996 14:21:40   RWolff
 * Forces build for NT 4.0, since all code drops to Microsoft will be
 * built under NT 4.0.
 * 
 *    Rev 1.17   23 Apr 1996 17:25:50   RWolff
 * Split reporting of "internal DAC cursor needs double buffering" from
 * "this is a CT", added flag to report 1M SDRAM cards.
 * 
 *    Rev 1.16   23 Jan 1996 11:41:36   RWolff
 * Now forces compile-time error if NTDDVDEO.H is not included before
 * this file rather than generating false values of TARGET_BUILD, added
 * DrvEscape() functions used by multiheaded display applet.
 * 
 *    Rev 1.15   22 Dec 1995 14:59:32   RWolff
 * Added support for Mach 64 GT internal DAC.
 * 
 *    Rev 1.14   21 Dec 1995 14:05:36   RWolff
 * Added TARGET_BUILD definition to identify which version of NT we are
 * building for, rather than using a different definition for each break
 * between versions.
 * 
 *    Rev 1.13   23 Nov 1995 11:25:10   RWolff
 * Added multihead support.
 * 
 *    Rev 1.12   24 Aug 1995 15:38:04   RWolff
 * Added definitions to report CT and VT ASICs to the display driver.
 * 
 *    Rev 1.11   27 Feb 1995 17:46:44   RWOLFF
 * Added flag for packed (relocatable) I/O to ENH_VERSION_NT.FeatureFlags
 * bitmask.
 * 
 *    Rev 1.10   24 Feb 1995 12:23:08   RWOLFF
 * Added flag for 24BPP text banding to ModeFlags field of mode
 * information structure.
 * 
 *    Rev 1.9   03 Feb 1995 15:14:16   RWOLFF
 * Added Feature Flag to show that dense space is available.
 * 
 *    Rev 1.8   30 Jan 1995 11:54:36   RWOLFF
 * Made detection of Daytona vs. older versions of NT automatic, miniport
 * and display driver now use the same version of this file.
 * 
 *    Rev 1.7   23 Dec 1994 10:48:34   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.6   31 Aug 1994 16:18:38   RWOLFF
 * Added definiton to go in ENH_VERSION_NT.FeatureFlags to show that
 * TVP3026 cursor handling is needed.
 * 
 *    Rev 1.5   04 May 1994 19:24:04   RWOLFF
 * Moved block write flag back to IOCTL_VIDEO_ATI_GET_MODE_INFORMATION
 * because the test can only be run if we have already switched
 * into graphics mode.
 * 
 *    Rev 1.4   28 Apr 1994 10:58:52   RWOLFF
 * Moved mode-independent bug/feature flags to IOCTL_VIDEO_ATI_GET_VERSION
 * packet from IOCTL_VIDEO_ATI_GET_MODE_INFORMATION packet.
 * 
 *    Rev 1.3   27 Apr 1994 13:52:58   RWOLFF
 * Added definition for MIO bug in ModeFlags bitfield.
 * 
 *    Rev 1.2   31 Mar 1994 15:00:52   RWOLFF
 * Added key to be used in DrvEscape() and values to be returned.
 * 
 *    Rev 1.1   14 Mar 1994 16:29:08   RWOLFF
 * Added bit definition in ModeFlags for 2M boundary tearing, DPMS IOCTL
 * is now consistent with Daytona.
 * 
 *    Rev 1.0   31 Jan 1994 11:29:10   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.3   24 Jan 1994 18:01:42   RWOLFF
 * Added definitions for new Mach 32 ASIC (68800LX), changed some Mach 64
 * definitions to accomodate changes in 94/01/19 BIOS document.
 * 
 *    Rev 1.2   14 Jan 1994 15:19:32   RWOLFF
 * Added definition for unknown non-Mach32 ASIC, flags to show if block
 * write and memory mapped registers are available, added fields for
 * bus type in ENH_VERSION_NT structure, preliminary structure and
 * definitions for DPMS packet.
 * 
 *    Rev 1.1   30 Nov 1993 18:12:12   RWOLFF
 * Renamed definitions for Mach 64 chip.
 * 
 *    Rev 1.0   03 Sep 1993 14:27:20   RWOLFF
 * Initial revision.
        
           Rev 1.5   22 Jan 1993 14:49:34   Chris_Brady
        add card capabilities to GET_INFO Ioctl.
        
           Rev 1.4   22 Jan 1993 14:46:40   Chris_Brady
        add ATIC_ defines for the card capabilities.
        
           Rev 1.3   20 Jan 1993 17:47:16   Robert_Wolff
        Added PVERSION_NT type definition, removed obsolete comment.
        
           Rev 1.2   19 Jan 1993 09:50:58   Chris_Brady
        add ANT_ drawing interface defines.
        
           Rev 1.1   18 Jan 1993 15:49:34   Chris_Brady
        new GetInof structure.
        
           Rev 1.0   15 Jan 1993 16:43:08   Chris_Brady
        Initial revision.
  

------------------------------------------------------------------------*/

//  is in the \ddk\public\sdk\inc  directory 
#include <devioctl.h>

// allow the miniport driver to Force seletion of a Programming Interface
enum    {
    ANT_DEFAULT=0,
    ANT_ENGINE_ONLY,
    ANT_APERTURE,
    ANT_VGA
    };

// Private Display driver Functions. Communication from ANTPANEL to
// the Display  ATI*.DLL to the Miniport ATI*.SYS  drivers.
enum   {                
    ATI_GET_INFO=1,
    ATI_GET_nextone
    };

// Define the possible ATI graphics card configurations so the Display
// driver can decide the best drawing methods to use.
// size is ULONG 32  bit field
// assigned by miniport to   VERSION_NT.capcard
#define ATIC_FIELD_LONGEST  0x80000000  //just to illustrate size

#define ATIC_APERTURE_LFB   0x0400
#define ATIC_APERTURE_VGA   0x0200      
#define ATIC_APERTURE_NONE  0x0100      //neither VGA or LFB found

#define ATIC_CARD_TYPE      0x00F0      //defines from 68801.h << 4
#define ATIC_BUS_TYPE       0x000F      //defines from 68801.H



// used with     IOCTL_VIDEO_ATI_GET_VERSION
// In hex:   BBBBVVMM where 
//    BBBB is the build number         (0-32767),
//    VV   is the major version number (0-255)
//    MM   is the minor version number (0-255)
typedef  struct  {
    ULONG       display;                //Display Version number
    ULONG       miniport;               //Miniport Version number
    ULONG       capcard;                //card capabilities
    struct   {
        short   xres;
        short   yres;
        short   color;                  // maximum bits per pixel
        }   resolution[6];
    } VERSION_NT, *PVERSION_NT;

/*
 * Definitions used with the ENH_VERSION_NT structure
 */
#define ENH_REVISION 1  // First revision of ENH_VERSION_NT structure

#define BETA_MINIPORT 0x00000080    // Bit set in InterfaceVersion for unsupported miniport versions

enum {
    CI_38800_1 = 0,         // Mach 8 ASIC, only one revision in use
    CI_68800_3,             // Mach 32 ASIC, first production revision
    CI_68800_6,             // Mach 32 ASIC, second production revision
    CI_68800_AX,            // Mach 32 AX ASIC
    CI_88800_GX,            // Mach 64 GX ASIC
    CI_68800_LX,            // Mach 32 LX ASIC
    CI_OTHER_UNKNOWN=30,    // Unknown ASIC other than Mach 32
    CI_68800_UNKNOWN=31     // Mach 32 ASIC other than versions above
    };

#define FL_CI_38800_1       0x00000001
#define FL_CI_68800_3       0x00000002
#define FL_CI_68800_6       0x00000004
#define FL_CI_68800_AX      0x00000008
#define FL_CI_88800_GX      0x00000010
#define FL_CI_68800_LX      0x00000020
#define FL_CI_OTHER_UNKNOWN 0x40000000
#define FL_CI_68800_UNKNOWN 0x80000000

enum {
    ENGINE_ONLY = 0,    // No aperture available
    AP_LFB,             // Linear framebuffer available
    AP_68800_VGA,       // 64k VGA aperture available
    AP_CX_VGA           // Two 32k VGA apertures available
    };

#define FL_ENGINE_ONLY  0x00000001
#define FL_AP_LFB       0x00000002
#define FL_68800_VGA    0x00000004
#define FL_CX_VGA       0x00000008

#define FL_MM_REGS      0x80000000  /* Memory Mapped registers are available */

/*
 * Values which can be placed in FeatureFlags field of ENH_VERSION_NT.
 *
 * Flags should be added to this field if they represent bugs/features
 * which affect all resolution/pixel depth combinations on a given card.
 */
#define EVN_DPMS            0x00000001  // DPMS is supported
#define EVN_SPLIT_TRANS     0x00000002  // This card has split transfer bug
#define EVN_MIO_BUG         0x00000004  // Card has multiple in/out hardware bug
#define EVN_TVP_DAC_CUR     0x00000008  // Cursor handled by TVP DAC, not the ASIC
#define EVN_IBM514_DAC_CUR  0x00000010  // Cursor handled by IBM DAC, not the ASIC
#define EVN_DENSE_CAPABLE   0x00000020  // Card is capable of using dense space
#define EVN_PACKED_IO       0x00000040  // Card uses packed I/O space
#define EVN_INT_DAC_CUR     0x00000080  /* Cards with internal DAC must use double buffer to avoid flickering cursor */
#define EVN_VT_ASIC         0x00000100  /* VT has extended capabilities our other cards don't */
#define EVN_GT_ASIC         0x00000200  /* GT has extended capabilities our other cards don't */
#define EVN_CT_ASIC         0x00000400  /* Identify CT ASIC */
/*
 * Cards with 1M of SDRAM need special handling (problem occurs on the
 * VTA4, may or may not happen with this configuration on future ASICs).
 */
#define EVN_SDRAM_1M        0x00000800


/*
 * Enhanced information structure for use with IOCTL_VIDEO_ATI_GET_VERSION.
 * This structure will be used if a non-null input buffer is passed when
 * making the call, and the older structure above will be used if a null
 * input buffer is passed.
 */
typedef struct{
    ULONG StructureVersion;     /* Revision of structure being passed in */
    ULONG InterfaceVersion;     /* Revision of private interface being used */
    ULONG ChipIndex;            /* Which accelerator chip is present */
    ULONG ChipFlag;             /* Flag corresponding to chip being used */
    ULONG ApertureType;         /* Best aperture type available */
    ULONG ApertureFlag;         /* Flag corresponding to aperture type */
    ULONG BusType;              /* Type of bus being used */
    ULONG BusFlag;              /* Flag corresponding to bus type */
    ULONG FeatureFlags;         /* Flags for features/bugs of this card */
    ULONG NumCards;             /* Number of ATI cards in the system */
    } ENH_VERSION_NT, *PENH_VERSION_NT;

/*
 * Values which can be placed in ModeFlags field of ATI_MODE_INFO.
 *
 * Flags should be added to this field if they represent bugs/features
 * which affect some but not all resolution/pixel depth combinations
 * on a given card.
 */
#define AMI_ODD_EVEN    0x00000001  // Hardware cursor odd/even bug, undefined
                                    // for cards without hardware cursor
#define AMI_MIN_MODE    0x00000002  // 8514/A compatible minimum mode
#define AMI_2M_BNDRY    0x00000004  // Tearing occurs on 2M boundary
#define AMI_BLOCK_WRITE 0x00000008  // Block write is supported. This is
                                    // mode-independent, but must be tested
                                    // after we have switched into graphics mode.
#define AMI_TEXTBAND    0x00000010  // Text banding in 24BPP mode

/*
 * Mode information structure for use with IOCTL_VIDEO_ATI_GET_MODE_INFORMATION.
 * This structure provides information specific to the video mode in use.
 */
typedef struct{
    ULONG ModeFlags;        /* Flags for features/bugs of this mode */

    LONG VisWidthPix;       /* Visible screen width in pixels */
    LONG VisWidthByte;      /* Visible screen width in bytes */
    LONG VisHeight;         /* Visible screen height */
    LONG BitsPerPixel;
    /*
     * The next 2 fields hold the number of bytes of memory used per pixel
     * (integer and fractional parts). A 4BPP unpacked (1 pixel per byte,
     * ignore unused 4 bits) mode would yield 1 and 0, the same as for 8BPP
     * (1.0 bytes per pixel). A 4BPP packed (2 pixels per byte) mode would
     * yield 0 and 500 (0.500 bytes per pixel). The fractional field will
     * always hold a 3-digit number, since bytes per pixel will always be
     * a multiple of 0.125 (one bit is one-eighth of a byte).
     */
    LONG IntBytesPerPixel;
    LONG FracBytesPerPixel;
    LONG PitchPix;          /* Screen pitch in pixels */
    LONG PitchByte;         /* Screen pitch in bytes */

    /*
     * The following fields refer to the offscreen block to the right of
     * the visible screen. This block is only present when the screen pitch
     * differs from the visible screen width. Its height is always the
     * same as the visible screen height, and its vertical start offset
     * is assumed to be zero.
     *
     * NOTE: If RightWidthPix is zero, this block does not exist for the
     *       current mode, and the other fields in this group are undefined.
     */
    LONG RightWidthPix;     /* Width of block in pixels */
    LONG RightWidthByte;    /* Width of block in bytes */
    LONG RightStartOffPix;  /* Horizontal start offset of block in pixels */
    LONG RightStartOffByte; /* Horizontal start offset of block in bytes */
    LONG RightEndOffPix;    /* Horizontal end offset of block in pixels */
    LONG RightEndOffByte;   /* Horizontal end offset of block in bytes */

    /*
     * The following fields refer to the offscreen block below the visible
     * screen. Values listed as "Hard" refer to the maximum vertical offset
     * for which enough video memory exists to support a full line of pixels.
     * Values listed as "Soft" refer to the maximum vertical offset which
     * can be reached without writing to the GE_OFFSET register.
     *
     * The horizontal start offset is assumed to be zero.
     */
    LONG BottomWidthPix;    /* Width of block in pixels */
    LONG BottomWidthByte;   /* Width of block in bytes */
    LONG BottomStartOff;    /* Vertical start offset of block */
    LONG BottomEndOffSoft;  /* "Soft" vertical end offset of block */
    LONG BottomEndOffHard;  /* "Hard" vertical end offset of block */
    LONG BottomHeightSoft;  /* "Soft" height of block */
    LONG BottomHeightHard;  /* "Hard" height of block */

    } ATI_MODE_INFO, *PATI_MODE_INFO;

//------------------------------------------------------------------------

/*
 * IOCTL codes to allow communication between the miniport driver
 * and higher-level modules. The Windows NT specification allocates
 * function codes 2048-4095 to external vendors.
 */
#define IOCTL_VIDEO_MIN_EXTERNAL_VENDOR \
    CTL_CODE(FILE_DEVICE_VIDEO, 2048, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAX_EXTERNAL_VENDOR \
    CTL_CODE(FILE_DEVICE_VIDEO, 4095, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ATI_GET_VERSION \
    CTL_CODE(FILE_DEVICE_VIDEO, 2048, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ATI_EM_SYNC_TO_MINIPORT \
    CTL_CODE(FILE_DEVICE_VIDEO, 2049, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ATI_EM_SYNC_FROM_MINIPORT \
    CTL_CODE(FILE_DEVICE_VIDEO, 2050, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ATI_GET_MODE_INFORMATION \
    CTL_CODE(FILE_DEVICE_VIDEO, 2051, METHOD_BUFFERED, FILE_ANY_ACCESS)


/*
 * The following definitions and IOCTLs are standard definitions from
 * the NTDDVDEO.H file in Daytona and later releases of Windows NT.
 * They are provided here to let earlier versions use the DPMS IOCTLs
 * without requiring source changes. Do not edit this section.
 *
 * Structures are made conditional on the absence of one of the
 * power management IOCTLs, rather than on the structure itself,
 * since "#if !defined(<symbol>)" doesn't trigger on symbols that
 * refer to structures, rather than numeric values.
 */

//
// IOCTL_VIDEO_SET_POWER_MANAGEMENT - Tells the device to change the power
//                                    consumption level of the device to the
//                                    new state.
// IOCTL_VIDEO_GET_POWER_MANAGEMENT - Return the current power consumption
//                                    level of the device.
//
// NOTE:
// This IOCTL is based on the VESA DPMS proposal.
// Changes to the DPMS standard will be refelcted in this IOCTL.
//

#if !defined(IOCTL_VIDEO_SET_POWER_MANAGEMENT)
typedef enum _VIDEO_POWER_STATE {
    VideoPowerOn = 1,
    VideoPowerStandBy,
    VideoPowerSuspend,
    VideoPowerOff
} VIDEO_POWER_STATE, *PVIDEO_POWER_STATE;
#endif

#if !defined(IOCTL_VIDEO_SET_POWER_MANAGEMENT)
typedef struct _VIDEO_POWER_MANAGEMENT {
    ULONG Length;
    ULONG DPMSVersion;
    ULONG PowerState;
} VIDEO_POWER_MANAGEMENT, *PVIDEO_POWER_MANAGEMENT;
#endif

//
//Length - Length of the structure in bytes. Also used to do verisioning.
//
//DPMSVersion - Version of the DPMS standard supported by the device.
//              Only used in the "GET" IOCTL.
//
//PowerState - One of the power states listed in VIDEO_POWER_STATE.
//

//
// Note:
// Once the power has been turned off to the device, all other IOCTLs made
// to the miniport will be intercepted by the port driver and will return
// failiure, until the power on the device has been turned back on.
//

/*
 * We use the presence or absence of various IOCTLs to determine
 * the build of Windows NT for which we are compiling the driver.
 * If this file is included, but the file which contains the IOCTLs
 * is not, in a source file, this will result in a false report of
 * the target build, which can cause numerous problems.
 *
 * This conditional block will force a compile error if the file
 * containing the IOCTLs (NTDDVDEO.H in NT 3.51 retail) was not
 * included prior to this file being included.
 */
#if !defined(IOCTL_VIDEO_SET_CURRENT_MODE)
    NTDDVDEO.H must be included before ATINT.H
#endif

/*
 * End of DPMS support for pre-Daytona versions of Windows NT.
 */

#define IOCTL_VIDEO_ATI_INIT_AUX_CARD \
    CTL_CODE(FILE_DEVICE_VIDEO, 2054, METHOD_BUFFERED, FILE_ANY_ACCESS)

/*
 * Structures used in DCI support. They were added some time after the
 * initial release of Windows NT 3.5, so we must make them available only
 * if they're not already defined. These "placeholders" are solely to
 * allow the miniport to be compiled - the packets will only be called
 * in later versions of Windows NT 3.5.
 *
 * There are no "placeholders" for the IOCTLs themselves, since their
 * presence or absence is used to determine whether or not to compile
 * the DCI cases in ATIMPStartIO().
 */
//
// _WIN32_WINNT is available starting from NT 4.0.
//
#if (_WIN32_WINNT >= 0x500)
    #define TARGET_BUILD        500
#else
    #if (_WIN32_WINNT >= 0x400)
        #define TARGET_BUILD    400
    #else
        #define TARGET_BUILD    351
    #endif
#endif

/*
 * Keys to be used in DrvEscape() call to handle DPMS and other private
 * ATI functions. These keys fit into a large "hole" between
 * GETSETSCREENPARAMS (3072) and BEGIN_PATH (4096)
 */
#define ESC_SET_POWER_MANAGEMENT    4000
#define ESC_GET_NUM_CARDS           4001
#define ESC_GET_MODES               4002
#define ESC_GET_VGA_ENABLED         4003
#define ESC_SET_CURRENT_FULLSCREEN  4004

/*
 * Values to show whether or not a given function is supported by
 * the DrvEscape entry point.
 */
#define ESC_IS_SUPPORTED    0x00000001  /* Function is supported */
#define ESC_NOT_SUPPORTED   0xFFFFFFFF  /* Unsupported function called */
#define ESC_NOT_IMPLEMENTED 0x00000000  /* QUERYESCSUPPORT called for unimplemented function */



//*********************   end of ATINT.H   ****************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\atimp.h ===
/************************************************************************/
/*                                                                      */
/*                              ATIMP.H                                 */
/*                                                                      */
/*    November  2  1992	    (c) 1992, ATI Technologies Incorporated.	*/
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.22  $
      $Date:   01 Mar 1996 12:10:48  $
   $Author:   RWolff  $
      $Log:   S:/source/wnt/ms11/miniport/archive/atimp.h_v  $
 * 
 *    Rev 1.22   01 Mar 1996 12:10:48   RWolff
 * Allocated more space for mapped registers, since VGA Graphics Index
 * and Graphics Data are now handled as separate registers rather than
 * as offsets into the block of VGA registers.
 * 
 *    Rev 1.21   02 Feb 1996 17:14:52   RWolff
 * Moved DDC/VDIF merge source information into hardware device extension
 * so each card can be considered independently in a multihead setup.
 * 
 *    Rev 1.20   29 Jan 1996 16:53:58   RWolff
 * Now uses VideoPortInt10() rather than no-BIOS code on PPC, removed
 * dead code.
 * 
 *    Rev 1.19   22 Dec 1995 14:52:32   RWolff
 * Added support for Mach 64 GT internal DAC.
 * 
 *    Rev 1.18   19 Dec 1995 14:00:26   RWolff
 * Increased size of buffer used to store query structure and mode tables
 * to allow for increase in the number of "canned" tables due to support
 * for higher refresh rates.
 * 
 *    Rev 1.17   28 Nov 1995 18:07:58   RWolff
 * Added "Card Initialized" field to hardware device extension. This
 * is part of multiheaded support, to prevent multiple initializations
 * of a single card.
 * 
 *    Rev 1.16   27 Oct 1995 14:21:26   RWolff
 * Removed mapped LFB from hardware device extension.
 * 
 *    Rev 1.15   08 Sep 1995 16:36:12   RWolff
 * Added support for AT&T 408 DAC (STG1703 equivalent).
 * 
 *    Rev 1.14   24 Aug 1995 15:38:38   RWolff
 * Changed detection of block I/O cards to match Microsoft's
 * standard for plug-and-play.
 * 
 *    Rev 1.13   28 Jul 1995 14:39:50   RWolff
 * Added support for the Mach 64 VT (CT equivalent with video overlay).
 * 
 *    Rev 1.12   31 Mar 1995 11:57:44   RWOLFF
 * Changed debug thresholds to avoid being swamped by level 3 statements
 * in VIDEOPRT.SYS, removed DEBUG_SWITCH since it's no longer used.
 * 
 *    Rev 1.11   30 Mar 1995 12:01:54   RWOLFF
 * Added definitions for debug level thresholds.
 * 
 *    Rev 1.10   07 Feb 1995 18:19:54   RWOLFF
 * Updated colour depth table for STG1702/1703. Entries for DACs
 * that are supposedly equivalent to these are unchanged, since
 * I did not have cards with these DACs and more than 2M of
 * video memory to test with.
 * 
 *    Rev 1.9   30 Jan 1995 11:56:42   RWOLFF
 * Added support for CT internal DAC.
 * 
 *    Rev 1.8   18 Jan 1995 15:39:32   RWOLFF
 * Added support for Chrontel DAC.
 * 
 *    Rev 1.7   23 Dec 1994 10:48:32   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.6   18 Nov 1994 11:53:28   RWOLFF
 * Added support for split rasters, Power PC, and new DAC type DAC_STG1703.
 * 
 *    Rev 1.5   06 Sep 1994 10:46:52   ASHANMUG
 * Disable 1600x1200 on all cards except with TVM DAC
 * 
 *    Rev 1.4   31 Aug 1994 16:16:10   RWOLFF
 * Added support for TVP3026 DAC and 1152x864, doubled QUERYSIZE to
 * allow additional mode tables (needed because we now support 1152x864
 * and 1600x1200, we have more refresh rates at 1280x1024, and TVP DAC
 * supports high-res high depth modes AND 4BPP).
 * 
 *    Rev 1.3   19 Aug 1994 17:06:22   RWOLFF
 * Added support for the SC15026 DAC.
 * 
 *    Rev 1.2   12 May 1994 11:09:00   RWOLFF
 * Expanded CardInfo field of hardware device extension structure to allow
 * more mode tables (needed when setting up "canned" refresh rates"), added
 * defined value for hardware default refresh rate.
 * 
 *    Rev 1.1   03 Mar 1994 12:37:10   ASHANMUG
 * Make pageable
 * 
 *    Rev 1.0   31 Jan 1994 11:40:12   RWOLFF
 * Initial revision.
        
           Rev 1.8   14 Jan 1994 15:19:14   RWOLFF
        Added support for 1600x1200 mode.
        
           Rev 1.7   15 Dec 1993 15:25:04   RWOLFF
        Added support for SC15021 DAC.
        
           Rev 1.6   30 Nov 1993 18:11:38   RWOLFF
        Changed maximum pixel depth for STG1700 DAC at 640x480 and 800x600 to 32BPP
        
           Rev 1.5   05 Nov 1993 13:22:46   RWOLFF
        Added new DAC types.
        
           Rev 1.4   08 Oct 1993 15:16:54   RWOLFF
        Updated build and version numbers.
        
           Rev 1.3   08 Oct 1993 11:01:46   RWOLFF
        Removed code specific to a particular family of ATI accelerators, added
        definition for a delay which is only used on DEC Alpha machines.
        
           Rev 1.2   24 Sep 1993 11:47:44   RWOLFF
        Added definition for DEBUG_SWITCH, which will allow VideoDebugPrint() calls
        to be turned on and off all at once.
        
           Rev 1.1   03 Sep 1993 14:27:00   RWOLFF
        Partway through CX isolation.
        
           Rev 1.0   16 Aug 1993 13:30:56   Robert_Wolff
        Initial revision.
        
           Rev 1.15   06 Jul 1993 15:48:32   RWOLFF
        Added MaxDepth[] entries for AT&T 491 and ATI 68860 DACs.
        
           Rev 1.14   10 Jun 1993 15:57:02   RWOLFF
        Added definition for size of buffer used in registry reads,
        moved definition of checked-version-only breakpoint INT
        here to avoid duplicating it in all C files.
        
           Rev 1.13   07 Jun 1993 12:59:00   BRADES
        add EXT_CUR_Y, and EXT_SRC_Y mach8 register defines.
        
           Rev 1.12   18 May 1993 14:07:38   RWOLFF
        Added definition TTY_ATTR_NORMAL (white on blue attribute), which is needed
        in aperture tests and was supplied by now-obsolete TTY.H.
        
           Rev 1.11   10 May 1993 16:41:18   RWOLFF
        Added table listing maximum pixel depth for each supported DAC/resolution
        combination.
        
           Rev 1.10   30 Apr 1993 17:08:24   RWOLFF
        RegistryBuffer is now dynamically allocated.
        
           Rev 1.9   30 Apr 1993 15:52:42   BRADES
        fix DISP_STATUS from 5 to 2e8.
        
           Rev 1.7   14 Apr 1993 17:41:30   RWOLFF
        Removed redundant definitions to eliminate warnings.
        
           Rev 1.6   08 Apr 1993 16:45:42   RWOLFF
        Revision level as checked in at Microsoft.

           Rev 1.5   30 Mar 1993 17:09:38   RWOLFF
        Made RegistryParameterCallback() avialable to all miniport source files,
        increased buffer capacity for registry reads.
        
           Rev 1.4   25 Mar 1993 11:17:16   RWOLFF
        No longer grabs registers we don't use.
        
           Rev 1.3   08 Mar 1993 19:30:52   BRADES
        submit to MS NT
        
           Rev 1.2   10 Feb 1993 13:00:48   Robert_Wolff
        Added VideoRamLength field to HW_DEVICE_EXTENSION, FrameLength is now
        the aperture size rather than the amount of video memory.
        
           Rev 1.1   05 Feb 1993 16:55:06   Robert_Wolff
        Now initializes "shareable" field of VIDEO_ACCESS_RANGE structures
        to allow VGA driver to run concurrently with ours. This allows switching
        to/from full-screen DOS sessions.
        
           Rev 1.0   05 Feb 1993 16:17:42   Robert_Wolff
        Initial revision.
        
           Rev 1.0   02 Nov 1992 20:48:14   Chris_Brady
        Initial revision.
        

End of PolyTron RCS section                             *****************/

#ifdef DOC

DESCRIPTION
     ATI Windows NT Miniport driver for the Mach64, Mach32, and Mach8 
     families.
     This file will select the appropriate functions depending on the 
     computer configuration.

Environment:

    Kernel mode

#endif


/*
 * SPLIT_RASTERS is defined in order to work with a display driver which
 * may break a scan line across the boundary between 64k pages when using
 * the VGA aperture, and undefined when working with a display driver
 * which requires that every scan line be contained within a single page
 * (modes with a screen width of less than 1024 pixels are padded to a
 * pitch of 1024, modes with a width greater than 1024 but less than
 * 2048 are padded to a pitch of 2048).
 */
#define SPLIT_RASTERS   1

/*
 * Values used to indicate priority of VideoDebugPrint() calls.
 *
 * To set the debug threshold, set the ati\Device0\VideoDebugLevel
 * registry field to the lowest-priority debug statments you want
 * to see. For example, a value of 2 will display DEBUG_ERROR and
 * DEBUG_IMPORTANT in addition to DEBUG_TRACE, but will not display
 * DEBUG_DETAIL.
 */
#define DEBUG_ERROR         0   /* Statements with this level should never happen */
#define DEBUG_NORMAL        1   /* Entry/exit points of major functions and other important information */
#define DEBUG_DETAIL        2   /* Detailed debug information */
#define DEBUG_RIDICULOUS    3   /* This level will trigger MASSIVE numbers of statments from VIDEOPRT.SYS */
/*
 * Uncomment to allow building using free version of VIDEOPRT.LIB
 */
//#undef VideoDebugPrint
//#define VideoDebugPrint(x)

/*
 * Delay for DEC Alpha and other machines too fast to allow
 * consecutive I/O instructions without a delay in between.
 */
#if defined (ALPHA) || defined (_ALPHA_)
#define DEC_DELAY delay(3);
#else
#define DEC_DELAY
#endif

/*
 * Definitions used by the IOCTL_VIDEO_ATI_GET_VERSION packet.
 */
#define MINIPORT_BUILD          511 /* NT Retail build number */
#define MINIPORT_VERSION_MAJOR  0   /* Major version number */
#define MINIPORT_VERSION_MINOR  3   /* Minor version number */


// #define DBG 1

#define CURSOR_WIDTH   64
#define CURSOR_HEIGHT  64

/*
 * Screen attributes for "blue screen" text (white on blue), used
 * to recognize whether or not we are looking at the "blue screen"
 * or other memory.
 */
#define TTY_ATTR_NORMAL 0x17


//------------------------------------------------------------------------

/*
 * List of available resolutions
 */
#define RES_640     0
#define RES_800     1
#define RES_1024    2
#define RES_1152    3
#define RES_1280    4
#define RES_1600    5

/*
 * "Card found" status variables. We support a single card that does
 * not use block relocatable I/O, or up to 16 cards (INT 10 AH=A0 through
 * AH=AF) that use block relocatable I/O, but never a mix of block and
 * non-block cards.
 */
extern BOOL FoundNonBlockCard;
extern USHORT NumBlockCardsFound;

/*
 * List of greatest pixel depths available for each supported
 * DAC at all resolutions.
 *
 * A value of 0 indicates that the DAC is known to not support
 * the corresponding resolution. A value of 1 indicates that
 * it is unknown whether or not the DAC supports the corresponding
 * resolution. Since we don't report any modes with a colour depth
 * less than 4BPP, both will be seen as the resolution not being
 * supported.
 */
#ifdef INCLUDE_ATIMP
short MaxDepth[HOW_MANY_DACs][RES_1600-RES_640+1] =
    {
    16, 16, 16, 16, 8,  1,  /* DAC_ATI_68830 */
    24, 16, 8,  8,  8,  1,  /* DAC_SIERRA */
    32, 32, 16, 16, 8,  1,  /* DAC_TI34075 */
    8,  8,  8,  8,  8,  1,  /* DAC_BT47x */
    24, 16, 8,  8,  8,  1,  /* DAC_BT48x */
    32, 32, 32, 32, 24, 1,  /* DAC_ATI_68860 */
    32, 32, 16, 16, 8,  1,  /* DAC_STG1700 */
    24, 24, 24, 24, 16, 1,  /* DAC_SC15021 NOTE: Should be able to handle 32BPP. */
    /*
     * DAC types below are for cases where incompatible DAC types
     * report the same code in CONFIG_STATUS_1. Since the DAC type
     * field is 3 bits and can't grow (bits immediately above and
     * below are already assigned), DAC types 8 and above will
     * not conflict with reported DAC types but are still legal
     * in the query structure's DAC type field (8 bit unsigned integer).
     */
    24, 16, 8,  8,  8,  1,  /* DAC_ATT491 */
    32, 32, 16, 16, 8,  1,  /* DAC_ATT498 */
    24, 16, 8,  8,  8,  1,  /* DAC_SC15026 */
    32, 32, 32, 32, 24, 24, /* DAC_TVP3026 */
    32, 32, 32, 32, 24, 24, /* DAC_IBM514 */
    32, 32, 24, 16, 16, 1,  /* DAC_STG1702 */
    32, 32, 24, 16, 16, 1,  /* DAC_STG1703 */
    32, 32, 16, 16, 8,  1,  /* DAC_CH8398 */
    32, 32, 16, 16, 8,  1,  /* DAC_ATT408 */
    32, 32, 16, 16, 8,  1,  /* DAC_INTERNAL_CT */
    32, 32, 16, 16, 8,  1,  /* DAC_INTERNAL_GT */
    32, 32, 16, 16, 8,  1   /* DAC_INTERNAL_VT */
    };
#else
extern short MaxDepth[HOW_MANY_DACs][RES_1600-RES_640+1];
#endif

//-----------------------------------------------------------------------

typedef struct tagVDATA {
    ULONG   Address;
    ULONG   Value;
} VDATA, *PVDATA;

//------------------------------------------

#ifndef QUERYSIZE
#define QUERYSIZE       12288
#endif

/*
 * Value stored in VIDEO_MODE_INFORMATION.Frequency field to
 * indicate hardware default refresh rate.
 */
#define DEFAULT_REFRESH 1


/*
 * Number of mapped address ranges allowed in HW_DEVICE_EXTENSION
 * structure. Modules which will be mapping address ranges to fill
 * arrays with this size contain checks on this value. If the array
 * would be overfilled, these checks will cause compile-time errors.
 */
#define NUM_ADDRESS_RANGES_ALLOWED  108

/*
 * Define device extension structure. This is device dependant/private
 * information.
 */
typedef struct _HW_DEVICE_EXTENSION {
    /*
     * I/O space ranges used. The extra 1 is for the
     * VGAWONDER extended base register, which is determined
     * at runtime.
     */
    PVOID aVideoAddressIO[NUM_ADDRESS_RANGES_ALLOWED];

    /*
     * Memory Mapped address ranges used. This array must
     * be the same size as the I/O mapped array.
     */
    PVOID aVideoAddressMM[NUM_ADDRESS_RANGES_ALLOWED];

    PVOID RomBaseRange;     /* ROM address range used */

    PHYSICAL_ADDRESS PhysicalFrameAddress;  /* Physical address of the LFB */

    ULONG VideoRamSize;         /* Amount of installed video memory */


    ULONG FrameLength;          /* Aperture size. */

    ULONG ModeIndex;            /* Index of current mode in either ModesVGA[] */
                                /* or mode tables in CardInfo[], depending on */
                                /* whether video card is VGAWonder or accelerator */

    ULONG HardwareCursorAddr;   /* Storage of cursor bitmap for 68800 hardware cursor */
    ULONG ModelNumber;			/* ATI Adapter Card Type */
    USHORT BiosPrefix;          /* Card sequence for accelerator INT 10 calls */
    ULONG BaseIOAddress;        /* Used in matching BIOS prefix to I/O base on relocatable cards */
    char CardInfo[QUERYSIZE];   /* Storage for query information */

    struct st_eeprom_data *ee;  /* Information used to access EEPROM */

    /*
     * The following 4 fields are used when re-initializing the windowed
     * screen after a full-screen DOS session. They are a flag to show
     * that the mode is being re-initialized instead of entered for the
     * first time, the palette of colours to use, the first palette entry
     * to be reloaded, and the number of palette entries to be reloaded.
     */
    BOOL ReInitializing;
    ULONG Clut[256];
    USHORT FirstEntry;
    USHORT NumEntries;

    /*
     * Used to ensure that ATIMPInitialize() is only called once for
     * any given card.
     */
    BOOL CardInitialized;

    ULONG PreviousPowerState;

    /*
     * Shows whether to merge "canned" mode tables with tables from
     * VDIF file, or with tables from EDID structure returned by DDC.
     */
    ULONG MergeSource;

    ULONG EdidChecksum;         /* Checksum of EDID structure */

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

#if defined INCLUDE_ATIMP
    PHW_DEVICE_EXTENSION phwDeviceExtension;       // Global Miniport Variable now
#else
    extern PHW_DEVICE_EXTENSION  phwDeviceExtension;
#endif


/*
 * Registry callback routine and buffers to allow data to be retrieved
 * by other routines.
 */
extern VP_STATUS
RegistryParameterCallback(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    PVOID Context,
    PWSTR Name,
    PVOID Data,
    ULONG Length
    );

#define REGISTRY_BUFFER_SIZE 200    /* Size of buffer used in registry reads */
extern UCHAR RegistryBuffer[];      /* Last value retrieved from the registry */
extern ULONG RegistryBufferLength;  /* Size of last retrieved value */

/*
 * Macros to provide debug breakpoints in checked version while
 * clearing them in free version.
 */
#if DBG
#if defined(i386) || defined(_X86_)
#define INT	_asm int 3;
#else
#define INT DbgBreakPoint();
/*
 * Function prototype has vanished from headers we include, so
 * we must supply it on our own.
 */
extern void DbgBreakPoint(void);
#endif
#else
#define INT
#endif

/*
 * Routine to make an absolute far call.
 */
#if 0
#ifdef _X86_
extern VP_STATUS CallAbsolute(unsigned short, unsigned short, VIDEO_X86_BIOS_ARGUMENTS *);
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\amach1.h ===
//*************************************************************************
//**                                                                     **
//**                               AMACH1.H                              **
//**                                                                     **
//**     Copyright (c) 1993, 1995 ATI Technologies Inc.                  **
//*************************************************************************
//   
//  Supplemental definitions and data structures which are independent
//      of the ATI accelerator family being used. Mach 8/Mach32 specific
//      definitions and structures are in AMACH.H, while Mach 64 specific
//      definitions and structures are in AMACHCX.H.
//
//  Created the 68800.inc file which includes equates, macros, etc 
//       from the following include files:    
//       8514vesa.inc, vga1regs.inc,  m32regs.inc,  8514.inc
//
// supplement structures and values to the 68800 Family.
//
// This is a "C" only file and is NOT derived from any Assembler INC files.

  
/**********************       PolyTron RCS Utilities

   $Revision:   1.14  $
   $Date:   23 Apr 1996 17:15:20  $
   $Author:   RWolff  $
   $Log:   S:/source/wnt/ms11/miniport/archive/amach1.h_v  $
 * 
 *    Rev 1.14   23 Apr 1996 17:15:20   RWolff
 * Added new memory types (used by ?T) to memory type enumeration.
 * 
 *    Rev 1.13   22 Dec 1995 14:51:10   RWolff
 * Added support for Mach 64 GT internal DAC.
 * 
 *    Rev 1.12   08 Sep 1995 16:36:00   RWolff
 * Added support for AT&T 408 DAC (STG1703 equivalent).
 * 
 *    Rev 1.11   28 Jul 1995 14:39:24   RWolff
 * Added support for the Mach 64 VT (CT equivalent with video overlay).
 * 
 *    Rev 1.10   30 Jan 1995 11:56:54   RWOLFF
 * Added support for CT internal DAC.
 * 
 *    Rev 1.9   18 Jan 1995 15:38:02   RWOLFF
 * Added Chrontel CH8398 to DAC type enumeration.
 * 
 *    Rev 1.8   23 Dec 1994 10:48:40   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.7   18 Nov 1994 11:49:16   RWOLFF
 * Added new DAC type DAC_STG1703. This DAC is equivalent to the STG1702,
 * but has its own clock generator. The STG1702/1703 in native mode are
 * programmed differently in 24BPP than when they are strapped for
 * STG1700 emulation.
 * 
 *    Rev 1.6   14 Sep 1994 15:25:54   RWOLFF
 * Added "most desirable colour ordering" field to query structure,
 * changed RGB<depth>_<order> definitions from enumeration to flags
 * that can be used in this field.
 * 
 *    Rev 1.5   31 Aug 1994 16:09:02   RWOLFF
 * Added support for TVP3026 DAC and 1152x864, removed dead code.
 * 
 *    Rev 1.4   19 Aug 1994 17:03:30   RWOLFF
 * Added support for Graphics Wonder, SC15026 DAC, and pixel clock
 * generator independence.
 * 
 *    Rev 1.3   20 May 1994 13:56:42   RWOLFF
 * Ajith's change: added field for bus type reported by NT to
 * the query structure.
 * 
 *    Rev 1.2   12 May 1994 11:15:04   RWOLFF
 * Removed redundant definition, added refresh rate to mode table structure.
 * 
 *    Rev 1.1   04 May 1994 19:22:58   RWOLFF
 * Fix for block write test corrupting the screen when running display applet
 * 
 *    Rev 1.0   31 Jan 1994 11:26:48   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.5   14 Jan 1994 15:17:00   RWOLFF
 * Added flag for 1600x1200 mode.
 * 
 *    Rev 1.4   15 Dec 1993 15:24:34   RWOLFF
 * Added support for SC15021 DAC.
 * 
 *    Rev 1.3   30 Nov 1993 18:08:58   RWOLFF
 * Renamed definition for Mach 64.
 * 
 *    Rev 1.2   05 Nov 1993 13:21:10   RWOLFF
 * Added new DAC types and memory sizes.
 * 
 *    Rev 1.1   08 Oct 1993 10:59:28   RWOLFF
 * Added colour ordering field to mode table.
 * 
 *    Rev 1.0   03 Sep 1993 14:26:18   RWOLFF
 * Initial revision.


End of PolyTron RCS section				*****************/


#ifndef BYTE
typedef unsigned char   BYTE;
#endif  /* BYTE */

#ifndef WORD
typedef unsigned short  WORD;
#endif  /* WORD */

#ifndef DWORD
typedef unsigned long   DWORD;
#endif  /* DWORD */

#ifndef UCHAR
typedef unsigned char UCHAR;    /* At least 8 bits, unsigned */
#endif  /* UCHAR */

#ifndef BOOL
typedef int BOOL;                /* Most efficient Boolean,
                                         compare against zero only! */
#endif  /* BOOL */

#ifndef VOID
#define VOID        void
#endif  /* VOID */

#ifndef PVOID
typedef void *PVOID;                   /* Generic untyped pointer */
#endif  /* PVOID */

// the eeprom i/o port bits are in different locations depending upon
// what bus and what class of accelerator.   This does NOT cover VGA class.
struct  st_eeprom_data  {
        WORD   iop_out;                 // I/O port for output
        WORD   iop_in;                  // I/O port for input
        WORD   clock;                   // clock bit to send data
        WORD   select;                  // select eeprom
        WORD   chipselect;              // chip select
        WORD   addr_size;               // Address size (fudge for VGA style)
        WORD   data_out;
        WORD   data_in;
        VOID   (*EEcmd)();              // function to write command to eeprom

        WORD   (*EEread)(short);        // function to read eeprom
        };

//-----------------------------------------------------------------------
struct  st_crt_mach8_table {  // CRT Parameter Tables    11 Words long
    WORD    control;                    // NOT in table, is 7,8,9, or 10
    WORD    info;                       // VGA or 8514 parm format, clock etc.
    BYTE    vmode_sel_2;
    BYTE    vmode_sel_1;
    BYTE    vmode_sel_4;
    BYTE    vmode_sel_3;
    BYTE    h_disp;
    BYTE    h_total;
    BYTE    h_sync_wid;
    BYTE    h_sync_strt;
    WORD    v_total;
    WORD    v_disp;
    WORD    v_sync_strt;
    BYTE    disp_cntl;
    BYTE    v_sync_wid;
    WORD    clock_sel;
    WORD    resvd;
    };


//  EEprom layout for the 8514/Ultra adapters. 64 words by 16 bits = 1K size
struct  st_ee_8514Ultra  {
    WORD    page_3_2;
    WORD    page_2_0;
    WORD    monitor;
    WORD    vfifo;
    WORD    clock;
    WORD    shadow;
    WORD    display_cntl;               // shadow sets 1,2
    WORD    v_sync_width;               // shadow sets 1,2
    WORD    v_sync_strt2;
    WORD    v_sync_strt1;
    WORD    v_display2;
    WORD    v_display1;
    WORD    v_total2;
    WORD    v_total1;
    WORD    h_sync_width;               // shadow sets 1,2
    WORD    h_sync_strt;
    WORD    h_display;
    WORD    h_total;
    WORD    crc;
    // Updated 8514/Ultra adds 800 and 1280 resolutions  
    WORD    ext_vfifo;                  // 800 and 1280 resolutions
    WORD    ext_clock;
    WORD    ext_shadow;
    WORD    ext_display;
    WORD    ext_v_sync_width;
    WORD    v_sync_strt_800;
    WORD    v_display_800;
    WORD    v_total_800;
    WORD    ext_h_sync_width;           // shadow sets for 800 and 1280
    WORD    ext_h_sync_strt;
    WORD    ext_h_display;
    WORD    ext_h_total;
    WORD    custom_mode;
    WORD    monitor_name[17];           // words 32-48
    WORD    v_sync_strt_1280;           // word 49
    WORD    v_display_1280;             // word 50
    WORD    v_total_1280;               // word 51
    };


//-----------------------------------------------------------------------
//  EEprom layout for the Graphics Ultra adapters. 64 words by 16 bits = 1K size
//  This is the brute forcing of the VGA Wonder and the 8514 chips
//  both residing on the same board.
struct  st_ee_GraphicsUltra  {
    WORD    eeprom_counter;
    WORD    mouse;
    WORD    powerup_mode;
    WORD    resvd1[2];                  // word 3,4
    WORD    monitor;
    WORD    resvd2;                     // word 6
    WORD    hz640_72;
    WORD    hz800;                      // word 8
    WORD    hz1024;
    WORD    hz1280;
    WORD    resvd3[2];                  // word 11,12

    struct  st_crt_mach8_table  r640;   // CRT parm Table 0 - 640x480 mode
    struct  st_crt_mach8_table  r800;   // CRT parm Table 1 - 640x480 mode
    struct  st_crt_mach8_table r1024;   // CRT parm Table 2 - 640x480 mode
    struct  st_crt_mach8_table r1280;   // Table 3 - 1280 OR 132 column text mode
    };


//-----------------------------------------------------------------------
//  EEprom layout for the 68800 adapters. 128 words by 16 bits = 2K size

struct  st_crt_mach32_table {   // CRT Parameter Tables    15 Words long
    WORD    info;                       // VGA or 8514 parm format, clock etc.
    BYTE    vmode_sel_2;
    BYTE    vmode_sel_1;
    BYTE    vmode_sel_4;
    BYTE    vmode_sel_3;
    BYTE    h_disp;
    BYTE    h_total;
    BYTE    h_sync_wid;
    BYTE    h_sync_strt;
    WORD    v_total;
    WORD    v_disp;
    WORD    v_sync_strt;
    BYTE    disp_cntl;
    BYTE    v_sync_wid;
    WORD    clock_sel;                  // same as st_crt_mach8 to here.
    WORD    mode_size;                  // word 10
    WORD    horz_ovscan;
    WORD    vert_ovscan;
    WORD    ov_col_blue;                // word 13
    WORD    ov_col_grn_red;             // word 14
    };


struct  st_ee_68800  {
    WORD    eeprom_counter;
    WORD    mouse;
    WORD    powerup_mode;
    WORD    ee_rev;                      // word 3
    WORD    cm_indices;                 // word 4
    WORD    monitor;
    WORD    aperture;                   // word 6
    WORD    hz640_72;
    WORD    hz800;                      // word 8
    WORD    hz1024;
    WORD    hz1280;
    WORD    hz1150;                     // word 11
    WORD    resvd3;                     // word 12

    // example crt tables,  there are many for each resolution
    //   struct  st_crt_mach32_table  r640;  // CRT parm Table 0 - 640x480 mode
    //   struct  st_crt_mach32_table  r800;  // CRT parm Table 1 - 640x480 mode
    //   struct  st_crt_mach32_table r1024;  // CRT parm Table 2 - 640x480 mode
    //   struct  st_crt_mach32_table r1280;  // Table 3 - 1280 OR 132 column text mode
    };



//-----------------------------------------------------------------------
//---------------  as defined in \68800\test\services.asm

#define QUERY_GET_SIZE   0       // return query structure size   (varying modes)
#define QUERY_LONG       1       // return query structure filled in
#define QUERY_SHORT      2       // return short query

struct  query_structure  {

    short   q_sizeof_struct;       // size of structure in bytes (including mode tables)
    UCHAR   q_structure_rev;       // structure revision number
    UCHAR   q_number_modes;        // total number of installed modes
    short   q_mode_offset;         // offset to 1st mode table
    UCHAR   q_sizeof_mode;         // size of mode table in bytes
    UCHAR   q_asic_rev;            // gate array revision number
    UCHAR   q_status_flags;        // status flags
    UCHAR   q_VGA_type;            // VGA type (enabled or disabled for now)
    UCHAR   q_VGA_boundary;        // VGA boundary
    UCHAR   q_memory_size;         // total memory size (VGA + accelerator)
    UCHAR   q_DAC_type;            // DAC type
    UCHAR   q_memory_type;         // memory type
    UCHAR   q_bus_type;            // bus type
    UCHAR   q_monitor_alias;       // monitor alias and monitor alias enable
    short   q_shadow_1;            // shadow set 1 state
    short   q_shadow_2;            // shadow set 2 state
    short   q_aperture_addr;       // aperture address
    UCHAR   q_aperture_cfg;        // aperture size
    UCHAR   q_mouse_cfg;           // mouse configuration
    UCHAR   q_reserved;
    short   q_desire_x;            // selected screen resolution X value
    short   q_desire_y;
    short   q_pix_depth;           // selected bits per pixel
    BYTE    *q_bios;              // Base address of the BIOS
    BOOL    q_eeprom;              // TRUE if eeprom present
    BOOL    q_ext_bios_fcn;        // TRUE if ATI Extended BIOS fcns present
    BOOL    q_ignore1280;          // TRUE if ignore 1280 table in Mach8 cards
    BOOL    q_m32_aper_calc;       // TRUE if mach32 aperture addr needs Extra Bits.
    BOOL    q_GraphicsWonder;       /* TRUE if this is a Graphics Wonder (restricted Mach 32) */
    short   q_screen_pitch;         // Pixels per display line
    UCHAR   q_BlockWrite;           /* Whether or not block write mode is available */
    ULONG   q_system_bus_type;      // bus type reported by NT
    USHORT  q_HiColourSupport;      /* Colour orders supported for non-paletted modes */
    };


// Matches BIOS mode table query function up to and including m_overscan_gr
struct  st_mode_table {
    short   m_x_size;              // horizontal screen resolution
    short   m_y_size;              // vertical screen resolution
    UCHAR   m_pixel_depth;         // maximum pixel depth
    UCHAR   m_status_flags;        // status flags
                                   //   bit 0: if set, non-linear Y addressing
                                   //   bit 1: if set, MUX mode
                                   //   bit 2: if set, PCLK/2
    short   m_reserved;      
    UCHAR   m_vfifo_16;            // 16 bpp vfifo depth
    UCHAR   m_vfifo_24;            // 24 bpp vfifo depth
    short   m_clock_select;        // clock select
    UCHAR   m_h_total;             // horizontal total
    UCHAR   m_h_disp;              // horizontal displayed
    UCHAR   m_h_sync_strt;         // horizontal sync start
    UCHAR   m_disp_cntl;           // display control
    UCHAR   m_h_sync_wid;          // horizontal sync width
    UCHAR   m_v_sync_wid;          // vertical sync width
    short   m_v_total;             // vertical total
    short   m_v_disp;              // vertical displayed
    short   m_v_sync_strt;         // vertical sync start
    short   m_h_overscan;          // horizontal overscan configuration
    short   m_v_overscan;          // vertical overscan configuration
    short   m_overscan_8b;         // overscan color for 8 bit and blue
    short   m_overscan_gr;         // overscan color green and red
    short   enabled;               // what frequency is enabled (eeprom 7,8,9,10 or 11)
    short   control;               // clock and control values  (CRT table 0)
    ULONG   ClockFreq;              /* Clock frequency (in Hertz) */
    short   m_screen_pitch;        // pixels per display line
    WORD    ColourDepthInfo;       /* Information about colour depth being used */
    short   Refresh;                /* Refresh rate, in hertz */
    };


/*
 * Masks and flags for the m_clock_select field.
 * All the flags will be stripped out when the field
 * is ANDed with CLOCK_SEL_STRIP.
 */
#define CLOCK_SEL_STRIP     0xFF83  /* AND to remove clock selector/divisor */
#define CLOCK_SEL_MUX       0x0004  /* Use mux mode (2x 8bit pixels in 16 bit path) */
#define CLOCK_SEL_DIVIDED   0x0008  /* Clock frequency for mux mode already divided by 2 */


/*
 * Flags to put in query_structure.q_HiColourSupport to show that
 * the corresponding colour order is supported.
 */
#define RGB16_555   0x0001
#define RGB16_565   0x0002
#define RGB16_655   0x0004
#define RGB16_664   0x0008
#define RGB24_RGB   0x0010
#define RGB24_BGR   0x0020
#define RGB32_RGBx  0x0040
#define RGB32_xRGB  0x0080
#define RGB32_BGRx  0x0100
#define RGB32_xBGR  0x0200


//-----  Video Memory  details
enum  {
    VMEM_DRAM_256Kx4 = 0,
	VMEM_VRAM_256Kx4_SER512,
	VMEM_VRAM_256Kx4_SER256,    /* 68800-3 only */
	VMEM_DRAM_256Kx16,
    VMEM_DRAM_256Kx4_GRAP,      /* This and following types on 68800-6 only */
    VMEM_VRAM_256Kx4_SPLIT512,
    VMEM_VRAM_256Kx16_SPLIT256,
    VMEM_GENERIC_DRAM,          /* This and following types are for Mach 64 ?T only */
    VMEM_EDO_DRAM,
    VMEM_BRRAM,
    VMEM_SDRAM
	};

#define VMEM_VRAM_256Kx16_SER256 VMEM_VRAM_256Kx4_SER256    /* 68800-6 only */


//-----  BUS types       matches the 68800 CONFIG_STATUS_1.BUS_TYPE
enum  { BUS_ISA_16,
	BUS_EISA,
	BUS_MC_16,
	BUS_MC_32,
	BUS_LB_386SX,
	BUS_LB_386DX,
	BUS_LB_486,
	BUS_PCI,
	BUS_ISA_8
	};

//-----  RAM DAC details, matches CONFIG_STATUS_1.DACTYPE field
enum  { DAC_ATI_68830,
	DAC_SIERRA,
	DAC_TI34075,
	DAC_BT47x,
	DAC_BT48x,
	DAC_ATI_68860,
    DAC_STG1700,
	DAC_SC15021,
	/*
	 * DAC types below are for cases where incompatible DAC types
	 * report the same code in CONFIG_STATUS_1. Since the DAC type
	 * field is 3 bits and can't grow (bits immediately above and
	 * below are already assigned), DAC types 8 and above will
	 * not conflict with reported DAC types but are still legal
	 * in the query structure's DAC type field (8 bit unsigned integer).
	 */
	DAC_ATT491,
    DAC_ATT498,
    DAC_SC15026,

    /*
     * DAC types below are not used on 8514/A-compatible accelerators.
     * Subsequent additions must be made AFTER DAC_SC15026.
     */
    DAC_TVP3026,
    DAC_IBM514,

    /*
     * This DAC is more advanced than the STG1700.
     */
    DAC_STG1702,

    /*
     * DAC is equivalent to STG1702, but it has its own clock
     * generator which is programmed differently from the one
     * normally used on the Mach 64.
     */
    DAC_STG1703,

    /*
     * DAC with equivalent capabilities to STG1703, but not a
     * drop-in replacement.
     */
    DAC_CH8398,

    /*
     * Yet another DAC which is equivalent to STG1703 but which
     * is not a drop-in replacement.
     */
    DAC_ATT408,

    /*
     * Internal DAC on Mach 64 CT ASIC.
     */
    DAC_INTERNAL_CT,

    /*
     * Internal DAC on Mach 64 GT ASIC. This is a CT equivalent
     * with built-in multimedia and games functionality.
     */
    DAC_INTERNAL_GT,

    /*
     * Internal DAC on Mach 64 VT ASIC. This is a CT equivalent
     * with built-in video overlay circuitry.
     */
    DAC_INTERNAL_VT,

	/*
	 * Size definition for arrays indexed by DAC type (assumes enumerated
	 * types are zero-based). This must be the LAST entry in the
	 * DAC type enumeration.
	 */
	HOW_MANY_DACs
	};

/*
 * Size definition for 8514/A-compatible accelerator arrays indexed by
 * DAC type.
 */
#define MAX_OLD_DAC DAC_TVP3026

/*
 * Possible knowledge states for block write capability.
 */
enum {BLOCK_WRITE_UNKNOWN,
    BLOCK_WRITE_NO,
    BLOCK_WRITE_YES
    };


//Monitor Descriptions are in IBM style
#define MONITOR_ID_8514      0x000A 
#define MONITOR_ID_8515      0x000B 
#define MONITOR_ID_VGA8503   0x000D 
#define MONITOR_ID_VGA8513   0x000E 
#define MONITOR_ID_VGA8512   0x000E 
#define MONITOR_ID_8604      0x0009 
#define MONITOR_ID_8507      0x0009 
#define MONITOR_ID_NOMON     0x000F 



/*
 * Give identifiers for the different ATI 8514 Products,
 * as used in the ModelNumber field of the HW_DEVICE_EXTENSION
 * structure and returned by Mach8_detect().
 */
enum  { _8514_ULTRA = 1,
        GRAPHICS_ULTRA,
        MACH32_ULTRA,
        MACH64_ULTRA,
        IBM_VGA,
        WONDER,
        IBM_8514,
        IBM_XGA,
        NO_ATI_ACCEL    // No ATI accelerator available
	};

/*
 * Number of ATI 8514 products available.
 */
#define HOW_MANY_8514_PRODS (NO_ATI_ACCEL - _8514_ULTRA) + 1

/*
 * Amount of Video RAM installed. The q_memory_size
 * field of the query_structure uses these definitions
 * rather than holding a count of the number of bytes.
 */
enum  { VRAM_256k=1,
	VRAM_512k,
	VRAM_768k,
	VRAM_1mb, 
	VRAM_1_25mb,
	VRAM_1_50mb, 
	VRAM_2mb=8, 
	VRAM_4mb=16,
    VRAM_6mb=24,
    VRAM_8mb=32,
    VRAM_12mb=48,
    VRAM_16mb=64
	};

/*
 * Define bits for resolutions. The q_status_flags field
 * of the query_structure uses these.
 */
#define VRES_640x480    0x0001
#define VRES_800x600    0x0002
#define VRES_1024x768   0x0004
#define VRES_1280x1024  0x0008
#define VRES_ALT_1      0x0010          /* Usually 1152x900,  1120x750 */
#define VRES_1152x864   VRES_ALT_1
#define VRES_RESERVED_6 0x0020
#define VRES_RESERVED_7 0x0040
#define VRES_RESERVED_8 0x0080
#define VRES_1600x1200  VRES_ALT_1


/*
 * Predefined Video Resolution Modes
 */
enum  { VRES_UNDEFINED,   
	VRES_640x480x4,   
	VRES_640x480x8,   
	VRES_640x480x16,  
	VRES_640x480x24,  
	VRES_640x480x32,  

	VRES_800x600x4,   
	VRES_800x600x8,   
	VRES_800x600x16,  
	VRES_800x600x24,  
	VRES_800x600x32,  

	VRES_1024x768x4,  
	VRES_1024x768x8,  
	VRES_1024x768x16, 
	VRES_1024x768x24, 
	VRES_1024x768x32, 

	VRES_1280x1024x4, 
	VRES_1280x1024x8, 
	VRES_1280x1024x16,
	VRES_1280x1024x24,
	VRES_1280x1024x32,

	VRES_ALTERNATEx4,
	VRES_ALTERNATEx8,
	VRES_ALTERNATEx16,
	VRES_ALTERNATEx24,
	VRES_ALTERNATEx32
	};

/*
 * Number of predefined video resolution modes.
 */
#define HOW_MANY_RES_MODES (VRES_ALTERNATEx32 - VRES_UNDEFINED) + 1

/*
 * Numbers used in memory calculations.
 */
#define ONE_MEG     1048576L
#define HALF_MEG     524288L
#define QUARTER_MEG  262144L



/*
 * Definitions with an underscore in their name will read or write
 * a portion of a larger register other than the least significant
 * byte or word. Due to limitations in the Lio<function> routines,
 * it is not possible to do this by calling (for example) LioInp(port+1).
 *
 * _HBLW    Access the high byte of the low word (16 and 32 bit registers)
 * _LBHW    Access the low byte of the high word (32 bit registers only)
 * _HBHW    Access the high byte of the high word (32 bit registers only)
 * _HW      Access the high word (32 bit registers only)
 */
#define INP(port)               LioInp(port, 0)
#define INP_HBLW(port)          LioInp(port, 1)
#define INP_LBHW(port)          LioInp(port, 2)
#define INP_HBHW(port)          LioInp(port, 3)
#define INPW(port)              LioInpw(port, 0)
#define INPW_HW(port)           LioInpw(port, 2)
#define INPD(port)              LioInpd(port)

#define OUTP(port, val)         LioOutp(port, val, 0)
#define OUTP_HBLW(port, val)    LioOutp(port, val, 1)
#define OUTP_LBHW(port, val)    LioOutp(port, val, 2)
#define OUTP_HBHW(port, val)    LioOutp(port, val, 3)
#define OUTPW(port, val)        LioOutpw(port, val, 0)
#define OUTPW_HW(port, val)     LioOutpw(port, val, 2)
#define OUTPD(port, val)        LioOutpd(port, val)


//**********************   end  of  AMACH1.H   ****************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\atioem.h ===
/************************************************************************/
/*                                                                      */
/*                              ATIOEM.H                                */
/*                                                                      */
/*  Copyright (c) 1993, ATI Technologies Incorporated.	                */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
    $Revision:   1.0  $
    $Date:   31 Jan 1994 11:28:06  $
    $Author:   RWOLFF  $
    $Log:   S:/source/wnt/ms11/miniport/vcs/atioem.h  $
 * 
 *    Rev 1.0   31 Jan 1994 11:28:06   RWOLFF
 * Initial revision.
        
           Rev 1.0   16 Aug 1993 13:30:20   Robert_Wolff
        Initial revision.
        
           Rev 1.1   10 May 1993 16:41:48   RWOLFF
        Eliminated unnecessary passing of hardware device extension
        as a parameter.
        
           Rev 1.0   30 Mar 1993 17:13:00   RWOLFF
        Initial revision.


End of PolyTron RCS section                             *****************/

#ifdef DOC
    ATIOEM.H -  Function prototypes and data definitions for ATIOEM.C.

#endif


/*
 * Definitions for IgnoreCase parameter of CompareASCIIToUnicode()
 */
#define CASE_SENSITIVE      0
#define CASE_INSENSITIVE    1

extern LONG CompareASCIIToUnicode(PUCHAR Ascii, PUCHAR Unicode, BOOL IgnoreCase);

extern VP_STATUS OEMGetParms(struct query_structure *query);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\atioem.c ===
/************************************************************************/
/*                                                                      */
/*                              ATIOEM.C                                */
/*                                                                      */
/*  Copyright (c) 1993, ATI Technologies Incorporated.                  */
/************************************************************************/

/**********************       PolyTron RCS Utilities

    $Revision:   1.20  $
    $Date:   01 May 1996 14:08:38  $
    $Author:   RWolff  $
    $Log:   S:/source/wnt/ms11/miniport/archive/atioem.c_v  $
 * 
 *    Rev 1.20   01 May 1996 14:08:38   RWolff
 * Locked out 24BPP on Alpha and on machines without LFB.
 * 
 *    Rev 1.19   23 Jan 1996 11:43:24   RWolff
 * Eliminated level 3 warnings, protected against false values of TARGET_BUILD.
 * 
 *    Rev 1.18   11 Jan 1996 19:35:58   RWolff
 * Added maximum pixel clock rate to all calls to SetFixedModes().
 * This is required as part of a Mach 64 fix.
 * 
 *    Rev 1.17   22 Dec 1995 14:52:52   RWolff
 * Switched to TARGET_BUILD to identify the NT version for which
 * the driver is being built.
 * 
 *    Rev 1.16   20 Jul 1995 17:26:54   mgrubac
 * Added support for VDIF files
 * 
 *    Rev 1.15   31 Mar 1995 11:51:36   RWOLFF
 * Changed from all-or-nothing debug print statements to thresholds
 * depending on importance of the message.
 * 
 *    Rev 1.14   23 Dec 1994 10:47:28   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.13   18 Nov 1994 11:37:56   RWOLFF
 * Added support for Dell Sylvester, STG1703 DAC, and display driver
 * that can handle split rasters.
 * 
 *    Rev 1.12   14 Sep 1994 15:29:52   RWOLFF
 * Now reads in frequency table and monitor description from disk.
 * If disk-based frequency table is missing or invalid, loads default
 * OEM-specific frequency table if it is different from the retail
 * frequency table. If disk-based monitor description is missing or
 * invalid, reads installed modes in OEM-specific manner if the OEM
 * type is known. For unknown OEM types with no disk-based monitor
 * description, only predefined mode tables are listed.
 * 
 *    Rev 1.11   31 Aug 1994 16:20:06   RWOLFF
 * Changed includes to correspond to Daytona RC1, now skips over
 * 1152x864 (Mach 64-only mode, this module is for Mach 32), assumes
 * system is not a Premmia SE under NT retail because the definition
 * we use to look for this machine is not available under NT retail.
 * 
 *    Rev 1.10   19 Aug 1994 17:08:28   RWOLFF
 * Fixed aperture location bug on AST Premmia SE, added support for
 * SC15026 DAC and 1280x1024 70Hz and 74Hz, and pixel clock
 * generator independence.
 * 
 *    Rev 1.9   20 Jul 1994 13:01:56   RWOLFF
 * Added diagnostic print statements for DELL, now defaults to "worst"
 * (interlaced if available, else lowest frequency) refresh rate instead
 * of skipping the resolution if we get an invalid result when trying
 * to find which refresh rate is desired on a DELL Omniplex.
 * 
 *    Rev 1.8   12 Jul 1994 17:42:24   RWOLFF
 * Andre Vachon's changes: different way of allowing DELL users
 * to run without an ATIOEM field.
 * 
 *    Rev 1.7   11 Jul 1994 11:57:34   RWOLFF
 * No longer aborts if ATIOEM field is missing from registry. Some OEMs
 * auto-detect, and generic OEMs can use the "canned" mode tables,
 * so this field is no longer mandatory and someone removed it from
 * the registry sometime after Beta 2 for Daytona.
 *
 *    Rev 1.6   15 Jun 1994 11:05:16   RWOLFF
 * No longer lists "canned" mode tables for Dell Omniplex, since these tables
 * assume the use of the same clock generator as on our retail cards, and
 * Dell uses a different clock generator.
 *
 *    Rev 1.5   20 May 1994 16:07:12   RWOLFF
 * Fix for 800x600 screen tearing on Intel BATMAN PCI motherboards.
 *
 *    Rev 1.4   18 May 1994 17:02:14   RWOLFF
 * Interlaced mode tables now report frame rate rather than vertical
 * scan frequency in the refresh rate field.
 *
 *    Rev 1.3   12 May 1994 11:06:20   RWOLFF
 * Added refresh rate to OEM mode tables, sets up "canned" mode tables
 * for all OEMs except AST Premmia, no longer aborts if no OEM string
 * found either in ATIOEM registry entry or through auto-detection since
 * the "canned" mode tables will be available, no longer supports 32BPP,
 * since this module is for the Mach 8 and Mach 32.
 *
 *    Rev 1.2   31 Mar 1994 15:06:20   RWOLFF
 * Added debugging code.
 *
 *    Rev 1.1   07 Feb 1994 14:05:14   RWOLFF
 * Added alloc_text() pragmas to allow miniport to be swapped out when
 * not needed.
 *
 *    Rev 1.0   31 Jan 1994 10:57:34   RWOLFF
 * Initial revision.

           Rev 1.7   24 Jan 1994 18:02:54   RWOLFF
        Pixel clock multiplication on BT48x and AT&T 49[123] DACs at 16 and 24 BPP
        is now done when mode tables are created rather than when mode is set.

           Rev 1.6   15 Dec 1993 15:25:26   RWOLFF
        Added support for SC15021 DAC, removed debug print statements.

           Rev 1.5   30 Nov 1993 18:12:28   RWOLFF
        Added support for AT&T 498 DAC, now doubles pixel clock at 32BPP for
        DACs that need it. Removed extra increment of mode table counter
        (previously, counter would show 1 more mode table than actually
        existed for each 24BPP mode table present that required clock doubling).

           Rev 1.4   05 Nov 1993 13:31:44   RWOLFF
        Added STG1700 DAC and Dell support

           Rev 1.2   08 Oct 1993 11:03:16   RWOLFF
        Removed debug breakpoint.

           Rev 1.1   03 Sep 1993 14:21:26   RWOLFF
        Partway through CX isolation.

           Rev 1.0   16 Aug 1993 13:27:00   Robert_Wolff
        Initial revision.

           Rev 1.8   10 Jun 1993 15:59:34   RWOLFF
        Translation of VDP-format monitor description file is now done inside
        the registry callback function to eliminate the need for an excessively
        large static buffer (Andre Vachon at Microsoft doesn't want the
        callback function to dynamically allocate a buffer).

           Rev 1.7   10 May 1993 16:37:56   RWOLFF
        GetOEMParms() now recognizes maximum pixel depth of each possible DAC at
        each supported resolution, eliminated unnecessary passing of
        hardware device extension as a parameter.

           Rev 1.6   04 May 1993 16:44:00   RWOLFF
        Removed INT 3s (debugging code), added workaround for optimizer bug that
        turned a FOR loop into an infinite loop.

           Rev 1.5   30 Apr 1993 16:37:02   RWOLFF
        Changed to work with dynamically allocated registry read buffer.
        Parameters are now read in from disk in VDP file format rather than
        as binary data (need floating point bug in NT fixed before this can be used).

           Rev 1.4   24 Apr 1993 17:14:48   RWOLFF
        No longer falls back to 56Hz at 800x600 16BPP on 1M Mach 32.

           Rev 1.3   21 Apr 1993 17:24:12   RWOLFF
        Now uses AMACH.H instead of 68800.H/68801.H.
        Sets q_status_flags to show which resolutions are supported.
        Can now read either CRT table to use or raw CRT parameters from
        disk file.

           Rev 1.2   14 Apr 1993 18:39:30   RWOLFF
        On AST machines, now reads from the computer what monitor type
        is configured and sets CRT parameters appropriately.

           Rev 1.1   08 Apr 1993 16:52:58   RWOLFF
        Revision level as checked in at Microsoft.

           Rev 1.0   30 Mar 1993 17:12:38   RWOLFF
        Initial revision.


End of PolyTron RCS section                             *****************/

#ifdef DOC
    ATIOEM.C -  Functions to obtain CRT parameters from OEM versions
                of Mach 32/Mach 8 accelerators which lack an EEPROM.

#endif


#include <stdlib.h>
#include <string.h>

#include "dderror.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"      /* for VP_STATUS definition */
#include "vidlog.h"

#include "stdtyp.h"
#include "amach.h"
#include "amach1.h"
#include "atimp.h"
#include "atint.h"
#include "cvtvga.h"
#include "atioem.h"
#include "services.h"
#include "vdptocrt.h"

/*
 * Definition needed to build under revision 404 of Windows NT.
 * Under later revisions, it is defined in a header which we
 * include.
 */
#ifndef ERROR_DEV_NOT_EXIST
#define ERROR_DEV_NOT_EXIST 55L
#endif

/*
 * OEM types supported by this module
 */
enum {
    OEM_AST_PREMMIA,        /* Also includes Bravo machines */
    OEM_DELL_OMNIPLEX,
    OEM_DELL_SYLVESTER,     /* Different programming of clock generator from Omniplex */
    OEM_UNKNOWN             /* Generic OEM - "canned" modes only, no HW defaults */
    };

/*
 * AST machines have "AST " starting at offset 0x50 into the BIOS.
 * AST_REC_VALUE is the character sequence "AST " stored as an
 * Intel-format DWORD.
 */
#define AST_REC_OFFSET  0x50
#define AST_REC_VALUE   0x20545341

/*
 * Definitions used to distinguish Premmia SE from other
 * AST machines. The Premmia SE has its aperture in the
 * 4G range, with the location split between MEM_CFG and
 * SCRATCH_PAD_0, but it does not have bit 0 of byte 0x62
 * in the BIOS set to indicate this.
 */
#define EISA_ID_OFFSET  8           /* Offset to feed VideoPortGetBusData() */
#define PREMMIA_SE_SLOT 0           /* Motherboard is slot 0 */
#define PREMMIA_SE_ID   0x01057406  /* EISA ID of Premmia SE */

/*
 * Indices into 1CE register where AST monitor configuration is kept.
 */
#define AST_640_STORE   0xBA
#define AST_800_STORE   0x81
#define AST_1024_STORE  0x80

/*
 * Values found in AST monitor configuration registers for the
 * different monitor setups.
 */
#define M640F60AST  0x02
#define M640F72AST  0x03
#define M800F56AST  0x84
#define M800F60AST  0x88
#define M800F72AST  0xA0
#define M1024F60AST 0x02
#define M1024F70AST 0x04
#define M1024F72AST 0x08
#define M1024F87AST 0x01

/*
 * Definitions used in stepping through pixel depths for AST Premmia.
 * Since the supported depths can't be stepped through a FOR loop
 * by a simple mathematical function, use an array index instead.
 */
enum {
    DEPTH_4BPP = 0,
    DEPTH_8BPP,
    DEPTH_16BPP,
    DEPTH_24BPP
    };

/*
 * Pixel depth
 */
USHORT ASTDepth[DEPTH_24BPP - DEPTH_4BPP + 1] =
{
    4,
    8,
    16,
    24
};

/*
 * Pixel clock frequency multiplier
 */
USHORT ASTClockMult[DEPTH_24BPP - DEPTH_4BPP + 1] =
{
    CLOCK_SINGLE,
    CLOCK_SINGLE,
    CLOCK_DOUBLE,
    CLOCK_TRIPLE
};

/*
 * Pixel size as a multiple of 4BPP (lowest depth)
 */
USHORT ASTNybblesPerPixel[DEPTH_24BPP - DEPTH_4BPP + 1] =
{
    1,
    2,
    4,
    6
};


/*
 * Dell machines have "DELL" starting at an offset into the BIOS which
 * is a multiple of 0x100. Currently, it is always at offset 0x100, but
 * this may change. DELL_REC_VALUE is the character sequence "DELL"
 * stored as an Intel-format DWORD.
 *
 * Some Dell machines store the pixel clock frequency table in the BIOS
 * rather than using the default Dell frequency table. On these machines,
 * the identifier DELL_TABLE_PRESENT will be found at offset DELL_TP_OFFSET
 * from the start of DELL_REC_VALUE, and the offset of the frequency table
 * into the video BIOS will be found at offset DELL_TABLE_OFFSET from the
 * start of DELL_TABLE_PRESENT.
 *
 * The table consists of 18 words. The first word is DELL_TABLE_SIG,
 * the second is the table type, and the remaining 16 are the clock
 * table entries.
 */
#define DELL_REC_SPACING    0x100
#define DELL_REC_VALUE      0x4C4C4544
#define DELL_TABLE_PRESENT  0x7674          /* "tv" as WORD */
#define DELL_TP_OFFSET      0x08
#define DELL_TABLE_OFFSET   0x0C
#define DELL_TABLE_SIG      0x7463          /* "ct" as WORD */

/*
 * Indices into 1CE register where Dell monitor configuration is kept.
 */
#define DELL_640_STORE  0xBA
#define DELL_800_STORE  0x81
#define DELL_1024_STORE 0x80
#define DELL_1280_STORE 0x84

/*
 * Values found in Dell monitor configuration registers for the
 * different monitor setups.
 */
#define MASK_640_DELL   0x01
#define M640F60DELL     0x00
#define M640F72DELL     0x01
#define MASK_800_DELL   0x3F
#define M800F56DELL     0x04
#define M800F60DELL     0x08
#define M800F72DELL     0x20
#define MASK_1024_DELL  0x1F
#define M1024F87DELL    0x01
#define M1024F60DELL    0x02
#define M1024F70DELL    0x04
#define M1024F72DELL    0x08
#define MASK_1280_DELL  0xFC
#define M1280F87DELL    0x04
#define M1280F60DELL    0x10
#define M1280F70DELL    0x20
#define M1280F74DELL    0x40



/*
 * Local functions to get CRT data for specific OEM cards.
 */
VP_STATUS ReadAST(struct query_structure *query);
VP_STATUS ReadZenith(struct st_mode_table *Modes);
VP_STATUS ReadOlivetti(struct st_mode_table *Modes);
VP_STATUS ReadDell(struct st_mode_table *Modes);
ULONG DetectDell(struct query_structure *Query);
BOOL DetectSylvester(struct query_structure *Query, ULONG HeaderOffset);
VP_STATUS ReadOEM1(struct st_mode_table *Modes);
VP_STATUS ReadOEM2(struct st_mode_table *Modes);
VP_STATUS ReadOEM3(struct st_mode_table *Modes);
VP_STATUS ReadOEM4(struct st_mode_table *Modes);
VP_STATUS ReadOEM5(struct st_mode_table *Modes);



/*
 * Allow miniport to be swapped out when not needed.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_COM, OEMGetParms)
#pragma alloc_text(PAGE_COM, CompareASCIIToUnicode)
#pragma alloc_text(PAGE_COM, ReadAST)
#pragma alloc_text(PAGE_COM, ReadZenith)
#pragma alloc_text(PAGE_COM, ReadOlivetti)
#pragma alloc_text(PAGE_COM, ReadDell)
#pragma alloc_text(PAGE_COM, DetectDell)
#pragma alloc_text(PAGE_COM, DetectSylvester)
#pragma alloc_text(PAGE_COM, ReadOEM1)
#pragma alloc_text(PAGE_COM, ReadOEM2)
#pragma alloc_text(PAGE_COM, ReadOEM3)
#pragma alloc_text(PAGE_COM, ReadOEM4)
#pragma alloc_text(PAGE_COM, ReadOEM5)
#endif


/*
 * VP_STATUS OEMGetParms(query);
 *
 * struct query_structure *query;   Description of video card setup
 *
 * Routine to fill in the mode tables for an OEM version of one
 * of our video cards which lacks an EEPROM to store this data.
 *
 * Returns:
 *  NO_ERROR                if successful
 *  ERROR_DEV_NOT_EXIST     if an unknown OEM card is specified
 *  ERROR_INVALID_PARAMETER         if an error occurs
 */
VP_STATUS OEMGetParms(struct query_structure *query)
{
struct st_mode_table *pmode;    /* Mode table we are currently working on */
struct st_mode_table ListOfModes[RES_1280 - RES_640 + 1];
VP_STATUS RetVal;           /* Value returned by called functions */
short CurrentResolution;    /* Resolution we are setting up */
long NumPixels;             /* Number of pixels at current resolution */
long MemAvail;              /* Bytes of video memory available to accelerator */
UCHAR Scratch;              /* Temporary variable */
short   StartIndex;         /* First mode for SetFixedModes() to set up */
short   EndIndex;           /* Last mode for SetFixedModes() to set up */
BOOL    ModeInstalled;      /* Is this resolution configured? */
WORD    Multiplier;         /* Pixel clock multiplier */
USHORT  OEMType;            /* Which OEM accelerator we are dealing with */
ULONG   OEMInfoOffset;      /* Offset of OEM information block into the BIOS */
short MaxModes;             /* Maximum number of modes possible */
short FreeTables;            /* Number of remaining free mode tables */

    /*
     * Clear out our mode tables, then check to see which OEM card
     * we are dealing with and read its CRT parameters.
     */
    VideoPortZeroMemory(ListOfModes, (RES_1280-RES_640+1)*sizeof(struct st_mode_table));

    /*
     * Try to auto-detect the type of OEM accelerator using recognition
     * strings in the BIOS. If we can't identify the OEM in this manner,
     * or there is no BIOS, treat it as a generic OEM card.
     */
    if (query->q_bios != FALSE)
        {
        if ((OEMInfoOffset = DetectDell(query)) != 0)
            OEMType = OEM_DELL_OMNIPLEX;
        else if (*(PULONG)(query->q_bios + AST_REC_OFFSET) == AST_REC_VALUE)
            OEMType = OEM_AST_PREMMIA;
        else
            OEMType = OEM_UNKNOWN;
        }
    else
        {
        OEMType = OEM_UNKNOWN;
        }

    /*
     * The ATIOEM registry field can override the auto-detected OEM type.
     * If this field is not present, or we don't recognize the value
     * it contains, continue with the OEM type we detected in the
     * previous step.
     */
    RegistryBufferLength = 0;

    if (VideoPortGetRegistryParameters(phwDeviceExtension,
                                       L"ATIOEM",
                                       FALSE,
                                       RegistryParameterCallback,
                                       NULL) == NO_ERROR)
        {
        VideoDebugPrint((DEBUG_DETAIL, "ATIOEM field found\n"));
        if (RegistryBufferLength == 0)
            {
            VideoDebugPrint((DEBUG_DETAIL, "Registry call gave Zero Length\n"));
            }
        else if (!CompareASCIIToUnicode("AST", RegistryBuffer, CASE_INSENSITIVE))
            {
            OEMType = OEM_AST_PREMMIA;
            }
        else if (!CompareASCIIToUnicode("DELL", RegistryBuffer, CASE_INSENSITIVE))
            {
            OEMType = OEM_DELL_OMNIPLEX;
            /*
             * If the auto-detection failed, assume the Dell header
             * starts at the default location (for Sylvester/Omniplex
             * determination). If the auto-detection succeeded, but
             * the ATIOEM registry field still exists, leave this
             * value alone.
             */
            if (OEMInfoOffset == 0)
                OEMInfoOffset = DELL_REC_SPACING;
            }
        else
            {
            VideoPortLogError(phwDeviceExtension, NULL, VID_ATIOEM_UNUSED, 20);
            }
        }

    /*
     * Load the frequency table corresponding to 
     * the selected OEM type, unless it uses the
     * same frequency table as our retail clock chip.
     *
     */
    
    /*
     * Load the table for the desired OEM type.
     */
    if (OEMType == OEM_DELL_OMNIPLEX)
        {
        /*
         * On a Sylvester (more recent model than the Omniplex),
         * we must read the clock frequency table from the BIOS
         * rather than using the Omniplex table. Otherwise, the
         * two machines can be handled in the same manner.
         *
         * DetectSylvester() will load the clock frequency table
         * if it finds a Sylvester, and return without loading
         * the table if it finds a non-Sylvester machine.
         */
        if (DetectSylvester(query,OEMInfoOffset) == FALSE)
            {
            ClockGenerator[0]  =  25175000L;
            ClockGenerator[1]  =  28322000L;
            ClockGenerator[2]  =  31500000L;
            ClockGenerator[3]  =  36000000L;
            ClockGenerator[4]  =  40000000L;
            ClockGenerator[5]  =  44900000L;
            ClockGenerator[6]  =  50000000L;
            ClockGenerator[7]  =  65000000L;
            ClockGenerator[8]  =  75000000L;
            ClockGenerator[9]  =  77500000L;
            ClockGenerator[10] =  80000000L;
            ClockGenerator[11] =  90000000L;
            ClockGenerator[12] = 100000000L;
            ClockGenerator[13] = 110000000L;
            ClockGenerator[14] = 126000000L;
            ClockGenerator[15] = 135000000L;
            }
        }
    else if (OEMType == OEM_AST_PREMMIA)
        {
        ClockGenerator[0]  =  50000000L;
        ClockGenerator[1]  =  63000000L;
        ClockGenerator[2]  =  92400000L;
        ClockGenerator[3]  =  36000000L;
        ClockGenerator[4]  =  50350000L;
        ClockGenerator[5]  =  56640000L;
        ClockGenerator[6]  =         0L;
        ClockGenerator[7]  =  44900000L;
        ClockGenerator[8]  =  67500000L;
        ClockGenerator[9]  =  31500000L;
        ClockGenerator[10] =  55000000L;
        ClockGenerator[11] =  80000000L;
        ClockGenerator[12] =  39910000L;
        ClockGenerator[13] =  72000000L;
        ClockGenerator[14] =  75000000L;
        ClockGenerator[15] =  65000000L;
        }

    /*
     * else (this OEM type uses the retail frequency table)
     */


    /*
     * Checking the number of modes available would involve
     * duplicating most of the code to fill in the mode tables.
     * Since this is to determine how much memory is needed
     * to hold the query structure, we can assume the worst
     * case (all possible modes are present). This would be:
     *
     * Resolution   Pixel Depths (BPP)  Refresh rates (Hz)      Number of modes
     * 640x480      4,8,16,24           HWD,60,72               12
     * 800x600      4,8,16,24           HWD,56,60,70,72,89,95   28
     * 1024x768     4,8,16              HWD,60,66,70,72,87      18
     * 1280x1024    4,8                 HWD,60,70,74,87,95      12
     *
     * HWD = hardware default refresh rate (rate set by INSTALL)
     *
     * Total: 70 modes
     */
    if (QUERYSIZE < (70 * sizeof(struct st_mode_table) + sizeof(struct query_structure)))
        return ERROR_INSUFFICIENT_BUFFER;

    MaxModes = (QUERYSIZE - sizeof(struct query_structure)) /
                                          sizeof(struct st_mode_table); 

    /*
     * Load the configured mode tables corresponding
     * to the selected OEM type. If there is no custom monitor description,
     * and we do not recognize the OEM type, use only the predefined
     * mode tables.
     *
     */

    /*
     * Load the configured mode tables according to the OEM type
     * detected.
     * AST machines load the entire list of mode tables (all
     * pixel depths, including "canned" modes). Generic OEM
     * machines only load the "canned" modes (done later).
     */
    if (OEMType == OEM_DELL_OMNIPLEX)
        {
        RetVal = ReadDell(ListOfModes);
        }
    else if (OEMType == OEM_AST_PREMMIA)
        {
        RetVal = ReadAST(query);
        return RetVal;
        }


    /*
     * Get a pointer into the mode table section of the query structure.
     */
    pmode = (struct st_mode_table *)query;  // first mode table at end of query
    ((struct query_structure *)pmode)++;

    /*
     * Get the amount of available video memory.
     */
    MemAvail = query->q_memory_size * QUARTER_MEG;  // Total memory installed
    /*
     * Subtract the amount of memory reserved for the VGA. This only
     * applies to the Graphics Ultra, since the 8514/ULTRA has no
     * VGA, and we will set all memory as shared on the Mach 32.
    if (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA)
        MemAvail -= (query->q_VGA_boundary * QUARTER_MEG);

    /*
     * Initially assume no video modes are available.
     */
    query->q_number_modes = 0;
    query->q_status_flags = 0;

    /*
     * Fill in the mode tables section of the query structure.
     */
    for (CurrentResolution = RES_640; CurrentResolution <= RES_1280; CurrentResolution++)
        {
        /*
         * Skip over 1152x864 (new resolution for Mach 64, which
         * would require extensive re-work for Mach 32, the family
         * for which this module was written).
         */
        if (CurrentResolution == RES_1152)
            continue;

        /*
         * If this resolution is configured, indicate that there is a
         * hardware default mode. If not, only list the "canned" refresh
         * rates for this resolution.
         */
        if (!ListOfModes[CurrentResolution].m_h_total)
            ModeInstalled = FALSE;
        else
            ModeInstalled = TRUE;

        /*
         * Find the number of pixels for the current resolution.
         */
        switch (CurrentResolution)
            {
            case RES_640:
                /*
                 * On a Mach 32 with no aperture, we use a screen pitch
                 * of 1024. Other cases and Mach 32 with an aperture
                 * use a screen pitch of the number of pixels.
                 */
#if !defined (SPLIT_RASTERS)
                if((phwDeviceExtension->ModelNumber == MACH32_ULTRA)
                    && (query->q_aperture_cfg == 0))
                    ListOfModes[CurrentResolution].m_screen_pitch = 1024;
                else
#endif
                  ListOfModes[CurrentResolution].m_screen_pitch = 640;
                NumPixels = ListOfModes[CurrentResolution].m_screen_pitch * 480;
                query->q_status_flags |= VRES_640x480;
                ListOfModes[CurrentResolution].Refresh = DEFAULT_REFRESH;
                StartIndex = B640F60;
                EndIndex = B640F72;
                break;

            case RES_800:
                /*
                 * On a Mach 32 with no aperture, we use a screen pitch
                 * of 1024. Mach 32 rev. 3 and Mach 8 cards need a screen
                 * pitch which is a multiple of 128. Other cases and
                 * Mach 32 rev. 6 and higher with an aperture use a screen
                 * pitch of the number of pixels.
                 */
#if defined (SPLIT_RASTERS)
                if ((query->q_asic_rev == CI_68800_3)
#else
                if((phwDeviceExtension->ModelNumber == MACH32_ULTRA)
                    && (query->q_aperture_cfg == 0))
                    ListOfModes[CurrentResolution].m_screen_pitch = 1024;
                else if ((query->q_asic_rev == CI_68800_3)
#endif
                    || (query->q_asic_rev == CI_38800_1)
                    || (query->q_bus_type == BUS_PCI))
                    ListOfModes[CurrentResolution].m_screen_pitch = 896;
                else
                    ListOfModes[CurrentResolution].m_screen_pitch = 800;
                NumPixels = ListOfModes[CurrentResolution].m_screen_pitch * 600;
                query->q_status_flags |= VRES_800x600;
                ListOfModes[CurrentResolution].Refresh = DEFAULT_REFRESH;
                StartIndex = B800F89;
                EndIndex = B800F72;
                break;

            case RES_1024:
                ListOfModes[CurrentResolution].m_screen_pitch = 1024;
                NumPixels = ListOfModes[CurrentResolution].m_screen_pitch * 768;
                query->q_status_flags |= VRES_1024x768;
                ListOfModes[CurrentResolution].Refresh = DEFAULT_REFRESH;
                StartIndex = B1024F87;
                EndIndex = B1024F72;
                break;

            case RES_1280:
                ListOfModes[CurrentResolution].m_screen_pitch = 1280;
                NumPixels = ListOfModes[CurrentResolution].m_screen_pitch * 1024;
                query->q_status_flags |= VRES_1024x768;
                ListOfModes[CurrentResolution].Refresh = DEFAULT_REFRESH;
                StartIndex = B1280F87;
                /*
                 * 1280x1024 noninterlaced has the following restrictions:
                 *
                 * Dell machines:
                 *  VRAM supports up to 70Hz
                 *  DRAM supports up to 74Hz
                 *
                 * Other machines:
                 *  VRAM supports up to 74Hz
                 *  DRAM supports up to 60Hz
                 *
                 * This is because Dell uses faster (and more expensive)
                 * DRAM than on our retail cards (non-x86 implementations
                 * will hit this code block on retail cards), but has
                 * problems at 74Hz on their VRAM implementations. Other
                 * OEMs have not requested that their cards be treated
                 * differently from our retail cards in this respect.
                 */
                if ((query->q_memory_type == VMEM_DRAM_256Kx4) ||
                    (query->q_memory_type == VMEM_DRAM_256Kx16) ||
                    (query->q_memory_type == VMEM_DRAM_256Kx4_GRAP))
                    {
                    if (OEMType == OEM_DELL_OMNIPLEX)
                        EndIndex = B1280F74;
                    else
                        EndIndex = B1280F60;
                    }
                else
                    {
                    if (OEMType == OEM_DELL_OMNIPLEX)
                        EndIndex = B1280F70;
                    else
                        EndIndex = B1280F74;
                    }
                break;
            }

        /*
         * For each supported pixel depth at the given resolution,
         * copy the mode table, fill in the colour depth field,
         * and increment the counter for the number of supported modes.
         * Test 4BPP before 8BPP so the mode tables will appear in
         * increasing order of pixel depth.
         */
        if (NumPixels <= MemAvail*2)
            {
            if (ModeInstalled)
                {
                VideoPortMoveMemory(pmode, &ListOfModes[CurrentResolution],
                            sizeof(struct st_mode_table));
                pmode->m_pixel_depth = 4;
                pmode++;    /* ptr to next mode table */
                query->q_number_modes++;
                }

            /*
             * Add "canned" mode tables
             */

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   CLOCK_SINGLE,
                                                   4,
                                                   ListOfModes[CurrentResolution].m_screen_pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);
            }
        if (NumPixels <= MemAvail)
            {
            if (ModeInstalled)
                {
                VideoPortMoveMemory(pmode, &ListOfModes[CurrentResolution],
                                    sizeof(struct st_mode_table));
                pmode->m_pixel_depth = 8;
                pmode++;    /* ptr to next mode table */
                query->q_number_modes++;
                }

            /*
             * Add "canned" mode tables
             */

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   CLOCK_SINGLE,
                                                   8,
                                                   ListOfModes[CurrentResolution].m_screen_pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);
            }

        /*
         * Resolutions above 8BPP are only available for the Mach 32.
         */
        if (phwDeviceExtension->ModelNumber != MACH32_ULTRA)
            continue;

        /*
         * 16, 24, and 32 BPP require a DAC which can support
         * the selected pixel depth at the current resolution
         * as well as enough memory.
         */
        if ((NumPixels*2 <= MemAvail) &&
            (MaxDepth[query->q_DAC_type][CurrentResolution] >= 16))
            {
            VideoPortMoveMemory(pmode, &ListOfModes[CurrentResolution],
                    sizeof(struct st_mode_table));
            /*
             * Handle DACs that require higher pixel clocks for 16BPP.
             */
            if ((query->q_DAC_type == DAC_BT48x) ||
                (query->q_DAC_type == DAC_SC15026) ||
                (query->q_DAC_type == DAC_ATT491))
                {
                pmode->ClockFreq *= 2;
                Multiplier = CLOCK_DOUBLE;
                if (CurrentResolution == RES_800)
                    EndIndex = B800F60;     /* 70 Hz and up not supported at 16BPP */
                }
            else
                {
                Scratch = 0;
                Multiplier = CLOCK_SINGLE;
                }

            pmode->m_pixel_depth = 16;

            /*
             * If this resolution is not configured, or if we need to
             * double the clock frequency but can't, ignore the mode
             * table we just created.
             */
            if (ModeInstalled && (Scratch != 0xFF))
                {
                pmode++;    /* ptr to next mode table */
                query->q_number_modes++;
                }

            /*
             * Add "canned" mode tables
             */

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   Multiplier,
                                                   16,
                                                   ListOfModes[CurrentResolution].m_screen_pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);
            }


        /*
         * Our new source stream display driver needs a linear aperture
         * in order to handle 24BPP. Since the display driver doesn't
         * have access to the aperture information when it is deciding
         * which modes to pass on to the display applet, it can't make
         * the decision to reject 24BPP modes for cards with only a
         * VGA aperture. This decision must therefore be made in the
         * miniport, so in a paged aperture configuration there are no
         * 24BPP modes for the display driver to accept or reject.
         *
         * On the Alpha, we can't use dense space on the Mach 32 LFB,
         * so we treat it as a no-aperture case.
         */
        if (query->q_aperture_cfg == 0)
            {
            VideoDebugPrint((DEBUG_DETAIL, "24BPP not available because we don't have a linear aperture\n"));
            continue;
            }

#if defined(ALPHA)
        VideoDebugPrint((DEBUG_DETAIL, "24BPP not available in sparse space on Alpha\n"));
        continue;
#endif

        /*
         * 800x600 24BPP exhibits screen tearing unless the pitch
         * is a multiple of 128 (only applies to Rev. 6, since Rev. 3
         * and PCI implementations already have a pitch of 896).
         * Other pixel depths are not affected, and other resolutions
         * are already a multiple of 128 pixels wide.
         *
         * Expand the 800x600 pitch to 896 here, rather than for
         * all pixel depths, because making the change for all
         * pixel depths would disable 16BPP (which doesn't have
         * the problem) on 1M cards. The screen pitch will only
         * be 800 on cards which will exhibit this problem - don't
         * check for a resolution of 800x600 because we don't want
         * to cut the pitch from 1024 down to 896 if SPLIT_RASTERS
         * is not defined.
         */
        if (ListOfModes[CurrentResolution].m_screen_pitch == 800)
            {
            ListOfModes[CurrentResolution].m_screen_pitch = 896;
            NumPixels = (long) ListOfModes[CurrentResolution].m_screen_pitch * 600;
            }

        if ((NumPixels*3 <= MemAvail) &&
            (MaxDepth[query->q_DAC_type][CurrentResolution] >= 24))
            {
            VideoPortMoveMemory(pmode, &ListOfModes[CurrentResolution],
                                sizeof(struct st_mode_table));
            pmode->m_pixel_depth = 24;

            /*
             * Handle DACs that require higher pixel clocks for 24BPP.
             */
            Scratch = 0;
            if ((query->q_DAC_type == DAC_STG1700) ||
                (query->q_DAC_type == DAC_ATT498))
                {
                pmode->ClockFreq *= 2;
                Multiplier = CLOCK_DOUBLE;
                }
            else if ((query->q_DAC_type == DAC_SC15021) ||
                (query->q_DAC_type == DAC_STG1702) ||
                (query->q_DAC_type == DAC_STG1703))
                {
                pmode->ClockFreq *= 3;
                pmode->ClockFreq >>= 1;
                Multiplier = CLOCK_THREE_HALVES;
                }
            else if ((query->q_DAC_type == DAC_BT48x) ||
                (query->q_DAC_type == DAC_SC15026) ||
                (query->q_DAC_type == DAC_ATT491))
                {
                pmode->ClockFreq *= 3;
                Multiplier = CLOCK_TRIPLE;
                EndIndex = B640F60;     /* Only supports 24BPP in 640x480 60Hz */
                }
            else
                {
                Multiplier = CLOCK_SINGLE;
                if ((query->q_DAC_type == DAC_TI34075) && (CurrentResolution == RES_800))
                    EndIndex = B800F70;
                }

            /*
             * If we needed to alter the clock frequency, and couldn't
             * generate an appropriate selector/divisor pair,
             * then ignore this mode.
             */
            if (ModeInstalled && (Scratch != 0x0FF))
                {
                pmode++;    /* ptr to next mode table */
                query->q_number_modes++;
                }

            /*
             * Add "canned" mode tables
             */

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   Multiplier,
                                                   24,
                                                   ListOfModes[CurrentResolution].m_screen_pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);
            }

        }

    return NO_ERROR;

}   /* OEMGetParms() */


/*
 * LONG CompareASCIIToUnicode(Ascii, Unicode, IgnoreCase);
 *
 * PUCHAR Ascii;    ASCII string to be compared
 * PUCHAR Unicode;  Unicode string to be compared
 * BOOL IgnoreCase; Flag to determine case sensitive/insensitive comparison
 *
 * Compare 2 strings, one ASCII and the other UNICODE, to see whether
 * they are equal, and if not, which one is first in alphabetical order.
 *
 * Returns:
 *  0           if strings are equal
 *  positive    if ASCII string comes first
 *  negative    if UNICODE string comes first
 */
LONG CompareASCIIToUnicode(PUCHAR Ascii, PUCHAR Unicode, BOOL IgnoreCase)
{
UCHAR   CharA;
UCHAR   CharU;

    /*
     * Keep going until both strings have a simultaneous null terminator.
     */
    while (*Ascii || *Unicode)
        {
        /*
         * Get the next character from each string. If we are doing a
         * case-insensitive comparison, translate to upper case.
         */
        if (IgnoreCase)
            {
            if ((*Ascii >= 'a') && (*Ascii <= 'z'))
                CharA = *Ascii - ('a'-'A');
            else
                CharA = *Ascii;

            if ((*Unicode >= 'a') && (*Unicode <= 'z'))
                CharU = *Unicode - ('a' - 'A');
            else
                CharU = *Unicode;
            }
        else{
            CharA = *Ascii;
            CharU = *Unicode;
            }

        /*
         * Check if one of the characters precedes the other. This will
         * catch the case of unequal length strings, since the null
         * terminator on the shorter string will precede any character
         * in the longer string.
         */
        if (CharA < CharU)
            return 1;
        else if (CharA > CharU)
            return -1;

        /*
         * Advance to the next character in each string. Unicode strings
         * occupy 2 bytes per character, so we must check only every
         * second character.
         */
        Ascii++;
        Unicode++;
        Unicode++;
        }

    /*
     * The strings are identical and of equal length.
     */
    return 0;

}   /* CompareASCIIToUnicode() */




/*
 * VP_STATUS ReadAST(Modes);
 *
 * struct query_structure *query;   Mode tables to be filled in
 *
 * Routine to get CRT parameters for AST versions of
 * our cards. All AST cards choose from a limited selection
 * of vertical refresh rates with no "custom monitor" option,
 * so we can use hardcoded tables for each refresh rate. We
 * can't use the BookVgaTable() function, since AST cards have
 * a different clock chip from retail cards, resulting in different
 * values in the ClockSel field for AST and retail versions. Also,
 * AST cards all use the Brooktree DAC.
 *
 * Returns:
 *  NO_ERROR
 */
VP_STATUS ReadAST(struct query_structure *query)
{
struct st_mode_table *pmode;    /* Mode table we are currently working on */
struct st_mode_table *OldPmode; /* Mode table pointer before SetFixedModes() call */
unsigned char Frequency;        /* Vertical refresh rate for monitor */
long NumPixels;                 /* Number of pixels at current resolution */
USHORT Pitch;                   /* Screen pitch */
long MemAvail;                  /* Bytes of video memory available to accelerator */
USHORT LastNumModes;            /* Number of modes not including current resolution */
short StartIndex;               /* First mode for SetFixedModes() to set up */
short EndIndex;                 /* Last mode for SetFixedModes() to set up */
short HWIndex;                  /* Mode selected as hardware default */
USHORT PixelDepth;              /* Pixel depth we are working on */
#if (TARGET_BUILD >= 350)
ULONG EisaId;                   /* EISA ID of the motherboard */
#endif
short MaxModes;                 /* Maximum number of modes possible */
short FreeTables;               /* Number of remaining free mode tables */


#if (TARGET_BUILD >= 350)
    /*
     * The Premmia SE splits its aperture location between MEM_CFG and
     * SCRATCH_PAD_0, but does not set the flag bit (bit 0 of BIOS byte
     * 0x62). According to AST, the only way to distinguish this from
     * other Premmia machines is to check its EISA ID.
     *
     * The VideoPortGetBusData() routine is not available in NT 3.1,
     * so Premmia users running NT 3.1 are out of luck.
     */
    VideoPortGetBusData(phwDeviceExtension,
                        EisaConfiguration,
                        PREMMIA_SE_SLOT,
                        &EisaId,
                        EISA_ID_OFFSET,
                        sizeof(ULONG));

    if (EisaId == PREMMIA_SE_ID)
    {
        query->q_aperture_addr = (INPW(MEM_CFG) & 0x7F00) >> 8;
        query->q_aperture_addr |= ((INPW(SCRATCH_PAD_0) & 0x1F00) >> 1);
    }
#endif


    /*
     * Get the memory size in nybbles (half a byte). A 4BPP pixel
     * uses 1 nybble. For other depths, compare this number to the
     * product of the number of pixels needed and the number of
     * nybbles per pixel.
     *
     * The q_memory_size field contains the number of quarter-megabyte
     * blocks of memory available, so multiplying it by HALF_MEG yields
     * the number of nybbles of video memory.
     */
    MemAvail = query->q_memory_size * HALF_MEG;

    /*
     * Initially assume no video modes.
     */
    query->q_number_modes = 0;
    LastNumModes = 0;
    query->q_status_flags = 0;

    /*
     * Get a pointer into the mode table section of the query structure.
     */
    pmode = (struct st_mode_table *)query;  // first mode table at end of query
    ((struct query_structure *)pmode)++;


    MaxModes = (QUERYSIZE - sizeof(struct query_structure)) /
                                          sizeof(struct st_mode_table); 
    /*
     * Find out which refresh rate is used at 640x480, and fill in the
     * mode tables for the various pixel depths at this resoulution.
     */
    OUTP(reg1CE, AST_640_STORE);
    Frequency = INP(reg1CF);
    switch(Frequency)
        {
        case M640F72AST:
            HWIndex = B640F72;
            break;

        case M640F60AST:
        default:
            HWIndex = B640F60;
            break;
        }

    /*
     * Select the "canned" mode tables for 640x480, and get
     * information regarding the screen size. The Premmia always
     * has the linear aperture enabled, so we don't need to
     * stretch the pitch to 1024. Also, it always uses a
     * Mach 32 ASIC and a BT48x or equivalent DAC, so we
     * don't need to check the ASIC family or DAC type
     * to determine if a particular resolution/pixel depth/
     * refresh rate combination is supported.
     */
    StartIndex = B640F60;
    EndIndex = B640F72;
    Pitch = 640;
    NumPixels = Pitch * 480;

    /*
     * Fill in the mode tables for 640x480 at all pixel depths.
     */
    for (PixelDepth = DEPTH_4BPP; PixelDepth <= DEPTH_24BPP; PixelDepth++)
        {
        /*
         * Only include modes if there is enough memory.
         */
        if ((NumPixels * ASTNybblesPerPixel[PixelDepth]) <= MemAvail)
            {
            /*
             * 640x480 24BPP is only available at 60Hz.
             */
            if (ASTDepth[PixelDepth] == 24)
                {
                HWIndex = B640F60;
                EndIndex = B640F60;
                }

            /*
             * Set up the hardware default refresh rate.
             */
            OldPmode = pmode;

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(HWIndex,
                                                   HWIndex,
                                                   ASTClockMult[PixelDepth],
                                                   ASTDepth[PixelDepth],
                                                   Pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);
            OldPmode->Refresh = DEFAULT_REFRESH;

            /*
             * Set up the canned mode tables.
             */

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   ASTClockMult[PixelDepth],
                                                   ASTDepth[PixelDepth],
                                                   Pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);

            }   /* end if (enough memory for 640x480) */

        }   /* end for (loop on 640x480 pixel depth) */

    /*
     * If we installed any 640x480 mode tables, report that
     * 640x480 is supported.
     */
    if (query->q_number_modes > LastNumModes)
        {
        query->q_status_flags |= VRES_640x480;
        LastNumModes = query->q_number_modes;
        }


    /*
     * Find out which refresh rate is used at 800x600, and fill in the
     * mode tables for the various pixel depths at this resoulution.
     */
    OUTP(reg1CE, AST_800_STORE);
    Frequency = INP(reg1CF);
    switch(Frequency)
        {
        case M800F72AST:
            HWIndex = B800F72;
            break;

        case M800F60AST:
            HWIndex = B800F60;
            break;

        case M800F56AST:
        default:
            HWIndex = B800F56;
            break;
        }

    /*
     * Select the "canned" mode tables for 800x600, and get
     * information regarding the screen size. 68800-3 cards
     * need a screen pitch that is a multiple of 128.
     */
    StartIndex = B800F89;
    EndIndex = B800F72;
    if (query->q_asic_rev == CI_68800_3)
        Pitch = 896;
    else
        Pitch = 800;
    NumPixels = Pitch * 600;

    /*
     * Fill in the mode tables for 800x600 at all pixel depths.
     */
    for (PixelDepth = DEPTH_4BPP; PixelDepth <= DEPTH_16BPP; PixelDepth++)
        {
        /*
         * Only include modes if there is enough memory.
         */
        if ((NumPixels * ASTNybblesPerPixel[PixelDepth]) <= MemAvail)
            {
            /*
             * 800x600 16BPP is only supported for 56Hz, 60Hz,
             * and interlaced. Machines with a hardware default
             * of 72Hz fall back to 56Hz.
             */
            if (ASTDepth[PixelDepth] == 16)
                {
                HWIndex = B800F56;
                EndIndex = B800F60;
                }

            /*
             * Set up the hardware default refresh rate.
             */
            OldPmode = pmode;

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(HWIndex,
                                                   HWIndex,
                                                   ASTClockMult[PixelDepth],
                                                   ASTDepth[PixelDepth],
                                                   Pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);
            OldPmode->Refresh = DEFAULT_REFRESH;

            /*
             * Set up the canned mode tables.
             */

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   ASTClockMult[PixelDepth],
                                                   ASTDepth[PixelDepth],
                                                   Pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);

            }   /* end if (enough memory for 800x600) */

        }   /* end for (loop on 800x600 pixel depth) */

    /*
     * If we installed any 800x600 mode tables, report that
     * 800x600 is supported.
     */
    if (query->q_number_modes > LastNumModes)
        {
        query->q_status_flags |= VRES_800x600;
        LastNumModes = query->q_number_modes;
        }


    /*
     * Find out which refresh rate is used at 1024x768, and fill in the
     * mode tables for the various pixel depths at this resoulution.
     */
    OUTP(reg1CE, AST_1024_STORE);
    Frequency = INP(reg1CF);
    switch(Frequency)
        {
        case M1024F72AST:
            HWIndex = B1024F72;
            break;

        case M1024F70AST:
            HWIndex = B1024F70;
            break;

        case M1024F60AST:
            HWIndex = B1024F60;
            break;

        case M1024F87AST:
        default:
            HWIndex = B1024F87;
            break;
        }

    /*
     * Select the "canned" mode tables for 1024x768.
     */
    StartIndex = B1024F87;
    EndIndex = B1024F72;
    Pitch = 1024;
    NumPixels = Pitch * 768;

    /*
     * Fill in the mode tables for 1024x768 at all pixel depths.
     */
    for (PixelDepth = DEPTH_4BPP; PixelDepth <= DEPTH_8BPP; PixelDepth++)
        {
        /*
         * Only include modes if there is enough memory.
         */
        if ((NumPixels * ASTNybblesPerPixel[PixelDepth]) <= MemAvail)
            {
            /*
             * Set up the hardware default refresh rate.
             */
            OldPmode = pmode;

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(HWIndex,
                                                   HWIndex,
                                                   ASTClockMult[PixelDepth],
                                                   ASTDepth[PixelDepth],
                                                   Pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);
            OldPmode->Refresh = DEFAULT_REFRESH;

            /*
             * Set up the canned mode tables.
             */

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   ASTClockMult[PixelDepth],
                                                   ASTDepth[PixelDepth],
                                                   Pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);

            }   /* end if (enough memory for 1024x768) */

        }   /* end for (loop on 1024x768 pixel depth) */

    /*
     * If we installed any 1024x768 mode tables, report that
     * 1024x768 is supported.
     */
    if (query->q_number_modes > LastNumModes)
        {
        query->q_status_flags |= VRES_1024x768;
        LastNumModes = query->q_number_modes;
        }


    /*
     * Select the "canned" mode tables for 1280x1024.
     *
     * The DACs used on AST Premmia machines only support
     * interlaced modes at this resolution, and there
     * is no configured hardware default refresh rate.
     */
    StartIndex = B1280F87;
    EndIndex = B1280F95;
    Pitch = 1280;
    NumPixels = Pitch * 1024;

    /*
     * Fill in the mode tables for 1280x1024 at all pixel depths.
     */
    for (PixelDepth = DEPTH_4BPP; PixelDepth <= DEPTH_8BPP; PixelDepth++)
        {
        /*
         * Only include modes if there is enough memory.
         */
        if ((NumPixels * ASTNybblesPerPixel[PixelDepth]) <= MemAvail)
            {
            /*
             * Set up the canned mode tables.
             */

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   ASTClockMult[PixelDepth],
                                                   ASTDepth[PixelDepth],
                                                   Pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);

            }   /* end if (enough memory for 1280x1024) */

        }   /* end for (loop on 1280x1024 pixel depth) */

    /*
     * If we installed any 1280x1024 mode tables, report that
     * 1280x1024 is supported.
     */
    if (query->q_number_modes > LastNumModes)
        query->q_status_flags |= VRES_1280x1024;

    return NO_ERROR;

}   /* ReadAST() */


/*
 * VP_STATUS ReadZenith(, Modes);
 *
 * struct st_mode_table *Modes; Mode tables to be filled in
 *
 * Routine to get CRT parameters for Zenith versions of
 * our cards. Mapped to NEC 3D or compatible until we get
 * info on how to read the actual parameters.
 *
 * Returns:
 *  NO_ERROR
 */
VP_STATUS ReadZenith(struct st_mode_table *Modes)
{
    ReadOEM3(Modes);
    return NO_ERROR;

}


/*
 * VP_STATUS ReadOlivetti(Modes);
 *
 * struct st_mode_table *Modes; Mode tables to be filled in
 *
 * Routine to get CRT parameters for Olivetti versions of
 * our cards. Mapped to NEC 3D or compatible until we get
 * info on how to read the actual parameters.
 *
 * Returns:
 *  NO_ERROR
 */
VP_STATUS ReadOlivetti(struct st_mode_table *Modes)
{
    ReadOEM3(Modes);
    return NO_ERROR;
}



/***************************************************************************
 *
 * VP_STATUS ReadDell(Modes);
 *
 * struct st_mode_table *Modes; Mode table to be filled in
 *
 * DESCRIPTION:
 *  Routine to get CRT parameters for Dell versions of our cards.
 *
 * RETURN VALUE:
 *  NO_ERROR
 *
 * GLOBALS CHANGED:
 *  ClockGenerator[] array
 *
 * CALLED BY:
 *  OEMGetParms()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS ReadDell(struct st_mode_table *Modes)
{
struct st_mode_table *pmode;    /* Mode table we are currently working on */
UCHAR Fubar;                    // Temporary variable

    pmode = Modes;

    /*
     * Get the 640x480 mode table.
     *
     * NOTE: Modes points to an array of 4 mode tables, one for each
     *       resolution. If a resolution is not configured, its
     *       mode table is left empty.
     */
    OUTP(reg1CE, DELL_640_STORE);
    Fubar = INP(reg1CF);
    VideoDebugPrint((DEBUG_DETAIL, "Dell 640x480: 0x1CF reports 0x%X\n", Fubar));
    switch(Fubar & MASK_640_DELL)
        {
        case M640F72DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 640x480: 72Hz\n"));
            BookVgaTable(B640F72, pmode);
            break;

        case M640F60DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 640x480: 60Hz explicit\n"));
        default:                /* All VGA monitors support 640x480 60Hz */
            VideoDebugPrint((DEBUG_DETAIL, "Dell 640x480: 60Hz\n"));
            BookVgaTable(B640F60, pmode);
            break;
        }
    pmode++;

    /*
     * Get the 800x600 mode table.
     */
    OUTP(reg1CE, DELL_800_STORE);
    Fubar = INP(reg1CF);
    VideoDebugPrint((DEBUG_DETAIL, "Dell 800x600: 0x1CF reports 0x%X\n", Fubar));
    switch(Fubar & MASK_800_DELL)
        {
        case M800F72DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 800x600: 72Hz\n"));
            BookVgaTable(B800F72, pmode);
            break;

        case M800F60DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 800x600: 60Hz\n"));
            BookVgaTable(B800F60, pmode);
            break;

        case M800F56DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 800x600: 56Hz explicit\n"));
        default:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 800x600: 56Hz\n"));
            BookVgaTable(B800F56, pmode);
            break;
        }
    pmode++;

    /*
     * Get the 1024x768 mode table.
     */
    OUTP(reg1CE, DELL_1024_STORE);
    Fubar = INP(reg1CF);
    VideoDebugPrint((DEBUG_DETAIL, "Dell 1024x768: 0x1CF reports 0x%X\n", Fubar));
    switch(Fubar & MASK_1024_DELL)
        {
        case M1024F72DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 1024x768: 72Hz\n"));
            BookVgaTable(B1024F72, pmode);
            break;

        case M1024F70DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 1024x768: 70Hz\n"));
            BookVgaTable(B1024F70, pmode);
            break;

        case M1024F60DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 1024x768: 60Hz\n"));
            BookVgaTable(B1024F60, pmode);
            break;

        case M1024F87DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 1024x768: 87Hz interlaced explicit\n"));
        default:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 1024x768: 87Hz interlaced\n"));
            BookVgaTable(B1024F87, pmode);
            break;
        }
    pmode++;

    /*
     * Skip 1152x864. This mode is not used on Mach 32 cards, and
     * this routine is only called for Mach 32 cards.
     */
    pmode++;

    /*
     * Get the 1280x1024 mode table.
     */
    OUTP(reg1CE, DELL_1280_STORE);
    Fubar = INP(reg1CF);
    VideoDebugPrint((DEBUG_DETAIL, "Dell 1280x1024: 0x1CF reports 0x%X\n", Fubar));
    switch(Fubar & MASK_1280_DELL)
        {
        case M1280F74DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 1280x1024: 74Hz\n"));
            BookVgaTable(B1280F74, pmode);
            break;

        case M1280F70DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 1280x1024: 70Hz\n"));
            BookVgaTable(B1280F70, pmode);
            break;

        case M1280F60DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 1280x1024: 60Hz\n"));
            BookVgaTable(B1280F60, pmode);
            break;

        case M1280F87DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 1280x1024: 87Hz interlaced explicit\n"));
        default:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 1280x1024: 87Hz interlaced\n"));
            BookVgaTable(B1280F87, pmode);
            break;
        }

    return NO_ERROR;

}   /* ReadDell() */



/***************************************************************************
 *
 * ULONG DetectDell(Query);
 *
 * struct query_structure *Query;   Description of video card setup
 *
 * DESCRIPTION:
 *  Routine to check whether or not we are dealing with a Dell machine.
 *
 * RETURN VALUE:
 *  Offset of beginning of the Dell information block into the BIOS
 *  0 if this is not a Dell OEM implementation.
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  OEMGetParms()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

ULONG DetectDell(struct query_structure *Query)
{
    ULONG CurrentOffset;    /* Current offset to check for Dell signature */
    ULONG BiosLength;       /* Length of the video BIOS */

    /*
     * Dell OEM implementations will have an information block
     * starting at an offset that is a multiple of DELL_REC_SPACING
     * into the video BIOS. The first 4 bytes of this block will
     * contain the signature value DELL_REC_VALUE. Find out how
     * large the video BIOS is, and step through it checking for
     * the signature string. If we reach the end of the video
     * BIOS without finding the signature string, this is not
     * a Dell OEM implementation.
     */
    BiosLength = (ULONG)(VideoPortReadRegisterUchar(Query->q_bios + 2)) * 512;

    for(CurrentOffset = DELL_REC_SPACING; CurrentOffset < BiosLength; CurrentOffset += DELL_REC_SPACING)
        {
        if (VideoPortReadRegisterUlong((PULONG)(Query->q_bios + CurrentOffset)) == DELL_REC_VALUE)
            return CurrentOffset;
        }

    /*
     * Signature string not found, so this is not a Dell OEM implementation.
     */
    return 0;

}   /* DetectDell() */



/***************************************************************************
 *
 * BOOL DetectSylvester(Query, HeaderOffset);
 *
 * struct query_structure *Query;   Description of video card setup
 * ULONG HeaderOffset;              Offset of Dell header into video BIOS
 *
 * DESCRIPTION:
 *  Routine to check whether or not the Dell machine we are dealing
 *  with is a Sylvester (table of pixel clock frequencies is stored
 *  in BIOS image, rather than using a fixed table). If it is a
 *  Sylvester, load the table of clock frequencies.
 *
 * RETURN VALUE:
 *  TRUE if this is a Sylvester
 *  FALSE if this is not a Sylvester
 *
 * GLOBALS CHANGED:
 *  ClockGenerator[]
 *
 * CALLED BY:
 *  OEMGetParms()
 *
 * NOTE:
 *  Assumes that this is a Dell OEM implementation. Results are undefined
 *  when run on other systems.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

BOOL DetectSylvester(struct query_structure *Query, ULONG HeaderOffset)
{
    PUSHORT TablePointer;   /* Pointer to the clock table in the BIOS */
    USHORT Scratch;         /* Temporary variable */

    /*
     * Dell machines which store the clock table in the BIOS have
     * the signature DELL_TABLE_PRESENT at offset DELL_TP_OFFSET
     * into the video information table (which starts at offset
     * HeaderOffset into the BIOS). Older implementations (i.e.
     * the Omniplex) use a fixed frequency table, and do not have
     * this signature string.
     */
    if (VideoPortReadRegisterUshort((PUSHORT)(Query->q_bios + HeaderOffset + DELL_TP_OFFSET)) != DELL_TABLE_PRESENT)
        return FALSE;

    /*
     * This is a Sylvester. The offset of the frequency table into the
     * BIOS is stored at offset DELL_TABLE_OFFSET into the video
     * information table.
     */
    TablePointer = (PUSHORT)(Query->q_bios + VideoPortReadRegisterUshort((PUSHORT)(Query->q_bios + HeaderOffset + DELL_TABLE_OFFSET)));

    /*
     * The frequency table has a 4-byte header. The first 2 bytes are
     * the signature string DELL_TABLE_SIG - if this signature is not
     * present, assume that the DELL_TABLE_PRESENT string was actually
     * other data that happened to match, and treat this as an older
     * implementation.
     *
     * The last 2 bytes are the table type. Currently, only table type
     * 1 (16 entries, each is a word specifying the pixel clock frequency
     * in units of 10 kHz) is supported. Treat other table types as an
     * older implementation.
     */
    if (VideoPortReadRegisterUshort(TablePointer++) != DELL_TABLE_SIG)
        return FALSE;
    if (VideoPortReadRegisterUshort(TablePointer++) != 1)
        return FALSE;

    /*
     * We have found a valid frequency table. Load its contents into
     * our frequency table. The multiplication is because the table
     * in the BIOS is in units of 10 kHz, and our table is in Hz.
     */
    for (Scratch = 0; Scratch < 16; Scratch++)
        {
        ClockGenerator[Scratch] = VideoPortReadRegisterUshort(TablePointer++) * 10000L;
        }

    return TRUE;

}   /* DetectSylvester() */




/*
 * VP_STATUS ReadOEM1(Modes);
 *
 * struct st_mode_table *Modes; Mode tables to be filled in
 *
 * Generic OEM monitor for future use.
 *
 * Resolutions supported:
 *  640x480 60Hz noninterlaced
 *
 *  (straight VGA monitor)
 *
 * Returns:
 *  NO_ERROR
 */
VP_STATUS ReadOEM1(struct st_mode_table *Modes)
{
    BookVgaTable(B640F60, &(Modes[RES_640]));
    return NO_ERROR;
}


/*
 * VP_STATUS ReadOEM2(Modes);
 *
 * struct st_mode_table *Modes; Mode tables to be filled in
 *
 * Generic OEM monitor for future use.
 *
 * Resolutions supported:
 *  640x480 60Hz noninterlaced
 *  1024x768 87Hz interlaced
 *
 *  (8514-compatible monitor)
 *
 * Returns:
 *  NO_ERROR
 */
VP_STATUS ReadOEM2(struct st_mode_table *Modes)
{
    BookVgaTable(B640F60, &(Modes[RES_640]));
    BookVgaTable(B1024F87, &(Modes[RES_1024]));
    return NO_ERROR;
}


/*
 * VP_STATUS ReadOEM3(Modes);
 *
 * struct st_mode_table *Modes; Mode tables to be filled in
 *
 * Generic OEM monitor for future use.
 *
 * Resolutions supported:
 *  640x480 60Hz noninterlaced
 *  800x600 56Hz noninterlaced
 *  1024x768 87Hz interlaced
 *
 *  (NEC 3D or compatible)
 *
 * Returns:
 *  NO_ERROR
 */
VP_STATUS ReadOEM3(struct st_mode_table *Modes)
{
    BookVgaTable(B640F60, &(Modes[RES_640]));
    BookVgaTable(B800F56, &(Modes[RES_800]));
    BookVgaTable(B1024F87, &(Modes[RES_1024]));
    return NO_ERROR;
}


/*
 * VP_STATUS ReadOEM4(Modes);
 *
 * struct st_mode_table *Modes; Mode tables to be filled in
 *
 * Generic OEM monitor for future use.
 *
 * Resolutions supported:
 *  640x480 60Hz noninterlaced
 *  800x600 72Hz noninterlaced
 *  1024x768 60Hz noninterlaced
 *  1280x1024 87Hz interlaced
 *
 *  (TVM MediaScan 4A+ or compatible)
 *
 * Returns:
 *  NO_ERROR
 */
VP_STATUS ReadOEM4(struct st_mode_table *Modes)
{
    BookVgaTable(B640F60, &(Modes[RES_640]));
    BookVgaTable(B800F72, &(Modes[RES_800]));
    BookVgaTable(B1024F60, &(Modes[RES_1024]));
    BookVgaTable(B1280F87, &(Modes[RES_1280]));
    return NO_ERROR;
}


/*
 * VP_STATUS ReadOEM5(Modes);
 *
 * struct st_mode_table *Modes; Mode tables to be filled in
 *
 * Generic OEM monitor for future use.
 *
 * Resolutions supported:
 *  640x480 60Hz noninterlaced
 *  800x600 72Hz noninterlaced
 *  1024x768 72Hz noninterlaced
 *  1280x1024 60Hz noninterlaced
 *
 *  (NEC 5FG or compatible)
 *
 * Returns:
 *  NO_ERROR
 */
VP_STATUS ReadOEM5(struct st_mode_table *Modes)
{
    BookVgaTable(B640F60, &(Modes[RES_640]));
    BookVgaTable(B800F72, &(Modes[RES_800]));
    BookVgaTable(B1024F72, &(Modes[RES_1024]));
    BookVgaTable(B1280F60, &(Modes[RES_1280]));
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\cvtddc.h ===
/************************************************************************/
/*                                                                      */
/*                              CVTDDC.H                                */
/*                                                                      */
/*       November 10  1995 (c) 1995 ATI Technologies Incorporated.      */
/************************************************************************/

/**********************       PolyTron RCS Utilities

  $Revision:   1.0  $
      $Date:   21 Nov 1995 11:04:58  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/cvtddc.h_v  $
//
//   Rev 1.0   21 Nov 1995 11:04:58   RWolff
//Initial revision.


End of PolyTron RCS section                             *****************/



/*
 * Prototypes for functions supplied by CVTVDIF.C
 */
extern ULONG IsDDCSupported(void);
extern VP_STATUS MergeEDIDTables(void);


/*
 * Definitions used to identify the type of external mode
 * table source to be merged with the "canned" tables.
 */
enum {
    MERGE_UNKNOWN = 0,  /* Source not yet determined */
    MERGE_VDIF_FILE,    /* Source is a VDIF file read from disk */
    MERGE_EDID_DDC,     /* Source is an EDID structure transferred via DDC */
    MERGE_VDIF_DDC      /* Source is a VDIF file transferred via DDC */
    };

/*
 * Definitions and data structures used only within CVTDDC.C
 */
/*
 * Detailed timing description from EDID structure
 */
#pragma pack(1)
struct EdidDetailTiming{
    USHORT PixClock;            /* Pixel clock in units of 10 kHz */
    UCHAR HorActiveLowByte;     /* Low byte of Horizontal Active */
    UCHAR HorBlankLowByte;      /* Low byte of Horizontal Blank (total - active) */
    UCHAR HorHighNybbles;       /* High nybbles of above 2 values */
    UCHAR VerActiveLowByte;     /* Low byte of Vertical Active */
    UCHAR VerBlankLowByte;      /* Low byte of Vertical Blank (total - active) */
    UCHAR VerHighNybbles;       /* High nybbles of above 2 values */
    UCHAR HSyncOffsetLB;        /* Low byte of hor. sync offset */
    UCHAR HSyncWidthLB;         /* Low byte of hor. sync width */
    UCHAR VSyncOffWidLN;        /* Low nybbles of ver. sync offset and width */
    UCHAR SyncHighBits;         /* High bits of sync values */
    UCHAR HorSizeLowByte;       /* Low byte of hor. size in mm */
    UCHAR VerSizeLowByte;       /* Low byte of ver. size in mm */
    UCHAR SizeHighNybbles;      /* High nybbles of above 2 values */
    UCHAR HorBorder;            /* Size of horizontal overscan */
    UCHAR VerBorder;            /* Size of vertical overscan */
    UCHAR Flags;                /* Interlace and sync polarities */
};
#pragma pack()

ULONG
DDC2Query(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    PUCHAR QueryBuffer,
    USHORT BufferSize
    );

BOOLEAN
DDC2Query50(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    PUCHAR QueryBuffer,
    ULONG  BufferSize
    );

#define EDID_FLAGS_INTERLACE            0x80
#define EDID_FLAGS_SYNC_TYPE_MASK       0x18
#define EDID_FLAGS_SYNC_ANALOG_COMP     0x00
#define EDID_FLAGS_SYNC_BIPOLAR_AN_COMP 0x08
#define EDID_FLAGS_SYNC_DIGITAL_COMP    0x10
#define EDID_FLAGS_SYNC_DIGITAL_SEP     0x18
#define EDID_FLAGS_V_SYNC_POS           0x04
#define EDID_FLAGS_H_SYNC_POS           0x02
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\cvtddc.c ===
/************************************************************************/
/*                                                                      */
/*                              CVTDDC.C                                */
/*                                                                      */
/*       November 10 1995 (c) 1995 ATI Technologies Incorporated.       */
/************************************************************************/

/**********************       PolyTron RCS Utilities

  $Revision:   1.5  $
      $Date:   10 Apr 1996 16:58:22  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/cvtddc.c_v  $
//
//   Rev 1.5   10 Apr 1996 16:58:22   RWolff
//Temorarily treats all cards as non-DDC to avoid system hang due to
//conflict over system timer registers. Final solution is to make DDC
//query in the miniport, using the StallExecution function, rather than
//calling the BIOS function which can hang the machine.
//
//   Rev 1.4   01 Mar 1996 12:13:28   RWolff
//Now saves and restores the portion of video memory used as
//a buffer to hold data returned by the DDC query call.
//
//   Rev 1.3   02 Feb 1996 17:15:44   RWolff
//Now gets DDC/VDIF merge source information from hardware device
//extension rather than storing it in static variables, moved code to
//obtain a buffer in VGA memory to a separate routine.
//
//   Rev 1.2   29 Jan 1996 16:54:40   RWolff
//Now uses VideoPortInt10() rather than no-BIOS code on PPC.
//
//   Rev 1.1   11 Jan 1996 19:37:44   RWolff
//Now restricts "canned" mode tables by both maximum index and maximum
//pixel clock frequency, and EDID mode tables by maximum pixel clock
//frequency only, rather than both by maximum refresh rate.
//
//   Rev 1.0   21 Nov 1995 11:04:38   RWolff
//Initial revision.


End of PolyTron RCS section                             *****************/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <math.h>

#include "dderror.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"      /* for VP_STATUS definition */

#include "stdtyp.h"
#include "amachcx.h"
#include "amach1.h"
#include "atimp.h"
#include "cvtvga.h"
#include "services.h"
#include "vdptocrt.h"
#include "cvtvdif.h"
#define INCLUDE_CVTDDC
#include "cvtddc.h"


/*
 * Allow miniport to be swapped out when not needed.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_CX, IsDDCSupported)
#pragma alloc_text(PAGE_DDC, MergeEDIDTables)
#endif



/*****************************************************************************
 *
 * ULONG IsDDCSupported(void);
 *
 * DESCRIPTION:
 *  Reports the degree of DDC support for the available monitor/graphics
 *  card combination.
 *
 * RETURN VALUE:
 *  MERGE_EDID_DDC  if DDC can return EDID data structures
 *  MERGE_VDIF_FILE if no monitor data available from DDC
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  SetFixedModes()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

ULONG IsDDCSupported(void)
{
    VIDEO_X86_BIOS_ARGUMENTS Registers; /* Used in VideoPortInt10() calls */
    VP_STATUS RetVal;                   /* Status returned by VideoPortInt10() */
    ULONG MergeSource;                  /* Source of mode tables to merge with "canned" tables */

    VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
    Registers.Eax = BIOS_DDC_SUPPORT;
    Registers.Ebx = 0;
    if ((RetVal = VideoPortInt10(phwDeviceExtension, &Registers)) != NO_ERROR)
        /*
         * If we can't find out DDC status from the BIOS,
         * assume DDC is not supported.
         */
        {
        VideoDebugPrint((DEBUG_ERROR, "Error querying DDC status, assume it's not supported\n"));
        MergeSource = MERGE_VDIF_FILE;
        }
    else
        {
#if 0
        /*
         * Workaround: Our BIOS call to obtain the DDC information uses
         * the system timer (0x40/0x43) registers, which (according to
         * Microsoft) the video BIOS is not supposed to touch. This
         * causes some machines to hang during the DDC query. Until
         * we can bring the DDC query into the miniport (using approved
         * time delay routines), report that this card doesn't support
         * DDC.
         */
        if ((Registers.Eax & 0x00000002) && (Registers.Ebx & 0x00000002))
            {
            /*
             * DDC2 supported by both BIOS and monitor. Check separately
             * for DDC1 and DDC2 in case we decide to handle them
             * differently in future.
             */
            VideoDebugPrint((DEBUG_NORMAL, "DDC2 supported\n"));
            MergeSource = MERGE_EDID_DDC;
            }
        else if ((Registers.Eax & 0x00000001) && (Registers.Ebx & 0x00000001))
            {
            /*
             * DDC1 supported by both BIOS and monitor.
             */
            VideoDebugPrint((DEBUG_NORMAL, "DDC1 supported\n"));
            MergeSource = MERGE_EDID_DDC;
            }
        else
            {
            /*
             * Either the BIOS or the monitor does not support DDC.
             */
            VideoDebugPrint((DEBUG_NORMAL, "DDC not supported\n"));
            MergeSource = MERGE_VDIF_FILE;
            }
#else
        MergeSource = MERGE_VDIF_FILE;
#endif
        }

    return MergeSource;

}   /* IsDDCSupported() */



/*****************************************************************************
 *
 * VP_STATUS MergeEDIDTables(void);
 *
 * DESCRIPTION:
 *  Merges canned mode tables from BookValues[] with tables found in an
 *  EDID structure retrieved via DDC. Global pointer variable pCallbackArgs
 *  is used to point to a structure that passes data in both directions
 *  between this function and SetFixedModes(). For details on input and
 *  output data see definition of stVDIFCallbackData structure. 
 *
 * RETURN VALUE:
 *  NO_ERROR if tables retrieved correctly
 *  ERROR_INVALID_PARAMETER if unable to retrieve data via DDC
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  SetFixedModes()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS MergeEDIDTables(void)
{
    VIDEO_X86_BIOS_ARGUMENTS Registers; /* Used in VideoPortInt10() calls */
    VP_STATUS RetVal;                   /* Status returned by VideoPortInt10() */
    ULONG BufferSeg;                    /* Segment to use for buffer */
    ULONG BufferSize = 128;             /* EDID structure is 128 bytes long */
    PUCHAR MappedBuffer;                /* Pointer to buffer used for BIOS query */
    static UCHAR FixedBuffer[128];      /* Buffer used to avoid repeated BIOS queries */
    struct EdidDetailTiming *EdidPtr;   /* Used in extracting information from buffer */
    ULONG DetailOffset;                 /* Offset of detailed timing into EDID structure */
    ULONG Scratch;                      /* Temporary variable */
    struct stVDIFCallbackData *pArgs;   /* Pointer to arguments structure */
    struct st_mode_table BuildTbl;      /* Mode table being built */
    struct st_mode_table LiveTables[4]; /* Tables already extracted */
    USHORT NumTablesFound = 0;          /* Number of valid entries in LiveTables[] */
    USHORT NumLowerTables;              /* Number of tables with a lower refresh rate than BuildTbl */
    USHORT HorTotal;                    /* Horizontal total */
    USHORT VerTotal;                    /* Vertical total */
    USHORT SyncStrt;                    /* Sync start */
    USHORT HighBound;                   /* Highest frame rate to look for */
    UCHAR SavedScreen[128];             /* Data saved from screen buffer used for DDC query */


    pArgs = pCallbackArgs;

    /*
     * If we haven't already retrieved the EDID information into local
     * storage, do it now.
     */
    if (phwDeviceExtension->EdidChecksum == 0)
        {
        MappedBuffer = GetVgaBuffer(BufferSize, 0x500, &BufferSeg, SavedScreen);

        /*
         * We now have a buffer big enough to hold the EDID structure,
         * so make the BIOS call to fill it in.
         */
        VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

        Registers.Eax = BIOS_DDC_SUPPORT;
        Registers.Ebx = 1;
        Registers.Ecx = BufferSize;
        Registers.Edx = BufferSeg;
        Registers.Edi = 0;
        if ((RetVal = VideoPortInt10(phwDeviceExtension, &Registers)) != NO_ERROR)

            {
            VideoDebugPrint((DEBUG_ERROR, "MergeEDIDTables() - failed BIOS_DDC_SUPPORT call\n"));
            VideoPortFreeDeviceBase(phwDeviceExtension, MappedBuffer);
            return RetVal;
            }

        /*
         * Copy the EDID structure into local storage, then restore
         * the contents of the buffer we used for the DDC query.
         */
        for (Scratch = 0; Scratch < 128; Scratch++)
            {
            FixedBuffer[Scratch] = VideoPortReadRegisterUchar(&(MappedBuffer[Scratch]));
            phwDeviceExtension->EdidChecksum += FixedBuffer[Scratch];
            VideoPortWriteRegisterUchar(&(MappedBuffer[Scratch]), SavedScreen[Scratch]);
            }

        /*
         * Check if we have a valid EDID header. If we don't, then
         * we can't extract EDID information. Occasionally, a
         * monitor hooked up to a switchbox will return corrupt
         * EDID data.
         */
        if ((FixedBuffer[0] != 0) ||
            (FixedBuffer[1] != 0xFF) ||
            (FixedBuffer[2] != 0xFF) ||
            (FixedBuffer[3] != 0xFF) ||
            (FixedBuffer[4] != 0xFF) ||
            (FixedBuffer[5] != 0xFF) ||
            (FixedBuffer[6] != 0xFF) ||
            (FixedBuffer[7] != 0))
            {
            VideoDebugPrint((DEBUG_ERROR, "Invalid EDID header\n"));
            return ERROR_INVALID_PARAMETER;
            }

        /*
         * We now have the EDID structure in local storage, so we can free
         * the buffer we collected it into. If the lower 8 bits of the
         * checksum are nonzero, the structure is invalid.
         */
        VideoPortFreeDeviceBase(phwDeviceExtension, MappedBuffer);
        if ((phwDeviceExtension->EdidChecksum & 0x000000FF) != 0)
            {
            VideoDebugPrint((DEBUG_ERROR, "MergeEDIDTables() - invalid checksum 0x%X\n", phwDeviceExtension->EdidChecksum));
            return ERROR_INVALID_PARAMETER;
            }
        }   /* endif (phwDeviceExtension->EdidChecksum == 0) */

    /*
     * There are 4 detailed timing blocks in the EDID structure. Read
     * each of them in turn.
     */
    for (DetailOffset = 54; DetailOffset <= 108; DetailOffset += 18)
        {
        ((PUCHAR)EdidPtr) = FixedBuffer + DetailOffset;

        /*
         * Initially check only the horizontal and vertical
         * resolution. If they don't match the resolution we
         * are working on, skip to the next detailed timing block.
         */
        BuildTbl.m_x_size = ((EdidPtr->HorHighNybbles & 0xF0) << 4) | EdidPtr->HorActiveLowByte;
        BuildTbl.m_y_size = ((EdidPtr->VerHighNybbles & 0xF0) << 4) | EdidPtr->VerActiveLowByte;

        if ((BuildTbl.m_x_size != pArgs->HorRes) || (BuildTbl.m_y_size != pArgs->VerRes))
            {
            VideoDebugPrint((DEBUG_DETAIL, "EDID mode %dx%d doesn't match desired mode %dx%d, skipping\n",
                BuildTbl.m_x_size, BuildTbl.m_y_size, pArgs->HorRes, pArgs->VerRes));
            continue;
            }

        /*
         * The table we are looking at matches the resolution we are
         * working on. Fill in the remaining parameters.
         */
        BuildTbl.m_h_disp = (UCHAR)(BuildTbl.m_x_size / 8 - 1);
        BuildTbl.m_v_disp = (short) normal_to_skip2((long)(BuildTbl.m_y_size - 1));

        BuildTbl.ClockFreq = (ULONG)(EdidPtr->PixClock) * 10000L;

        /*
         * If the pixel clock frequency for this mode is greater than
         * the maximum pixel clock frequency the graphics card supports
         * for the current resolution and pixel depth (this routine deals
         * with only one resolution/pixel depth combination at a time,
         * so our limiting pixel clock rate will always be for the current
         * resolution/pixel depth combination), we can't use this mode.
         */
        if (BuildTbl.ClockFreq > pArgs->MaxDotClock)
            {
            VideoDebugPrint((DEBUG_NORMAL, "Skipping table because pixel clock rate is too high\n"));
            continue;
            }

        HorTotal = ((EdidPtr->HorHighNybbles & 0x0F) << 8) | EdidPtr->HorBlankLowByte;
        HorTotal += BuildTbl.m_x_size;
        BuildTbl.m_h_total = (UCHAR)(HorTotal / 8 - 1);

        VerTotal = ((EdidPtr->VerHighNybbles & 0x0F) << 8) | EdidPtr->VerBlankLowByte;
        VerTotal += BuildTbl.m_y_size;
        BuildTbl.m_v_total = (short) normal_to_skip2((long)(VerTotal - 1));

        SyncStrt = ((EdidPtr->SyncHighBits & 0xC0) << 2) | EdidPtr->HSyncOffsetLB;
        SyncStrt += BuildTbl.m_x_size;
        BuildTbl.m_h_sync_strt = (UCHAR)(SyncStrt / 8 - 1);

        SyncStrt = ((EdidPtr->SyncHighBits & 0x0C) << 2) | ((EdidPtr->VSyncOffWidLN & 0xF0) >> 4);
        SyncStrt += BuildTbl.m_y_size;
        BuildTbl.m_v_sync_strt = (short) normal_to_skip2((long)(SyncStrt - 1));

        /*
         * We only support digital separate sync monitors.
         */
        if ((EdidPtr->Flags & EDID_FLAGS_SYNC_TYPE_MASK) != EDID_FLAGS_SYNC_DIGITAL_SEP)
            {
            VideoDebugPrint((DEBUG_NORMAL, "Skipping table due to wrong sync type\n"));
            continue;
            }

        Scratch = ((EdidPtr->SyncHighBits & 0x30) << 4) | EdidPtr->HSyncWidthLB;
        if (!(EdidPtr->Flags & EDID_FLAGS_H_SYNC_POS))
            Scratch |= 0x20;
        BuildTbl.m_h_sync_wid = (UCHAR)Scratch;

        Scratch = ((EdidPtr->SyncHighBits & 0x03) << 4) | (EdidPtr->VSyncOffWidLN & 0x0F);
        if (!(EdidPtr->Flags & EDID_FLAGS_V_SYNC_POS))
            Scratch |= 0x20;
        BuildTbl.m_v_sync_wid = (UCHAR)Scratch;

        BuildTbl.m_status_flags = 0;
        BuildTbl.m_vfifo_16 = 8;
        BuildTbl.m_vfifo_24 = 8;
        BuildTbl.m_clock_select = 0x800;

        BuildTbl.m_h_overscan = 0;
        BuildTbl.m_v_overscan = 0;
        BuildTbl.m_overscan_8b = 0;
        BuildTbl.m_overscan_gr = 0;

        if (EdidPtr->Flags & EDID_FLAGS_INTERLACE)
            BuildTbl.m_disp_cntl = 0x33;
        else
            BuildTbl.m_disp_cntl = 0x23;

        /*
         * The EDID detailed timing tables don't include the refresh
         * rate. In our VDIF to monitor timings routines, we obtain
         * the horizontal and vertical totals from the equations
         *
         * Htot = PixClk/HorFreq
         * Vtot = HorFreq/FrameRate
         *
         * These equations can be rearranged to
         *
         * HorFreq = PixClk/Htot
         * FrameRate = HorFreq/Vtot = (PixClk/Htot)/Vtot = PixClk/(Htot*Vtot)
         *
         * The multiplication, addition, and division below is to
         * round up to the nearest whole number, since we don't
         * have access to floating point.
         */
        Scratch = (BuildTbl.ClockFreq * 10)/(HorTotal*VerTotal);
        Scratch += 5;
        Scratch /= 10;
        BuildTbl.Refresh = (short)Scratch;
        VideoDebugPrint((DEBUG_DETAIL, "Refresh rate = %dHz\n", BuildTbl.Refresh));

        /*
         * Set the pixel depth and pitch, and adjust the clock frequency
         * if the DAC needs multiple clocks per pixel.
         */
        SetOtherModeParameters(pArgs->PixelDepth, pArgs->Pitch,
                               pArgs->Multiplier, &BuildTbl);

        /*
         * We now have a mode table for the resolution we are
         * looking at. If this is the first table we have found
         * at this resolution, we can simply fill in the first
         * entry in LiveTables[]. If not, we must put the table
         * into the list in order by refresh rate.
         */
        if (NumTablesFound == 0)
            {
            VideoDebugPrint((DEBUG_DETAIL, "First DDC table for this resolution\n"));
            VideoPortMoveMemory(&(LiveTables[0]), &BuildTbl, sizeof(struct st_mode_table));
            NumTablesFound = 1;
            }
        else
            {
            /*
             * Run through the list of tables we have already found.
             * Skip over the tables which have refresh rates lower than
             * the new table, and shift tables with higher refresh
             * rates up one position to make room for the new table.
             * There is no need to check for available spaces in the
             * LiveTables[] array, since this array has 4 entries and
             * the EDID structure can hold a maximum of 4 detailed
             * timings.
             */
            for (NumLowerTables = 0; NumLowerTables < NumTablesFound; NumLowerTables++)
                {
                if (LiveTables[NumLowerTables].Refresh < BuildTbl.Refresh)
                    {
                    VideoDebugPrint((DEBUG_DETAIL, "Skipping table %d, since %dHz is less than %dHz\n",
                                    NumLowerTables, LiveTables[NumLowerTables].Refresh, BuildTbl.Refresh));
                    continue;
                    }

                /*
                 * NumLowerTables now holds the number of tables in LiveTables[] which
                 * have refresh rates lower than that in BuildTbl. We must now move
                 * the tables in LiveTables[] with refresh rates higher than that in
                 * BuildTbl up one space to make room for BuildTbl to be inserted.
                 * After moving the tables, break out of the outer loop.
                 */
                for (Scratch = NumTablesFound; Scratch >= NumLowerTables; Scratch--)
                    {
                    VideoDebugPrint((DEBUG_DETAIL, "Moving table %d, since %dHz is more than %dHz\n",
                                    Scratch, LiveTables[Scratch].Refresh, BuildTbl.Refresh));
                    VideoPortMoveMemory(&(LiveTables[Scratch+1]), &(LiveTables[Scratch]), sizeof(struct st_mode_table));
                    }
                break;
                }
            /*
             * When we get here, one of two conditions is satisfied:
             *
             * 1. All the existing tables in LiveTables[] have a refresh
             *    rate less than that in BuildTbl, so the outer loop will
             *    have exited with NumLowerTables equal to NumTablesFound.
             *
             * 2. There are some tables in LiveTables[] which have a refresh
             *    rate greater than that in BuildTbl. The inner loop will
             *    have exited after moving these tables up one space, then
             *    we will have broken out of the outer loop. NumLowerTables
             *    is equal to the number of existing tables which have a
             *    refresh rate less than that in BuildTbl.
             *
             * In both cases, LiveTables[NumLowerTables] is a free slot
             * at the location where BuildTbl should be copied.
             */
            VideoDebugPrint((DEBUG_DETAIL, "Copying new table to entry %d\n", NumLowerTables));
            VideoPortMoveMemory(&(LiveTables[NumLowerTables]), &BuildTbl, sizeof(struct st_mode_table));
            NumTablesFound++;

            }   /* end if (NumTablesFound != 0) */

        }   /* end for (look at next detailed timing block) */

    /*
     * We now have all the mode tables from the EDID structure which
     * match the desired resolution stored in LiveTables[] in order
     * of increasing refresh rate, with the number of such tables
     * in NumTablesFound. Now we must merge the results with the
     * "canned" mode tables.
     */
    HighBound = BookValues[pArgs->EndIndex].Refresh;

    /*
     * Use NumLowerTables to go through the list of tables from
     * the EDID structure.
     *
     * Since there will never be a legitimate mode table with a
     * pixel clock frequency of zero hertz, we can use this value
     * as a flag to show that we don't want to use the tables from
     * the EDID structure. Initially, we only want to lock out the
     * use of these tables if none exist, but we will later lock
     * them out if we have already used all of them.
     */
    NumLowerTables = 0;
    if (NumTablesFound == 0)
        LiveTables[0].ClockFreq = 0;

    while (pArgs->FreeTables > 0)
        {
        /*
         * If the EDID table exists, and either it has a refresh rate
         * less than or equal to that of the next "canned" table or
         * we have run out of acceptable "canned" tables, use the EDID
         * table. We know that any EDID table will have an acceptable
         * pixel clock frequency because we have already discarded any
         * that are out of range.
         */
        if ((LiveTables[NumLowerTables].ClockFreq != 0) &&
            ((LiveTables[NumLowerTables].Refresh <= BookValues[pArgs->Index].Refresh) ||
             (pArgs->Index > pArgs->EndIndex) ||
             (BookValues[pArgs->Index].ClockFreq > pArgs->MaxDotClock)))
            {
            VideoDebugPrint((DEBUG_DETAIL, "Copying %dHz table from EDID\n", LiveTables[NumLowerTables].Refresh));
            VideoPortMoveMemory((*pArgs->ppFreeTables), &(LiveTables[NumLowerTables]), sizeof(struct st_mode_table));
            NumLowerTables++;
            }
        /*
         * The above check will have failed if the EDID table did not exist,
         * or if it did but an acceptable "canned" table with a lower
         * refresh rate also exists. Check to see if we have an acceptable
         * "canned" table, and use it if we do.
         */
        else if ((pArgs->Index <= pArgs->EndIndex) &&
                 (BookValues[pArgs->Index].ClockFreq <= pArgs->MaxDotClock))
            {
            VideoDebugPrint((DEBUG_DETAIL, "Copying %dHz \"canned\" table\n", BookValues[pArgs->Index].Refresh));
            BookVgaTable(pArgs->Index, *pArgs->ppFreeTables);
            SetOtherModeParameters(pArgs->PixelDepth, pArgs->Pitch,
                pArgs->Multiplier, *pArgs->ppFreeTables);
            pArgs->Index++;
            }
        /*
         * The only way we will fail both of the above checks is if there
         * are no acceptable mode tables remaining, either from the EDID
         * structure or from our list of "canned" tables. If this is the
         * case, we don't need to look for more mode tables to add to
         * our list.
         */
        else
            {
            break;
            }

        /*
         * Update the lower bound, since we don't want to consider
         * tables with refresh rates lower than or equal to the one
         * in the table we just added to the list. After we have
         * done this, skip ahead in both the "canned" and EDID tables
         * to get past those which are below the new lower bound.
         *
         * Don't skip a mode table from the EDID structure with a pixel
         * clock frequency of zero, since this is a flag to show that we
         * have already used all of the suitable mode tables from the
         * EDID structure, rather than a legitimate mode table.
         */
        pArgs->LowBound = (*pArgs->ppFreeTables)->Refresh + 1;

        while ((pArgs->Index <= pArgs->EndIndex) &&
               (BookValues[pArgs->Index].Refresh < pArgs->LowBound))
            {
            VideoDebugPrint((DEBUG_DETAIL, "Skipping %dHz \"canned\" table\n", BookValues[pArgs->Index].Refresh));
            pArgs->Index++;
            }

        while ((NumLowerTables < NumTablesFound) &&
               (LiveTables[NumLowerTables].ClockFreq != 0) &&
               (LiveTables[NumLowerTables].Refresh < pArgs->LowBound))
            {
            VideoDebugPrint((DEBUG_DETAIL, "Skipping %dHz table from EDID\n", LiveTables[NumLowerTables].Refresh));
            NumLowerTables++;
            }

        /*
         * If we have run out of EDID tables, mark the EDID tables
         * with our flag to show that they should be ignored (no
         * legitimate mode will have a pixel clock rate of zero
         * hertz).
         *
         * We must do this in the first entry of the structure then
         * reset the "next EDID table to use" index to point to the
         * first entry, rather than modifying whatever happens to be
         * the next entry, to avoid trampling data outside our array
         * in the (unlikely) event that all of the possible detailed
         * timings in the EDID structure were valid mode tables with
         * in-range pixel clock frequencies for the resolution we are
         * looking at.
         *
         * There is no need to set a flag if we run out of "canned"
         * tables because we identify this condition by the index
         * being higher than the highest index we want to look for,
         * which is an input parameter.
         */
        if (NumLowerTables == NumTablesFound)
            {
            VideoDebugPrint((DEBUG_DETAIL, "Ran out of EDID tables\n"));
            NumLowerTables = 0;
            LiveTables[0].ClockFreq = 0;
            }

        /*
         * Adjust the free tables pointer and count to reflect the
         * table we have just added.
         */
        (*pArgs->ppFreeTables)++;
        pArgs->NumModes++;
        pArgs->FreeTables--;

        }   /* end while (more tables and not yet reached high bound) */

    return NO_ERROR;

}   /* MergeEDIDTables() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\cvtvdif.c ===
/************************************************************************/
/*                                                                      */
/*                              CVTVDIF.C                               */
/*                                                                      */
/*       July 12  1995 (c) 1993, 1995 ATI Technologies Incorporated.    */
/************************************************************************/

/**********************       PolyTron RCS Utilities

  $Revision:   1.5  $
      $Date:   23 Jan 1996 11:45:32  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/cvtvdif.c_v  $
 * 
 *    Rev 1.5   23 Jan 1996 11:45:32   RWolff
 * Protected against false values of TARGET_BUILD.
 * 
 *    Rev 1.4   11 Jan 1996 19:39:06   RWolff
 * Now restricts "canned" mode tables by both maximum index and maximum
 * pixel clock frequency, and VDIF mode tables by maximum pixel clock
 * frequency only, rather than both by maximum refresh rate.
 * 
 *    Rev 1.3   19 Dec 1995 14:07:14   RWolff
 * Added debug print statements.
 * 
 *    Rev 1.2   30 Oct 1995 12:09:42   MGrubac
 * Fixed bug in calculating CRTC parameters based on read in data from VDIF files.
 * 
 *    Rev 1.1   26 Jul 1995 13:06:44   mgrubac
 * Moved mode tables merging to VDIFCallback() routine.
 * 
 *    Rev 1.0   20 Jul 1995 18:19:12   mgrubac
 * Initial revision.


End of PolyTron RCS section                             *****************/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <math.h>

#include "dderror.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"      /* for VP_STATUS definition */
#include "vidlog.h"

#include "stdtyp.h"
#include "amach.h"
#include "amach1.h"
#include "atimp.h"
#include "atint.h"
#include "cvtvga.h"
#include "atioem.h"
#include "services.h"
#include "vdptocrt.h"
#include "vdpdata.h"
#include "cvtvdif.h"


/*
 * Allow miniport to be swapped out when not needed.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_COM, SetOtherModeParameters)
#endif

void *pCallbackArgs;  /* Pointer for passing parameters to VDIFCallback() */ 

 
/**************************************************************************
 *
 * void SetOtherModeParameters( PixelDepth, Pitch, Multiplier, pmode)
 * WORD Multiplier;     What needs to be done to the pixel clock
 * WORD PixelDepth;     Number of bits per pixel
 * WORD Pitch;          Screen pitch to use
 * struct st_mode_table *pmode; Pointer to structure that must contain
 *                              at least the member ClockFreq
 *
 *
 * DESCRIPTION:
 *  Sets parameters PixelDepth, Pitch and adjusts ClockFreq 
 *
 * RETURN VALUE:
 *  None
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  SetFixedModes and VDIFCallback 
 *
 * AUTHOR:
 *  Miroslav Grubac
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/
void SetOtherModeParameters( WORD PixelDepth,
                              WORD Pitch,
                              WORD Multiplier,
                              struct st_mode_table *pmode)
{
    pmode->m_pixel_depth = (UCHAR) PixelDepth;
    pmode->m_screen_pitch = Pitch;

    /*
     * Take care of any pixel clock multiplication that is needed.
     */
    switch(Multiplier)
        {
        case CLOCK_TRIPLE:
            pmode->ClockFreq *= 3;
            break;

        case CLOCK_DOUBLE:
            pmode->ClockFreq *= 2;
            break;

        case CLOCK_THREE_HALVES:
            pmode->ClockFreq *= 3;
            pmode->ClockFreq >>= 1;
            break;

        case CLOCK_SINGLE:
        default:
            break;
        }

} /* SetOtherModeParameters() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\cvtvga.c ===
/************************************************************************/
/*                                                                      */
/*                              CVTVGA.C                                */
/*                                                                      */
/*  Copyright (c) 1992, ATI Technologies Incorporated.	                */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
    $Revision:   1.9  $
    $Date:   20 Jul 1995 17:53:30  $
    $Author:   mgrubac  $
    $Log:   S:/source/wnt/ms11/miniport/vcs/cvtvga.c  $
 * 
 *    Rev 1.9   20 Jul 1995 17:53:30   mgrubac
 * Added support for VDIF files
 * 
 *    Rev 1.8   10 Apr 1995 15:55:26   RWOLFF
 * Updated 640x480 72Hz mode table from version 1.2 to version 1.5 of the
 * Programmer's Guide to the Mach 32 Registers, added routine to replace
 * BookValues[] entries where the Mach 64 needs CRT parameters the Mach 8
 * and Mach 32 can't handle (currently, only 640x480 72Hz falls into
 * this category).
 * 
 *    Rev 1.7   23 Dec 1994 10:47:58   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.6   18 Nov 1994 11:39:04   RWOLFF
 * Added comments with function name at the end of each function.
 * 
 *    Rev 1.5   31 Aug 1994 16:22:42   RWOLFF
 * Added support for 1152x864 and 1600x1200 "canned" mode tables.
 * 
 *    Rev 1.4   19 Aug 1994 17:09:52   RWOLFF
 * Added support for non-standard pixel clock generators.
 * 
 *    Rev 1.3   18 May 1994 17:02:58   RWOLFF
 * Interlaced mode tables now report frame rate rather than vertical
 * scan frequency in the refresh rate field.
 * 
 *    Rev 1.2   12 May 1994 11:13:04   RWOLFF
 * Added refresh rate to entries in BookValues[], re-ordered BookValues[]
 * to allow a single range of indices to cover all desired refresh rates at
 * a given resolution even when the highest nonitnerlaced refresh rates
 * are ignored.
 * 
 *    Rev 1.1   07 Feb 1994 14:06:06   RWOLFF
 * Added alloc_text() pragmas to allow miniport to be swapped out when
 * not needed.
 * 
 *    Rev 1.0   31 Jan 1994 11:05:14   RWOLFF
 * Initial revision.
        
           Rev 1.4   30 Nov 1993 18:15:02   RWOLFF
        Corrected clock select value for 1280x1024 60Hz noninterlaced.
        
           Rev 1.3   08 Oct 1993 15:17:56   RWOLFF
        No longer includes VIDFIND.H
        
           Rev 1.2   08 Oct 1993 11:05:14   RWOLFF
        Removed unused "fall back to 56Hz" function for 800x600.
        
           Rev 1.1   03 Sep 1993 14:21:52   RWOLFF
        Partway through CX isolation.
        
           Rev 1.0   16 Aug 1993 13:22:04   Robert_Wolff
        Initial revision.
        
           Rev 1.12   30 Apr 1993 16:39:18   RWOLFF
        640x480 8BPP now stable on 512k Graphics Vantage. Fix is not yet final -
        old code is present but commented out, will remove when fix is final.
        
           Rev 1.11   21 Apr 1993 17:17:16   RWOLFF
        Now uses AMACH.H instead of 68800.H/68801.H.
        
           Rev 1.10   30 Mar 1993 17:10:28   RWOLFF
        Added 1280x1024 60Hz noninterlaced to resolutions which can be selected
        by BookVgaTable().
        
           Rev 1.9   25 Mar 1993 11:12:34   RWOLFF
        Brought comment block in function header into sync with actual code.
        
           Rev 1.8   08 Mar 1993 19:28:28   BRADES
        submit to MS NT
        
           Rev 1.6   06 Jan 1993 10:57:56   Robert_Wolff
        Added type casts to eliminate compile warnings.
        
           Rev 1.5   02 Dec 1992 17:28:58   Robert_Wolff
        Added function FallBack800to56(), which replaces those parameters
        of an 800x600 mode table with the values used by the 56Hz vertical
        frequency mode in Programmer's Guide to the Mach 32 Registers.
        
           Rev 1.4   27 Nov 1992 15:18:30   STEPHEN
        No change.
        
           Rev 1.3   17 Nov 1992 17:21:02   Robert_Wolff
        Now uses parameters from Appendix D of the Programmer's Guide to
        the Mach 32 Registers rather than values from the EEPROM if the
        CRTC_USAGE bit is clear (clear = use sync polarities only, will
        be clear if card is configured for a predefined monitor rather
        than having CRT parameters written to the EEPROM), fixed calculation
        of parameters for Mach 8 in 800x600 at 60, 70, and 72 Hz noninterlaced
        (other frequencies at 800x600, other resolutions on Mach 8, and all
        resolutions on Mach 32 didn't have this problem).
        
           Rev 1.2   13 Nov 1992 17:09:44   Robert_Wolff
        Now includes 68801.H, which consists of the now-obsolete MACH8.H
        and elements moved from VIDFIND.H.
        
           Rev 1.1   12 Nov 1992 16:39:38   Robert_Wolff
        Merged source trees for Windows NT driver and VIDEO.EXE test program
        (same source file can be used for both). XlateVgaTable() now takes
        an extra parameter to determine whether to handle data for Mach32
        or Mach8 cards, rather than using the global variable classMACH32.
        
           Rev 1.0   05 Nov 1992 13:59:56   Robert_Wolff
        Initial revision.
        
           Rev 1.1   09 Oct 1992 15:03:28   Robert_Wolff
        Now assigns values for DISP_CNTL, CLOCK_SEL, VFIFO_16, and VFIFO_24.
        
           Rev 1.0   01 Oct 1992 15:31:42   Robert_Wolff
        Initial revision.


End of PolyTron RCS section                             *****************/

#ifdef DOC
    CVTVGA.C -  Functions to convert CRT parameter table from VGA
        to 8514 format.

#endif

#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"

#define INCLUDE_CVTVGA
#include "amach.h"
#include "amach1.h"
#include "cvtvga.h"
#include "atimp.h"
#include "services.h"

/*
 * Arrays of VGA parameter tables used in translating from
 * VGA format to 8514 format. Currently the 800x600 noninterlaced
 * entries have different values for the Mach8 and Mach32
 * engines (Mach 8 is the "else" case with the comment
 * "TESTING ONLY" for 56Hz). Assume that the VFIFO_DEPTH
 * field is 8 entries.
 */
static struct st_vga_data VgaParmTable_M32[10] =
{
    {0x050, 0x000, 0x04F, 0x0DF, 0x0E3, 0x0800, 0x023, 32000000L},  /* Mode 12, VGAP$PS2.ASM */
    {0x064, 0x000, 0x063, 0x057, 0x0E3, 0x0800, 0x023, 36000000L},  /* m800_36m, VGAP$68A.MAC */
    {0x064, 0x000, 0x063, 0x057, 0x0E3, 0x0800, 0x023, 40000000L},  /* m800_40mphip, VGAP$68A.MAC */
    {0x064, 0x000, 0x063, 0x057, 0x0E3, 0x0800, 0x023, 44900000L},  /* m800_45m, VGAP$68A.MAC */
    {0x064, 0x000, 0x063, 0x057, 0x0E3, 0x0800, 0x023, 50350000L},  /* m800_50mvesa, VGAP$68A.MAC */
    {0x064, 0x0C0, 0x063, 0x057, 0x0E3, 0x0800, 0x033, 32500000L},  /* m800_36m8514, VGAP$68A.MAC */
    {0x080, 0x000, 0x07F, 0x0FF, 0x0E3, 0x0800, 0x023, 65000000L},  /* m1024_65m, VGAP$68A.MAC */
    {0x080, 0x000, 0x07F, 0x0FF, 0x0E3, 0x0800, 0x023, 75000000L},  /* m1024_75mvesa, VGAP$68A.MAC */
    {0x080, 0x000, 0x07F, 0x0FF, 0x0E3, 0x0800, 0x023, 75000000L},  /* m1024_75m72Hz, VGAP$68A.MAC */
    {0x080, 0x0C0, 0x07F, 0x0FF, 0x0E3, 0x0800, 0x033, 44900000L}   /* m1024_45m, VGAP$68A.MAC */
};

static struct st_vga_data VgaParmTable_M8[10] =
{
    {0x050, 0x000, 0x04F, 0x0DF, 0x0E3, 0x0800, 0x023, 32000000L},  /* Mode 12, VGAP$PS2.ASM */
    {0x064, 0x000, 0x063, 0x02B, 0x0E7, 0x0800, 0x023, 36000000L},  /* m800_36m, VGAP$68A.MAC */
    {0x064, 0x000, 0x063, 0x02B, 0x0E7, 0x0800, 0x023, 40000000L},  /* m800_40mphip, VGAP$68A.MAC */
    {0x064, 0x000, 0x063, 0x02B, 0x0E7, 0x0800, 0x023, 44900000L},  /* m800_45m, VGAP$68A.MAC */
    {0x064, 0x000, 0x063, 0x02B, 0x0E7, 0x0800, 0x023, 50350000L},  /* m800_50mvesa, VGAP$68A.MAC */
    {0x064, 0x0C0, 0x063, 0x057, 0x0E3, 0x0800, 0x033, 32500000L},  /* m800_36m8514, VGAP$68A.MAC */
    {0x080, 0x000, 0x07F, 0x0FF, 0x0E3, 0x0800, 0x023, 65000000L},  /* m1024_65m, VGAP$68A.MAC */
    {0x080, 0x000, 0x07F, 0x0FF, 0x0E3, 0x0800, 0x023, 75000000L},  /* m1024_75mvesa, VGAP$68A.MAC */
    {0x080, 0x000, 0x07F, 0x0FF, 0x0E3, 0x0800, 0x023, 75000000L},  /* m1024_75m72Hz, VGAP$68A.MAC */
    {0x080, 0x0C0, 0x07F, 0x0FF, 0x0E3, 0x0800, 0x033, 44900000L}   /* m1024_45m, VGAP$68A.MAC */
};

/*
 * Pointer to currently-used VGA parameter table
 */
static struct st_vga_data *VgaParmTable;


/*
 * Some of the processing of vertical values is handled differently
 * on non-Mach32 cards with 512k of video memory. The routine which
 * behaves differently based on whether or not we have an older card
 * with 512k is called several times, so setting this flag in a higher-
 * level routine will reduce the number of tests required.
 */
static BOOL HalfMeg;


static void GetVertOverflow(unsigned char *Value);
static unsigned short Gen8514V(union SplitWord INPut, short VgaTblEntry);


/*
 * Allow miniport to be swapped out when not needed.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_M, GetVertOverflow)
#pragma alloc_text(PAGE_M, Gen8514V)
#pragma alloc_text(PAGE_M, XlateVgaTable)
#pragma alloc_text(PAGE_M, BookVgaTable)
#endif


/****************************************************************
 * GetVertOverflow
 *
 * Gets the overflow (2 most significant bits) of a vertical
 * value. On entry, Value will point to a copy of the CRT07
 * register which has been shifted so that bit 8 of the desired
 * value is in bit 0 of *Value, and bit 9 of the desired value
 * is in bit 5 of *Value. On exit, bits 8 and 9 will be in bits
 * 0 and 1 respectively of *Value.
 *
 *   INPUT: Value = ptr to raw overflow value
 *
 *   RETURN: Value = ptr to processed overflow value
 *
 ****************************************************************/
static void GetVertOverflow(unsigned char *Value)
{
    unsigned char Scratch;  /* Scratchpad variable */

    Scratch = (*Value >> 4) & 0x02;
    *Value = (*Value & 0x01) | Scratch;
    return;

}   /* GetVertOverflow() */



/****************************************************************
 * Gen8514V
 *
 * Another stage in the processing of a vertical value. This is
 * taken directly from gen8514v in COMBO$01.ASM.
 *
 *   INPUT: INPut	= value before processing
 *          VgaTblEntry = which set of VGA parameters corresponds
 *                        to the desired mode
 *
 *   RETURN: processed value
 *
 ****************************************************************/
static unsigned short Gen8514V(union SplitWord INPut, short VgaTblEntry)
{
    union SplitWord Scratch;    /* Scratchpad variable */

    if(VgaParmTable[VgaTblEntry].Mode & WORD_MODE)
	INPut.word <<= 1;

    INPut.word -= 1;
    Scratch.word = INPut.word;
    Scratch.word <<= 1;

// 512k handling not yet final. 640x480 is stable with wrong colours
// with special case commented out, don't want to delete code until
// changes are final.
//
//    if (HalfMeg)
//        {
//        Scratch.word <<= 1;
//        INPut.byte.low &= 0x01;
//        }
//    else{
        INPut.byte.low &= 0x03;
//        }

    Scratch.byte.low &= 0x0F8;
    INPut.byte.high = Scratch.byte.high;
    INPut.byte.low |= Scratch.byte.low;

    Scratch.byte.high &= 0x01;
    Scratch.byte.high <<= 2;
    INPut.byte.low |= Scratch.byte.high;

    return INPut.word;

}   /* Gen8514V() */



/*
 * short XlateVgaTable(HwDeviceExtension, TableOffset, pmode, VgaTblEntry,
 *                     BookTblEntry, ee, IsMach32);
 *
 * PVOID HwDeviceExtension;     Hardware extension for Windows NT
 * short TableOffset;           Offset of start of desired mode table into EEPROM
 * struct st_mode_table *pmode; Mode table to fill in
 * short VgaTblEntry;           Resolution/vertical frequency of desired mode
 * short BookTblEntry;          Appendix D entry to use if parameters not in EEPROM
 * struct st_eeprom_data *ee;   EEPROM setup description
 * BOOL IsMach32;               Indicates whether card is a Mach32 or a Mach8
 *
 * Translates an EEPROM mode table from VGA to 8514 format and
 * fills in the mode table passed in the parameter pmode.
 *
 *  RETURN: Nonzero if values filled in
 *          Zero if we were unable to find the appropriate
 *           VGA parameter table. If this is the case, the
 *           value INVALID_WARNING is placed in pmode->m_h_overscan,
 *           pmode->m_v_overscan, pmode->m_overscan_8b, and
 *           pmode->m_overscan_gr.
 */

short XlateVgaTable(PVOID HwDeviceExtension,
		    short TableOffset, struct st_mode_table *pmode,
                    short VgaTblEntry, short BookTblEntry,
                    struct st_eeprom_data *ee, BOOL IsMach32)
{
    /*
     * Certain modes on some cards require extra scaling. This variable
     * is set to the scaling factor (zero if no scaling needed). Initially
     * assume that no scaling is needed.
     */
    short FudgeFactor = 0;

    union SplitWord ValueRead;  /* Value read from the EEPROM */
    
    /*
     * Storage for CRT registers 06, 07 and 11. These registers are either
     * used a number of times and would need repeated reads if they weren't
     * saved, or are read before they are needed because they are the
     * other byte of a word which contains a register which is needed
     * at an earlier stage of the calculation.
     */
    unsigned char Crt06;
    unsigned char Crt07;
    unsigned char Crt11;

    /*
     * Saved value of the low byte of the vertical sync start.
     */
    unsigned char VSyncStart;

    UNREFERENCED_PARAMETER(HwDeviceExtension);

    /*
     * If this is a mode for which we have no information,
     * set up our warning and return.
     */
    if (VgaTblEntry == NO_TBL_ENTRY)
        {
        pmode->m_h_overscan = (short) INVALID_WARNING;
        pmode->m_v_overscan = (short) INVALID_WARNING;
        pmode->m_overscan_8b = (short) INVALID_WARNING;
        pmode->m_overscan_gr = (short) INVALID_WARNING;
        return 0;
        }

    /*
     * Under some circumstances, the CRT parameters will not be
     * properly entered into the EEPROM, so attempting to read
     * them will produce garbage values. If this is the case,
     * the CRTC_USAGE bit in word 0 of the mode table will
     * be clear (use sync polarities only).
     *
     * This case must be detected here, rather than calling
     * BookVgaTable() whenever the USE_STORED_PARMS bit of the
     * mode descriptor word is clear, because adjusting the screen
     * size and position for a custom monitor does not always set
     * this bit, but it will set the CRTC_USAGE bit.
     *
     * For this case, and for modes for which we have the parameters
     * from Appendix D of the Programmer's Guide to the Mach 32
     * Registers but no way to calculate the mode table information
     * based on values read from the EEPROM, fill in the mode table
     * with the book values and return.
     */
    ValueRead.word = (ee->EEread)((short)(TableOffset+0));
    if ((VgaTblEntry >= USE_BOOK_VALUE) || !(ValueRead.word & CRTC_USAGE))
        {
        BookVgaTable(BookTblEntry, pmode);
        return 1;
        }

    /*
     * We have VGA parameter tables to allow us to calculate the mode
     * table entries from the EEPROM contents.
     *
     * Initially assume that we have either a Mach32 card or an older
     * card with 1M of video memory.
     */
    HalfMeg = 0;

    /*
     * Select the VGA parameter table for the card we are using
     * (Mach8 or Mach32). On Mach8 cards, check if we are using
     * a mode which requires scaling, and if we have only 512k
     * of video memory.
     */
    if (IsMach32)
        {
        VgaParmTable = VgaParmTable_M32;
        }
    else{
        VgaParmTable = VgaParmTable_M8;
        if (VgaParmTable[VgaTblEntry].Stretch == 0x080)
            FudgeFactor = 1;
	if (!(INP(SUBSYS_STAT) & 0x080))
            HalfMeg = 1;
        }


    /*
     * Get the horizontal total first.
     */
    ValueRead.word = (ee->EEread)((short) (TableOffset+3));
    ValueRead.byte.high = ((ValueRead.byte.high + 5) << FudgeFactor) - 1;
    pmode->m_h_total = ValueRead.byte.high;
    Crt06 = ValueRead.byte.low;


    /*
     * Get the horizontal display width.
     */
    pmode->m_h_disp = VgaParmTable[VgaTblEntry].DisplayWidth;
    pmode->m_x_size = (pmode->m_h_disp + 1) * 8;


    /*
     * Get the start of the horizontal sync.
     */
    ValueRead.word = (ee->EEread)((short) (TableOffset+4));
    pmode->m_h_sync_strt = ((ValueRead.byte.high - 2) << FudgeFactor) + FudgeFactor;


    /*
     * Get the horizontal sync width.
     */
    ValueRead.word &= 0x1F1F;
    ValueRead.byte.low -= ValueRead.byte.high;
    ValueRead.byte.low &= 0x1f;
    ValueRead.byte.low <<= FudgeFactor;
    if (pmode->control & HSYNC_BIT)
        ValueRead.byte.low |= NEG_SYNC_FACTOR;
    pmode->m_h_sync_wid = ValueRead.byte.low;


    /*
     * Get the vertical total.
     */
    ValueRead.word = (ee->EEread)((short) (TableOffset+8));
    Crt07 = ValueRead.byte.high;
    ValueRead.byte.low = Crt06;
    GetVertOverflow(&(ValueRead.byte.high));    /* Overflow in bits 0&5 */
    ValueRead.word += 2;

    if (VgaParmTable[VgaTblEntry].MiscParms & INTERL)
        ValueRead.word += 4;

    ValueRead.word = Gen8514V(ValueRead, VgaTblEntry);

    if (VgaParmTable[VgaTblEntry].MiscParms & INTERL)
        ValueRead.byte.low &= 0x0FE;

    pmode->m_v_total = ValueRead.word;


    /*
     * Get the number of displayed scanlines.
     */
    ValueRead.byte.low = VgaParmTable[VgaTblEntry].DisplayHgt;
    ValueRead.byte.high = Crt07 >> 1;   /* Overflow in bits 1&6 */
    GetVertOverflow(&(ValueRead.byte.high));
    ValueRead.word++;
    pmode->m_v_disp = Gen8514V(ValueRead, VgaTblEntry);

    /*
     * Y size is derived by removing bit 2.
     */
    pmode->m_y_size = (((pmode->m_v_disp >> 1) & 0x0FFFC) | (pmode->m_v_disp & 0x03)) + 1;


    /*
     * Get the start of the vertical sync.
     */
    ValueRead.word = (ee->EEread)((short) (TableOffset+5));
    Crt11 = ValueRead.byte.low;
    ValueRead.byte.low = ValueRead.byte.high;
    VSyncStart = ValueRead.byte.high;
    ValueRead.byte.high = Crt07 >> 2;   /* Overflow in bits 2&7 */
    GetVertOverflow(&(ValueRead.byte.high));

    ValueRead.word++;
    pmode->m_v_sync_strt = Gen8514V(ValueRead, VgaTblEntry);


    /*
     * Get the vertical sync width.
     */
    Crt11 -= (VSyncStart & 0x0f);
    if (VgaParmTable[VgaTblEntry].Mode & WORD_MODE)
        Crt11 <<= 1;
    Crt11 &= 0x0f;
    if (pmode->control & VSYNC_BIT)
        Crt11 |= NEG_SYNC_FACTOR;
    pmode->m_v_sync_wid = Crt11;

    /*
     * Get the clock select and display control values.
     */
    pmode->m_clock_select = VgaParmTable[VgaTblEntry].ClockSel;
    pmode->ClockFreq = VgaParmTable[VgaTblEntry].ClockFreq;
    pmode->m_disp_cntl = (UCHAR)(VgaParmTable[VgaTblEntry].DispCntl);

    /*
     * Assume an 8-entry FIFO for 16 and 24 bit colour.
     */
    pmode->m_vfifo_24 = 8;
    pmode->m_vfifo_16 = 8;

    /*
     * Some parameters in 8514 format do not have corresponding EEPROM
     * table entries in VGA format. Set the pmode fields for these
     * parameters to zero.
     */
    pmode->m_h_overscan = 0;
    pmode->m_v_overscan = 0;
    pmode->m_overscan_8b = 0;
    pmode->m_overscan_gr = 0;
    pmode->m_status_flags = 0;


    /*
     * Let the caller know that the pmode table is now filled in.
     */
    return 1;

}   /* XlateVgaTable() */


/*
 * void BookVgaTable(VgaTblEntry, pmode);
 *
 * short VgaTblEntry;               Desired entry in BookValues[]
 * struct st_mode_table *pmode;     Mode table to fill in
 *
 * Fills in a mode table using the values in the BookValues[] entry
 * corresponding to the resolution specified by VgaTblEntry.
 */
void BookVgaTable(short VgaTblEntry, struct st_mode_table *pmode)
{
    pmode->m_h_total = BookValues[VgaTblEntry].HTotal;
    pmode->m_h_disp  = BookValues[VgaTblEntry].HDisp;
    pmode->m_x_size  = (pmode->m_h_disp+1)*8;

    pmode->m_h_sync_strt = BookValues[VgaTblEntry].HSyncStrt;
    pmode->m_h_sync_wid  = BookValues[VgaTblEntry].HSyncWid;

    pmode->m_v_total = BookValues[VgaTblEntry].VTotal;
    pmode->m_v_disp  = BookValues[VgaTblEntry].VDisp;
    /*
     * y_size is derived by removing bit 2
     */
    pmode->m_y_size = (((pmode->m_v_disp >> 1) & 0x0FFFC) | (pmode->m_v_disp & 0x03)) + 1;

    pmode->m_v_sync_strt = BookValues[VgaTblEntry].VSyncStrt;
    pmode->m_v_sync_wid  = BookValues[VgaTblEntry].VSyncWid;
    pmode->m_disp_cntl   = BookValues[VgaTblEntry].DispCntl;

    pmode->m_clock_select = BookValues[VgaTblEntry].ClockSel;
    pmode->ClockFreq = BookValues[VgaTblEntry].ClockFreq;

    /*
     * Assume 8 FIFO entries for 16 and 24 bit colour.
     */
    pmode->m_vfifo_24 = 8;
    pmode->m_vfifo_16 = 8;

    /*
     * Fill in the refresh rate
     */
    pmode->Refresh = BookValues[VgaTblEntry].Refresh;

    /*
     * Clear the values which we don't have data for, then let
     * the caller know that the table is filled in.
     */
    pmode->m_h_overscan = 0;
    pmode->m_v_overscan = 0;
    pmode->m_overscan_8b = 0;
    pmode->m_overscan_gr = 0;
    pmode->m_status_flags = 0;

    return;

}   /* BookVgaTable() */



/***************************************************************************
 *
 * void SetMach64Tables(void);
 *
 * DESCRIPTION:
 *  Replace "canned" mode tables that differ between Mach 64 and
 *  Mach 8/Mach 32 parameters with Mach 64 versions. Whenever possible,
 *  an update to a VESA-compatible parameter table should be done in
 *  BookValues[] - this routine is only for those cases where the
 *  Mach 64 requires a pixel clock frequency that the clock generator
 *  on the Mach 8 or Mach 32 can't produce.
 *
 * GLOBALS CHANGED:
 *  Some entries in BookValues[] table
 *
 * CALLED BY:
 *  QueryMach64()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void SetMach64Tables(void)
{
    #define NUM_TABLES_TO_SWAP  1
    ULONG TableIndices[NUM_TABLES_TO_SWAP] =
    {
        B640F72
    };
    struct st_book_data NewTables[NUM_TABLES_TO_SWAP] =
    {
        {0x067, 0x04F, 0x052, 0x025, 0x040B, 0x03BF, 0x03D0, 0x023, 0x023,  31200000L, 0x0800, 72}  /* 640x480 72Hz NI */
    };
    ULONG LoopCount;

    /*
     * Go through the list of tables that need to be replaced, setting all
     * the fields to the Mach 64 values.
     */
    for (LoopCount = 0; LoopCount < NUM_TABLES_TO_SWAP; LoopCount++)
        {
        BookValues[TableIndices[LoopCount]].HTotal    = NewTables[LoopCount].HTotal;
        BookValues[TableIndices[LoopCount]].HDisp     = NewTables[LoopCount].HDisp;
        BookValues[TableIndices[LoopCount]].HSyncStrt = NewTables[LoopCount].HSyncStrt;
        BookValues[TableIndices[LoopCount]].HSyncWid  = NewTables[LoopCount].HSyncWid;
        BookValues[TableIndices[LoopCount]].VTotal    = NewTables[LoopCount].VTotal;
        BookValues[TableIndices[LoopCount]].VDisp     = NewTables[LoopCount].VDisp;
        BookValues[TableIndices[LoopCount]].VSyncStrt = NewTables[LoopCount].VSyncStrt;
        BookValues[TableIndices[LoopCount]].VSyncWid  = NewTables[LoopCount].VSyncWid;
        BookValues[TableIndices[LoopCount]].DispCntl  = NewTables[LoopCount].DispCntl;
        BookValues[TableIndices[LoopCount]].ClockFreq = NewTables[LoopCount].ClockFreq;
        BookValues[TableIndices[LoopCount]].ClockSel  = NewTables[LoopCount].ClockSel;
        BookValues[TableIndices[LoopCount]].Refresh   = NewTables[LoopCount].Refresh;
        }

    return;

}   /* SetMach64Tables() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\cvtvdif.h ===
/************************************************************************/
/*                                                                      */
/*                              CVTVDIF.H                               */
/*                                                                      */
/*       July 12  1995 (c) 1993, 1995 ATI Technologies Incorporated.    */
/************************************************************************/

/**********************       PolyTron RCS Utilities

  $Revision:   1.3  $
      $Date:   11 Jan 1996 19:40:34  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/cvtvdif.h_v  $
 * 
 *    Rev 1.3   11 Jan 1996 19:40:34   RWolff
 * Added field for maximum supported pixel clock frequency to VDIFInputs
 * structure.
 * 
 *    Rev 1.2   30 Oct 1995 12:11:56   MGrubac
 * Fixed bug in calculating CRTC parameters based on read in data from VDIF files.
 * 
 *    Rev 1.1   26 Jul 1995 12:54:54   mgrubac
 * Changed members of stVDIFCallbackData structure.
 * 
 *    Rev 1.0   20 Jul 1995 18:23:32   mgrubac
 * Initial revision.


End of PolyTron RCS section                             *****************/



/*
 * Prototypes for functions supplied by CVTVDIF.C
 */

extern void SetOtherModeParameters( WORD PixelDepth,
                                    WORD Pitch,
                                    WORD Multiplier,
                                    struct st_mode_table *pmode);

#define CARRETURN       '\x0D'  /* Carriage return */
#define TIMINGSECTION   "PREADJUSTED_TIMING"
#define HORPIXEL        "HORPIXEL"
#define VERPIXEL        "VERPIXEL"
#define VERFREQUENCY    "VERFREQUENCY"
#define HORFREQUENCY    "HORFREQUENCY"
#define SCANTYPE        "SCANTYPE"
#define PIXELCLOCK      "PIXELCLOCK"
#define HORSYNCTIME     "HORSYNCTIME"
#define HORADDRTIME     "HORADDRTIME"
#define HORBLANKTIME    "HORBLANKTIME"
#define HORBLANKSTART   "HORBLANKSTART"
#define VERSYNCTIME     "VERSYNCTIME"
#define VERADDRTIME     "VERADDRTIME"
#define VERBLANKTIME    "VERBLANKTIME"
#define VERBLANKSTART   "VERBLANKSTART"
#define HORSYNCSTART    "HORSYNCSTART"
#define VERSYNCSTART    "VERSYNCSTART"
#define HORSYNCPOLARITY "HORSYNCPOLARITY"
#define VERSYNCPOLARITY "VERSYNCPOLARITY"

/*
 * Structure for passing arguments and returned values between 
 * SetFixedModes() and VDIFCallback() 
 */
struct stVDIFCallbackData 
    { 
    /* 
     * Input and Outputs are from perspective of VDIFCallback() 
     */

    /*
     * FreeTables;  Input : number of free tables 
     *              Output: number of free tables after VDIFCallback routine  
     */
    short FreeTables;      
    /*
     * NumModes; Input and output: Number of mode tables added to list.
     * Incremented every time a new mode table is added to the list, in 
     * SetFixedModes() and in VDIFCallback()  
     */
    WORD NumModes;        
    WORD Index;         /* Input: First entry from "book" tables to use */
    WORD EndIndex;      /* Input: Last entry from "book" tables to use */
    WORD LowBound;      /* Input and output: The lowest frame rate */
    WORD Multiplier;    /* Input Argument from SetFixedModes */
    WORD HorRes;        /* Input Argument from SetFixedModes */
    WORD VerRes;        /* Input Argument from SetFixedModes */
    WORD PixelDepth;    /* Input Argument from SetFixedModes */
    WORD Pitch;         /* Input Argument from SetFixedModes */
    ULONG MaxDotClock;  /* Maximum supported pixel clock frequency */
    /*
     * ppFreeTables; Input and output: Pointer to pointer to the next free mode 
     * table. Incremented every time a new mode table is added to the list, in
     * SetFixedModes() and in VDIFCallback() 
     */
    struct st_mode_table **ppFreeTables; 
    };

/*
 * Structure for AlterTables[] to contain information we need to extract
 * from VDIF file for each mode table
 */
struct VDIFInputs 
    {      
    short MinFrameRate;
    BOOL  Interlaced; 
    ULONG PixelClock;
    ULONG HorFrequency;
    ULONG VerFrequency;
    ULONG HorSyncStart;
    ULONG VerSyncStart;
    ULONG HorBlankStart;
    ULONG VerBlankStart;
    ULONG HorAddrTime;
    ULONG VerAddrTime;
    ULONG HorBlankTime;
    ULONG VerBlankTime;
    ULONG HorSyncTime;
    ULONG VerSyncTime;
    ULONG HorPolarity;
    ULONG VerPolarity;
    };


/*
 * Pointer for passing parameters to callback functions by pointing 
 * (after casting) to a structure containing input (and possibly output)
 * variables for a callback function. Originally intended for use with 
 * SetFixedModes() and VDIFCallback(). 
 */
extern void *pCallbackArgs;  

/*
 * VDIF Macros
 */
#define OPER_LIMITS(vdif) \
        ((VDIFLimitsRec *)((char *)(vdif) + (vdif)->OffsetOperationalLimits))
#define NEXT_OPER_LIMITS(limits) \
        ((VDIFLimitsRec *)((char *)(limits) + (limits)->OffsetNextLimits))
#define PREADJ_TIMING(limits) \
        ((VDIFTimingRec *)((char *)(limits) + (limits)->Header.ScnLength))
#define NEXT_PREADJ_TIMING(timing) \
        ((VDIFTimingRec *)((char *)(timing) + (timing)->Header.ScnLength))

/*
 * Binary VDIF file defines
 */
#define VDIF_MONITOR_MONOCHROME      0
#define VDIF_MONITOR_COLOR           1

#define VDIF_VIDEO_TTL               0
#define VDIF_VIDEO_ANALOG            1
#define VDIF_VIDEO_ECL               2
#define VDIF_VIDEO_DECL              3
#define VDIF_VIDEO_OTHER             4

#define VDIF_SYNC_SEPARATE           0
#define VDIF_SYNC_C                  1
#define VDIF_SYNC_CP                 2
#define VDIF_SYNC_G                  3
#define VDIF_SYNC_GP                 4
#define VDIF_SYNC_OTHER              5
#define VDIF_EXT_XTAL                6

#define VDIF_SCAN_NONINTERLACED      0
#define VDIF_SCAN_INTERLACED         1
#define VDIF_SCAN_OTHER              2

#define VDIF_POLARITY_NEGATIVE       0
#define VDIF_POLARITY_POSITIVE       1

/*
 * We must force byte alignment of structures used in binary VDIF files, 
 * since structures contained in binary files are already byte aligned 
 */

#pragma pack(1)

struct _VDIF                           /* Monitor Description: */
   {
   UCHAR        VDIFId[4];             /* Always "VDIF" */
   ULONG        FileLength;            /* Lenght of the whole file */
   ULONG        Checksum;              /* Sum of all bytes in the file after */
                                       /* This feeld */
   USHORT       VDIFVersion;           /* Structure version number */
   USHORT       VDIFRevision;          /* Structure revision number */
   USHORT       Date[3];               /* File date Year/Month/Day */
   USHORT       DateManufactured[3];   /* Date Year/Month/Day */
   ULONG        FileRevision;          /* File revision string */
   ULONG        Manufacturer;          /* ASCII ID of the manufacturer */
   ULONG        ModelNumber;           /* ASCII ID of the model */
   ULONG        MinVDIFIndex;          /* ASCII ID of Minimum VDIF index */
   ULONG        Version;               /* ASCII ID of the model version */
   ULONG        SerialNumber;          /* ASCII ID of the serial number */
   UCHAR        MonitorType;           /* Monochrome or Color */
   UCHAR        CRTSize;               /* Inches */
   UCHAR        BorderRed;             /* Percent */
   UCHAR        BorderGreen;           /* Percent */
   UCHAR        BorderBlue;            /* Percent */
   UCHAR        Reserved1;             /* Padding */
   USHORT       Reserved2;             /* Padding */
   ULONG        RedPhosphorDecay;      /* Microseconds */
   ULONG        GreenPhosphorDecay;    /* Microseconds */
   ULONG        BluePhosphorDecay;     /* Microseconds */
   USHORT       WhitePoint_x;          /* WhitePoint in CIExyY (scale 1000) */
   USHORT       WhitePoint_y;
   USHORT       WhitePoint_Y;
   USHORT       RedChromaticity_x;     /* Red chromaticity in x,y */
   USHORT       RedChromaticity_y;
   USHORT       GreenChromaticity_x;   /* Green chromaticity in x,y */
   USHORT       GreenChromaticity_y;
   USHORT       BlueChromaticity_x;    /* Blue chromaticity in x,y */
   USHORT       BlueChromaticity_y;
   USHORT       RedGamma;              /* Gamme curve exponent (scale 1000) */
   USHORT       GreenGamma;
   USHORT       BlueGamma;
   ULONG        NumberOperationalLimits;
   ULONG        OffsetOperationalLimits;
   ULONG        NumberOptions;         /* Optional sections (gamma table) */
   ULONG        OffsetOptions;
   ULONG        OffsetStringTable;
   };
#pragma pack()

typedef struct _VDIF  VDIFRec;

#pragma pack(1)
struct _VDIFScnHdr                     /* Generic Section Header: */
   {
   ULONG        ScnLength;             /* Lenght of section */
   ULONG        ScnTag;                /* Tag for section identification */
   };
#pragma pack()
typedef struct _VDIFScnHdr  VDIFScnHdrRec;

#pragma pack(1)
struct _VDIFLimits                     /* Operational Limits: */
   {
   VDIFScnHdrRec        Header;        /* Common section info */
   USHORT       MaxHorPixel;           /* Pixels */
   USHORT       MaxVerPixel;           /* Lines */
   USHORT       MaxHorAddrLength;      /* Millimeters */
   USHORT       MaxVerAddrHeight;      /* Millimeters */
   UCHAR        VideoType;             /* TTL / Analog / ECL / DECL */
   UCHAR        SyncType;              /* TTL / Analog / ECL / DECL */
   UCHAR        SyncConfiguration;     /* Separate / C / CP / G / GP */
   UCHAR        Reserved1;             /* Padding */
   USHORT       Reserved2;             /* Padding */
   USHORT       TerminationResistance;        
   USHORT       WhiteLevel;            /* Millivolts */
   USHORT       BlackLevel;            /* Millivolts */
   USHORT       BlankLevel;            /* Millivolts */
   USHORT       SyncLevel;             /* Millivolts */
   ULONG        MaxPixelClock;         /* KiloHertz */
   ULONG        MinHorFrequency;       /* Hertz */
   ULONG        MaxHorFrequency;       /* Hertz */
   ULONG        MinVerFrequency;       /* MilliHertz */
   ULONG        MaxVerFrequency;       /* MilliHertz */
   USHORT       MinHorRetrace;         /* Nanoseconds */
   USHORT       MinVerRetrace;         /* Microseconds */
   ULONG        NumberPreadjustedTimings;
   ULONG        OffsetNextLimits;
   };
#pragma pack()
typedef struct _VDIFLimits  VDIFLimitsRec;

#pragma pack(1)
struct _VDIFTiming                     /* Preadjusted Timing: */
   {
   VDIFScnHdrRec        Header;        /* Common section info */
   ULONG        PreadjustedTimingName; /* SVGA/SVPMI mode number */
   USHORT       HorPixel;              /* Pixels */
   USHORT       VerPixel;              /* Lines */
   USHORT       HorAddrLength;         /* Millimeters */
   USHORT       VerAddrHeight;         /* Millimeters */
   UCHAR        PixelWidthRatio;       /* Gives H:V */
   UCHAR        PixelHeightRatio;
   UCHAR        Reserved1;             /* Padding */
   UCHAR        ScanType;              /* Noninterlaced / interlaced */
   UCHAR        HorSyncPolarity;       /* Negative / positive */
   UCHAR        VerSyncPolarity;       /* Negative / positive */
   USHORT       CharacterWidth;        /* Pixels */
   ULONG        PixelClock;            /* KiloHertz */
   ULONG        HorFrequency;          /* Hertz */
   ULONG        VerFrequency;          /* MilliHertz */
   ULONG        HorTotalTime;          /* Nanoseconds */
   ULONG        VerTotalTime;          /* Microseconds */
   USHORT       HorAddrTime;           /* Nanoseconds */
   USHORT       HorBlankStart;         /* Nanoseconds */
   USHORT       HorBlankTime;          /* Nanoseconds */
   USHORT       HorSyncStart;          /* Nanoseconds */
   USHORT       HorSyncTime;           /* Nanoseconds */
   USHORT       VerAddrTime;           /* Microseconds */
   USHORT       VerBlankStart;         /* Microseconds */
   USHORT       VerBlankTime;          /* Microseconds */
   USHORT       VerSyncStart;          /* Microseconds */
   USHORT       VerSyncTime;           /* Microseconds */
   };
#pragma pack()
typedef struct _VDIFTiming  VDIFTimingRec;

#pragma pack(1)
struct     _VDIFGamma                  /* Gamma Table: */
   {
   VDIFScnHdrRec Header;               /* Common sectio info */
   USHORT     GammaTableEntries;       /* Count of grays or RGB 3-tuples */
   USHORT     Unused1;
   };
#pragma pack()
typedef struct _VDIFGamma  VDIFGammaRec;

typedef enum                           /* Tags for section identification */
   {
   VDIF_OPERATIONAL_LIMITS_TAG = 1,
   VDIF_PREADJUSTED_TIMING_TAG,
   VDIF_GAMMA_TABLE_TAG
   } VDIFScnTag;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\detect_m.c ===
/************************************************************************/
/*                                                                      */
/*                              DETECT_M.C                              */
/*                                                                      */
/*        Aug 25  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.9  $
      $Date:   31 Mar 1995 11:55:44  $
	$Author:   RWOLFF  $
	   $Log:   S:/source/wnt/ms11/miniport/vcs/detect_m.c  $
 * 
 *    Rev 1.9   31 Mar 1995 11:55:44   RWOLFF
 * Changed from all-or-nothing debug print statements to thresholds
 * depending on importance of the message.
 * 
 *    Rev 1.8   11 Jan 1995 13:58:46   RWOLFF
 * Fixed bug introduced in rev. 1.4 - COM4: was detected as being a Mach8
 * or Mach32 card, which would leave the triple-boot with no valid video
 * driver.
 * 
 *    Rev 1.7   04 Jan 1995 12:02:06   RWOLFF
 * Get_BIOS_Seg() moved to SERVICES.C as part of fix for non-ATI cards
 * being detected as Mach64.
 * 
 *    Rev 1.6   23 Dec 1994 10:48:10   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.5   19 Aug 1994 17:10:56   RWOLFF
 * Added support for Graphics Wonder, fixed search for BIOS signature,
 * removed dead code.
 * 
 *    Rev 1.4   22 Jul 1994 17:46:56   RWOLFF
 * Merged with Richard's non-x86 code stream.
 * 
 *    Rev 1.3   20 Jul 1994 13:03:44   RWOLFF
 * Fixed debug print statment.
 * 
 *    Rev 1.2   31 Mar 1994 15:06:42   RWOLFF
 * Added debugging code.
 * 
 *    Rev 1.1   07 Feb 1994 14:06:42   RWOLFF
 * Added alloc_text() pragmas to allow miniport to be swapped out when
 * not needed.
 * 
 *    Rev 1.0   31 Jan 1994 11:05:48   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.3   05 Nov 1993 13:23:36   RWOLFF
 * Fixed BIOS segment detection (used to always get C000).
 * 
 *    Rev 1.2   08 Oct 1993 11:09:26   RWOLFF
 * Added "_m" to function names to identify them as being specific to the
 * 8514/A-compatible family of ATI accelerators.
 * 
 *    Rev 1.1   24 Sep 1993 11:41:58   RWOLFF
 * Removed mapping of identification-only registers for all card families,
 * added additional 8514/A-compatible information gathering formerly done
 * in ATIMP.C.
 * 
 *    Rev 1.0   03 Sep 1993 14:22:48   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
DETECT_M.C - Identify which (if any) ATI card is present in the system.

DESCRIPTION
    This file contains routines which check for the presence of various
    ATI graphics accelerators.

    NOTE: This module only has access to those I/O registers needed
          to uniquely identify which ATI card is present.

OTHER FILES

#endif

#include "dderror.h"

#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"
#include "amach.h"
#include "amach1.h"
#include "atimp.h"

#define INCLUDE_DETECT_M
#include "detect_m.h"
#include "eeprom.h"
#include "modes_m.h"
#include "services.h"
#include "setup_m.h"


/*
 * Allow miniport to be swapped out when not needed.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_M, WhichATIAccelerator_m)
#pragma alloc_text(PAGE_M, GetExtraData_m)
#pragma alloc_text(PAGE_M, ATIFindExtFcn_m)
#pragma alloc_text(PAGE_M, ATIFindEEPROM_m)
#pragma alloc_text(PAGE_M, ATIGetSpecialHandling_m)
#endif


/*
 * Static variables used by this module.
 */
static BYTE *p;             // Used to address ROM directly
static BYTE GraphicsWonderSignature[] = "GRAPHICS WONDER";


/*
 * int WhichATIAccelerator_m(void);
 *
 * Determine which (if any) ATI 8514/A-compatible
 * accelerator is present.
 *
 * Returns: Accelerator type
 *  _8514_ULTRA     - 8514/Ultra
 *  GRAPHICS_ULTRA  - Graphics ULTRA/Graphics VANTAGE
 *  MACH32_ULTRA    - 68800 detected
 *  NO_ATI_ACCEL    - no ATI 8514/A-compatible accelerator
 */
int WhichATIAccelerator_m(void)
{
	int	status;
    WORD    Scratch;        /* Temporary variable */

    /*
     * All current ATI accelerators are 8514/A compatible. Check
     * for 8514/A, and if not present assume that no ATI accelerator
     * is present.
     */

    /*
     * Ensure that the DAC gets clocks (not guaranteed in ISA machines
     * in VGA passthrough mode because the cable might not be connected).
     */
    Passth8514_m(SHOW_ACCEL);

    /*
     * Cut the pixel clock down to low speed. The value given will yield
     * 25 MHz on most of the clock chips we are dealing with.
     */
    Scratch=(INPW(CLOCK_SEL) & 0xff00) | 0x51;
    OUTPW(CLOCK_SEL,Scratch);

/************************************************************************
 * DAC index read/write test
 *   This test writes to the read index and reads it back
 *   (it should be incremented by one).  This tests for the
 *   presence of a standard DAC in an 8514/A adapter.  This
 *   test is sufficient to ensure the presence of an 8514/A
 *   type adapter.
 ************************************************************************/

	OUTP(DAC_R_INDEX,0xa4);
	short_delay();	/* This delay must be greater than	*/
			/* than the minimum delay required	*/
			/* by the DAC (see the DAC spec)	*/
	if (INP(DAC_W_INDEX) == 0xa5)
        {
        /*
         * Reading back A5 from DAC_W_INDEX always means an 8514-compatible
         * card is present, but not all 8514-compatible cards will
         * produce this value.
         */
        status=TRUE;
        VideoDebugPrint((DEBUG_DETAIL, "First test - this is an 8514/A\n"));
        }
	else{
        /*
         * Secondary test for 8514/compatible card. Reset the draw engine,
         * then write an alternating bit pattern to the ERR_TERM register.
         */
        OUTPW(SUBSYS_CNTL, 0x900F);
        OUTPW(SUBSYS_CNTL, 0x400F);
        OUTPW(ERR_TERM, 0x5555);
        WaitForIdle_m();
        /*
         * If we don't read back the value we wrote, then there is
         * no 8514-compatible card in the system. If we do read back
         * what we wrote, we must repeat the test with the opposite
         * bit pattern.
         */
        if (INPW(ERR_TERM) != 0x5555)
            {
            status=FALSE;
            VideoDebugPrint((DEBUG_DETAIL, "Second test - 0x5555 not found, no 8514/A\n"));
            }
        else{
            OUTPW(ERR_TERM, 0x0AAAA);
            WaitForIdle_m();
            if (INPW(ERR_TERM) != 0x0AAAA)
                {
                status=FALSE;
                VideoDebugPrint((DEBUG_DETAIL, "Second test - 0xAAAA not found, no 8514/A\n"));
                }
            else
                {
                status=TRUE;
                VideoDebugPrint((DEBUG_DETAIL, "Second test - this is an 8514/A\n"));
                }
            }
        }

    /*
     * Turn on passthrough so display is driven by VGA.
     */
    Passth8514_m(SHOW_VGA);

    if (status == FALSE)
        {
        VideoDebugPrint((DEBUG_DETAIL, "No 8514/A-compatible card found\n"));
        return NO_ATI_ACCEL;
        }


    /*
     * We now know that the video card is 8514/A compatible. Now check
     * to see if it has the ATI extensions.
     */
    Scratch = INPW (ROM_ADDR_1);    // save original value
    OUTPW (ROM_ADDR_1,0x5555);      // bits 7 and 15 must be zero

    WaitForIdle_m();

    status = INPW(ROM_ADDR_1) == 0x5555 ? TRUE : FALSE;

    OUTPW  (ROM_ADDR_1, Scratch);
    if (status == FALSE)
        {
        VideoDebugPrint((DEBUG_DETAIL, "8514/A-compatible card found, but it doesn't have ATI extensions\n"));
        return NO_ATI_ACCEL;
        }


    /*
     * We know that an ATI accelerator is present. Determine which one.
     */

    VideoDebugPrint((DEBUG_DETAIL, "8514/A-compatible card found with ATI extensions\n"));
#if !defined (i386) && !defined (_i386_)
    /*
     * Alpha Jensen under test falsely reports Mach 32 as Mach 8
     */
    Scratch = 0x02aa;
#else
    // This is not a R/W register in the Mach 8 but it is in the Mach 32
    OUTPW (SRC_X,0xaaaa);		// fill with a dummy value
    WaitForIdle_m();
    Scratch = INPW(R_SRC_X);
#endif
    if (Scratch == 0x02aa)
        {
        status = MACH32_ULTRA;
    	if (INPW(CONFIG_STATUS_1) & 1)	    //is 8514 or VGA enabled decides eeprom
            {
            Mach32DescribeEEPROM(STYLE_8514);
            }
        else
            {
            Mach32DescribeEEPROM(STYLE_VGA);
            }
        }

    else{
        /*
         * Mach 8 card found, determine which one.
         *
         * Only the 8514/ULTRA shares its clock with the VGA.
         * We can't check for the IBM 8514 ROM pages to be
         * enabled, because if we did an 8514/ULTRA with the
         * jumper set to disable the EEPROM would be falsely
         * recognized as a Graphics ULTRA.
         *
         * Even if this jumper is set to "disabled", we can
         * still read from the EEPROM.
         */
        if (INPW(CONFIG_STATUS_2) & SHARE_CLOCK)
            {
            status = _8514_ULTRA;
            /*
             * Only the 8514/Ultra has a hardware bug that prevents it
             * from writing to the EEPROM when it is in an 8 bit ISA bus.
             */
    	    if (   ((INPW(CONFIG_STATUS_1) & MC_BUS) == 0)     // ISA  bus only
	    	&& ((INPW(CONFIG_STATUS_1) & BUS_16) == 0))    // 8 bit BUS
                {
                Mach8UltraDescribeEEPROM(BUS_8BIT);
                }
            else
                {
                Mach8UltraDescribeEEPROM(BUS_16BIT);
                }
            }
        else{
            /*
             * Graphics ULTRA or Graphics VANTAGE found. For our purposes,
             * they are identical.
             */
            status = GRAPHICS_ULTRA;
            Mach8ComboDescribeEEPROM();
            }
        }

    phwDeviceExtension->ee = &g_ee;

    return (status);

}   /* WhichATIAccelerator_m() */



/*
 * void GetExtraData_m(void);
 *
 * Collect additional data (register locations and revision-specific
 * card capabilities) for the 8514/A-compatible family of ATI accelerators.
 */
void GetExtraData_m(void)
{
    struct query_structure *QueryPtr;   /* Query information for the card */

    
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);
    ati_reg  = reg1CE;              // ATI VGA extended register
    vga_chip = VideoPortReadRegisterUchar (&((QueryPtr->q_bios)[VGA_CHIP_OFFSET]));     /* VGA chip revision as ASCII */

    // Find out whether extended BIOS functions and the EEPROM are available.
    QueryPtr->q_ext_bios_fcn = ATIFindExtFcn_m(QueryPtr);
    QueryPtr->q_eeprom = ATIFindEEPROM_m(QueryPtr);

    ATIGetSpecialHandling_m(QueryPtr);           // special card distinctions
    return;
}   /* GetExtraData_m() */



/*
 * BOOL ATIFindExtFcn_m(QueryPtr)
 *
 * struct query_structure *QueryPtr;    Pointer to query structure
 *
 * Routine to see if extended BIOS functions for setting the accelerator
 * mode are present in the BIOS of an ATI accelerator card. Assumes that
 * an ATI accleratore with a ROM BIOS is present, results are undefined
 * if this assumption is invalid.
 */
BOOL ATIFindExtFcn_m(struct query_structure *QueryPtr)
{

    /*
     * TEMPORARY WORKAROUND: Windows NT does not yet provide a hook
     * to make an absolute far call to real mode code. To avoid
     * branching into code which depends on this service being available,
     * report that no extended BIOS functions are available.
     *
     * Once this hook becomes available so that we can use
     * extended BIOS functions, we can check the BIOS to see
     * if it contains entry points. On Mach 8 and Mach 32
     * accelerators with extended BIOS functions, there will
     * be an unconditional jump located at the entry point
     * for each extended function.
     */
    return FALSE;

}   /* ATIFindExtFcn_m() */



/*
 * BOOL ATIFindEEPROM_m(QueryPtr);
 *
 * struct query_structure *QueryPtr;    Pointer to query structure
 *
 * Routine to see if an EEPROM is present on an ATI accelerator card.
 * Assumes that an ATI accelerator is present and the model is known,
 * results are undefined if this assumption is invalid.
 *
 * Returns:
 *  TRUE if an EEPROM is present on the card
 *  FALSE if no EEPROM is present
 */
BOOL ATIFindEEPROM_m(struct query_structure *QueryPtr)
{
    WORD ValueRead;     /* Value read from the EEPROM */


    /*
     * The EEPROM read will return all bits the same if no EEPROM
     * is present. If an EEPROM is present, word 2 will have at least
     * one bit set and at least one bit cleared regardless of
     * accelerator type (8514/ULTRA, Graphics Ultra, or Mach 32).
     */
    ValueRead = (g_ee.EEread) (2);
    VideoDebugPrint((DEBUG_NORMAL, "Value read from second EEPROM word is 0x%X\n", ValueRead));
    if ((ValueRead == 0x0FFFF) || !ValueRead)
        {
        VideoDebugPrint((DEBUG_NORMAL, "Will check for OEM accelerator\n"));
        return FALSE;
        }
    else
        {
        VideoDebugPrint((DEBUG_NORMAL, "Won't check for OEM accelerator\n"));
        return TRUE;
        }

}   /* ATIFindEEPROM_m() */


/*
 * void ATIGetSpecialHandling_m(QueryPtr);
 *
 * struct query_structure *QueryPtr;    Pointer to query structure
 *
 * Finds out from ROM BIOS whether or not 1280x1024 is available on
 * a Mach 8 card, and whether or not all bits of memory aperture
 * location are found in MEM_CFG register on a Mach 32. Assumes
 * that an ATI accelerator with a ROM BIOS is present, results
 * are undefined if this assumption is invalid.
 */
void ATIGetSpecialHandling_m(struct query_structure *QueryPtr)
{
    USHORT SearchLoop;  /* Used in finding beginning of Graphics Wonder ID string */
    USHORT ScanLoop;    /* Used in stepping through Graphics Wonder ID string */


    /*
     * Check the BIOS revision number. Mach 8 cards with a BIOS
     * revision prior to 1.4 can't do 1280x1024, but use the same
     * mode table for 132 column text mode.
     *
     * Some BIOS revisions (including 1.40 on a Graphics Ultra)
     * only contain the first digit of the minor revision in the
     * BIOS, while others (including 1.35 on an 8514/ULTRA) contain
     * the entire minor revision.
     *
     * The q_ignore1280 field is ignored for Mach 32 cards.
     */
    if((VideoPortReadRegisterUchar (&((QueryPtr->q_bios)[MACH8_REV_OFFSET])) < 1) ||    // Major revision
        (VideoPortReadRegisterUchar (&((QueryPtr->q_bios)[MACH8_REV_OFFSET+1])) < 4) || // Single-digit minor revision
        ((VideoPortReadRegisterUchar (&((QueryPtr->q_bios)[MACH8_REV_OFFSET+1])) >= 10) &&  // 2-digit minor revision
        (VideoPortReadRegisterUchar (&((QueryPtr->q_bios)[MACH8_REV_OFFSET+1])) < 40)))
        QueryPtr->q_ignore1280 = TRUE;
    else
        QueryPtr->q_ignore1280 = FALSE;



    /*
     * On the Mach 32, bit 0 of BIOS byte MACH32_EXTRA_OFFSET will
     * be set if bits 7 through 11 of the aperture address are to
     * located in SCRATCH_PAD_0 and clear if all the bits are in
     * MEM_CFG.
     *
     * The q_m32_aper_calc field is ignored for Mach 8 cards.
     */
    if (VideoPortReadRegisterUchar (&((QueryPtr->q_bios)[MACH32_EXTRA_OFFSET])) & 0x0001)
        QueryPtr->q_m32_aper_calc = TRUE;
    else
        QueryPtr->q_m32_aper_calc = FALSE;

    /*
     * The Graphics Wonder (low-cost version of the Mach 32) is
     * available with either the BT48x or the TI34075 DAC.
     *
     * These cards may be built with ASICs which passed tests on
     * modes supported by the BT48x DAC but failed tests on modes
     * only supported by the TI34075. Such a card may appear to work
     * in TI-only modes, but experience problems (not necessarily
     * reproducable on other Graphics Wonder cards, even from the
     * same production run) ranging from drawing bugs to hardware
     * damage. For this reason, Graphics Wonder cards MUST NOT be
     * run in modes not supported by the BT48x DAC.
     *
     * Initially assume that we do not have a Graphics Wonder. If
     * we find the beginning of the ID string, we can change our
     * assumption.
     */
    QueryPtr->q_GraphicsWonder = FALSE;
    for (SearchLoop = GW_AREA_START; SearchLoop < GW_AREA_END; SearchLoop++)
        {
        /*
         * Loop until we have found what might be the Graphics Wonder
         * identification string, but might also be a byte which
         * happens to match the first character in the string.
         * If we find a match, initially assume that we have
         * found the start of the string.
         */
        if (VideoPortReadRegisterUchar(&((QueryPtr->q_bios)[SearchLoop])) != GraphicsWonderSignature[0])
            continue;

        QueryPtr->q_GraphicsWonder = TRUE;
        /*
         * Check to see whether this is actually the start of the
         * Graphics Wonder identification string. If it isn't,
         * keep looking.
         */
        for (ScanLoop = 0; GraphicsWonderSignature[ScanLoop] != 0; ScanLoop++)
            {
            if (VideoPortReadRegisterUchar(&((QueryPtr->q_bios)[SearchLoop + ScanLoop]))
                != GraphicsWonderSignature[ScanLoop])
                {
                QueryPtr->q_GraphicsWonder = FALSE;
                break;
                }
            }

        /*
         * If this is a Graphics Wonder, restrict the maximum pixel
         * depth of the TI34075 DAC to that supported by the BT48x.
         *
         * Once we have found the Graphics Wonder ID string, we don't
         * need to keep looking for it.
         */
        if (QueryPtr->q_GraphicsWonder == TRUE)
            {
            for (ScanLoop = RES_640; ScanLoop <= RES_1280; ScanLoop++)
                {
                MaxDepth[DAC_TI34075][ScanLoop] = MaxDepth[DAC_BT48x][ScanLoop];
                }
            QueryPtr->q_GraphicsWonder = TRUE;
            break;
            }

        }   /* end search for Graphics Wonder */

    return;

}   /* ATIGetSpecialHandling_m() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\atimp.c ===
/************************************************************************/
/*                                                                      */
/*                              ATIMP.C                                 */
/*                                                                      */
/*      Copyright (c) 1992,         ATI Technologies Inc.               */
/************************************************************************/

//  Brades:  Changes to be merged into Rob's source
//
//  904 -- frame address stored in dar[0]. we are rgistering our LFB addres
//      in DriverIORanges, but assigning to frameaddress.
//      Is this used,  or needed????

/**********************       PolyTron RCS Utilities

  $Revision:   1.43  $
      $Date:   15 May 1996 16:29:52  $
   $Author:   RWolff  $
      $Log:   S:/source/wnt/ms11/miniport/archive/atimp.c_v  $
 *
 *    Rev 1.43   15 May 1996 16:29:52   RWolff
 * Added workaround for Alpha hang on PCI bus greater than 0, now reports
 * failure of mode set on Mach 64.
 *
 *    Rev 1.42   01 May 1996 14:07:52   RWolff
 * Calls new routine DenseOnAlpha() to determine dense space support rather
 * than assuming all PCI cards support dense space.
 *
 *    Rev 1.41   23 Apr 1996 17:16:38   RWolff
 * Now reports 1M cards with SDRAM (needs special alignment in display
 * driver), separated "internal DAC cursor double buffering needed"
 * from "this is a CT".
 *
 *    Rev 1.40   15 Mar 1996 16:27:08   RWolff
 * IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES now only frees the I/O mapped
 * registers in NT 4.0 and above. This is because the mapped values for
 * the permanent and test screens use the same virtual address, and
 * in 3.51 VideoPortUnmapMemory() refuses to unmap them.
 *
 *    Rev 1.39   12 Mar 1996 17:41:50   RWolff
 * Made IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES work under new source
 * stream display driver, removed debug print statements from ATIMPResetHw()
 * since this routine can't call pageable routines and debug print
 * statements are pageable.
 *
 *    Rev 1.38   29 Jan 1996 16:53:30   RWolff
 * Now uses VideoPortInt10() rather than no-BIOS code on PPC, removed
 * dead code.
 *
 *    Rev 1.37   23 Jan 1996 11:41:10   RWolff
 * Eliminated level 3 warnings, added debug print statements.
 *
 *    Rev 1.36   22 Dec 1995 14:51:42   RWolff
 * Added support for Mach 64 GT internal DAC, switched to TARGET_BUILD
 * to identify the NT version for which the driver is being built.
 *
 *    Rev 1.35   23 Nov 1995 11:24:40   RWolff
 * Added multihead support.
 *
 *    Rev 1.34   17 Nov 1995 13:41:02   RWolff
 * Temporary fallback until problem with VideoPortGetBaseAddress() is
 * resolved. This should have gone in as branch revision 1.33.1.0, but
 * the @#$%^&* configuration doesn't allow branches.
 *
 *    Rev 1.33   27 Oct 1995 14:20:06   RWolff
 * Fixes to bring up NT 3.51 on PPC, no longer makes mapped LFB part of
 * hardware device extension.
 *
 *    Rev 1.32   08 Sep 1995 16:36:04   RWolff
 * Added support for AT&T 408 DAC (STG1703 equivalent).
 *
 *    Rev 1.31   28 Aug 1995 16:37:36   RWolff
 * No longer restores memory size on x86 boxes in ATIMPResetHw(). This
 * is a fix for EPR 7839 - the restoration is not necessary on x86
 * machines, but on some non-x86 boxes the memory size is not restored
 * on a warm boot, so we must do it to allow the use of modes needing
 * more than 1M after booting out of a 4BPP mode.
 *
 *    Rev 1.30   24 Aug 1995 15:39:42   RWolff
 * Changed detection of block I/O cards to match Microsoft's standard for
 * plug-and-play, now reports CT and VT ASICs to the display driver.
 *
 *    Rev 1.29   03 Aug 1995 16:22:42   RWOLFF
 * Reverted to old bus ordering (PCI last) for non-Alpha machines under
 * NT 3.5. Using the new ordering (PCI first) on an x86 under 3.5
 * resulted in the display applet rejecting attempts to test 16 and 24 BPP
 * on a Mach 32 (PCI or ISA) in a PCI machine.
 *
 *    Rev 1.28   02 Jun 1995 14:19:14   RWOLFF
 * Rearranged bus test order to put PCI first, added CT internal to
 * DACs supported in no-BIOS version.
 *
 *    Rev 1.27   31 Mar 1995 11:55:18   RWOLFF
 * Changed from all-or-nothing debug print statements to thresholds
 * depending on importance of the message.
 *
 *    Rev 1.26   08 Mar 1995 11:33:18   ASHANMUG
 * The pitch in 24bpp should be the pitch in engine pixels and not true pixels
 *
 *    Rev 1.25   27 Feb 1995 17:51:50   RWOLFF
 * Now reports (Mach 64 only) whether I/O space is packed (relocatable)
 * or not, reports number of lines of offscreen memory for 4BPP as if
 * the card has 1M of video memory, since we set the card to 1M for
 * this depth.
 *
 *    Rev 1.24   24 Feb 1995 12:24:40   RWOLFF
 * Now adds text banding to the ATIModeInformation->ModeFlags bits
 * that are filled in.
 *
 *    Rev 1.23   20 Feb 1995 18:03:30   RWOLFF
 * Reporting of screen tearing on 2M boundary is now DAC-independant, added
 * 1600x1200 16BPP to modes which experience this tearing.
 *
 *    Rev 1.22   03 Feb 1995 15:13:50   RWOLFF
 * Added packets to support DCI.
 *
 *    Rev 1.21   30 Jan 1995 12:16:24   RWOLFF
 * Made definition of IBM DAC special cursor flag consistent with
 * similar flag for TVP DAC.
 *
 *    Rev 1.20   18 Jan 1995 15:38:46   RWOLFF
 * Now looks for Mach64 before looking for our older accelerators, Chrontel
 * DAC is now supported as a separate type rather than being lumped in
 * with STG1702.
 *
 *    Rev 1.19   11 Jan 1995 13:54:00   RWOLFF
 * ATIMPResetHw() now restores the memory size on Mach64 cards. This is
 * a fix for a problem that showed up on the DEC Alpha, but may affect
 * other platforms as well. In 4BPP modes, we must tell the card that it
 * has only 1M of memory, but on a warm boot, the x86 emulation did not
 * re-initialize the memory size, so until the next cold boot, only modes
 * available in 1M were listed.
 *
 *    Rev 1.18   04 Jan 1995 11:59:28   RWOLFF
 * ATIMPFindAdapter() will only detect ATI cards on the first invocation,
 * to avoid the same card being detected once per bus and causing problems
 * when Windows NT thinks it's multiple cards.
 *
 *    Rev 1.17   23 Dec 1994 10:48:10   ASHANMUG
 * ALPHA/Chrontel-DAC
 *
 *    Rev 1.16   18 Nov 1994 11:36:52   RWOLFF
 * Now checks for PCI bus, cleaned up temporary debug print statements,
 * fixed non-x86 Mach 64 handling, added support for Power PC and
 * STG1703 DAC.
 *
 *    Rev 1.15   31 Aug 1994 16:14:00   RWOLFF
 * IOCTL_VIDEO_ATI_GET_VERSION packet now reports TVP3026 DAC (different
 * cursor handling needed in display driver),
 * IOCTL_VIDEO_ATI_GET_MODE_INFORMATION now reports 1152x864 24BPP as
 * having screen tearing at end of first 2M bank.
 *
 *    Rev 1.14   22 Jul 1994 17:47:50   RWOLFF
 * Merged with Richard's non-x86 code stream.
 *
 *    Rev 1.13   20 Jul 1994 13:04:06   RWOLFF
 * Changes required to support multiple I/O base addresses for Mach 64
 * accelerator registers, ATIMPInitialize() now leaves the adapter in
 * a state where an INT 10 can switch it to a VGA mode (fix for
 * showstopper bug on Landtrain machines), calls new routine
 * FillInRegistry() so the video applet can get information about
 * the graphics card.
 *
 *    Rev 1.12   30 Jun 1994 18:11:36   RWOLFF
 * Changes to allow the new method of checking for aperture conflict.
 *
 *    Rev 1.11   15 Jun 1994 11:04:24   RWOLFF
 * In IOCTL_VIDEO_ATI_GET_VERSION, now only sets
 * RequestPacket->StatusBlock->Information if the buffer is big enough.
 *
 *    Rev 1.10   20 May 1994 19:18:00   RWOLFF
 * IOCTL_VIDEO_ATI_GET_VERSION old format packet now returns the highest
 * pixel depth for a given resolution even if it isn't the last mode
 * table for the resolution.
 *
 *    Rev 1.9   20 May 1994 13:57:40   RWOLFF
 * Ajith's change: now saves in the query structure the bus type reported by NT.
 *
 *    Rev 1.8   12 May 1994 11:04:24   RWOLFF
 * Now forces OEM handling on DEC ALPHA machines.
 *
 *    Rev 1.7   04 May 1994 19:25:40   RWOLFF
 * Fixes for hanging and corrupting screen when display applet run.
 *
 *    Rev 1.6   28 Apr 1994 10:59:56   RWOLFF
 * Moved mode-independent bug/feature flags to IOCTL_VIDEO_ATI_GET_VERSION
 * packet from IOCTL_VIDEO_ATI_GET_MODE_INFORMATION packet.
 *
 *    Rev 1.5   27 Apr 1994 13:54:42   RWOLFF
 * IOCTL_VIDEO_ATI_GET_MODE_INFORMATION packet now reports whether MIO bug
 * is present on Mach 32 cards.
 *
 *    Rev 1.4   31 Mar 1994 15:05:00   RWOLFF
 * Added DPMS support, brought ATIMPResetHw() up to latest specs, added
 * debugging code.
 *
 *    Rev 1.3   14 Mar 1994 16:32:20   RWOLFF
 * Added ATIMPResetHw() function, fix for 2M boundary tearing, replaced
 * VCS logfile comments that were omitted in an earlier checkin.
 *
 *    Rev 1.2   03 Mar 1994 12:36:56   ASHANMUG
 * Make pageable
 *
 *    Rev 1.1   07 Feb 1994 13:56:18   RWOLFF
 * Added alloc_text() pragmas to allow miniport to be swapped out when
 * not needed, removed LookForSubstitute() since miniport is no longer
 * supposed to check whether mode has been substituted, no longer logs
 * a message when the miniport aborts due to no ATI card being found,
 * removed unused routine ATIMPQueryPointerCapabilities().
 *
 *    Rev 1.0   31 Jan 1994 10:52:34   RWOLFF
 * Initial revision.

           Rev 1.6   14 Jan 1994 15:14:08   RWOLFF
        Removed commented-out code, packet announcements now all controlled by
        DEBUG_SWITCH, device reset for old cards now done by a single call,
        new format for IOCTL_VIDEO_ATI_GET_VERSION packet, reports block write
        capability in IOCTL_VIDEO_ATI_GET_MODE_INFORMATION packet, added
        1600x1200 support.

           Rev 1.5   30 Nov 1993 18:10:04   RWOLFF
        Moved query of card capabilities (once type of card is known) from
        ATIMPFindAdapter() to ATIMPInitialize() because query for Mach 64 needs
        to use VideoPortInt10(), which can't be used in ATIMPFindAdapter().

           Rev 1.4   05 Nov 1993 13:22:12   RWOLFF
        Added initial Mach64 code (currently inactive).

           Rev 1.3   08 Oct 1993 11:00:24   RWOLFF
        Removed code specific to a particular family of ATI accelerators.

           Rev 1.2   24 Sep 1993 11:49:46   RWOLFF
        Removed cursor-specific IOCTLs (handled in display driver), now selects
        24BPP colour order best suited to the DAC being used instead of forcing
        BGR.

           Rev 1.1   03 Sep 1993 14:20:46   RWOLFF
        Partway through CX isolation.

           Rev 1.0   16 Aug 1993 13:27:50   Robert_Wolff
        Initial revision.

           Rev 1.23   06 Jul 1993 15:46:14   RWOLFF
        Got rid of mach32_split_fixup special handling. This code was to support
        a non-production hardware combination.

           Rev 1.22   10 Jun 1993 15:58:32   RWOLFF
        Reading from registry now uses a static buffer rather than a dynamically
        allocated one (originated by Andre Vachon at Microsoft).

           Rev 1.21   07 Jun 1993 11:43:16   BRADES
        Rev 6 split transfer fixup.

           Rev 1.19   18 May 1993 14:04:00   RWOLFF
        Removed reference to obsolete header TTY.H, calls to wait_for_idle()
        no longer pass hardware device extension, since it's a global variable.

           Rev 1.18   12 May 1993 16:30:36   RWOLFF
        Now writes error messages to event log rather than blue screen,
        initializes "special handling" variables determined from BIOS
        to default values on cards with no BIOS. This revision contains
        code for experimental far call support, but it's "#if 0"ed out.

           Rev 1.17   10 May 1993 16:35:12   RWOLFF
        LookForSubstitute() now recognizes all cases of colour depth not
        supported by the DAC, unusable linear frame buffer now falls back
        to LFB disabled operation rather than aborting the miniport, removed
        unused variables and unnecessary passing of hardware device extension
        as a parameter.

           Rev 1.16   30 Apr 1993 17:58:50   BRADES
        ATIMP startio assign QueryPtr once at start of function.
        uses aVideoAddress virtual table for IO port addresses.

           Rev 1.15   30 Apr 1993 16:33:42   RWOLFF
        Updated to use NT build 438 initialization data structure.
        Registry read buffer is now dynamically allocated to fit data requested
        rather than being a fixed "hope it's big enough" size.

           Rev 1.14   21 Apr 1993 17:22:06   RWOLFF
        Now uses AMACH.H instead of 68800.H/68801.H.
        Accelerator detection now checks only for functionality, not our BIOS
        signature string which may not be present in OEM versions. Query
        structure now indicates whether extended BIOS functions and/or
        EEPROM are present. Added ability to switch between graphics and
        text modes using absolute far calls in BIOS. Removed handling
        of obsolete DriverOverride registry field.

           Rev 1.13   14 Apr 1993 18:30:22   RWOLFF
        24BPP is now done as BGR (supported by both TI and Brooktree DACs)
        rather than RGB (only supported by TI DACs).

           Rev 1.12   08 Apr 1993 16:53:18   RWOLFF
        Revision level as checked in at Microsoft.

           Rev 1.9   25 Mar 1993 11:10:38   RWOLFF
        Cleaned up compile warnings, now returns failure if no EEPROM is present.

           Rev 1.8   16 Mar 1993 17:15:16   BRADES
        get_cursor uses screen_pitch instead of x_size.

           Rev 1.7   16 Mar 1993 17:04:58   BRADES
        Change ATI video to graphics message

           Rev 1.6   15 Mar 1993 22:20:30   BRADES
        use m_screen_pitch for the # pixels per display lines

           Rev 1.5   08 Mar 1993 19:23:44   BRADES
        update memory sizing to 256 increments, clean code.

           Rev 1.4   10 Feb 1993 13:01:28   Robert_Wolff
        IOCTL_VIDEO_MAP_VIDEO_MEMORY no longer assumes frame buffer length
        is equal to video memory size (linear aperture present). It can now
        accept 64k (uses VGA aperture) and 0 (no aperture available).

           Rev 1.3   06 Feb 1993 12:55:52   Robert_Wolff
        Now sets VIDEO_MODE_INFORMATION.ScreenStride to bytes per line (as listed
        in the documentation). In the October beta, it had to be pixels per line.

           Rev 1.2   05 Feb 1993 22:12:36   Robert_Wolff
        Adjusted MessageDelay() to compensate for short_delay() no longer being
        optimized out of existence.

           Rev 1.1   05 Feb 1993 16:15:28   Robert_Wolff
        Made it compatible with the new DDK, registry calls now use VideoPort
        functions rather than RTL functions. This version will work with the
        framebuffer driver.

           Rev 1.0   02 Feb 1993 13:36:50   Robert_Wolff
        Initial revision.

           Rev 1.2   26 Jan 1993 10:28:30   Robert_Wolff
        Now fills in Number<colour>Bits fields in VIDEO_MODE_INFORMATION structure.

           Rev 1.1   25 Jan 1993 13:31:52   Robert_Wolff
        Re-enabled forcing of shared VGA/accelerator memory for Mach 32
        cards with no aperture enabled.

           Rev 1.0   22 Jan 1993 16:44:42   Robert_Wolff
        Initial revision.

           Rev 1.26   21 Jan 1993 17:59:24   Robert_Wolff
        Eliminated multiple definition link warnings, updated comments
        in LookForSubstitute().

           Rev 1.25   20 Jan 1993 17:47:48   Robert_Wolff
        Now checks optional DriverOverride field in registry, and forces
        use of appropriate (engine, framebuffer, or VGAWonder) driver
        if the field is present and nonzero. If field is missing or zero,
        former behaviour is used.
        IOCTL_VIDEO_ATI_GET_VERSION packet now also returns the maximum
        pixel depth available at each resolution.
        Added mode substitution case for 16 BPP selected when using the
        engine-only (fixed 8 BPP colour depth) driver.

           Rev 1.24   15 Jan 1993 15:12:26   Robert_Wolff
        Added IOCTL_VIDEO_ATI_GET_VERSION packet in ATIMPStartIO() to
        return version number of the miniport.

           Rev 1.23   14 Jan 1993 17:49:40   Robert_Wolff
        Removed reference to blank screen in message printed before query
        structure filled in, moved printing of this message and the "Done."
        terminator so all checking for video cards is between them.

           Rev 1.22   14 Jan 1993 10:37:28   Robert_Wolff
        Re-inserted "fail if VGAWonder but no ATI accelerator" check due
        to lack of VGAWONDER .DLL file in late January driver package.

           Rev 1.21   13 Jan 1993 13:31:04   Robert_Wolff
        Added support for the Corsair and other machines which don't store
        their aperture location in the EEPROM, single miniport now handles
        VGAWonder in addition to accelerators.

           Rev 1.20   07 Jan 1993 18:20:34   Robert_Wolff
        Now checks to see if aperture is configured but unusable, and
        forces the use of the engine-only driver if this is the case.
        Added message to let users know that the black screen during
        EEPROM read is normal.

           Rev 1.19   06 Jan 1993 11:04:36   Robert_Wolff
        BIOS locations C0000-DFFFF now mapped as one block, cleaned up warnings.

           Rev 1.18   04 Jan 1993 14:39:50   Robert_Wolff
        Added card type as a parameter to setmode().

           Rev 1.17   24 Dec 1992 14:41:20   Chris_Brady
        fixup warnings

           Rev 1.16   15 Dec 1992 13:34:46   Robert_Wolff
        Writing of MEM_CFG when forcing 4M aperture now preserves all but
        the aperture size bits. This allows operation on Corsair as well
        as standard versions of the Mach 32 card.

           Rev 1.15   11 Dec 1992 14:45:44   Robert_Wolff
        Now forces the use of the FRAMEBUF driver if a 2M aperture is configured.

           Rev 1.14   11 Dec 1992 09:47:34   Robert_Wolff
        Now sets the "don't show the substitution message" flag no matter what
        the status of the first call to LookForSubstitute() was (sub, no sub,
        or error), rather than only when a substitution was made and the message
        was displayed.

           Rev 1.13   10 Dec 1992 14:24:16   Robert_Wolff
        Shortened mode substitution messages in LookForSubstitute(), messages
        are now displayed only on the first call to this routine, to avoid
        delays in switching back to graphics mode from a full-screen DOS box.

           Rev 1.12   09 Dec 1992 14:18:38   Robert_Wolff
        Eliminated uninitialized pointer in IOCTL_VIDEO_SET_CURRENT_MODE
        packet, moved initialization of QueryPtr and FirstMode pointers
        to before the switch on packet type, rather than being in all
        packets where the pointers are used. This should prevent similar
        problems if other packets are changed to use the pointers, and
        eliminates redundant code.

           Rev 1.11   09 Dec 1992 10:35:04   Robert_Wolff
        Added user-level "blue-screen" messages for fatal errors, checks BIOS
        revision to catch Mach 8 cards that can't do 1280x1024, forces the
        use of the engine-only driver if no aperture is configured, memory
        boundary and hardware cursor stuff is now done only for Mach 32 cards
        (since they're only available on Mach 32), sets split pixel mode for
        Mach 8 in 1280x1024, added mode substitution message for Mach 8 when
        registry is configured for 16 BPP or higher.

           Rev 1.10   01 Dec 1992 17:00:18   Robert_Wolff
        "I-beam" text insertion cursor no longer has left side filled with a
        solid black block.

           Rev 1.9   30 Nov 1992 17:34:38   Robert_Wolff
        Now allows 1M aperture if configured video mode uses less than 1M
        of video memory, prints message to user if Windows NT decides
        to use a video mode other than the one configured in the registry.

           Rev 1.8   27 Nov 1992 18:40:24   Chris_Brady
        VGA Wonder detect looks for signature in a range.
        Graphics Ultra Pro Microchannel version moved it.

           Rev 1.7   25 Nov 1992 09:47:36   Robert_Wolff
        Now tells GetCapMach32() to assume the VGA boundary is set to shared,
        since we will set it to this value later, and we don't want to lose
        access to modes which require some of the memory currently assigned
        to the VGA. Added delay in IOCTL_VIDEO_SET_CURRENT_MODE case of
        ATIMPStartIO() after calculating the hardware cursor offset. This delay
        may not be needed, but I didn't want to remove it since this is the
        source for the driver sent to QA and I wanted it to be rebuildable.

           Rev 1.6   20 Nov 1992 16:04:30   Robert_Wolff
        Now reads query information from Mach 8 cards instead of only
        from Mach 32 cards. Mach 8 cards still cause ATIMPFindAdapter()
	to return ERROR_INVALID_PARAMETER, since until we get an engine-only
        driver, we can't use a card that doesn't support an aperture.

           Rev 1.5   19 Nov 1992 09:53:36   GRACE
        after setting a mode do a wait for idle to let the pixel clock settle before
        using engine to draw.

           Rev 1.4   17 Nov 1992 14:07:52   GRACE
        changed framelength to reflect the size of memory on the board not the
        aperture size.
        In the StartIO section, only set up QueryPtr and FirstMode when necessary

           Rev 1.3   12 Nov 1992 09:23:02   GRACE
        removed the struct definition for DeviceExtension to a68.h
        Not using DevInitATIMP, DevSetCursorShape, DevSetCursorPos or DevCursorOff.
	DevCursorOff changed to a define that turns cursor off with an OUTP.
        Also removed some excess junk that is left from the video program.

           Rev 1.2   06 Nov 1992 19:12:48   Robert_Wolff
        Fixed signed/unsigned bug in multiple calls to VideoPortInitialize().
        Now requests access to I/O ports and ROM addresses used for VGA-style
        EEPROM reads, and gets information about installed modes from the
        Mach32 card.

        NOTE: This is a checkpoint for further changes. Due to incompatibilities
              between the old (hardcoded resolution) code in other modules and the
              new (read from the card) code here, this revision will not produce a
              working driver.

           Rev 1.1   05 Nov 1992 12:02:18   Robert_Wolff
        Now reads query structure and mode tables from the MACH32 card
        rather than using hardcoded values for aperture size/location
        and supported modes.

           Rev 1.0   02 Nov 1992 20:47:58   Chris_Brady
        Initial revision.


End of PolyTron RCS section                             *****************/

#ifdef DOC

DESCRIPTION
     ATI Windows NT Miniport driver for the Mach 64, Mach32, and Mach8
     families.
     This file will select the appropriate functions depending on the
     computer configuration.

OTHER FILES
     ???

#endif

#include <stdio.h>
#include <string.h>

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "stdtyp.h"

#include "amach1.h"
#include "vidlog.h"

/*
 * To avoid multiple definition errors, pre-initialized variables
 * in ATIMP.H are initialized if INCLUDE_ATIMP is defined, but
 * are declared external if it is not defined. For consistency,
 * define this value here rather than in other files which also include
 * ATIMP.H so the variables are initialized by the source file with
 * the same root name as the header file.
 */
#define INCLUDE_ATIMP
#include "detect_m.h"
#include "amachcx.h"
#include "atimp.h"
#include "atint.h"
#include "atioem.h"
#include "cvtddc.h"
#include "dpms.h"
#include "eeprom.h"
#include "init_cx.h"
#include "init_m.h"
#include "modes_m.h"
#include "query_cx.h"
#include "query_m.h"
#include "services.h"
#include "setup_cx.h"
#include "setup_m.h"



//------------------------------------------------------------------

/*
 * Initially assume we have not yet found a non-block card, and
 * have found no block relocatable cards.
 */
BOOL FoundNonBlockCard = FALSE;
USHORT NumBlockCardsFound = 0;

/*------------------------------------------------------------------------
 *
 * Function Prototypes
 *
 * Functions that start with 'ATIMP' are entry points for the OS port driver.
 */

ULONG
DriverEntry (
    PVOID Context1,
    PVOID Context2
    );

VP_STATUS
ATIMPFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

BOOLEAN
ATIMPInitialize(
    PVOID HwDeviceExtension
    );

BOOLEAN
ATIMPStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

BOOLEAN
ATIMPResetHw(
    IN PVOID HwDeviceExtension,
    IN ULONG Columns,
    IN ULONG Rows
    );

//
// New entry points added for NT 5.0.
//

#if (TARGET_BUILD >= 500)

//
// Routine to set a desired DPMS power management state.
//
VP_STATUS
ATIMPSetPower50(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT pVideoPowerMgmt
    );

//
// Routine to retrieve possible DPMS power management states.
//
VP_STATUS
ATIMPGetPower50(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT pVideoPowerMgmt
    );

//
// Routine to retrieve the Enhanced Display ID structure via DDC
//
ULONG
ATIMPGetVideoChildDescriptor(
    PVOID pHwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    );
#endif  // TARGET_BUILD >= 500


//
// Routine to set the DPMS power management state.
//
BOOLEAN
SetDisplayPowerState(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    VIDEO_POWER_STATE VideoPowerState
    );

//
// Routine to retrieve the current DPMS power management state.
//
VIDEO_POWER_STATE
GetDisplayPowerState(
    PHW_DEVICE_EXTENSION phwDeviceExtension
    );


/* */
UCHAR RegistryBuffer[REGISTRY_BUFFER_SIZE];     /* Last value retrieved from the registry */
ULONG RegistryBufferLength = 0;     /* Size of last retrieved value */

/*
 * Allow miniport to be swapped out when not needed.
 *
 * ATIMPResetHw() must be in the non-paged pool.
 *
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_COM, DriverEntry)
#pragma alloc_text(PAGE_COM, ATIMPFindAdapter)
#pragma alloc_text(PAGE_COM, ATIMPInitialize)
#pragma alloc_text(PAGE_COM, ATIMPStartIO)
#if (TARGET_BUILD >= 500)
#pragma alloc_text(PAGE_COM, ATIMPSetPower50)
#pragma alloc_text(PAGE_COM, ATIMPGetPower50)
#pragma alloc_text(PAGE_COM, ATIMPGetVideoChildDescriptor)
#endif  // TARGET_BUILD >= 500
#pragma alloc_text(PAGE_COM, RegistryParameterCallback)
#endif


//------------------------------------------------------------------------

ULONG
DriverEntry (
    PVOID Context1,
    PVOID Context2
    )

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    Context1 - First context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

    Context2 - Second context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

Return Value:

    Status from VideoPortInitialize()

--*/

{

    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    /*
     * Most recently returned and lowest received so far return values
     * from VideoPortInitialize().
     *
     * BUGBUG: According to the docs and include files, these should
     *         be of type VP_STATUS (maps to long). When tracing
     *         through the code, however, I saw that a failed call
     *         to VideoPortInitialize() due to submitting the wrong
     *         bus type yields a code of 0xC00000C0 while one which
     *         succeeds yields 0x00000000. When following the format
     *         of the NTSTATUS (maps to unsigned long) type, these are
     *         STATUS_DEVICE_DOES_NOT_EXIST and STATUS_SUCCESS respectively.
     *         The docs on VideoPortInitialize() say to return the smallest
     *         returned value if multiple calls are made (consistent with
     *         the NTSTATUS format where the 2 most significant bits are
     *         00 for success, 01 for information, 10 for warning, and
     *         11 for error, since the multiple calls would be for mutually
     *         exclusive bus types), presumably to return the best possible
     *         outcome (fail only if we can't find any supported bus).
     *
     *         If we use the VP_STATUS type as recommended, error conditions
     *         will be seen as smaller than success, since they are negative
     *         numbers (MSB set) and success is positive (MSB clear). Use
     *         unsigned long values to avoid this problem.
     */
    ULONG   ThisInitStatus;
    ULONG   LowestInitStatus;


    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA));
    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);
    /*
     * Set entry points.
     */
    hwInitData.HwFindAdapter = ATIMPFindAdapter;
    hwInitData.HwInitialize  = ATIMPInitialize;
    hwInitData.HwInterrupt   = NULL;
    hwInitData.HwStartIO     = ATIMPStartIO;
    hwInitData.HwResetHw     = ATIMPResetHw;

#if (TARGET_BUILD >= 500)

    //
    // Set new entry points added for NT 5.0.
    //

    //
    // We can only enable these for a PnP driver, and this is not
    // a pnp driver.  At least at the moment.
    //

    hwInitData.HwSetPowerState = ATIMPSetPower50;
    hwInitData.HwGetPowerState = ATIMPGetPower50;
    hwInitData.HwGetVideoChildDescriptor = ATIMPGetVideoChildDescriptor;

#endif  // TARGET_BUILD >= 500


    hwInitData.HwDeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);

    /*
     * Call VideoPortInitialize() once for each type of interface we support.
     * As documented in the DDK, return the lowest status value returned
     * by this function.
     *
     * The DEC Alpha requires the new ordering (PCI first) in both
     * 3.5 and 3.51, while the x86 requires the new ordering in 3.51
     * and the old ordering in 3.5. I haven't built a new miniport
     * for either Power PC or MIPS since implementing the new order,
     * so for now assume that they require the old order.
     *
     * On the x86, using the new order in 3.5 will result in the
     * IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES packet failing on
     * the Mach 32 in PCI systems, which leaves 16 and 24 BPP
     * listed as available in the video applet but being rejected
     * when they are tested.
     */
#if !defined(_ALPHA_) && !defined(IOCTL_VIDEO_SHARE_VIDEO_MEMORY)
    hwInitData.AdapterInterfaceType = Eisa;
    LowestInitStatus =  (ULONG) VideoPortInitialize(Context1, Context2, &hwInitData, NULL);

    hwInitData.AdapterInterfaceType = Isa;
    ThisInitStatus = (ULONG) VideoPortInitialize(Context1, Context2, &hwInitData, NULL);
    if (ThisInitStatus < LowestInitStatus)
        LowestInitStatus = ThisInitStatus;

    hwInitData.AdapterInterfaceType = MicroChannel;
    ThisInitStatus = (ULONG) VideoPortInitialize(Context1, Context2, &hwInitData, NULL);
    if (ThisInitStatus < LowestInitStatus)
        LowestInitStatus = ThisInitStatus;

    hwInitData.AdapterInterfaceType = PCIBus;
    ThisInitStatus = (ULONG) VideoPortInitialize(Context1, Context2, &hwInitData, NULL);
    if (ThisInitStatus < LowestInitStatus)
        LowestInitStatus = ThisInitStatus;
#else
    hwInitData.AdapterInterfaceType = PCIBus;
    LowestInitStatus =  (ULONG) VideoPortInitialize(Context1, Context2, &hwInitData, NULL);

    hwInitData.AdapterInterfaceType = Eisa;
    ThisInitStatus = (ULONG) VideoPortInitialize(Context1, Context2, &hwInitData, NULL);
    if (ThisInitStatus < LowestInitStatus)
        LowestInitStatus = ThisInitStatus;

    hwInitData.AdapterInterfaceType = Isa;
    ThisInitStatus = (ULONG) VideoPortInitialize(Context1, Context2, &hwInitData, NULL);
    if (ThisInitStatus < LowestInitStatus)
        LowestInitStatus = ThisInitStatus;

    hwInitData.AdapterInterfaceType = MicroChannel;
    ThisInitStatus = (ULONG) VideoPortInitialize(Context1, Context2, &hwInitData, NULL);
    if (ThisInitStatus < LowestInitStatus)
        LowestInitStatus = ThisInitStatus;
#endif

    return LowestInitStatus;

}   /* end DriverEntry() */

//------------------------------------------------------------------------

VP_STATUS
ATIMPFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    )

/*++

Routine Description:
    This routine is the main execution entry point for the miniport driver.
    It accepts a Video Request Packet, performs the request, and then
    returns with the appropriate status.

Arguments:
    HwDeviceExtension - Supplies the miniport driver's adapter storage. This
        storage is initialized to zero before this call.

    HwContext - Supplies the context value which was passed to
        VideoPortInitialize().

    ArgumentString - Suuplies a NYLL terminated ASCII string. This string
        originates from the user.

    ConfigInfo - Returns the configuration information structure which is
        filled by the miniport driver . This structure is initialized with
        any knwon configuration information (such as SystemIoBusNumber) by
        the port driver. Where possible, drivers should have one set of
        defaults which do not require any supplied configuration information.

    Again - Indicates if the miniport driver wants the port driver to call
        its VIDEO_HW_FIND_ADAPTER function again with a new device extension
        and the same config info. This is used by the miniport drivers which
        can search for several adapters on a bus.

Return Value:

    This routine must return:

    NO_ERROR - Indicates a host adapter was found and the
        configuration information was successfully determined.

    ERROR_INVALID_PARAMETER - Indicates a host adapter was found but there was an
        error obtaining the configuration information. If possible an error
        should be logged.

    ERROR_INVALID_PARAMETER - Indicates the supplied configuration was invalid.

    ERROR_DEV_NOT_EXIST - Indicates no host adapter was found for the
        supplied configuration information.

--*/

{
    VP_STATUS status;
    struct query_structure *QueryPtr;   /* Query information for the card */
    phwDeviceExtension = HwDeviceExtension;


    VideoDebugPrint((DEBUG_NORMAL, "ATI: FindAdapter\n"));

    /*
     * On systems with multiple buses (i.e. any PCI/ISA system), this
     * routine will be called once for each bus, and each invocation
     * will detect the ATI card. To keep Windows NT from thinking that
     * there are multiple cards, check to see if we have found an ATI
     * card on a previous invocation, and if we have, report that there
     * is no ATI card.
     */
    if (ConfigInfo->AdapterInterfaceType == PCIBus)
        {

        VIDEO_ACCESS_RANGE AccessRange3C0 = { 0x3C0, 0, 1, 1, 1, 1};

        VideoDebugPrint((DEBUG_NORMAL, "PCI bus\n"));
#if defined(ALPHA) || defined(_ALPHA_)
        /*
         * On the DEC Alpha, our card detection runs into trouble
         * on all but the first (bridged to ISA/EISA, supports
         * VGA BIOS emulation) PCI bus.
         */
        if (ConfigInfo->SystemIoBusNumber > 0)
            {
            VideoDebugPrint((DEBUG_NORMAL, "Alpha, not first PCI bus - skipping\n"));
            return ERROR_DEV_NOT_EXIST;
            }
#endif
        //
        // AndreVa.
        // Since we have a PnP driver, all detection is done throught the
        // inf - no slot searching.
        // Fix code that is lower in DetectMach64 later.
        //
        // For now, just make sure the card is enabled and fail if it's not,
        // so we don't any a different card via the searching mechanism.
        // This only happens if you have a disabled ATI card on the motherboard
        // and an active one in a slot
        //

        if (NO_ERROR != VideoPortVerifyAccessRanges(HwDeviceExtension,
                                                    1,
                                                    &AccessRange3C0))
        {
            VideoDebugPrint((DEBUG_NORMAL, "ATI: PCI FindAdapter called for Disabled card\n"));
            *Again = 0;     /* We don't want to be called again */
            return ERROR_DEV_NOT_EXIST;
        }

        }
    else if (ConfigInfo->AdapterInterfaceType == Isa)
        {
        VideoDebugPrint((DEBUG_NORMAL, "ISA bus\n"));
        }
    else if (ConfigInfo->AdapterInterfaceType == Eisa)
        {
        VideoDebugPrint((DEBUG_NORMAL, "EISA bus\n"));
        }
    else if (ConfigInfo->AdapterInterfaceType == MicroChannel)
        {
        VideoDebugPrint((DEBUG_NORMAL, "MicroChannel bus\n"));
        }

    if ((FoundNonBlockCard == TRUE) || (NumBlockCardsFound == ATI_MAX_BLOCK_CARDS))
        {
        VideoDebugPrint((DEBUG_NORMAL, "ATI: FindAdapter already found maximum number of supported cards\n"));
        *Again = 0;     /* We don't want to be called again */
        return ERROR_DEV_NOT_EXIST;
        }

    /*
     * Get a formatted pointer into the query section of HwDeviceExtension.
     * The CardInfo[] field is an unformatted buffer.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);

    /*
     * Save the bus type reported by NT
     */
    QueryPtr->q_system_bus_type = ConfigInfo->AdapterInterfaceType;


    /*
     * Initially we don't know whether or not block write mode is available.
     */
    QueryPtr->q_BlockWrite = BLOCK_WRITE_UNKNOWN;

    /*
     * Make sure the size of the structure is at least as large as what we
     * are expecting (check version of the config info structure).
     * If this test fails, it's an unrecoverable error, so we don't want
     * to be called again.
     */
    if (ConfigInfo->Length < sizeof(VIDEO_PORT_CONFIG_INFO))
        {
        VideoPortLogError(HwDeviceExtension, NULL, VID_SMALL_BUFFER, 1);
        *Again = 0;
        return ERROR_INVALID_PARAMETER;
        }

    /********************************************************************/
    /* Find out which of our accelerators, if any, is present.          */
    /********************************************************************/


    /*
     * Look for an ATI accelerator card. This test does not require
     * information retrieved from the BIOS or the EEPROM (which may not
     * be present in some versions of our cards).
     *
     * Initially assume that we are looking for a Mach 64 accelerator,
     * since the test for this family is less destructive (doesn't
     * black out the screen on DEC Alpha machines) than the test for
     * one of our 8514/A-compatible accelerators.
     *
     * Don't report failure if we are unable to map the I/O ranges
     * used by the Mach 64 accelerators, since if we are dealing with
     * one of our 8514/A-compatible accelerators this is irrelevant.
     *
     * CompatIORangesUsable_cx() calls DetectMach64() when it's checking
     * to see which base address to use for the accelerator registers,
     * so if this calll succeeds we know that a Mach 64 is present.
     * If the call fails, there is no need to unmap the I/O ranges
     * it has mapped, since it always cleans up after itself when it
     * finds that a particular base address is not being used for a
     * Mach 64. As a result, a failed call will not leave any addresses
     * mapped, since no available base address was used by a Mach 64.
     */
    if ((status = CompatIORangesUsable_cx(ConfigInfo->AdapterInterfaceType)) == NO_ERROR)
        {
        phwDeviceExtension->ModelNumber = MACH64_ULTRA;
        }
    else if (NumBlockCardsFound == 0)
        {
        /*
         * There is no Mach 64 present, so look for one of our
         * 8514/A-compatible accelerators (Mach 8 and Mach 32).
         * The check on NumBlockCardsFound is to catch the case
         * where we found a relocatable card on a previous bus
         * type, so we won't have dropped out due to FoundNonBlockCard
         * being TRUE but CompatIORangesUsable_cx() won't find
         * a Mach 64 on this bus type.
         */

        /*
         * Since we don't use PCI detection, don't look for these cards
         * on the PCI bus, except for the Mach 32 PCI AX
         */
        if (ConfigInfo->AdapterInterfaceType == PCIBus)
        {
            PCI_COMMON_CONFIG ConfigData;
            ULONG RetVal;

            RetVal = VideoPortGetBusData(phwDeviceExtension,
                                        PCIConfiguration,
                                        0,
                                        &ConfigData,
                                        0,
                                        PCI_COMMON_HDR_LENGTH);

            /*
             * If we received an error return, skip to the
             * next possible slot.
             */
            if ((RetVal == PCI_COMMON_HDR_LENGTH) &&
                (ConfigData.VendorID == 0x1002)   &&
                (ConfigData.DeviceID == 0x4158))
            {
                VideoDebugPrint((DEBUG_NORMAL, "FOUND PnP Mach 32 AX card found\n"));
            }
            else
            {
                *Again = 0;
                return ERROR_DEV_NOT_EXIST;
            }
        }

        /* If we can't map the I/O base addresses used by these cards,
         * then there is no ATI accelerator present. Unmap any of
         * the ranges which may have been mapped, then report failure.
         *
         * In the event of failure to find a Mach 8 or Mach 32,
         * report that we don't want to be called again for the
         * current bus, but don't set LookForAnotherCard to zero.
         * This is because there may still be a block relocatable
         * card on a subsequent bus.
         */
        status = CompatIORangesUsable_m();
        if (status != NO_ERROR)
            {
            UnmapIORanges_m();
            VideoPortLogError(HwDeviceExtension, NULL, VID_CANT_MAP, 2);
            *Again = 0;
            return status;
            }

#if !defined (i386) && !defined (_i386_)
        /*
         *  ALPHA - The miniport will have to perform the ROM Bios functions
         * that are normally done on bootup in x86 machines.
         * For now we will initialize them the way they are specifically
         * on this card that we are currently using.
         */
        AlphaInit_m();

#endif

        /*
         * Check which of our 8514/A-accelerators is present. If we
         * can't find one, unmap the I/O ranges and report failure.
         *
         * Don't log an error, because NT tries all the miniports
         * on initial setup to see which card is installed, and failure
         * to find an ATI card is a normal condition if another brand
         * of accelerator is present.
         *
         */
        phwDeviceExtension->ModelNumber = WhichATIAccelerator_m();
        if (phwDeviceExtension->ModelNumber == NO_ATI_ACCEL)
            {
            UnmapIORanges_m();
            *Again = 0;
            return ERROR_DEV_NOT_EXIST;
            }

        /*
         * We have found a Mach 8 or Mach 32. None of these cards are
         * block relocatable, so we must not look for another card
         * (since we don't support a mix of block and non-block
         * cards).
         */
        FoundNonBlockCard = TRUE;
        LookForAnotherCard = 0;

        }   /* endif (no Mach 64) */
    else
        {
        /*
         * A relocatable Mach 64 was found on a previous bus type.
         * Since we can't handle a mix of relocatable and fixed
         * base cards, we have skipped the Mach 32 search (the
         * Mach 64 search doesn't look for fixed base cards if
         * a relocatable card has already been found), and must
         * report that no ATI cards were found.
         */
        *Again = 0;
        VideoDebugPrint((DEBUG_DETAIL, "Skipping 8514/A-compatible test because block cards found\n"));
        return ERROR_DEV_NOT_EXIST;
        }

    /*
     * We have found one of our accelerators, so check for the
     * BIOS signature string.
     */
    QueryPtr->q_bios = (char *) Get_BIOS_Seg();

    /*
     * If we can't find the signature string, we can't access either
     * the EEPROM (if present) or the extended BIOS functions. Since
     * the special handling functions (extended Mach 32 aperture calculation
     * and Mach 8 ignore 1280x1024) depend on BIOS data, assume that
     * they don't apply.
     *
     * If we found the signature string, check whether the EEPROM
     * and extended BIOS functions are available.
     */

#if !defined (i386) && !defined (_i386_)
    /*
     * If we are using a Mach 64, we always use the extended BIOS
     * functions (either emulated x86 in the firmware, or an approximation
     * of the BIOS functions accessed through the same interface as
     * the BIOS functions would use). For this reason, we must have
     * the BIOS as non-FALSE. Since all searches that depend on the
     * q_bios field being a valid address are Mach 8/32 specific,
     * we can just set it to TRUE for Mach 64. For Mach 8 and 32,
     * still assume that we don't have a BIOS.
     */
    if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
        {
        VideoDebugPrint((DEBUG_NORMAL, "Non-x86 machine with Mach64, assuming BIOS is available\n"));
        QueryPtr->q_bios = (PUCHAR)TRUE;
        }
    else
        {
        VideoDebugPrint((DEBUG_NORMAL, "Non-x86 machine with Mach8/Mach32, forcing no-BIOS handling\n"));
        QueryPtr->q_bios = FALSE;
        }
#endif

    if (QueryPtr->q_bios == FALSE)
        {
        QueryPtr->q_eeprom = FALSE;
        QueryPtr->q_ext_bios_fcn = FALSE;
        QueryPtr->q_m32_aper_calc = FALSE;
        QueryPtr->q_ignore1280 = FALSE;
        }
    else{
        /*
         * Get additional data required by the graphics card being used.
         */
        if ((phwDeviceExtension->ModelNumber == _8514_ULTRA) ||
            (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA) ||
            (phwDeviceExtension->ModelNumber == MACH32_ULTRA))
            {
            GetExtraData_m();
            }

        else if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
            {
            /*
             * Mach 64 cards always have extended BIOS functions
             * available. The EEPROM (normally present) is irrelevant,
             * since we can query the card's status using the BIOS.
             */
            QueryPtr->q_ext_bios_fcn = TRUE;
            }


        }   /* BIOS signature string found */

    /*
     * We must map the VGA aperture (graphics, colour text, and mono
     * text) into the VDM's address space to use VideoPortInt10()
     * (function is only available on 80x86).
     */
#ifdef i386
    ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart  = 0x000A0000;
    ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;
    ConfigInfo->VdmPhysicalVideoMemoryLength           = 0x00020000;
#else
    ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart  = 0x00000000;
    ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;
    ConfigInfo->VdmPhysicalVideoMemoryLength           = 0x00000000;
#endif

    /*
     * If we get this far, we have enough information to be able to set
     * the video mode we want. ATI accelerator cards need the
     * Emulator entries and state size cleared
     */
    ConfigInfo->NumEmulatorAccessEntries = 0;
    ConfigInfo->EmulatorAccessEntries = NULL;
    ConfigInfo->EmulatorAccessEntriesContext = 0;

    ConfigInfo->HardwareStateSize = 0;

    /*
     * Setting *Again to 0 tells Windows NT not to call us again for
     * the same bus, while setting it to 1 indicates that we want to
     * look for another card on the current bus. LookForAnotherCard
     * will have been set to 0 if we have found the maximum number
     * of block-relocatable cards or a single non-relocatable card.
     */
    *Again = LookForAnotherCard;

    /*
     * Since ATIMPFindAdapter() is called before ATIMPInitialize(),
     * this card has not yet had ATIMPInitialize() called.
     */
    phwDeviceExtension->CardInitialized = FALSE;

    return NO_ERROR;

}   /* end ATIMPFindAdapter() */

//------------------------------------------------------------------------

/***************************************************************************
 *
 * BOOLEAN ATIMPInitialize(HwDeviceExtension);
 *
 * PVOID HwDeviceExtension;     Pointer to the miniport's device extension.
 *
 * DESCRIPTION:
 *  Query the capabilities of the graphics card, then initialize it. This
 *  routine is called once an adapter has been found and all the required
 *  data structures for it have been created.
 *
 *  We can't query the capabilities of the card in ATIMPFindAdapter()
 *  because some families of card use VideoPortInt10() in the query
 *  routine, and this system service will fail if called in ATIMPFindAdapter().
 *
 * RETURN VALUE:
 *  TRUE if we are able to obtain the query information for the card
 *  FALSE if we can't query the card's capabilities.
 *
 * GLOBALS CHANGED:
 *  phwDeviceExtension  This global variable is set in every entry point routine.
 *
 * CALLED BY:
 *  This is one of the entry point routines for Windows NT.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

BOOLEAN ATIMPInitialize(PVOID HwDeviceExtension)
{
    struct st_mode_table *CrtTable;     /* Pointer to current mode */
    struct query_structure *QueryPtr;   /* Query information for the card */
    VP_STATUS QueryStatus;
    phwDeviceExtension = HwDeviceExtension;

    /*
     * We only need to keep track of which I/O base address is involved
     * in multi-headed setups. In some single-headed setups, the
     * additional data is not available.
     */
    if (NumBlockCardsFound >= 2)
        VideoDebugPrint((DEBUG_NORMAL, "\nATIMPInitialize() called for base address 0x%X\n\n", phwDeviceExtension->BaseIOAddress));
    else
        VideoDebugPrint((DEBUG_NORMAL, "ATIMPInitialize: start\n"));

    /*
     * This function should only be called once for any card. Since
     * we have no way of knowing whether or not the display driver
     * will make multiple calls to the IOCTL_VIDEO_ATI_INIT_AUX_CARD
     * packet, we must ensure that only the first call for any card
     * actually does anything.
     */
    if (phwDeviceExtension->CardInitialized != FALSE)
        {
        VideoDebugPrint((DEBUG_ERROR, "This card already initialized, no further action needed\n"));
        return TRUE;
        }
    phwDeviceExtension->CardInitialized = TRUE;

    /*
     * Get a formatted pointer into the query section of HwDeviceExtension,
     * and another pointer to the first mode table. The CardInfo[] field
     * is an unformatted buffer.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);
    CrtTable = (struct st_mode_table *)QueryPtr;
    ((struct query_structure *)CrtTable)++;

    /*
     * Indicate that the next IOCTL_VIDEO_SET_CURRENT_MODE call
     * is the first. On the first call, video memory is cleared.
     * On subsequent calls, the palette is re-initialized but
     * video memory is not cleared.
     */
    phwDeviceExtension->ReInitializing = FALSE;

    /*
     * ASSERT: We are dealing with an ATI accelerator card
     * whose model is known, and we know whether or not
     * any special handling is needed for the card.
     *
     * Fill in the query structure for the card, using a method
     * appropriate to the card type.
     */
    switch(phwDeviceExtension->ModelNumber)
        {
        case _8514_ULTRA:
            VideoDebugPrint((DEBUG_NORMAL, "8514/ULTRA found\n"));
            QueryStatus = Query8514Ultra(QueryPtr);
            break;

        case GRAPHICS_ULTRA:
            VideoDebugPrint((DEBUG_NORMAL, "Mach 8 combo found\n"));
            QueryStatus = QueryGUltra(QueryPtr);
            break;

        case MACH32_ULTRA:
            VideoDebugPrint((DEBUG_NORMAL, "Mach 32 found\n"));
            QueryStatus = QueryMach32(QueryPtr, TRUE);
            if (QueryStatus == ERROR_INSUFFICIENT_BUFFER)
                {
                VideoPortLogError(HwDeviceExtension, NULL, VID_SMALL_BUFFER, 3);
                return FALSE;
                }
            break;

        case MACH64_ULTRA:
            VideoDebugPrint((DEBUG_NORMAL, "Mach 64 found\n"));
            QueryStatus = QueryMach64(QueryPtr);
            if (QueryStatus == ERROR_INSUFFICIENT_BUFFER)
                {
                VideoDebugPrint((DEBUG_ERROR, "QueryMach64() failed due to small buffer\n"));
                VideoPortLogError(HwDeviceExtension, NULL, VID_SMALL_BUFFER, 4);
                return FALSE;
                }
            else if (QueryStatus != NO_ERROR)
                {
                VideoDebugPrint((DEBUG_ERROR, "QueryMach64() failed due to unknown cause\n"));
                VideoPortLogError(HwDeviceExtension, NULL, VID_QUERY_FAIL, 5);
                return FALSE;
                }
            break;
        }

    /*
     * If we have access to the extended BIOS functions, we can
     * use them to switch into the desired video mode. If we don't
     * have access to these functions, but were able to read
     * the EEPROM, we can switch into the desired mode by writing
     * CRT parameters directly to the accelerator registers.
     *
     * If we don't have access to the extended BIOS functions, and
     * we couldn't find an EEPROM, attempt to retrieve the CRT
     * parameters based on the contents of the ATIOEM field in
     * the registry. If we can't do this, then we don't have enough
     * information to be able to set the video mode we want.
     */
    if (!QueryPtr->q_ext_bios_fcn && !QueryPtr->q_eeprom)
        {
        QueryStatus = OEMGetParms(QueryPtr);
        if (QueryStatus != NO_ERROR)
            {
		    return FALSE;
            }
        }

    phwDeviceExtension->VideoRamSize = QueryPtr->q_memory_size * QUARTER_MEG;

    //  Subtract the amount of memory reserved for the VGA.
    phwDeviceExtension->VideoRamSize -= (QueryPtr->q_VGA_boundary * QUARTER_MEG);

    phwDeviceExtension->PhysicalFrameAddress.HighPart = 0;
    phwDeviceExtension->PhysicalFrameAddress.LowPart  = QueryPtr->q_aperture_addr*ONE_MEG;

    /*
     * If the linear aperture is available, the frame buffer size
     * is equal to the amount of accelerator-accessible video memory.
     */
    if (QueryPtr->q_aperture_cfg)
        {
        phwDeviceExtension->FrameLength = phwDeviceExtension->VideoRamSize;
        VideoDebugPrint((DEBUG_DETAIL, "LFB size = 0x%X bytes\n", phwDeviceExtension->FrameLength));
        }

    /*
     * Call the hardware-specific initialization routine for the
     * card we are using.
     */
    if ((phwDeviceExtension->ModelNumber == _8514_ULTRA) ||
        (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA) ||
        (phwDeviceExtension->ModelNumber == MACH32_ULTRA))
        {
        /*
         * If the LFB is not usable, set up the LFB configuration
         * variables to show that there is no linear frame buffer.
         * The decision as to whether to use the 64k VGA aperture
         * or go with the graphics engine only is made in the
         * IOCTL_VIDEO_MAP_VIDEO_MEMORY packet.
         */
        if (QueryPtr->q_aperture_cfg)
            {
            if (IsApertureConflict_m(QueryPtr))
                {
                VideoPortLogError(HwDeviceExtension, NULL, VID_LFB_CONFLICT, 7);
                QueryPtr->q_aperture_cfg        = 0;
                phwDeviceExtension->FrameLength = 0;
                }
            else
                {
                /*
                 * On Mach 32 cards that can use memory mapped registers,
                 * map them in. We already know that we are dealing with
                 * a Mach 32, since this is the only card in the family
                 * of 8514/A-compatible ATI accelerators that can use
                 * a linear framebuffer.
                 */
                if ((QueryPtr->q_asic_rev == CI_68800_6) || (QueryPtr->q_asic_rev == CI_68800_AX))
                    {
                    CompatMMRangesUsable_m();
                    }
                }
            }
        /*
         * On Mach 32 cards with the aperture disabled (either as configured
         * or because a conflict was detected), try to claim the VGA aperture.
         * If we can't (unlikely), report failure, since some of our Mach 32
         * chips run into trouble in engine-only (neither linear nor paged
         * aperture available) mode.
         */
        if ((phwDeviceExtension->ModelNumber == MACH32_ULTRA) &&
            (QueryPtr->q_aperture_cfg == 0) &&
            (QueryPtr->q_VGA_type == 1))
            {
            if (IsVGAConflict_m())
                return FALSE;
            }

        Initialize_m();

        /*
         * This routine must leave the card in a state where an INT 10
         * can set it to a VGA mode. Only the Mach 8 and Mach 32 need
         * a special setup (the Mach 64 can always be set into VGA mode
         * by an INT 10).
         */
        ResetDevice_m();
        }
    else if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
        {
        /*
         * If the LFB is not usable, set up the LFB configuration
         * variables to show that there is no linear frame buffer.
         */
        if (QueryPtr->q_aperture_cfg)
            {
            if (IsApertureConflict_cx(QueryPtr))
                {
                VideoDebugPrint((DEBUG_NORMAL, "Found LFB conflict, must use VGA aperture instead\n"));
                VideoPortLogError(HwDeviceExtension, NULL, VID_LFB_CONFLICT, 8);
                QueryPtr->q_aperture_cfg        = 0;
                phwDeviceExtension->FrameLength = 0;
                }
            }
        else
            {
            phwDeviceExtension->FrameLength = 0;
            }

        /*
         * Mach 64 drawing registers only exist in memory mapped form.
         * If the linear aperture is not available, they will be
         * available through the VGA aperture (unlike Mach 32,
         * where memory mapped registers are only in the linear
         * aperture). If memory mapped registers are unavailable,
         * we can't run.
         */
        QueryStatus = CompatMMRangesUsable_cx();
        if (QueryStatus != NO_ERROR)
            {
            VideoDebugPrint((DEBUG_ERROR, "Can't use memory-mapped registers, aborting\n"));
            VideoPortLogError(HwDeviceExtension, NULL, VID_CANT_MAP, 9);
            return FALSE;
            }
        Initialize_cx();

        }   /* end if (Mach 64) */

    /*
     * Initialize the monitor parameters.
     */
    phwDeviceExtension->ModeIndex = 0;

    /*
     * Set CrtTable to point to the mode table associated with the
     * selected mode.
     *
     * When a pointer to a structure is incremented by an integer,
     * the integer represents the number of structure-sized blocks
     * to skip over, not the number of bytes to skip over.
     */
    CrtTable += phwDeviceExtension->ModeIndex;
    QueryPtr->q_desire_x  = CrtTable->m_x_size;
    QueryPtr->q_desire_y  = CrtTable->m_y_size;
    QueryPtr->q_pix_depth = CrtTable->m_pixel_depth;


#if (TARGET_BUILD >= 350)
    /*
     * In Windows NT 3.5 and higher, fill in regsistry fields used
     * by the display applet to report card specifics to the user.
     */
    FillInRegistry(QueryPtr);
#endif

    VideoDebugPrint((DEBUG_NORMAL, "End of ATIMPInitialize()\n"));

    return TRUE;

}   /* end ATIMPInitialize() */

//------------------------------------------------------------------------

BOOLEAN
ATIMPStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )

/*++

Routine Description:

    This routine is the main execution routine for the miniport driver. It
    accepts a Video Request Packet, performs the request, and then returns
    with the appropriate status.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

    RequestPacket - Pointer to the video request packet. This structure
        contains all the parameters passed to the VideoIoControl function.

Return Value:


--*/

{
    VP_STATUS status;
    PVIDEO_NUM_MODES NumModes;
    PVERSION_NT VersionInformation;
    PENH_VERSION_NT EnhVersionInformation;
    PATI_MODE_INFO ATIModeInformation;
    PVIDEO_CLUT clutBuffer;
    PVIDEO_MEMORY MappedMemory;

    UCHAR ModesLookedAt;    /* Number of mode tables we have already examined */
    short LastXRes;         /* X-resolution of last mode table examined */
    short ResolutionsDone;  /* Number of resolutions we have finished with */
    ULONG ulScratch;        /* Temporary variable */

    int i;
    ULONG *pSrc;

    struct query_structure *QueryPtr;   /* Query information for the card */
    struct st_mode_table *FirstMode;    /* Pointer to first mode table */
    struct st_mode_table *CrtTable;     /* Pointer to current mode */

    phwDeviceExtension = HwDeviceExtension;

    /*
     * We only need to keep track of which I/O base address is involved
     * in multi-headed setups. In some single-headed setups, the
     * additional data is not available.
     */
    if (NumBlockCardsFound >= 2)
        VideoDebugPrint((DEBUG_NORMAL, "\nATIMPStartIO() called for base address 0x%X\n\n", phwDeviceExtension->BaseIOAddress));

    // * Get a formatted pointer into the query section of HwDeviceExtension.
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);


    //
    // Switch on the IoControlCode in the RequestPacket. It indicates which
    // function must be performed by the driver.
    //
    switch (RequestPacket->IoControlCode)
        {
        case IOCTL_VIDEO_MAP_VIDEO_MEMORY:
            VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - MapVideoMemory\n"));

            if ( (RequestPacket->OutputBufferLength <
                (RequestPacket->StatusBlock->Information =
                sizeof(VIDEO_MEMORY_INFORMATION))) ||
                (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) )
                {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }

            /*
             * Map the video memory in the manner appropriate to the
             * card we are using.
             */
            if ((phwDeviceExtension->ModelNumber == _8514_ULTRA) ||
                (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA) ||
                (phwDeviceExtension->ModelNumber == MACH32_ULTRA))
                {
                status = MapVideoMemory_m(RequestPacket, QueryPtr);
                }
            else if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
                {
                status = MapVideoMemory_cx(RequestPacket, QueryPtr);
                }
            else	//	handling a case which should never
            {		//	happen: unknown ModelNumber
                VideoDebugPrint((DEBUG_ERROR, "ati.sys ATIMPStartIO: Unknown ModelNumber\n"));
                ASSERT(FALSE);
                status = ERROR_INVALID_PARAMETER;
            }

            break;

        case IOCTL_VIDEO_UNMAP_VIDEO_MEMORY:
            VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - UnMapVideoMemory\n"));

            if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY))
                {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }

            //
            // Note that in MapVideoMemory_m, the VP routine VideoMapMemory
            // is not called, so don't try to call unmap here!
            //

            if ((QueryPtr->q_aperture_cfg == 0) &&
                !((phwDeviceExtension->ModelNumber == MACH32_ULTRA) &&
                  (QueryPtr->q_VGA_type == 1)))
                status = NO_ERROR;
            else
            {
                status = NO_ERROR;
                if ( ((PVIDEO_MEMORY)(RequestPacket->InputBuffer))->RequestedVirtualAddress != NULL )
                {
                    status = VideoPortUnmapMemory(phwDeviceExtension,
                        ((PVIDEO_MEMORY) (RequestPacket->InputBuffer))->RequestedVirtualAddress,  0);
                }
            }
            break;


        case IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES:
            VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - QueryPublicAccessRanges\n"));

            // HACKHACK - This is a temporary hack for ALPHA until we really
            // decide how to do this.

            if ((phwDeviceExtension->ModelNumber == _8514_ULTRA) ||
                (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA) ||
                (phwDeviceExtension->ModelNumber == MACH32_ULTRA))
                {
                status = QueryPublicAccessRanges_m(RequestPacket);
                }
            else if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
                {
                status = QueryPublicAccessRanges_cx(RequestPacket);
                }
            break;


        case IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES:
            VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - FreePublicAccessRanges\n"));

            if (RequestPacket->InputBufferLength < 2 * sizeof(VIDEO_MEMORY))
                {
                VideoDebugPrint((DEBUG_ERROR, "Received length %d, need length %d\n", RequestPacket->InputBufferLength, sizeof(VIDEO_PUBLIC_ACCESS_RANGES)));
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }

            status = NO_ERROR;
            MappedMemory = RequestPacket->InputBuffer;

            if (MappedMemory->RequestedVirtualAddress != NULL)
                {
#if (TARGET_BUILD >= 400)
                /*
                 * This packet will be called as part of the cleanup
                 * for the test of a new graphics mode. The packet
                 * IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES will have
                 * generated the same virtual address for the test
                 * screen as was generated for the main Windows session.
                 *
                 * In NT 3.51 (and presumably earlier versions), the
                 * call to VideoPortUnmapMemory() will refuse to release
                 * the mapping, while in NT 4.0 (and presumably subsequent
                 * versions) it will release the mapping. This is probably
                 * due to the routine being able to distinguish between
                 * the test and permanent screens in 4.0, but not being
                 * able to disginguish between them (and therefore refusing
                 * to free resources which it thinks are currently in use
                 * by the permanent screen) in 3.51.
                 *
                 * Freeing resources will be necessary if "on-the-fly"
                 * mode switching is added to Windows NT, but this will
                 * almost certainly not be added to 3.51 (if it is added,
                 * it would be to the then-current version). Since we
                 * don't really need to free the mapped I/O ranges under
                 * 3.51 (under the old display driver source stream, this
                 * packet didn't get called), let 3.51 and earlier think
                 * that the resources were freed successfully to avoid
                 * generating an error condition, and only attempt to
                 * unmap the I/O registers under NT 4.0 and later.
                 */
                status = VideoPortUnmapMemory(phwDeviceExtension,
                                            MappedMemory->RequestedVirtualAddress,
                                            0);
#endif
                VideoDebugPrint((DEBUG_DETAIL, "VideoPortUnmapMemory() returned 0x%X\n", status));
                }
            else
                {
                VideoDebugPrint((DEBUG_DETAIL, "Address was NULL, no need to unmap\n"));
                }

            /*
             * We have just unmapped the I/O mapped registers. Since our
             * memory-mapped registers are contained in the block which
             * is mapped by IOCTL_VIDEO_MAP_VIDEO_MEMORY, they will have
             * already been freed by IOCTL_VIDEO_UNMAP_VIDEO_MEMORY, so
             * there is no need to free them here.
             */
            break;

        case IOCTL_VIDEO_QUERY_CURRENT_MODE:
            VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - QueryCurrentModes\n"));

            if ((phwDeviceExtension->ModelNumber == _8514_ULTRA) ||
                (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA) ||
                (phwDeviceExtension->ModelNumber == MACH32_ULTRA))
                {
                status = QueryCurrentMode_m(RequestPacket, QueryPtr);
                }
            else if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
                {
                status = QueryCurrentMode_cx(RequestPacket, QueryPtr);
                }
            break;

        case IOCTL_VIDEO_QUERY_AVAIL_MODES:
            VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - QueryAvailableModes\n"));

            if ((phwDeviceExtension->ModelNumber == _8514_ULTRA) ||
                (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA) ||
                (phwDeviceExtension->ModelNumber == MACH32_ULTRA))
                {
                status = QueryAvailModes_m(RequestPacket, QueryPtr);
                }
            else if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
                {
                status = QueryAvailModes_cx(RequestPacket, QueryPtr);
                }
            break;


        case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:
            VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - QueryNumAvailableModes\n"));

            /*
             * Find out the size of the data to be put in the buffer and
             * return that in the status information
             */
            if (RequestPacket->OutputBufferLength <
                (RequestPacket->StatusBlock->Information = sizeof(VIDEO_NUM_MODES)) )
                {
                status = ERROR_INSUFFICIENT_BUFFER;
                }
            else{
                NumModes = (PVIDEO_NUM_MODES)RequestPacket->OutputBuffer;
                NumModes->NumModes = QueryPtr->q_number_modes;
                NumModes->ModeInformationLength = sizeof(VIDEO_MODE_INFORMATION);
                status = NO_ERROR;
                }
            break;

        case IOCTL_VIDEO_SET_CURRENT_MODE:
            VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - SetCurrentMode\n"));

            /*
             * Verify that the mode we've been asked to set is less
             * than or equal to the highest mode number for which we
             * have a mode table (mode number is zero-based, so highest
             * mode number is 1 less than number of modes).
             */
            if (((PVIDEO_MODE)(RequestPacket->InputBuffer))->RequestedMode
    	        >= QueryPtr->q_number_modes)
                {
                status = ERROR_INVALID_PARAMETER;
                break;
                }

            phwDeviceExtension->ModeIndex = *(ULONG *)(RequestPacket->InputBuffer);

            CrtTable = (struct st_mode_table *)QueryPtr;
            ((struct query_structure *)CrtTable)++;

            CrtTable += phwDeviceExtension->ModeIndex;

            // * Set resolution and pixel depth of new current mode.
            QueryPtr->q_desire_x = CrtTable->m_x_size;
            QueryPtr->q_desire_y = CrtTable->m_y_size;
            QueryPtr->q_pix_depth = CrtTable->m_pixel_depth;
            QueryPtr->q_screen_pitch = CrtTable->m_screen_pitch;

            /*
             * If we are using the extended BIOS functions to switch modes,
             * do it now. The Mach 32 uses the extended BIOS functions to
             * read in the CRT parameters for a direct-register mode switch,
             * rather than using a BIOS mode switch.
             */
            if ((QueryPtr->q_ext_bios_fcn) && (phwDeviceExtension->ModelNumber != MACH32_ULTRA))
                {
                /*
                 * Do the mode switch through the BIOS.
                 */
                if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
                    {
                    status = SetCurrentMode_cx(QueryPtr, CrtTable);
                    }
                }
            else{
                if ((phwDeviceExtension->ModelNumber == _8514_ULTRA) ||
                    (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA) ||
                    (phwDeviceExtension->ModelNumber == MACH32_ULTRA))
                    {
                    SetCurrentMode_m(QueryPtr, CrtTable);
                    status = NO_ERROR;
                    }
                }   /* end if (not using BIOS call for mode switch) */

            break;


        case IOCTL_VIDEO_SET_PALETTE_REGISTERS:
            VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - SetPaletteRegs\n"));
            status = NO_ERROR;
            break;

        case IOCTL_VIDEO_SET_COLOR_REGISTERS:
            VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - SetColorRegs\n"));

            CrtTable = (struct st_mode_table *)QueryPtr;
	        ((struct query_structure *)CrtTable)++;

        	clutBuffer = RequestPacket->InputBuffer;
        	phwDeviceExtension->ReInitializing = TRUE;

            /*
             * Check if the size of the data in the input
             * buffer is large enough.
             */
            if ( (RequestPacket->InputBufferLength < sizeof(VIDEO_CLUT) - sizeof(ULONG))
                || (RequestPacket->InputBufferLength < sizeof(VIDEO_CLUT) +
                    (sizeof(ULONG) * (clutBuffer->NumEntries - 1)) ) )
                {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }

            CrtTable += phwDeviceExtension->ModeIndex;
        	if (CrtTable->m_pixel_depth <= 8)
                {
                if ((phwDeviceExtension->ModelNumber == _8514_ULTRA) ||
                    (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA) ||
                    (phwDeviceExtension->ModelNumber == MACH32_ULTRA))
                    {
                    SetPalette_m((PULONG)clutBuffer->LookupTable,
                                 clutBuffer->FirstEntry,
                                 clutBuffer->NumEntries);
                    }
                else if(phwDeviceExtension->ModelNumber == MACH64_ULTRA)
                    {
                    SetPalette_cx((PULONG)clutBuffer->LookupTable,
                                  clutBuffer->FirstEntry,
                                  clutBuffer->NumEntries);
                    }
                status = NO_ERROR;
                }

            /*
             * Remember the most recent palette we were given so we
             * can re-initialize it in subsequent calls to the
             * IOCTL_VIDEO_SET_CURRENT_MODE packet.
             */
        	phwDeviceExtension->FirstEntry = clutBuffer->FirstEntry;
        	phwDeviceExtension->NumEntries = clutBuffer->NumEntries;

        	pSrc = (ULONG *) clutBuffer->LookupTable;

            for (i = clutBuffer->FirstEntry; i < (int) clutBuffer->NumEntries; i++)
	            {
                /*
                 * Save palette colours.
                 */
        	    phwDeviceExtension->Clut[i] = *pSrc;
                pSrc++;
        	    }

            break;




    case IOCTL_VIDEO_RESET_DEVICE:
        VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - RESET_DEVICE\n"));

        /*
         * If we are using the extended BIOS functions to switch modes,
         * do it now. The Mach 32 uses the extended BIOS functions to
         * read in the CRT parameters for a direct-register mode switch,
         * rather than using a BIOS mode switch.
         */
        if ((QueryPtr->q_ext_bios_fcn) && (phwDeviceExtension->ModelNumber != MACH32_ULTRA))
            {
            /*
             * Do the mode switch through the BIOS (hook not yet present
             * in Windows NT).
             */
            if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
                {
                ResetDevice_cx();
                }
            }
        else{
            ResetDevice_m();
            }

        status = NO_ERROR;
        break;


    case IOCTL_VIDEO_SET_POWER_MANAGEMENT:
        VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - SET_POWER_MANAGEMENT\n"));

        /*
         * If the VIDEO_POWER_MANAGEMENT structure is the wrong size
         * (miniport and display driver using different versions),
         * report the error.
         */
        if (((PVIDEO_POWER_MANAGEMENT)(RequestPacket->InputBuffer))->Length
            != sizeof(struct _VIDEO_POWER_MANAGEMENT))
            {
            status = ERROR_INVALID_PARAMETER;
            break;
            }

        ulScratch = ((PVIDEO_POWER_MANAGEMENT)(RequestPacket->InputBuffer))->PowerState;

        switch (ulScratch)
            {
            case VideoPowerOn:
                VideoDebugPrint((DEBUG_DETAIL, "DPMS ON selected\n"));
                break;

            case VideoPowerStandBy:
                VideoDebugPrint((DEBUG_DETAIL, "DPMS STAND-BY selected\n"));
                break;

            case VideoPowerSuspend:
                VideoDebugPrint((DEBUG_DETAIL, "DPMS SUSPEND selected\n"));
                break;

            case VideoPowerOff:
                VideoDebugPrint((DEBUG_DETAIL, "DPMS OFF selected\n"));
                break;

            default:
                VideoDebugPrint((DEBUG_ERROR, "DPMS invalid state selected\n"));
                break;
            }

        /*
         * Different card families need different routines to set
         * the power management state.
         */
        if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
            status = SetPowerManagement_cx(ulScratch);
        else
            status = SetPowerManagement_m(QueryPtr, ulScratch);
        break;


    /*
     * Packets used in DCI support. They were added some time after
     * the initial release of Windows NT 3.5, so not all versions of
     * the DDK will support them. Make the packet code conditional on
     * our building a driver for NT version 3.51 or later in order to
     * avoid the need for a SOURCES flag to identify DCI vs. non-DCI builds.
     */
#if (TARGET_BUILD >= 351)
    case IOCTL_VIDEO_SHARE_VIDEO_MEMORY:
        VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - SHARE_VIDEO_MEMORY\n"));

        if ((RequestPacket->OutputBufferLength < sizeof(VIDEO_SHARE_MEMORY_INFORMATION)) ||
            (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)))
            {
            VideoDebugPrint((DEBUG_ERROR, "IOCTL_VIDEO_SHARE_VIDEO_MEMORY - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        /*
         * Share the video memory in the manner appropriate to the
         * card we are using. We can only share memory if the
         * card supports an aperture - Mach 8 cards never support
         * an aperture, so if we are working with one, we know
         * that we can't share the memory. The card-specific
         * routines will identify no-aperture and other cases
         * where we can't share video memory on Mach 32 and
         * Mach 64 cards.
         */
        if ((phwDeviceExtension->ModelNumber == _8514_ULTRA) ||
            (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA))
            {
            VideoDebugPrint((DEBUG_ERROR, "IOCTL_VIDEO_SHARE_VIDEO_MEMORY - Mach 8 can't share memory\n"));
            status = ERROR_INVALID_FUNCTION;
            }
        else if (phwDeviceExtension->ModelNumber == MACH32_ULTRA)
            {
            status = ShareVideoMemory_m(RequestPacket, QueryPtr);
            }
        else if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
            {
            status = ShareVideoMemory_cx(RequestPacket, QueryPtr);
            }

        break;


    case IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY:
        VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - UNSHARE_VIDEO_MEMORY\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_SHARE_MEMORY))
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        status = VideoPortUnmapMemory(phwDeviceExtension,
                                    ((PVIDEO_SHARE_MEMORY)(RequestPacket->InputBuffer))->RequestedVirtualAddress,
                                    ((PVIDEO_SHARE_MEMORY)(RequestPacket->InputBuffer))->ProcessHandle);

        break;
#endif  /* TARGET_BUILD >= 350 */


    // ------ * ATI-specific packets start here.  -------------
    /*
     * Get the version number of the miniport, and the
     * resolutions supported (including maximum colour
     * depth).
     */
    case IOCTL_VIDEO_ATI_GET_VERSION:
        VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - ATIGetVersion\n"));

        /*
         * Two versions of this packet exist, depending on which display
         * driver is used. Display drivers which use the old version do
         * not send information to the miniport, so the input buffer is
         * null. Drivers which use the new version pass a non-null input
         * buffer.
         */
        if (RequestPacket->InputBufferLength == 0)
            {
            /*
             * Old packet.
             */
            if (RequestPacket->OutputBufferLength < sizeof(VERSION_NT))
                {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }

            RequestPacket->StatusBlock->Information = sizeof(VERSION_NT);

            FirstMode = (struct st_mode_table *)QueryPtr;
            ((struct query_structure *)FirstMode)++;

            VersionInformation = RequestPacket->OutputBuffer;
            VersionInformation->miniport =
                (MINIPORT_BUILD << 16) | (MINIPORT_VERSION_MAJOR << 8) | MINIPORT_VERSION_MINOR;

            /*
             * Get the capabilities of the video card. The capcard field
             * holds the following information:
             *
             * Bits 0-3     Bus type (defined values from AMACH.H)
             * Bits 4-7     Product identifier (defined values from AMACH.H)
             * Bit  8       No aperture is available
             * Bit  9       64k VGA aperture is available
             * Bit  10      Linear aperture is available
             *
             * NOTE: Bits 9 and 10 are NOT mutually exclusive.
             */
            VersionInformation->capcard = QueryPtr->q_bus_type;
            VersionInformation->capcard |= (phwDeviceExtension->ModelNumber) << 4;

            if (QueryPtr->q_aperture_cfg)
                VersionInformation->capcard |= ATIC_APERTURE_LFB;

            /*
             * 64k VGA aperture is available on the VGAWonder, and on
             * accelerator cards with the VGA enabled and the VGA boundary
             * set to shared memory.
             */
            if ((phwDeviceExtension->ModelNumber == WONDER) ||
                ((QueryPtr->q_VGA_type) && !(QueryPtr->q_VGA_boundary)))
                VersionInformation->capcard |= ATIC_APERTURE_VGA;

            /*
             * If neither aperture is available, set the "no aperture" bit.
             */
            if (!(VersionInformation->capcard & ATIC_APERTURE_LFB) &&
                !(VersionInformation->capcard & ATIC_APERTURE_VGA))
                VersionInformation->capcard |= ATIC_APERTURE_NONE;

            // Get the available resolutions and maximum colour depth for
            // each. init to a value which does not correspond to any
            // resolution.
            CrtTable = FirstMode;
            LastXRes = -1;
            ResolutionsDone = -1;
            for (ModesLookedAt = 0; ModesLookedAt < QueryPtr->q_number_modes; ModesLookedAt++)
                {
                // do we have a new resolution?
                if (LastXRes != CrtTable->m_x_size)
                    {
                    ResolutionsDone++;
                    LastXRes = CrtTable->m_x_size;
                    VersionInformation->resolution[ResolutionsDone].color = 0;
                    }

                /*
                 * Write the desired information from the current mode table
                 * in the query structure into the current mode table in
                 * the OUTPut buffer.
                 * Leave the OUTPut buffer with the highest colour depth in
                 * each supported resolution.
                 */
                if (CrtTable->m_pixel_depth > VersionInformation->resolution[ResolutionsDone].color)
                    {
                    VersionInformation->resolution[ResolutionsDone].xres = CrtTable->m_x_size;
                    VersionInformation->resolution[ResolutionsDone].yres = CrtTable->m_y_size;
                    VersionInformation->resolution[ResolutionsDone].color= CrtTable->m_pixel_depth;
                    }

                CrtTable++;         // Advance to the next mode table
                }
            status = NO_ERROR;
            }
        else if((RequestPacket->InputBuffer == RequestPacket->OutputBuffer) &&
                (((PENH_VERSION_NT)(RequestPacket->InputBuffer))->StructureVersion == 0) &&
                (((PENH_VERSION_NT)(RequestPacket->InputBuffer))->InterfaceVersion == 0))
            {
            /*
             * Interim packet
             */

            if (RequestPacket->OutputBufferLength < sizeof(ENH_VERSION_NT))
                {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }

            RequestPacket->StatusBlock->Information = sizeof(ENH_VERSION_NT);

            EnhVersionInformation = RequestPacket->OutputBuffer;

            /*
             * Report the miniport version we are using.
             */
//            EnhVersionInformation->InterfaceVersion = (MINIPORT_VERSION_MAJOR << 8) | MINIPORT_VERSION_MINOR;
            EnhVersionInformation->InterfaceVersion = 0;

            /*
             * Remove the following line ONLY for official release versions
             * of the miniport. This line indicates that this is an
             * experimental (unsupported) version.
             */
            EnhVersionInformation->InterfaceVersion |= BETA_MINIPORT;

            /*
             * Report the chip used as both a numeric value and a flag.
             */
            EnhVersionInformation->ChipIndex = QueryPtr->q_asic_rev;
            EnhVersionInformation->ChipFlag = 1 << (QueryPtr->q_asic_rev);

            /*
             * Report the best aperture configuration available.
             *
             * Linear Framebuffer is preferable to VGA aperture,
             * which is preferable to engine-only.
             *
             * NOTE: VGA aperture will need to be split into
             *       68800-style and 68800CX-style once we
             *       go from the emulator to silicon.
             */
            if (QueryPtr->q_aperture_cfg != 0)
                EnhVersionInformation->ApertureType = AP_LFB;
            else if ((QueryPtr->q_asic_rev != CI_38800_1) && (QueryPtr->q_VGA_type == 1))
                EnhVersionInformation->ApertureType = AP_68800_VGA;
            else
                EnhVersionInformation->ApertureType = ENGINE_ONLY;
            EnhVersionInformation->ApertureFlag = 1 << (EnhVersionInformation->ApertureType);

            /*
             * Report the bus type being used.
             */
            EnhVersionInformation->BusType = QueryPtr->q_bus_type;
            EnhVersionInformation->BusFlag = 1 << (EnhVersionInformation->BusType);

            /*
             * For ASIC revisions that are capable of using memory mapped
             * registers, check to see whether we are using them.
             */
            if ((QueryPtr->q_asic_rev == CI_68800_6) || (QueryPtr->q_asic_rev == CI_68800_AX))
                {
                if (MemoryMappedEnabled_m())
                    EnhVersionInformation->BusFlag |= FL_MM_REGS;
                }

            /*
             * Report the number of ATI graphics cards in the system,
             * so the display driver will know how many auxillary
             * cards to initialize.
             *
             * Since multiheaded support requires all the ATI cards
             * present to be block I/O cards, the global variable
             * NumBlockCardsFound will always be 2 or higher in
             * multiheaded systems. If it is 0 (non-block card found,
             * since we will never get to this point if there are
             * no ATI cards) or 1 (single block I/O card), report
             * that there is 1 ATI card present.
             */
            if (NumBlockCardsFound >= 2)
                EnhVersionInformation->NumCards = NumBlockCardsFound;
            else
                EnhVersionInformation->NumCards = 1;
            VideoDebugPrint((DEBUG_DETAIL, "Reporting %d cards\n", EnhVersionInformation->NumCards));

            /*
             * Fill in the list of features this card supports.
             *
             * We can disable the sync signals even on cards that
             * don't have registers dedicated to DPMS support, so
             * all our cards support DPMS.
             */
            EnhVersionInformation->FeatureFlags = EVN_DPMS;

            /*
             * All platforms except the DEC Alpha are always
             * capable of using dense space. On the Alpha,
             * some machines with some of our cards are
             * capable of using dense space, while others
             * aren't.
             */
#if defined(_ALPHA_)
            if (DenseOnAlpha(QueryPtr) == TRUE)
                {
                EnhVersionInformation->FeatureFlags |= EVN_DENSE_CAPABLE;
                VideoDebugPrint((DEBUG_DETAIL, "Reporting dense capable in FeatureFlags\n"));
                }
#else
            EnhVersionInformation->FeatureFlags |= EVN_DENSE_CAPABLE;
#endif
            if (phwDeviceExtension->ModelNumber == MACH32_ULTRA)
                {
                if ((QueryPtr->q_asic_rev == CI_68800_6) && (QueryPtr->q_aperture_cfg == 0)
                    && (QueryPtr->q_VGA_type == 1) && ((QueryPtr->q_memory_type == 5) ||
                    (QueryPtr->q_memory_type == 6)))
                    EnhVersionInformation->FeatureFlags |= EVN_SPLIT_TRANS;
                if (IsMioBug_m(QueryPtr))
                    EnhVersionInformation->FeatureFlags |= EVN_MIO_BUG;
                }
            else if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
                {
                if (IsPackedIO_cx())
                    EnhVersionInformation->FeatureFlags |= EVN_PACKED_IO;

                if ((QueryPtr->q_memory_type == VMEM_SDRAM) &&
                    (QueryPtr->q_memory_size == VRAM_1mb))
                    EnhVersionInformation->FeatureFlags |= EVN_SDRAM_1M;

                if (QueryPtr->q_DAC_type == DAC_TVP3026)
                    {
                    EnhVersionInformation->FeatureFlags |= EVN_TVP_DAC_CUR;
                    }
                else if (QueryPtr->q_DAC_type == DAC_IBM514)
                    {
                    EnhVersionInformation->FeatureFlags |= EVN_IBM514_DAC_CUR;
                    }
                else if (QueryPtr->q_DAC_type == DAC_INTERNAL_CT)
                    {
                    EnhVersionInformation->FeatureFlags |= EVN_INT_DAC_CUR;
                    EnhVersionInformation->FeatureFlags |= EVN_CT_ASIC;
                    }
                else if (QueryPtr->q_DAC_type == DAC_INTERNAL_VT)
                    {
                    EnhVersionInformation->FeatureFlags |= EVN_INT_DAC_CUR;
                    EnhVersionInformation->FeatureFlags |= EVN_VT_ASIC;
                    }
                else if (QueryPtr->q_DAC_type == DAC_INTERNAL_GT)
                    {
                    EnhVersionInformation->FeatureFlags |= EVN_INT_DAC_CUR;
                    EnhVersionInformation->FeatureFlags |= EVN_GT_ASIC;
                    }
                }
            /*
             * Currently there are no feature flags specific to the Mach 8.
             */

            status = NO_ERROR;
            }
        else    /* Final form of the packet is not yet defined */
            {
            status = ERROR_INVALID_FUNCTION;
            }
        break;



        /*
         * Packet to return information regarding the capabilities/bugs
         * of the current mode.
         */
        case IOCTL_VIDEO_ATI_GET_MODE_INFORMATION:
            VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - ATIGetModeInformation\n"));
            if (RequestPacket->OutputBufferLength <
                (RequestPacket->StatusBlock->Information = sizeof(ENH_VERSION_NT)))
                {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }
            ATIModeInformation = RequestPacket->OutputBuffer;
            ATIModeInformation->ModeFlags = 0;

            /*
             * Information regarding the visible portion of the screen.
             */
            ATIModeInformation->VisWidthPix = QueryPtr->q_desire_x;
            ATIModeInformation->VisHeight = QueryPtr->q_desire_y;
            ATIModeInformation->BitsPerPixel = QueryPtr->q_pix_depth;

            /*
             * We require the true pitch in 24bpp
             */
            if (QueryPtr->q_pix_depth == 24)
                {
                ATIModeInformation->PitchPix = QueryPtr->q_screen_pitch * 3;
                }
            else
                {
                ATIModeInformation->PitchPix = QueryPtr->q_screen_pitch;
                }
            /*
             * The FracBytesPerPixel field represents the first 3 places
             * of decimal in the fractional part of bytes per pixel.
             * No precision is lost, because the smallest granularity
             * (one bit per pixel) is 0.125 bytes per pixel, and any
             * multiple of this value does not extend beyond 3 places
             * of decimal.
             *
             * Mach 8 1280x1024 4BPP is packed pixel, other 4BPP modes all
             * ignore the upper 4 bits of each byte.
             */
            if ((QueryPtr->q_pix_depth == 4) &&
                !((QueryPtr->q_asic_rev == CI_38800_1) && (QueryPtr->q_desire_x == 1280)))
                {
                ATIModeInformation->IntBytesPerPixel = 1;
                ATIModeInformation->FracBytesPerPixel = 0;
                }
            else{
                ATIModeInformation->IntBytesPerPixel = QueryPtr->q_pix_depth / 8;
                switch (QueryPtr->q_pix_depth % 8)
                    {
                    case 0:
                        ATIModeInformation->FracBytesPerPixel = 0;
                        break;

                    case 1:
                        ATIModeInformation->FracBytesPerPixel = 125;
                        break;

                    case 2:
                        ATIModeInformation->FracBytesPerPixel = 250;
                        break;

                    case 3:
                        ATIModeInformation->FracBytesPerPixel = 375;
                        break;

                    case 4:
                        ATIModeInformation->FracBytesPerPixel = 500;
                        break;

                    case 5:
                        ATIModeInformation->FracBytesPerPixel = 625;
                        break;

                    case 6:
                        ATIModeInformation->FracBytesPerPixel = 750;
                        break;

                    case 7:
                        ATIModeInformation->FracBytesPerPixel = 875;
                        break;
                    }
                }
            ATIModeInformation->PitchByte = (QueryPtr->q_screen_pitch *
                ((ATIModeInformation->IntBytesPerPixel * 1000) + ATIModeInformation->FracBytesPerPixel)) / 8000;
            ATIModeInformation->VisWidthByte = (QueryPtr->q_desire_x *
                ((ATIModeInformation->IntBytesPerPixel * 1000) + ATIModeInformation->FracBytesPerPixel)) / 8000;

            /*
             * Information regarding the offscreen memory to the right
             * of the visible screen.
             */
            ATIModeInformation->RightWidthPix = ATIModeInformation->PitchPix - ATIModeInformation->VisWidthPix;
            ATIModeInformation->RightWidthByte = ATIModeInformation->PitchByte - ATIModeInformation->VisWidthByte;
            ATIModeInformation->RightStartOffPix = ATIModeInformation->VisWidthPix + 1;
            ATIModeInformation->RightStartOffByte = ATIModeInformation->VisWidthByte + 1;
            ATIModeInformation->RightEndOffPix = ATIModeInformation->PitchPix;
            ATIModeInformation->RightEndOffByte = ATIModeInformation->PitchByte;

            /*
             * Information regarding the offscreen memory below the
             * visible screen.
             */
            ATIModeInformation->BottomWidthPix = ATIModeInformation->PitchPix;
            ATIModeInformation->BottomWidthByte = ATIModeInformation->PitchByte;
            ATIModeInformation->BottomStartOff = ATIModeInformation->VisHeight + 1;
            /*
             * "Hard" values are the maximum Y coordinate which is backed by
             * video memory. "Soft" values are the maximum Y coordinate which
             * may be accessed without resetting the graphic engine offset
             * into video memory.
             *
             * In 4BPP modes, we always force the card to think it has
             * only 1M of memory.
             */
            if (QueryPtr->q_pix_depth == 4)
                {
                ATIModeInformation->BottomEndOffHard = ONE_MEG / ATIModeInformation->PitchByte;
                }
            else
                {
                ATIModeInformation->BottomEndOffHard = ((QueryPtr->q_memory_size - QueryPtr->q_VGA_boundary)
                    * QUARTER_MEG) / ATIModeInformation->PitchByte;
                }
            if ((QueryPtr->q_asic_rev == CI_88800_GX) && (ATIModeInformation->BottomEndOffHard > 16387))
                ATIModeInformation->BottomEndOffSoft = 16387;
            else if (ATIModeInformation->BottomEndOffHard > 1535)
                ATIModeInformation->BottomEndOffSoft = 1535;
            else
                ATIModeInformation->BottomEndOffSoft = ATIModeInformation->BottomEndOffHard;
            ATIModeInformation->BottomHeightHard = ATIModeInformation->BottomEndOffHard - ATIModeInformation->VisHeight;
            ATIModeInformation->BottomHeightSoft = ATIModeInformation->BottomEndOffSoft - ATIModeInformation->VisHeight;

            /*
             * Fill in the list of "quirks" experienced by this particular mode.
             */
            if (phwDeviceExtension->ModelNumber == MACH32_ULTRA)
                {
                if (((QueryPtr->q_desire_x == 1280) && (QueryPtr->q_desire_y == 1024)) ||
                    (((QueryPtr->q_DAC_type == DAC_STG1700) ||
                        (QueryPtr->q_DAC_type == DAC_STG1702) ||
                        (QueryPtr->q_DAC_type == DAC_STG1703)) && (QueryPtr->q_pix_depth >= 24)))
                    {
                    ATIModeInformation->ModeFlags |= AMI_ODD_EVEN;
                    }

                /*
                 * The test for block write mode must be made after we
                 * switch into graphics mode, but it is not mode dependent.
                 *
                 * Because the test corrupts the screen, and is not
                 * mode dependent, only run it the first time this
                 * packet is called and save the result to report
                 * on subsequent calls.
                 */
                if (QueryPtr->q_BlockWrite == BLOCK_WRITE_UNKNOWN)
                    {
                    if (BlockWriteAvail_m(QueryPtr))
                        QueryPtr->q_BlockWrite = BLOCK_WRITE_YES;
                    else
                        QueryPtr->q_BlockWrite = BLOCK_WRITE_NO;
                    }
                if (QueryPtr->q_BlockWrite == BLOCK_WRITE_YES)
                    ATIModeInformation->ModeFlags |= AMI_BLOCK_WRITE;
                }
            else if(phwDeviceExtension->ModelNumber == MACH64_ULTRA)
                {
                if (((QueryPtr->q_DAC_type == DAC_STG1700) ||
                        (QueryPtr->q_DAC_type == DAC_STG1702) ||
                        (QueryPtr->q_DAC_type == DAC_STG1703) ||
                        (QueryPtr->q_DAC_type == DAC_ATT408) ||
                        (QueryPtr->q_DAC_type == DAC_CH8398)) &&
                    (QueryPtr->q_pix_depth >= 24))
                    ATIModeInformation->ModeFlags |= AMI_ODD_EVEN;
                if (((QueryPtr->q_pix_depth == 24) && (QueryPtr->q_desire_x == 1280)) ||
                    ((QueryPtr->q_pix_depth == 24) && (QueryPtr->q_desire_x == 1152)) ||
                    ((QueryPtr->q_pix_depth == 16) && (QueryPtr->q_desire_x == 1600)))
                    ATIModeInformation->ModeFlags |= AMI_2M_BNDRY;

                if (TextBanding_cx(QueryPtr))
                    ATIModeInformation->ModeFlags |= AMI_TEXTBAND;

                /*
                 * See Mach 32 section above for explanation.
                 */
                if (QueryPtr->q_BlockWrite == BLOCK_WRITE_UNKNOWN)
                    {
                    if (BlockWriteAvail_cx(QueryPtr))
                        QueryPtr->q_BlockWrite = BLOCK_WRITE_YES;
                    else
                        QueryPtr->q_BlockWrite = BLOCK_WRITE_NO;
                    }
                if (QueryPtr->q_BlockWrite == BLOCK_WRITE_YES)
                    ATIModeInformation->ModeFlags |= AMI_BLOCK_WRITE;
                }

            status = NO_ERROR;
            break;


        /*
         * Packet to force initialization of auxillary card in multiheaded
         * setup. Currently (NT 3.51 retail), only the primrary card
         * receives a call to ATIMPInitialize().
         *
         * This packet must be called for all auxillary cards before
         * IOCTL_VIDEO_SET_CURRENT_MODE is called for any card, since
         * ATIMPInitialize() uses resources that are only available
         * when the primrary (VGA enabled) card is in a VGA mode.
         */
        case IOCTL_VIDEO_ATI_INIT_AUX_CARD:
            VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - ATIInitAuxCard\n"));
            ATIMPInitialize(phwDeviceExtension);
            status = NO_ERROR;
            break;




        default:
            VideoDebugPrint((DEBUG_ERROR, "Fell through ATIMP startIO routine - invalid command\n"));
            status = ERROR_INVALID_FUNCTION;
            break;

    }

    RequestPacket->StatusBlock->Status = status;
    VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO: Returning with status=%d\n", status));

    return TRUE;

} // end ATIMPStartIO()

/***************************************************************************
 *
 * BOOLEAN ATIMPResetHw(HwDeviceExtension, Columns, Rows);
 *
 * PVOID HwDeviceExtension;     Pointer to the miniport's device extension.
 * ULONG Columns;               Number of character columns on text screen
 * ULONG Rows;                  Number of character rows on text screen
 *
 * DESCRIPTION:
 *  Put the graphics card into either a text mode or a state where an
 *  INT 10 call will put it into a text mode.
 *
 * GLOBALS CHANGED:
 *  phwDeviceExtension  This global variable is set in every entry point routine.
 *
 * CALLED BY:
 *  This is one of the entry point routines for Windows NT.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

BOOLEAN ATIMPResetHw(PVOID HwDeviceExtension, ULONG Columns, ULONG Rows)
{
    phwDeviceExtension = HwDeviceExtension;

    /*
     * On the Mach 64, an INT 10 to VGA text mode will work even
     * when in accelerator mode, so we don't need to explicitly
     * switch out of accelerator mode. On the Mach 8 and Mach 32,
     * we must switch out of accelerator mode, and on the Mach 32
     * we must load the VGA text font.
     *
     * On the Mach 64, some non-x86 machines (first noticed on the
     * DEC Alpha) don't do the warm boot BIOS re-initialization that
     * is done on the x86. Part of this re-initialization sets the
     * memory size register to the correct amount of memory, which
     * must be done if we were in a 4BPP mode (in 4BPP, we must force
     * the memory size to 1M). To avoid locking out modes requiring
     * over 1M (at least until the next cold boot) on these machines,
     * we must restore the memory size to the correct value. Since this
     * has the side effect of generating black vertical bands as a
     * transient (due to interleaving of memory banks on 2M and higher
     * configurations), only do this on non-x86 machines, since the
     * BIOS will take care of it (without the visible side effect)
     * on x86 platforms.
     *
     * Since this routine, and all routines it calls, must be
     * nonpageable (in case the reason it is called is because
     * there is a fatal error in the paging mechanism), and
     * VideoDebugPrint() is pageable, we must not call VideoDebugPrint()
     * from this routine. Temporary additions for testing are OK,
     * but the calls must be removed before the code is released
     * for production.
     */
#if defined (i386) || defined (_i386_)
    if (phwDeviceExtension->ModelNumber != MACH64_ULTRA)
        SetTextMode_m();
#else
    if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
        RestoreMemSize_cx();
    else
        SetTextMode_m();
#endif

    return FALSE;

}   /* end ATIMPResetHw() */

#if (TARGET_BUILD >= 500)

#define QUERY_MONITOR_ID            0x22446688
#define QUERY_NONDDC_MONITOR_ID     0x11223344

VP_STATUS
ATIMPSetPower50(
    PHW_DEVICE_EXTENSION pHwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT pVideoPowerMgmt
    )
//
// DESCRIPTION:
//  Set the graphics card to the desired DPMS state.
//
// PARAMETERS:
//  pHwDeviceExtension  Points to per-adapter device extension.
//  HwDeviceId          id identifying the device.
//  pVideoPowerMgmt     Points to structure containing desired DPMS state.
//
// RETURN VALUE:
//	Status code.
//
{
    ULONG ulDesiredState;

    ASSERT((pHwDeviceExtension != NULL) && (pVideoPowerMgmt != NULL));

    VideoDebugPrint((DEBUG_NORMAL, "ati.sys ATIMPSetPower50: *** Entry point ***\n"));

    ulDesiredState = pVideoPowerMgmt->PowerState;

    //
    // Check the ID passed down by the caller.
    // We must handle setting the power for each of the devices specifically.
    //
    VideoDebugPrint((DEBUG_DETAIL, "ati.sys ATIMPSetPower50: Device Id = 0x%x\n", HwDeviceId));

    if ((QUERY_MONITOR_ID == HwDeviceId) ||
        (QUERY_NONDDC_MONITOR_ID == HwDeviceId))
    {
        VideoDebugPrint((DEBUG_DETAIL, "ati.sys ATIMPSetPower50: Device Id = Monitor\n"));

        if (pVideoPowerMgmt->PowerState == VideoPowerHibernate) {

            // We just leave the monitor powered on for Hibernate.
            return NO_ERROR;
        }

        //
        // This is the monitor -- we will use the standard BIOS DPMS call.
        //
        return SetMonitorPowerState(pHwDeviceExtension, ulDesiredState);
    }
    else if (DISPLAY_ADAPTER_HW_ID == HwDeviceId)
    {
        VP_STATUS status;
        struct query_structure *QueryPtr =
            (struct query_structure *) (phwDeviceExtension->CardInfo);


        VideoDebugPrint((DEBUG_DETAIL, "ati.sys ATIMPSetPower50: Device Id = Graphics Adapter\n"));

        switch (pVideoPowerMgmt->PowerState) {

            case VideoPowerOn:
            case VideoPowerHibernate:

                status = NO_ERROR;
                break;

            case VideoPowerStandBy:
            case VideoPowerSuspend:
            case VideoPowerOff:

                status = ERROR_INVALID_PARAMETER;
                break;

            default:

                //
                // We indicated in ATIGetPowerState that we couldn't
                // do VideoPowerOff.  So we should not get a call to
                // do it here.
                //

                ASSERT(FALSE);
                status = ERROR_INVALID_PARAMETER;
                break;

        }

        return status;
    }
    else
    {
        VideoDebugPrint((DEBUG_ERROR, "ati.sys ATIMPSetPower50: Unknown pHwDeviceId\n"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
}   // ATIMPSetPower50()

VP_STATUS
ATIMPGetPower50(
    PHW_DEVICE_EXTENSION pHwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT pVideoPowerMgmt
    )
//
// DESCRIPTION:
//  Returns whether or not this particular DPMS state can be set on the
//  graphics card or monitor
//
// PARAMETERS:
//  pHwDeviceExtension  Points to per-adapter device extension.
//  HwDeviceId          id identifying the device.
//  pVideoPowerMgmt     Points to DPMS state we wish to know is supported or not.
//
// RETURN VALUE:
//  Status code.
//
{
    ASSERT((pHwDeviceExtension != NULL) && (pVideoPowerMgmt != NULL));

    VideoDebugPrint((DEBUG_NORMAL, "ati.sys ATIMPGetPower50: *** Entry point ***\n"));

    //
    // We currently only support settings the power on the monitor.
    // Check that we get the private ID we passed back the system.
    //

    VideoDebugPrint((DEBUG_DETAIL, "ati.sys ATIMPGetPower50: Device Id = 0x%x\n", HwDeviceId));

    if ((QUERY_MONITOR_ID == HwDeviceId) ||
        (QUERY_NONDDC_MONITOR_ID == HwDeviceId))
    {
        VideoDebugPrint((DEBUG_DETAIL, "ati.sys ATIMPGetPower50: Device Id = Monitor, State = D%ld\n",
            pVideoPowerMgmt->PowerState - 1));

        switch (pVideoPowerMgmt->PowerState)
        {
            case VideoPowerOn:
            case VideoPowerHibernate:

                return NO_ERROR;

            case VideoPowerStandBy:
            case VideoPowerSuspend:
            case VideoPowerOff:

                return ERROR_INVALID_FUNCTION;

            default:

                return ERROR_INVALID_PARAMETER;
        }

    }
    else if (DISPLAY_ADAPTER_HW_ID == HwDeviceId)
    {
        VideoDebugPrint((DEBUG_DETAIL, "ati.sys ATIMPGetPower50: Device Id = Graphics Adapter, State = D%ld\n",
            pVideoPowerMgmt->PowerState - 1));

        switch (pVideoPowerMgmt->PowerState) {

            case VideoPowerOn:
            case VideoPowerHibernate:

                return NO_ERROR;

            case VideoPowerStandBy:
            case VideoPowerSuspend:
            case VideoPowerOff:

                //
                // Indicate that we can't do VideoPowerOff, because
                // we have no way of coming back when power is re-applied
                // to the card.
                //

                return ERROR_INVALID_FUNCTION;

            default:

                ASSERT(FALSE);
                return ERROR_INVALID_FUNCTION;
        }
    }
    else
    {
        VideoDebugPrint((DEBUG_ERROR, "ati.sys ATIMPGetPower50: Unknown HwDeviceId\n"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
}   // ATIMPGetPower50()

ULONG
ATIMPGetVideoChildDescriptor(
    PVOID pHwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    )
//
// DESCRIPTION:
//  Enumerate all devices controlled by the ATI graphics chip.
//  This includes DDC monitors attached to the board, as well as other devices
//  which may be connected to a proprietary bus.
//
// PARAMETERS:
//  HwDeviceExtension   Pointer to our hardware device extension structure.
//  ChildEnumInfo       Information about the device that should be enumerated.
//  pvChildDescriptor   Identification structure of the device (EDID, string).
//  pHwId               Private unique 32 bit ID to passed back to the miniport.
//  pUnused             Do not use.
//
// RETURN VALUE:
//  ERROR_NO_MORE_DEVICES if no more child devices exist.
//  ERROR_INVALID_NAME if the device could not be enumerated, but more devices
//                     exist.
//  ERROR_MORE_DATA to be called again
//
// NOTE:
//  In the event of a failure return, none of the fields are valid except for
//  the return value and the pbMoreChildren field.
//
{
//
//
    ULONG Status;

    ASSERT(NULL != pHwDeviceExtension);

    VideoDebugPrint((DEBUG_NORMAL, "ATI.SYS!AtiGetVideoChildDescriptor: *** Entry point ***\n"));
    VideoDebugPrint((DEBUG_NORMAL, "ATI.SYS!AtiGetVideoChildDescriptor: pHwDeviceExtension = 0x%08X\n",
        pHwDeviceExtension));
    VideoDebugPrint((DEBUG_NORMAL, "ATI.SYS!AtiGetVideoChildDescriptor: ChildIndex = %ld\n", ChildEnumInfo->ChildIndex));


    switch (ChildEnumInfo->ChildIndex) {
    case 0:

        //
        // Case 0 is used to enumerate devices found by the ACPI firmware.
        //
        // Since we do not support ACPI devices yet, we must return failure.
        //

        Status = ERROR_NO_MORE_DEVICES;
        break;

    case 1:

        //
        // This is the last device we enumerate.  Tell the system we don't
        // have any more.
        //

        *pChildType = Monitor;

        //
        // Obtain the EDID structure via DDC.
        //

        if (DDC2Query50(pHwDeviceExtension,
                        pvChildDescriptor,
                        ChildEnumInfo->ChildDescriptorSize) == TRUE)
        {
            ASSERT(pChildType != NULL && pHwId != NULL);

            *pHwId = QUERY_MONITOR_ID;

            VideoDebugPrint((DEBUG_NORMAL, "ati.sys ATIMPGetVideoChildDescriptor: Successfully read EDID structure\n"));

        } else {

            //
            // Alway return TRUE, since we always have a monitor output
            // on the card and it just may not be a detectable device.
            //
            ASSERT(pChildType != NULL && pHwId != NULL);

            *pHwId = QUERY_NONDDC_MONITOR_ID;

            VideoDebugPrint((DEBUG_NORMAL, "ati.sys ATIMPGetVideoChildDescriptor: DDC not supported\n"));

        }

        Status = ERROR_MORE_DATA;
        break;

    case DISPLAY_ADAPTER_HW_ID:
        {

        PUSHORT     pPnpDeviceDescription = NULL;
        ULONG       stringSize = sizeof(L"*PNPXXXX");

        struct query_structure * QueryPtr =
            (struct query_structure *) (phwDeviceExtension->CardInfo);

        //
        // Special ID to handle return legacy PnP IDs for root enumerated
        // devices.
        //

        *pChildType = VideoChip;
        *pHwId      = DISPLAY_ADAPTER_HW_ID;


        //
        //  Figure out which card type and set pPnpDeviceDescription at
        //  associated string.
        //

        // "ATI Graphics Ultra Pro (mach32)"
        pPnpDeviceDescription = L"*PNP090A";

        if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
        {
            // "ATI Graphics Pro Turbo (mach64)"
            pPnpDeviceDescription = L"*PNP0916";
        }
        else if (phwDeviceExtension->ModelNumber == MACH32_ULTRA)
        {
            if (QueryPtr->q_system_bus_type == Eisa)
            {
                // "ATI Graphics Ultra Pro EISA (mach32)"
                pPnpDeviceDescription = L"*ATI4402";
            }
        }
        else if (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA)
        {
            // "ATI Graphics Ultra (mach8)"
            pPnpDeviceDescription = L"*PNP090B";

        }
        else if (phwDeviceExtension->ModelNumber == WONDER)
        {
            // "ATI VGA Wonder"
            pPnpDeviceDescription = L"*PNP090D";
        }

        //
        //  Now just copy the string into memory provided.
        //

        memcpy(pvChildDescriptor, pPnpDeviceDescription, stringSize);

        Status = ERROR_MORE_DATA;

        break;
        }


    default:

        Status = ERROR_NO_MORE_DEVICES;
        break;
    }

    if (ERROR_MORE_DATA == Status)
    {
        VideoDebugPrint((DEBUG_NORMAL, "ATI.SYS!AtiGetVideoChildDescriptor: ChildType = %ld\n", *pChildType));
        VideoDebugPrint((DEBUG_NORMAL, "ATI.SYS!AtiGetVideoChildDescriptor: pvHdId = 0x%x\n", *pHwId));
        VideoDebugPrint((DEBUG_NORMAL, "ATI.SYS!AtiGetVideoChildDescriptor: *** Exit TRUE ***\n"));
    }
    else
    {
        VideoDebugPrint((DEBUG_NORMAL, "ATI.SYS!AtiGetVideoChildDescriptor: *** Exit FALSE ***\n"));
    }

    return Status;

}   // AtiGetVideoChildDescriptor()

#endif  // TARGET_BUILD >= 500


//------------------------------------------------------------------------
/*
 * VP_STATUS RegistryParameterCallback(phwDeviceExtension, Context, Name, Data, Length);
 *
 * PHW_DEVICE_EXTENSION phwDeviceExtension;     Miniport device extension
 * PVOID Context;           Context parameter passed to the callback routine
 * PWSTR Name;              Pointer to the name of the requested field
 * PVOID Data;              Pointer to a buffer containing the information
 * ULONG Length;            Length of the data
 *
 * Routine to process the information coming back from the registry.
 *
 * Return value:
 *  NO_ERROR if successful
 *  ERROR_INSUFFICIENT_BUFFER if too much data to store
 */
VP_STATUS RegistryParameterCallback(PHW_DEVICE_EXTENSION phwDeviceExtension,
                                    PVOID Context,
                                    PWSTR Name,
                                    PVOID Data,
                                    ULONG Length)
{
    if (Length > REGISTRY_BUFFER_SIZE)
        {
        return ERROR_INSUFFICIENT_BUFFER;
        }

    /*
     * Copy the data to our local buffer so other routines
     * can use it.
     */
    memcpy(RegistryBuffer, Data, Length);
    RegistryBufferLength = Length;
    return NO_ERROR;

}   /* RegistryParameterCallback() */

BOOLEAN
SetDisplayPowerState(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    VIDEO_POWER_STATE VideoPowerState
    )
//
// DESCRIPTION:
//  Set the graphics card to the desired DPMS state under NT 3.51 and NT 4.0.
//
// PARAMETERS:
//  phwDeviceExtension  Pointer to our hardware device extension structure.
//  VideoPowerState     Desired DPMS state.
//
// RETURN VALUE:
//  TRUE if successful.
//  FALSE if unsuccessful.
//
{
    ASSERT(phwDeviceExtension != NULL);

    VideoDebugPrint((DEBUG_DETAIL, "ati.sys SetDisplayPowerState: Setting power state to %lu\n", VideoPowerState));

    //
    // Different card families need different routines to set the power management state.
    //

    if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
    {
        VIDEO_X86_BIOS_ARGUMENTS Registers;

        //
        // Invoke the BIOS call to set the desired DPMS state. The BIOS call
        // enumeration of DPMS states is in the same order as that in
        // VIDEO_POWER_STATE, but it is zero-based instead of one-based.
        //
        VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
        Registers.Eax = BIOS_SET_DPMS;
        Registers.Ecx = VideoPowerState - 1;
        VideoPortInt10(phwDeviceExtension, &Registers);

        return TRUE;
    }
    else
    {
        VideoDebugPrint((DEBUG_ERROR, "ati.sys SetDisplayPowerState: Invalid adapter type\n"));
        ASSERT(FALSE);
        return FALSE;
    }
}   // SetDisplayPowerState()

VIDEO_POWER_STATE
GetDisplayPowerState(
    PHW_DEVICE_EXTENSION phwDeviceExtension
    )
//
// DESCRIPTION:
//  Retrieve the current DPMS state from the graphics card.
//
// PARAMETERS:
//  phwDeviceExtension  Pointer to our hardware device extension structure.
//
// RETURN VALUE:
//  Current power management state.
//
// NOTE:
//  The enumerations VIDEO_DEVICE_POWER_MANAGEMENT (used by GetDisplayPowerState()) and VIDEO_POWER_MANAGEMENT
//  (used by this IOCTL) have opposite orderings (VIDEO_POWER_MANAGEMENT values increase as power consumption
//  decreases, while VIDEO_DEVICE_POWER_MANAGEMENT values increase as power consumption increases, and has
//  a reserved value for "state unknown"), so we can't simply add a constant to translate between them.
//
{
    VIDEO_POWER_STATE CurrentState = VideoPowerUnspecified;         // Current DPMS state

    ASSERT(phwDeviceExtension != NULL);

    //
    // Different card families need different routines to retrieve the power management state.
    //
    if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
        CurrentState = GetPowerManagement_cx(phwDeviceExtension);

    //
    // VIDEO_POWER_STATE has 5 possible states and a
    // reserved value to report that we can't read the state.
    // Our cards support 3 levels of monitor power-down in
    // addition to normal operation. Since the number of
    // values which can be reported exceeds the number
    // of states our cards can be in, we will never report
    // one of the possible states (VPPowerDeviceD3).
    //
    switch (CurrentState)
    {
        case VideoPowerUnspecified:

            VideoDebugPrint((DEBUG_DETAIL, "ati.sys GetDisplayPowerState: unknown videocard\n"));
            break;

        case VideoPowerOn:

            VideoDebugPrint((DEBUG_DETAIL, "ati.sys GetDisplayPowerState: Currently set to DPMS ON\n"));
            break;

        case VideoPowerStandBy:

            VideoDebugPrint((DEBUG_DETAIL, "ati.sys GetDisplayPowerState: Currently set to DPMS STAND-BY\n"));
            break;

        case VideoPowerSuspend:

            VideoDebugPrint((DEBUG_DETAIL, "ati.sys GetDisplayPowerState: Currently set to DPMS SUSPEND\n"));
            break;

        case VideoPowerOff:

            VideoDebugPrint((DEBUG_DETAIL, "ati.sys GetDisplayPowerState: Currently set to DPMS OFF\n"));
            break;

        default:

            VideoDebugPrint((DEBUG_ERROR, "ati.sys GetDisplayPowerState: Currently set to invalid DPMS state\n"));
            break;
    }

    return CurrentState;
}   // GetDisplayPowerState()



// ***********************   End of  ATIMP.C  ****************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\ddc50.c ===
//
// Module:  DDC50.C
// Date:    Jun 29, 1997
//
// Copyright (c) 1997 by ATI Technologies Inc.
//

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.1  $
      $Date:   30 Jun 1997 11:36:28  $
   $Author:   MACIESOW  $
      $Log:   V:\source\wnt\ms11\miniport\archive\ddc50.c_v  $
 * 
 *    Rev 1.1   30 Jun 1997 11:36:28   MACIESOW
 * Initial revision.

End of PolyTron RCS section                             *****************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <math.h>

#include "dderror.h"
#include "miniport.h"
#include "ntddvdeo.h"

#include "video.h"      /* for VP_STATUS definition */

#include "stdtyp.h"
#include "amachcx.h"
#include "amach1.h"
#include "atimp.h"
#include "atint.h"
#include "cvtvdif.h"
#include "cvtvga.h"
#include "dynainit.h"
#include "dynatime.h"
#include "services.h"
#include "vdptocrt.h"
#define INCLUDE_CVTDDC
#include "cvtddc.h"


#if (TARGET_BUILD >= 500)


VOID    WriteClockLineDAC(PHW_DEVICE_EXTENSION phwDeviceExtension, UCHAR ucData);
VOID    WriteDataLineDAC(PHW_DEVICE_EXTENSION phwDeviceExtension, UCHAR ucData);
BOOLEAN ReadClockLineDAC(PHW_DEVICE_EXTENSION phwDeviceExtension);
BOOLEAN ReadDataLineDAC(PHW_DEVICE_EXTENSION phwDeviceExtension);
VOID    WaitForVsyncActiveDAC(PHW_DEVICE_EXTENSION HwDeviceExtension);


VOID    WriteClockLineGP(PHW_DEVICE_EXTENSION phwDeviceExtension, UCHAR ucData);
VOID    WriteDataLineGP(PHW_DEVICE_EXTENSION phwDeviceExtension, UCHAR ucData);
BOOLEAN ReadClockLineGP(PHW_DEVICE_EXTENSION phwDeviceExtension);
BOOLEAN ReadDataLineGP(PHW_DEVICE_EXTENSION phwDeviceExtension);
VOID    WaitForVsyncActiveGP(PHW_DEVICE_EXTENSION HwDeviceExtension);


/****************************************************************
;       DDC register
;
; High Byte, High Word
;
;      ...  5   4   3   2   1   0    SCW = CLK  Write
; --------|---|---|---|---|---|---|  SDW = DATA Write
;      ...|SCW|SDW|   |SCR|SDR|   |  SCR = CLK  Read
; ---------------------------------  SDR = DATA Read
;
;****************************************************************/


VOID WriteClockLineDAC(PHW_DEVICE_EXTENSION phwDeviceExtension, UCHAR ucData)
{
    UCHAR Scratch;

    //
    // Value is inverted.
    //

    ucData = (ucData + 1) & 0x01;

    //
    // Write to the SCL line.
    //

    Scratch = (INP_HBHW(DAC_CNTL) & 0xE8) | (ucData << 5);
    OUTP_HBHW(DAC_CNTL, Scratch);

}

VOID WriteDataLineDAC(PHW_DEVICE_EXTENSION phwDeviceExtension, UCHAR ucData)
{
    UCHAR Scratch;

    //
    // Value is inverted.
    //

    ucData = (ucData + 1) & 0x01;

    //
    // Write to the SDA line.
    //

    Scratch = (INP_HBHW(DAC_CNTL) & 0xD8) | (ucData << 4);
    OUTP_HBHW(DAC_CNTL, Scratch);
}


BOOLEAN ReadClockLineDAC(PHW_DEVICE_EXTENSION phwDeviceExtension)
{
    return ((INP_HBHW(DAC_CNTL) & 0x04) >> 2);
}

BOOLEAN ReadDataLineDAC(PHW_DEVICE_EXTENSION phwDeviceExtension)
{
    return ((INP_HBHW(DAC_CNTL) & 0x02) >> 1);
}


VOID WaitForVsyncActiveDAC(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    //
    // BUGBUG
    //

    delay(30);
}


/****************************************************************
;       DDC register
;
; High Byte, Low Word
;
;      ...  5   4   3   2   1   0
; --------|---|---|---|---|---|---|
;      ...|SCR|SDR|   |   |   |   |  SCR = CLK  Read
; ---------------------------------  SDR = DATA Read
;
; High Byte, High Word
;
;      ...  5   4   3   2   1   0    SCW = CLK  Write
; --------|---|---|---|---|---|---|  SDW = DATA Write
;      ...|SCW|SDW|   |   |   |   |
; ---------------------------------
;
;****************************************************************/


VOID WriteClockLineGP(PHW_DEVICE_EXTENSION phwDeviceExtension, UCHAR ucData)
{
    UCHAR Scratch;

    //
    // Value is inverted.
    //

    ucData = (ucData + 1) & 0x01;

    //
    // Write to the SCL line.
    //

    Scratch = (INP_HBHW(GP_IO) & 0xDF) | (ucData << 5);
    OUTP_HBHW(GP_IO, Scratch);

}

VOID WriteDataLineGP(PHW_DEVICE_EXTENSION phwDeviceExtension, UCHAR ucData)
{
    UCHAR Scratch;

    //
    // Value is inverted.
    //

    ucData = (ucData + 1) & 0x01;

    //
    // Write to the SDA line.
    //

    Scratch = (INP_HBHW(GP_IO) & 0xEF) | (ucData << 4);
    OUTP_HBHW(GP_IO, Scratch);
}


BOOLEAN ReadClockLineGP(PHW_DEVICE_EXTENSION phwDeviceExtension)
{
    return ((INP_HBLW(GP_IO) & 0x20) >> 5);
}

BOOLEAN ReadDataLineGP(PHW_DEVICE_EXTENSION phwDeviceExtension)
{
    return ((INP_HBLW(GP_IO) & 0x10) >> 4);
}

VOID WaitForVsyncActiveGP(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    //
    // BUGBUG
    //

    delay(30);
}





BOOLEAN
DDC2Query50(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    PUCHAR QueryBuffer,
    ULONG  BufferSize)
//
// DESCRIPTION:
//  Reads the basic EDID structure from the monitor using DDC2.
//
// PARAMETERS:
//  phwDeviceExtension  Points to per-adapter device extension.
//  QueryBuffer         Buffer where information will be stored.
//  BufferSize          Size of the buffer to fill.
//
// RETURN VALUE:
//  Whether the call succeeded or not.
//
{

    struct query_structure * Query;
    I2C_FNC_TABLE i2c;
    ULONG Checksum;
    ULONG i;

    //
    // Get a formatted pointer into the query section of HW_DEVICE_EXTENSION.
    //

    Query = (struct query_structure *)phwDeviceExtension->CardInfo;

    //
    // Determine which class of hardware we are dealing with, since
    // different cards use different registers to control the SCL
    // and SDA lines. Don't worry about cards which don't support
    // DDC2, since the check for DDC support will have rejected
    // any of these cards so we won't reach this point in the code.
    //

    {
        i2c.WriteClockLine = WriteClockLineDAC;
        i2c.WriteDataLine  = WriteDataLineDAC;
        i2c.ReadClockLine  = ReadClockLineDAC;
        i2c.ReadDataLine   = ReadDataLineDAC;
        i2c.WaitVsync      = WaitForVsyncActiveDAC;

        VideoDebugPrint((DEBUG_NORMAL, "DAC DDC control"));
    }

    i2c.Size = sizeof(I2C_FNC_TABLE);

    if (!VideoPortDDCMonitorHelper(phwDeviceExtension,
                                   &i2c,
                                   QueryBuffer,
                                   BufferSize))
    {
        VideoDebugPrint((DEBUG_NORMAL, "DDC Query Failed\n"));
        return FALSE;
    }

    return TRUE;

}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\dpms.c ===
//
// Module:  DPMS.C
// Date:    Aug 08, 1997
//
// Copyright (c) 1997 by ATI Technologies Inc.
//

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.1  $
      $Date:   21 Aug 1997 15:01:36  $
   $Author:   MACIESOW  $
      $Log:   V:\source\wnt\ms11\miniport\archive\dpms.c_v  $
 * 
 *    Rev 1.1   21 Aug 1997 15:01:36   MACIESOW
 * Initial revision.

End of PolyTron RCS section                             *****************/

#include <stdio.h>
#include <stdlib.h>

#include "dderror.h"
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"
#include "amach1.h"
#include "amachcx.h"
#include "atimp.h"
#include "atint.h"
#include "dpms.h"
#include "init_m.h"
#include "init_cx.h"

//
// Allow miniport to be swapped out when not needed.
//
#if defined (ALLOC_PRAGMA)
#pragma alloc_text (PAGE_COM, SetMonitorPowerState)
#pragma alloc_text (PAGE_COM, GetMonitorPowerState)
#endif


VP_STATUS
SetMonitorPowerState(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    VIDEO_POWER_STATE VideoPowerState
    )
//
// DESCRIPTION:
//  Set the CRT output to the desired DPMS state under.
//
// PARAMETERS:
//  phwDeviceExtension  Points to hardware device extension structure.
//  VideoPowerState     Desired DPMS state.
//
// RETURN VALUE:
//  Status code, NO_ERROR = OK.
//
{
    ASSERT(phwDeviceExtension != NULL);

    VideoDebugPrint((DEBUG_DETAIL, "ATI.SYS SetMonitorPowerState: Setting power state to %lu\n", VideoPowerState));

    if ((VideoPowerState != VideoPowerOn) &&
        (VideoPowerState != VideoPowerStandBy) &&
        (VideoPowerState != VideoPowerSuspend) &&
        (VideoPowerState != VideoPowerOff))
    {
        VideoDebugPrint((DEBUG_DETAIL, "ATI.SYS SetMonitorPowerState: Invalid VideoPowerState\n"));
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Different card families need different routines to set the power management state.
    //

    if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
    {
        VIDEO_X86_BIOS_ARGUMENTS Registers;

        //
        // Invoke the BIOS call to set the desired DPMS state. The BIOS call
        // enumeration of DPMS states is in the same order as that in
        // VIDEO_POWER_STATE, but it is zero-based instead of one-based.
        //
        VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
        Registers.Eax = BIOS_SET_DPMS;
        Registers.Ecx = VideoPowerState - 1;
        VideoPortInt10(phwDeviceExtension, &Registers);

        return NO_ERROR;
    }

    else if((phwDeviceExtension->ModelNumber == _8514_ULTRA) ||
            (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA) ||
            (phwDeviceExtension->ModelNumber == MACH32_ULTRA))

    {
        struct query_structure * pQuery =
            (struct query_structure *) phwDeviceExtension->CardInfo;

        return SetPowerManagement_m(pQuery, VideoPowerState);
    }
    else
    {
        VideoDebugPrint((DEBUG_ERROR, "ATI.SYS SetMonitorPowerState: Invalid adapter type\n"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
}   // SetMonitorPowerState()

VP_STATUS
GetMonitorPowerState(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    PVIDEO_POWER_STATE pVideoPowerState
    )
//
// DESCRIPTION:
//  Retrieve the current CRT power state.
//
// PARAMETERS:
//  phwDeviceExtension  Points to hardware device extension structure.
//  pVideoPowerStats    Points to
//
// RETURN VALUE:
//  Error code on error.
//  NO_ERROR = OK, current power management state in pVideoPowerState.
//
// NOTE:
//  The enumerations VIDEO_DEVICE_POWER_MANAGEMENT (used by GetMonitorPowerState()) and VIDEO_POWER_MANAGEMENT
//  (used by this IOCTL) have opposite orderings (VIDEO_POWER_MANAGEMENT values increase as power consumption
//  decreases, while VIDEO_DEVICE_POWER_MANAGEMENT values increase as power consumption increases, and has
//  a reserved value for "state unknown"), so we can't simply add a constant to translate between them.
//
{
    VP_STATUS vpStatus;

    ASSERT(phwDeviceExtension != NULL && pVideoPowerState != NULL);

    //
    // Different card families need different routines to retrieve the power management state.
    //
    if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
        *pVideoPowerState = GetPowerManagement_cx(phwDeviceExtension);
    else
        *pVideoPowerState = GetPowerManagement_m(phwDeviceExtension);

    //
    // VIDEO_POWER_STATE has 5 possible states and a
    // reserved value to report that we can't read the state.
    // Our cards support 3 levels of monitor power-down in
    // addition to normal operation. Since the number of
    // values which can be reported exceeds the number
    // of states our cards can be in, we will never report
    // one of the possible states (VPPowerDeviceD3).
    //
    switch (*pVideoPowerState)
    {
        case VideoPowerOn:
    
            VideoDebugPrint((DEBUG_DETAIL, "ATI.SYS GetMonitorPowerState: Currently set to DPMS ON\n"));
            vpStatus = NO_ERROR;
            break;

        case VideoPowerStandBy:

            VideoDebugPrint((DEBUG_DETAIL, "ATI.SYS GetMonitorPowerState: Currently set to DPMS STAND-BY\n"));
            vpStatus = NO_ERROR;
            break;

        case VideoPowerSuspend:

            VideoDebugPrint((DEBUG_DETAIL, "ATI.SYS GetMonitorPowerState: Currently set to DPMS SUSPEND\n"));
            vpStatus = NO_ERROR;
            break;

        case VideoPowerOff:

            VideoDebugPrint((DEBUG_DETAIL, "ATI.SYS GetMonitorPowerState: Currently set to DPMS OFF\n"));
            vpStatus = NO_ERROR;
            break;

        default:

            VideoDebugPrint((DEBUG_ERROR, "ATI.SYS GetMonitorPowerState: Currently set to invalid DPMS state\n"));
            *pVideoPowerState = VideoPowerOn;
            vpStatus = ERROR_INVALID_PARAMETER;
            break;
    }

    return vpStatus;
}   // GetMonitorPowerState()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\cvtvga.h ===
/************************************************************************/
/*                                                                      */
/*                                  CVTVGA.H                            */
/*                                                                      */
/*      Copyright (c) 1992,         ATI Technologies Inc.               */
/************************************************************************/

/**********************       PolyTron RCS Utilities

 $Revision:   1.8  $
     $Date:   06 Feb 1996 15:59:40  $
   $Author:   RWolff  $
      $Log:   S:/source/wnt/ms11/miniport/archive/cvtvga.h_v  $
 * 
 *    Rev 1.8   06 Feb 1996 15:59:40   RWolff
 * For 1600x1200, deleted 52Hz table (never an official mode, offered
 * only to allow a choice of refresh rates), updated 60Hz to match CRT
 * parameters currently offered by install program, added 66Hz and 76Hz.
 * 
 *    Rev 1.7   19 Dec 1995 14:01:34   RWolff
 * Added support for refresh rates up to 100Hz at 640x480, 800x600, and
 * 1024x768 and 75Hz at 1280x1024. Updated mode tables to match those in
 * the Mach64 Programmer's Guide.
 * 
 *    Rev 1.6   07 Sep 1995 16:43:06   RWolff
 * Fixed 1280x1024 95Hz interlaced (listed as 47Hz in display applet) to
 * eliminate "wrap" at top of screen. The tables in both the Mach 32
 * and Mach 64 books contain the wrong values for vertical total and
 * vertical sync start.
 * 
 *    Rev 1.5   20 Jul 1995 17:55:48   mgrubac
 * Added support for VDIF files
 * 
 *    Rev 1.4   10 Apr 1995 15:57:36   RWOLFF
 * Added prototype for routine to replace BookValues[] entries where the
 * Mach 64 and Mach 8/Mach 32 need different CRT parameters.
 * 
 *    Rev 1.3   31 Aug 1994 16:23:08   RWOLFF
 * Added support for 1152x864 and 1600x1200 "canned" mode tables.
 * 
 *    Rev 1.2   19 Aug 1994 17:10:22   RWOLFF
 * Added support for non-standard pixel clock generators.
 * 
 *    Rev 1.1   12 May 1994 11:11:02   RWOLFF
 * Added refresh rate to st_book_data structure, re-ordered list of book
 * mode tables to allow a single range of indices when highest noninterlaced
 * refresh rates at a given resolution are ignored.
 * 
 *    Rev 1.0   31 Jan 1994 11:40:38   RWOLFF
 * Initial revision.
        
           Rev 1.1   08 Oct 1993 11:04:50   RWOLFF
        Removed prototype for unused "fall back to 56Hz" function for 800x600.
        
           Rev 1.0   16 Aug 1993 13:30:00   Robert_Wolff
        Initial revision.
        
           Rev 1.8   08 Apr 1993 16:44:54   RWOLFF
        Revision level as checked in at Microsoft.
        
           Rev 1.6   25 Mar 1993 11:13:38   RWOLFF
        Brought function prototype into sync with the function definition
        to eliminate compile-time warnings.
        
           Rev 1.5   08 Mar 1993 19:28:18   BRADES
        submit to MS NT
        
           Rev 1.4   02 Dec 1992 17:29:56   Robert_Wolff
        Added prototype for FallBack800to56().
        
           Rev 1.3   27 Nov 1992 15:18:20   STEPHEN
        No change.
        
           Rev 1.2   17 Nov 1992 17:25:34   Robert_Wolff
        Fixed gathering of CRT parameters for 68800 card with minimal
        install (EEPROM blank, then predefined monitor type selected).
        
           Rev 1.1   12 Nov 1992 16:44:26   Robert_Wolff
        Same file is now used for both Windows NT driver and VIDEO.EXE
        test program. XlateVgaTable() no longer depends on the global
        variable classMACH32.
        
           Rev 1.1   09 Oct 1992 15:01:24   Robert_Wolff
        Added fields for DISP_CNTL and CLOCK_SEL values.
        
           Rev 1.0   01 Oct 1992 15:32:38   Robert_Wolff
        Initial revision.


End of PolyTron RCS section                             *****************/


#if defined(DOC)
CVTVGA.H - ATI card VGA to 8514 format translation

DESCRIPTION:
    This include file contains definitions specific to the
    VGA to 8514 format EEPROM translation module of the program VIDEO.EXE

    Included are structure definitions, function prototypes
    and general definitions


#endif

/*
 * Bit 8 of CRT parameter table entry 0 is set if the table is in
 * 8514 format and clear if the table is in VGA format.
 */
#define FMT_8514    0x0100

/*
 * Bit 6 of CRT parameter table entry 0 is set if all parameters
 * are to be read from the EEPROM and clear if only sync polarities
 * are to be used.
 */
#define CRTC_USAGE  0x0040

/*
 * Bit flags to recognize which vertical scan rate is used at
 * a given resolution. The name for the constant is in the form
 * M<horizontal resolution>F<vertical scan frequency), with the
 * "M" standing for (M)ode.
 */
#define M640F72     0x0001

#define M800F72     0x0020
#define M800F70     0x0010
#define M800F60     0x0008
#define M800F56     0x0004
#define M800F89     0x0002
#define M800F95     0x0001

#define M1024F66    0x0010
#define M1024F72    0x0008
#define M1024F70    0x0004
#define M1024F60    0x0002
#define M1024F87    0x0001

#define M1280F95    0x0002
#define M1280F87    0x0001

/*
 * There are 3 1120x750 modes which use the same flag bit. Assume
 * that the 70Hz noninterlaced mode was selected.
 */
#define M1120F70    0x0001

/*
 * In some installations, the display parameters are not stored
 * in the EEPROM. Instead, they are read from a table corresponding
 * to Appendix D of the Programmer's Guide to the Mach 32 Registers.
 *
 * The entries in our copy of the table are arranged in ascending order
 * of horizontal resolution, with entries having the same horizontal
 * resolution sorted from worst to best (interlaced modes in increasing
 * order of vertical scan frequency, followed by noninterlaced modes in
 * ascending order of vertical scan frequency.
 *
 * The name for the constant is in the form
 * B<horizontal resolution>F<vertical scan frequency>, with the
 * "B" standing for (B)ook.
 */
#define B640F60     0
#define B640F72     1
#define B640F75     2
#define B640F90     3
#define B640F100    4
#define B800F89     5
#define B800F95     6
#define B800F56     7
#define B800F60     8
#define B800F70     9
#define B800F72     10
#define B800F75     11
#define B800F90     12
#define B800F100    13
#define B1024F87    14
#define B1024F60    15
#define B1024F66    16
#define B1024F70    17
#define B1024F72    18
#define B1024F75    19
#define B1024F90    20
#define B1024F100   21
#define B1120F70    22
#define B1152F87    23
#define B1152F95    24
#define B1152F60    25
#define B1152F70    26
#define B1152F75    27
#define B1152F80    28
#define B1280F87    29
#define B1280F95    30
#define B1280F60    31
#define B1280F70    32
#define B1280F74    33
#define B1280F75    34
#define B1600F60    35
#define B1600F66    36
#define B1600F76    37

/*
 * VGA parameter table entry to use when translating into 8514 format.
 * The value NO_TBL_ENTRY will cause the VGA to 8514 format translation
 * routine to fail gracefully if we have run into an EEPROM CRT parameter
 * table in VGA format for which we have no entry in the VGA parameter table.
 *
 * The entries in the VGA parameter table are arranged in ascending order
 * of horizontal resolution, with entries having the same horizontal
 * resolution sorted in ascending order of vertical scan frequency. No
 * distinction is made between interlaced and noninterlaced modes.
 *
 * The name for the constant is in the form
 * T<horizontal resolution>F<vertical scan frequency>, with the
 * "T" standing for (T)able.
 */
#define T640F72     0

#define T800F72     4
#define T800F70     3
#define T800F60     2
#define T800F56     1
#define T800F89     5

#define T1024F72    8
#define T1024F70    7
#define T1024F60    6
#define T1024F87    9

/*
 * Some resolution/vertical scan rate combinations (e.g. IBM default
 * 640x480) did not have VGA parameter tables in either VGAP$PS2.ASM
 * or VGAP$68A.MAC. For these modes, XlateVgaTable() will return
 * the parameters in Appendix D of the Programmer's Guide to the
 * Mach 32 Registers, since calculating the values for the mode table
 * requires a VGA parameter table.
 *
 * If we encounter one of these modes (identified by its (T)able
 * value being greater than or equal to USE_BOOK_VALUE), handle
 * it the same way we deal with modes whose parameters are not
 * stored in the EEPROM.
 */
#define NO_TBL_ENTRY -1
#define USE_BOOK_VALUE 1000

#define T640F60     USE_BOOK_VALUE+B640F60
#define T800F95     USE_BOOK_VALUE+B800F95
#define T1024F66    USE_BOOK_VALUE+B1024F66
#define T1280F87    USE_BOOK_VALUE+B1280F87
#define T1280F95    USE_BOOK_VALUE+B1280F95
#define T1120F70    USE_BOOK_VALUE+B1120F70

/*
 * Value returned in overscan words if no table entry was found.
 * This value was chosen because it will stand out when the overscan
 * words are printed out as 4 hex digits (as is done by VIDEO.EXE).
 */
#define INVALID_WARNING 0x0DEAD

/*
 * Bits which are set in pmode->control when sync polarity is negative,
 * and mask which must be ORed with sync width during VGA to 8514 conversion
 * if the sync is negative.
 */
#define HSYNC_BIT       0x4000
#define VSYNC_BIT       0x8000
#define NEG_SYNC_FACTOR 0x0020

/*
 * Mask for bit which is set in st_vga_data.MiscParms
 * for interlaced modes.
 */
#define INTERL  0x040

/*
 * Mask for bit which is set in st_vga_data.Mode
 * if word mode is enabled.
 */
#define WORD_MODE 0x004

/*
 * Format of VGA parameter table. This structure contains only those values
 * from the mode tables in VGAROM\VGAP$68A.MAC and VGAROM\VGAP$PS2.ASM which
 * are used in translating EEPROM data from VGA to 8514 format (original
 * tables are 64 bytes).
 *
 * The offsets listed in the comments are the offsets of the corresponding
 * bytes in the assembler tables.
 */
struct st_vga_data
{
    unsigned char Stretch;      /* Horizontal values stretched if 128 here, offset 0 */
    unsigned char MiscParms;    /* Miscelaneous parameters, offset 7 */
    unsigned char DisplayWidth; /* Offset 11 */
    unsigned char DisplayHgt;   /* Offset 28 */
    unsigned char Mode;         /* Contains word mode flag, offset 33 */

    /*
     * Values for CLOCK_SEL, DISP_CNTL, and ClockFreq taken from the
     * Programmer's Guide to the Mach 32 Registers. These values are
     * not stored as a combination of the CRT registers when the
     * EEPROM data is in VGA format.
     */
    unsigned short ClockSel;
    unsigned short DispCntl;
    unsigned long  ClockFreq;   /* Pixel clock frequency in Hertz */
};

/*
 * Data structure to hold mode parameters as quoted in Appendix D
 * of the Programmer's Guide to the Mach 32 Registers.
 */
struct st_book_data
{
    unsigned char HTotal;       /* Horizontal total */
    unsigned char HDisp;        /* Horizontal displayed */
    unsigned char HSyncStrt;    /* Horizontal sync start */
    unsigned char HSyncWid;     /* Horizontal sync width */
    unsigned short VTotal;      /* Vertical total */
    unsigned short VDisp;       /* Vertical displayed */
    unsigned short VSyncStrt;   /* Vertical sync start */
    unsigned char VSyncWid;     /* Vertical sync width */
    unsigned char DispCntl;     /* Display control */
    unsigned long ClockFreq;    /* Pixel clock frequency, in Hertz */
    unsigned short ClockSel;    /* Clock Select */
    unsigned short Refresh;     /* Refresh rate */
};

/*
 * Data structure which eases setting one particular byte of a
 * data word. If foo is a variable of type SplitWord, then a 16 bit
 * value can be set using foo.word, or the high and low bytes
 * can be accessed independently by using foo.byte.high and
 * foo.byte.low.
 */
struct TwoBytes
{
    unsigned char low;
    unsigned char high;
};

union SplitWord
{
    unsigned short word;
    struct TwoBytes byte;
};

/*
 * Function to translate a CRT parameter table in VGA format
 * into 8514 format and fill in the mode table.
 */
extern short XlateVgaTable(PVOID HwDeviceExtension, short TableOffset,
                           struct st_mode_table *pmode, short VgaTblEntry,
                           short BookTblEntry, struct st_eeprom_data *ee,
                           BOOL IsMach32);

/*
 * Function to fill in a CRT parameter table using values from
 * Appendix D of the Programmer's Guide to the Mach 32 Registers,
 * rather than the EEPROM contents. This is done when the
 * bit flag for "use stored parameters" is clear.
 */
extern void BookVgaTable(short VgaTblEntry, struct st_mode_table *pmode);

/*
 * Function to replace "canned" CRT tables with Mach 64 versions
 * in cases where the Mach 64 needs a pixel clock value which the
 * Mach 8 and Mach 32 can't generate.
 */
extern void SetMach64Tables(void);

/*
 * Array of parameters taken from Appendix D of the
 * Programmer's Guide to the Mach 32 Registers.
 *
 * For interlaced modes, the refresh rate field contains the
 * frame rate, not the vertical scan frequency.
 */
#ifdef INCLUDE_CVTVGA
struct st_book_data BookValues[B1600F76-B640F60+1] =
{
    {0x063, 0x04F, 0x052, 0x02C, 0x0418, 0x03BF, 0x03D2, 0x022, 0x023,  25175000L, 0x0800, 60}, /* 640x480 60Hz NI */
    {0x069, 0x04F, 0x052, 0x025, 0x040B, 0x03BF, 0x03D0, 0x023, 0x023,  32000000L, 0x0800, 72}, /* 640x480 72Hz NI */
    {0x068, 0x04F, 0x051, 0x028, 0x03E3, 0x03BF, 0x03C0, 0x023, 0x023,  31500000L, 0x0800, 75}, /* 640x480 75Hz NI */
    {0x067, 0x04F, 0x053, 0x025, 0x0428, 0x03BF, 0x03F0, 0x02E, 0x023,  39910000L, 0x0800, 90}, /* 640x480 90Hz NI */
    {0x069, 0x04F, 0x057, 0x030, 0x0422, 0x03BF, 0x03E9, 0x02C, 0x023,  44900000L, 0x0800, 100},    /* 640x480 100Hz NI */

    {0x080, 0x063, 0x065, 0x004, 0x057D, 0x04AB, 0x04C2, 0x02C, 0x033,  32500000L, 0x0800, 44}, /* 800x600 89Hz I */
    {0x084, 0x063, 0x06D, 0x010, 0x057C, 0x04AB, 0x04C2, 0x00C, 0x033,  36000000L, 0x0800, 47}, /* 800x600 95Hz I */
    {0x07F, 0x063, 0x066, 0x009, 0x04E0, 0x04AB, 0x04B0, 0x002, 0x023,  36000000L, 0x0800, 56}, /* 800x600 56Hz NI */
    {0x083, 0x063, 0x068, 0x010, 0x04E3, 0x04AB, 0x04B0, 0x004, 0x023,  40000000L, 0x0800, 60}, /* 800x600 60Hz NI */
    {0x07D, 0x063, 0x066, 0x012, 0x04F3, 0x04AB, 0x04C0, 0x02C, 0x023,  44900000L, 0x0800, 70}, /* 800x600 70Hz NI */
    {0x081, 0x063, 0x06A, 0x00F, 0x0537, 0x04AB, 0x04F8, 0x006, 0x023,  50000000L, 0x0800, 72}, /* 800x600 72Hz NI */
    {0x083, 0x063, 0x065, 0x00A, 0x04E0, 0x04AB, 0x04B0, 0x003, 0x023,  49500000L, 0x0800, 75}, /* 800x600 75Hz NI */
    {0x07B, 0x063, 0x063, 0x008, 0x04F2, 0x04AB, 0x04BB, 0x00B, 0x023,  56640000L, 0x0800, 90}, /* 800x600 90Hz NI */
    {0x086, 0x063, 0x067, 0x008, 0x04E0, 0x04AB, 0x04BA, 0x004, 0x023,  67500000L, 0x0800, 100},    /* 800x600 75Hz NI */

    {0x09D, 0x07F, 0x081, 0x016, 0x0660, 0x05FF, 0x0600, 0x008, 0x033,  44900000L, 0x0800, 43}, /* 1024x768 87Hz I */
    {0x0A7, 0x07F, 0x082, 0x031, 0x0649, 0x05FF, 0x0602, 0x026, 0x023,  65000000L, 0x0800, 60}, /* 1024x768 60Hz NI */
    {0x0AD, 0x07F, 0x085, 0x016, 0x065B, 0x05FF, 0x060B, 0x004, 0x023,  75000000L, 0x0800, 66}, /* 1024x768 66Hz NI */
    {0x0A5, 0x07F, 0x082, 0x031, 0x0649, 0x05FF, 0x0602, 0x026, 0x023,  75000000L, 0x0800, 70}, /* 1024x768 70Hz NI */
    {0x0A0, 0x07F, 0x082, 0x031, 0x0649, 0x05FF, 0x0602, 0x026, 0x023,  75000000L, 0x0800, 72}, /* 1024x768 72Hz NI */
    {0x0A3, 0x07F, 0x081, 0x00C, 0x063B, 0x05FF, 0x0600, 0x003, 0x023,  78750000L, 0x0800, 75}, /* 1024x768 75Hz NI */
    {0x0A3, 0x07F, 0x07C, 0x02C, 0x0698, 0x05FF, 0x0628, 0x02F, 0x023, 100000000L, 0x0800, 90}, /* 1024x768 90Hz NI */
    {0x0AD, 0x07F, 0x081, 0x02B, 0x062B, 0x05FF, 0x05FF, 0x028, 0x023, 110000000L, 0x0800, 100},    /* 1024x768 100Hz NI */

    {0x0AE, 0x08B, 0x095, 0x00F, 0x0659, 0x05DD, 0x05FC, 0x00A, 0x023,  80000000L, 0x0800, 70}, /* 1120x750 70Hz NI */

    {0x0B0, 0x08F, 0x097, 0x010, 0x083E, 0x06BF, 0x075D, 0x009, 0x033,  65000000L, 0x0800, 43}, /* 1152x864 87Hz I */
    {0x0B4, 0x08F, 0x09A, 0x010, 0x0766, 0x06BF, 0x06FD, 0x009, 0x033,  65000000L, 0x0800, 47}, /* 1152x864 95Hz I */
    {0x0B5, 0x08F, 0x097, 0x00E, 0x0727, 0x06BF, 0x06CD, 0x005, 0x023,  80000000L, 0x0800, 60}, /* 1152x864 60Hz NI */
    {0x0BC, 0x08F, 0x093, 0x013, 0x0764, 0x06BF, 0x06DC, 0x00B, 0x023, 100000000L, 0x0800, 70}, /* 1152x864 70Hz NI */
    {0x0B6, 0x08F, 0x092, 0x012, 0x07D5, 0x06BF, 0x071C, 0x008, 0x023, 110000000L, 0x0800, 75}, /* 1152x864 75Hz NI */
    {0x0B3, 0x08F, 0x090, 0x00E, 0x077D, 0x06BF, 0x06FD, 0x007, 0x023, 110000000L, 0x0800, 80}, /* 1152x864 80Hz NI */

    {0x0C7, 0x09F, 0x0A9, 0x00A, 0x08F8, 0x07FF, 0x0861, 0x00A, 0x033,  80000000L, 0x0800, 43}, /* 1280x1024 87Hz I */
    {0x0C7, 0x09F, 0x0A9, 0x00A, 0x0842, 0x07FF, 0x0800, 0x00A, 0x033,  80000000L, 0x0800, 47}, /* 1280x1024 95Hz I */
    {0x0D6, 0x09F, 0x0A9, 0x02E, 0x0852, 0x07FF, 0x0800, 0x025, 0x023, 110000000L, 0x0800 | CLOCK_SEL_MUX, 60}, /* 1280x1024 60Hz NI */
    {0x0D2, 0x09F, 0x0A9, 0x00E, 0x0851, 0x07FF, 0x0800, 0x005, 0x023, 126000000L, 0x0800 | CLOCK_SEL_MUX, 70}, /* 1280x1024 70Hz NI */
    {0x0D5, 0x09F, 0x0A3, 0x012, 0x084B, 0x07FF, 0x07FF, 0x01E, 0x023, 135000000L, 0x0800 | CLOCK_SEL_MUX, 74}, /* 1280x1024 74Hz NI */
    {0x0D2, 0x09F, 0x0A1, 0x012, 0x0851, 0x07FF, 0x0800, 0x003, 0x023, 135000000L, 0x0800 | CLOCK_SEL_MUX, 75}, /* 1280x1024 75Hz NI */

    /*
     * Although the horizontal CRT parameters are stored in 8-bit fields,
     * some refresh rates at 1600x1200 result in a 9-bit value. In these
     * cases, we store only the lower-order 8 bits, and the BIOS will
     * resolve the matter when we set the mode.
     */
    {0x0FF, 0x0C7, 0x0CB, 0x034, 0x09E9, 0x095F, 0x0971, 0x028, 0x023, 156000000L, 0x0800, 60}, /* 1600x1200 60Hz NI */
    {0x003, 0x0C7, 0x0CC, 0x031, 0x09C8, 0x095F, 0x0962, 0x023, 0x023, 172000000L, 0x0800, 66}, /* 1600x1200 66Hz NI */
    {0x003, 0x0C7, 0x0CC, 0x031, 0x09C8, 0x095F, 0x0962, 0x025, 0x023, 198000000L, 0x0800, 76}  /* 1600x1200 76Hz NI */
};
#else
extern struct st_book_data BookValues[B1600F76-B640F60+1]; 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\detect_m.h ===
/************************************************************************/
/*                                                                      */
/*                              DETECT_M.H                              */
/*                                                                      */
/*        Aug 25  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.4  $
      $Date:   11 Jan 1995 13:57:52  $
	$Author:   RWOLFF  $
	   $Log:   S:/source/wnt/ms11/miniport/vcs/detect_m.h  $
 * 
 *    Rev 1.4   11 Jan 1995 13:57:52   RWOLFF
 * Replaced VCS logfile comment accidentally removed when checking in
 * the last revision.
 * 
 *    Rev 1.3   04 Jan 1995 13:17:30   RWOLFF
 * Moved definitions used by Get_BIOS_Seg() to SERVICES.H.
 * 
 *    Rev 1.2   23 Dec 1994 10:48:10   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.1   19 Aug 1994 17:10:40   RWOLFF
 * Added support for Graphics Wonder, removed dead code.
 * 
 *    Rev 1.0   31 Jan 1994 11:41:00   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.3   05 Nov 1993 13:24:36   RWOLFF
 * Added new #defined values for new BIOS segment detection code.
 * 
 *    Rev 1.2   08 Oct 1993 11:08:42   RWOLFF
 * Added "_m" to function names to identify them as being specific to the
 * 8514/A-compatible family of ATI accelerators.
 * 
 *    Rev 1.1   24 Sep 1993 11:43:26   RWOLFF
 * Removed mapping of identification-only registers for all card families,
 * added additional 8514/A-compatible information gathering formerly done
 * in ATIMP.C.
 * 
 *    Rev 1.0   03 Sep 1993 14:27:50   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
DETECT_M.H - Header file for DETECT_M.C

#endif

/*
 * Prototypes for functions supplied by DETECT_M.C
 */
extern int  WhichATIAccelerator_m(void);

extern void GetExtraData_m(void);
extern BOOL ATIFindExtFcn_m(struct query_structure *);
extern BOOL ATIFindEEPROM_m(struct query_structure *);
extern void ATIGetSpecialHandling_m(struct query_structure *);

/*
 * Definitions used internally by DETECT_M.C.
 */
#ifdef INCLUDE_DETECT_M

   
/*
 * On Graphics Wonder cards, the string "GRAPHICS WONDER" will appear
 * somewhere in the first 500 bytes of the video BIOS.
 */
#define GW_AREA_START       0
#define GW_AREA_END       500  


#define VGA_CHIP_OFFSET     0x43    /* Bytes from base where vga_chip found */
#define MACH8_REV_OFFSET    0x4C    /* Bytes from base where Mach 8 BIOS revision found */
#define MACH32_EXTRA_OFFSET 0x62    /* Bytes from base where "aperture high bits read
                                       from high byte of SCRATCH_PAD_0" flag found */
#define LOAD_SHADOW_OFFSET  0x64    /* Bytes from base where Load Shadow Set entry found */
#define INTEL_JMP           0xE9    /* Opcode for Intel 80x86 JMP instruction */


#endif  /* defined INCLUDE_DETECT_M */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\dpms.h ===
//
// Module:  DPMS.H
// Date:    Aug 11, 1997
//
// Copyright (c) 1997 by ATI Technologies Inc.
//

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.1  $
      $Date:   21 Aug 1997 15:02:00  $
   $Author:   MACIESOW  $
      $Log:   V:\source\wnt\ms11\miniport\archive\dpms.h_v  $
 * 
 *    Rev 1.1   21 Aug 1997 15:02:00   MACIESOW
 * Initial revision.

End of PolyTron RCS section                             *****************/


#ifndef _DPMS_H_
#define _DPMS_H_

//
// Prototypes for functions supplied by DPMS.C
//
VP_STATUS
SetMonitorPowerState(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    VIDEO_POWER_STATE VideoPowerState
    );

VP_STATUS
GetMonitorPowerState(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    PVIDEO_POWER_STATE pVideoPowerState
    );

#endif  // _DPMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\eeprom.h ===
/************************************************************************/
/*                                                                      */
/*                              EEPROM.H                                */
/*                                                                      */
/*        Aug 25  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.0  $
      $Date:   31 Jan 1994 11:41:26  $
	$Author:   RWOLFF  $
	   $Log:   S:/source/wnt/ms11/miniport/vcs/eeprom.h  $
 * 
 *    Rev 1.0   31 Jan 1994 11:41:26   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.1   08 Oct 1993 15:18:50   RWOLFF
 * Added prototypes for ee_sel_eeprom() and ee_init_io() to allow
 * EEVGA.C to be built without including VIDFIND.H.
 * 
 *    Rev 1.0   03 Sep 1993 14:28:04   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
EEPROM.H - Header file for EEPROM.C

#endif


/*
 * Constants used for EEPROM access.
 */
#define STYLE_8514  0   /* Data stored 8514-style */
#define STYLE_VGA   1   /* Data stored VGA-style */

#define BUS_8BIT    0   /* 8514/ULTRA in 8-bit slot */
#define BUS_16BIT   1   /* 8514/ULTRA in 16-bit slot */

/*
 * Global data structures used for EEPROM access.
 */
extern struct  st_eeprom_data  g_ee;    // the location of I/O port bits

/*
 * Global variables dealing with the EEPROM.
 */
extern ULONG    ati_reg;        /* Base register for ATI extended VGA registers */
extern char     vga_chip;       // VGA chip revision as ascii

/*
 * Function prototypes.
 */
extern WORD ee_read_vga (short iIndex);     // VGA method
extern void ee_write_vga(unsigned short uiIndex, unsigned short uiData);
extern void ee_cmd_vga(unsigned short uiInstruct);
extern void ee_erase_vga(unsigned short uiIndex);
extern void ee_enab_vga(void);
extern void ee_disab_vga(void);

extern WORD ee_read_8514 (short index);
extern void ee_cmd_16 (WORD instruct);
extern void ee_cmd_1K (WORD instruct);

extern void Mach32DescribeEEPROM(int Style);
extern void Mach8UltraDescribeEEPROM(int BusWidth);
extern void Mach8ComboDescribeEEPROM(void);

BOOLEAN ee_sel_eeprom (PVOID Context);
BOOLEAN ee_init_io (PVOID Context);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\dynatime.h ===
//
// Module:  DYNATIME.H
// Date:    Feb 13, 1997
//
// Copyright (c) 1997 by ATI Technologies Inc.
//

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.4  $
      $Date:   13 Jul 1997 21:36:20  $
   $Author:   MACIESOW  $
      $Log:   V:\source\wnt\ms11\miniport\archive\dynatime.h_v  $
 * 
 *    Rev 1.4   13 Jul 1997 21:36:20   MACIESOW
 * Flat panel and TV support.
 * 
 *    Rev 1.3   02 Jun 1997 14:20:56   MACIESOW
 * Clean up.
 * 
 *    Rev 1.2   02 May 1997 15:01:56   MACIESOW
 * Registry mode filters. Mode lookup table.
 * 
 *    Rev 1.1   25 Apr 1997 13:07:46   MACIESOW
 * o globals.
 * 
 *    Rev 1.0   15 Mar 1997 10:16:50   MACIESOW
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifndef _DYNATIME_H_
#define _DYNATIME_H_

//
// Define the various types of displays.
//
#define DISPLAY_TYPE_FLAT_PANEL     0x00000001
#define DISPLAY_TYPE_CRT            0x00000002
#define DISPLAY_TYPE_TV             0x00000004

//
// Prototypes for functions supplied by DYNATIME.C.
//
BOOL
IsMonitorConnected(
    PHW_DEVICE_EXTENSION phwDeviceExtension
    );

BOOL
IsMonitorOn(
    PHW_DEVICE_EXTENSION phwDeviceExtension
    );

BOOL
SetMonitorOn(
    PHW_DEVICE_EXTENSION phwDeviceExtension
    );

BOOL
SetMonitorOff(
    PHW_DEVICE_EXTENSION phwDeviceExtension
    );

BOOL
SetFlatPanelOn(
    PHW_DEVICE_EXTENSION phwDeviceExtension
    );

BOOL
SetFlatPanelOff(
    PHW_DEVICE_EXTENSION phwDeviceExtension
    );

BOOL
SetTVOn(
    PHW_DEVICE_EXTENSION phwDeviceExtension
    );

BOOL
SetTVOff(
    PHW_DEVICE_EXTENSION phwDeviceExtension
    );

VP_STATUS
GetDisplays(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    PULONG pulDisplays
    );

VP_STATUS
GetDisplays(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    PULONG pulDisplays
    );

VP_STATUS
SetDisplays(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    ULONG ulDisplays
    );

BOOL
MapModeIndex(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    ULONG ulDesiredIndex,
    PULONG pulActualIndex
    );

#endif  // _DYNATIME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\eeprom.c ===
/************************************************************************/
/*                                                                      */
/*                               EEPROM.C                               */
/*                                                                      */
/*  Copyright (c) 1992, ATI Technologies Incorporated.	                */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
    $Revision:   1.3  $
    $Date:   23 Jan 1996 11:45:50  $
    $Author:   RWolff  $
    $Log:   S:/source/wnt/ms11/miniport/archive/eeprom.c_v  $
 * 
 *    Rev 1.3   23 Jan 1996 11:45:50   RWolff
 * Eliminated level 3 warnings.
 * 
 *    Rev 1.2   23 Dec 1994 10:47:34   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.1   07 Feb 1994 14:07:06   RWOLFF
 * Added alloc_text() pragmas to allow miniport to be swapped out when
 * not needed.
 * 
 *    Rev 1.0   31 Jan 1994 11:08:14   RWOLFF
 * Initial revision.
        
           Rev 1.2   08 Oct 1993 15:17:42   RWOLFF
        No longer includes VIDFIND.H.
        
           Rev 1.1   03 Sep 1993 14:23:06   RWOLFF
        Partway through CX isolation.
        
           Rev 1.0   16 Aug 1993 13:23:00   Robert_Wolff
        Initial revision.
        
           Rev 1.10   21 Apr 1993 17:29:48   RWOLFF
        Now uses AMACH.H instead of 68800.H/68801.H.
        
           Rev 1.9   25 Mar 1993 11:14:42   RWOLFF
        Added typecast to get rid of warnings.
        
           Rev 1.8   08 Mar 1993 19:30:28   BRADES
        submit to MS NT
        
           Rev 1.5   06 Jan 1993 11:02:04   Robert_Wolff
        Eliminated dead code.
        
           Rev 1.4   24 Dec 1992 14:41:36   Chris_Brady
        fixup warnings
        
           Rev 1.3   27 Nov 1992 15:19:12   STEPHEN
        No change.
        
           Rev 1.2   13 Nov 1992 17:08:28   Robert_Wolff
        Now includes 68801.H, which consists of the now-obsolete MACH8.H
        and elements moved from VIDFIND.H.
        
           Rev 1.1   12 Nov 1992 16:54:00   Robert_Wolff
        Same source file can now be used with both Windows NT driver
        and VIDEO.EXE test program.
        
           Rev 1.0   05 Nov 1992 14:06:02   Robert_Wolff
        Initial revision.
        
           Rev 1.1   14 Sep 1992 09:44:40   Robert_Wolff
        Moved EEPROM opcodes to VIDEO.H, made VGA routine names consistent
        with same-purpose routines for 8514.
        
           Rev 1.0   02 Sep 1992 12:12:54   Chris_Brady
        Initial revision.
        

End of PolyTron RCS section                             *****************/

#ifdef DOC
    EEPROM.C -  EEPROM functions for 8514/Ultra, Graphics Ultra adapters
        see   EEVGA.ASM for the  VGA class  eeprom functions.

        Since time marches on, and the names of accelerator products
        changes often, these names are equivalent :
        { Mach32 or 68800 or Graphics Ultra Pro }

#endif

#include <conio.h>

#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"

#include "amach.h"
#include "amach1.h"

#include "atimp.h"
#include "eeprom.h"
#include "services.h"

//----------------IFNDEF DATA_ASM
extern  WORD    rom_segment;
extern  WORD    rom_offset;



//----------------IFNDEF INIT_ASM
extern  WORD    default_640_set;
extern  WORD    default_1024_set;



/*
 * Global EEPROM data structures
 */
struct  st_eeprom_data  g_ee;           // the location of I/O port bits


//-----------------------------------------
//   function prototypes 



        void    ee_wait (void);
        void    ee_clock_16 (WORD eedata);
        void    ee_sel_16 (void);
        void    ee_deselect_16 (void);
        WORD    ee_read (short index);
        void    ee_write (short index, WORD eedata);


//-----------------------------------------


/*
 * Allow miniport to be swapped out when not needed.
 *
 * The following routines are called through function pointers
 * rather than an explicit call to the routine, and may run into
 * trouble if paged out. If problems develop, make them un-pageable:
 * ee_cmd_16()
 * ee_cmd_1K()
 * ee_read_8514()
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_M, ee_wait)
#pragma alloc_text(PAGE_M, ee_cmd_16)
#pragma alloc_text(PAGE_M, ee_cmd_1K)
#pragma alloc_text(PAGE_M, ee_sel_16)
#pragma alloc_text(PAGE_M, ee_deselect_16)
#pragma alloc_text(PAGE_M, ee_clock_16)
#pragma alloc_text(PAGE_M, ee_read)
#pragma alloc_text(PAGE_M, ee_read_8514)
#pragma alloc_text(PAGE_M, ee_write)
#pragma alloc_text(PAGE_M, Mach32DescribeEEPROM)
#pragma alloc_text(PAGE_M, Mach8UltraDescribeEEPROM)
#pragma alloc_text(PAGE_M, Mach8ComboDescribeEEPROM)
#endif
// these commands do NOT use the index component bits 5-0 so there
// is not a problem addressing up to 8 bit indexes , 256 words.
#define EE_EWEN            0x04C0    // program enable
#define EE_EWDS            0x0400    // program disable
#define EE_ERAL            0x0480    // erase all
#define EE_WRAL            0x0440    // program all



//;----------------------------------------------------------------------
//; EE_WAIT
//;   Waits for the requisite minimum setup time for the EEPROM
//;----------------------------------------------------------------------


void    ee_wait ()
{
//EE_DELAY_TIME (256-1) * 0.8381 usec = 214.0 usec
    delay (1);                      // delay in milliseconds
}   /* ee_wait */


//----------------------------------------------------------------------
// EE_CMD_16
//   Sends EEPROM opcode and address to a 1k, 2k eeprom
//   instruct is an  5 bit command in the form of 0111 1100 0000
//            with a 6 bit index   in the form of 0000 0011 1111
//   IF bit 10 is 1, then 8 bit address follows, else address not used.
//   Write data Serially to the   EE_DATA_OUT_M32 bit of the ee->out.
//   Send out in high to low bit order
//   
//----------------------------------------------------------------------

void    ee_cmd_16 (WORD instruct)
{
int     jj;
WORD    bittest = 0x400;                // 0100 0000 0000b    bit 10
WORD    eedata;
struct st_eeprom_data *ee = phwDeviceExtension->ee;

    ee_clock_16((WORD) (ee->select | ee->chipselect));  // start bit
    for (jj=0; jj < 11;  jj++)
        {
        ee_wait();
        if (instruct & bittest)             // is a one bit
            eedata = ee->select | ee->chipselect | ee->data_out;
        else
            eedata = ee->select | ee->chipselect;
        OUTPW (ee->iop_out, eedata);
        
        ee_clock_16 (eedata);       // send cmd bit
        bittest >>= 1;                      // next bit to the right
        }
    return;
}    /* ee_cmd_16 */



//----------------------------------------------------------------------
// EE_CMD_1K
//   Sends EEPROM opcode and address to a 1k, 2k eeprom
//   instruct is an  5 bit command in the form of 0111 1100 0000
//            with a 6 bit index   in the form of 0000 0011 1111
//   IF bit 10 is 1, then 8 bit address follows, else address not used.
//   Write data Serially to the   EE_DATA_OUT_M32 bit of the ee->iop_out.
//   Send out in high to low bit order
//   
//----------------------------------------------------------------------

void    ee_cmd_1K (WORD instruct)
{
int     jj;
WORD    bittest = 0x400;                // 0100 0000 0000b    bit 10
WORD    eedata;
struct st_eeprom_data *ee = phwDeviceExtension->ee;

    ee_clock_16((WORD) (ee->select | ee->chipselect));  // start bit      
    for (jj=0; jj < 3;  jj++)
        {
        ee_wait();
        if (instruct & bittest)             // is a one bit
            eedata = ee->select | ee->chipselect | ee->data_out;
        else
            eedata = ee->select | ee->chipselect;
        OUTPW (ee->iop_out, eedata);
        
        ee_clock_16 (eedata);       // send cmd bit
        bittest >>= 1;                      // next bit to the right
        }
    bittest = 0x20;                         // 0010 0000b    bit 5
    for (jj=0; jj < 6;  jj++)
        {
        ee_wait();
        if (instruct & bittest)             // is a one bit
            eedata = ee->select | ee->chipselect | ee->data_out;
        else
            eedata = ee->select | ee->chipselect;
        OUTPW (ee->iop_out, eedata);
        
        ee_clock_16 (eedata);           // send cmd bit
        bittest >>= 1;                      // next bit to the right
        }
    return;
}    /* ee_cmd_1K */



//;----------------------------------------------------------------------
//; EE_SEL_16
//;   Pull EEPROM chip select high
//;
//;----------------------------------------------------------------------

void    ee_sel_16 (void)
{
struct st_eeprom_data *ee = phwDeviceExtension->ee;

    ee_wait();
    OUTPW (ee->iop_out, (WORD)((ee->select) | (ee->chipselect)));   // EE_CS high
    ee_wait();
    return;

}   /* ee_sel_16 */


//;----------------------------------------------------------------------
//; EE_DESELECT_16
//;   Pull EEPROM chip select low
//;
//;----------------------------------------------------------------------

void    ee_deselect_16 (void)
{
struct st_eeprom_data *ee = phwDeviceExtension->ee;

    ee_wait();
    OUTPW (ee->iop_out, ee->select);    // EE_CS high
    ee_clock_16 (ee->select);           // send cmd bit
    OUTPW (ee->iop_out, 0);             // disable EEprom activity
    ee_wait();
    return;

}   /* ee_deselect_16 */


//;----------------------------------------------------------------------
//; EE_CLOCK_16
//;   Toggle EEPROM CLK line high then low
//;
//;   INPUT: eedata = select status for EEPROM
//;----------------------------------------------------------------------

void    ee_clock_16 (WORD eedata)
{
struct st_eeprom_data *ee = phwDeviceExtension->ee;

    ee_wait();
    OUTPW (ee->iop_out, (WORD)(eedata | (ee->clock)));      // clock ON
    ee_wait();
    OUTPW (ee->iop_out, (WORD)(eedata & ~(ee->clock)));     // clock OFF
    ee_wait();

}   /* ee_clock_16 */


//;----------------------------------------------------------------------
//; EE_READ                     - was a 68800 function
//;   Read a word from EEPROM      ONLY called from   INIT.asm
//;   INPUT: bl = index
//;   OUTPUT: ax = data
//;----------------------------------------------------------------------

WORD    ee_read (short index)
{
WORD    indata=0;

    if (INPW(CONFIG_STATUS_1) & 1)		//is 8514 or VGA eeprom
        {                               // VGA disabled, use 8514 method
        indata = ee_read_8514 (index);
        }
    else{
        indata = ee_read_vga (index);   // VGA method
        }
    return (indata);
}   /* ee_read */


//;----------------------------------------------------------------------
//; EE_READ_8514   
//;   Read a word from using 8514 EEPROM registers
//;   INPUT: bl = index
//;   OUTPUT: ax = data
//;----------------------------------------------------------------------

WORD    ee_read_8514 (short index) 
{
struct st_eeprom_data *ee = phwDeviceExtension->ee;

int     jj;
WORD    save_misc, indata=0;

    save_misc = INPW (R_MISC_CNTL); 	// Read only location
    ee_sel_16();
    (ee->EEcmd) ((WORD) (EE_READ | index));     // send read cmd and index to EEPROM
    ee_clock_16 ((WORD) (ee->select | ee->chipselect));

    for (jj=0; jj < 16; jj++)
        {
        indata <<= 1;
        if (INPW(ee->iop_in) & ee->data_in)	// get data bit
            indata |= 1;
        ee_clock_16 ((WORD) (ee->select | ee->chipselect));
        }

    ee_deselect_16();
    OUTPW (MISC_CNTL, save_misc);

    return (indata);
}   /* ee_read_8514 */


//;----------------------------------------------------------------------
//; EE_WRITE
//;   Writes a word to EEPROM      
//;             However, this will fail since 1K eeprom does NOT need
//;             the EE_EWEN, EE_EWDS  commands          +++++++++++++++++
//;             See EEVGA.C  ee_write_vga().
//;   INPUT: index = which word to write
//;          data  = data to write
//;----------------------------------------------------------------------
                
void    ee_write (short index, WORD eedata)
{
struct st_eeprom_data *ee = phwDeviceExtension->ee;

int     jj;
WORD    save_misc, indata=0;

    if (INPW(CONFIG_STATUS_1) & 1)		//is 8514 or VGA eeprom
        {                                       // VGA disabled, use 8514 method
        save_misc = INPW (R_MISC_CNTL); 	// Read only location
        OUTP (DISP_CNTL, 0x53); 	// disable CRT before writing EEPROM

        ee_sel_16();
        ee_cmd_16 (EE_EWEN);        // enable EEPROM write

        ee_deselect_16();   // EE_CS low
        ee_sel_16();

        ee_cmd_16 ((WORD) (EE_ERASE | index)); 
        ee_deselect_16();   // EE_CS low
        delay (50);

        ee_sel_16();
        ee_cmd_16 ((WORD) (EE_WRITE | index));      // EEPROM write data


        for (jj=0; jj < 16; jj++)
            {
            ee_wait();
            if (eedata & 0x8000)                // get data bit
                OUTPW (ee->iop_out, (WORD)((ee->select) | (ee->chipselect) | (ee->data_out)));
            else
                OUTPW (ee->iop_out, (WORD)((ee->select) | (ee->chipselect)));
            ee_clock_16  ((WORD) (ee->select | ee->chipselect));
            eedata <<= 1;
            }

        ee_deselect_16();   // EE_CS low
        delay (50);                                   // in milliseconds
        ee_sel_16();
        ee_cmd_16 (EE_EWDS);    // disable EEPROM write
        ee_deselect_16();   // EE_CS low

        OUTPW (ee->iop_out, save_misc);
        }
    else{
        ee_write_vga (index, eedata);       // VGA method
        }

}   /* ee_write */


/***************************************************************************
 *
 * New Functions
 *
 ***************************************************************************/

/*
 * void Mach32DescribeEEPROM(Style);
 *
 * int Style;   Is data stored 8514-style or VGA-style?
 *
 * Fill in the EEPROM description structure for the Mach 32 card.
 */
void Mach32DescribeEEPROM(int Style)
{
    g_ee.iop_out      = MISC_CNTL;
    g_ee.iop_in       = EXT_GE_STATUS;
    g_ee.clock        = EE_CLK_M32;
    g_ee.select       = EE_SELECT_M32;
    g_ee.chipselect   = EE_CS_M32;
    g_ee.data_out     = EE_DATA_OUT_M32;
    g_ee.data_in      = EE_DATA_IN;

    if (Style == STYLE_8514)
        {
        g_ee.EEread = ee_read_8514;       // 8514 style
        g_ee.EEcmd  = ee_cmd_16;
        }
    else{
        g_ee.EEread       = ee_read_vga;  // VGA style
        g_ee.EEcmd        = ee_cmd_vga;
        g_ee.addr_size    = 8;
        }
    return;
}


/*
 * void Mach8UltraDescribeEEPROM(BusWidth);
 *
 * int BusWidth;    Is 8514/ULTRA plugged into 8 or 16 bit slot?
 *
 * Fill in the EEPROM description structure for the 8514/ULTRA.
 */
void Mach8UltraDescribeEEPROM(int BusWidth)
{
    g_ee.data_in      = EE_DATA_IN;
    g_ee.iop_out      = EXT_GE_CONFIG;
    g_ee.iop_in       = EXT_GE_STATUS;
    g_ee.EEread       = ee_read_8514;        // how read eeprom
    g_ee.EEcmd        = ee_cmd_1K;           // send command to eeprom

    /*
     * Only the 8514/Ultra has a hardware bug that prevents it
     * from writing to the EEPROM when it is in an 8 bit ISA bus.
     */
    if (BusWidth == BUS_8BIT)
        {
        g_ee.clock        = EE_CLK_M8_8;
        g_ee.select       = EE_SELECT_M8_8;
        g_ee.chipselect   = EE_CS_M8_8;
        g_ee.data_out     = EE_DATA_OUT_M8_8;
        }
    else{
        g_ee.clock        = EE_CLK_M8_16;        // assume are in a 16 bit bus
        g_ee.select       = EE_SELECT_M8_16;
        g_ee.chipselect   = EE_CS_M8_16;
        g_ee.data_out     = EE_DATA_OUT_M8_16;
        }
    return;
}


/*
 * void Mach8ComboDescribeEEPROM(void);
 *
 * Fill in the EEPROM description structure for the Graphics ULTRA
 * and Graphics VANTAGE. These cards always have both the 8514 and
 * the VGA enabled, so the EEPROM is ALWAYS read VGA style.
 */
extern void Mach8ComboDescribeEEPROM(void)
{
    g_ee.addr_size        = 6;
    g_ee.iop_out          = EXT_GE_CONFIG;
    g_ee.iop_in           = EXT_GE_STATUS;
    g_ee.data_in          = EE_DATA_IN;

    g_ee.clock            = EE_CLK_M8_16;     // are in a 16 bit bus
    g_ee.select           = EE_SELECT_M8_16;
    g_ee.chipselect       = EE_CS_M8_16;
    g_ee.data_out         = EE_DATA_OUT_M8_16;

    g_ee.EEread           = ee_read_vga;      // VGA style
    g_ee.EEcmd            = ee_cmd_vga;
    return;
}




//*******************   end  of  EEPROM.C   ******************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\dynainit.h ===
//
// Module:  DYNAINIT.H
// Date:    Feb 10, 1997
//
// Copyright (c) 1997 by ATI Technologies Inc.
//

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.4  $
      $Date:   13 Jul 1997 21:34:14  $
   $Author:   MACIESOW  $
      $Log:   V:\source\wnt\ms11\miniport\archive\dynainit.h_v  $
 * 
 *    Rev 1.4   13 Jul 1997 21:34:14   MACIESOW
 * Flat panel and TV support.
 * 
 *    Rev 1.3   02 Jun 1997 14:18:14   MACIESOW
 * Clean up.
 * 
 *    Rev 1.2   02 May 1997 15:00:14   MACIESOW
 * Registry mode filters. Mode lookup table.
 * 
 *    Rev 1.1   25 Apr 1997 12:53:06   MACIESOW
 * No globals.
 * 
 *    Rev 1.0   15 Mar 1997 10:16:16   MACIESOW
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifndef _DYNAINIT_H_
#define _DYNAINIT_H_

//
// Flags used by hardware change detection
//
#define HC_CARD                     0x0001
#define HC_MONITOR                  0x0002
#define HC_MONITOR_OFF              0x0004
#define HC_MONITOR_UNKNOWN          0x8000

//
// Defines used in CARD_INFO structure
//
#define CARD_CHIP_TYPE_SIZE         128
#define CARD_DAC_TYPE_SIZE          128
#define CARD_ADAPTER_STRING_SIZE    128
#define CARD_BIOS_STRING_SIZE       128

//
// Defines used in MONITOR_INFO structure
//
#define MONITOR_GENERIC             L"Generic"
#define MONITOR_DATA_GENERIC        0
#define MONITOR_DATA_ASCII_VDIF     1
#define MONITOR_DATA_BIN_VDIF       2
#define MONITOR_DATA_EDID           3
#define MONITOR_DATE_SIZE           11
#define MONITOR_REVISION_SIZE       16
#define MONITOR_MANUFACTURER_SIZE   16
#define MONITOR_MODEL_NUMBER_SIZE   16
#define MONITOR_MIN_VDIF_INDEX_SIZE 16
#define MONITOR_VERSION_SIZE        16
#define MONITOR_SERIAL_NUMBER_SIZE  16
#define MONITOR_TYPE_SIZE           16
#define MONITOR_GENERIC_SIZE        sizeof(MONITOR_GENERIC)
#define MONITOR_BIN_VDIF_SIZE       38
#define MONITOR_EDID_SIZE           10

//
// Define the maximum TV resolutions and refresh rate.
//
#define TV_MAX_HOR_RESOLUTION       800
#define TV_MAX_VER_RESOLUTION       600
#define TV_MAX_REFRESH              60

//
// Define default values in case if ATI ROM cannot be read.
//
#define LT_MAX_HOR_RESOLUTION       1600
#define LT_MAX_VER_RESOLUTION       1200
#define LT_DEFAULT_REFRESH_FLAGS    0xFFFF

//
// Define refresh LT rate flags.
//
#define LT_REFRESH_FLAG_43          0x0001
#define LT_REFRESH_FLAG_47          0x0002
#define LT_REFRESH_FLAG_60          0x0004
#define LT_REFRESH_FLAG_67          0x0008
#define LT_REFRESH_FLAG_70          0x0010
#define LT_REFRESH_FLAG_72          0x0020
#define LT_REFRESH_FLAG_75          0x0040
#define LT_REFRESH_FLAG_76          0x0080
#define LT_REFRESH_FLAG_85          0x0100
#define LT_REFRESH_FLAG_90          0x0200
#define LT_REFRESH_FLAG_100         0x0400
#define LT_REFRESH_FLAG_120         0x0800
#define LT_REFRESH_FLAG_140         0x1000
#define LT_REFRESH_FLAG_150         0x2000
#define LT_REFRESH_FLAG_160         0x4000
#define LT_REFRESH_FLAG_200         0x8000

//
// Structure containing information about the current LCD display (BIOS al = 0x83).
//
#pragma pack(1)
typedef struct _FLAT_PANEL_INFO
{
    BYTE byteId;                    // Panel identification
    BYTE byteIdString[24];          // Panel identification string
    WORD wHorSize;                  // Horizontal size in pixels
    WORD wVerSize;                  // Vertical size in lines
    WORD wType;                     // Flat panel type
	                                //  bit 0      0 = monochrome
	                                //             1 = color
	                                //  bit 1      0 = single panel construction
	                                //             1 = dual (split) panel construction
	                                //  bits 7-2   0 = STN (passive matrix)
	                                //             1 = TFT (active matrix)
	                                //             2 = active addressed STN
	                                //             3 = EL
	                                //             4 = plasma
	                                //  bits 15-18 reserved
    BYTE byteRedBits;               // Red bits per primary
    BYTE byteGreenBits;             // Green bits per primary
    BYTE byteBlueBits;              // Blue bits per primary
    BYTE byteReserved1;             // Reserved bits per primary
    DWORD dwOffScreenMem;           // Size in KB of off screen memory required for frame buffer
    DWORD dwPointerMem;             // Pointer to reserved off screen memory for frame buffer
    BYTE byteReserved2[14];         // Reserved
} FLAT_PANEL_INFO, *PFLAT_PANEL_INFO;
#pragma pack()

typedef struct _CARD_INFO
{
    UCHAR ucaChipType[CARD_CHIP_TYPE_SIZE];
    UCHAR ucaDacType[CARD_DAC_TYPE_SIZE];
    UCHAR ucaAdapterString[CARD_ADAPTER_STRING_SIZE];
    UCHAR ucaBiosString[CARD_BIOS_STRING_SIZE];
    ULONG ulMemorySize;
} CARD_INFO, *PCARD_INFO;

typedef struct _MONITOR_INFO
{
    BOOL bDDC2Used;
    short nDataSource;
    union
    {
        struct
        {
            UCHAR ucaDate[MONITOR_DATE_SIZE];
            UCHAR ucaRevision[MONITOR_REVISION_SIZE];
            UCHAR ucaManufacturer[MONITOR_MANUFACTURER_SIZE];
            UCHAR ucaModelNumber[MONITOR_MODEL_NUMBER_SIZE];
            UCHAR ucaMinVDIFIndex[MONITOR_MIN_VDIF_INDEX_SIZE];
            UCHAR ucaVersion[MONITOR_VERSION_SIZE];
            UCHAR ucaSerialNumber[MONITOR_SERIAL_NUMBER_SIZE];
            UCHAR ucaDateManufactured[MONITOR_DATE_SIZE];
            UCHAR ucaMonitorType[MONITOR_TYPE_SIZE];
            short nCRTSize;
        } AsciiVdif;
        UCHAR ucaGeneric[MONITOR_GENERIC_SIZE];
        UCHAR ucaBinVdif[MONITOR_BIN_VDIF_SIZE];
        UCHAR ucaEdid[MONITOR_EDID_SIZE];
    } ProductID;
} MONITOR_INFO, *PMONITOR_INFO;

//
// Prototypes for functions supplied by DYNAINIT.C
//
BOOL
FinishModeTableCreation(                    // To be removed
    PHW_DEVICE_EXTENSION phwDeviceExtension
    );

VOID
GetRegistryCardInfo(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    PCARD_INFO pCardInfo
    );

VOID
GetRegistryMonitorInfo(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    PMONITOR_INFO pMonitorInfo
    );

#endif  // _DYNAINIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\eevga.c ===
/************************************************************************/
/*                                                                      */
/*                              EEVGA.C                                 */
/*                                                                      */
/* Copyright   (c)  1992  ATI Technologies Inc.                         */
/************************************************************************/
/*                                                                      */

/**********************       PolyTron RCS Utilities

 $Revision:   1.3  $
     $Date:   23 Jan 1996 11:46:08  $
   $Author:   RWolff  $
      $Log:   S:/source/wnt/ms11/miniport/archive/eevga.c_v  $
 * 
 *    Rev 1.3   23 Jan 1996 11:46:08   RWolff
 * Eliminated level 3 warnings.
 * 
 *    Rev 1.2   23 Dec 1994 10:47:10   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.1   07 Feb 1994 14:07:44   RWOLFF
 * Added alloc_text() pragmas to allow miniport to be swapped out when
 * not needed.
 * 
 *    Rev 1.0   31 Jan 1994 11:08:26   RWOLFF
 * Initial revision.
        
           Rev 1.2   08 Oct 1993 15:17:28   RWOLFF
        No longer includes VIDFIND.H.
        
           Rev 1.1   03 Sep 1993 14:23:18   RWOLFF
        Partway through CX isolation.
        
           Rev 1.0   16 Aug 1993 13:26:32   Robert_Wolff
        Initial revision.
        
           Rev 1.11   24 Jun 1993 14:32:48   RWOLFF
        Microsoft-originated change: now uses VideoPortSynchronizeExecution()
        instead of _disable()/_enable() pairs.
        
           Rev 1.10   10 May 1993 10:54:08   RWOLFF
        Fixed uninitialized variable in Read_ee().
        
           Rev 1.9   27 Apr 1993 20:19:40   BRADES
        change extern ati_reg toa long, is a virtual IO address now.
        
           Rev 1.8   21 Apr 1993 17:31:10   RWOLFF
        Now uses AMACH.H instead of 68800.H/68801.H.
        
           Rev 1.7   08 Mar 1993 19:28:36   BRADES
        submit to MS NT
        
           Rev 1.5   06 Jan 1993 11:05:22   Robert_Wolff
        Cleaned up compile warnings.
        
           Rev 1.4   27 Nov 1992 15:19:30   STEPHEN
        No change.
        
           Rev 1.3   13 Nov 1992 16:32:32   Robert_Wolff
        Now includes 68801.H, which consists of the now-obsolete MACH8.H
        and elements moved from VIDFIND.H.
        
           Rev 1.2   12 Nov 1992 16:56:56   Robert_Wolff
        Same source file can now be used for both Windows NT driver and
        VIDEO.EXE test program.
        
           Rev 1.1   06 Nov 1992 19:02:34   Robert_Wolff
        Moved I/O port defines to VIDFIND.H.
        
           Rev 1.0   05 Nov 1992 14:01:06   Robert_Wolff
        Initial revision.
        
           Rev 1.1   01 Oct 1992 15:29:08   Robert_Wolff
        Can now handle both Mach32 and Mach8 cards.
        
           Rev 1.0   14 Sep 1992 09:44:30   Robert_Wolff
        Initial revision.
        
        
End of PolyTron RCS section                             *****************/


#if defined(DOC)
EEVGA.C - EEPROM read and write routines

DESCRIPTION:

        VGA   EEPROM read and write routines

September 4 1992 -  R. Wolff

Translated from assembler into C.

August 28 1992 -   C. Brady.

This has been adapted from the VGA$EEC.ASM software by Steve Stefanidis

The original code used externs to long_delay() and short_delay(), these
where changed to use local function delay.

The original used compile time options to work with various VGA revisions,
it is required to be run time determinate since we need to access
eeprom VGA style (how archaic) for the Graphics Ultra (38800) and the
68800 family of graphics controllers.

OLD_EEPROM_MAP  equ     1       ; enables the Old EEPROM Handling routines
REMOVED,  the DETECT.C routine assigns the eeprom address size used 
in EE_addr().  I do not know of a Graphics Ultra using 7 bit address
since they ONLY had a 1k eeprom == 64 words.

#endif      

#include <conio.h>
#include <dos.h>

#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"
#include "amach.h"
#include "amach1.h"
#include "atimp.h"
#include "cvtvga.h"     /* For SplitWord data type */
#include "eeprom.h"
#include "services.h"

#define OFF		0
#define ON		1

#define IND_OFFSET  0x00B0
#define SYNC_I      0x008 ^ IND_OFFSET
#define L_ALL       0x004
#define MISC3_I     0x010 ^ IND_OFFSET
#define EEPROM      0x020               /* EEPROM Enable bit */
#define EE_WREG     0x003 ^ IND_OFFSET
#define EE_CS       0x008               /* Chip Select bit */
#define EE_ENABLE   0x004
#define EE_CLK      0x002
#define EE_DI       0x001
#define EE_RREG     0x007 ^ IND_OFFSET
#define EE_DO       0x008

/*
 * Definitions for reading and writing the VGA sequencer registers.
 */
#define SD_CLOCK    0x0001      /* Index for clock mode register */
/*
 * Bit to set in clock mode register to blank the screen and disable
 * video-generation logic access to video memory.
 */
#define SD_CLK_OFF  0x020

ULONG   ati_reg;        // Base register for ATI extended VGA registers
char    vga_chip;       // VGA chip revision as ascii

/*
 * Storage for register where EEPROM read/write happens.
 */
static union SplitWord zEepromIOPort;

/*
 * Storage for original status which is determined in Sel_EE() and
 * which must be restored in DeSel_EE().
 */
static union SplitWord zOrigStat;

/*
 * EEPROM word to be read/written/erased/etc.
 */
static unsigned char ucEepromWord;

static void setscrn(int iSetting);
static unsigned short Read_ee(void);
static void ee_sel_vga(void);
static void ee_clock_vga(void);
static void EE_control(unsigned char ucEepromStatus);
static void ee_deselect_vga(void);
static void Write_ee(unsigned short uiData);
static void Enabl_ee(void);
static void Disab_ee(void);
static void Erase_ee(void);

extern void ee_wait(void);


/*
 * Allow miniport to be swapped out when not needed.
 *
 * The following routines are called through function pointers
 * rather than an explicit call to the routine, and may run into
 * trouble if paged out. If problems develop, make them un-pageable:
 * ee_read_vga()
 * ee_cmd_vga()
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_M, ee_read_vga)
#pragma alloc_text(PAGE_M, ee_write_vga)
#pragma alloc_text(PAGE_M, ee_erase_vga)
#pragma alloc_text(PAGE_M, ee_enab_vga)
#pragma alloc_text(PAGE_M, ee_disab_vga)
#pragma alloc_text(PAGE_M, setscrn)
#pragma alloc_text(PAGE_M, Read_ee)
#pragma alloc_text(PAGE_M, ee_sel_vga)
#pragma alloc_text(PAGE_M, ee_cmd_vga)
#pragma alloc_text(PAGE_M, ee_sel_eeprom)
#pragma alloc_text(PAGE_M, ee_clock_vga)
#pragma alloc_text(PAGE_M, EE_control)
#pragma alloc_text(PAGE_M, ee_deselect_vga)
#pragma alloc_text(PAGE_M, Write_ee)
#pragma alloc_text(PAGE_M, Enabl_ee)
#pragma alloc_text(PAGE_M, Disab_ee)
#pragma alloc_text(PAGE_M, Erase_ee)
#endif


/*
 * WORD ee_read_vga(iIndex);
 *
 * short iIndex;                    Which word of EEPROM should be read
 *
 * Read the specified word from the EEPROM.
 */
WORD ee_read_vga(short iIndex)
{
    unsigned short uiRetVal;    /* Value returned by Read_ee() */

    setscrn(OFF);           /* Disable the video card */

    /*
     * Set up the word index within the EEPROM and the chip identifier.
     */
    ucEepromWord = iIndex & 0x00ff;

    uiRetVal = Read_ee();           /* Get the word */

    setscrn(ON);            /* Re-enable the video card */

    return uiRetVal;
}



/*
 * void ee_write_vga(uiIndex, uiData);
 *
 * unsigned short uiIndex;
 * unsigned short uiData;
 *
 * Routine to write a word to the EEPROM.
 */
void ee_write_vga(unsigned short uiIndex, unsigned short uiData)
{
    setscrn(OFF);
    ucEepromWord = uiIndex & 0x00ff;
    Write_ee(uiData);

    ee_wait();
    setscrn(ON);

    return;
}



/*
 * void ee_erase_vga(uiIndex);
 *
 * unsigned short uiIndex;
 *
 * Routine to erase a word in the EEPROM.
 */
void ee_erase_vga(unsigned short uiIndex)
{
    setscrn(OFF);
    ucEepromWord = uiIndex & 0x00ff;
    Erase_ee();
    setscrn(ON);

    ee_wait();
    return;
}



/*
 * void ee_enab_vga(void);
 *
 * Routine to enable the EEPROM.
 */
void ee_enab_vga()
{
    setscrn(OFF);
    Enabl_ee();
    setscrn(ON);
    return;
}



/*
 * void ee_disab_vga(void);
 *
 * Routine to disable the EEPROM.
 */
void ee_disab_vga(void)
{
    setscrn(OFF);
    Disab_ee();
    setscrn(ON);

    ee_wait();
    return;
}



/*
 * static void setscrn(iSetting);
 *
 * int iSetting;    Should the video card be enabled (ON) or disabled (OFF)
 *
 * Enable or disable the video card, as selected by the caller.
 */
static void setscrn(int iSetting)
{
    static unsigned char ucSavedMode;   /* Saved value of clock mode register */


    if (iSetting)
        {
        /*
         * Caller wants to unblank the screen.
         *
         * Point the sequencer index register to the clock mode register.
         */
        OUTP(SEQ_IND, SD_CLOCK);

        /*
         * Set the clock mode register to the value it had before we
         * blanked the screen.
         */
        OUTP(SEQ_DATA, ucSavedMode);
        }

    else{
        /*
         * Caller wants to blank the screen.
         *
         * Point the sequencer index register to the clock mode register.
         */
        OUTP(SEQ_IND, SD_CLOCK);

        /*
         * Read and save the current contents of the clock mode register.
         */
        ucSavedMode = INP(SEQ_DATA);

        /*
         * Blank the screen without changing the other contents
         * of the clock mode register.
         */
        OUTP(SEQ_DATA, (BYTE)(ucSavedMode | SD_CLK_OFF));
        }

    return;
}



/*
 * static unsigned short Read_ee(void);
 *
 * A lower-level way of getting a word out of the EEPROM.
 */
static unsigned short Read_ee(void)
{
    int iCount;                         /* Loop counter */
    unsigned short uiValueRead = 0;     /* Value read from the EEPROM */
    union SplitWord zStateSet;          /* Used in setting the video state */

    ee_sel_vga();
    if (vga_chip >= '4')    /* ASIC revision level */
        {
        /*
         * Set read/write bit of ATI register 26 to read.
         */
        zStateSet.byte.low = 0x0a6;
        OUTP(ati_reg, zStateSet.byte.low);
        zStateSet.byte.high = INP(ati_reg+1);
        OUTPW(ati_reg, (WORD)((zStateSet.word & 0x0FBFF)));
        }

    ee_cmd_vga((unsigned short) (EE_READ | ucEepromWord));
    zEepromIOPort.byte.high &= (~EE_DI);
    OUTPW(ati_reg, zEepromIOPort.word);
    ee_clock_vga();

    /*
     * Read in the word, one bit at a time.
     */
    for (iCount = 0; iCount < 16; iCount++)
        {
        uiValueRead = uiValueRead << 1;
        OUTP(ati_reg, EE_RREG);
        if (INP(ati_reg+1) & EE_DO)
            uiValueRead |= 1;
        ee_clock_vga();
        }

    ee_deselect_vga();

    /*
     * Undo the state setting which was done on entry.
     */
    if (vga_chip >= '4')
	OUTPW(ati_reg, zStateSet.word);

    return uiValueRead;
}




/*
 * static void ee_sel_vga(void);
 *
 * This routine selects the EEPROM.
 */
static void ee_sel_vga(void)
{

    if (vga_chip <= '2')
        {
        /*
         * Get the video card's status.
         */
        VideoPortSynchronizeExecution(phwDeviceExtension,
                                      VpHighPriority,
                                      (PMINIPORT_SYNCHRONIZE_ROUTINE)
                                          ee_sel_eeprom,
                                      phwDeviceExtension);

        OUTPW(HI_SEQ_ADDR, 0x0100);
        }
    else{
        EE_control(EEPROM);
        }

    return;
}



/*
 * void ee_cmd_vga(uiInstruct);
 *
 * unsigned short uiInstruct;   Opcode and address to send
 *
 * Sends EEPROM opcode and address to the EEPROM. The uiInstruct
 * parameter holds the 5 bit opcode and 6 bit index in the
 * format xxxx xOOO OOII IIII, where:
 * x is an unused bit
 * O is an opcode bit
 * I is an index bit
 */
void ee_cmd_vga(unsigned short uiInstruct)
{
    struct st_eeprom_data *ee = phwDeviceExtension->ee;

    int iCount;     /* Loop counter */
    /*
     * Mask showing which bit to test when sending the opcode or the address.
     */
    unsigned short uiBitTest;

    /*
     * Get the initial value for the I/O register which
     * will have its bits forced to specific values.
     */
    VideoPortSynchronizeExecution(phwDeviceExtension,
                                  VpHighPriority,
                                  (PMINIPORT_SYNCHRONIZE_ROUTINE) ee_init_io,
                                  phwDeviceExtension);

    ee_clock_vga();
    zEepromIOPort.byte.high &= (~EE_DI);
    zEepromIOPort.byte.high |= (EE_ENABLE | EE_CS); /* Enable the EEPROM and select the chip */
    OUTPW(ati_reg, zEepromIOPort.word);

    ee_clock_vga();

    /*
     * Send the opcode.
     */
    uiBitTest = 0x400;
    for (iCount = 0; iCount < 3; iCount++)
        {
        if (uiInstruct & uiBitTest)
            zEepromIOPort.byte.high |= EE_DI;
        else
            zEepromIOPort.byte.high &= (~EE_DI);
        OUTPW(ati_reg, zEepromIOPort.word);
        ee_clock_vga();
        uiBitTest >>= 1;
        }


    /*
     * We have finished with the opcode, now send the address.
     * Assume the EEPROM address is no longer than 8 bits
     * (256 word capacity). The Graphics Ultra series use
     * a 6 bit address (64 words), while the G.U. Plus and
     * Pro use 8 bits (but the EEPROM is only 128 words long).
     * Assume a 6 bit EEPROM address (64 word capacity).
     */
    uiBitTest = 0x01 << (ee->addr_size - 1);
    for (iCount = 0; iCount < ee->addr_size; iCount++)
        {
        if (uiBitTest & uiInstruct)
            zEepromIOPort.byte.high |= EE_DI;
        else
            zEepromIOPort.byte.high &= (~EE_DI);
        OUTPW(ati_reg, zEepromIOPort.word);
        ee_clock_vga();
        uiBitTest >>= 1;
        }

    return;
}


BOOLEAN
ee_sel_eeprom (
    PVOID Context
    )

/*++

Routine Description:

    Selects the eeprom within the context of interrupts being disabled.

    This function must be called via a call to VideoPortSynchronizeRoutine.

Arguments:

    Context - Context parameter passed to the synchronized routine.
        Must be a pointer to the miniport driver's device extension.

Return Value:

    TRUE.

--*/

{
    union SplitWord zStatus;    /* Status of the video card. */
	UNREFERENCED_PARAMETER(Context);


    OUTP(ati_reg, SYNC_I);
    zStatus.byte.high = INP(ati_reg + 1);
    zStatus.byte.low = SYNC_I;

    /*
     * Preserve the status so ee_deselect_vga() can restore it.
     */
    zOrigStat.word = zStatus.word;

    /*
     * Unlock the EEPROM to allow reading/writing.
     */
    zStatus.byte.high &= ~L_ALL;
    OUTPW(ati_reg, zStatus.word);
    return TRUE;
}

BOOLEAN
ee_init_io (
    PVOID Context
    )

/*++

Routine Description:


    Gets the initial value for the I/O register which
    will have its bits forced to specific values.

    This function must be called via a call to VideoPortSynchronizeRoutine.

Arguments:

    Context - Context parameter passed to the synchronized routine.
        Must be a pointer to the miniport driver's device extension.

Return Value:

    TRUE.

--*/

{
	UNREFERENCED_PARAMETER(Context);

    zEepromIOPort.byte.low = EE_WREG;
    OUTP(ati_reg, zEepromIOPort.byte.low);
    zEepromIOPort.byte.high = INP(ati_reg + 1);
    return TRUE;
}



/*
 * static void ee_clock_vga(void);
 *
 * Toggle the EEPROM CLK line high then low.
 */
static void ee_clock_vga(void)
{
    ee_wait();

    zEepromIOPort.byte.high |= EE_CLK;
    OUTPW(ati_reg, zEepromIOPort.word);

    ee_wait();

    zEepromIOPort.byte.high &= ~EE_CLK;
    OUTPW(ati_reg, zEepromIOPort.word);

    return;
}



/*
 * static void EE_control(ucEepromStatus);
 *
 * unsigned char ucEepromStatus;    Sets whether or not we should access the EEPROM
 *
 * Sets/resets the EEPROM bit of the data register at index MISC3_I.
 * This enables/disables EEPROM access.
 */
static void EE_control(unsigned char ucEepromStatus)
{
    union SplitWord zCtrlData;  /* Data read/written at specified control port */


    /*
     * Set up to write to the MISC3_I index register, and initialize
     * the data field to the EEPROM status we want.
     */
    zCtrlData.byte.high = ucEepromStatus;
    zCtrlData.byte.low = MISC3_I;
    OUTP(ati_reg, zCtrlData.byte.low);

    /*
     * Read in the data which is stored at the index MISC3_I, and combine
     * its contents (other than the EEPROM enable/disable bit)
     * with the desired EEPROM status we received as a parameter.
     */
    zCtrlData.byte.high |= (INP(ati_reg + 1) & ~EEPROM);

    /*
     * Write the result back. All bits other than the EEPROM enable/disable
     * bit will be unmodified.
     */
    OUTPW(ati_reg, zCtrlData.word);

    return;
}



/*
 * static void ee_deselect_vga(void);
 *
 * Purpose: Disable EEPROM read/write
 */
static void ee_deselect_vga(void)
{
    zEepromIOPort.byte.high &= (~EE_CS);
    OUTPW(ati_reg, zEepromIOPort.word);
    ee_clock_vga();
    zEepromIOPort.byte.high &= (~EE_ENABLE);
    OUTPW(ati_reg, zEepromIOPort.word);

    if (vga_chip <= '2')
        {
        OUTPW(HI_SEQ_ADDR, 0x0300);
        OUTPW(ati_reg, zOrigStat.word);
        }
    else{
        EE_control(0);
        }

    ee_wait();
    return;
}



/*
 * static void Write_ee(uiData);
 *
 * unsigned short uiData;       Value to write to the EEPROM.
 *
 * Lower-level routine to write a word to the EEPROM.
 */
static void Write_ee(unsigned short uiData)
{
    int iCount;                 /* Loop counter */

    ee_sel_vga();

    ee_cmd_vga((unsigned short) (EE_WRITE | ucEepromWord));

    /*
     * Write out the word, one bit at a time.
     */
    for (iCount = 0; iCount < 16; iCount++)
        {
        if (uiData & 0x8000)
            zEepromIOPort.byte.high |= EE_DI;
        else
            zEepromIOPort.byte.high &= (~EE_DI);
        OUTPW(ati_reg, zEepromIOPort.word);

        ee_clock_vga();
        uiData = uiData << 1;
        }

    ee_deselect_vga();

    return;
}



/*
 * Static void Enabl_ee(void);
 *
 * This is a lower-level routine to enable the EEPROM.
 */
static void Enabl_ee()
{

    ee_sel_vga();

    ee_cmd_vga((EE_ENAB | 0x3f));

    ee_deselect_vga();

    return;
}



/*
 * Static void Disab_ee(void);
 *
 * This is a lower-level routine to disable the EEPROM.
 */
static void Disab_ee(void)
{

    ee_sel_vga();

    ee_cmd_vga((EE_DISAB | 0x00));

    ee_deselect_vga();

    return;
}



/*
 * Static void Erase_ee(void);
 *
 * This is a lower-level routine to erase the EEPROM.
 */
static void Erase_ee(void)
{

    ee_sel_vga();

    ee_cmd_vga((unsigned short) (EE_ERASE | ucEepromWord));

    ee_deselect_vga();

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\init_cx.c ===
/************************************************************************/
/*                                                                      */
/*                              INIT_CX.C                               */
/*                                                                      */
/*        Nov 15  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities

  $Revision:   1.42  $
      $Date:   15 May 1996 16:34:38  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/init_cx.c_v  $
 *
 *    Rev 1.42   15 May 1996 16:34:38   RWolff
 * Now reports failure of mode set, waits for idle after setting
 * accelerator mode.
 *
 *    Rev 1.41   01 May 1996 14:09:20   RWolff
 * Calls new routine DenseOnAlpha() to determine dense space support rather
 * than assuming all PCI cards support dense space.
 *
 *    Rev 1.40   17 Apr 1996 13:09:04   RWolff
 * Backed out Alpha LFB mapping as dense.
 *
 *    Rev 1.39   11 Apr 1996 15:13:20   RWolff
 * Now maps framebuffer as dense on DEC Alpha with PCI graphics card.
 *
 *    Rev 1.38   20 Mar 1996 13:42:32   RWolff
 * Removed debug print statements from RestoreMemSize_cx(), which must
 * be nonpageable since it is called from ATIMPResetHw().
 *
 *    Rev 1.37   01 Mar 1996 12:11:50   RWolff
 * VGA Graphics Index and Graphics Data are now handled as separate
 * registers rather than as offsets into the block of VGA registers.
 *
 *    Rev 1.36   02 Feb 1996 17:16:40   RWolff
 * Now uses VideoPortInt10() rather than our no-BIOS code to set "canned"
 * modes on VGA-disabled cards.
 *
 *    Rev 1.35   29 Jan 1996 16:55:02   RWolff
 * Now uses VideoPortInt10() rather than no-BIOS code on PPC.
 *
 *    Rev 1.34   23 Jan 1996 11:46:22   RWolff
 * Added debug print statements.
 *
 *    Rev 1.33   22 Dec 1995 14:53:30   RWolff
 * Added support for Mach 64 GT internal DAC.
 *
 *    Rev 1.32   23 Nov 1995 11:27:46   RWolff
 * Fixes needed for initial run of VT chips (check if they're still needed
 * on the final version), added support for multiple block-relocatable
 * Mach 64 cards.
 *
 *    Rev 1.31   28 Jul 1995 14:40:58   RWolff
 * Added support for the Mach 64 VT (CT equivalent with video overlay).
 *
 *    Rev 1.30   23 Jun 1995 16:01:46   RWOLFF
 * In 8BPP and lower modes, SetPalette_cx() now uses the VGA palette
 * registers rather than the accelerator palette registers. This is
 * done so that a video capture card attached to the feature connector
 * will know what colours the palette is set to.
 *
 *    Rev 1.29   02 Jun 1995 14:26:48   RWOLFF
 * Added debug print statements.
 *
 *    Rev 1.28   31 Mar 1995 11:57:12   RWOLFF
 * Changed from all-or-nothing debug print statements to thresholds
 * depending on importance of the message.
 *
 *    Rev 1.27   08 Mar 1995 11:33:54   ASHANMUG
 * Fixed a bug if the banked aperture was enabled, the memory mapped register we
 * getting moved if the memory sized was changed to support 4bpp
 *
 *    Rev 1.26   27 Feb 1995 17:48:08   RWOLFF
 * Now always reports 1M when mapping video memory for 4BPP, since we
 * force the card to 1M, QueryPublicAccessRanges_cx() now returns
 * the virtual address of the I/O register base rather than the
 * beginning of I/O space.
 *
 *    Rev 1.25   20 Feb 1995 18:01:18   RWOLFF
 * Made test and workaround for screen tearing on 2M boundary DAC-independant,
 * 1600x1200 16BPP added to modes that have this tearing.
 *
 *    Rev 1.24   14 Feb 1995 15:45:36   RWOLFF
 * Changed conditional compile that uses or fakes failure of
 * VideoPortMapBankedMemory() to look for IOCTL_VIDEO_SHARE_VIDEO_MEMORY
 * instead of the routine itself. Looking for the routine always failed,
 * and since the routine is supplied in order to allow DCI to be used
 * on systems without a linear framebuffer, it should be available on
 * any DDK version that supports the IOCTL. If it isn't, a compile-time
 * error will be generated (unresolved external reference).
 *
 *    Rev 1.23   09 Feb 1995 14:57:36   RWOLFF
 * Fix for GX-E IBM DAC screen tearing in 800x600 8BPP.
 *
 *    Rev 1.22   07 Feb 1995 18:24:22   RWOLFF
 * Fixed screen trash on return from 4BPP test on CT and 4M Xpression.
 * These were the first cards I was able to obtain that switched aperture
 * size between modes (GX uses 8M aperture only on 4M cards, which used
 * to be made only with DAC that didn't support 4BPP, but CT uses 8M for
 * 2M card and 4M when cut back to 1M).
 *
 *    Rev 1.21   03 Feb 1995 15:15:12   RWOLFF
 * Added support for DCI, fixed CT internal DAC 4BPP cursor problem,
 * RestoreMemSize_cx() is no longer pageable, since it is called
 * on a bugcheck.
 *
 *    Rev 1.20   30 Jan 1995 11:56:24   RWOLFF
 * Now supports CT internal DAC.
 *
 *    Rev 1.19   11 Jan 1995 14:04:04   RWOLFF
 * Added routine RestoreMemSize_cx() which sets the memory size register
 * back to the value read by the BIOS query. This is used when returning
 * from a test of 4BPP (code had been inlined there) or when shutting down
 * from 4BPP (new) because 4BPP modes require that the memory size be
 * set to 1M. On some platforms, the x86 emulation in the firmware does not
 * reset the memory size to the true value, so a warm reboot from 4BPP left
 * the card thinking that it only had 1M.
 *
 *    Rev 1.18   23 Dec 1994 10:47:48   ASHANMUG
 * ALPHA/Chrontel-DAC
 *
 *    Rev 1.17   18 Nov 1994 11:40:00   RWOLFF
 * Added support for Mach 64 without BIOS.
 *
 *    Rev 1.16   14 Sep 1994 15:24:38   RWOLFF
 * Now uses "most desirable supported colour ordering" field in query
 * structure rather than DAC type to determine which colour ordering
 * to use for 24 and 32BPP.
 *
 *    Rev 1.15   31 Aug 1994 16:24:02   RWOLFF
 * Added support for TVP3026 DAC, 1152x864, and BGRx colour ordering
 * (used by TVP DAC), uses VideoPort[Read|Write]Register[Uchar|Ushort|Ulong]()
 * instead of direct assignments when accessing structures stored in
 * VGA text screen off-screen memory.
 *
 *    Rev 1.14   19 Aug 1994 17:15:32   RWOLFF
 * Added support for non-standard pixel clock generators.
 *
 *    Rev 1.13   09 Aug 1994 11:52:30   RWOLFF
 * Shifting of colours when setting up palette is now done in
 * display driver.
 *
 *    Rev 1.12   27 Jun 1994 16:27:38   RWOLFF
 * Now reports all hardware default mode tables as noninterlaced to
 * avoid confusing the display applet.
 *
 *    Rev 1.11   15 Jun 1994 11:06:24   RWOLFF
 * Now sets the cursor colour every time we enter graphics mode. This is a
 * fix for the black cursor after testing 4BPP from 16BPP.
 *
 *    Rev 1.10   12 May 1994 11:22:40   RWOLFF
 * Added routine SetModeFromTable_cx() to allow the use of refresh rates not
 * configured when card was installed, now reports refresh rate from mode table
 * instead of only "use hardware default".
 *
 *    Rev 1.9   04 May 1994 10:59:12   RWOLFF
 * Now forces memory size to 1M on all 4BPP-capable DACs when using 4BPP,
 * sets memory size back to true value when not using 4BPP.
 *
 *    Rev 1.8   27 Apr 1994 13:59:38   RWOLFF
 * Added support for paged aperture, fixed cursor colour for 4BPP.
 *
 *    Rev 1.7   26 Apr 1994 12:38:32   RWOLFF
 * Now uses a frame length of 128k when LFB is disabled.
 *
 *    Rev 1.6   31 Mar 1994 15:02:42   RWOLFF
 * Added SetPowerManagement_cx() function to implement DPMS handling,
 * added 4BPP support.
 *
 *    Rev 1.5   14 Mar 1994 16:30:58   RWOLFF
 * XMillimeter field of mode information structure now set properly, added
 * fix for 2M boundary tearing.
 *
 *    Rev 1.4   03 Mar 1994 12:37:32   ASHANMUG
 * Set palettized mode
 *
 *    Rev 1.2   03 Feb 1994 16:44:26   RWOLFF
 * Fixed "ceiling check" on right scissor register (documentation had
 * maximum value wrong). Moved initialization of hardware cursor
 * colours to after the switch into graphics mode. Colour initialization
 * is ignored if it is done before the mode switch (undocumented), but
 * this wasn't noticed earlier because most cards power up with the
 * colours already set to the values we want.
 *
 *    Rev 1.1   31 Jan 1994 16:24:38   RWOLFF
 * Fixed setting of cursor colours on cards with 68860 DAC, now fills
 * in Frequency and VideoMemoryBitmap[Width|Height] fields of mode
 * information structure. Sets Number[Red|Green|Blue]Bits fields for
 * palette modes to 6 (assumes VGA-compatible DAC) instead of 0 to allow
 * Windows NT to set the palette colours to the best match for the
 * colours to be displayed.
 *
 *    Rev 1.0   31 Jan 1994 11:10:18   RWOLFF
 * Initial revision.
 *
 *    Rev 1.3   24 Jan 1994 18:03:52   RWOLFF
 * Changes to accomodate 94/01/19 BIOS document.
 *
 *    Rev 1.2   14 Jan 1994 15:20:48   RWOLFF
 * Fixes required by BIOS version 0.13, added 1600x1200 support.
 *
 *    Rev 1.1   15 Dec 1993 15:26:30   RWOLFF
 * Clear screen only the first time we set the desired video mode.
 *
 *    Rev 1.0   30 Nov 1993 18:32:22   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
INIT_CX.C - Highest-level card-dependent routines for miniport.

DESCRIPTION
    This file contains initialization and packet handling routines
    for Mach 64-compatible ATI accelerators. Routines in this module
    are called only by routines in ATIMP.C, which is card-independent.

OTHER FILES

#endif

#include "dderror.h"

#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"
#include "amachcx.h"
#include "amach1.h"
#include "atimp.h"
#include "atint.h"

#define INCLUDE_INIT_CX
#include "init_cx.h"
#include "query_cx.h"
#include "services.h"
#include "setup_cx.h"



/*
 * Prototypes for static functions.
 */
static void QuerySingleMode_cx(PVIDEO_MODE_INFORMATION ModeInformation, struct query_structure *QueryPtr, ULONG ModeIndex);
static VP_STATUS SetModeFromTable_cx(struct st_mode_table *ModeTable, VIDEO_X86_BIOS_ARGUMENTS Registers);


/*
 * Allow miniport to be swapped out when not needed.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_CX, Initialize_cx)
#pragma alloc_text(PAGE_CX, MapVideoMemory_cx)
#pragma alloc_text(PAGE_CX, QueryPublicAccessRanges_cx)
#pragma alloc_text(PAGE_CX, QueryCurrentMode_cx)
#pragma alloc_text(PAGE_CX, QueryAvailModes_cx)
#pragma alloc_text(PAGE_CX, QuerySingleMode_cx)
#pragma alloc_text(PAGE_CX, SetCurrentMode_cx)
#pragma alloc_text(PAGE_CX, SetPalette_cx)
#pragma alloc_text(PAGE_CX, IdentityMapPalette_cx)
#pragma alloc_text(PAGE_CX, ResetDevice_cx)
#pragma alloc_text(PAGE_CX, SetPowerManagement_cx)
#pragma alloc_text(PAGE_CX, GetPowerManagement_cx)
#pragma alloc_text(PAGE_CX, SetModeFromTable_cx)
/* RestoreMemSize_cx() can't be made pageable */
#pragma alloc_text(PAGE_CX, ShareVideoMemory_cx)
/* BankMap_cx() can't be made pageable */
#endif

/***************************************************************************
 *
 * void Initialize_cx(void);
 *
 * DESCRIPTION:
 *  This routine is the Mach 64-compatible hardware initialization routine
 *  for the miniport driver. It is called once an adapter has been found
 *  and all the required data structures for it have been created.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  ATIMPInitialize()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void Initialize_cx(void)
{
    DWORD Scratch;                      /* Temporary variable */
    VIDEO_X86_BIOS_ARGUMENTS Registers; /* Used in VideoPortInt10() calls */
    struct query_structure *Query;      /* Information about the graphics card */

    Query = (struct query_structure *) (phwDeviceExtension->CardInfo);
    /*
     * If the linear aperture is not configured, enable the VGA aperture.
     */
    if (phwDeviceExtension->FrameLength == 0)
        {
        VideoDebugPrint((DEBUG_DETAIL, "Initialize_cx() switching to VGA aperture\n"));
        VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
        Registers.Eax = BIOS_APERTURE;
        Registers.Ecx = BIOS_VGA_APERTURE;
        VideoPortInt10(phwDeviceExtension, &Registers);
        }

    /*
     * Set the screen to start at the beginning of accelerator memory.
     */
    Scratch = INPD(CRTC_OFF_PITCH) & ~CRTC_OFF_PITCH_Offset;
    OUTPD(CRTC_OFF_PITCH, Scratch);

    /*
     * Disable the hardware cursor and set it up with the bitmap
     * starting at the top left corner of the 64x64 block.
     */
    Scratch = INPD(GEN_TEST_CNTL) & ~GEN_TEST_CNTL_CursorEna;
    OUTPD(GEN_TEST_CNTL, Scratch);
    OUTPD(CUR_HORZ_VERT_OFF, 0x00000000);

    /*
     * TVP3026 DAC requires special handling to disable
     * the cursor.
     */
    if (Query->q_DAC_type == DAC_TVP3026)
        {
        /*
         * Access the indirect cursor control register.
         */
        OUTP(DAC_CNTL, (BYTE)(INP(DAC_CNTL) & 0xFC));
        OUTP(DAC_REGS, 6);
        /*
         * Write the "cursor disabled" value to the
         * indexed data register.
         */
        OUTP(DAC_CNTL, (BYTE)((INP(DAC_CNTL) & 0xFC) | 2));
        OUTP_HBLW(DAC_REGS, 0);
        /*
         * Go back to using direct registers.
         */
        OUTP(DAC_CNTL, (BYTE)(INP(DAC_CNTL) & 0xFC));
        }

    VideoDebugPrint((DEBUG_NORMAL, "Initialize_cx() complete\n"));

    return;

}   /* Initialize_cx() */



/**************************************************************************
 *
 * VP_STATUS MapVideoMemory_cx(RequestPacket, QueryPtr);
 *
 * PVIDEO_REQUEST_PACKET RequestPacket; Request packet with input and output buffers
 * struct query_structure *QueryPtr;    Query information for the card
 *
 * DESCRIPTION:
 *  Map the card's video memory into system memory and store the mapped
 *  address and size in OutputBuffer.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if failed
 *
 * GLOBALS CHANGED:
 *  FrameLength and PhysicalFrameAddress fields of phwDeviceExtension
 *  if linear framebuffer is not present.
 *
 * CALLED BY:
 *  IOCTL_VIDEO_MAP_VIDEO_MEMORY packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS MapVideoMemory_cx(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr)
{
    PVIDEO_MEMORY_INFORMATION memoryInformation;
    ULONG inIoSpace;        /* Scratch variable used by VideoPortMapMemory() */
    VP_STATUS status;       /* Error code obtained from O/S calls */
    UCHAR Scratch;          /* Temporary variable */
    ULONG FrameBufferLengthSave;


    memoryInformation = RequestPacket->OutputBuffer;

    memoryInformation->VideoRamBase = ((PVIDEO_MEMORY)
        (RequestPacket->InputBuffer))->RequestedVirtualAddress;

    /*
     * The VideoRamLength field contains the amount of video memory
     * on the card. The FrameBufferLength field contains the
     * size of the aperture in bytes
     *
     * Initially assume that the linear aperture is available.
     *
     * In 4BPP, we always force the card to think it has 1M of memory.
     */
    if (QueryPtr->q_pix_depth == 4)
        memoryInformation->VideoRamLength = ONE_MEG;
    else
        memoryInformation->VideoRamLength = phwDeviceExtension->VideoRamSize;

    Scratch = QueryPtr->q_aperture_cfg & CONFIG_CNTL_LinApMask;

    if (Scratch == CONFIG_CNTL_LinAp4M)
        {
        memoryInformation->FrameBufferLength = 4 * ONE_MEG;
        }
    else if (Scratch == CONFIG_CNTL_LinAp8M)
        {
        memoryInformation->FrameBufferLength = 8 * ONE_MEG;
        }

    /*
     * If the linear aperture is not available, map in the VGA aperture
     * instead. Since the Mach 64 needs an aperture in order to use
     * the drawing registers, ATIMPFindAdapter() will have already
     * reported that it couldn't find a usable card if both the linear
     * and VGA apertures are disabled.
     */
    else if (Scratch == CONFIG_CNTL_LinApDisab)
        {
        phwDeviceExtension->FrameLength = 0x20000;
        phwDeviceExtension->PhysicalFrameAddress.LowPart = 0x0A0000;
        memoryInformation->FrameBufferLength = phwDeviceExtension->FrameLength;
        }
    inIoSpace = 0;
#if defined(ALPHA)
    /*
     * Use dense space if we can, otherwise use sparse space.
     */
    if (DenseOnAlpha(QueryPtr) == TRUE)
        {
        VideoDebugPrint((DEBUG_DETAIL, "Using dense space for LFB\n"));
        inIoSpace = 4;
        }
#endif

    FrameBufferLengthSave = memoryInformation->FrameBufferLength;

    status = VideoPortMapMemory(phwDeviceExtension,
                    	        phwDeviceExtension->PhysicalFrameAddress,
                                &(memoryInformation->FrameBufferLength),
                                &inIoSpace,
                                &(memoryInformation->VideoRamBase));

#if defined (ALPHA)
    /*
     * VideoPortMapMemory() returns invalid FrameBufferLength
     * on the Alpha.
     */
    memoryInformation->FrameBufferLength = FrameBufferLengthSave;
#endif

    memoryInformation->FrameBufferBase    = memoryInformation->VideoRamBase;
    VideoDebugPrint((DEBUG_DETAIL, "Frame buffer mapped base = 0x%X\n", memoryInformation->VideoRamBase));

    /*
     * On some DAC/memory combinations, some modes which require more
     * than 2M of memory (1152x764 24BPP, 1280x1024 24BPP, and
     * 1600x1200 16BPP) will have screen tearing at the 2M boundary.
     *
     * As a workaround, the display driver must start the framebuffer
     * at an offset which will put the 2M boundary at the start of a
     * scanline.
     *
     * Other DAC/memory combinations are unaffected, but since this
     * fix is nearly harmless (only ill effect is to make DCI unusable
     * in these modes), we can catch all future combinations which
     * suffer from this problem by assuming that all DAC/memory
     * combinations are affected.
     */
    if ((QueryPtr->q_pix_depth == 24) &&
        (QueryPtr->q_desire_x == 1280))
        (PUCHAR)memoryInformation->FrameBufferBase += (0x40 * 8);
    else if ((QueryPtr->q_pix_depth == 24) &&
            (QueryPtr->q_desire_x == 1152))
        (PUCHAR)memoryInformation->FrameBufferBase += (0x160 * 8);
    else if ((QueryPtr->q_pix_depth == 16) &&
            (QueryPtr->q_desire_x == 1600))
        (PUCHAR)memoryInformation->FrameBufferBase += (0x90 * 8);

    return status;

}   /* MapVideoMemory_cx() */


/**************************************************************************
 *
 * VP_STATUS QueryPublicAccessRanges_cx(RequestPacket);
 *
 * PVIDEO_REQUEST_PACKET RequestPacket; Request packet with input and output buffers
 *
 * DESCRIPTION:
 *  Map and return information on the video card's public access ranges.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if failed
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS QueryPublicAccessRanges_cx(PVIDEO_REQUEST_PACKET RequestPacket)
{
    PVIDEO_PUBLIC_ACCESS_RANGES portAccess;
    PHYSICAL_ADDRESS physicalPortBase;
    ULONG physicalPortLength;

    if ( RequestPacket->OutputBufferLength <
        (RequestPacket->StatusBlock->Information =
        sizeof(VIDEO_PUBLIC_ACCESS_RANGES)) )
        {
        VideoDebugPrint((DEBUG_ERROR, "QueryPublicAccessRanges_cx() - buffer too small to handle query\n"));
        return ERROR_INSUFFICIENT_BUFFER;
        }

    portAccess = RequestPacket->OutputBuffer;
	
    portAccess->VirtualAddress  = (PVOID) NULL;    // Requested VA
    portAccess->InIoSpace       = 1;               // In IO space
    portAccess->MappedInIoSpace = portAccess->InIoSpace;

    physicalPortBase.HighPart   = 0x00000000;
    physicalPortBase.LowPart    = GetIOBase_cx();
//    physicalPortLength          = LINEDRAW+2 - physicalPortBase.LowPart;
    /*
     * If we are using packed (relocatable) I/O, all our I/O mapped
     * registers are in a 1k block. If not, they are sparsely distributed
     * in a 32k region.
     */
    if (IsPackedIO_cx())
        physicalPortLength = 0x400;
    else
        physicalPortLength = 0x8000;

// *SANITIZE* Should report MM registers instead

    return VideoPortMapMemory(phwDeviceExtension,
                              physicalPortBase,
                              &physicalPortLength,
                              &(portAccess->MappedInIoSpace),
                              &(portAccess->VirtualAddress));

}   /* QueryPublicAccessRanges_cx() */


/**************************************************************************
 *
 * VP_STATUS QueryCurrentMode_cx(RequestPacket, QueryPtr);
 *
 * PVIDEO_REQUEST_PACKET RequestPacket; Request packet with input and output buffers
 * struct query_structure *QueryPtr;    Query information for the card
 *
 * DESCRIPTION:
 *  Get screen information and colour masks for the current video mode.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if failed
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  IOCTL_VIDEO_QUERY_CURRENT_MODE packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS QueryCurrentMode_cx(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr)
{
    PVIDEO_MODE_INFORMATION ModeInformation;

    /*
     * If the output buffer is too small to hold the information we need
     * to put in it, return with the appropriate error code.
     */
    if (RequestPacket->OutputBufferLength <
        (RequestPacket->StatusBlock->Information =
        sizeof(VIDEO_MODE_INFORMATION)) )
        {
        VideoDebugPrint((DEBUG_ERROR, "QueryCurrentMode_cx() - buffer too small to handle query\n"));
        return ERROR_INSUFFICIENT_BUFFER;
        }

    /*
     * Fill in the mode information structure.
     */
    ModeInformation = RequestPacket->OutputBuffer;

    QuerySingleMode_cx(ModeInformation, QueryPtr, phwDeviceExtension->ModeIndex);

    return NO_ERROR;

}   /* QueryCurrentMode_cx() */


/**************************************************************************
 *
 * VP_STATUS QueryAvailModes_cx(RequestPacket, QueryPtr);
 *
 * PVIDEO_REQUEST_PACKET RequestPacket; Request packet with input and output buffers
 * struct query_structure *QueryPtr;    Query information for the card
 *
 * DESCRIPTION:
 *  Get screen information and colour masks for all available video modes.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if failed
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  IOCTL_VIDEO_QUERY_AVAIL_MODES packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS QueryAvailModes_cx(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr)
{
    PVIDEO_MODE_INFORMATION ModeInformation;
    ULONG CurrentMode;

    /*
     * If the output buffer is too small to hold the information we need
     * to put in it, return with the appropriate error code.
     */
    if (RequestPacket->OutputBufferLength <
        (RequestPacket->StatusBlock->Information =
        QueryPtr->q_number_modes * sizeof(VIDEO_MODE_INFORMATION)) )
        {
        VideoDebugPrint((DEBUG_ERROR, "QueryAvailModes_cx() - buffer too small to handle query\n"));
        return ERROR_INSUFFICIENT_BUFFER;
        }

    /*
     * Fill in the mode information structure.
     */
    ModeInformation = RequestPacket->OutputBuffer;

    /*
     * For each mode supported by the card, store the mode characteristics
     * in the output buffer.
     */
    for (CurrentMode = 0; CurrentMode < QueryPtr->q_number_modes; CurrentMode++, ModeInformation++)
        QuerySingleMode_cx(ModeInformation, QueryPtr, CurrentMode);

    return NO_ERROR;

}   /* QueryCurrentMode_cx() */



/**************************************************************************
 *
 * static void QuerySingleMode_cx(ModeInformation, QueryPtr, ModeIndex);
 *
 * PVIDEO_MODE_INFORMATION ModeInformation; Table to be filled in
 * struct query_structure *QueryPtr;        Query information for the card
 * ULONG ModeIndex;                         Index of mode table to use
 *
 * DESCRIPTION:
 *  Fill in a single Windows NT mode information table using data from
 *  one of our CRT parameter tables.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  QueryCurrentMode_cx() and QueryAvailModes_cx()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

static void QuerySingleMode_cx(PVIDEO_MODE_INFORMATION ModeInformation,
                              struct query_structure *QueryPtr,
                              ULONG ModeIndex)
{
    struct st_mode_table *CrtTable;     /* Pointer to current mode table */
    CrtTable = (struct st_mode_table *)QueryPtr;
    ((struct query_structure *)CrtTable)++;
    CrtTable += ModeIndex;


    ModeInformation->Length = sizeof(VIDEO_MODE_INFORMATION);
    ModeInformation->ModeIndex = ModeIndex;

    ModeInformation->VisScreenWidth  = CrtTable->m_x_size;
    ModeInformation->VisScreenHeight = CrtTable->m_y_size;

    // * Bytes per line = ((pixels/line) * (bits/pixel)) / (bits/byte))
    ModeInformation->ScreenStride = (CrtTable->m_screen_pitch * CrtTable->m_pixel_depth) / 8;

    ModeInformation->NumberOfPlanes = 1;
    ModeInformation->BitsPerPlane = (USHORT) CrtTable->m_pixel_depth;

    ModeInformation->Frequency = CrtTable->Refresh;

    /*
     * Driver can't measure the screen size,
     * so take reasonable values (16" diagonal).
     */
    ModeInformation->XMillimeter = 320;
    ModeInformation->YMillimeter = 240;

    switch(ModeInformation->BitsPerPlane)
        {
        case 4:
            /*
             * Assume 6 bit DAC, since all VGA-compatible DACs support
             * 6 bit mode. Future expansion (extensive testing needed):
             * check DAC definition to see if 8 bit mode is supported,
             * and use 8 bit mode if available.
             */
            ModeInformation->RedMask   = 0x00000000;
            ModeInformation->GreenMask = 0x00000000;
            ModeInformation->BlueMask  = 0x00000000;
            ModeInformation->NumberRedBits      = 6;
            ModeInformation->NumberGreenBits    = 6;
            ModeInformation->NumberBlueBits     = 6;
            CrtTable->ColourDepthInfo = BIOS_DEPTH_4BPP;
            break;

        case 16:
            /*
             * Assume that all DACs capable of 16BPP support 565.
             */
            ModeInformation->RedMask   = 0x0000f800;
            ModeInformation->GreenMask = 0x000007e0;
            ModeInformation->BlueMask  = 0x0000001f;
            ModeInformation->NumberRedBits      = 5;
            ModeInformation->NumberGreenBits    = 6;
            ModeInformation->NumberBlueBits     = 5;
            CrtTable->ColourDepthInfo = BIOS_DEPTH_16BPP_565;
            break;

        case 24:
            /*
             * Windows NT uses RGB as the standard 24BPP mode,
             * so use this ordering unless this card only
             * supports BGR.
             */
            if (QueryPtr->q_HiColourSupport & RGB24_RGB)
                {
                ModeInformation->RedMask   = 0x00ff0000;
                ModeInformation->GreenMask = 0x0000ff00;
                ModeInformation->BlueMask  = 0x000000ff;
                }
            else{
                ModeInformation->RedMask   = 0x000000ff;
                ModeInformation->GreenMask = 0x0000ff00;
                ModeInformation->BlueMask  = 0x00ff0000;
                }
            CrtTable->ColourDepthInfo = BIOS_DEPTH_24BPP;
            ModeInformation->NumberRedBits      = 8;
            ModeInformation->NumberGreenBits    = 8;
            ModeInformation->NumberBlueBits     = 8;
            break;

        case 32:
            /*
             * Windows NT uses RGBx as the standard 32BPP mode,
             * so use this ordering if it's available. If it
             * isn't, use the best available colour ordering.
             */
            if (QueryPtr->q_HiColourSupport & RGB32_RGBx)
                {
                ModeInformation->RedMask   = 0xff000000;
                ModeInformation->GreenMask = 0x00ff0000;
                ModeInformation->BlueMask  = 0x0000ff00;
                CrtTable->ColourDepthInfo = BIOS_DEPTH_32BPP_RGBx;
                }
            else if (QueryPtr->q_HiColourSupport & RGB32_xRGB)
                {
                ModeInformation->RedMask   = 0x00ff0000;
                ModeInformation->GreenMask = 0x0000ff00;
                ModeInformation->BlueMask  = 0x000000ff;
                CrtTable->ColourDepthInfo = BIOS_DEPTH_32BPP_xRGB;
                }
            else if (QueryPtr->q_HiColourSupport & RGB32_BGRx)
                {
                ModeInformation->RedMask   = 0x0000ff00;
                ModeInformation->GreenMask = 0x00ff0000;
                ModeInformation->BlueMask  = 0xff000000;
                CrtTable->ColourDepthInfo = BIOS_DEPTH_32BPP_BGRx;
                }
            else    /* if (QueryPtr->q_HiColourSupport & RGB32_xBGR) */
                {
                ModeInformation->RedMask   = 0x000000ff;
                ModeInformation->GreenMask = 0x0000ff00;
                ModeInformation->BlueMask  = 0x00ff0000;
                CrtTable->ColourDepthInfo = BIOS_DEPTH_32BPP_xBGR;
                }
            ModeInformation->NumberRedBits      = 8;
            ModeInformation->NumberGreenBits    = 8;
            ModeInformation->NumberBlueBits     = 8;
            break;

        case 8:
        default:
            /*
             * Assume 6 bit DAC, since all VGA-compatible DACs support
             * 6 bit mode. Future expansion (extensive testing needed):
             * check DAC definition to see if 8 bit mode is supported,
             * and use 8 bit mode if available.
             */
            ModeInformation->RedMask   = 0x00000000;
            ModeInformation->GreenMask = 0x00000000;
            ModeInformation->BlueMask  = 0x00000000;
            ModeInformation->NumberRedBits      = 6;
            ModeInformation->NumberGreenBits    = 6;
            ModeInformation->NumberBlueBits     = 6;
            CrtTable->ColourDepthInfo = BIOS_DEPTH_8BPP;
            break;
        }

    ModeInformation->AttributeFlags = VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS;

    if (CrtTable->m_pixel_depth <= 8)
        {
        ModeInformation->AttributeFlags |= VIDEO_MODE_PALETTE_DRIVEN |
            VIDEO_MODE_MANAGED_PALETTE;
        }

    /*
     * On "canned" mode tables,bit 4 of the m_disp_cntl field is set
     * for interlaced modes and cleared for noninterlaced modes.
     *
     * The display applet gets confused if some of the "Use hardware
     * default" modes are interlaced and some are noninterlaced
     * (two "Use hardware default" entries are shown in the refresh
     * rate list). To avoid this, report all mode tables stored in
     * the EEPROM as noninterlaced, even if they are interlaced.
     * "Canned" mode tables give true reports.
     *
     * If the display applet ever gets fixed, configured mode tables
     * have (CrtTable->control & (CRTC_GEN_CNTL_Interlace << 8)) nonzero
     * for interlaced and zero for noninterlaced.
     */
    if (CrtTable->Refresh == DEFAULT_REFRESH)
        {
        ModeInformation->AttributeFlags &= ~VIDEO_MODE_INTERLACED;
        }
    else
        {
        if (CrtTable->m_disp_cntl & 0x010)
            {
            ModeInformation->AttributeFlags |= VIDEO_MODE_INTERLACED;
            }
        else
            {
            ModeInformation->AttributeFlags &= ~VIDEO_MODE_INTERLACED;
            }
        }

    /*
     * Fill in the video memory bitmap width and height fields.
     * The descriptions are somewhat ambiguous - assume that
     * "bitmap width" is the same as ScreenStride (bytes from
     * start of one scanline to start of the next) and "bitmap
     * height" refers to the number of complete scanlines which
     * will fit into video memory.
     */
    ModeInformation->VideoMemoryBitmapWidth = ModeInformation->ScreenStride;
    ModeInformation->VideoMemoryBitmapHeight = (QueryPtr->q_memory_size * QUARTER_MEG) / ModeInformation->VideoMemoryBitmapWidth;

    return;

}   /* QuerySingleMode_m() */

VOID
EnableOldMach64MouseCursor(
    PHW_DEVICE_EXTENSION pHwDeviceExtension
    )
{
    ULONG   temp;

    VideoDebugPrint((1, "Enabling the cursor\n"));
    temp  = INPD(GEN_TEST_CNTL);
    temp |= GEN_TEST_CNTL_CursorEna;

    OUTPD(GEN_TEST_CNTL, temp);
}



/**************************************************************************
 *
 * VP_STATUS SetCurrentMode_cx(QueryPtr, CrtTable);
 *
 * struct query_structure *QueryPtr;    Query information for the card
 * struct st_mode_table *CrtTable;      CRT parameter table for desired mode
 *
 * DESCRIPTION:
 *  Switch into the specified video mode.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if failed
 *
 * NOTE:
 *  In the event of an error return by one of the services we call,
 *  there is no indication in our error return of which service failed,
 *  only the fact that one failed and the error code it returned. If
 *  a checked version of the miniport is being run under the kernel
 *  debugger, an indication will be printed to the debug terminal.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  IOCTL_VIDEO_SET_CURRENT_MODE packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *  96 05 15    Now checks return values from INT 10 calls.
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS SetCurrentMode_cx(struct query_structure *QueryPtr, struct st_mode_table *CrtTable)
{
    VIDEO_X86_BIOS_ARGUMENTS Registers; /* Used in VideoPortInt10() calls */
    ULONG WidthToClear;                 /* Screen width (in pixels) to clear */
    ULONG ScreenPitch;                  /* Pitch in units of 8 pixels */
    ULONG ScreenOffset = 0;             /* Byte offset - varies with display mode */
    ULONG PixelDepth;                   /* Colour depth of screen */
    ULONG HorScissors;                  /* Horizontal scissor values */
    ULONG Scratch;                      /* Temporary variable */
    int CursorProgOffset;               /* Offset of DAC register used to program the cursor */
    VP_STATUS RetVal;                   /* Value returned by routines called */

    /*
     * Early versions of the Mach 64 BIOS have a bug where not all registers
     * are set when initializing an accelerator mode. These registers are
     * set when going into the 640x480 8BPP VGAWonder mode.
     *
     * All VGA disabled cards were built after this bug was fixed, so
     * this mode switch is not necessary for them. On these cards, we
     * must not do the mode switch, since it will affect the VGA enabled
     * card rather than the card we are working on.
     */
    if (phwDeviceExtension->BiosPrefix == BIOS_PREFIX_VGA_ENAB)
        {
        VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
        Registers.Eax = 0x62;
        RetVal = VideoPortInt10(phwDeviceExtension, &Registers);
        if (RetVal != NO_ERROR)
            {
            VideoDebugPrint((DEBUG_ERROR, "SetCurrentMode_cx() failed SVGA mode set\n"));
            return RetVal;
            }
        }

    /*
     * Setting the linear aperture using the BIOS call will set
     * a 4M aperture on 2M and lower cards, and an 8M aperture
     * on 4M cards. Since we force the memory size to 1M in
     * 4BPP modes (workaround for a hardware bug), this can
     * result in writing to the wrong location for memory mapped
     * registers if we switch between 4BPP and other depths
     * (typically when testing a new mode) on a 4M card.
     *
     * To avoid this, set the memory size to its "honest" value
     * before enabling the linear aperture. If we need to cut
     * back to 1M, we will do this after the aperture is set.
     * This will result in the aperture always being the same
     * size, so the memory mapped registers will always be
     * in the same place.
     *
     * When using the VGA aperture, we must set the "honest" value
     * after enabling the aperture but before setting the mode.
     * Otherwise, the system will hang when testing a mode that
     * needs more than 1M of memory from a 4BPP mode.
     *
     * If the linear aperture is not configured, enable the VGA aperture.
     */
    if (QueryPtr->q_aperture_cfg != 0)
        {
        RestoreMemSize_cx();
        VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
        Registers.Eax = BIOS_APERTURE;
        Registers.Ecx = BIOS_LINEAR_APERTURE;
        RetVal = VideoPortInt10(phwDeviceExtension, &Registers);
        if (RetVal != NO_ERROR)
            {
            VideoDebugPrint((DEBUG_ERROR, "SetCurrentMode_cx() failed to enable linear aperture\n"));
            return RetVal;
            }
        }
    else
        {
        VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
        Registers.Eax = BIOS_APERTURE;
        Registers.Ecx = BIOS_VGA_APERTURE;
        RetVal = VideoPortInt10(phwDeviceExtension, &Registers);
        if (RetVal != NO_ERROR)
            {
            VideoDebugPrint((DEBUG_ERROR, "SetCurrentMode_cx() failed to enable VGA aperture\n"));
            return RetVal;
            }
        OUTP(VGA_GRAX_IND, 6);
        OUTP(VGA_GRAX_DATA, (BYTE)(INP(VGA_GRAX_DATA) & 0xF3));
        }

    /*
     * Now we can set the accelerator mode.
     */
    VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
    Registers.Eax = BIOS_LOAD_SET;

    /*
     * ECX register holds colour depth, gamma correction enable/disable
     * (not used in NT miniport), pitch size, and resolution.
     */
    Registers.Ecx = CrtTable->ColourDepthInfo;

    /*
     * Screen pitch differs from horizontal resolution only when using the
     * VGA aperture and horizontal resolution is less than 1024.
     */
    if ((CrtTable->m_screen_pitch == 1024) && (CrtTable->m_x_size < 1024))
        Registers.Ecx |= BIOS_PITCH_1024;
    else
        Registers.Ecx |= BIOS_PITCH_HOR_RES;

    /*
     * On the 68860 DAC and ?T internal DACs, we must enable gamma
     * correction for all pixel depths where the palette is not used.
     */
    if (((QueryPtr->q_DAC_type == DAC_ATI_68860) ||
        (QueryPtr->q_DAC_type == DAC_INTERNAL_CT) ||
        (QueryPtr->q_DAC_type == DAC_INTERNAL_GT) ||
        (QueryPtr->q_DAC_type == DAC_INTERNAL_VT)) &&
        (QueryPtr->q_pix_depth > 8))
        {
        Registers.Ecx |= BIOS_ENABLE_GAMMA;
        }
    /*
     * Fix 4bpp bugs by setting memory size to 1Meg. We do not
     * need to switch back to the "honest" memory size for
     * other pixel depths unless we are using the VGA aperture,
     * since this was done for linear apertures before we enabled
     * the aperture in order to ensure the same aperture size
     * (and therefore the same locations for memory mapped
     * registers) is used for all modes.
     */
    else if (QueryPtr->q_pix_depth == 4)
        {
        OUTPD(MEM_CNTL, (INPD(MEM_CNTL) & ~MEM_CNTL_MemSizeMsk) | MEM_CNTL_MemSize1Mb);
        }
    else if (QueryPtr->q_aperture_cfg == 0)
        {
        RestoreMemSize_cx();
        }

    switch(CrtTable->m_x_size)
        {
        case 640:
            Registers.Ecx |= BIOS_RES_640x480;
            break;

        case 800:
            Registers.Ecx |= BIOS_RES_800x600;
            break;

        case 1024:
            Registers.Ecx |= BIOS_RES_1024x768;
            break;

        case 1152:
            /*
             * Only "Other" mode that the config program will
             * install for production cards.
             */
            Registers.Ecx |= BIOS_RES_OEM;
            break;

        case 1280:
            Registers.Ecx |= BIOS_RES_1280x1024;
            break;

        case 1600:
            Registers.Ecx |= BIOS_RES_1600x1200;
            break;
        }

    if (CrtTable->Refresh == DEFAULT_REFRESH)
        {
        RetVal = VideoPortInt10(phwDeviceExtension, &Registers);
        if (RetVal != NO_ERROR)
            {
            VideoDebugPrint((DEBUG_ERROR, "SetCurrentMode_cx() failed mode set for default refresh\n"));
            return RetVal;
            }
        if (phwDeviceExtension->BiosPrefix != BIOS_PREFIX_VGA_ENAB)
            {
            VideoDebugPrint((DEBUG_DETAIL, "Have set hardware default refresh on VGA-disabled card\n"));
            /*
             * On VGA-disabled cards, the INT 10 call will leave the
             * DAC mask set to 0x00 (in palette modes, treat all pixels
             * as if they are colour 0, regardless of what colour they
             * really are). We must set it to 0xFF (in palette modes,
             * use all bits of the value written to each pixel) in order
             * to get the screen to display properly. This has no effect
             * on non-palette (16BPP and higher) modes.
             */
            OUTP_LBHW(DAC_REGS, 0xFF);  /* DAC_MASK */
            }
        }
    else
        {
        RetVal = SetModeFromTable_cx(CrtTable, Registers);
        if (RetVal != NO_ERROR)
            {
            VideoDebugPrint((DEBUG_ERROR, "SetCurrentMode_cx() failed call to SetModeFromTable_cx()\n"));
            return RetVal;
            }
        }

    /*
     * If the LFB is disabled, and we had to round up the pitch
     * to 2048 (1152x864, 1280x1024, or 1600x1200), set the pitch
     * registers manually, because there's no option in the
     * INT 10 call to set them to anything other than 1024 or the
     * screen width.
     */
    if (CrtTable->m_screen_pitch == 2048)
        {
        OUTPD(CRTC_OFF_PITCH, ((INPD(CRTC_OFF_PITCH) & 0x000FFFFF) | ((2048/8) << 22)));
        OUTPD(SRC_OFF_PITCH, ((INPD(SRC_OFF_PITCH) & 0x000FFFFF) | ((2048/8) << 22)));
        OUTPD(DST_OFF_PITCH, ((INPD(DST_OFF_PITCH) & 0x000FFFFF) | ((2048/8) << 22)));
        }
    /*
     * On 800x600, we must round the pitch up to a multiple of 64 to avoid
     * screen warping on some DACs. Set the pitch registers to correspond
     * to this.
     */
    else if (CrtTable->m_screen_pitch == 832)
        {
        OUTPD(CRTC_OFF_PITCH, ((INPD(CRTC_OFF_PITCH) & 0x000FFFFF) | ((832/8) << 22)));
        OUTPD(SRC_OFF_PITCH, ((INPD(SRC_OFF_PITCH) & 0x000FFFFF) | ((832/8) << 22)));
        OUTPD(DST_OFF_PITCH, ((INPD(DST_OFF_PITCH) & 0x000FFFFF) | ((832/8) << 22)));
        }


    /*
     * Set up the hardware cursor with colour 0 black and colour 1 white.
     * Do this here rather than in Initialize_cx() because the cursor
     * colours don't "take" unless we are in accelerator mode.
     *
     * On cards with 68860 DACs, the CUR_CLR0/1 registers don't set
     * the cursor colours. Instead, the colours must be set using the
     * DAC_CNTL and DAC_REGS registers. The cursor colour settings
     * are independent of pixel depth because the 68860 doesn't
     * support 4BPP, which is the only depth that requires a different
     * setting for the cursor colours.
     *
     * Cursor colour initialization is done unconditionally, rather than
     * only on the first graphics mode set, because otherwise testing a
     * different pixel depth (most commonly testing 1024x768 4BPP when
     * 1024x768 16BPP configured) may corrupt the cursor colours.
     */
    if ((QueryPtr->q_DAC_type == DAC_ATI_68860) ||
        (QueryPtr->q_DAC_type == DAC_TVP3026) ||
        (QueryPtr->q_DAC_type == DAC_IBM514))
        {
        OUTP(DAC_CNTL, (BYTE)((INP(DAC_CNTL) & 0xFC) | 1));

        /*
         * On TVP3026 DAC, skip the OVERSCAN colour register.
         */
        if (QueryPtr->q_DAC_type == DAC_TVP3026)
            {
            OUTP(DAC_REGS, 1);
            CursorProgOffset = 1;   /* DAC_DATA */
            }
        else if (QueryPtr->q_DAC_type == DAC_ATI_68860)
            {
            OUTP(DAC_REGS, 0);
            CursorProgOffset = 1;   /* DAC_DATA */
            }
        else /* if (QueryPtr->q_DAC_type == DAC_IBM514) */
            {
            OUTP_HBHW(DAC_REGS, 1);     /* Auto-increment */
            OUTP(DAC_REGS, 0x40);
            OUTP_HBLW(DAC_REGS, 0);
            CursorProgOffset = 2;   /* DAC_MASK */
            }

        LioOutp(DAC_REGS, 0, CursorProgOffset);     /* Colour 0 red */
        LioOutp(DAC_REGS, 0, CursorProgOffset);     /* Colour 0 green */
        LioOutp(DAC_REGS, 0, CursorProgOffset);     /* Colour 0 blue */

        LioOutp(DAC_REGS, 0xFF, CursorProgOffset);  /* Colour 1 red */
        LioOutp(DAC_REGS, 0xFF, CursorProgOffset);  /* Colour 1 green */
        LioOutp(DAC_REGS, 0xFF, CursorProgOffset);  /* Colour 1 blue */


        OUTP(DAC_CNTL, (BYTE)((INP(DAC_CNTL) & 0xFC)));
        }

    else    /* if (DAC not one of ATI68860, TVP3026, or IBM514) */
        {
        OUTPD(CUR_CLR0, 0x00000000);
        /*
         * On most Mach 64 cards, we must use only the lower 4 bits
         * when setting up the white part of the cursor. On the
         * ?T, however, we must set all 8 bits for each of the colour
         * components.
         *
         * Verify that the VT/GT still need this after the final ASIC
         * becomes available.
         */
        if ((QueryPtr->q_pix_depth == 4) &&
            (QueryPtr->q_DAC_type != DAC_INTERNAL_CT) &&
            (QueryPtr->q_DAC_type != DAC_INTERNAL_GT) &&
            (QueryPtr->q_DAC_type != DAC_INTERNAL_VT))
            {
            OUTPD(CUR_CLR1, 0x0F0F0F0F);
            }
        else
            {
            OUTPD(CUR_CLR1, 0xFFFFFFFF);
            }

        }

    /*
     * phwDeviceExtension->ReInitializing becomes TRUE in
     * IOCTL_VIDEO_SET_COLOR_REGISTERS packet of ATIMPStartIO().
     *
     * If this is the first time we are going into graphics mode,
     * Turn on the graphics engine. Otherwise, set the palette
     * to the last set of colours that was selected while in
     * accelerator mode.
     */
    if (phwDeviceExtension->ReInitializing)
        {
        SetPalette_cx(phwDeviceExtension->Clut,
                      phwDeviceExtension->FirstEntry,
                      phwDeviceExtension->NumEntries);
        }
    else
        {

        /*
         * Turn on the graphics engine.
         */
        OUTPD(GEN_TEST_CNTL, (INPD(GEN_TEST_CNTL) | GEN_TEST_CNTL_GuiEna));
        }

    /*
     * If we are using a 68860 DAC or ?T internal DAC in a non-palette
     * mode, identity map the palette.
     */
    if (((QueryPtr->q_DAC_type == DAC_ATI_68860) ||
        (QueryPtr->q_DAC_type == DAC_INTERNAL_CT) ||
        (QueryPtr->q_DAC_type == DAC_INTERNAL_GT) ||
        (QueryPtr->q_DAC_type == DAC_INTERNAL_VT)) &&
        (QueryPtr->q_pix_depth > 8))
        IdentityMapPalette_cx();


    /*
     * Clear the screen regardless of whether or not this is the
     * first time we are going into graphics mode. This is done
     * because in 3.50 and later releases of Windows NT, the
     * screen will be filled with garbage if we don't clear it.
     *
     * 24BPP is not a legal setting for DP_DST_PIX_WID@DP_PIX_WID.
     * Instead, use 8BPP, but tell the engine that the screen is
     * 3 times as wide as it actually is.
     */
    if (CrtTable->ColourDepthInfo == BIOS_DEPTH_24BPP)
        {
        WidthToClear = CrtTable->m_x_size * 3;
        ScreenPitch = (CrtTable->m_screen_pitch * 3) / 8;
        PixelDepth = BIOS_DEPTH_8BPP;
        /*
         * Horizontal scissors are only valid in the range
         * -4096 to +4095. If the horizontal resolution
         * is high enough to put the scissor outside this
         * range, clamp the scissors to the maximum
         * permitted value.
         */
        HorScissors = QueryPtr->q_desire_x * 3;
        if (HorScissors > 4095)
            HorScissors = 4095;
        HorScissors <<= 16;
        }
    else
        {
        WidthToClear = CrtTable->m_x_size;
        ScreenPitch = CrtTable->m_screen_pitch / 8;
        PixelDepth = CrtTable->ColourDepthInfo;
        HorScissors = (QueryPtr->q_desire_x) << 16;
        }

    /*
     * On some DAC/memory combinations, some modes which require more
     * than 2M of memory (1152x764 24BPP, 1280x1024 24BPP, and
     * 1600x1200 16BPP) will have screen tearing at the 2M boundary.
     *
     * As a workaround, the offset field of all 3 CRTC/SRC/DST_OFF_PITCH
     * registers must be set to put the 2M boundary at the start
     * of a scanline.
     *
     * Other DAC/memory combinations are unaffected, but since this
     * fix is nearly harmless (only ill effect is to make DCI unusable
     * in these modes), we can catch all future combinations which
     * suffer from this problem by assuming that all DAC/memory
     * combinations are affected.
     */
    if ((QueryPtr->q_pix_depth == 24) &&
        (QueryPtr->q_desire_x == 1280))
        {
        ScreenOffset = 0x40;
        }
    else if ((QueryPtr->q_pix_depth == 24) &&
            (QueryPtr->q_desire_x == 1152))
        {
        ScreenOffset = 0x160;
        }
    else if ((QueryPtr->q_pix_depth == 16) &&
            (QueryPtr->q_desire_x == 1600))
        {
        ScreenOffset = 0x90;
        }
    else /* all other DAC/resolution/pixel depth combinations */
        {
        ScreenOffset = 0;
        }

    CheckFIFOSpace_cx(TWO_WORDS);
    Scratch = INPD(CRTC_OFF_PITCH) & ~CRTC_OFF_PITCH_Offset;
    Scratch |= ScreenOffset;
    OUTPD(CRTC_OFF_PITCH, Scratch);
    Scratch = INPD(SRC_OFF_PITCH) & ~SRC_OFF_PITCH_Offset;
    Scratch |= ScreenOffset;
    OUTPD(SRC_OFF_PITCH, Scratch);


    /*
     * The pixel widths for destination,
     * source, and host must be the same.
     */
    PixelDepth |= ((PixelDepth << 8) | (PixelDepth << 16));

    CheckFIFOSpace_cx(ELEVEN_WORDS);

    OUTPD(DP_WRITE_MASK, 0xFFFFFFFF);
    OUTPD(DST_OFF_PITCH, (ScreenPitch << 22) | ScreenOffset);
    OUTPD(DST_CNTL, (DST_CNTL_XDir | DST_CNTL_YDir));
    OUTPD(DP_PIX_WIDTH, PixelDepth);
    OUTPD(DP_SRC, (DP_FRGD_SRC_FG | DP_BKGD_SRC_BG | DP_MONO_SRC_ONE));
    OUTPD(DP_MIX, ((MIX_FN_PAINT << 16) | MIX_FN_PAINT));
    OUTPD(DP_FRGD_CLR, 0x0);
    OUTPD(SC_LEFT_RIGHT, HorScissors);
    OUTPD(SC_TOP_BOTTOM, (CrtTable->m_y_size) << 16);
    OUTPD(DST_Y_X, 0);
    OUTPD(DST_HEIGHT_WIDTH, (WidthToClear << 16) | CrtTable->m_y_size);

    if (WaitForIdle_cx() == FALSE)
        {
        VideoDebugPrint((DEBUG_ERROR, "SetCurrentMode_cx() failed WaitForIdle_cx()\n"));
        return ERROR_INSUFFICIENT_BUFFER;
        }

    return NO_ERROR;

}   /* SetCurrentMode_cx() */


/***************************************************************************
 *
 * void SetPalette_cx(lpPalette, StartIndex, Count);
 *
 * PPALETTEENTRY lpPalette;     Colour values to plug into palette
 * USHORT StartIndex;           First palette entry to set
 * USHORT Count;                Number of palette entries to set
 *
 * DESCRIPTION:
 *  Set the desired number of palette entries to the specified colours,
 *  starting at the specified index. Colour values are stored in
 *  doublewords, in the order (low byte to high byte) RGBx.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  SetCurrentMode_cx() and IOCTL_VIDEO_SET_COLOR_REGISTERS packet
 *  of ATIMPStartIO()
 *
 * AUTHOR:
 *  unknown
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void SetPalette_cx(PULONG lpPalette, USHORT StartIndex, USHORT Count)
{
int   i;
BYTE *pPal=(BYTE *)lpPalette;
struct query_structure *Query;      /* Information about the graphics card */

    Query = (struct query_structure *) (phwDeviceExtension->CardInfo);

    /*
     * In the current rev of the 88800GX, the memory mapped access
     * to the DAC_REGS register is broken but the I/O mapped access
     * works properly. Force the use of the I/O mapped access.
     */
    phwDeviceExtension->aVideoAddressMM[DAC_REGS] = 0;

    /*
     * If a video capture card is hooked up to the feature connector,
     * it will only "see" the palette being set if we use the VGA
     * palette registers. This applies only in 4 and 8BPP, and is
     * not necessary for when we identity map the palette (needed
     * on certain DACs in 16BPP and above).
     *
     * In a multi-headed setup, only the card with the VGA enabled is
     * able to be programmed using the VGA registers. All others must
     * be programmed using the accelerator registers. Since this is
     * the only card where we can hook up a video capture card to the
     * feature connector, we don't lose "snooping" capability by
     * programming VGA-disabled cards through the accelerator registers.
     */
    if ((Query->q_pix_depth <= 8) && (phwDeviceExtension->BiosPrefix == BIOS_PREFIX_VGA_ENAB))
        {
        VideoDebugPrint((DEBUG_DETAIL, "Setting palette via VGA registers\n"));
        /*
         * DAC_W_INDEX is 8 bytes into second block of VGA registers.
         * We do not have a separate OUTP()able register for this one.
         */
        LioOutp(VGA_END_BREAK_PORT, (BYTE)StartIndex, 8);

            for (i=0; i<Count; i++)     /* this is number of colours to update */
                {
            /*
             * DAC_DATA is 9 bytes into second block of VGA registers.
             * We do not have a separate OUTP()able register for this one.
             */
            LioOutp(VGA_END_BREAK_PORT, *pPal++, 9);    /* red */
            LioOutp(VGA_END_BREAK_PORT, *pPal++, 9);    /* green */
            LioOutp(VGA_END_BREAK_PORT, *pPal++, 9);    /* blue */
            pPal++;
                }
        }
    else
        {
        VideoDebugPrint((DEBUG_DETAIL, "Setting palette via accelerator registers\n"));
        OUTP(DAC_REGS,(BYTE)StartIndex);    /* load DAC_W_INDEX@DAC_REGS with StartIndex */

            for (i=0; i<Count; i++)     /* this is number of colours to update */
                {
            /*
             * DAC_DATA@DAC_REGS is high byte of low word.
             */
            OUTP_HBLW(DAC_REGS, *pPal++);   /* red */
                OUTP_HBLW(DAC_REGS, *pPal++);   /* green */
                OUTP_HBLW(DAC_REGS, *pPal++);   /* blue */
            pPal++;
                }
        }

    /*
     * Victor Tango requires a few registers to be re-initialized after
     * setting the palette.
     */
    if (Query->q_DAC_type == DAC_INTERNAL_VT)
        {
        OUTP_LBHW(DAC_REGS, 0xFF);  /* DAC_MASK */
        OUTP(DAC_REGS, 0xFF);       /* DAC_W_INDEX */
        }

    return;

}   /* SetPalette_cx() */



/***************************************************************************
 *
 * void IdentityMapPalette_cx(void);
 *
 * DESCRIPTION:
 *  Set the entire palette to a grey scale whose intensity at each
 *  index is equal to the index value.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  SetCurrentMode_cx()
 *
 * AUTHOR:
 *  unknown
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void IdentityMapPalette_cx(void)
{
unsigned long Index;
struct query_structure *Query;      /* Information about the graphics card */

    Query = (struct query_structure *) (phwDeviceExtension->CardInfo);

    /*
     * In the current rev of the 88800GX, the memory mapped access
     * to the DAC_REGS register is broken but the I/O mapped access
     * works properly. Force the use of the I/O mapped access.
     */
    phwDeviceExtension->aVideoAddressMM[DAC_REGS] = 0;

	 OUTP(DAC_REGS, 0);      // Start at first palette entry.

	 for (Index=0; Index<256; Index++)   // Fill the whole palette.
        {
        /*
         * DAC_DATA@DAC_REGS is high byte of low word.
         */
             OUTP_HBLW(DAC_REGS,(BYTE)(Index));      // red
             OUTP_HBLW(DAC_REGS,(BYTE)(Index));      // green
             OUTP_HBLW(DAC_REGS,(BYTE)(Index));      // blue
        }

    /*
     * Victor Tango requires a few registers to be re-initialized after
     * setting the palette.
     */
    if (Query->q_DAC_type == DAC_INTERNAL_VT)
        {
        OUTP_LBHW(DAC_REGS, 0xFF);  /* DAC_MASK */
        OUTP(DAC_REGS, 0xFF);       /* DAC_W_INDEX */
        }

    return;

}   /* IdentityMapPalette_cx() */



/**************************************************************************
 *
 * void ResetDevice_cx(void);
 *
 * DESCRIPTION:
 *  Switch back to VGA mode.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  IOCTL_VIDEO_RESET_DEVICE packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void ResetDevice_cx(void)
{
    VIDEO_X86_BIOS_ARGUMENTS Registers; /* Used in VideoPortInt10() calls */
    ULONG Scratch;


    VideoDebugPrint((DEBUG_NORMAL, "ResetDevice_cx() - entry\n"));

    VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
    Registers.Eax = BIOS_SET_MODE;
    Registers.Ecx = BIOS_MODE_VGA;
    VideoPortInt10(phwDeviceExtension, &Registers);

    VideoDebugPrint((DEBUG_DETAIL, "ResetDevice_cx() - VGA controls screen\n"));

    VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
    Registers.Eax = 0x3;
    VideoPortInt10(phwDeviceExtension, &Registers);

    VideoDebugPrint((DEBUG_NORMAL, "ResetDevice_cx() - exit\n"));

    return;

}   /* ResetDevice_cx() */



/**************************************************************************
 *
 * DWORD GetPowerManagement_cx();
 *
 * DESCRIPTION:
 *  Determine our current DPMS state.
 *
 * RETURN VALUE:
 *  Current DPMS state (VIDEO_POWER_STATE enumeration)
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  ATIMPGetPower()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

DWORD GetPowerManagement_cx(PHW_DEVICE_EXTENSION phwDeviceExtension)
{
    VIDEO_X86_BIOS_ARGUMENTS Registers; /* Used in VideoPortInt10() calls */

    ASSERT(phwDeviceExtension != NULL);

    /*
     * Invoke the BIOS call to get the desired DPMS state. The BIOS call
     * enumeration of DPMS states is in the same order as that in
     * VIDEO_POWER_STATE, but it is zero-based instead of one-based.
     */
    VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
    Registers.Eax = BIOS_GET_DPMS;
    VideoPortInt10(phwDeviceExtension, &Registers);

    return (Registers.Ecx + 1);
}   /* GetPowerManagement_cx() */


/**************************************************************************
 *
 * VP_STATUS SetPowerManagement_cx(DpmsState);
 *
 *  DWORD DpmsState;    Desired DPMS state (VIDEO_POWER_STATE enumeration)
 *
 * DESCRIPTION:
 *  Switch into the desired DPMS state.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  ERROR_INVALID_PARAMETER if invalid state requested.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  IOCTL_VIDEO_SET_POWER_MANAGEMENT packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS SetPowerManagement_cx(DWORD DpmsState)
{
    VIDEO_X86_BIOS_ARGUMENTS Registers; /* Used in VideoPortInt10() calls */

    /*
     * Only accept valid states.
     */
    if ((DpmsState < VideoPowerOn) || (DpmsState > VideoPowerOff))
        {
        VideoDebugPrint((DEBUG_ERROR, "SetPowerManagement_cx - invalid DPMS state selected\n"));
        return ERROR_INVALID_PARAMETER;
        }

    /*
     * Invoke the BIOS call to set the desired DPMS state. The BIOS call
     * enumeration of DPMS states is in the same order as that in
     * VIDEO_POWER_STATE, but it is zero-based instead of one-based.
     */
    VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
    Registers.Eax = BIOS_SET_DPMS;
    Registers.Ecx = DpmsState - 1;
    VideoPortInt10(phwDeviceExtension, &Registers);

    return NO_ERROR;

}   /* SetPowerManagement_cx() */





/**************************************************************************
 *
 * static VP_STATUS SetModeFromTable_cx(ModeTable, Registers);
 *
 * struct st_mode_table *ModeTable;     Mode table to set up screen from
 * VIDEO_X86_BIOS_ARGUMENTS Registers;  Registers for INT 10 call
 *
 * DESCRIPTION:
 *  Switch into the graphics mode specified by ModeTable.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if failed
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  SetCurrentMode_cx()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *  96 05 15    Now checks return values from INT 10 calls.
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

static VP_STATUS SetModeFromTable_cx(struct st_mode_table *ModeTable, VIDEO_X86_BIOS_ARGUMENTS Registers)
{
#define TBL_SET_BUFFER_SIZE 100

    PUCHAR MappedBuffer;                    /* Pointer to buffer used for BIOS query */
    struct cx_bios_set_from_table *CxTable; /* Mode table in Mach 64 BIOS format */
    ULONG Scratch;                          /* Temporary variable */
    struct query_structure *QueryPtr;       /* Query information for the card */
    VIDEO_X86_BIOS_ARGUMENTS TempRegs;      /* Used in setting 640x480 8BPP to enable LFB */
    BOOL FlippedPrimrary = FALSE;           /* TRUE if we switched to VGA aperture on primrary card */
    UCHAR SavedScreen[TBL_SET_BUFFER_SIZE]; /* Used to restore contents of primrary screen */
    VP_STATUS RetVal;                       /* Value returned by routines called */

    /*
     * Get a formatted pointer into the query section of HwDeviceExtension.
     * The CardInfo[] field is an unformatted buffer.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);

    /*
     * To set the video mode from a table, we need to write the mode table
     * to a buffer in physical memory below 1M. The nature of this block
     * falls into one of two cases:
     *
     * Primrary (VGA enabled) card:
     *  We have already switched into video mode 0x62 (VGA 640x480 8BPP)
     *  to set up registers that under some circumstances are not set up
     *  by the accelerator mode set, so we have access to a 64k block
     *  starting at 0xA0000 which is backed by physical (video) memory
     *  and which we can write to without corrupting code and/or data
     *  being used by other processes.
     *
     * Secondary (VGA disabled) card:
     *  There is a VGA enabled card in the machine, which falls into
     *  one of five sub-cases:
     *
     *  1. VGA is in colour text mode
     *     We can use the offscreen portion of the buffer, and it doesn't
     *     matter whether or not the card is a Mach 64.
     *
     *  2. VGA is in mono text mode
     *     We can use the offscreen portion of the buffer, and it doesn't
     *     matter whether or not the card is a Mach 64.
     *
     *  3. VGA is in graphics mode
     *     We can use the beginning of the graphics screen, and it doesn't
     *     matter whether or not the card is a Mach 64.
     *
     *  4. VGA-enabled card is a Mach 64 in accelerator mode
     *     We can temporarily flip the primrary card's aperture status
     *     from LFB to VGA aperture, and use the start of the VGA
     *     aperture.
     *
     *  5. VGA-enabled card is another brand of accelerator, in accelerator mode
     *     This case should never occur, since NT should only run one video
     *     driver with VgaCompatible set to zero. If it is the ATI driver,
     *     a non-ATI card should not be in accelerator mode. If it is the
     *     driver for the non-ATI card, we will never receive a request
     *     to change into an accelerator mode on our card.
     *
     * We don't need to claim the whole block, but we should claim a bit
     * more than the size of the mode table so the BIOS won't try to access
     * unclaimed memory.
     */
    if (phwDeviceExtension->BiosPrefix == BIOS_PREFIX_VGA_ENAB)
        {
        VideoDebugPrint((DEBUG_NORMAL, "Setting mode on primrary card\n"));
        MappedBuffer = MapFramebuffer(0xA0000, TBL_SET_BUFFER_SIZE);
        if (MappedBuffer == 0)
            {
            VideoDebugPrint((DEBUG_ERROR, "SetModeFromTable_cx() failed MapFramebuffer()\n"));
            return ERROR_INSUFFICIENT_BUFFER;
            }
        /*
         * Tell the BIOS to load the CRTC parameters from a table,
         * rather than using the configured refresh rate for this
         * resolution, and let it know where the table is.
         */
        Registers.Eax = BIOS_LOAD_SET;
        Registers.Edx = 0xA000;
        Registers.Ebx = 0x0000;
        Registers.Ecx &= ~BIOS_RES_MASK;    /* Mask out code for configured resolution */
        Registers.Ecx |= BIOS_RES_BUFFER;
        }
    else
        {
        /*
         * This is a VGA disabled card. First try sub-cases 1 through 3.
         */
        VideoDebugPrint((DEBUG_NORMAL, "Setting mode on secondary card\n"));

        MappedBuffer = GetVgaBuffer(TBL_SET_BUFFER_SIZE, 0, &(Registers.Edx), SavedScreen);

        /*
         * If we were unable to map the buffer, assume we are dealing
         * with sub-case 4. We can't distinguish between sub-cases
         * 4 and 5, since the code to report an error if we issue an
         * invalid BIOS call is in the ATI video BIOS, which won't
         * be present in sub-case 5. Users in this sub-case are on
         * their own.
         *
         * For sub-case 4 (VGA-enabled card is a Mach 64 in accelerator
         * mode), temporarily flip from LFB mode to VGA aperture mode
         * so we can use the VGA aperture without destroying the contents
         * of the screen.
         */
        if (MappedBuffer == 0)
            {
            FlippedPrimrary = TRUE;
            VideoDebugPrint((DEBUG_DETAIL, "Temporary setting primrary card to VGA aperture\n"));
            VideoPortZeroMemory(&TempRegs, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
            TempRegs.Eax = BIOS_PREFIX_VGA_ENAB | BIOS_APERTURE_LB;
            TempRegs.Ecx = BIOS_VGA_APERTURE;
            RetVal = VideoPortInt10(phwDeviceExtension, &TempRegs);
            if (RetVal != NO_ERROR)
                {
                VideoDebugPrint((DEBUG_ERROR, "SetModeFromTable_cx() failed VGA-enabled flip to VGA aperture\n"));
                return RetVal;
                }
            MappedBuffer = MapFramebuffer(0xA0000, TBL_SET_BUFFER_SIZE);
            if (MappedBuffer == 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "SetModeFromTable_cx() failed to map buffer on VGA-enabled card\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            Registers.Edx = 0xA000;

            /*
             * Save the contents of the buffer so that we can restore it
             * after we finish the mode set.
             */
            for (Scratch = 0; Scratch < TBL_SET_BUFFER_SIZE; Scratch++)
                SavedScreen[Scratch] = VideoPortReadRegisterUchar(&(MappedBuffer[Scratch]));
            }

        /*
         * Tell the BIOS to load the CRTC parameters from a table,
         * rather than using the configured refresh rate for this
         * resolution, and let it know where the table is.
         */
        Registers.Eax = BIOS_LOAD_SET;
        Registers.Ebx = 0x0000;
        Registers.Ecx &= ~BIOS_RES_MASK;    /* Mask out code for configured resolution */
        Registers.Ecx |= BIOS_RES_BUFFER;

        }   /* end if (VGA disabled card) */

    CxTable = (struct cx_bios_set_from_table *)MappedBuffer;

    /*
     * Copy the mode table into the Mach 64 format table. First handle
     * the fields that only require shifting and masking.
     */
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_mode_select), (WORD)((Registers.Ecx & BIOS_RES_MASK) | CX_BS_MODE_SELECT_ACC));
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_h_tot_disp), (WORD)((ModeTable->m_h_disp << 8) | ModeTable->m_h_total));
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_h_sync_strt_wid), (WORD)((ModeTable->m_h_sync_wid << 8) | ModeTable->m_h_sync_strt));
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_v_sync_wid), (WORD)(ModeTable->m_v_sync_wid | CX_BS_V_SYNC_WID_CLK));
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_h_overscan), ModeTable->m_h_overscan);
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_v_overscan), ModeTable->m_v_overscan);
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_overscan_8b), ModeTable->m_overscan_8b);
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_overscan_gr), ModeTable->m_overscan_gr);

    /*
     * Next take care of fields which must be translated from our
     * "canned" mode tables.
     *
     * The cx_crtc_gen_cntl field has only 3 bits that we use: interlace,
     * MUX mode (all 1280x1024 noninterlaced modes), and force use of
     * all parameters from the table (this bit is used by all the
     * "canned" tables).
     */
    if ((ModeTable->m_disp_cntl) & 0x10)
        VideoPortWriteRegisterUshort(&(CxTable->cx_bs_flags), CX_BS_FLAGS_INTERLACED | CX_BS_FLAGS_ALL_PARMS);
    else if ((ModeTable->m_x_size > 1024) && (ModeTable->ClockFreq >= 100000000L))
        VideoPortWriteRegisterUshort(&(CxTable->cx_bs_flags), CX_BS_FLAGS_MUX | CX_BS_FLAGS_ALL_PARMS);
    else
        VideoPortWriteRegisterUshort(&(CxTable->cx_bs_flags), CX_BS_FLAGS_ALL_PARMS);
    /*
     * Vertical parameters other than sync width are in skip-2 in
     * the "canned" tables, but need to be in linear form for the Mach 64.
     */
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_v_total), (WORD)(((ModeTable->m_v_total >> 1) & 0x0FFFC) | (ModeTable->m_v_total & 0x03)));
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_v_disp), (WORD)(((ModeTable->m_v_disp >> 1) & 0x0FFFC) | (ModeTable->m_v_disp & 0x03)));
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_v_sync_strt), (WORD)(((ModeTable->m_v_sync_strt >> 1) & 0x0FFFC) | (ModeTable->m_v_sync_strt & 0x03)));
    /*
     * The cx_dot_clock field takes the pixel clock frequency in units
     * of 10 kHz.
     */
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_dot_clock), (WORD)(ModeTable->ClockFreq / 10000L));

    /*
     * Now set up fields which have constant values.
     */
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_reserved_1), 0);
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_reserved_2), 0);

    /*
     * Some Mach64 cards need to have an internal flag set up before
     * they can switch into certain resolutions. Cards which have
     * these resolutions configured using INSTALL.EXE don't need this
     * flag set up, so we don't need to do it when switching to a
     * hardware default mode. Since we don't know if the card needs
     * this flag for the resolution we are using, set it for all
     * "canned" mode tables.
     *
     * Unfortunately, this flag will disable automatic "kickdown"
     * to a lower refresh rate for high pixel depths when "use
     * hardware default refresh rate" is selected. To avoid this
     * problem, save the contents of the scratchpad register, set
     * the flag, then after we set the mode we want, restore the
     * contents of the scratchpad register.
     */
    Scratch = INPD(SCRATCH_REG1);
    OUTPD(SCRATCH_REG1, Scratch | 0x00000200);

    RetVal = VideoPortInt10(phwDeviceExtension, &Registers);
    if (RetVal != NO_ERROR)
        {
        VideoDebugPrint((DEBUG_ERROR, "SetModeFromTable_cx() failed mode set\n"));
        return RetVal;
        }

    /*
     * If we are dealing with a VGA-disabled card (typically in a
     * multiheaded setup, but under rare circumstances someone may
     * be using a VGA-disabled Mach 64 with a separate VGA card),
     * we must clean up after ourselves. First of all, the DAC_MASK
     * register will have been left at zero by the BIOS call, which
     * inhibits display of palette modes. Next, we must restore the
     * contents of the buffer we used to store the CRT parameter table.
     *
     * Finally, if we obtained the buffer by setting a VGA-enabled
     * Mach 64 in accelerator mode to use the VGA aperture, we must
     * restore it to its previous aperture status. Since this will
     * only happen in a multiheaded setup, and we only support PCI
     * cards in such a setup (i.e. all cards have LFB available),
     * we can safely assume that the VGA-enabled card was originally
     * configured for LFB mode.
     */
    if (phwDeviceExtension->BiosPrefix != BIOS_PREFIX_VGA_ENAB)
        {
        VideoDebugPrint((DEBUG_DETAIL, "Cleaning up after mode set on VGA-disabled card\n"));
        OUTP_LBHW(DAC_REGS, 0xFF);  /* DAC_MASK */

        for (Scratch = 0; Scratch < TBL_SET_BUFFER_SIZE; Scratch++)
            VideoPortWriteRegisterUchar(&(MappedBuffer[Scratch]), SavedScreen[Scratch]);

        if (FlippedPrimrary == TRUE)
            {
            VideoDebugPrint((DEBUG_DETAIL, "Setting primrary card back to LFB mode\n"));
            VideoPortZeroMemory(&TempRegs, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
            TempRegs.Eax = BIOS_PREFIX_VGA_ENAB | BIOS_APERTURE_LB;
            TempRegs.Ecx = BIOS_LINEAR_APERTURE;
            RetVal = VideoPortInt10(phwDeviceExtension, &TempRegs);
            if (RetVal != NO_ERROR)
                {
                VideoDebugPrint((DEBUG_ERROR, "SetModeFromTable_cx() failed VGA-enabled flip to linear aperture\n"));
                return RetVal;
                }
            }
        }
    OUTPD(SCRATCH_REG1, Scratch);
    VideoPortFreeDeviceBase(phwDeviceExtension, MappedBuffer);

    return NO_ERROR;

}   /* SetModeFromTable_cx() */


/**************************************************************************
 *
 * void RestoreMemSize_cx(void);
 *
 * DESCRIPTION:
 *  Restore the "memory size" register on the card when switching out
 *  of a mode which requires this register to be set to a specific value.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  SetCurrentMode_cx() and ATIMPResetHw()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void RestoreMemSize_cx(void)
{
    struct query_structure *QueryPtr;   /* Query information for the card */
    ULONG Scratch;                      /* Temporary variable */

    /*
     * Get a formatted pointer into the query section of HwDeviceExtension.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);

    Scratch = INPD(MEM_CNTL) & ~MEM_CNTL_MemSizeMsk;
    switch(QueryPtr->q_memory_size)
        {
        case VRAM_512k:
            Scratch |= MEM_CNTL_MemSize512k;
            break;

        case VRAM_1mb:
            Scratch |= MEM_CNTL_MemSize1Mb;
            break;

        case VRAM_2mb:
            Scratch |= MEM_CNTL_MemSize2Mb;
            break;

        case VRAM_4mb:
            Scratch |= MEM_CNTL_MemSize4Mb;
            break;

        case VRAM_6mb:
            Scratch |= MEM_CNTL_MemSize6Mb;
            break;

        case VRAM_8mb:
            Scratch |= MEM_CNTL_MemSize8Mb;
            break;

        default:
            break;
        }
    OUTPD(MEM_CNTL, Scratch);

    return;

}   /* RestoreMemSize_cx() */



/**************************************************************************
 *
 * VP_STATUS ShareVideoMemory_cx(RequestPacket, QueryPtr);
 *
 * PVIDEO_REQUEST_PACKET RequestPacket; Request packet with input and output buffers
 * struct query_structure *QueryPtr;    Query information for the card
 *
 * DESCRIPTION:
 *  Allow applications to do direct screen access through DCI.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if failed
 *
 * CALLED BY:
 *  IOCTL_VIDEO_SHARE_VIDEO_MEMORY packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS ShareVideoMemory_cx(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr)
{
    PVIDEO_SHARE_MEMORY InputPtr;               /* Pointer to input structure */
    PVIDEO_SHARE_MEMORY_INFORMATION OutputPtr;  /* Pointer to output structure */
    PHYSICAL_ADDRESS ShareAddress;              /* Physical address of video memory */
    PVOID VirtualAddress;                       /* Virtual address to map video memory at */
    ULONG SharedViewSize;                       /* Size of block to share */
    ULONG SpaceType;                            /* Sparse or dense space? */
    VP_STATUS Status;                           /* Status to return */

    /*
     * On some DAC/memory combinations, some modes which require more
     * than 2M of memory (1152x764 24BPP, 1280x1024 24BPP, and
     * 1600x1200 16BPP) will have screen tearing at the 2M boundary.
     *
     * As a workaround, the display driver must start the framebuffer
     * at an offset which will put the 2M boundary at the start of a
     * scanline.
     *
     * Other DAC/memory combinations are unaffected, but since this
     * fix is nearly harmless (only ill effect is to make DCI unusable
     * in these modes), we can catch all future combinations which
     * suffer from this problem by assuming that all DAC/memory
     * combinations are affected.
     *
     * Since this requires anyone making direct access to video memory
     * to be aware of the workaround, we can't make the memory available
     * through DCI.
     */
    if (((QueryPtr->q_pix_depth == 24) && (QueryPtr->q_desire_x == 1280)) ||
        ((QueryPtr->q_pix_depth == 24) && (QueryPtr->q_desire_x == 1152)) ||
        ((QueryPtr->q_pix_depth == 16) && (QueryPtr->q_desire_x == 1600)))
        return ERROR_INVALID_FUNCTION;

    InputPtr = RequestPacket->InputBuffer;

    if ((InputPtr->ViewOffset > phwDeviceExtension->VideoRamSize) ||
        ((InputPtr->ViewOffset + InputPtr->ViewSize) > phwDeviceExtension->VideoRamSize))
        {
        VideoDebugPrint((DEBUG_ERROR, "ShareVideoMemory_cx() - access beyond video memory\n"));
        return ERROR_INVALID_PARAMETER;
        }

    RequestPacket->StatusBlock->Information = sizeof(VIDEO_SHARE_MEMORY_INFORMATION);

    /*
     * Beware: the input buffer and the output buffer are the same buffer,
     * and therefore data should not be copied from one to the other.
     */
    VirtualAddress = InputPtr->ProcessHandle;
    SharedViewSize = InputPtr->ViewSize;

    SpaceType = 0;
#if defined(_ALPHA_)
    /*
     * Use dense space mapping whenever we can, because that will
     * allow us to support DCI and direct GDI access.
     *
     * Dense space is extremely slow with ISA cards on the newer Alphas,
     * because any byte- or word-write requires a read/modify/write
     * operation, and the ALpha can only ever do 64-bit reads when in
     * dense mode. As a result, these operations would always require
     * 4 reads and 2 writes on the ISA bus. Also, some older Alphas
     * don't support dense space mapping.
     *
     * Any Alpha that supports PCI can support dense space mapping, and
     * because the bus is wider and faster, the read/modify/write has
     * less of an impact on performance.
     */
    if (QueryPtr->q_bus_type == BUS_PCI)
        SpaceType = 4;
#endif

    /*
     * NOTE: we are ignoring ViewOffset
     */
    ShareAddress.QuadPart = phwDeviceExtension->PhysicalFrameAddress.QuadPart;


    /*
     * If the LFB is enabled, use ordinary mapping. If we have only
     * the paged aperture, we must map to banked memory. Since the
     * LFB is always aligned on a 4M boundary (8M boundary for 8M
     * aperture), this check for the paged aperture will never falsely
     * detect a LFB as paged.
     */
    if (phwDeviceExtension->PhysicalFrameAddress.LowPart == 0x0A0000)
        {
        /*
         * On some versions of the DDK, VideoPortMapBankedMemory() is
         * not available. If this is the case, force an error.
         * This routine should be available in all versions of
         * the DDK which support DCI, since it is used for DCI
         * support on cards with banked apertures.
         */
#if defined(IOCTL_VIDEO_SHARE_VIDEO_MEMORY)
        Status = VideoPortMapBankedMemory(
            phwDeviceExtension,
            ShareAddress,
            &SharedViewSize,
            &SpaceType,
            &VirtualAddress,
            0x10000,            /* Only first 64k of 128k aperture available */
            FALSE,              /* No separate read/write banks */
            BankMap_cx,         /* Our bank-mapping routine */
            (PVOID) phwDeviceExtension);
#else
        Status = ERROR_INVALID_FUNCTION;
#endif
        }
    else    /* LFB */
        {
        Status = VideoPortMapMemory(phwDeviceExtension,
                                    ShareAddress,
                                    &SharedViewSize,
                                    &SpaceType,
                                    &VirtualAddress);
        }

    OutputPtr = RequestPacket->OutputBuffer;
    OutputPtr->SharedViewOffset = InputPtr->ViewOffset;
    OutputPtr->VirtualAddress = VirtualAddress;
    OutputPtr->SharedViewSize = SharedViewSize;

    return Status;

}   /* ShareVideoMemory_cx() */



/**************************************************************************
 *
 * void BankMap_cx(BankRead, BankWrite, Context);
 *
 * ULONG BankRead;       Bank to read
 * ULONG BankWrite;      Bank to write
 * PVOID Context;       Pointer to hardware-specific information
 *
 * DESCRIPTION:
 *  Map the selected bank of video memory into the 64k VGA aperture.
 *  We don't support separate read and write banks, so we use BankWrite
 *  to set the read/write bank, and ignore BankRead.
 *
 * CALLED BY:
 *  This is an entry point, rather than being called
 *  by other miniport functions.
 *
 * NOTE:
 *  This function is called directly by the memory manager during page
 *  fault handling, and so cannot be made pageable.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void BankMap_cx(ULONG BankRead, ULONG BankWrite, PVOID Context)
{
    OUTPD(MEM_VGA_WP_SEL, (BankWrite*2) | (BankWrite*2 + 1) << 16);
    OUTPD(MEM_VGA_RP_SEL, (BankWrite*2) | (BankWrite*2 + 1) << 16);

    return;

}   /* BankMap_cx() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\init_m.c ===
/************************************************************************/
/*                                                                      */
/*                              INIT_M.C                                */
/*                                                                      */
/*        Sep 27  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities

  $Revision:   1.16  $
      $Date:   15 May 1996 16:35:42  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/init_m.c_v  $
 *
 *    Rev 1.16   15 May 1996 16:35:42   RWolff
 * Waits for idle after setting accelerator mode.
 *
 *    Rev 1.15   17 Apr 1996 13:09:26   RWolff
 * Backed out Alpha LFB mapping as dense.
 *
 *    Rev 1.14   11 Apr 1996 15:12:40   RWolff
 * Now maps framebuffer as dense on DEC Alpha with PCI graphics card.
 *
 *    Rev 1.13   31 Mar 1995 11:53:46   RWOLFF
 * Changed from all-or-nothing debug print statements to thresholds
 * depending on importance of the message.
 *
 *    Rev 1.12   14 Feb 1995 15:41:20   RWOLFF
 * Changed conditional compile that uses or fakes failure of
 * VideoPortMapBankedMemory() to look for IOCTL_VIDEO_SHARE_VIDEO_MEMORY
 * instead of the routine itself. Looking for the routine always failed,
 * and since the routine is supplied in order to allow DCI to be used
 * on systems without a linear framebuffer, it should be available on
 * any DDK version that supports the IOCTL. If it isn't, a compile-time
 * error will be generated (unresolved external reference).
 *
 *    Rev 1.11   03 Feb 1995 15:17:00   RWOLFF
 * Added support for DCI, removed dead code.
 *
 *    Rev 1.10   23 Dec 1994 10:47:18   ASHANMUG
 * ALPHA/Chrontel-DAC
 *
 *    Rev 1.9   22 Jul 1994 17:48:50   RWOLFF
 * Merged with Richard's non-x86 code stream.
 *
 *    Rev 1.8   27 Jun 1994 16:30:12   RWOLFF
 * Now reports all hardware default mode tables as noninterlaced to
 * avoid confusing the display applet.
 *
 *    Rev 1.7   15 Jun 1994 11:07:08   RWOLFF
 * Now uses VideoPortZeroDeviceMemory() to clear 24BPP screens on NT builds
 * where this function is available.
 *
 *    Rev 1.6   12 May 1994 11:05:32   RWOLFF
 * Reports the refresh rate from the mode table, rather than always
 * reporting "Use hardware default".
 *
 *    Rev 1.5   31 Mar 1994 15:02:00   RWOLFF
 * Added SetPowerManagement_m() function to implement DPMS handling.
 *
 *    Rev 1.4   14 Mar 1994 16:31:36   RWOLFF
 * XMillimeter field of mode information structure now set properly.
 *
 *    Rev 1.3   03 Mar 1994 12:37:54   ASHANMUG
 * Pageable
 *
 *    Rev 1.1   31 Jan 1994 16:27:06   RWOLFF
 * Now fills in Frequency and VideoMemoryBitmap[Width|Height] fields of
 * mode information structure. Sets Number[Red|Green|Blue]Bits fields
 * for palette modes to 6 (assumes VGA-compatible DAC) instead of 0
 * to allow Windows NT to set the palette colours to the best match
 * for the colours to be displayed.
 *
 *    Rev 1.0   31 Jan 1994 11:10:40   RWOLFF
 * Initial revision.
 *
 *    Rev 1.6   24 Jan 1994 18:04:28   RWOLFF
 * Now puts DAC in known state before setting video mode. This is to
 * accomodate the Graphics Wonder (1M DRAM Mach 32 with BT48x DAC).
 *
 *    Rev 1.5   14 Jan 1994 15:21:22   RWOLFF
 * SetCurrentMode_m() and (new routine) ResetDevice_m() now initialize
 * and deinitialize the bank manager.
 *
 *    Rev 1.4   15 Dec 1993 15:26:48   RWOLFF
 * Added note to clean up before sending to Microsoft.
 *
 *    Rev 1.3   30 Nov 1993 18:16:34   RWOLFF
 * MapVideoMemory_m() now sets memoryInformation->FrameBufferLength to
 * aperture size rather than amount of video memory present.
 *
 *    Rev 1.2   05 Nov 1993 13:25:24   RWOLFF
 * Switched to defined values for memory type, 1280x1024 DAC initialization is
 * now done in the same manner as for other resolutions.
 *
 *    Rev 1.0   08 Oct 1993 11:20:34   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
INIT_M.C - Highest-level card-dependent routines for miniport.

DESCRIPTION
    This file contains initialization and packet handling routines
    for 8514/A-compatible ATI accelerators. Routines in this module
    are called only by routines in ATIMP.C, which is card-independent.

OTHER FILES

#endif

#include "dderror.h"

#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"
#include "amach.h"
#include "amach1.h"
#include "atimp.h"
#include "atint.h"

#define INCLUDE_INIT_M
#include "init_m.h"
#include "modes_m.h"
#include "services.h"
#include "setup_m.h"


/*
 * Prototypes for static functions.
 */
static void QuerySingleMode_m(PVIDEO_MODE_INFORMATION ModeInformation, struct query_structure *QueryPtr, ULONG ModeIndex);


/*
 * Allow miniport to be swapped out when not needed.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_M, AlphaInit_m)
#pragma alloc_text(PAGE_M, Initialize_m)
#pragma alloc_text(PAGE_M, MapVideoMemory_m)
#pragma alloc_text(PAGE_M, QueryPublicAccessRanges_m)
#pragma alloc_text(PAGE_M, QueryCurrentMode_m)
#pragma alloc_text(PAGE_M, QueryAvailModes_m)
#pragma alloc_text(PAGE_M, QuerySingleMode_m)
#pragma alloc_text(PAGE_M, SetCurrentMode_m)
#pragma alloc_text(PAGE_M, ResetDevice_m)
#pragma alloc_text(PAGE_M, SetPowerManagement_m)
#pragma alloc_text(PAGE_M, ShareVideoMemory_m)
/* BankMap_m() can't be made pageable */
#endif



/***************************************************************************
 *
 * void AlphaInit_m(void);
 *
 * DESCRIPTION:
 *  Perform the initialization that would normally be done by the ROM
 *  BIOS on x86 machines.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  ATIMPFindAdapter()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void AlphaInit_m(void)
{
    OUTPW(MEM_CFG, 0);
    DEC_DELAY
    OUTPW(MISC_OPTIONS, 0xb0a9);
    DEC_DELAY
    OUTPW(MEM_BNDRY, 0);
    DEC_DELAY
#if 0
    OUTPW(CONFIG_STATUS_1, 0x1410);
    DEC_DELAY
    OUTPW(SCRATCH_PAD_1, 0);
    DEC_DELAY
    OUTPW(SCRATCH_PAD_0, 0);
    DEC_DELAY
#endif
    OUTPW(CLOCK_SEL, 0x250);
    DEC_DELAY
    OUTPW(DAC_W_INDEX, 0x40);
    DEC_DELAY
    OUTPW(MISC_CNTL, 0xC00);
    DEC_DELAY
    OUTPW(LOCAL_CONTROL, 0x1402);
#if defined (MIPS) || defined (_MIPS_)
    DEC_DELAY
    OUTPW(OVERSCAN_COLOR_8, 0);    //RKE: to eliminate left overscan on MIPS
#endif
    DEC_DELAY

    return;

}   /* AlphaInit_m() */



/***************************************************************************
 *
 * void Initialize_m(void);
 *
 * DESCRIPTION:
 *  This routine is the 8514/A-compatible hardware initialization routine
 *  for the miniport driver. It is called once an adapter has been found
 *  and all the required data structures for it have been created.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  ATIMPInitialize()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void Initialize_m(void)
{
    /*
     * Make sure we have enough available FIFO entries
     * to initialize the card.
     */
    CheckFIFOSpace_m(SIXTEEN_WORDS);

    /*
     * On the 68800, set the memory boundary to shared VGA memory.
     * On all cards, set the screen and drawing engine to start
     * at the beginning of accelerator memory and MEM_CNTL
     * to linear.
     */
    if (phwDeviceExtension->ModelNumber == MACH32_ULTRA)
        OUTP (MEM_BNDRY,0);

    OUTPW(CRT_OFFSET_LO, 0);
    OUTPW(GE_OFFSET_LO,  0);
    OUTPW(CRT_OFFSET_HI, 0);
    OUTPW(GE_OFFSET_HI,  0);
    OUTPW(MEM_CNTL,0x5006);

    /*
     * Reset the engine and FIFO, then return to normal operation.
     */
    OUTPW(SUBSYS_CNTL,0x9000);
    OUTPW(SUBSYS_CNTL,0x5000);

    /*
     * The hardware cursor is available only for Mach 32 cards.
     * disable the cursor and initialize it to display quadrant I - 0
     */
    if (phwDeviceExtension->ModelNumber == MACH32_ULTRA)
        {
        OUTPW(CURSOR_OFFSET_HI,0);

        OUTPW(HORZ_CURSOR_OFFSET,0);
        OUTP(VERT_CURSOR_OFFSET,0);
        OUTPW(CURSOR_COLOR_0, 0x0FF00);         /* Colour 0 black, colour 1 white */
        OUTPW(EXT_CURSOR_COLOR_0,0);	// black
        OUTPW(EXT_CURSOR_COLOR_1,0xffff);	// white
        }

    return;

}   /* Initialize_m() */


/**************************************************************************
 *
 * VP_STATUS MapVideoMemory_m(RequestPacket, QueryPtr);
 *
 * PVIDEO_REQUEST_PACKET RequestPacket; Request packet with input and output buffers
 * struct query_structure *QueryPtr;    Query information for the card
 *
 * DESCRIPTION:
 *  Map the card's video memory into system memory and store the mapped
 *  address and size in OutputBuffer.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if failed
 *
 * GLOBALS CHANGED:
 *  FrameLength and PhysicalFrameAddress fields of phwDeviceExtension
 *  if Mach 32 card without linear framebuffer.
 *
 * CALLED BY:
 *  IOCTL_VIDEO_MAP_VIDEO_MEMORY packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS MapVideoMemory_m(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr)
{
    PVIDEO_MEMORY_INFORMATION memoryInformation;
    ULONG inIoSpace;        /* Scratch variable used by VideoPortMapMemory() */
    VP_STATUS status;       /* Error code obtained from O/S calls */

    memoryInformation = RequestPacket->OutputBuffer;

    memoryInformation->VideoRamBase = ((PVIDEO_MEMORY)
        (RequestPacket->InputBuffer))->RequestedVirtualAddress;

    /*
     * The VideoRamLength field contains the amount of video memory
     * on the card. The FrameBufferLength field contains the
     * size of the aperture in bytes
     *
     * Initially assume that the linear aperture is available.
     * For our 8514/A-compatible cards, we always enable a 4M aperture
     * if the LFB is available, so map the full 4M even if the
     * aperture size is greater than the amount of video memory.
     */
    memoryInformation->VideoRamLength    = phwDeviceExtension->VideoRamSize;
    memoryInformation->FrameBufferLength = 4 * ONE_MEG;

    /*
     * If the linear aperture is not available (==0), and we are
     * dealing with a card which can use the VGA 64k aperture,
     * map it in.
     */
    if (QueryPtr->q_aperture_cfg == 0)
        {
        if ((phwDeviceExtension->ModelNumber == MACH32_ULTRA) &&
            (QueryPtr->q_VGA_type == 1))
            {
            phwDeviceExtension->FrameLength = 0x10000;
            phwDeviceExtension->PhysicalFrameAddress.LowPart = 0x0A0000;
            memoryInformation->FrameBufferLength = phwDeviceExtension->FrameLength;
            }
        else{
            /*
             * This card can't use either linear or VGA aperture.
             * Set frame buffer size to zero and return.
             */
            memoryInformation->VideoRamBase      = 0;
            memoryInformation->FrameBufferLength = 0;
            memoryInformation->FrameBufferBase   = 0;
            return NO_ERROR;
            }
        }
    inIoSpace = 0;
#if 0   /* defined(ALPHA) if display driver can handle dense LFB */
    if (QueryPtr->q_bus_type == BUS_PCI)
        inIoSpace = 4;
#endif

    status = VideoPortMapMemory(phwDeviceExtension,
                    	        phwDeviceExtension->PhysicalFrameAddress,
                                &(memoryInformation->FrameBufferLength),
                                &inIoSpace,
                                &(memoryInformation->VideoRamBase));

    memoryInformation->FrameBufferBase    = memoryInformation->VideoRamBase;

    return status;

}   /* MapVideoMemory_m() */


/**************************************************************************
 *
 * VP_STATUS QueryPublicAccessRanges_m(RequestPacket);
 *
 * PVIDEO_REQUEST_PACKET RequestPacket; Request packet with input and output buffers
 *
 * DESCRIPTION:
 *  Map and return information on the video card's public access ranges.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if failed
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS QueryPublicAccessRanges_m(PVIDEO_REQUEST_PACKET RequestPacket)
{
    PVIDEO_PUBLIC_ACCESS_RANGES portAccess;
    PHYSICAL_ADDRESS physicalPortBase;
    ULONG physicalPortLength;

    if ( RequestPacket->OutputBufferLength <
        (RequestPacket->StatusBlock->Information =
        sizeof(VIDEO_PUBLIC_ACCESS_RANGES)) )
        {
        return ERROR_INSUFFICIENT_BUFFER;
        }

    portAccess = RequestPacket->OutputBuffer;
	
    portAccess->VirtualAddress  = (PVOID) NULL;    // Requested VA
    portAccess->InIoSpace       = 1;               // In IO space
    portAccess->MappedInIoSpace = portAccess->InIoSpace;

    physicalPortBase.HighPart   = 0x00000000;
    physicalPortBase.LowPart    = 0x00000000;
//    physicalPortLength          = LINEDRAW+2 - physicalPortBase.LowPart;
    physicalPortLength = 0x10000;


// *SANITIZE* If MM available, give MM ports instead.

    return VideoPortMapMemory(phwDeviceExtension,
                              physicalPortBase,
                              &physicalPortLength,
                              &(portAccess->MappedInIoSpace),
                              &(portAccess->VirtualAddress));

}   /* QueryPublicAccessRanges_m() */


/**************************************************************************
 *
 * VP_STATUS QueryCurrentMode_m(RequestPacket, QueryPtr);
 *
 * PVIDEO_REQUEST_PACKET RequestPacket; Request packet with input and output buffers
 * struct query_structure *QueryPtr;    Query information for the card
 *
 * DESCRIPTION:
 *  Get screen information and colour masks for the current video mode.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if failed
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  IOCTL_VIDEO_QUERY_CURRENT_MODE packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS QueryCurrentMode_m(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr)
{
    PVIDEO_MODE_INFORMATION ModeInformation;

    /*
     * If the output buffer is too small to hold the information we need
     * to put in it, return with the appropriate error code.
     */
    if (RequestPacket->OutputBufferLength <
        (RequestPacket->StatusBlock->Information =
        sizeof(VIDEO_MODE_INFORMATION)) )
        {
        return ERROR_INSUFFICIENT_BUFFER;
        }

    /*
     * Fill in the mode information structure.
     */
    ModeInformation = RequestPacket->OutputBuffer;

    QuerySingleMode_m(ModeInformation, QueryPtr, phwDeviceExtension->ModeIndex);

    return NO_ERROR;

}   /* QueryCurrentMode_m() */


/**************************************************************************
 *
 * VP_STATUS QueryAvailModes_m(RequestPacket, QueryPtr);
 *
 * PVIDEO_REQUEST_PACKET RequestPacket; Request packet with input and output buffers
 * struct query_structure *QueryPtr;    Query information for the card
 *
 * DESCRIPTION:
 *  Get screen information and colour masks for all available video modes.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if failed
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  IOCTL_VIDEO_QUERY_AVAIL_MODES packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS QueryAvailModes_m(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr)
{
    PVIDEO_MODE_INFORMATION ModeInformation;
    ULONG CurrentMode;

    /*
     * If the output buffer is too small to hold the information we need
     * to put in it, return with the appropriate error code.
     */
    if (RequestPacket->OutputBufferLength <
        (RequestPacket->StatusBlock->Information =
        QueryPtr->q_number_modes * sizeof(VIDEO_MODE_INFORMATION)) )
        {
        return ERROR_INSUFFICIENT_BUFFER;
        }

    /*
     * Fill in the mode information structure.
     */
    ModeInformation = RequestPacket->OutputBuffer;

    /*
     * For each mode supported by the card, store the mode characteristics
     * in the output buffer.
     */
    for (CurrentMode = 0; CurrentMode < QueryPtr->q_number_modes; CurrentMode++, ModeInformation++)
        QuerySingleMode_m(ModeInformation, QueryPtr, CurrentMode);

    return NO_ERROR;

}   /* QueryCurrentMode_m() */



/**************************************************************************
 *
 * static void QuerySingleMode_m(ModeInformation, QueryPtr, ModeIndex);
 *
 * PVIDEO_MODE_INFORMATION ModeInformation; Table to be filled in
 * struct query_structure *QueryPtr;        Query information for the card
 * ULONG ModeIndex;                         Index of mode table to use
 *
 * DESCRIPTION:
 *  Fill in a single Windows NT mode information table using data from
 *  one of our CRT parameter tables.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  QueryCurrentMode_m() and QueryAvailModes_m()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

static void QuerySingleMode_m(PVIDEO_MODE_INFORMATION ModeInformation,
                              struct query_structure *QueryPtr,
                              ULONG ModeIndex)
{
    struct st_mode_table *CrtTable;     /* Pointer to current mode table */
    CrtTable = (struct st_mode_table *)QueryPtr;
    ((struct query_structure *)CrtTable)++;
    CrtTable += ModeIndex;


    ModeInformation->Length = sizeof(VIDEO_MODE_INFORMATION);
    ModeInformation->ModeIndex = ModeIndex;

    ModeInformation->VisScreenWidth  = CrtTable->m_x_size;
    ModeInformation->VisScreenHeight = CrtTable->m_y_size;

    // * Bytes per line = ((pixels/line) * (bits/pixel)) / (bits/byte))
    ModeInformation->ScreenStride = (CrtTable->m_screen_pitch * CrtTable->m_pixel_depth) / 8;

    ModeInformation->NumberOfPlanes = 1;
    ModeInformation->BitsPerPlane = (USHORT) CrtTable->m_pixel_depth;

    ModeInformation->Frequency = CrtTable->Refresh;

    /*
     * Driver can't measure the screen size,
     * so take reasonable values (16" diagonal).
     */
    ModeInformation->XMillimeter = 320;
    ModeInformation->YMillimeter = 240;

    switch(ModeInformation->BitsPerPlane)
        {
        case 16:
            ModeInformation->RedMask   = 0x0000f800;
            ModeInformation->GreenMask = 0x000007e0;
            ModeInformation->BlueMask  = 0x0000001f;
            ModeInformation->NumberRedBits      = 5;
            ModeInformation->NumberGreenBits    = 6;
            ModeInformation->NumberBlueBits     = 5;
            CrtTable->ColourDepthInfo = PIX_WIDTH_16BPP | ORDER_16BPP_565;
            break;

        case 24:
            /*
             * Windows NT uses RGB as the standard 24BPP mode,
             * so use this ordering for all DACs except the
             * Brooktree 48x which only supports BGR.
             */
            if (QueryPtr->q_DAC_type != DAC_BT48x)
                {
                ModeInformation->RedMask   = 0x00ff0000;
                ModeInformation->GreenMask = 0x0000ff00;
                ModeInformation->BlueMask  = 0x000000ff;
                CrtTable->ColourDepthInfo = PIX_WIDTH_24BPP | ORDER_24BPP_RGB;
                }
            else{
                ModeInformation->RedMask   = 0x000000ff;
                ModeInformation->GreenMask = 0x0000ff00;
                ModeInformation->BlueMask  = 0x00ff0000;
                CrtTable->ColourDepthInfo = PIX_WIDTH_24BPP | ORDER_24BPP_BGR;
                }
            ModeInformation->NumberRedBits      = 8;
            ModeInformation->NumberGreenBits    = 8;
            ModeInformation->NumberBlueBits     = 8;
            break;

        case 32:
            /*
             * Only the Brooktree 481 requires BGR,
             * and it doesn't support 32BPP.
             */
            ModeInformation->RedMask   = 0xff000000;
            ModeInformation->GreenMask = 0x00ff0000;
            ModeInformation->BlueMask  = 0x0000ff00;
            ModeInformation->NumberRedBits      = 8;
            ModeInformation->NumberGreenBits    = 8;
            ModeInformation->NumberBlueBits     = 8;
            CrtTable->ColourDepthInfo = PIX_WIDTH_24BPP | ORDER_24BPP_RGBx;
            break;

        default:
            ModeInformation->RedMask   = 0x00000000;
            ModeInformation->GreenMask = 0x00000000;
            ModeInformation->BlueMask  = 0x00000000;
            ModeInformation->NumberRedBits      = 6;
            ModeInformation->NumberGreenBits    = 6;
            ModeInformation->NumberBlueBits     = 6;
            CrtTable->ColourDepthInfo = PIX_WIDTH_8BPP;
            break;
        }

    ModeInformation->AttributeFlags = VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS;

    if (CrtTable->m_pixel_depth <= 8)
        {
        ModeInformation->AttributeFlags |= VIDEO_MODE_PALETTE_DRIVEN |
            VIDEO_MODE_MANAGED_PALETTE;
        }

    /*
     * Bit 4 of the m_disp_cntl field is set for interlaced and
     * cleared for noninterlaced.
     *
     * The display applet gets confused if some of the "Use hardware
     * default" modes are interlaced and some are noninterlaced
     * (two "Use hardware default" entries are shown in the refresh
     * rate list). To avoid this, report all mode tables stored in
     * the EEPROM as noninterlaced, even if they are interlaced.
     * "Canned" mode tables give true reports.
     */
    if ((CrtTable->m_disp_cntl & 0x010) && (ModeInformation->Frequency != DEFAULT_REFRESH))
        ModeInformation->AttributeFlags |= VIDEO_MODE_INTERLACED;
    else
        ModeInformation->AttributeFlags &= ~VIDEO_MODE_INTERLACED;

    /*
     * Fill in the video memory bitmap width and height fields.
     * The descriptions are somewhat ambiguous - assume that
     * "bitmap width" is the same as ScreenStride (bytes from
     * start of one scanline to start of the next) and "bitmap
     * height" refers to the number of complete scanlines which
     * will fit into video memory.
     */
    ModeInformation->VideoMemoryBitmapWidth = ModeInformation->ScreenStride;
    ModeInformation->VideoMemoryBitmapHeight = (QueryPtr->q_memory_size * QUARTER_MEG) / ModeInformation->VideoMemoryBitmapWidth;

    return;

}   /* QuerySingleMode_m() */

//
//  When coming back from hibernate, mach32s can lock up and blackscreen.
//  This is because the card itself has to be reinitialized.
//  This initialization include at least the frame buffer initialization
//  and the initialization of the use of memory mapped registers.
//

VOID
EnableMach32FrameBufferAndMemMappedRegisters(
    PHW_DEVICE_EXTENSION pHwDeviceExtension
    )
{
    USHORT temp, temp1;

    //
    // enable the framebuffer.
    //

    temp = INPW(MEM_CFG) & 0x0fffc;     /* Preserve bits 2-15 */
    temp  |= 0x0002;                     /* 4M aperture        */
    OUTPW(MEM_CFG, temp);

    //
    // enable memory mapped register use.
    // save SRC_X ???

    OUTPW(SRC_X, 0x0AAAA);
    temp = INPW(R_SRC_X);
    if (temp  != 0x02AA)
       VideoDebugPrint((DEBUG_NORMAL, "Can't use memory mapped ranges, read %x\n", temp));

    temp1 = INPW(LOCAL_CONTROL);
    temp1 |= 0x0020;   // Enable memory mapped registers
    OUTPW(LOCAL_CONTROL, temp1);

    //restore SRC_X???: OUTPW(SRC_X, temp);
}


/**************************************************************************
 *
 * void SetCurrentMode_m(QueryPtr, CrtTable);
 *
 * struct query_structure *QueryPtr;    Query information for the card
 * struct st_mode_table *CrtTable;      CRT parameter table for desired mode
 *
 * DESCRIPTION:
 *  Switch into the specified video mode.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  IOCTL_VIDEO_SET_CURRENT_MODE packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *  1994 01 13  Added initialization of bank manager
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void SetCurrentMode_m(struct query_structure *QueryPtr, struct st_mode_table *CrtTable)
{
    WORD MiscOptions;   /* Contents of MISC_OPTIONS register */
    USHORT Scratch, USTemp;     /* Temporary variable */

    //
    //  When coming back from hibernate, mach32s can lock up and blackscreen.
    //  This is because the card itself has to be reinitialized.
    //  This initialization include at least the frame buffer initialization
    //  and the initialization of the use of memory mapped registers.
    //

    if (phwDeviceExtension->ModelNumber == MACH32_ULTRA)
        {
        // enable the framebuffer.
        Scratch = INPW(MEM_CFG) & 0x0fffc;     /* Preserve bits 2-15 */
        Scratch  |= 0x0002;                     /* 4M aperture        */
        OUTPW(MEM_CFG, Scratch);

        // enable memory mapped register use.
        // save SRC_X ???
        OUTPW(SRC_X, 0x0AAAA);
        Scratch = INPW(R_SRC_X);
        if (Scratch  != 0x02AA)
           VideoDebugPrint((DEBUG_NORMAL, "Can't use memory mapped ranges, read %x\n", Scratch));

        USTemp = INPW(LOCAL_CONTROL);
        USTemp |= 0x0020;   // Enable memory mapped registers
        OUTPW(LOCAL_CONTROL, USTemp);
        //restore SRC_X???: OUTPW(SRC_X, Scratch);
        }


    /*
     * Put the DAC in a known state before we start.
     */
    UninitTiDac_m();

    Passth8514_m(SHOW_ACCEL);    // turn vga pass through off

    /*
     * On cards with the "MISC_OPTIONS doesn't report video memory size
     * correctly" bug, reset MISC_OPTIONS to show the true amount of
     * video memory. This is done here rather than when we determine
     * how much memory is present in order to avoid trashing the "blue
     * screen" (no adverse effects on operation, but would generate
     * large numbers of user complaints).
     */
    if (((QueryPtr->q_asic_rev == CI_68800_6) || (QueryPtr->q_asic_rev == CI_68800_AX)) &&
        (QueryPtr->q_VGA_type == 1) &&
        ((QueryPtr->q_memory_type == VMEM_DRAM_256Kx4) ||
         (QueryPtr->q_memory_type == VMEM_DRAM_256Kx16) ||
         (QueryPtr->q_memory_type == VMEM_DRAM_256Kx4_GRAP)))
        {
        MiscOptions = INPW(MISC_OPTIONS) & MEM_SIZE_STRIPPED;

        switch (QueryPtr->q_memory_size)
            {
            case VRAM_512k:
                MiscOptions |= MEM_SIZE_512K;
                break;

            case VRAM_1mb:
                MiscOptions |= MEM_SIZE_1M;
                break;

            case VRAM_2mb:
                MiscOptions |= MEM_SIZE_2M;
                break;

            case VRAM_4mb:
                MiscOptions |= MEM_SIZE_4M;
                break;
            }
        OUTPW(MISC_OPTIONS, MiscOptions);
        }

    setmode_m(CrtTable, (ULONG_PTR) &(phwDeviceExtension->RomBaseRange), (ULONG) phwDeviceExtension->ModelNumber);

    /*
     * On a Mach 8 card, 1280x1024 can only be done in split
     * pixel mode. If we are running on a Mach 8, and this
     * resolution was selected, go into split pixel mode.
     *
     * Bit 4 of EXT_GE_CONFIG is set for split pixel mode and
     * clear for normal mode. Bit 3 must be set, since clearing
     * it accesses EEPROM read/write mode.
     */
    if    ((phwDeviceExtension->ModelNumber == _8514_ULTRA)
        || (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA))
        {
        if (QueryPtr->q_desire_x == 1280)
                OUTPW(EXT_GE_CONFIG, 0x0018);
        else    OUTPW(EXT_GE_CONFIG, 0x0008);
        }

    /*
     * Default to 8 bits per pixel. Modes which require a different
     * setting will change this in the init_ti_<depth>_m() function.
     */
    OUTP(DAC_MASK, 0xff);

    if (phwDeviceExtension->ModelNumber == MACH32_ULTRA)
        {
        switch (CrtTable->m_pixel_depth)    // program the DAC for the
            {                               // other resolutions
            case 4:
            case 8:
                InitTi_8_m((WORD)(CrtTable->ColourDepthInfo | 0x0a));
                break;

            case 16:
                InitTi_16_m((WORD)(CrtTable->ColourDepthInfo | 0x0a), (ULONG_PTR) &(phwDeviceExtension->RomBaseRange));   /* 16 bit 565 */
                break;

            case 24:
            case 32:
                /*
                 * RGB/BGR and 24/32 bit mode information is
                 * stored in CrtTable->ColourDepthInfo.
                 */
                InitTi_24_m((WORD)(CrtTable->ColourDepthInfo | 0x0a), (ULONG_PTR) &(phwDeviceExtension->RomBaseRange));
                break;
            }
        }

    /*
     * If we are going to be using the VGA aperture on a Mach 32,
     * initialize the bank manager by saving the ATI extended register
     * values and putting the VGA controller into packed pixel mode.
     *
     * We can't identify this case by looking at
     * phwDeviceExtension->FrameLength because it is set to 0x10000
     * when the VGA aperture is being used in the
     * IOCTL_VIDEO_MAP_VIDEO_MEMORY packet which may or may not
     * have been called by the time we reach this point.
     */
    if ((phwDeviceExtension->ModelNumber == MACH32_ULTRA) &&
        (QueryPtr->q_aperture_cfg == 0) &&
        (QueryPtr->q_VGA_type == 1))
        {
        for (Scratch = 0; Scratch <= 2; Scratch++)
            {
            OUTP(reg1CE, (BYTE)(SavedExtRegs[Scratch] & 0x00FF));
            SavedExtRegs[Scratch] = (SavedExtRegs[Scratch] & 0x00FF) | (INP(reg1CF) << 8);
            }
        OUTPW(HI_SEQ_ADDR, 0x0F02);
        OUTPW(HI_SEQ_ADDR, 0x0A04);
        OUTPW(reg3CE, 0x1000);
        OUTPW(reg3CE, 0x0001);
        OUTPW(reg3CE, 0x0002);
        OUTPW(reg3CE, 0x0003);
        OUTPW(reg3CE, 0x0004);
        OUTPW(reg3CE, 0x0005);
        OUTPW(reg3CE, 0x0506);
        OUTPW(reg3CE, 0x0F07);
        OUTPW(reg3CE, 0xFF08);
        OUTPW(reg1CE, 0x28B0);  /* Enable 256 colour, 1M video RAM */
        OUTPW(reg1CE, 0x04B6);  /* Select linear addressing */
        OUTP(reg1CE, 0xBE);
        OUTPW(reg1CE, (WORD)(((INP(reg1CF) & 0xF7) << 8) | 0xBE));
        }


    /*
     * phwDeviceExtension->ReInitializing becomes TRUE in
     * IOCTL_VIDEO_SET_COLOR_REGISTERS packet of ATIMPStartIO().
     *
     * If this is not the first time we are switching into graphics
     * mode, set the palette to the last set of colours that was
     * selected while in graphics mode.
     */
    if (phwDeviceExtension->ReInitializing)
        {
        SetPalette_m(phwDeviceExtension->Clut,
                     phwDeviceExtension->FirstEntry,
                     phwDeviceExtension->NumEntries);
        }

    /*
     * Clear visible screen.
     *
     * 24 and 32 BPP would require a q_desire_y value beyond the
     * maximum allowable clipping value (1535) if we clear the screen
     * using a normal blit. Since these pixel depths are only supported
     * up to 800x600, we can fake it by doing a 16BPP blit of double the
     * screen height, clipping the special case of 640x480 24BPP on
     * a 1M card (this is the only true colour mode that will fit in
     * 1M, so if we hit this case on a 1M card, we know which mode
     * we're dealing with) to avoid running off the end of video memory.
     */
    if (CrtTable->m_pixel_depth >= 24)
        {
        /*
         * Save the colour depth configuration and switch into 16BPP
         */
        Scratch = INPW(R_EXT_GE_CONFIG);
        OUTPD(EXT_GE_CONFIG, (Scratch & 0xFFCF) | PIX_WIDTH_16BPP);

        CheckFIFOSpace_m(SIXTEEN_WORDS);

        OUTPW(DP_CONFIG, 0x2011);
        OUTPW(ALU_FG_FN, 0x7);          // Paint
        OUTPW(FRGD_COLOR, 0);	        // Black
        OUTPW(CUR_X, 0);
        OUTPW(CUR_Y, 0);
        OUTPW(DEST_X_START, 0);
        OUTPW(DEST_X_END, QueryPtr->q_desire_x);

        if (QueryPtr->q_memory_size == VRAM_1mb)
            OUTPW(DEST_Y_END, 720);     /* Only 640x480 24BPP will fit in 1M */
        else
            OUTPW(DEST_Y_END, (WORD)(2*(QueryPtr->q_desire_y)));

        /*
         * Let the blit finish then restore the colour depth configuration
         */
        WaitForIdle_m();
        OUTPD(EXT_GE_CONFIG, Scratch);

        }
    else{
        /*
         * Other colour depths can be handled by a normal blit, and the
         * LFB may not be available, so use a blit to clear the screen.
         */
        CheckFIFOSpace_m(SIXTEEN_WORDS);

        OUTPW(DP_CONFIG, 0x2011);
        OUTPW(ALU_FG_FN, 0x7);          // Paint
        OUTPW(FRGD_COLOR, 0);	        // Black
        OUTPW(CUR_X, 0);
        OUTPW(CUR_Y, 0);
        OUTPW(DEST_X_START, 0);
        OUTPW(DEST_X_END, QueryPtr->q_desire_x);
        OUTPW(DEST_Y_END, QueryPtr->q_desire_y);
        }

#if 0
    /*
     * In 800x600 24BPP, set the offset to start 1 pixel into video
     * memory to avoid screen tearing. The MAP_VIDEO_MEMORY packet
     * must adjust the framebuffer base to compensate for this.
     */
    if ((QueryPtr->q_desire_x == 800) && (QueryPtr->q_pix_depth == 24))
        {
        OUTPW(CRT_OFFSET_LO, 3);
        }
    else
        {
        OUTPW(CRT_OFFSET_HI, 0);
        }
#endif

    WaitForIdle_m();

    return;

}   /* SetCurrentMode_m() */



/**************************************************************************
 *
 * void ResetDevice_m(void);
 *
 * DESCRIPTION:
 *  Reset the accelerator to allow the VGA miniport to switch
 *  into a VGA mode.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  IOCTL_VIDEO_RESET_DEVICE packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void ResetDevice_m(void)
{
    VIDEO_X86_BIOS_ARGUMENTS Registers; /* Used in VideoPortInt10() calls */

    /*
     * If we are using the VGA aperture on a Mach 32, put its
     * VGA controller into planar mode.
     */
    if (phwDeviceExtension->FrameLength == 0x10000)
        {
        OUTPW(reg1CE, SavedExtRegs[0]);
        OUTPW(reg1CE, SavedExtRegs[1]);
        OUTPW(reg1CE, SavedExtRegs[2]);
        OUTP(reg1CE, 0xBE);
        OUTPW(reg1CE, (WORD)(((INP(reg1CF) & 0xF7) << 8) | 0xBE));
        }
    UninitTiDac_m();
    Passth8514_m(SHOW_VGA);

    VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
    Registers.Eax = 0x0003;         // set text mode 3
    VideoPortInt10(phwDeviceExtension, &Registers);

}   /* ResetDevice_m() */



/**************************************************************************
 *
 * VP_STATUS SetPowerManagement_m(QueryPtr, DpmsState);
 *
 * struct query_structure *QueryPtr;    Query information for the card
 * DWORD DpmsState;                     Desired DPMS state
 *                                      (VIDEO_POWER_STATE enumeration)
 *
 * DESCRIPTION:
 *  Switch into the desired DPMS state.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  ERROR_INVALID_PARAMETER if invalid state requested.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  IOCTL_VIDEO_SET_POWER_MANAGEMENT packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS SetPowerManagement_m(struct query_structure *QueryPtr, DWORD DpmsState)
{
    struct st_mode_table *CrtTable; /* Mode table, used to obtain sync values */

    /*
     * Only accept valid states.
     */
    if ((DpmsState < VideoPowerOn) || (DpmsState > VideoPowerOff))
        return ERROR_INVALID_PARAMETER;

    /*
     * Set CrtTable to point to the mode table associated with the
     * selected mode.
     *
     * When a pointer to a structure is incremented by an integer,
     * the integer represents the number of structure-sized blocks
     * to skip over, not the number of bytes to skip over.
     */
    CrtTable = (struct st_mode_table *)QueryPtr;
    ((struct query_structure *)CrtTable)++;
    CrtTable += phwDeviceExtension->ModeIndex;

    SavedDPMSState = DpmsState;

    /*
     * Mach 32 rev. 6 and later supports turning the sync signals on and off
     * through the HORZ_OVERSCAN registers, but some chips that report as
     * rev. 6 don't have this implemented. Also, Mach 32 rev. 3 and Mach 8
     * don't support this mechanism.
     *
     * Disabling the sync by setting it to start after the total will work
     * for all chips. Most chips will de-synchronize if the sync is set
     * to 1 more than the total, but some need higher values. To be sure
     * of de-synchronizing, set the disabled sync signal to start at
     * the highest possible value.
     */
    switch (DpmsState)
        {
        case VideoPowerOn:
            OUTP(H_SYNC_STRT,	CrtTable->m_h_sync_strt);
            OUTPW(V_SYNC_STRT,	CrtTable->m_v_sync_strt);
            break;

        case VideoPowerStandBy:
            OUTP(H_SYNC_STRT,	0xFF);
            OUTPW(V_SYNC_STRT,	CrtTable->m_v_sync_strt);
            break;

        case VideoPowerSuspend:
            OUTP(H_SYNC_STRT,	CrtTable->m_h_sync_strt);
            OUTPW(V_SYNC_STRT,	0x0FFF);
            break;

        case VideoPowerOff:
            OUTP(H_SYNC_STRT,	0xFF);
            OUTPW(V_SYNC_STRT,	0x0FFF);
            break;

        /*
         * This case should never happen, because the initial
         * acceptance of only valid states should have already
         * rejected anything that will appear here.
         */
        default:
            break;
        }
        return NO_ERROR;

}   /* SetPowerManagement_m() */


DWORD GetPowerManagement_m(PHW_DEVICE_EXTENSION phwDeviceExtension)
/*
 * DESCRIPTION:
 *  Report which DPMS state we are in.
 *
 * PARAMETERS:
 *  phwDeviceExtension  Points to per-adapter device extension.
 *
 * RETURN VALUE:
 *  Current DPMS state (VIDEO_POWER_STATE enumeration).
 */
{
    ASSERT(phwDeviceExtension != NULL);

    /*
     * On the Mach 8, the sync start registers are write-only, so
     * we can't check which state we are in. For this reason, we
     * have saved the state we switched into using SetPowerManagement_m().
     * On the Mach 32, we can either use this saved state or read
     * the sync start registers, but using the same method as for
     * the Mach 8 reduces complexity.
     */
    return SavedDPMSState;
}   /* GetPowerManagement_m() */



/**************************************************************************
 *
 * VP_STATUS ShareVideoMemory_m(RequestPacket, QueryPtr);
 *
 * PVIDEO_REQUEST_PACKET RequestPacket; Request packet with input and output buffers
 * struct query_structure *QueryPtr;    Query information for the card
 *
 * DESCRIPTION:
 *  Allow applications to do direct screen access through DCI.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if failed
 *
 * CALLED BY:
 *  IOCTL_VIDEO_SHARE_VIDEO_MEMORY packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS ShareVideoMemory_m(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr)
{
    PVIDEO_SHARE_MEMORY InputPtr;               /* Pointer to input structure */
    PVIDEO_SHARE_MEMORY_INFORMATION OutputPtr;  /* Pointer to output structure */
    PHYSICAL_ADDRESS ShareAddress;              /* Physical address of video memory */
    PVOID VirtualAddress;                       /* Virtual address to map video memory at */
    ULONG SharedViewSize;                       /* Size of block to share */
    ULONG SpaceType;                            /* Sparse or dense space? */
    VP_STATUS Status;                           /* Status to return */

    /*
     * We can only share the aperture with application programs if there
     * is an aperture available. If both the LFB and the on-board VGA
     * and therefore the VGA aperture) are disabled, report that we
     * can't share the aperture.
     */
    if ((QueryPtr->q_aperture_cfg == 0) && (QueryPtr->q_VGA_type == 0))
        return ERROR_INVALID_FUNCTION;

    InputPtr = RequestPacket->InputBuffer;

    if ((InputPtr->ViewOffset > phwDeviceExtension->VideoRamSize) ||
        ((InputPtr->ViewOffset + InputPtr->ViewSize) > phwDeviceExtension->VideoRamSize))
        {
        VideoDebugPrint((DEBUG_ERROR, "ShareVideoMemory_m() - access beyond video memory\n"));
        return ERROR_INVALID_PARAMETER;
        }

    RequestPacket->StatusBlock->Information = sizeof(VIDEO_SHARE_MEMORY_INFORMATION);

    /*
     * Beware: the input buffer and the output buffer are the same buffer,
     * and therefore data should not be copied from one to the other.
     */
    VirtualAddress = InputPtr->ProcessHandle;
    SharedViewSize = InputPtr->ViewSize;

    SpaceType = 0;
#if defined(_ALPHA_)
    /*
     * Use dense space mapping whenever we can, because that will
     * allow us to support DCI and direct GDI access.
     *
     * Dense space is extremely slow with ISA cards on the newer Alphas,
     * because any byte- or word-write requires a read/modify/write
     * operation, and the ALpha can only ever do 64-bit reads when in
     * dense mode. As a result, these operations would always require
     * 4 reads and 2 writes on the ISA bus. Also, some older Alphas
     * don't support dense space mapping.
     *
     * Any Alpha that supports PCI can support dense space mapping, and
     * because the bus is wider and faster, the read/modify/write has
     * less of an impact on performance.
     */
    if (QueryPtr->q_bus_type == BUS_PCI)
        SpaceType = 4;
#endif

    /*
     * NOTE: we are ignoring ViewOffset
     */
    ShareAddress.QuadPart = phwDeviceExtension->PhysicalFrameAddress.QuadPart;


    /*
     * If the LFB is enabled, use ordinary mapping. If we have only
     * the paged aperture, we must map to banked memory. Since the
     * LFB is always aligned on a 1M boundary (4M boundary for 4M
     * aperture), this check for the paged aperture will never falsely
     * detect a LFB as paged.
     */
    if (phwDeviceExtension->PhysicalFrameAddress.LowPart == 0x0A0000)
        {
        /*
         * On some versions of the DDK, VideoPortMapBankedMemory() is
         * not available. If this is the case, force an error.
         * This routine should be available in all versions of
         * the DDK which support DCI, since it is used for DCI
         * support on cards with banked apertures.
         */
#if defined(IOCTL_VIDEO_SHARE_VIDEO_MEMORY)
        Status = VideoPortMapBankedMemory(
            phwDeviceExtension,
            ShareAddress,
            &SharedViewSize,
            &SpaceType,
            &VirtualAddress,
            0x10000,            /* 64k VGA aperture */
            FALSE,              /* No separate read/write banks */
            BankMap_m,          /* Our bank-mapping routine */
            (PVOID) phwDeviceExtension);
#else
        Status = ERROR_INVALID_FUNCTION;
#endif
        }
    else    /* LFB */
        {
        Status = VideoPortMapMemory(phwDeviceExtension,
                                    ShareAddress,
                                    &SharedViewSize,
                                    &SpaceType,
                                    &VirtualAddress);
        }

    OutputPtr = RequestPacket->OutputBuffer;
    OutputPtr->SharedViewOffset = InputPtr->ViewOffset;
    OutputPtr->VirtualAddress = VirtualAddress;
    OutputPtr->SharedViewSize = SharedViewSize;

    return Status;

}   /* ShareVideoMemory_m() */



/**************************************************************************
 *
 * void BankMap_m(BankRead, BankWrite, Context);
 *
 * ULONG BankRead;       Bank to read
 * ULONG BankWrite;      Bank to write
 * PVOID Context;       Pointer to hardware-specific information
 *
 * DESCRIPTION:
 *  Map the selected bank of video memory into the 64k VGA aperture.
 *  We don't support separate read and write banks, so we use BankWrite
 *  to set the read/write bank, and ignore BankRead.
 *
 * CALLED BY:
 *  This is an entry point, rather than being called
 *  by other miniport functions.
 *
 * NOTE:
 *  This function is called directly by the memory manager during page
 *  fault handling, and so cannot be made pageable.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void BankMap_m(ULONG BankRead, ULONG BankWrite, PVOID Context)
{
    OUTPW( reg1CE, (USHORT)(((BankWrite & 0x0f) << 9) | 0xb2));
    OUTPW( reg1CE, (USHORT)(((BankWrite & 0x30) << 4) | 0xae));

    return;

}   /* BankMap_m() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\makefile.inc ===
atimp.rc: vidlog.rc

vidlog.h vidlog.rc msg00001.bin: vidlog.mc
    mc -v vidlog.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\init_cx.h ===
/************************************************************************/
/*                                                                      */
/*                              INIT_CX.H                               */
/*                                                                      */
/*        Nov 15  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities

  $Revision:   1.6  $
      $Date:   15 May 1996 16:35:10  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/init_cx.h_v  $
 *
 *    Rev 1.6   15 May 1996 16:35:10   RWolff
 * Updated prototype for SetCurrentMode_cx() to allow reporting
 * of failure on mode set.
 *
 *    Rev 1.5   03 Feb 1995 15:16:24   RWOLFF
 * Added prototypes for functions used in DCI support.
 *
 *    Rev 1.4   11 Jan 1995 14:02:48   RWOLFF
 * Added prototype for RestoreMemSize_cx().
 *
 *    Rev 1.3   12 May 1994 11:14:36   RWOLFF
 * Definitions and data structures used by new routine SetModeFromTable_cx()
 *
 *    Rev 1.2   31 Mar 1994 15:05:38   RWOLFF
 * Added prototype for SetPowerManagement_cx().
 *
 *    Rev 1.1   03 Mar 1994 12:37:20   ASHANMUG
 *
 *    Rev 1.0   31 Jan 1994 11:41:50   RWOLFF
 * Initial revision.
 *
 *    Rev 1.0   30 Nov 1993 18:32:58   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
INIT_CX.H - Header file for INIT_CX.C

#endif


/*
 * Prototypes for functions supplied by INIT_CX.C
 */
extern void Initialize_cx(void);
extern VP_STATUS MapVideoMemory_cx(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr);
extern VP_STATUS QueryPublicAccessRanges_cx(PVIDEO_REQUEST_PACKET RequestPacket);
extern VP_STATUS QueryCurrentMode_cx(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr);
extern VP_STATUS QueryAvailModes_cx(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr);
extern VP_STATUS SetCurrentMode_cx(struct query_structure *QueryPtr, struct st_mode_table *CrtTable);
extern void SetPalette_cx(PULONG lpPalette, USHORT StartIndex, USHORT Count);
extern void IdentityMapPalette_cx(void);
extern void ResetDevice_cx(void);
extern VP_STATUS SetPowerManagement_cx(ULONG DpmsState);

DWORD GetPowerManagement_cx(
    PHW_DEVICE_EXTENSION phwDeviceExtension
    );

extern void RestoreMemSize_cx(void);
extern VP_STATUS ShareVideoMemory_cx(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr);
extern void BankMap_cx(ULONG BankRead, ULONG BankWrite, PVOID Context);

#ifdef INCLUDE_INIT_CX
/*
 * Private definitions used in INIT_CX.C
 */

/*
 * Value to put in low byte of cx_bios_set_from_table.cx_bs_mode_select
 * to indicate that this is an accelerator mode.
 */
#define CX_BS_MODE_SELECT_ACC   0x0080

/*
 * Bit fields in cx_bios_set_from_table.cx_bs_flags
 */
#define CX_BS_FLAGS_MUX         0x0400
#define CX_BS_FLAGS_INTERLACED  0x0200
#define CX_BS_FLAGS_ALL_PARMS   0x0010

/*
 * Value to put in high byte of cx_bios_set_from_table.cx_bs_v_sync_wid
 * to force use of the pixel clock frequency in the cx_bs_dot_clock
 * field rather than a divisor/selector pair.
 */
#define CX_BS_V_SYNC_WID_CLK    0xFF00

/*
 * Mode table structure used in setting the video mode using CH=0x81
 * AX=??00 BIOS call.
 *
 * The alignment of fields within the table expected by the BIOS
 * does not match the default structure alignment of the Windows NT
 * C compiler, so we must force byte alignment.
 */
#pragma pack(1)
struct cx_bios_set_from_table{
    WORD cx_bs_reserved_1;      /* Reserved */
    WORD cx_bs_mode_select;     /* Resolution to use */
    WORD cx_bs_flags;           /* Flags to indicate various conditions */
    WORD cx_bs_h_tot_disp;      /* Horizontal total and displayed values */
    WORD cx_bs_h_sync_strt_wid; /* Horizontal sync start and width */
    WORD cx_bs_v_total;         /* Vertical total */
    WORD cx_bs_v_disp;          /* Vertical displayed */
    WORD cx_bs_v_sync_strt;     /* Vertical sync start */
    WORD cx_bs_v_sync_wid;      /* Vertical sync width */
    WORD cx_bs_dot_clock;       /* Pixel clock frequency to use */
    WORD cx_bs_h_overscan;      /* Horizontal overscan information */
    WORD cx_bs_v_overscan;      /* Vertical overscan information */
    WORD cx_bs_overscan_8b;     /* 8BPP and blue overscan colour */
    WORD cx_bs_overscan_gr;     /* Green and red overscan colour */
    WORD cx_bs_reserved_2;      /* Reserved */
};
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\modes_m.h ===
/************************************************************************/
/*                                                                      */
/*                              MODES_M.H                               */
/*                                                                      */
/*        Aug 25  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities

  $Revision:   1.0  $
      $Date:   31 Jan 1994 11:42:30  $
	$Author:   RWOLFF  $
	   $Log:   S:/source/wnt/ms11/miniport/vcs/modes_m.h  $
 *
 *    Rev 1.0   31 Jan 1994 11:42:30   RWOLFF
 * Initial revision.
 *
 *    Rev 1.2   14 Jan 1994 15:23:04   RWOLFF
 * Added definitions and data for SetTextMode_m()
 *
 *    Rev 1.1   08 Oct 1993 11:11:50   RWOLFF
 * Added "_m" to function names to identify them as being specific to the
 * 8514/A-compatible family of ATI accelerators.
 *
 *    Rev 1.0   03 Sep 1993 14:28:44   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
MODES_M.H - Header file for MODES_M.C

#endif


/*
 * Card-independent definitions for mode setting.
 */
#define SHOW_VGA    1   /* Display driven by VGA */
#define SHOW_ACCEL  0   /* Display driven by accelerator */

/*
 * Prototypes for mode setting functions.
 */
extern void setmode_m(struct st_mode_table *, ULONG_PTR, ULONG);
extern void Passth8514_m(int status);
extern void InitTi_8_m(WORD ext_ge_config);
extern void InitTi_16_m(WORD ext_ge_config, ULONG_PTR rom_address);
extern void InitTi_24_m(WORD ext_ge_config, ULONG_PTR rom_address);
extern void UninitTiDac_m(void);
extern void SetPalette_m(PULONG lpPalette, USHORT StartIndex, USHORT Count);
extern void SetTextMode_m(void);

/*
 * Definitions and data structures used internally by MODES_M.C
 */
#ifdef INCLUDE_MODES_M

/*
 * Red, Green, and Blue values for the default 16 colurs in VGA
 * 80x25 text mode. On the DEC ALPHA, the RGB ordering is reversed.
 */
unsigned char TextDAC_m[0x10*3] =
{
#if defined (ALPHA) || defined (_ALPHA_)
    0x00, 0x00, 0x00,   /* Black */
    0x2A, 0x00, 0x00,   /* Blue */
    0x00, 0x2A, 0x00,   /* Green */
    0x2A, 0x2A, 0x00,   /* Cyan */
    0x00, 0x00, 0x2A,   /* Red */
    0x2A, 0x00, 0x2A,   /* Magenta */
    0x00, 0x15, 0x2A,   /* Brown */
    0x2A, 0x2A, 0x2A,   /* White */
    0x15, 0x15, 0x15,   /* Grey */
    0x3F, 0x15, 0x15,   /* High intensity Blue */
    0x15, 0x3F, 0x15,   /* High intensity Green */
    0x3F, 0x3F, 0x15,   /* High intensity Cyan */
    0x15, 0x15, 0x3F,   /* High intensity Red */
    0x3F, 0x15, 0x3F,   /* High intensity Magenta */
    0x15, 0x3F, 0x3F,   /* Yellow */
    0x3F, 0x3F, 0x3F    /* High intensity White */
#else
    0x00, 0x00, 0x00,   /* Black */
    0x00, 0x00, 0x2A,   /* Blue */
    0x00, 0x2A, 0x00,   /* Green */
    0x00, 0x2A, 0x2A,   /* Cyan */
    0x2A, 0x00, 0x00,   /* Red */
    0x2A, 0x00, 0x2A,   /* Magenta */
    0x2A, 0x15, 0x00,   /* Brown */
    0x2A, 0x2A, 0x2A,   /* White */
    0x15, 0x15, 0x15,   /* Grey */
    0x15, 0x15, 0x3F,   /* High intensity Blue */
    0x15, 0x3F, 0x15,   /* High intensity Green */
    0x15, 0x3F, 0x3F,   /* High intensity Cyan */
    0x3F, 0x15, 0x15,   /* High intensity Red */
    0x3F, 0x15, 0x3F,   /* High intensity Magenta */
    0x3F, 0x3F, 0x15,   /* Yellow */
    0x3F, 0x3F, 0x3F    /* High intensity White */
#endif
};


/*
 * Indices into StdTextCRTC_m[] array
 */
#define S_PARM      5                   /* Start of sequencer parameters */
#define S_LEN       4                   /* Number of sequencer parameters */
#define MIS_PARM    S_PARM + S_LEN      /* Start of miscelaneous parameters */
#define MIS_LEN     1                   /* Number of miscelaneous parameters */
#define C_PARM      MIS_PARM + MIS_LEN  /* Start of CRTC parameters */
#define C_LEN       0x19                /* Number of CRTC parameters */
#define A_PARM      C_PARM + C_LEN      /* Start of attribute parameters */
#define A_LEN       0x14                /* Number of attribute parameters */
#define G_PARM      A_PARM + A_LEN      /* Start of Graphics parameters */
#define G_LEN       0x09                /* Number of graphics parameters */

/*
 * Values written to the standard VGA registers when switching into
 * 80x25 16 colour text mode.
 */
unsigned char StdTextCRTC_m[0x40] =
{
    0x50, 0x18, 0x10,
    0x00, 0x10,
    0x00, 0x03, 0x00, 0x02,
    0x67,
    0x5F, 0x4F, 0x50, 0x82, 0x55, 0x81, 0xBF, 0x1F,
    0x00, 0x4F, 0x0D, 0x0E, 0x00, 0x00, 0x00, 0x00,
    0x9C, 0x8E, 0x8F, 0x28, 0x1F, 0x96, 0xB9, 0xA3, 0xFF,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07,
    0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
    0x0C, 0x00, 0x0F, 0x08,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF
};

/*
 * Values written to the ATI extended VGA registers when switching into
 * 80x25 16 colour text mode. Within each triplet of bytes, the first
 * byte is the extended register, the second is the AND mask for the
 * contents of the register, and the third byte is the OR mask. A register
 * value of zero signals that all necessary registers have been programmed.
 */
unsigned char ExtTextCRTC_m[] =
{
    0xB0, 0xC1, 0x00,
    0xB1, 0x87, 0x00,
    0xB2, 0xBE, 0x00,
    0xB5, 0x7F, 0x00,
    0xB6, 0xE7, 0x00,
    0xB8, 0x7F, 0x40,
    0x00
};

/*
 * Font data
 */
unsigned char FontData_m[256*16] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x00 '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0x82, 0x82, 0xAA, 0x82, 0x82, /* 0x01 '' */
    0xC6, 0xBA, 0x82, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xFE, 0xFE, 0xD6, 0xFE, 0xFE, /* 0x02 '' */
    0xBA, 0xC6, 0xFE, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x6C, 0xEE, 0xFE, 0xFE, 0xFE, /* 0x03 '' */
    0xFE, 0x7C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x10, 0x38, 0x7C, 0xFE, 0x7C, /* 0x04 '' */
    0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x10, 0x38, 0x38, 0x10, 0x6C, /* 0x05 '' */
    0xEE, 0x6C, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x10, 0x38, 0x7C, 0x7C, 0xFE, 0xFE, /* 0x06 '' */
    0xFE, 0x6C, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3C, 0x3C, /* 0x07 '' */
    0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC3, 0xC3, /* 0x08 '' */
    0xC3, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    0x00, 0x00, 0x00, 0x00, 0x18, 0x3C, 0x66, 0x66, /* 0x09 <unprintable> */
    0x66, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,

    0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC3, 0x99, 0x99, /* 0x0A '
' */
    0x99, 0xC3, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    0x00, 0x00, 0x1E, 0x0E, 0x1E, 0x36, 0x78, 0xCC, /* 0x0B '' */
    0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x18, /* 0x0C '' */
    0x7E, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x1E, 0x1A, 0x1E, 0x18, 0x18, 0x18, /* 0x0D <unprintable> */
    0x18, 0x78, 0xF8, 0x70, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x3E, 0x36, 0x3E, 0x36, 0x36, 0x76, /* 0x0E '' */
    0xF6, 0x66, 0x0E, 0x1E, 0x0C, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x18, 0xDB, 0x7E, 0x3C, 0x66, 0x66, /* 0x0F '' */
    0x3C, 0x7E, 0xDB, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x80, 0xE0, 0xF0, 0xFC, 0xFE, /* 0x10 '' */
    0xFC, 0xF0, 0xE0, 0x80, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x02, 0x0E, 0x3E, 0x7E, 0xFE, /* 0x11 '' */
    0x7E, 0x3E, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, /* 0x12 '' */
    0x18, 0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, /* 0x13 '' */
    0x66, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7F, 0xDB, 0xDB, 0xDB, 0xDB, 0x7B, /* 0x14 '' */
    0x1B, 0x1B, 0x1B, 0x1B, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x60, 0x7C, 0xF6, /* 0x15 '' */
    0xDE, 0x7C, 0x0C, 0xC6, 0xC6, 0x7C, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x16 '' */
    0xFE, 0xFE, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, /* 0x17 '' */
    0x7E, 0x3C, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, /* 0x18 '' */
    0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, /* 0x19 '' */
    0x18, 0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0E, 0xFF, /* 0x1A '' */
    0x0E, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x70, 0xFE, /* 0x1B '' */
    0x70, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0, /* 0x1C '' */
    0xC0, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x66, 0xFF, /* 0x1D '' */
    0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x10, 0x38, 0x38, 0x38, 0x7C, /* 0x1E '' */
    0x7C, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0xFE, 0xFE, 0x7C, 0x7C, 0x7C, /* 0x1F '' */
    0x38, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x20 ' ' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x18, 0x3C, 0x3C, 0x3C, 0x3C, 0x18, /* 0x21 '!' */
    0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x36, 0x36, 0x36, 0x36, 0x14, 0x00, 0x00, /* 0x22 '"' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x6C, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, /* 0x23 '#' */
    0xFE, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x18, 0x18, 0x7C, 0xC6, 0xC0, 0x78, /* 0x24 '$' */
    0x3C, 0x06, 0xC6, 0x7C, 0x18, 0x18, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x66, 0x0C, /* 0x25 '%' */
    0x18, 0x30, 0x66, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x38, 0x6C, 0x38, 0x30, 0x76, 0x7E, /* 0x26 '&' */
    0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x0C, 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, /* 0x27 ''' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, /* 0x28 '(' */
    0x30, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x0C, /* 0x29 ')' */
    0x0C, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0x38, 0xFE, /* 0x2A '*' */
    0x38, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, /* 0x2B '+' */
    0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x2C ',' */
    0x00, 0x0C, 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, /* 0x2D '-' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x2E '.' */
    0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x0C, 0x18, /* 0x2F '/' */
    0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xD6, 0xD6, /* 0x30 '0' */
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x18, 0x78, 0x18, 0x18, 0x18, 0x18, /* 0x31 '1' */
    0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x06, 0x0C, 0x18, /* 0x32 '2' */
    0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0x06, 0x06, 0x3C, 0x06, /* 0x33 '3' */
    0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xCC, /* 0x34 '4' */
    0xFE, 0x0C, 0x0C, 0x1E, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xFE, 0xC0, 0xC0, 0xC0, 0xFC, 0x06, /* 0x35 '5' */
    0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC0, 0xFC, 0xC6, /* 0x36 '6' */
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xFE, 0xC6, 0x06, 0x0C, 0x18, 0x30, /* 0x37 '7' */
    0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0xC6, /* 0x38 '8' */
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, /* 0x39 '9' */
    0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00, /* 0x3A ':' */
    0x00, 0x0C, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00, /* 0x3B ';' */
    0x00, 0x0C, 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x0C, 0x18, 0x30, 0x60, 0xC0, /* 0x3C '<' */
    0x60, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, /* 0x3D '=' */
    0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, /* 0x3E '>' */
    0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x0C, 0x18, 0x18, /* 0x3F '?' */
    0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xDE, 0xDE, /* 0x40 '@' */
    0xDE, 0xDC, 0xC0, 0x7E, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0xFE, /* 0x41 'A' */
    0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66, /* 0x42 'B' */
    0x66, 0x66, 0x66, 0xFC, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC0, /* 0x43 'C' */
    0xC0, 0xC2, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66, /* 0x44 'D' */
    0x66, 0x66, 0x6C, 0xF8, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xFE, 0x66, 0x60, 0x64, 0x7C, 0x64, /* 0x45 'E' */
    0x60, 0x60, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xFE, 0x66, 0x60, 0x64, 0x7C, 0x64, /* 0x46 'F' */
    0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC0, 0xC0, 0xC0, /* 0x47 'G' */
    0xCE, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xFE, 0xC6, /* 0x48 'H' */
    0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, /* 0x49 'I' */
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, /* 0x4A 'J' */
    0x18, 0xD8, 0xD8, 0x70, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xC6, 0xC6, 0xCC, 0xD8, 0xF0, 0xF0, /* 0x4B 'K' */
    0xD8, 0xCC, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xF0, 0x60, 0x60, 0x60, 0x60, 0x60, /* 0x4C 'L' */
    0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xC6, 0xC6, 0xEE, 0xEE, 0xFE, 0xD6, /* 0x4D 'M' */
    0xD6, 0xD6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xC6, 0xC6, 0xE6, 0xE6, 0xF6, 0xDE, /* 0x4E 'N' */
    0xCE, 0xCE, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, /* 0x4F 'O' */
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x66, 0x7C, /* 0x50 'P' */
    0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, /* 0x51 'Q' */
    0xC6, 0xD6, 0xD6, 0x7C, 0x06, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x78, /* 0x52 'R' */
    0x6C, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC0, 0x70, 0x1C, /* 0x53 'S' */
    0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, /* 0x54 'T' */
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, /* 0x55 'U' */
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, /* 0x56 'V' */
    0xC6, 0x6C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xD6, 0xD6, 0xD6, /* 0x57 'W' */
    0xFE, 0xEE, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x38, /* 0x58 'X' */
    0x6C, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, /* 0x59 'Y' */
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xFE, 0xC6, 0x86, 0x0C, 0x18, 0x30, /* 0x5A 'Z' */
    0x60, 0xC2, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0x60, 0x60, 0x60, 0x60, 0x60, /* 0x5B '[' */
    0x60, 0x60, 0x60, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0x60, 0x30, /* 0x5C '\' */
    0x18, 0x0C, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, /* 0x5D ']' */
    0x0C, 0x0C, 0x0C, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, /* 0x5E '^' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x5F '_' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00,

    0x00, 0x18, 0x18, 0x18, 0x0C, 0x00, 0x00, 0x00, /* 0x60 '`' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0C, 0x7C, /* 0x61 'a' */
    0xCC, 0xCC, 0xDC, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xE0, 0x60, 0x60, 0x7C, 0x66, 0x66, /* 0x62 'b' */
    0x66, 0x66, 0x66, 0xFC, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0, /* 0x63 'c' */
    0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x1C, 0x0C, 0x0C, 0x7C, 0xCC, 0xCC, /* 0x64 'd' */
    0xCC, 0xCC, 0xCC, 0x7E, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, /* 0x65 'e' */
    0xFE, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x1C, 0x36, 0x30, 0x30, 0xFC, 0x30, /* 0x66 'f' */
    0x30, 0x30, 0x30, 0x78, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCE, 0xC6, /* 0x67 'g' */
    0xC6, 0xCE, 0x76, 0x06, 0xC6, 0x7C, 0x00, 0x00,

    0x00, 0x00, 0xE0, 0x60, 0x60, 0x7C, 0x66, 0x66, /* 0x68 'h' */
    0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, /* 0x69 'i' */
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x0C, 0x0C, 0x00, 0x1C, 0x0C, 0x0C, /* 0x6A 'j' */
    0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00, 0x00,

    0x00, 0x00, 0xE0, 0x60, 0x60, 0x66, 0x66, 0x6C, /* 0x6B 'k' */
    0x78, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, /* 0x6C 'l' */
    0x18, 0x18, 0x18, 0x1C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0xFE, 0xD6, /* 0x6D 'm' */
    0xD6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, /* 0x6E 'n' */
    0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, /* 0x6F 'o' */
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, /* 0x70 'p' */
    0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, /* 0x71 'q' */
    0xCC, 0xCC, 0x7C, 0x0C, 0x0C, 0x1E, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x60, /* 0x72 'r' */
    0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0, /* 0x73 's' */
    0x7C, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x30, 0x30, 0x30, 0xFC, 0x30, 0x30, /* 0x74 't' */
    0x30, 0x30, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, /* 0x75 'u' */
    0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6, /* 0x76 'v' */
    0xC6, 0x6C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xD6, /* 0x77 'w' */
    0xD6, 0xD6, 0xFE, 0x6C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0x6C, /* 0x78 'x' */
    0x38, 0x6C, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6, /* 0x79 'y' */
    0xC6, 0xCE, 0x76, 0x06, 0xC6, 0x7C, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x86, 0x0C, /* 0x7A 'z' */
    0x18, 0x30, 0x62, 0xFE, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x0E, 0x18, 0x18, 0x18, 0x70, 0x18, /* 0x7B '{' */
    0x18, 0x18, 0x18, 0x0E, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, /* 0x7C '|' */
    0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x70, 0x18, 0x18, 0x18, 0x0E, 0x18, /* 0x7D '}' */
    0x18, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, /* 0x7E '~' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x38, /* 0x7F '' */
    0x6C, 0x6C, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0xC6, /* 0x80 '' */
    0x66, 0x3C, 0x18, 0x0C, 0xCC, 0x38, 0x00, 0x00,

    0x00, 0x00, 0xC6, 0x00, 0x00, 0xC6, 0xC6, 0xC6, /* 0x81 '' */
    0xC6, 0xC6, 0xCE, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x0C, 0x18, 0x30, 0x00, 0x7C, 0xC6, 0xC6, /* 0x82 '' */
    0xFE, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x30, 0x78, 0xCC, 0x00, 0x78, 0x0C, 0x7C, /* 0x83 '' */
    0xCC, 0xCC, 0xDC, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xCC, 0x00, 0x00, 0x78, 0x0C, 0x7C, /* 0x84 '' */
    0xCC, 0xCC, 0xDC, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x60, 0x30, 0x18, 0x00, 0x78, 0x0C, 0x7C, /* 0x85 '' */
    0xCC, 0xCC, 0xDC, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x38, 0x6C, 0x38, 0x00, 0x78, 0x0C, 0x7C, /* 0x86 '' */
    0xCC, 0xCC, 0xDC, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC0, /* 0x87 '' */
    0xC6, 0x7C, 0x18, 0x0C, 0x6C, 0x38, 0x00, 0x00,

    0x00, 0x30, 0x78, 0xCC, 0x00, 0x7C, 0xC6, 0xC6, /* 0x88 '' */
    0xFE, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xCC, 0x00, 0x00, 0x7C, 0xC6, 0xC6, /* 0x89 '' */
    0xFE, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x30, 0x18, 0x0C, 0x00, 0x7C, 0xC6, 0xC6, /* 0x8A '' */
    0xFE, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x66, 0x00, 0x00, 0x38, 0x18, 0x18, /* 0x8B '' */
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x18, 0x3C, 0x66, 0x00, 0x38, 0x18, 0x18, /* 0x8C '' */
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x60, 0x30, 0x18, 0x00, 0x38, 0x18, 0x18, /* 0x8D '' */
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0xC6, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, /* 0x8E '' */
    0xFE, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x38, 0x6C, 0x38, 0x00, 0x38, 0x6C, 0xC6, 0xC6, /* 0x8F '' */
    0xFE, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x0C, 0x18, 0x30, 0x00, 0xFE, 0x60, 0x60, 0x7C, /* 0x90 '' */
    0x60, 0x60, 0x60, 0xFE, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x66, 0xDB, 0x1B, 0x7F, /* 0x91 '' */
    0xD8, 0xD8, 0xDF, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7E, 0xD8, 0xD8, 0xD8, 0xD8, 0xFE, /* 0x92 '' */
    0xd8, 0xD8, 0xD8, 0xDE, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x30, 0x78, 0xCC, 0x00, 0x7C, 0xC6, 0xC6, /* 0x93 '' */
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xC6, 0x00, 0x00, 0x7C, 0xC6, 0xC6, /* 0x94 '' */
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x30, 0x18, 0x0C, 0x00, 0x7C, 0xC6, 0xC6, /* 0x95 '' */
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x30, 0x78, 0xCC, 0x00, 0xC6, 0xC6, 0xC6, /* 0x96 '' */
    0xC6, 0xC6, 0xCE, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x60, 0x30, 0x18, 0x00, 0xC6, 0xC6, 0xC6, /* 0x97 '' */
    0xC6, 0xC6, 0xCE, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0xC6, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, /* 0x98 '' */
    0xCE, 0x76, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00,

    0x00, 0xC6, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, /* 0x99 '' */
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0xC6, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, /* 0x9A '' */
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x18, 0x18, 0x7C, 0xC6, 0xC0, 0xC0, /* 0x9B '' */
    0xC6, 0x7C, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x38, 0x6C, 0x60, 0x60, 0xF0, 0x60, 0x60, /* 0x9C '' */
    0x60, 0x66, 0xF6, 0x6C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, /* 0x9D '' */
    0x18, 0x3C, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0xFC, 0xC6, 0xC6, 0xFC, 0xC0, 0xCC, 0xDE, /* 0x9E '' */
    0xCC, 0xCC, 0xCC, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x0E, 0x1B, 0x18, 0x18, 0x18, 0x7E, 0x18, /* 0x9F '' */
    0x18, 0x18, 0x18, 0x18, 0xD8, 0x70, 0x00, 0x00,

    0x00, 0x0C, 0x18, 0x30, 0x00, 0x78, 0x0C, 0x7C, /* 0xA0 '' */
    0xCC, 0xCC, 0xDC, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x0C, 0x18, 0x30, 0x00, 0x38, 0x18, 0x18, /* 0xA1 '' */
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x0C, 0x18, 0x30, 0x00, 0x7C, 0xC6, 0xC6, /* 0xA2 '' */
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x18, 0x30, 0x60, 0x00, 0xCC, 0xCC, 0xCC, /* 0xA3 '' */
    0xCC, 0xCC, 0xDC, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x76, 0xDC, 0x00, 0xBC, 0x66, 0x66, /* 0xA4 '' */
    0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x76, 0xBC, 0x00, 0xC6, 0xC6, 0xE6, 0xF6, /* 0xA5 '' */
    0xDE, 0xCE, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x3C, 0x6C, 0x6C, 0x3E, 0x00, 0x7E, 0x00, /* 0xA6 '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x38, 0x6C, 0x6C, 0x38, 0x00, 0x7E, 0x00, /* 0xA7 '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x30, /* 0xA8 '' */
    0x60, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, /* 0xA9 '' */
    0x60, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, /* 0xAA '' */
    0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x60, 0x60, 0x62, 0x66, 0x6C, 0x18, 0x30, /* 0xAB '' */
    0x60, 0xDC, 0x36, 0x0C, 0x18, 0x3E, 0x00, 0x00,

    0x00, 0x60, 0x60, 0x62, 0x66, 0x6C, 0x18, 0x36, /* 0xAC '' */
    0x6E, 0xDE, 0x36, 0x7E, 0x06, 0x06, 0x00, 0x00,

    0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x3C, /* 0xAD '' */
    0x3C, 0x3C, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x6C, 0xD8, /* 0xAE '' */
    0x6C, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xD8, 0x6C, 0x36, /* 0xAF '' */
    0x6C, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, /* 0xB0 '' */
    0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44,

    0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, /* 0xB1 '' */
    0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,

    0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, /* 0xB2 '' */
    0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77,

    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, /* 0xB3 '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, /* 0xB4 '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0xF8, /* 0xB5 '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xF6, /* 0xB6 '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, /* 0xB7 '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0xF8, /* 0xB8 '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x36, 0x36, 0x36, 0x36, 0x36, 0xF6, 0x36, 0xF6, /* 0xB9 '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, /* 0xBA '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x06, 0xF6, /* 0xBB '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x36, 0x36, 0x36, 0x36, 0x36, 0xF6, 0x06, 0xFE, /* 0xBC '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFE, /* 0xBD '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0xF8, /* 0xBE '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, /* 0xBF '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, /* 0xC0 '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, /* 0xC1 '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, /* 0xC2 '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, /* 0xC3 '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, /* 0xC4 '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, /* 0xC5 '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x1F, /* 0xC6 '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, /* 0xC7 '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x3F, /* 0xC8 '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x30, 0x37, /* 0xC9 '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x36, 0x36, 0x36, 0x36, 0x36, 0xF7, 0x00, 0xFF, /* 0xCA '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xF7, /* 0xCB '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x37, /* 0xCC '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, /* 0xCD '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x36, 0x36, 0x36, 0x36, 0x36, 0xF7, 0x00, 0xF7, /* 0xCE '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x00, 0xFF, /* 0xCF '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFF, /* 0xD0 '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, /* 0xD1 '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, /* 0xD2 '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x3F, /* 0xD3 '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x1F, /* 0xD4 '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x1F, /* 0xD5 '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, /* 0xD6 '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFF, /* 0xD7 '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0xFF, /* 0xD8 '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, /* 0xD9 '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, /* 0xDA '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* 0xDB '' */
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0xDC '' */
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, /* 0xDD '' */
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,

    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, /* 0xDE '' */
    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,

    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* 0xDF '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, 0xD8, 0xD8, /* 0xE0 '' */
    0xD8, 0xD8, 0xDC, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x78, 0xCC, 0xCC, 0xD8, 0xFC, 0xC6, /* 0xE1 '' */
    0xC6, 0xC6, 0xC6, 0xCC, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xFE, 0x66, 0x62, 0x60, 0x60, 0x60, /* 0xE2 '' */
    0x60, 0x60, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x6C, 0x6C, /* 0xE3 '' */
    0x6C, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xFE, 0xC6, 0x62, 0x30, 0x18, 0x18, /* 0xE4 '' */
    0x30, 0x62, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0xD8, 0xCC, /* 0xE5 '' */
    0xCC, 0xCC, 0xD8, 0x70, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, /* 0xE6 '' */
    0x66, 0x7C, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, 0x18, /* 0xE7 '' */
    0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xFE, 0x38, 0x38, 0x6C, 0xC6, 0xC6, /* 0xE8 '' */
    0x6C, 0x38, 0x38, 0xFE, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, /* 0xE9 '' */
    0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0xC6, /* 0xEA '' */
    0x6C, 0x6C, 0x6C, 0xEE, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x3E, 0x60, 0x60, 0x3C, 0x66, 0xC6, /* 0xEB '' */
    0xC6, 0xC6, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0xDB, 0xDB, /* 0xEC '' */
    0xDB, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x02, 0x06, 0x7C, 0xCE, 0xDE, 0xF6, /* 0xED '' */
    0xF6, 0x7C, 0x60, 0xC0, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x1C, 0x30, 0x60, 0x60, 0x7C, /* 0xEE '' */
    0x60, 0x60, 0x30, 0x1C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, /* 0xEF '' */
    0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0xFE, /* 0xF0 '' */
    0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, /* 0xF1 '' */
    0x18, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, /* 0xF2 '' */
    0x30, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, /* 0xF3 '' */
    0x0C, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x0C, 0x1E, 0x1A, 0x18, /* 0xF4 '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, /* 0xF5 '' */
    0x18, 0x18, 0x58, 0x78, 0x30, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x7E, /* 0xF6 '' */
    0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, /* 0xF7 '' */
    0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00, 0x00, /* 0xF8 '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, /* 0xF9 '' */
    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0xFA '' */
    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, /* 0xFB '' */
    0xD8, 0xD8, 0x78, 0x38, 0x18, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xD8, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, /* 0xFC '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x70, 0xD8, 0x18, 0x30, 0x60, 0xF8, /* 0xFD '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0x7E, /* 0xFE '' */
    0x7E, 0x7E, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0xFF ''*/
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\init_m.h ===
/************************************************************************/
/*                                                                      */
/*                              INIT_M.H                                */
/*                                                                      */
/*        Sep 27  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities

  $Revision:   1.2  $
      $Date:   03 Feb 1995 15:16:10  $
	$Author:   RWOLFF  $
	   $Log:   S:/source/wnt/ms11/miniport/vcs/init_m.h  $
 *
 *    Rev 1.2   03 Feb 1995 15:16:10   RWOLFF
 * Added prototypes for functions used in DCI support.
 *
 *    Rev 1.1   31 Mar 1994 15:06:00   RWOLFF
 * Added prototype for SetPowerManagement_m().
 *
 *    Rev 1.0   31 Jan 1994 11:42:04   RWOLFF
 * Initial revision.
 *
 *    Rev 1.2   14 Jan 1994 15:22:00   RWOLFF
 * Added prototype for ResetDevice_m(), global variable to store
 * extended register status when initializing bank manager.
 *
 *    Rev 1.1   30 Nov 1993 18:17:36   RWOLFF
 * Added logging of VCS revision comments to comment block at top of file.

End of PolyTron RCS section                             *****************/

#ifdef DOC
INIT_M.H - Header file for INIT_M.C

#endif


/*
 * Prototypes for functions supplied by INIT_M.C
 */
extern void AlphaInit_m(void);
extern void Initialize_m(void);
extern VP_STATUS MapVideoMemory_m(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr);
extern VP_STATUS QueryPublicAccessRanges_m(PVIDEO_REQUEST_PACKET RequestPacket);
extern VP_STATUS QueryCurrentMode_m(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr);
extern VP_STATUS QueryAvailModes_m(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr);
extern void SetCurrentMode_m(struct query_structure *QueryPtr, struct st_mode_table *CrtTable);
extern void ResetDevice_m(void);
extern VP_STATUS SetPowerManagement_m(struct query_structure *QueryPtr, ULONG DpmsState);
DWORD GetPowerManagement_m(PHW_DEVICE_EXTENSION phwDeviceExtension);
extern VP_STATUS ShareVideoMemory_m(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr);
extern void BankMap_m(ULONG BankRead, ULONG BankWrite, PVOID Context);


#ifdef INCLUDE_INIT_M
/*
 * Private definitions and variables used in INIT_M.C
 */

/*
 * Used to reset Mach 32 extended registers before going
 * to full screen DOS.
 */
WORD SavedExtRegs[] = {0x08B0, 0x00B6, 0x00B2};

static DWORD SavedDPMSState = VideoPowerOn;

#endif /* defined INCLUDE_INIT_M */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\modes_m.c ===
/************************************************************************/
/*                                                                      */
/*                               MODES_M.C                              */
/*                                                                      */
/*          (c) 1991,1992, 1993    ATI Technologies Incorporated.       */
/************************************************************************/

/**********************       PolyTron RCS Utilities

    $Revision:   1.18  $
    $Date:   10 Apr 1996 17:00:44  $
    $Author:   RWolff  $
    $Log:   S:/source/wnt/ms11/miniport/archive/modes_m.c_v  $
 *
 *    Rev 1.18   10 Apr 1996 17:00:44   RWolff
 * Microsoft-originated change.
 *
 *    Rev 1.17   23 Jan 1996 11:46:36   RWolff
 * Eliminated level 3 warnings.
 *
 *    Rev 1.16   08 Feb 1995 13:54:38   RWOLFF
 * Updated FIFO depth entries to correspond to more recent table.
 *
 *    Rev 1.15   20 Jan 1995 16:23:04   RWOLFF
 * Optimized video FIFO depth for the installed RAM size and selected
 * resolution, pixel depth, and refresh rate. This gives a slight performance
 * improvement on low-res, low-depth, low frequency modes while eliminating
 * noise on high-res, high-depth, high frequency modes.
 *
 *    Rev 1.14   23 Dec 1994 10:47:24   ASHANMUG
 * ALPHA/Chrontel-DAC
 *
 *    Rev 1.13   18 Nov 1994 11:40:54   RWOLFF
 * Added support for STG1702/1703 in native mode, as opposed to being
 * strapped into STG1700 emulation.
 *
 *    Rev 1.12   19 Aug 1994 17:11:26   RWOLFF
 * Added support for SC15026 DAC and non-standard pixel clock
 * generators, removed dead code.
 *
 *    Rev 1.11   09 Aug 1994 11:53:58   RWOLFF
 * Shifting of colours when setting up palette is now done in
 * display driver.
 *
 *    Rev 1.10   06 Jul 1994 16:23:58   RWOLFF
 * Fix for screen doubling when warm booting from ATI driver to 8514/A
 * driver on Mach 32.
 *
 *    Rev 1.9   30 Jun 1994 18:10:44   RWOLFF
 * Andre Vachon's change: don't clear screen on switch into text mode.
 * The HAL will do it, and we aren't allowed to do the memory mapping
 * needed to clear the screen.
 *
 *    Rev 1.8   20 May 1994 14:00:40   RWOLFF
 * Ajith's change: clears the screen on shutdown.
 *
 *    Rev 1.7   18 May 1994 17:01:18   RWOLFF
 * Fixed colour scramble in 16 and 24BPP on IBM ValuePoint (AT&T 49[123]
 * DAC), got rid of debug print statements and commented-out code.
 *
 *    Rev 1.6   31 Mar 1994 15:07:00   RWOLFF
 * Added debugging code.
 *
 *    Rev 1.5   16 Mar 1994 15:28:02   RWOLFF
 * Now determines DAC type using q_DAC_type field of query structure,
 * rather than raw value from CONFIG_STATUS_1. This allows different
 * DAC types reporting the same value to be distinguished.
 *
 *    Rev 1.4   14 Mar 1994 16:28:10   RWOLFF
 * Routines used by ATIMPResetHw() are no longer swappable, SetTextMode_m()
 * returns after toggling passthrough on Mach 8.
 *
 *    Rev 1.3   10 Feb 1994 16:02:34   RWOLFF
 * Fixed out-of-sync problem in 640x480 16BPP 60Hz.
 *
 *    Rev 1.2   08 Feb 1994 19:00:22   RWOLFF
 * Fixed pixel delay for Brooktree 48x DACs. This corrects flickering pixels
 * at 8BPP and unstable colours at 16 and 24 BPP.
 *
 *    Rev 1.1   07 Feb 1994 14:09:02   RWOLFF
 * Added alloc_text() pragmas to allow miniport to be swapped out when
 * not needed.
 *
 *    Rev 1.0   31 Jan 1994 11:11:36   RWOLFF
 * Initial revision.
 *
 *    Rev 1.10   24 Jan 1994 18:05:36   RWOLFF
 * Now expects mode tables for 16 and 24 BPP on BT48x and AT&T 49[123] DACs
 * to already contain modified pixel clock and other fields, rather than
 * increasing pixel clock frequency when setting the video mode.
 *
 *    Rev 1.9   14 Jan 1994 15:22:36   RWOLFF
 * Added routine to switch into 80x25 16 colour text mode without using BIOS.
 *
 *    Rev 1.8   15 Dec 1993 15:27:32   RWOLFF
 * Added support for SC15021 DAC.
 *
 *    Rev 1.7   30 Nov 1993 18:18:40   RWOLFF
 * Added support for AT&T 498 DAC, 32BPP on STG1700 DAC.
 *
 *    Rev 1.6   10 Nov 1993 19:24:28   RWOLFF
 * Re-enabled MUX handling of 1280x1024 8BPP as special case of InitTi_8_m(),
 * fix for dark DOS full-screen on TI DAC cards.
 *
 *    Rev 1.5   05 Nov 1993 13:26:14   RWOLFF
 * Added support for STG1700 DAC.
 *
 *    Rev 1.4   15 Oct 1993 18:13:18   RWOLFF
 * Fix for memory-mapped scrambled screen.
 *
 *    Rev 1.3   08 Oct 1993 15:18:08   RWOLFF
 * No longer includes VIDFIND.H.
 *
 *    Rev 1.2   08 Oct 1993 11:11:04   RWOLFF
 * Added "_m" to function names to identify them as being specific to the
 * 8514/A-compatible family of ATI accelerators.
 *
 *    Rev 1.1   24 Sep 1993 18:15:08   RWOLFF
 * Added support for AT&T 49x DACs.
 *
 *    Rev 1.1   24 Sep 1993 11:47:14   RWOLFF
 * Added support for AT&T 49x DACs.
 *
 *    Rev 1.0   03 Sep 1993 14:23:48   RWOLFF
 * Initial revision.

           Rev 1.0   16 Aug 1993 13:29:28   Robert_Wolff
        Initial revision.

           Rev 1.18   06 Jul 1993 15:49:46   RWOLFF
        Removed mach32_split_fixup special handling (for non-production hardware),
        added support for AT&T 491 and ATI 68860 DACs. Unable to obtain appropriate
        hardware to test the DAC-related changes, must still add routine to
        distinguish AT&T 491 from Brooktree 48x when setting q_dac_type.

           Rev 1.17   07 Jun 1993 11:43:42   BRADES
        Rev 6 split transfer fixup.

           Rev 1.15   18 May 1993 14:06:04   RWOLFF
        Calls to wait_for_idle() no longer pass in hardware device extension,
        since it's a global variable.

           Rev 1.14   27 Apr 1993 20:16:28   BRADES
        do not use IO register+1 since now from Linear address table.

           Rev 1.13   21 Apr 1993 17:25:22   RWOLFF
        Now uses AMACH.H instead of 68800.H/68801.H.

           Rev 1.12   14 Apr 1993 18:22:26   RWOLFF
        High-colour initialization now supports Bt481 DAC.

           Rev 1.11   08 Apr 1993 16:50:48   RWOLFF
        Revision level as checked in at Microsoft.

           Rev 1.10   15 Mar 1993 22:19:28   BRADES
        use m_screen_pitch for the # pixels per display line.

           Rev 1.9   08 Mar 1993 19:29:30   BRADES
        submit to MS NT

           Rev 1.6   06 Jan 1993 10:59:20   Robert_Wolff
        ROM BIOS area C0000-DFFFF is now mapped as a single block,
        added type casts to eliminate compile warnings.

           Rev 1.5   04 Jan 1993 14:42:18   Robert_Wolff
        Added card type as a parameter to setmode(). This is done because the
        Mach 32 requires GE_PITCH and CRT_PITCH to be set to the horizontal
        resolution divided by 8, while the Mach 8 requires them to be set
        to the smallest multiple of 128 which is not less than the horizontal
        resolution, divided by 8. This difference is only significant for
        800x600, since 640x480, 1024x768, and 1280x1024 all have horizontal
        resolutions which are already multiples of 128 pixels.

           Rev 1.4   09 Dec 1992 10:31:52   Robert_Wolff
        Made setmode() compatible with Mach 8 cards in 800x600 mode, Get_clk_src()
        will now compile properly under both MS-DOS and Windows NT.

           Rev 1.3   27 Nov 1992 15:18:58   STEPHEN
        No change.

           Rev 1.2   17 Nov 1992 14:09:24   GRACE
        program the palette here instead of in a68_init.asm

           Rev 1.1   12 Nov 1992 09:29:04   GRACE
        removed all the excess baggage carried over from the video program.

           Rev 1.0   05 Nov 1992 14:02:22   Robert_Wolff
        Initial revision.



End of PolyTron RCS section                             *****************/

#ifdef DOC
 MODES_M.C -  Functions to switch the 8514/A-compatible family of
                ATI Graphics Accelerator adapters into ALL supported modes
   Note:  Different DACs have a different use for the DAC registers
   in IO space 2EA-2ED.  The DAC_MASK, DAC_R_INDEX may be misleading.


OTHER FILES

#endif


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"
#include "amach.h"
#include "amach1.h"
#include "atimp.h"
#include "detect_m.h"

#define INCLUDE_MODES_M
#include "modes_m.h"
#include "services.h"
#include "setup_m.h"


#define NUM_ROM_BASE_RANGES 2

#if DBG
#if defined(i386) || defined(_X86_)
#define INT	_asm int 3;
#else
#define INT DbgBreakPoint();
#endif
#else
#define INT
#endif



static void InitTIMux_m(int config,ULONG_PTR rom_address);
static BYTE GetClkSrc_m(ULONG *rom_address);
static void SetBlankAdj_m(BYTE adjust);
static void Init68860_m(WORD ext_ge_config);
static void InitSTG1700_m(WORD ext_ge_config, BOOL DoublePixel);
static void InitSTG1702_m(WORD ext_ge_config, BOOL DoublePixel);
static void InitATT498_m(WORD ext_ge_config, BOOL DoublePixel);
static void InitSC15021_m(WORD ext_ge_config, BOOL DoublePixel);
static void InitSC15026_m(WORD ext_ge_config);
static void ReadDac4(void);



/*
 * Allow miniport to be swapped out when not needed.
 *
 * SetTextMode_m() and Passth8514_m() are called by ATIMPResetHw(),
 * which must be in nonpageable memory.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_M, setmode_m)
#pragma alloc_text(PAGE_M, InitTIMux_m)
#pragma alloc_text(PAGE_M, GetClkSrc_m)
#pragma alloc_text(PAGE_M, SetBlankAdj_m)
#pragma alloc_text(PAGE_M, InitTi_8_m)
#pragma alloc_text(PAGE_M, InitTi_16_m)
#pragma alloc_text(PAGE_M, InitTi_24_m)
#pragma alloc_text(PAGE_M, Init68860_m)
#pragma alloc_text(PAGE_M, InitSTG1700_m)
#pragma alloc_text(PAGE_M, InitSTG1702_m)
#pragma alloc_text(PAGE_M, InitATT498_m)
#pragma alloc_text(PAGE_M, InitSC15021_m)
#pragma alloc_text(PAGE_M, InitSC15026_m)
#pragma alloc_text(PAGE_M, ReadDac4)
#pragma alloc_text(PAGE_M, UninitTiDac_m)
#pragma alloc_text(PAGE_M, SetPalette_m)
#endif



/*
 * void Passth8514_m(status)
 *
 * int status;      Desired source for display
 *
 * Turn passthrough off (accelerator mode) if status is SHOW_ACCEL,
 * or on (vga passthrough) if status is SHOW_VGA.
 *
 * Note that this routine is specific to ATI graphics accelerators.
 * Generic 8514/A routine should also include setting up CRT parameters
 * to ensure that the DAC gets a reasonable clock rate.
 */
void Passth8514_m(int status)
{

    OUTP(DISP_CNTL,0x53);		/* disable CRT controller */

    if (status == SHOW_ACCEL)
        {
        OUTPW(ADVFUNC_CNTL,0x7);
        OUTPW(CLOCK_SEL,(WORD)(INPW(CLOCK_SEL)|1));     /* slow down the clock rate */
        }
    else
        {
        OUTPW(ADVFUNC_CNTL,0x6);
        OUTPW(CLOCK_SEL,(WORD)(INPW(CLOCK_SEL)&0xfffe));    /* speed up the clock rate */
        }
    OUTP(DISP_CNTL,0x33);		/* enable CRT controller */

    return;

}   /* Passth8514_m() */



/*
 * void setmode_m(crttable, rom_address, CardType);
 *
 * struct st_mode_table *crttable;  CRT parameters for desired mode
 * ULONG_PTR rom_address;           Location of ROM BIOS (virtual address)
 * ULONG CardType;                  Type of ATI accelerator
 *
 * Initialize the CRT controller in the 8514/A-compatible
 * family of ATI accelerators.
 */
void setmode_m (struct st_mode_table *crttable, ULONG_PTR rom_address, ULONG CardType)
{
    BYTE clock;
    WORD overscan;
    BYTE low,high;
    WORD ClockSelect;   /* Value to write to CLOCK_SEL register */
    struct query_structure *QueryPtr;   /* Query information for the card */
    ULONG BaseClock;    /* Pixel rate not adjusted for DAC type and pixel depth */

    /*
     * Get a formatted pointer into the query section of HwDeviceExtension.
     * The CardInfo[] field is an unformatted buffer.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);

    ClockSelect = (crttable->m_clock_select & CLOCK_SEL_STRIP) | GetShiftedSelector(crttable->ClockFreq);

    WaitForIdle_m();

    OUTP(SHADOW_SET, 2);                    /* unlock shadows */
    DEC_DELAY
    DEC_DELAY
    OUTP(SHADOW_CTL, 0);
    DEC_DELAY
    OUTP(SHADOW_SET, 1);
    DEC_DELAY
    OUTP(SHADOW_CTL, 0);
    DEC_DELAY
    OUTP(SHADOW_SET, 0);
    DEC_DELAY

    /* disable CRT controller */

    OUTP(DISP_CNTL,0x53);
    delay(10);

    OUTP(CLOCK_SEL,	(UCHAR)(ClockSelect | 0x01 ));  /* Disable passthrough */
    DEC_DELAY
    OUTP(V_SYNC_WID,	crttable->m_v_sync_wid);
    DEC_DELAY
    OUTPW(V_SYNC_STRT,	crttable->m_v_sync_strt);
    DEC_DELAY
    OUTPW(V_DISP,	crttable->m_v_disp);
    DEC_DELAY
    OUTPW(V_TOTAL,	crttable->m_v_total);
    DEC_DELAY
    OUTP(H_SYNC_WID,	crttable->m_h_sync_wid);
    DEC_DELAY
    OUTP(H_SYNC_STRT,	crttable->m_h_sync_strt);
    DEC_DELAY
    OUTP(H_DISP,	crttable->m_h_disp);
    DEC_DELAY
    OUTP(H_TOTAL,	crttable->m_h_total);
    DEC_DELAY

    OUTP(GE_PITCH,  (UCHAR) (crttable->m_screen_pitch >> 3));
    DEC_DELAY
    OUTP(CRT_PITCH, (UCHAR) (crttable->m_screen_pitch >> 3));
    delay(10);

    OUTP(DISP_CNTL,	crttable->m_disp_cntl);
    delay(10);

    /*
     * Set up the Video FIFO depth. This field is used only on DRAM cards.
     * Since the required FIFO depth depends on 4 values (memory size,
     * pixel depth, resolution, and refresh rate) which are not enumerated
     * types, implementing the selection as an array indexed by these
     * values would require a very large, very sparse array.
     *
     * Select DRAM cards by excluding all known VRAM types rather than
     * by including all known DRAM types because only 7 of the 8 possible
     * memory types are defined. If the eighth type is VRAM and we include
     * it because it's not in the exclusion list, the value we assign will
     * be ignored. If it's DRAM and we exclude it because it's not in the
     * inclusion list, we will have problems.
     */
    if ((QueryPtr->q_memory_type != VMEM_VRAM_256Kx4_SER512) &&
        (QueryPtr->q_memory_type != VMEM_VRAM_256Kx4_SER256) &&
        (QueryPtr->q_memory_type != VMEM_VRAM_256Kx4_SPLIT512) &&
        (QueryPtr->q_memory_type != VMEM_VRAM_256Kx16_SPLIT256))
        {
        /*
         * We can't switch on the refresh rate because if we're setting
         * the mode from the installed mode table rather than one of the
         * "canned" tables, the refresh rate field will hold a reserved
         * value rather than the true rate. Instead, use the pixel rate,
         * which varies with refresh rate. We can't simply use the pixel
         * clock frequency, since it will have been boosted for certain
         * DAC and pixel depth combinations. Instead, we must undo this
         * boost in order to get the pixel rate.
         */
        switch (crttable->m_pixel_depth)
            {
            case 24:
                if ((QueryPtr->q_DAC_type == DAC_BT48x) ||
                    (QueryPtr->q_DAC_type == DAC_SC15026) ||
                    (QueryPtr->q_DAC_type == DAC_ATT491))
                    {
                    BaseClock = crttable->ClockFreq / 3;
                    }
                else if ((QueryPtr->q_DAC_type == DAC_SC15021) ||
                    (QueryPtr->q_DAC_type == DAC_STG1702) ||
                    (QueryPtr->q_DAC_type == DAC_STG1703))
                    {
                    BaseClock = crttable->ClockFreq * 2;
                    BaseClock /= 3;
                    }
                else if ((QueryPtr->q_DAC_type == DAC_STG1700) ||
                    (QueryPtr->q_DAC_type == DAC_ATT498))
                    {
                    BaseClock = crttable->ClockFreq / 2;
                    }
                else
                    {
                    BaseClock = crttable->ClockFreq;
                    }
                break;

            case 16:
                if ((QueryPtr->q_DAC_type == DAC_BT48x) ||
                    (QueryPtr->q_DAC_type == DAC_SC15026) ||
                    (QueryPtr->q_DAC_type == DAC_ATT491))
                    {
                    BaseClock = crttable->ClockFreq / 2;
                    }
                else
                    {
                    BaseClock = crttable->ClockFreq;
                    }
                break;

            case 8:
            default:
                BaseClock = crttable->ClockFreq;
                break;
            }

        /*
         * 1M cards include Mach 8 combo cards which report the total
         * (accelerator plus VGA) memory in q_memory_size. Since the
         * maximum VGA memory on these cards is 512k, none of them will
         * report 2M. If we were to look for 1M cards, we'd also have to
         * check for 1.25M and 1.5M cards in order to catch the combos.
         *
         * Some threshold values of BaseClock are chosen to catch both
         * straight-through (DAC displays 1 pixel per clock) and adjusted
         * (DAC needs more than 1 clock per pixel) cases, and so do not
         * correspond to the pixel clock frequency for any mode.
         */
        if (QueryPtr->q_memory_size == VRAM_2mb)
            {
            switch (crttable->m_pixel_depth)
                {
                case 24:
                    /*
                     * Only 640x480 and 800x600 suported.
                     */
                    if (crttable->m_x_size == 640)
                        {
                        if (BaseClock < 30000000L)    /* 60Hz */
                            clock = 0x08;
                        else    /* 72Hz */
                            clock = 0x0A;
                        }
                    else    /* 800x600 */
                        {
                        if (BaseClock <= 32500000)  /* 89Hz  interlaced */
                            clock = 0x0A;
                        else if (BaseClock <= 36000000) /* 95Hz interlaced and 56Hz */
                            clock = 0x0C;
                        else if (BaseClock <= 40000000) /* 60Hz */
                            clock = 0x0D;
                        else    /* 70Hz and 72Hz */
                            clock = 0x0E;
                        }
                    break;

                case 16:
                    /*
                     * All resolutions except 1280x1024 supported.
                     */
                    if (crttable->m_x_size == 640)
                        {
                        if (BaseClock < 30000000L)    /* 60Hz */
                            clock = 0x04;
                        else    /* 72Hz */
                            clock = 0x05;
                        }
                    else if (crttable->m_x_size == 800)
                        {
                        if (BaseClock <= 40000000) /* 89Hz and 95Hz interlaced, 56Hz, and 60Hz */
                            clock = 0x05;
                        else if (BaseClock <= 46000000) /* 70Hz */
                            clock = 0x07;
                        else    /* 72Hz */
                            clock = 0x08;
                        }
                    else    /* 1024x768 */
                        {
                        if (BaseClock < 45000000)   /* 87Hz interlaced */
                            {
                            clock = 0x07;
                            }
                        else if (BaseClock < 70000000)  /* 60Hz */
                            {
                            clock = 0x0B;
                            }
                        else    /* 66Hz, 70Hz, and 72Hz */
                            {
                            clock = 0x0D;
                            }
                        }
                    break;

                case 8:
                default:    /* If 4BPP is implemented, it will be treated like 8BPP */
                    if (crttable->m_x_size == 640)
                        {
                        /*
                         * Both available refresh rates use the same value
                         */
                        clock = 0x02;
                        }
                    else if (crttable->m_x_size == 800)
                        {
                        if (BaseClock <= 46000000) /* 89Hz and 95Hz interlaced, 56Hz, 60Hz, and 70Hz */
                            clock = 0x02;
                        else    /* 72Hz */
                            clock = 0x04;
                        }
                    else if (crttable->m_x_size == 1024)
                        {
                        if (BaseClock < 45000000)   /* 87Hz interlaced */
                            {
                            clock = 0x03;
                            }
                        else if (BaseClock < 70000000)  /* 60Hz */
                            {
                            clock = 0x05;
                            }
                        else    /* 66Hz, 70Hz, and 72Hz */
                            {
                            clock = 0x06;
                            }
                        }
                    else    /* 1280x1024 */
                        {
                        if (BaseClock < 100000000)  /* both interlaced modes */
                            clock = 0x07;
                        else    /* 60Hz - only DRAM noninterlaced mode */
                            clock = 0x0A;
                        }
                    break;
                }
            }
        else    /* 1M cards */
            {
            switch (crttable->m_pixel_depth)
                {
                case 24:
                    /*
                     * Only 640x480 fits in 1M. Both 60Hz and 72Hz
                     * use the same FIFO depth.
                     */
                    clock = 0x0E;
                    break;

                case 16:
                    /*
                     * Only 640x480 and 800x600 suported.
                     */
                    if (crttable->m_x_size == 640)
                        {
                        if (BaseClock < 30000000L)    /* 60Hz */
                            clock = 0x08;
                        else    /* 72Hz */
                            clock = 0x0A;
                        }
                    else    /* 800x600 */
                        {
                        if (BaseClock <= 32500000)  /* 89Hz  interlaced */
                            clock = 0x0A;
                        else    /* 95Hz interlaced and 56Hz, higher rates not supported in 1M */
                            clock = 0x0C;
                        }
                    break;

                case 8:
                default:    /* If 4BPP is implemented, it will be treated like 8BPP */
                    if (crttable->m_x_size == 640)
                        {
                        if (BaseClock < 30000000L)    /* 60Hz */
                            clock = 0x04;
                        else    /* 72Hz */
                            clock = 0x05;
                        }
                    else if (crttable->m_x_size == 800)
                        {
                        if (BaseClock <= 32500000)  /* 89Hz  interlaced */
                            clock = 0x05;
                        else if (BaseClock <= 40000000) /* 95Hz interlaced, 56Hz, and 60Hz */
                            clock = 0x06;
                        else if (BaseClock <= 46000000) /* 70Hz */
                            clock = 0x07;
                        else    /* 72Hz */
                            clock = 0x08;
                        }
                    else if (crttable->m_x_size == 1024)
                        {
                        if (BaseClock < 45000000)   /* 87Hz interlaced */
                            {
                            clock = 0x07;
                            }
                        else    /* 60Hz, 66Hz, 70Hz, and 72Hz */
                            {
                            clock = 0x08;
                            }
                        }
                    else    /* 1280x1024 */
                        {
                        /*
                         * Only interlaced modes supported in 1M (4BPP only),
                         * both use the same FIFO depth.
                         */
                        clock = 0x03;
                        }

                    break;
                }
            }

        WaitForIdle_m();
        OUTPW (CLOCK_SEL, (WORD)((clock << 8) | (ClockSelect & 0x00FF) | 0x01));
        DEC_DELAY
        }

    overscan=crttable->m_h_overscan;
    low=(BYTE)(overscan&0xff);
    high=(BYTE)(overscan>>8);

    high=high>>4;
    low=low&0xf;
    if (high>=low)
        high=low;
    else
        low=high;
    high=high<<4;
    low=low|high;

    WaitForIdle_m();
    OUTPW(HORZ_OVERSCAN,(WORD)(low & 0x00FF));
    DEC_DELAY

    overscan=crttable->m_v_overscan;
    low=(BYTE)(overscan&0xff);
    high=(BYTE)(overscan>>8);

    if (high>=low)
        high=low;
    else
        low=high;

    high <<= 8;
    overscan=(WORD)high + (WORD)low;

    OUTPW(VERT_OVERSCAN,overscan);
    DEC_DELAY
    return;

}   /* setmode_m() */



/*
 * void InitTIMux_m(config, rom_address);
 *
 * int config;          Default EXT_GE_CONFIG (should be 0x10A or 0x11A)
 * ULONG_PTR rom_address;   Virtual address of start of ROM BIOS
 *
 * Put TI DAC into MUX mode for 1280x1024 non-interlaced displays.
 */
void InitTIMux_m(int config,ULONG_PTR rom_address)
{
    struct query_structure *QueryPtr;   /* Query information for the card */
    WORD    reg;
    WORD    temp;

    /*
     * Get a formatted pointer into the query section of HwDeviceExtension.
     * The CardInfo[] field is an unformatted buffer.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);

    if (QueryPtr->q_DAC_type == DAC_TI34075)
        {
        reg=INPW(CLOCK_SEL);
        temp = (reg & CLOCK_SEL_STRIP) | GetShiftedSelector(50000000L);
        OUTPW(CLOCK_SEL,temp);
        OUTPW(EXT_GE_CONFIG,0x201a);        /* Set EXT_DAC_ADDR field */
        OUTP(DAC_MASK,9);	/* OUTPut clock is SCLK/2 and VCLK/2 */
        OUTP(DAC_R_INDEX,0x1d);        /* set MUX control to 8/16 */

        /* INPut clock source is CLK3 or CLK1 (most current release) */
        OUTP(DAC_DATA,GetClkSrc_m((ULONG *) rom_address));

        /* reset EXT_DAC_ADDR, put DAC in 6 bit mode, engine in 8 bit mode, enable MUX mode */
        OUTPW(EXT_GE_CONFIG,(WORD)config);
        SetBlankAdj_m(1);       /* set BLANK_ADJUST=1, PIXEL_DELAY=0    */
        OUTPW (CLOCK_SEL,reg);
        }
    return;

}   /* InitTIMux_m() */



/*
 * BYTE GetClkSrc_m(rom_address);
 *
 * ULONG *rom_address;  Virtual address of start of ROM BIOS
 *
 * Get INPUT_CLOCK_SEL value for TI DACs
 *
 * Returns:
 *  Input clock source
 */
BYTE GetClkSrc_m(ULONG *rom_address)
{
    WORD *rom;
    BYTE *crom;
    BYTE clock_sel=0;
    int	i;

        rom= (PUSHORT)*rom_address++;
        if (rom && VideoPortReadRegisterUshort ((PUSHORT)rom)==VIDEO_ROM_ID)
            {
            crom=(BYTE *)rom;
    	    clock_sel=VideoPortReadRegisterUchar (&crom[0x47]);
    	    i=NUM_ROM_BASE_RANGES;
            }
        if (clock_sel==0)
        clock_sel=1;

    return(clock_sel);

}   /* GetClkSrc_m() */



/*
 * void SetBlankAdj_m(adjust);
 *
 * BYTE adjust;     Desired blank adjust (bits 0-1)
 *                  and pixel delay (bits 2-3) values
 *
 * Sets the blank adjust and pixel delay values.
 */
void SetBlankAdj_m(BYTE adjust)
{
    WORD misc;

    misc = INPW(R_MISC_CNTL) & 0xF0FF | (adjust << 8);
    OUTPW (MISC_CNTL,misc);
    return;

}   /* SetBlankAdj_m() */



/*
 * void InitTi_8_m(ext_ge_config);
 *
 * WORD ext_ge_config;  Desired EXT_GE_CONFIG value (should be 0x1a)
 *
 * Initialize DAC for standard 8 bit per pixel mode.
 */
void InitTi_8_m(WORD ext_ge_config)
{
struct query_structure *QueryPtr;   /* Query information for the card */
WORD ClockSelect;                   /* Value from CLOCK_SEL register */
struct st_mode_table *CrtTable;     /* Pointer to current mode table */

    /*
     * Get a formatted pointer into the query section of HwDeviceExtension,
     * and another pointer to the current mode table. The CardInfo[] field
     * is an unformatted buffer.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);
    CrtTable = (struct st_mode_table *)QueryPtr;
    ((struct query_structure *)CrtTable)++;
    CrtTable += phwDeviceExtension->ModeIndex;

    switch(QueryPtr->q_DAC_type)
        {
        case DAC_ATT491:    /* At 8 BPP, Brooktree 48x and AT&T 20C491 */
        case DAC_BT48x:     /* are set up the same way */
            OUTPW(EXT_GE_CONFIG,0x101a);        /* Set EXT_DAC_ADDR */
            OUTP (DAC_MASK,0);
        SetBlankAdj_m(0x0C);       /* set BLANK_ADJUST=0, PIXEL_DELAY=3    */
            break;

        case DAC_STG1700:
            /*
             * If we are running 1280x1024 noninterlaced, cut the
             * clock frequency in half, set the MUX bit in
             * ext_ge_config, and tell InitSTG1700_m() to use the
             * 8BPP double pixel mode.
             *
             * All 1280x1024 noninterlaced modes use a pixel clock
             * frequency of 110 MHz or higher, with the clock
             * frequency divided by 1.
             */
            ClockSelect = INPW(CLOCK_SEL);
            if ((QueryPtr->q_desire_x == 1280) &&
                ((CrtTable->m_clock_select & CLOCK_SEL_MUX) ||
                (CrtTable->ClockFreq >= 110000000)))
                {
                if (CrtTable->ClockFreq >= 110000000)
                    {
                    ClockSelect &= CLOCK_SEL_STRIP;
                    ClockSelect |= GetShiftedSelector((CrtTable->ClockFreq) / 2);
                    OUTPW(CLOCK_SEL, ClockSelect);
                    }
                ext_ge_config |= 0x0100;
                InitSTG1700_m(ext_ge_config, TRUE);
                }
            else
                {
                InitSTG1700_m(ext_ge_config, FALSE);
                }
            break;

        case DAC_STG1702:
        case DAC_STG1703:
            /*
             * If we are running 1280x1024 noninterlaced, cut the
             * clock frequency in half, set the MUX bit in
             * ext_ge_config, and tell InitSTG1702_m() to use the
             * 8BPP double pixel mode.
             *
             * All 1280x1024 noninterlaced modes use a pixel clock
             * frequency of 110 MHz or higher, with the clock
             * frequency divided by 1.
             */
            ClockSelect = INPW(CLOCK_SEL);
            if ((QueryPtr->q_desire_x == 1280) &&
                ((CrtTable->m_clock_select & CLOCK_SEL_MUX) ||
                (CrtTable->ClockFreq >= 110000000)))
                {
                if (CrtTable->ClockFreq >= 110000000)
                    {
                    ClockSelect &= CLOCK_SEL_STRIP;
                    ClockSelect |= GetShiftedSelector((CrtTable->ClockFreq) / 2);
                    OUTPW(CLOCK_SEL, ClockSelect);
                    }
                ext_ge_config |= 0x0100;
                InitSTG1702_m(ext_ge_config, TRUE);
                }
            else
                {
                InitSTG1702_m(ext_ge_config, FALSE);
                }
            break;

        case DAC_ATT498:
            /*
             * If we are running 1280x1024 noninterlaced, cut the
             * clock frequency in half, set the MUX bit in
             * ext_ge_config, and tell InitATT498_m() to use the
             * 8BPP double pixel mode.
             *
             * All 1280x1024 noninterlaced modes use a pixel clock
             * frequency of 110 MHz or higher, with the clock
             * frequency divided by 1.
             */
            ClockSelect = INPW(CLOCK_SEL);
            if ((QueryPtr->q_desire_x == 1280) &&
                ((CrtTable->m_clock_select & CLOCK_SEL_MUX) ||
                (CrtTable->ClockFreq >= 110000000)))
                {
                if (CrtTable->ClockFreq >= 110000000)
                    {
                    ClockSelect &= CLOCK_SEL_STRIP;
                    ClockSelect |= GetShiftedSelector((CrtTable->ClockFreq) / 2);
                    OUTPW(CLOCK_SEL, ClockSelect);
                    }
                ext_ge_config |= 0x0100;
                InitATT498_m(ext_ge_config, TRUE);
                }
            else
                {
                InitATT498_m(ext_ge_config, FALSE);
                }
            break;

        case DAC_SC15021:
            /*
             * If we are running 1280x1024 noninterlaced, cut the
             * clock frequency in half, set the MUX bit in
             * ext_ge_config, and tell InitSC15021_m() to use the
             * 8BPP double pixel mode.
             *
             * All 1280x1024 noninterlaced modes use a pixel clock
             * frequency of 110 MHz or higher, with the clock
             * frequency divided by 1.
             */
            ClockSelect = INPW(CLOCK_SEL);
            if ((QueryPtr->q_desire_x == 1280) &&
                ((CrtTable->m_clock_select & CLOCK_SEL_MUX) ||
                (CrtTable->ClockFreq >= 110000000)))
                {
                /*
                 * NOTE: The only SC15021 card available for testing
                 *       (93/12/07) is a DRAM card. Since 1280x1024
                 *       noninterlaced is only available on VRAM cards,
                 *       it has not been tested.
                 */
                if (CrtTable->ClockFreq >= 110000000)
                    {
                    ClockSelect &= CLOCK_SEL_STRIP;
                    ClockSelect |= GetShiftedSelector((CrtTable->ClockFreq) / 2);
                    OUTPW(CLOCK_SEL, ClockSelect);
                    }
                ext_ge_config |= 0x0100;
                InitSC15021_m(ext_ge_config, TRUE);
                }
            else
                {
                InitSC15021_m(ext_ge_config, FALSE);
                }
            break;

        case DAC_SC15026:
            InitSC15026_m(ext_ge_config);
            break;

        case DAC_TI34075:
            /*
             * Handle 1280x1024 through the MUX.
             */
            if (QueryPtr->q_desire_x == 1280)
                {
	            InitTIMux_m(0x11a, (ULONG_PTR) &(phwDeviceExtension->RomBaseRange));
                return;
                }
            else
                {
                OUTPW(EXT_GE_CONFIG,0x201a);    /* Set EXT_DAC_ADDR field */
                DEC_DELAY
                OUTP (DAC_DATA,0);              /* Input clock source is CLK0 */
                DEC_DELAY
                OUTP (DAC_MASK,0);              /* Output clock is SCLK/1 and VCLK/1 */
                DEC_DELAY
                OUTP (DAC_R_INDEX,0x2d);        /* set MUX control to 8/8 */
                DEC_DELAY
                SetBlankAdj_m(0xc);             /* set pixel delay to 3 */
                DEC_DELAY
                OUTPW(HORZ_OVERSCAN,1);         /* set horizontal skew */
                DEC_DELAY
                break;
                }

        case DAC_ATI_68860:
            Init68860_m(ext_ge_config);
            break;
        }

    //
    // reset EXT_DAC_ADDR, put DAC in 6 bit mode
    //
    OUTPW(EXT_GE_CONFIG,ext_ge_config);
    DEC_DELAY
    OUTP (DAC_MASK,0xff);           /* enable DAC_MASK */
    DEC_DELAY
    return;

}   /* InitTi_8_m() */



/*
 * void InitTi_16_m(ext_ge_config, rom_address);
 *
 * WORD ext_ge_config;  Desired EXT_GE_CONFIG value (should be 0x2a, 0x6a, 0xaa, or 0xea)
 * ULONG_PTR rom_address; Virtual address of start of ROM BIOS
 *
 * Initialize DAC for 16 bit per pixel mode.
 */
void InitTi_16_m(WORD ext_ge_config, ULONG_PTR rom_address)
{
    WORD    ReadExtGeConfig;
    BYTE dummy;
    struct query_structure *QueryPtr;   /* Query information for the card */

    /*
     * Get a formatted pointer into the query section of HwDeviceExtension.
     * The CardInfo[] field is an unformatted buffer.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);

    switch(QueryPtr->q_DAC_type)
        {
        case DAC_TI34075:
            /* TLC34075 initialization */
            /* disable overlay feature */

            OUTP (DAC_MASK,0);
            DEC_DELAY

            /* set BLANK_ADJUST=1, PIXEL_DELAY=0 */
            SetBlankAdj_m(1);

            /* Set EXT_DAC_ADDR field */
            OUTPW(EXT_GE_CONFIG,0x201a);
            DEC_DELAY

            /* get INPut clock source */
            OUTP (DAC_DATA, GetClkSrc_m((ULONG *) rom_address));
            DEC_DELAY

            /*
             * Re-write the I/O vs. memory mapped flag (bit 5 of
             * LOCAL_CONTROL set). If this is not done, and memory
             * mapped registers are being used, the EXT_GE_CONFIG
             * value won't be interpreted properly.
             *
             * If this is done at the beginning of the
             * IOCTL_VIDEO_SET_CURRENT_MODE packet, rather than
             * just before setting EXT_GE_CONFIG for each DAC type,
             * it has no effect.
             */
            OUTPW(LOCAL_CONTROL, INPW(LOCAL_CONTROL));

            /* OUTPut clock source is SCLK/1 and VCLK/1 */
            /*   -- for modes which require PCLK/2, set VCLK/2 */

            if ( INPW(CLOCK_SEL) & 0xc0 )
                {
                DEC_DELAY
                OUTPW (CLOCK_SEL, (WORD)(INPW(CLOCK_SEL) & 0xff3f));
                DEC_DELAY

                if ( (INPW(R_H_DISP) & 0x00FF) == 0x4f )    // H_DISP = 640?
                    {
                    /* exception case: 640x480 60 Hz needs longer blank adjust (2) */
                    DEC_DELAY
                    SetBlankAdj_m(2);
                    }

                OUTP (DAC_MASK,8);
                DEC_DELAY
                }
            else{
                DEC_DELAY
                OUTP (DAC_MASK,0);
                DEC_DELAY
                }
            OUTP (DAC_R_INDEX,0xd);     /* set MUX control to 24/32 */
            DEC_DELAY

            /* reset EXT_DAC_ADDR, put DAC in 8 bit mode, engine in 555 mode */
            OUTPW (EXT_GE_CONFIG, (WORD)(ext_ge_config | 0x4000));
            DEC_DELAY
            break;

        case DAC_BT48x:                   /* Brooktree Bt481 initialization */
            /*
             * Re-write the I/O vs. memory mapped flag (bit 5 of
             * LOCAL_CONTROL set). If this is not done, and memory
             * mapped registers are being used, the clock select
             * value won't be interpreted properly.
             */
            OUTPW(LOCAL_CONTROL, INPW(LOCAL_CONTROL));
            ReadExtGeConfig = INPW(R_EXT_GE_CONFIG) & 0x000f;
            ReadExtGeConfig |= (ext_ge_config & 0x0ff0);
            OUTPW(EXT_GE_CONFIG, (WORD)(ReadExtGeConfig | 0x1000));

            /*
             * See Bt481/Bt482 Product Description p.5 top of col. 2
             */
            dummy = INP(DAC_MASK);
            dummy = INP(DAC_MASK);
            dummy = INP(DAC_MASK);
            dummy = INP(DAC_MASK);

            /*
             * Determine 555 or 565
             */
            if (ext_ge_config & 0x0c0)
                OUTP(DAC_MASK, 0x0e0);  /* 565 */
            else
                OUTP(DAC_MASK, 0x0a0);  /* 555 */

            OUTPW(EXT_GE_CONFIG, ReadExtGeConfig);

            SetBlankAdj_m(0x0C);       /* set BLANK_ADJUST=0, PIXEL_DELAY=3    */

            break;

        /*
         * ATT20C491 initialization. At 16BPP, this DAC is subtly
         * different from the Brooktree 48x.
         */
        case DAC_ATT491:
            OUTP (DAC_MASK,0);
            SetBlankAdj_m(0x0C);        /* BLANK_ADJUST=0, PIXEL_DELAY=3 */
            OUTPW(EXT_GE_CONFIG,0x101a);        /* set EXT_DAC_ADDR */

            /*
             * Windows NT miniport currently only supports 565 in 16BPP.
             * The test for the mode may need to be changed once all
             * orderings are supported.
             */
            if (ext_ge_config &0x0c0)
                OUTP (DAC_MASK,0xc0);       // 565, 8 bit
            else
                OUTP (DAC_MASK,0xa0);       // 555, 8 bit   UNTESTED MODE

            OUTPW(EXT_GE_CONFIG,ext_ge_config);
            break;

        case DAC_STG1700:
            InitSTG1700_m(ext_ge_config, FALSE);
            break;

        case DAC_STG1702:
        case DAC_STG1703:
            InitSTG1702_m(ext_ge_config, FALSE);
            break;

        case DAC_ATT498:
            InitATT498_m(ext_ge_config, FALSE);
            break;

        case DAC_SC15021:
            InitSC15021_m(ext_ge_config, FALSE);
            break;

        case DAC_SC15026:
            InitSC15026_m(ext_ge_config);
            break;

        case DAC_ATI_68860:
            SetBlankAdj_m(0x0C);        /* BLANK_ADJUST=0, PIXEL_DELAY=3 */
            Init68860_m(ext_ge_config);
            OUTPW(EXT_GE_CONFIG,ext_ge_config);
            break;

        default:
            OUTPW(EXT_GE_CONFIG,ext_ge_config);

            /* set pixel delay (3) for non-TI_DACs */
            SetBlankAdj_m(0xc);
            break;
        }
    return;

}   /* InitTi_16_m() */



/*
 * void InitTi_24_m(ext_ge_config, rom_address);
 *
 * WORD ext_ge_config;  Desired EXT_GE_CONFIG value (should be 0x3a | 24_BIT_OPTIONS)
 * ULONG_PTR rom_address; Virtual address of start of ROM BIOS
 *
 * Initialize DAC for 24 bit per pixel mode, 3 bytes, RGB.
 */
void InitTi_24_m(WORD ext_ge_config, ULONG_PTR rom_address)
{
    WORD clock_sel;
    BYTE dummy;
    WORD ReadExtGeConfig;
    struct query_structure *QueryPtr;   /* Query information for the card */

    /*
     * Get a formatted pointer into the query section of HwDeviceExtension.
     * The CardInfo[] field is an unformatted buffer.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);

    /*
     * Set 8-bit DAC operation.
     */
    ext_ge_config |= 0x4000;

    switch(QueryPtr->q_DAC_type)
        {
        case DAC_TI34075:               /* TLC34075 initialization */
            SetBlankAdj_m(1);           /* BLANK_ADJ=1, PIXEL_DELAY=0 */
            DEC_DELAY
            OUTPW(EXT_GE_CONFIG,0x201a);        /* Set EXT_DAC_ADDR field */
            DEC_DELAY
            OUTP (DAC_DATA, GetClkSrc_m((ULONG *) rom_address));
            DEC_DELAY

            /* OUTPut clock source is SCLK/1 and VCLK/1 */
            /*   -- for modes which require PCLK/2, set VCLK/2 */
            clock_sel= INPW(CLOCK_SEL);
            DEC_DELAY

            /*
             * If clock select is currently divided by 2, divide by 1.
             */
            if (clock_sel & 0xc0)
                {
                clock_sel &= 0xff3f;

                /*
                 * 640x480 60Hz needs longer blank adjust (2). Other
                 * refresh rates at 640x400 don't need this, but they
                 * use a divide-by-1 clock so they don't reach this point.
                 */
                if (INP(R_H_DISP) == 0x4f)
                    {
                    /* exception case: 640x480 60 Hz needs longer blank adjust (2) */
                    DEC_DELAY
                    SetBlankAdj_m(2);
                    }

                DEC_DELAY
                OUTP (DAC_MASK,8);
                DEC_DELAY
                }
            else{
                OUTP (DAC_MASK,0);
                DEC_DELAY
                }

            OUTP(DAC_R_INDEX,0xd); /* set MUX control to 24/32 */
            DEC_DELAY

            /*
             * Re-write the I/O vs. memory mapped flag (bit 5 of
             * LOCAL_CONTROL set). If this is not done, and memory
             * mapped registers are being used, the clock select
             * value won't be interpreted properly.
             *
             * If this is done at the beginning of the
             * IOCTL_VIDEO_SET_CURRENT_MODE packet, rather than
             * just before setting EXT_GE_CONFIG for each DAC type,
             * it has no effect.
             */
            OUTPW(LOCAL_CONTROL, INPW(LOCAL_CONTROL));
            DEC_DELAY

            /* reset EXT_DAC_ADDR, put DAC in 8 bit mode, engine in 555 mode */
            OUTPW (EXT_GE_CONFIG, (WORD)(ext_ge_config | 0x4000));
            DEC_DELAY
            OUTPW(CLOCK_SEL,clock_sel);
            DEC_DELAY
            OUTP  (DAC_MASK,0);           /* disable overlay feature */
            DEC_DELAY
            break;


        case DAC_BT48x:            /* Brooktree Bt481 initialization */
            /*
             * This code is still experimental.
             */

            /*
             * Re-write the I/O vs. memory mapped flag (bit 5 of
             * LOCAL_CONTROL set). If this is not done, and memory
             * mapped registers are being used, the clock select
             * value won't be interpreted properly.
             */
            OUTPW(LOCAL_CONTROL, INPW(LOCAL_CONTROL));

            ReadExtGeConfig = INPW(R_EXT_GE_CONFIG) & 0x000f;
            ReadExtGeConfig |= (ext_ge_config & 0x0ff0);
            OUTPW(EXT_GE_CONFIG, (WORD)(ReadExtGeConfig | 0x1000));

            /*
             * See Bt481/Bt482 Product Description p.5 top of col. 2
             */
            dummy = INP(DAC_MASK);
            dummy = INP(DAC_MASK);
            dummy = INP(DAC_MASK);
            dummy = INP(DAC_MASK);

            OUTP(DAC_MASK, 0x0f0);  /* 8:8:8 single-edge clock */

            OUTPW(EXT_GE_CONFIG, ReadExtGeConfig);

            SetBlankAdj_m(0x0C);       /* set BLANK_ADJUST=0, PIXEL_DELAY=3    */

            break;


        case DAC_ATT491:        /* ATT20C491 initialization */
            OUTP(DAC_MASK,0);

            SetBlankAdj_m(0x0C);       /* set BLANK_ADJUST=0, PIXEL_DELAY=3    */

            /* set EXT_DAC_ADDR field */
            OUTPW(EXT_GE_CONFIG,0x101a);

            /* set 24bpp bypass mode */
            OUTP(DAC_MASK,0xe2);

            /*
             * Re-write the I/O vs. memory mapped flag (bit 5 of
             * LOCAL_CONTROL set). If this is not done, and memory
             * mapped registers are being used, the clock select
             * value won't be interpreted properly.
             */
            OUTPW(LOCAL_CONTROL, INPW(LOCAL_CONTROL));

            OUTPW(EXT_GE_CONFIG,ext_ge_config);
            break;

        case DAC_STG1700:
            InitSTG1700_m(ext_ge_config, FALSE);
            break;

        case DAC_STG1702:
        case DAC_STG1703:
            InitSTG1702_m(ext_ge_config, FALSE);
            break;

        case DAC_ATT498:
            InitATT498_m(ext_ge_config, FALSE);
            break;

        case DAC_SC15021:
            InitSC15021_m(ext_ge_config, FALSE);
            break;

        case DAC_SC15026:
            InitSC15026_m(ext_ge_config);
            break;

        case DAC_ATI_68860:
            Init68860_m(ext_ge_config);
            /* Intentional fallthrough */

        default:
            OUTPW(EXT_GE_CONFIG,ext_ge_config);
            break;
        }
    return;

}   /* InitTi_24_m() */



/*
 * void Init68860_m(ext_ge_config);
 *
 * WORD ext_ge_config;  Value to be written to EXT_GE_CONFIG register
 *
 * Initialize the ATI 68860 DAC.
 */
void Init68860_m(WORD ext_ge_config)
{
    struct query_structure *QueryPtr;   /* Query information for the card */
    unsigned char GMRValue;             /* Value to put into Graphics Mode Register */

    /*
     * Get a formatted pointer into the query section of HwDeviceExtension.
     * The CardInfo[] field is an unformatted buffer.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);

    OUTPW(EXT_GE_CONFIG, (WORD)(ext_ge_config | 0x3000));   /* 6 bit DAC, DAC_EXT_ADDR = 3 */

    /*
     * Initialize Device Setup Register A. Select 6-bit DAC operation,
     * normal power mode, PIXA bus width=64, disable overscan, and
     * no delay PIXA latching. Enable both SOB0 and SOB1 on cards
     * with more than 512k, 512k cards enable only SOB0.
     */
    if (QueryPtr->q_memory_size == VRAM_512k)
        OUTP(DAC_W_INDEX, 0x2D);
    else
        OUTP(DAC_W_INDEX, 0x6D);

    OUTPW(EXT_GE_CONFIG, (WORD)(ext_ge_config | 0x2000));   /* 6 bit DAC, DAC_EXT_ADDR = 2 */

    /*
     * Initialize Clock Selection Register. Select activate SCLK, enable
     * SCLK output, CLK1 as dot clock, VCLK=CLK1/4, no delay PIXB latch.
     */
    OUTP(DAC_MASK, 0x1D);

    /*
     * Initialize Display Control Register. Enable CMPA output, enable POSW,
     * 0 IRE blanking pedestal, disabe sync onto Red, Green, and Blue DACs.
     */
    OUTP(DAC_W_INDEX, 0x02);

    /*
     * Get the Graphics Mode Register value corresponding to the desired
     * colour depth and RGB ordering, then write it.
     */
    switch (ext_ge_config & 0x06F0)
        {
        case 0x0000:    /* 4 BPP */
            GMRValue = 0x01;
            break;

        case 0x0020:    /* 16 BPP 555 */
            GMRValue = 0x20;
            break;

        case 0x0060:    /* 16 BPP 565 */
            GMRValue = 0x21;
            break;

        case 0x00A0:    /* 16 BPP 655 */
            GMRValue = 0x22;
            break;

        case 0x00E0:    /* 16 BPP 664 */
            GMRValue = 0x23;
            break;

        case 0x0030:    /* 24 BPP RBG */
            GMRValue = 0x40;
            break;

        case 0x0430:    /* 24 BPP BGR */
            GMRValue = 0x41;
            break;

        case 0x0230:    /* 32 BPP RBGa */
            GMRValue = 0x60;
            break;

        case 0x0630:    /* 32 BPP aBGR */
            GMRValue = 0x61;
            break;

        default:        /* 8 BPP */
            GMRValue = 0x03;
            break;
        }
    OUTP(DAC_R_INDEX, GMRValue);

    return;

}   /* end Init68860_m() */



/***************************************************************************
 *
 * void InitSTG1700_m(ext_ge_config, DoublePixel);
 *
 * WORD ext_ge_config;      Value to be written to EXT_GE_CONFIG register
 * BOOL DoublePixel;        Whether or not to use 8BPP double pixel mode
 *
 * DESCRIPTION:
 *  Initializes the STG1700 DAC to the desired colour depth.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  InitTi_<depth>_m(), UninitTiDac_m()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void InitSTG1700_m(WORD ext_ge_config, BOOL DoublePixel)
{
    unsigned char PixModeSelect;    /* Value to write to DAC Pixel Mode Select registers */
    unsigned char Dummy;            /* Scratch variable */


    /*
     * Get the value to be written to the DAC's Pixel Mode Select registers.
     */
    switch (ext_ge_config & 0x06F0)
        {
        case (PIX_WIDTH_16BPP | ORDER_16BPP_555):
            PixModeSelect = 0x02;
            break;

        case (PIX_WIDTH_16BPP | ORDER_16BPP_565):
            PixModeSelect = 0x03;
            break;

        case (PIX_WIDTH_24BPP | ORDER_24BPP_RGB):
        case (PIX_WIDTH_24BPP | ORDER_24BPP_RGBx):
            PixModeSelect = 0x04;
            break;

        default:    /* 4 and 8 BPP */
            if (DoublePixel == TRUE)
                PixModeSelect = 0x05;
            else
                PixModeSelect = 0x00;
            break;
        }

    /*
     * Enable extended register/pixel mode.
     */
    ReadDac4();
    OUTP(DAC_MASK, 0x18);

    /*
     * Skip over the Pixel Command register, then write to indexed
     * registers 3 and 4 (Primrary and Secondary Pixel Mode Select
     * registers). Registers auto-increment when written.
     */
    ReadDac4();
    Dummy = INP(DAC_MASK);
    OUTP(DAC_MASK, 0x03);               /* Index low */
    OUTP(DAC_MASK, 0x00);               /* Index high */
    OUTP(DAC_MASK, PixModeSelect);      /* Primrary pixel mode select */
    OUTP(DAC_MASK, PixModeSelect);      /* Secondary pixel mode select */

    /*
     * In 8BPP double pixel mode, we must also set the PLL control
     * register. Since this mode is only used for 1280x1024 noninterlaced,
     * which always has a pixel clock frequency greater than 64 MHz,
     * the setting for this register is a constant.
     */
    if (DoublePixel == TRUE)
        OUTP(DAC_MASK, 0x02);       /* Input is 32 to 67.5 MHz, output 64 to 135 MHz */

    OUTPW(EXT_GE_CONFIG, ext_ge_config);
    Dummy = INP(DAC_W_INDEX);               /* Clear counter */

    return;

}   /* end InitSTG1700_m() */



/***************************************************************************
 *
 * void InitSTG1702_m(ext_ge_config, DoublePixel);
 *
 * WORD ext_ge_config;      Value to be written to EXT_GE_CONFIG register
 * BOOL DoublePixel;        Whether or not to use 8BPP double pixel mode
 *
 * DESCRIPTION:
 *  Initializes the STG1702/1703 DAC to the desired colour depth.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  InitTi_<depth>_m(), UninitTiDac_m()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void InitSTG1702_m(WORD ext_ge_config, BOOL DoublePixel)
{
    unsigned char PixModeSelect;    /* Value to write to DAC Pixel Mode Select registers */
    unsigned char Dummy;            /* Scratch variable */


    /*
     * Get the value to be written to the DAC's Pixel Mode Select registers.
     */
    switch (ext_ge_config & 0x06F0)
        {
        case (PIX_WIDTH_16BPP | ORDER_16BPP_555):
            PixModeSelect = 0x02;
            break;

        case (PIX_WIDTH_16BPP | ORDER_16BPP_565):
            PixModeSelect = 0x03;
            break;

        case (PIX_WIDTH_24BPP | ORDER_24BPP_RGB):
        case (PIX_WIDTH_24BPP | ORDER_24BPP_RGBx):
            /*
             * Use double 24BPP direct colour. In this mode,
             * two pixels are passed as
             * RRRRRRRRGGGGGGGG BBBBBBBBrrrrrrrr ggggggggbbbbbbbb
             * rather than
             * RRRRRRRRGGGGGGGG BBBBBBBBxxxxxxxx rrrrrrrrgggggggg bbbbbbbbxxxxxxxx
             */
            PixModeSelect = 0x09;
            break;

        default:    /* 4 and 8 BPP */
            if (DoublePixel == TRUE)
                PixModeSelect = 0x05;
            else
                PixModeSelect = 0x00;
            break;
        }

    /*
     * Enable extended register/pixel mode.
     */
    ReadDac4();
    OUTP(DAC_MASK, 0x18);

    /*
     * Skip over the Pixel Command register, then write to indexed
     * registers 3 and 4 (Primrary and Secondary Pixel Mode Select
     * registers). Registers auto-increment when written.
     */
    ReadDac4();
    Dummy = INP(DAC_MASK);
    OUTP(DAC_MASK, 0x03);               /* Index low */
    OUTP(DAC_MASK, 0x00);               /* Index high */
    OUTP(DAC_MASK, PixModeSelect);      /* Primrary pixel mode select */
    OUTP(DAC_MASK, PixModeSelect);      /* Secondary pixel mode select */

    /*
     * In 8BPP double pixel mode, we must also set the PLL control
     * register. Since this mode is only used for 1280x1024 noninterlaced,
     * which always has a pixel clock frequency greater than 64 MHz,
     * the setting for this register is a constant.
     */
    if (DoublePixel == TRUE)
        OUTP(DAC_MASK, 0x02);       /* Input is 32 to 67.5 MHz, output 64 to 135 MHz */

    OUTPW(EXT_GE_CONFIG, ext_ge_config);
    Dummy = INP(DAC_W_INDEX);               /* Clear counter */

    return;

}   /* end InitSTG1702_m() */



/***************************************************************************
 *
 * void InitATT498_m(ext_ge_config, DoublePixel);
 *
 * WORD ext_ge_config;      Value to be written to EXT_GE_CONFIG register
 * BOOL DoublePixel;        Whether or not to use 8BPP double pixel mode
 *
 * DESCRIPTION:
 *  Initializes the AT&T 498 DAC to the desired colour depth.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  InitTi_<depth>_m(), UninitTiDac_m()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void InitATT498_m(WORD ext_ge_config, BOOL DoublePixel)
{
    unsigned char PixModeSelect;    /* Value to write to DAC Pixel Mode Select registers */
    unsigned char Dummy;            /* Scratch variable */


    /*
     * Get the value to be written to the DAC's Pixel Mode Select registers.
     */
    switch (ext_ge_config & 0x06F0)
        {
        case (PIX_WIDTH_16BPP | ORDER_16BPP_555):
            PixModeSelect = 0x17;
            break;

        case (PIX_WIDTH_16BPP | ORDER_16BPP_565):
            PixModeSelect = 0x37;
            break;

        case (PIX_WIDTH_24BPP | ORDER_24BPP_RGB):
        case (PIX_WIDTH_24BPP | ORDER_24BPP_RGBx):
            PixModeSelect = 0x57;
            break;

        default:    /* 4 and 8 BPP */
            if (DoublePixel == TRUE)
                PixModeSelect = 0x25;
            else
                PixModeSelect = 0x05;
            break;
        }

    /*
     * Get to the "hidden" Control Register 0, then fill it with
     * the appropriate pixel mode select value.
     */
    ReadDac4();
    OUTP(DAC_MASK, PixModeSelect);

    OUTPW(EXT_GE_CONFIG, ext_ge_config);
    Dummy = INP(DAC_W_INDEX);               /* Clear counter */

    return;

}   /* end InitATT498_m() */



/***************************************************************************
 *
 * void InitSC15021_m(ext_ge_config, DoublePixel);
 *
 * WORD ext_ge_config;      Value to be written to EXT_GE_CONFIG register
 * BOOL DoublePixel;        Whether or not to use 8BPP double pixel mode
 *
 * DESCRIPTION:
 *  Initializes the Sierra 15021 DAC to the desired colour depth.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  InitTi_<depth>_m(), UninitTiDac_m()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void InitSC15021_m(WORD ext_ge_config, BOOL DoublePixel)
{
    unsigned char Repack;           /* Value to write to Repack register */
    unsigned char ColourMode;       /* Colour mode to write to Command register */


    /*
     * Get the values to be written to the DAC's Repack (external to
     * internal data translation) and Command registers.
     */
    switch (ext_ge_config & 0x06F0)
        {
        case (PIX_WIDTH_16BPP | ORDER_16BPP_555):
            Repack = 0x08;
            ColourMode = 0x80;
            break;

        case (PIX_WIDTH_16BPP | ORDER_16BPP_565):
            Repack = 0x08;
            ColourMode = 0xC0;
            break;

        case (PIX_WIDTH_24BPP | ORDER_24BPP_RGB):
        case (PIX_WIDTH_24BPP | ORDER_24BPP_RGBx):
            Repack = 0x05;
            ColourMode = 0x40;
            break;

        default:    /* 4 and 8 BPP */
            if (DoublePixel == TRUE)
                Repack = 0x04;
            else
                Repack = 0x00;
            ColourMode = 0x00;
            break;
        }

    OUTPW(EXT_GE_CONFIG, ext_ge_config);

    /*
     * Get to the "hidden" Command register and set Extended
     * Register Programming Flag.
     */
    ReadDac4();
    OUTP(DAC_MASK, 0x10);

    /*
     * Write to the Extended Index register so the Extended Data
     * register points to the Repack register.
     */
    OUTP(DAC_R_INDEX, 0x10);

    /*
     * Write out the values for the Repack and Command registers.
     * Clearing bit 4 of the Command register (all our ColourMode
     * values have this bit clear) will clear the Extended Register
     * Programming flag.
     */
    OUTP(DAC_W_INDEX, Repack);
    OUTP(DAC_MASK, ColourMode);

    OUTPW(EXT_GE_CONFIG, ext_ge_config);

    return;

}   /* end InitSC15021_m() */



/***************************************************************************
 *
 * void InitSC15026_m(ext_ge_config);
 *
 * WORD ext_ge_config;      Value to be written to EXT_GE_CONFIG register
 *
 * DESCRIPTION:
 *  Initializes the Sierra 15026 DAC to the desired colour depth.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  InitTi_<depth>_m(), UninitTiDac_m()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void InitSC15026_m(WORD ext_ge_config)
{
    unsigned char ColourMode;       /* Colour mode to write to Command register */


    /*
     * Get the values to be written to the DAC's Repack (external to
     * internal data translation) and Command registers.
     */
    switch (ext_ge_config & 0x06F0)
        {
        case (PIX_WIDTH_16BPP | ORDER_16BPP_555):
            ColourMode = 0xA0;
            break;

        case (PIX_WIDTH_16BPP | ORDER_16BPP_565):
            ColourMode = 0xE0;
            break;

        case (PIX_WIDTH_24BPP | ORDER_24BPP_RGB):
        case (PIX_WIDTH_24BPP | ORDER_24BPP_RGBx):
            ColourMode = 0x60;
            break;

        default:    /* 4 and 8 BPP */
            ColourMode = 0x00;
            break;
        }

    OUTPW(EXT_GE_CONFIG, ext_ge_config);

    /*
     * Get to the "hidden" Command register and set Extended
     * Register Programming Flag.
     */
    ReadDac4();
    OUTP(DAC_MASK, 0x10);

    /*
     * Write to the Extended Index register so the Extended Data
     * register points to the Repack register.
     */
    OUTP(DAC_R_INDEX, 0x10);

    /*
     * Write out the values for the Repack and Command registers.
     * Clearing bit 4 of the Command register (all our ColourMode
     * values have this bit clear) will clear the Extended Register
     * Programming flag. All of our supported pixel depths use
     * a Repack value of zero.
     */
    OUTP(DAC_W_INDEX, 0);
    OUTP(DAC_MASK, ColourMode);

    OUTPW(EXT_GE_CONFIG, ext_ge_config);

    return;

}   /* end InitSC15026_m() */



/***************************************************************************
 *
 * void ReadDac4(void);
 *
 * DESCRIPTION:
 *  Gain access to the extended registers on STG1700 and similar DACs.
 *  These registers are hidden behind the pixel mask register. To access
 *  them, read the DAC_W_INDEX register once, then the DAC_MASK register
 *  four times. The next access to the DAC_MASK register will then be
 *  to the Pixel Command register. If access to another extended register
 *  is desired, each additional read from DAC_MASK will skip to the
 *  next extended register.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  Init<DAC type>_m()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void ReadDac4(void)
{
    UCHAR Dummy;        /* Scratch variable */

    Dummy = INP(DAC_W_INDEX);
    Dummy = INP(DAC_MASK);
    Dummy = INP(DAC_MASK);
    Dummy = INP(DAC_MASK);
    Dummy = INP(DAC_MASK);
    return;

}   /* end ReadDac4() */



/*
 * void UninitTiDac_m(void);
 *
 * Prepare DAC for 8514/A compatible mode on
 * 8514/A-compatible ATI accelerators.
 */
void UninitTiDac_m (void)
{
    struct query_structure *QueryPtr;   /* Query information for the card */

    /*
     * Get a formatted pointer into the query section of HwDeviceExtension.
     * The CardInfo[] field is an unformatted buffer.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);

    Passth8514_m(SHOW_ACCEL);    // can only program DAC in 8514 mode

    switch (QueryPtr->q_DAC_type)
        {
        case DAC_TI34075:
            OUTPW (EXT_GE_CONFIG,0x201a);       /* set EXT_DAC_ADDR field */
            DEC_DELAY
            OUTP (DAC_DATA,0);      /* Input clock source is CLK0 */
            DEC_DELAY
            OUTP (DAC_MASK,0);      /* Output clock is SCLK/1 and VCLK/1 */
            DEC_DELAY
            OUTP (DAC_R_INDEX,0x2d);       /* set MUX CONTROL TO 8/16 */
            DEC_DELAY

            /* set default 8bpp pixel delay and blank adjust */
            OUTPW (LOCAL_CONTROL,(WORD)(INPW(LOCAL_CONTROL) | 8));  // TI_DAC_BLANK_ADJUST is always on
            DEC_DELAY
            SetBlankAdj_m(0xc);
            DEC_DELAY
            OUTPW(HORZ_OVERSCAN,1);             /* set horizontal skew */
            DEC_DELAY
            break;

        case DAC_STG1700:
            InitSTG1700_m(PIX_WIDTH_8BPP | 0x000A, FALSE);
            break;

        case DAC_STG1702:
        case DAC_STG1703:
            InitSTG1702_m(PIX_WIDTH_8BPP | 0x000A, FALSE);
            break;

        case DAC_ATT498:
            InitATT498_m(PIX_WIDTH_8BPP | 0x000A, FALSE);
            break;

        case DAC_SC15021:
            InitSC15021_m(PIX_WIDTH_8BPP | 0x000A, FALSE);
            break;

        case DAC_SC15026:
            InitSC15026_m(PIX_WIDTH_8BPP | 0x000A);
            break;

        case DAC_ATT491:
        case DAC_BT48x:
            OUTPW (EXT_GE_CONFIG,0x101a);
            OUTP  (DAC_MASK,0);
            /* Intentional fallthrough */

        default:
            SetBlankAdj_m(0);                       /* PIXEL_DELAY=0 */
            OUTPW(HORZ_OVERSCAN,0);                 /* set horizontal skew */
            break;
        }

// reset EXT_DAC_ADDR, put DAC in 6 bit mode, engine in 8 bit mode
    OUTPW(EXT_GE_CONFIG,0x1a);
    DEC_DELAY
    Passth8514_m(SHOW_VGA);
    return;

}   /* UninitTiDac_m() */

/***************************************************************************
 *
 * void SetPalette_m(lpPalette, StartIndex, Count);
 *
 * PPALETTEENTRY lpPalette;     Colour values to plug into palette
 * USHORT StartIndex;           First palette entry to set
 * USHORT Count;                Number of palette entries to set
 *
 * DESCRIPTION:
 *  Set the desired number of palette entries to the specified colours,
 *  starting at the specified index. Colour values are stored in
 *  doublewords, in the order (low byte to high byte) RGBx.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  SetCurrentMode_m() and IOCTL_VIDEO_SET_COLOR_REGISTERS packet
 *  of ATIMPStartIO()
 *
 * AUTHOR:
 *  unknown
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void SetPalette_m(PULONG lpPalette, USHORT StartIndex, USHORT Count)
{
int     i;
BYTE *pPal=(BYTE *)lpPalette;

        OUTP(DAC_W_INDEX,(BYTE)StartIndex);     // load DAC_W_INDEX with StartIndex

        for (i=0; i<Count; i++)         // this is number of colours to update
            {
            OUTP(DAC_DATA, *pPal++);    // red
            OUTP(DAC_DATA, *pPal++);    // green
            OUTP(DAC_DATA, *pPal++);    // blue
            pPal++;
            }

    return;

}   /* SetPalette_m() */



/**************************************************************************
 *
 * void SetTextMode_m(void);
 *
 * DESCRIPTION:
 *  Switch into 80x25 16 colour text mode using register writes rather
 *  than BIOS calls. This allows systems with no video BIOS (e.g. DEC
 *  ALPHA) to return to a text screen when shutting down and rebooting.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  ATIMPStartIO(), packet IOCTL_VIDEO_RESET_DEVICE
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 **************************************************************************/

void SetTextMode_m(void)
{
    short LoopCount;        /* Loop counter */
    BYTE Scratch;           /* Temporary variable */
    BYTE Seq02;             /* Saved value of Sequencer register 2 */
    BYTE Seq04;             /* Saved value of Sequencer register 4 */
    BYTE Gra05;             /* Saved value of Graphics register 5 */
    BYTE Gra06;             /* Saved value of Graphics register 6 */
    WORD ExtGeConfig;       /* Saved contents of EXT_GE_CONFIG register */
    WORD MiscOptions;       /* Saved contents of MISC_OPTIONS register */
    WORD Column;            /* Current byte of font data being dealt with */
    WORD ScreenColumn;      /* Screen column corresponding to current byte of font data */
    WORD Row;               /* Current character being dealt with */

    /*
     * Let the VGA drive the screen. Mach 8 cards have separate VGA and
     * accelerator controllers, so no further action needs to be taken
     * once this is done. Mach 32 cards need to be put into VGA text mode.
     */
    Passth8514_m(SHOW_VGA);
    if (phwDeviceExtension->ModelNumber != MACH32_ULTRA)
        return;

    /*
     * Stop the sequencer to change memory timing
     * and memory organization
     */
    OUTPW(HI_SEQ_ADDR, 0x00 | (0x01 << 8));

    for (LoopCount = 1; LoopCount <= S_LEN; ++LoopCount)
        OUTPW(HI_SEQ_ADDR, (WORD)(LoopCount | (StdTextCRTC_m[S_PARM + LoopCount - 1] << 8)));

    /*
     * Program the extended VGAWonder registers
     */
    for (LoopCount = 0; ExtTextCRTC_m[LoopCount] != 0; LoopCount += 3)
        {
        OUTP(reg1CE, ExtTextCRTC_m[LoopCount]);
        Scratch = (INP(reg1CF) & ExtTextCRTC_m[LoopCount + 1]) | ExtTextCRTC_m[LoopCount + 2];
        OUTPW(reg1CE, (WORD)(ExtTextCRTC_m[LoopCount] | (Scratch << 8)));
        }

    LioOutp(regVGA_END_BREAK_PORT, StdTextCRTC_m[MIS_PARM], GENMO_OFFSET);

    /*
     * Restart the sequencer after the memory changes
     */
    OUTPW(HI_SEQ_ADDR, 0x00 | (0x03 << 8));

    /*
     * Program the CRTC controller
     */
    LioOutpw(regVGA_END_BREAK_PORT, 0x11 | (0x00 << 8), CRTX_COLOUR_OFFSET);

    for (LoopCount = 0; LoopCount < C_LEN; ++LoopCount)
        LioOutpw(regVGA_END_BREAK_PORT, (WORD)(LoopCount | (StdTextCRTC_m[C_PARM + LoopCount] << 8)), CRTX_COLOUR_OFFSET);

    /*
     * Program the Attribute controller (internal palette)
     */
    Scratch = LioInp(regVGA_END_BREAK_PORT, GENS1_COLOUR_OFFSET);
    for (LoopCount = 0; LoopCount < A_LEN; LoopCount++)
        {
        OUTP(regVGA_END_BREAK_PORT, (BYTE)LoopCount);
        OUTP(regVGA_END_BREAK_PORT, StdTextCRTC_m[A_PARM + LoopCount]);
        }
    OUTP(regVGA_END_BREAK_PORT, 0x14);
    OUTP(regVGA_END_BREAK_PORT, 0x00);

    /*
     * Program the graphics controller
     */
    for (LoopCount = 0; LoopCount < G_LEN; ++LoopCount)
        OUTPW(reg3CE, (WORD)(LoopCount | (StdTextCRTC_m[G_PARM + LoopCount] << 8)));

    /*
     * Program the DAC (external palette)
     */
    for (LoopCount = 0; LoopCount < 0x10; ++LoopCount)
        {
        LioOutp(regVGA_END_BREAK_PORT, StdTextCRTC_m[A_PARM + LoopCount], DAC_W_INDEX_OFFSET);
        LioOutp(regVGA_END_BREAK_PORT, TextDAC_m[LoopCount * 3], DAC_DATA_OFFSET);
        LioOutp(regVGA_END_BREAK_PORT, TextDAC_m[LoopCount * 3 + 1], DAC_DATA_OFFSET);
        LioOutp(regVGA_END_BREAK_PORT, TextDAC_m[LoopCount * 3 + 2], DAC_DATA_OFFSET);
        }

    /*
     * Turn on the display
     */
    Scratch = LioInp(regVGA_END_BREAK_PORT, GENS1_COLOUR_OFFSET);
    OUTP(regVGA_END_BREAK_PORT, 0x20);

    /*
     * No need to clear the screen.
     * First, the driver should not call Map Frame while the machine is
     * bug checking !!!
     * Second, it is not necessary to clear the screen since the HAL will
     * do it.
     */

    /*
     * Initialize the 8x16 font. Start by saving the registers which
     * are changed during font initialization.
     */
    OUTP(SEQ_IND, 0x02);
    Seq02 = INP(SEQ_DATA);
    OUTP(SEQ_IND, 4);
    Seq04 = INP(SEQ_DATA);
    OUTP(reg3CE, 5);
    Gra05 = INP_HBLW(reg3CE);
    OUTP(reg3CE, 6);
    Gra06 = INP_HBLW(reg3CE);

    /*
     * Set up to allow font loading
     */
    OUTPW(reg3CE, 0x0005);
    OUTPW(reg3CE, 0x0406);
    OUTPW(HI_SEQ_ADDR, 0x0402);
    OUTPW(HI_SEQ_ADDR, 0x0704);

    /*
     * Load our font data into video memory. This would normally be
     * done through the VGA aperture, but some machines (including
     * the DEC ALPHA) are unable to use the VGA aperture. Since
     * this routine is needed to re-initialize the VGA text screen
     * on non-80x86 machines (which can't use the BIOS), and some
     * of these are unable to use the VGA aperture, we need an
     * alternate method of loading the font data.
     *
     * The font data occupies byte 2 (zero-based) of each doubleword
     * for the first 8192 doublewords of video memory, in the pattern
     * 16 bytes of character data followed by 16 zero bytes. To load
     * the font data using the graphics engine, set it to 8BPP at a
     * screen pitch of 128 pixels (32 doublewords per line). In the
     * first 16 font data columns, use a host to scr