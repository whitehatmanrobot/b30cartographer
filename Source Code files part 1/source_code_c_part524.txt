const {return pstr;}

    wstring & operator =(const wstring &str){return assign(str.c_str());}
    wstring & operator +=(const wstring &str){return append(str.c_str());}
    wstring & operator =(const wchar_t *psz){return assign(psz);}
    wstring & operator +=(const wchar_t *psz){return append(psz);}
    bool      operator ==(const wstring &str) const {return isequal(str.c_str());}
    bool      operator ==(const wchar_t *psz) const {return isequal(psz);}
    bool      operator !=(const wstring &str) const {return !isequal(str.c_str());}
    bool      operator !=(const wchar_t *psz) const {return !isequal(psz);}

    size_t length()const {return (0==pstr) ? 0 : wcslen(pstr);}
    void   truncate(size_t i){if(i<length())pstr[i]=0x00;}
private:
    wchar_t *pstr;

    wstring & append(const wchar_t *psz)
    {
        if(!pstr)
            assign(psz);
        else if(psz)
        {
            pstr = reinterpret_cast<wchar_t *>(CoTaskMemRealloc(pstr, sizeof(wchar_t)*(wcslen(pstr)+wcslen(psz)+1)));
            if(pstr)
                wcscat(pstr, psz);
        }
        return *this;
    }
    wstring & assign(const wchar_t *psz)
    {
        if(psz)
        {
            pstr = reinterpret_cast<wchar_t *>(CoTaskMemRealloc(pstr, sizeof(wchar_t)*(wcslen(psz)+1)));
            if(pstr)
                wcscpy(pstr, psz);
        }
        return *this;
    }
    bool      isequal(const wchar_t *psz) const {return (0==wcscmp(pstr, psz));}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\shared\util\safecs.cpp ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        SafeCS.cpp
//
// Contents:    CSafeAutoCriticalSection implementation
//              CSafeLock implementation
//
//------------------------------------------------------------------------
#include "precomp.hxx"



//+--------------------------------------------------------------------------
//
//  Class:      CSafeAutoCriticalSection
//
//  Purpose:    Wrapper for initializing critical-sections.
//
//  Interface:  Lock			- locks the critical section
//				Unlock			- unlocks the critical section
//				Constructor		- initializes the critical section
//				Detructor		- uninitializes the critical section
//
//  Notes:		This provides a convenient way to ensure that you're
//              you wrap InitializeCriticalSection and
//              UnInitializeCriticalSection in try catches which is useful
//              in low-mem conditions
//
//---------------------------------------------------------------------------

//+--------------------------------------------------------------------------
// Default constructor - Initializes the critical section and sets the state
// flag to initialized
//+--------------------------------------------------------------------------

CSafeAutoCriticalSection::CSafeAutoCriticalSection()
{
    LONG  lPreviousState;

    m_lState = STATE_UNINITIALIZED;
	m_dwError = ERROR_SUCCESS;

    // try to set state flag
    lPreviousState = InterlockedCompareExchange( &m_lState,
                                                 STATE_INITIALIZED,
                                                 STATE_UNINITIALIZED );

    // if this critical section was not initialized
    if ( STATE_UNINITIALIZED == lPreviousState )
    {
		if ( !InitializeCriticalSectionAndSpinCount( &m_cs, 0 ) )
        {
            m_dwError = GetLastError();
        }
    }

    // failed to initialize - need to reset
    if( ERROR_SUCCESS != m_dwError )
    {
        m_lState = STATE_UNINITIALIZED;
    }

}

//+--------------------------------------------------------------------------
// Destructor
//+--------------------------------------------------------------------------

CSafeAutoCriticalSection::~CSafeAutoCriticalSection()
{
    LONG                lPreviousState;

    // try to reset the the state to uninitialized
    lPreviousState = InterlockedCompareExchange(&m_lState,
                                                STATE_UNINITIALIZED,
                                                STATE_INITIALIZED);

    // if the object was initialized delete the critical section
    if ( STATE_INITIALIZED == lPreviousState )
    {
        DeleteCriticalSection( &m_cs );
    }
}

//+--------------------------------------------------------------------------
// Enters critical section, if needed initializes critical section
// before entering
//
// Returns
//	DWORD -	ERROR_SUCCESS if everything is fine
//			ERROR_OUTOFMEMORY if failed to create or enter critical section
//+--------------------------------------------------------------------------

DWORD CSafeAutoCriticalSection::Lock()
{
    DWORD dwError = ERROR_SUCCESS;

    if(!IsInitialized())
    {
        return m_dwError;
    }

    EnterCriticalSection(&m_cs);

    return dwError;
}

//+--------------------------------------------------------------------------
// Leaves critical section
//+--------------------------------------------------------------------------
DWORD CSafeAutoCriticalSection::Unlock()
{
    if(!IsInitialized())
    {
        return m_dwError;
    }

    LeaveCriticalSection(&m_cs);

    return ERROR_SUCCESS;

}

//+--------------------------------------------------------------------------
//
//  Class:      CSafeLock
//
//  Purpose:    Auto-unlocking critical-section services
//
//  Interface:  Lock			- locks the critical section
//				Unlock			- unlocks the critical section
//				Constructor		- locks the critical section (unless told
//								  otherwise)
//				Detructor		- unlocks the critical section if its locked
//
//  Notes:		This provides a convenient way to ensure that you're
//              unlocking a CSemExclusive, which is useful if your routine
//              can be left via several returns and/or via exceptions....
//
//---------------------------------------------------------------------------

CSafeLock::CSafeLock(CSafeAutoCriticalSection* val) :
m_pSem(val),
m_locked(FALSE)
{
}

CSafeLock::CSafeLock(CSafeAutoCriticalSection& val) :
m_pSem(&val),
m_locked(FALSE)
{
}

CSafeLock::~CSafeLock()
{
	if (m_locked)
	{
		m_pSem->Unlock();
	}
}

DWORD CSafeLock::Lock()
{
	DWORD dwError = ERROR_SUCCESS;

	if(!m_locked)
	{
		dwError = m_pSem->Lock();

		if(ERROR_SUCCESS == dwError)
		{
			m_locked = TRUE;
		}
	}

	return dwError;
}


DWORD CSafeLock::Unlock()
{
	DWORD dwError = ERROR_SUCCESS;

	if(m_locked)
	{
		dwError = m_pSem->Unlock();
		m_locked = FALSE;
	}

	return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\plugins\metabasedifferencing\metabasedifferencing.h ===
//  Copyright (C) 2000-2001 Microsoft Corporation.  All rights reserved.

#pragma once

class TMetabaseDifferencing: public IInterceptorPlugin
{
public:
	TMetabaseDifferencing ();
	~TMetabaseDifferencing ();

public:

	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv);
	STDMETHOD_(ULONG,AddRef)		();
	STDMETHOD_(ULONG,Release)		();

	STDMETHOD(Intercept)				(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ULONG i_TableID, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD i_eQueryFormat, DWORD i_fTable, IAdvancedTableDispenser* i_pISTDisp, LPCWSTR i_wszLocator, LPVOID i_pSimpleTable, LPVOID* o_ppv);
	STDMETHOD(OnPopulateCache)		    (ISimpleTableWrite2* i_pISTShell);
	STDMETHOD(OnUpdateStore)		    (ISimpleTableWrite2* i_pISTShell);

private:
    static ULONG                    m_kInsert;
    static ULONG                    m_kUpdate;
    static ULONG                    m_kDelete;
    static ULONG                    m_kDeleteNode;
    static ULONG                    m_kOne;
    static ULONG                    m_kTwo;
    static ULONG                    m_kZero;

	ULONG							m_cRef;
    long                            m_IsIntercepted;

    CComPtr<ISimpleTableWrite2>     m_ISTOriginal;
    CComPtr<ISimpleTableWrite2>     m_ISTUpdated;

    HRESULT DeleteNodeRow   (tMBPropertyDiffRow &row, ULONG *aSize, ISimpleTableWrite2* i_pIST);
    HRESULT DeleteRow       (tMBPropertyDiffRow &row, ULONG *aSize, ISimpleTableWrite2* i_pIST);
    HRESULT InsertRow       (tMBPropertyDiffRow &row, ULONG *aSize, ISimpleTableWrite2* i_pIST);
    HRESULT UpdateRow       (tMBPropertyDiffRow &row, ULONG *aSize, ISimpleTableWrite2* i_pIST);

    HRESULT GetColumnValues_AsMBPropertyDiff(ISimpleTableWrite2 *i_pISTWrite, ULONG i_iRow, ULONG o_aSizes[], tMBPropertyDiffRow &o_DiffRow);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\shared\util\eventlogger.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name:
    EventLogger.h

$Header: $

Abstract: This class implements ICatalogErrorLogger2 interface and
            sends error information to the NT EventLog

Author:
    stephenr 	4/26/2001		Initial Release

Revision History:

--**************************************************************************/
#include "precomp.hxx"


//=================================================================================
// Function: ReportError
//
// Synopsis: Mechanism for reporting errors to the NT EventLog
//
// Arguments: [i_BaseVersion_DETAILEDERRORS] -
//            [i_ExtendedVersion_DETAILEDERRORS] -
//            [i_cDETAILEDERRORS_NumberOfColumns] -
//            [i_acbSizes] -
//            [i_apvValues] -
//
// Return Value:
//=================================================================================
HRESULT
EventLogger::ReportError
(
    ULONG      i_BaseVersion_DETAILEDERRORS,
    ULONG      i_ExtendedVersion_DETAILEDERRORS,
    ULONG      i_cDETAILEDERRORS_NumberOfColumns,
    ULONG *    i_acbSizes,
    LPVOID *   i_apvValues
)
{
    HRESULT             hr = S_OK;
    HRESULT             hrT = S_OK;
    DWORD               dwError = 0;
    BOOL                fRet = FALSE;
    WCHAR               wszInsertionString5[1024];
    tDETAILEDERRORSRow  errorRow;
    LPCTSTR             pInsertionStrings[5];
    HANDLE              hEventSource = NULL;

    memset(&errorRow, 0x00, sizeof(tDETAILEDERRORSRow));

    if(i_BaseVersion_DETAILEDERRORS != BaseVersion_DETAILEDERRORS)
    {
        hr = E_ST_BADVERSION;
        goto exit;
    }

    if(0 == i_apvValues)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if(i_cDETAILEDERRORS_NumberOfColumns <= iDETAILEDERRORS_ErrorCode)//we need at least this many columns
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    memcpy(&errorRow, i_apvValues, i_cDETAILEDERRORS_NumberOfColumns * sizeof(void *));

    if(0 == errorRow.pType)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if(0 == errorRow.pCategory)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if(0 == errorRow.pEvent)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if(0 == errorRow.pSource)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if(0 == errorRow.pString5)
    {
        FillInInsertionString5(wszInsertionString5, 1024, errorRow);
    }

    pInsertionStrings[4] = errorRow.pString5 ? errorRow.pString5 : L"";
    pInsertionStrings[3] = errorRow.pString5 ? errorRow.pString4 : L"";
    pInsertionStrings[2] = errorRow.pString5 ? errorRow.pString3 : L"";
    pInsertionStrings[1] = errorRow.pString5 ? errorRow.pString2 : L"";
    pInsertionStrings[0] = errorRow.pString5 ? errorRow.pString1 : L"";

    hEventSource = RegisterEventSource(NULL, errorRow.pSource);
    if ( hEventSource == NULL )
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32( dwError );
        // Do NOT bail, just remember the error to allow the next logger to log even in case of failure.
    }
    else
    {
        fRet = ReportEvent(hEventSource, LOWORD(*errorRow.pType), LOWORD(*errorRow.pCategory), *errorRow.pEvent, 0, 5, 0, pInsertionStrings, 0);
        if ( !fRet )
        {
            dwError = GetLastError();
            hr = HRESULT_FROM_WIN32( dwError );
            // Do NOT bail, just remember the error to allow the next logger to log even in case of failure.
        }
    }

    if(m_spNextLogger)//is there a chain of loggers
    {
        hrT =  m_spNextLogger->ReportError(i_BaseVersion_DETAILEDERRORS,
                                           i_ExtendedVersion_DETAILEDERRORS,
                                           i_cDETAILEDERRORS_NumberOfColumns,
                                           i_acbSizes,
                                           reinterpret_cast<LPVOID *>(&errorRow));//instead of passing forward i_apvValues, let's use errorRow since it has String5
    }

    if ( SUCCEEDED(hr) && FAILED(hrT) )
    {
        hr = hrT;
    }

exit:
    if ( hEventSource != NULL )
    {
        DeregisterEventSource(hEventSource);
        hEventSource = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\shared\util\svcerr.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#include "precomp.hxx"

extern HMODULE g_hModule;// Module handle
LPWSTR  g_wszDefaultProduct = L"";//this can be changed by CatInProc or whomever knows best what the default product ID is.
bool    g_bReportErrorsToEventLog = true;
bool    g_bReportErrorsToTextFile = true;

// functions
void LogWinError (const wchar_t* szMsg,
                  int   rc,
                  const wchar_t* szFile,
                  int   iLine)
{
    CErrorInterceptor(  0                           ,//ISimpleTableWrite2 **           ppErrInterceptor,
                        0                           ,//IAdvancedTableDispenser *       pDisp,
                        static_cast<HRESULT>(rc)    ,//HRESULT                         hrErrorCode,
                        ID_CAT_CAT                  ,//ULONG                           ulCategory,
                        IDS_CATALOG_INTERNAL_ERROR  ,//ULONG                           ulEvent,
                        szMsg                       ,//LPCWSTR                         szString1,
                        0                           ,//ULONG                           ulInterceptor=0,
                        0                           ,//LPCWSTR                         szTable=0,
                        eDETAILEDERRORS_Unspecified ,//eDETAILEDERRORS_OperationType   OperationType=eDETAILEDERRORS_Unspecified,
                        iLine                       ,//ULONG                           ulRow=-1,
                        (ULONG)-1                   ,//ULONG                           ulColumn=-1,
                        szFile                       //LPCWSTR                         szConfigurationSource=0,
                        ).WriteToLog(szFile, iLine);
}


/////////////////////////////////////////////////////
//
// TErrorLogWriter
//
// This object writes an entry into the EventLog and
// one into the CatalogEventLog XML file.
//
class TErrorLogWriter
{
public:
    TErrorLogWriter() : m_hEventSource(0)
    {
    }
    ~TErrorLogWriter()
    {
        Close();
    }
    HRESULT WriteDetailedErrors(tDETAILEDERRORSRow &row, ULONG * aSizes=0, ULONG cSizes=0);
private:
    HRESULT Open(LPCWSTR wszSourceName);
    HRESULT Close();

    HANDLE m_hEventSource;
};

TErrorLogWriter g_ErrorLogWriter;

HRESULT TErrorLogWriter::Open(LPCWSTR wszSourceName)
{
    m_hEventSource = RegisterEventSource(NULL, wszSourceName);
    return S_OK;
}

HRESULT TErrorLogWriter::Close()
{
    if(0 != m_hEventSource)
        DeregisterEventSource(m_hEventSource);
    return S_OK;
}

HRESULT TErrorLogWriter::WriteDetailedErrors(tDETAILEDERRORSRow &row, ULONG * aSizes, ULONG cSizes)
{
    HRESULT hr;

    UNREFERENCED_PARAMETER(aSizes);
    UNREFERENCED_PARAMETER(cSizes);

    if(0==m_hEventSource)
        if(FAILED(hr = Open(row.pSource)))
            return hr;

    ASSERT(row.pString1);
    ASSERT(row.pString2);
    ASSERT(row.pString3);
    ASSERT(row.pString4);
    ASSERT(row.pString5);

    LPCWSTR pStrings[5];
    pStrings[0] = row.pString1;
    pStrings[1] = row.pString2;
    pStrings[2] = row.pString3;
    pStrings[3] = row.pString4;
    pStrings[4] = row.pString5;

    if(g_bReportErrorsToEventLog)
        ReportEvent(m_hEventSource, LOWORD(*row.pType), LOWORD(*row.pCategory), *row.pEvent, 0, 5, 0, pStrings, 0);
    //TraceEvent(row, pStrings);

    if(g_bReportErrorsToTextFile)
        TextFileLogger(row.pSource, g_hModule).Report(LOWORD(*row.pType), LOWORD(*row.pCategory), *row.pEvent, 5, 0, pStrings, 0);

    return S_OK;
}


//class CErrorInterceptor implementation
ULONG CErrorInterceptor::cError=0;
CErrorInterceptor::CErrorInterceptor(
                        HRESULT                         hrErrorCode,
                        ULONG                           ulCategory,
                        ULONG                           ulEvent,
                        LPCWSTR                         szString1,
                        LPCWSTR                         szString2,
                        LPCWSTR                         szString3,
                        LPCWSTR                         szString4,
                        eDETAILEDERRORS_Type            eType,
                        unsigned char *                 pData,
                        ULONG                           cbData,
                        BOOL                            bNotUsed)
                        : m_pStorage(0)
{
    UNREFERENCED_PARAMETER(pData);
    UNREFERENCED_PARAMETER(cbData);
    UNREFERENCED_PARAMETER(bNotUsed);

    Init(   0,   0,    hrErrorCode,    ulCategory,    ulEvent,    szString1, szString2, szString3, szString4,
            0,   0,    eDETAILEDERRORS_Unspecified,   (ULONG)-1,  (ULONG)-1, 0,         eType);
}
CErrorInterceptor::CErrorInterceptor(
                        ISimpleTableWrite2 **           ppErrInterceptor,
                        IAdvancedTableDispenser *       pDisp,
                        HRESULT                         hrErrorCode,
                        ULONG                           ulCategory,
                        ULONG                           ulEvent,
                        LPCWSTR                         szString1,
                        ULONG                           ulInterceptor,
                        LPCWSTR                         szTable,
                        eDETAILEDERRORS_OperationType   OperationType,
                        ULONG                           ulRow,
                        ULONG                           ulColumn,
                        LPCWSTR                         szConfigurationSource,
                        eDETAILEDERRORS_Type            eType,
                        unsigned char *                 pData,
                        ULONG                           cbData,
                        ULONG                           MajorVersion,
                        ULONG                           MinorVersion)
                        : m_pStorage(0)
{
    Init(   ppErrInterceptor,   pDisp,    hrErrorCode,    ulCategory,    ulEvent,    szString1,     0,      0,      0,
            ulInterceptor,      szTable,  OperationType,  ulRow,         ulColumn,   szConfigurationSource, eType,  pData,  cbData, MajorVersion, MinorVersion);
}
CErrorInterceptor::CErrorInterceptor(
                        ISimpleTableWrite2 **           ppErrInterceptor,
                        IAdvancedTableDispenser *       pDisp,
                        HRESULT                         hrErrorCode,
                        ULONG                           ulCategory,
                        ULONG                           ulEvent,
                        LPCWSTR                         szString1,
                        LPCWSTR                         szString2,
                        ULONG                           ulInterceptor,
                        LPCWSTR                         szTable,
                        eDETAILEDERRORS_OperationType   OperationType,
                        ULONG                           ulRow,
                        ULONG                           ulColumn,
                        LPCWSTR                         szConfigurationSource,
                        eDETAILEDERRORS_Type            eType,
                        unsigned char *                 pData,
                        ULONG                           cbData,
                        ULONG                           MajorVersion,
                        ULONG                           MinorVersion)
                        : m_pStorage(0)
{
    Init(   ppErrInterceptor,   pDisp,    hrErrorCode,    ulCategory,    ulEvent,    szString1,    szString2,    0,    0,
            ulInterceptor,      szTable,  OperationType,  ulRow,         ulColumn,   szConfigurationSource,      eType,         pData,        cbData, MajorVersion, MinorVersion);
}
CErrorInterceptor::CErrorInterceptor(
                        ISimpleTableWrite2 **           ppErrInterceptor,
                        IAdvancedTableDispenser *       pDisp,
                        HRESULT                         hrErrorCode,
                        ULONG                           ulCategory,
                        ULONG                           ulEvent,
                        LPCWSTR                         szString1,
                        LPCWSTR                         szString2,
                        LPCWSTR                         szString3,
                        ULONG                           ulInterceptor,
                        LPCWSTR                         szTable,
                        eDETAILEDERRORS_OperationType   OperationType,
                        ULONG                           ulRow,
                        ULONG                           ulColumn,
                        LPCWSTR                         szConfigurationSource,
                        eDETAILEDERRORS_Type            eType,
                        unsigned char *                 pData,
                        ULONG                           cbData,
                        ULONG                           MajorVersion,
                        ULONG                           MinorVersion)
                        : m_pStorage(0)
{
    Init(   ppErrInterceptor,   pDisp,    hrErrorCode,    ulCategory,    ulEvent,    szString1,    szString2,    szString3,    0,
            ulInterceptor,      szTable,  OperationType,  ulRow,         ulColumn,   szConfigurationSource,      eType,         pData,        cbData, MajorVersion, MinorVersion);
}
CErrorInterceptor::CErrorInterceptor(
                        ISimpleTableWrite2 **           ppErrInterceptor,
                        IAdvancedTableDispenser *       pDisp,
                        HRESULT                         hrErrorCode,
                        ULONG                           ulCategory,
                        ULONG                           ulEvent,
                        LPCWSTR                         szString1,
                        LPCWSTR                         szString2,
                        LPCWSTR                         szString3,
                        LPCWSTR                         szString4,
                        ULONG                           ulInterceptor,
                        LPCWSTR                         szTable,
                        eDETAILEDERRORS_OperationType   OperationType,
                        ULONG                           ulRow,
                        ULONG                           ulColumn,
                        LPCWSTR                         szConfigurationSource,
                        eDETAILEDERRORS_Type            eType,
                        unsigned char *                 pData,
                        ULONG                           cbData,
                        ULONG                           MajorVersion,
                        ULONG                           MinorVersion)
                        : m_pStorage(0)
{
    Init(   ppErrInterceptor,   pDisp,    hrErrorCode,    ulCategory,    ulEvent,    szString1,    szString2,    szString3,    szString4,
            ulInterceptor,      szTable,  OperationType,  ulRow,         ulColumn,   szConfigurationSource,      eType,         pData,        cbData, MajorVersion, MinorVersion);
}
void CErrorInterceptor::Init(
                        ISimpleTableWrite2 **           ppErrInterceptor,
                        IAdvancedTableDispenser *       pDisp,
                        HRESULT                         hrErrorCode,
                        ULONG                           ulCategory,
                        ULONG                           ulEvent,
                        LPCWSTR                         szString1,
                        LPCWSTR                         szString2,
                        LPCWSTR                         szString3,
                        LPCWSTR                         szString4,
                        ULONG                           ulInterceptor,
                        LPCWSTR                         szTable,
                        eDETAILEDERRORS_OperationType   OperationType,
                        ULONG                           ulRow,
                        ULONG                           ulColumn,
                        LPCWSTR                         szConfigurationSource,
                        eDETAILEDERRORS_Type            eType,
                        unsigned char *                 pData,
                        ULONG                           cbData,
                        ULONG                           MajorVersion,
                        ULONG                           MinorVersion)
{
    UNREFERENCED_PARAMETER(pData);
    UNREFERENCED_PARAMETER(cbData);
    m_pStorage = new ErrorInterceptorStorage;
    if(0 == m_pStorage)
    {
        m_hr = E_OUTOFMEMORY;
        return;
    }

    m_pStorage->m_pIErrorInfo = 0;
    m_pStorage->m_pISTWriteError = 0;
    m_pStorage->m_pISTControllerError = 0;

    m_hr = S_OK;

    if(0 != ppErrInterceptor)
    {
        if(0 == *ppErrInterceptor)//If the user passed us a valid pp but *p is zero then we need to
        {                         //instantiate an error table.
            if(FAILED(m_hr = pDisp->GetTable(wszDATABASE_ERRORS, wszTABLE_DETAILEDERRORS, 0, 0, eST_QUERYFORMAT_CELLS,
                                fST_LOS_UNPOPULATED, reinterpret_cast<LPVOID *>(&m_pStorage->m_pISTWriteError))))
                return;
            *ppErrInterceptor = m_pStorage->m_pISTWriteError;//we don't keep a ref count, the caller is responsible for that
        }
        else
        {
            m_pStorage->m_pISTWriteError = *ppErrInterceptor;//we don't keep a ref count, the caller is responsible for that
        }

        if(FAILED(m_hr = m_pStorage->m_pISTWriteError->QueryInterface(IID_ISimpleTableController, reinterpret_cast<LPVOID *>(&m_pStorage->m_pISTControllerError))))
            return;
        if(FAILED(m_hr = m_pStorage->m_pISTWriteError->QueryInterface(IID_ISimpleTableController, reinterpret_cast<LPVOID *>(&m_pStorage->m_pIErrorInfo))))
            return;
    }


/*
struct tDETAILEDERRORSRow {
         ULONG *     pErrorID;              //Inferred as some unique increasing value
         WCHAR *     pDescription;          //Inferred from the other columns
         WCHAR *     pDate;                 //Inferred from API call
         WCHAR *     pTime;                 //Inferred from API call
         WCHAR *     pSource;               //Passed in or obtained from the Dispenser
         ULONG *     pType;                 //Inferred from the Upper 2 bits of the HRESULT ErrorCode
         ULONG *     pCategory;             //Passed in / defaulted to ID_CAT_CAT
         WCHAR *     pUser;                 //Inferred from API call - This is the user account that was running or N/A
         WCHAR *     pComputer;             //Interred from API call
 unsigned char *     pData;                 //User binary data may be passed in
         ULONG *     pEvent;                //MessageID
         WCHAR *     pString1;              //Passed in - defaulted to "" - perhaps an example of the offending XML
         WCHAR *     pString2;              //Passed in - defaulted to "" - perhaps an explaination of what's wrong with the XML
         WCHAR *     pString3;              //Passed in - defaulted to ""
         WCHAR *     pString4;              //Passed in - defaulted to ""
         ULONG *     pErrorCode;            //Passed in - HRESULT
         ULONG *     pInterceptor;          //Passed in - Interceptor enum
         WCHAR *     pInterceptorSource;    //Inferred __FILE__ __LINE__
         ULONG *     pOperationType;        //Passed in - enum (Unspecified (default), Populate or UpdateStore)
         WCHAR *     pTable;                //Passed in - TableName
         WCHAR *     pConfigurationSource;  //Passed in - filename
         ULONG *     pRow;                  //Passed in - fast cache row, or XML line number
         ULONG *     pColumn;               //Passed in - fast cache column or XML column
         ULONG *     pMajorVersion;         //Passed in - Usually the Metabase Edit While Running MajorVersion
         ULONG *     pMinorVersion;         //Passed in - Usually the Metabase Edit While Running MinorVersion
};
*/
    SYSTEMTIME  systime;
    GetSystemTime(&systime);

    SetSourceFileName();
    SetErrorID(systime);
    //SetDescription();This must be set last since it's the consolidation of all the other information
    SetDate(systime);
    SetTime(systime);
    SetSource(pDisp);
    SetType(hrErrorCode, eType);
    SetCategory(ulCategory);
    SetUser();
    SetComputer();
    SetData();
    SetEvent(ulEvent);
    SetMessageString();//This must be called after SetEvent
    SetString1(const_cast<LPWSTR>(szString1));
    SetString2(const_cast<LPWSTR>(szString2));
    SetString3(const_cast<LPWSTR>(szString3));
    SetString4(const_cast<LPWSTR>(szString4));
    SetErrorCode(hrErrorCode);
    SetInterceptor(ulInterceptor);
    //SetInterceptorSource();//This is filled in by WriteToLog
    SetOperationType(OperationType);
    SetTable(const_cast<LPWSTR>(szTable));
    SetConfigurationSource(const_cast<LPWSTR>(szConfigurationSource));
    SetRow(ulRow);
    SetColumn(ulColumn);
    SetMajorVersion(MajorVersion);
    SetMinorVersion(MinorVersion);
}

HRESULT CErrorInterceptor::WriteToLog(LPCWSTR szSource, ULONG Line, ULONG los)
{
    if(FAILED(m_hr))//if the construction failed, then bail.
        return m_hr;

    SetInterceptorSource(szSource, Line);
    SetString5();
    SetDescription();

    //if an ISTWrite was provided and LOS says to SetErrorInfo
    if(m_pStorage->m_pISTWriteError && (los & fST_LOS_DETAILED_ERROR_TABLE))
    {
        ASSERT(0 != m_pStorage->m_pISTControllerError);//we can't have an ISTWrite without an ISTController

        ULONG iRow;
        if(FAILED(m_hr = m_pStorage->m_pISTControllerError->PrePopulateCache(fST_POPCONTROL_RETAINREAD)))
            return m_hr;
        if(FAILED(m_hr = m_pStorage->m_pISTWriteError->AddRowForInsert(&iRow)))
            return m_hr;
        if(FAILED(m_hr = m_pStorage->m_pISTWriteError->SetWriteColumnValues(iRow, cDETAILEDERRORS_NumberOfColumns, 0, 0,
            reinterpret_cast<LPVOID *>(&m_pStorage->m_errRow))))
            return m_hr;
        if(FAILED(m_hr = m_pStorage->m_pISTControllerError->PostPopulateCache()))
            return m_hr;

        if(FAILED(m_hr = SetErrorInfo(0, m_pStorage->m_pIErrorInfo)))
            return m_hr;
    }

    if(m_pStorage->m_pDispenser)
    {   //if a dispenser is provided (all code that has a dispenser should do this) then use the logger associated with it.
        if(0 == (los & fST_LOS_NO_LOGGING))//only log if this LOS is NOT specified
        {
            CComPtr<ICatalogErrorLogger2> spErrorLogger;
            if(FAILED(m_hr = m_pStorage->m_pDispenser->GetCatalogErrorLogger(&spErrorLogger)))
                return m_hr;
            ASSERT(0 != spErrorLogger.p);
            if(FAILED(m_hr = spErrorLogger->ReportError(
                                 BaseVersion_DETAILEDERRORS
                                ,ExtendedVersion_DETAILEDERRORS
                                ,cDETAILEDERRORS_NumberOfColumns
                                ,0//currently don't support data param
                                ,reinterpret_cast<LPVOID *>(&m_pStorage->m_errRow))))
                return m_hr;
        }
    }
    else
    {   //Some code can't provide a dispenser so we have to default to the g_ErrorLogWriter
        //There is very little control over how things are logged when no dispenser is provided.
        return g_ErrorLogWriter.WriteDetailedErrors(m_pStorage->m_errRow);
    }
    return S_OK;
}


void CErrorInterceptor::SetCategory(ULONG ulCategory)
{
    m_pStorage->m_Category = ulCategory;
    m_pStorage->m_errRow.pCategory = &m_pStorage->m_Category;

    DWORD len = FormatMessage(  FORMAT_MESSAGE_MAX_WIDTH_MASK | FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                g_hModule,
                                *m_pStorage->m_errRow.pCategory,
                                0,
                                m_pStorage->m_szCategoryString,
                                cchCategoryString,
                                (va_list*)0);
    if(0==len)
    {
        _ultow(*m_pStorage->m_errRow.pCategory, m_pStorage->m_szCategoryString, 10);
    }
    m_pStorage->m_szCategoryString[(len < cchCategoryString) ? len : cchCategoryString-1] = 0x00;//make sure it's NULL terminated (boundary condition)
    m_pStorage->m_errRow.pCategoryString = m_pStorage->m_szCategoryString;
}


void CErrorInterceptor::SetColumn(ULONG ulColumn)
{
    m_pStorage->m_Column = ulColumn;
    m_pStorage->m_errRow.pColumn = (-1 == m_pStorage->m_Column ? 0 : &m_pStorage->m_Column);
}


void CErrorInterceptor::SetComputer()
{
    DWORD _cchComputerName = cchComputerName;
    m_pStorage->m_errRow.pComputer = GetComputerName(m_pStorage->m_szComputerName,  &_cchComputerName) ? m_pStorage->m_szComputerName : 0;
}

void CErrorInterceptor::SetConfigurationSource(LPWSTR wszConfigurationSource)
{
    m_pStorage->m_errRow.pConfigurationSource = wszConfigurationSource;
}

void CErrorInterceptor::SetData()
{
    m_pStorage->m_errRow.pData = 0;
}


void CErrorInterceptor::SetDate(SYSTEMTIME &systime)
{
    m_pStorage->m_errRow.pDate = GetDateFormat(0, DATE_SHORTDATE | LOCALE_NOUSEROVERRIDE, &systime, 0, m_pStorage->m_szDate, cchDate) ? m_pStorage->m_szDate : 0;
}


void CErrorInterceptor::SetDescription()
{
    ASSERT(m_pStorage->m_errRow.pEvent);
    ASSERT(m_pStorage->m_errRow.pString1);
    ASSERT(m_pStorage->m_errRow.pString2);
    ASSERT(m_pStorage->m_errRow.pString3);
    ASSERT(m_pStorage->m_errRow.pString4);
    ASSERT(m_pStorage->m_errRow.pString5);

    LPWSTR lpStrings[5];
    lpStrings[0] = m_pStorage->m_errRow.pString1;
    lpStrings[1] = m_pStorage->m_errRow.pString2;
    lpStrings[2] = m_pStorage->m_errRow.pString3;
    lpStrings[3] = m_pStorage->m_errRow.pString4;
    lpStrings[4] = m_pStorage->m_errRow.pString5;

    DWORD len = FormatMessage(  FORMAT_MESSAGE_MAX_WIDTH_MASK | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                m_pStorage->m_errRow.pMessageString,
                                0 /* Event ID is ignored becuase we're loading from the pMessageString*/,
                                0,
                                m_pStorage->m_szDescription,
                                cchDescription,
                                (va_list*)lpStrings);

    m_pStorage->m_szDescription[(len < cchDescription) ? len : cchDescription-1] = 0x00;//make sure it's NULL terminated (boundary condition)
    m_pStorage->m_errRow.pDescription = m_pStorage->m_szDescription;
}


void CErrorInterceptor::SetErrorCode(HRESULT hrErrorCode)
{
    m_pStorage->m_ErrorCode = static_cast<ULONG>(hrErrorCode);
    m_pStorage->m_errRow.pErrorCode = (S_OK==m_pStorage->m_ErrorCode ? 0 : &m_pStorage->m_ErrorCode);
}


void CErrorInterceptor::SetErrorID(SYSTEMTIME &systime)
{
    /*
    typedef struct _SYSTEMTIME {
        WORD wYear;
        WORD wMonth;
        WORD wDayOfWeek;
        WORD wDay;
        WORD wHour;
        WORD wMinute;
        WORD wSecond;
        WORD wMilliseconds;
    } SYSTEMTIME, *PSYSTEMTIME;
    */

    m_pStorage->m_ErrorID = Hash(m_pStorage->m_szSourceFileName     , 0);
    m_pStorage->m_ErrorID = Hash(systime.wYear          , m_pStorage->m_ErrorID);
    m_pStorage->m_ErrorID = Hash(systime.wMonth         , m_pStorage->m_ErrorID);
    m_pStorage->m_ErrorID = Hash(systime.wDayOfWeek     , m_pStorage->m_ErrorID);
    m_pStorage->m_ErrorID = Hash(systime.wDay           , m_pStorage->m_ErrorID);
    m_pStorage->m_ErrorID = Hash(systime.wHour          , m_pStorage->m_ErrorID);
    m_pStorage->m_ErrorID = Hash(systime.wMinute        , m_pStorage->m_ErrorID);
    m_pStorage->m_ErrorID = Hash(systime.wSecond        , m_pStorage->m_ErrorID);
    m_pStorage->m_ErrorID = Hash(systime.wMilliseconds  , m_pStorage->m_ErrorID);
    m_pStorage->m_ErrorID = Hash(++cError               , m_pStorage->m_ErrorID);

    m_pStorage->m_errRow.pErrorID = &m_pStorage->m_ErrorID;
}


void CErrorInterceptor::SetEvent(ULONG ulEvent)
{
    m_pStorage->m_Event = ulEvent;
    m_pStorage->m_errRow.pEvent = &m_pStorage->m_Event;
}


void CErrorInterceptor::SetInterceptor(ULONG ulInterceptor)
{
    m_pStorage->m_Interceptor = ulInterceptor;
    m_pStorage->m_errRow.pInterceptor = (0 == m_pStorage->m_Interceptor ? 0 : &m_pStorage->m_Interceptor);
}


void CErrorInterceptor::SetInterceptorSource(LPCWSTR file, ULONG line)
{
    ASSERT(0 != file);
    wsprintf(m_pStorage->m_szInterceptorSource, L"%s (%d)", file, line);
    m_pStorage->m_errRow.pInterceptorSource = m_pStorage->m_szInterceptorSource;
}


void CErrorInterceptor::SetMajorVersion(ULONG ulMajorVersion)
{
    m_pStorage->m_MajorVersion = ulMajorVersion;
    m_pStorage->m_errRow.pMajorVersion = (-1 == m_pStorage->m_MajorVersion) ? 0 : &m_pStorage->m_MajorVersion;
}


void CErrorInterceptor::SetMessageString()
{
    DWORD len = FormatMessage(  FORMAT_MESSAGE_MAX_WIDTH_MASK | FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                g_hModule,
                                *m_pStorage->m_errRow.pEvent,
                                0,
                                m_pStorage->m_szMessageString,
                                cchMessageString,
                                (va_list*)0);
    if(0==len)
    {
        len = FormatMessage(    FORMAT_MESSAGE_MAX_WIDTH_MASK | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                L"The description for this event could not be found.  "
                                L"It contains the following insertion string(s):\r\n%1\r\n%2\r\n%3\r\n%4\r\n%5\r\n%0",
                                *m_pStorage->m_errRow.pEvent,
                                0,
                                m_pStorage->m_szMessageString,
                                cchMessageString,
                                (va_list*)0);
    }
    m_pStorage->m_szMessageString[(len < cchMessageString) ? len : cchMessageString-1] = 0x00;//make sure it's NULL terminated (boundary condition)
    m_pStorage->m_errRow.pMessageString = m_pStorage->m_szMessageString;
}


void CErrorInterceptor::SetMinorVersion(ULONG ulMinorVersion)
{
    m_pStorage->m_MinorVersion = ulMinorVersion;
    m_pStorage->m_errRow.pMinorVersion = (-1 == m_pStorage->m_MinorVersion) ? 0 : &m_pStorage->m_MinorVersion;
}


void CErrorInterceptor::SetOperationType(eDETAILEDERRORS_OperationType OperationType)
{
    m_pStorage->m_OperationType = static_cast<ULONG>(OperationType);
    m_pStorage->m_errRow.pOperationType = (0 == m_pStorage->m_OperationType ? 0 : &m_pStorage->m_OperationType);
}


void CErrorInterceptor::SetRow(ULONG ulRow)
{
    m_pStorage->m_Row = ulRow;
    m_pStorage->m_errRow.pRow = (-1 == m_pStorage->m_Row ? 0 : &m_pStorage->m_Row);
}


void CErrorInterceptor::SetSource(IAdvancedTableDispenser *pDisp)
{
    m_pStorage->m_pDispenser = pDisp;
    ULONG cch = cchSource-14;
    if(0==pDisp || FAILED(pDisp->GetProductID(m_pStorage->m_szSource, &cch)))// count of bytes for L" Config"
        wcscpy(m_pStorage->m_szSource, g_wszDefaultProduct);//Default to " Config"
    wcscat(m_pStorage->m_szSource, L" Config");//The result should be something like "IIS Config", " Config" etc
    m_pStorage->m_errRow.pSource = m_pStorage->m_szSource;
}

void CErrorInterceptor::SetSourceFileName()
{
    m_pStorage->m_szSourceFileName[0] = 0x00;//just in case GetModuleFileName fails, we'll have a 0 length string as the SourceFilename
    GetModuleFileName(g_hModule, m_pStorage->m_szSourceFileName, cchSourceFileName);
    m_pStorage->m_szSourceFileName[cchSourceFileName-1] = 0x00;//I don't think GetModuleFileName

    m_pStorage->m_errRow.pSourceModuleName = m_pStorage->m_szSourceFileName;
}


void CErrorInterceptor::SetString1(LPWSTR wsz)
{
    wcsncpy(m_pStorage->m_szString1, wsz  ? wsz : L"", cchString1);
    m_pStorage->m_szString1[cchString1 - 1] = 0x00;//NULL terminate it in case the string is too big
    m_pStorage->m_errRow.pString1 = m_pStorage->m_szString1;
}


void CErrorInterceptor::SetString2(LPWSTR wsz)
{
    wcsncpy(m_pStorage->m_szString2, wsz  ? wsz : L"", cchString2);
    m_pStorage->m_szString2[cchString2 - 1] = 0x00;//NULL terminate it in case the string is too big
    m_pStorage->m_errRow.pString2 = m_pStorage->m_szString2;
}


void CErrorInterceptor::SetString3(LPWSTR wsz)
{
    wcsncpy(m_pStorage->m_szString3, wsz  ? wsz : L"", cchString3);
    m_pStorage->m_szString3[cchString3 - 1] = 0x00;//NULL terminate it in case the string is too big
    m_pStorage->m_errRow.pString3 = m_pStorage->m_szString3;
}


void CErrorInterceptor::SetString4(LPWSTR wsz)
{
    wcsncpy(m_pStorage->m_szString4, wsz  ? wsz : L"", cchString4);
    m_pStorage->m_szString4[cchString4 - 1] = 0x00;//NULL terminate it in case the string is too big
    m_pStorage->m_errRow.pString4 = m_pStorage->m_szString4;
}

void CErrorInterceptor::SetString5()
{
    m_pStorage->m_errRow.pString5 = 0;
    FillInInsertionString5(m_pStorage->m_szString5, cchString5, m_pStorage->m_errRow);
}


void CErrorInterceptor::SetTable(LPWSTR wszTable)
{
    m_pStorage->m_errRow.pTable = wszTable;
}



void CErrorInterceptor::SetTime(SYSTEMTIME &systime)
{
    m_pStorage->m_errRow.pTime = GetTimeFormat(0, LOCALE_NOUSEROVERRIDE, &systime, 0, m_pStorage->m_szTime, cchTime) ? m_pStorage->m_szTime : 0;
}


void CErrorInterceptor::SetType(HRESULT hrErrorCode, eDETAILEDERRORS_Type eType)
{                                                                                         //We'll consider hrs of the form 0x80000000, errors since most errors are defined that way
    static ULONG hrToEventType[4] = {eDETAILEDERRORS_SUCCESS, eDETAILEDERRORS_INFORMATION, eDETAILEDERRORS_ERROR/*eDETAILEDERRORS_WARNING*/, eDETAILEDERRORS_ERROR};

    if(eDETAILEDERRORS_SUCCESS == eType)//if SUCCESS then user the error code
        m_pStorage->m_Type = hrToEventType[(hrErrorCode >> 30) & 3];
    else
        m_pStorage->m_Type = eType;//otherwise use what was passed in

    m_pStorage->m_errRow.pType = &m_pStorage->m_Type;
}


void CErrorInterceptor::SetUser()
{
    DWORD _cchUserName = cchUserName;
    m_pStorage->m_errRow.pUser = GetUserName(m_pStorage->m_szUserName,  &_cchUserName) ? m_pStorage->m_szUserName : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\shared\util\textfilelogger.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name:
    TextFileLogger.cpp

$Header: $

Abstract:
    Text file log complements event file logging.

Author:
    ???             Legacy code from COM+ 1.0 time frame (or before)

Revision History:
    mohits          4/19/01

--**************************************************************************/
#include "precomp.hxx"

// Module handle
extern HMODULE g_hModule;

// Defined in svcerr.cpp (i.e. "IIS")
extern LPWSTR  g_wszDefaultProduct;

// TODO: Get from a central place instead
static const ULONG   MAX_PRODUCT_CCH = 64;

// We are using stack buffers throughout.
static const ULONG   BUFSIZE = 2048;

// Relevant registry stuff
static const LPCWSTR WSZ_REG_CAT42   = L"Software\\Microsoft\\Catalog42\\";
static const ULONG   CCH_REG_CAT42   = sizeof(WSZ_REG_CAT42)/sizeof(WCHAR)-1;
static const LPCWSTR WSZ_REG_LOGSIZE = L"TextFileLogSize";

// Current filename we are logging to is shared across processes
// This is to prevent expensive Find*File calls every time we need
// to log.  Protected by Lock()/Unlock() methods of TextFileLogger.
WCHAR g_wszFileCur[MAX_PATH] = {0};
ULONG g_idxNumPart           = 0;

// TLogData: private methods

bool TLogData::WstrToUl(
    LPCWSTR     i_wszSrc,
    WCHAR       i_wcTerminator,
    ULONG*      o_pul)
/*++

Synopsis:
    Converts a WstrToUl.
    We need this because neither swscanf nor atoi indicate error cases correctly.

Arguments: [i_wszSrc]       - The str to be converted
           [i_wcTerminator] - At what char we should stop searching
           [o_pul]          - The result, only set on success.

Return Value:
    bool - true if succeeded, false otherwise

--*/
{
    ASSERT(o_pul);
    ASSERT(i_wszSrc);

    static const ULONG  ulMax  = 0xFFFFFFFF;
    ULONG               ulCur  = 0;
    _int64              i64Out = 0;

    for(LPCWSTR pCur = i_wszSrc; *pCur != L'\0' && *pCur != i_wcTerminator; pCur++)
    {
        ulCur = *pCur - L'0';
        if(ulCur > 9)
        {
            DBGINFO((DBG_CONTEXT, "[WstrToUl] Invalid char encountered\n"));
            return false;
        }

        i64Out = i64Out*10 + ulCur;
        if(i64Out > ulMax)
        {
            DBGINFO((DBG_CONTEXT, "[WstrToUl] Number is too big\n"));
            return false;
        }
    }

    ASSERT(i64Out <= ulMax);
    *o_pul = (ULONG)i64Out;
    return true;
}

// TextFileLogger: public methods

CSafeAutoCriticalSection TextFileLogger::_cs;

TextFileLogger::TextFileLogger(
    LPCWSTR wszEventSource,
    HMODULE hMsgModule,
    DWORD dwNumFiles) :  _hFile(INVALID_HANDLE_VALUE)
                        ,_hMsgModule(hMsgModule)
                        ,_eventSource(wszEventSource)
                        ,_dwMaxSize(524288)
                        ,_dwNumFiles(dwNumFiles)
                        ,m_cRef(0)
{
    wcscpy(m_wszProductID, g_wszDefaultProduct);

    Init(wszEventSource, hMsgModule);
}

TextFileLogger::TextFileLogger(
    LPCWSTR wszProductID,
    ICatalogErrorLogger2 *pNext,
    DWORD dwNumFiles) :
                         _hFile(INVALID_HANDLE_VALUE)
                        ,_hMsgModule(0)
                        ,_eventSource(0)
                        ,_dwMaxSize(524288)
                        ,_dwNumFiles(dwNumFiles)
                        ,m_cRef(0)
                        ,m_spNextLogger(pNext)
{
    wcsncpy( m_wszProductID, wszProductID, 63 );
    m_wszProductID[63] = L'\0';
}

void TextFileLogger::Init(
    LPCWSTR wszEventSource,
    HMODULE hMsgModule)
{
    _hMsgModule     = hMsgModule;
    _eventSource    = wszEventSource;

    ASSERT(_dwNumFiles > 0);

    // Open the message module (comsvcs.dll).
    if(0 == _hMsgModule)
    {
        _hMsgModule = LoadLibraryEx(L"comsvcs.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);
    }

    // Open the registry to get the maxfile size.
    WCHAR wszRegPath[CCH_REG_CAT42 + 1 + MAX_PRODUCT_CCH + 1];
    wcscpy(wszRegPath,  WSZ_REG_CAT42);
    wcsncat(wszRegPath, m_wszProductID, MAX_PRODUCT_CCH);

    // First, open the path
    HKEY  hkProd = NULL;
    DWORD dw     = RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszRegPath, 0, KEY_READ, &hkProd);
    if (dw != ERROR_SUCCESS)
    {
        DBGWARN((
            DBG_CONTEXT,
            "Could not open regkey: %ws, err=%u\n", wszRegPath, dw));
        return;
    }

    // Then, get the value
    DWORD dwType   = 0;
    DWORD dwData   = 0;
    DWORD dwcbData = 4;
    dw = RegQueryValueEx(hkProd, WSZ_REG_LOGSIZE, NULL, &dwType, (LPBYTE)&dwData, &dwcbData);
    RegCloseKey(hkProd);

    // Error conditions
    if (dw != ERROR_SUCCESS)
    {
        DBGINFO((
            DBG_CONTEXT,
            "Could not fetch %ws, err=%u.  Using default of %u\n",
            WSZ_REG_LOGSIZE,
            dw,
            _dwMaxSize));
        return;
    }
    if (dwType != REG_DWORD)
    {
        DBGWARN((
            DBG_CONTEXT,
            "%ws found, but type is not REG_DWORD.  Using %u instead\n",
            WSZ_REG_LOGSIZE,
            _dwMaxSize));
        return;
    }
    if (dwData < _dwMaxSize)
    {
        DBGWARN((
            DBG_CONTEXT,
            "%u is too small.  Using %u instead\n",
            dwData,
            _dwMaxSize));
        return;
    }

    // If none of the error conditions hold, ...
    _dwMaxSize = dwData;
}

TextFileLogger::~TextFileLogger()
{
    if (_hFile != INVALID_HANDLE_VALUE)
        CloseHandle(_hFile);
    if (_hMsgModule != NULL && _hMsgModule!=g_hModule)
        FreeLibrary(_hMsgModule);
}

//IUnknown
// =======================================================================

STDMETHODIMP TextFileLogger::QueryInterface(REFIID riid, void **ppv)
{
    if (NULL == ppv)
        return E_INVALIDARG;
    *ppv = NULL;

    if (riid == IID_ICatalogErrorLogger2)
    {
        *ppv = (ICatalogErrorLogger2*) this;
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = (ICatalogErrorLogger2*) this;
    }

    if (NULL != *ppv)
    {
        ((ICatalogErrorLogger2*)this)->AddRef ();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }

}

STDMETHODIMP_(ULONG) TextFileLogger::AddRef()
{
    return InterlockedIncrement((LONG*) &m_cRef);

}

STDMETHODIMP_(ULONG) TextFileLogger::Release()
{
    long cref = InterlockedDecrement((LONG*) &m_cRef);
    if (cref == 0)
    {
        delete this;
    }
    return cref;
}

//ICatalogErrorLogger2
//=================================================================================
// Function: ReportError
//
// Synopsis: Machanism for reporting errors to a text file in IIS
//
// Arguments: [i_BaseVersion_DETAILEDERRORS] - Must be BaseVersion_DETAILEDERRORS
//            [i_ExtendedVersion_DETAILEDERRORS] - May be any value, used for debug purposes only
//            [i_cDETAILEDERRORS_NumberOfColumns] - indicates the size of the apvValue array
//            [i_acbSizes] - may be NULL if no BYTES columns are used
//            [i_apvValues] - columns in the DETAILEDERRORS table
//
// Return Value:
//=================================================================================
HRESULT TextFileLogger::ReportError(ULONG      i_BaseVersion_DETAILEDERRORS,
                                    ULONG      i_ExtendedVersion_DETAILEDERRORS,
                                    ULONG      i_cDETAILEDERRORS_NumberOfColumns,
                                    ULONG *    i_acbSizes,
                                    LPVOID *   i_apvValues)
{
    if(i_BaseVersion_DETAILEDERRORS != BaseVersion_DETAILEDERRORS)
        return E_ST_BADVERSION;
    if(0 == i_apvValues)
        return E_INVALIDARG;
    if(i_cDETAILEDERRORS_NumberOfColumns <= iDETAILEDERRORS_ErrorCode)//we need at least this many columns
        return E_INVALIDARG;

    tDETAILEDERRORSRow errorRow;
    memset(&errorRow, 0x00, sizeof(tDETAILEDERRORSRow));
    memcpy(&errorRow, i_apvValues, i_cDETAILEDERRORS_NumberOfColumns * sizeof(void *));

    if(0 == errorRow.pType)
        return E_INVALIDARG;
    if(0 == errorRow.pCategory)
        return E_INVALIDARG;
    if(0 == errorRow.pEvent)
        return E_INVALIDARG;
    if(0 == errorRow.pSource)
        return E_INVALIDARG;

    WCHAR wszInsertionString5[1024];
    if(0 == errorRow.pString5)
        FillInInsertionString5(wszInsertionString5, 1024, errorRow);

    LPCTSTR pInsertionStrings[5];
    pInsertionStrings[4] = errorRow.pString5 ? errorRow.pString5 : L"";
    pInsertionStrings[3] = errorRow.pString5 ? errorRow.pString4 : L"";
    pInsertionStrings[2] = errorRow.pString5 ? errorRow.pString3 : L"";
    pInsertionStrings[1] = errorRow.pString5 ? errorRow.pString2 : L"";
    pInsertionStrings[0] = errorRow.pString5 ? errorRow.pString1 : L"";

    Init(errorRow.pSource, g_hModule);

    Report(
        LOWORD(*errorRow.pType),
        LOWORD(*errorRow.pCategory),
        *errorRow.pEvent,
        5,
        (errorRow.pData && i_acbSizes) ? i_acbSizes[iDETAILEDERRORS_Data] : 0,
        pInsertionStrings,
        errorRow.pData,
        errorRow.pCategoryString,
        errorRow.pMessageString);

    if(m_spNextLogger)//is there a chain of loggers
    {
        return m_spNextLogger->ReportError(i_BaseVersion_DETAILEDERRORS,
                                          i_ExtendedVersion_DETAILEDERRORS,
                                          i_cDETAILEDERRORS_NumberOfColumns,
                                          i_acbSizes,
                                          reinterpret_cast<LPVOID *>(&errorRow));//instead of passing forward i_apvValues, let's use errorRow since it has String5
    }

    return S_OK;
}

// TextFileLogger: private methods

void TextFileLogger::Report(
    WORD     wType,
    WORD     wCategory,
    DWORD    dwEventID,
    WORD     wNumStrings,
    size_t   dwDataSize,
    LPCTSTR* lpStrings,
    LPVOID   lpRawData,
    LPCWSTR  wszCategory,
    LPCWSTR  wszMessageString)
{
    WCHAR szBuf[BUFSIZE]; // documented maximum size for wsprintf is 1024; but FormatMessage can be longer
    int len;
    DWORD written;

    HRESULT hr = Lock();
    if(FAILED(hr))
    {
        DBGERROR((DBG_CONTEXT, "Couldn't obtain critical section.  Not logging.\n"));
        return;
    }

    if (_hFile == INVALID_HANDLE_VALUE)
    {
        InitFile();
    }

    if (_hFile == INVALID_HANDLE_VALUE)
    {
        hr = Unlock();
        DBG_ASSERT(SUCCEEDED(hr));
        DBGERROR((DBG_CONTEXT, "Not logging due to error\n"));
        return;
    }

    // Set the file handle, and position the pointer to the end of
    // the file (we append).
    SetFilePointer(_hFile, 0, NULL, FILE_END);

    // Write a separator line.
    ASSERT(0 != _eventSource);
    len = _snwprintf(szBuf, BUFSIZE-1, L"===================== %s =====================\r\n", _eventSource);
    szBuf[BUFSIZE-1]=L'\0';
    ASSERT(len >= 0);
    WriteFile(_hFile, szBuf, len * sizeof szBuf[0], &written, NULL);

    // Write the time/date stamp.
    SYSTEMTIME st;
    GetLocalTime(&st);
    len = _snwprintf(szBuf, BUFSIZE-1, L"Time:  %d/%d/%d  %02d:%02d:%02d.%03d\r\n",
                   st.wMonth, st.wDay, st.wYear,
                   st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
    szBuf[BUFSIZE-1]=L'\0';
    ASSERT(len >= 0);
    WriteFile(_hFile, szBuf, len * sizeof szBuf[0], &written, NULL);

    // Write the message type.
    WCHAR* szType = NULL;
    switch(wType) {
    case EVENTLOG_ERROR_TYPE:
        szType = L"Error";
        break;
    case EVENTLOG_WARNING_TYPE:
        szType = L"Warning";
        break;
    case EVENTLOG_INFORMATION_TYPE:
        szType = L"Information";
        break;
    default:
        szType = L"Unknown Type";
        break;
    }
    len = _snwprintf(szBuf, BUFSIZE-1, L"Type: %s\r\n", szType);
    szBuf[BUFSIZE-1]=L'\0';
    ASSERT(len >= 0);
    WriteFile(_hFile, szBuf, len * sizeof szBuf[0], &written, NULL);

    WCHAR szCat[80];
    LPCWSTR pBuf = wszCategory;
    if(0 == wszCategory)
    {
        // Write the message category.
        len = FormatMessage(FORMAT_MESSAGE_MAX_WIDTH_MASK |
                            FORMAT_MESSAGE_FROM_HMODULE |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            _hMsgModule,
                            wCategory,
                            0,
                            szCat,
                            sizeof(szCat)/sizeof(WCHAR),
                            (va_list*)lpStrings);
        pBuf = szCat;
    }
    else
    {
        if(wcslen(wszCategory)>80)
            len = 0;
    }
    if (len == 0)
        len = _snwprintf(szBuf, BUFSIZE-1, L"Category: %hd\r\n", wCategory);
    else
        len = _snwprintf(szBuf, BUFSIZE-1, L"Category: %s\r\n", pBuf);
    ASSERT(len >= 0);
    szBuf[BUFSIZE-1]=L'\0';
    WriteFile(_hFile, szBuf, len * sizeof szBuf[0], &written, NULL);

    // Write the event ID.
    len = wsprintf(szBuf, L"Event ID: %d\r\n", dwEventID & 0xffff);
    WriteFile(_hFile, szBuf, len * sizeof szBuf[0], &written, NULL);

    // Write out the formatted message.
    len = FormatMessage(FORMAT_MESSAGE_MAX_WIDTH_MASK |
        (wszMessageString ? FORMAT_MESSAGE_FROM_STRING : FORMAT_MESSAGE_FROM_HMODULE) |
                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        reinterpret_cast<LPCVOID>(wszMessageString) ? reinterpret_cast<LPCVOID>(wszMessageString)
                                        : reinterpret_cast<LPCVOID>(_hMsgModule), //we get errors when using (A ? B : C) when A,B & C are not the same type
                        dwEventID,
                        0,
                        szBuf,
                        sizeof(szBuf)/sizeof(WCHAR),
                        (va_list*)lpStrings);

    szBuf[(len < sizeof(szBuf)/sizeof(WCHAR)) ? len : (sizeof(szBuf)/sizeof(WCHAR))-1] = 0x00;

    if (len == 0)
    {
        // Unable to get message... dump the insertion strings.
        len = wsprintf(szBuf, L"The description for this event could not be found. "
                       L"It contains the following insertion string(s):\r\n");
        WriteFile(_hFile, szBuf, len * sizeof szBuf[0], &written, NULL);

        for (WORD i = 0; i < wNumStrings; ++i) {
            len = lstrlen(lpStrings[i]);
            WriteFile(_hFile, lpStrings[i], len * sizeof lpStrings[0][0], &written, NULL);
            WriteFile(_hFile, L"\r\n", sizeof L"\r\n" - sizeof L'\0', &written, NULL);
        }
    }
    else {
        // Got the message...
        WriteFile(_hFile, szBuf, len * sizeof szBuf[0], &written, NULL);
        WriteFile(_hFile, L"\r\n", sizeof L"\r\n" - sizeof L'\0', &written, NULL);
    }

    // If necessary, write out the raw data bytes.
    if (dwDataSize > 0) {
        WriteFile(_hFile, L"Raw data: ", sizeof L"Raw data: " - sizeof L'\0', &written, NULL);
        for (DWORD dw = 0; dw < dwDataSize; ++dw) {
            BYTE* b = (BYTE*)lpRawData + dw;
            len = wsprintf(szBuf, L"%02x ", *b);
            WriteFile(_hFile, szBuf, len * sizeof szBuf[0], &written, NULL);
        }
        WriteFile(_hFile, L"\r\n", sizeof L"\r\n" - sizeof L'\0', &written, NULL);
    }

    if(_hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(_hFile);
        _hFile = INVALID_HANDLE_VALUE;
    }

    hr = Unlock();
    DBG_ASSERT(SUCCEEDED(hr));
}

void TextFileLogger::InitFile()
/*++

Synopsis:
    Sets _hFile based on what DetermineFile returns.
    We do not call DetermineFile if
    - Our current log file is not full
    - We have a current log file.  We just increment and clean up stale file.

    Caller should Lock() before calling this.

--*/
{
    bool bDetermineFile = false;

    // We have already set g_wszFileCur
    if(g_wszFileCur[0] != L'\0')
    {
        WIN32_FILE_ATTRIBUTE_DATA FileAttrData;

        // If we could not fetch attributes or file is RO, then call DetermineFile.
        if( (0 == GetFileAttributesEx(g_wszFileCur, GetFileExInfoStandard, &FileAttrData)) ||
            (FileAttrData.dwFileAttributes & FILE_ATTRIBUTE_READONLY) )
        {
            bDetermineFile = true;
        }

        // Just use the next file if we're full.
        else if(FileAttrData.nFileSizeLow >= _dwMaxSize/_dwNumFiles)
        {
            // Construct so we can use conversion features.
            TLogData LogData(
                g_idxNumPart, _dwMaxSize/_dwNumFiles, g_wszFileCur, FileAttrData.nFileSizeLow);

            // When we set g_wszFileCur in first place, we validated then.
            // So, this will always succeed
            VERIFY(LogData.SyncVersion());

            // Set g_wszFileCur to next version
            SetGlobalFile(g_wszFileCur, g_idxNumPart, LogData.GetVersion()+1);

            // Delete file we are going to write to
            LogData.SetVersion(LogData.GetVersion()+1);
            if( 0 == DeleteFile(LogData.cFileName) &&
                ERROR_FILE_NOT_FOUND != GetLastError() )
            {
                bDetermineFile = true;
            }
            else
            {
                // Delete stale file.  We don't care if it doesn't exist.
                LogData.SetVersion(LogData.GetVersion() - _dwNumFiles);
                DeleteFile(LogData.cFileName);
            }
        }
        else
        {
            _hFile = CreateFile();
            if(_hFile == INVALID_HANDLE_VALUE)
            {
                if(ERROR_ACCESS_DENIED == GetLastError())
                {
                    bDetermineFile = true;
                }
            }
        }
    }

    // Has not been set yet, so we need to determine.
    else
    {
        bDetermineFile = true;
    }

    if(bDetermineFile)
    {
        HRESULT hr = DetermineFile();
        if(FAILED(hr))
        {
            DBGERROR((DBG_CONTEXT, "DetermineFile failed, hr=0x%x\n", hr));
            return;
        }
    }

    // g_wszFileCur is now set

    if(_hFile == INVALID_HANDLE_VALUE)
    {
        _hFile = CreateFile();
    }
    if (_hFile == INVALID_HANDLE_VALUE)
    {
        return;
    }

    if(ERROR_ALREADY_EXISTS != GetLastError())//If the file was just created, then write FF FE to indicate UNICODE text file
    {
        WCHAR wchUnicodeSignature = 0xFEFF;
        DWORD written;
        WriteFile(_hFile, &wchUnicodeSignature, sizeof(WCHAR), &written, NULL);
    }
}


HRESULT TextFileLogger::DetermineFile()
/*++

Synopsis:
    Finds the file to log to.
    1) Find the highest file (<= MAX_ULONG).
    2) If we don't find a single valid file, just set version to 0.
    3) If the file we found is full
        - Normally, just use next.
        - In case of rollover, look for first non-full file.
    4) Once a file has been picked, delete file# (new version-_dwNumFiles).

    Caller should Lock() before calling this.

Return Value:
    HRESULT

--*/
{
    HRESULT hr = S_OK;
    WCHAR   wszSearchPath[MAX_PATH];

    // This is actually a pointer to somewhere in wszSearchPath
    LPWSTR pNumPart  = NULL;
    LPWSTR pFilePart = NULL;

    if( !ConstructSearchString(wszSearchPath, &pFilePart, &pNumPart) )
    {
        DBGERROR((DBG_CONTEXT, "ConstructSearchString failed\n"));
        return E_FAIL;
    }
    ASSERT(pFilePart >= wszSearchPath);
    ASSERT(pNumPart  >= pFilePart);

    // pFileDataHighest and pFileDataCurrent should never point to same memory.
    TLogData  FindFileData1((ULONG)(pNumPart-pFilePart), _dwMaxSize/_dwNumFiles);
    TLogData  FindFileData2((ULONG)(pNumPart-pFilePart), _dwMaxSize/_dwNumFiles);
    TLogData* pFileDataHighest       = &FindFileData1;
    TLogData* pFileDataCurrent       = &FindFileData2;

    HANDLE     hFindFile = FindFirstFile(wszSearchPath, pFileDataCurrent);

    // special case when no files are found: just set g_wszFileCur to ver 0.
    if( hFindFile == INVALID_HANDLE_VALUE )
    {
        SetGlobalFile(wszSearchPath, static_cast<ULONG>(pNumPart-wszSearchPath), 0);
        return S_OK;
    }

    DWORD dw = ERROR_SUCCESS;
    while(1)
    {
        // Only consider file if we can determine the version number
        if( pFileDataCurrent->SyncVersion() )
        {
            // only check full if we haven't found a "lowest" yet or this file is
            // smaller than the current "lowest"
            if( !pFileDataHighest->ContainsData() ||
                pFileDataCurrent->GetVersion() > pFileDataHighest->GetVersion())
            {
                TLogData* pFindTemp    = pFileDataHighest;
                pFileDataHighest       = pFileDataCurrent;
                pFileDataCurrent       = pFindTemp;
            }
        }

        // Move to next file
        dw = FindNextFile(hFindFile, pFileDataCurrent);
        if(0 == dw)
        {
            dw = GetLastError();
            if(dw == ERROR_NO_MORE_FILES)
            {
                break;
            }
            else
            {
                FindClose(hFindFile);
                DBGERROR((DBG_CONTEXT, "FindNextFile returned err=%u\n", dw));
                return HRESULT_FROM_WIN32(dw);
            }
        }
    }
    FindClose(hFindFile);

    // If we didn't find a highest, just set g_wszFileCur to 0.
    if(!pFileDataHighest->ContainsData())
    {
        SetGlobalFile(wszSearchPath, static_cast<ULONG>(pNumPart-wszSearchPath), 0);
        return S_OK;
    }

    // Doing this here so we can determine if RO or not.
    bool bReadOnly = false;
    if(!pFileDataHighest->IsFull())
    {
        SetGlobalFile(wszSearchPath, static_cast<ULONG>(pNumPart-wszSearchPath), pFileDataHighest->GetVersion());
        _hFile = CreateFile();
        if(_hFile == INVALID_HANDLE_VALUE)
        {
            if(ERROR_ACCESS_DENIED == GetLastError())
            {
                bReadOnly = true;
            }
        }
    }

    if(pFileDataHighest->IsFull() || bReadOnly)
    {
        // The file we selected is not adequate.

        DBG_ASSERT(_hFile == INVALID_HANDLE_VALUE);

        for(ULONG i = 0; i < 0xFFFFFFFF; i++)
        {
            if(pFileDataHighest->GetVersion() == 0xFFFFFFFF && i == 0)
            {
                hr = GetFirstAvailableFile(wszSearchPath, pFilePart, pFileDataHighest);
                if(FAILED(hr))
                {
                    DBGERROR((DBG_CONTEXT, "GetFirstAvailableFile returned hr=0x%x\n", hr));
                    return hr;
                }
            }
            else
            {
                pFileDataHighest->IncrementVersion();
            }

            // Delete the obsolete log file to keep our count correct.
            _snwprintf(pNumPart, 10, L"%010lu", pFileDataHighest->GetVersion() - _dwNumFiles);
            DeleteFile(wszSearchPath);

            // Delete the file we will be logging to.
            // It shouldn't be there anyways, but just in case it is...
            _snwprintf(pNumPart, 10, L"%010lu", pFileDataHighest->GetVersion());
            if(0 == DeleteFile(wszSearchPath))
            {
                if(GetLastError() == ERROR_FILE_NOT_FOUND)
                {
                    // If file doesn't exist, we're ready to go.
                    break;
                }
                // If file was not deletable, we need to get the next one.
            }
            else
            {
                // On successful delete, we're ready to go.
                break;
            }
        }
        if(i == 0xFFFFFFFF)
        {
            hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES);
            DBGERROR((DBG_CONTEXT, "Cannot log.  There are 0xFFFFFFFF undeletable log files.\n"));
            return hr;
        }

        SetGlobalFile(wszSearchPath, static_cast<ULONG>(pNumPart-wszSearchPath), pFileDataHighest->GetVersion());
    }

    return S_OK;
}

HRESULT TextFileLogger::GetFirstAvailableFile(
    LPWSTR    wszBuf,
    LPWSTR    wszFilePartOfBuf,
    TLogData* io_pFileData)
/*++

Synopsis:
    Should only be called when we have a file of version MAX_ULONG.
    Caller should Lock().

Arguments: [wszBuf] -
           [wszFilePartOfBuf] -
           [io_pFileData] -

Return Value:

--*/
{
    ASSERT(wszBuf);
    ASSERT(wszFilePartOfBuf);
    ASSERT(wszFilePartOfBuf >= wszBuf);
    ASSERT(io_pFileData);

    WIN32_FILE_ATTRIBUTE_DATA FileData;

    for(ULONG i = 0; i < 0xFFFFFFFF; i++)
    {
        io_pFileData->SetVersion(i);

        wcscpy(wszFilePartOfBuf, io_pFileData->cFileName);

        if(0 == GetFileAttributesEx(wszBuf, GetFileExInfoStandard, &FileData))
        {
            HRESULT hr = GetLastError();
            hr = HRESULT_FROM_WIN32(hr);
            if(hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            {
                DBGERROR((DBG_CONTEXT, "Could not fetch attributes, hr=0x%x\n", hr));
                return hr;
            }
            io_pFileData->nFileSizeLow = 0;
            return S_OK;
        }

        if(FileData.nFileSizeLow < _dwMaxSize/_dwNumFiles)
        {
            io_pFileData->nFileSizeLow = FileData.nFileSizeLow;
            return S_OK;
        }
    }

    DBGERROR((DBG_CONTEXT, "Could not find an available file\n"));
    return HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES);
}

bool TextFileLogger::ConstructSearchString(
    LPWSTR  o_wszSearchPath,
    LPWSTR* o_ppFilePartOfSearchPath,
    LPWSTR* o_ppNumPartOfSearchPath)
/*++

Synopsis:
    Constructs the search string.

Arguments: [o_wszSearchPath] -           The search string
           [o_ppFilePartOfSearchPath] -  Ptr into search string
           [o_ppNumPartOfSearchPath] -   Ptr into search string

Return Value:

--*/
{
    ASSERT(o_wszSearchPath);
    ASSERT(o_ppNumPartOfSearchPath);
    ASSERT(*o_ppNumPartOfSearchPath == NULL);
    ASSERT(o_ppFilePartOfSearchPath);
    ASSERT(*o_ppFilePartOfSearchPath == NULL);

    ULONG cchWinDir = GetSystemDirectory(o_wszSearchPath, MAX_PATH);
    if(cchWinDir == 0 || cchWinDir > MAX_PATH)
    {
        DBGERROR((DBG_CONTEXT, "Path of windows dir is larger than MAX_PATH\n"));
        return false;
    }

    static LPCWSTR     wszBackSlash  = L"\\";
    static const ULONG cchBackSlash  = 1;

    static WCHAR       wszInetSrv[]  = L"inetsrv\\";
    static const ULONG cchInetSrv    = sizeof(wszInetSrv)/sizeof(WCHAR) - 1;

    ULONG              cchEventSrc   = (ULONG)wcslen(_eventSource);

    static WCHAR       wszSuffix[]   = L"_??????????.log";
    static const ULONG cchSuffix     = sizeof(wszSuffix)/sizeof(WCHAR) - 1;

    if((cchWinDir + cchBackSlash + cchInetSrv + cchEventSrc + cchSuffix) >= MAX_PATH)
    {
        DBGERROR((DBG_CONTEXT, "Path + logfile exceeds MAX_PATH\n"));
        return false;
    }

    LPWSTR pEnd = o_wszSearchPath + cchWinDir;

    if((pEnd != o_wszSearchPath) && (*(pEnd-1) != L'\\'))
    {
        memcpy(pEnd, wszBackSlash, cchBackSlash*sizeof(WCHAR));
        pEnd += cchBackSlash;
    }

    memcpy(pEnd, wszInetSrv, cchInetSrv*sizeof(WCHAR));
    pEnd += cchInetSrv;

    *o_ppFilePartOfSearchPath = pEnd;

    memcpy(pEnd, _eventSource, cchEventSrc*sizeof(WCHAR));
    pEnd += cchEventSrc;

    memcpy(pEnd, wszSuffix,    cchSuffix*sizeof(WCHAR));
    *o_ppNumPartOfSearchPath = pEnd+1;
    pEnd += cchSuffix;

    *pEnd = L'\0';
    return true;
}

void TextFileLogger::SetGlobalFile(
    LPCWSTR i_wszSearchString,
    ULONG   i_ulIdxNumPart,
    ULONG   i_ulVersion)
/*++

Synopsis:
    Sets g_wszFileCur and g_idxNumPart.
    Caller should Lock().

Arguments: [i_wszSearchString] - The search string
           [i_ulIdxNumPart] -    Index into search string where version starts
           [i_ulVersion] -       The version we want to set.

--*/
{
    ASSERT(i_wszSearchString);

    g_idxNumPart = i_ulIdxNumPart;

    if(g_wszFileCur != i_wszSearchString)
    {
        wcscpy(g_wszFileCur, i_wszSearchString);
    }
    _snwprintf(g_wszFileCur + g_idxNumPart, 10, L"%010lu", i_ulVersion);
}

HANDLE TextFileLogger::CreateFile()
/*++

Synopsis:
    A wrapper for CreateFile

--*/
{
    return ::CreateFile(
        g_wszFileCur,
        GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL, // security attributes
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
        NULL);
}

// end TextFileLogger
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\shared\util\tmsxmlbase.cpp ===
// Copyright (C) 2000-2001 Microsoft Corporation.  All rights reserved.
// Filename:        TMSXmlBase.cpp
// Author:          Stephenr
// Date Created:    10/16/2000
// Description:     This abstracts how (and which) MSXML dll we load.
//                  This is important becuase we never call CoCreateInstance
//                  on MSXML.
//

#include "precomp.hxx"

TMSXMLBase::~TMSXMLBase()
{
}

CLSID TMSXMLBase::m_CLSID_DOMDocument    ={0x2933bf90, 0x7b36, 0x11d2, 0xb2, 0x0e, 0x00, 0xc0, 0x4f, 0x98, 0x3e, 0x60};
CLSID TMSXMLBase::m_CLSID_DOMDocument30  ={0xf5078f32, 0xc551, 0x11d3, 0x89, 0xb9, 0x00, 0x00, 0xf8, 0x1f, 0xe2, 0x21};
CLSID TMSXMLBase::m_CLSID_XMLParser      ={0xd2423620, 0x51a0, 0x11d2, 0x9c, 0xaf, 0x00, 0x60, 0xb0, 0xec, 0x3d, 0x39};//old CLSID
CLSID TMSXMLBase::m_CLSID_XMLParser30    ={0xf5078f19, 0xc551, 0x11d3, 0x89, 0xb9, 0x00, 0x00, 0xf8, 0x1f, 0xe2, 0x21};//MSXML3 CLSID

CLSID TMSXMLBase::GetCLSID_DOMDocument()
{
    return m_CLSID_DOMDocument30;
}


CLSID TMSXMLBase::GetCLSID_XMLParser()
{
    return m_CLSID_XMLParser30;
}


typedef HRESULT( __stdcall *DLLGETCLASSOBJECT)(REFCLSID, REFIID, LPVOID FAR*);

HRESULT TMSXMLBase::CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid,  LPVOID * ppv) const
{
    HRESULT                 hr = S_OK;
    HINSTANCE               hInstMSXML = NULL;
    DLLGETCLASSOBJECT       DllGetClassObject = NULL;
	CComPtr<IClassFactory>  spClassFactory;

	ASSERT( NULL != ppv );
	*ppv = NULL;

    // create a instance of the object we want
	hr = ::CoCreateInstance( rclsid, pUnkOuter, dwClsContext, riid, ppv );

    // During setup msxml3 is not yet registered
	if ( hr != REGDB_E_CLASSNOTREG )
	{
	    goto exit;
	}

    // This assumes MSXML3.DLL for the object, leave the instance dangling
    hInstMSXML = LoadLibraryW( L"msxml3.dll" );
    if ( hInstMSXML == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }

    DllGetClassObject = (DLLGETCLASSOBJECT)GetProcAddress( hInstMSXML, "DllGetClassObject" );
    if ( DllGetClassObject == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }

    // get the class factory object
    hr = DllGetClassObject( rclsid, IID_IClassFactory, (LPVOID*)&spClassFactory );
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    // create a instance of the object we want
    hr = spClassFactory->CreateInstance( NULL, riid, ppv );
    if ( FAILED( hr ) )
    {
        goto exit;
    }

exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\shared\util\txmlparsedfile.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
//  TXmlParsedFile.cpp : Implementation of TXmlParsedFile, TAttribute and TElement

//  This is a read only data table that comes from an XML document.  It contains metadata.
//  It can be used in place of sdtfxd, which has the meta data hard coded into structures.

#include "precomp.hxx"

//Public Methods
TXmlParsedFile::TXmlParsedFile() : m_cbElementPool(0), m_cbStringPool(0), m_cElements(0), m_CurrentLevelBelowRootElement(0), m_cWcharsInStringPool(0),
                m_dwTickCountOfLastParse(0), m_pElement(0), m_pLastBeginTagElement(0), m_pCache(0)
{
    m_FileName[0] = 0x00;
    memset(&m_ftLastWriteTime, 0x00, sizeof(FILETIME));
    if(TXmlParsedFile::Undetermined == m_OSSupportForInterLockedExchangeAdd)
    {
        OSVERSIONINFO osvi;

        memset(&osvi, 0x00, sizeof(osvi));
        osvi.dwOSVersionInfoSize = sizeof(osvi);

        GetVersionEx(&osvi);
        if(((osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) && (osvi.dwMajorVersion >= 4)) ||
            ((osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) && ((osvi.dwMajorVersion > 4) || ((osvi.dwMajorVersion == 4) && (osvi.dwMinorVersion > 0)))))
        {
            HINSTANCE hKernel32 = LoadLibraryA("kernel32.dll");
            m_pfnInterLockedExchangeAdd = reinterpret_cast<INTERLOCKEDEXCHANGEADD>(GetProcAddress(hKernel32, "InterlockedExchangeAdd"));//GetProcAddress tolerates NULL instance handles
			if (m_pfnInterLockedExchangeAdd)
			{
	            m_OSSupportForInterLockedExchangeAdd = Supported;
			}
			else
			{
	            m_OSSupportForInterLockedExchangeAdd = Unsupported;
			}
            FreeLibrary(hKernel32);
        }
        else
        {   // Win95 doesn't have this function
            m_OSSupportForInterLockedExchangeAdd = Unsupported;
        }
    }
    AddRef();//This guy is a callback interface, so we implicitly have a ref count of 1, then when the user is done with it, he should call delete.
}


TXmlParsedFile::~TXmlParsedFile()
{
    //Warning! This object is thread safe but don't delete it while another thread is parsing.  This shouldn't be an issue.
}


HRESULT TXmlParsedFile::Parse(TXmlParsedFileNodeFactory &i_XmlParsedFileNodeFactory, LPCTSTR i_filename, bool bOnlyIfInCache)
{
    HRESULT hr;

    //We have to guard this method with a critical section, otherwise two threads might try to Parse (or Unload) at the same time.
    CSafeLock ThisObject(m_SACriticalSectionThis);
	DWORD dwRes = ThisObject.Lock();
    if(ERROR_SUCCESS != dwRes)
    {
        return HRESULT_FROM_WIN32(dwRes);
    }

    //If we haven't already parsed this file, then parse it into a form that can be scanned quicker.
    WIN32_FILE_ATTRIBUTE_DATA FileInfo;
    GetFileAttributesEx(i_filename, GetFileExInfoStandard, &FileInfo);

    //If this XmlParsedFile is not a complete parse OR the filenames don't match OR the LastWriteTime has changed...
    if(!IsCompletedParse() || 0 != _wcsicmp(i_filename, m_FileName) || 0 != memcmp(&FileInfo.ftLastWriteTime, &m_ftLastWriteTime, sizeof(FILETIME)))
    {
        if(bOnlyIfInCache)
            return E_SDTXML_NOT_IN_CACHE;

        //...then we need to re MSXML Parse
        Unload();//If a file was loaded into this object, unload it.
        if(FAILED(hr = Load(i_filename)))return hr;

        //Remember the LastWriteTime for comparison next time
        memcpy(&m_ftLastWriteTime, &FileInfo.ftLastWriteTime, sizeof(FILETIME));

        //We're getting ready to access the GrowableBuffer, so we need to lock it.
        CSafeLock StaticBuffers(m_SACriticalSectionStaticBuffers);
		dwRes = StaticBuffers.Lock ();
		if(ERROR_SUCCESS != dwRes)
		{
			return HRESULT_FROM_WIN32(dwRes);
		}

        //If the GrowableBuffer isn't big enough, make it bigger.
        if(m_SizeOfGrowableBuffer/2 < ((sizeof(LPVOID)/sizeof(ULONG))*Size()*sizeof(WCHAR))) // for 64 bits we need a larger memory block to store the pointers
        {
            m_aGrowableBuffer.Delete();          //@@@TODO We should check the size as we're adding elements into this buffer and realloc if necessary.  But for now 3 times the size should be big enough for the worst case (excluding contrived enum public row name worst case).
            m_aGrowableBuffer = new unsigned char [3*(sizeof(LPVOID)/sizeof(ULONG))*Size()*sizeof(WCHAR)];
            if(!m_aGrowableBuffer)
                return E_OUTOFMEMORY;
            m_SizeOfGrowableBuffer = 3*(sizeof(LPVOID)/sizeof(ULONG))*Size()*sizeof(WCHAR);
        }

        //Start creating the list of TElement at the beginning of the buffer
        m_cElements     = 0;
        m_cbElementPool = 0;
        m_pElement  = reinterpret_cast<TElement *>(m_aGrowableBuffer.m_p);

        //Node Factory is a stream line way of parsing XML.  It does not validate the XML, nor is it capable of writing.  So populating
        //read only XML tables should be faster than populating writable tables.
        CComPtr<IXMLParser> pXMLParser;
        if(FAILED(hr = i_XmlParsedFileNodeFactory.CoCreateInstance(_CLSID_XMLParser, NULL, CLSCTX_INPROC_SERVER, IID_IXMLParser, (void**)&pXMLParser)))return hr;

        if(FAILED(hr = pXMLParser->SetFactory(this)))return hr;

        if(FAILED(hr = pXMLParser->SetFlags( XMLFLAG_NOWHITESPACE )))return hr;
        if(FAILED(hr = pXMLParser->PushData(Mapping(), Size(), true)))return hr;

        hr = pXMLParser->Run(-1);//Run can return with E_SDTXML_DONE, which is a special case.

        //We're now done with the file so unmap it as soon as possible.
        TFileMapping::Unload();

        if(S_OK != hr && E_SDTXML_DONE != hr)return hr;

        if(!m_pCache)
        {
            //Now that we have a XmlParsedFile, we can scan through the elements quicker
            m_pElement = reinterpret_cast<TElement *>(m_aGrowableBuffer.m_p);
            hr=S_OK;
            for(unsigned int i=0;i<m_cElements && S_OK==hr;++i)
            {
                hr = i_XmlParsedFileNodeFactory.CreateNode(*m_pElement);
                m_pElement = m_pElement->Next();
            }
            Unload();
            return hr;
        }

        //If this object belongs to a cache then allocate and copy the element list from the growable buffer to the member element list
        if(FAILED(hr = AllocateAndCopyElementList((ULONG)(reinterpret_cast<unsigned char *>(m_pElement) + sizeof(DWORD) - m_aGrowableBuffer))))return hr;
                                                                                                //Leave room for the zero terminating m_LevelOfElement
        //If this object belongs to a cache and the parse completed, then accumulate the size
        MemberInterlockedExchangeAdd(&m_pCache->m_cbTotalCache, PoolSize());
    }
    //Now the StaticBuffers are unlocked, but this object is still locked

    //Always keep track of the tick count
    m_dwTickCountOfLastParse = GetTickCount();

    //Now that we have a XmlParsedFile, we can scan through the elements quicker
    m_pElement = reinterpret_cast<TElement *>(m_ElementPool.m_p);
    hr=S_OK;
    for(unsigned int i=0;i<m_cElements && S_OK==hr;++i)
    {
        hr = i_XmlParsedFileNodeFactory.CreateNode(*m_pElement);
        m_pElement = m_pElement->Next();
    }

    return hr;//If XmlParsedFileNodeFactory.CreateNode returned anything but S_OK, return that back out
    //Release this object's critical section as we leave the function
}


HRESULT
TXmlParsedFile::Unload()
{
    CSafeLock ThisObject(m_SACriticalSectionThis);
	DWORD dwRes = ThisObject.Lock();
	if(ERROR_SUCCESS != dwRes)
    {
        return HRESULT_FROM_WIN32(dwRes);
    }

    if(m_pCache)
    {
        MemberInterlockedExchangeAdd(&m_pCache->m_cbTotalCache, -static_cast<long>(PoolSize()));
    }

    m_cbElementPool         = 0;
    m_cbStringPool          = 0;
    m_cElements             = 0;
    m_cWcharsInStringPool   = 0;
    m_FileName[0]           = 0;

    m_ElementPool.Delete();
    m_StringPool.Delete();
    TFileMapping::Unload();

	return S_OK;
}


//Private static variables
TSmartPointerArray<unsigned char>    TXmlParsedFile::m_aGrowableBuffer;
CSafeAutoCriticalSection             TXmlParsedFile::m_SACriticalSectionStaticBuffers;
unsigned long                        TXmlParsedFile::m_SizeOfGrowableBuffer = 0;
int                                  TXmlParsedFile::m_OSSupportForInterLockedExchangeAdd = TXmlParsedFile::Undetermined;
INTERLOCKEDEXCHANGEADD               TXmlParsedFile::m_pfnInterLockedExchangeAdd = NULL;

//IXMLNodeFactory methods
STDMETHODIMP TXmlParsedFile::BeginChildren(IXMLNodeSource __RPC_FAR *i_pSource, XML_NODE_INFO* __RPC_FAR i_pNodeInfo)\
{
    UNREFERENCED_PARAMETER(i_pSource);
    UNREFERENCED_PARAMETER(i_pNodeInfo);

    return S_OK;
}


STDMETHODIMP TXmlParsedFile::CreateNode(IXMLNodeSource __RPC_FAR *i_pSource, PVOID i_pNodeParent, USHORT i_cNumRecs, XML_NODE_INFO* __RPC_FAR * __RPC_FAR i_apNodeInfo)
{
    unsigned long CurrentLevel  = m_CurrentLevelBelowRootElement;

    UNREFERENCED_PARAMETER(i_pSource);
    UNREFERENCED_PARAMETER(i_pNodeParent);

    if (!i_apNodeInfo[0]->fTerminal )
        ++m_CurrentLevelBelowRootElement;

    if(0 == CurrentLevel)
        return S_OK;//We never care about the Root element

    switch(i_apNodeInfo[0]->dwType)
    {
    case XML_ELEMENT:
        {
            if(0 == i_apNodeInfo[0]->pwcText)
                return S_OK;

            m_pElement->m_ElementType         = static_cast<XML_NODE_TYPE>(i_apNodeInfo[0]->dwType);
            m_pElement->m_LevelOfElement      = CurrentLevel;
            m_pElement->m_ElementNameLength   = i_apNodeInfo[0]->ulLen;
            m_pElement->m_ElementName         = AddStringToPool(i_apNodeInfo[0]->pwcText + i_apNodeInfo[0]->ulNsPrefixLen, i_apNodeInfo[0]->ulLen);
            m_pElement->m_NumberOfAttributes  = 0;
            m_pElement->m_NodeFlags           = fBeginTag;
            m_pLastBeginTagElement = m_pElement;

        //    unsigned long len = wcslen(m_pElement->m_ElementName);

            for(unsigned long iNodeInfo=1; iNodeInfo<i_cNumRecs; ++iNodeInfo)
            {
                if(XML_ATTRIBUTE != i_apNodeInfo[iNodeInfo]->dwType)
                    continue;

                m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_NameLength   = i_apNodeInfo[iNodeInfo]->ulLen;
                m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_Name         = AddStringToPool(i_apNodeInfo[iNodeInfo]->pwcText + i_apNodeInfo[iNodeInfo]->ulNsPrefixLen, i_apNodeInfo[iNodeInfo]->ulLen);

                if((iNodeInfo+1) == i_cNumRecs || XML_PCDATA != i_apNodeInfo[iNodeInfo+1]->dwType)
                {   //We don't want to increment iNodeInfo if we're at the last one OR if the next NodeInfo isn't an XML_PCDATA type.
                    m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_ValueLength  = 0;//Zero length string
                    m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_Value        = AddStringToPool(0,0);
                }
                else
                {
                    ++iNodeInfo;
                    m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_ValueLength  = i_apNodeInfo[iNodeInfo]->ulLen;
                    m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_Value        = AddStringToPool(i_apNodeInfo[iNodeInfo]->pwcText + i_apNodeInfo[iNodeInfo]->ulNsPrefixLen, i_apNodeInfo[iNodeInfo]->ulLen);

                    while((iNodeInfo+1)<i_cNumRecs && XML_PCDATA==i_apNodeInfo[iNodeInfo+1]->dwType)
                    {
                        ++iNodeInfo;
                        m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_ValueLength  += i_apNodeInfo[iNodeInfo]->ulLen;
                        AppendToLastStringInPool(i_apNodeInfo[iNodeInfo]->pwcText + i_apNodeInfo[iNodeInfo]->ulNsPrefixLen, i_apNodeInfo[iNodeInfo]->ulLen);
                    }
                }
                ++m_pElement->m_NumberOfAttributes;
            }
        }
        break;
    case XML_COMMENT://These three are exactly the same but with different types
    case XML_PCDATA:
    case XML_WHITESPACE:
        {
            ASSERT(0 != i_apNodeInfo[0]->pwcText && "I don't think this can happen for this type; but I handle it for XML_ELEMENTs so there must have been a reason");
            if(0 == i_apNodeInfo[0]->pwcText)
                return S_OK;

            m_pElement->m_ElementType         = static_cast<XML_NODE_TYPE>(i_apNodeInfo[0]->dwType);
            m_pElement->m_LevelOfElement      = CurrentLevel;
            m_pElement->m_cchComment          = i_apNodeInfo[0]->ulLen;
            m_pElement->m_Comment             = AddStringToPool(i_apNodeInfo[0]->pwcText + i_apNodeInfo[0]->ulNsPrefixLen, i_apNodeInfo[0]->ulLen);
            m_pElement->m_NumberOfAttributes  = 0;
            m_pElement->m_NodeFlags           = fNone;
        }
        break;
    default://ignore all other node types
        return S_OK;
    }


    ++m_cElements;
    m_pElement = m_pElement->Next();
    m_pElement->m_LevelOfElement = 0;//This is my way of zero terminating the linked list.  It is only used by people who have a pElement and want to know
                                     //if it's the last one.  They check if(0 == pElement->Next()->m_LevelOfElement){//last element}
    return S_OK;
}


STDMETHODIMP TXmlParsedFile::EndChildren(IXMLNodeSource __RPC_FAR *i_pSource, BOOL i_fEmptyNode,XML_NODE_INFO* __RPC_FAR i_pNodeInfo)
{
    UNREFERENCED_PARAMETER(i_pSource);

    --m_CurrentLevelBelowRootElement;
    if(0 == m_pLastBeginTagElement || XML_PI == i_pNodeInfo->dwType || XML_XMLDECL == i_pNodeInfo->dwType)
        return S_OK;//This is needed to handle the <?xml version="1.0" encoding="UTF-8" ?>

    if(i_fEmptyNode)
    {
        ASSERT(fBeginTag == m_pLastBeginTagElement->m_NodeFlags);
        m_pLastBeginTagElement->m_NodeFlags |= fEndTag;
    }
    else
    {   //We need to create a new node for the EndTag
            m_pElement->m_ElementType         = static_cast<XML_NODE_TYPE>(i_pNodeInfo->dwType);
            m_pElement->m_LevelOfElement      = m_CurrentLevelBelowRootElement;
            m_pElement->m_cchComment          = i_pNodeInfo->ulLen;
            m_pElement->m_Comment             = AddStringToPool(i_pNodeInfo->pwcText + i_pNodeInfo->ulNsPrefixLen, i_pNodeInfo->ulLen);
            m_pElement->m_NumberOfAttributes  = 0;
            m_pElement->m_NodeFlags           = fEndTag;

            ++m_cElements;
            m_pElement = m_pElement->Next();
            m_pElement->m_LevelOfElement = 0;//This is my way of zero terminating the linked list.  It is only used by people who have a pElement and want to know
                                             //if it's the last one.  They check if(0 == pElement->Next()->m_LevelOfElement){//last element}
    }
    return S_OK;
}


STDMETHODIMP TXmlParsedFile::Error(IXMLNodeSource __RPC_FAR *i_pSource, HRESULT i_hrErrorCode, USHORT i_cNumRecs, XML_NODE_INFO* __RPC_FAR * __RPC_FAR i_apNodeInfo)
{
    UNREFERENCED_PARAMETER(i_pSource);
    UNREFERENCED_PARAMETER(i_cNumRecs);
    UNREFERENCED_PARAMETER(i_apNodeInfo);
    return i_hrErrorCode;
}


STDMETHODIMP TXmlParsedFile::NotifyEvent(IXMLNodeSource __RPC_FAR *i_pSource, XML_NODEFACTORY_EVENT i_iEvt)
{
    UNREFERENCED_PARAMETER(i_pSource);
    UNREFERENCED_PARAMETER(i_iEvt);
    return S_OK;
}



//private methods
LPCWSTR TXmlParsedFile::AddStringToPool(LPCWSTR i_String, unsigned long i_Length)
{
    if(0 == i_String || 0 == i_Length)
        return m_StringPool;

    LPCWSTR rtn = m_StringPool + m_cWcharsInStringPool;

    memcpy(m_StringPool + m_cWcharsInStringPool, i_String, i_Length * sizeof(WCHAR));
    m_cWcharsInStringPool += i_Length;
    m_StringPool[m_cWcharsInStringPool++] = 0x00;//may as well NULL terminate it.
    return rtn;
}


HRESULT TXmlParsedFile::AllocateAndCopyElementList(unsigned long i_Length)
{
    m_ElementPool = new unsigned char [i_Length];
    if(0 == m_ElementPool.m_p)
        return E_OUTOFMEMORY;
    m_cbElementPool = i_Length;
    memcpy(m_ElementPool, m_aGrowableBuffer, i_Length);
    TFileMapping::Unload();
    return S_OK;
}

void TXmlParsedFile::AppendToLastStringInPool(LPCWSTR i_String, unsigned long i_Length)
{
    if(0 == i_String || 0 == i_Length)
        return;

    --m_cWcharsInStringPool;
    memcpy(m_StringPool + m_cWcharsInStringPool, i_String, i_Length * sizeof(WCHAR));
    m_cWcharsInStringPool += i_Length;
    m_StringPool[m_cWcharsInStringPool++] = 0x00;//may as well NULL terminate it.
}

HRESULT TXmlParsedFile::Load(LPCTSTR i_filename)
{
    ASSERT(0 == m_StringPool.m_p);

    HRESULT hr;
    m_FileName[MAX_PATH-1] = 0;
    wcsncpy(m_FileName, i_filename, MAX_PATH-1);//This is probably unnecessary, but this will prevent buffer overrun when i_filename is greater than MAX_PATH.
    if(FAILED(hr = TFileMapping::Load(i_filename, false)))return hr;

    m_StringPool = new WCHAR[Size()];
    if(0 == m_StringPool.m_p)
        return E_OUTOFMEMORY;
    m_cbStringPool = Size();
    m_StringPool[m_cWcharsInStringPool++] = 0x00;//reserve the first WCHAR as a zero length string
    return S_OK;
}

VOID TXmlParsedFile::MemberInterlockedExchangeAdd(PLONG Addend, LONG Increment)
{
        if(Supported == m_OSSupportForInterLockedExchangeAdd)
        {
            ASSERT(m_pfnInterLockedExchangeAdd != NULL);
            m_pfnInterLockedExchangeAdd(Addend, Increment);
        }
        else
        {
            //TODO Take a criticalsection instead
            InterlockedExchange(Addend, (LONG)(*Addend) + Increment);
        }
}



TXmlParsedFile_NoCache::TXmlParsedFile_NoCache() : m_CurrentLevelBelowRootElement(0), m_pElement(0), m_pXmlParsedFileNodeFactory(0)
{
    AddRef();//This guy is a callback interface, so we implicitly have a ref count of 1, then when the user is done with it, he should call delete.
}
TXmlParsedFile_NoCache::~TXmlParsedFile_NoCache()
{
}

HRESULT TXmlParsedFile_NoCache::Parse(TXmlParsedFileNodeFactory &i_XmlParsedFileNodeFactory, LPCTSTR i_filename)
{
    HRESULT hr;

    if(0 == m_ScratchBuffer.m_p)
    {
        m_ScratchBuffer = new unsigned char[0x4000];
        if(0 == m_ScratchBuffer.m_p)
            return E_OUTOFMEMORY;
    }

    m_pElement = reinterpret_cast<TElement *>(m_ScratchBuffer.m_p);
    m_CurrentLevelBelowRootElement = 0;
    m_pXmlParsedFileNodeFactory = &i_XmlParsedFileNodeFactory;

    //Node Factory is a stream line way of parsing XML.  It does not validate the XML, nor is it capable of writing.  So populating
    //read only XML tables should be faster than populating writable tables.
    CComPtr<IXMLParser> pXMLParser;
    if(FAILED(hr = i_XmlParsedFileNodeFactory.CoCreateInstance(_CLSID_XMLParser, NULL, CLSCTX_INPROC_SERVER, IID_IXMLParser, (void**)&pXMLParser)))return hr;

    if(FAILED(hr = pXMLParser->SetFactory(this)))return hr;
    if(FAILED(hr = pXMLParser->SetFlags( XMLFLAG_NOWHITESPACE )))return hr;
    if(FAILED(hr = pXMLParser->SetURL(0, i_filename, FALSE)))return hr;

    hr = pXMLParser->Run(-1);

    m_ScratchBuffer.Delete();
    m_pElement = 0;

    return hr;
}

STDMETHODIMP TXmlParsedFile_NoCache::BeginChildren(IXMLNodeSource __RPC_FAR *i_pSource, XML_NODE_INFO* __RPC_FAR i_pNodeInfo)
{
    UNREFERENCED_PARAMETER(i_pSource);
    UNREFERENCED_PARAMETER(i_pNodeInfo);

    return S_OK;
}

STDMETHODIMP TXmlParsedFile_NoCache::CreateNode(IXMLNodeSource __RPC_FAR *i_pSource, PVOID i_pNodeParent, USHORT i_cNumRecs, XML_NODE_INFO* __RPC_FAR * __RPC_FAR i_apNodeInfo)
{
    HRESULT hr;
    unsigned long CurrentLevel  = m_CurrentLevelBelowRootElement;

    UNREFERENCED_PARAMETER(i_pSource);
    UNREFERENCED_PARAMETER(i_pNodeParent);


    if (!i_apNodeInfo[0]->fTerminal )
        ++m_CurrentLevelBelowRootElement;

    if(0 == CurrentLevel)
        return S_OK;//We never care about the Root element

    switch(i_apNodeInfo[0]->dwType)
    {
    case XML_COMMENT:
    case XML_PCDATA:
    case XML_WHITESPACE:
        m_pElement->m_ElementType         = static_cast<XML_NODE_TYPE>(i_apNodeInfo[0]->dwType);
        m_pElement->m_LevelOfElement      = CurrentLevel;
        m_pElement->m_ElementNameLength   = i_apNodeInfo[0]->ulLen;
        m_pElement->m_ElementName         = i_apNodeInfo[0]->pwcText + i_apNodeInfo[0]->ulNsPrefixLen;
        m_pElement->m_NumberOfAttributes  = 0;
        m_pElement->m_NodeFlags           = fNone;
        return m_pXmlParsedFileNodeFactory->CreateNode(*m_pElement);
    case XML_ELEMENT:
        if(0 == i_apNodeInfo[0]->pwcText)
            return S_OK;
        break;
    default://ignore all other node types
        return S_OK;
    }

    if(XML_ELEMENT != i_apNodeInfo[0]->dwType ||//if this node is not an element, then ignore it
        0 == i_apNodeInfo[0]->pwcText)
        return S_OK;

    m_pElement->m_ElementType         = XML_ELEMENT;
    m_pElement->m_LevelOfElement      = CurrentLevel;
    m_pElement->m_ElementNameLength   = i_apNodeInfo[0]->ulLen;
    m_pElement->m_ElementName         = i_apNodeInfo[0]->pwcText + i_apNodeInfo[0]->ulNsPrefixLen;
    m_pElement->m_NumberOfAttributes  = 0;
    m_pElement->m_NodeFlags           = fBeginTag;
    TSmartPointerArray<TSmartPointerArray<WCHAR> > ppWcharForEscapedAttributeValues;

    for(unsigned long iNodeInfo=1; iNodeInfo<i_cNumRecs; ++iNodeInfo)
    {
        if(XML_ATTRIBUTE != i_apNodeInfo[iNodeInfo]->dwType)
            continue;

        m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_NameLength   = i_apNodeInfo[iNodeInfo]->ulLen;
        m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_Name         = i_apNodeInfo[iNodeInfo]->pwcText + i_apNodeInfo[iNodeInfo]->ulNsPrefixLen;

        if((iNodeInfo+1) == i_cNumRecs || XML_PCDATA != i_apNodeInfo[iNodeInfo+1]->dwType)
        {   //We don't want to increment iNodeInfo if we're at the last one OR if the next NodeInfo isn't an XML_PCDATA type.
            m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_ValueLength  = 0;//Zero length string
            m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_Value        = 0;
        }
        else
        {
            ++iNodeInfo;
            m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_ValueLength  = i_apNodeInfo[iNodeInfo]->ulLen;
            m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_Value        = i_apNodeInfo[iNodeInfo]->pwcText + i_apNodeInfo[iNodeInfo]->ulNsPrefixLen;

            if((iNodeInfo+1)<i_cNumRecs && XML_PCDATA==i_apNodeInfo[iNodeInfo+1]->dwType)
            {
                //When the attribute has an escape sequence in it, we get it as multiple PCDATAs
                //we need to paste them into one string before passing to the XmlParsedFileNodeFactory.

                for(unsigned long iNodeInfoTemp=iNodeInfo+1; iNodeInfoTemp<i_cNumRecs && XML_PCDATA==i_apNodeInfo[iNodeInfoTemp]->dwType;++iNodeInfoTemp)
                {   //Here we determine the length of the resulting attr value (after cat'ing all of the escapes together).
                    m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_ValueLength  += i_apNodeInfo[iNodeInfoTemp]->ulLen;
                }
                if(0 == ppWcharForEscapedAttributeValues.m_p)//if this is the first Escaped attribute value we've seen for this element, then allocate
                {                                            //enoung smartpointersarrays for all attributes (which can be no more that i_cNumRecs).
                    ppWcharForEscapedAttributeValues = new TSmartPointerArray<WCHAR> [i_cNumRecs];
                    if(0 == ppWcharForEscapedAttributeValues.m_p)
                        return E_OUTOFMEMORY;
                }
                //No need to allocate enough space for the NULL since we don't guarentee that string are NULL terminated
                ppWcharForEscapedAttributeValues[iNodeInfo] = new WCHAR [m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_ValueLength + 0x100];
                if(0 == ppWcharForEscapedAttributeValues[iNodeInfo].m_p)
                    return E_OUTOFMEMORY;

                m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_Value = ppWcharForEscapedAttributeValues[iNodeInfo];

                //memcpy the portion of the string that we already have.
                WCHAR *pDestination = ppWcharForEscapedAttributeValues[iNodeInfo];
                memcpy(pDestination, (i_apNodeInfo[iNodeInfo]->pwcText + i_apNodeInfo[iNodeInfo]->ulNsPrefixLen),
                                sizeof(WCHAR)*(i_apNodeInfo[iNodeInfo]->ulLen));
                pDestination += (i_apNodeInfo[iNodeInfo]->ulLen);

                while((iNodeInfo+1)<i_cNumRecs && XML_PCDATA==i_apNodeInfo[iNodeInfo+1]->dwType)
                {
                    ++iNodeInfo;
                    memcpy(pDestination, i_apNodeInfo[iNodeInfo]->pwcText + i_apNodeInfo[iNodeInfo]->ulNsPrefixLen, sizeof(WCHAR)*i_apNodeInfo[iNodeInfo]->ulLen);
                    pDestination += i_apNodeInfo[iNodeInfo]->ulLen;
                }
            }
        }
        ++m_pElement->m_NumberOfAttributes;
    }
    hr = m_pXmlParsedFileNodeFactory->CreateNode(*m_pElement);

    return hr;
}

STDMETHODIMP TXmlParsedFile_NoCache::EndChildren(IXMLNodeSource __RPC_FAR *i_pSource, BOOL i_fEmptyNode,XML_NODE_INFO* __RPC_FAR i_pNodeInfo)
{
    UNREFERENCED_PARAMETER(i_pSource);

    --m_CurrentLevelBelowRootElement;
    if(XML_PI == i_pNodeInfo->dwType || XML_XMLDECL == i_pNodeInfo->dwType)
        return S_OK;//This is needed to handle the <?xml version="1.0" encoding="UTF-8" ?>

    if(0 == i_fEmptyNode)
    {   //We need to create a new node for the EndTag
        m_pElement->m_ElementType         = static_cast<XML_NODE_TYPE>(i_pNodeInfo->dwType);
        m_pElement->m_LevelOfElement      = m_CurrentLevelBelowRootElement;
        m_pElement->m_cchComment          = i_pNodeInfo->ulLen;
        m_pElement->m_Comment             = i_pNodeInfo->pwcText + i_pNodeInfo->ulNsPrefixLen;
        m_pElement->m_NumberOfAttributes  = 0;
        m_pElement->m_NodeFlags           = fEndTag;
        return m_pXmlParsedFileNodeFactory->CreateNode(*m_pElement);
    }
    return S_OK;
}

STDMETHODIMP TXmlParsedFile_NoCache::Error(IXMLNodeSource __RPC_FAR *i_pSource, HRESULT i_hrErrorCode, USHORT i_cNumRecs, XML_NODE_INFO* __RPC_FAR * __RPC_FAR i_apNodeInfo)
{
    UNREFERENCED_PARAMETER(i_pSource);
    UNREFERENCED_PARAMETER(i_cNumRecs);
    UNREFERENCED_PARAMETER(i_apNodeInfo);
    return i_hrErrorCode;
}

STDMETHODIMP TXmlParsedFile_NoCache::NotifyEvent(IXMLNodeSource __RPC_FAR *i_pSource, XML_NODEFACTORY_EVENT i_iEvt)
{
    UNREFERENCED_PARAMETER(i_pSource);
    UNREFERENCED_PARAMETER(i_iEvt);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\shared\xmlwriter\catalogcollectionwriter.cpp ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    CatalogCollectionWriter.cpp

Abstract:

    Implementation of the class that writes collections to the schema file.
    These classes are invoked from the schema compiler after schema compilation
    to enerate the schema file. Hence, they consume the IST data structures.
    It is contained by CCatalogSchemaWriter.

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/

#include "precomp.hxx"

typedef CCatalogPropertyWriter*  LP_CCatalogPropertyWriter;

#define MAX_PROPERTY        700


/***************************************************************************++
Routine Description:

    Constructor for CCatalogCollectionWriter.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/
CCatalogCollectionWriter::CCatalogCollectionWriter():
m_pCWriter(NULL),
m_apProperty(NULL),
m_cProperty(0),
m_iProperty(0)
{
    memset(&m_Collection, 0, sizeof(tTABLEMETARow));

} // CCatalogCollectionWriter


/***************************************************************************++
Routine Description:

    Destructor for CCatalogCollectionWriter.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/
CCatalogCollectionWriter::~CCatalogCollectionWriter()
{
    if(NULL != m_apProperty)
    {
        for(ULONG i=0; i<m_iProperty; i++)
        {
            if(NULL != m_apProperty[i])
            {
                delete m_apProperty[i];
                m_apProperty[i] = NULL;
            }
        }

        delete [] m_apProperty;
        m_apProperty = NULL;
    }
    m_cProperty = 0;
    m_iProperty = 0;

} // ~CCatalogCollectionWriter


/***************************************************************************++
Routine Description:

    Initialize the collection writer object

Arguments:

    [in] TableMetaRow (IST data structure) that has info about the collection
    [in] Writer object - Assume that it is valid for the lifetime of the
         collection writer

Return Value:

    None.

--***************************************************************************/
void CCatalogCollectionWriter::Initialize(tTABLEMETARow*    i_pCollection,
                                          CWriter*          i_pcWriter)
{
    memcpy(&m_Collection, i_pCollection, sizeof(tTABLEMETARow));

    //
    // Assumption: i_pcWriter will be valid for the
    // lifetime of the collection writer object.
    //

    m_pCWriter    = i_pcWriter;

} // CCatalogCollectionWriter::Initialize


/***************************************************************************++
Routine Description:

    Creates a new property writer and adds it to its list.
    Note: This is called only when you add a property to the IIsConfigObject
          collection.

Arguments:

    [in]  ColumnMetaRow (IST data structure) that has info about the property
    [in]  Arra of sizes for elements in ColumnMetaRow
    [out] Property writer object.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CCatalogCollectionWriter::GetPropertyWriter(tCOLUMNMETARow*             i_pProperty,
                                                    ULONG*                      i_aPropertySize,
                                                    CCatalogPropertyWriter**     o_pProperty)
{
    HRESULT hr = S_OK;

    if(m_iProperty == m_cProperty)
    {
        hr = ReAllocate();

        if(FAILED(hr))
        {
            return hr;
        }
    }

    m_apProperty[m_iProperty++] = new CCatalogPropertyWriter();

    if(NULL == m_apProperty[m_iProperty-1])
    {
        return E_OUTOFMEMORY;
    }

    m_apProperty[m_iProperty-1]->Initialize(i_pProperty,
                                            i_aPropertySize,
                                            &m_Collection,
                                            m_pCWriter);

    *o_pProperty = m_apProperty[m_iProperty-1];

    return S_OK;

} // CCatalogCollectionWriter::GetPropertyWriter


/***************************************************************************++
Routine Description:

    Helper function grows the buffer that contains all property writers of
    a collection.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CCatalogCollectionWriter::ReAllocate()
{
    CCatalogPropertyWriter** pSav = NULL;

    pSav = new LP_CCatalogPropertyWriter[m_cProperty + MAX_PROPERTY];
    if(NULL == pSav)
    {
        return E_OUTOFMEMORY;
    }
    memset(pSav, 0, (sizeof(LP_CCatalogPropertyWriter))*(m_cProperty + MAX_PROPERTY));

    if(NULL != m_apProperty)
    {
        memcpy(pSav, m_apProperty, (sizeof(LP_CCatalogPropertyWriter))*(m_cProperty));
        delete [] m_apProperty;
        m_apProperty = NULL;
    }

    m_apProperty = pSav;
    m_cProperty = m_cProperty + MAX_PROPERTY;

    return S_OK;

} // CCatalogCollectionWriter::ReAllocate


/***************************************************************************++
Routine Description:

    Function that writes the collection.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CCatalogCollectionWriter::WriteCollection()
{
    HRESULT hr = S_OK;

    hr = BeginWriteCollection();

    if(FAILED(hr))
    {
        return hr;
    }

    for(ULONG i=0; i<m_iProperty; i++)
    {
        hr = m_apProperty[i]->WriteProperty();

        if(FAILED(hr))
        {
            return hr;
        }

    }

    hr = EndWriteCollection();

    if(FAILED(hr))
    {
        return hr;
    }

    return hr;

} // CCatalogCollectionWriter::WriteCollection


/***************************************************************************++
Routine Description:

    Function that writes the begin collection tag

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CCatalogCollectionWriter::BeginWriteCollection()
{
    DBG_ASSERT(NULL != m_Collection.pInternalName);
    DBG_ASSERT(NULL != m_Collection.pSchemaGeneratorFlags);
    DBG_ASSERT(NULL != m_Collection.pMetaFlags);

    HRESULT     hr                      = S_OK;
    LPWSTR      wszMetaFlagsEx          = NULL;
    LPWSTR      wszMetaFlags            = NULL;
    LPWSTR      wszEndBeginCollection   = NULL;
    ULONG       cchEndBeginCollection   = 0;
    ULONG       iColMetaFlagsEx         = iTABLEMETA_SchemaGeneratorFlags;
    ULONG       iColMetaFlags           = iTABLEMETA_MetaFlags;

    DWORD       dwMetaFlagsEx           = 0;
    DWORD       dwValidMetaFlagsExMask  =  fTABLEMETA_EMITXMLSCHEMA             |
                                           fTABLEMETA_EMITCLBBLOB               |
                                           fTABLEMETA_NOTSCOPEDBYTABLENAME      |
                                           fTABLEMETA_GENERATECONFIGOBJECTS     |
                                           fTABLEMETA_NOTABLESCHEMAHEAPENTRY    |
                                           fTABLEMETA_CONTAINERCLASS;



    hr = m_pCWriter->WriteToFile((LPVOID)g_wszBeginCollection,
                                 g_cchBeginCollection);

    if(FAILED(hr))
    {
        goto exit;
    }


    hr = m_pCWriter->WriteToFile((LPVOID)m_Collection.pInternalName,
                                 (DWORD)wcslen(m_Collection.pInternalName));

    if(FAILED(hr))
    {
        goto exit;
    }

    dwMetaFlagsEx = *(m_Collection.pSchemaGeneratorFlags);
    dwMetaFlagsEx = dwMetaFlagsEx & dwValidMetaFlagsExMask; // Zero out any non-valid bits. (i.e. bits that must be inferred)

    if(dwMetaFlagsEx != 0)
    {
        hr = m_pCWriter->m_pCWriterGlobalHelper->FlagToString(dwMetaFlagsEx,
                                                              &wszMetaFlagsEx,
                                                              wszTABLE_TABLEMETA,
                                                              iColMetaFlagsEx);

        if(FAILED(hr))
        {
            goto exit;
        }

        hr = m_pCWriter->WriteToFile((LPVOID)g_wszMetaFlagsExEq,
                                     g_cchMetaFlagsExEq);

        if(FAILED(hr))
        {
            goto exit;
        }

        hr = m_pCWriter->WriteToFile((LPVOID)wszMetaFlagsEx,
                                     (DWORD)wcslen(wszMetaFlagsEx));

        if(FAILED(hr))
        {
            goto exit;
        }

    }


    if((*(m_Collection.pMetaFlags)) != 0)
    {
        hr = m_pCWriter->m_pCWriterGlobalHelper->FlagToString(*(m_Collection.pMetaFlags),
                                                              &wszMetaFlags,
                                                              wszTABLE_TABLEMETA,
                                                              iColMetaFlags);

        if(FAILED(hr))
        {
            goto exit;
        }

        hr = m_pCWriter->WriteToFile((LPVOID)g_wszMetaFlagsEq,
                                     g_cchMetaFlagsEq);

        if(FAILED(hr))
        {
            goto exit;
        }

        hr = m_pCWriter->WriteToFile((LPVOID)wszMetaFlags,
                                     (DWORD)wcslen(wszMetaFlags));

        if(FAILED(hr))
        {
            goto exit;
        }
    }

    if(m_Collection.pContainerClassList != NULL)
    {
        hr = m_pCWriter->WriteToFile((LPVOID)g_wszContainerClassListEq,
                                     g_cchContainerClassListEq);

        if(FAILED(hr))
        {
            goto exit;
        }

        hr = m_pCWriter->WriteToFile((LPVOID)m_Collection.pContainerClassList,
                                     (DWORD)wcslen(m_Collection.pContainerClassList));

        if(FAILED(hr))
        {
            goto exit;
        }

    }


    if(0 == _wcsicmp(m_Collection.pInternalName, wszTABLE_IIsConfigObject))
    {
        wszEndBeginCollection = (LPWSTR)g_wszEndBeginCollectionCatalog;
        cchEndBeginCollection = g_cchEndBeginCollectionCatalog;
    }
    else
    {
        wszEndBeginCollection = (LPWSTR)g_wszInheritsFrom;
        cchEndBeginCollection = g_cchInheritsFrom;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)wszEndBeginCollection,
                                 cchEndBeginCollection);

    if(FAILED(hr))
    {
        goto exit;
    }

exit:

    if(NULL != wszMetaFlagsEx)
    {
        delete [] wszMetaFlagsEx;
        wszMetaFlagsEx = NULL;
    }

    if(NULL != wszMetaFlags)
    {
        delete [] wszMetaFlags;
        wszMetaFlags = NULL;
    }

    return hr;

} // CCatalogCollectionWriter::BeginWriteCollection



/***************************************************************************++
Routine Description:

    Function that writes the end collection tag

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CCatalogCollectionWriter::EndWriteCollection()
{
    return m_pCWriter->WriteToFile((LPVOID)g_wszEndCollection,
                                   g_cchEndCollection);

} // CCatalogCollectionWriter::EndWriteCollection
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\shared\xmlwriter\catalogpropertywriter.cpp ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    CatalogPropertyWriter.cpp

Abstract:

    Implementation of the class that writes properties to the schema file.
    These classes are invoked from the schema compiler after schema compilation
    to enerate the schema file. Hence, they consume the IST data structures.
    It is contained by CCatalogCollectionWriter.

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/

#include "precomp.hxx"

#define MAX_FLAG 32

typedef tTAGMETARow* LP_tTAGMETARow;


/***************************************************************************++
Routine Description:

    Helper function that returns the metabase-type from the catalog SynID

Arguments:

    [in]  CatalogSynID
    [out] Metabase Type

Return Value:

    HRESULT

--***************************************************************************/
HRESULT GetMetabaseDisplayTypeFromSynID(DWORD       i_dwSynID,
                                        LPWSTR*     o_pwszType)
{
    if((i_dwSynID < 1) || (i_dwSynID > 12))
    {
        return E_INVALIDARG;
    }
    else
    {
        *o_pwszType = (LPWSTR)g_aSynIDToWszType[i_dwSynID];
    }

    return S_OK;
}


/***************************************************************************++
Routine Description:

    Constructor for CCatalogPropertyWriter.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/
CCatalogPropertyWriter::CCatalogPropertyWriter():
m_pCWriter(NULL),
m_pCollection(NULL),
m_aFlag(NULL),
m_cFlag(0),
m_iFlag(0)
{
    memset(&m_Property, 0, sizeof(tCOLUMNMETARow));

} // CCatalogPropertyWriter::CCatalogPropertyWriter


/***************************************************************************++
Routine Description:

    Destructor for CCatalogPropertyWriter.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/
CCatalogPropertyWriter::~CCatalogPropertyWriter()
{
    if(NULL != m_aFlag)
    {
        delete [] m_aFlag;
        m_aFlag = NULL;
    }
    m_cFlag = 0;
    m_iFlag = 0;

} // CCatalogPropertyWriter::CCatalogPropertyWriter


/***************************************************************************++
Routine Description:

    Initialize the property writer object

Arguments:

    [in] ColumnMetaRow (IST data structure) that has info about the property
    [in] Array of sizes that indicates the sizes for individual members of the
         ColumnMetaRow structure.
    [in] TableMetaRow (IST data structure) that has info about the collection
         to which the properties belong
    [in] Writer object - Assume that it is valid for the lifetime of the
         property writer

Return Value:

    None.

--***************************************************************************/
void CCatalogPropertyWriter::Initialize(tCOLUMNMETARow* i_pProperty,
                                        ULONG*          i_aPropertySize,
                                        tTABLEMETARow*  i_pCollection,
                                        CWriter*        i_pcWriter)
{
    //
    // Assumption: i_pcWriter will be valid for the
    // lifetime of the property writer object.
    //

    m_pCWriter    = i_pcWriter;
    m_pCollection = i_pCollection;

    memcpy(&m_Property, i_pProperty, sizeof(tCOLUMNMETARow));
    memcpy(&m_PropertySize, i_aPropertySize, sizeof(m_PropertySize));

} // CCatalogPropertyWriter::Initialize


/***************************************************************************++
Routine Description:

    Save property's flag.

Arguments:

    [in] tTAGMETARow (IST data structure) that has information about the flag

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CCatalogPropertyWriter::AddFlagToProperty(tTAGMETARow*      i_pFlag)
{
    HRESULT hr = S_OK;

    if(m_iFlag == m_cFlag)
    {
        hr = ReAllocate();

        if(FAILED(hr))
        {
            return hr;
        }
    }

    memcpy(&(m_aFlag[m_iFlag++]), i_pFlag, sizeof(tTAGMETARow));

    return hr;

} // CCatalogPropertyWriter::AddFlagToProperty



/***************************************************************************++
Routine Description:

    Helper function to grow the buffer that holds the flag objects

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CCatalogPropertyWriter::ReAllocate()
{
    tTAGMETARow* pSav = NULL;

    pSav = new tTAGMETARow[m_cFlag + MAX_FLAG];
    if(NULL == pSav)
    {
        return E_OUTOFMEMORY;
    }
    memset(pSav, 0, (sizeof(tTAGMETARow))*(m_cFlag + MAX_FLAG));

    if(NULL != m_aFlag)
    {
        memcpy(pSav, m_aFlag, (sizeof(tTAGMETARow))*(m_cFlag));
        delete [] m_aFlag;
        m_aFlag = NULL;
    }

    m_aFlag = pSav;
    m_cFlag = m_cFlag + MAX_FLAG;

    return S_OK;

} // CCatalogPropertyWriter::ReAllocate


/***************************************************************************++
Routine Description:

    Function that writes the property.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CCatalogPropertyWriter::WriteProperty()
{
    HRESULT hr = S_OK;

    if(0 == _wcsicmp(m_pCollection->pInternalName, wszTABLE_IIsConfigObject))
    {
        hr = WritePropertyLong();
    }
    else
    {
        hr = WritePropertyShort();
    }

    return hr;

} // CCatalogPropertyWriter::WriteProperty


/***************************************************************************++
Routine Description:

    Function that writes the property (short form) i.e. property that belongs
    to a non-IIsConfigObject collection.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CCatalogPropertyWriter::WritePropertyShort()
{
    HRESULT     hr               = S_OK;
    WCHAR*      wszMetaFlagsEx   = NULL;
    DWORD       dwMetaFlagsEx    = fCOLUMNMETA_MANDATORY;
    DWORD       iColMetaFlagsEx  = iCOLUMNMETA_SchemaGeneratorFlags;

    hr = m_pCWriter->WriteToFile((LPVOID)g_wszBeginPropertyShort,
                                 g_cchBeginPropertyShort);

    if(FAILED(hr))
    {
        goto exit;
    }

    DBG_ASSERT((NULL != m_Property.pInternalName) && (0 != *(m_Property.pInternalName)));
    DBG_ASSERT(NULL != m_Property.pSchemaGeneratorFlags);

    hr = m_pCWriter->WriteToFile((LPVOID)m_Property.pInternalName,
                                 (DWORD)wcslen(m_Property.pInternalName));

    if(FAILED(hr))
    {
        goto exit;
    }

    if(fCOLUMNMETA_MANDATORY & (*(m_Property.pSchemaGeneratorFlags)))
    {
        //
        // Compute the MetaFlags string
        //

        hr = m_pCWriter->m_pCWriterGlobalHelper->FlagToString(dwMetaFlagsEx,
                                                              &wszMetaFlagsEx,
                                                              wszTABLE_COLUMNMETA,
                                                              iColMetaFlagsEx);

        if(FAILED(hr))
        {
            goto exit;
        }

        DBG_ASSERT((NULL != wszMetaFlagsEx) && (0 != *wszMetaFlagsEx));

        hr = m_pCWriter->WriteToFile((LPVOID)g_wszMetaFlagsExEq,
                                     g_cchMetaFlagsExEq);

        if(FAILED(hr))
        {
            goto exit;
        }

        hr = m_pCWriter->WriteToFile((LPVOID)g_wszOr,
                                     g_cchOr);

        if(FAILED(hr))
        {
            goto exit;
        }

        hr = m_pCWriter->WriteToFile((LPVOID)wszMetaFlagsEx,
                                     (DWORD)wcslen(wszMetaFlagsEx));

        if(FAILED(hr))
        {
            goto exit;
        }

    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_wszEndPropertyShort,
                                 g_cchEndPropertyShort);

exit:

    if(NULL != wszMetaFlagsEx)
    {
        delete [] wszMetaFlagsEx;
        wszMetaFlagsEx = NULL;
    }

    return hr;

} // CCatalogPropertyWriter::WritePropertyShort


/***************************************************************************++
Routine Description:

    Function that writes the property (long form) i.e. property that belongs
    to the global IIsConfigObject collection.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CCatalogPropertyWriter::WritePropertyLong()
{
    HRESULT hr = S_OK;

    hr = BeginWritePropertyLong();

    if(FAILED(hr))
    {
        return hr;
    }

    if(NULL != m_aFlag)
    {
        for(ULONG i=0; i<m_iFlag; i++)
        {
            hr = WriteFlag(i);

            if(FAILED(hr))
            {
                return hr;
            }
        }
    }

    hr = EndWritePropertyLong();

    return hr;

} // CCatalogPropertyWriter::WritePropertyLong


/***************************************************************************++
Routine Description:

    Function that writes the property (long form) i.e. property that belongs
    to a IIsConfigObject collection.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CCatalogPropertyWriter::BeginWritePropertyLong()
{
    HRESULT     hr                       = S_OK;
    WCHAR       wszID[40];
    WCHAR*      wszType                  = NULL;
    WCHAR*      wszUserType              = NULL;
    ULONG       cchUserType              = 0;
    BOOL        bAllocedUserType         = FALSE;
    WCHAR*      wszAttribute             = NULL;
    DWORD       iColAttribute            = iCOLUMNMETA_Attributes;
    WCHAR*      wszMetaFlags             = NULL;
    DWORD       iColMetaFlags            = iCOLUMNMETA_MetaFlags;
    WCHAR*      wszMetaFlagsEx           = NULL;
    DWORD       iColMetaFlagsEx          = iCOLUMNMETA_SchemaGeneratorFlags;
    WCHAR*      wszDefaultValue          = NULL;
    WCHAR       wszMinValue[40];
    WCHAR       wszMaxValue[40];
    DWORD       dwMetaFlags              = 0;
    DWORD       dwValidMetaFlagsMask     = fCOLUMNMETA_PRIMARYKEY           |
                                           fCOLUMNMETA_DIRECTIVE            |
                                           fCOLUMNMETA_WRITENEVER           |
                                           fCOLUMNMETA_WRITEONCHANGE        |
                                           fCOLUMNMETA_WRITEONINSERT        |
                                           fCOLUMNMETA_NOTPUBLIC            |
                                           fCOLUMNMETA_NOTDOCD              |
                                           fCOLUMNMETA_PUBLICREADONLY       |
                                           fCOLUMNMETA_PUBLICWRITEONLY      |
                                           fCOLUMNMETA_INSERTGENERATE       |
                                           fCOLUMNMETA_INSERTUNIQUE         |
                                           fCOLUMNMETA_INSERTPARENT         |
                                           fCOLUMNMETA_LEGALCHARSET         |
                                           fCOLUMNMETA_ILLEGALCHARSET       |
                                           fCOLUMNMETA_NOTPERSISTABLE       |
                                           fCOLUMNMETA_CASEINSENSITIVE      |
                                           fCOLUMNMETA_TOLOWERCASE;
    DWORD       dwMetaFlagsEx            = 0;
    DWORD       dwValidMetaFlagsExMask   = fCOLUMNMETA_CACHE_PROPERTY_MODIFIED  |
                                           fCOLUMNMETA_CACHE_PROPERTY_CLEARED   |
                                           fCOLUMNMETA_PROPERTYISINHERITED      |
                                           fCOLUMNMETA_USEASPUBLICROWNAME       |
                                           fCOLUMNMETA_MANDATORY                |
                                           fCOLUMNMETA_WAS_NOTIFICATION         |
                                           fCOLUMNMETA_HIDDEN;
    DWORD       dwSynID                  = 0;



    hr = m_pCWriter->WriteToFile((LPVOID)g_wszBeginPropertyLong,
                                 g_cchBeginPropertyLong);

    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // Name of the property
    //

    DBG_ASSERT((NULL != m_Property.pInternalName) && (0 != *m_Property.pInternalName));

    hr = m_pCWriter->WriteToFile((LPVOID)m_Property.pInternalName,
                                 (DWORD)wcslen(m_Property.pInternalName));

    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // ID of the property
    //

    hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropIDEq,
                                 g_cchPropIDEq);

    if(FAILED(hr))
    {
        goto exit;
    }

    DBG_ASSERT(NULL != m_Property.pID);
    wszID[0] = 0;
    _ultow(*(m_Property.pID), wszID, 10);

    hr = m_pCWriter->WriteToFile((LPVOID)wszID,
                                 (DWORD)wcslen(wszID));

    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // Type of the property
    //

    hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropTypeEq,
                                 g_cchPropTypeEq);

    if(FAILED(hr))
    {
        goto exit;
    }

    // The type should always be derived from the SynID
    // TODO: At some point, we should get this from the schema.
    DBG_ASSERT(NULL != m_Property.pSchemaGeneratorFlags);

    dwSynID = SynIDFromMetaFlagsEx(*(m_Property.pSchemaGeneratorFlags));
    hr = GetMetabaseDisplayTypeFromSynID(dwSynID,
                                         &wszType);

    if(FAILED(hr))
    {
        goto exit;
    }
    DBG_ASSERT((NULL != wszType) && ( 0 != *wszType));

    hr = m_pCWriter->WriteToFile((LPVOID)wszType,
                                 (DWORD)wcslen(wszType));

    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // UserType of the property
    //

    hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropUserTypeEq,
                                 g_cchPropUserTypeEq);

    if(FAILED(hr))
    {
        goto exit;
    }

    DBG_ASSERT(NULL != m_Property.pUserType);
    hr = m_pCWriter->m_pCWriterGlobalHelper->GetUserType(*(m_Property.pUserType),
                                                         &wszUserType,
                                                         &cchUserType,
                                                         &bAllocedUserType);
    if(FAILED(hr))
    {
        goto exit;
    }
    DBG_ASSERT((NULL != wszUserType) && ( 0 != *wszUserType));

    hr = m_pCWriter->WriteToFile((LPVOID)wszUserType,
                                 cchUserType);

    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // Attribute of the property
    //

    DBG_ASSERT(NULL != m_Property.pAttributes);
    hr = m_pCWriter->m_pCWriterGlobalHelper->FlagToString(*(m_Property.pAttributes),
                                                          &wszAttribute,
                                                          wszTABLE_COLUMNMETA,
                                                          iColAttribute);

    if(FAILED(hr))
    {
        goto exit;
    }

    if(NULL != wszAttribute)
    {
        hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropAttributeEq,
                                     g_cchPropAttributeEq);

        if(FAILED(hr))
        {
            goto exit;
        }

        hr = m_pCWriter->WriteToFile((LPVOID)wszAttribute,
                                     (DWORD)wcslen(wszAttribute));

        if(FAILED(hr))
        {
            goto exit;
        }
    }


    //
    // MetaFlags (only the relavant ones - PRIMARYKEY, BOOL, MULTISTRING, EXPANDSTRING)
    //

    DBG_ASSERT(NULL != m_Property.pMetaFlags);
    dwMetaFlags = *(m_Property.pMetaFlags);
    // Zero out any non-valid bits. (i.e. bits that must be inferred)
    dwMetaFlags = dwMetaFlags & dwValidMetaFlagsMask;

    if(0 != dwMetaFlags)
    {
        hr = m_pCWriter->m_pCWriterGlobalHelper->FlagToString(dwMetaFlags,
                                                              &wszMetaFlags,
                                                              wszTABLE_COLUMNMETA,
                                                              iColMetaFlags);

        if(FAILED(hr))
        {
            goto exit;
        }

        if(NULL != wszMetaFlags)
        {
            hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropMetaFlagsEq,
                                         g_cchPropMetaFlagsEq);

            if(FAILED(hr))
            {
                goto exit;
            }

            hr = m_pCWriter->WriteToFile((LPVOID)wszMetaFlags,
                                         (DWORD)wcslen(wszMetaFlags));

            if(FAILED(hr))
            {
                goto exit;
            }

        }

    }

    //
    // MetaFlagsEx (only the relavant ones - CACHE_PROPERTY_MODIFIED, CACHE_PROPERTY_CLEARED, EXTENDEDTYPE0-3, MANDATORY)
    //

    DBG_ASSERT(NULL != m_Property.pSchemaGeneratorFlags);
    dwMetaFlagsEx = *(m_Property.pSchemaGeneratorFlags);
    // Zero out any non-valid bits. (i.e. bits that must be inferred)
    dwMetaFlagsEx = dwMetaFlagsEx & dwValidMetaFlagsExMask;

    if(0 != dwMetaFlagsEx)
    {
        hr = m_pCWriter->m_pCWriterGlobalHelper->FlagToString(dwMetaFlagsEx,
                                                              &wszMetaFlagsEx,
                                                              wszTABLE_COLUMNMETA,
                                                              iColMetaFlagsEx);

        if(FAILED(hr))
        {
            goto exit;
        }

        if(NULL != wszMetaFlagsEx)
        {
            hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropMetaFlagsExEq,
                                         g_cchPropMetaFlagsExEq);

            if(FAILED(hr))
            {
                goto exit;
            }

            hr = m_pCWriter->WriteToFile((LPVOID)wszMetaFlagsEx,
                                         (DWORD)wcslen(wszMetaFlagsEx));

            if(FAILED(hr))
            {
                goto exit;
            }
        }
    }


    //
    // DefaultValue
    //

    if(NULL != m_Property.pDefaultValue)
    {
            DBG_ASSERT(NULL != m_Property.pID);
        hr = m_pCWriter->m_pCWriterGlobalHelper->ToString(m_Property.pDefaultValue,
                                                          m_PropertySize[iCOLUMNMETA_DefaultValue],
                                                          *(m_Property.pID),
                                                          MetabaseTypeFromColumnMetaType(),
                                                          METADATA_NO_ATTRIBUTES,           // Do not check for attributes while applying defaults
                                                          &wszDefaultValue);

        if(FAILED(hr))
        {
            goto exit;
        }

        if(NULL != wszDefaultValue)
        {
            hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropDefaultEq,
                                         g_cchPropDefaultEq);

            if(FAILED(hr))
            {
                goto exit;
            }

            hr = m_pCWriter->WriteToFile((LPVOID)wszDefaultValue,
                                         (DWORD)wcslen(wszDefaultValue));

            if(FAILED(hr))
            {
                goto exit;
            }
        }

    }

    //
    // Min and Max only for DWORDs
    //

    wszMinValue[0] = 0;
    wszMaxValue[0] = 0;

    // TODO: Change to DBTYPE_DWORD
    DBG_ASSERT(NULL != m_Property.pType);
    if(19 == *(m_Property.pType))
    {
        if(NULL != m_Property.pStartingNumber && 0 != *m_Property.pStartingNumber)
        {
            _ultow(*(m_Property.pStartingNumber), wszMinValue, 10);

            hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropMinValueEq,
                                         g_cchPropMinValueEq);

            if(FAILED(hr))
            {
                goto exit;
            }

            hr = m_pCWriter->WriteToFile((LPVOID)wszMinValue,
                                         (DWORD)wcslen(wszMinValue));

            if(FAILED(hr))
            {
                goto exit;
            }


        }

        if(NULL != m_Property.pEndingNumber && -1 != *m_Property.pEndingNumber)
        {
            _ultow(*(m_Property.pEndingNumber), wszMaxValue, 10);

            hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropMaxValueEq,
                                         g_cchPropMaxValueEq);

            if(FAILED(hr))
            {
                goto exit;
            }

            hr = m_pCWriter->WriteToFile((LPVOID)wszMaxValue,
                                         (DWORD)wcslen(wszMaxValue));

            if(FAILED(hr))
            {
                goto exit;
            }

        }
    }


    //
    // Write the flags
    //

    if(NULL != m_aFlag)
    {
        hr = m_pCWriter->WriteToFile((LPVOID)g_wszEndPropertyLongBeforeFlag,
                                 g_cchEndPropertyLongBeforeFlag);

        if(FAILED(hr))
        {
            goto exit;
        }
    }

exit:

    if((NULL != wszUserType) && bAllocedUserType)
    {
        delete [] wszUserType;
    }
    if(NULL != wszAttribute)
    {
        delete [] wszAttribute;
    }
    if(NULL != wszMetaFlags)
    {
        delete [] wszMetaFlags;
    }
    if(NULL != wszMetaFlagsEx)
    {
        delete [] wszMetaFlagsEx;
    }
    if(NULL != wszDefaultValue)
    {
        delete [] wszDefaultValue;
    }

    return hr;

} // CCatalogPropertyWriter::BeginWritePropertyLong


/***************************************************************************++
Routine Description:

    Function that writes the property (long form) i.e. property that belongs
    to a IIsConfigObject collection.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CCatalogPropertyWriter::EndWritePropertyLong()
{
    HRESULT     hr              = S_OK;
    WCHAR*      wszEndProperty  = NULL;

    if(NULL != m_aFlag)
    {
        wszEndProperty = (LPWSTR)g_wszEndPropertyLongAfterFlag;
    }
    else
    {
        wszEndProperty = (LPWSTR)g_wszEndPropertyShort;
    }


    hr = m_pCWriter->WriteToFile((LPVOID)wszEndProperty,
                                 (DWORD)wcslen(wszEndProperty));

    return hr;

}


/***************************************************************************++
Routine Description:

    Function that writes a flag of the property

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CCatalogPropertyWriter::WriteFlag(ULONG i_iFlag)
{
    HRESULT             hr          = S_OK;
    WCHAR               wszValue[25];
    // IVANPASH BUG #563549
    // Because of the horrible implementation of _ultow Prefix is complaning about potential buffer overflow
    // in MultiByteToWideChar indirectly called by _ultow. To avoid the warning I am increasing
    // the size to 40 to match _ultow local buffer.
    WCHAR               wszID[40];

    hr = m_pCWriter->WriteToFile((LPVOID)g_wszBeginFlag,
                                 g_cchBeginFlag);

    if(FAILED(hr))
    {
        goto exit;
    }

    DBG_ASSERT(NULL != m_aFlag[i_iFlag].pInternalName);
    hr = m_pCWriter->WriteToFile((LPVOID)m_aFlag[i_iFlag].pInternalName,
                                 (DWORD)wcslen(m_aFlag[i_iFlag].pInternalName));

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_wszFlagValueEq,
                                 g_cchFlagValueEq);

    if(FAILED(hr))
    {
        goto exit;
    }

    DBG_ASSERT(NULL != m_aFlag[i_iFlag].pValue);
    wszValue[0] = 0;
    _ultow(*(m_aFlag[i_iFlag].pValue), wszValue, 10);

    hr = m_pCWriter->WriteToFile((LPVOID)wszValue,
                                 (DWORD)wcslen(wszValue));

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_wszFlagIDEq,
                                 g_cchFlagIDEq);

    if(FAILED(hr))
    {
        goto exit;
    }

    DBG_ASSERT(NULL != m_aFlag[i_iFlag].pID);
    wszID[0] = wszID[39] = L'\0';
    _ultow(*(m_aFlag[i_iFlag].pID), wszID, 10);

    hr = m_pCWriter->WriteToFile((LPVOID)wszID,
                                 (DWORD)wcslen(wszID));

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_wszEndFlag,
                                 g_cchEndFlag);

    if(FAILED(hr))
    {
        goto exit;
    }

exit:

    return hr;

} // CCatalogPropertyWriter::WriteFlag


/***************************************************************************++
Routine Description:

    Helper funciton that gets the Metabase type from the Catalog ype

Arguments:

    None

Return Value:

    DWORD - Metabase Type

--***************************************************************************/
DWORD CCatalogPropertyWriter::MetabaseTypeFromColumnMetaType()
{
    DBG_ASSERT(NULL != m_Property.pType);

    switch(*(m_Property.pType))
    {
    case eCOLUMNMETA_UI4:
        return eMBProperty_DWORD;
    case eCOLUMNMETA_BYTES:
        return eMBProperty_BINARY;
    case eCOLUMNMETA_WSTR:
        if(*(m_Property.pMetaFlags) & fCOLUMNMETA_EXPANDSTRING)
            return eMBProperty_EXPANDSZ;
        else if(*(m_Property.pMetaFlags) & fCOLUMNMETA_MULTISTRING)
            return eMBProperty_MULTISZ;
        return eMBProperty_STRING;
    default:
        ;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\shared\xmlwriter\catalogschemawriter.cpp ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    CatalogSchemaWriter.cpp

Abstract:

    Implementation of the class that writes schema file. These classes
    are invoked from the schema compiler, after schema compilation, to
    generate the schema file. Hence, they consume the IST data structures.

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/

#include "precomp.hxx"

typedef CCatalogCollectionWriter* LP_CCatalogCollectionWriter;

#define  MAX_COLLECTIONS        50



/***************************************************************************++
Routine Description:

    Constructor for CCatalogSchemaWriter.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/
CCatalogSchemaWriter::CCatalogSchemaWriter(CWriter* i_pcWriter):
m_apCollection(NULL),
m_cCollection(0),
m_iCollection(0),
m_pCWriter(NULL)
{
    //
    // Assumption: i_pcWriter will be valid for the
    // lifetime of the schema writer object.
    //

    m_pCWriter = i_pcWriter;

} // CCatalogSchemaWriter


/***************************************************************************++
Routine Description:

    Destructor for CCatalogSchemaWriter.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/
CCatalogSchemaWriter::~CCatalogSchemaWriter()
{
    if(NULL != m_apCollection)
    {
        for(ULONG i=0; i<m_iCollection; i++)
        {
            if(NULL != m_apCollection[i])
            {
                delete m_apCollection[i];
                m_apCollection[i] = NULL;
            }
        }

        delete [] m_apCollection;
        m_apCollection = NULL;
    }

    m_cCollection = 0;
    m_iCollection = 0;

} // ~CCatalogSchemaWriter


/***************************************************************************++
Routine Description:

    Creates a new collection writer and saves it in its list

Arguments:

    [in]  TableMetaRow (IST data structure) that has info about the collection
    [out] New collection writer object

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CCatalogSchemaWriter::GetCollectionWriter(tTABLEMETARow* i_pCollection,
                                                  CCatalogCollectionWriter**    o_pCollectionWriter)
{
    CCatalogCollectionWriter*    pCCatalogCollectionWriter = NULL;
    HRESULT                      hr                        = S_OK;

    *o_pCollectionWriter = NULL;

    if(m_iCollection == m_cCollection)
    {
        hr = ReAllocate();

        if(FAILED(hr))
        {
            return hr;
        }
    }

    pCCatalogCollectionWriter = new CCatalogCollectionWriter();

    if(NULL == pCCatalogCollectionWriter)
    {
        return E_OUTOFMEMORY;
    }

    pCCatalogCollectionWriter->Initialize(i_pCollection,
                                                m_pCWriter);

    m_apCollection[m_iCollection++] = pCCatalogCollectionWriter;

    *o_pCollectionWriter = pCCatalogCollectionWriter;

    return S_OK;

} // CCatalogSchemaWriter::GetCollectionWriter



/***************************************************************************++
Routine Description:

    ReAllocates its list of collection writers.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CCatalogSchemaWriter::ReAllocate()
{
    CCatalogCollectionWriter** pSav = NULL;

    pSav = new LP_CCatalogCollectionWriter[m_cCollection + MAX_COLLECTIONS];
    if(NULL == pSav)
    {
        return E_OUTOFMEMORY;
    }
    memset(pSav, 0, (sizeof(LP_CCatalogCollectionWriter))*(m_cCollection + MAX_COLLECTIONS));

    if(NULL != m_apCollection)
    {
        memcpy(pSav, m_apCollection, (sizeof(LP_CCatalogCollectionWriter))*(m_cCollection));
        delete [] m_apCollection;
        m_apCollection = NULL;
    }

    m_apCollection = pSav;
    m_cCollection = m_cCollection + MAX_COLLECTIONS;

    return S_OK;

} // CCatalogSchemaWriter::ReAllocate


/***************************************************************************++
Routine Description:

    Wites the schema.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CCatalogSchemaWriter::WriteSchema()
{
    HRESULT hr = S_OK;

    for(ULONG i=0; i<m_iCollection; i++)
    {
        hr = m_apCollection[i]->WriteCollection();

        if(FAILED(hr))
        {
            return hr;
        }
    }

    return hr;

} // CCatalogSchemaWriter::WriteSchema
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\shared\xmlwriter\mbschemawriter.cpp ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    MBSchemaWriter.cpp

Abstract:

    Implementation of the class that writes schema extensions.
    If there are schema extensions, then, we create an extensions file
    (MD_SCHEMA_EXTENSION_FILE_NAMEW), that contains the schema extension
    descriptions and we then compile it into the schema bin format.

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/

#include "precomp.hxx"

typedef  CMBCollectionWriter*   LP_CMBCollectionWriter;

#define  MAX_COLLECTIONS        50

/***************************************************************************++
Routine Description:

    Constructor for CMBSchemaWriter.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/
CMBSchemaWriter::CMBSchemaWriter(CWriter* i_pcWriter):
m_apCollection(NULL),
m_cCollection(0),
m_iCollection(0),
m_pCWriter(NULL)
{
    //
    // Assumption: i_pcWriter will be valid for the
    // lifetime of the schema writer object.
    //

    m_pCWriter = i_pcWriter;

} // CMBSchemaWriter::CMBSchemaWriter


/***************************************************************************++
Routine Description:

    Destructor for CMBSchemaWriter.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/
CMBSchemaWriter::~CMBSchemaWriter()
{
    if(NULL != m_apCollection)
    {
        for(ULONG i=0; i<m_iCollection; i++)
        {
            if(NULL != m_apCollection[i])
            {
                delete m_apCollection[i];
                m_apCollection[i] = NULL;
            }
        }

        delete [] m_apCollection;
        m_apCollection = NULL;
    }

    m_cCollection = 0;
    m_iCollection = 0;

} // CMBSchemaWriter::~CMBSchemaWriter


/***************************************************************************++
Routine Description:

    Creates a new collection writer and saves it in its list

Arguments:

    [in]  Collection name.
    [in]  Bool to indicate container
    [in]  Container list, if container
    [out] New collection writer object

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBSchemaWriter::GetCollectionWriter(LPCWSTR                i_wszCollection,
                                             BOOL                   i_bContainer,
                                             LPCWSTR                i_wszContainerClassList,
                                             CMBCollectionWriter**  o_pMBCollectionWriter)
{
    CMBCollectionWriter*    pCMBCollectionWriter = NULL;
    HRESULT                 hr                   = S_OK;

    *o_pMBCollectionWriter = NULL;

    if(m_iCollection == m_cCollection)
    {
        hr = ReAllocate();

        if(FAILED(hr))
        {
            return hr;
        }
    }

    pCMBCollectionWriter = new CMBCollectionWriter();
    if(NULL == pCMBCollectionWriter)
    {
        return E_OUTOFMEMORY;
    }

    pCMBCollectionWriter->Initialize(i_wszCollection,
                                     i_bContainer,
                                     i_wszContainerClassList,
                                     m_pCWriter);

    m_apCollection[m_iCollection++] = pCMBCollectionWriter;

    *o_pMBCollectionWriter = pCMBCollectionWriter;

    return S_OK;

} // CMBSchemaWriter::GetCollectionWriter


/***************************************************************************++
Routine Description:

    ReAllocates its list of collection writers.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBSchemaWriter::ReAllocate()
{
    CMBCollectionWriter** pSav = NULL;

    pSav = new LP_CMBCollectionWriter[m_cCollection + MAX_COLLECTIONS];
    if(NULL == pSav)
    {
        return E_OUTOFMEMORY;
    }
    memset(pSav, 0, (sizeof(LP_CMBCollectionWriter))*(m_cCollection + MAX_COLLECTIONS));

    if(NULL != m_apCollection)
    {
        memcpy(pSav, m_apCollection, (sizeof(LP_CMBCollectionWriter))*(m_cCollection));
        delete [] m_apCollection;
        m_apCollection = NULL;
    }

    m_apCollection = pSav;
    m_cCollection = m_cCollection + MAX_COLLECTIONS;

    return S_OK;

} // CMBSchemaWriter::ReAllocate


/***************************************************************************++
Routine Description:

    Wites the schema.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBSchemaWriter::WriteSchema()
{
    HRESULT hr = S_OK;

    for(ULONG i=0; i<m_iCollection; i++)
    {
        hr = m_apCollection[i]->WriteCollection();

        if(FAILED(hr))
        {
            return hr;
        }
    }

    return hr;

} // CMBSchemaWriter::WriteSchema
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\shared\xmlwriter\writer.cpp ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    Writer.cpp

Abstract:

    Writer class that is used to wrap the calls to the API WriteFile. It writes
    to a buffer and everytime the buffer gets full, it flushes to the disk.

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/

#include "precomp.hxx"


/***************************************************************************++

Routine Description:

    Initializes global lengths.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT InitializeLengths()
{
    g_cchBeginFile0                 = (ULONG)wcslen(g_wszBeginFile0);
    g_cchBeginFile1                 = (ULONG)wcslen(g_wszBeginFile1);
    g_cchEndFile                    = (ULONG)wcslen(g_wszEndFile);
    g_cchBeginLocation              = (ULONG)wcslen(g_BeginLocation);
    g_cchLocation                   = (ULONG)wcslen(g_Location);
    g_cchEndLocationBegin           = (ULONG)wcslen(g_EndLocationBegin);
    g_cchEndLocationEnd             = (ULONG)wcslen(g_EndLocationEnd);
    g_cchCloseQuoteBraceRtn         = (ULONG)wcslen(g_CloseQuoteBraceRtn);
    g_cchRtn                        = (ULONG)wcslen(g_Rtn);
    g_cchEqQuote                    = (ULONG)wcslen(g_EqQuote);
    g_cchQuoteRtn                   = (ULONG)wcslen(g_QuoteRtn);
    g_cchTwoTabs                    = (ULONG)wcslen(g_TwoTabs);
    g_cchNameEq                     = (ULONG)wcslen(g_NameEq);
    g_cchIDEq                       = (ULONG)wcslen(g_IDEq);
    g_cchValueEq                    = (ULONG)wcslen(g_ValueEq);
    g_cchTypeEq                     = (ULONG)wcslen(g_TypeEq);
    g_cchUserTypeEq                 = (ULONG)wcslen(g_UserTypeEq);
    g_cchAttributesEq               = (ULONG)wcslen(g_AttributesEq);
    g_cchBeginGroup                 = (ULONG)wcslen(g_BeginGroup);
    g_cchEndGroup                   = (ULONG)wcslen(g_EndGroup);
    g_cchBeginCustomProperty        = (ULONG)wcslen(g_BeginCustomProperty);
    g_cchEndCustomProperty          = (ULONG)wcslen(g_EndCustomProperty);
    g_cchZeroHex                    = (ULONG)wcslen(g_ZeroHex);
    g_cchBeginComment               = (ULONG)wcslen(g_BeginComment);
    g_cchEndComment                 = (ULONG)wcslen(g_EndComment);


    BYTE_ORDER_MASK =   0xFEFF;
    UTF8_SIGNATURE = 0x00BFBBEF;

    g_cchUnknownName                = (ULONG)wcslen(g_wszUnknownName);
    g_cchUT_Unknown                 = (ULONG)wcslen(g_UT_Unknown);
    g_cchMaxBoolStr                 = (ULONG)wcslen(g_wszFalse);

    g_cchHistorySlash               = (ULONG)wcslen(g_wszHistorySlash);
    g_cchMinorVersionExt            = (ULONG)wcslen(g_wszMinorVersionExt);
    g_cchDotExtn                    = (ULONG)wcslen(g_wszDotExtn);

    g_cchTrue                       = (ULONG)wcslen(g_wszTrue);
    g_cchFalse                      = (ULONG)wcslen(g_wszFalse);

    g_cchTemp                       = 1024;
    g_cchBeginSchema                = (ULONG)wcslen(g_wszBeginSchema);
    g_cchEndSchema                  = (ULONG)wcslen(g_wszEndSchema);
    g_cchBeginCollection            = (ULONG)wcslen(g_wszBeginCollection);
    g_cchEndBeginCollectionMB       = (ULONG)wcslen(g_wszEndBeginCollectionMB);
    g_cchEndBeginCollectionCatalog  = (ULONG)wcslen(g_wszEndBeginCollectionCatalog);
    g_cchInheritsFrom               = (ULONG)wcslen(g_wszInheritsFrom);
    g_cchEndCollection              = (ULONG)wcslen(g_wszEndCollection);
    g_cchBeginPropertyShort         = (ULONG)wcslen(g_wszBeginPropertyShort);
    g_cchMetaFlagsExEq              = (ULONG)wcslen(g_wszMetaFlagsExEq);
    g_cchEndPropertyShort           = (ULONG)wcslen(g_wszEndPropertyShort);
    g_cchBeginPropertyLong          = (ULONG)wcslen(g_wszBeginPropertyLong);
    g_cchPropIDEq                   = (ULONG)wcslen(g_wszPropIDEq);
    g_cchPropTypeEq                 = (ULONG)wcslen(g_wszPropTypeEq);
    g_cchPropUserTypeEq             = (ULONG)wcslen(g_wszPropUserTypeEq);
    g_cchPropAttributeEq            = (ULONG)wcslen(g_wszPropAttributeEq);

    g_cchPropMetaFlagsEq            = (ULONG)wcslen(g_wszPropMetaFlagsEq);
    g_cchPropMetaFlagsExEq          = (ULONG)wcslen(g_wszPropMetaFlagsExEq);
    g_cchPropDefaultEq              = (ULONG)wcslen(g_wszPropDefaultEq);
    g_cchPropMinValueEq             = (ULONG)wcslen(g_wszPropMinValueEq);
    g_cchPropMaxValueEq             = (ULONG)wcslen(g_wszPropMaxValueEq);
    g_cchEndPropertyLongNoFlag      = (ULONG)wcslen(g_wszEndPropertyLongNoFlag);
    g_cchEndPropertyLongBeforeFlag  = (ULONG)wcslen(g_wszEndPropertyLongBeforeFlag);
    g_cchEndPropertyLongAfterFlag   = (ULONG)wcslen(g_wszEndPropertyLongAfterFlag);
    g_cchBeginFlag                  = (ULONG)wcslen(g_wszBeginFlag);
    g_cchFlagValueEq                = (ULONG)wcslen(g_wszFlagValueEq);
    g_cchEndFlag                    = (ULONG)wcslen(g_wszEndFlag);

    g_cchOr                         = (ULONG)wcslen(g_wszOr);
    g_cchOrManditory                = (ULONG)wcslen(g_wszOrManditory);
    g_cchFlagIDEq                   = (ULONG)wcslen(g_wszFlagIDEq);
    g_cchContainerClassListEq       = (ULONG)wcslen(g_wszContainerClassListEq);

    g_cchSlash                                      = (ULONG)wcslen(g_wszSlash);
    g_cchLM                                         = (ULONG)wcslen(g_wszLM);
    g_cchSchema                                     = (ULONG)wcslen(g_wszSchema);
    g_cchSlashSchema                                = (ULONG)wcslen(g_wszSlashSchema);
    g_cchSlashSchemaSlashProperties                 = (ULONG)wcslen(g_wszSlashSchemaSlashProperties);
    g_cchSlashSchemaSlashPropertiesSlashNames       = (ULONG)wcslen(g_wszSlashSchemaSlashPropertiesSlashNames);
    g_cchSlashSchemaSlashPropertiesSlashTypes       = (ULONG)wcslen(g_wszSlashSchemaSlashPropertiesSlashTypes);
    g_cchSlashSchemaSlashPropertiesSlashDefaults    = (ULONG)wcslen(g_wszSlashSchemaSlashPropertiesSlashDefaults);
    g_cchSlashSchemaSlashClasses                    = (ULONG)wcslen(g_wszSlashSchemaSlashClasses);
    g_cchEmptyMultisz                               = 2;
    g_cchEmptyWsz                                   = 1;
    g_cchComma                                      = (ULONG)wcslen(g_wszComma);
    g_cchMultiszSeperator                           = (ULONG)wcslen(g_wszMultiszSeperator);

    return S_OK;

} // InitializeLengths


/***************************************************************************++

Routine Description:

    Creates the CWriterGlobalHelper object - the object that has all the ISTs
    to the meta tables - and initializess it.

Arguments:

    [in]   Bool indicating if we should fail if the bin file is absent.
           There are some scenarios in which we can tolerate this, and some
           where we dont - hence the distinction.

    [out]  new CWriterGlobalHelper object.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT GetGlobalHelper(BOOL                    i_bFailIfBinFileAbsent,
                        CWriterGlobalHelper**   ppCWriterGlobalHelper)
{
    HRESULT                 hr                      = S_OK;
    static  BOOL            bInitializeLengths      = FALSE;
    CWriterGlobalHelper*    pCWriterGlobalHelper    = NULL;

    *ppCWriterGlobalHelper = NULL;

    if(!bInitializeLengths)
    {
        //
        // Initialize lengths once.
        //

        ::InitializeLengths();
        bInitializeLengths = TRUE;
    }

    if(NULL != *ppCWriterGlobalHelper)
    {
        delete *ppCWriterGlobalHelper;
        *ppCWriterGlobalHelper = NULL;
    }

    pCWriterGlobalHelper = new CWriterGlobalHelper();
    if(NULL == pCWriterGlobalHelper)
    {
        return E_OUTOFMEMORY;
    }

    hr = pCWriterGlobalHelper->InitializeGlobals(i_bFailIfBinFileAbsent);

    if(FAILED(hr))
    {
        delete pCWriterGlobalHelper;
        pCWriterGlobalHelper = NULL;
        return hr;
    }

    *ppCWriterGlobalHelper = pCWriterGlobalHelper;

    return S_OK;

} // GetGlobalHelper


/***************************************************************************++

Routine Description:

    Constructor for CWriter

Arguments:

    None

Return Value:

    None

--***************************************************************************/
CWriter::CWriter()
{
    m_wszFile              = NULL;
    m_hFile                = INVALID_HANDLE_VALUE;
    m_bCreatedFile         = FALSE;
    m_pCWriterGlobalHelper = NULL;
    m_bCreatedGlobalHelper = FALSE;
    m_pISTWrite            = NULL;
    m_cbBufferUsed         = 0;
    m_psidSystem           = NULL;
    m_psidAdmin            = NULL;
    m_paclDiscretionary    = NULL;
    m_psdStorage           = NULL;

} // Constructor  CWriter


/***************************************************************************++

Routine Description:

    Destructor for CWriter

Arguments:

    None

Return Value:

    None

--***************************************************************************/
CWriter::~CWriter()
{
    if(NULL != m_wszFile)
    {
        delete [] m_wszFile;
        m_wszFile = NULL;
    }
    if(m_bCreatedFile &&
       ((INVALID_HANDLE_VALUE != m_hFile) && (NULL != m_hFile))
      )
    {
        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
    }
    else
    {
        m_hFile = INVALID_HANDLE_VALUE;
    }

    FreeSecurityRelatedMembers();

    if(NULL != m_pISTWrite)
    {
        m_pISTWrite->Release();
        m_pISTWrite = NULL;
    }

    if(m_bCreatedGlobalHelper)
    {
        delete m_pCWriterGlobalHelper;
        m_pCWriterGlobalHelper = NULL;

    } // Else Global helper is created externally, no need to delete here

} // Constructor  CWriter


/***************************************************************************++

Routine Description:

    Initialization for CWriter.

Arguments:

    [in]   FileName.
    [in]   Pointer to the CWriterGlobalHelper object that has all the meta
           table information. We assume that this pointer is valid for the
           duration of the writer object being initialized.
    [in]   Filehandle.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriter::Initialize(LPCWSTR              wszFile,
                            CWriterGlobalHelper* i_pCWriterGlobalHelper,
                            HANDLE               hFile)
{

    HRESULT                     hr            = S_OK;
    ISimpleTableDispenser2*     pISTDisp      = NULL;
    IAdvancedTableDispenser*    pISTAdvanced  = NULL;

    //
    // Assert that all members are NULL
    //

    DBG_ASSERT(NULL == m_wszFile);
    DBG_ASSERT((INVALID_HANDLE_VALUE == m_hFile) || (NULL == m_hFile));
    DBG_ASSERT(NULL == m_pCWriterGlobalHelper);
    DBG_ASSERT(NULL == m_pISTWrite);

    //
    // Save file name and handle.
    //

    m_wszFile = new WCHAR[wcslen(wszFile)+1];
    if(NULL == m_wszFile)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    wcscpy(m_wszFile, wszFile);

    m_hFile = hFile;

    //
    // Initialized the used buffer count to zero.
    //

    m_cbBufferUsed = 0;

    //
    // Save the global helper object that has all the ISTs to all the meta
    // tables. Assumption: i_pCWriterGlobalHelper will be valid for the
    // lifetime of the writer object.
    //

    m_pCWriterGlobalHelper = i_pCWriterGlobalHelper;

    if(NULL == m_pCWriterGlobalHelper)
    {
        //
        // If the global helper is not specified, then create one now - This will
        // be the case when the schema compiler calls the writer object to write
        // the schema file.
        // Assumption: GlobalHelper will be NULL only in the case when the writer
        // is called to write the schema file after schema compilation. Hence, the
        // 1st param to GetClobalHelper can be FALSE, since the bin file may not
        // yet exist.
        //

        hr = GetGlobalHelper(FALSE,
                             &m_pCWriterGlobalHelper);

        if(FAILED(hr))
        {
            goto exit;
        }

        m_bCreatedGlobalHelper = TRUE;

    }

    hr = DllGetSimpleObjectByIDEx( eSERVERWIRINGMETA_TableDispenser, IID_ISimpleTableDispenser2, (VOID**)&pISTDisp, WSZ_PRODUCT_IIS );

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = pISTDisp->QueryInterface(IID_IAdvancedTableDispenser, (LPVOID*)&pISTAdvanced);

    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // This IST is used as a cache to save the contents of a location. It
    // used to be local to the location writer object (locationwriter.cpp).
    // But it was moved to the writer object for perf because location
    // writer is created for each location. The cache is cleared for each
    // location by calling TODO
    //

    hr = pISTAdvanced->GetMemoryTable(wszDATABASE_METABASE,
                                      wszTABLE_MBProperty,
                                      0,
                                      NULL,
                                      NULL,
                                      eST_QUERYFORMAT_CELLS,
                                      fST_LOS_READWRITE,
                                      &m_pISTWrite);

    if (FAILED(hr))
    {
        goto exit;
    }

exit:

    if(NULL != pISTAdvanced)
    {
        pISTAdvanced->Release();
        pISTAdvanced = NULL;
    }

    if(NULL != pISTDisp)
    {
        pISTDisp->Release();
        pISTDisp = NULL;
    }

    return hr;

} // CWriter::Initialize


/***************************************************************************++

Routine Description:

    Creates the file.

Arguments:

    [in]   Security attributes.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriter::ConstructFile(PSECURITY_ATTRIBUTES psa)
{
    HRESULT              hr = S_OK;
    PSECURITY_ATTRIBUTES pSecurityAttributes = psa;
    SECURITY_ATTRIBUTES  sa;

    if(NULL == pSecurityAttributes)
    {
        hr = SetSecurityDescriptor();
        if ( FAILED( hr ) )
        {
            return hr;
        }

        if (m_psdStorage != NULL)
        {
            sa.nLength = sizeof(SECURITY_ATTRIBUTES);
            sa.lpSecurityDescriptor = m_psdStorage;
            sa.bInheritHandle = FALSE;
            pSecurityAttributes = &sa;
        }
    }

    m_hFile = CreateFileW(m_wszFile,
                          GENERIC_WRITE,
                          0,
                          pSecurityAttributes,
                          CREATE_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL);

    if(INVALID_HANDLE_VALUE == m_hFile)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    m_bCreatedFile = TRUE;

    return S_OK;

} // CWriter::ConstructFile


/***************************************************************************++

Routine Description:

    Writes the begin tags depending on whats being written (schema or data)

Arguments:

    [in]   Writer type - schema or metabase data.
    [in]   Security attributes.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriter::BeginWrite(eWriter              eType,
                            PSECURITY_ATTRIBUTES pSecurityAttributes)
{
    ULONG   dwBytesWritten = 0;
    HRESULT hr             = S_OK;

    if((NULL == m_hFile) || (INVALID_HANDLE_VALUE == m_hFile))
    {
        hr = ConstructFile(pSecurityAttributes);

        if(FAILED(hr))
        {
            return hr;
        }
    }

    if(!WriteFile(m_hFile,
                  (LPVOID)&UTF8_SIGNATURE,
                  sizeof(BYTE)*3,
                  &dwBytesWritten,
                  NULL))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if(eWriter_Metabase == eType)
    {
        hr = WriteToFile((LPVOID)g_wszBeginFile0,
                           g_cchBeginFile0);
        if(FAILED(hr))
            return hr;

        //Put in the version like 1_0
        // IVANPASH BUG #563172
        // Because of the horrible implementation of _ultow Prefix is complaning about potential buffer overflow
        // in MultiByteToWideChar indirectly called by _ultow. To avoid the warning I am increasing
        // the size to 40 to match _ultow local buffer.
        WCHAR wszVersion[40];
        wszVersion[0] = wszVersion[39] = L'\0';
        _ultow(BaseVersion_MBProperty, wszVersion, 10);
        hr = WriteToFile((LPVOID)wszVersion, (DWORD)wcslen(wszVersion));
        if(FAILED(hr))
            return hr;

        hr = WriteToFile((LPVOID)L"_", (DWORD)wcslen(L"_"));
        if(FAILED(hr))
            return hr;

        _ultow(ExtendedVersion_MBProperty, wszVersion, 10);
        hr = WriteToFile((LPVOID)wszVersion, (DWORD)wcslen(wszVersion));
        if(FAILED(hr))
            return hr;

        return WriteToFile((LPVOID)g_wszBeginFile1,
                           g_cchBeginFile1);
    }
    else if(eWriter_Schema == eType)
    {
        hr = WriteToFile((LPVOID)g_wszBeginSchema,
                         g_cchBeginSchema);
    }

    return hr;

} // CWriter::BeginWrite


/***************************************************************************++

Routine Description:

    Writes the end tags depending on whats being written (schema or data)
    Or if the write is being aborted, and the file has been created by the
    writer, it cleans up the file.

Arguments:

    [in]   Writer type - schema or metabase data or abort

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriter::EndWrite(eWriter eType)
{
    HRESULT hr = S_OK;

    switch(eType)
    {
        case eWriter_Abort:

            //
            // Abort the write and return
            //

            if(m_bCreatedFile &&
               ((INVALID_HANDLE_VALUE != m_hFile) && (NULL != m_hFile))
              )
            {
                //
                // We created the file - delete it.
                //

                CloseHandle(m_hFile);
                m_hFile = INVALID_HANDLE_VALUE;

                if(NULL != m_wszFile)
                {
                    if(!DeleteFileW(m_wszFile))
                    {
                        hr= HRESULT_FROM_WIN32(GetLastError());
                    }
                }
            }
            return hr;
            break;

        case eWriter_Metabase:

            hr = WriteToFile((LPVOID)g_wszEndFile,
                             g_cchEndFile,
                             TRUE);
            break;

        case eWriter_Schema:

            hr = WriteToFile((LPVOID)g_wszEndSchema,
                             g_cchEndSchema,
                             TRUE);
            break;

        default:

            return E_INVALIDARG;
    }

    if(SUCCEEDED(hr))
    {
        if(SetEndOfFile(m_hFile))
        {
            if(!FlushFileBuffers(m_hFile))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;

} // CWriter::EndWrite


/***************************************************************************++

Routine Description:

    Writes the data to the buffer. If the buffer is full, it forces a flush
    to disk. It also forces a flush to disk if it is told to do so.

Arguments:

    [in]   Data
    [in]   Count of bytes to write
    [in]   Bool to indicate force flush or not.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriter::WriteToFile(LPVOID pvData,
                             DWORD  cchData,
                             BOOL   bForceFlush)
{
    HRESULT hr           = S_OK;
    ULONG   cbData       = cchData *sizeof(WCHAR);
    ULONG   cchRemaining = cchData;

    if((m_cbBufferUsed + cbData) > g_cbMaxBuffer)
    {
        ULONG iData = 0;
        //
        // If the data cannot be put in the global buffer, flush the contents
        // of the global buffer to disk.
        //

        hr = FlushBufferToDisk();

        if(FAILED(hr))
        {
            goto exit;
        }

        //
        // m_cbBufferUsed should be zero now. If you still cannot accomodate
        // the data split it up write into buffer.
        //

        while( cbData > g_cbMaxBuffer)
        {

            hr = WriteToFile(&(((LPWSTR)pvData)[iData]),
                             g_cchMaxBuffer,
                             bForceFlush);

            if(FAILED(hr))
            {
                goto exit;
            }

            iData = iData + g_cchMaxBuffer;
            cbData = cbData - g_cbMaxBuffer;
            cchRemaining = cchRemaining - g_cchMaxBuffer;

        }

        hr = WriteToFile(&(((LPWSTR)pvData)[iData]),
                         cchRemaining,
                         bForceFlush);

        if(FAILED(hr))
        {
            goto exit;
        }

    }
    else
    {
        memcpy( (&(m_Buffer[m_cbBufferUsed])), pvData, cbData);
        m_cbBufferUsed = m_cbBufferUsed + cbData;

        if(TRUE == bForceFlush)
        {
            hr = FlushBufferToDisk();

            if(FAILED(hr))
            {
                goto exit;
            }
        }

    }


exit:

    return hr;

} // CWriter::WriteToFile


/***************************************************************************++

Routine Description:

    Converts the data in the buffer (UNICODE) to UTF8 and writes the contents
    to the file.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriter::FlushBufferToDisk()
{
    HRESULT             hr = S_OK;
    DWORD               dwBytesWritten = 0;
    int                 cb = 0;
    int                 cb2;
    BYTE                *pbBuff = m_BufferMultiByte;

    if ( m_cbBufferUsed == 0 )
    {
        goto exit;
    }

    cb = WideCharToMultiByte(CP_UTF8,                       // Convert to UTF8
                             NULL,                          // Must be NULL
                             LPWSTR(m_Buffer),              // Unicode string to convert.
                             m_cbBufferUsed/sizeof(WCHAR),  // cch in string.
                             (LPSTR)pbBuff,                 // buffer for new string
                             g_cbMaxBufferMultiByte,        // size of buffer
                             NULL,
                             NULL);
    if( cb == 0 )
    {
        cb = WideCharToMultiByte(CP_UTF8,                       // Convert to UTF8
                                 NULL,                          // Must be NULL
                                 LPWSTR(m_Buffer),              // Unicode string to convert.
                                 m_cbBufferUsed/sizeof(WCHAR),  // cch in string.
                                 NULL,                          // no buffer for new string
                                 0,                             // 0 for the size of buffer to request calculating the required size
                                 NULL,
                                 NULL);
        DBG_ASSERT( cb != 0 );
        if ( cb == 0 )
        {
            hr = E_FAIL;
            goto exit;
        }

        pbBuff = new BYTE[cb];
        if ( pbBuff == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        cb2 = WideCharToMultiByte(CP_UTF8,                       // Convert to UTF8
                                  NULL,                          // Must be NULL
                                  LPWSTR(m_Buffer),              // Unicode string to convert.
                                  m_cbBufferUsed/sizeof(WCHAR),  // cch in string.
                                  (LPSTR)pbBuff,                 // buffer for new string
                                  cb,                            // size of buffer
                                  NULL,
                                  NULL);
        DBG_ASSERT( cb2 == cb );

        if ( cb2 == 0 )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }
    }

    if(!WriteFile(m_hFile,
                  (LPVOID)pbBuff,
                  cb,
                  &dwBytesWritten,
                  NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    m_cbBufferUsed = 0;

exit:

    if ( ( pbBuff != NULL ) && ( pbBuff != m_BufferMultiByte ) )
    {
        delete [] pbBuff;
        pbBuff = NULL;
    }

    return hr;

} // CWriter::FlushBufferToDisk


/***************************************************************************++

Routine Description:

    Creates a new location writer, initializes it and hands it out.

Arguments:

    [out] Location Writer
    [in]  Location

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriter::GetLocationWriter(CLocationWriter** ppCLocationWriter,
                                   LPCWSTR            wszLocation)
{
    HRESULT hr = S_OK;

    *ppCLocationWriter = new CLocationWriter();
    if(NULL == *ppCLocationWriter)
    {
        return E_OUTOFMEMORY;
    }

    hr = (*ppCLocationWriter)->Initialize((CWriter*)(this),
                                          wszLocation);

    return hr;

} // CWriter::GetLocationWriter


/***************************************************************************++

Routine Description:

    Creates a new metabase schema writer, initializes it and hands it out.
    Metabase schema writer consumes the metabase datastructures to generate
    the schema file. This is used to generate the temporary schema file that
    has extensions, when extensions are detected during savealldata and when
    a compilation neds to be triggered.

Arguments:

    [out] Schema Writer

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriter::GetMetabaseSchemaWriter(CMBSchemaWriter** ppSchemaWriter)
{
    *ppSchemaWriter = new CMBSchemaWriter((CWriter*)(this));
    if(NULL == *ppSchemaWriter)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;

} // CWriter::GetMetabaseSchemaWriter


/***************************************************************************++

Routine Description:

    Creates a new catalog schema writer, initializes it and hands it out.
    Catalog schema writer consumes the catalog datastructures to generate
    the schema file. This is used during schema compile time. This is what
    the schema compile code uses to generate the schema file.

Arguments:

    [out] Schema Writer

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriter::GetCatalogSchemaWriter(CCatalogSchemaWriter** ppSchemaWriter)
{
    *ppSchemaWriter = new CCatalogSchemaWriter((CWriter*)(this));
    if(NULL == *ppSchemaWriter)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
} // CWriter::GetCatalogSchemaWriter


/***************************************************************************++

Routine Description:

    Creates a security descriptor for the file, if one is not specified.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriter::SetSecurityDescriptor()
{

    HRESULT                  hresReturn  = S_OK;
    BOOL                     status;
    DWORD                    dwDaclSize;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;


    m_psdStorage = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);

    if (m_psdStorage == NULL)
    {
        hresReturn = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    //
    // Initialize the security descriptor.
    //

    status = InitializeSecurityDescriptor(
                 m_psdStorage,
                 SECURITY_DESCRIPTOR_REVISION
                 );

    if( !status )
    {
        hresReturn = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    //
    // Create the SIDs for the local system and admin group.
    //

    status = AllocateAndInitializeSid(
                 &ntAuthority,
                 1,
                 SECURITY_LOCAL_SYSTEM_RID,
                 0,
                 0,
                 0,
                 0,
                 0,
                 0,
                 0,
                 &m_psidSystem
                 );

    if( !status )
    {
        hresReturn = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    status=  AllocateAndInitializeSid(
                 &ntAuthority,
                 2,
                 SECURITY_BUILTIN_DOMAIN_RID,
                 DOMAIN_ALIAS_RID_ADMINS,
                 0,
                 0,
                 0,
                 0,
                 0,
                 0,
                 &m_psidAdmin
                 );

    if( !status )
    {
        hresReturn = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    //
    // Create the DACL containing an access-allowed ACE
    // for the local system and admin SIDs.
    //

    dwDaclSize = sizeof(ACL)
                   + sizeof(ACCESS_ALLOWED_ACE)
                   + GetLengthSid(m_psidAdmin)
                   + sizeof(ACCESS_ALLOWED_ACE)
                   + GetLengthSid(m_psidSystem)
                   - sizeof(DWORD);

    m_paclDiscretionary = (PACL)LocalAlloc(LPTR, dwDaclSize );

    if( m_paclDiscretionary == NULL )
    {
        hresReturn = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    status = InitializeAcl(
                 m_paclDiscretionary,
                 dwDaclSize,
                 ACL_REVISION
                 );

    if( !status )
    {
        hresReturn = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    status = AddAccessAllowedAce(
                 m_paclDiscretionary,
                 ACL_REVISION,
                 FILE_ALL_ACCESS,
                 m_psidSystem
                 );

    if( !status ) {
        hresReturn = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    status = AddAccessAllowedAce(
                 m_paclDiscretionary,
                 ACL_REVISION,
                 FILE_ALL_ACCESS,
                 m_psidAdmin
                 );

    if( !status ) {
        hresReturn = HRESULT_FROM_WIN32(GetLastError());
        goto exit;

    }

    //
    // Set the DACL into the security descriptor.
    //

    status = SetSecurityDescriptorDacl(
                 m_psdStorage,
                 TRUE,
                 m_paclDiscretionary,
                 FALSE
                 );

    if( !status ) {
        hresReturn = HRESULT_FROM_WIN32(GetLastError());
        goto exit;

    }

exit:

    if (FAILED(hresReturn))
    {
        FreeSecurityRelatedMembers();
    }

    return hresReturn;

} // CWriter::SetSecurityDescriptor


/***************************************************************************++

Routine Description:

    Frees all the security related member vairables, if needed.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
void CWriter::FreeSecurityRelatedMembers()
{
    if( m_paclDiscretionary != NULL )
    {
        LocalFree( m_paclDiscretionary );
        m_paclDiscretionary = NULL;
    }

    if( m_psidAdmin != NULL )
    {
        FreeSid( m_psidAdmin );
        m_psidAdmin = NULL;

    }

    if( m_psidSystem != NULL )
    {
        FreeSid( m_psidSystem );
        m_psidSystem = NULL;
    }

    if( m_psdStorage != NULL )
    {
        LocalFree( m_psdStorage );
        m_psdStorage = NULL;
    }

    return;

} // CWriter::FreeSecurityRelatedMembers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\shared\xmlwriter\locationwriter.cpp ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    LocationWriter.cpp

Abstract:

    Implementation of the class that writes a node (location)
    in the metabase

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/

#include "precomp.hxx"

#define MB_PROPERTIES_ON_STACK  16
#define SORTARRAYSIZE_ONSTACK   32

typedef struct _MBProperty
{
    LPWSTR wszPropertyName;
    ULONG  iRow;
} MBProperty;

typedef MBProperty* PMBProperty;

int _cdecl MyCompare(const void *a,
                     const void *b)
{
    return wcscmp(((PMBProperty)a)->wszPropertyName, ((PMBProperty)b)->wszPropertyName);
}

/***************************************************************************++

Routine Description:

   Helper function that retuns a metabase type, given a catalog type.

Arguments:

    None

Return Value:

    None

--***************************************************************************/
DWORD GetMetabaseType(DWORD             i_dwType,
                     DWORD         i_dwMetaFlags)
{
        if(i_dwType < INVALID_END_METADATA)
        {
                return i_dwType;  // Already metabase type.
        }

        switch(i_dwType)
        {
                case eCOLUMNMETA_UI4:
                        return DWORD_METADATA;
                case eCOLUMNMETA_BYTES:
                        return BINARY_METADATA;
                case eCOLUMNMETA_WSTR:
                        if(0 != (i_dwMetaFlags & fCOLUMNMETA_MULTISTRING))
                        {
                                return MULTISZ_METADATA;
                        }
                        else if(0 != (i_dwMetaFlags & fCOLUMNMETA_EXPANDSTRING))
                        {
                                return EXPANDSZ_METADATA;
                        }
                        else
                        {
                                return STRING_METADATA;
                        }
                default:
                        DBG_ASSERT(0 && "Invalid Type");
                        break;
        }

        return (DWORD)-1;

}


/***************************************************************************++

Routine Description:

    Constructor for CLocationWriter.

Arguments:

    None

Return Value:

    None

--***************************************************************************/
CLocationWriter::CLocationWriter()
{
    m_wszKeyType           = NULL;
    m_eKeyTypeGroup        = eMBProperty_IIsConfigObject;
    m_pCWriter             = NULL;
    m_pCWriterGlobalHelper = NULL;
    m_wszLocation          = NULL;
    m_wszComment           = NULL;
    m_cWellKnownProperty   = 0;
    m_cCustomProperty      = 0;

} // CLocationWriter::CLocationWriter


/***************************************************************************++

Routine Description:

    Destructor for CLocationWriter.

Arguments:

    None

Return Value:

    None

--***************************************************************************/
CLocationWriter::~CLocationWriter()
{
    if(NULL != m_wszKeyType)
    {
        delete [] m_wszKeyType;
        m_wszKeyType = NULL;
    }

    if(NULL != m_wszLocation)
    {
        delete [] m_wszLocation;
        m_wszLocation = NULL;
    }

    if(NULL != m_wszComment)
    {
        delete [] m_wszComment;
        m_wszComment = NULL;
    }

} // CLocationWriter::CLocationWriter


/***************************************************************************++

Routine Description:

    This function initializes the location writer

Arguments:

    [in] Pointer to the writer object. It is assumed that this pointer is
         valid for the lifetime of the locationwriter object.
    [in] Location

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::Initialize(CWriter* pCWriter,
                                    LPCWSTR  wszLocation)
{
    ISimpleTableAdvanced*       pISTAdv = NULL;
    HRESULT                     hr      = S_OK;

    m_pCWriter = pCWriter;

    //
    //  Clear the cache for this new location.
    //
    hr = m_pCWriter->m_pISTWrite->QueryInterface(IID_ISimpleTableAdvanced, (LPVOID*)&pISTAdv);

    if (FAILED(hr))
    {
        goto exit;
    }

    hr = pISTAdv->ResetCaches();

    if (FAILED(hr))
    {
        goto exit;
    }

    m_wszLocation = new WCHAR[wcslen(wszLocation)+1];

    if(NULL == m_wszLocation)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        wcscpy(m_wszLocation, wszLocation);
    }

    m_pCWriterGlobalHelper = m_pCWriter->m_pCWriterGlobalHelper;

    m_cWellKnownProperty   = 0;
    m_cCustomProperty      = 0;

exit:
    if(NULL != pISTAdv)
    {
        pISTAdv->Release();
        pISTAdv = NULL;
    }

    return hr;

} // CLocationWriter::Initialize


/***************************************************************************++
Routine Description:

    This function initializes the key type and is called during
    IMSAdminBase::Export to initialize the keytype of the exported node when
    there are inherited properties involved.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::InitializeKeyTypeAsInherited()
{
    return AssignKeyType(wszTABLE_IIsInheritedProperties);
}


/***************************************************************************++
Routine Description:

    Given a keytype property from the in-memory metabase, this function
    validates it against the schema and sets the keytype of the location.

Arguments:

    [in] KeyType property ID as seen in the metabase
    [in] KeyType property attributes as seen in the metabase
    [in] KeyType property user type as seen in the metabase
    [in] KeyType property data type as seen in the metabase
    [in] KeyType value as seen in the metabase
    [in] KeyType value count of bytes as seen in the metabase

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::InitializeKeyType(DWORD    ,
                                           DWORD    dwKeyTypeAttributes,
                                           DWORD    dwKeyTypeUserType,
                                           DWORD    dwKeyTypeDataType,
                                           PBYTE    pbKeyTypeValue,
                                           DWORD    )
{
    HRESULT hr = S_OK;

    if(NULL != m_wszKeyType)
    {
        hr = HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
        goto exit;
    }

    if(NULL == pbKeyTypeValue)
    {
        //
        // If KeyType is NULL then assign IIsConfigObject
        //
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto exit;
    }

    if((dwKeyTypeAttributes == *(DWORD*)((m_pCWriterGlobalHelper->m_apvKeyTypeMetaData)[iCOLUMNMETA_Attributes])) &&
            (dwKeyTypeUserType   == *(DWORD*)((m_pCWriterGlobalHelper->m_apvKeyTypeMetaData)[iCOLUMNMETA_UserType])) &&
            (dwKeyTypeDataType   == GetMetabaseType(*(DWORD*)(m_pCWriterGlobalHelper->m_apvKeyTypeMetaData[iCOLUMNMETA_Type]),
                                                    *(DWORD*)(m_pCWriterGlobalHelper->m_apvKeyTypeMetaData[iCOLUMNMETA_MetaFlags])
                                                   )
            )
           )
    {
        hr = AssignKeyType((LPWSTR)pbKeyTypeValue);

        if(FAILED(hr))
        {
            goto exit;
        }

    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto exit;
    }

exit:

    if(FAILED(hr))
    {
        //
        // TODO: Log error that KeyType could  not be initialized,
        //       and default  it to IIsConfigObject.
        //

        hr = AssignKeyType(NULL);

    }

    return hr;

} // CLocationWriter::InitializeKeyType


/***************************************************************************++
Routine Description:

    Helper function that helps in initializing the keytype

Arguments:

    [in] KeyType string

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::AssignKeyType(LPWSTR i_wszKeyType)
{
    HRESULT           hr         = S_OK;
    eMBProperty_Group eGroup;
    LPWSTR            wszKeyType = NULL;

    if(NULL != m_wszKeyType)
    {
        delete [] m_wszKeyType;
        m_wszKeyType = NULL;
    }

    if(NULL == i_wszKeyType)
    {
        wszKeyType = wszTABLE_IIsConfigObject;
        m_eKeyTypeGroup = eMBProperty_IIsConfigObject;
    }
    else
    {
        hr = GetGroupEnum(i_wszKeyType,
                          &eGroup,
                          &wszKeyType);

        if(FAILED(hr))
        {
            return hr;
        }

        if(eMBProperty_Custom == eGroup)
        {
            wszKeyType = wszTABLE_IIsConfigObject;
            m_eKeyTypeGroup = eMBProperty_IIsConfigObject;
        }
        else
        {
            m_eKeyTypeGroup = eGroup;
        }
    }

    m_wszKeyType = new WCHAR [wcslen(wszKeyType)+1];
    if(NULL == m_wszKeyType)
    {
        return E_OUTOFMEMORY;
    }
    wcscpy(m_wszKeyType, wszKeyType);

    return hr;

} // CLocationWriter::AssignKeyType


/***************************************************************************++
Routine Description:

    This function saves a property belonging to this location, and is used
    while writing from the in-memory metabase.

Arguments:

    [in] Property ID as seen in the metabase
    [in] Property attributes as seen in the metabase
    [in] Property user type as seen in the metabase
    [in] Property data type as seen in the metabase
    [in] Property value as seen in the metabase
    [in] Property value count of bytes as seen in the metabase

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::AddProperty(DWORD  dwID,
                                     DWORD  dwAttributes,
                                     DWORD  dwUserType,
                                     DWORD  dwDataType,
                                     PBYTE  pbData,
                                     DWORD  cbData)
{
    HRESULT             hr                = S_OK;
    ULONG               iStartRow         = 0;
    ULONG               aColSearchGroup[] = {iCOLUMNMETA_Table,
                                             iCOLUMNMETA_ID
                                            };
    ULONG               cColSearchGroup   = sizeof(aColSearchGroup)/sizeof(ULONG);
    LPVOID apvSearchGroup[cCOLUMNMETA_NumberOfColumns];
    apvSearchGroup[iCOLUMNMETA_Table]     = (LPVOID)m_wszKeyType;
    apvSearchGroup[iCOLUMNMETA_ID]        = (LPVOID)&dwID;
    ULONG               iRow              = 0;
    LPWSTR              wszName           = NULL;
    BOOL                bAllocedName      = FALSE;
    eMBProperty_Group   eGroup;
    ULONG               aColWrite[]       = {iMBProperty_Name,
                                             iMBProperty_Type,
                                             iMBProperty_Attributes,
                                             iMBProperty_Value,
                                             iMBProperty_Group,
                                             iMBProperty_ID,
                                             iMBProperty_UserType,
                                            };
    ULONG               cColWrite         = sizeof(aColWrite)/sizeof(ULONG);
    ULONG               acbSizeWrite[cMBProperty_NumberOfColumns];
    LPVOID              apvWrite[cMBProperty_NumberOfColumns];
    DWORD               iWriteRow         = 0;


    if((NULL == m_wszKeyType) || (NULL == m_pCWriter->m_pISTWrite))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto exit;
    }

    if((MD_KEY_TYPE == dwID) &&
       (m_eKeyTypeGroup != eMBProperty_IIsConfigObject)
      )
    {
        hr = S_OK; // Do not add KeyType, if it is a well-known KeyType.
        goto exit;
    }

    if(MD_COMMENTS == dwID)
    {
        hr = SaveComment(dwDataType,
                        (WCHAR*)pbData); // Save comment and exit
        goto exit;
    }

    //
    // Fetch the Name for this ID
    //

    hr = m_pCWriterGlobalHelper->GetPropertyName(dwID,
                                                 &wszName,
                                                 &bAllocedName);

    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // Compute the group for this ID.
    //

    if(eMBProperty_IIsConfigObject == m_eKeyTypeGroup)
    {
        //
        // If the KeyType is IIsConfigObject, then directly assign custom group for this ID.
        //

        eGroup = eMBProperty_Custom;

    }
    else
    {
        //
        //  Check if this ID belogs to its KeyType collection.
        //

        hr = (m_pCWriterGlobalHelper->m_pISTColumnMetaByTableAndID)->GetRowIndexBySearch(iStartRow,
                                                                                         cColSearchGroup,
                                                                                         aColSearchGroup,
                                                                                         NULL,
                                                                                         apvSearchGroup,
                                                                                         &iRow);

        if(E_ST_NOMOREROWS == hr)
        {
            eGroup = eMBProperty_Custom ;
        }
        else if(FAILED(hr))
        {
            goto exit;
        }
        else
        {
            //
            // Match the type, usertype, and attributes of this property.
            // Assign to KeyType group only if they match. Else assign
            // to custom.
            //
            ULONG aColMetaInfo[] = {iCOLUMNMETA_Type,
                                    iCOLUMNMETA_MetaFlags,
                                    iCOLUMNMETA_UserType,
                                    iCOLUMNMETA_Attributes
                                   };

            ULONG cColMetaInfo = sizeof(aColMetaInfo)/sizeof(ULONG);
            LPVOID apvMetaInfo[cCOLUMNMETA_NumberOfColumns];

            hr = (m_pCWriterGlobalHelper->m_pISTColumnMetaByTableAndID)->GetColumnValues(iRow,
                                                                                 cColMetaInfo,
                                                                                 aColMetaInfo,
                                                                                 NULL,
                                                                                 apvMetaInfo);
            if(FAILED(hr))
                goto exit;

            if((dwUserType == *(DWORD*)apvMetaInfo[iCOLUMNMETA_UserType]) &&
               (dwAttributes == *(DWORD*)apvMetaInfo[iCOLUMNMETA_Attributes]) &&
               (dwDataType == GetMetabaseType(*(DWORD*)apvMetaInfo[iCOLUMNMETA_Type],
                                          *(DWORD*)apvMetaInfo[iCOLUMNMETA_MetaFlags])
               )
              )
            {
                eGroup = m_eKeyTypeGroup;
            }
            else
                eGroup = eMBProperty_Custom;

        }
    }

    //
    // Save the property to the table.
    //

    if(0 == cbData)
        pbData = NULL;  // Sometimes, config was setting pbData, while cbData was 0. Assuming pbData is NULL when cbData is 0.

    apvWrite[iMBProperty_Name]       = (LPVOID)wszName;
    apvWrite[iMBProperty_Type]       = (LPVOID)&dwDataType;
    apvWrite[iMBProperty_Attributes] = (LPVOID)&dwAttributes;
    apvWrite[iMBProperty_Value]      = (LPVOID)pbData;
    apvWrite[iMBProperty_Group]      = (LPVOID)&eGroup;
    apvWrite[iMBProperty_Location]   = (LPVOID)NULL;
    apvWrite[iMBProperty_ID]         = (LPVOID)&dwID;
    apvWrite[iMBProperty_UserType]   = (LPVOID)&dwUserType;
    apvWrite[iMBProperty_LocationID] = (LPVOID)NULL;

    acbSizeWrite[iMBProperty_Name]       = 0;
    acbSizeWrite[iMBProperty_Type]       = 0;
    acbSizeWrite[iMBProperty_Attributes] = 0;
    acbSizeWrite[iMBProperty_Value]      = cbData;
    acbSizeWrite[iMBProperty_Group]      = 0;
    acbSizeWrite[iMBProperty_Location]   = 0;
    acbSizeWrite[iMBProperty_ID]         = 0;
    acbSizeWrite[iMBProperty_UserType]   = 0;
    acbSizeWrite[iMBProperty_LocationID] = 0;

    hr = m_pCWriter->m_pISTWrite->AddRowForInsert(&iWriteRow);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->m_pISTWrite->SetWriteColumnValues(iWriteRow,
                                           cColWrite,
                                           aColWrite,
                                           acbSizeWrite,
                                           apvWrite);

    if(FAILED(hr))
    {
        goto exit;
    }

    IncrementGroupCount(*((DWORD*)apvWrite[iMBProperty_Group]));

exit:

    if(bAllocedName && (NULL != wszName))
    {
        delete [] wszName;
        wszName = NULL;
    }

    return hr;

} // CLocationWriter::AddProperty


/***************************************************************************++
Routine Description:

    This function saves a property belonging to this location, and is used
    while applying edit while running changes to the history file.

Arguments:

    [in] Bool -  identifies the format of the next to buffers - if true, it
         is according to MBProperty table else MBPropertyDiff table.
    [in] Buffer containing property value and attributes.
    [in] Count of bytes for data in the buffer

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::AddProperty(BOOL       bMBPropertyTable,
                                     LPVOID*    a_pv,
                                     ULONG*     a_cbSize)
{
    HRESULT hr             = S_OK;
    ULONG   iRow           = 0;
    ULONG   cCol           = cMBProperty_NumberOfColumns;
    LPWSTR  wszName        = NULL;
    BOOL    bAllocedName   = FALSE;

    ULONG   a_cbSizeAdd[cMBProperty_NumberOfColumns];
    LPVOID  a_pvAdd[cMBProperty_NumberOfColumns];

    if(!bMBPropertyTable)
    {
        a_pvAdd[iMBProperty_Name]             = a_pv[iMBPropertyDiff_Name];
        a_pvAdd[iMBProperty_Type]             = a_pv[iMBPropertyDiff_Type];
        a_pvAdd[iMBProperty_Attributes]       = a_pv[iMBPropertyDiff_Attributes];
        a_pvAdd[iMBProperty_Value]            = a_pv[iMBPropertyDiff_Value];
        a_pvAdd[iMBProperty_Location]         = a_pv[iMBPropertyDiff_Location];
        a_pvAdd[iMBProperty_ID]               = a_pv[iMBPropertyDiff_ID];
        a_pvAdd[iMBProperty_UserType]         = a_pv[iMBPropertyDiff_UserType];
        a_pvAdd[iMBProperty_LocationID]       = a_pv[iMBPropertyDiff_LocationID];
        a_pvAdd[iMBProperty_Group]            = a_pv[iMBPropertyDiff_Group];

        a_cbSizeAdd[iMBProperty_Name]         = a_cbSize[iMBPropertyDiff_Name];
        a_cbSizeAdd[iMBProperty_Type]         = a_cbSize[iMBPropertyDiff_Type];
        a_cbSizeAdd[iMBProperty_Attributes]   = a_cbSize[iMBPropertyDiff_Attributes];
        a_cbSizeAdd[iMBProperty_Value]        = a_cbSize[iMBPropertyDiff_Value];
        a_cbSizeAdd[iMBProperty_Location]     = a_cbSize[iMBPropertyDiff_Location];
        a_cbSizeAdd[iMBProperty_ID]           = a_cbSize[iMBPropertyDiff_ID];
        a_cbSizeAdd[iMBProperty_UserType]     = a_cbSize[iMBPropertyDiff_UserType];
        a_cbSizeAdd[iMBProperty_LocationID]   = a_cbSize[iMBPropertyDiff_LocationID];
        a_cbSizeAdd[iMBProperty_Group]        = a_cbSize[iMBPropertyDiff_Group];

    }
    else
    {
        a_pvAdd[iMBProperty_Name]             = a_pv[iMBProperty_Name];
        a_pvAdd[iMBProperty_Type]             = a_pv[iMBProperty_Type];
        a_pvAdd[iMBProperty_Attributes]       = a_pv[iMBProperty_Attributes];
        a_pvAdd[iMBProperty_Value]            = a_pv[iMBProperty_Value];
        a_pvAdd[iMBProperty_Location]         = a_pv[iMBProperty_Location];
        a_pvAdd[iMBProperty_ID]               = a_pv[iMBProperty_ID];
        a_pvAdd[iMBProperty_UserType]         = a_pv[iMBProperty_UserType];
        a_pvAdd[iMBProperty_LocationID]       = a_pv[iMBProperty_LocationID];
        a_pvAdd[iMBProperty_Group]            = a_pv[iMBProperty_Group];

        a_cbSizeAdd[iMBProperty_Name]         = a_cbSize[iMBProperty_Name];
        a_cbSizeAdd[iMBProperty_Type]         = a_cbSize[iMBProperty_Type];
        a_cbSizeAdd[iMBProperty_Attributes]   = a_cbSize[iMBProperty_Attributes];
        a_cbSizeAdd[iMBProperty_Value]        = a_cbSize[iMBProperty_Value];
        a_cbSizeAdd[iMBProperty_Location]     = a_cbSize[iMBProperty_Location];
        a_cbSizeAdd[iMBProperty_ID]           = a_cbSize[iMBProperty_ID];
        a_cbSizeAdd[iMBProperty_UserType]     = a_cbSize[iMBProperty_UserType];
        a_cbSizeAdd[iMBProperty_LocationID]   = a_cbSize[iMBProperty_LocationID];
        a_cbSizeAdd[iMBProperty_Group]        = a_cbSize[iMBProperty_Group];

    }

    //
    // Check if non-primary keys have valid values, if not error
    //

    if((NULL == a_pvAdd[iMBProperty_Type])       ||
       (NULL == a_pvAdd[iMBProperty_Attributes]) ||
       (NULL == a_pvAdd[iMBProperty_ID])         ||
       (NULL == a_pvAdd[iMBProperty_UserType])   ||
       (NULL == a_pvAdd[iMBProperty_Group])
      )
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto exit;
    }

    if(MD_COMMENTS == *(DWORD*)a_pvAdd[iMBProperty_ID])
    {
        hr = SaveComment(*(DWORD*)a_pvAdd[iMBProperty_Type],
                        (WCHAR*)a_pvAdd[iMBProperty_Value]);
        goto exit;
    }

    if((NULL == a_pvAdd[iMBProperty_Name]) || (0 == *(LPWSTR)(a_pvAdd[iMBProperty_Name])))
    {
        //
        // Fetch the Name for this ID
        //

        hr = m_pCWriterGlobalHelper->GetPropertyName(*(DWORD*)(a_pvAdd[iMBProperty_ID]),
                                                     &wszName,
                                                     &bAllocedName);

        a_pvAdd[iMBProperty_Name] = wszName;

    }

    if(MD_KEY_TYPE == *(DWORD*)a_pvAdd[iMBProperty_ID])
    {
        //
        // Initialize the KeyType, only if it is not custom.
        // Note that the case will be correct for valid keytypes because if
        // someone has typed the keytype with the wrong case then the element
        // itself would be ignored during read and will not show up in the
        // table.
        //

        if((eMBProperty_Custom != (*(DWORD*)a_pvAdd[iMBProperty_Group])) &&
           (eMBProperty_IIsConfigObject != (*(DWORD*)a_pvAdd[iMBProperty_Group]))
          )
        {
            hr = AssignKeyType((LPWSTR)a_pvAdd[iMBProperty_Value]);
            goto exit;
        }
    }

    hr = m_pCWriter->m_pISTWrite->AddRowForInsert(&iRow);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->m_pISTWrite->SetWriteColumnValues(iRow,
                                                       cCol,
                                                       NULL,
                                                       a_cbSizeAdd,
                                                       a_pvAdd);

    if(FAILED(hr))
    {
        goto exit;
    }

    IncrementGroupCount(*((DWORD*)a_pvAdd[iMBProperty_Group]));

exit:

    if(bAllocedName && (NULL != wszName))
    {
        delete [] wszName;
        wszName = NULL;
    }

    return hr;

}


/***************************************************************************++
Routine Description:

    This function is saves the comment property.

Arguments:

    [in] data type
    [in] comment

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::SaveComment(DWORD  i_dwDataType,
                                     LPWSTR i_wszComment)
{
    HRESULT hr = S_OK;

    if(STRING_METADATA == i_dwDataType)
    {
        if((NULL  != i_wszComment) &&
           (L'\0' != *i_wszComment)
          )
        {
            ULONG cchComment = (ULONG)wcslen(i_wszComment);
            m_wszComment = new WCHAR[cchComment+1];

            if(NULL == m_wszComment)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                wcscpy(m_wszComment, i_wszComment);
            }
        }
    }

    return hr;

} // CLocationWriter::SaveComment


/***************************************************************************++
Routine Description:

    Given a string representation of the keytype (also called as group in the
    MBProperty table) this function returns the corresponginf group enum in
    the MBProperty table.

Arguments:

    [in]  KeyType string
    [out] group enum
    [out] group string as seen by the meta

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::GetGroupEnum(LPWSTR             wszGroup,
                                      eMBProperty_Group* peGroup,
                                      LPWSTR*            pwszGroup)
{
    ULONG   iReadRow                             = 0;
    HRESULT hr                                   = S_OK;
    ULONG   aColSearch[]                         = {iTAGMETA_Table,
                                                    iTAGMETA_ColumnIndex,
                                                    iTAGMETA_InternalName};
    ULONG   cColSearch                           = sizeof(aColSearch)/sizeof(ULONG);
    ULONG   a_iCol[]                             = {iTAGMETA_Value,
                                                    iTAGMETA_InternalName};
    ULONG   cCol                                 = sizeof(a_iCol)/sizeof(ULONG);
    LPVOID  a_pv[cTAGMETA_NumberOfColumns];

    ULONG   iCol                                 = iMBProperty_Group;
    LPVOID  apvSearch[cTAGMETA_NumberOfColumns];
    apvSearch[iTAGMETA_Table]                    = (LPVOID)m_pCWriterGlobalHelper->m_wszTABLE_MBProperty;
    apvSearch[iTAGMETA_ColumnIndex]              = (LPVOID)&iCol;
    apvSearch[iTAGMETA_InternalName]             = (LPVOID)wszGroup;
    ULONG   iStartRow                            = 0;

    hr = (m_pCWriterGlobalHelper->m_pISTTagMetaByTableAndColumnIndexAndName)->GetRowIndexBySearch(iStartRow,
                                                                                                  cColSearch,
                                                                                                  aColSearch,
                                                                                                  NULL,
                                                                                                  apvSearch,
                                                                                                  &iReadRow);
    if(E_ST_NOMOREROWS == hr)
    {
        //
        // Value does not match any known group. Return Custom
        //
        *peGroup = eMBProperty_Custom;
        hr = S_OK;
        goto exit;
    }
    else if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"\nGetRowIndexBySearch failed with hr = 0x%x\n",hr));
        goto exit;
    }

    hr = (m_pCWriterGlobalHelper->m_pISTTagMetaByTableAndColumnIndexAndName)->GetColumnValues (iReadRow,
                                                                                               cCol,
                                                                                               a_iCol,
                                                                                               NULL,
                                                                                               (LPVOID*)a_pv);

    if(E_ST_NOMOREROWS == hr)
    {
        //
        // Value does not match any known group. Return Custom
        //
        *peGroup = eMBProperty_Custom;
        hr = S_OK;
        goto exit;
    }
    else if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"\nGetColumnValues failed with hr = 0x%x\n",hr));
        goto exit;
    }
    else
    {
        *peGroup = (eMBProperty_Group)(*(DWORD*)a_pv[iTAGMETA_Value]);
        *pwszGroup = (LPWSTR) a_pv[iTAGMETA_InternalName];
    }

exit:

    return hr;

} // CLocationWriter::GetGroupEnum


/***************************************************************************++
Routine Description:

    This function writes the location and its properties that have been
    added to it.

    Eg: <IIsWebService  Location ="/LM/W3SVC"
                        AccessFlags="AccessExecute | AccessRead"
                        AnonymousUserName="IUSR_ANILR-STRESS"
                        AnonymousUserPass="496344627000000022000000400000001293a44feb796fdb8b9946a130e4d1292f3f402b02a178747135bf774f3af7f788ad000000000000c8e578cb0f27e78f3823ee341098ef4dda5d44c0121ae53d2959ffb198380af80f15af29e2c865b2473931e1a5e768a1752166062555bd1df951ab71fb67239d"
                    >
                    <Custom
                        Name="AdminServer"
                        ID="2115"
                        Value="2"
                        Type="STRING"
                        UserType="IIS_MD_UT_SERVER"
                        Attributes="INHERIT"
                    />
        </IIsWebService>

    Eg: <IIsConfigObject    Location ="/LM/W3SVC/1/Root/localstart.asp"
                    >
                    <Custom
                        Name="AuthFlags"
                        ID="6000"
                        Value="AuthBasic | AuthNTLM"
                        Type="DWORD"
                        UserType="IIS_MD_UT_FILE"
                        Attributes="INHERIT"
                    />
        </IIsConfigObject>

Arguments:

    [in]  Bool - sort location or not.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::WriteLocation(BOOL bSort)
{

    HRESULT hr                        = S_OK;
    ULONG   aiRowSorted_OnStack[SORTARRAYSIZE_ONSTACK];
    ULONG*  aiRowSorted               = NULL;
    ULONG   i                         = 0;
    DWORD   bFirstCustomPropertyFound = FALSE;

    //
    // KeyType has to be initialized, if not initialize it
    //

    if(NULL == m_wszKeyType)
    {
        hr = AssignKeyType(NULL);

        if(FAILED(hr))
        {
            goto exit;
        }
    }

    if(bSort)
    {

        if (m_cCustomProperty + m_cWellKnownProperty > SORTARRAYSIZE_ONSTACK)
        {
            aiRowSorted = new ULONG [m_cCustomProperty + m_cWellKnownProperty];
            if(NULL == aiRowSorted)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
        }
        else
        {
            aiRowSorted = aiRowSorted_OnStack;
        }

        hr = Sort(aiRowSorted);

        if(FAILED(hr))
        {
            goto exit;
        }

    }

    if(NULL != m_wszComment)
    {
        hr = WriteComment();

        if(FAILED(hr))
        {
            goto exit;
        }
    }

    hr = WriteBeginLocation(m_wszLocation);

    if(FAILED(hr))
    {
        goto exit;
    }

    for(i=0; ;i++)
    {

        ULONG   iRow = 0;
        ULONG   cCol = cMBProperty_NumberOfColumns;
        ULONG   a_cbSize[cMBProperty_NumberOfColumns];
        LPVOID  a_pv[cMBProperty_NumberOfColumns];

        if(bSort && (NULL != aiRowSorted))
        {
            if(m_cCustomProperty + m_cWellKnownProperty == i)
            {
                break;
            }

            iRow =  aiRowSorted[i];
        }
        else
        {
            iRow = i;
        }

        hr = m_pCWriter->m_pISTWrite->GetWriteColumnValues(iRow,
                                               cCol,
                                               NULL,
                                               NULL,
                                               a_cbSize,
                                               a_pv);

        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;
            break;
        }
        else if(FAILED(hr))
        {
            goto exit;
        }

        //
        // Ignore the location with no property property.
        //

        if((*(DWORD*)a_pv[iMBProperty_ID] == MD_LOCATION) && (*(LPWSTR)a_pv[iMBProperty_Name] == L'#'))
        {
            continue;
        }

        if(!bFirstCustomPropertyFound)
        {
            if((eMBProperty_Custom == *(DWORD*)(a_pv[iMBProperty_Group])) ||
               (eMBProperty_IIsConfigObject == *(DWORD*)(a_pv[iMBProperty_Group]))
              )
            {
                hr = WriteEndWellKnownGroup();

                if(FAILED(hr))
                {
                    goto exit;
                }

                bFirstCustomPropertyFound = TRUE;

            }
        }

        if((eMBProperty_Custom == *(DWORD*)(a_pv[iMBProperty_Group])) ||
           (eMBProperty_IIsConfigObject == *(DWORD*)(a_pv[iMBProperty_Group]))
          )
        {
            hr = WriteCustomProperty(a_pv,
                                     a_cbSize);
        }
        else
        {
            hr = WriteWellKnownProperty(a_pv,
                                        a_cbSize);
        }

        if(FAILED(hr))
        {
            goto exit;
        }


    }

    if(!bFirstCustomPropertyFound)
    {
        hr = WriteEndWellKnownGroup();

        if(FAILED(hr))
        {
            goto exit;
        }
    }

    hr = WriteEndLocation();

    if(FAILED(hr))
    {
        goto exit;
    }

exit:

    if(NULL != aiRowSorted && aiRowSorted_OnStack != aiRowSorted)
    {
        delete [] aiRowSorted;
        aiRowSorted = NULL;
    }

    return hr;

} // CLocationWriter::WriteLocation


/***************************************************************************++
Routine Description:

    This function reurn a sorted array of indicies of the cache containing
    properties. The sort is based on property name.
    Note - the number of wellknowns vs custom properties are counted in
    AddProperty.The caller provides a buffer which is at least as big as
    m_cCustomProperty + m_cWellknownProperty

Arguments:

    [in]  Bool - sort location or not.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::Sort(ULONG*  aiRowSorted)
{

    HRESULT     hr                 = S_OK;
    ULONG       iCustom            = 0;
    ULONG       iWellKnown         = 0;
    ULONG       iRow               = 0;
    ULONG       i                  = 0;
    MBProperty  aWellKnownPropertyOnStack[MB_PROPERTIES_ON_STACK];
    MBProperty  aCustomPropertyOnStack[MB_PROPERTIES_ON_STACK];
    MBProperty* aWellKnownProperty = NULL;
    MBProperty* aCustomProperty    = NULL;

    //
    // Allocate arrays to hold Cusom property / Well known property.
    //

    if(m_cCustomProperty > 0)
    {
        if (m_cCustomProperty > MB_PROPERTIES_ON_STACK)
        {
            aCustomProperty = new MBProperty[m_cCustomProperty];
            if(NULL == aCustomProperty)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
        }
        else
        {
            aCustomProperty = aCustomPropertyOnStack;
        }
    }

    if(m_cWellKnownProperty > 0)
    {
        if(m_cWellKnownProperty > MB_PROPERTIES_ON_STACK)
        {
            aWellKnownProperty = new MBProperty[m_cWellKnownProperty];
            if(NULL == aWellKnownProperty)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
        }
        else
        {
            aWellKnownProperty = aWellKnownPropertyOnStack;
        }
    }

    //
    // Populate the arrays
    //

    for(iRow=0;;iRow++)
    {
        ULONG  aCol[] = {iMBProperty_Group,
                         iMBProperty_Name
                        };
        ULONG  cCol = sizeof(aCol)/sizeof(ULONG);
        LPVOID apv[cMBProperty_NumberOfColumns];

        hr = m_pCWriter->m_pISTWrite->GetWriteColumnValues(iRow,
                                               cCol,
                                               aCol,
                                               NULL,
                                               NULL,
                                               apv);

        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;
            break;
        }
        else if(FAILED(hr))
        {
            goto exit;
        }

        if((eMBProperty_Custom == *(DWORD*)(apv[iMBProperty_Group])) ||
           (eMBProperty_IIsConfigObject == *(DWORD*)(apv[iMBProperty_Group]))
          )
        {
            DBG_ASSERT((aCustomProperty != NULL) && (iCustom < m_cCustomProperty));
            aCustomProperty[iCustom].iRow = iRow;
            aCustomProperty[iCustom++].wszPropertyName = (LPWSTR)apv[iMBProperty_Name];
        }
        else
        {
            DBG_ASSERT((aWellKnownProperty != NULL) && (iWellKnown < m_cWellKnownProperty));
            aWellKnownProperty[iWellKnown].iRow = iRow;
            aWellKnownProperty[iWellKnown++].wszPropertyName = (LPWSTR)apv[iMBProperty_Name];
        }

    }


    //
    // Sort the individual arrays.
    //

    if(m_cCustomProperty > 0)
    {
        DBG_ASSERT(aCustomProperty != NULL);
        qsort((void*)aCustomProperty, m_cCustomProperty, sizeof(MBProperty), MyCompare);
    }
    if(m_cWellKnownProperty > 0)
    {
        DBG_ASSERT(aWellKnownProperty != NULL);
        qsort((void*)aWellKnownProperty, m_cWellKnownProperty, sizeof(MBProperty), MyCompare);
    }

    //
    // Create the new array of indicies. First add well known, then custom
    //

    DBG_ASSERT(aiRowSorted != NULL);

    for(i=0, iRow=0; iRow<m_cWellKnownProperty; iRow++, i++)
    {
        aiRowSorted[i] = (aWellKnownProperty[iRow]).iRow;
    }

    for(iRow=0; iRow<m_cCustomProperty; iRow++, i++)
    {
        aiRowSorted[i] = (aCustomProperty[iRow]).iRow;
    }

exit:

    if(NULL != aCustomProperty && aCustomPropertyOnStack != aCustomProperty)
    {
        delete [] aCustomProperty;
        aCustomProperty = NULL;
    }
    if(NULL != aWellKnownProperty && aWellKnownPropertyOnStack != aWellKnownProperty)
    {
        delete [] aWellKnownProperty;
        aWellKnownProperty = NULL;
    }

    return hr;

} // CLocationWriter::Sort


/***************************************************************************++
Routine Description:

    This writes comments at the beginning of a location.

    Eg: <!-- Add the user defined comments here. -->

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::WriteComment()
{

    HRESULT hr                = S_OK;
    LPWSTR  wszEscapedComment = NULL;
    ULONG   cchEscapedComment = 0;
    BOOL    bEscapedComment   = FALSE;

    hr = m_pCWriter->WriteToFile((LPVOID)g_BeginComment,
                                 g_cchBeginComment);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriterGlobalHelper->EscapeString(m_wszComment,
                                              (ULONG)wcslen(m_wszComment),
                                              &bEscapedComment,
                                              &wszEscapedComment,
                                              &cchEscapedComment);


    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)wszEscapedComment,
                                 cchEscapedComment);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_EndComment,
                                 g_cchEndComment);

    if(FAILED(hr))
    {
        goto exit;
    }

exit:

    if(bEscapedComment && (NULL != wszEscapedComment))
    {
        delete [] wszEscapedComment;
        wszEscapedComment = NULL;
    }

    return hr;


} // CLocationWriter::WriteComment


/***************************************************************************++
Routine Description:

    This writes the beginning tag of a location.

    Eg: <IIsWebServer Location="/LM/W3SVC"
    or: <IIsConfigObject Location="/LM/W3SVC/Foo"

Arguments:

    [in]  Location

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::WriteBeginLocation(LPCWSTR  wszLocation)
{
    HRESULT hr                 = S_OK;
    DWORD   cchLocation        = (DWORD)wcslen(wszLocation);
    DWORD   iLastChar          = cchLocation-1;
    BOOL    bEscapedLocation   = FALSE;
    LPWSTR  wszEscapedLocation = NULL;
    ULONG   cchEscapedLocation = 0;

    hr = m_pCWriterGlobalHelper->EscapeString(wszLocation,
                                              cchLocation,
                                              &bEscapedLocation,
                                              &wszEscapedLocation,
                                              &cchEscapedLocation);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_BeginLocation,
                                 g_cchBeginLocation);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)m_wszKeyType,
                                 (DWORD)wcslen(m_wszKeyType));

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_Location,
                                 g_cchLocation);

    if(FAILED(hr))
    {
        goto exit;
    }

    if((0 != iLastChar) && (L'/' == wszLocation[iLastChar]))
    {
        cchEscapedLocation--;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)wszEscapedLocation,
                                 cchEscapedLocation);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_QuoteRtn,
                                 g_cchQuoteRtn);

    if(FAILED(hr))
    {
        goto exit;
    }

exit:

    if(bEscapedLocation && (NULL != wszEscapedLocation))
    {
        delete [] wszEscapedLocation;
        wszEscapedLocation = NULL;
    }

    return hr;

} // CLocationWriter::WriteBeginLocation


/***************************************************************************++
Routine Description:

    This writes the end tag of a location.

    Eg: </IIsWebServer>
    or: </IIsConfigObject>

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::WriteEndLocation()
{
    HRESULT hr= S_OK;

    hr = m_pCWriter->WriteToFile((LPVOID)g_EndLocationBegin,
                                 g_cchEndLocationBegin);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)m_wszKeyType,
                                 (DWORD)wcslen(m_wszKeyType));

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_EndLocationEnd,
                                 g_cchEndLocationEnd);

    if(FAILED(hr))
    {
        goto exit;
    }

exit:

    return hr;

} // CLocationWriter::WriteEndLocation


/***************************************************************************++
Routine Description:

    This writes a custom property

    Eg: <Custom
                Name="LogCustomPropertyName"
                ID="4501"
                Value="Process Accounting"
                Type="STRING"
                UserType="IIS_MD_UT_SERVER"
                Attributes="NO_ATTRIBUTES"
        />


Arguments:

    [in] Buffer containing property value and attributes.
    [in] Count of bytes for data in the buffer

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::WriteCustomProperty(LPVOID*  a_pv,
                                             ULONG*   a_cbSize)
{
    HRESULT hr               = S_OK;
    DWORD   dwType           = *(DWORD*)a_pv[iMBProperty_Type];
    LPWSTR  wszType          = g_T_Unknown;
    DWORD   dwUserType       = *(DWORD*)a_pv[iMBProperty_UserType];
    LPWSTR  wszUserType      = g_UT_Unknown;
    ULONG   cchUserType      = 0;
    BOOL    bAllocedUserType = FALSE;
    LPWSTR  wszValue         = NULL;
    WCHAR   wszID[40];
    LPWSTR  wszAttributes    = NULL;


    ULONG aColSearchType[]   = {iTAGMETA_Table,
                                iTAGMETA_ColumnIndex,
                                iTAGMETA_Value
    };
    ULONG cColSearchType     = sizeof(aColSearchType)/sizeof(ULONG);
    ULONG iColType           = iMBProperty_Type;
    LPVOID apvSearchType[cTAGMETA_NumberOfColumns];
    apvSearchType[iTAGMETA_Table]       = (LPVOID)m_pCWriterGlobalHelper->m_wszTABLE_MBProperty;
    apvSearchType[iTAGMETA_ColumnIndex] = (LPVOID)&iColType;
    apvSearchType[iTAGMETA_Value]       = (LPVOID)&dwType;

    ULONG iRow               = 0;
    ULONG iStartRow          = 0;
    ULONG iColAttributes     = iMBProperty_Attributes;

    _ultow(*(DWORD*)a_pv[iMBProperty_ID], wszID, 10);

    //
    // Get the tag for UserType from meta
    //

    hr = m_pCWriter->m_pCWriterGlobalHelper->GetUserType(dwUserType,
                                                         &wszUserType,
                                                         &cchUserType,
                                                         &bAllocedUserType);

    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // Get the tag for Type from meta
    //

    hr = (m_pCWriterGlobalHelper->m_pISTTagMetaByTableAndColumnIndexAndValue)->GetRowIndexBySearch(iStartRow,
                                                                                                   cColSearchType,
                                                                                                   aColSearchType,
                                                                                                   NULL,
                                                                                                   apvSearchType,
                                                                                                   &iRow);

    if(E_ST_NOMOREROWS == hr)
    {
        hr = S_OK;
        wszType = g_T_Unknown;
    }
    else if(FAILED(hr))
    {
        goto exit;
    }
    else
    {
        iColType = iTAGMETA_InternalName;

        hr = (m_pCWriterGlobalHelper->m_pISTTagMetaByTableAndColumnIndexAndValue)->GetColumnValues(iRow,
                                                                                                   1,
                                                                                                   &iColType,
                                                                                                   NULL,
                                                                                                   (LPVOID*)&wszType);

        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;
            wszType = g_T_Unknown;
        }
        else if(FAILED(hr))
        {
            goto exit;
        }
    }

    //
    // Construct the tag for Attributes from meta
    //

    hr = m_pCWriterGlobalHelper->FlagToString(*(DWORD*)a_pv[iMBProperty_Attributes],
                                              &wszAttributes,
                                              m_pCWriterGlobalHelper->m_wszTABLE_MBProperty,
                                              iColAttributes);
    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriterGlobalHelper->ToString((PBYTE)a_pv[iMBProperty_Value],
                                          a_cbSize[iMBProperty_Value],
                                          *(DWORD*)a_pv[iMBProperty_ID],
                                          dwType,
                                          *(DWORD*)a_pv[iMBProperty_Attributes],
                                          &wszValue);

    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // Write all the values.
    //

    hr = m_pCWriter->WriteToFile((LPVOID)g_BeginCustomProperty,
                                 g_cchBeginCustomProperty);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_NameEq,
                                 g_cchNameEq);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)(LPWSTR)a_pv[iMBProperty_Name],
                                 (DWORD)wcslen((LPWSTR)a_pv[iMBProperty_Name]));

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_QuoteRtn,
                                 g_cchQuoteRtn);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_IDEq,
                                 g_cchIDEq);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)wszID,
                                 (DWORD)wcslen(wszID));

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_QuoteRtn,
                                 g_cchQuoteRtn);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_ValueEq,
                                 g_cchValueEq);

    if(FAILED(hr))
    {
        goto exit;
    }

    if(NULL != wszValue)
    {
        hr = m_pCWriter->WriteToFile((LPVOID)wszValue,
                                     (DWORD)wcslen(wszValue));

        if(FAILED(hr))
        {
            goto exit;
        }
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_QuoteRtn,
                                 g_cchQuoteRtn);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_TypeEq,
                                 g_cchTypeEq);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)wszType,
                                 (DWORD)wcslen(wszType));

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_QuoteRtn,
                                 g_cchQuoteRtn);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_UserTypeEq,
                                 g_cchUserTypeEq);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)wszUserType,
                                 (DWORD)wcslen(wszUserType));

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_QuoteRtn,
                                 g_cchQuoteRtn);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_AttributesEq,
                                 g_cchAttributesEq);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)wszAttributes,
                                 (DWORD)wcslen(wszAttributes));

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_QuoteRtn,
                                 g_cchQuoteRtn);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_EndCustomProperty,
                                 g_cchEndCustomProperty);

    if(FAILED(hr))
    {
        goto exit;
    }

exit:

    if((NULL != wszUserType) && bAllocedUserType)
    {
        delete [] wszUserType;
        wszUserType = NULL;
    }
    cchUserType = NULL;

    if(NULL != wszValue)
    {
        delete [] wszValue;
        wszValue = NULL;
    }

    if(NULL != wszAttributes)
    {
        delete [] wszAttributes;
        wszAttributes = NULL;
    }

    return hr;

} // CLocationWriter::WriteCustomProperty


/***************************************************************************++
Routine Description:

    This writes end of a well known group

    Eg: >

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::WriteEndWellKnownGroup()
{
    return m_pCWriter->WriteToFile((LPVOID)g_EndGroup,
                                   (DWORD)wcslen(g_EndGroup));

} // CLocationWriter::WriteEndWellKnownGroup


/***************************************************************************++
Routine Description:

    This writes a well-known property

    Eg: AccessFlags="AccessExecute | AccessRead"

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CLocationWriter::WriteWellKnownProperty(LPVOID*   a_pv,
                                                ULONG*    a_cbSize)
{
    HRESULT hr       = S_OK;
    LPWSTR  wszValue = NULL;

    hr = m_pCWriterGlobalHelper->ToString((PBYTE)a_pv[iMBProperty_Value],
                                          a_cbSize[iMBProperty_Value],
                                          *(DWORD*)a_pv[iMBProperty_ID],
                                          *(DWORD*)a_pv[iMBProperty_Type],
                                          *(DWORD*)a_pv[iMBProperty_Attributes],
                                          &wszValue);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_TwoTabs,
                                 g_cchTwoTabs);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)(LPWSTR)a_pv[iMBProperty_Name],
                                 (DWORD)wcslen((LPWSTR)a_pv[iMBProperty_Name]));

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_EqQuote,
                                 g_cchEqQuote);

    if(FAILED(hr))
    {
        goto exit;
    }

    if(NULL != wszValue)
    {
        hr = m_pCWriter->WriteToFile((LPVOID)wszValue,
                                     (DWORD)wcslen(wszValue));

        if(FAILED(hr))
        {
            goto exit;
        }

    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_QuoteRtn,
                                 g_cchQuoteRtn);

    if(FAILED(hr))
    {
        goto exit;
    }

exit:

    if(NULL != wszValue)
    {
        delete [] wszValue;
        wszValue = NULL;
    }

    return hr;

} // CLocationWriter::WriteWellKnownProperty


/***************************************************************************++
Routine Description:

    Looks at the group and increments the group count.
    This must be called every time a property is added.

Arguments:

    group.

Return Value:

    Void

--***************************************************************************/
void CLocationWriter::IncrementGroupCount(DWORD i_dwGroup)
{
    if((eMBProperty_Custom == i_dwGroup) ||
       (eMBProperty_IIsConfigObject == i_dwGroup)
      )
    {
        m_cCustomProperty++;
    }
    else
    {
        m_cWellKnownProperty++;
    }

} // CLocationWriter::IncrementGroupCount
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\shared\xmlwriter\mbpropertywriter.cpp ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    MBPropertyWriter.cpp

Abstract:

    Implementation of the class that writes proterty information when there are
    schema extensions. It is usually contaied by the CMBCollectionWriter class.
    If there are schema extensions, then, we create an extensions file
    (MD_SCHEMA_EXTENSION_FILE_NAMEW), that contains the schema extension
    descriptions and we then compile it into the schema bin format.

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/

#include "precomp.hxx"

typedef CMBPropertyWriter* LP_CMBPropertyWriter;

#define     IIS_SYNTAX_ID_DWORD         1
#define     IIS_SYNTAX_ID_STRING        2
#define     IIS_SYNTAX_ID_EXPANDSZ      3
#define     IIS_SYNTAX_ID_MULTISZ       4
#define     IIS_SYNTAX_ID_BINARY        5
#define     IIS_SYNTAX_ID_BOOL          6
#define     IIS_SYNTAX_ID_BOOL_BITMASK  7
#define     IIS_SYNTAX_ID_MIMEMAP       8
#define     IIS_SYNTAX_ID_IPSECLIST     9
#define     IIS_SYNTAX_ID_NTACL        10
#define     IIS_SYNTAX_ID_HTTPERRORS   11
#define     IIS_SYNTAX_ID_HTTPHEADERS  12

#define    cMaxFlag 32

static DWORD g_dwCatalogTypeFromSynID[]=
{
  0,                                   //invalid     no equivalent in IISSynID.h
  eCOLUMNMETA_DWORD_METADATA,          //#define     IIS_SYNTAX_ID_DWORD         1
  eCOLUMNMETA_STRING_METADATA,         //#define     IIS_SYNTAX_ID_STRING        2
  eCOLUMNMETA_EXPANDSZ_METADATA,       //#define     IIS_SYNTAX_ID_EXPANDSZ      3
  eCOLUMNMETA_MULTISZ_METADATA,        //#define     IIS_SYNTAX_ID_MULTISZ       4
  eCOLUMNMETA_BINARY_METADATA,         //#define     IIS_SYNTAX_ID_BINARY        5
  eCOLUMNMETA_DWORD_METADATA,          //#define     IIS_SYNTAX_ID_BOOL          6
  eCOLUMNMETA_DWORD_METADATA,          //#define     IIS_SYNTAX_ID_BOOL_BITMASK  7
  eCOLUMNMETA_MULTISZ_METADATA,        //#define     IIS_SYNTAX_ID_MIMEMAP       8
  eCOLUMNMETA_MULTISZ_METADATA,        //#define     IIS_SYNTAX_ID_IPSECLIST     9
  eCOLUMNMETA_BINARY_METADATA,         //#define     IIS_SYNTAX_ID_NTACL        10
  eCOLUMNMETA_MULTISZ_METADATA,        //#define     IIS_SYNTAX_ID_HTTPERRORS   11
  eCOLUMNMETA_MULTISZ_METADATA,        //#define     IIS_SYNTAX_ID_HTTPHEADERS  12
  0
};

static DWORD g_dwMetabaseTypeFromSynID[]=
{
  0,                       //invalid     no equivalent in IISSynID.h
  DWORD_METADATA,          //#define     IIS_SYNTAX_ID_DWORD         1
  STRING_METADATA,         //#define     IIS_SYNTAX_ID_STRING        2
  EXPANDSZ_METADATA,       //#define     IIS_SYNTAX_ID_EXPANDSZ      3
  MULTISZ_METADATA,        //#define     IIS_SYNTAX_ID_MULTISZ       4
  BINARY_METADATA,         //#define     IIS_SYNTAX_ID_BINARY        5
  DWORD_METADATA,          //#define     IIS_SYNTAX_ID_BOOL          6
  DWORD_METADATA,          //#define     IIS_SYNTAX_ID_BOOL_BITMASK  7
  MULTISZ_METADATA,        //#define     IIS_SYNTAX_ID_MIMEMAP       8
  MULTISZ_METADATA,        //#define     IIS_SYNTAX_ID_IPSECLIST     9
  BINARY_METADATA,         //#define     IIS_SYNTAX_ID_NTACL        10
  MULTISZ_METADATA,        //#define     IIS_SYNTAX_ID_HTTPERRORS   11
  MULTISZ_METADATA,        //#define     IIS_SYNTAX_ID_HTTPHEADERS  12
  0
};

static DWORD g_dwCatalogTypeFromMetaType[]=
{
  0,                                   //invalid     no equivalent for metatype
  eCOLUMNMETA_DWORD_METADATA,          //#define     DWORD_METADATA         1
  eCOLUMNMETA_STRING_METADATA,         //#define     STRING_METADATA        2
  eCOLUMNMETA_BINARY_METADATA,         //#define     BINARY_METADATA        3
  eCOLUMNMETA_EXPANDSZ_METADATA,       //#define     EXPANDSZ_METADATA      4
  eCOLUMNMETA_MULTISZ_METADATA,        //#define     MULTISZ_METADATA       5
  0
};


HRESULT GetTypefromSynID(DWORD      i_dwSynID,
                         LPWSTR*    o_pwszType)
{
    if((i_dwSynID < 1) || (i_dwSynID > 12))
    {
        return E_INVALIDARG;
    }
    else
    {
        *o_pwszType = (LPWSTR)g_aSynIDToWszType[i_dwSynID];
    }

    return S_OK;
}


/***************************************************************************++
Routine Description:

    Constructor for CMBPropertyWriter

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
CMBPropertyWriter::CMBPropertyWriter():
m_pCWriter(NULL),
m_wszName(NULL),
m_pType(NULL),
m_dwID(0),
m_bDefault(NULL),
m_cbDefault(0),
m_apFlag(NULL),
m_cFlag(0),
m_iFlag(0),
m_IsProperty(TRUE),
m_bMandatory(FALSE),
m_pCollection(NULL)
{

} // CMBPropertyWriter::CMBPropertyWriter


/***************************************************************************++
Routine Description:

    Destructor for CMBPropertyWriter

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
CMBPropertyWriter::~CMBPropertyWriter()
{
    if(NULL != m_apFlag)
    {
        for(ULONG i=0; i<m_iFlag; i++)
        {
            if(NULL != m_apFlag[i])
            {
                m_apFlag[i] = NULL; // No need to delete because you had simply saved the pointer.
            }
        }

        delete [] m_apFlag;
        m_apFlag = NULL;
    }

    m_cFlag = 0;
    m_iFlag = 0;

} // CMBPropertyWriter::CMBPropertyWriter


/***************************************************************************++
Routine Description:

    Initialize property writer.

Arguments:

    [in] Property ID
    [in] Bool indicating manditory property or optional.
    [in] Pointer to the Collection writer object to which it belongs.
         Assuming that the collection writer is valid for the lifetime
         of this property writer.
    [in] Pointer to the writer object. Assuming that the writer is valid for
         the lifetime of this property writer.

Return Value:

    HRESULT

--***************************************************************************/
void CMBPropertyWriter::Initialize(DWORD                    i_dwID,
                                   BOOL                     i_bMandatory,
                                   CMBCollectionWriter*     i_pCollection,
                                   CWriter*                 i_pcWriter)
{
    //
    // Assumption: i_pcWriter will be valid for the
    // lifetime of the schema writer object.
    //
    m_pCWriter      = i_pcWriter;
    m_dwID          = i_dwID;
    m_bMandatory    = i_bMandatory;
    //
    // Assumption: i_pCollection will be valid for the
    // lifetime of the property writer object.
    //
    m_pCollection   = i_pCollection;

    return;

} // CMBPropertyWriter::Initialize


/***************************************************************************++
Routine Description:

    Initialize property's name.

Arguments:

    [in] Property Name

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBPropertyWriter::AddNameToProperty(LPCWSTR    i_wszName)
{
    //
    // We have to make a copy of the name because
    //

    m_wszName  = i_wszName;

    return S_OK;

} // CMBPropertyWriter::Initialize


/***************************************************************************++
Routine Description:

    Initialize property type.

Arguments:

    [in] PropValue structure that has metabase type information.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBPropertyWriter::AddTypeToProperty(PropValue* i_pType)
{
    HRESULT hr = S_OK;

    //
    // First save the type, then if the meta/prop ids differ, mark the
    // object as a flag and add it to its property.
    //

    m_pType = i_pType;

    //
    // A lot of tests dont really ensure that PropID == MetaID.
    // They just set PropID to zero. We must not interpret this as a flag
    //

    if((0 != i_pType->dwPropID) && (i_pType->dwMetaID != i_pType->dwPropID))
    {
        //
        // This is a flag. Add it as a flag to its property
        //

        //
        // TODO: Assert that the ID of this object is the same as the propID.
        //

        CMBPropertyWriter*  pPropertyWriter = NULL;

        DBGINFOW((DBG_CONTEXT,
              L"[AddTypeToProperty] Saving a non-shipped flag. Adding tag ID %d to its property ID %d\n",
              i_pType->dwPropID,
              i_pType->dwMetaID));

        hr = m_pCollection->GetMBPropertyWriter(i_pType->dwMetaID,
                                                &pPropertyWriter);

        if(FAILED(hr))
        {
            return hr;
        }

        hr = pPropertyWriter->AddFlagToProperty(this);

        m_IsProperty = FALSE;

    }

    return S_OK;

} // CMBPropertyWriter::Initialize


/***************************************************************************++
Routine Description:

    Initialize property defaults.

Arguments:

    [in] Default value
    [in] Count of bytes for default value.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBPropertyWriter::AddDefaultToProperty(BYTE*      i_bDefault,
                                                ULONG      i_cbDefault)
{
    m_bDefault = i_bDefault;
    m_cbDefault = i_cbDefault;

    return S_OK;

} // CMBPropertyWriter::Initialize


/***************************************************************************++
Routine Description:

    Save property's flag. Note that flag objects are also the same data
    structure as property objects i.e. CMBPropertyWriter

Arguments:

    [in] Flag object

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBPropertyWriter::AddFlagToProperty(CMBPropertyWriter* i_pFlag)
{
    //
    // ASSUMPTION: A meta ID will have only one occurance of a Prop ID. i.e. flag
    //

    HRESULT hr = S_OK;

    if(m_iFlag == m_cFlag)
    {
        hr = ReAllocate();

        if(FAILED(hr))
        {
            return hr;
        }
    }

    m_apFlag[m_iFlag++] = i_pFlag;

    return hr;

}


/***************************************************************************++
Routine Description:

    Helper function to grow the buffer that holds the flag objects

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBPropertyWriter::ReAllocate()
{
    CMBPropertyWriter** pSav = NULL;

    pSav = new LP_CMBPropertyWriter[m_cFlag + cMaxFlag];
    if(NULL == pSav)
    {
        return E_OUTOFMEMORY;
    }
    memset(pSav, 0, (sizeof(LP_CMBPropertyWriter))*(m_cFlag + cMaxFlag));

    if(NULL != m_apFlag)
    {
        memcpy(pSav, m_apFlag, (sizeof(LP_CMBPropertyWriter))*(m_cFlag));
        delete [] m_apFlag;
        m_apFlag = NULL;
    }

    m_apFlag = pSav;
    m_cFlag = m_cFlag + cMaxFlag;

    return S_OK;

} // CMBPropertyWriter::ReAllocate


/***************************************************************************++
Routine Description:

    Function that writes the property.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBPropertyWriter::WriteProperty()
{
    HRESULT hr = S_OK;

    if(!m_IsProperty)
    {
        return S_OK;
    }

    if(0 == _wcsicmp(m_pCollection->Name(), wszTABLE_IIsConfigObject))
    {
        hr = WritePropertyLong();
    }
    else
    {
        hr = WritePropertyShort();
    }

    return hr;

} // CMBPropertyWriter::WriteProperty


/***************************************************************************++
Routine Description:

    Helper function to determine if the property is a bool.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
BOOL CMBPropertyWriter::IsPropertyFlag(BOOL i_bLog)
{
    if(NULL != m_apFlag)
    {
        DBGINFOW((DBG_CONTEXT,
              L"[IsPropertyFlag] PropertyID %d. Type: %d.\n",
              m_dwID,
              m_pType));

        DBGINFOW((DBG_CONTEXT,
              L"[IsPropertyFlag] PropertyID %d. SynID: %d.\n",
              m_dwID,
              m_pType->dwSynID));

        if(eCOLUMNMETA_DWORD_METADATA == g_dwCatalogTypeFromSynID[m_pType->dwSynID])
        {
            return TRUE;
        }
        else
        {
            if(i_bLog)
            {
                DBGINFOW((DBG_CONTEXT,
                      L"[IsPropertyFlag] PropertyID %d is not a DWORD. Ignoring flags for this property.\n",m_dwID));
            }

            return FALSE;

        }
    }
    else
    {
        return FALSE;
    }

} // CMBPropertyWriter::IsPropertyFlag


/***************************************************************************++
Routine Description:

    Function that writes the property (long form) i.e. property that belongs
    to the global IIsConfigObject collection.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBPropertyWriter::WritePropertyLong()
{
    HRESULT hr = S_OK;

    hr = BeginWritePropertyLong();

    if(FAILED(hr))
    {
        if(HRESULT_FROM_WIN32(ERROR_INVALID_DATATYPE) == hr)
        {
            return S_OK;
        }
        else
        {
            return hr;
        }
    }

    if(IsPropertyFlag(FALSE))
    {
        for(ULONG i=0; i<m_iFlag; i++)
        {
            hr = WriteFlag(i);
            // hr = m_aFlag[i]->WriteFlag;

            if(FAILED(hr))
            {
                return hr;
            }
        }
    }

    hr = EndWritePropertyLong();

    if(FAILED(hr))
    {
        return hr;
    }

    return hr;

} // CMBPropertyWriter::WritePropertyLong


/***************************************************************************++
Routine Description:

    Function that writes the property (short form) i.e. property that belongs
    to a non-IIsConfigObject collection.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBPropertyWriter::WritePropertyShort()
{
    HRESULT         hr                  = S_OK;
    static WCHAR    wchSeparator        = L',';
    WCHAR*          wszEndName          = NULL;
    WCHAR*          wszName             = NULL;
    WCHAR           wszUnknownName[25];
    size_t          cchPropertyName     = 0;
    DWORD           dwMetaFlagsEx       = fCOLUMNMETA_MANDATORY;
    DWORD           iColMetaFlagsEx     = iCOLUMNMETA_SchemaGeneratorFlags;
    WCHAR*          wszMetaFlagsEx      = NULL;

    if(NULL == m_wszName)
    {

        CreateUnknownName(wszUnknownName,
                          m_dwID);
        wszName = wszUnknownName;
        cchPropertyName = wcslen(wszName);
    }
    else
    {
        wszName = (LPWSTR)m_wszName;
        wszEndName = wcschr(m_wszName, wchSeparator);
        if(NULL == wszEndName)
        {
            cchPropertyName = wcslen(m_wszName);
        }
        else
        {
            cchPropertyName = wszEndName-m_wszName; // No need to divide by WCHAR because both are WCHAR pointers
        }
    }

    if(m_bMandatory)
    {
        hr = m_pCWriter->m_pCWriterGlobalHelper->FlagToString(dwMetaFlagsEx,
                                                              &wszMetaFlagsEx,
                                                              wszTABLE_COLUMNMETA,
                                                              iColMetaFlagsEx);

        if(FAILED(hr))
        {
            goto exit;
        }

    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_wszBeginPropertyShort,
                                 g_cchBeginPropertyShort);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)wszName,
                                 (DWORD)cchPropertyName);

    if(FAILED(hr))
    {
        goto exit;
    }

    if(m_bMandatory)
    {
        hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropMetaFlagsExEq,
                                     g_cchPropMetaFlagsExEq);

        if(FAILED(hr))
        {
            goto exit;
        }

        hr = m_pCWriter->WriteToFile((LPVOID)g_wszOr,
                                     g_cchOr);

        if(FAILED(hr))
        {
            goto exit;
        }

        hr = m_pCWriter->WriteToFile((LPVOID)wszMetaFlagsEx,
                                     (DWORD)wcslen(wszMetaFlagsEx));

        if(FAILED(hr))
        {
            goto exit;
        }
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_wszEndPropertyShort,
                                 g_cchEndPropertyShort);

    if(FAILED(hr))
    {
        goto exit;
    }

exit:

    if(NULL != wszMetaFlagsEx)
    {
        delete [] wszMetaFlagsEx;
        wszMetaFlagsEx = NULL;
    }

    return hr;

} // CMBPropertyWriter::WritePropertyShort


/***************************************************************************++
Routine Description:

    Function that writes the property (long form) i.e. property that belongs
    to a IIsConfigObject collection.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBPropertyWriter::BeginWritePropertyLong()
{

    HRESULT         hr                              = S_OK;
    WCHAR*          wszEndName                      = NULL;
    static WCHAR    wchSeparator                    = L',';
    WCHAR*          wszName                         = NULL;
    WCHAR           wszUnknownName[40];
    size_t          cchPropertyName                 = 0;
    WCHAR           wszID[11];
    WCHAR*          wszType                         = NULL;
    WCHAR*          wszUserType                     = NULL;
    ULONG           cchUserType                     = 0;
    BOOL            bAllocedUserType                = FALSE;
    WCHAR*          wszAttribute                    = NULL;
    DWORD           iColAttribute                   = iCOLUMNMETA_Attributes;
    WCHAR*          wszMetaFlags                    = NULL;
    WCHAR*          wszMetaFlagsEx                  = NULL;
    WCHAR*          wszDefault                      = NULL;
    WCHAR           wszMinValue[40];
    WCHAR           wszMaxValue[40];

    //
    // Compute the individual strings and lengths.
    //

    //
    // Name
    //

    if(NULL == m_wszName)
    {

        CreateUnknownName(wszUnknownName,
                          m_dwID);
        wszName = wszUnknownName;
        cchPropertyName = wcslen(wszName);
    }
    else
    {
        wszName = (LPWSTR)m_wszName;
        wszEndName = wcschr(m_wszName, wchSeparator);
        if(NULL == wszEndName)
        {
            cchPropertyName = wcslen(m_wszName);
        }
        else
        {
            cchPropertyName = wszEndName-m_wszName; // // No need to divide by WCHAR because both are WCHAR pointers
        }
    }

    //
    // ID
    //

    wszID[0] = 0;
    _ultow(m_dwID, wszID, 10);

    //
    // Type
    //

    if(NULL == m_pType)
    {
        //
        // TODO: Log the fact that you found a property with no type and move on to the next property
        //
        DBGINFOW((DBG_CONTEXT,
              L"[BeginWritePropertyLong] Type not found for PropertyID %d.\n",
              m_dwID));
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATATYPE);
        goto exit;
    }

    hr = GetTypefromSynID(m_pType->dwSynID,
                          &wszType);

    /*

    TODO: Get from schema

    hr = m_pCWriter->m_pCWriterGlobalHelper->FlagToString(g_dwCatalogTypeFromSynID[m_pType->dwSynID],
                                                          &wszType,
                                                          wszTABLE_COLUMNMETA,
                                                          iColType);
    */
    if(FAILED(hr) || (NULL == wszType))
    {
        DBGINFOW((DBG_CONTEXT,
              L"[GetType] PropertyID %d, type: %d from synid %d is invalid.\n",
              m_dwID,
              g_dwCatalogTypeFromSynID[m_pType->dwSynID],
              m_pType->dwSynID));
        goto exit;
    }

    if(g_dwCatalogTypeFromSynID[m_pType->dwSynID] != g_dwCatalogTypeFromMetaType[m_pType->dwMetaType])
    {
        //
        // TODO: Log a warning.
        //
    }

    //
    // UserType
    //

    hr = m_pCWriter->m_pCWriterGlobalHelper->GetUserType(m_pType->dwUserGroup,
                                                         &wszUserType,
                                                         &cchUserType,
                                                         &bAllocedUserType);
    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
              L"[GetUserType] PropertyID %d, usertype: %d is invalid.\n",m_dwID, m_pType->dwUserGroup));
        goto exit;
    }

    //
    // Attribute
    //

    hr = m_pCWriter->m_pCWriterGlobalHelper->FlagToString(m_pType->dwMetaFlags,
                                                          &wszAttribute,
                                                          wszTABLE_COLUMNMETA,
                                                          iColAttribute);

    if(FAILED(hr) || (NULL == wszAttribute))
    {
        goto exit;
    }

    //
    // Since this object is used only to write MBSchemaExt.XML, we are not
    // writing the MetaFlags tag, because it will be derived on a compile.
    // And besides, we do not have this info in the metabase - this tag
    // contains catalog related data
    //

    //
    // MetaFlagsEx (only the relavant ones - CACHE_PROPERTY_MODIFIED, CACHE_PROPERTY_CLEARED, EXTENDEDTYPE0-3)
    //

    hr = GetMetaFlagsExTag(&wszMetaFlagsEx);
    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // DefaultValue
    //

    if(NULL != m_bDefault && m_cbDefault != 0)
    {
        hr = m_pCWriter->m_pCWriterGlobalHelper->ToString(m_bDefault,
                                                          m_cbDefault,
                                                          m_dwID,
                                                          g_dwMetabaseTypeFromSynID[m_pType->dwSynID],
                                                          METADATA_NO_ATTRIBUTES,                   // Do not check for attributes while applying defaults
                                                          &wszDefault);

        if(FAILED(hr))
        {
            goto exit;
        }
    }

    wszMinValue[0] = 0;
    wszMaxValue[0] = 0;

    if(DWORD_METADATA == g_dwMetabaseTypeFromSynID[m_pType->dwSynID])
    {
        //
        // Set min/max values only for DWORD types
        //

        //
        // TODO: Get the catalog's default for min/max from schema/ header file
        //

        if(0 != m_pType->dwMinRange)
        {
            _ultow(m_pType->dwMinRange, wszMinValue, 10);
        }

        if(-1 != m_pType->dwMaxRange)
        {
            _ultow(m_pType->dwMaxRange, wszMaxValue, 10);
        }

    }

    //
    // Write the values into the file.
    //

    hr = m_pCWriter->WriteToFile((LPVOID)g_wszBeginPropertyLong,
                                 g_cchBeginPropertyLong);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)wszName,
                                 (DWORD)cchPropertyName);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropIDEq,
                                 g_cchPropIDEq);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)wszID,
                                 (DWORD)wcslen(wszID));

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropTypeEq,
                                 g_cchPropTypeEq);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)wszType,
                                 (DWORD)wcslen(wszType));

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropUserTypeEq,
                                 g_cchPropUserTypeEq);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)wszUserType,
                                 cchUserType);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropAttributeEq,
                                 g_cchPropAttributeEq);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)wszAttribute,
                                 (DWORD)wcslen(wszAttribute));

    if(FAILED(hr))
    {
        goto exit;
    }

    if(NULL != wszMetaFlags)
    {
        hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropMetaFlagsEq,
                                     g_cchPropMetaFlagsEq);

        if(FAILED(hr))
        {
            goto exit;
        }

        hr = m_pCWriter->WriteToFile((LPVOID)wszMetaFlags,
                                     (DWORD)wcslen(wszMetaFlags));

        if(FAILED(hr))
        {
            goto exit;
        }

    }
    if(NULL != wszMetaFlagsEx)
    {
        hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropMetaFlagsExEq,
                                     g_cchPropMetaFlagsExEq);

        if(FAILED(hr))
        {
            goto exit;
        }

        hr = m_pCWriter->WriteToFile((LPVOID)wszMetaFlagsEx,
                                     (DWORD)wcslen(wszMetaFlagsEx));

        if(FAILED(hr))
        {
            goto exit;
        }


    }
    if(NULL != wszDefault)
    {
        hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropDefaultEq,
                                     g_cchPropDefaultEq);

        if(FAILED(hr))
        {
            goto exit;
        }

        hr = m_pCWriter->WriteToFile((LPVOID)wszDefault,
                                     (DWORD)wcslen(wszDefault));

        if(FAILED(hr))
        {
            goto exit;
        }

    }
    if(0 != *wszMinValue)
    {
        hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropMinValueEq,
                                     g_cchPropMinValueEq);

        if(FAILED(hr))
        {
            goto exit;
        }

        hr = m_pCWriter->WriteToFile((LPVOID)wszMinValue,
                                     (DWORD)wcslen(wszMinValue));

        if(FAILED(hr))
        {
            goto exit;
        }

    }
    if(0 != *wszMaxValue)
    {
        hr = m_pCWriter->WriteToFile((LPVOID)g_wszPropMaxValueEq,
                                     g_cchPropMaxValueEq);

        if(FAILED(hr))
        {
            goto exit;
        }

        hr = m_pCWriter->WriteToFile((LPVOID)wszMaxValue,
                                     (DWORD)wcslen(wszMaxValue));

        if(FAILED(hr))
        {
            goto exit;
        }

    }
    if(IsPropertyFlag(FALSE))
    {
        hr = m_pCWriter->WriteToFile((LPVOID)g_wszEndPropertyLongBeforeFlag,
                                     g_cchEndPropertyLongBeforeFlag);

        if(FAILED(hr))
        {
            goto exit;
        }

    }

exit:

/*
    if(NULL != wszType)
    {
        delete [] wszType;
        wszType = NULL;
    }
*/

    if((NULL != wszUserType) && bAllocedUserType)
    {
        delete [] wszUserType;
        wszUserType = NULL;
    }
    if(NULL != wszAttribute)
    {
        delete [] wszAttribute;
        wszAttribute = NULL;
    }

    if(NULL != wszMetaFlags)
    {
        delete [] wszMetaFlags;
        wszMetaFlags = NULL;
    }

    if(NULL != wszMetaFlagsEx)
    {
        delete [] wszMetaFlagsEx;
        wszMetaFlagsEx = NULL;
    }

    if(NULL != wszDefault)
    {
        delete [] wszDefault;
        wszDefault = NULL;
    }

    return hr;

} // CMBPropertyWriter::BeginWritePropertyLong


/***************************************************************************++
Routine Description:

    Function that writes the property (long form) i.e. property that belongs
    to a IIsConfigObject collection.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBPropertyWriter::EndWritePropertyLong()
{
    HRESULT     hr              = S_OK;
    WCHAR*      wszEndProperty  = NULL;

    if(IsPropertyFlag(FALSE))
    {
        wszEndProperty = (LPWSTR)g_wszEndPropertyLongAfterFlag;
    }
    else
    {
        wszEndProperty = (LPWSTR)g_wszEndPropertyShort;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)wszEndProperty,
                                 (DWORD)wcslen(wszEndProperty));
    return hr;

} // CMBPropertyWriter::EndWriterPropertyLong


/***************************************************************************++
Routine Description:

    Function that writes a flag of the property

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBPropertyWriter::WriteFlag(ULONG i_iFlag)
{
    CMBPropertyWriter*  pFlag       = m_apFlag[i_iFlag];
    HRESULT             hr          = S_OK;
    WCHAR               wszValue[40];
    WCHAR               wszID[40];
    WCHAR               wszUnknownName[40];
    ULONG               cchFlagName = 0;
    WCHAR*              wszFlagName     = NULL;

    if(NULL != pFlag->Name())
    {
        wszFlagName = (LPWSTR)pFlag->Name();
    }
    else
    {
        CreateUnknownName(wszUnknownName,
                          pFlag->ID());
        wszFlagName = wszUnknownName;
    }
    cchFlagName = (ULONG)wcslen(wszFlagName);

    wszValue[0] = 0;
    _ultow(pFlag->FlagValue(), wszValue, 10);

    wszID[0] = 0;
    _ultow(pFlag->ID(), wszID, 10);

    //
    // Write values to the flag
    //

    hr = m_pCWriter->WriteToFile((LPVOID)g_wszBeginFlag,
                                 g_cchBeginFlag);

    if(FAILED(hr))
    {
        return hr;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)wszFlagName,
                                 cchFlagName);

    if(FAILED(hr))
    {
        return hr;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_wszFlagValueEq,
                                 g_cchFlagValueEq);

    if(FAILED(hr))
    {
        return hr;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)wszValue,
                                 (DWORD)wcslen(wszValue));

    if(FAILED(hr))
    {
        return hr;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_wszFlagIDEq,
                                 g_cchFlagIDEq);

    if(FAILED(hr))
    {
        return hr;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)wszID,
                                 (DWORD)wcslen(wszID));

    if(FAILED(hr))
    {
        return hr;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_wszEndFlag,
                                 g_cchEndFlag);

    return hr;

} // CMBPropertyWriter::WriteFlag


/***************************************************************************++
Routine Description:

    Helper funciton that creates an unknown name
    TODO: Should we make this a standalone function since it is also used in
    locationWriter?

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
void CMBPropertyWriter::CreateUnknownName(LPWSTR    io_wszUnknownName,
                                          DWORD     )
{
    WCHAR wszID[40];
    wcscpy(io_wszUnknownName, L"UnknownName_");

    _ultow(m_dwID, wszID, 10);
    wcscat(io_wszUnknownName, wszID);

    return;

} // CMBPropertyWriter::CreateUnknownName


/***************************************************************************++
Routine Description:

    Helper funciton that creates metaflagsex tag

Arguments:

    [out] String form of metaflags ex

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBPropertyWriter::GetMetaFlagsExTag(LPWSTR* o_pwszMetaFlagsEx)
{
    HRESULT hr                   = S_OK;
    DWORD   dwMetaFlagsEx        = 0;
    DWORD   iColMetaFlagsEx      = iCOLUMNMETA_SchemaGeneratorFlags;

    //
    // TODO: Check if IIS_SYNTAX_ID_BOOL_BITMASK is bool.
    //

    if(1 == m_pType->dwFlags)
    {
        dwMetaFlagsEx = dwMetaFlagsEx | fCOLUMNMETA_CACHE_PROPERTY_MODIFIED;
    }
    else if (2 == m_pType->dwFlags)
    {
        dwMetaFlagsEx = dwMetaFlagsEx | fCOLUMNMETA_CACHE_PROPERTY_CLEARED;
    }

    if(0 != dwMetaFlagsEx)
    {
        hr = m_pCWriter->m_pCWriterGlobalHelper->FlagToString(dwMetaFlagsEx,
                                                              o_pwszMetaFlagsEx,
                                                              wszTABLE_COLUMNMETA,
                                                              iColMetaFlagsEx);
    }
    else
    {
        *o_pwszMetaFlagsEx = NULL;
    }


    return hr;

} // CMBPropertyWriter::GetMetaFlagsTag
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\shared\xmlwriter\mbcollectionwriter.cpp ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    MBCollectionWriter.cpp

Abstract:

    Implementation of the class that writes class (or collection) information
    when there are schema extensions. It is usually contained by the CMBSchemaWriter
    class. If there are schema extensions, then, during SaveAllData, we create an
    extensions file (MD_SCHEMA_EXTENSION_FILE_NAMEW), that contains the schema
    extension descriptions and we then compile it into the schema bin format.

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/

#include "precomp.hxx"

typedef CMBPropertyWriter*  LP_CMBPropertyWriter;

#define MAX_PROPERTY        700


/***************************************************************************++
Routine Description:

    Constructor for CMBCollectionWriter.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/
CMBCollectionWriter::CMBCollectionWriter():
m_pCWriter(NULL),
m_wszMBClass(NULL),
m_wszContainerClassList(NULL),
m_bContainer(FALSE),
m_apProperty(NULL),
m_cProperty(0),
m_iProperty(0),
m_aIndexToProperty(NULL),
m_dwLargestID(1)
{

} // CCollectionWriter


/***************************************************************************++
Routine Description:

    Destructor for CMBCollectionWriter.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/
CMBCollectionWriter::~CMBCollectionWriter()
{
    if(NULL != m_apProperty)
    {
        for(ULONG i=0; i<m_iProperty; i++)
        {
            if(NULL != m_apProperty[i])
            {
                delete m_apProperty[i];
                m_apProperty[i] = NULL;
            }
        }

        delete [] m_apProperty;
        m_apProperty = NULL;
    }
    m_cProperty = 0;
    m_iProperty = 0;

} // ~CCollectionWriter


/***************************************************************************++
Routine Description:

    Initialize the collection writer object

Arguments:

    [in] Name of the collection
    [in] Optional - Is its a container class (for Non-IIsConfigObject
         collections)
    [in] Optional - Container class list (for Non-IIsConfigObject
         collections)
    [in] Writer object - Assume that it is valid for the lifetime of the
         collection writer

Return Value:

    None.

--***************************************************************************/
void CMBCollectionWriter::Initialize(LPCWSTR           i_wszMBClass,
                                     BOOL              i_bContainer,
                                     LPCWSTR           i_wszContainerClassList,
                                     CWriter*          i_pcWriter)
{
    m_wszMBClass            = i_wszMBClass;
    m_bContainer            = i_bContainer;
    m_wszContainerClassList = i_wszContainerClassList;

    //
    // Assumption: i_pcWriter will be valid for the
    // lifetime of the schema writer object.
    //

    m_pCWriter              = i_pcWriter;

} // CCatalogCollectionWriter::Initialize


/***************************************************************************++
Routine Description:

    Creates a new property writer and adds it to its list.
    Note: This is called only when you add a property to the IIsConfigObject
          collection.

Arguments:

    [in]  Property ID.
    [out] Property writer object.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBCollectionWriter::GetMBPropertyWriter(DWORD                  i_dwID,
                                                 CMBPropertyWriter**    o_pProperty)
{
    HRESULT hr = S_OK;

    if((NULL == m_aIndexToProperty)              ||
       (i_dwID > m_dwLargestID)                  ||
       (NULL == m_aIndexToProperty[i_dwID])
      )
    {
        //
        // If index not created, then create a new property.
        // If index does not have an object for this id, then create it.
        // Note if the ID is greater than the largest id and the index
        // has been created then GetNewMBPropertyWriter reallocates
        // the index. GetNewMBPropertyWriter updates the index with
        // the new property, if the index array has been created.
        //

        hr = GetNewMBPropertyWriter(i_dwID,
                                    o_pProperty);
    }
    else
    {
        //
        // If Index has a valid object, then return from index.
        //

        *o_pProperty = m_aIndexToProperty[i_dwID];
    }

    return hr;

} // CMBCollectionWriter::GetMBPropertyWriter


/***************************************************************************++
Routine Description:

    Creates a new property writer and adds it to its list.
    Note: This is called only when you add a property to the non-
          IIsConfigObject collection.

Arguments:

    [in] Name of the collection
    [in] Is it a manditory property or not.
    [out] Property writer object.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBCollectionWriter::GetMBPropertyWriter(LPCWSTR                i_wszName,
                                                 BOOL                   i_bMandatory,
                                                 CMBPropertyWriter**    o_pProperty)
{
    HRESULT hr = S_OK;
    DWORD   dwID = (DWORD)-1;

    if(m_iProperty == m_cProperty)
    {
        hr = ReAllocate();

        if(FAILED(hr))
        {
            return hr;
        }
    }


    m_apProperty[m_iProperty++] = new CMBPropertyWriter();

    if(NULL == m_apProperty[m_iProperty-1])
    {
        return E_OUTOFMEMORY;
    }

    m_apProperty[m_iProperty-1]->Initialize(dwID,
                                            i_bMandatory,
                                            this,
                                            m_pCWriter);

    m_apProperty[m_iProperty-1]->AddNameToProperty(i_wszName);

    *o_pProperty = m_apProperty[m_iProperty-1];

    return hr;

} // CMBCollectionWriter::GetMBPropertyWriter


/***************************************************************************++
Routine Description:

    Helper function that creates a new property writer and adds it to its
    list.

Arguments:

    [in] Property ID
    [out] Property writer object.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBCollectionWriter::GetNewMBPropertyWriter(DWORD                   i_dwID,
                                                    CMBPropertyWriter**     o_pProperty)
{
    HRESULT hr = S_OK;

    if(m_iProperty == m_cProperty)
    {
        hr = ReAllocate();

        if(FAILED(hr))
        {
            return hr;
        }
    }

    m_apProperty[m_iProperty++] = new CMBPropertyWriter();

    if(NULL == m_apProperty[m_iProperty-1])
    {
        return E_OUTOFMEMORY;
    }

    m_apProperty[m_iProperty-1]->Initialize(i_dwID,
                                            FALSE,
                                            this,
                                            m_pCWriter);

    *o_pProperty = m_apProperty[m_iProperty-1];

    if(NULL == m_aIndexToProperty)
    {

        hr = ReAllocateIndex(i_dwID);

        if(FAILED(hr))
        {
            return hr;
        }
    }

    if(i_dwID > m_dwLargestID)
    {
        //
        // If the ID being added, is greater than the highest ID seen so far,
        // then update the highest id saved, and if the index has been
        // created, update it.
        //

        hr = ReAllocateIndex(i_dwID);

        if(FAILED(hr))
        {
            return hr;
        }

    }

    //
    // If the index has been created, then updated it with the new property
    //

    m_aIndexToProperty[i_dwID] = *o_pProperty;

    return hr;

} // CMBCollectionWriter::GetNewMBPropertyWriter


/***************************************************************************++
Routine Description:

    Helper function grows the buffer that contains all property writers of
    a collection.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBCollectionWriter::ReAllocate()
{
    CMBPropertyWriter** pSav = NULL;

    pSav = new LP_CMBPropertyWriter[m_cProperty + MAX_PROPERTY];
    if(NULL == pSav)
    {
        return E_OUTOFMEMORY;
    }
    memset(pSav, 0, (sizeof(LP_CMBPropertyWriter))*(m_cProperty + MAX_PROPERTY));

    if(NULL != m_apProperty)
    {
        memcpy(pSav, m_apProperty, (sizeof(LP_CMBPropertyWriter))*(m_cProperty));
        delete [] m_apProperty;
        m_apProperty = NULL;
    }

    m_apProperty = pSav;
    m_cProperty = m_cProperty + MAX_PROPERTY;

    return S_OK;

} // CMBCollectionWriter::ReAllocate


/***************************************************************************++
Routine Description:

    In order to  provide fast access to locate the property writer of a given
    property, we create an index to the property writer buffer based on the
    property id. m_aIndexToProperty[PropertyID] will give you a pointer to the
    property writer object for that property.

    This function creates the index.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBCollectionWriter::CreateIndex()
{
    HRESULT hr = S_OK;

    hr = ReAllocateIndex(m_dwLargestID);

    if(FAILED(hr))
    {
        return hr;
    }

    for(ULONG i=0; i<m_iProperty; i++)
    {
        m_aIndexToProperty[m_apProperty[i]->ID()] = m_apProperty[i];
    }

    return hr;

} // CMBCollectionWriter::CreateIndex


/***************************************************************************++
Routine Description:

    Helper function grows the property writer index buffer.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBCollectionWriter::ReAllocateIndex(DWORD i_dwLargestID)
{
    CMBPropertyWriter** pSav = NULL;
    DWORD               dwLargestID = 0;

    //
    // Always allocate one more that the largest ID because if the largest
    // ID is say "i" we will store in m_aIndexToProperty[i] and hence need
    // array of size i+1
    //
    // Since the index is being updated everytime a new property is added
    // we allocate extra space so that we dont have to reallocate each time.
    //
    //

    if(i_dwLargestID < 0xFFFFFFFF)
    {
        if(i_dwLargestID < 0xFFFFFFFF-(50+1))
        {
            dwLargestID = i_dwLargestID+50;

        }
        else
        {
            dwLargestID = i_dwLargestID;
        }
    }
    else
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    pSav = new LP_CMBPropertyWriter[dwLargestID+1];
    if(NULL == pSav)
    {
        return E_OUTOFMEMORY;
    }
    memset(pSav, 0, (sizeof(LP_CMBPropertyWriter))*(dwLargestID+1));

    if(NULL != m_aIndexToProperty)
    {
        memcpy(pSav, m_aIndexToProperty, (sizeof(LP_CMBPropertyWriter))*(m_dwLargestID+1));
        delete [] m_aIndexToProperty;
        m_aIndexToProperty = NULL;
    }

    m_aIndexToProperty = pSav;
    m_dwLargestID = dwLargestID;

    return S_OK;

} // CMBCollectionWriter::ReAllocateIndex


/***************************************************************************++
Routine Description:

    Function that writes the collection.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBCollectionWriter::WriteCollection()
{
    HRESULT hr = S_OK;

    hr = BeginWriteCollection();

    if(FAILED(hr))
    {
        return hr;
    }

    for(ULONG i=0; i<m_iProperty; i++)
    {
        hr = m_apProperty[i]->WriteProperty();

        if(FAILED(hr))
        {
            return hr;
        }

    }

    hr = EndWriteCollection();

    if(FAILED(hr))
    {
        return hr;
    }

    return hr;

} // CMBCollectionWriter::WriteCollection


/***************************************************************************++
Routine Description:

    Function that writes the begin collection tag

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBCollectionWriter::BeginWriteCollection()
{
    HRESULT     hr                          = S_OK;
    LPWSTR      wszEndBeginCollection       = NULL;
    ULONG       cchEndBeginCollection       = 0;
    ULONG       iColMetaFlagsEx             = iTABLEMETA_SchemaGeneratorFlags;
    LPWSTR      wszContainer                = NULL;

    if(0 == _wcsicmp(m_wszMBClass, wszTABLE_IIsConfigObject))
    {
        wszEndBeginCollection = (LPWSTR)g_wszEndBeginCollectionMB;
        cchEndBeginCollection = g_cchEndBeginCollectionMB;
    }
    else
    {
        wszEndBeginCollection = (LPWSTR)g_wszInheritsFrom;
        cchEndBeginCollection = g_cchInheritsFrom;
    }


    if(m_bContainer)
    {
        hr = m_pCWriter->m_pCWriterGlobalHelper->FlagToString(fTABLEMETA_CONTAINERCLASS,
                                                              &wszContainer,
                                                              wszTABLE_TABLEMETA,
                                                              iColMetaFlagsEx);

        if(FAILED(hr))
        {
            goto exit;
        }
    }

    hr = m_pCWriter->WriteToFile((LPVOID)g_wszBeginCollection,
                                 g_cchBeginCollection);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = m_pCWriter->WriteToFile((LPVOID)m_wszMBClass,
                                 (DWORD)wcslen(m_wszMBClass));

    if(FAILED(hr))
    {
        goto exit;
    }

    if(m_bContainer)
    {
        hr = m_pCWriter->WriteToFile((LPVOID)g_wszMetaFlagsExEq,
                                     g_cchMetaFlagsExEq);

        if(FAILED(hr))
        {
            goto exit;
        }

        hr = m_pCWriter->WriteToFile((LPVOID)wszContainer,
                                     (DWORD)wcslen(wszContainer));

        if(FAILED(hr))
        {
            goto exit;
        }

    }

    if(m_wszContainerClassList)
    {
        hr = m_pCWriter->WriteToFile((LPVOID)g_wszContainerClassListEq,
                                     g_cchContainerClassListEq);

        if(FAILED(hr))
        {
            goto exit;
        }

        hr = m_pCWriter->WriteToFile((LPVOID)m_wszContainerClassList,
                                     (DWORD)wcslen(m_wszContainerClassList));

        if(FAILED(hr))
        {
            goto exit;
        }
    }

    hr = m_pCWriter->WriteToFile((LPVOID)wszEndBeginCollection,
                                 (DWORD)wcslen(wszEndBeginCollection));

    if(FAILED(hr))
    {
        goto exit;
    }

exit:

    if(NULL != wszContainer)
    {
        delete [] wszContainer;
        wszContainer = NULL;
    }

    return hr;

} // CMBCollectionWriter::BeginWriteCollection


/***************************************************************************++
Routine Description:

    Function that writes the end collection tag

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CMBCollectionWriter::EndWriteCollection()
{
    return m_pCWriter->WriteToFile((LPVOID)g_wszEndCollection,
                                   g_cchEndCollection);

} // CMBCollectionWriter::EndWriteCollection
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\fixedschemainterceptor\fixedpackedschema.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

extern ULONG g_aFixedTableHeap[];
#define g_aTableSchemaHeap (g_aFixedTableHeap + 0x400)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\shared\xmlwriter\writerglobalhelper.cpp ===
/*++


Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    WriterGlobalHelper.cpp

Abstract:

    Implementation of a global helper class that wraps access to config meta
    tables.

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/

#include "precomp.hxx"
#include "WriterGlobals.cpp"

#define  MAX_FLAG_STRING_CHARS 1024

//
// TODO: Since XML table also uses this, cant we reduce to one definition?
//

static WCHAR * kByteToWchar[256] =
{
    L"00",    L"01",    L"02",    L"03",    L"04",    L"05",    L"06",    L"07",    L"08",    L"09",    L"0a",    L"0b",    L"0c",    L"0d",    L"0e",    L"0f",
    L"10",    L"11",    L"12",    L"13",    L"14",    L"15",    L"16",    L"17",    L"18",    L"19",    L"1a",    L"1b",    L"1c",    L"1d",    L"1e",    L"1f",
    L"20",    L"21",    L"22",    L"23",    L"24",    L"25",    L"26",    L"27",    L"28",    L"29",    L"2a",    L"2b",    L"2c",    L"2d",    L"2e",    L"2f",
    L"30",    L"31",    L"32",    L"33",    L"34",    L"35",    L"36",    L"37",    L"38",    L"39",    L"3a",    L"3b",    L"3c",    L"3d",    L"3e",    L"3f",
    L"40",    L"41",    L"42",    L"43",    L"44",    L"45",    L"46",    L"47",    L"48",    L"49",    L"4a",    L"4b",    L"4c",    L"4d",    L"4e",    L"4f",
    L"50",    L"51",    L"52",    L"53",    L"54",    L"55",    L"56",    L"57",    L"58",    L"59",    L"5a",    L"5b",    L"5c",    L"5d",    L"5e",    L"5f",
    L"60",    L"61",    L"62",    L"63",    L"64",    L"65",    L"66",    L"67",    L"68",    L"69",    L"6a",    L"6b",    L"6c",    L"6d",    L"6e",    L"6f",
    L"70",    L"71",    L"72",    L"73",    L"74",    L"75",    L"76",    L"77",    L"78",    L"79",    L"7a",    L"7b",    L"7c",    L"7d",    L"7e",    L"7f",
    L"80",    L"81",    L"82",    L"83",    L"84",    L"85",    L"86",    L"87",    L"88",    L"89",    L"8a",    L"8b",    L"8c",    L"8d",    L"8e",    L"8f",
    L"90",    L"91",    L"92",    L"93",    L"94",    L"95",    L"96",    L"97",    L"98",    L"99",    L"9a",    L"9b",    L"9c",    L"9d",    L"9e",    L"9f",
    L"a0",    L"a1",    L"a2",    L"a3",    L"a4",    L"a5",    L"a6",    L"a7",    L"a8",    L"a9",    L"aa",    L"ab",    L"ac",    L"ad",    L"ae",    L"af",
    L"b0",    L"b1",    L"b2",    L"b3",    L"b4",    L"b5",    L"b6",    L"b7",    L"b8",    L"b9",    L"ba",    L"bb",    L"bc",    L"bd",    L"be",    L"bf",
    L"c0",    L"c1",    L"c2",    L"c3",    L"c4",    L"c5",    L"c6",    L"c7",    L"c8",    L"c9",    L"ca",    L"cb",    L"cc",    L"cd",    L"ce",    L"cf",
    L"d0",    L"d1",    L"d2",    L"d3",    L"d4",    L"d5",    L"d6",    L"d7",    L"d8",    L"d9",    L"da",    L"db",    L"dc",    L"dd",    L"de",    L"df",
    L"e0",    L"e1",    L"e2",    L"e3",    L"e4",    L"e5",    L"e6",    L"e7",    L"e8",    L"e9",    L"ea",    L"eb",    L"ec",    L"ed",    L"ee",    L"ef",
    L"f0",    L"f1",    L"f2",    L"f3",    L"f4",    L"f5",    L"f6",    L"f7",    L"f8",    L"f9",    L"fa",    L"fb",    L"fc",    L"fd",    L"fe",    L"ff"
};

static eESCAPE kWcharToEscape[256] =
{
  /* 00-0F */ eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eNoESCAPE,            eNoESCAPE,            eESCAPEillegalxml,    eESCAPEillegalxml,    eNoESCAPE,            eESCAPEillegalxml,    eESCAPEillegalxml,
  /* 10-1F */ eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,
  /* 20-2F */ eNoESCAPE,            eNoESCAPE,            eESCAPEquote,         eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eESCAPEamp,           eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,
  /* 30-3F */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eESCAPElt,            eNoESCAPE,            eESCAPEgt,            eNoESCAPE,
  /* 40-4F */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,
  /* 50-5F */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,
  /* 60-6F */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,
  /* 70-7F */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,
  /* 80-8F */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,
  /* 90-9F */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,
  /* A0-AF */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,
  /* B0-BF */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,
  /* C0-CF */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,
  /* D0-DF */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,
  /* E0-EF */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,
  /* F0-FF */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE
};

#define IsSecureMetadata(id,att) (((DWORD)(att) & METADATA_SECURE) != 0)

/***************************************************************************++

Routine Description:

    Gets the bin file name by querying the compiler. The compiler hands out
    the latest valid bin file. Once we get the bin file name from the complier
    we can assume that it is valid until we call release bin file on it.

Arguments:

    [in, optional] Compiler interface
    [out]          Bin file name

Return Value:

    HRESULT

--***************************************************************************/
HRESULT GetBinFile(IMetabaseSchemaCompiler* i_pCompiler,
                   LPWSTR*                  o_wszBinFile)
{
    HRESULT                     hr          = S_OK;
    ULONG                       cch         = 0;
    ISimpleTableDispenser2*     pISTDisp    = NULL;
    IMetabaseSchemaCompiler*    pCompiler   = i_pCompiler;

    *o_wszBinFile = NULL;

    //
    // GetBinFile relies on the fact that SetBinFile has been called at ReadAllData
    // See InitializeIISGlobalsToDefaults
    //

    if(NULL == i_pCompiler)
    {
        //
        // Get a pointer to the compiler to get the bin file name.
        //

        hr = DllGetSimpleObjectByIDEx( eSERVERWIRINGMETA_TableDispenser, IID_ISimpleTableDispenser2, (VOID**)&pISTDisp, WSZ_PRODUCT_IIS );

        if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[ReleaseBinFile] DllGetSimpleObjectByIDEx failed with hr = 0x%x.\n",hr));
            goto exit;
        }

        hr = pISTDisp->QueryInterface(IID_IMetabaseSchemaCompiler,
                                      (LPVOID*)&pCompiler);

        if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[ReleaseBinFile] QueryInterface on compiler failed with hr = 0x%x.\n",hr));
            goto exit;
        }

    }

    hr = pCompiler->GetBinFileName(NULL,
                                   &cch);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[GetBinFile] Unable to get the count of chars in the bin file name. IMetabaseSchemaCompiler::GetBinFileName failed with hr = 0x%x.\n",hr));
        goto exit;
    }

    *o_wszBinFile = new WCHAR[cch+1];
    if(NULL == *o_wszBinFile)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = pCompiler->GetBinFileName(*o_wszBinFile,
                                   &cch);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[GetBinFile] Unable to get the bin file name. IMetabaseSchemaCompiler::GetBinFileName failed with hr = 0x%x.\n",hr));
        goto exit;
    }

    //
    // If there is no bin file, GetBinFileName returns a null string i.e. L""
    //

exit:

    if(NULL != pISTDisp)
    {
        pISTDisp->Release();
    }

    if((NULL == i_pCompiler) && (NULL != pCompiler))
    {
        //
        // We created it - release it.
        //

        pCompiler->Release();
    }

    if(FAILED(hr) && (NULL != *o_wszBinFile))
    {
        delete [] *o_wszBinFile;
        *o_wszBinFile = NULL;

    }

    return hr;

} // GeBinFile


/***************************************************************************++

Routine Description:

    Releases the bin file name by from the compiler. Once release is called
    on the bin file, the compiler releases locks on it, and is free to clean
    it up and we cannot make the assumption that it will be valid.
    The function also release the bin file name, which we assume has been
    allocated in GetBinFile

Arguments:

    [in, optional] Compiler interface
    [in,out]       Bin file name

Return Value:

    HRESULT

--***************************************************************************/
void ReleaseBinFile(IMetabaseSchemaCompiler*    i_pCompiler,
                    LPWSTR*                     io_wszBinFileName)
{
    ISimpleTableDispenser2*     pISTDisp   = NULL;
    IMetabaseSchemaCompiler*    pCompiler  = i_pCompiler;
    HRESULT                     hr         = S_OK;

    if(NULL == *io_wszBinFileName)
    {
        goto exit;
    }

    if(NULL == i_pCompiler)
    {
        //
        // Get a pointer to the compiler to get the bin file name.
        //

        hr = DllGetSimpleObjectByIDEx( eSERVERWIRINGMETA_TableDispenser, IID_ISimpleTableDispenser2, (VOID**)&pISTDisp, WSZ_PRODUCT_IIS );

        if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[ReleaseBinFile] DllGetSimpleObjectByIDEx failed with hr = 0x%x.\n",hr));
            goto exit;
        }

        hr = pISTDisp->QueryInterface(IID_IMetabaseSchemaCompiler,
                                      (LPVOID*)&pCompiler);

        if(FAILED(hr))
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[ReleaseBinFile] QueryInterface on compiler failed with hr = 0x%x.\n",hr));
            goto exit;
        }

    }

    pCompiler->ReleaseBinFileName(*io_wszBinFileName);

exit:

    if(NULL != pISTDisp)
    {
        pISTDisp->Release();
    }

    if((NULL != pCompiler) && (NULL == i_pCompiler))
    {
        //
        // We created it - release it.
        //
        pCompiler->Release();
    }

    if(NULL !=  *io_wszBinFileName)
    {
        delete []   *io_wszBinFileName;
        *io_wszBinFileName = NULL;
    }

    return;

} // ReleaseBinFile


/***************************************************************************++

Routine Description:

    Convert unsigned long to a sting.

Arguments:

    [in]   ULONG to convert to string
    [out]  New stringised ULONG

Return Value:

    HRESULT

--***************************************************************************/
HRESULT UnsignedLongToNewString(ULONG    i_ul,
                                LPWSTR*  o_wszUl)
{
    WCHAR wszBufferDW[40];

    _ultow(i_ul, wszBufferDW, 10);

    *o_wszUl = new WCHAR[wcslen(wszBufferDW)+1];
    if(NULL == *o_wszUl)
    {
        return E_OUTOFMEMORY;
    }
    wcscpy(*o_wszUl, wszBufferDW);

    return S_OK;

} // UnsignedLongToString


/***************************************************************************++

Routine Description:

    Copy String

Arguments:

    [in]   String to copy
    [out]  New string

Return Value:

    HRESULT

--***************************************************************************/
HRESULT StringToNewString(LPWSTR   i_wsz,
                          ULONG    i_cch,
                          LPWSTR*  o_wsz)
{
    ULONG cb  = (i_cch+1)*sizeof(WCHAR);

    *o_wsz = new WCHAR[i_cch+1];
    if(NULL == *o_wsz)
    {
        return E_OUTOFMEMORY;
    }
    memcpy(*o_wsz, i_wsz, cb);

    return S_OK;

} // StringToNewString


/***************************************************************************++

Routine Description:

    Create a new String and NULL terminate it.

Arguments:

    [in]   Count of chars (assume without null terminator)
    [out]  New string

Return Value:

    HRESULT

--***************************************************************************/
HRESULT NewString(ULONG    cch,
                  LPWSTR*  o_wsz)
{
    *o_wsz = new WCHAR[cch+1];
    if(NULL == *o_wsz)
    {
        return E_OUTOFMEMORY;
    }
    **o_wsz = L'\0';

    return S_OK;

} // NewString


/***************************************************************************++

Routine Description:

    Reallocate more buffer for the string and copy old contents.

Arguments:

    [in]       Count of chars to grow (assume without null terminator)
    [in,out]   Current count of chars, gets updated to the new current count.
    [out]      New string with extra allocation

Return Value:

    HRESULT

--***************************************************************************/
HRESULT ReAllocateString(ULONG   i_chhToGrow,
                         ULONG*  io_cchCurrent,
                         LPWSTR* io_wsz)
{
    LPWSTR  wszTemp = NULL;
    ULONG   cch     = *io_cchCurrent + i_chhToGrow;
    HRESULT hr      = S_OK;

    hr = NewString(cch,
                   &wszTemp);

    if(FAILED(hr))
    {
        return hr;
    }

    if(NULL != *io_wsz)
    {
        wcscpy(wszTemp, *io_wsz);
        delete [] (*io_wsz);
    }

    *io_wsz = wszTemp;
    *io_cchCurrent = cch;

    return S_OK;

} // ReAllocateString


/***************************************************************************++

Routine Description:

    Constructor for CWriterGlobalHelper

Arguments:

    None

Return Value:

    None

--***************************************************************************/
CWriterGlobalHelper::CWriterGlobalHelper()
{
    m_pISTTagMetaByTableAndColumnIndexAndName   = NULL;
    m_pISTTagMetaByTableAndColumnIndexAndValue  = NULL;
    m_pISTTagMetaByTableAndColumnIndex          = NULL;
    m_pISTTagMetaByTableAndID                   = NULL;
    m_pISTTagMetaByTableAndName                 = NULL;
    m_pISTColumnMeta                            = NULL;
    m_pISTColumnMetaByTableAndID                = NULL;
    m_pISTColumnMetaByTableAndName              = NULL;
    m_pISTTableMetaForMetabaseTables            = NULL;
    m_cColKeyTypeMetaData                       = cCOLUMNMETA_NumberOfColumns;
    m_wszTABLE_IIsConfigObject                  = wszTABLE_IIsConfigObject;
    m_wszTABLE_MBProperty                       = wszTABLE_MBProperty;
    m_iStartRowForAttributes                    = -1;
    m_wszBinFileForMeta                         = NULL;
    m_cchBinFileForMeta                         = 0;
    m_wszIIS_MD_UT_SERVER                       = NULL;
    m_cchIIS_MD_UT_SERVER                       = 0;
    m_wszIIS_MD_UT_FILE                         = NULL;
    m_cchIIS_MD_UT_FILE                         = 0;
    m_wszIIS_MD_UT_WAM                          = NULL;
    m_cchIIS_MD_UT_WAM                          = 0;
    m_wszASP_MD_UT_APP                          = NULL;
    m_cchASP_MD_UT_APP                          = 0;

} // Constructor


/***************************************************************************++

Routine Description:

    Destructor for CWriterGlobalHelper

Arguments:

    None

Return Value:

    None

--***************************************************************************/
CWriterGlobalHelper::~CWriterGlobalHelper()
{
    if(NULL != m_pISTTagMetaByTableAndColumnIndexAndName)
    {
        m_pISTTagMetaByTableAndColumnIndexAndName->Release();
        m_pISTTagMetaByTableAndColumnIndexAndName = NULL;
    }
    if(NULL != m_pISTTagMetaByTableAndColumnIndexAndValue)
    {
        m_pISTTagMetaByTableAndColumnIndexAndValue->Release();
        m_pISTTagMetaByTableAndColumnIndexAndValue = NULL;
    }
    if(NULL != m_pISTTagMetaByTableAndColumnIndex)
    {
        m_pISTTagMetaByTableAndColumnIndex->Release();
        m_pISTTagMetaByTableAndColumnIndex = NULL;
    }
    if(NULL != m_pISTTagMetaByTableAndID)
    {
        m_pISTTagMetaByTableAndID->Release();
        m_pISTTagMetaByTableAndID = NULL;
    }
    if(NULL != m_pISTTagMetaByTableAndName)
    {
        m_pISTTagMetaByTableAndName->Release();
        m_pISTTagMetaByTableAndName = NULL;
    }
    if(NULL != m_pISTColumnMeta)
    {
        m_pISTColumnMeta->Release();
        m_pISTColumnMeta = NULL;
    }
    if(NULL != m_pISTColumnMetaByTableAndID)
    {
        m_pISTColumnMetaByTableAndID->Release();
        m_pISTColumnMetaByTableAndID = NULL;
    }
    if(NULL != m_pISTColumnMetaByTableAndName)
    {
        m_pISTColumnMetaByTableAndName->Release();
        m_pISTColumnMetaByTableAndName = NULL;
    }
    if(NULL != m_pISTTableMetaForMetabaseTables)
    {
        m_pISTTableMetaForMetabaseTables->Release();
        m_pISTTableMetaForMetabaseTables = NULL;
    }
    if(NULL != m_wszBinFileForMeta)
    {
        ReleaseBinFile(NULL,
                       &m_wszBinFileForMeta);
    }
    if(NULL != m_wszIIS_MD_UT_SERVER)
    {
        delete [] m_wszIIS_MD_UT_SERVER;
        m_wszIIS_MD_UT_SERVER           = NULL;
    }
    m_cchIIS_MD_UT_SERVER               = 0;
    if(NULL != m_wszIIS_MD_UT_FILE)
    {
        delete [] m_wszIIS_MD_UT_FILE;
        m_wszIIS_MD_UT_FILE             = NULL;
    }
    m_cchIIS_MD_UT_FILE                 = 0;
    if(NULL != m_wszIIS_MD_UT_WAM)
    {
        delete [] m_wszIIS_MD_UT_WAM;
        m_wszIIS_MD_UT_WAM              = NULL;
    }
    m_cchIIS_MD_UT_WAM                  = 0;
    if(NULL != m_wszASP_MD_UT_APP)
    {
        delete [] m_wszASP_MD_UT_APP;
        m_wszASP_MD_UT_APP              = NULL;
    }
    m_cchASP_MD_UT_APP                  = 0;

} // Destructor


/***************************************************************************++

Routine Description:

    Initializes the object with all the metatable ISTs that are needed during
    write.

Arguments:

    [in]   Bool indicating if we should fail if the bin file is absent.
           There are some scenarios in which we can tolerate this, and some
           where we dont - hence the distinction.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriterGlobalHelper::InitializeGlobals(BOOL i_bFailIfBinFileAbsent)
{
    ISimpleTableDispenser2* pISTDisp      = NULL;
    HRESULT                 hr            = S_OK;
    STQueryCell             Query[2];
    ULONG                   cCell         = sizeof(Query)/sizeof(STQueryCell);
    ULONG                   iStartRow     = 0;
    DWORD                   dwKeyTypeID   = MD_KEY_TYPE;
    ULONG                   aColSearch [] = {iCOLUMNMETA_Table,
                                             iCOLUMNMETA_ID
                                            };
    ULONG                   cColSearch    = sizeof(aColSearch)/sizeof(ULONG);
    ULONG                   iRow          = 0;
    ULONG                   iCol          = iMBProperty_Attributes;
    LPVOID                  apvSearch[cCOLUMNMETA_NumberOfColumns];
    ULONG                   aColSearchFlags[] = {iTAGMETA_Table,
                                                 iTAGMETA_ColumnIndex
    };
    ULONG                   cColSearchFlags = sizeof(aColSearchFlags)/sizeof(ULONG);
    LPVOID                  apvSearchFlags[cTAGMETA_NumberOfColumns];
    apvSearchFlags[iTAGMETA_ColumnIndex] = (LPVOID)&iCol;

    //
    // Save the bin file name
    //

    hr = GetBinFile(NULL,
                    &m_wszBinFileForMeta);

    if(FAILED(hr))
    {
        DBGINFOW((DBG_CONTEXT,
                 L"[InitializeGlobals] Unable to get the the bin file name. GetBinFileName failed with hr = 0x%x.\n",
                 hr));
        goto exit;
    }

    if(( i_bFailIfBinFileAbsent)  &&
       ((NULL == m_wszBinFileForMeta) || (0 == *m_wszBinFileForMeta))
      )
    {
        DBGINFOW((DBG_CONTEXT,
                 L"[InitializeGlobals] Expected to find a valid schema bin file. GetBinFileName returned a null file name. Bin file is either invalid or not found.\n"));

        hr = HRESULT_FROM_WIN32(ERROR_FILE_INVALID);
        goto exit;
    }

    //
    // Get the dispenser
    //

    hr = DllGetSimpleObjectByIDEx( eSERVERWIRINGMETA_TableDispenser, IID_ISimpleTableDispenser2, (VOID**)&pISTDisp, WSZ_PRODUCT_IIS );

    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // Initialize the in file name in the query.
    //

    Query[0].pData     = (LPVOID)m_wszBinFileForMeta;
    Query[0].eOperator = eST_OP_EQUAL;
    Query[0].iCell     = iST_CELL_FILE;
    Query[0].dbType    = DBTYPE_WSTR;
    Query[0].cbSize    = m_cchBinFileForMeta*sizeof(WCHAR);

    //
    // m_pISTTableMetaForMetabaseTables
    // Save pointer to tablemeta for all tables in the metabase database.
    // This is used for fetching tablemeta of a table from the metabase
    // database, given its internal name.
    //

    DBGINFOW((DBG_CONTEXT,
              L"[InitializeGlobals] Reading table: %s with hint %s from file: %s.\n",
              wszTABLE_COLUMNMETA,
              g_wszByID,
              m_wszBinFileForMeta));

    Query[1].pData      = (void*)wszDATABASE_METABASE;
    Query[1].eOperator  = eST_OP_EQUAL;
    Query[1].iCell      = iTABLEMETA_Database;
    Query[1].dbType     = DBTYPE_WSTR;
    Query[1].cbSize     = 0;

    hr = pISTDisp->GetTable(wszDATABASE_META,
                            wszTABLE_TABLEMETA,
                            (LPVOID)Query,
                            (LPVOID)&cCell,
                            eST_QUERYFORMAT_CELLS,
                            0,
                            (LPVOID*)&m_pISTTableMetaForMetabaseTables);

    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // Fetch the internal pointers to relevant table names. This is a perf
    // optimization. When you use internal pointers to strings in
    // GetRowIndexBySearch, then you avoid a string compare
    //

    hr = GetInternalTableName(pISTDisp,
                              wszTABLE_IIsConfigObject,
                              &m_wszTABLE_IIsConfigObject);

    if(FAILED(hr))
    {
        goto exit;
    }

    hr = GetInternalTableName(pISTDisp,
                              wszTABLE_MBProperty,
                              &m_wszTABLE_MBProperty);

    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // m_pISTTagMetaByTableAndColumnIndexAndName
    // Save pointer to TagMeta table with ByTableAndColumnIndexAndName index hint.
    // This is used for fetching tagmeta of a tag, given its tagname, columnindex
    // and table.
    //

    DBGINFOW((DBG_CONTEXT,
              L"[InitializeGlobals] Reading table: %s with hint %s from file: %s.\n",
              wszTABLE_TAGMETA,
              g_wszByTableAndColumnIndexAndNameOnly,
              m_wszBinFileForMeta));

    Query[1].pData      = (void*)g_wszByTableAndColumnIndexAndNameOnly;
    Query[1].eOperator  = eST_OP_EQUAL;
    Query[1].iCell      = iST_CELL_INDEXHINT;
    Query[1].dbType     = DBTYPE_WSTR;
    Query[1].cbSize     = 0;

    hr = pISTDisp->GetTable(wszDATABASE_META,
                            wszTABLE_TAGMETA,
                            (LPVOID)Query,
                            (LPVOID)&cCell,
                            eST_QUERYFORMAT_CELLS,
                            0,
                            (LPVOID*)&m_pISTTagMetaByTableAndColumnIndexAndName);

    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // m_pISTTagMetaByTableAndColumnIndexAndValue
    // Save pointer to TagMeta table with ByTableAndColumnIndexAndValue index hint.
    // This is used for fetching tagmeta of a tag, given its value, columnindex
    // and table.
    //

    DBGINFOW((DBG_CONTEXT,
              L"[InitializeGlobals] Reading table: %s with hint %s from file: %s.\n",
              wszTABLE_TAGMETA,
              g_wszByTableAndColumnIndexAndValueOnly,
              m_wszBinFileForMeta));


    Query[1].pData      = (void*)g_wszByTableAndColumnIndexAndValueOnly;
    Query[1].eOperator  = eST_OP_EQUAL;
    Query[1].iCell      = iST_CELL_INDEXHINT;
    Query[1].dbType     = DBTYPE_WSTR;
    Query[1].cbSize     = 0;

    hr = pISTDisp->GetTable(wszDATABASE_META,
                            wszTABLE_TAGMETA,
                            (LPVOID)Query,
                            (LPVOID)&cCell,
                            eST_QUERYFORMAT_CELLS,
                            0,
                            (LPVOID*)&m_pISTTagMetaByTableAndColumnIndexAndValue);

    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // m_pISTTagMetaByTableAndColumnIndex
    // Save pointer to TagMeta table with ByTableAndColumnIndex index hint.
    // This is used for fetching tagmeta for all tags of a column, given
    // columnindex and table.
    //

    DBGINFOW((DBG_CONTEXT,
              L"[InitializeGlobals] Reading table: %s with hint %s from file: %s.\n",
              wszTABLE_TAGMETA,
              g_wszByTableAndColumnIndexOnly,
              m_wszBinFileForMeta));


    Query[1].pData      = (void*)g_wszByTableAndColumnIndexOnly;
    Query[1].eOperator  = eST_OP_EQUAL;
    Query[1].iCell      = iST_CELL_INDEXHINT;
    Query[1].dbType     = DBTYPE_WSTR;
    Query[1].cbSize     = 0;

    hr = pISTDisp->GetTable(wszDATABASE_META,
                            wszTABLE_TAGMETA,
                            (LPVOID)Query,
                            (LPVOID)&cCell,
                            eST_QUERYFORMAT_CELLS,
                            0,
                            (LPVOID*)&m_pISTTagMetaByTableAndColumnIndex);

    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // m_pISTTagMetaByTableAndID
    // Save pointer to TagMeta table with ByTableAndColumnIndex index hint.
    // This is used for fetching tagmeta for a tag, given the table and
    // metabase tag ID. The assumption here is that the tag ID is unique
    // for every tag in a table.
    //

    Query[1].pData      = (void*)g_wszByTableAndTagIDOnly;
    Query[1].eOperator  = eST_OP_EQUAL;
    Query[1].iCell      = iST_CELL_INDEXHINT;
    Query[1].dbType     = DBTYPE_WSTR;
    Query[1].cbSize     = 0;

    hr = pISTDisp->GetTable(wszDATABASE_META,
                            wszTABLE_TAGMETA,
                            (LPVOID)Query,
                            (LPVOID)&cCell,
                            eST_QUERYFORMAT_CELLS,
                            0,
                            (LPVOID*)&m_pISTTagMetaByTableAndID);

    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // m_pISTTagMetaByTableAndName
    // Save pointer to TagMeta table with ByTableAndTagName index hint.
    // This is used for fetching tagmeta for a tag, given the table and
    // tag name. The Asumption here is that the tagname is unique
    // for every tag in a table.
    //

    Query[1].pData      = (void*)g_wszByTableAndTagNameOnly;
    Query[1].eOperator  = eST_OP_EQUAL;
    Query[1].iCell      = iST_CELL_INDEXHINT;
    Query[1].dbType     = DBTYPE_WSTR;
    Query[1].cbSize     = 0;

    hr = pISTDisp->GetTable(wszDATABASE_META,
                            wszTABLE_TAGMETA,
                            (LPVOID)Query,
                            (LPVOID)&cCell,
                            eST_QUERYFORMAT_CELLS,
                            0,
                            (LPVOID*)&m_pISTTagMetaByTableAndName);
    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // m_pISTColumnMeta
    // This is used for:
    // A. Fetching columnmeta of a given table - Using GetRowIndexByIndentity with table name, starting with index 0.
    // B. Getting columnmeta of a given table + column index - Using GetRowIndexByIndentity with table name and index.
    //

    cCell = cCell-1;

    hr = pISTDisp->GetTable(wszDATABASE_META,
                            wszTABLE_COLUMNMETA,
                            (LPVOID)Query,
                            (LPVOID)&cCell,
                            eST_QUERYFORMAT_CELLS,
                            0,
                            (LPVOID*)&m_pISTColumnMeta);

    cCell = cCell+1;

    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // m_pISTColumnMetaByTableAndID
    // Save pointer to ColumnMeta table with ByTableAndID index hint.
    // This is used for fetching columnmeta of a column, given its metabase id.
    //

    DBGINFOW((DBG_CONTEXT,
              L"[InitializeGlobals] Reading table: %s with hint %s from file: %s.\n",
              wszTABLE_COLUMNMETA,
              g_wszByID,
              m_wszBinFileForMeta));

    Query[1].pData      = (void*)g_wszByID;
    Query[1].eOperator  = eST_OP_EQUAL;
    Query[1].iCell      = iST_CELL_INDEXHINT;
    Query[1].dbType     = DBTYPE_WSTR;
    Query[1].cbSize     = 0;

    hr = pISTDisp->GetTable(wszDATABASE_META,
                            wszTABLE_COLUMNMETA,
                            (LPVOID)Query,
                            (LPVOID)&cCell,
                            eST_QUERYFORMAT_CELLS,
                            0,
                            (LPVOID*)&m_pISTColumnMetaByTableAndID);

    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // m_pISTColumnMetaByTableAndName
    // Save pointer to ColumnMeta table with ByTableAndName index hint.
    // This is used for fetching columnmeta of a column, given its internal
    // name and the table to which it belongs.
    //

    DBGINFOW((DBG_CONTEXT,
              L"[InitializeGlobals] Reading table: %s with hint %s from file: %s.\n",
              wszTABLE_COLUMNMETA,
              g_wszByID,
              m_wszBinFileForMeta));

    Query[1].pData      = (void*)g_wszByName;
    Query[1].eOperator  = eST_OP_EQUAL;
    Query[1].iCell      = iST_CELL_INDEXHINT;
    Query[1].dbType     = DBTYPE_WSTR;
    Query[1].cbSize     = 0;

    hr = pISTDisp->GetTable(wszDATABASE_META,
                            wszTABLE_COLUMNMETA,
                            (LPVOID)Query,
                            (LPVOID)&cCell,
                            eST_QUERYFORMAT_CELLS,
                            0,
                            (LPVOID*)&m_pISTColumnMetaByTableAndName);

    if(FAILED(hr))
    {
        goto exit;
    }


    //
    // Save meta information about the KeyType property.
    //

    apvSearch[iCOLUMNMETA_Table] = (LPVOID)m_wszTABLE_IIsConfigObject;
    apvSearch[iCOLUMNMETA_ID] = (LPVOID)&dwKeyTypeID;

    hr = m_pISTColumnMetaByTableAndID->GetRowIndexBySearch(iStartRow,
                                                           cColSearch,
                                                           aColSearch,
                                                           NULL,
                                                           apvSearch,
                                                           &iRow);

    if(FAILED(hr))
    {
        goto exit;
    }


    hr = m_pISTColumnMetaByTableAndID->GetColumnValues(iRow,
                                                       m_cColKeyTypeMetaData,
                                                       NULL,
                                                       NULL,
                                                       m_apvKeyTypeMetaData);

    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // Save start row index in tagmeta table for the attributes column
    // in MBproperty table.
    //

    apvSearchFlags[iTAGMETA_Table] = m_wszTABLE_MBProperty;

    hr = m_pISTTagMetaByTableAndColumnIndex->GetRowIndexBySearch(iStartRow,
                                                                 cColSearchFlags,
                                                                 aColSearchFlags,
                                                                 NULL,
                                                                 apvSearchFlags,
                                                                 (ULONG*)&m_iStartRowForAttributes);

    if(FAILED(hr))
    {
        goto exit;
    }

exit:

    if(NULL != pISTDisp)
    {
        pISTDisp->Release();
        pISTDisp = NULL;
    }

    return hr;



} // CWriterGlobalHelper::InitializeGlobals


/***************************************************************************++

Routine Description:

    This function gets pointers to the internal table names so that it can be
    used as part of queries later on. The advantage of getting an internal
    pointer is the fact that Stephen does a pointer comapare instead of
    string compare.

Arguments:

    [in]   Dispenser
    [in]   Table name
    [out]  Internal pointer to table name

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriterGlobalHelper::GetInternalTableName(ISimpleTableDispenser2*  ,
                                                  LPCWSTR                  i_wszTableName,
                                                  LPWSTR*                  o_wszInternalTableName)
{
    HRESULT               hr            = S_OK;
    ULONG                 iCol          = iTABLEMETA_InternalName;
    ULONG                 iRow          = 0;

    if(NULL == m_pISTTableMetaForMetabaseTables)
    {
        return E_INVALIDARG;
    }

    DBGINFOW((DBG_CONTEXT,
              L"[GetInternalTableName] Reading table: %s from file: %s.\n",
              wszTABLE_TABLEMETA,
              m_wszBinFileForMeta));


    if(FAILED(hr))
    {
        return hr;
    }

    hr = m_pISTTableMetaForMetabaseTables->GetRowIndexByIdentity(NULL,
                                                                (LPVOID*)&i_wszTableName,
                                                                &iRow);

    if(FAILED(hr))
    {
        return hr;
    }

    hr = m_pISTTableMetaForMetabaseTables->GetColumnValues(iRow,
                                                           1,
                                                           &iCol,
                                                           NULL,
                                                           (LPVOID*)o_wszInternalTableName);

    if(FAILED(hr))
    {
        return hr;
    }

    return hr;

} // CWriterGlobalHelper::GetInternalTableName


/***************************************************************************++

Routine Description:

    This function converts a given flag value to its string representation.
    The flags bits are delimited by | and if we encounter an unknown bit/bits
    we just spit out a stringized ULONG.

    Eg: dwValue == 3  => ACCESS_READ | ACCESS_WRITE
        dwValue == 88 => 88

Arguments:

    [in]   flag numeric value
    [out]  String representation for the flag
    [in]  Meta table name to search for flag meta
    [in]  Meta table column to search for flag meta

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriterGlobalHelper::FlagToString(DWORD      dwValue,
                                          LPWSTR*    pwszData,
                                          LPWSTR     wszTable,
                                          ULONG      iColFlag)
{
    HRESULT hr         = S_OK;
    ULONG   iStartRow  = 0;
    ULONG   iRow       = 0;
    ULONG   iCol       = 0;
    LPWSTR  wszFlag    = NULL;

    ULONG   aCol[]     = {iTAGMETA_Value,
                          iTAGMETA_InternalName,
                          iTAGMETA_Table,
                          iTAGMETA_ColumnIndex
                         };
    ULONG   cCol       = sizeof(aCol)/sizeof(ULONG);
    LPVOID  apv[cTAGMETA_NumberOfColumns];
    LPVOID  apvIdentity [] = {(LPVOID)wszTable,
                              (LPVOID)&iColFlag
    };
    ULONG   iColFlagMask = iCOLUMNMETA_FlagMask;
    DWORD*  pdwFlagMask = NULL;

    DWORD   dwZero = 0;
    ULONG   aColSearchByValue[] = {iTAGMETA_Table,
                                   iTAGMETA_ColumnIndex,
                                   iTAGMETA_Value
    };
    ULONG   cColSearchByValue = sizeof(aColSearchByValue)/sizeof(ULONG);
    LPVOID  apvSearchByValue[cTAGMETA_NumberOfColumns];
    apvSearchByValue[iTAGMETA_Table]       = (LPVOID)wszTable;
    apvSearchByValue[iTAGMETA_ColumnIndex] = (LPVOID)&iColFlag;
    apvSearchByValue[iTAGMETA_Value]       = (LPVOID)&dwZero;


    //
    // Make one pass and compute all flag values for this property.
    //

    hr = m_pISTColumnMeta->GetRowIndexByIdentity(NULL,
                                                 apvIdentity,
                                                 &iRow);

    if(SUCCEEDED(hr))
    {
        hr = m_pISTColumnMeta->GetColumnValues(iRow,
                                               1,
                                               &iColFlagMask,
                                               NULL,
                                               (LPVOID*)&pdwFlagMask);

        if(FAILED(hr))
        {
            return hr;
        }
    }
    else if(E_ST_NOMOREROWS != hr)
    {
        return hr;
    }

    if((E_ST_NOMOREROWS == hr) ||
       (0 != (dwValue & (~(dwValue & (*pdwFlagMask))))))
    {
        //
        //  There was no mask associated with this property, or there are one
        //  or more unknown bits set. Spit out a regular number.
        //

        return UnsignedLongToNewString(dwValue,
                                       pwszData);

    }
    else if(0 == dwValue)
    {
        //
        // See if there is a flag with 0 as its value.
        //

        hr = m_pISTTagMetaByTableAndColumnIndexAndValue->GetRowIndexBySearch(iStartRow,
                                                                             cColSearchByValue,
                                                                             aColSearchByValue,
                                                                             NULL,
                                                                             apvSearchByValue,
                                                                             &iRow);

        if(E_ST_NOMOREROWS == hr)
        {
            //
            // There was no flag associated with the value zero. Spit out a
            // regular number
            //

            return UnsignedLongToNewString(dwValue,
                                           pwszData);

        }
        else if(FAILED(hr))
        {
            return hr;
        }
        else
        {
            iCol = iTAGMETA_InternalName;

            hr = m_pISTTagMetaByTableAndColumnIndexAndValue->GetColumnValues(iRow,
                                                                             1,
                                                                             &iCol,
                                                                             NULL,
                                                                             (LPVOID*)&wszFlag);
            if(FAILED(hr))
            {
                return hr;
            }

            return StringToNewString(wszFlag,
                                     (ULONG)wcslen(wszFlag),
                                     pwszData);

        }
    }
    else
    {
        //
        // Make another pass, and convert flag to string.
        //

        ULONG  cchMaxFlagString  = MAX_FLAG_STRING_CHARS;
        LPWSTR wszExtension      = L" | ";
        ULONG  cchExtension      = (ULONG)wcslen(wszExtension);
        ULONG  cchFlagStringUsed = 0;

        hr = NewString(cchMaxFlagString,
                       pwszData);

        if(FAILED(hr))
        {
            return hr;
        }

        hr = GetStartRowIndex(wszTable,
                              iColFlag,
                              &iStartRow);

        if(FAILED(hr) || (iStartRow == -1))
        {
            return hr;
        }

        for(iRow=iStartRow;;iRow++)
        {
            hr = m_pISTTagMetaByTableAndColumnIndex->GetColumnValues(iRow,
                                                                     cCol,
                                                                     aCol,
                                                                     NULL,
                                                                     apv);
            if((dwValue  == 0)         ||
               (E_ST_NOMOREROWS == hr) ||
               (iColFlag != *(DWORD*)apv[iTAGMETA_ColumnIndex]) ||
               (0 != wcscmp(wszTable, (LPWSTR)apv[iTAGMETA_Table])) // OK to do case sensitive compare because all callers pass well known table names
              )
            {
                hr = S_OK;
                break;
            }
            else if(FAILED(hr))
            {
                return hr;
            }

            if(0 != (dwValue & (*(DWORD*)apv[iTAGMETA_Value])))
            {
                ULONG strlen = (ULONG)wcslen((LPWSTR)apv[iTAGMETA_InternalName]);

                if(cchFlagStringUsed + cchExtension + strlen > cchMaxFlagString)
                {
                    hr = ReAllocateString(MAX_FLAG_STRING_CHARS + cchExtension + strlen,
                                          &cchMaxFlagString,
                                          pwszData);

                    if(FAILED(hr))
                    {
                        return hr;
                    }

                }

                if(**pwszData != 0)
                {
                    wcscat(*pwszData, wszExtension);
                    cchFlagStringUsed = cchFlagStringUsed + cchExtension;
                }

                wcscat(*pwszData, (LPWSTR)apv[iTAGMETA_InternalName]);
                cchFlagStringUsed = cchFlagStringUsed + strlen;

                //
                // Clear out that bit
                //

                dwValue = dwValue & (~(*(DWORD*)apv[iTAGMETA_Value]));
            }

        } // End for

    }

    return S_OK;

} // CWriterGlobalHelper::FlagToString


/***************************************************************************++

Routine Description:

    This function converts a given enum value to its string representation.
    If we encounter an unknown bit/bits we just spit out a stringized ULONG.

    Eg: dwValue == 101  => IIS_MD_UT_SERVER
        dwValue == 88 => 88

Arguments:

    [in]   Enum numeric value
    [out]  String representation for the flag
    [in]  Meta table name to search for flag meta
    [in]  Meta table column to search for flag meta

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriterGlobalHelper::EnumToString(DWORD      dwValue,
                                          LPWSTR*    pwszData,
                                          LPWSTR     wszTable,
                                          ULONG      iColEnum)
{

    HRESULT hr             = S_OK;
    ULONG   iStartRow      = 0;
    ULONG   iRow           = 0;
    ULONG   iColEnumString = iTAGMETA_InternalName;
    LPWSTR  wszEnum        = NULL;
    ULONG   aColSearch[]   = {iTAGMETA_Table,
                              iTAGMETA_ColumnIndex,
                              iTAGMETA_Value};
    ULONG   cColSearch     = sizeof(aColSearch)/sizeof(ULONG);
    LPVOID  apvSearch[cTAGMETA_NumberOfColumns];
    apvSearch[iTAGMETA_Table]       = (LPVOID)wszTable;
    apvSearch[iTAGMETA_ColumnIndex] = (LPVOID)&iColEnum;
    apvSearch[iTAGMETA_Value]       = (LPVOID)&dwValue;


    hr = m_pISTTagMetaByTableAndColumnIndexAndValue->GetRowIndexBySearch(iStartRow,
                                                                         cColSearch,
                                                                         aColSearch,
                                                                         NULL,
                                                                         apvSearch,
                                                                         &iRow);

    if(E_ST_NOMOREROWS == hr)
    {
        //
        // Convert to a number
        //
        WCHAR   wszBufferDW[20];
        _ultow(dwValue, wszBufferDW, 10);
        *pwszData = new WCHAR[wcslen(wszBufferDW)+1];
        if(NULL == *pwszData)
        {
            return E_OUTOFMEMORY;
        }
        wcscpy(*pwszData, wszBufferDW);
        return S_OK;

    }
    else if(FAILED(hr))
    {
        return hr;
    }
    else
    {
        hr = m_pISTTagMetaByTableAndColumnIndexAndValue->GetColumnValues(iRow,
                                                                         1,
                                                                         &iColEnumString,
                                                                         NULL,
                                                                         (LPVOID*)&wszEnum);
        if(FAILED(hr))
        {
            return hr;
        }

        *pwszData = new WCHAR[wcslen(wszEnum)+1];
        if(NULL == *pwszData)
        {
            return E_OUTOFMEMORY;
        }
        wcscpy(*pwszData, wszEnum);
    }

    return S_OK;

} // CWiterGlobalHelper::EnumToString


/***************************************************************************++

Routine Description:

    This function converts a given data value to its string representation,
    taking into account the type of the data.

Arguments:

    [in]   Pointer to data
    [in]   Count of bytes of data
    [in]   Metabase id of the property
    [in]   Type of the property
    [in]   Attibutes of the property
    [out]  String representation of the value.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriterGlobalHelper::ToString(PBYTE   pbData,
                                      DWORD   cbData,
                                      DWORD   dwIdentifier,
                                      DWORD   dwDataType,
                                      DWORD   dwAttributes,
                                      LPWSTR* pwszData)
{
    HRESULT hr              = S_OK;
    ULONG   i               = 0;
    WCHAR*  wszTemp         = NULL;
    BYTE*   a_Bytes         = NULL;
    WCHAR*  wszMultisz      = NULL;
    ULONG   cMultisz        = 0;
    ULONG   cchMultisz      = 0;
    ULONG   cchBuffer       = 0;
    ULONG   cchSubsz        = 0;
    DWORD   dwValue         = 0;
    ULONG   aColSearch[]    = {iCOLUMNMETA_Table,
                               iCOLUMNMETA_ID
                              };
    ULONG   cColSearch      = sizeof(aColSearch)/sizeof(ULONG);
    LPVOID  apvSearch[cCOLUMNMETA_NumberOfColumns];
    apvSearch[iCOLUMNMETA_Table] = (LPVOID)m_wszTABLE_IIsConfigObject;
    apvSearch[iCOLUMNMETA_ID] = (LPVOID)&dwIdentifier;

    ULONG   iRow            = 0;
    ULONG   iStartRow       = 0;
    LPWSTR  wszEscaped      = NULL;
    ULONG   cchEscaped      = 0;
    BOOL    bEscaped        = FALSE;

    *pwszData = NULL;

    if(NULL == pbData)
    {
        goto exit;
    }

    if(IsSecureMetadata(dwIdentifier, dwAttributes))
    {
        dwDataType = BINARY_METADATA;
    }

    switch(dwDataType)
    {
        case BINARY_METADATA:

            //
            // Each byte is represented by 2 chars.
            //

            hr  = NewString(cbData*2,
                            pwszData);

            if(FAILED(hr))
            {
                goto exit;
            }

            wszTemp         = *pwszData;
            a_Bytes         = (BYTE*)(pbData);

            for(i=0; i<cbData; i++)
            {
                wszTemp[0] = kByteToWchar[a_Bytes[i]][0];
                wszTemp[1] = kByteToWchar[a_Bytes[i]][1];
                wszTemp += 2;
            }

            *wszTemp    = 0; // Add the terminating NULL

            break;

        case DWORD_METADATA :

            //
            // Currently we convert only to decimal, because the XML interceptor
            // does not support reading hex.
            //

            dwValue = *(DWORD*)(pbData);

            //
            // First check to see if it is a flag or bool type.
            //

            hr = m_pISTColumnMetaByTableAndID->GetRowIndexBySearch(iStartRow,
                                                                   cColSearch,
                                                                   aColSearch,
                                                                   NULL,
                                                                   apvSearch,
                                                                   &iRow);

            if(SUCCEEDED(hr))
            {
                ULONG  aCol [] = {iCOLUMNMETA_Index,
                                 iCOLUMNMETA_MetaFlags
                                };
                ULONG  cCol = sizeof(aCol)/sizeof(ULONG);
                LPVOID apv[cCOLUMNMETA_NumberOfColumns];

                hr = m_pISTColumnMetaByTableAndID->GetColumnValues(iRow,
                                                                   cCol,
                                                                   aCol,
                                                                   NULL,
                                                                   apv);

                if(FAILED(hr))
                {
                    goto exit;
                }

                if(0 != (fCOLUMNMETA_FLAG & (*(DWORD*)apv[iCOLUMNMETA_MetaFlags])))
                {
                    //
                    // This is a flag property convert it.
                    //

                    hr = FlagToString(dwValue,
                                      pwszData,
                                      m_wszTABLE_IIsConfigObject,
                                      *(ULONG*)apv[iCOLUMNMETA_Index]);

                    goto exit;
                }
                else if(0 != (fCOLUMNMETA_BOOL & (*(DWORD*)apv[iCOLUMNMETA_MetaFlags])))
                {
                    //
                    // This is a bool property
                    //

                    hr = BoolToString(dwValue,
                                      pwszData);

                    goto exit;
                }

            }
            else if((E_ST_NOMOREROWS != hr) && FAILED(hr))
            {
                goto exit;
            }

            hr = UnsignedLongToNewString(dwValue,
                                         pwszData);

            if(FAILED(hr))
            {
                goto exit;
            }

            break;

        case MULTISZ_METADATA :

            //
            // Count the number of multisz
            //

            wszMultisz = (WCHAR*)(pbData);
            cchSubsz   = (ULONG)wcslen(wszMultisz);

            hr = EscapeString(wszMultisz,
                              cchSubsz,
                              &bEscaped,
                              &wszEscaped,
                              &cchEscaped);

            if(FAILED(hr))
            {
                goto exit;
            }

            cMultisz++;
            cchMultisz = cchMultisz + cchEscaped;
            wszMultisz = wszMultisz + cchSubsz + 1;

            while((0 != *wszMultisz) && ((BYTE*)wszMultisz < (pbData + cbData)))
            {

                if(bEscaped && (NULL != wszEscaped))    // reset for next string in multisz
                {
                    delete [] wszEscaped;
                    wszEscaped = NULL;
                    bEscaped = FALSE;
                }

                cchSubsz   = (ULONG)wcslen(wszMultisz);

                hr = EscapeString(wszMultisz,
                                  cchSubsz,
                                  &bEscaped,
                                  &wszEscaped,
                                  &cchEscaped);

                if(FAILED(hr))
                {
                    goto exit;
                }

                cMultisz++;
                cchMultisz = cchMultisz + cchEscaped;
                wszMultisz = wszMultisz + cchSubsz + 1;
            }

            cchBuffer = cchMultisz + (5*(cMultisz-1)) + 1;    // (5*(cMultisz-1) => \r\n\t\t\t.

            //
            // Allocate new string
            //

            hr = NewString(cchBuffer,
                           pwszData);

            if(FAILED(hr))
            {
                goto exit;
            }

            //
            // Create the string
            //

            wszMultisz = (WCHAR*)(pbData);
            cchSubsz   = (ULONG)wcslen(wszMultisz);
            wszTemp = *pwszData;

            hr = EscapeString(wszMultisz,
                              cchSubsz,
                              &bEscaped,
                              &wszEscaped,
                              &cchEscaped);

            if(FAILED(hr))
            {
                goto exit;
            }

//          wcscat(wszTemp, wszEscaped);
            memcpy(wszTemp, wszEscaped, (cchEscaped*sizeof(WCHAR)));
            wszTemp = wszTemp + cchEscaped;
            *wszTemp = L'\0';
            wszMultisz = wszMultisz + cchSubsz + 1;

            while((0 != *wszMultisz) && ((BYTE*)wszMultisz < (pbData + cbData)))
            {
//              wcscat(wszTemp, L"\r\n\t\t\t");
                memcpy(wszTemp, g_wszMultiszSeperator, (g_cchMultiszSeperator*sizeof(WCHAR)));
                wszTemp = wszTemp + g_cchMultiszSeperator;
                *wszTemp = L'\0';

                if(bEscaped && (NULL != wszEscaped))    // reset for next string in multisz
                {
                    delete [] wszEscaped;
                    wszEscaped = NULL;
                    bEscaped = FALSE;
                }

                cchSubsz   = (ULONG)wcslen(wszMultisz);

                hr = EscapeString(wszMultisz,
                                  cchSubsz,
                                  &bEscaped,
                                  &wszEscaped,
                                  &cchEscaped);

                if(FAILED(hr))
                {
                    goto exit;
                }

//              wcscat(wszTemp, wszEscaped);
                memcpy(wszTemp, wszEscaped, (cchEscaped*sizeof(WCHAR)));
                wszTemp = wszTemp + cchEscaped;
                *wszTemp = L'\0';
                wszMultisz = wszMultisz + cchSubsz + 1;
            }

            break;

        case EXPANDSZ_METADATA :
        case STRING_METADATA :

            hr = EscapeString((WCHAR*)pbData,
                              (ULONG)wcslen((WCHAR*)pbData),
                              &bEscaped,
                              &wszEscaped,
                              &cchEscaped);

            if(FAILED(hr))
            {
                goto exit;
            }

            hr = StringToNewString(wszEscaped,
                                   cchEscaped,
                                   pwszData);

            if(FAILED(hr))
            {
                goto exit;
            }

            break;

        default:
            DBGINFOW((DBG_CONTEXT,
                      L"[ToString] Unknown data type %d for ID: %d.\n",
                      dwDataType,
                      dwIdentifier));
            hr = E_INVALIDARG;
            break;

    }

exit:

    if(bEscaped && (NULL != wszEscaped))
    {
        delete [] wszEscaped;
        wszEscaped = NULL;
        bEscaped = FALSE;
    }

    return hr;

} // CWriterGlobalHelper::ToString


/***************************************************************************++

Routine Description:

    This function converts a given boolean its string representation,

Arguments:

    [in]   Bool value
    [out]  String representation of the Bool.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriterGlobalHelper::BoolToString(DWORD      dwValue,
                                          LPWSTR*    pwszData)
{
    HRESULT hr = S_OK;

    if(dwValue)
    {
        hr = StringToNewString(g_wszTrue,
                               g_cchTrue,
                               pwszData);
    }
    else
    {
        hr = StringToNewString(g_wszFalse,
                               g_cchFalse,
                               pwszData);
    }

    return hr;

} // CWriterGlobalHelper::BoolToString


/***************************************************************************++

Routine Description:

    Helper funciton that return the start row index in the metatable for
    the flag concerned

Arguments:

    [in]   Table to which the flag property belongs
    [in]   Column index of the flag property
    [out]  Start row index of the flag meta in the metatable for this flag.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriterGlobalHelper::GetStartRowIndex(LPWSTR    wszTable,
                                              ULONG     iColFlag,
                                              ULONG*    piStartRow)
{
    HRESULT hr = S_OK;
    ULONG   aColSearch[] = {iTAGMETA_Table,
                            iTAGMETA_ColumnIndex
                           };
    ULONG   cColSearch = sizeof(aColSearch)/sizeof(ULONG);
    LPVOID  apvSearch[cTAGMETA_NumberOfColumns];
    apvSearch[iTAGMETA_Table] = (LPVOID)wszTable;
    apvSearch[iTAGMETA_ColumnIndex] = (LPVOID)&iColFlag;

    *piStartRow = 0;

    if((0 == wcscmp(wszTable, m_wszTABLE_MBProperty)) && // OK to do case sensitive compare because all callers pass well known table names
       (iMBProperty_Attributes == iColFlag))
    {
        *piStartRow = m_iStartRowForAttributes;
    }
    else
    {
        hr = m_pISTTagMetaByTableAndColumnIndex->GetRowIndexBySearch(*piStartRow,
                                                                     cColSearch,
                                                                     aColSearch,
                                                                     NULL,
                                                                     apvSearch,
                                                                     piStartRow);

        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;
            *piStartRow = (ULONG)-1;
        }
    }

    return hr;

} // CWriterGlobalHelper::GetStartRowIndex


/***************************************************************************++

Routine Description:

    Function that escapes a string according to the following ruules:

    ************************************************************************
    ESCAPING LEGAL XML
    ************************************************************************

    Following characters are legal in XML:
    #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] |
    [#x10000-#x10FFFF]

    Out of this legal set, following need special escaping:
    Quote         => " => 34 => Escaped as: &quot;
    Ampersand     => & => 38 => Escaped as: &amp;
    Less than     => < => 60 => Escaped as: &lt;
    Gretater than => > => 62 => Escaped as: &gt;

    Note there may be chars in the legal set that may appear legal in certain
    languages and not in others. All such chars are not escaped. We could
    escape them as hex numbers Eg 0xA as &#x000A, but we do not want to
    do this because editors may be able to render these chars, when we change
    the language.
    Following are the hex values of such chars.

    #x9 | #xA | #xD | [#x7F-#xD7FF] | [#xE000-#xFFFD]

    Note we disregard the range [#x10000-#x10FFFF] because it is not 2 bytes

    ************************************************************************
    ESCAPING ILLEGAL XML
    ************************************************************************

    Illegal XML is also escaped in the following manner

    We add 0x10000 to the char value and escape it as hex. the XML
    interceptor will render these chars correctly. Note that we are using
    the fact unicode chars are not > 0x10000 and hence we can make this
    assumption.

Arguments:

    [in]   String to be escaped
    [in]   Count of characters in the string
    [out]  Bool indicating if escaping happened
    [out]  Escaped string - If no escaping occured, it will just point to
           the original string. If escaping occured it will point to a newly
           allocated string that the caller needs to free. The caller can
           use the bool to determine what action he needs to take.
    [out]  Count of characters in the escaped string

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriterGlobalHelper::EscapeString(LPCWSTR wszString,
                                          ULONG   cchString,
                                          BOOL*   pbEscaped,
                                          LPWSTR* pwszEscaped,
                                          ULONG*  pcchEscaped)
{

    ULONG              cchAdditional        = 0;
    HRESULT            hr                   = S_OK;
    eESCAPE            eEscapeType          = eNoESCAPE;
    const ULONG        cchLegalCharAsHex    = (sizeof(WCHAR)*2) + 4; // Each byte is represented as 2 WCHARs plus 4 additional escape chars (&#x;)
    WCHAR              wszLegalCharAsHex[cchLegalCharAsHex];
    const ULONG        cchIllegalCharAsHex  = cchLegalCharAsHex + 1; // illegal xml has an extra char because we are adding 0x10000 to it.
    WCHAR              wszIllegalCharAsHex[cchIllegalCharAsHex];
    DWORD              dwIllegalChar        = 0;
    static WCHAR       wszQuote[]           = L"&quot;";
    static const ULONG  cchQuote            = (sizeof(wszQuote)/sizeof(WCHAR))-1;
    static WCHAR       wszAmp[]             = L"&amp;";
    static const ULONG  cchAmp              = (sizeof(wszAmp)/sizeof(WCHAR))-1;
    static WCHAR       wszlt[]              = L"&lt;";
    static const ULONG  cchlt               = (sizeof(wszlt)/sizeof(WCHAR))-1;
    static WCHAR       wszgt[]              = L"&gt;";
    static const ULONG  cchgt               = (sizeof(wszgt)/sizeof(WCHAR))-1;

    *pbEscaped = FALSE;

    //
    // Go through each char and compute the addtional chars needed to escape.
    // Since each of the chars itself are counted in cchString, while computing
    // the cchAdditional, we will add the extra chars and subtract 1 from it,
    // because we will be replacing the char with the escaped chars.
    //

    for(ULONG i=0; i<cchString; i++)
    {
        eEscapeType = GetEscapeType(wszString[i]);

        switch(eEscapeType)
        {
        case eNoESCAPE:
            break;
        case eESCAPEgt:
            cchAdditional = (cchAdditional + cchgt) - 1;
            *pbEscaped = TRUE;
            break;
        case eESCAPElt:
            cchAdditional = (cchAdditional + cchlt) - 1;
            *pbEscaped = TRUE;
            break;
        case eESCAPEquote:
            cchAdditional = (cchAdditional + cchQuote) - 1;
            *pbEscaped = TRUE;
            break;
        case eESCAPEamp:
            cchAdditional = (cchAdditional + cchAmp) - 1;
            *pbEscaped = TRUE;
            break;
        case eESCAPEashex:
            cchAdditional = (cchAdditional + cchLegalCharAsHex) - 1;
            *pbEscaped = TRUE;
            break;
        case eESCAPEillegalxml:
            cchAdditional = (cchAdditional + cchIllegalCharAsHex) - 1;
            *pbEscaped = TRUE;
            break;
        default:
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            break;
        }
    }

    if(*pbEscaped)
    {
        //
        // String needs to be escaped, allocate the extra memory
        //

        hr = NewString(cchString+cchAdditional,
                       pwszEscaped);

        if(FAILED(hr))
        {
            return hr;
        }

        *pcchEscaped = cchString+cchAdditional;

        //
        // Escape string
        //

        for(ULONG i=0; i<cchString; i++)
        {
            eEscapeType = GetEscapeType(wszString[i]);

            switch(eEscapeType)
            {
            case eNoESCAPE:
                wcsncat(*pwszEscaped, (WCHAR*)&(wszString[i]), 1);
                break;
            case eESCAPEgt:
                wcsncat(*pwszEscaped, wszgt, cchgt);
                break;
            case eESCAPElt:
                wcsncat(*pwszEscaped, wszlt, cchlt);
                break;
            case eESCAPEquote:
                wcsncat(*pwszEscaped, wszQuote, cchQuote);
                break;
            case eESCAPEamp:
                wcsncat(*pwszEscaped, wszAmp, cchAmp);
                break;
            case eESCAPEashex:
                _snwprintf(wszLegalCharAsHex, cchLegalCharAsHex, L"&#x%04hX;", wszString[i]);
                wcsncat(*pwszEscaped, (WCHAR*)wszLegalCharAsHex, cchLegalCharAsHex);
                break;
            case eESCAPEillegalxml:
                dwIllegalChar = 0x10000 + wszString[i];
                _snwprintf(wszIllegalCharAsHex, cchIllegalCharAsHex, L"&#x%05X;", dwIllegalChar);
                wcsncat(*pwszEscaped, (WCHAR*)wszIllegalCharAsHex, cchIllegalCharAsHex);
                break;
            default:
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                break;
            }
        }

    }
    else
    {
        //
        // String need not be escaped, just pass the string out.
        //

        *pwszEscaped = (LPWSTR)wszString;
        *pcchEscaped = cchString;
    }

    return S_OK;

} // CWriterGlobalHelper::EscapeString


/***************************************************************************++

Routine Description:

    Returns the escape type of a character

Arguments:

    [in]   Char

Return Value:

    Escape type

--***************************************************************************/
eESCAPE CWriterGlobalHelper::GetEscapeType(WCHAR i_wChar)
{
    WORD    wChar       = i_wChar;
    eESCAPE eEscapeType = eNoESCAPE;

    if(wChar <= 0xFF)
    {
        eEscapeType = kWcharToEscape[wChar];
    }
    else if( (wChar <= 0xD7FF) ||
             ((wChar >= 0xE000) && (wChar <= 0xFFFD))
           )
    {
        eEscapeType = eNoESCAPE;
    }
    else
    {
        eEscapeType = eESCAPEillegalxml;
    }

    return eEscapeType;

} // CWriterGlobalHelper::GetEscapeType


/***************************************************************************++

Routine Description:

    Returns the user type

Arguments:

    [in]   user type
    [out]  user type
    [out]  count of chars in user type
    [out]  alloced or not

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriterGlobalHelper::GetUserType(DWORD   i_dwUserType,
                                         LPWSTR* o_pwszUserType,
                                         ULONG*  o_cchUserType,
                                         BOOL*   o_bAllocedUserType)
{
    HRESULT hr            = S_OK;
    DWORD   iColUserType  = iCOLUMNMETA_UserType;

    *o_bAllocedUserType = FALSE;

    switch(i_dwUserType)
    {

    case IIS_MD_UT_SERVER:

        if(NULL == m_wszIIS_MD_UT_SERVER)
        {
            hr = EnumToString(i_dwUserType,
                              &m_wszIIS_MD_UT_SERVER,
                              wszTABLE_COLUMNMETA,
                              iColUserType);
            if(FAILED(hr))
            {
                return hr;
            }

            m_cchIIS_MD_UT_SERVER = (ULONG)wcslen(m_wszIIS_MD_UT_SERVER);
        }

        *o_pwszUserType = m_wszIIS_MD_UT_SERVER;
        *o_cchUserType  = m_cchIIS_MD_UT_SERVER;

        break;

    case IIS_MD_UT_FILE:

        if(NULL == m_wszIIS_MD_UT_FILE)
        {
            hr = EnumToString(i_dwUserType,
                              &m_wszIIS_MD_UT_FILE,
                              wszTABLE_COLUMNMETA,
                              iColUserType);
            if(FAILED(hr))
            {
                return hr;
            }

            m_cchIIS_MD_UT_FILE = (ULONG)wcslen(m_wszIIS_MD_UT_FILE);
        }

        *o_pwszUserType = m_wszIIS_MD_UT_FILE;
        *o_cchUserType  = m_cchIIS_MD_UT_FILE;

        break;

    case IIS_MD_UT_WAM:

        if(NULL == m_wszIIS_MD_UT_WAM)
        {
            hr = EnumToString(i_dwUserType,
                              &m_wszIIS_MD_UT_WAM,
                              wszTABLE_COLUMNMETA,
                              iColUserType);
            if(FAILED(hr))
            {
                return hr;
            }

            m_cchIIS_MD_UT_WAM = (ULONG)wcslen(m_wszIIS_MD_UT_WAM);
        }

        *o_pwszUserType = m_wszIIS_MD_UT_WAM;
        *o_cchUserType  = m_cchIIS_MD_UT_WAM;

        break;

    case ASP_MD_UT_APP:

        if(NULL == m_wszASP_MD_UT_APP)
        {
            hr = EnumToString(i_dwUserType,
                              &m_wszASP_MD_UT_APP,
                              wszTABLE_COLUMNMETA,
                              iColUserType);
            if(FAILED(hr))
            {
                return hr;
            }

            m_cchASP_MD_UT_APP = (ULONG)wcslen(m_wszASP_MD_UT_APP);
        }

        *o_pwszUserType = m_wszASP_MD_UT_APP;
        *o_cchUserType  = m_cchASP_MD_UT_APP;

        break;

    default:

        hr = EnumToString(i_dwUserType,
                          o_pwszUserType,
                          wszTABLE_COLUMNMETA,
                          iColUserType);
        if(FAILED(hr))
        {
            return hr;
        }

        *o_cchUserType = (ULONG)wcslen(*o_pwszUserType);
        *o_bAllocedUserType = TRUE;

        break;

    }

    return S_OK;

} // CWriterGlobalHelper::GetUserType


/***************************************************************************++

Routine Description:

    Given the property id this routine contructs the name. If the name is not
    found in the schema, it creates a name of the form Unknown_XXXX where XXX
    is the ID.

Arguments:

    [in]   property id
    [out]  name
    [out]  alloced or not

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriterGlobalHelper::GetPropertyName(ULONG      i_dwPropertyID,
                                             LPWSTR*    o_wszName,
                                             BOOL*      o_bAlloced)
{
    HRESULT             hr                = S_OK;
    ULONG               iStartRow         = 0;
    ULONG               iRow              = 0;
    ULONG               iColColumnMeta    = iCOLUMNMETA_InternalName;
    LPWSTR              wszUnknownName    = NULL;
    LPWSTR              wszColumnName     = NULL;
    ULONG               aColSearchName[]  = {iCOLUMNMETA_Table,
                                             iCOLUMNMETA_ID
                                            };
    ULONG               cColSearchName    = sizeof(aColSearchName)/sizeof(ULONG);
    LPVOID              apvSearchName[cCOLUMNMETA_NumberOfColumns];

    apvSearchName[iCOLUMNMETA_Table]      = (LPVOID)m_wszTABLE_IIsConfigObject;
    apvSearchName[iCOLUMNMETA_ID]         = (LPVOID)&i_dwPropertyID;

    *o_wszName = NULL;
    *o_bAlloced = FALSE;

    //
    // Fetch the Name for this ID
    //

    //
    // Try the cache first, to get the row index.
    //
    if (S_FALSE == m_PropertyIDs.GetRowByID(i_dwPropertyID, &iRow))
    {

        //
        // If not in cache, search in the fixed table.
        //

        hr = m_pISTColumnMetaByTableAndID->GetRowIndexBySearch(iStartRow,
                                                               cColSearchName,
                                                               aColSearchName,
                                                               NULL,
                                                               apvSearchName,
                                                               &iRow);

        if(E_ST_NOMOREROWS == hr)
        {
            hr  = CreateUnknownName(i_dwPropertyID,
                                    &wszUnknownName);

            if(FAILED(hr))
            {
                goto exit;
            }

            *o_wszName = wszUnknownName;
            *o_bAlloced = TRUE;
            goto exit;

        }
        else if(FAILED(hr))
        {
            goto exit;
        }
        else
        {
            //
            // Add the row index to the cache, so that we can find it easier next time around.
            //

            hr = m_PropertyIDs.AddPropertyID(i_dwPropertyID, iRow);
            if (FAILED(hr))
            {
                goto exit;
            }
        }
    }

    hr = m_pISTColumnMetaByTableAndID->GetColumnValues(iRow,
                                                       1,
                                                       &iColColumnMeta,
                                                       NULL,
                                                      (LPVOID*)&wszColumnName);

    if(E_ST_NOMOREROWS == hr)
    {
        hr  = CreateUnknownName(i_dwPropertyID,
                                &wszUnknownName);

        if(FAILED(hr))
        {
            goto exit;
        }

        *o_wszName = wszUnknownName;
        *o_bAlloced = TRUE;

    }
    else if(FAILED(hr))
    {
        goto exit;
    }
    else
    {
        *o_wszName = wszColumnName;
    }

exit:

    if(FAILED(hr) && (NULL != wszUnknownName))
    {
        delete [] wszUnknownName;
        wszUnknownName = NULL;
    }

    return hr;

}  // CWriterGlobalHelper::GetPropertyName


/***************************************************************************++
Routine Description:

    This function is invoked when the name for a given property is missing.
    We create a name of the follwoing form: Unknown_NameXXXX

Arguments:

    [in]  ID
    [out] Name

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriterGlobalHelper::CreateUnknownName(DWORD    dwID,
                                           LPWSTR*  pwszUnknownName)
{
    WCHAR wszID[40];
    ULONG cchID = 0;
    WCHAR* wszEnd = NULL;

    _ultow(dwID, wszID, 10);

    cchID = (ULONG)wcslen(wszID);

    *pwszUnknownName = new WCHAR[cchID+g_cchUnknownName+1];
    if(NULL == *pwszUnknownName)
    {
        return E_OUTOFMEMORY;
    }

    wszEnd = *pwszUnknownName;
    memcpy(wszEnd, g_wszUnknownName, ((g_cchUnknownName+1)*sizeof(WCHAR)));
    wszEnd = wszEnd + g_cchUnknownName;
    memcpy(wszEnd, wszID, ((cchID+1)*sizeof(WCHAR)));

    return S_OK;

} // CWriterGlobalHelper::CreateUnknownName


/***************************************************************************++
Routine Description:

    This function is invoked to add a <property-id  & columnmeta row index >
    pair into the property id cache. This is cache was implemented to speed up
    the GetPropertyName method, which is called a lot and is not very cheap.

Arguments:

    [in] Metabase Property ID
    [in] Index of the property id in the column meta table.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CPropertyIDCache::AddPropertyID(
    DWORD   i_iPropertyID,
    DWORD   i_iRow)
{
    Entry   entry;
    DWORD   iEntry = 0;

    entry.iPropertyID = i_iPropertyID;
    entry.iPropertyRow = i_iRow;

    //
    // Findl the location to insert at.
    //

    iEntry = caCache.BinarySearch(entry);

    // @TODO: Assert that the row isn't already there.

    return caCache.InsertAt (entry, iEntry);

} // CPropertyIDCache::AddPropertyID


/***************************************************************************++
Routine Description:

    This function is invoked to get the fixed table row index given a metabase
    property id.

Arguments:

    [in]  Metabase Property ID
    [out] Fixed table row index.

Return Value:

    HRESULT
        S_FALSE: not in cache.

--***************************************************************************/
HRESULT CPropertyIDCache::GetRowByID(
    DWORD   i_iPropertyID,
    DWORD   *o_iRow)
{
    Entry   entry;
    DWORD   iEntry = 0;

    entry.iPropertyID = i_iPropertyID;

    iEntry = caCache.BinarySearch(entry);
    if ((iEntry >= caCache.Count()) ||
        (iEntry == 0) ||
        (caCache[iEntry-1].iPropertyID != i_iPropertyID))
    {
        // Not in the cache.
        *o_iRow = (DWORD)-1;
        return S_FALSE;
    }
    else
    {
        // Found it.
        *o_iRow = caCache[iEntry-1].iPropertyRow;
    }

    return S_OK;

} // CPropertyIDCache::GetRowByID
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\errortable\errortable.h ===
/********************************************************************++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    ErrorTable.h

Abstract:

    Detailed Errors go into a table. This is the implementation of
    that table.

Author:

    Stephen Rakonza (stephenr)        9-Mar-2001

Revision History:

--********************************************************************/
#pragma once

class ErrorTable : public ISimpleTableInterceptor
                  ,public ISimpleTableWrite2
                  ,public ISimpleTableController
                  ,public IErrorInfo
{
public:
    ErrorTable () : m_cRef(0), m_IsIntercepted(0){}
    virtual ~ErrorTable () {}

//IUnknown
public:
    STDMETHOD (QueryInterface)          (REFIID riid, OUT void **ppv);
    STDMETHOD_(ULONG,AddRef)            ();
    STDMETHOD_(ULONG,Release)           ();


    //ISimpleTableInterceptor
    STDMETHOD (Intercept)               (LPCWSTR                    i_wszDatabase,
                                         LPCWSTR                    i_wszTable,
										 ULONG						i_TableID,
                                         LPVOID                     i_QueryData,
                                         LPVOID                     i_QueryMeta,
                                         DWORD                      i_eQueryFormat,
                                         DWORD                      i_fLOS,
                                         IAdvancedTableDispenser*   i_pISTDisp,
                                         LPCWSTR                    i_wszLocator,
                                         LPVOID                     i_pSimpleTable,
                                         LPVOID*                    o_ppvSimpleTable
                                        );

	// ISimpleTableRead2
    STDMETHOD (GetRowIndexByIdentity)   (ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
                                        {   return m_spISTWrite->GetRowIndexByIdentity(i_acbSizes, i_apvValues, o_piRow);    }
    STDMETHOD (GetRowIndexBySearch)     (ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
                                        {   return m_spISTWrite->GetRowIndexBySearch(i_iStartingRow, i_cColumns, i_aiColumns, i_acbSizes, i_apvValues, o_piRow);}
	STDMETHOD (GetColumnValues)         (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues)
                                        {   return m_spISTWrite->GetColumnValues(i_iRow, i_cColumns, i_aiColumns, o_acbSizes, o_apvValues);}
	STDMETHOD (GetTableMeta)            (ULONG* o_pcVersion, DWORD* o_pfTable, ULONG* o_pcRows, ULONG* o_pcColumns )
                                        {   return m_spISTWrite->GetTableMeta(o_pcVersion, o_pfTable, o_pcRows, o_pcColumns);}
	STDMETHOD (GetColumnMetas)	        (ULONG i_cColumns, ULONG* i_aiColumns, SimpleColumnMeta* o_aColumnMetas )
                                        {   return m_spISTWrite->GetColumnMetas(i_cColumns, i_aiColumns, o_aColumnMetas );}

    //ISimpleTableWrite2 : ISimpleTableRead2
	STDMETHOD (AddRowForDelete)		    (ULONG i_iReadRow)
                                        {   return m_spISTWrite->AddRowForDelete(i_iReadRow);}
	STDMETHOD (AddRowForInsert)		    (ULONG* o_piWriteRow)
                                        {   return m_spISTWrite->AddRowForInsert(o_piWriteRow);}
	STDMETHOD (AddRowForUpdate)		    (ULONG i_iReadRow, ULONG* o_piWriteRow)
                                        {   return m_spISTWrite->AddRowForUpdate(i_iReadRow, o_piWriteRow);}
	STDMETHOD (SetWriteColumnValues)    (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues)
                                        {   return m_spISTWrite->SetWriteColumnValues(i_iRow, i_cColumns, i_aiColumns, i_acbSizes, i_apvValues);}
	STDMETHOD (GetWriteColumnValues)    (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns,  DWORD* o_afStatus, ULONG* o_acbSizes, LPVOID* o_apvValues)
                                        {   return m_spISTWrite->GetWriteColumnValues(i_iRow, i_cColumns, i_aiColumns,  o_afStatus, o_acbSizes, o_apvValues);}
	STDMETHOD (GetWriteRowIndexByIdentity)	(ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
                                        {   return m_spISTWrite->GetWriteRowIndexByIdentity(i_acbSizes, i_apvValues, o_piRow);}
	STDMETHOD (UpdateStore)				()
                                        {   return S_OK;}
	STDMETHOD (GetWriteRowIndexBySearch)(ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
                                        {   return m_spISTWrite->GetWriteRowIndexBySearch(i_iStartingRow, i_cColumns, i_aiColumns, i_acbSizes, i_apvValues, o_piRow);}
	STDMETHOD (GetErrorTable)			(DWORD i_fServiceRequests, LPVOID* o_ppvSimpleTable)
                                        {   return m_spISTWrite->GetErrorTable(i_fServiceRequests, o_ppvSimpleTable);}

    //ISimpleTableAdvanced
	STDMETHOD (PopulateCache)			()
                                        {   return S_OK;}
	STDMETHOD (GetDetailedErrorCount)	(ULONG* o_pcErrs)
                                        {
                                            UNREFERENCED_PARAMETER(o_pcErrs);

                                            return E_NOTIMPL;
                                        }
	STDMETHOD (GetDetailedError)		(ULONG i_iErr, STErr* o_pSTErr)
                                        {
                                            UNREFERENCED_PARAMETER(i_iErr);
                                            UNREFERENCED_PARAMETER(o_pSTErr);

                                            return E_NOTIMPL;
                                        }
	STDMETHOD (ResetCaches)				()
                                        {   return S_OK;}
    STDMETHOD (GetColumnValuesEx)       (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, DWORD* o_afStatus, ULONG* o_acbSizes, LPVOID* o_apvValues)
										{
										    UNREFERENCED_PARAMETER(i_iRow);
										    UNREFERENCED_PARAMETER(i_cColumns);
										    UNREFERENCED_PARAMETER(i_aiColumns);
										    UNREFERENCED_PARAMETER(o_afStatus);
										    UNREFERENCED_PARAMETER(o_acbSizes);
										    UNREFERENCED_PARAMETER(o_apvValues);

										    return E_NOTIMPL;
										}


    //ISimpleTableController : ISimpleTableAdvanced
	STDMETHOD (ShapeCache)				(DWORD i_fTable, ULONG i_cColumns, SimpleColumnMeta* i_acolmetas, LPVOID* i_apvDefaults, ULONG* i_acbSizes)
                                        {   return m_spISTController->ShapeCache(i_fTable, i_cColumns, i_acolmetas, i_apvDefaults, i_acbSizes);}
	STDMETHOD (PrePopulateCache)		(DWORD i_fControl)
                                        {   return m_spISTController->PrePopulateCache(i_fControl);}
	STDMETHOD (PostPopulateCache)		()
                                        {   return m_spISTController->PostPopulateCache();}
	STDMETHOD (DiscardPendingWrites)	()
                                        {   return m_spISTController->DiscardPendingWrites();}
	STDMETHOD (GetWriteRowAction)		(ULONG i_iRow, DWORD* o_peAction)
                                        {   return m_spISTController->GetWriteRowAction(i_iRow, o_peAction);}
	STDMETHOD (SetWriteRowAction)		(ULONG i_iRow, DWORD i_eAction)
                                        {   return m_spISTController->SetWriteRowAction(i_iRow, i_eAction);}
	STDMETHOD (ChangeWriteColumnStatus)	(ULONG i_iRow, ULONG i_iColumn, DWORD i_fStatus)
                                        {   return m_spISTController->ChangeWriteColumnStatus(i_iRow, i_iColumn, i_fStatus);}
	STDMETHOD (AddDetailedError)		(STErr* o_pSTErr)
                                        {   return m_spISTController->AddDetailedError(o_pSTErr);}
	STDMETHOD (GetMarshallingInterface) (IID * o_piid, LPVOID * o_ppItf)
                                        {   return m_spISTController->GetMarshallingInterface(o_piid, o_ppItf);}

    //IErrorInfo
    STDMETHOD (GetGUID)                 (GUID *         o_pGUID);
    STDMETHOD (GetSource)               (BSTR *         o_pBstrSource);
    STDMETHOD (GetDescription)          (BSTR *         o_pBstrDescription);
    STDMETHOD (GetHelpFile)             (BSTR *         o_pBstrHelpFile);
    STDMETHOD (GetHelpContext)          (DWORD *        o_pdwHelpContext);

private:
    LONG                            m_cRef;
    LONG                            m_IsIntercepted;

    CComPtr<ISimpleTableWrite2>     m_spISTWrite;
    CComQIPtr<ISimpleTableController, &IID_ISimpleTableController> m_spISTController;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\errortable\errortable.cpp ===
/********************************************************************++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    ErrorTable.cpp

Abstract:

    Detailed Errors go into a table. This is the implementation of
    that table.

Author:

    Stephen Rakonza (stephenr)        9-Mar-2001

Revision History:

--********************************************************************/

#include "precomp.hxx"

/********************************************************************++

Routine Description:

    Intercept member of ISimpleTableInterceptor.  See IST documentation
    for details.

Arguments:

	i_wszDatabase   - only wszDATABASE_ERRORS is allowed
	i_wszTable      - only wszTABLE_DETAILEDERRORS is allowed
	i_TableID       - no used anymore
	i_QueryData     - no queries are currently acknowledged
	i_QueryMeta     - no queries are currently acknowledged
	i_eQueryFormat  - must be eST_QUERYFORMAT_CELLS
	i_fLOS          - Level of service (currently we don't allow READWRITE)
	i_pISTDisp      - the dispenser used to create this table
	i_wszLocator    - not currently used
	i_pSimpleTable  - this is not a logic interceptor so no table is under us
	o_ppvSimpleTable- we just create a memory table and return it

Notes:

    This is the most basic type of table.  It's empty to start with.
    So OnPopulateCache does nothing.  And it is never written to disk.
    So UpdateStore does nothing.  Intercept just create a memory table.
    What could be simpler.

Return Value:

    HRESULT

--********************************************************************/
STDMETHODIMP
ErrorTable::Intercept(
	LPCWSTR 	                i_wszDatabase,
	LPCWSTR 	                i_wszTable,
	ULONG		                i_TableID,
	LPVOID		                i_QueryData,
	LPVOID		                i_QueryMeta,
	DWORD		                i_eQueryFormat,
	DWORD		                i_fLOS,
	IAdvancedTableDispenser*    i_pISTDisp,
	LPCWSTR		                i_wszLocator,
	LPVOID		                i_pSimpleTable,
	LPVOID*		                o_ppvSimpleTable)
{
	HRESULT		hr = S_OK;

	UNREFERENCED_PARAMETER(i_wszLocator);

    InterlockedIncrement(&m_IsIntercepted);//We can only be called to Intercept once.

    if(1 != m_IsIntercepted)
    {
        ASSERT(false && "Intercept has already been called.  It can't be called twice.");
        return E_INVALIDARG;
    }

    if(_wcsicmp(i_wszDatabase, wszDATABASE_ERRORS))
    {
        ASSERT(false && "This interceptor only knows how to deal with wszDATABASE_ERRORS.  The wiring must be wrong");
        return E_INVALIDARG;
    }

    if(_wcsicmp(i_wszTable, wszTABLE_DETAILEDERRORS))
    {
        ASSERT(false && "This interceptor only knows how to deal with wszTABLE_DETAILEDERRORS.  The wiring must be wrong");
        return E_INVALIDARG;
    }

    if(0 != i_pSimpleTable)
    {
        ASSERT(false && "Programming Error!  i_pSimpleTable should be NULL.  The Error table is a bottom layer table.");
        return E_INVALIDARG;
    }

    if(0 == i_pISTDisp)
    {
        ASSERT(false && "Programming Error!  The dispenser needs to be passed into ::Intercept");
        return E_INVALIDARG;
    }

    *o_ppvSimpleTable = 0;//init out param

    STQueryCell *   pQueryCell = (STQueryCell*) i_QueryData;    // Query cell array from caller.
    int             nQueryCount = i_QueryMeta ? *reinterpret_cast<ULONG *>(i_QueryMeta) : 0;
    while(nQueryCount--)
    {
        if(0 == (pQueryCell->iCell & iST_CELL_SPECIAL))//ignore iST_CELL_SPECIAL, any other query is an error
            return E_ST_INVALIDQUERY;
        ++pQueryCell;
    }

    if(i_fLOS & fST_LOS_READWRITE)
    {
        ASSERT(false && "Error tables are not writable at this time");
        return E_ST_LOSNOTSUPPORTED;
    }

    if(eST_QUERYFORMAT_CELLS != i_eQueryFormat)
        return E_ST_QUERYNOTSUPPORTED;//Verify query type.

    ASSERT(0 == *o_ppvSimpleTable && "This should be NULL.  Possible memory leak or just an uninitialized variable.");

    if(FAILED(hr = i_pISTDisp->GetMemoryTable(  i_wszDatabase,
                                        i_wszTable,
                                        i_TableID,
                                        0,
                                        0,
                                        i_eQueryFormat,
                                        i_fLOS,
                                        reinterpret_cast<ISimpleTableWrite2 **>(&m_spISTWrite))))
            return hr;

    m_spISTController = m_spISTWrite;
    ASSERT(0 != m_spISTController.p);
    if(0 == m_spISTController.p)
        return E_NOINTERFACE;

    *o_ppvSimpleTable = (ISimpleTableWrite2*)(this);
    ((ISimpleTableInterceptor*)this)->AddRef();

    return hr;
}//ErrorTable::Intercept


STDMETHODIMP
ErrorTable::GetGUID(GUID * o_pGUID)
{
    UNREFERENCED_PARAMETER(o_pGUID);

    return E_NOTIMPL;
}


STDMETHODIMP
ErrorTable::GetSource(BSTR * o_pBstrSource)
{
    HRESULT     hr;
    LPWSTR      wszSource;
    ULONG       iColumn = iDETAILEDERRORS_Source;

    if(FAILED(hr = m_spISTWrite->GetColumnValues(0, 1, &iColumn, 0, reinterpret_cast<void **>(&wszSource))))
        return hr;

    CComBSTR bstrSource = wszSource;//Allocation can fail
    if(0 == bstrSource.m_str)
        return E_OUTOFMEMORY;

    *o_pBstrSource = bstrSource.Detach();//this assigns the BSTR and marks the CComBSTR as empty so it doesn't get freed.
    return S_OK;
}


STDMETHODIMP
ErrorTable::GetDescription(BSTR * o_pBstrDescription)
{   //GetDescription gets the first error from the table.  If the table contains more than one error, the caller will need to QI for ISimpleTableRead
    HRESULT     hr;
    LPWSTR      wszDescription;
    ULONG       iColumn = iDETAILEDERRORS_Description;

    if(FAILED(hr = m_spISTWrite->GetColumnValues(0, 1, &iColumn, 0, reinterpret_cast<void **>(&wszDescription))))
        return hr;

    CComBSTR bstrDescription = wszDescription;//Allocation can fail
    if(0 == bstrDescription.m_str)
        return E_OUTOFMEMORY;

    *o_pBstrDescription = bstrDescription.Detach();//this assigns the BSTR and marks the CComBSTR as empty so it doesn't get freed.
    return S_OK;
}


STDMETHODIMP
ErrorTable::GetHelpFile(BSTR * o_pBstrHelpFile)
{
    UNREFERENCED_PARAMETER(o_pBstrHelpFile);

    return E_NOTIMPL;
}


STDMETHODIMP
ErrorTable::GetHelpContext(DWORD * o_pdwHelpContext)
{
    UNREFERENCED_PARAMETER(o_pdwHelpContext);

    return E_NOTIMPL;
}


STDMETHODIMP
ErrorTable::QueryInterface(
    REFIID riid,
    void **ppv
)
{
    if (NULL == ppv)
        return E_INVALIDARG;
    *ppv = NULL;

    if (riid == IID_IUnknown)
    {
        *ppv = (ISimpleTableInterceptor*)(this);
    }
    if (riid == IID_ISimpleTableInterceptor)
    {
        *ppv = (ISimpleTableInterceptor*)(this);
    }
    else if (riid == IID_IErrorInfo)
    {
        *ppv = (IErrorInfo*)(this);
    }
    else if (riid == IID_ISimpleTableRead2)
    {
        *ppv = (ISimpleTableRead2*)(this);
    }
    else if (riid == IID_ISimpleTableWrite2)
    {
        *ppv = (ISimpleTableWrite2*)(this);
    }
    else if (riid == IID_ISimpleTableAdvanced)
    {
        *ppv = (ISimpleTableAdvanced*)(this);
    }
    else if (riid == IID_ISimpleTableController)
    {
        *ppv = (ISimpleTableController*)(this);
    }

    if (NULL != *ppv)
    {
        ((ISimpleTableInterceptor*)this)->AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}//ErrorTable::QueryInterface


STDMETHODIMP_(ULONG)
ErrorTable::AddRef()
{
    return InterlockedIncrement((LONG*) &m_cRef);
}//ErrorTable::AddRef

STDMETHODIMP_(ULONG)
ErrorTable::Release()
{
    long cref = InterlockedDecrement((LONG*) &m_cRef);
    if (cref == 0)
        delete this;

    return cref;
}//ErrorTable::Release
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\shared\xmlwriter\writerglobals.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    WriterGlobals.cpp

$Header: $

Abstract: This file defines all the strings used to write the XML files.

--**************************************************************************/

LPCWSTR g_wszBeginFile0                 = L"<?xml version =\"1.0\"?>\r\n<configuration xmlns=\"urn:microsoft-catalog:XML_Metabase_V";
ULONG   g_cchBeginFile0                 = (ULONG)wcslen(g_wszBeginFile0);
LPCWSTR g_wszBeginFile1                 = L"\">\r\n<MBProperty>\r\n";
ULONG   g_cchBeginFile1                 = (ULONG)wcslen(g_wszBeginFile1);
LPCWSTR g_wszEndFile                    = L"</MBProperty>\r\n</configuration>\r\n";
ULONG   g_cchEndFile                    = (ULONG)wcslen(g_wszEndFile);
LPCWSTR g_BeginLocation                 = L"<";
ULONG   g_cchBeginLocation              = (ULONG)wcslen(g_BeginLocation);
LPCWSTR g_Location                      = L"\tLocation =\"";
ULONG   g_cchLocation                   = (ULONG)wcslen(g_Location);
LPCWSTR g_EndLocationBegin              = L"</";
ULONG   g_cchEndLocationBegin           = (ULONG)wcslen(g_EndLocationBegin);
LPCWSTR g_EndLocationEnd                = L">\r\n";
ULONG   g_cchEndLocationEnd             = (ULONG)wcslen(g_EndLocationEnd);
LPCWSTR g_CloseQuoteBraceRtn            = L"\">\r\n";
ULONG   g_cchCloseQuoteBraceRtn         = (ULONG)wcslen(g_CloseQuoteBraceRtn);
LPCWSTR g_Rtn                           = L"\r\n";
ULONG   g_cchRtn                        = (ULONG)wcslen(g_Rtn);
LPCWSTR g_EqQuote                       = L"=\"";
ULONG   g_cchEqQuote                    = (ULONG)wcslen(g_EqQuote);
LPCWSTR g_QuoteRtn                      = L"\"\r\n";
ULONG   g_cchQuoteRtn                   = (ULONG)wcslen(g_QuoteRtn);
LPCWSTR g_TwoTabs                       = L"\t\t";
ULONG   g_cchTwoTabs                    = (ULONG)wcslen(g_TwoTabs);
LPCWSTR g_NameEq                        = L"\t\tName=\"";
ULONG   g_cchNameEq                     = (ULONG)wcslen(g_NameEq);
LPCWSTR g_IDEq                          = L"\t\tID=\"";
ULONG   g_cchIDEq                       = (ULONG)wcslen(g_IDEq);
LPCWSTR g_ValueEq                       = L"\t\tValue=\"";
ULONG   g_cchValueEq                    = (ULONG)wcslen(g_ValueEq);
LPCWSTR g_TypeEq                        = L"\t\tType=\"";
ULONG   g_cchTypeEq                     = (ULONG)wcslen(g_TypeEq);
LPCWSTR g_UserTypeEq                    = L"\t\tUserType=\"";
ULONG   g_cchUserTypeEq                 = (ULONG)wcslen(g_UserTypeEq);
LPCWSTR g_AttributesEq                  = L"\t\tAttributes=\"";
ULONG   g_cchAttributesEq               = (ULONG)wcslen(g_AttributesEq);
LPCWSTR g_BeginGroup                    = L"\t<";
ULONG   g_cchBeginGroup                 = (ULONG)wcslen(g_BeginGroup);
LPCWSTR g_EndGroup                      = L"\t>\r\n";
ULONG   g_cchEndGroup                   = (ULONG)wcslen(g_EndGroup);
LPCWSTR g_BeginCustomProperty           = L"\t<Custom\r\n";
ULONG   g_cchBeginCustomProperty        = (ULONG)wcslen(g_BeginCustomProperty);
LPCWSTR g_EndCustomProperty             = L"\t/>\r\n";
ULONG   g_cchEndCustomProperty          = (ULONG)wcslen(g_EndCustomProperty);
LPCWSTR g_ZeroHex                       = L"0x00000000";
ULONG   g_cchZeroHex                    = (ULONG)wcslen(g_ZeroHex);
LPCWSTR g_wszIIsConfigObject            = L"IIsConfigObject";
LPCWSTR g_BeginComment                  = L"<!--";
ULONG   g_cchBeginComment               = (ULONG)wcslen(g_BeginComment);
LPCWSTR g_EndComment                    = L"-->\r\n";
ULONG   g_cchEndComment                 = (ULONG)wcslen(g_EndComment);

WORD    BYTE_ORDER_MASK                 = 0xFEFF;
DWORD   UTF8_SIGNATURE                  = 0x00BFBBEF;

LPWSTR  g_wszByID                       = L"ByID";
LPWSTR  g_wszByName                     = L"ByName";
LPWSTR  g_wszByTableAndColumnIndexOnly        = L"ByTableAndColumnIndexOnly";
LPWSTR  g_wszByTableAndColumnIndexAndNameOnly = L"ByTableAndColumnIndexAndNameOnly";
LPWSTR  g_wszByTableAndColumnIndexAndValueOnly = L"ByTableAndColumnIndexAndValueOnly";
LPWSTR  g_wszByTableAndTagNameOnly             = L"ByTableAndTagNameOnly";
LPWSTR  g_wszByTableAndTagIDOnly               = L"ByTableAndTagIDOnly";
LPWSTR  g_wszUnknownName                = L"UnknownName_";
ULONG   g_cchUnknownName                = (ULONG)wcslen(g_wszUnknownName);
LPWSTR  g_UT_Unknown                    = L"UNKNOWN_UserType";
ULONG   g_cchUT_Unknown                 = (ULONG)wcslen(g_UT_Unknown);
LPWSTR  g_T_Unknown                     = L"Unknown_Type";
LPWSTR  g_wszTrue                       = L"TRUE";
ULONG   g_cchTrue                       = (ULONG)wcslen(g_wszTrue);
LPWSTR  g_wszFalse                      = L"FALSE";
ULONG   g_cchFalse                      = (ULONG)wcslen(g_wszFalse);
ULONG   g_cchMaxBoolStr                 = (ULONG)wcslen(g_wszFalse);

LPCWSTR g_wszHistorySlash              = L"History\\";
ULONG   g_cchHistorySlash              = (ULONG)wcslen(g_wszHistorySlash);
LPCWSTR g_wszMinorVersionExt            = L"??????????";
ULONG   g_cchMinorVersionExt            = (ULONG)wcslen(g_wszMinorVersionExt);
LPCWSTR g_wszDotExtn                    = L".";
ULONG   g_cchDotExtn                    = (ULONG)wcslen(g_wszDotExtn);
WCHAR   g_wchBackSlash                  = L'\\';
WCHAR   g_wchFwdSlash                   = L'/';
WCHAR   g_wchDot                        = L'.';

ULONG   g_cchTemp                       = 1024;
WCHAR   g_wszTemp[1024];
LPCWSTR g_wszBeginSchema                = L"<?xml version =\"1.0\"?>\r\n<!-- WARNING, DO NOT EDIT THIS FILE. -->\r\n<MetaData xmlns=\"x-urn:microsoft-catalog:MetaData_V7\">\r\n\r\n\t<DatabaseMeta               InternalName =\"METABASE\">\r\n\t\t<ServerWiring           Interceptor  =\"Core_XMLInterceptor\"/>\r\n\t\t<Collection         InternalName =\"MetabaseBaseClass\"    MetaFlagsEx=\"NOTABLESCHEMAHEAPENTRY\"  MetaFlags=\"HIDDEN\">\r\n\t\t\t<Property       InternalName =\"Location\"                                    Type=\"WSTR\"   MetaFlags=\"PRIMARYKEY\"/>\r\n\t\t</Collection>\r\n";
ULONG   g_cchBeginSchema                = (ULONG)wcslen(g_wszBeginSchema);
LPCWSTR g_wszEndSchema                  = L"\t</DatabaseMeta>\r\n</MetaData>\r\n";
ULONG   g_cchEndSchema                  = (ULONG)wcslen(g_wszEndSchema);
LPCWSTR g_wszBeginCollection            = L"\t\t<Collection         InternalName =\"";
ULONG   g_cchBeginCollection            = (ULONG)wcslen(g_wszBeginCollection);
LPCWSTR g_wszEndBeginCollectionMB       = L"\"  MetaFlagsEx=\"NOTABLESCHEMAHEAPENTRY\">\r\n";
ULONG   g_cchEndBeginCollectionMB       = (ULONG)wcslen(g_wszEndBeginCollectionMB);
LPCWSTR g_wszEndBeginCollectionCatalog  = L"\">\r\n";
ULONG   g_cchEndBeginCollectionCatalog  = (ULONG)wcslen(g_wszEndBeginCollectionCatalog);
LPCWSTR g_wszInheritsFrom               = L"\"    InheritsPropertiesFrom=\"MetabaseBaseClass\" >\r\n";
ULONG   g_cchInheritsFrom               = (ULONG)wcslen(g_wszInheritsFrom);
LPCWSTR g_wszEndCollection              = L"\t\t</Collection>\r\n";
ULONG   g_cchEndCollection              = (ULONG)wcslen(g_wszEndCollection);
LPCWSTR g_wszBeginPropertyShort         = L"\t\t\t<Property       InheritsPropertiesFrom =\"IIsConfigObject:";
ULONG   g_cchBeginPropertyShort         = (ULONG)wcslen(g_wszBeginPropertyShort);
LPCWSTR g_wszMetaFlagsExEq              = L"\"  MetaFlagsEx=\"";
ULONG   g_cchMetaFlagsExEq              = (ULONG)wcslen(g_wszMetaFlagsExEq);
LPCWSTR g_wszMetaFlagsEq                = L"\"  MetaFlags=\"";
ULONG   g_cchMetaFlagsEq                = (ULONG)wcslen(g_wszMetaFlagsEq);
LPCWSTR g_wszEndPropertyShort           = L"\"/>\r\n";
ULONG   g_cchEndPropertyShort           = (ULONG)wcslen(g_wszEndPropertyShort);
LPCWSTR g_wszBeginPropertyLong          = L"\t\t\t<Property       InternalName =\"";
ULONG   g_cchBeginPropertyLong          = (ULONG)wcslen(g_wszBeginPropertyLong);
LPCWSTR g_wszPropIDEq                   = L"\"\t\t\tID=\"";
ULONG   g_cchPropIDEq                   = (ULONG)wcslen(g_wszPropIDEq);
LPCWSTR g_wszPropTypeEq                 = L"\"\t\t\tType=\"";
ULONG   g_cchPropTypeEq                 = (ULONG)wcslen(g_wszPropTypeEq);
LPCWSTR g_wszPropUserTypeEq             = L"\"\t\t\tUserType=\"";
ULONG   g_cchPropUserTypeEq             = (ULONG)wcslen(g_wszPropUserTypeEq);
LPCWSTR g_wszPropAttributeEq            = L"\"\t\t\tAttributes=\"";
ULONG   g_cchPropAttributeEq            = (ULONG)wcslen(g_wszPropAttributeEq);

LPWSTR  g_wszPropMetaFlagsEq            = L"\"\t\t\tMetaFlags=\"";
ULONG   g_cchPropMetaFlagsEq            = (ULONG)wcslen(g_wszPropMetaFlagsEq);
LPWSTR  g_wszPropMetaFlagsExEq          = L"\"\t\t\tMetaFlagsEx=\"";
ULONG   g_cchPropMetaFlagsExEq          = (ULONG)wcslen(g_wszPropMetaFlagsExEq);
LPWSTR  g_wszPropDefaultEq              = L"\"\t\t\tDefaultValue=\"";
ULONG   g_cchPropDefaultEq              = (ULONG)wcslen(g_wszPropDefaultEq);
LPWSTR  g_wszPropMinValueEq             = L"\"\t\t\tStartingNumber=\"";
ULONG   g_cchPropMinValueEq             = (ULONG)wcslen(g_wszPropMinValueEq);
LPWSTR  g_wszPropMaxValueEq             = L"\"\t\t\tEndingNumber=\"";
ULONG   g_cchPropMaxValueEq             = (ULONG)wcslen(g_wszPropMaxValueEq);
LPWSTR  g_wszEndPropertyLongNoFlag      = L"\"/>\r\n";
ULONG   g_cchEndPropertyLongNoFlag      = (ULONG)wcslen(g_wszEndPropertyLongNoFlag);
LPWSTR  g_wszEndPropertyLongBeforeFlag  = L"\">\r\n";
ULONG   g_cchEndPropertyLongBeforeFlag  = (ULONG)wcslen(g_wszEndPropertyLongBeforeFlag);
LPWSTR  g_wszEndPropertyLongAfterFlag   = L"\t\t\t</Property>\r\n";
ULONG   g_cchEndPropertyLongAfterFlag   = (ULONG)wcslen(g_wszEndPropertyLongAfterFlag);
LPCWSTR g_wszBeginFlag                  = L"\t\t\t\t<Flag       InternalName =\"";
ULONG   g_cchBeginFlag                  = (ULONG)wcslen(g_wszBeginFlag);
LPCWSTR g_wszFlagValueEq                = L"\"\t\tValue=\"";
ULONG   g_cchFlagValueEq                = (ULONG)wcslen(g_wszFlagValueEq);
LPCWSTR g_wszEndFlag                    = L"\"\t/>\r\n";
ULONG   g_cchEndFlag                    = (ULONG)wcslen(g_wszEndFlag);

LPCWSTR g_wszOr                         = L"| ";
ULONG   g_cchOr                         = (ULONG)wcslen(g_wszOr);
LPCWSTR g_wszOrManditory                = L"| MANDATORY";
ULONG   g_cchOrManditory                = (ULONG)wcslen(g_wszOrManditory);
LPCWSTR g_wszFlagIDEq                   = L"\"\t\tID=\"";
ULONG   g_cchFlagIDEq                   = (ULONG)wcslen(g_wszFlagIDEq);
LPCWSTR g_wszContainerClassListEq       = L"\"    ContainerClassList=\"";
ULONG   g_cchContainerClassListEq       = (ULONG)wcslen(g_wszContainerClassListEq);

LPCWSTR g_wszSlash                                      = L"/";
ULONG   g_cchSlash                                      = (ULONG)wcslen(g_wszSlash);
LPCWSTR g_wszLM                                         = L"LM";
ULONG   g_cchLM                                         = (ULONG)wcslen(g_wszLM);
LPCWSTR g_wszSchema                                     = L"Schema";
ULONG   g_cchSchema                                     = (ULONG)wcslen(g_wszSchema);
LPCWSTR g_wszSlashSchema                                = L"/Schema";
ULONG   g_cchSlashSchema                                = (ULONG)wcslen(g_wszSlashSchema);
LPCWSTR g_wszSlashSchemaSlashProperties                 = L"/Schema/Properties";
ULONG   g_cchSlashSchemaSlashProperties                 = (ULONG)wcslen(g_wszSlashSchemaSlashProperties);
LPCWSTR g_wszSlashSchemaSlashPropertiesSlashNames       = L"/Schema/Properties/Names";
ULONG   g_cchSlashSchemaSlashPropertiesSlashNames       = (ULONG)wcslen(g_wszSlashSchemaSlashPropertiesSlashNames);
LPCWSTR g_wszSlashSchemaSlashPropertiesSlashTypes       = L"/Schema/Properties/Types";
ULONG   g_cchSlashSchemaSlashPropertiesSlashTypes       = (ULONG)wcslen(g_wszSlashSchemaSlashPropertiesSlashTypes);
LPCWSTR g_wszSlashSchemaSlashPropertiesSlashDefaults    = L"/Schema/Properties/Defaults";
ULONG   g_cchSlashSchemaSlashPropertiesSlashDefaults    = (ULONG)wcslen(g_wszSlashSchemaSlashPropertiesSlashDefaults);
LPCWSTR g_wszSlashSchemaSlashClasses                    = L"/Schema/Classes";
ULONG   g_cchSlashSchemaSlashClasses                    = (ULONG)wcslen(g_wszSlashSchemaSlashClasses);
WCHAR*  g_wszEmptyMultisz                               = L"\0\0";
ULONG   g_cchEmptyMultisz                               = 2;
WCHAR*  g_wszEmptyWsz                                   = L"";
ULONG   g_cchEmptyWsz                                   = 1;
LPCWSTR g_wszComma                                      = L",";
ULONG   g_cchComma                                      = (ULONG)wcslen(g_wszComma);
LPCWSTR g_wszMultiszSeperator                           = L"\r\n\t\t\t";
ULONG   g_cchMultiszSeperator                           = (ULONG)wcslen(g_wszMultiszSeperator);

LPCWSTR g_aSynIDToWszType []                            ={NULL,
                                                          L"DWORD",
                                                          L"STRING",
                                                          L"EXPANDSZ",
                                                          L"MULTISZ",
                                                          L"BINARY",
                                                          L"BOOL",
                                                          L"BOOL_BITMASK",
                                                          L"MIMEMAP",
                                                          L"IPSECLIST",
                                                          L"NTACL",
                                                          L"HTTPERRORS",
                                                          L"HTTPHEADERS"
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\fixedschemainterceptor\fixedpackedschemainterceptor_com.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "precomp.hxx"

// -----------------------------------------
// CSDTFxd: IUnknown
// -----------------------------------------

// =======================================================================
STDMETHODIMP TFixedPackedSchemaInterceptor::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv)
		return E_INVALIDARG;
	*ppv = NULL;

	if (!m_fIsTable) // ie: Component is posing as class factory / dispenser:
	{
		if (riid == IID_ISimpleTableInterceptor)
		{
			*ppv = (ISimpleTableInterceptor*) this;
		}
		else if (riid == IID_IUnknown)
		{
			*ppv = (ISimpleTableInterceptor*) this;
		}
	}
	else // ie: Component is currently posing as data table:
	{
		if (riid == IID_IUnknown)
		{
			*ppv = (ISimpleTableRead2*) this;
		}
		else if (riid == IID_ISimpleTableRead2)
		{
			*ppv = (ISimpleTableRead2*) this;
		}
		else if (riid == IID_ISimpleTableAdvanced)
		{
			*ppv = (ISimpleTableAdvanced*) this;
		}
	}


	if (NULL != *ppv)
	{
		((ISimpleTableWrite2*)this)->AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}

}

// =======================================================================
STDMETHODIMP_(ULONG) TFixedPackedSchemaInterceptor::AddRef()
{
	return InterlockedIncrement((LONG*) &m_cRef);

}

// =======================================================================
STDMETHODIMP_(ULONG) TFixedPackedSchemaInterceptor::Release()
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\fixedschemainterceptor\fixedpackedschemainterceptor.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "precomp.hxx"

//This gets rid of an 'if' inside GetColumnValues.  Since this function is called more than any other, even one 'if' should make a difference,
//especially when it's inside the 'for' loop.
const unsigned long  TFixedPackedSchemaInterceptor::m_aColumnIndex[] = {
        0x00,   0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,   0x09,   0x0a,   0x0b,   0x0c,   0x0d,   0x0e,   0x0f,
        0x10,   0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,   0x19,   0x1a,   0x1b,   0x1c,   0x1d,   0x1e,   0x1f,
        0x20,   0x21,   0x22,   0x23,   0x24,   0x25,   0x26,   0x27,   0x28,   0x29,   0x2a,   0x2b,   0x2c,   0x2d,   0x2e,   0x2f
    };

const TableSchema::TableSchemaHeap * TFixedPackedSchemaInterceptor::m_pTableSchemaHeap = reinterpret_cast<const TableSchema::TableSchemaHeap *>(g_aTableSchemaHeap);

HRESULT TFixedPackedSchemaInterceptor::GetTableID(LPCWSTR /*i_wszDatabaseName*/, LPCWSTR i_wszTableName, ULONG &o_TableID)
{
    return GetTableID(i_wszTableName, o_TableID);
}

HRESULT TFixedPackedSchemaInterceptor::GetTableID(LPCWSTR i_wszTableName, ULONG &o_TableID)
{
    o_TableID = TableIDFromTableName(i_wszTableName);//This does the bit manipulation; but we still need to verify that the string matches

    TableSchema::TTableSchema tableschema;
    if(FAILED(tableschema.Init(m_pTableSchemaHeap->Get_TableSchema(o_TableID))))//Get_TableSchema may return NULL, in which case Init should fail gracefully
        return E_ST_INVALIDTABLE;
    return (0==_wcsicmp(tableschema.GetWCharPointerFromIndex(tableschema.GetCollectionMeta()->InternalName), i_wszTableName) ? S_OK : E_ST_INVALIDTABLE);
}

HRESULT TFixedPackedSchemaInterceptor::GetTableName(ULONG i_TableID, LPCWSTR &o_wszTableName)
{
    TableSchema::TTableSchema tableschema;
    if(FAILED(tableschema.Init(m_pTableSchemaHeap->Get_TableSchema(i_TableID))))//If a bogus TableID was passed in Get_TableSchema will return NULL, and Init will fail.
        return E_ST_INVALIDTABLE;
    o_wszTableName      = tableschema.GetWCharPointerFromIndex(tableschema.GetCollectionMeta()->InternalName);
    return S_OK;
}

HRESULT TFixedPackedSchemaInterceptor::GetTableName(ULONG i_TableID, LPCWSTR &o_wszTableName, LPCWSTR &o_wszDatabaseName)
{
    TableSchema::TTableSchema tableschema;
    if(FAILED(tableschema.Init(m_pTableSchemaHeap->Get_TableSchema(i_TableID))))//If a bogus TableID was passed in Get_TableSchema will return NULL, and Init will fail.
        return E_ST_INVALIDTABLE;
    o_wszTableName      = tableschema.GetWCharPointerFromIndex(tableschema.GetCollectionMeta()->InternalName);
    o_wszDatabaseName   = tableschema.GetWCharPointerFromIndex(tableschema.GetCollectionMeta()->Database);
    return S_OK;
}


// ==================================================================
TFixedPackedSchemaInterceptor::TFixedPackedSchemaInterceptor () :
                 m_cColumns(0)
                ,m_cColumnsPlusPrivateColumns(0)
                ,m_ciRows((ULONG)-1)
                ,m_cRef(0)
                ,m_fIsTable(false)
                ,m_pFixedData(0)
                ,m_pSimpleColumnMeta(0)
                ,m_TableMeta_MetaFlags(0)
                ,m_TableMeta_BaseVersion(0)
                ,m_TableSchemaHeap(*m_pTableSchemaHeap)
                ,m_MetaTable(m_eUnknownMeta)
{
}
// ==================================================================
TFixedPackedSchemaInterceptor::~TFixedPackedSchemaInterceptor ()
{
}


// ------------------------------------
// ISimpleDataTableDispenser:
// ------------------------------------

// ==================================================================
STDMETHODIMP TFixedPackedSchemaInterceptor::Intercept
(
    LPCWSTR					i_wszDatabase,
    LPCWSTR					i_wszTable,
    ULONG                   i_TableID,
    LPVOID					i_QueryData,
    LPVOID					i_QueryMeta,
    DWORD					i_eQueryFormat,
	DWORD					i_fTable,
	IAdvancedTableDispenser *i_pISTDisp,
    LPCWSTR					i_wszLocator,
	LPVOID					i_pSimpleTable,
    LPVOID*					o_ppv
)
{
    /*
    The only tables we support are CollectionMeta, PropertyMeta, TagMeta, ServerWiring
    In the future we will also support Fixed tables whose data is contained within the TableSchema block (small fixed tables)

    The types of queries we support:
        CollectionMeta  by TableName
        PropertyMeta    by TableName
        PropertyMeta    by TableName & Index
        TagMeta         by TableName
        TagMeta         by TableName & ColumnIndex
        TagMeta         by TableName, ColumnIndex & InternalName
        ServerWiring       <no query>
        ServerWiring    by TableName
        ServerWiring    by TableName, Order
    */
    STQueryCell           * pQueryCell = (STQueryCell*) i_QueryData;    // Query cell array from caller.
    ULONG                   cQueryCells = 0;
    HRESULT                 hr;

    UNREFERENCED_PARAMETER(i_pISTDisp);

	if (i_pSimpleTable)
		return E_INVALIDARG;
    if (i_QueryMeta)//The count is only valid if i_QueryMeta is not NULL
         cQueryCells= *(ULONG *)i_QueryMeta;

    //We don't support Intercept being called twice
    ASSERT(!m_fIsTable);if(m_fIsTable)return E_UNEXPECTED; // ie: Assert component is posing as class factory / dispenser.

    // Parameter validation:
    //Either i_TableID is non zero OR (i_wszDatabase==wszDATABASE_PACKEDSCHEMA && i_wszTable is NOT NULL)
    if(0==i_TableID)
    {
        if(NULL == i_wszDatabase)                   return E_INVALIDARG;
        if(NULL == i_wszTable)                      return E_INVALIDARG;

        //The only database we support is wszDATABASE_PACKEDSCHEMA (hack, we're handling wszDATABASE_META, TableMeta, ColumnMeta and TagMeta)
        if(0 != StringInsensitiveCompare(i_wszDatabase, wszDATABASE_META) &&
           0 != StringInsensitiveCompare(i_wszDatabase, wszDATABASE_PACKEDSCHEMA))return E_ST_INVALIDTABLE;
    }
    if(NULL == o_ppv)                           return E_INVALIDARG;
    if(eST_QUERYFORMAT_CELLS != i_eQueryFormat) return E_ST_QUERYNOTSUPPORTED;
    if(NULL != i_wszLocator)                    return E_INVALIDARG;
    if((fST_LOS_READWRITE | fST_LOS_MARSHALLABLE | fST_LOS_UNPOPULATED | fST_LOS_REPOPULATE | fST_LOS_MARSHALLABLE) & i_fTable)
                                                return E_ST_LOSNOTSUPPORTED;

    *o_ppv = NULL;

    //The only tables we support are:
    //  wszTABLE_COLLECTION_META    TABLEID_COLLECTION_META
    //  wszTABLE_PROPERTY_META      TABLEID_PROPERTY_META
    //  wszTABLE_TAG_META           TABLEID_TAG_META
    //  wszTABLE_SERVERWIRING_META  TABLEID_SERVERWIRING_META
    if(0 == i_TableID)
        if(FAILED(hr = GetTableID(i_wszTable, i_TableID)))return hr;

    hr = E_ST_INVALIDTABLE;
    switch(i_TableID)
    {
    case TABLEID_TABLEMETA:
    case TABLEID_COLLECTION_META:
        hr = GetCollectionMetaTable     (pQueryCell, cQueryCells);
        break;
    case TABLEID_COLUMNMETA:
    case TABLEID_PROPERTY_META:
        hr = GetPropertyMetaTable       (pQueryCell, cQueryCells);
        break;
    case TABLEID_TAGMETA:
    case TABLEID_TAG_META:
        hr = GetTagMetaTable            (pQueryCell, cQueryCells);
        break;
    case TABLEID_SERVERWIRING_META:
        hr = GetServerWiringMetaTable   (pQueryCell, cQueryCells);
        break;
    default:
        break;
    }
    if(FAILED(hr) && E_ST_NOMOREROWS != hr)//It's perfectly OK to return a table with No rows.
        return hr;

// Supply ISimpleTable* and transition state from class factory / dispenser to data table:
    *o_ppv = (ISimpleTableRead2*) this;
    AddRef ();
    InterlockedIncrement ((LONG*) &m_fIsTable);
    m_fIsTable = true;

    hr = S_OK;
    return hr;
}


// ------------------------------------
// ISimpleTableRead2:
// ------------------------------------

// ==================================================================
STDMETHODIMP TFixedPackedSchemaInterceptor::GetRowIndexByIdentity( ULONG*  i_cb, LPVOID* i_pv, ULONG* o_piRow)
{
    //TagMeta doesn't support this
    if(m_eTagMeta == m_MetaTable)
        return E_NOTIMPL;

    //Also, the other tables don't support this if they were given a query
    if(m_pFixedData)//if turns out that m_pFixedData is only valid when the table was given a query
        return E_NOTIMPL;

    //We're serving up unqueried tables.  The zeroth PK is ALWAYS table name or TableID
    //Also, we don't have DBTYPE_BYTES as a PK so i_cb should always be NULL
    if(NULL != i_cb)        return E_INVALIDARG;
    if(NULL == i_pv)        return E_INVALIDARG;
    if(NULL == i_pv[0])     return E_INVALIDARG;
    if(NULL == o_piRow)     return E_INVALIDARG;

    ULONG TableID = *reinterpret_cast<ULONG *>(i_pv[0]);//WARNING! This assumes that the 0th PK is the TableName BUT users will instead pass &TableID instead.
    if(0 != (0xFF & TableID))//if no table ID was given, then get the TableID from the table name
    {
        if(FAILED(GetTableID(reinterpret_cast<LPCWSTR>(i_pv[0]), TableID)))
            return E_ST_NOMOREROWS;
    }

    switch(m_MetaTable)
    {
    case m_eCollectionMeta:
        *o_piRow = TableID;
        break;
    case m_ePropertyMeta:
    case m_eServerWiringMeta:
        //So the iRow returned has the TableID in the high word and the Order in the low word.
        if(NULL == i_pv[1])
            return E_INVALIDARG;
        *o_piRow = TableID | *reinterpret_cast<ULONG *>(i_pv[1]);
        break;
    default:
        ASSERT(false && "unknown meta table type");
    }

    return S_OK;
}

// ==================================================================
STDMETHODIMP TFixedPackedSchemaInterceptor::GetColumnValues(ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues)
{
    if(0 == o_apvValues)
        return E_INVALIDARG;
    if(i_cColumns <= 0)
        return E_INVALIDARG;

    //Unqueried tables return a Row containing the TableID in the high 24 bits and the Row index for THAT table in the low 8 bits.  This allows
    //the row returned by GetRowIndexByIdentity to be incremented (within the confines of a table), while retaining all information needed to GetColumnValues

    //If we laready have m_pFixedData then we're good to go
    if(m_pFixedData)
    {
        ASSERT(0 == (i_iRow & ~0x3FF));
        return GetColumnValues(m_TableSchema, m_pFixedData, m_ciRows, i_iRow, i_cColumns, i_aiColumns, o_acbSizes, o_apvValues);
    }

    TableSchema::TTableSchema TableSchema;//We can't reuse m_TableSchema as that would make this call thread unsafe, so we must declare it on the stack each time.
    const ULONG *pFixedData = 0;
    ULONG  cRows = 0;

    //WARNING!! Very remote chance of a problem.  What if i_iRow is 0x00000100.  Does this mean we have a TableID 0x00000100 and a row index of 0?
    //So what are the chances of a TableID being 0x00000100?  This is the ONLY TableID that is a problem since we only support 503 tables currently.
    //CatUtil bans TableIDs whose upper 21 bits are 0.  This would allow us to grow to 1792 (0x00000700) tables without encountering this problem.
    if(m_MetaTable == m_eCollectionMeta)
    {//The only way this should happen is when the user request CollectionMeta without a query AND wants to iterate through ALL the tables
        if(i_iRow>=m_pTableSchemaHeap->Get_CountOfTables())
            return E_ST_NOMOREROWS;
        VERIFY(SUCCEEDED(TableSchema.Init(reinterpret_cast<const unsigned char *>(m_pTableSchemaHeap) + m_pTableSchemaHeap->Get_aTableSchemaRowIndex()[i_iRow])));//This should NEVER fail, if it does we probably have an error in CatUtil
        pFixedData = reinterpret_cast<const ULONG *>(TableSchema.GetCollectionMeta());
        cRows = 1;
        i_iRow = 0;//remap the request to the 0th row within this table
    }
    else
    {
        ULONG TableID = i_iRow & ~0xFF;
        if(0 == TableID)
            return E_ST_NOMOREROWS;

        i_iRow = i_iRow & 0xFF;//The TableID is in the high 24 bits.  The low 8 bits contains the row within the table.
        if(m_MetaTable == m_eCollectionMeta && 0 != i_iRow)//This makes no sense because, the only way we can have a TableID for CollectionMeta tables, is
            return E_ST_NOMOREROWS;//for the user to call GetRowByIdentity then GetColumnValues.  Well the row returns by GetRowByIdentity will be the TableID
                                   //the user may NOT increment the row index (in this particular case).  The only way for the user to iterate is to set iRow<CountOfTables
                                   //which is handled in the 'if' clause above.

        if(FAILED(TableSchema.Init(m_TableSchemaHeap.Get_TableSchema(TableID))))
            return E_ST_NOMOREROWS;//remap the error to E_ST_NOMOREROWS.  Get_TableSchema will return E_ST_INVALIDTABLE when given a bogus TableID.

        switch(m_MetaTable)
        {
        case m_eServerWiringMeta:
            //This may seem unsafe but if i_iRow >= cRows the pointer will never be accessed (see the private GetColumnValues)
            pFixedData = reinterpret_cast<const ULONG *>(TableSchema.GetServerWiringMeta());
            cRows = TableSchema.GetCollectionMeta()->cServerWiring;
            break;
        case m_eCollectionMeta:
            //This may seem unsafe but if i_iRow >= cRows the pointer will never be accessed (see the private GetColumnValues)
            pFixedData = reinterpret_cast<const ULONG *>(TableSchema.GetCollectionMeta());
            cRows = 1;
            break;
        case m_ePropertyMeta:
            //This may seem unsafe but if i_iRow >= cRows the pointer will never be accessed (see the private GetColumnValues)
            pFixedData = reinterpret_cast<const ULONG *>(TableSchema.GetPropertyMeta(0));
            cRows = TableSchema.GetCollectionMeta()->CountOfProperties;
            break;
        default:
            ASSERT(false && "Hmm!  Only ServerWiring, CollectionMeta dn PropertyMeta can have no query, so how did this happen?");
            return E_FAIL;
        }
    }
    return GetColumnValues(TableSchema, pFixedData, cRows, i_iRow, i_cColumns, i_aiColumns, o_acbSizes, o_apvValues);
}

// ==================================================================
STDMETHODIMP TFixedPackedSchemaInterceptor::GetTableMeta(ULONG *o_pcVersion, DWORD *o_pfTable, ULONG * o_pcRows, ULONG * o_pcColumns )
{
	if(NULL != o_pfTable)
	{
		*o_pfTable =  m_TableMeta_MetaFlags;
	}
	if(NULL != o_pcVersion)
	{
		*o_pcVersion = m_TableMeta_BaseVersion;
	}
    if (NULL != o_pcRows)
    {
        if(-1 == m_ciRows)//Some tables have no concept of how many rows they have.  They only know on a TableID by TableID basis
            return E_NOTIMPL;

        *o_pcRows = m_ciRows;
    }
    if (NULL != o_pcColumns)
    {
        *o_pcColumns = m_cColumns;
    }
    return S_OK;
}

// ==================================================================
STDMETHODIMP TFixedPackedSchemaInterceptor::GetColumnMetas (ULONG i_cColumns, ULONG* i_aiColumns, SimpleColumnMeta* o_aColumnMetas)
{
	ULONG iColumn;
	ULONG iTarget;

    if(0 == o_aColumnMetas)
        return E_INVALIDARG;

	if ( i_cColumns > m_cColumns )
		return  E_ST_NOMORECOLUMNS;

	for ( ULONG i = 0; i < i_cColumns; i ++ )
	{
		if(NULL != i_aiColumns)
			iColumn = i_aiColumns[i];
		else
			iColumn = i;

		iTarget = (i_cColumns == 1) ? 0 : iColumn;

		if ( iColumn >= m_cColumns )
			return  E_ST_NOMORECOLUMNS;

        memcpy(o_aColumnMetas + iTarget, m_pSimpleColumnMeta + iColumn, sizeof(SimpleColumnMeta));
	}

    return S_OK;
}

// ------------------------------------
// ISimpleTableAdvanced:
// ------------------------------------

// ==================================================================
STDMETHODIMP TFixedPackedSchemaInterceptor::PopulateCache ()
{
    return S_OK;
}

// ==================================================================
STDMETHODIMP TFixedPackedSchemaInterceptor::GetDetailedErrorCount(ULONG* o_pcErrs)
{
    UNREFERENCED_PARAMETER(o_pcErrs);

    return E_NOTIMPL;
}

// ==================================================================
STDMETHODIMP TFixedPackedSchemaInterceptor::GetDetailedError(ULONG i_iErr, STErr* o_pSTErr)
{
    UNREFERENCED_PARAMETER(i_iErr);
    UNREFERENCED_PARAMETER(o_pSTErr);

    return E_NOTIMPL;
}

// ==================================================================
STDMETHODIMP TFixedPackedSchemaInterceptor::ResetCaches ()
{
    return S_OK;
}

STDMETHODIMP TFixedPackedSchemaInterceptor::GetColumnValuesEx (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, DWORD* o_afStatus, ULONG* o_acbSizes, LPVOID* o_apvValues)
{
    UNREFERENCED_PARAMETER(i_iRow);
    UNREFERENCED_PARAMETER(i_cColumns);
    UNREFERENCED_PARAMETER(i_aiColumns);
    UNREFERENCED_PARAMETER(o_afStatus);
    UNREFERENCED_PARAMETER(o_acbSizes);
    UNREFERENCED_PARAMETER(o_apvValues);

	return E_NOTIMPL;
}




//
//
// Private member functions
//
//
HRESULT TFixedPackedSchemaInterceptor::GetCollectionMetaQuery(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells, LPCWSTR &o_wszTable, ULONG &o_TableID) const
{
    o_wszTable    = 0;
    o_TableID     = 0;
    //The only query we support for COLLECTION_META is by the table.  BUT there are two ways of specifiying the table: either by
    //TableID or by InternalName.  InternalName is the PK so it is queried by iCell==iCOLLECTION_META_InternalName.  TableID is a
    //an iST_CELL_SPECIAL (just like iST_CELL_FILE), so we check for iCell==iST_CELL_TABLEID also.
    //So walk the list looking for this query
    for(; i_cQueryCells; --i_cQueryCells, ++i_pQueryCell)
    {   //Walk the Query cells looking for one that matches the following criteria
        switch(i_pQueryCell->iCell)
        {
        case iCOLLECTION_META_InternalName:
            if( 0                         == o_wszTable       &&
                i_pQueryCell->eOperator   == eST_OP_EQUAL     &&
                i_pQueryCell->dbType      == DBTYPE_WSTR      &&
                i_pQueryCell->pData       != 0)
                o_wszTable = reinterpret_cast<LPCWSTR>(i_pQueryCell->pData);
            else
                return E_ST_INVALIDQUERY;
            break;
        case iST_CELL_TABLEID:
            if( 0                         == o_TableID        &&
                i_pQueryCell->eOperator   == eST_OP_EQUAL     &&
                i_pQueryCell->dbType      == DBTYPE_UI4       &&
                i_pQueryCell->pData       != 0)
            {
                o_TableID = *(reinterpret_cast<ULONG *>(i_pQueryCell->pData));
            }
            else
                return E_ST_INVALIDQUERY;
            break;
        default:
            if(0 == (i_pQueryCell->iCell & iST_CELL_SPECIAL))//The above cell is the only non-reserved cell we support
                return E_ST_INVALIDQUERY;                    //and we're supposed to ignore all reserved cell we don't understand
            break;
        }
    }
    if(0 == o_wszTable && 0 == o_TableID)
        return E_ST_INVALIDQUERY;

    return S_OK;
}


HRESULT TFixedPackedSchemaInterceptor::GetCollectionMetaTable(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells)
{
    //COLLECTION_META must be supplied a table name
    HRESULT hr;
    ULONG   TableID  = 0;
    LPCWSTR wszTable = 0;
    if(FAILED(hr = GetCollectionMetaQuery(i_pQueryCell, i_cQueryCells, wszTable, TableID)))
        return hr;

    ASSERT(0 != TableID || 0 != wszTable);//No Query (this is invalid)

    if(0 == TableID)//If the TableID wasn't supplied in the query, we need to search for it by TableName
    {
        //So map the table name to an ID
        if(FAILED(hr = GetTableID(wszTable, TableID)))
            return hr;
    }
#ifdef _DEBUG
    else if(wszTable)//If the query included both the TableID AND the Collection Name, then verify that the ID matches the Collection name.
    {
        ULONG TableIDTemp;
        if(FAILED(hr = GetTableID(wszTable, TableIDTemp)))
            return hr;
        ASSERT(TableIDTemp == TableID);
    }
#endif

    //Once we have the TableID it's just a straight forward lookup
    if(FAILED(hr = m_TableSchema.Init(m_TableSchemaHeap.Get_TableSchema(TableID))))
        return hr;
    m_pFixedData                    = reinterpret_cast<const ULONG *>(m_TableSchema.GetCollectionMeta());
    m_ciRows                        = 1;

    m_cColumns                      = kciTableMetaPublicColumns;
    m_cColumnsPlusPrivateColumns    = kciTableMetaPublicColumns;//We don't have to consider the private columns for this table since we don't ever treat it as an array of CollectionMeta
    m_MetaTable                        = m_eCollectionMeta;

    m_pSimpleColumnMeta     = m_pTableSchemaHeap->Get_aSimpleColumnMeta(m_pTableSchemaHeap->eCollectionMeta);
    m_TableMeta_MetaFlags   = fTABLEMETA_INTERNAL | fTABLEMETA_NOLISTENING;
    m_TableMeta_BaseVersion = 0;

    return S_OK;
}


HRESULT TFixedPackedSchemaInterceptor::GetColumnValues(TableSchema::TTableSchema &i_TableSchema, const ULONG *i_pFixedData, ULONG i_ciRows, ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues) const
{
    ASSERT(i_pFixedData);
// Validate in params
    if(  i_ciRows <= i_iRow     )   return E_ST_NOMOREROWS;
    if(         0 == o_apvValues)   return E_INVALIDARG;
    if(i_cColumns <= 0          )   return E_INVALIDARG;
    if(i_cColumns >  m_cColumns )   return E_INVALIDARG;

    const ULONG   * aColumns    = i_aiColumns ? i_aiColumns : m_aColumnIndex;
    HRESULT         hr          = S_OK;
    ULONG           ipv         = 0;
    ULONG           iColumn     = aColumns[ipv];
    ULONG	        iTarget     = (i_cColumns == 1) ? 0 : iColumn;// If caller needs one column only, he doesn't need to pass a buffer for all the columns.

    // Read data and populate out params
    //The following duplicate code eliminates an 'if' inside the for loop (below).
    {
        if(m_cColumns <= iColumn)// Validate column index
        {
            hr = E_ST_NOMORECOLUMNS;
            goto Cleanup;
        }

        // Read data:
        //So any time we see a WSTR in we treat it as an index into the heap and return the pointer to the item at
        //that index.  Same goes for GUIDs (g_aGuid) and BYTESs (g_aBytes).  In the Bytes array, we expected the first
        //four bytes (cast as a ULONG *) represents the number of bytes.  This is followed by the bytes.
        switch(m_pSimpleColumnMeta[iColumn].dbType)
        {
        case DBTYPE_UI4:
            o_apvValues[iTarget] = const_cast<ULONG *>(i_pFixedData + (m_cColumnsPlusPrivateColumns * i_iRow) + iColumn);
            break;
        case DBTYPE_BYTES:
        case DBTYPE_WSTR:
        case DBTYPE_GUID:
            o_apvValues[iTarget] = const_cast<unsigned char *>(i_TableSchema.GetPointerFromIndex(*(i_pFixedData + (m_cColumnsPlusPrivateColumns * i_iRow) + iColumn)));
            break;
        default:
            ASSERT(false && "Bogus DBTYPE");
            return E_FAIL;
        }


        if(o_acbSizes)
        {
            o_acbSizes[iTarget] = 0;//start with 0
            if(NULL != o_apvValues[iTarget])
            {
                switch(m_pSimpleColumnMeta[iColumn].dbType)
                {
                case DBTYPE_UI4:
                    o_acbSizes[iTarget] = sizeof(ULONG);
                    break;
                case DBTYPE_BYTES:
                    o_acbSizes[iTarget] = *(reinterpret_cast<const ULONG *>(o_apvValues[iTarget])-1);
                    break;
                case DBTYPE_WSTR:
                    if(fCOLUMNMETA_FIXEDLENGTH & m_pSimpleColumnMeta[iColumn].fMeta)
                        o_acbSizes[iTarget] = m_pSimpleColumnMeta[iColumn].cbSize;//if a size was specified AND FIXED_LENGTH was specified then return that size specified
                    else //if size was specified and FIXEDLENGTH was NOT then size is just interpretted as Maximum size
                        o_acbSizes[iTarget] = (ULONG)(wcslen ((LPWSTR) o_apvValues[iTarget]) + 1) * sizeof (WCHAR);//just return the string (length +1) in BYTES
                    break;
                case DBTYPE_GUID:
                    o_acbSizes[iTarget] = sizeof(GUID);
                    break;
                }
            }
        }
    }

    // Read data and populate out params
    for(ipv=1; ipv<i_cColumns; ipv++)
    {
//        if(NULL != i_aiColumns)
//            iColumn = i_aiColumns[ipv];
//        else
//            iColumn = ipv;
        iColumn = aColumns[ipv];
		iTarget = iColumn;// If caller needs one column only, he doesn't need to pass a buffer for all the columns.

        if(m_cColumns < iColumn)// Validate column index
        {
            hr = E_ST_NOMORECOLUMNS;
            goto Cleanup;
        }


        // Read data:
        //So any time we see a WSTR in we treat it as an index into the heap and return the pointer to the item at
        //that index.  Same goes for GUIDs (g_aGuid) and BYTESs (g_aBytes).  In the Bytes array, we expected the first
        //four bytes (cast as a ULONG *) represents the number of bytes.  This is followed by the bytes.
        switch(m_pSimpleColumnMeta[iColumn].dbType)
        {
        case DBTYPE_UI4:
            o_apvValues[iTarget] = const_cast<ULONG *>(i_pFixedData + (m_cColumnsPlusPrivateColumns * i_iRow) + iColumn);
            break;
        case DBTYPE_BYTES:
        case DBTYPE_WSTR:
        case DBTYPE_GUID:
            o_apvValues[iTarget] = const_cast<unsigned char *>(i_TableSchema.GetPointerFromIndex(*(i_pFixedData + (m_cColumnsPlusPrivateColumns * i_iRow) + iColumn)));
            break;
        default:
            ASSERT(false && "Bogus DBTYPE");
            return E_FAIL;
        }


        if(o_acbSizes)
        {
            o_acbSizes[iTarget] = 0;//start with 0
            if(NULL != o_apvValues[iTarget])
            {
                switch(m_pSimpleColumnMeta[iColumn].dbType)
                {
                case DBTYPE_UI4:
                    o_acbSizes[iTarget] = sizeof(ULONG);
                    break;
                case DBTYPE_BYTES:
                    o_acbSizes[iTarget] = *(reinterpret_cast<const ULONG *>(o_apvValues[iTarget])-1);
                    break;
                case DBTYPE_WSTR:
                    if(fCOLUMNMETA_FIXEDLENGTH & m_pSimpleColumnMeta[iColumn].fMeta)
                        o_acbSizes[iTarget] = m_pSimpleColumnMeta[iColumn].cbSize;//if a size was specified AND FIXED_LENGTH was specified then return that size specified
                    else //if size was specified and FIXEDLENGTH was NOT then size is just interpretted as Maximum size
                        o_acbSizes[iTarget] = (ULONG)(wcslen ((LPWSTR) o_apvValues[iTarget]) + 1) * sizeof (WCHAR);//just return the string (length +1) in BYTES
                    break;
                case DBTYPE_GUID:
                    o_acbSizes[iTarget] = sizeof(GUID);
                    break;
                }
            }
        }
    }

Cleanup:

    if(FAILED(hr))
    {
// Initialize out parameters
        for(ipv=0; ipv<i_cColumns; ipv++)
        {
            o_apvValues[ipv]        = NULL;
            if(NULL != o_acbSizes)
                o_acbSizes[ipv] = 0;
        }
    }

    return hr;
}//GetColumnValues


HRESULT TFixedPackedSchemaInterceptor::GetPropertyMetaQuery(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells, LPCWSTR &o_wszTable, ULONG &o_TableID, ULONG &o_PropertyIndex) const
{
    o_PropertyIndex = (ULONG)-1;
    o_wszTable      = 0;
    o_TableID       = 0;
    //The only queries we support for PROPERTY_META is by the table or table/property index.  BUT there are two ways of specifiying
    //the table: either by TableID or by InternalName.  InternalName is the PK so it is queried by iCell==iCOLLECTION_META_InternalName.
    //TableID is a an iST_CELL_SPECIAL (just like iST_CELL_FILE), so we check for iCell==iST_CELL_TABLEID also.
    //So walk the list looking for this query
    for(; i_cQueryCells; --i_cQueryCells, ++i_pQueryCell)
    {   //Walk the Query cells looking for one that matches the following criteria
        switch(i_pQueryCell->iCell)
        {
        case iPROPERTY_META_Table:
            if( 0                         == o_wszTable       &&
                i_pQueryCell->eOperator   == eST_OP_EQUAL     &&
                i_pQueryCell->dbType      == DBTYPE_WSTR      &&
                i_pQueryCell->pData       != 0)
            {
                o_wszTable = reinterpret_cast<LPCWSTR>(i_pQueryCell->pData);
            }
            else
                return E_ST_INVALIDQUERY;
            break;
        case iPROPERTY_META_Index:
            if( -1                        == o_PropertyIndex  &&
                i_pQueryCell->eOperator   == eST_OP_EQUAL     &&
                i_pQueryCell->dbType      == DBTYPE_UI4       &&
                i_pQueryCell->pData       != 0)
            {
                o_PropertyIndex = *(reinterpret_cast<ULONG *>(i_pQueryCell->pData));
            }
            else
                return E_ST_INVALIDQUERY;
            break;
        case iST_CELL_TABLEID:
            if( 0                         == o_TableID        &&
                i_pQueryCell->eOperator   == eST_OP_EQUAL     &&
                i_pQueryCell->dbType      == DBTYPE_UI4       &&
                i_pQueryCell->pData       != 0)
            {
                o_TableID = *(reinterpret_cast<ULONG *>(i_pQueryCell->pData));
            }
            else
                return E_ST_INVALIDQUERY;
            break;
        default:
            if(0 == (i_pQueryCell->iCell & iST_CELL_SPECIAL))//The above cell is the only non-reserved cell we support
                return E_ST_INVALIDQUERY;                       //and we're supposed to ignore all reserved cell we don't understand
            break;
        }
    }
    if(0 == o_TableID && 0 == o_wszTable && -1 != o_PropertyIndex)
        return E_ST_INVALIDQUERY;//User can't specify a property index without specifying a table also

    return S_OK;
}


HRESULT TFixedPackedSchemaInterceptor::GetPropertyMetaTable(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells)
{
    //PROPERTY_META must be supplied a table name or table name/property index
    HRESULT hr;
    ULONG   PropertyIndex   = (ULONG)-1;
    ULONG   TableID         = 0;
    LPCWSTR wszTable        = 0;
    if(FAILED(hr = GetPropertyMetaQuery(i_pQueryCell, i_cQueryCells, wszTable, TableID, PropertyIndex)))
        return hr;

    if(0 == TableID && 0 == wszTable)
    {
        m_pFixedData    = 0;//Does not make sense without a query
        m_ciRows        = (ULONG)-1;//the only way a user can access rows in this table is by Identity first, then the row index can be incremented (within a given table)
        //but ALL columns of ALL tables cannot be iterated.  This would require a mapping which we don't yet build (and we probably shouldn't).
    }
    else
    {
        if(0 == TableID)//If the TableID wasn't supplied in the query, we need to search for it by TableName
        {
            //So map the table name to an ID
            if(FAILED(hr = GetTableID(wszTable, TableID)))
                return hr;
        }
#ifdef _DEBUG
        else if(wszTable)//If the query included both the TableID AND the Collection Name, then verify that the ID matches the Collection name.
        {
            ULONG TableIDTemp;
            if(FAILED(hr = GetTableID(wszTable, TableIDTemp)))
                return hr;
            if(TableIDTemp != TableID)
                return E_ST_INVALIDQUERY;
        }
#endif
        //Once we have the TableID it's just a straight forward lookup
        if(FAILED(hr = m_TableSchema.Init(m_TableSchemaHeap.Get_TableSchema(TableID))))
            return hr;

        //If the user is asking for a column index that doesn't exist, then return error.
        if(PropertyIndex != -1 && PropertyIndex >= m_TableSchema.GetCollectionMeta()->CountOfProperties)
            return E_ST_INVALIDQUERY;

        m_pFixedData                    = reinterpret_cast<const ULONG *>(m_TableSchema.GetPropertyMeta(-1 == PropertyIndex ? 0 : PropertyIndex));
        m_ciRows                        = (-1 == PropertyIndex ? m_TableSchema.GetCollectionMeta()->CountOfProperties : 1);
    }

    m_cColumns                      = kciColumnMetaPublicColumns;
    m_cColumnsPlusPrivateColumns    = m_cColumns + kciColumnMetaPrivateColumns;
    m_MetaTable                        = m_ePropertyMeta;

    m_pSimpleColumnMeta     = m_pTableSchemaHeap->Get_aSimpleColumnMeta(m_pTableSchemaHeap->ePropertyMeta);
    m_TableMeta_MetaFlags   = fTABLEMETA_INTERNAL | fTABLEMETA_NOLISTENING;
    m_TableMeta_BaseVersion = 0;

    return S_OK;
}


HRESULT TFixedPackedSchemaInterceptor::GetServerWiringMetaQuery(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells) const
{
    //We currently don't support any queries for Server Wiring; so we need to verify that.
    for(; i_cQueryCells; --i_cQueryCells, ++i_pQueryCell)
    {   //Walk the Query cells looking for one that matches the following criteria
        if(0 == (i_pQueryCell->iCell & iST_CELL_SPECIAL))//Ignore any iST_CELL_SPECIAL queries but fail if anything else is specified
            return E_ST_INVALIDQUERY;
    }
    return S_OK;
}


HRESULT TFixedPackedSchemaInterceptor::GetServerWiringMetaTable(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells)
{
    //SERVERWIRING_META must NOT be supplied a query (except iST_CELL_SPECIAL cells other than iST_CELL_TABLEID)
    HRESULT hr;

    if(FAILED(hr = GetServerWiringMetaQuery(i_pQueryCell, i_cQueryCells)))
        return hr;

    m_pFixedData                    = 0;//ServerWiring & ClientWiring don't use this.  The pFixedData is figured out at GetColumnValues time
    m_ciRows                        = (ULONG)-1;//ServerWiring & ClientWiring don't use this.  This is figured out at GetColumnValues time on a per table basis.  See GetColumnValues comments for more datails
    m_cColumns                      = kciServerWiringMetaPublicColumns;
    m_cColumnsPlusPrivateColumns    = m_cColumns + kciServerWiringMetaPrivateColumns;
    m_MetaTable                     = m_eServerWiringMeta;

    m_pSimpleColumnMeta     = m_pTableSchemaHeap->Get_aSimpleColumnMeta(m_pTableSchemaHeap->eServerWiringMeta);
    m_TableMeta_MetaFlags   = fTABLEMETA_INTERNAL | fTABLEMETA_NOLISTENING;
    m_TableMeta_BaseVersion = 0;

    return S_OK;
}


HRESULT TFixedPackedSchemaInterceptor::GetTagMetaQuery(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells, LPCWSTR &o_wszTable, ULONG &o_TableID, ULONG &o_PropertyIndex) const
{
    o_PropertyIndex = (ULONG)-1;
    o_wszTable      = 0;
    o_TableID       = 0;
    //The only queries we support for TAG_META is by the table or table/property index.  BUT there are two ways of specifiying
    //the table: either by TableID or by InternalName.  InternalName is the PK so it is queried by iCell==iCOLLECTION_META_InternalName.
    //TableID is a an iST_CELL_SPECIAL (just like iST_CELL_FILE), so we check for iCell==iST_CELL_TABLEID also.
    //So walk the list looking for this query
    for(; i_cQueryCells; --i_cQueryCells, ++i_pQueryCell)
    {   //Walk the Query cells looking for one that matches the following criteria
        switch(i_pQueryCell->iCell)
        {
        case iTAG_META_Table:
            if( 0                         == o_wszTable       &&
                i_pQueryCell->eOperator   == eST_OP_EQUAL     &&
                i_pQueryCell->dbType      == DBTYPE_WSTR      &&
                i_pQueryCell->pData       != 0)
            {
                o_wszTable = reinterpret_cast<LPCWSTR>(i_pQueryCell->pData);
            }
            else
                return E_ST_INVALIDQUERY;
            break;
        case iTAG_META_ColumnIndex:
            if( -1                        == o_PropertyIndex  &&
                i_pQueryCell->eOperator   == eST_OP_EQUAL     &&
                i_pQueryCell->dbType      == DBTYPE_UI4       &&
                i_pQueryCell->pData       != 0)
            {
                o_PropertyIndex = *(reinterpret_cast<ULONG *>(i_pQueryCell->pData));
            }
            else
                return E_ST_INVALIDQUERY;
            break;
        case iST_CELL_TABLEID:
            if( 0                         == o_TableID        &&
                i_pQueryCell->eOperator   == eST_OP_EQUAL     &&
                i_pQueryCell->dbType      == DBTYPE_UI4       &&
                i_pQueryCell->pData       != 0)
            {
                o_TableID = *(reinterpret_cast<ULONG *>(i_pQueryCell->pData));
            }
            else
                return E_ST_INVALIDQUERY;
            break;
        default:
            if(0 == (i_pQueryCell->iCell & iST_CELL_SPECIAL))//The above cell is the only non-reserved cell we support
                return E_ST_INVALIDQUERY;                       //and we're supposed to ignore all reserved cell we don't understand
            break;
        }
    }
    if(0==o_wszTable && 0==o_TableID)//The Query MUST provide a table name OR the TableID
        return E_ST_INVALIDQUERY;

    return S_OK;
}


HRESULT TFixedPackedSchemaInterceptor::GetTagMetaTable(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells)
{
    //TAG_META must be supplied a table name or table name/property index (NOTE: we don't currently support table name/property index/tag name query)
    HRESULT hr;
    ULONG   PropertyIndex   = (ULONG)-1;
    ULONG   TableID         = 0;
    LPCWSTR wszTable        = 0;
    if(FAILED(hr = GetTagMetaQuery(i_pQueryCell, i_cQueryCells, wszTable, TableID, PropertyIndex)))
        return hr;

    if(0 == TableID)//If the TableID wasn't supplied in the query, we need to search for it by TableName
    {
        //So map the table name to an ID
        if(FAILED(hr = GetTableID(wszTable, TableID)))
            return hr;
    }
#ifdef _DEBUG
    else if(wszTable)//If the query included both the TableID AND the Collection Name, then verify that the ID matches the Collection name.
    {
        ULONG TableIDTemp;
        if(FAILED(hr = GetTableID(wszTable, TableIDTemp)))
            return hr;
        if(TableIDTemp != TableID)
            return E_ST_INVALIDQUERY;
    }
#endif
    //Once we have the TableID it's just a straight forward lookup
    if(FAILED(hr = m_TableSchema.Init(m_TableSchemaHeap.Get_TableSchema(TableID))))
        return hr;

    m_pFixedData                    = reinterpret_cast<const ULONG *>(m_TableSchema.GetTagMeta(PropertyIndex));
    m_ciRows                        = (-1 == PropertyIndex ? m_TableSchema.GetCollectionMeta()->CountOfTags : m_TableSchema.GetPropertyMeta(PropertyIndex)->CountOfTags);
    m_cColumns                      = kciTagMetaPublicColumns;
    m_cColumnsPlusPrivateColumns    = m_cColumns + kciTagMetaPrivateColumns;
    m_MetaTable                        = m_eTagMeta;

    m_pSimpleColumnMeta     = m_pTableSchemaHeap->Get_aSimpleColumnMeta(m_pTableSchemaHeap->eTagMeta);
    m_TableMeta_MetaFlags   = fTABLEMETA_INTERNAL | fTABLEMETA_NOLISTENING;
    m_TableMeta_BaseVersion = 0;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\fixedschemainterceptor\fixedpackedschemainterceptor.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

// ------------------------------------------------------------------
// class TFixedPackedSchemaInterceptor:
// ------------------------------------------------------------------
class TFixedPackedSchemaInterceptor :
    public ISimpleTableInterceptor,
    public ISimpleTableRead2,
    public ISimpleTableAdvanced
{
public:
    TFixedPackedSchemaInterceptor ();
    ~TFixedPackedSchemaInterceptor ();

// -----------------------------------------
// IUnknown, IClassFactory, ISimpleLogicTableDispenser:
// -----------------------------------------

//IUnknown
public:
    STDMETHOD (QueryInterface)      (REFIID riid, OUT void **ppv);
    STDMETHOD_(ULONG,AddRef)        ();
    STDMETHOD_(ULONG,Release)       ();

//ISimpleDataTableDispenser
public:
    STDMETHOD(Intercept) (
                        LPCWSTR                 i_wszDatabase,
                        LPCWSTR                 i_wszTable,
                        ULONG                   i_TableID,
                        LPVOID                  i_QueryData,
                        LPVOID                  i_QueryMeta,
                        DWORD                   i_eQueryFormat,
                        DWORD                   i_fTable,
                        IAdvancedTableDispenser* i_pISTDisp,
                        LPCWSTR                 i_wszLocator,
                        LPVOID                  i_pSimpleTable,
                        LPVOID*                 o_ppv
                        );

// -----------------------------------------
// ISimpleTable*:
// -----------------------------------------

//ISimpleTableRead2
public:
    STDMETHOD (GetRowIndexByIdentity)   (ULONG * i_cb, LPVOID * i_pv, ULONG* o_piRow);
    STDMETHOD (GetRowIndexBySearch) (ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
    {
        UNREFERENCED_PARAMETER(i_iStartingRow);
        UNREFERENCED_PARAMETER(i_cColumns);
        UNREFERENCED_PARAMETER(i_aiColumns);
        UNREFERENCED_PARAMETER(i_acbSizes);
        UNREFERENCED_PARAMETER(i_apvValues);
        UNREFERENCED_PARAMETER(o_piRow);

        return E_NOTIMPL;
    }
    STDMETHOD (GetColumnValues)     (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues);
    STDMETHOD (GetTableMeta)        (ULONG *o_pcVersion, DWORD * o_pfTable, ULONG * o_pcRows, ULONG * o_pcColumns );
    STDMETHOD (GetColumnMetas)      (ULONG i_cColumns, ULONG* i_aiColumns, SimpleColumnMeta* o_aColumnMetas);

//ISimpleTableAdvanced
public:
    STDMETHOD (PopulateCache)           ();
    STDMETHOD (GetDetailedErrorCount)   (ULONG* o_pcErrs);
    STDMETHOD (GetDetailedError)        (ULONG i_iErr, STErr* o_pSTErr);
    STDMETHOD (ResetCaches)				();
    STDMETHOD (GetColumnValuesEx)		(ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, DWORD* o_afStatus, ULONG* o_acbSizes, LPVOID* o_apvValues);


    static HRESULT GetTableID(LPCWSTR /*i_wszDatabaseName*/, LPCWSTR i_wszTableName, ULONG &o_TableID);
    static HRESULT GetTableID(LPCWSTR i_wszTableName, ULONG &o_TableID);
    static HRESULT GetTableName(ULONG i_TableID, LPCWSTR &o_wszTableName);
    static HRESULT GetTableName(ULONG i_TableID, LPCWSTR &o_wszTableName, LPCWSTR &o_wszDatabaseName);

// -----------------------------------------
// Member variables:
// -----------------------------------------

private:
    //static members first
    static const unsigned long                  m_aColumnIndex[0x30];
    static const TableSchema::TableSchemaHeap * m_pTableSchemaHeap;
    const TableSchema::TableSchemaHeap        & m_TableSchemaHeap;

    enum
    {
        m_eUnknownMeta      = 0,
        m_eServerWiringMeta = 1,
        m_eCollectionMeta   = 3,
        m_ePropertyMeta     = 4,
        m_eTagMeta          = 5
    } m_MetaTable;

    ULONG                           m_cColumns;
    ULONG                           m_cColumnsPlusPrivateColumns;
    ULONG                           m_ciRows;
    ULONG                           m_cRef;
    ULONG                           m_fIsTable;
    const ULONG                 *   m_pFixedData;//This abstracts which PACKED_META table is being served up
    const SimpleColumnMeta      *   m_pSimpleColumnMeta;//There is a minimal amount of ColumnMeta needed for these FixedPackedSchema table.
                                                        //Looking up the CollectionMeta's PropertyMeta will incur an extra page hit.  So
                                                        //the TFixedPackedSchemaInterceptor only relies on SimpleColumnMeta and NOT the full PropertyMeta.
    ULONG                           m_TableMeta_MetaFlags;
    ULONG                           m_TableMeta_BaseVersion;
    TableSchema::TTableSchema       m_TableSchema;

    inline int              StringInsensitiveCompare(LPCWSTR sz1, LPCWSTR sz2) const {return _wcsicmp(sz1, sz2);}
    HRESULT                 GetClientWiringMetaTable(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells);
    HRESULT                 GetCollectionMetaQuery(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells, LPCWSTR &o_wszTable, ULONG &o_TableID) const;
    HRESULT                 GetCollectionMetaTable(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells);
    HRESULT                 GetColumnValues(TableSchema::TTableSchema &i_TableSchema, const ULONG *i_pFixedData, ULONG i_ciRows, ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues) const;
    HRESULT                 GetPropertyMetaQuery(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells, LPCWSTR &o_wszTable, ULONG &o_TableID, ULONG &o_PropertyIndex) const;
    HRESULT                 GetPropertyMetaTable(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells);
    HRESULT                 GetServerWiringMetaQuery(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells) const;
    HRESULT                 GetServerWiringMetaTable(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells);
    HRESULT                 GetTagMetaQuery(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells, LPCWSTR &o_wszTable, ULONG &o_TableID, ULONG &o_PropertyIndex) const;
    HRESULT                 GetTagMetaTable(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\fixedtable\sdtfxd_com.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "precomp.hxx"

// -----------------------------------------
// CSDTFxd: IUnknown
// -----------------------------------------

// =======================================================================
STDMETHODIMP CSDTFxd::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv)
		return E_INVALIDARG;
	*ppv = NULL;

	if (!m_fIsTable) // ie: Component is posing as class factory / dispenser:
	{
		if (riid == IID_ISimpleTableInterceptor)
		{
			*ppv = (ISimpleTableInterceptor*) this;
		}
		else if (riid == IID_IUnknown)
		{
			*ppv = (ISimpleTableInterceptor*) this;
		}
	}
	else // ie: Component is currently posing as data table:
	{
		if (riid == IID_IUnknown)
		{
			*ppv = (ISimpleTableRead2*) this;
		}
		else if (riid == IID_ISimpleTableRead2)
		{
			*ppv = (ISimpleTableRead2*) this;
		}
		else if (riid == IID_ISimpleTableAdvanced)
		{
			*ppv = (ISimpleTableAdvanced*) this;
		}
	}


	if (NULL != *ppv)
	{
		((ISimpleTableWrite2*)this)->AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}

}

// =======================================================================
STDMETHODIMP_(ULONG) CSDTFxd::AddRef()
{
	return InterlockedIncrement((LONG*) &m_cRef);

}

// =======================================================================
STDMETHODIMP_(ULONG) CSDTFxd::Release()
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\fixedtable\sdtfxd.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "precomp.hxx"

#define UI4FromIndex(i)         (*reinterpret_cast<const ULONG *>(m_pFixedTableHeap->Get_PooledData(i)))
#define StringFromIndex(i)      ( const_cast<WCHAR *>(reinterpret_cast<const WCHAR *>(m_pFixedTableHeap->Get_PooledData(i))))
#define GuidPointerFromIndex(i) ( const_cast<GUID *> (reinterpret_cast<const GUID *> (m_pFixedTableHeap->Get_PooledData(i))))
#define BytePointerFromIndex(i) ( const_cast<unsigned char *>(reinterpret_cast<const unsigned char *> (m_pFixedTableHeap->Get_PooledData(i))))
#undef String
#define String(x)           (StringFromIndex(x) ? StringFromIndex(x) : L"(null)")
#define StringBufferLengthFromIndex(i)  (i ? reinterpret_cast<ULONG *>(m_pFixedTableHeap->Get_PooledData(i))[-1] : 0)
void DumpTables();

extern HMODULE g_hModule;             // our dll's module handle
CSafeAutoCriticalSection TBinFileMappingCache::m_CriticalSection;//The list is a globally shared resource, so we have to guard it.
TBinFileMappingCache *   TBinFileMappingCache::m_pFirst=0;

//This gets rid of an 'if' inside a loop in GetColumnValues.  Since this function is called more than any other, even one 'if' should make a difference,
//especially when it's inside the 'for' loop.
unsigned long  aColumnIndex[512] = {
        0x00,   0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,   0x09,   0x0a,   0x0b,   0x0c,   0x0d,   0x0e,   0x0f,
        0x10,   0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,   0x19,   0x1a,   0x1b,   0x1c,   0x1d,   0x1e,   0x1f,
        0x20,   0x21,   0x22,   0x23,   0x24,   0x25,   0x26,   0x27,   0x28,   0x29,   0x2a,   0x2b,   0x2c,   0x2d,   0x2e,   0x2f,
        0x30,   0x31,   0x32,   0x33,   0x34,   0x35,   0x36,   0x37,   0x38,   0x39,   0x3a,   0x3b,   0x3c,   0x3d,   0x3e,   0x3f,
        0x40,   0x41,   0x42,   0x43,   0x44,   0x45,   0x46,   0x47,   0x48,   0x49,   0x4a,   0x4b,   0x4c,   0x4d,   0x4e,   0x4f,
        0x50,   0x51,   0x52,   0x53,   0x54,   0x55,   0x56,   0x57,   0x58,   0x59,   0x5a,   0x5b,   0x5c,   0x5d,   0x5e,   0x5f,
        0x60,   0x61,   0x62,   0x63,   0x64,   0x65,   0x66,   0x67,   0x68,   0x69,   0x6a,   0x6b,   0x6c,   0x6d,   0x6e,   0x6f,
        0x70,   0x71,   0x72,   0x73,   0x74,   0x75,   0x76,   0x77,   0x78,   0x79,   0x7a,   0x7b,   0x7c,   0x7d,   0x7e,   0x7f,
        0x80,   0x81,   0x82,   0x83,   0x84,   0x85,   0x86,   0x87,   0x88,   0x89,   0x8a,   0x8b,   0x8c,   0x8d,   0x8e,   0x8f,
        0x90,   0x91,   0x92,   0x93,   0x94,   0x95,   0x96,   0x97,   0x98,   0x99,   0x9a,   0x9b,   0x9c,   0x9d,   0x9e,   0x9f,
        0xa0,   0xa1,   0xa2,   0xa3,   0xa4,   0xa5,   0xa6,   0xa7,   0xa8,   0xa9,   0xaa,   0xab,   0xac,   0xad,   0xae,   0xaf,
        0xb0,   0xb1,   0xb2,   0xb3,   0xb4,   0xb5,   0xb6,   0xb7,   0xb8,   0xb9,   0xba,   0xbb,   0xbc,   0xbd,   0xbe,   0xbf,
        0xc0,   0xc1,   0xc2,   0xc3,   0xc4,   0xc5,   0xc6,   0xc7,   0xc8,   0xc9,   0xca,   0xcb,   0xcc,   0xcd,   0xce,   0xcf,
        0xd0,   0xd1,   0xd2,   0xd3,   0xd4,   0xd5,   0xd6,   0xd7,   0xd8,   0xd9,   0xda,   0xdb,   0xdc,   0xdd,   0xde,   0xdf,
        0xe0,   0xe1,   0xe2,   0xe3,   0xe4,   0xe5,   0xe6,   0xe7,   0xe8,   0xe9,   0xea,   0xeb,   0xec,   0xed,   0xee,   0xef,
        0xf0,   0xf1,   0xf2,   0xf3,   0xf4,   0xf5,   0xf6,   0xf7,   0xf8,   0xf9,   0xfa,   0xfb,   0xfc,   0xfd,   0xfe,   0xff,
       0x100,  0x101,  0x102,  0x103,  0x104,  0x105,  0x106,  0x107,  0x108,  0x109,  0x10a,  0x10b,  0x10c,  0x10d,  0x10e,  0x10f,
       0x110,  0x111,  0x112,  0x113,  0x114,  0x115,  0x116,  0x117,  0x118,  0x119,  0x11a,  0x11b,  0x11c,  0x11d,  0x11e,  0x11f,
       0x120,  0x121,  0x122,  0x123,  0x124,  0x125,  0x126,  0x127,  0x128,  0x129,  0x12a,  0x12b,  0x12c,  0x12d,  0x12e,  0x12f,
       0x130,  0x131,  0x132,  0x133,  0x134,  0x135,  0x136,  0x137,  0x138,  0x139,  0x13a,  0x13b,  0x13c,  0x13d,  0x13e,  0x13f,
       0x140,  0x141,  0x142,  0x143,  0x144,  0x145,  0x146,  0x147,  0x148,  0x149,  0x14a,  0x14b,  0x14c,  0x14d,  0x14e,  0x14f,
       0x150,  0x151,  0x152,  0x153,  0x154,  0x155,  0x156,  0x157,  0x158,  0x159,  0x15a,  0x15b,  0x15c,  0x15d,  0x15e,  0x15f,
       0x160,  0x161,  0x162,  0x163,  0x164,  0x165,  0x166,  0x167,  0x168,  0x169,  0x16a,  0x16b,  0x16c,  0x16d,  0x16e,  0x16f,
       0x170,  0x171,  0x172,  0x173,  0x174,  0x175,  0x176,  0x177,  0x178,  0x179,  0x17a,  0x17b,  0x17c,  0x17d,  0x17e,  0x17f,
       0x180,  0x181,  0x182,  0x183,  0x184,  0x185,  0x186,  0x187,  0x188,  0x189,  0x18a,  0x18b,  0x18c,  0x18d,  0x18e,  0x18f,
       0x190,  0x191,  0x192,  0x193,  0x194,  0x195,  0x196,  0x197,  0x198,  0x199,  0x19a,  0x19b,  0x19c,  0x19d,  0x19e,  0x19f,
       0x1a0,  0x1a1,  0x1a2,  0x1a3,  0x1a4,  0x1a5,  0x1a6,  0x1a7,  0x1a8,  0x1a9,  0x1aa,  0x1ab,  0x1ac,  0x1ad,  0x1ae,  0x1af,
       0x1b0,  0x1b1,  0x1b2,  0x1b3,  0x1b4,  0x1b5,  0x1b6,  0x1b7,  0x1b8,  0x1b9,  0x1ba,  0x1bb,  0x1bc,  0x1bd,  0x1be,  0x1bf,
       0x1c0,  0x1c1,  0x1c2,  0x1c3,  0x1c4,  0x1c5,  0x1c6,  0x1c7,  0x1c8,  0x1c9,  0x1ca,  0x1cb,  0x1cc,  0x1cd,  0x1ce,  0x1cf,
       0x1d0,  0x1d1,  0x1d2,  0x1d3,  0x1d4,  0x1d5,  0x1d6,  0x1d7,  0x1d8,  0x1d9,  0x1da,  0x1db,  0x1dc,  0x1dd,  0x1de,  0x1df,
       0x1e0,  0x1e1,  0x1e2,  0x1e3,  0x1e4,  0x1e5,  0x1e6,  0x1e7,  0x1e8,  0x1e9,  0x1ea,  0x1eb,  0x1ec,  0x1ed,  0x1ee,  0x1ef,
       0x1f0,  0x1f1,  0x1f2,  0x1f3,  0x1f4,  0x1f5,  0x1f6,  0x1f7,  0x1f8,  0x1f9,  0x1fa,  0x1fb,  0x1fc,  0x1fd,  0x1fe,  0x1ff,
    };


// ==================================================================
CSDTFxd::CSDTFxd () :
      m_bDidMeta                (false)
    , m_cColumns                (0)
    , m_cIndexMeta              (0)
    , m_ciRows                  (0)
    , m_cPrimaryKeys            (0)
    , m_cRef                    (0)
    , m_fIsTable                (0)
    , m_iZerothRow              (0)
    , m_pColumnMeta             (0)
    , m_pFixedTable             (0)
    , m_pFixedTableHeap         (g_pFixedTableHeap)//We'll assume the global heap unless the user specifies extended meta
    , m_pFixedTableUnqueried    (0)
    , m_pHashedIndex            (0)
    , m_pHashTableHeader        (0)
    , m_pIndexMeta              (0)
    , m_pTableMeta              (0)
{
}
// ==================================================================
CSDTFxd::~CSDTFxd ()
{
    TBinFileMappingCache::ReleaseFileMappingPointer(m_pFixedTableHeap);
}


// ------------------------------------
// ISimpleDataTableDispenser:
// ------------------------------------

// ==================================================================
STDMETHODIMP CSDTFxd::Intercept
(
    LPCWSTR					i_wszDatabase,
    LPCWSTR					i_wszTable,
	ULONG					i_TableID,
    LPVOID					i_QueryData,
    LPVOID					i_QueryMeta,
    DWORD					i_eQueryFormat,
	DWORD					i_fTable,
	IAdvancedTableDispenser * i_pISTDisp,
    LPCWSTR					i_wszLocator,
	LPVOID					i_pSimpleTable,
    LPVOID*					o_ppv
)
{
    STQueryCell           * pQueryCell = (STQueryCell*) i_QueryData;    // Query cell array from caller.
    ULONG                   cQueryCells = 0;
    HRESULT                 hr;

    UNREFERENCED_PARAMETER(i_pISTDisp);
    UNREFERENCED_PARAMETER(i_TableID);

    //There are only a few ways we can be queried
    //If we're given no queries, we just walk the g_aDatabaseMeta table and find the wszDatabase, then walk the TableArray that it points to and find the table.
    //If we ARE given a query, ASSERT that i_wszDatabase is wszDATABASEMETA (wszDATABASE_WIRING doesn't support queries)
    //if wszDATABASE_META then switch on the i_wszTable

	if (i_pSimpleTable)
		return E_INVALIDARG;
    if (i_QueryMeta)
         cQueryCells= *(ULONG *)i_QueryMeta;

    ASSERT(!m_fIsTable);if(m_fIsTable)return E_UNEXPECTED; // ie: Assert component is posing as class factory / dispenser.

// Parameter validation:
    if(NULL == i_wszDatabase)                   return E_INVALIDARG;
    if(NULL == i_wszTable)                      return E_INVALIDARG;
    if(NULL == o_ppv)                           return E_INVALIDARG;
    if(eST_QUERYFORMAT_CELLS != i_eQueryFormat) return E_ST_QUERYNOTSUPPORTED;
    if(NULL != i_wszLocator)                    return E_INVALIDARG;
    if((fST_LOS_READWRITE | fST_LOS_MARSHALLABLE | fST_LOS_UNPOPULATED | fST_LOS_REPOPULATE | fST_LOS_MARSHALLABLE) & i_fTable)
                                                return E_ST_LOSNOTSUPPORTED;
    *o_ppv = NULL;

    if(cQueryCells>0)
    {
        for(ULONG i=0; i<cQueryCells && 0!=(pQueryCell[i].iCell & iST_CELL_SPECIAL);++i)
            if(pQueryCell[i].iCell == iST_CELL_FILE || pQueryCell[i].iCell == iST_CELL_SCHEMAFILE)
                TBinFileMappingCache::GetFileMappingPointer(reinterpret_cast<LPCWSTR>(pQueryCell[i].pData), m_pFixedTableHeap);
    }

// Determine table type:
    if(0 == StringInsensitiveCompare(i_wszDatabase, wszDATABASE_META))
    {
        hr = E_ST_INVALIDTABLE;
        switch(i_wszTable[0])
        {
        case L'c':
        case L'C':
            if(0 == lstrcmpi(i_wszTable, wszTABLE_COLUMNMETA))         hr = GetColumnMetaTable(  pQueryCell, cQueryCells);
            break;
            //TRACE(TEXT("Error! ColumnMeta should come from the fixed packed interceptor!\n"));
            //ASSERT(false && "Error! ColumnMeta should come from the fixed packed interceptor!");
            //break;
        case L'd':
        case L'D':
            if(0 == lstrcmpi(i_wszTable, wszTABLE_DATABASEMETA ))      hr = GetDatabaseMetaTable(  pQueryCell, cQueryCells);
            break;
        case L'i':
        case L'I':
            if(0 == lstrcmpi(i_wszTable, wszTABLE_INDEXMETA    ))      hr = GetIndexMetaTable(     pQueryCell, cQueryCells);
            break;
        case L'q':
        case L'Q':
            if(0 == lstrcmpi(i_wszTable, wszTABLE_QUERYMETA    ))      hr = GetQueryMetaTable(     pQueryCell, cQueryCells);
            break;
        case L'r':
        case L'R':
            if(0 == lstrcmpi(i_wszTable, wszTABLE_RELATIONMETA ))      hr = GetRelationMetaTable(  pQueryCell, cQueryCells);
            break;
        case L't':
        case L'T':
            // Only extesible schema comes from here - the rest comes from the fixed pachked interceptor
            if(0 == lstrcmpi(i_wszTable, wszTABLE_TABLEMETA ))         hr = GetTableMetaTable(     pQueryCell, cQueryCells);
            else if(0 == lstrcmpi(i_wszTable, wszTABLE_TAGMETA ))      hr = GetTagMetaTable(       pQueryCell, cQueryCells);
            else
            {
                ASSERT(false && L"What table is this?  We should only be called for TableMeta or TagMeta for extensible schema!!");
                return E_ST_INVALIDTABLE;
            }
            break;
        default:
            break;
        }
        if(FAILED(hr) && E_ST_NOMOREROWS != hr)
            return hr;

        //Now see if there's any special indexing
        if(FAILED(hr = GetIndexMeta(pQueryCell, cQueryCells)))return hr;
    }
    else
    {
        //Fixed Tables that are not Meta tables are not allowed to be queried
        for(ULONG i=0; i<cQueryCells;++i)
            if(0 == (pQueryCell[i].iCell & iST_CELL_SPECIAL))
                return E_ST_INVALIDQUERY;


        //FixedTables
        unsigned long cTables =0;
		unsigned long iRow;

        //Walk the Fixed Databases (it's an overloaded use of the DatabaseMeta structure)
        m_pTableMeta = NULL;
        for(iRow = 0; iRow < m_pFixedTableHeap->Get_cDatabaseMeta(); iRow++)
            if (0 == StringInsensitiveCompare(i_wszDatabase, StringFromIndex(m_pFixedTableHeap->Get_aDatabaseMeta(iRow)->InternalName)))
            {
                m_pTableMeta    = m_pFixedTableHeap->Get_aTableMeta(m_pFixedTableHeap->Get_aDatabaseMeta(iRow)->iTableMeta);
                cTables         = UI4FromIndex(m_pFixedTableHeap->Get_aDatabaseMeta(iRow)->CountOfTables);
                break;
            }

        if(NULL == m_pTableMeta)//If the Database is not found then error
            return E_INVALIDARG;

        for (iRow = 0; iRow < cTables; iRow++, m_pTableMeta++)//Walk the Tables in that Database
            if (0 == StringInsensitiveCompare(i_wszTable, StringFromIndex(m_pTableMeta->InternalName)))
                break;

        if(iRow == cTables)               //if we walked the entire list without finding a matching tid,
            return E_ST_INVALIDTABLE;   //return Tid not recognized

        if(static_cast<long>(m_pTableMeta->iFixedTable) <= 0)//If the database and table are found but the iFixedTable member is <= 0 then no table to dispense
            return E_ST_INVALIDTABLE;

        m_pFixedTable       = m_pFixedTableHeap->Get_aULONG(m_pTableMeta->iFixedTable); //iFixedTable is an index into ULONG pool
        m_pFixedTableUnqueried = m_pFixedTable;//we don't support queries on fixed tables other than Meta tables
        m_pColumnMeta       = m_pFixedTableHeap->Get_aColumnMeta(m_pTableMeta->iColumnMeta);
        m_pHashedIndex      = m_pTableMeta->iHashTableHeader ? m_pFixedTableHeap->Get_HashedIndex(m_pTableMeta->iHashTableHeader + 1) : 0;
        m_pHashTableHeader  = m_pTableMeta->iHashTableHeader ? m_pFixedTableHeap->Get_HashHeader(m_pTableMeta->iHashTableHeader) : 0;
        m_ciRows = m_pTableMeta->ciRows;
        ASSERT(0 != m_ciRows);//We don't have any Fixed tables that are empty so ASSERT that.
        m_cColumnsPlusPrivate = UI4FromIndex(m_pTableMeta->CountOfColumns);
    }
    m_cColumns              = UI4FromIndex(m_pTableMeta->CountOfColumns);

    //We do this up front, it will save us time in the long run
    for(unsigned long iColumn=0; iColumn<m_cColumns; ++iColumn)
    {
        if(UI4FromIndex(m_pColumnMeta[iColumn].MetaFlags) & fCOLUMNMETA_PRIMARYKEY)
            m_cPrimaryKeys++;
    }

// Supply ISimpleTable* and transition state from class factory / dispenser to data table:
    *o_ppv = (ISimpleTableRead2*) this;
    AddRef ();
    InterlockedIncrement ((LONG*) &m_fIsTable);

    hr = S_OK;
    return hr;
}


// ------------------------------------
// ISimpleTableRead2:
// ------------------------------------

// ==================================================================
STDMETHODIMP CSDTFxd::GetRowIndexByIdentity( ULONG*  i_cb, LPVOID* i_pv, ULONG* o_piRow)
{
    if(0 != i_cb    )return E_INVALIDARG;
    if(0 == o_piRow )return E_INVALIDARG;
    if(0 == i_pv    )return E_INVALIDARG;
    if(0 == m_ciRows)return E_ST_NOMOREROWS;

    if(m_pHashedIndex && 1!=m_ciRows)//If the table has a hash table, then use it.
    {
        ULONG       iColumn, iPK, RowHash=0;
		for(iColumn = 0, iPK = 0; iPK < m_cPrimaryKeys; iColumn++)
		{
			if (fCOLUMNMETA_PRIMARYKEY & UI4FromIndex(m_pColumnMeta[iColumn].MetaFlags))
			{
                if(0 == i_pv[iPK])
                    return E_INVALIDARG;//NULL PK is invalid

                switch(UI4FromIndex(m_pColumnMeta[iColumn].Type))
                {
                case DBTYPE_GUID:
                    RowHash = Hash( *reinterpret_cast<GUID *>(i_pv[iPK]), RowHash );break;
                case DBTYPE_WSTR:
                    RowHash = Hash( reinterpret_cast<LPCWSTR>(i_pv[iPK]), RowHash );break;
                case DBTYPE_UI4:
                    RowHash = Hash( *reinterpret_cast<ULONG *>(i_pv[iPK]), RowHash );break;
                case DBTYPE_BYTES:
                    ASSERT (0 != i_cb);
                    RowHash = Hash( reinterpret_cast<unsigned char *>(i_pv[iPK]), i_cb[iPK], RowHash );break;
                default:
                    ASSERT (false && "We don't support PKs of type DBTYPE_BYTES yet.");//@@@
                    return E_UNEXPECTED;
                }
                ++iPK;
            }
        }

        const HashedIndex * pHashedIndex = &m_pHashedIndex[RowHash % m_pHashTableHeader->Modulo];
        if(-1 == pHashedIndex->iOffset)//If the hash slot is empty then bail.
            return E_ST_NOMOREROWS;

        //After we get the HashedIndex we need to verify that it really matches.  Also if there is more than one, then walk the list.
        bool bMatch=false;                                 //-1 iNext value indicated the end of the list
        for(;; pHashedIndex = &m_pHashedIndex[pHashedIndex->iNext])
        {
    		for(iColumn = 0, iPK = 0; iPK < m_cPrimaryKeys; iColumn++)
            {
			    if(fCOLUMNMETA_PRIMARYKEY & UI4FromIndex(m_pColumnMeta[iColumn].MetaFlags))
			    {
				    bMatch = false;
                    unsigned long index = *(reinterpret_cast<const DWORD*>(m_pFixedTableUnqueried) + (m_cColumnsPlusPrivate * pHashedIndex->iOffset) + iColumn);
				    switch(UI4FromIndex(m_pColumnMeta[iColumn].Type))
				    {
					    case DBTYPE_GUID:
						    bMatch = (0 == memcmp (GuidPointerFromIndex(index), i_pv[iPK], sizeof (GUID)));
    					    break;
					    case DBTYPE_WSTR:
                            if(IsStringFromPool(reinterpret_cast<LPWSTR>(i_pv[iPK])))//If the i_pv is a pointer from our pool, then just compare the pointers
                                bMatch = (StringFromIndex(index) == reinterpret_cast<LPWSTR>(i_pv[iPK]));
                            else
                                bMatch = (0 == StringInsensitiveCompare(StringFromIndex(index), reinterpret_cast<LPWSTR>(i_pv[iPK])));
    					    break;
					    case DBTYPE_UI4:
						    bMatch = (UI4FromIndex(index) == *(ULONG*)(i_pv[iPK]));
    					    break;
					    default:
						    ASSERT (0); // ie: Remaining types not currently supported as primary keys.
    					    return E_UNEXPECTED;
				    }
				    iPK++;
				    if(!bMatch)
					    break;
			    }
            }
            if(bMatch)
                break;
            if(-1 == pHashedIndex->iNext)
                break;
        }
        if(!bMatch)
            return E_ST_NOMOREROWS;

        if(pHashedIndex->iOffset < m_iZerothRow)
            return E_ST_NOMOREROWS;
        if(pHashedIndex->iOffset >= (m_iZerothRow + m_ciRows))
            return E_ST_NOMOREROWS;

        *o_piRow = pHashedIndex->iOffset - m_iZerothRow;
        return S_OK;
    }
    else//Currently there is only one Fixed Table that does not have a hash table (RelationMeta).  As soon as we get a hash table for it we can eliminate the else.
    {
        ULONG       iColumn, iRow, iPK;
        BOOL        fMatch;

        for (iRow = 0, fMatch = FALSE; iRow < m_ciRows; iRow++)
	    {
		    for (iColumn = 0, iPK = 0; iColumn < m_cColumns; iColumn++)
		    {
			    if (fCOLUMNMETA_PRIMARYKEY & UI4FromIndex(m_pColumnMeta[iColumn].MetaFlags))
			    {
				    fMatch = FALSE;
                    unsigned long index = *(reinterpret_cast<const DWORD *>(m_pFixedTable) + (m_cColumnsPlusPrivate * iRow) + iColumn);
                    if(0 == i_pv[iPK])
                        return E_INVALIDARG;//NULL PK is invalid
				    switch (UI4FromIndex(m_pColumnMeta[iColumn].Type))
				    {
					    case DBTYPE_GUID:
						    if (0 == memcmp (GuidPointerFromIndex(index), i_pv[iPK], sizeof (GUID)))
						    {
							    fMatch = TRUE;
							    break;
						    }
					    break;
					    case DBTYPE_WSTR:
						    if (0 == StringInsensitiveCompare(StringFromIndex(index), reinterpret_cast<LPWSTR>(i_pv[iPK])))
						    {
							    fMatch = TRUE;
							    break;
						    }
					    break;
					    case DBTYPE_UI4:
						    if (UI4FromIndex(index) == *(ULONG*)(i_pv[iPK]))
						    {
							    fMatch = TRUE;
							    break;
						    }
					    break;
					    default:
						    ASSERT (0); // ie: Remaining types not currently supported as primary keys.
					    return E_UNEXPECTED;
				    }
				    iPK++;
				    if (!fMatch)
				    {
					    break;
				    }
			    }
		    }
		    if (fMatch)
		    {
			    break;
		    }
	    }
        if (fMatch)
        {
            *o_piRow = iRow;
            return S_OK;
        }
        else
        {
            return E_ST_NOMOREROWS;
        }
    }
}

STDMETHODIMP CSDTFxd::GetRowIndexBySearch(ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
{
    if(i_cColumns==0 && i_cColumns>=m_cColumns)return E_INVALIDARG;
    if(0 == o_piRow )return E_INVALIDARG;
    if(0 == m_ciRows)return E_ST_NOMOREROWS;

    ULONG * aColumns    = i_aiColumns ? i_aiColumns : aColumnIndex;

    bool bUsingIndexMetaHashTable = false;
    //If the query indicated a Unique index AND the rest of the parameters indicate that the search is by that index, then we can use the hash
    if(m_pIndexMeta && i_cColumns==m_cIndexMeta)//associated with this index
    {
        ULONG i;
        for(i=0;i<i_cColumns;++i)
        {
            if(i_aiColumns[i] != UI4FromIndex(m_pIndexMeta[i].ColumnIndex))
                break;
        }
        if(m_cIndexMeta == i)//If all of the column indexes match up with the IndexMeta.ColumnIndex
        {                    //then we're OK to use the hash table
            bUsingIndexMetaHashTable = true;
        }
    }

    if(bUsingIndexMetaHashTable)
    {
        ULONG       i, RowHash=0;
		for(i = 0; i< i_cColumns; i++)
		{
            ULONG iTarget = (i_cColumns==1) ? 0 : aColumns[i];

            if(0 == i_apvValues[iTarget])
                continue;//NULL is handle as nothing hashed


            switch(UI4FromIndex(m_pColumnMeta[aColumns[i]].Type))
            {
            case DBTYPE_GUID:
                RowHash = Hash( *reinterpret_cast<GUID *>(i_apvValues[iTarget]), RowHash );break;
            case DBTYPE_WSTR:
                RowHash = Hash( reinterpret_cast<LPCWSTR>(i_apvValues[iTarget]), RowHash );break;
            case DBTYPE_UI4:
                RowHash = Hash( *reinterpret_cast<ULONG *>(i_apvValues[iTarget]), RowHash );break;
            case DBTYPE_BYTES:
                if(0 != i_acbSizes)
                    return E_INVALIDARG;
                RowHash = Hash( reinterpret_cast<unsigned char *>(i_apvValues[iTarget]), i_acbSizes[iTarget], RowHash );break;
            default:
                ASSERT(false && L"Bogus type!");
                return E_FAIL;
            }
        }

        const HashedIndex     * pHashedIndex0th     = m_pFixedTableHeap->Get_HashedIndex(m_pIndexMeta->iHashTable+1);
        const HashTableHeader * pHashTableHeader    = m_pFixedTableHeap->Get_HashHeader(m_pIndexMeta->iHashTable);
        const HashedIndex     * pHashedIndex        = pHashedIndex0th + (RowHash % pHashTableHeader->Modulo);
        if(-1 == pHashedIndex->iOffset)//If the hash slot is empty then bail.
            return E_ST_NOMOREROWS;

        //After we get the HashedIndex we need to verify that it really matches.  Also if there is more than one, then walk the list.
        bool bMatch=false;                                 //-1 iNext value indicated the end of the list
        for(;;)
        {
            if((pHashedIndex->iOffset - m_iZerothRow)>=i_iStartingRow)//if the hash table points to a row that is less than the StartinRow (the first row the caller wishes to be considered), then go to the next.
			{
				for(ULONG i1 = 0; i1< i_cColumns; i1++)
				{
					unsigned long index = *(reinterpret_cast<const DWORD*>(m_pFixedTableUnqueried) + (m_cColumnsPlusPrivate * pHashedIndex->iOffset) + aColumns[i1]);
					ULONG iTarget = (i_cColumns==1) ? 0 : aColumns[i1];

					if(0 == i_apvValues[iTarget] && 0==index)
					{
						bMatch=true;
					}
					else
					{
						switch(UI4FromIndex(m_pColumnMeta[aColumns[i1]].Type))
						{
							case DBTYPE_GUID:
								bMatch = (0 == memcmp (GuidPointerFromIndex(index), i_apvValues[iTarget], sizeof (GUID)));
    							break;
							case DBTYPE_WSTR:
								if(IsStringFromPool(reinterpret_cast<LPWSTR>(i_apvValues[iTarget])))//If the i_apv is a pointer from our pool, then just compare the pointers
									bMatch = (StringFromIndex(index) == reinterpret_cast<LPWSTR>(i_apvValues[iTarget]));
								else
									bMatch = (0 == StringInsensitiveCompare(StringFromIndex(index), reinterpret_cast<LPWSTR>(i_apvValues[iTarget])));
    							break;
							case DBTYPE_UI4:
								bMatch = (UI4FromIndex(index) == *(ULONG*)(i_apvValues[iTarget]));
    							break;
							case DBTYPE_BYTES:
								{
									ASSERT(0 != i_acbSizes);//This should have laready been checked above
									ULONG cbSize= reinterpret_cast<ULONG *>(BytePointerFromIndex(index))[-1];
									bMatch = (cbSize==i_acbSizes[iTarget] && 0 == memcmp(BytePointerFromIndex(index), i_apvValues[iTarget], cbSize));
								}
								break;
							default:
								ASSERT(false && L"Bogus type!");
								return E_FAIL;
						}
					}
					if(!bMatch)
						break;
				}
			}
            if(bMatch)//break if we found a match
				break;

			if(-1 == pHashedIndex->iNext)
                break;//break if were at the end

			pHashedIndex = &pHashedIndex0th[pHashedIndex->iNext];
        }
        if(!bMatch)
            return E_ST_NOMOREROWS;

        if(pHashedIndex->iOffset < m_iZerothRow+i_iStartingRow)
            return E_ST_NOMOREROWS;
        if(pHashedIndex->iOffset >= (m_iZerothRow + m_ciRows))
            return E_ST_NOMOREROWS;

        *o_piRow = pHashedIndex->iOffset - m_iZerothRow;
    }
    else//If we can't use our IndexMeta hash table then we'll have to do a linear search
    {
        ULONG       i, iRow;
        bool        bMatch=false;

        for (iRow = i_iStartingRow; iRow < m_ciRows; iRow++)
	    {
		    for (i = 0; i < i_cColumns; i++)
		    {
				bMatch = false;
                unsigned long index = *(reinterpret_cast<const DWORD *>(m_pFixedTable) + (m_cColumnsPlusPrivate * iRow) + aColumns[i]);

                ULONG iTarget = (i_cColumns==1) ? 0 : aColumns[i];

                if(0 == i_apvValues[iTarget] && 0==index)
                {
                    bMatch = true;
                }
                else
                {
				    switch (UI4FromIndex(m_pColumnMeta[aColumns[i]].Type))
				    {
					    case DBTYPE_GUID:
						    bMatch = (0 == memcmp (GuidPointerFromIndex(index), i_apvValues[iTarget], sizeof (GUID)));
                            break;
					    break;
					    case DBTYPE_WSTR:
                            if(IsStringFromPool(reinterpret_cast<LPWSTR>(i_apvValues[iTarget])))//If the i_apv is a pointer from our pool, then just compare the pointers
                                bMatch = (StringFromIndex(index) == reinterpret_cast<LPWSTR>(i_apvValues[iTarget]));
                            else
                                bMatch = (0 == StringInsensitiveCompare(StringFromIndex(index), reinterpret_cast<LPWSTR>(i_apvValues[iTarget])));
						    break;
					    break;
					    case DBTYPE_UI4:
						    bMatch = (UI4FromIndex(index) == *(ULONG*)(i_apvValues[iTarget]));
                            break;
					    break;
					    case DBTYPE_BYTES:
                            {
                                if(0 != i_acbSizes)
                                    return E_INVALIDARG;
                                ULONG cbSize= reinterpret_cast<ULONG *>(BytePointerFromIndex(index))[-1];
                                bMatch = (cbSize==i_acbSizes[iTarget] && 0 == memcmp(BytePointerFromIndex(index), i_apvValues[iTarget], cbSize));
                            }
                            break;
					    default:
						    ASSERT (0); // ie: Remaining types not currently supported as primary keys.
					    return E_UNEXPECTED;
				    }
                }
				if(!bMatch)
				    break;
		    }
            if(bMatch)
                break;
	    }
        if(bMatch)
            *o_piRow = iRow;
        else
            return E_ST_NOMOREROWS;
    }
    return S_OK;
}

// ==================================================================
STDMETHODIMP CSDTFxd::GetColumnValues(ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues)
{
// Validate in params
    if(  m_ciRows <= i_iRow     )return E_ST_NOMOREROWS;
    if(         0 == o_apvValues)return E_INVALIDARG;
    if(i_cColumns <= 0          )return E_INVALIDARG;
    if(i_cColumns >  m_cColumns)return E_ST_NOMORECOLUMNS;

    ULONG   ipv;
    ULONG   iColumn;
    ULONG	iTarget;
    HRESULT hr          = S_OK;
    ULONG * aColumns    = i_aiColumns ? i_aiColumns : aColumnIndex;

// Read data and populate out params
    ipv=0;
    //The following duplicate code eliminates an 'if' inside the for loop (below).
    {
        iColumn = aColumns[ipv];

	// If caller needs one column only, he doesn't need to pass a buffer for all the columns.
		iTarget = (i_cColumns == 1) ? 0 : iColumn;

    // Validate column index
        if(m_cColumns <= iColumn)
        {
            hr = E_ST_NOMORECOLUMNS;
            goto Cleanup;
        }


    // Read data:
        unsigned long index = *(reinterpret_cast<const DWORD *>(m_pFixedTable) + (m_cColumnsPlusPrivate * i_iRow) + iColumn);
        if(0 == index)
            o_apvValues[iTarget] = 0;
        else
        {
            ASSERT(UI4FromIndex(m_pColumnMeta[iColumn].Type) <= DBTYPE_DBTIMESTAMP);
            o_apvValues[iTarget] = BytePointerFromIndex(index);
        }


    // Optionally read size if the pvValue is not NULL
        if(NULL != o_acbSizes)
        {
            o_acbSizes[iTarget] = 0;//start with 0
            if(NULL != o_apvValues[iTarget])
            {
                switch (UI4FromIndex(m_pColumnMeta[iColumn].Type))
                {
                case DBTYPE_WSTR:
                    if(fCOLUMNMETA_FIXEDLENGTH & UI4FromIndex(m_pColumnMeta[iColumn].MetaFlags))
                        o_acbSizes[iTarget] = UI4FromIndex(m_pColumnMeta[iColumn].Size);//if a size was specified AND FIXED_LENGTH was specified then return that size specified
                    else //if size was specified and FIXEDLENGTH was NOT then size is just interpretted as Maximum size
                        o_acbSizes[iTarget] = (ULONG)(wcslen ((LPWSTR) o_apvValues[iTarget]) + 1) * sizeof (WCHAR);//just return the string (length +1) in BYTES
                    break;
                case DBTYPE_BYTES:
                    o_acbSizes[iTarget] = reinterpret_cast<const ULONG *>(o_apvValues[iTarget])[-1];
                    break;
                default:
                    o_acbSizes[iTarget] = UI4FromIndex(m_pColumnMeta[iColumn].Size);
                    break;
                }
            }
        }
    }

// Read data and populate out params
    for(ipv=1; ipv<i_cColumns; ipv++)
    {
//        if(NULL != i_aiColumns)
//            iColumn = i_aiColumns[ipv];
//        else
//            iColumn = ipv;
        iColumn = aColumns[ipv];

	// If caller needs one column only, he doesn't need to pass a buffer for all the columns.
		iTarget = iColumn;

    // Validate column index
        if(m_cColumns < iColumn)
        {
            hr = E_ST_NOMORECOLUMNS;
            goto Cleanup;
        }


    // Read data:
        unsigned long index = *(reinterpret_cast<const DWORD *>(m_pFixedTable) + (m_cColumnsPlusPrivate * i_iRow) + iColumn);
        if(0 == index)
            o_apvValues[iTarget] = 0;
        else
        {
            ASSERT(UI4FromIndex(m_pColumnMeta[iColumn].Type) <= DBTYPE_DBTIMESTAMP);
            o_apvValues[iTarget] = BytePointerFromIndex(index);
        }


    // Optionally read size if the pvValue is not NULL
        if(NULL != o_acbSizes)
        {
            o_acbSizes[iTarget] = 0;//start with 0
            if(NULL != o_apvValues[iTarget])
            {
                switch (UI4FromIndex(m_pColumnMeta[iColumn].Type))
                {
                case DBTYPE_WSTR:
                    if(fCOLUMNMETA_FIXEDLENGTH & UI4FromIndex(m_pColumnMeta[iColumn].MetaFlags))
                        o_acbSizes[iTarget] = UI4FromIndex(m_pColumnMeta[iColumn].Size);//if a size was specified AND FIXED_LENGTH was specified then return that size specified
                    else //if size was specified and FIXEDLENGTH was NOT then size is just interpretted as Maximum size
                        o_acbSizes[iTarget] = (ULONG)(wcslen ((LPWSTR) o_apvValues[iTarget]) + 1) * sizeof (WCHAR);//just return the string (length +1) in BYTES
                    break;
                case DBTYPE_BYTES:
                    o_acbSizes[iTarget] = reinterpret_cast<const ULONG *>(BytePointerFromIndex(index))[-1];
                    break;
                default:
                    o_acbSizes[iTarget] = UI4FromIndex(m_pColumnMeta[iColumn].Size);
                    break;
                }
            }
        }
    }

Cleanup:

    if(FAILED(hr))
    {
// Initialize out parameters
        for(ipv=0; ipv<i_cColumns; ipv++)
        {
            o_apvValues[ipv]        = NULL;
            if(NULL != o_acbSizes)
            {
                o_acbSizes[ipv] = 0;
            }
        }
    }

    return hr;
}
// ==================================================================
STDMETHODIMP CSDTFxd::GetTableMeta(ULONG *o_pcVersion, DWORD *o_pfTable, ULONG * o_pcRows, ULONG * o_pcColumns )
{
	if(NULL != o_pfTable)
	{
		*o_pfTable = 0;
	}
	if(NULL != o_pcVersion)
	{
		*o_pcVersion = UI4FromIndex(m_pTableMeta->BaseVersion);
	}


    if (NULL != o_pcRows)
    {
        *o_pcRows = m_ciRows;
    }
    if (NULL != o_pcColumns)
    {
        *o_pcColumns = m_cColumns;
    }
    return S_OK;
}

// ==================================================================
STDMETHODIMP CSDTFxd::GetColumnMetas (ULONG i_cColumns, ULONG* i_aiColumns, SimpleColumnMeta* o_aColumnMetas)
{
	ULONG iColumn;
	ULONG iTarget;

    if(0 == o_aColumnMetas)
        return E_INVALIDARG;

	if ( i_cColumns > m_cColumns )
		return  E_ST_NOMORECOLUMNS;

	for ( ULONG i = 0; i < i_cColumns; i ++ )
	{
		if(NULL != i_aiColumns)
			iColumn = i_aiColumns[i];
		else
			iColumn = i;

		iTarget = (i_cColumns == 1) ? 0 : iColumn;

		if ( iColumn >= m_cColumns )
			return  E_ST_NOMORECOLUMNS;

        o_aColumnMetas[iTarget].dbType   = UI4FromIndex(m_pColumnMeta[iColumn].Type);
        o_aColumnMetas[iTarget].cbSize   = UI4FromIndex(m_pColumnMeta[iColumn].Size);
        o_aColumnMetas[iTarget].fMeta    = UI4FromIndex(m_pColumnMeta[iColumn].MetaFlags);
	}

    return S_OK;
}

// ------------------------------------
// ISimpleTableAdvanced:
// ------------------------------------

// ==================================================================
STDMETHODIMP CSDTFxd::PopulateCache ()
{
    return S_OK;
}

// ==================================================================
STDMETHODIMP CSDTFxd::GetDetailedErrorCount(ULONG* o_pcErrs)
{
    UNREFERENCED_PARAMETER(o_pcErrs);

    return E_NOTIMPL;
}

// ==================================================================
STDMETHODIMP CSDTFxd::GetDetailedError(ULONG i_iErr, STErr* o_pSTErr)
{
    UNREFERENCED_PARAMETER(i_iErr);
    UNREFERENCED_PARAMETER(o_pSTErr);

    return E_NOTIMPL;
}

// ==================================================================
STDMETHODIMP CSDTFxd::ResetCaches ()
{
    return S_OK;
}

STDMETHODIMP CSDTFxd::GetColumnValuesEx (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, DWORD* o_afStatus, ULONG* o_acbSizes, LPVOID* o_apvValues)
{
    UNREFERENCED_PARAMETER(i_iRow);
    UNREFERENCED_PARAMETER(i_cColumns);
    UNREFERENCED_PARAMETER(i_aiColumns);
    UNREFERENCED_PARAMETER(o_afStatus);
    UNREFERENCED_PARAMETER(o_acbSizes);
    UNREFERENCED_PARAMETER(o_apvValues);

	return E_NOTIMPL;
}



//
//
// Private member functions
//
//
HRESULT CSDTFxd::GetColumnMetaQuery(const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszTable, unsigned long &iOrder) const
{
    wszTable    = 0;
    iOrder      = (ULONG)-1;
    //The only queries supported is tid equals or iOrder equals
    for(; cQueryCells; --cQueryCells, ++pQueryCell)
    {
        if(pQueryCell->iCell     == iCOLUMNMETA_Table)
        {
            if(0 == wszTable && pQueryCell->eOperator == eST_OP_EQUAL        &&
                                pQueryCell->dbType    == DBTYPE_WSTR         &&
//                                pQueryCell->cbSize    != 0                   &&
                                pQueryCell->pData     != 0)
                wszTable = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
            else//The iCell is iDATABASEMETA_iGuidDid, but some other part of the query is bogus
                return E_ST_INVALIDQUERY;
        }
        else if(pQueryCell->iCell     == iCOLUMNMETA_Index)
        {
            if(-1 == iOrder &&  pQueryCell->eOperator == eST_OP_EQUAL        &&
                                pQueryCell->dbType    == DBTYPE_UI4          &&
//                                pQueryCell->cbSize    == sizeof(ULONG)       &&
                                pQueryCell->pData     != 0)
                iOrder = *reinterpret_cast<ULONG *>(pQueryCell->pData);
            else
                return E_ST_INVALIDQUERY;
        }
        else if(0 == (pQueryCell->iCell & iST_CELL_SPECIAL))//The above cells are the only non-reserved cells we support
            return E_ST_INVALIDQUERY;                       //and we're supposed to ignore all reserved cell we don't understand

        //ignore query cells we don't know about
    }
    if(!wszTable && (-1 != iOrder))
        return E_ST_INVALIDQUERY;
    return S_OK;
}


HRESULT CSDTFxd::GetColumnMetaTable(STQueryCell * pQueryCell, unsigned long cQueryCells)
{
    ULONG iTableMetaRow = m_pFixedTableHeap->FindTableMetaRow(wszTABLE_COLUMNMETA);
    ASSERT(-1 != iTableMetaRow);
    m_pTableMeta    = m_pFixedTableHeap->Get_aTableMeta(iTableMetaRow);
    m_pColumnMeta   = m_pFixedTableHeap->Get_aColumnMeta(m_pTableMeta->iColumnMeta);

    m_pHashedIndex          = m_pFixedTableHeap->Get_HashedIndex(m_pTableMeta->iHashTableHeader+1);
    m_pHashTableHeader      = m_pFixedTableHeap->Get_HashHeader(m_pTableMeta->iHashTableHeader);
    m_pFixedTableUnqueried  = m_pFixedTableHeap->Get_aColumnMeta();
    m_cColumnsPlusPrivate   = kciColumnMetaColumns;


    HRESULT hr;
    LPCWSTR wszTable=0;
    ULONG   iOrder  =(ULONG)-1;

    if(FAILED(hr = GetColumnMetaQuery(pQueryCell, cQueryCells, wszTable, iOrder)))
        return hr;

    const ColumnMeta * pColumnMeta = m_pFixedTableHeap->Get_aColumnMeta();
    if(0 == wszTable)//if a tid wasn't provided as part of the query then we're done
    {
        m_ciRows        = m_pFixedTableHeap->Get_cColumnMeta();
        m_iZerothRow    = 0;
    }
    else
    {
        //We're looking up the TableMeta for this table (the table that we're finding the ColumnMeta for) because it already has the pointer to the ColumnMeta AND the count
        const TableMeta       * pTableMetaForTheTableMeta = m_pFixedTableHeap->Get_aTableMeta(m_pFixedTableHeap->FindTableMetaRow(wszTABLE_TABLEMETA));
        const HashedIndex     * pBaseHashedIndex = m_pFixedTableHeap->Get_HashedIndex(pTableMetaForTheTableMeta->iHashTableHeader + 1);
        const HashTableHeader * pHashTableHeader = reinterpret_cast<const HashTableHeader *>(pBaseHashedIndex-1);
        ULONG RowHash = Hash(wszTable, 0) % pHashTableHeader->Modulo;
        const HashedIndex     * pHashedIndex     = &pBaseHashedIndex[RowHash];

        if(-1 == pHashedIndex->iOffset)//if no row matches this hash then return an empty table
        {
            m_pFixedTable   = 0;
            m_ciRows        = 0;
            m_iZerothRow    = 0;
            return S_OK;
        }

        const TableMeta * pTableMeta;
        //After we get the HashedIndex we need to verify that it really matches.  Also if there is more than one, then walk the list. -1 iNext value indicated the end of the list
        for(; ; pHashedIndex = &pBaseHashedIndex[pHashedIndex->iNext])
        {   //Walk the hash links 'til we find a match
            pTableMeta = m_pFixedTableHeap->Get_aTableMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszTable, StringFromIndex(pTableMeta->InternalName)))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;
        }
        if(-1 == iOrder)
        {
            pColumnMeta     = m_pFixedTableHeap->Get_aColumnMeta(pTableMeta->iColumnMeta);
            m_ciRows        = UI4FromIndex(pTableMeta->CountOfColumns);
            m_iZerothRow    = pTableMeta->iColumnMeta;
        }
        else
        {
            if(iOrder >= UI4FromIndex(pTableMeta->CountOfColumns))//can't ask for a row that doesn't exist
                return E_ST_INVALIDQUERY;

            pColumnMeta     = m_pFixedTableHeap->Get_aColumnMeta(pTableMeta->iColumnMeta + iOrder);
            m_ciRows        = 1;
            m_iZerothRow    = pTableMeta->iColumnMeta + iOrder;
        }
    }
    m_pFixedTable   = const_cast<ColumnMeta *>(pColumnMeta);
    return S_OK;
}


HRESULT CSDTFxd::GetDatabaseMetaQuery(const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszDatabase) const
{
    wszDatabase = 0;
    //The only query supported is 'did equals' (or iCell==0, dbType==GUID etc)
    for(; cQueryCells; --cQueryCells, ++pQueryCell)
    {   //Walk the Query cells looking for one that matches the following criteria
        if(pQueryCell->iCell     == iDATABASEMETA_InternalName)
        {
            if(0 == wszDatabase &&  pQueryCell->eOperator == eST_OP_EQUAL        &&
                                    pQueryCell->dbType    == DBTYPE_WSTR         &&
//                                    pQueryCell->cbSize    != 0                   &&
//                                    pQueryCell->cbSize    <= 16                  && //@@@ 16 should be replaced by a define
                                    pQueryCell->pData     != 0)
                wszDatabase = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
            else//The iCell is iDATABASEMETA_iGuidDid, but some other part of the query is bogus
                return E_ST_INVALIDQUERY;
        }
        else if(0 == (pQueryCell->iCell & iST_CELL_SPECIAL))//The above cells are the only non-reserved cells we support
            return E_ST_INVALIDQUERY;                       //and we're supposed to ignore all reserved cell we don't understand
    }
    return S_OK;
}


HRESULT CSDTFxd::GetDatabaseMetaTable(STQueryCell * pQueryCell, unsigned long cQueryCells)
{   //Now enforce the query (the only one supported is 'did equals' (or iCell==0, dbType==GUID etc)
    ULONG iTableMetaRow = m_pFixedTableHeap->FindTableMetaRow(wszTABLE_DATABASEMETA);
    ASSERT(-1 != iTableMetaRow);
    m_pTableMeta    = m_pFixedTableHeap->Get_aTableMeta(iTableMetaRow);
    m_pColumnMeta   = m_pFixedTableHeap->Get_aColumnMeta(m_pTableMeta->iColumnMeta);

    ASSERT(0 != m_pTableMeta->iHashTableHeader);
    m_pHashedIndex          = m_pFixedTableHeap->Get_HashedIndex(m_pTableMeta->iHashTableHeader+1);
    m_pHashTableHeader      = m_pFixedTableHeap->Get_HashHeader(m_pTableMeta->iHashTableHeader);
    m_pFixedTableUnqueried  = m_pFixedTableHeap->Get_aDatabaseMeta();
    m_cColumnsPlusPrivate   = kciDatabaseMetaColumns;

    HRESULT hr;
    LPCWSTR wszDatabase=0;

    if(FAILED(hr = GetDatabaseMetaQuery(pQueryCell, cQueryCells, wszDatabase)))
        return hr;

    const DatabaseMeta *    pDatabaseMeta = m_pFixedTableHeap->Get_aDatabaseMeta();
    if(0 == wszDatabase)
    {
        m_ciRows        = m_pFixedTableHeap->Get_cDatabaseMeta();
        m_iZerothRow    = 0;
    }
    else
    {
        ULONG           RowHash = Hash(wszDatabase, 0) % m_pHashTableHeader->Modulo;
        const HashedIndex   * pHashedIndex = &m_pHashedIndex[RowHash];

        if(-1 == pHashedIndex->iOffset)return E_ST_NOMOREROWS;

        for(;; pHashedIndex = &m_pHashedIndex[pHashedIndex->iNext])//Walk the hash links 'til we find a match
        {
            pDatabaseMeta = m_pFixedTableHeap->Get_aDatabaseMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszDatabase, StringFromIndex(pDatabaseMeta->InternalName)))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;
        }

        m_ciRows        = 1;//if we found a match then the size of the table is 1
        m_iZerothRow    = pHashedIndex->iOffset;
    }//0 == wszDatabase
    m_pFixedTable   = const_cast<DatabaseMeta *>(pDatabaseMeta);//The 0th element is reserved as NULL
    return S_OK;
}


HRESULT CSDTFxd::GetIndexMeta(const STQueryCell *pQueryCell, unsigned long cQueryCells)
{
    LPCWSTR wszIndexName=0;
    for(; 0!=cQueryCells; --cQueryCells, ++pQueryCell)
    {
        if(pQueryCell->iCell == iST_CELL_INDEXHINT)
        {
            if(0 == wszIndexName &&  pQueryCell->eOperator == eST_OP_EQUAL    &&
                                     pQueryCell->dbType    == DBTYPE_WSTR     &&
//                                   pQueryCell->cbSize    != 0               &&
                                     pQueryCell->pData     != 0)
            {
                wszIndexName = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
            }
            else
                return E_ST_INVALIDQUERY;
        }
    }
    if(0 == wszIndexName)//if there was no IndexName specified, then bail
        return S_OK;

    //Find the first index that matches the IndexName
    const IndexMeta * pIndexMeta = m_pFixedTableHeap->Get_aIndexMeta() + m_pTableMeta->iIndexMeta;
    for(ULONG iIndexMeta=0; iIndexMeta<m_pTableMeta->cIndexMeta; ++iIndexMeta, ++pIndexMeta)
    {
        ASSERT(pIndexMeta->Table == m_pTableMeta->InternalName);

        if(0 == StringInsensitiveCompare(StringFromIndex(pIndexMeta->InternalName), wszIndexName))
        {
            if(0 == m_cIndexMeta)//Keep around a pointer to the first IndexMeta row.
                m_pIndexMeta = pIndexMeta;

            ++m_cIndexMeta;//For every IndexMeta that matches the index name, bump the count
        }
        else if(m_cIndexMeta>0)
            break;
    }
    if(0 == m_cIndexMeta)//The user specified an IndexName that does not exist.
        return E_ST_INVALIDQUERY;

    return S_OK;
}


HRESULT CSDTFxd::GetIndexMetaQuery(const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszTable, LPCWSTR &InternalName, unsigned long &iColumnOrder) const
{
    wszTable        = 0;
    InternalName    = 0;
    iColumnOrder    = (ULONG)-1;

    unsigned long fSpecifiedQueries=0;//must be 0, 1, 3 or 7

    //There are three queries we support for TagMeta, by TableID, TableID & iOrder, TableID iOrder & InternalName
    for(; cQueryCells; --cQueryCells, ++pQueryCell)
    {
        if(pQueryCell->iCell == iINDEXMETA_Table)
        {
            if(0 == wszTable && pQueryCell->eOperator == eST_OP_EQUAL    &&
                                pQueryCell->dbType    == DBTYPE_WSTR     &&
//                                pQueryCell->cbSize    != 0               &&
                                pQueryCell->pData     != 0)
            {
                wszTable = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
                fSpecifiedQueries |= 1;
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(pQueryCell->iCell == iINDEXMETA_InternalName)
        {
            if(0 == InternalName && pQueryCell->eOperator == eST_OP_EQUAL   &&
                                    pQueryCell->dbType    == DBTYPE_WSTR    &&
//                                    pQueryCell->cbSize    != 0              &&
                                    pQueryCell->pData     != 0)
            {
                InternalName = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
                fSpecifiedQueries |= 2;
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(pQueryCell->iCell == iINDEXMETA_ColumnIndex)
        {
            if(-1 == iColumnOrder &&  pQueryCell->eOperator == eST_OP_EQUAL   &&
                                pQueryCell->dbType    == DBTYPE_UI4     &&
//                                pQueryCell->cbSize    == sizeof(ULONG)  &&
                                pQueryCell->pData     != 0)
            {
                iColumnOrder = *reinterpret_cast<ULONG *>(pQueryCell->pData);
                fSpecifiedQueries |= 4;
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(0 == (pQueryCell->iCell & iST_CELL_SPECIAL))//The above cells are the only non-reserved cells we support
            return E_ST_INVALIDQUERY;                       //and we're supposed to ignore all reserved cell we don't understand
    }
    switch(fSpecifiedQueries)
    {
    case 0:     //Legal value so fall through to the break
    case 1:     //Legal value so fall through to the break
    case 3:     //Legal value so fall through to the break
    case 7:     break;//Legal value
    default:    return E_ST_INVALIDQUERY;//anything else is an invalid query
    }
    return S_OK;
}


HRESULT CSDTFxd::GetIndexMetaTable(STQueryCell * pQueryCell, unsigned long cQueryCells)
{
    ULONG iTableMetaRow = m_pFixedTableHeap->FindTableMetaRow(wszTABLE_INDEXMETA);
    ASSERT(-1 != iTableMetaRow);
    m_pTableMeta    = m_pFixedTableHeap->Get_aTableMeta(iTableMetaRow);
    m_pColumnMeta   = m_pFixedTableHeap->Get_aColumnMeta(m_pTableMeta->iColumnMeta);

    ASSERT(0 != m_pTableMeta->iHashTableHeader);
    m_pHashedIndex          = m_pFixedTableHeap->Get_HashedIndex(m_pTableMeta->iHashTableHeader+1);
    m_pHashTableHeader      = m_pFixedTableHeap->Get_HashHeader(m_pTableMeta->iHashTableHeader);
    m_pFixedTableUnqueried  = m_pFixedTableHeap->Get_aIndexMeta();
    m_cColumnsPlusPrivate   = kciIndexMetaColumns;


    HRESULT hr;
    LPCWSTR wszTable    = 0;
    ULONG   ColumnIndex = (ULONG)-1;
    LPCWSTR InternalName= 0;

    if(FAILED(hr = GetIndexMetaQuery(pQueryCell, cQueryCells, wszTable, InternalName, ColumnIndex)))
        return hr;

    const IndexMeta *pIndexMeta = m_pFixedTableHeap->Get_aIndexMeta();//Start with the whole table.
    if(0 == wszTable)
    {   //No query, return the whole table
        m_ciRows        = m_pFixedTableHeap->Get_cIndexMeta();
        m_iZerothRow    = 0;
    }
    else if(0 == InternalName)
    {   //TableName only query
        ULONG                   RowHash         = Hash(wszTable, 0) % m_pHashTableHeader->Modulo;
        const HashedIndex     * pHashedIndex    = &m_pHashedIndex[RowHash];

        if(-1 == pHashedIndex->iOffset)return E_ST_NOMOREROWS;

        for(;; pHashedIndex = &m_pHashedIndex[pHashedIndex->iNext])
        {   //Walk the hash links 'til we find a match
            pIndexMeta      = m_pFixedTableHeap->Get_aIndexMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszTable, StringFromIndex(pIndexMeta->Table)))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;
        }

        m_iZerothRow    = pHashedIndex->iOffset;
        for(m_ciRows = 0; (m_iZerothRow + m_ciRows) < m_pFixedTableHeap->Get_cIndexMeta() && 0 == StringInsensitiveCompare(wszTable, StringFromIndex(pIndexMeta[m_ciRows].Table)); ++m_ciRows);
    }
    else if(-1 == ColumnIndex)
    {   //TableName and InternalName but NO ColumnIndex
        ULONG                   RowHash         = Hash(InternalName, Hash(wszTable, 0)) % m_pHashTableHeader->Modulo;
        const HashedIndex     * pHashedIndex    = &m_pHashedIndex[RowHash];

        if(-1 == pHashedIndex->iOffset)return E_ST_NOMOREROWS;

        for(;; pHashedIndex = &m_pHashedIndex[pHashedIndex->iNext])
        {   //Walk the hash links 'til we find a match
            pIndexMeta      = m_pFixedTableHeap->Get_aIndexMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszTable, StringFromIndex(pIndexMeta->Table)) && 0 == StringInsensitiveCompare(InternalName, StringFromIndex(pIndexMeta->InternalName)))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;
        }

        m_iZerothRow    = pHashedIndex->iOffset;
        for(m_ciRows = 0; (m_iZerothRow + m_ciRows) < m_pFixedTableHeap->Get_cIndexMeta() && 0 == StringInsensitiveCompare(wszTable, StringFromIndex(pIndexMeta[m_ciRows].Table))
                         && 0 == StringInsensitiveCompare(InternalName, StringFromIndex(pIndexMeta[m_ciRows].InternalName)); ++m_ciRows);
    }
    else
    {   //All three PrimaryKey were specified in the query
        ULONG                   RowHash         = Hash(ColumnIndex, Hash(InternalName, Hash(wszTable, 0))) % m_pHashTableHeader->Modulo;
        const HashedIndex     * pHashedIndex    = &m_pHashedIndex[RowHash];

        if(-1 == pHashedIndex->iOffset)return E_ST_NOMOREROWS;

        for(;; pHashedIndex = &m_pHashedIndex[pHashedIndex->iNext])
        {   //Walk the hash links 'til we find a match
            pIndexMeta      = m_pFixedTableHeap->Get_aIndexMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszTable, StringFromIndex(pIndexMeta->Table)) && UI4FromIndex(pIndexMeta->ColumnIndex)==ColumnIndex && 0 == StringInsensitiveCompare(InternalName, StringFromIndex(pIndexMeta->InternalName)))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;
        }
        m_ciRows        = 1;//When all PK are queried for, the only result is 1 row
        m_iZerothRow    = pHashedIndex->iOffset;
    }
    m_pFixedTable   = const_cast<IndexMeta *>(pIndexMeta);
    return S_OK;
}


HRESULT CSDTFxd::GetQueryMetaQuery(const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszTable, LPCWSTR &wszInternalName, LPCWSTR &wszCellName) const
{
    wszTable        = 0;
    wszInternalName = 0;
    wszCellName     = 0;

    unsigned long fSpecifiedQueries=0;//must be 0, 1, 3 or 7

    //The only two queries we support for QueryMeta are, iCell==iQUERYMETA_Table && iCell==iQUERYMETA_InternalName
    //So walk the list looking for one of those two queries
    for(; cQueryCells; --cQueryCells, ++pQueryCell)
    {   //Walk the Query cells looking for one that matches the following criteria
        if(pQueryCell->iCell == iQUERYMETA_Table)
        {
            if(0 == wszTable &&     pQueryCell->eOperator == eST_OP_EQUAL    &&
                                    pQueryCell->dbType    == DBTYPE_WSTR     &&
//@@@ work around bug in dispenser                                    pQueryCell->cbSize    != 0               &&
                                    pQueryCell->pData     != 0)
            {
                wszTable = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
                fSpecifiedQueries |= 1;
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(pQueryCell->iCell == iQUERYMETA_InternalName)
        {
            if(0 == wszInternalName &&  pQueryCell->eOperator == eST_OP_EQUAL    &&
                                        pQueryCell->dbType    == DBTYPE_WSTR     &&
//@@@ work around bug in dispenser                                pQueryCell->cbSize    != 0               &&
                                        pQueryCell->pData     != 0)
            {
                wszInternalName = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
                fSpecifiedQueries |= 2;
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(pQueryCell->iCell == iQUERYMETA_CellName)
        {
            if(0 == wszCellName &&      pQueryCell->eOperator == eST_OP_EQUAL    &&
                                        pQueryCell->dbType    == DBTYPE_WSTR     &&
//@@@ work around bug in dispenser                                pQueryCell->cbSize    != 0               &&
                                        pQueryCell->pData     != 0)
            {
                wszCellName = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
                fSpecifiedQueries |= 4;
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(0 == (pQueryCell->iCell & iST_CELL_SPECIAL))//The above cells are the only non-reserved cells we support
            return E_ST_INVALIDQUERY;                       //and we're supposed to ignore all reserved cell we don't understand
    }
    switch(fSpecifiedQueries)
    {
    case 0:     //Legal value so fall through to the break
    case 1:     //Legal value so fall through to the break
    case 3:     //Legal value so fall through to the break
    case 7:     break;//Legal value
    default:    return E_ST_INVALIDQUERY;//anything else is an invalid query
    }

    return S_OK;
}


HRESULT CSDTFxd::GetQueryMetaTable(STQueryCell * pQueryCell, unsigned long cQueryCells)
{
    ULONG iTableMetaRow = m_pFixedTableHeap->FindTableMetaRow(wszTABLE_QUERYMETA);
    ASSERT(-1 != iTableMetaRow);
    m_pTableMeta    = m_pFixedTableHeap->Get_aTableMeta(iTableMetaRow);
    m_pColumnMeta   = m_pFixedTableHeap->Get_aColumnMeta(m_pTableMeta->iColumnMeta);

    ASSERT(0 != m_pTableMeta->iHashTableHeader);
    m_pHashedIndex          = m_pFixedTableHeap->Get_HashedIndex(m_pTableMeta->iHashTableHeader+1);
    m_pHashTableHeader      = m_pFixedTableHeap->Get_HashHeader(m_pTableMeta->iHashTableHeader);
    m_pFixedTableUnqueried  = m_pFixedTableHeap->Get_aQueryMeta();
    m_cColumnsPlusPrivate   = kciQueryMetaColumns;

    HRESULT hr;
    LPCWSTR wszTable        = 0;
    LPCWSTR wszInternalName = 0;
    LPCWSTR wszCellName     = 0;

    if(FAILED(hr = GetQueryMetaQuery(pQueryCell, cQueryCells, wszTable, wszInternalName, wszCellName)))
        return hr;

    const QueryMeta *pQueryMeta = m_pFixedTableHeap->Get_aQueryMeta();//Start with the whole table.
    if(0 == wszTable)
    {   //No query, return the whole table
        m_ciRows        = m_pFixedTableHeap->Get_cQueryMeta();
        m_iZerothRow    = 0;
    }
    else if(0 == wszInternalName)
    {   //Query is by TableName only
        ULONG                   RowHash         = Hash(wszTable, 0) % m_pHashTableHeader->Modulo;
        const HashedIndex     * pHashedIndex    = &m_pHashedIndex[RowHash];

        if(-1 == pHashedIndex->iOffset)return E_ST_NOMOREROWS;

        for(;; pHashedIndex = &m_pHashedIndex[pHashedIndex->iNext])
        {   //Walk the hash links 'til we find a match
            pQueryMeta      = m_pFixedTableHeap->Get_aQueryMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszTable, StringFromIndex(pQueryMeta->Table)))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;
        }

        m_iZerothRow    = pHashedIndex->iOffset;
        for(m_ciRows = 0; (m_iZerothRow + m_ciRows) < m_pFixedTableHeap->Get_cQueryMeta() && 0 == StringInsensitiveCompare(wszTable, StringFromIndex(pQueryMeta[m_ciRows].Table)); ++m_ciRows);
    }
    else if(0 == wszCellName)
    {   //Query is by TableName and InternalName
        ULONG                   RowHash         = Hash( wszInternalName, Hash(wszTable, 0)) % m_pHashTableHeader->Modulo;
        const HashedIndex     * pHashedIndex    = &m_pHashedIndex[RowHash];

        if(-1 == pHashedIndex->iOffset)return E_ST_NOMOREROWS;

        for(;; pHashedIndex = &m_pHashedIndex[pHashedIndex->iNext])
        {   //Walk the hash links 'til we find a match
            pQueryMeta      = m_pFixedTableHeap->Get_aQueryMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszTable, StringFromIndex(pQueryMeta->Table)) && 0 == StringInsensitiveCompare(wszInternalName, StringFromIndex(pQueryMeta->InternalName)))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;
        }

        m_iZerothRow    = pHashedIndex->iOffset;
        for(m_ciRows = 0; (m_iZerothRow + m_ciRows) < m_pFixedTableHeap->Get_cQueryMeta() && 0 == StringInsensitiveCompare(wszTable, StringFromIndex(pQueryMeta[m_ciRows].Table)) &&
                         0 == StringInsensitiveCompare(wszInternalName, StringFromIndex(pQueryMeta[m_ciRows].InternalName)); ++m_ciRows);
    }
    else
    {   //Query is by all three PrimaryKeys
        ULONG                   RowHash         = Hash(wszCellName, Hash( wszInternalName, Hash(wszTable, 0))) % m_pHashTableHeader->Modulo;
        const HashedIndex     * pHashedIndex    = &m_pHashedIndex[RowHash];

        if(-1 == pHashedIndex->iOffset)return E_ST_NOMOREROWS;

        for(;; pHashedIndex = &m_pHashedIndex[pHashedIndex->iNext])
        {   //Walk the hash links 'til we find a match
            pQueryMeta      = m_pFixedTableHeap->Get_aQueryMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszTable, StringFromIndex(pQueryMeta->Table)) && 0 == StringInsensitiveCompare(wszInternalName, StringFromIndex(pQueryMeta->InternalName))
                            && 0 == StringInsensitiveCompare(wszCellName, StringFromIndex(pQueryMeta->CellName)))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;
        }

        m_iZerothRow    = pHashedIndex->iOffset;
        for(m_ciRows = 0; (m_iZerothRow + m_ciRows) < m_pFixedTableHeap->Get_cQueryMeta() && 0 == StringInsensitiveCompare(wszTable, StringFromIndex(pQueryMeta[m_ciRows].Table)) &&
                         0 == StringInsensitiveCompare(wszInternalName, StringFromIndex(pQueryMeta->InternalName))
                         && 0 == StringInsensitiveCompare(wszCellName, StringFromIndex(pQueryMeta->CellName)); ++m_ciRows);
    }
    m_pFixedTable = const_cast<QueryMeta *>(pQueryMeta);
    return S_OK;
}


HRESULT CSDTFxd::GetRelationMetaQuery(const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszTablePrimary, LPCWSTR &wszTableForeign) const
{
    wszTablePrimary = 0;
    wszTableForeign    = 0;

    //@@@ To Do: we need to support queries by either Primary or Foreign table.  This means we'll want the table sorted by each (a copy of the table).
    //@@@ For now the only query we'll support is by BOTH Primary and Foreign Tables

    for(; cQueryCells; --cQueryCells, ++pQueryCell)
    {   //Walk the Query cells looking for one that matches the following criteria
        if(pQueryCell->iCell == iRELATIONMETA_PrimaryTable)
        {
            if(0 == wszTablePrimary &&  pQueryCell->eOperator == eST_OP_EQUAL    &&
                                        pQueryCell->dbType    == DBTYPE_WSTR     &&
//@@@ work around bug in dispenser                                    pQueryCell->cbSize    != 0               &&
                                        pQueryCell->pData     != 0)
            {
                wszTablePrimary = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(pQueryCell->iCell == iRELATIONMETA_ForeignTable)
        {
            if(0 == wszTableForeign &&  pQueryCell->eOperator == eST_OP_EQUAL    &&
                                        pQueryCell->dbType    == DBTYPE_WSTR     &&
//@@@ work around bug in dispenser                                pQueryCell->cbSize    != 0               &&
                                        pQueryCell->pData     != 0)
            {
                wszTableForeign = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(0 == (pQueryCell->iCell & iST_CELL_SPECIAL))//The above cells are the only non-reserved cells we support
            return E_ST_INVALIDQUERY;                       //and we're supposed to ignore all reserved cell we don't understand
    }
    if((wszTablePrimary && !wszTableForeign) || (!wszTablePrimary && wszTableForeign))//@@@ For now both or neither should be specified.
        return E_ST_INVALIDQUERY;

    return S_OK;
}


//@@@ To Do: Need to support querying by either primary key not just both!
HRESULT CSDTFxd::GetRelationMetaTable(STQueryCell * pQueryCell, unsigned long cQueryCells)
{
    ULONG iTableMetaRow = m_pFixedTableHeap->FindTableMetaRow(wszTABLE_RELATIONMETA);
    ASSERT(-1 != iTableMetaRow);
    m_pTableMeta        = m_pFixedTableHeap->Get_aTableMeta(iTableMetaRow);
    m_pColumnMeta       = m_pFixedTableHeap->Get_aColumnMeta(m_pTableMeta->iColumnMeta);

    m_pHashedIndex          = 0;
    m_pHashTableHeader      = 0;
    m_pFixedTableUnqueried  = m_pFixedTableHeap->Get_aRelationMeta();
    m_cColumnsPlusPrivate   = kciRelationMetaColumns;

    HRESULT hr;
    LPCWSTR wszTablePrimary = 0;
    LPCWSTR wszTableForeign = 0;

    if(FAILED(hr = GetRelationMetaQuery(pQueryCell, cQueryCells, wszTablePrimary, wszTableForeign)))
        return hr;

    if(0 == wszTablePrimary && 0 == wszTableForeign)
    {
        m_pFixedTable   = m_pFixedTableHeap->Get_aRelationMeta();
        m_ciRows        = m_pFixedTableHeap->Get_cRelationMeta();
        return S_OK;
    }
    const RelationMeta *pRelationMeta = m_pFixedTableHeap->Get_aRelationMeta();
    for(unsigned long iRelationMeta=0; iRelationMeta<m_pFixedTableHeap->Get_cRelationMeta(); ++iRelationMeta, ++pRelationMeta)
    {
        if(0 == StringInsensitiveCompare(StringFromIndex(pRelationMeta->PrimaryTable), wszTablePrimary) &&
           0 == StringInsensitiveCompare(StringFromIndex(pRelationMeta->ForeignTable), wszTableForeign))
        {
            m_pFixedTable   = const_cast<RelationMeta *>(pRelationMeta);
            m_ciRows        = 1;//These are both of the PKs so there can only be one match.
            break;
        }
    }
    return S_OK;
}


HRESULT CSDTFxd::GetTableMetaQuery(const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszDatabase, LPCWSTR &wszTable) const
{
    wszDatabase = 0;
    wszTable    = 0;
    //The only two queries we support for TableMeta are, iCell==iTABLEMETA_iGuidDid && iCell==iTABLEMETA_iGuidTid
    //So walk the list looking for one of those two queries
    for(; cQueryCells; --cQueryCells, ++pQueryCell)
    {   //Walk the Query cells looking for one that matches the following criteria
        if(pQueryCell->iCell == iTABLEMETA_Database)
        {
            if(0 == wszDatabase &&  pQueryCell->eOperator == eST_OP_EQUAL    &&
                                    pQueryCell->dbType    == DBTYPE_WSTR     &&
//                                    pQueryCell->cbSize    != 0               &&
//                                    pQueryCell->cbSize    <= 16              && //@@@ the 16 should be replaced by a define
                                    pQueryCell->pData     != 0)
            {
                wszDatabase = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(pQueryCell->iCell == iTABLEMETA_InternalName)
        {
            if(0 == wszTable && pQueryCell->eOperator == eST_OP_EQUAL    &&
                                pQueryCell->dbType    == DBTYPE_WSTR     &&
//                                pQueryCell->cbSize    != 0               &&
                                pQueryCell->pData     != 0)
            {
                wszTable = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(0 == (pQueryCell->iCell & iST_CELL_SPECIAL))//The above cells are the only non-reserved cells we support
            return E_ST_INVALIDQUERY;                       //and we're supposed to ignore all reserved cell we don't understand
    }
    if(wszDatabase)
    {
        if(wszTable)//We support query by Database or TableName but NOT both.
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Warning! Users should NOT query TableMeta by both DatabaseName AND TableName.  It is redundant.  Just query by iTABLEMETA_InternalName.\n" ));
            return S_OK;//E_ST_INVALIDQUERY;
        }
    }
    return S_OK;
}


HRESULT CSDTFxd::GetTableMetaTable(STQueryCell * pQueryCell, unsigned long cQueryCells)
{
    ULONG iTableMetaRow = m_pFixedTableHeap->FindTableMetaRow(wszTABLE_TABLEMETA);
    ASSERT(-1 != iTableMetaRow);
    m_pTableMeta    = m_pFixedTableHeap->Get_aTableMeta(iTableMetaRow);
    m_pColumnMeta   = m_pFixedTableHeap->Get_aColumnMeta(m_pTableMeta->iColumnMeta);

    ASSERT(0 != m_pTableMeta->iHashTableHeader);
    m_pHashedIndex          = m_pFixedTableHeap->Get_HashedIndex(m_pTableMeta->iHashTableHeader+1);
    m_pHashTableHeader      = m_pFixedTableHeap->Get_HashHeader(m_pTableMeta->iHashTableHeader);
    m_pFixedTableUnqueried  = m_pFixedTableHeap->Get_aTableMeta();
    m_cColumnsPlusPrivate   = kciTableMetaColumns;

    HRESULT hr;
    LPCWSTR wszDatabase =0;
    LPCWSTR wszTable    =0;

    if(FAILED(hr = GetTableMetaQuery(pQueryCell, cQueryCells, wszDatabase, wszTable)))
        return hr;

    const TableMeta *    pTableMeta = m_pFixedTableHeap->Get_aTableMeta();
    //TableMeta has a special case.  Even though Database name is NOT aPK, we allow querying by it.
    if(0 != wszDatabase && 0 == wszTable)//So if we're querying by Database only
    {
        const TableMeta       * pTableMetaForDatabaseMeta = m_pFixedTableHeap->Get_aTableMeta(m_pFixedTableHeap->FindTableMetaRow(wszTABLE_DATABASEMETA));
        const HashedIndex     * pHashedIndex     = m_pFixedTableHeap->Get_HashedIndex(pTableMetaForDatabaseMeta->iHashTableHeader + 1);
        const HashedIndex     * _pHashedIndex    = pHashedIndex;
        const HashTableHeader * pHashTableHeader = m_pFixedTableHeap->Get_HashHeader(pTableMetaForDatabaseMeta->iHashTableHeader);
        ULONG RowHash = Hash(wszDatabase, 0) % pHashTableHeader->Modulo;

        pHashedIndex += RowHash;

        if(-1 == pHashedIndex->iOffset)//if no row matches this hash then return an empty table
        {
            m_pFixedTable   = 0;
            m_ciRows        = 0;
            m_iZerothRow    = 0;
            return S_OK;
        }

        const DatabaseMeta * pDatabaseMeta;
        //After we get the HashedIndex we need to verify that it really matches.  Also if there is more than one, then walk the list. -1 iNext value indicated the end of the list
        for(;; pHashedIndex = &_pHashedIndex[pHashedIndex->iNext])
        {   //Walk the hash links 'til we find a match
            pDatabaseMeta = m_pFixedTableHeap->Get_aDatabaseMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszDatabase, StringFromIndex(pDatabaseMeta->InternalName)))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;
        }

        pTableMeta      = m_pFixedTableHeap->Get_aTableMeta(pDatabaseMeta->iTableMeta);
        m_ciRows        = UI4FromIndex(pDatabaseMeta->CountOfTables);
        m_iZerothRow    = pDatabaseMeta->iTableMeta;
    }
    else if(0 == wszTable)//Nither Database NOR Table name supplied
    {
        m_ciRows        = m_pFixedTableHeap->Get_cTableMeta();
        m_iZerothRow    = 0;
    }
    else
    {   //Query by Table's InternalName
        ULONG               RowHash = Hash(wszTable, 0) % m_pHashTableHeader->Modulo;
        const HashedIndex * pHashedIndex = &m_pHashedIndex[RowHash];

        if(-1 == pHashedIndex->iOffset)return E_ST_NOMOREROWS;

        for(;; pHashedIndex = &m_pHashedIndex[pHashedIndex->iNext])//Walk the hash links 'til we find a match
        {
            pTableMeta = m_pFixedTableHeap->Get_aTableMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszTable, StringFromIndex(pTableMeta->InternalName)))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;
        }

        m_ciRows        = 1;//if we found a match then the size of the table is 1
        m_iZerothRow    = pHashedIndex->iOffset;
    }
    m_pFixedTable   = const_cast<TableMeta *>(pTableMeta);
    return S_OK;
}


HRESULT CSDTFxd::GetTagMetaQuery(const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszTable, unsigned long &iOrder, LPCWSTR &InternalName) const
{
    wszTable    = 0;
    iOrder      = (ULONG)-1;
    InternalName= 0;

    unsigned long fSpecifiedQueries=0;//must be 0, 1, 3 or 7

    //There are three queries we support for TagMeta, by TableID, TableID & iOrder, TableID iOrder & InternalName
    for(; cQueryCells; --cQueryCells, ++pQueryCell)
    {
        if(pQueryCell->iCell == iTAGMETA_Table)
        {
            if(0 == wszTable && pQueryCell->eOperator == eST_OP_EQUAL    &&
                                pQueryCell->dbType    == DBTYPE_WSTR     &&
//                                pQueryCell->cbSize    != 0               &&
                                pQueryCell->pData     != 0)
            {
                wszTable = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
                fSpecifiedQueries |= 1;
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(pQueryCell->iCell == iTAGMETA_ColumnIndex)
        {
            if(-1 == iOrder &&  pQueryCell->eOperator == eST_OP_EQUAL   &&
                                pQueryCell->dbType    == DBTYPE_UI4     &&
//                                pQueryCell->cbSize    == sizeof(ULONG)  &&
                                pQueryCell->pData     != 0)
            {
                iOrder = *reinterpret_cast<ULONG *>(pQueryCell->pData);
                fSpecifiedQueries |= 2;
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(pQueryCell->iCell == iTAGMETA_InternalName)
        {
            if(0 == InternalName && pQueryCell->eOperator == eST_OP_EQUAL   &&
                                    pQueryCell->dbType    == DBTYPE_WSTR    &&
//                                    pQueryCell->cbSize    != 0              &&
                                    pQueryCell->pData     != 0)
            {
                InternalName = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
                fSpecifiedQueries |= 4;
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(0 == (pQueryCell->iCell & iST_CELL_SPECIAL))//The above cells are the only non-reserved cells we support
            return E_ST_INVALIDQUERY;                       //and we're supposed to ignore all reserved cell we don't understand
    }
    switch(fSpecifiedQueries)
    {
    case 0:     //Legal value so fall through to the break
    case 1:     //Legal value so fall through to the break
    case 3:     //Legal value so fall through to the break
    case 7:     break;//Legal value
    default:    return E_ST_INVALIDQUERY;//anything else is an invalid query
    }
    return S_OK;
}


HRESULT CSDTFxd::GetTagMetaTable(STQueryCell * pQueryCell, unsigned long cQueryCells)
{
    ULONG iTableMetaRow = m_pFixedTableHeap->FindTableMetaRow(wszTABLE_TAGMETA);
    ASSERT(-1 != iTableMetaRow);
    m_pTableMeta    = m_pFixedTableHeap->Get_aTableMeta(iTableMetaRow);
    m_pColumnMeta   = m_pFixedTableHeap->Get_aColumnMeta(m_pTableMeta->iColumnMeta);

    ASSERT(0 != m_pTableMeta->iHashTableHeader);
    m_pHashedIndex          = m_pFixedTableHeap->Get_HashedIndex(m_pTableMeta->iHashTableHeader+1);
    m_pHashTableHeader      = m_pFixedTableHeap->Get_HashHeader(m_pTableMeta->iHashTableHeader);
    m_pFixedTableUnqueried  = m_pFixedTableHeap->Get_aTagMeta();
    m_cColumnsPlusPrivate   = kciTagMetaColumns;


    HRESULT hr;
    LPCWSTR wszTable        =0;
    ULONG   ColumnIndex     =(ULONG)-1;
    LPCWSTR InternalName    =0;

    if(cQueryCells && FAILED(hr = GetTagMetaQuery(pQueryCell, cQueryCells, wszTable, ColumnIndex, InternalName)))
        return hr;

    const TagMeta *pTagMeta = m_pFixedTableHeap->Get_aTagMeta();//Start with the whole table.
    if(0 == wszTable)
    {   //No query
        m_ciRows        = m_pFixedTableHeap->Get_cTagMeta();
        m_iZerothRow    = 0;
    }
    else if(-1 == ColumnIndex)
    {   //query by Table only
        ULONG                   RowHash         = Hash(wszTable, 0) % m_pHashTableHeader->Modulo;
        const HashedIndex     * pHashedIndex    = &m_pHashedIndex[RowHash];

        if(-1 == pHashedIndex->iOffset)return E_ST_NOMOREROWS;

        for(;; pHashedIndex = &m_pHashedIndex[pHashedIndex->iNext])
        {   //Walk the hash links 'til we find a match
            pTagMeta      = m_pFixedTableHeap->Get_aTagMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszTable, StringFromIndex(pTagMeta->Table)))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;
        }

        m_iZerothRow    = pHashedIndex->iOffset;
        for(m_ciRows = 0; (m_iZerothRow + m_ciRows) < m_pFixedTableHeap->Get_cTagMeta() && 0 == StringInsensitiveCompare(wszTable, StringFromIndex(pTagMeta[m_ciRows].Table)); ++m_ciRows);
    }
    else if(0 == InternalName)
    {   //Query by TableName and ColumnIndex
        ULONG                   RowHash         = Hash(ColumnIndex, Hash(wszTable, 0)) % m_pHashTableHeader->Modulo;
        const HashedIndex     * pHashedIndex    = &m_pHashedIndex[RowHash];

        if(-1 == pHashedIndex->iOffset)return E_ST_NOMOREROWS;

        for(;; pHashedIndex = &m_pHashedIndex[pHashedIndex->iNext])
        {   //Walk the hash links 'til we find a match
            pTagMeta      = m_pFixedTableHeap->Get_aTagMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszTable, StringFromIndex(pTagMeta->Table)) && ColumnIndex == UI4FromIndex(pTagMeta->ColumnIndex))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;
        }

        m_iZerothRow    = pHashedIndex->iOffset;
        for(m_ciRows = 0; (m_iZerothRow + m_ciRows) < m_pFixedTableHeap->Get_cTagMeta() && 0 == StringInsensitiveCompare(wszTable, StringFromIndex(pTagMeta[m_ciRows].Table))
                         && ColumnIndex == UI4FromIndex(pTagMeta[m_ciRows].ColumnIndex); ++m_ciRows);
    }
    else
    {   //Query by all three PrimaryKeys
        ULONG                   RowHash         = Hash(InternalName, Hash(ColumnIndex, Hash(wszTable, 0))) % m_pHashTableHeader->Modulo;
        const HashedIndex     * pHashedIndex    = &m_pHashedIndex[RowHash];

        if(-1 == pHashedIndex->iOffset)return E_ST_NOMOREROWS;

        for(;; pHashedIndex = &m_pHashedIndex[pHashedIndex->iNext])
        {   //Walk the hash links 'til we find a match
            pTagMeta      = m_pFixedTableHeap->Get_aTagMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszTable, StringFromIndex(pTagMeta->Table)) && ColumnIndex == UI4FromIndex(pTagMeta->ColumnIndex)
                            && 0 == StringInsensitiveCompare(InternalName, StringFromIndex(pTagMeta->InternalName)))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;
        }

        m_ciRows        = 1;
        m_iZerothRow    = pHashedIndex->iOffset;
    }
    m_pFixedTable = const_cast<TagMeta *>(pTagMeta);
    return S_OK;
}


//TBinFileMappingCache public functions
void TBinFileMappingCache::GetFileMappingPointer(LPCWSTR i_wszFilename, const FixedTableHeap *& o_pFixedTableHeap)
{
    o_pFixedTableHeap = g_pFixedTableHeap;//if anything goes wrong we'll return the global one

    CSafeLock lock(m_CriticalSection);

    //if we made it here then we didn't find a match in the cache
    TBinFileMappingCache * pCacheEntry = GetCacheEntry(i_wszFilename);
    if(0 == pCacheEntry)
    {
        pCacheEntry = new TBinFileMappingCache;
        if(0 == pCacheEntry)
            return;
        if(FAILED(pCacheEntry->Init(i_wszFilename)))
        {
            //if the Init fails we have to clean up
            delete pCacheEntry;
            return;
        }
    }

    ++pCacheEntry->m_cRef;
    o_pFixedTableHeap = reinterpret_cast<const FixedTableHeap *>(pCacheEntry->m_FileMapping.Mapping());
}

void TBinFileMappingCache::ReleaseFileMappingPointer(const class FixedTableHeap * i_pFixedTableHeap)
{
    if(g_pFixedTableHeap == i_pFixedTableHeap)//the global one does exist in the cache and should not be released, it's the fall back
        return;
    if(g_pExtendedFixedTableHeap == i_pFixedTableHeap)//there is another global heap that we don't care about
        return;

    CSafeLock lock(m_CriticalSection);

    TBinFileMappingCache * pCache = GetCacheEntry(reinterpret_cast<const char *>(i_pFixedTableHeap));
    ASSERT(pCache);
    --pCache->m_cRef;
    if(0 == pCache->m_cRef)//if there are no references to this file then remove it from the cache
    {
        RemoveCacheEntry(pCache);
        delete pCache;
    }
}

//TBinFileMappingCache private functions
TBinFileMappingCache * TBinFileMappingCache::GetCacheEntry(LPCWSTR i_wszFilename)
{
    //Scan the cache
    for(TBinFileMappingCache * pCurrent=m_pFirst;pCurrent;pCurrent = pCurrent->m_pNext)
    {
        ASSERT(0 != pCurrent->m_spaFilename.m_p);
        if(0 == _wcsicmp(i_wszFilename, pCurrent->m_spaFilename.m_p))
            return pCurrent;
    }
    return 0;
}

TBinFileMappingCache * TBinFileMappingCache::GetCacheEntry(const char *i_pMapping)
{
    //Scan the cache
    for(TBinFileMappingCache * pCurrent=m_pFirst;pCurrent;pCurrent = pCurrent->m_pNext)
    {
        if(i_pMapping == pCurrent->m_FileMapping.Mapping())
            return pCurrent;
    }
    return 0;
}

HRESULT TBinFileMappingCache::Init(LPCWSTR i_wszFilename)
{
    HRESULT hr;
    if(FAILED(hr = m_FileMapping.Load(i_wszFilename)))
        return hr;
    if(m_FileMapping.Size()>4096)
        E_FAIL;//This does NOT get propagated beyond this object

    if(!reinterpret_cast<const class FixedTableHeap *>(m_FileMapping.Mapping())->IsValid())
    {
        LOG_ERROR(Interceptor, (E_FAIL, ID_CAT_CAT, IDS_COMCAT_MBSCHEMA_BIN_INVALID,
                            reinterpret_cast<LPCWSTR>(i_wszFilename)));
        return E_FAIL;//This does NOT get propagated beyond this object
    }
    //Make a copy of the string
    m_spaFilename = new WCHAR [wcslen(i_wszFilename)+1];//+1 for the NULL
    if(0 == m_spaFilename.m_p)
        return E_OUTOFMEMORY;
    wcscpy(m_spaFilename, i_wszFilename);

    //Last thing to do is actually add it to the list
    m_pNext  = m_pFirst;
    m_pFirst = this;
    return S_OK;
}

void TBinFileMappingCache::RemoveCacheEntry(TBinFileMappingCache * pRemove)
{
    if(pRemove == m_pFirst)
    {
        m_pFirst = pRemove->m_pNext;
        return;
    }

    //Scan the cache
    TBinFileMappingCache * pPrev = 0;
    for(TBinFileMappingCache * pCurrent=m_pFirst;pCurrent && pCurrent!=pRemove;pCurrent = pCurrent->m_pNext)
    {
        pPrev = pCurrent;
    }
    ASSERT(pPrev);//We already covered the case where this is the first one in the list
    pPrev->m_pNext = pRemove->m_pNext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\xmltable\metabase_xmltable.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.

#pragma once

class TGrowableBuffer : public TSmartPointerArray<unsigned char>
{
public:
    TGrowableBuffer() : m_cb(0){}
    void Grow(size_t cb)
    {
        if(cb > m_cb)
        {
            delete [] m_p;
            m_p     = new unsigned char[cb];
            if(0 == m_p)
            {
                m_cb = 0;
                throw static_cast<HRESULT>(E_OUTOFMEMORY);
            }
            m_cb    = cb;
        }
    }
    size_t Size() const {return m_cb;}
    void Delete()//The parent doesn't set m_cb to zero
    {
        delete [] m_p;
        m_p = 0;
        m_cb = 0;
    }
private:
    size_t m_cb;
};


// ------------------------------------------------------------------
// class TMetabase_XMLtable:
// ------------------------------------------------------------------
class TMetabase_XMLtable :
	public      ISimpleTableWrite2,
	public      ISimpleTableController,
	public      ISimpleTableInterceptor,
    public      TXmlParsedFileNodeFactory,
    public      TXmlSDTBase,
    public      TMSXMLBase
{
public:
    TMetabase_XMLtable ();
    virtual ~TMetabase_XMLtable ();

//IUnknown
public:
    STDMETHOD (QueryInterface)          (REFIID riid, OUT void **ppv);
    STDMETHOD_(ULONG,AddRef)            ();
    STDMETHOD_(ULONG,Release)           ();


	// ISimpleTableRead2 (ISimpleTableWrite2 : ISimpleTableRead2)
    STDMETHOD (GetRowIndexByIdentity)   (ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow);
    STDMETHOD (GetRowIndexBySearch)     (ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
                                        {
                                            UNREFERENCED_PARAMETER(i_iStartingRow);
                                            UNREFERENCED_PARAMETER(i_cColumns);
                                            UNREFERENCED_PARAMETER(i_aiColumns);
                                            UNREFERENCED_PARAMETER(i_acbSizes);
                                            UNREFERENCED_PARAMETER(i_apvValues);
                                            UNREFERENCED_PARAMETER(o_piRow);

                                            return E_NOTIMPL;
                                        }
	STDMETHOD (GetColumnValues)         (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues)
                                        {
                                            if(m_bUseIndexMapping)
                                            {
                                                if(i_iRow>=m_cRows)
                                                    return E_ST_NOMOREROWS;
                                                i_iRow=m_aRowIndex[i_iRow];
                                            }
                                            return m_SimpleTableWrite2_Memory->GetColumnValues(i_iRow, i_cColumns, i_aiColumns, o_acbSizes, o_apvValues);
                                        }
	STDMETHOD (GetTableMeta)            (ULONG* o_pcVersion, DWORD* o_pfTable, ULONG* o_pcRows, ULONG* o_pcColumns )
                                        {
                                            if(o_pcRows)
                                                *o_pcRows = m_cRows;
                                            return m_SimpleTableWrite2_Memory->GetTableMeta(o_pcVersion, o_pfTable, 0, o_pcColumns);
                                        }
	STDMETHOD (GetColumnMetas)	        (ULONG i_cColumns, ULONG* i_aiColumns, SimpleColumnMeta* o_aColumnMetas )
                                        { return m_SimpleTableWrite2_Memory->GetColumnMetas(i_cColumns, i_aiColumns, o_aColumnMetas );}

	// ISimpleTableWrite2
	STDMETHOD (AddRowForDelete)         (ULONG i_iReadRow)
                                        { return m_SimpleTableWrite2_Memory->AddRowForDelete(i_iReadRow);}
	STDMETHOD (AddRowForInsert)         (ULONG* o_piWriteRow)
                                        { return m_SimpleTableWrite2_Memory->AddRowForInsert(o_piWriteRow);}
	STDMETHOD (AddRowForUpdate)         (ULONG i_iReadRow, ULONG* o_piWriteRow)
                                        { return m_SimpleTableWrite2_Memory->AddRowForUpdate(i_iReadRow, o_piWriteRow);}
	STDMETHOD (SetWriteColumnValues)    (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues)
                                        { return m_SimpleTableWrite2_Memory->SetWriteColumnValues(i_iRow, i_cColumns, i_aiColumns, i_acbSizes, i_apvValues);}
	STDMETHOD (GetWriteColumnValues)    (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, DWORD* o_afStatus, ULONG* o_acbSizes, LPVOID* o_apvValues)
                                        { return m_SimpleTableWrite2_Memory->GetWriteColumnValues(i_iRow, i_cColumns, i_aiColumns, o_afStatus, o_acbSizes, o_apvValues);}
	STDMETHOD (GetWriteRowIndexByIdentity) (ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
                                        { return m_SimpleTableWrite2_Memory->GetWriteRowIndexByIdentity(i_acbSizes, i_apvValues, o_piRow);}
	STDMETHOD (GetWriteRowIndexBySearch)(ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
	                                    {
	                                        UNREFERENCED_PARAMETER(i_iStartingRow);
	                                        UNREFERENCED_PARAMETER(i_cColumns);
	                                        UNREFERENCED_PARAMETER(i_aiColumns);
	                                        UNREFERENCED_PARAMETER(i_acbSizes);
	                                        UNREFERENCED_PARAMETER(i_apvValues);
	                                        UNREFERENCED_PARAMETER(o_piRow);

	                                        return E_NOTIMPL;
	                                    }
	STDMETHOD (GetErrorTable)           (DWORD i_fServiceRequests, LPVOID* o_ppvSimpleTable)
                                        {
                                            UNREFERENCED_PARAMETER(i_fServiceRequests);
                                            UNREFERENCED_PARAMETER(o_ppvSimpleTable);

                                            return E_NOTIMPL;}
	STDMETHOD (UpdateStore)             ()
                                        { return E_NOTIMPL;}

	// ISimpleTableAdvanced (ISimpleTableController : ISimpleTableAdvanced)
	STDMETHOD (PopulateCache)           ();
	STDMETHOD (GetDetailedErrorCount)   (ULONG* o_pcErrs)
                                        { return m_SimpleTableController_Memory->GetDetailedErrorCount(o_pcErrs);}
	STDMETHOD (GetDetailedError)        (ULONG i_iErr, STErr* o_pSTErr)
                                        { return m_SimpleTableController_Memory->GetDetailedError(i_iErr, o_pSTErr);}
	STDMETHOD (ResetCaches)				()
                                        { return m_SimpleTableController_Memory->ResetCaches();}
	STDMETHOD (GetColumnValuesEx)       (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, DWORD* o_afStatus, ULONG* o_acbSizes, LPVOID* o_apvValues)
										{ return m_SimpleTableController_Memory->GetColumnValuesEx (i_iRow, i_cColumns, i_aiColumns, o_afStatus, o_acbSizes, o_apvValues);}



	// ISimpleTableController:
	STDMETHOD (ShapeCache)              (DWORD i_fTable, ULONG i_cColumns, SimpleColumnMeta* i_acolmetas, LPVOID* i_apvDefaults, ULONG* i_acbSizes)
                                        { return m_SimpleTableController_Memory->ShapeCache(i_fTable, i_cColumns, i_acolmetas, i_apvDefaults, i_acbSizes);}
	STDMETHOD (PrePopulateCache)        (DWORD i_fControl)
                                        { return m_SimpleTableController_Memory->PrePopulateCache(i_fControl);}
	STDMETHOD (PostPopulateCache)	    ()
                                        { return m_SimpleTableController_Memory->PostPopulateCache();}
	STDMETHOD (DiscardPendingWrites)    ()
                                        { return m_SimpleTableController_Memory->DiscardPendingWrites();}
	STDMETHOD (GetWriteRowAction)	    (ULONG i_iRow, DWORD* o_peAction)
                                        { return m_SimpleTableController_Memory->GetWriteRowAction(i_iRow, o_peAction);}
	STDMETHOD (SetWriteRowAction)	    (ULONG i_iRow, DWORD i_eAction)
                                        { return m_SimpleTableController_Memory->SetWriteRowAction(i_iRow, i_eAction);}
	STDMETHOD (ChangeWriteColumnStatus) (ULONG i_iRow, ULONG i_iColumn, DWORD i_fStatus)
                                        { return m_SimpleTableController_Memory->ChangeWriteColumnStatus(i_iRow, i_iColumn, i_fStatus);}
	STDMETHOD (AddDetailedError)        (STErr* o_pSTErr)
                                        { return m_SimpleTableController_Memory->AddDetailedError(o_pSTErr);}
	STDMETHOD (GetMarshallingInterface) (IID * o_piid, LPVOID * o_ppItf)
                                        { return m_SimpleTableController_Memory->GetMarshallingInterface(o_piid, o_ppItf);}

//ISimpleTableInterceptor
    STDMETHOD (Intercept)               (LPCWSTR                    i_wszDatabase,
                                         LPCWSTR                    i_wszTable,
										 ULONG						i_TableID,
                                         LPVOID                     i_QueryData,
                                         LPVOID                     i_QueryMeta,
                                         DWORD                      i_eQueryFormat,
                                         DWORD                      i_fLOS,
                                         IAdvancedTableDispenser*   i_pISTDisp,
                                         LPCWSTR                    i_wszLocator,
                                         LPVOID                     i_pSimpleTable,
                                         LPVOID*                    o_ppvSimpleTable
                                        );


//TXmlParsedFileNodeFactory (callback interface) routines
public:
    virtual HRESULT CoCreateInstance    (REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid,  LPVOID * ppv) const {return TMSXMLBase::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, riid, ppv);}
    virtual HRESULT CreateNode          (const TElement &Element);



// Helper functions
private:
    HRESULT     AddPropertyToLocationMapping(LPCWSTR i_Location, ULONG i_iFastCacheRow);
    HRESULT     AddKeyTypeRow(LPCWSTR i_KeyType, ULONG i_Len, bool bNULLKeyTypeRow=false);
    HRESULT     AddCommentRow();
    IAdvancedTableDispenser * Dispenser() {return m_pISTDisp;}
    HRESULT     FillInColumn(ULONG iColumn, LPCWSTR pwcText, ULONG ulLen, ULONG dbType, ULONG fMeta, bool bSecure=false);
    bool        FindAttribute(const TElement &i_Element, LPCWSTR i_wszAttr, ULONG i_cchAttr, ULONG &o_iAttr);
    ULONG       GetColumnMetaType(ULONG type) const;
    HRESULT     GetColumnValue_Bytes(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned long i_Len);
    HRESULT     GetColumnValue_MultiSZ(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned long i_Len);
    HRESULT     GetColumnValue_String(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned long i_Len);
    HRESULT     GetColumnValue_UI4(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned long i_Len);
    HRESULT     GetColumnValue_Bool(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned long i_Len);
    HRESULT     GetMetaTable(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, CComPtr<ISimpleTableRead2> &pMetaTable) const;
    bool        IsNumber(LPCWSTR i_awch, ULONG i_Len) const;
    HRESULT     InternalComplicatedInitialize();
    inline HRESULT InternalSetWriteColumn(ISimpleTableWrite2 *pISTW2, ULONG i_iRow, ULONG i_iColumn, ULONG i_cbSize, LPVOID i_pvValue)
                    {return pISTW2->SetWriteColumnValues(i_iRow, 1, &i_iColumn, &i_cbSize, &i_pvValue);}
    HRESULT     LoadDocumentFromURL(IXMLDOMDocument *pXMLDoc);
    int         Memicmp(LPCWSTR i_p0, LPCWSTR i_p1, ULONG i_cby) const;
    ULONG       MetabaseTypeFromColumnMetaType(tCOLUMNMETARow &columnmetaRow) const;
    bool        NumberFromString(LPCWSTR i_pNumber, ULONG i_Len, ULONG & o_Number) const;
    HRESULT     ObtainPertinentRelationMetaInfo();
    HRESULT     ObtainPertinentTableMetaInfo();
    HRESULT     ObtainPertinentTagMetaInfo();
    HRESULT     ParseXMLFile(IXMLDOMDocument *pXMLDoc, bool bValidating=true);
    HRESULT     SetComment(LPCWSTR i_pComment, ULONG i_Len, bool i_bAppend);
    int         SizeOf(LPCWSTR wsz) const {return (int)(wcslen(wsz)+1)*sizeof(WCHAR);}
    inline int  StringInsensitiveCompare(LPCWSTR sz1, LPCWSTR sz2) const {return _wcsicmp(sz1, sz2);}
    inline int  StringCompare(LPCWSTR sz1, LPCWSTR sz2) const {if(*sz1 != *sz2)return -1;return wcscmp(sz1, sz2);}
    inline int  StringCompare(LPCWSTR sz1, LPCWSTR pstrNoNull, ULONG cch_pstrNoNull) const {return memcmp(sz1, pstrNoNull, sizeof(WCHAR)*cch_pstrNoNull);}

// Private member variables
private:
    static const VARIANT_BOOL   kvboolTrue;
    static const VARIANT_BOOL   kvboolFalse;
    static       ULONG          m_kLocationID;
    static       ULONG          m_kZero;
    static       ULONG          m_kOne;
    static       ULONG          m_kTwo;
    static       ULONG          m_kThree;
    static       ULONG          m_kSTRING_METADATA;
    static       ULONG          m_kMBProperty_Custom;
    static const WCHAR *        m_kwszBoolStrings[];
    static       WCHAR          m_kKeyType[];
    static       LONG           m_LocationID;

    bool        IsEnumPublicRowName() const {return (-1 != m_iPublicRowNameColumn);}

    //This class maps a Location to its first instance in the fast cache.  It also tracks how many instances of the location exist in the fast cache
    class TLocation
    {
    public:
        TLocation() : m_iFastCache(0), m_cRows(0), m_cchLocation(0)
        {
        }
        TLocation(LPCWSTR wszLocation, ULONG iFastCache) : m_iFastCache(iFastCache), m_cRows(1)
        {
            if(wszLocation)
            {
                m_cchLocation = (ULONG)wcslen(wszLocation);
                m_wszLocation = new WCHAR[m_cchLocation+1];
                if(0 == m_wszLocation.m_p)
                    throw static_cast<HRESULT>(E_OUTOFMEMORY);
                memcpy(m_wszLocation, wszLocation, sizeof(WCHAR)*(m_cchLocation+1));
            }
        }

        bool        operator <  (const TLocation &location) const { return ( CSTR_LESS_THAN==CompareLocation(location));}
        bool        operator >  (const TLocation &location) const { return ( CSTR_GREATER_THAN==CompareLocation(location));}
        bool        operator == (const TLocation &location) const { return ( CSTR_EQUAL==CompareLocation(location));}
        TLocation & operator =  (const TLocation &location)
        {
            m_wszLocation.Delete();
            if(location.m_wszLocation)
            {
                m_cchLocation = location.m_cchLocation;
                m_wszLocation = new WCHAR[m_cchLocation+1];
                if(0 == m_wszLocation.m_p)
                    throw static_cast<HRESULT>(E_OUTOFMEMORY);
                memcpy(m_wszLocation, location.m_wszLocation, sizeof(WCHAR)*(m_cchLocation+1));
            }

            m_iFastCache    = location.m_iFastCache;
            m_cRows         = location.m_cRows;
            return *this;
        }

        TSmartPointerArray<WCHAR> m_wszLocation;
        ULONG   m_cRows;
        ULONG   m_iFastCache;
        ULONG   m_cchLocation;
    private:
        int CompareLocation(const TLocation &location) const
        {
            return CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, m_wszLocation, m_cchLocation,  location.m_wszLocation, location.m_cchLocation);
        }
    };
    class TProperty
    {   //It's OK to track property names by pointer since, by the time we build the sorted list, all entries are already in the fast
        //cache (no opportunity for the fast cache to resize, thus pointers are always valid).  This is NOT the case for the Locations.
    public:
        TProperty() : m_iFastCache(0), m_wszPropertyName(0)
        {
        }
        TProperty(LPCWSTR wszProperty, ULONG iFastCache) : m_iFastCache(iFastCache), m_wszPropertyName(wszProperty)
        {
        }

        ULONG   m_iFastCache;
        LPCWSTR m_wszPropertyName;

        bool        operator <  (const TProperty &property) const { return (_wcsicmp(m_wszPropertyName, property.m_wszPropertyName) < 0);}
        bool        operator >  (const TProperty &property) const { return (_wcsicmp(m_wszPropertyName, property.m_wszPropertyName) > 0);}
        bool        operator == (const TProperty &property) const { return (_wcsicmp(m_wszPropertyName, property.m_wszPropertyName) == 0);}
        TProperty & operator =  (const TProperty &property)
        {
            m_wszPropertyName = property.m_wszPropertyName;
            m_iFastCache      = property.m_iFastCache;
            return *this;
        }
    };

    class TTagMetaIndex
    {
    public:
        TTagMetaIndex() : m_iTagMeta((unsigned long)-1), m_cTagMeta(0){}
        unsigned long m_iTagMeta;//Index into the TagMeta (for this table)
        unsigned long m_cTagMeta;//Number of tags for this column
    };
    //We list the const members first.
    TComBSTR                            m_bstr_name;
    const LPCWSTR                       m_kXMLSchemaName;           // This is the XML Schema name that is used to validate the XML document

    //We have this problem where we need a bunch of arrays, each of size m_cColumns.  To reduce the number of allocations we'll create these arrays as
    //fixed size and hope that most tables will have no more than m_kColumns.
    enum
    {
        m_kColumns          = cMBProperty_NumberOfColumns,
        m_kMaxEventReported = 50
    };
    //Here are the 'fixed' size arrays
    TComBSTR                                m_abstrColumnNames[m_kColumns];
    SimpleColumnMeta                        m_acolmetas[m_kColumns];
    unsigned int                            m_aLevelOfColumnAttribute[m_kColumns];
    LPVOID                                  m_apColumnValue[m_kColumns];
    STQueryCell                             m_aQuery[m_kColumns];
    ULONG                                   m_aStatus[m_kColumns];
    LPCWSTR                                 m_awszColumnName[m_kColumns];
    unsigned long                           m_acchColumnName[m_kColumns];
    unsigned int                            m_aColumnsIndexSortedByLevel[m_kColumns];//Node Factory variable (see below)
    unsigned long                           m_aSize[m_kColumns];                     //Node Factory variable (see below)
    TTagMetaIndex                           m_aTagMetaIndex[m_kColumns];
    TGrowableBuffer                         m_aGrowableBuffer[m_kColumns];

    TPublicRowName                      m_aPublicRowName;
    TSmartPointerArray<ULONG>           m_aRowIndex;                // When the XML file isn't sorted correctly, we have to map the fast cache row indexes into a Location sorted list.
    TSmartPointerArray<tTAGMETARow>     m_aTagMetaRow;              // This is a copy of the TagMeta for this table. m_aiTagMeta for each column points into this array if the column has tag meta
    bool                                m_bEnumPublicRowName_NotContainedTable_ParentFound;//This is to keep track of the parent of this special kind of table.  And when we reach a close tag for the parent we can bail.
    bool                                m_bFirstPropertyOfThisLocationBeingAdded;
    bool                                m_bIISConfigObjectWithNoCustomProperties;
    bool                                m_bQueriedLocationFound;
    TComBSTR                            m_bstrPublicTableName;      // These come from the table meta
    TComBSTR                            m_bstrPublicRowName;        // There is a need for the base PublicRowName aside from the array of PublicRowNames above
    bool                                m_bUseIndexMapping;         // This is true when the order of the Locations in the XML file are not correctly sorted, and the Metabase XML interceptor has to remap the row indexes
    bool                                m_bValidating;              // If we don't validate, then the parse should be a bit faster
    ULONG                               m_cchCommentBufferSize;
    ULONG                               m_cEventsReported;
    unsigned                            m_cLocations;               // Count of Metabase Locations (or Paths)
    ULONG                               m_cMaxProertiesWithinALocation;//This is the count of properties in the most populated location.
    ULONG                               m_cRef;                     // Interface reference count.
    ULONG                               m_cRows;                    // Number of Rows in the table, this is also the size of m_aRowIndex
    ULONG                               m_cTagMetaValues;           // Count Of TagMeta entries for the table
    DWORD                               m_fCache;                   // Cache flags.
    ULONG                               m_fLOS;                     // Level Of Service passed into ::Intercept
    ULONG                               m_iCollectionCommentRow;
    ULONG                               m_iKeyTypeRow;
    ULONG                               m_iPreviousLocation;
    unsigned int                        m_iPublicRowNameColumn;     // Some tables use an enum value as the public row name, this is an index to the column with the enum.  If this is not one of those types of tables, then this value is -1.
    LONG                                m_IsIntercepted;            // Table flags (from caller).
    CCfgArray<TLocation>                m_LocationMapping;
    ULONG                               m_MajorVersion;
    CComPtr<IAdvancedTableDispenser>    m_pISTDisp;
    CComPtr<IXMLDOMNode>                m_pLastPrimaryTable;
    CComPtr<IXMLDOMNode>                m_pLastParent;
    CComPtr<ISimpleTableRead2>          m_pTableMeta;
    CComPtr<ISimpleTableRead2>          m_pTagMeta;
    CComPtr<ISimpleTableRead2>          m_pTagMeta_IISConfigObject;//This is how we look up Tags for the Value column
    TSmartPointerArray<WCHAR>           m_saCollectionComment;
    TSmartPointerArray<WCHAR>           m_saQueriedLocation;
    TSmartPointerArray<WCHAR>           m_saSchemaBinFileName;
    CComPtr<ISimpleTableWrite2>         m_SimpleTableWrite2_Memory;
    CComQIPtr<ISimpleTableController,
           &IID_ISimpleTableController> m_SimpleTableController_Memory;
    CComPtr<ISimpleTableWrite2>         m_spISTError;
    CComQIPtr<IMetabaseSchemaCompiler, &IID_IMetabaseSchemaCompiler> m_spMetabaseSchemaCompiler;
    tTABLEMETARow                       m_TableMetaRow;

    ULONG                               m_cCacheHit;
    ULONG                               m_cCacheMiss;

    const unsigned long                 m_kPrime;

    TXmlParsedFile_NoCache              m_XmlParsedFile;
//    CComPtr<ISimpleTableRead2>          m_pNameValueMeta;
    CComPtr<ISimpleTableRead2>          m_pColumnMetaAll;//This uses "ByName" indexing
    enum
    {
        ciColumnMeta_IndexBySearch      = 2,
        ciColumnMeta_IndexBySearchID    = 2,
        ciTagMeta_IndexBySearch         = 2
    };

    ULONG                               m_aiColumnMeta_IndexBySearch[ciColumnMeta_IndexBySearch];
    ULONG                               m_aiColumnMeta_IndexBySearchID[ciColumnMeta_IndexBySearchID];//We'll reuse m_ColumnMeta_IndexBySearch_Values for ByID
    tCOLUMNMETARow                      m_ColumnMeta_IndexBySearch_Values;//This is passed into GetRowIndexBySearch, the 0th element is the Table, the 1st element is the Column's InternalName
    ULONG                               m_aiTagMeta_IndexBySearch[ciTagMeta_IndexBySearch];
    tTAGMETARow                         m_TagMeta_IndexBySearch_Values;

    CComPtr<ISimpleTableRead2>          m_pTableMeta_Metabase;//These are the Tables belonging to the Metabase Database
    CComPtr<ISimpleTableRead2>          m_pColumnMeta;//The only reason we keep this guy around after initial meta setup, is so we don't have to make copies of the ColumnNames

    DWORD                               m_dwGroupRemembered;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\xmltable\metabase_xmltable.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
//  SDTxml.cpp : Implementation of Metabase_XMLtable

#include "precomp.hxx"

//  This is a read/write data table that comes from an XML document.

#define LOG_WARNING1(x, str1)                   {if(m_cEventsReported<m_kMaxEventReported){m_cEventsReported++;LOG_ERROR_LOS(m_fLOS, Interceptor, (&m_spISTError.p, m_pISTDisp, E_SDTXML_LOGICAL_ERROR_IN_XML, ID_CAT_CAT, x, str1,                   eSERVERWIRINGMETA_Core_MetabaseInterceptor, wszTABLE_MBProperty, eDETAILEDERRORS_Populate, (ULONG) -1, (ULONG) -1, m_wszURLPath, eDETAILEDERRORS_WARNING, 0, 0, m_MajorVersion));} \
                                                                                      else if(m_cEventsReported==m_kMaxEventReported){m_cEventsReported++;LOG_ERROR_LOS(m_fLOS, Interceptor, (&m_spISTError.p, m_pISTDisp, E_SDTXML_LOGICAL_ERROR_IN_XML, ID_CAT_CAT, IDS_METABASE_TOO_MANY_WARNINGS, m_wszURLPath, eSERVERWIRINGMETA_Core_MetabaseInterceptor, wszTABLE_MBProperty, eDETAILEDERRORS_Populate, (ULONG )-1, (ULONG) -1, m_wszURLPath, eDETAILEDERRORS_WARNING, 0, 0, m_MajorVersion));}}
#define LOG_WARNING2(x, str1, str2)             {if(m_cEventsReported<m_kMaxEventReported){m_cEventsReported++;LOG_ERROR_LOS(m_fLOS, Interceptor, (&m_spISTError.p, m_pISTDisp, E_SDTXML_LOGICAL_ERROR_IN_XML, ID_CAT_CAT, x, str1, str2,             eSERVERWIRINGMETA_Core_MetabaseInterceptor, wszTABLE_MBProperty, eDETAILEDERRORS_Populate, (ULONG )-1, (ULONG) -1, m_wszURLPath, eDETAILEDERRORS_WARNING, 0, 0, m_MajorVersion));} \
                                                                                      else if(m_cEventsReported==m_kMaxEventReported){m_cEventsReported++;LOG_ERROR_LOS(m_fLOS, Interceptor, (&m_spISTError.p, m_pISTDisp, E_SDTXML_LOGICAL_ERROR_IN_XML, ID_CAT_CAT, IDS_METABASE_TOO_MANY_WARNINGS, m_wszURLPath, eSERVERWIRINGMETA_Core_MetabaseInterceptor, wszTABLE_MBProperty, eDETAILEDERRORS_Populate, (ULONG) -1, (ULONG) -1, m_wszURLPath, eDETAILEDERRORS_WARNING, 0, 0, m_MajorVersion));}}
#define LOG_WARNING3(x, str1, str2, str3)       {if(m_cEventsReported<m_kMaxEventReported){m_cEventsReported++;LOG_ERROR_LOS(m_fLOS, Interceptor, (&m_spISTError.p, m_pISTDisp, E_SDTXML_LOGICAL_ERROR_IN_XML, ID_CAT_CAT, x, str1, str2, str3,       eSERVERWIRINGMETA_Core_MetabaseInterceptor, wszTABLE_MBProperty, eDETAILEDERRORS_Populate, (ULONG)-1, (ULONG) -1, m_wszURLPath, eDETAILEDERRORS_WARNING, 0, 0, m_MajorVersion));} \
                                                                                      else if(m_cEventsReported==m_kMaxEventReported){m_cEventsReported++;LOG_ERROR_LOS(m_fLOS, Interceptor, (&m_spISTError.p, m_pISTDisp, E_SDTXML_LOGICAL_ERROR_IN_XML, ID_CAT_CAT, IDS_METABASE_TOO_MANY_WARNINGS, m_wszURLPath, eSERVERWIRINGMETA_Core_MetabaseInterceptor, wszTABLE_MBProperty, eDETAILEDERRORS_Populate, (ULONG) -1, (ULONG) -1, m_wszURLPath, eDETAILEDERRORS_WARNING, 0, 0, m_MajorVersion));}}
#define LOG_WARNING4(x, str1, str2, str3, str4) {if(m_cEventsReported<m_kMaxEventReported){m_cEventsReported++;LOG_ERROR_LOS(m_fLOS, Interceptor, (&m_spISTError.p, m_pISTDisp, E_SDTXML_LOGICAL_ERROR_IN_XML, ID_CAT_CAT, x, str1, str2, str3, str4, eSERVERWIRINGMETA_Core_MetabaseInterceptor, wszTABLE_MBProperty, eDETAILEDERRORS_Populate, (ULONG) -1, (ULONG) -1, m_wszURLPath, eDETAILEDERRORS_WARNING, 0, 0, m_MajorVersion));} \
                                                                                                          else{LOG_ERROR_LOS(m_fLOS, Interceptor, (&m_spISTError.p, m_pISTDisp, E_SDTXML_LOGICAL_ERROR_IN_XML, ID_CAT_CAT, IDS_METABASE_TOO_MANY_WARNINGS, m_wszURLPath, eSERVERWIRINGMETA_Core_MetabaseInterceptor, wszTABLE_MBProperty, eDETAILEDERRORS_Populate, (ULONG) -1, (ULONG) -1, m_wszURLPath, eDETAILEDERRORS_WARNING, 0, 0, m_MajorVersion));}}

#define LOG_ERROR1(x, hr, str1)                 LOG_ERROR_LOS(m_fLOS, Interceptor, (&m_spISTError.p, m_pISTDisp, hr, ID_CAT_CAT, x, str1,                   eSERVERWIRINGMETA_Core_MetabaseInterceptor, wszTABLE_MBProperty, eDETAILEDERRORS_Populate, (ULONG) -1, (ULONG) -1, m_wszURLPath, eDETAILEDERRORS_ERROR,   0, 0, m_MajorVersion))
#define S_IGNORE_THIS_PROPERTY                  S_FALSE

extern HMODULE g_hModule;

const VARIANT_BOOL  TMetabase_XMLtable::kvboolTrue              = -1;
const VARIANT_BOOL  TMetabase_XMLtable::kvboolFalse             =  0;
      ULONG         TMetabase_XMLtable::m_kLocationID           =  9989;
      ULONG         TMetabase_XMLtable::m_kZero                 =  0;
      ULONG         TMetabase_XMLtable::m_kOne                  =  1;
      ULONG         TMetabase_XMLtable::m_kTwo                  =  2;
      ULONG         TMetabase_XMLtable::m_kThree                =  3;
      ULONG         TMetabase_XMLtable::m_kSTRING_METADATA      =  eCOLUMNMETA_STRING_METADATA;
      ULONG         TMetabase_XMLtable::m_kMBProperty_Custom    = eMBProperty_Custom;
const WCHAR *       TMetabase_XMLtable::m_kwszBoolStrings[]     = {L"false", L"true", L"0", L"1", L"no", L"yes", L"off", L"on", 0};
      WCHAR         TMetabase_XMLtable::m_kKeyType[]            = L"KeyType";
      LONG          TMetabase_XMLtable::m_LocationID            = 0;

/////////////////////////////////////////////////////////////////////////////
// TMetabase_XMLtable
// Constructor and destructor
// ==================================================================
TMetabase_XMLtable::TMetabase_XMLtable() :
                m_bEnumPublicRowName_NotContainedTable_ParentFound(false)
                ,m_bFirstPropertyOfThisLocationBeingAdded(true)
                ,m_bIISConfigObjectWithNoCustomProperties(false)
                ,m_bQueriedLocationFound(false)
                ,m_bUseIndexMapping(true)//Always map the indexes
                ,m_bValidating(true)
                ,m_cCacheHit(0)
                ,m_cCacheMiss(0)
                ,m_cEventsReported(0)
                ,m_cLocations(0)
                ,m_cMaxProertiesWithinALocation(0x20)
                ,m_cRef(0)
                ,m_cRows(0)
                ,m_dwGroupRemembered((ULONG)-1)
                ,m_fCache(0)
                ,m_fLOS(0)
                ,m_iCollectionCommentRow((ULONG)-1)
                ,m_iKeyTypeRow((ULONG)-1)
                ,m_iPreviousLocation((ULONG)-1)
                ,m_IsIntercepted(0)
                ,m_kPrime(97)
                ,m_kXMLSchemaName(L"ComCatMeta_v6")
                ,m_MajorVersion((ULONG)-1)
                ,m_pISTDisp(0)
{
    m_wszURLPath[0] = 0x00;
    memset(m_acolmetas                  , 0x00, sizeof(m_acolmetas                  ));
    memset(m_aLevelOfColumnAttribute    , 0x00, sizeof(m_aLevelOfColumnAttribute    ));
    memset(m_aStatus                    , 0x00, sizeof(m_aStatus                    ));
    memset(m_aSize                      , 0x00, sizeof(m_aSize                      ));
    memset(m_awszColumnName             , 0x00, sizeof(m_awszColumnName             ));
    memset(m_acchColumnName             , 0x00, sizeof(m_acchColumnName             ));

    m_aiColumnMeta_IndexBySearch[0]    = iCOLUMNMETA_Table;
    m_aiColumnMeta_IndexBySearch[1]    = iCOLUMNMETA_InternalName;

    m_aiColumnMeta_IndexBySearchID[0]  = iCOLUMNMETA_Table;
    m_aiColumnMeta_IndexBySearchID[1]  = iCOLUMNMETA_ID;

    m_aiTagMeta_IndexBySearch[0]       = iTAGMETA_Table;
    m_aiTagMeta_IndexBySearch[1]       = iTAGMETA_InternalName;
}

// ==================================================================
TMetabase_XMLtable::~TMetabase_XMLtable()
{
    if(m_spMetabaseSchemaCompiler.p && m_saSchemaBinFileName.m_p)
        m_spMetabaseSchemaCompiler->ReleaseBinFileName(m_saSchemaBinFileName);
}


HRESULT TMetabase_XMLtable::AddPropertyToLocationMapping(LPCWSTR i_Location, ULONG i_iFastCacheRow)//can throw HRESULT
{
	HRESULT hr = S_OK;
    //Is this the same location we just saw
    if(!m_bFirstPropertyOfThisLocationBeingAdded && m_cLocations > 0)
    {   //if it's not the first property, then the previous location should match
        ASSERT(0 == StringInsensitiveCompare(m_LocationMapping[m_iPreviousLocation].m_wszLocation, i_Location));
        ++m_LocationMapping[m_iPreviousLocation].m_cRows;
        if(m_LocationMapping[m_iPreviousLocation].m_cRows > m_cMaxProertiesWithinALocation)
            m_cMaxProertiesWithinALocation = m_LocationMapping[m_iPreviousLocation].m_cRows;//track the larest property count
    }
    else
    {   //If not we have a new location to add to the LocationMapping array
        TLocation   locationTemp(i_Location, i_iFastCacheRow);

        //Usually a new location means adding it to the end since the Metabase is already sorted
        if(0 == m_cLocations)
        {
            hr = m_LocationMapping.Append(locationTemp);
			if (FAILED (hr))
				return hr;

            m_iPreviousLocation = m_cLocations;
        }
        else
        {   //Does this new location go at the end?  Usually it does.
#ifdef UNSORTED_METABASE
            if(true)
#else
            if(locationTemp > m_LocationMapping[m_cLocations-1])
#endif
            {
                hr = m_LocationMapping.Append(locationTemp);
				if (FAILED (hr))
					return hr;

                m_iPreviousLocation = m_cLocations;
            }
            else
            {   //But if, for some reason, the XML file is not properly sorted then we need to determine where in the list this element belongs.  So we do a binary search.
                DBGPRINTF(( DBG_CONTEXT,
                            "Location %s is out of order.  The previous location was %s\r\n", locationTemp.m_wszLocation, m_LocationMapping[m_iPreviousLocation].m_wszLocation ));

                hr = m_LocationMapping.InsertAt(locationTemp, m_iPreviousLocation = m_LocationMapping.BinarySearch(locationTemp));
				if (FAILED (hr))
					return hr;

                m_bUseIndexMapping = true;//The first time we have to insert a location into middle (instead of just appending) we know we'll have to build a set of row indexes
            }
        }
        ++m_cLocations;
#ifdef VERBOSE_DEBUGOUTPUT
		if(pfnIsDebuggerPresent && pfnIsDebuggerPresent())
		{
            DBGPRINTF(( DBG_CONTEXT,
                        "iFastCache       cRows    wszLocation\r\n" ));
            for(ULONG i=0;i<m_cLocations;++i)
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "  %8d    %8d    %s\r\n", m_LocationMapping[i].m_iFastCache, m_LocationMapping[i].m_cRows, m_LocationMapping[i].m_wszLocation ));
            }
        }
#endif
    }

	return S_OK;
}


HRESULT TMetabase_XMLtable::FillInColumn(ULONG iColumn, LPCWSTR pwcText, ULONG ulLen, ULONG dbType, ULONG MetaFlags, bool bSecure)
{
    //length of 0 on a string means a 0 length string, for every other type it means NULL
	if(0==ulLen && DBTYPE_WSTR!=GetColumnMetaType(dbType) && DBTYPE_BYTES!=GetColumnMetaType(dbType))//In the case of BYTES, we fall through so we might recursively call FillInColumn again
	{
        LOG_WARNING1(IDS_METABASE_ZERO_LENGTH_STRING_NOT_PERMITTED, L"");
        return S_IGNORE_THIS_PROPERTY;
	}

    if(bSecure)          //GetColumnValue will realloc the GrowableBuffer if necessary
        return GetColumnValue_Bytes(iColumn, pwcText, ulLen);

    switch(GetColumnMetaType(dbType))
    {
    case DBTYPE_UI4:
        if(MetaFlags & fCOLUMNMETA_BOOL)
            return GetColumnValue_Bool(iColumn, pwcText, ulLen);
        else
            return GetColumnValue_UI4(iColumn, pwcText, ulLen);
    case DBTYPE_WSTR:
        if(MetaFlags & fCOLUMNMETA_MULTISTRING || eMBProperty_MULTISZ==dbType)
            return GetColumnValue_MultiSZ(iColumn, pwcText, ulLen);
        else
            return GetColumnValue_String(iColumn, pwcText, ulLen);
    case DBTYPE_GUID:
        {
            ASSERT(false && "There are no GUIDs in the Metabase!!  So what's going on here?");
            return E_FAIL;
        }

    case DBTYPE_BYTES:
        {//Some of the tables use this data type but the parser returns the BYTES as a string.  We'll have to convert the string to hex ourselves.
            if(iMBProperty_Value == iColumn && m_apColumnValue[iMBProperty_Type] && DBTYPE_BYTES != GetColumnMetaType(*reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Type])))
            {   //We know we've already found the Type column because we sorted them in InternalComplicatedInitialize
                //So we override the type and recursively call this function.
                return FillInColumn(iColumn, pwcText, ulLen, *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Type]), MetaFlags);
            }

            return GetColumnValue_Bytes(iColumn, pwcText, ulLen);
        }
    default:
        {
            ASSERT(false && "SDTXML - An Unsupported data type was specified\r\n");
            return E_SDTXML_NOTSUPPORTED;//An Unsupported data type was specified
        }
    }
    return S_OK;
}


HRESULT TMetabase_XMLtable::GetMetaTable(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, CComPtr<ISimpleTableRead2> &pMetaTable) const
{
    STQueryCell         qcellMeta[2];                  // Query cell for grabbing meta table.

    UNREFERENCED_PARAMETER(i_wszDatabase);

    qcellMeta[0].pData     = (LPVOID)m_saSchemaBinFileName.m_p;
    qcellMeta[0].eOperator = eST_OP_EQUAL;
    qcellMeta[0].iCell     = iST_CELL_FILE;
    qcellMeta[0].dbType    = DBTYPE_WSTR;
    qcellMeta[0].cbSize    = 0;

    qcellMeta[1].pData     = (LPVOID)i_wszTable;
    qcellMeta[1].eOperator = eST_OP_EQUAL;
    qcellMeta[1].iCell     = iCOLUMNMETA_Table;
    qcellMeta[1].dbType    = DBTYPE_WSTR;
    qcellMeta[1].cbSize    = 0;

// Obtain our dispenser
#ifdef XML_WIRING
    CComPtr<ISimpleDataTableDispenser>     pSimpleDataTableDispenser;      // Dispenser for the Meta Table

    HRESULT hr;
    if(FAILED(hr = CoCreateInstance(clsidSDTXML, 0, CLSCTX_INPROC_SERVER, IID_ISimpleDataTableDispenser,  reinterpret_cast<void **>(&pSimpleDataTableDispenser))))
        return hr;

    return pSimpleDataTableDispenser->GetTable (wszDATABASE_META, wszTABLE_COLUMNMETA, (LPVOID) &qcellMeta, (LPVOID)&m_kTwo,
                        eST_QUERYFORMAT_CELLS, 0, 0, (LPVOID*) &pMetaTable);
#else
    return ((IAdvancedTableDispenser *)m_pISTDisp.p)->GetTable (wszDATABASE_META, wszTABLE_COLUMNMETA, (LPVOID) qcellMeta, (LPVOID)&m_kTwo, eST_QUERYFORMAT_CELLS, 0, (LPVOID*) &pMetaTable);

#endif
}

//We take either a metabase type, or a columnmeta type and return the appropriate columnmeta type.
ULONG TMetabase_XMLtable::GetColumnMetaType(ULONG type) const
{
    if(type <= eMBProperty_MULTISZ)
    {
        ASSERT(0 != type);

        static ULONG TypeMapping[eMBProperty_MULTISZ+1]={0,eCOLUMNMETA_UI4,eCOLUMNMETA_WSTR,eCOLUMNMETA_BYTES,eCOLUMNMETA_WSTR,eCOLUMNMETA_WSTR};
        return TypeMapping[type];
    }
    return type;
}

//The following GetColumnValue_xxx functions, take the wszAttr and convert it to the appropriate type.  The results are placed
//into the column's Growable buffer; and the array pointer m_apColumnValue is set to point to the GrowableBuffer.  Also the size
//of the result (which is NOT the same as the size of the GrowableBuffer) is placed into the m_aSize array.
//
//WARNING!!! These functions should be called by FillInColumn ONLY.  Do NOT call these directly.  FillInColumn handles the NULL
//cases.
HRESULT TMetabase_XMLtable::GetColumnValue_Bool(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned long i_Len)
{
    if(0==wszAttr || 0==i_Len)
    {
        m_apColumnValue[i_iColumn] = 0;
        m_aSize[i_iColumn] = 0;
        return S_OK;
    }

    ASSERT(m_aGrowableBuffer[i_iColumn].Size()>=sizeof(ULONG));
    m_apColumnValue[i_iColumn] = m_aGrowableBuffer[i_iColumn].m_p;
    m_aSize[i_iColumn] = sizeof(ULONG);

    if((wszAttr[0]>=L'0' && wszAttr[0]<=L'9') || (wszAttr[0]<=L'-'))//accept a numeric value for bools
    {
    	*reinterpret_cast<ULONG *>(m_apColumnValue[i_iColumn]) = static_cast<unsigned long>(wcstoul(wszAttr, 0, 10));
        return S_OK;
    }

    unsigned long iBoolString;
    if(i_Len)
    {
        for(iBoolString=0; m_kwszBoolStrings[iBoolString] &&
            (0 != _memicmp(m_kwszBoolStrings[iBoolString], wszAttr, i_Len*sizeof(WCHAR))); ++iBoolString);
    }
    else
    {
        for(iBoolString=0; m_kwszBoolStrings[iBoolString] &&
            (0 != StringInsensitiveCompare(m_kwszBoolStrings[iBoolString], wszAttr)); ++iBoolString);
    }

    if(0 == m_kwszBoolStrings[iBoolString])
    {
        TSmartPointerArray<WCHAR> wszTemp = new WCHAR [i_Len+1];
		if (wszTemp == 0)
			return E_OUTOFMEMORY;

        memcpy(wszTemp, wszAttr, i_Len*sizeof(WCHAR));
        wszTemp[i_Len]=0x00;//NULL terminate it

        LOG_WARNING1(IDS_COMCAT_XML_ILLEGAL_BOOL_VALUE, wszTemp);
        return S_IGNORE_THIS_PROPERTY;
    }

    *reinterpret_cast<ULONG *>(m_apColumnValue[i_iColumn]) = (iBoolString & 0x01);

    return S_OK;
}


HRESULT TMetabase_XMLtable::GetColumnValue_Bytes(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned long i_Len)
{
    HRESULT     hr;

    if(0==wszAttr || 0==i_Len)
    {
        m_apColumnValue[i_iColumn] = 0;
        m_aSize[i_iColumn] = 0;
        return S_OK;
    }

    //If someone has an odd number of characters in this attribute then the odd one will be ignored
    if(i_Len & 1)
    {
        TSmartPointerArray<WCHAR> wszTemp = new WCHAR [i_Len+1];
		if (wszTemp == 0)
			return E_OUTOFMEMORY;

        memcpy(wszTemp, wszAttr, i_Len*sizeof(WCHAR));
        wszTemp[i_Len]=0x00;//NULL terminate it

        LOG_WARNING1(IDS_COMCAT_XML_BINARY_STRING_CONTAINS_ODD_NUMBER_OF_CHARACTERS, wszTemp);
        return S_IGNORE_THIS_PROPERTY;
    }

    m_aSize[i_iColumn] = i_Len/sizeof(WCHAR);// L"FF" is 2 characters, so i_Len needs to be divisible by sizeof(WCHAR)

    if(0 == m_aSize[i_iColumn])//Special case "" so it's NULL
    {
        m_apColumnValue[i_iColumn] = 0;
        m_aSize[i_iColumn] = 0;
        return S_OK;
    }

    m_aGrowableBuffer[i_iColumn].Grow(m_aSize[i_iColumn]);
    m_apColumnValue[i_iColumn] = m_aGrowableBuffer[i_iColumn].m_p;

    if(FAILED(hr = StringToByteArray(wszAttr, reinterpret_cast<unsigned char *>(m_apColumnValue[i_iColumn]), i_Len)))
    {
        TSmartPointerArray<WCHAR> wszTemp = new WCHAR [i_Len+1];
		if (wszTemp == 0)
			return E_OUTOFMEMORY;

        memcpy(wszTemp, wszAttr, i_Len*sizeof(WCHAR));
        wszTemp[i_Len]=0x00;//NULL terminate it

        LOG_WARNING1(IDS_COMCAT_XML_BINARY_STRING_CONTAINS_A_NON_HEX_CHARACTER, wszTemp);
        return S_IGNORE_THIS_PROPERTY;
    }

    return S_OK;
}

//See comment above GetColumnValue_Bytes
HRESULT TMetabase_XMLtable::GetColumnValue_MultiSZ(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned long i_Len)
{
    if(0==wszAttr || 0==i_Len)
    {
        m_apColumnValue[i_iColumn] = &m_kZero;
        m_aSize[i_iColumn] = 2*sizeof(WCHAR);//Double NULLs
        return S_OK;
    }

	//We know that i_Len+2 is enough space because the MULTISZ representation is always shorter than the '|' or '\n' delimited form (with the exception of the double NULL)
    m_aGrowableBuffer[i_iColumn].Grow((i_Len+2) * sizeof(WCHAR));//i_Len does NOT include the terminating NULL, and we need 2 NULLs for a MultiSZ
    m_apColumnValue[i_iColumn] = m_aGrowableBuffer[i_iColumn].m_p;

    LPWSTR pMultiSZ = reinterpret_cast<LPWSTR>(m_apColumnValue[i_iColumn]);

	//Scan the string for the '\n' character.  This is the MultiSZ delimiter.  Then walk backwards to the first non white space.  This is the end of the string.
	//Now move back up to the '\n' and ignore the white spaces.
	bool bIgnoringLeadingWhiteSpaces=true;
	bool bIgnoringDelimiters=true;//this is set to true after we've seen a delimiter since we don't want to treat two "\n" as two separate delimiters.
	for(ULONG iMultiSZ=0; iMultiSZ<i_Len; ++iMultiSZ)
	{
		switch(wszAttr[iMultiSZ])
		{
		case L'\n':
		case L'\r':
			if(bIgnoringDelimiters)
				break;
            //Eliminate trailing whitespaces
			while(--pMultiSZ > reinterpret_cast<LPWSTR>(m_apColumnValue[i_iColumn]))
			{
				if(*pMultiSZ != L' ' && *pMultiSZ != L'\t')
					break;
			}
            if(*pMultiSZ == 0x00)
            {   //if the string is only white spaces then there's nothing to do
    			++pMultiSZ;
            }
            else
            {   //null terminate the string
			    ++pMultiSZ;
                *pMultiSZ++ = 0x00;
            }
			bIgnoringLeadingWhiteSpaces = true;
            bIgnoringDelimiters = true;
			break;
		case L' ':
		case L'\t':
			bIgnoringDelimiters = false;//once we've found a non delimiter we can chage state
			if(!bIgnoringLeadingWhiteSpaces)
				*pMultiSZ++ = wszAttr[iMultiSZ];
			break;
        case 0xD836:
			bIgnoringDelimiters = false;//once we've found a non delimiter we can chage state
			bIgnoringLeadingWhiteSpaces = false;//we've found a nonwhitespace, so any whitespaces following are part of the string.
            *pMultiSZ = wszAttr[++iMultiSZ] & 0xFBFF;break;
        case 0xD837:
			bIgnoringDelimiters = false;//once we've found a non delimiter we can chage state
			bIgnoringLeadingWhiteSpaces = false;//we've found a nonwhitespace, so any whitespaces following are part of the string.
            *pMultiSZ = wszAttr[++iMultiSZ];
            break;
        case 0xD83F:
			bIgnoringDelimiters = false;//once we've found a non delimiter we can chage state
			bIgnoringLeadingWhiteSpaces = false;//we've found a nonwhitespace, so any whitespaces following are part of the string.
            *pMultiSZ = wszAttr[++iMultiSZ] | 0x2000;break;
        case 0xD800:
			bIgnoringDelimiters = false;//once we've found a non delimiter we can chage state
			bIgnoringLeadingWhiteSpaces = false;//we've found a nonwhitespace, so any whitespaces following are part of the string.
            *pMultiSZ = wszAttr[++iMultiSZ] - 0xDC00;break;
		default:
			bIgnoringDelimiters = false;//once we've found a non delimiter we can chage state
			bIgnoringLeadingWhiteSpaces = false;//we've found a nonwhitespace, so any whitespaces following are part of the string.
			*pMultiSZ++ = wszAttr[iMultiSZ];
			break;
		}
	}
    //Eliminate trailing whitespaces
	while(--pMultiSZ > reinterpret_cast<LPWSTR>(m_apColumnValue[i_iColumn]))
	{
		if(*pMultiSZ != L' ' && *pMultiSZ != L'\t')
			break;
	}
    if(*pMultiSZ == 0x00)
    {   //if the string is only white spaces then there's nothing to do
    	++pMultiSZ;
    }
    else
    {   //null terminate the string
		++pMultiSZ;
        *pMultiSZ++ = 0x00;
    }
    *pMultiSZ++ = 0x00;//add the second NULL terminator

    m_aSize[i_iColumn] = (ULONG)((reinterpret_cast<unsigned char *>(pMultiSZ) - reinterpret_cast<unsigned char *>(m_apColumnValue[i_iColumn])));
    return S_OK;
}


//See comment above GetColumnValue_Bytes
HRESULT TMetabase_XMLtable::GetColumnValue_String(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned long i_Len)
{
    if(0==wszAttr || 0==i_Len)
    {
        m_apColumnValue[i_iColumn] = &m_kZero;
        m_aSize[i_iColumn] = sizeof(WCHAR);
        return S_OK;
    }

    m_aGrowableBuffer[i_iColumn].Grow((i_Len + 1) * sizeof(WCHAR));//ulLen does NOT include the terminating NULL
    m_apColumnValue[i_iColumn] = m_aGrowableBuffer[i_iColumn].m_p;

    WCHAR *pDest = reinterpret_cast<WCHAR *>(m_aGrowableBuffer[i_iColumn].m_p);
    for(; i_Len; ++wszAttr, --i_Len, ++pDest)
    {
        if((*wszAttr & 0xD800) == 0xD800)
        {
            switch(*wszAttr)
            {
            case 0xD836:
                *pDest = *(++wszAttr) & 0xFBFF;
                --i_Len;
                break;
            case 0xD837:
                *pDest = *(++wszAttr);
                --i_Len;
                break;
            case 0xD83F:
                *pDest = *(++wszAttr) | 0x2000;
                --i_Len;
                break;
            case 0xD800:
                *pDest = *(++wszAttr) - 0xDC00;
                --i_Len;
                break;
            default:
                *pDest = *wszAttr;             break;//No special escaping was done
            }
        }
        else
        {
            *pDest = *wszAttr;//No special escaping was done
        }
    }
    *pDest++ = 0x00;//NULL terminate it
    m_aSize[i_iColumn] = static_cast<ULONG>(reinterpret_cast<char *>(pDest) - reinterpret_cast<char *>(m_apColumnValue[i_iColumn]));
    return S_OK;
}


//See comment above GetColumnValue_Bytes
HRESULT TMetabase_XMLtable::GetColumnValue_UI4(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned long i_Len)
{
    //There are NO NULLABLE UI4s in the Metabase, this should be handled by FillInColumn
    ASSERT(0!=wszAttr);
    ASSERT(0!=i_Len);

    HRESULT hr;

    ASSERT(m_aGrowableBuffer[i_iColumn].Size()>=sizeof(ULONG));
    m_apColumnValue[i_iColumn] = m_aGrowableBuffer[i_iColumn].m_p;
    m_aSize[i_iColumn] = sizeof(ULONG);

    if(i_iColumn == iMBProperty_Value)//Value column is NOT described by m_acolmetas.  A DWORD Value will either be interpreted by a number or string flags
    {
        if((wszAttr[0]>=L'0' && wszAttr[0]<=L'9') || (wszAttr[0]<=L'-'))
        {
            ULONG ulTemp;
            if(!NumberFromString(wszAttr, i_Len, ulTemp))
            {
                WCHAR wszOffendingXml[0x100];
                wcsncpy(wszOffendingXml, wszAttr, min(i_Len, 0xFF));//copy up to 0xFF characters
                wszOffendingXml[min(i_Len, 0xFF)]=0x00;

                LOG_WARNING1(IDS_COMCAT_XML_ILLEGAL_NUMERIC_VALUE, wszOffendingXml);
                return S_IGNORE_THIS_PROPERTY;
            }
		    *reinterpret_cast<ULONG *>(m_apColumnValue[i_iColumn]) = ulTemp;
        }
        else
        {
            TSmartPointerArray<WCHAR> szAttr = new WCHAR [i_Len+1];
            if(0 == szAttr.m_p)
                return E_OUTOFMEMORY;
            memcpy(szAttr, wszAttr, i_Len*sizeof(WCHAR));
            szAttr[i_Len] = 0x00;//NULL terminate the flag string
            LPWSTR wszTag = wcstok(szAttr, L" ,|\n\t\r");

            *reinterpret_cast<ULONG *>(m_apColumnValue[i_iColumn]) = 0;//flags start as zero

            m_TagMeta_IndexBySearch_Values.pTable        = const_cast<LPWSTR>(m_aPublicRowName.GetFirstPublicRowName());//setup the first part of the Search
            ULONG iRowTagMeta;

            //NOTE!!! There is a hole here.  It is possible (but illegal in the metabase) to have two Tag with the same name but different values.
            //We are looking up tags by name, so if there is a conflict we won't know about it.  We would need to look up by column index as well,
            //thus a full PK lookup.
		    while(wszTag)
		    {
                m_TagMeta_IndexBySearch_Values.pInternalName = wszTag;
                if(FAILED(hr = m_pTagMeta_IISConfigObject->GetRowIndexBySearch(0, ciTagMeta_IndexBySearch, m_aiTagMeta_IndexBySearch, 0, reinterpret_cast<void **>(&m_TagMeta_IndexBySearch_Values), &iRowTagMeta)))
                {
                    //FLAG_xx where xx is a value between 00 and 31
                    //Note: because of the way the compiler deals with '1<<x' where x>31, we need to explicitly check for x>31.
                    //1<<x for x>31 acts as a rotate which makes win32 and ia64 act differently
                    ULONG FlagBit = (ULONG)-1;
                    if(0 == wcsncmp(wszTag, L"FLAG_", 5) && wszTag[5]>=L'0' && wszTag[5]<=L'3' && wszTag[6]>=L'0' && wszTag[6]<=L'9' &&  wszTag[7]==0x00)
                        FlagBit = static_cast<unsigned long>(wcstoul(wszTag+5, 0, 10));

                    if(FlagBit<32)
        			    *reinterpret_cast<ULONG *>(m_apColumnValue[i_iColumn]) |= (1<<FlagBit);
                    else
                    {
                        WCHAR wszOffendingXml[0x100];
                        wcsncpy(wszOffendingXml, wszAttr, min(i_Len, 0xFF));//copy up to 0xFF characters
                        wszOffendingXml[min(i_Len, 0xFF)]=0x00;

                        LOG_WARNING2(IDS_COMCAT_XML_ILLEGAL_FLAG_VALUE, wszTag, wszOffendingXml);
                        return S_IGNORE_THIS_PROPERTY;
                    }
                }
                else
                {
                    ULONG * pValue;
                    ULONG   iValueColumn = iTAGMETA_Value;
                    if(FAILED(hr = m_pTagMeta_IISConfigObject->GetColumnValues(iRowTagMeta, 1, &iValueColumn, 0, reinterpret_cast<void **>(&pValue))))
                        return hr;

    				*reinterpret_cast<ULONG *>(m_apColumnValue[i_iColumn]) |= *pValue;
                }
                wszTag = wcstok(NULL, L" ,|\n\t\r");//next flag
		    }
        }
    }
    else if(m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_BOOL)
    {
        unsigned long iBoolString;
        if(i_Len)
        {
            for(iBoolString=0; m_kwszBoolStrings[iBoolString] &&
                (0 != _memicmp(m_kwszBoolStrings[iBoolString], wszAttr, i_Len*sizeof(WCHAR))); ++iBoolString);
        }
        else
        {
            for(iBoolString=0; m_kwszBoolStrings[iBoolString] &&
                (0 != StringInsensitiveCompare(m_kwszBoolStrings[iBoolString], wszAttr)); ++iBoolString);
        }

        if(0 == m_kwszBoolStrings[iBoolString])
        {
            TSmartPointerArray<WCHAR> wszTemp = new WCHAR [i_Len+1];
			if (wszTemp == 0)
				return E_OUTOFMEMORY;

            memcpy(wszTemp, wszAttr, i_Len*sizeof(WCHAR));
            wszTemp[i_Len]=0x00;//NULL terminate it

            LOG_WARNING1(IDS_COMCAT_XML_ILLEGAL_BOOL_VALUE, wszTemp);
            return S_IGNORE_THIS_PROPERTY;
        }

        *reinterpret_cast<ULONG *>(m_apColumnValue[i_iColumn]) = (iBoolString & 0x01);
    }                                                         //Enum for Type MUST be as a Tag string, UserType may be either Tag string or a number
	else if(m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_ENUM && (iMBProperty_Type==i_iColumn || !IsNumber(wszAttr, i_Len)))
	{       //If the first and last characters are numeric, then treat as a regular ui4
		ASSERT(0 != m_aTagMetaIndex[i_iColumn].m_cTagMeta);//Not all columns have tagmeta, those elements of the array are set to 0.  Assert this isn't one of those.

		for(unsigned long iTag = m_aTagMetaIndex[i_iColumn].m_iTagMeta, cTag = m_aTagMetaIndex[i_iColumn].m_cTagMeta; cTag;++iTag, --cTag)//m_pTagMeta was queried for ALL columns, m_aiTagMeta[iColumn] indicates which row to start with
		{
			ASSERT(*m_aTagMetaRow[iTag].pColumnIndex == i_iColumn);

            //string compare the tag to the PublicName of the Tag in the meta.
            if(i_Len)
            {
			    if(0 == _memicmp(m_aTagMetaRow[iTag].pPublicName, wszAttr, i_Len*sizeof(WCHAR)) && i_Len==wcslen(m_aTagMetaRow[iTag].pPublicName))
			    {
				    *reinterpret_cast<ULONG *>(m_apColumnValue[i_iColumn]) = *m_aTagMetaRow[iTag].pValue;
				    return S_OK;
			    }
            }
            else
            {
			    if(0 == StringInsensitiveCompare(m_aTagMetaRow[iTag].pPublicName, wszAttr))
			    {
				    *reinterpret_cast<ULONG *>(m_apColumnValue[i_iColumn]) = *m_aTagMetaRow[iTag].pValue;
				    return S_OK;
			    }
            }
		}
        {
            TSmartPointerArray<WCHAR> wszTemp = new WCHAR [i_Len+1];
			if (wszTemp == 0)
				return E_OUTOFMEMORY;

            memcpy(wszTemp, wszAttr, i_Len*sizeof(WCHAR));
            wszTemp[i_Len]=0x00;//NULL terminate it

            LOG_WARNING2(IDS_COMCAT_XML_ILLEGAL_ENUM_VALUE, m_awszColumnName[i_iColumn], wszTemp);
            return S_IGNORE_THIS_PROPERTY;
        }
        return E_ST_VALUEINVALID;
	}
    else if(m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_FLAG && !IsNumber(wszAttr, i_Len))//If the first character is a numeric, then treat as a regular ui4
    {
		ASSERT(0 != m_aTagMetaIndex[i_iColumn].m_cTagMeta);//Not all columns have tagmeta, those elements of the array are set to 0.  Assert this isn't one of those.

        TSmartPointerArray<WCHAR> szAttr = new WCHAR [i_Len+1];
        if(0 == szAttr.m_p)
            return E_OUTOFMEMORY;
        memcpy(szAttr, wszAttr, i_Len*sizeof(WCHAR));
        szAttr[i_Len]=0x00;//NULL terminate it
        LPWSTR wszTag = wcstok(szAttr, L" ,|\n\t\r");

        *reinterpret_cast<ULONG *>(m_apColumnValue[i_iColumn]) = 0;//flags start as zero
        unsigned long iTag = m_aTagMetaIndex[i_iColumn].m_iTagMeta;

		while(wszTag && iTag<(m_aTagMetaIndex[i_iColumn].m_iTagMeta + m_aTagMetaIndex[i_iColumn].m_cTagMeta))//m_pTagMeta was queried for ALL columns, m_aiTagMeta[iColumn] indicates which row to start with
		{
			ASSERT(*m_aTagMetaRow[iTag].pColumnIndex == i_iColumn);

            //string compare the tag to the PublicName of the Tag in the meta.
			if(0 == StringInsensitiveCompare(m_aTagMetaRow[iTag].pPublicName, wszTag))
			{
				*reinterpret_cast<ULONG *>(m_apColumnValue[i_iColumn]) |= *m_aTagMetaRow[iTag].pValue;
                wszTag = wcstok(NULL, L" ,|\n\t\r");//next flag
                iTag = m_aTagMetaIndex[i_iColumn].m_iTagMeta;//reset the loop
			}
            else//if they're not equal then move on to the next TagMeta
                ++iTag;
		}
        if(wszTag)
        {
            WCHAR wszOffendingXml[0x100];
            wcsncpy(wszOffendingXml, wszAttr, min(i_Len, 0xFF));//copy up to 0xFF characters
            wszOffendingXml[min(i_Len, 0xFF)]=0x00;

            LOG_WARNING2(IDS_COMCAT_XML_ILLEGAL_FLAG_VALUE, wszTag, wszOffendingXml);
            return S_IGNORE_THIS_PROPERTY;
        }
    }
	else
    {
        ULONG ulTemp;
        if(!NumberFromString(wszAttr, i_Len, ulTemp))
        {
            WCHAR wszOffendingXml[0x100];
            wcsncpy(wszOffendingXml, wszAttr, min(i_Len, 0xFF));//copy up to 0xFF characters
            wszOffendingXml[min(i_Len, 0xFF)]=0x00;

            LOG_WARNING1(IDS_COMCAT_XML_ILLEGAL_NUMERIC_VALUE, wszOffendingXml);
            return S_IGNORE_THIS_PROPERTY;
        }
		*reinterpret_cast<ULONG *>(m_apColumnValue[i_iColumn]) = ulTemp;
    }
    return S_OK;
}

bool TMetabase_XMLtable::IsNumber(LPCWSTR i_awch, ULONG i_Len) const
{
    if((*i_awch>=L'0' && *i_awch<=L'9') || *i_awch==L'-')
    {   //if the string is L"-" then it is NOT a number.
        if(1==i_Len && *i_awch==L'-')
            return false;

        //if the first char is a negative sign or a number, then scan the rest
        while(--i_Len)
        {
            ++i_awch;
            if(*i_awch<L'0' || *i_awch>L'9')//if not a numeric then we're done, NOT a number
                return false;
        }
        return true;//we made it through all the chars and they were all numerics, so it IS a number
    }
    return false;
}

//This is a wrapper for InternalSimpleInitialize (thus the name), it just gets the meta information THEN calls InternalSimpleInitialize.
HRESULT TMetabase_XMLtable::InternalComplicatedInitialize()
{
    HRESULT hr = m_LocationMapping.SetSize(0x80);//Lets start with 128 locations.  This size will grow by %50 each time we reach an overflow
	if (FAILED (hr))
	{
		return hr;
	}

    hr = m_LocationMapping.SetSize(0);//The Array is still pre allocated at size 0x80; but the current number of elements is set to 0.
	if (FAILED (hr))
	{
		return hr;
	}

    //Preallocate the growable buffers
    m_aGrowableBuffer[iMBProperty_Name      ].Grow(256);
    m_aGrowableBuffer[iMBProperty_Value     ].Grow(256);
    m_aGrowableBuffer[iMBProperty_Location  ].Grow(256);

    //If the user passed in the Bin filename as part of the query, then we already have this filled in
    if(0 == m_saSchemaBinFileName.m_p)
    {   //if it wasn't passed in as part of the query then get it from the IMetabaseSchemaCompiler
        m_spMetabaseSchemaCompiler = m_pISTDisp;
        if(0 == m_spMetabaseSchemaCompiler.p)
        {
            ASSERT(false && L"Dispenser without a MetabaseSchemaCompiler shouldn't be calling Intercept on the Metabase interceptor");
            return E_FAIL;
        }
        ULONG cchSchemaBinFileName;
        if(FAILED(hr = m_spMetabaseSchemaCompiler->GetBinFileName(0, &cchSchemaBinFileName)))
            return hr;

        m_saSchemaBinFileName = new WCHAR [cchSchemaBinFileName];
        if(0 == m_saSchemaBinFileName.m_p)
            return E_OUTOFMEMORY;

        if(FAILED(hr = m_spMetabaseSchemaCompiler->GetBinFileName(m_saSchemaBinFileName, &cchSchemaBinFileName)))
            return hr;
    }


    ULONG   iColumn;
    for(iColumn=0;iColumn<m_kColumns;++iColumn)//The above three columns are sized larger, the rest are set to sizeof(ULONG) to start with
        m_aGrowableBuffer[iColumn].Grow(sizeof(ULONG));

    if(FAILED(hr = ObtainPertinentTableMetaInfo()))return hr;

    m_fCache             |= *m_TableMetaRow.pMetaFlags;

    if(FAILED(hr = GetMetaTable(wszDATABASE_METABASE, wszTABLE_MBProperty, m_pColumnMeta)))return hr;

    tCOLUMNMETARow          ColumnMetaRow;

    for (iColumn = 0;; iColumn++)
    {
        if(E_ST_NOMOREROWS == (hr = m_pColumnMeta->GetColumnValues(iColumn, cCOLUMNMETA_NumberOfColumns, 0, 0, reinterpret_cast<void **>(&ColumnMetaRow))))// Next row:
        {
            ASSERT(m_kColumns == iColumn);
            if(m_kColumns != iColumn)return E_SDTXML_UNEXPECTED; // Assert expected column count.
            break;
        }
        else
        {
            if(FAILED(hr))
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "GetColumnValues FAILED with something other than E_ST_NOMOREROWS" ));
                return hr;
            }
        }

        m_acolmetas[iColumn].dbType = *ColumnMetaRow.pType;
        m_acolmetas[iColumn].cbSize = *ColumnMetaRow.pSize;
        m_acolmetas[iColumn].fMeta  = *ColumnMetaRow.pMetaFlags;

        m_awszColumnName[iColumn]   =  ColumnMetaRow.pPublicColumnName;
        m_acchColumnName[iColumn]   =  (ULONG)wcslen(ColumnMetaRow.pPublicName);

        ASSERT(m_awszColumnName[iColumn]);//CatUtil should have already enforced this
        ASSERT(m_acchColumnName[iColumn]>0);
    }

    //After we have the ColumnMeta info, get the TagMeta
    if(FAILED(hr = ObtainPertinentTagMetaInfo()))return hr;
    if(FAILED(hr = m_aPublicRowName.Init(&m_aTagMetaRow[m_aTagMetaIndex[iMBProperty_Group].m_iTagMeta], m_aTagMetaIndex[iMBProperty_Group].m_cTagMeta)))return hr;

    //We need to make sure that NameValue tables list the Name column before the Type column, and the Type column before the Value column.
    ASSERT(iMBProperty_Name        < iMBProperty_Type); if(iMBProperty_Name      >= iMBProperty_Type) return E_FAIL;
    ASSERT(iMBProperty_Type        < iMBProperty_Value);if(iMBProperty_Type      >= iMBProperty_Value)return E_FAIL;
    ASSERT(iMBProperty_Attributes  < iMBProperty_Value);if(iMBProperty_Attributes>= iMBProperty_Value)return E_FAIL;

    //Keep around an interface pointer to the NameValueMeta table

	STQueryCell Query[2];
	Query[0].pData		= (LPVOID)m_saSchemaBinFileName.m_p;
    Query[0].eOperator	= eST_OP_EQUAL;
    Query[0].iCell		= iST_CELL_FILE;
    Query[0].dbType	    = DBTYPE_WSTR;
    Query[0].cbSize	    = 0;

	Query[1].pData		= (void*)L"ByName";
    Query[1].eOperator	= eST_OP_EQUAL;
    Query[1].iCell		= iST_CELL_INDEXHINT;
    Query[1].dbType	    = DBTYPE_WSTR;
    Query[1].cbSize	    = 0;

    return Dispenser()->GetTable(wszDATABASE_META, wszTABLE_COLUMNMETA, Query, &m_kTwo, eST_QUERYFORMAT_CELLS, 0, reinterpret_cast<void **>(&m_pColumnMetaAll));
}


HRESULT TMetabase_XMLtable::LoadDocumentFromURL(IXMLDOMDocument *pXMLDoc)
{
    HRESULT hr;

    ASSERT(pXMLDoc);

    VERIFY(SUCCEEDED(hr = pXMLDoc->put_async(kvboolFalse)));//We want the parse to be synchronous
    if(FAILED(hr))
        return hr;

    if(FAILED(hr = pXMLDoc->put_resolveExternals(kvboolTrue)))return hr;//we need all of the external references resolved

    VARIANT_BOOL    bSuccess;
    CComVariant     xml(m_wszURLPath);
    if(FAILED(hr = pXMLDoc->load(xml,&bSuccess)))return hr;

    return (bSuccess == kvboolTrue) ? S_OK : E_FAIL;
}


int TMetabase_XMLtable::Memicmp(LPCWSTR i_p0, LPCWSTR i_p1, ULONG i_cby) const
{
    ASSERT(0 == (i_cby & 1) && "Make sure you're passing in Count Of Bytes and not Count of WCHARs");
    i_cby /= 2;

    ULONG i;
    for(i=0; i<i_cby; ++i, ++i_p0, ++i_p1)
    {
        if(ToLower(*i_p0) != ToLower(*i_p1))
            return 1;//not equal
    }
    return 0;//they're equal
}


HRESULT TMetabase_XMLtable::ObtainPertinentTableMetaInfo()
{
    HRESULT hr;

	STQueryCell Query[2];
	Query[0].pData		= (LPVOID)m_saSchemaBinFileName.m_p;
    Query[0].eOperator	= eST_OP_EQUAL;
    Query[0].iCell		= iST_CELL_FILE;
    Query[0].dbType	    = DBTYPE_WSTR;
    Query[0].cbSize	    = 0;

	Query[1].pData		= (void*) wszTABLE_MBProperty;
    Query[1].eOperator	= eST_OP_EQUAL;
    Query[1].iCell		= iTABLEMETA_InternalName;
    Query[1].dbType	    = DBTYPE_WSTR;
    Query[1].cbSize	    = 0;

	if(FAILED(hr = Dispenser()->GetTable(wszDATABASE_META, wszTABLE_TABLEMETA, Query, &m_kTwo, eST_QUERYFORMAT_CELLS, 0, reinterpret_cast<void**>(&m_pTableMeta))))
		return hr;

	if(FAILED(hr = m_pTableMeta->GetColumnValues(0, cTABLEMETA_NumberOfColumns, NULL, NULL, reinterpret_cast<void**>(&m_TableMetaRow))))return hr;

    return S_OK;
}

HRESULT TMetabase_XMLtable::ObtainPertinentTagMetaInfo()
{
    HRESULT hr;

	//Now that we have the ColumnMeta setup, setup the TagMeta
	STQueryCell Query[3];
	Query[1].pData		= (LPVOID)m_saSchemaBinFileName.m_p;
    Query[1].eOperator	= eST_OP_EQUAL;
    Query[1].iCell		= iST_CELL_FILE;
    Query[1].dbType	    = DBTYPE_WSTR;
    Query[1].cbSize	    = 0;

	Query[2].pData		= (void*) wszTABLE_MBProperty;
    Query[2].eOperator	=eST_OP_EQUAL;
    Query[2].iCell		=iTAGMETA_Table;
    Query[2].dbType	=DBTYPE_WSTR;
    Query[2].cbSize	=0;

	//Optain the TagMeta table
	if(FAILED(hr = Dispenser()->GetTable (wszDATABASE_META, wszTABLE_TAGMETA, &Query[1], &m_kTwo, eST_QUERYFORMAT_CELLS, 0, (void**) &m_pTagMeta)))
		return hr;

    ULONG cRows;
    if(FAILED(hr = m_pTagMeta->GetTableMeta(0,0,&cRows,0)))return hr;
    m_aTagMetaRow = new tTAGMETARow[cRows];
    if(0 == m_aTagMetaRow.m_p)return E_OUTOFMEMORY;

// Build tag column indexes:
	ULONG iColumn, iRow;
	for(iRow = 0, iColumn = ~0ul;iRow<cRows; ++iRow)
	{
		if(FAILED(hr = m_pTagMeta->GetColumnValues (iRow, cTAGMETA_NumberOfColumns, NULL, NULL, reinterpret_cast<void **>(&m_aTagMetaRow[iRow]))))
            return hr;

		if(iColumn != *m_aTagMetaRow[iRow].pColumnIndex)
		{
			iColumn = *m_aTagMetaRow[iRow].pColumnIndex;
			m_aTagMetaIndex[iColumn].m_iTagMeta = iRow;
		}
        ++m_aTagMetaIndex[iColumn].m_cTagMeta;
	}


	Query[2].pData		= (void*) wszTABLE_IIsConfigObject;
	Query[0].pData		= (void*)L"ByTableAndTagNameOnly";
    Query[0].eOperator	=eST_OP_EQUAL;
    Query[0].iCell		=iST_CELL_INDEXHINT;
    Query[0].dbType	    =DBTYPE_WSTR;
    Query[0].cbSize	    =0;

    //Now get the TagMeta for the ISSConfigObject table.  This is where the global tags (for the metabase) are kept.
	if(FAILED(hr = Dispenser()->GetTable (wszDATABASE_META, wszTABLE_TAGMETA, Query, &m_kThree, eST_QUERYFORMAT_CELLS, 0, (void**) &m_pTagMeta_IISConfigObject)))
		return hr;

    return S_OK;
}


HRESULT TMetabase_XMLtable::ParseXMLFile(IXMLDOMDocument *pXMLDoc, bool bValidating)//defaults to validating against the DTD or XML schema
{
    HRESULT hr;

    ASSERT(pXMLDoc);

    if(FAILED(hr = pXMLDoc->put_preserveWhiteSpace(kvboolFalse)))
        return hr;
    if(FAILED(hr = pXMLDoc->put_validateOnParse(bValidating ? kvboolTrue : kvboolFalse)))//Tell parser whether to validate according to an XML schema or DTD
        return hr;

    if(FAILED(LoadDocumentFromURL(pXMLDoc)))
    {   //If the load failed then let's spit out as much information as possible about what went wrong
        CComPtr<IXMLDOMParseError> pXMLParseError;
        long lErrorCode, lFilePosition, lLineNumber, lLinePosition;
        TComBSTR bstrReasonString, bstrSourceString, bstrURLString;

        if(FAILED(hr = pXMLDoc->get_parseError(&pXMLParseError)))       return hr;
        if(FAILED(hr = pXMLParseError->get_errorCode(&lErrorCode)))     return hr;
        if(FAILED(hr = pXMLParseError->get_filepos(&lFilePosition)))    return hr;
        if(FAILED(hr = pXMLParseError->get_line(&lLineNumber)))         return hr;
        if(FAILED(hr = pXMLParseError->get_linepos(&lLinePosition)))    return hr;
        if(FAILED(hr = pXMLParseError->get_reason(&bstrReasonString)))  return hr;
        if(FAILED(hr = pXMLParseError->get_srcText(&bstrSourceString))) return hr;
        if(FAILED(hr = pXMLParseError->get_url(&bstrURLString)))        return hr;

		if((HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION) != lErrorCode) &&
		   (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != lErrorCode)    &&
		   (HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) != lErrorCode)
		  )
		{
			LOG_ERROR_LOS(m_fLOS, Interceptor, (&m_spISTError.p, m_pISTDisp, lErrorCode, ID_CAT_CAT, IDS_COMCAT_XML_PARSE_ERROR,
							L" ",
							(bstrReasonString.m_str ? bstrReasonString.m_str : L""),
							(bstrSourceString.m_str ? bstrSourceString.m_str : L""),
							eSERVERWIRINGMETA_Core_MetabaseInterceptor,
							wszTABLE_MBProperty,
							eDETAILEDERRORS_Populate,
							lLineNumber,
							lLinePosition,
							(bstrURLString.m_str ? bstrURLString.m_str : L"")));
		}

        return  E_ST_INVALIDTABLE;
    }
    //Not only does the XML file have to be Valid and Well formed, but its schema must match the one this C++ file was written to.
    return  S_OK;
}


HRESULT TMetabase_XMLtable::SetComment(LPCWSTR i_pComment, ULONG i_Len, bool i_bAppend)
{
    if(0 == m_saCollectionComment.m_p)
    {
        m_cchCommentBufferSize = ((i_Len+1) + 1023) & -1024;//+1 for the NULL, then round up to the nearest 1024 wchars
        m_saCollectionComment = new WCHAR [m_cchCommentBufferSize];
        if(0 == m_saCollectionComment.m_p)
            return E_OUTOFMEMORY;
        m_saCollectionComment[0] = 0x00;//the code below relys on this being initialized to L""
    }

    ULONG cchCurrentCommentSize=0;
    if(i_bAppend)
        cchCurrentCommentSize = (ULONG) wcslen(m_saCollectionComment);

    if(cchCurrentCommentSize + 1 + i_Len > m_cchCommentBufferSize)
    {
        m_cchCommentBufferSize = ((cchCurrentCommentSize + 1 + i_Len) + 1023) & -1024;
        m_saCollectionComment.m_p = reinterpret_cast<WCHAR *>(CoTaskMemRealloc(m_saCollectionComment.m_p, m_cchCommentBufferSize*sizeof(WCHAR)));
        if(0 == m_saCollectionComment.m_p)
            return E_OUTOFMEMORY;
    }
    memcpy(m_saCollectionComment + cchCurrentCommentSize, i_pComment, i_Len * sizeof(WCHAR));
    cchCurrentCommentSize += i_Len;
    m_saCollectionComment[cchCurrentCommentSize] = 0x00;//NULL terminate it

    return S_OK;
}


// ISimpleTableRead2 (ISimpleTableWrite2 : ISimpleTableRead2)
STDMETHODIMP TMetabase_XMLtable::GetRowIndexByIdentity(ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
{
    HRESULT hr;
    if(FAILED(hr = m_SimpleTableWrite2_Memory->GetRowIndexByIdentity(i_acbSizes, i_apvValues, o_piRow)))return hr;
    if(m_bUseIndexMapping)
    {   //If we're mapping the row indexes, then find out which row index corresponds to the one just returned.
        for(ULONG iMappedRow=0;iMappedRow<m_cRows;++iMappedRow)//If this becomes a perf bottleneck we can build another index that maps
        {                                                      //these indexes in the other direction; but for now we'll do a linear search.
            if(*o_piRow == m_aRowIndex[iMappedRow])
            {
                *o_piRow = iMappedRow;
                return S_OK;
            }
        }
        ASSERT(false && "This shouldn't happen.  All fast cache rows should map to an m_aRowIndex, the only exception is duplicate rows in which the first one should be found.");
        return E_ST_NOMOREROWS;
    }
    return S_OK;
}

// ------------------------------------
// ISimpleTableInterceptor
// ------------------------------------
STDMETHODIMP TMetabase_XMLtable::Intercept(    LPCWSTR i_wszDatabase,  LPCWSTR i_wszTable, ULONG i_TableID, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD i_eQueryFormat,
                                    DWORD i_fLOS,           IAdvancedTableDispenser* i_pISTDisp,    LPCWSTR /*i_wszLocator unused*/,
                                    LPVOID i_pSimpleTable,  LPVOID* o_ppvSimpleTable)
{
    try
    {
        HRESULT hr;

        SetErrorInfo(0, 0);

        //If we've already been called to Intercept, then fail
        if(0 != m_IsIntercepted)return E_UNEXPECTED;

        //Some basic parameter validation:
        if(i_pSimpleTable)return E_INVALIDARG;//We're at the bottom of the Table hierarchy.  A table under us is Chewbacca.  This is NOT a logic table.
        if(0 == i_pISTDisp)return E_INVALIDARG;
        if(0 == o_ppvSimpleTable)return E_INVALIDARG;

        ASSERT(0 == *o_ppvSimpleTable && "This should be NULL.  Possible memory leak or just an uninitialized variable.");
        *o_ppvSimpleTable = 0;

        if(eST_QUERYFORMAT_CELLS != i_eQueryFormat)return E_INVALIDARG;//Verify query type.
	    // For the CookDown process we have a logic table that sits above this during PopulateCache time.
	    // Hence we should support fST_LOS_READWRITE
        if((fST_LOS_MARSHALLABLE | fST_LOS_UNPOPULATED | fST_LOS_READWRITE) & i_fLOS)return E_ST_LOSNOTSUPPORTED;//check table flags
        if(0 != _wcsicmp(i_wszDatabase, wszDATABASE_METABASE))return E_ST_INVALIDTABLE;
        if(i_TableID!=TABLEID_MBProperty && (0==i_wszTable || (0 != _wcsicmp(i_wszTable, wszTABLE_MBProperty))))return E_ST_INVALIDTABLE;

        m_fLOS = i_fLOS;//Keep this around.  We use it to determine whether or not to log errors

        //Create this singleton for future use
	    m_pISTDisp = i_pISTDisp;

        STQueryCell *   pQueryCell  = (STQueryCell*) i_QueryData;    // Query cell array from caller.
        int             nQueryCount = (i_QueryMeta && i_QueryData) ? *reinterpret_cast<ULONG *>(i_QueryMeta) : 0;

        while(nQueryCount--)//Get the only query cell we care about, and save the information.
        {
            if(pQueryCell[nQueryCount].iCell & iST_CELL_SPECIAL)
            {
                if(pQueryCell[nQueryCount].pData     != 0                  &&
                   pQueryCell[nQueryCount].eOperator == eST_OP_EQUAL       &&
                   pQueryCell[nQueryCount].iCell     == iST_CELL_FILE      &&
                   pQueryCell[nQueryCount].dbType    == DBTYPE_WSTR        /*&&
                   pQueryCell[nQueryCount].cbSize    == (wcslen(reinterpret_cast<WCHAR *>(pQueryCell[nQueryCount].pData))+1)*sizeof(WCHAR)*/)
                {
                    if(FAILED(hr = GetURLFromString(reinterpret_cast<WCHAR *>(pQueryCell[nQueryCount].pData))))
                        return hr;
                }
                else if(pQueryCell[nQueryCount].pData!= 0                   &&
                   pQueryCell[nQueryCount].eOperator == eST_OP_EQUAL        &&
                   pQueryCell[nQueryCount].iCell     == iST_CELL_SCHEMAFILE &&
                   pQueryCell[nQueryCount].dbType    == DBTYPE_WSTR        /*&&
                   pQueryCell[nQueryCount].cbSize    == (wcslen(reinterpret_cast<WCHAR *>(pQueryCell[nQueryCount].pData))+1)*sizeof(WCHAR)*/)
                {
                    m_saSchemaBinFileName = new WCHAR [wcslen(reinterpret_cast<WCHAR *>(pQueryCell[nQueryCount].pData))+1];
                    if(0 == m_saSchemaBinFileName.m_p)
                        return E_OUTOFMEMORY;
                    wcscpy(m_saSchemaBinFileName, reinterpret_cast<WCHAR *>(pQueryCell[nQueryCount].pData));
                }
            }
            else if(pQueryCell[nQueryCount].iCell == iMBProperty_Location)
            {//we only support querying by Location
                m_saQueriedLocation = new WCHAR [wcslen(reinterpret_cast<WCHAR *>(pQueryCell[nQueryCount].pData))+1];
                if(0 == m_saQueriedLocation.m_p)
                    return E_OUTOFMEMORY;
                wcscpy(m_saQueriedLocation, reinterpret_cast<WCHAR *>(pQueryCell[nQueryCount].pData));
            }
            else
                return E_ST_INVALIDQUERY;
        }
        if(0x00 == m_wszURLPath[0])//The user must supply a URLPath (which must be a filename for writeable tables).
            return E_SDTXML_FILE_NOT_SPECIFIED;

        //This has nothing to do with InternalSimpleInitialize.  This just gets the meta and saves some of it in a more accessible form.
        //This calls GetTable for the meta.  It should probably call the IST (that we get from GetMemoryTable).
        if(FAILED(hr = InternalComplicatedInitialize()))//This can throw an HRESULT
            return hr;

	// Determine minimum cache size:
		STQueryCell					qcellMinCache;
		ULONG						cbminCache = 1024;
		ULONG						cCells = 1;
		WIN32_FILE_ATTRIBUTE_DATA	filedata;

		qcellMinCache.iCell		= iST_CELL_cbminCACHE;
		qcellMinCache.eOperator	= eST_OP_EQUAL;
		qcellMinCache.dbType	= DBTYPE_UI4;
		qcellMinCache.cbSize	= sizeof (ULONG);


		if (0 != GetFileAttributesEx (m_wszURLPath, GetFileExInfoStandard, &filedata))
		{
			if (filedata.nFileSizeHigh != 0) return E_NOTIMPL; // TODO: verify low size isn't too big either!
			cbminCache = filedata.nFileSizeLow * 2;
		}
		qcellMinCache.pData = &cbminCache;

 																		//Our memory table needs to be Read/Write even if the XML table is Read-Only
        if(FAILED(hr = i_pISTDisp->GetMemoryTable(wszDATABASE_METABASE, wszTABLE_MBProperty, TABLEID_MBProperty, &qcellMinCache, &cCells, i_eQueryFormat, i_fLOS,
                        reinterpret_cast<ISimpleTableWrite2 **>(&m_SimpleTableWrite2_Memory))))return hr;

        m_SimpleTableController_Memory = m_SimpleTableWrite2_Memory;
        ASSERT(0 != m_SimpleTableController_Memory.p);

        *o_ppvSimpleTable = (ISimpleTableWrite2 *)(this);
        AddRef ();
        InterlockedIncrement(&m_IsIntercepted);//We can only be called to Intercept once.
    }
    catch(HRESULT e)
    {
        return e;
    }
	return S_OK;
}


STDMETHODIMP TMetabase_XMLtable::PopulateCache()
{
    try
    {
        HRESULT hr;

	    if (FAILED(hr = PrePopulateCache (0))) return hr;

        if(-1 == GetFileAttributes(m_wszURLPath))//if GetFileAttributes fails then the file does not exist
            return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

        hr = m_XmlParsedFile.Parse(*this, m_wszURLPath);
        if(S_OK != hr && E_SDTXML_DONE != hr)
        {
            CComPtr<IXMLDOMDocument> pXMLDoc;
            if(FAILED(hr = CoCreateInstance(_CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, _IID_IXMLDOMDocument, (void**)&pXMLDoc)))return hr;//Instantiate the XMLParser
            //We use the DOM to parse the ReadWrite table.  This gives better validation and error reporting.
            if(FAILED(hr = ParseXMLFile(pXMLDoc, m_bValidating)))return hr;                                                                      //Validate the XML file

            //LOG_ERROR1(IDS_COMCAT_XML_DOM_PARSE_SUCCEEDED_WHEN_NODE_FACTORY_PARSE_FAILED, hrNodeFactory, m_wszURLPath);
            return E_SDTXML_XML_FAILED_TO_PARSE;
        }

        //clean up (this is also done in the dtor so don't hassle cleaning up if an error occurs and we return prematurely.)
        for(unsigned long iColumn=0; iColumn<m_kColumns; ++iColumn)
            m_aGrowableBuffer[iColumn].Delete();

        //This usually goes at the end; but in our case we need to GetColumnValues, so PostPopulateCache before the sorting
	    if (FAILED(hr = PostPopulateCache ())) return hr;

        //Currently this is alwasy true.  But once we add smarts to the property sorting this might be able to be false (currently only Location sorting is acknowledged using this flag).
#ifdef UNSORTED_METABASE
        if(false)
#else
        if(m_bUseIndexMapping)
#endif
        {    //The cache has been populated but now we need to remap the row indexes.
            m_SimpleTableWrite2_Memory->GetTableMeta(0, 0, &m_cRows, 0);
            m_aRowIndex = new ULONG [m_cRows];
            if(0 == m_aRowIndex.m_p)return E_OUTOFMEMORY;

            //IMPORTANT!!!  CreateNode/case 3 defaults well-known IDs when given a Name AND defaults well-known Names when given an ID.
            //Because of this, we only have to consider duplicate IDs when the propertied are both Custom AND user-defined (not in
            //the IisConfigObject table).
            TSmartPointerArray<ULONG> spCustomIDs;
            ULONG                     cSizeOf_spCustomIDs=0;
            ULONG                     cCustomIDs=0;

            ULONG iRow=0;
            CCfgArray<TProperty>          PropertyMapping;
            hr = PropertyMapping.SetSize(m_cMaxProertiesWithinALocation);//pre allocate enough space so we never have to realloc
			if (FAILED (hr))
				return hr;

            for(ULONG iLocationMapping=0; iLocationMapping<m_LocationMapping.Count(); ++iLocationMapping)
            {
                hr = PropertyMapping.SetSize(0);//The Array is still pre allocated at size m_cMaxProertiesWithinALocation; but the current number of elements is set to 0.
				if (FAILED (hr))
					return hr;

                if(iLocationMapping>0 && m_LocationMapping[iLocationMapping]==m_LocationMapping[iLocationMapping-1])
                {   //if the previous location matches the current, then ignore all the properties within this location
                    LOG_WARNING1(IDS_METABASE_DUPLICATE_LOCATION, m_LocationMapping[iLocationMapping].m_wszLocation);
                    m_cRows -= m_LocationMapping[iLocationMapping].m_cRows;
                    continue;
                }

                tMBPropertyRow mbpropertyRow;
                ULONG          acbSizes[cMBProperty_NumberOfColumns];

                //Get the 0th property outside the loop for efficiency
                if(FAILED(hr = m_SimpleTableWrite2_Memory->GetColumnValues(m_LocationMapping[iLocationMapping].m_iFastCache,
                                            cMBProperty_NumberOfColumns, 0, acbSizes, reinterpret_cast<void **>(&mbpropertyRow))))
                    return hr;

                hr = PropertyMapping.Append(TProperty(mbpropertyRow.pName, m_LocationMapping[iLocationMapping].m_iFastCache));
				if (FAILED (hr))
				{
					return hr;
				}

                if(cSizeOf_spCustomIDs<m_LocationMapping[iLocationMapping].m_cRows)//if the buffer isn't big enough
                {                                                                      //round up to nearest 256 bytes
                    cSizeOf_spCustomIDs = (m_LocationMapping[iLocationMapping].m_cRows +63 ) & -64;
                    spCustomIDs.m_p = reinterpret_cast<ULONG *>(CoTaskMemRealloc(spCustomIDs.m_p, sizeof(ULONG)*cSizeOf_spCustomIDs));
                    if(0 == spCustomIDs.m_p)
                        return E_OUTOFMEMORY;
                }
                cCustomIDs = 0;//start with 0 Custom properties
                if(*mbpropertyRow.pGroup == m_kMBProperty_Custom)//We only need to consider duplicate IDs of Custom properties
                    spCustomIDs[cCustomIDs++] = *mbpropertyRow.pID;//build an array of the Custom IDs

                ULONG iEndOfList=1;
                ULONG iLocationRow=1;
                for(ULONG iFastCache=1+m_LocationMapping[iLocationMapping].m_iFastCache; iLocationRow<m_LocationMapping[iLocationMapping].m_cRows; ++iFastCache, ++iLocationRow)
                {
                    if(FAILED(hr = m_SimpleTableWrite2_Memory->GetColumnValues(iFastCache, cMBProperty_NumberOfColumns, 0,
                                                acbSizes, reinterpret_cast<void **>(&mbpropertyRow))))
                        return hr;

                    if(*mbpropertyRow.pGroup == m_kMBProperty_Custom)//We only need to consider duplicate IDs of Custom properties
                    {                                                //This is because of the implementation of ::CreateNode/case 3
                        ULONG iID=0;
                        for(;iID<cCustomIDs;++iID)//linear scan of the previously seen Custom IDs
                        {
                            if(*mbpropertyRow.pID == spCustomIDs[iID])
                            {//Duplicate ID
                                break;
                            }
                        }
                        if(iID<cCustomIDs)
                        {   //if we didn't make it through the list, then we have a duplicate.  So log a warning.
                            WCHAR wszID[12];
                            wsprintf(wszID, L"%d", *mbpropertyRow.pID);
                            LOG_WARNING2( IDS_METABASE_DUPLICATE_PROPERTY_ID
                                        , wszID
                                        , m_LocationMapping[iLocationMapping].m_wszLocation);
                            --m_cRows;//skipping the row so subtract one from the cRows.
                            continue;//duplicate ID, skip this property
                        }
                        spCustomIDs[cCustomIDs++] = *mbpropertyRow.pID;//build an array of the Custom IDs
                    }

                    TProperty propertyTemp(mbpropertyRow.pName, iFastCache);
                    if(propertyTemp > PropertyMapping[iEndOfList-1])
                    {   //either put it at the end of the list
                        if(FAILED (hr = PropertyMapping.Append(propertyTemp)))
                            return hr;
                        ++iEndOfList;
                    }
                    else
                    {   //or do a binary search to determine where it goes
                        unsigned int iInsertionPoint = PropertyMapping.BinarySearch(propertyTemp);

                        //The implementation of the binarySearch results in iInsertionPoint being placed after
                        //a property matching the one being inserted.
                        if(iInsertionPoint > 0 && propertyTemp==PropertyMapping[iInsertionPoint-1])
                        {
                            LOG_WARNING2( IDS_METABASE_DUPLICATE_PROPERTY
                                        , propertyTemp.m_wszPropertyName
                                        , m_LocationMapping[iLocationMapping].m_wszLocation);
                            --m_cRows;
                            continue;
                        }
                        if(FAILED(hr = PropertyMapping.InsertAt(propertyTemp, iInsertionPoint)))
                            return hr;
                        ++iEndOfList;
                    }
                }

                //Now walk the sorted property list to remap the row indexes
                for(ULONG i=0; i<PropertyMapping.Count(); ++i)
                {
                    if(-1 != PropertyMapping[i].m_iFastCache)
                        m_aRowIndex[iRow++] = PropertyMapping[i].m_iFastCache;
                }
            }
            ASSERT(iRow == m_cRows);//When we're done mapping the rows we should have completely filled m_aRowIndex.
        }
        m_LocationMapping.Reset();

    }
    catch(HRESULT e)
    {
        return e;
    }

    if(m_cEventsReported > 0)
    {
        TCHAR szTemp[20];
        wsprintf(szTemp, L"(%d)", m_cEventsReported);

        LOG_ERROR_LOS(fST_LOS_DETAILED_ERROR_TABLE | fST_LOS_NO_LOGGING //These LOSes say to lop the error to the detailed error table; but NOT the normal logging
                        , Interceptor                                   //mechanism (which is the event log AND the text log in the case of the IIS product)
                        ,(&m_spISTError.p
                        , m_pISTDisp
                        , E_SDTXML_LOGICAL_ERROR_IN_XML
                        , ID_CAT_CAT
                        , MD_ERROR_PROCESSING_TEXT_EDITS
                        , L""
                        , eSERVERWIRINGMETA_Core_MetabaseInterceptor
                        , wszTABLE_MBProperty
                        , eDETAILEDERRORS_Populate
                        , (ULONG) -1
                        , (ULONG) -1
                        , m_wszURLPath
                        , eDETAILEDERRORS_WARNING
                        , 0, 0, m_MajorVersion));
    }

    return S_OK;
}

ULONG TMetabase_XMLtable::MetabaseTypeFromColumnMetaType(tCOLUMNMETARow &columnmetaRow) const
{
    switch(*columnmetaRow.pType)
    {
    case eCOLUMNMETA_UI4:
        return eMBProperty_DWORD;
    case eCOLUMNMETA_BYTES:
        return eMBProperty_BINARY;
    case eCOLUMNMETA_WSTR:
        if(*columnmetaRow.pMetaFlags & fCOLUMNMETA_EXPANDSTRING)
            return eMBProperty_EXPANDSZ;
        else if(*columnmetaRow.pMetaFlags & fCOLUMNMETA_MULTISTRING)
            return eMBProperty_MULTISZ;
        return eMBProperty_STRING;
    default:
        ASSERT(false && L"This type is not allow in the Metabase. MetaMigrate should not have create a column of this type");
    }
    return 0;
}


//returns true if the String was converted to a number and returned in o_Number
bool TMetabase_XMLtable::NumberFromString(LPCWSTR i_pNumber, ULONG i_Len, ULONG & o_Number) const
{
    if(i_Len>=12)
        return false;

    if(1==i_Len && i_pNumber[0]==L'1')
    {
        o_Number = 1;
        return true;
    }
    if(((2==i_Len && 0==memcmp(i_pNumber, L"-1", 2*sizeof(WCHAR))) || (10==i_Len && 0==memcmp(i_pNumber, L"4294967295", 10*sizeof(WCHAR)))))
    {
        o_Number = (ULONG)-1;
        return true;
    }

    //check to see that all of the chars are numeric
    if(!IsNumber(i_pNumber, i_Len))
        return false;

    o_Number = static_cast<unsigned long>(wcstoul(i_pNumber, 0, 10));//This returns -1 on overflow, and 1 on underflow
    if(0xFFFFFFFF==o_Number || 1==o_Number)
        return false;//We're already returned above if the number was 1 or -1, so this must be an underflow or overflow
    return true;
}


//TXmlParsedFileNodeFactory (callback interface) routine
HRESULT TMetabase_XMLtable::CreateNode(const TElement &Element)
{
    if(Element.m_NodeFlags&fEndTag && 1!=Element.m_LevelOfElement)//This is to catch KeyType with NO custom properties
        return S_OK;

    if(XML_PCDATA == Element.m_ElementType)
    {
        WCHAR wszElementName[0x100];
        WCHAR wszElementValue[0x100];

        wcsncpy(wszElementName, Element.m_ElementName, min(Element.m_ElementNameLength, 0xFF));//copy up to 0xFF characters
        wszElementName[min(Element.m_ElementNameLength, 0xFF)]=0x00;

        wcsncpy(wszElementValue, Element.m_ElementValue, min(Element.m_cchElementValue, 0xFF));//copy up to 0xFF characters
        wszElementValue[min(Element.m_cchElementValue, 0xFF)]=0x00;
        if(Element.m_cchElementValue>0xFF)
        {
            wszElementValue[0xFC]=L'.';
            wszElementValue[0xFD]=L'.';
            wszElementValue[0xFE]=L'.';
        }
        LOG_WARNING2(IDS_METABASE_XML_CONTENT_IGNORED, wszElementName, wszElementValue);
    }
    else if(XML_WHITESPACE == Element.m_ElementType)//ignore whitespaces
        return S_OK;

    try
    {
        HRESULT         hr;
        switch(Element.m_LevelOfElement)
        {
        case 1://The only thing we need to do at this level, is check to see if the previous element was an IISConfigObject
            {
                if(m_bIISConfigObjectWithNoCustomProperties)
                {
                    AddKeyTypeRow(m_aPublicRowName.GetFirstPublicRowName(), (ULONG) wcslen(m_aPublicRowName.GetFirstPublicRowName()), true);//We previously saw an IISConfigObject node.  If NO custom properties were found beneath it, we need to add a NULLKeyType row.
                    m_bIISConfigObjectWithNoCustomProperties = false;
                }
                for(ULONG iColumn = 0; iColumn<m_kColumns; ++iColumn)
                {
                    m_apColumnValue[iColumn] = 0;
                    m_aSize[iColumn] = 0;
                }
                return S_OK;
            }
        case 2://We're dealing with Well-Known properties
            {
                m_bFirstPropertyOfThisLocationBeingAdded = true;//This helps identify duplicate locations

                if(0 != m_saQueriedLocation.m_p && m_bQueriedLocationFound)
                    return E_SDTXML_DONE;

                if(XML_COMMENT == Element.m_ElementType)
                    return SetComment(Element.m_ElementName, Element.m_ElementNameLength, true);

                //Before we go NULLing out the m_apColumnValue array we need to check to see if we need to write a NULLKeyType row (ie. Location with no properties).
                if(m_bIISConfigObjectWithNoCustomProperties)
                {
                    AddKeyTypeRow(m_aPublicRowName.GetFirstPublicRowName(), (ULONG) wcslen(m_aPublicRowName.GetFirstPublicRowName()), true);//We previously saw an IISConfigObject node.  If NO custom properties were found beneath it, we need to add a NULLKeyType row.
                    m_bIISConfigObjectWithNoCustomProperties = false;
                }

                //Initialize m_apColumnValue to ALL NULLs, some code relies on this
                ULONG iColumn;
                for(iColumn = 0; iColumn<m_kColumns; ++iColumn)
                {
                    m_apColumnValue[iColumn] = 0;
                    m_aSize[iColumn] = 0;
                }

                //We need a NULL terminated version of this string in a few places
                if(Element.m_ElementNameLength>1023)
                {
                    WCHAR wszTemp[1024];
                    memcpy(wszTemp, Element.m_ElementName, 1023 * sizeof(WCHAR));
                    wszTemp[1023]=0x00;
                    LOG_WARNING1(IDS_COMCAT_XML_ELEMENT_NAME_TOO_LONG, wszTemp);

                    if(0!=m_saCollectionComment.m_p)//Invalidate the preceding comment nodes
                        m_saCollectionComment[0] = 0x00;//NULL out the comment row
                    m_bIISConfigObjectWithNoCustomProperties = false;
                    return S_OK;//If the element name is too long, just ignore it.
                }
                WCHAR wszElement[1024];
                memcpy(wszElement, Element.m_ElementName, Element.m_ElementNameLength * sizeof(WCHAR));
                wszElement[Element.m_ElementNameLength] = 0x00;//NULL terminate it

                if(!m_aPublicRowName.IsEqual(Element.m_ElementName, Element.m_ElementNameLength))
                {
                    //By not filling in m_apColumnValue[iMBProperty_Group], we guarantee no child Custom elements get added to a bogus Group below.

                    LOG_WARNING1(IDS_COMCAT_XML_METABASE_CLASS_NOT_FOUND, wszElement);

                    if(0!=m_saCollectionComment.m_p)//Invalidate the preceding comment nodes
                        m_saCollectionComment[0] = 0x00;//NULL out the comment row
                    m_bIISConfigObjectWithNoCustomProperties = false;
                    return S_OK;//If the tag name of this element doesn't match the PublicRowName of the Group column log an error and continue.
                }
                //We special case Custom.  Custom is a perfectly valid enum public row name; but not at the same level as the Group
                if(0 == StringInsensitiveCompare(L"Custom", Element.m_ElementName))
                {
                    WCHAR wszOffendingXml[0x100];
                    wcsncpy(wszOffendingXml, Element.m_ElementName, min(Element.m_ElementNameLength, 0xFF));//copy up to 0xFF characters
                    wszOffendingXml[min(Element.m_ElementNameLength, 0xFF)]=0x00;
                    LOG_WARNING1(IDS_COMCAT_XML_CUSTOM_ELEMENT_NOT_UNDER_PARENT, wszOffendingXml);

                    if(0!=m_saCollectionComment.m_p)//Invalidate the preceding comment nodes
                        m_saCollectionComment[0] = 0x00;//NULL out the comment row
                    m_bIISConfigObjectWithNoCustomProperties = false;
                    return S_OK;
                }

                if(S_OK != (hr = FillInColumn(iMBProperty_Group, Element.m_ElementName, Element.m_ElementNameLength, m_acolmetas[iMBProperty_Group].dbType, m_acolmetas[iMBProperty_Group].fMeta)))
                {
                    if(0!=m_saCollectionComment.m_p)//Invalidate the preceding comment nodes
                        m_saCollectionComment[0] = 0x00;//NULL out the comment row
                    m_bIISConfigObjectWithNoCustomProperties = false;
                    m_apColumnValue[iMBProperty_Group] = 0;
                    return S_IGNORE_THIS_PROPERTY==hr ? S_OK : hr;
                }

                //IIsConfigObject
                bool bIISConfigObject = (0 == StringCompare(m_aPublicRowName.GetFirstPublicRowName(), Element.m_ElementName));
                m_bIISConfigObjectWithNoCustomProperties = bIISConfigObject;
                //We don't add a keytype row for IISConfigObject unless it's a NULLKeyType (there is a location with NO properties)
                //Remember that this is IISConfigObject.  We don't yet know whether we need to write a NULLKeyType.
                //If the next element is at level 3, we do NOT write a NULLKeyType.  If the next element is at level 2 or 1, we DO write a NULLKeyType row


                ASSERT(m_acolmetas[iMBProperty_Group].fMeta & fCOLUMNMETA_PRIMARYKEY);
                ASSERT(iMBProperty_Group > iMBProperty_Name);

                //There is one attribute that does NOT correspond to a NameValue row.  That's the Path attribute.  We have to find it first
                //since all of the other attributes use its value as one of the columns within their row
                ULONG iAttrLocation;
                if(FindAttribute(Element, m_awszColumnName[iMBProperty_Location], m_acchColumnName[iMBProperty_Location], iAttrLocation))
                {
                    if(S_OK != (hr = FillInColumn(iMBProperty_Location, Element.m_aAttribute[iAttrLocation].m_Value, Element.m_aAttribute[iAttrLocation].m_ValueLength, m_acolmetas[iMBProperty_Location].dbType, m_acolmetas[iMBProperty_Location].fMeta)))
                    {
                        if(0!=m_saCollectionComment.m_p)//Invalidate the preceding comment nodes
                            m_saCollectionComment[0] = 0x00;//NULL out the comment row
                        m_bIISConfigObjectWithNoCustomProperties = false;
                        return S_IGNORE_THIS_PROPERTY==hr ? S_OK : hr;
                    }

                    if(0 != m_saQueriedLocation.m_p && 0 != wcscmp(reinterpret_cast<LPCWSTR>(m_apColumnValue[iMBProperty_Location]), m_saQueriedLocation))
                    {
                        if(m_saCollectionComment.m_p)
                            m_saCollectionComment[0] = 0x00;//NULL out the comment row
                        m_bIISConfigObjectWithNoCustomProperties = false;
                        return S_OK;//ignore this element if querying by location and the location doesn't match
                    }

                    m_apColumnValue[iMBProperty_LocationID] = &m_LocationID;
                    m_aSize[iMBProperty_LocationID] = sizeof(ULONG);
                    InterlockedIncrement(&m_LocationID);
                    m_bQueriedLocationFound = true;
                }
                else
                {
                    WCHAR wszOffendingXml[0x100];
                    wcsncpy(wszOffendingXml, Element.m_ElementName, min(Element.m_ElementNameLength, 0xFF));//copy up to 0xFF characters
                    wszOffendingXml[min(Element.m_ElementNameLength, 0xFF)]=0x00;
                    LOG_WARNING2(IDS_COMCAT_XML_NO_METABASE_LOCATION_FOUND, wszElement, wszOffendingXml);

                    if(0!=m_saCollectionComment.m_p)//Invalidate the preceding comment nodes
                        m_saCollectionComment[0] = 0x00;//NULL out the comment row
                    m_bIISConfigObjectWithNoCustomProperties = false;
                    return S_OK;
                }

                //Add the comment property if there is one
                if(0!=m_saCollectionComment.m_p && 0!=m_saCollectionComment[0])
                {
                    if(FAILED(hr = AddCommentRow()))
                        return hr;
                    m_bFirstPropertyOfThisLocationBeingAdded = false;
                    m_bIISConfigObjectWithNoCustomProperties = false;
                }

                if(!bIISConfigObject)
                {   //IIsConfigObject cannot have a keytype row
                    AddKeyTypeRow(Element.m_ElementName, Element.m_ElementNameLength);
                    m_bFirstPropertyOfThisLocationBeingAdded = false;
                }

                //Every attribute represents a row, where the Value column is the attribute value and the other columns come from the NameValueMeta
                //Walk through the attributes and Query tha NameValueMeta for a property from this Group with a name matching the Attribute name

                //Now go through all of the attribute, each of which should map to a Well-Known Name, and add a row for each.
                for(ULONG iAttr = 0; iAttr<Element.m_NumberOfAttributes; ++iAttr)
                {
                    if(iAttrLocation == iAttr)
                        continue;//we already got the location attribute taken care of.

                    if(S_OK != (hr = FillInColumn(iMBProperty_Name, Element.m_aAttribute[iAttr].m_Name, Element.m_aAttribute[iAttr].m_NameLength, m_acolmetas[iMBProperty_Name].dbType, m_acolmetas[iMBProperty_Name].fMeta)))
                        return S_IGNORE_THIS_PROPERTY==hr ? S_OK : hr;
                    ASSERT(m_apColumnValue[iMBProperty_Name] && "This is Chewbacca, we can't have an attribute of NULL");

                    m_ColumnMeta_IndexBySearch_Values.pTable           = wszElement;
                    m_ColumnMeta_IndexBySearch_Values.pInternalName    = reinterpret_cast<LPWSTR>(m_apColumnValue[iMBProperty_Name]);

                    ULONG iColumnMetaRow= (ULONG) -1;
                    if(FAILED(m_pColumnMetaAll->GetRowIndexBySearch(0, ciColumnMeta_IndexBySearch, m_aiColumnMeta_IndexBySearch, 0, reinterpret_cast<void **>(&m_ColumnMeta_IndexBySearch_Values), &iColumnMetaRow)))
                    {
                        WCHAR wszOffendingXml[0x100];
                        wcsncpy(wszOffendingXml, Element.m_aAttribute[iAttr].m_Name, min(Element.m_aAttribute[iAttr].m_NameLength, 0xFF));//copy up to 0xFF characters
                        wszOffendingXml[min(Element.m_aAttribute[iAttr].m_NameLength, 0xFF)]=0x00;
                        LOG_WARNING2(IDS_COMCAT_XML_METABASE_NO_PROPERTYMETA_FOUND, reinterpret_cast<LPCWSTR>(m_apColumnValue[iMBProperty_Name]), wszOffendingXml);
                        continue;//just ignore any attributes that we don't understand
                    }

                    //This gets all of the default values for the column that matches the well know property
                    tCOLUMNMETARow  columnmetaRow;
                    ULONG           acbColumnMeta[cCOLUMNMETA_NumberOfColumns];
                    if(FAILED(hr = m_pColumnMetaAll->GetColumnValues(iColumnMetaRow, cCOLUMNMETA_NumberOfColumns, NULL, acbColumnMeta, reinterpret_cast<void **>(&columnmetaRow))))
                        return hr;

                    //Attributes MUST match CASE-SENSITIVELY, and GetRowIndexBySearch find case-insensatively since ColumnMeta::InternalName is case-insensatively according to the meta
                    if(0 != StringCompare(columnmetaRow.pInternalName, m_ColumnMeta_IndexBySearch_Values.pInternalName))
                    {
                        WCHAR wszOffendingXml[0x100];
                        wcsncpy(wszOffendingXml, Element.m_aAttribute[iAttr].m_Name, min(Element.m_aAttribute[iAttr].m_NameLength, 0xFF));//copy up to 0xFF characters
                        wszOffendingXml[min(Element.m_aAttribute[iAttr].m_NameLength, 0xFF)]=0x00;
                        LOG_WARNING2(IDS_COMCAT_XML_METABASE_NO_PROPERTYMETA_FOUND, reinterpret_cast<LPCWSTR>(m_apColumnValue[iMBProperty_Name]), wszOffendingXml);
                        continue;//just ignore any attributes that we don't understand
                    }

                    ULONG Type = MetabaseTypeFromColumnMetaType(columnmetaRow);

                    //The name is already filled in; but we're going to copy over it with the Name we got back from columnmeta.  This way
                    //we will correct any case problems.  WARNING!!  I am depending on the buffer previously allocated by FillInColumn and just
                    //overwriting the contents
                    wcscpy(reinterpret_cast<LPWSTR>(m_apColumnValue[iMBProperty_Name]), columnmetaRow.pInternalName);

                    m_apColumnValue[iMBProperty_Type]       = &Type;                        m_aSize[iMBProperty_Type]       = acbColumnMeta[iCOLUMNMETA_Type];
                    m_apColumnValue[iMBProperty_Attributes] = columnmetaRow.pAttributes;    m_aSize[iMBProperty_Attributes] = acbColumnMeta[iMBProperty_Attributes];
                    //m_apColumnValue[iMBProperty_Value]    = Filled in below
                    //m_apColumnValue[iMBProperty_Group]    = Already filled in
                    //m_apColumnValue[iMBProperty_Location] = Already filled in
                    m_apColumnValue[iMBProperty_ID]         = columnmetaRow.pID;            m_aSize[iMBProperty_ID]         = acbColumnMeta[iMBProperty_ID];
                    m_apColumnValue[iMBProperty_UserType]   = columnmetaRow.pUserType;      m_aSize[iMBProperty_UserType]   = acbColumnMeta[iMBProperty_UserType];
                    //m_apColumnValue[iMBProperty_LocationID] Already filled in


                    //FillInColumn relies on m_apColumnValue[iMBProperty_Type] being already filled in for Secure and iMBProperty_Value column
                    bool bSecure = (0!=m_apColumnValue[iMBProperty_Attributes] && 0!=(fMBProperty_SECURE & *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Attributes])));
                    if(S_OK != (hr = FillInColumn(
                        iMBProperty_Value, //ColumnIndex
                        Element.m_aAttribute[iAttr].m_Value,                   //Attribute value
                        Element.m_aAttribute[iAttr].m_ValueLength,             //Attribute Value length
                        *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Type]),     //Value's Column Type
                        *columnmetaRow.pMetaFlags,                                           //Fixed length is always true for Value columns (since they're treated as bytes).
                        bSecure
                        )))continue;//@@@ToDo: Are we absolutely sure we've logged all possible error?  We don't want to ignore any errors without logging them.

                    if(*columnmetaRow.pID == 9994 /*MajorVersion*/)
                    {
                        m_MajorVersion = *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Value]);
                    }

                    //@@@ We need to finish defining flags so this doesn't happen, until then we'll NOT log this warning
                    /*
                    if((fCOLUMNMETA_FLAG & *columnmetaRow.pMetaFlags) && (*reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Value]) & ~(*columnmetaRow.pFlagMask)))
                    {
                        WCHAR wszOffendingXml[0x100];
                        wcsncpy(wszOffendingXml, Element.m_aAttribute[iAttr].m_Name, 0xFF);//copy up to 0xFF characters
                        wszOffendingXml[0xFF]=0x00;

                        WCHAR wszValue[11];
                        wsprintf(wszValue, L"0x%08X", *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Value]));

                        WCHAR wszFlagMask[11];
                        wsprintf(wszFlagMask, L"0x%08X", *columnmetaRow.pFlagMask);

                        LOG_WARNING4(IDS_COMCAT_XML_FLAG_BITS_DONT_MATCH_FLAG_MASK,
                                        reinterpret_cast<LPCWSTR>(m_apColumnValue[iMBProperty_Name]),
                                        wszValue,
                                        wszFlagMask,
                                        wszOffendingXml);
                    }
                    */

                    unsigned long iRow;
                    if(FAILED(hr = AddRowForInsert(&iRow)))
                        return hr;
                    if(FAILED(hr = SetWriteColumnValues(iRow, m_kColumns, 0, m_aSize, reinterpret_cast<void **>(m_apColumnValue))))
                        return hr;

                    hr = AddPropertyToLocationMapping(reinterpret_cast<LPCWSTR>(m_apColumnValue[iMBProperty_Location]), iRow);
					if (FAILED (hr))
						return hr;

                    m_bFirstPropertyOfThisLocationBeingAdded = false;
                }
            }
            break;
        case 3://We're dealing with Custom properties
            {   //We can rely on the fact that 2 columns are already set: Location and LocationID
                if(XML_ELEMENT != Element.m_ElementType)
                    return S_OK;//ignore non Element nodes
                if(Element.m_ElementNameLength != 6/*wcslen(L"Custom")*/ || 0 != memcmp(L"Custom", Element.m_ElementName, sizeof(WCHAR)*Element.m_ElementNameLength))
                {   //The only Child element supported is "Custom"
                    WCHAR wszOffendingXml[0x100];
                    wcsncpy(wszOffendingXml, Element.m_ElementName, min(Element.m_ElementNameLength, 0xFF));//copy up to 0xFF characters
                    wszOffendingXml[min(Element.m_ElementNameLength, 0xFF)]=0x00;

                    LOG_WARNING1(IDS_COMCAT_METABASE_CUSTOM_ELEMENT_EXPECTED, wszOffendingXml);
                    return S_OK;
                }
                if(0 == m_apColumnValue[iMBProperty_Group])
                {
                    WCHAR wszOffendingXml[0x100];
                    wcsncpy(wszOffendingXml, Element.m_ElementName, min(Element.m_ElementNameLength, 0xFF));//copy up to 0xFF characters
                    wszOffendingXml[min(Element.m_ElementNameLength, 0xFF)]=0x00;

                    LOG_WARNING1(IDS_COMCAT_METABASE_CUSTOM_ELEMENT_FOUND_BUT_NO_KEY_TYPE_LOCATION, wszOffendingXml);
                    return S_OK;
                }

                if(0!=m_saQueriedLocation.m_p && 0==m_apColumnValue[iMBProperty_LocationID])
                    return S_OK;
                //Cover the case where Level 2 was bogus

                //If this is the first custom element, then the Group column will be set to the parent element group - we need to remember what group the
                //parent is because custom KeyTypes are allowed on IIsConfigObject only.
                //If this is the second or subsequent custom property then we will have already clobbered m_apColumnValue[iMBProperty_Group] with eMBProperty_Custom.
                if(*reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Group]) != eMBProperty_Custom)
                {
                    m_dwGroupRemembered = *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Group]);
                }
                ASSERT(m_dwGroupRemembered != -1);

                m_bIISConfigObjectWithNoCustomProperties = false;//This indicates whether to write a NULLKeyType row.  The rules are described above where m_bIISConfigObjectWithNoCustomProperties is assigned.

                //Columns MUST be set to zero so they can be properly defaulted
                ULONG iColumn;
                for(iColumn=0;iColumn<m_kColumns; ++iColumn)
                {
                    switch(iColumn)
                    {
                    case iMBProperty_Group://This column is going to be overridden with eMBProperty_Custom; but we need to retain the original Group so we can query the NameValue meta
                        ASSERT(0 != m_apColumnValue[iColumn] && L"Group is NULL.  This shouldn't happen");
                        break;
                    case iMBProperty_Location:
                    case iMBProperty_LocationID://We can get here if the parent's Location attribute is missing
                        if(0 == m_apColumnValue[iColumn])
                            return S_OK;
                        break;
                    default:
                        m_aSize[iColumn]         = 0;
                        m_apColumnValue[iColumn] = 0;
                        break;
                    }
                }

                //We need for the Name column to be listed first so we don't require special handling of default
                //TODO: put this error check in CatUtil
                ASSERT(iMBProperty_Name == 0);

                //Find the Name attribute so we can look it up in the Well-Known name table and initialize all the columns to their default values
                ULONG iAttr;
                ULONG fMetaFlags=0;//if this is a well-know property, it will have MetaFlags that we'll need to capture for use below.
                ULONG Type = 0;//Zero is not a legal Type, so 0 means uninitialized
                bool  bWellKnownForThisKeyType  = false;
                bool  bWellKnown                = false;
                bool  bWellKnownForThisKeyTypeAndNoDifferenceEncountered = false;
                tCOLUMNMETARow  columnmetaRow;
                ULONG           acbColumnMeta[cCOLUMNMETA_NumberOfColumns];

                memset(&columnmetaRow, 0x00, sizeof(tCOLUMNMETARow));
                //Get the Name attribute first
                if(FindAttribute(Element, m_awszColumnName[iMBProperty_Name], m_acchColumnName[iMBProperty_Name], iAttr))
                {   //If we found the Name attribute
                    //Setup the Identity for the NameValueMeta GetRowByIdentity
                    if(S_OK != (hr = FillInColumn(iMBProperty_Name, Element.m_aAttribute[iAttr].m_Value, Element.m_aAttribute[iAttr].m_ValueLength, m_acolmetas[iMBProperty_Name].dbType, m_acolmetas[iMBProperty_Name].fMeta)))
                        return S_IGNORE_THIS_PROPERTY==hr ? S_OK : hr;

                    //This next line might seem a bit confusing - m_aTagMetaIndex[iMBProperty_Group] indicates which element of the m_aTagMetaRow array starts the group enums.
                    //And we rely on MetaMigrate to put enums in sequential order.  So we just add the value of the Group column to the TagMetaIndex and we have the
                    //TagMeta for the Group, thus we know which KeyType (Table) we're dealing with since the Group names ARE the TableNames (KeyTypes).
                    m_ColumnMeta_IndexBySearch_Values.pTable        = m_aTagMetaRow[m_aTagMetaIndex[iMBProperty_Group].m_iTagMeta + m_dwGroupRemembered].pInternalName;
                    //ASSERT that the Nth TagMeta (for the Group column) has a value of N.
                    ASSERT(m_dwGroupRemembered == *m_aTagMetaRow[m_aTagMetaIndex[iMBProperty_Group].m_iTagMeta + m_dwGroupRemembered].pValue);
                    m_ColumnMeta_IndexBySearch_Values.pInternalName = reinterpret_cast<LPWSTR>(m_apColumnValue[iMBProperty_Name]);

                    ULONG iColumnMetaRow= (ULONG) -1;
                    if(SUCCEEDED(m_pColumnMetaAll->GetRowIndexBySearch(0, ciColumnMeta_IndexBySearch, m_aiColumnMeta_IndexBySearch, 0, reinterpret_cast<void **>(&m_ColumnMeta_IndexBySearch_Values), &iColumnMetaRow)))
                    {   //So we have a Well-Known property
                        bWellKnownForThisKeyType                            = true;
                        bWellKnown                                          = true;
                        bWellKnownForThisKeyTypeAndNoDifferenceEncountered  = true;
                    }
                    else
                    {
                        m_ColumnMeta_IndexBySearch_Values.pTable        = const_cast<LPWSTR>(m_aPublicRowName.GetFirstPublicRowName());//The first one is always IISConfigObject; but we do this just in case we decide to change the name
                        if(SUCCEEDED(m_pColumnMetaAll->GetRowIndexBySearch(0, ciColumnMeta_IndexBySearch, m_aiColumnMeta_IndexBySearch, 0, reinterpret_cast<void **>(&m_ColumnMeta_IndexBySearch_Values), &iColumnMetaRow)))
                        {
                            bWellKnownForThisKeyType                            = false;
                            bWellKnown                                          = true;
                            bWellKnownForThisKeyTypeAndNoDifferenceEncountered  = false;
                        }
                    }

                    if(iColumnMetaRow!=-1)
                    {
                        if(FAILED(hr = m_pColumnMetaAll->GetColumnValues(iColumnMetaRow, cCOLUMNMETA_NumberOfColumns, NULL, acbColumnMeta, reinterpret_cast<void **>(&columnmetaRow))))
                            return hr;

                        Type = MetabaseTypeFromColumnMetaType(columnmetaRow);

                        //The name is already filled in; but we're going to copy over it with the Name we got back from columnmeta.  This way
                        //we will correct any case problems.  WARNING!!  I am depending on the buffer previously allocated by FillInColumn and just
                        //overwriting the contents
                        wcscpy(reinterpret_cast<LPWSTR>(m_apColumnValue[iMBProperty_Name]), columnmetaRow.pInternalName);

                        m_apColumnValue[iMBProperty_Type]       = &Type ;                                   m_aSize[iMBProperty_Type]       = acbColumnMeta[iCOLUMNMETA_Type];
                        m_apColumnValue[iMBProperty_Attributes] = columnmetaRow.pAttributes;                m_aSize[iMBProperty_Attributes] = acbColumnMeta[iMBProperty_Attributes];
                        //m_apColumnValue[iMBProperty_Value]    = Filled in below
                        //m_apColumnValue[iMBProperty_Group]    = Filled in below with eMBProperty_Custom
                        //m_apColumnValue[iMBProperty_Location] = Already filled in via Parent element
                        m_apColumnValue[iMBProperty_ID]         = columnmetaRow.pID;                        m_aSize[iMBProperty_ID]         = acbColumnMeta[iMBProperty_ID];
                        m_apColumnValue[iMBProperty_UserType]   = columnmetaRow.pUserType;                  m_aSize[iMBProperty_UserType]   = acbColumnMeta[iMBProperty_UserType];
                        //m_apColumnValue[iMBProperty_LocationID] Already filled in via Parent element

                        fMetaFlags = *columnmetaRow.pMetaFlags;
                    }
                }

                //Get the ID attribute second
                if(FindAttribute(Element, m_awszColumnName[iMBProperty_ID], m_acchColumnName[iMBProperty_ID], iAttr))
                {   //There is no Name attribute in this element, so we can infer one from the ID
                    //First get the ID from the XML
                    if(S_OK != (hr = FillInColumn(iMBProperty_ID, Element.m_aAttribute[iAttr].m_Value, Element.m_aAttribute[iAttr].m_ValueLength,
                                                m_acolmetas[iMBProperty_ID].dbType, m_acolmetas[iMBProperty_ID].fMeta)))
                                return S_IGNORE_THIS_PROPERTY==hr ? S_OK : hr;

                    if(bWellKnown && //if it's a well-known property and it doesn't fit the pID we looked up in the ColumnMeta, then log warning
                        *reinterpret_cast<ULONG *>(columnmetaRow.pID) != *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_ID]))
                    {   //So we have a well-known ID but a user-defined Name - warn and reject the property
                        WCHAR wszID[12];
                        wsprintf(wszID, L"%d", *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_ID]));

                        WCHAR wszOffendingXml[0x100];
                        wcsncpy(wszOffendingXml, Element.m_aAttribute[0].m_Name, min(Element.m_aAttribute[0].m_NameLength, 0xFF));//copy up to 0xFF characters
                        wszOffendingXml[min(Element.m_aAttribute[0].m_NameLength, 0xFF)]=0x00;
                        LOG_WARNING3(IDS_COMCAT_METABASE_CUSTOM_PROPERTY_NAME_ID_CONFLICT, reinterpret_cast<LPCWSTR>(m_apColumnValue[iMBProperty_Name])
                                            , wszID, wszOffendingXml);
                        return S_OK;
                    }

                    //If NO Name was supplied OR we have a Name but it's NOT well-know
                    if(!bWellKnown)
                    {   //We need to see if the ID is well-known
                        m_ColumnMeta_IndexBySearch_Values.pTable = m_aTagMetaRow[m_aTagMetaIndex[iMBProperty_Group].m_iTagMeta + m_dwGroupRemembered].pInternalName;
                        m_ColumnMeta_IndexBySearch_Values.pID    = reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_ID]);

                        ULONG iColumnMetaRow= (ULONG) -1;
                        if(SUCCEEDED(m_pColumnMetaAll->GetRowIndexBySearch(0, ciColumnMeta_IndexBySearchID, m_aiColumnMeta_IndexBySearchID, 0, reinterpret_cast<void **>(&m_ColumnMeta_IndexBySearch_Values), &iColumnMetaRow)))
                        {   //So we have a Well-Known property
                            bWellKnownForThisKeyType                            = true;
                            bWellKnown                                          = true;
                            bWellKnownForThisKeyTypeAndNoDifferenceEncountered  = true;
                        }
                        else
                        {
                            m_ColumnMeta_IndexBySearch_Values.pTable        = const_cast<LPWSTR>(m_aPublicRowName.GetFirstPublicRowName());//The first one is always IISConfigObject; but we do this just in case we decide to change the name
                            if(SUCCEEDED(m_pColumnMetaAll->GetRowIndexBySearch(0, ciColumnMeta_IndexBySearchID, m_aiColumnMeta_IndexBySearchID, 0, reinterpret_cast<void **>(&m_ColumnMeta_IndexBySearch_Values), &iColumnMetaRow)))
                            {
                                bWellKnownForThisKeyType                            = false;
                                bWellKnown                                          = true;
                                bWellKnownForThisKeyTypeAndNoDifferenceEncountered  = false;
                            }
                        }

                        if(iColumnMetaRow!=-1)
                        {   //We HAVe a well-known ID (remember, we do NOT have a well-known Name, per if(!bWellKnwon) condition above
                            if(FAILED(hr = m_pColumnMetaAll->GetColumnValues(iColumnMetaRow, cCOLUMNMETA_NumberOfColumns, NULL, acbColumnMeta, reinterpret_cast<void **>(&columnmetaRow))))
                                return hr;

                            //If the name is NOT NULL and it does NOT begin with UnknownName_, or it does begin with UnknownName_ but the ID doesn't match.
                            //The extra condition allows for upgrades where a property used to be refered to as UnknownName_xxxx and now it has a well-known
                            //name (but the xxxx has to match the ID of newly defined well-known name).
                            if(0 != m_apColumnValue[iMBProperty_Name] &&
                                (0!=wcsncmp(reinterpret_cast<LPCWSTR>(m_apColumnValue[iMBProperty_Name]), L"UnknownName_", wcslen(L"UnknownName_")) ||
                                *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_ID])
                                        != wcstoul(reinterpret_cast<LPCWSTR>(m_apColumnValue[iMBProperty_Name]) + 12, 0, 10)))
                            {
                                //So we have a well-known ID but a user-defined Name - warn and reject the property
                                WCHAR wszID[12];
                                wsprintf(wszID, L"%d", *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_ID]));

                                WCHAR wszOffendingXml[0x100];
                                wcsncpy(wszOffendingXml, Element.m_aAttribute[0].m_Name, min(Element.m_aAttribute[0].m_NameLength, 0xFF));//copy up to 0xFF characters
                                wszOffendingXml[min(Element.m_aAttribute[0].m_NameLength, 0xFF)]=0x00;
                                LOG_WARNING3(IDS_COMCAT_METABASE_CUSTOM_PROPERTY_NAME_ID_CONFLICT, reinterpret_cast<LPCWSTR>(m_apColumnValue[iMBProperty_Name])
                                                    , wszID, wszOffendingXml);
                                return S_OK;
                            }

                            Type = MetabaseTypeFromColumnMetaType(columnmetaRow);

                            m_apColumnValue[iMBProperty_Name]       = columnmetaRow.pInternalName;              m_aSize[iMBProperty_Name]       = acbColumnMeta[iCOLUMNMETA_InternalName];
                            m_apColumnValue[iMBProperty_Type]       = &Type ;                                   m_aSize[iMBProperty_Type]       = acbColumnMeta[iCOLUMNMETA_Type];
                            m_apColumnValue[iMBProperty_Attributes] = columnmetaRow.pAttributes;                m_aSize[iMBProperty_Attributes] = acbColumnMeta[iMBProperty_Attributes];
                            //m_apColumnValue[iMBProperty_Value]    = Filled in below
                            //m_apColumnValue[iMBProperty_Group]    = Filled in below with eMBProperty_Custom
                            //m_apColumnValue[iMBProperty_Location] = Already filled in via Parent element
                            //m_apColumnValue[iMBProperty_ID]       = Already filled in
                            m_apColumnValue[iMBProperty_UserType]   = columnmetaRow.pUserType;                  m_aSize[iMBProperty_UserType]   = acbColumnMeta[iMBProperty_UserType];
                            //m_apColumnValue[iMBProperty_LocationID] Already filled in via Parent element

                            fMetaFlags = *columnmetaRow.pMetaFlags;
                        }
                        else//whether we have a name or not, when it's not a well known ID or Name, then user UnknownName_xxxx for the name
                        {
                            //Then create a string with "UknownName_" followed by the ID
                            ASSERT(m_aGrowableBuffer[iMBProperty_Name].Size()>=256);
                            m_apColumnValue[iMBProperty_Name] = m_aGrowableBuffer[iMBProperty_Name].m_p;
                            m_aSize[iMBProperty_Name] = sizeof(WCHAR) * (1+wsprintf(reinterpret_cast<LPWSTR>(m_apColumnValue[iMBProperty_Name]), L"UnknownName_%u", *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_ID])));
                        }
                    }
                }

                //At this point we MUST have an ID
                if(0 == m_apColumnValue[iMBProperty_ID])
                {
                    WCHAR wszOffendingXml[0x100];
                    wszOffendingXml[0]= 0x00;
                    if(Element.m_NumberOfAttributes>0)
                    {
                        wcsncpy(wszOffendingXml, Element.m_aAttribute[0].m_Name, min(Element.m_aAttribute[0].m_NameLength, 0xFF));//copy up to 0xFF characters
                        wszOffendingXml[min(Element.m_aAttribute[0].m_NameLength, 0xFF)]=0x00;
                    }

                    LOG_WARNING1(IDS_COMCAT_METABASE_CUSTOM_ELEMENT_CONTAINS_NO_ID, wszOffendingXml);
                    return S_OK;
                }

                //1002 is the KeyType property                                          0 is IIsConfigObject
                if(1002==*reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_ID]) && eMBProperty_IIsConfigObject!=m_dwGroupRemembered)
                {
                    WCHAR wszOffendingXml[0x100];
                    wcsncpy(wszOffendingXml, Element.m_aAttribute[0].m_Name, min(Element.m_aAttribute[0].m_NameLength, 0xFF));//copy up to 0xFF characters
                    wszOffendingXml[min(Element.m_aAttribute[0].m_NameLength, 0xFF)]=0x00;

                    LOG_WARNING2(IDS_COMCAT_XML_CUSTOM_KEYTYPE_NOT_ON_IISCONFIGOBJECT, m_aPublicRowName.GetFirstPublicRowName(), wszOffendingXml);
                }

                //We have to read the columns in order.  We can't just read the attributes since we need the Type and Attribute columns before we read the Value column.
                if(FindAttribute(Element, m_awszColumnName[iMBProperty_Type], m_acchColumnName[iMBProperty_Type], iAttr))
                {
                    if(S_OK != (hr = FillInColumn(iMBProperty_Type, Element.m_aAttribute[iAttr].m_Value, Element.m_aAttribute[iAttr].m_ValueLength,
                                                m_acolmetas[iMBProperty_Type].dbType, m_acolmetas[iMBProperty_Type].fMeta, false)))
                                return S_IGNORE_THIS_PROPERTY==hr ? S_OK : hr;

                    //If the Type was specified AND the type was different from ColumnMeta, then we have to invalidate
                    //the meta flags (that we may have gotten from ColumnMeta
                    if(Type != *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Type]))
                    {
                        bWellKnownForThisKeyTypeAndNoDifferenceEncountered = false;//The type is different

                        switch(*reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Type]))
                        {
                        case eMBProperty_DWORD:
                            fMetaFlags = fCOLUMNMETA_FIXEDLENGTH;
                            break;
                        case eMBProperty_STRING:
                        case eMBProperty_BINARY:
                            fMetaFlags = 0;
                            break;
                        case eMBProperty_EXPANDSZ:
                            fMetaFlags = fCOLUMNMETA_EXPANDSTRING;
                            break;
                        case eMBProperty_MULTISZ:
                            fMetaFlags = fCOLUMNMETA_MULTISTRING;
                            break;
                        default:
                            {//This used to be an ASSERT but, if we want to allow users to supply Enums as numeric, the this code will be executed
                                WCHAR wszIllegalTag[0x100];
                                wcsncpy(wszIllegalTag, Element.m_aAttribute[iAttr].m_Value, min(0xFF, Element.m_aAttribute[iAttr].m_ValueLength));//copy up to 0xFF characters
                                wszIllegalTag[min(0xFE, Element.m_aAttribute[iAttr].m_ValueLength)]=0x00;

                                LOG_WARNING2(IDS_COMCAT_XML_ILLEGAL_ENUM_VALUE, m_awszColumnName[iMBProperty_Type], wszIllegalTag);
                                return S_IGNORE_THIS_PROPERTY;
                            }
                        }
                    }
                }
                if(FindAttribute(Element, m_awszColumnName[iMBProperty_Attributes], m_acchColumnName[iMBProperty_Attributes], iAttr))
                {
                    if(S_OK != (hr = FillInColumn(iMBProperty_Attributes, Element.m_aAttribute[iAttr].m_Value, Element.m_aAttribute[iAttr].m_ValueLength,
                                                m_acolmetas[iMBProperty_Attributes].dbType, m_acolmetas[iMBProperty_Attributes].fMeta, false)))
                                return S_IGNORE_THIS_PROPERTY==hr ? S_OK : hr;
                    if(bWellKnown && *columnmetaRow.pAttributes != *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Attributes]))
                        bWellKnownForThisKeyTypeAndNoDifferenceEncountered = false;//The Attributes are different
                }
                if(0 == m_apColumnValue[iMBProperty_Type])
                {
                    WCHAR wszOffendingXml[0x100];//unlike above, we know there is at least one attribute, we've already read either the name or the ID
                    wcsncpy(wszOffendingXml, Element.m_aAttribute[0].m_Name, min(Element.m_aAttribute[0].m_NameLength, 0xFF));//copy up to 0xFF characters
                    wszOffendingXml[min(Element.m_aAttribute[0].m_NameLength, 0xFF)]=0x00;

                    LOG_WARNING2(IDS_COMCAT_METABASE_CUSTOM_ELEMENT_CONTAINS_NO_TYPE, reinterpret_cast<LPWSTR>(m_apColumnValue[iMBProperty_Name]), wszOffendingXml);

                    //We can't just default the Type like we do with other columns, since FillInColumnRelies on this being NOT NULL, so default it here.
                    static ULONG ulStringType = eMBProperty_STRING;
                    m_apColumnValue[iMBProperty_Type] = &ulStringType;
                    m_aSize[iMBProperty_Type] = sizeof(ULONG);
                }

                for(iColumn=0;iColumn<m_kColumns; ++iColumn)
                {
                    switch(iColumn)
                    {
                    case iMBProperty_Location:      //we pick up the path from the parent, which we should already have
                    case iMBProperty_LocationID:    //we infer this from the parent, which we should already have
                    case iMBProperty_Group:         //we just hard coded the Group to eMBProperty_Custom
                    case iMBProperty_ID:            //this either came from the Well-Known name table OR we read it from the attribute
                    case iMBProperty_Name:          //we got this first thing (or we may have inferred it from the name)
                    case iMBProperty_Type:
                        ASSERT(0 != m_apColumnValue[iColumn]);break;
                    case iMBProperty_Value:
                        {
                            if(FindAttribute(Element, m_awszColumnName[iColumn], m_acchColumnName[iColumn], iAttr))
                            {
                                bool bSecure = (0!=m_apColumnValue[iMBProperty_Attributes] && 0!=(4/*fNameValuePairTable_METADATA_SECURE*/ & *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Attributes])));
                                ULONG metaflags = fMetaFlags;//we need to OR in any Metaflags
                                if(S_OK != (hr = FillInColumn(iColumn, Element.m_aAttribute[iAttr].m_Value, Element.m_aAttribute[iAttr].m_ValueLength,
                                                            m_acolmetas[iColumn].dbType, metaflags, bSecure)))
                                            return S_IGNORE_THIS_PROPERTY==hr ? S_OK : hr;
                            }
                            else if(bWellKnown)//if well know, pass "" and let FillInColumn do the right thing.
                            {
                                bool bSecure = (0!=m_apColumnValue[iMBProperty_Attributes] && 0!=(4/*fNameValuePairTable_METADATA_SECURE*/ & *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Attributes])));
                                ULONG metaflags = fMetaFlags;//we need to OR in any Metaflags
                                if(S_OK != (hr = FillInColumn(iColumn, L"", 0, m_acolmetas[iColumn].dbType, metaflags, bSecure)))
                                            return S_IGNORE_THIS_PROPERTY==hr ? S_OK : hr;
                            }
                            else if(!bWellKnown)//If not well-known then we won't just leave the value as NULL, so log a warning.
                            {
                                LOG_WARNING1(IDS_METABASE_NO_VALUE_SUPPLIED_FOR_CUSTOM_PROPERTY, reinterpret_cast<LPCWSTR>(m_apColumnValue[iMBProperty_Name]));
                                return S_OK;
                            }
                            //Otherwise leave it defaulted (Well-Known default).
                        }
                        break;
                    case iMBProperty_Attributes:
                        {
                            if(FindAttribute(Element, m_awszColumnName[iColumn], m_acchColumnName[iColumn], iAttr))
                            {
                                ULONG metaflags = m_acolmetas[iColumn].fMeta;
                                if(S_OK != (hr = FillInColumn(iColumn, Element.m_aAttribute[iAttr].m_Value, Element.m_aAttribute[iAttr].m_ValueLength,
                                                            m_acolmetas[iColumn].dbType, metaflags, false/*Not secure*/)))
                                            return S_IGNORE_THIS_PROPERTY==hr ? S_OK : hr;
                                //AND out these two bits
                                *reinterpret_cast<ULONG *>(m_apColumnValue[iColumn]) &= ~(0x22);//~(METADATA_ISINHERITED | METADATA_PARTIAL_PATH);
                            }
                        }
                    case iMBProperty_UserType:
                    default:
                        {
                            if(FindAttribute(Element, m_awszColumnName[iColumn], m_acchColumnName[iColumn], iAttr))
                            {
                                ULONG metaflags = m_acolmetas[iColumn].fMeta;
                                if(S_OK != (hr = FillInColumn(iColumn, Element.m_aAttribute[iAttr].m_Value, Element.m_aAttribute[iAttr].m_ValueLength,
                                                            m_acolmetas[iColumn].dbType, metaflags, false/*Not secure*/)))
                                            return S_IGNORE_THIS_PROPERTY==hr ? S_OK : hr;
                                if(bWellKnown && iColumn==iMBProperty_UserType && bWellKnownForThisKeyTypeAndNoDifferenceEncountered)
                                {
                                    if(*columnmetaRow.pUserType != *reinterpret_cast<ULONG *>(m_apColumnValue[iColumn]))
                                        bWellKnownForThisKeyTypeAndNoDifferenceEncountered = false;
                                }
                            }
                            //Otherwise leave it defaulted (either to the Well-Known default, or NULL if this isn't a Well-Known property).
                        }
                        break;
                    }
                }

                //We can hard code the Group column to be Custom unless, everything matches the well-known value
                m_apColumnValue[iMBProperty_Group] = bWellKnownForThisKeyTypeAndNoDifferenceEncountered ? &m_dwGroupRemembered : &m_kMBProperty_Custom;
                m_aSize[iMBProperty_Group] = sizeof(ULONG);

                unsigned long iRow;
                if(FAILED(hr = AddRowForInsert(&iRow)))
                    return hr;
                if(FAILED(hr = SetWriteColumnValues(iRow, m_kColumns, 0, m_aSize, reinterpret_cast<void **>(m_apColumnValue))))
                    return hr;

                hr = AddPropertyToLocationMapping(reinterpret_cast<LPCWSTR>(m_apColumnValue[iMBProperty_Location]), iRow);//Can throw HRESULT
				if (FAILED (hr))
					return hr;

                m_bFirstPropertyOfThisLocationBeingAdded = false;//This helps identify duplicate locations
            }
            break;
        default://Ignore everything at a level other than 1, 2 or 3
            return S_OK;
        }
    }
    catch(HRESULT e)
    {
        return e;
    }

    return S_OK;
}

bool TMetabase_XMLtable::FindAttribute(const TElement &i_Element, LPCWSTR i_wszAttr, ULONG i_cchAttr, ULONG &o_iAttr)
{
    for(o_iAttr=0; (o_iAttr<i_Element.m_NumberOfAttributes); ++o_iAttr)
    {
        //If this attribute doesn't match the Column's Public name, move on to the next attribute
        if( i_cchAttr == i_Element.m_aAttribute[o_iAttr].m_NameLength
            &&       0 == StringCompare(i_wszAttr, i_Element.m_aAttribute[o_iAttr].m_Name, i_Element.m_aAttribute[o_iAttr].m_NameLength))
            return true;
    }
    return false;
}

HRESULT TMetabase_XMLtable::AddKeyTypeRow(LPCWSTR i_KeyType, ULONG i_Len, bool bNULLKeyTypeRow)
{
    HRESULT hr = S_OK;
    if(-1 == m_iKeyTypeRow)
    {   //Fill in the KeyType row
        m_ColumnMeta_IndexBySearch_Values.pTable        = const_cast<LPWSTR>(m_aPublicRowName.GetFirstPublicRowName());//The first one is always IISConfigObject; but we do this just in case we decide to change the name
        m_ColumnMeta_IndexBySearch_Values.pInternalName = L"KeyType";

        if(FAILED(m_pColumnMetaAll->GetRowIndexBySearch(0, ciColumnMeta_IndexBySearch, m_aiColumnMeta_IndexBySearch, 0, reinterpret_cast<void **>(&m_ColumnMeta_IndexBySearch_Values), &m_iKeyTypeRow)))
        {
            LOG_ERROR_LOS(m_fLOS, Interceptor, (&m_spISTError.p, m_pISTDisp, E_ST_INVALIDBINFILE, ID_CAT_CAT, IDS_COMCAT_METABASE_PROPERTY_NOT_FOUND, m_ColumnMeta_IndexBySearch_Values.pInternalName,
                eSERVERWIRINGMETA_Core_MetabaseInterceptor, wszTABLE_MBProperty, eDETAILEDERRORS_Populate, (ULONG)-1, (ULONG)-1, m_wszURLPath, eDETAILEDERRORS_ERROR, 0, 0, m_MajorVersion));
            return E_ST_INVALIDBINFILE;
        }

        ASSERT(-1 != m_iKeyTypeRow);
    }
    tCOLUMNMETARow  columnmetaRow;
    ULONG           acbColumnMeta[cCOLUMNMETA_NumberOfColumns];
    if(FAILED(hr = m_pColumnMetaAll->GetColumnValues(m_iKeyTypeRow, cCOLUMNMETA_NumberOfColumns, NULL, acbColumnMeta, reinterpret_cast<void **>(&columnmetaRow))))return hr;

    ULONG Type = MetabaseTypeFromColumnMetaType(columnmetaRow);
    m_apColumnValue[iMBProperty_Name]       = columnmetaRow.pInternalName;          m_aSize[iMBProperty_Type]       = acbColumnMeta[iCOLUMNMETA_InternalName];
    m_apColumnValue[iMBProperty_Type]       = &Type;                                m_aSize[iMBProperty_Type]       = acbColumnMeta[iCOLUMNMETA_Type];
    m_apColumnValue[iMBProperty_Attributes] = columnmetaRow.pAttributes;            m_aSize[iMBProperty_Attributes] = acbColumnMeta[iMBProperty_Attributes];
    //m_apColumnValue[iMBProperty_Value]    = Filled in below
    //m_apColumnValue[iMBProperty_Group]    = Filled in already
    //m_apColumnValue[iMBProperty_Location] = Already filled in via Parent element
    m_apColumnValue[iMBProperty_ID]         = columnmetaRow.pID;                    m_aSize[iMBProperty_ID]         = acbColumnMeta[iMBProperty_ID];
    m_apColumnValue[iMBProperty_UserType]   = columnmetaRow.pUserType;              m_aSize[iMBProperty_UserType]   = acbColumnMeta[iMBProperty_UserType];
    //m_apColumnValue[iMBProperty_LocationID] Already filled in via Parent element

    //FillInColumn relies on m_apColumnValue[iMBProperty_Type] being already filled in for Secure and iMBProperty_Value column
    if(S_OK != (hr = FillInColumn(
        iMBProperty_Value, //ColumnIndex
        i_KeyType,
        i_Len,
        *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Type]),     //Value's Column Type
        0
        )))return S_IGNORE_THIS_PROPERTY==hr ? S_OK : hr;

    static ULONG zero = 0;
    if(bNULLKeyTypeRow)//A NULL KeyType row indicates that the KeyType is only property, there are no other proerties under this Location.
    {
        static WCHAR szNULLKeyTypeRow[]=L"#LocationWithNoProperties";
        m_apColumnValue[iMBProperty_Name] = szNULLKeyTypeRow;
        m_aSize[iMBProperty_Name] = (ULONG)(wcslen(szNULLKeyTypeRow)+1)*sizeof(WCHAR);
        m_apColumnValue[iMBProperty_ID] = &m_kLocationID;
        m_aSize[iMBProperty_ID] = 0;
        m_apColumnValue[iMBProperty_Value] = 0;//NULL
        m_aSize[iMBProperty_Value] = 0;
    }

    unsigned long iRow;
    if(FAILED(hr = AddRowForInsert(&iRow)))return hr;
    if(FAILED(hr = SetWriteColumnValues(iRow, m_kColumns, 0, m_aSize, reinterpret_cast<void **>(m_apColumnValue))))return hr;

    hr = AddPropertyToLocationMapping(reinterpret_cast<LPCWSTR>(m_apColumnValue[iMBProperty_Location]), iRow);

    return hr;
}


HRESULT TMetabase_XMLtable::AddCommentRow()
{
    ASSERT(0!=m_saCollectionComment.m_p && 0!=m_saCollectionComment[0]);

    HRESULT hr;
    if(-1 == m_iCollectionCommentRow)
    {   //Fill in the KeyType row
        m_ColumnMeta_IndexBySearch_Values.pTable        = const_cast<LPWSTR>(m_aPublicRowName.GetFirstPublicRowName());//The first one is always IISConfigObject; but we do this just in case we decide to change the name
        m_ColumnMeta_IndexBySearch_Values.pInternalName = L"CollectionComment";

        if(FAILED(m_pColumnMetaAll->GetRowIndexBySearch(0, ciColumnMeta_IndexBySearch, m_aiColumnMeta_IndexBySearch, 0, reinterpret_cast<void **>(&m_ColumnMeta_IndexBySearch_Values), &m_iCollectionCommentRow)))
        {
            LOG_ERROR_LOS(m_fLOS, Interceptor, (&m_spISTError.p, m_pISTDisp, E_ST_INVALIDBINFILE, ID_CAT_CAT, IDS_COMCAT_METABASE_PROPERTY_NOT_FOUND, m_ColumnMeta_IndexBySearch_Values.pInternalName,
                eSERVERWIRINGMETA_Core_MetabaseInterceptor, wszTABLE_MBProperty, eDETAILEDERRORS_Populate, (ULONG)-1, (ULONG)-1, m_wszURLPath, eDETAILEDERRORS_ERROR, 0, 0, m_MajorVersion));
            return E_ST_INVALIDBINFILE;
        }

        ASSERT(-1 != m_iCollectionCommentRow);
    }

    tCOLUMNMETARow  columnmetaRow;
    ULONG           acbColumnMeta[cCOLUMNMETA_NumberOfColumns];
    if(FAILED(hr = m_pColumnMetaAll->GetColumnValues(m_iCollectionCommentRow, cCOLUMNMETA_NumberOfColumns, NULL, acbColumnMeta, reinterpret_cast<void **>(&columnmetaRow))))
        return hr;

    ULONG Type = MetabaseTypeFromColumnMetaType(columnmetaRow);
    m_apColumnValue[iMBProperty_Name]       = columnmetaRow.pInternalName;          m_aSize[iMBProperty_Type]       = acbColumnMeta[iCOLUMNMETA_InternalName];
    m_apColumnValue[iMBProperty_Type]       = &Type;                                m_aSize[iMBProperty_Type]       = acbColumnMeta[iCOLUMNMETA_Type];
    m_apColumnValue[iMBProperty_Attributes] = columnmetaRow.pAttributes;            m_aSize[iMBProperty_Attributes] = acbColumnMeta[iMBProperty_Attributes];
    //m_apColumnValue[iMBProperty_Value]    = Filled in below
    //m_apColumnValue[iMBProperty_Group]    = Filled in already
    //m_apColumnValue[iMBProperty_Location] = Already filled in via Parent element
    m_apColumnValue[iMBProperty_ID]         = columnmetaRow.pID;                    m_aSize[iMBProperty_ID]         = acbColumnMeta[iMBProperty_ID];
    m_apColumnValue[iMBProperty_UserType]   = columnmetaRow.pUserType;              m_aSize[iMBProperty_UserType]   = acbColumnMeta[iMBProperty_UserType];
    //m_apColumnValue[iMBProperty_LocationID] Already filled in via Parent element

    //FillInColumn relies on m_apColumnValue[iMBProperty_Type] being already filled in for Secure and iMBProperty_Value column
    if(S_OK != (hr = FillInColumn(
        iMBProperty_Value, //ColumnIndex
        m_saCollectionComment,
        (ULONG)wcslen(m_saCollectionComment),
        *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Type]),     //Value's Column Type
        0
        )))return S_IGNORE_THIS_PROPERTY==hr ? S_OK : hr;

    unsigned long iRow;
    if(FAILED(hr = AddRowForInsert(&iRow)))
        return hr;
    if(FAILED(hr = SetWriteColumnValues(iRow, m_kColumns, 0, m_aSize, reinterpret_cast<void **>(m_apColumnValue))))
        return hr;

    hr = AddPropertyToLocationMapping(reinterpret_cast<LPCWSTR>(m_apColumnValue[iMBProperty_Location]), iRow);
	if (FAILED (hr))
		return hr;

    m_saCollectionComment[0] = 0x00;//now that we've added the comment, set it to "" for the next time
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\fixedtable\sdtfxd_data.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.

// IMPORTANT:   For any schema changes which are incompatible with previous versions:
//              The CURRENT_SCHEMA_VERSION must be incremented as part of the checkin.
//              (Note that this is currently required for all regdb schema changes.)


#include "precomp.hxx"

extern ULONG g_aFixedTableHeap[]; // from catinproc.cpp

const FixedTableHeap * g_pFixedTableHeap = reinterpret_cast<const FixedTableHeap *>(g_aFixedTableHeap);
const FixedTableHeap * g_pExtendedFixedTableHeap = 0;//This one gets built on the fly as needed.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\fixedtable\sdtfxd_data.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

extern const FixedTableHeap * g_pFixedTableHeap;
extern const FixedTableHeap * g_pExtendedFixedTableHeap;//This one gets built on the fly as needed.

#define g_aColumnMeta   (m_pFixedTableHeap->Get_aColumnMeta())
#define g_aDatabaseMeta (m_pFixedTableHeap->Get_aDatabaseMeta())
#define g_aIndexMeta    (m_pFixedTableHeap->Get_aIndexMeta())
#define g_aTableMeta    (m_pFixedTableHeap->Get_aTableMeta())
#define g_aTagMeta      (m_pFixedTableHeap->Get_aTagMeta())
#define g_aQueryMeta    (m_pFixedTableHeap->Get_aQueryMeta())
#define g_aRelationMeta (m_pFixedTableHeap->Get_aRelationMeta())

#define g_aBytes        (m_pFixedTableHeap->Get_PooledDataHeap())
#define g_aHashedIndex  (m_pFixedTableHeap->Get_HashTableHeap())

#define g_ciColumnMetas     (m_pFixedTableHeap->Get_cColumnMeta())
#define g_ciDatabaseMetas   (m_pFixedTableHeap->Get_cDatabaseMeta())
#define g_ciIndexMeta       (m_pFixedTableHeap->Get_cIndexMeta())
#define g_ciTableMetas      (m_pFixedTableHeap->Get_cTableMeta())
#define g_ciTagMeta         (m_pFixedTableHeap->Get_cTagMeta())
#define g_ciQueryMeta       (m_pFixedTableHeap->Get_cQueryMeta())
#define g_ciRelationMeta    (m_pFixedTableHeap->Get_cRelationMeta())

#define g_aFixedTable       (m_pFixedTableHeap->Get_aULONG())
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\fixedtable\sdtfxd.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

class TBinFileMappingCache
{
public:
    static void GetFileMappingPointer(LPCWSTR i_wszFilename, const FixedTableHeap *& o_pFixedTableHeap);
    static void ReleaseFileMappingPointer(const FixedTableHeap * i_pFixedTableHeap);

private:
    TBinFileMappingCache() : m_cRef(0), m_pNext(0)
    {
    }
    ~TBinFileMappingCache()
    {
        ASSERT(0 == m_cRef);
    }

    static TBinFileMappingCache *   GetCacheEntry(LPCWSTR i_wszFilename);
    static TBinFileMappingCache *   GetCacheEntry(const char *i_pMapping);
    HRESULT                         Init(LPCWSTR i_wszFilename);
    static void                     RemoveCacheEntry(TBinFileMappingCache *pRemove);


    static CSafeAutoCriticalSection m_CriticalSection;//The list is a globally shared resource, so we have to guard it.
    static TBinFileMappingCache *   m_pFirst;
    TSmartPointerArray<WCHAR>       m_spaFilename;
    TFileMapping                    m_FileMapping;
    ULONG                           m_cRef;
    TBinFileMappingCache        *   m_pNext;

};


// ------------------------------------------------------------------
// class CSDTFxd:
// ------------------------------------------------------------------
class CSDTFxd :
    public ISimpleTableInterceptor,
    public ISimpleTableRead2,
    public ISimpleTableAdvanced
{
public:
    CSDTFxd ();
    ~CSDTFxd ();

// -----------------------------------------
// IUnknown, IClassFactory, ISimpleLogicTableDispenser:
// -----------------------------------------

//IUnknown
public:
    STDMETHOD (QueryInterface)      (REFIID riid, OUT void **ppv);
    STDMETHOD_(ULONG,AddRef)        ();
    STDMETHOD_(ULONG,Release)       ();

//ISimpleDataTableDispenser
public:
    STDMETHOD(Intercept) (
                        LPCWSTR                 i_wszDatabase,
                        LPCWSTR                 i_wszTable,
						ULONG					i_TableID,
                        LPVOID                  i_QueryData,
                        LPVOID                  i_QueryMeta,
                        DWORD                   i_eQueryFormat,
                        DWORD                   i_fTable,
                        IAdvancedTableDispenser* i_pISTDisp,
                        LPCWSTR                 i_wszLocator,
                        LPVOID                  i_pSimpleTable,
                        LPVOID*                 o_ppv
                        );

// -----------------------------------------
// ISimpleTable*:
// -----------------------------------------

//ISimpleTableRead2
public:
    STDMETHOD (GetRowIndexByIdentity)   (ULONG * i_cb, LPVOID * i_pv, ULONG* o_piRow);
    STDMETHOD (GetRowIndexBySearch) (ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow);
    STDMETHOD (GetColumnValues)     (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues);
    STDMETHOD (GetTableMeta)        (ULONG *o_pcVersion, DWORD * o_pfTable, ULONG * o_pcRows, ULONG * o_pcColumns );
    STDMETHOD (GetColumnMetas)      (ULONG i_cColumns, ULONG* i_aiColumns, SimpleColumnMeta* o_aColumnMetas);

//ISimpleTableAdvanced
public:
    STDMETHOD (PopulateCache)           ();
    STDMETHOD (GetDetailedErrorCount)   (ULONG* o_pcErrs);
    STDMETHOD (GetDetailedError)        (ULONG i_iErr, STErr* o_pSTErr);
    STDMETHOD (ResetCaches)				();
    STDMETHOD (GetColumnValuesEx)       (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, DWORD* o_afStatus, ULONG* o_acbSizes, LPVOID* o_apvValues);

// -----------------------------------------
// Member variables:
// -----------------------------------------

private:
    bool                    m_bDidMeta;
    unsigned long           m_cColumns;             // This duplicate to m_pTableMeta->CountOfColumns eliminate a bunch of UI4FromIndexs
    unsigned long           m_cColumnsPlusPrivate;  // Since this information is needed all over the place, we have this to eliminate an 'add'.
    unsigned long           m_cIndexMeta;
    unsigned long           m_ciRows;
    ULONG                   m_cPrimaryKeys;         // This is the number of promary keys there are in the table.
    ULONG                   m_cRef;                 // Interface reference count.
    DWORD                   m_fIsTable;             // Either component is posing as class factory / dispenser or table.
    ULONG                   m_iZerothRow;           // When a query is executed, the consumer's 0th row, is m_iZerothRow.  All Rows must be between 0 & m_ciRows
    const ColumnMeta      * m_pColumnMeta;          // Pointer to the ColumnMeta
    const void            * m_pFixedTableUnqueried; // We need to keep this around since, hash indexes refer to the row from the beginning of the table.
    const void            * m_pFixedTable;
    const HashedIndex     * m_pHashedIndex;
    const HashTableHeader * m_pHashTableHeader;
    const IndexMeta       * m_pIndexMeta;           // Pointer to the first IndexMeta row for this table & index named in the query.
    const TableMeta       * m_pTableMeta;           // Pointer to the TableMeta, part of this meta is the pointer to the actual data (if exists as FIXED table).
    TFileMapping            m_FixedTableHeapFile;   // If the Meta comes from a file, this object maps a view of the file.

    const FixedTableHeap  * m_pFixedTableHeap;      // This can either be a pointer to g_pFixedTableHeap or one that we generate for extensible schema

    HRESULT                 GetColumnMetaQuery(  const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszTable, unsigned long &iOrder) const;
    HRESULT                 GetColumnMetaTable(  STQueryCell * pQueryCell, unsigned long cQueryCells);
    HRESULT                 GetDatabaseMetaQuery(const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszDatabase) const;
    HRESULT                 GetDatabaseMetaTable(STQueryCell * pQueryCell, unsigned long cQueryCells);
    HRESULT                 GetIndexMeta(        const STQueryCell *pQueryCell, unsigned long cQueryCells);
    HRESULT                 GetIndexMetaQuery(   const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszTable, LPCWSTR &InternalName, unsigned long &iOrder) const;
    HRESULT                 GetIndexMetaTable(   STQueryCell * pQueryCell, unsigned long cQueryCells);
    HRESULT                 GetQueryMetaQuery(   const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszTable, LPCWSTR &wszInternalName, LPCWSTR &wszCellName) const;
    HRESULT                 GetQueryMetaTable(   STQueryCell * pQueryCell, unsigned long cQueryCells);
    HRESULT                 GetRelationMetaQuery(const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszTablePrimary, LPCWSTR &TableForeign) const;
    HRESULT                 GetRelationMetaTable(STQueryCell * pQueryCell, unsigned long cQueryCells);
    HRESULT                 GetTableMetaQuery(   const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszDatabase, LPCWSTR &wszTable) const;
    HRESULT                 GetTableMetaTable(   STQueryCell * pQueryCell, unsigned long cQueryCells);
    HRESULT                 GetTagMetaQuery(     const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszTable, unsigned long &iOrder, LPCWSTR &PublicName) const;
    HRESULT                 GetTagMetaTable(     STQueryCell * pQueryCell, unsigned long cQueryCells);
    inline int              StringInsensitiveCompare(LPCWSTR sz1, LPCWSTR sz2) const
                            {
                                if(sz1 == sz2 || 0 == wcscmp(sz1, sz2))//try case sensitive compare first
                                    return 0;
                                return _wcsicmp(sz1, sz2);
                            }
    inline int              StringCompare(LPCWSTR sz1, LPCWSTR sz2) const
                            {
                                if(sz1 == sz2)
                                    return 0;
                                if(*sz1 != *sz2)//check the first character before calling wcscmp
                                    return -1;
                                return wcscmp(sz1, sz2);
                            }
    inline bool             IsStringFromPool(LPCWSTR sz) const
    {
        return (reinterpret_cast<const unsigned char *>(sz) > m_pFixedTableHeap->Get_PooledDataHeap() && reinterpret_cast<const unsigned char *>(sz) < m_pFixedTableHeap->Get_PooledDataHeap()+m_pFixedTableHeap->Get_cbPooledHeap());
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\fixedschemainterceptor\tableschema.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "precomp.hxx"

namespace TableSchema
{

const unsigned char * TableSchemaHeap::Get_TableSchema(LPCWSTR TableName) const
{
    const unsigned char *pTableSchema = Get_TableSchema(TableIDFromTableName(TableName));
    const CollectionMeta *pCollectionMeta = reinterpret_cast<const CollectionMeta *>(pTableSchema);
    if(0==pTableSchema || 0!=_wcsicmp(TableName, reinterpret_cast<LPCWSTR>(pTableSchema + pCollectionMeta->iHeap + pCollectionMeta->InternalName)))
        return 0;//the TableID didn't correspond to a valid table OR the table names don't match then fail.
    return pTableSchema;
}

const unsigned char * TableSchemaHeap::Get_TableSchema(ULONG TableID) const
{
    if(0 != (TableID & 0xFF))//TableIDs are 32 bit values whose lower 8 bits are zero.
        return 0;

    const HashedIndex * pHashedIndex = Get_TableNameHashHeader().Get_HashedIndex(TableID);

    for(;pHashedIndex; pHashedIndex = Get_TableNameHashHeader().Get_NextHashedIndex(pHashedIndex))
    {
        if(pHashedIndex->iOffset >= Get_EndOfaTableSchema())//if we're given a bogus TableID, it will result in a pHashedIndex with iOffset==-1 and iNext==-1
            return 0;                                       //if we don't do this check, we'll AV
        const CollectionMeta *pCollectionMeta = reinterpret_cast<const CollectionMeta *>(reinterpret_cast<const unsigned char *>(this) + pHashedIndex->iOffset);
        if(pCollectionMeta->nTableID == TableID)
            return reinterpret_cast<const unsigned char *>(pCollectionMeta);
    }
    return 0;
}

LPCWSTR TableSchemaHeap::Get_TableName(ULONG TableID) const
{
    const unsigned char *  pTableSchema     = Get_TableSchema(TableID);
    if(!pTableSchema)
        return 0;

    const CollectionMeta * pCollectionMeta  = reinterpret_cast<const CollectionMeta *>(pTableSchema);
    return reinterpret_cast<LPCWSTR>(pTableSchema + pCollectionMeta->iHeap + pCollectionMeta->InternalName);//InternalName is a byte offset from the beginning of the pTableSchema's Heap

}

HRESULT TTableSchema::Init(const unsigned char *pTableSchema)
{
    if(0==pTableSchema)
        return E_ST_INVALIDTABLE;

    m_pCollectionMeta   = reinterpret_cast<const CollectionMeta *>(pTableSchema);
    m_pPropertyMeta     = reinterpret_cast<const PropertyMeta *>(pTableSchema + sizeof(CollectionMeta));

    m_pTagMeta          = reinterpret_cast<const TagMeta *>(m_pCollectionMeta->iTagMeta ? pTableSchema + m_pCollectionMeta->iTagMeta : 0);

    ASSERT(0 != m_pCollectionMeta->iServerWiring);
    ASSERT(0 != m_pCollectionMeta->cServerWiring);//There must be at least one
    m_pServerWiring     = reinterpret_cast<const ServerWiringMeta *>(pTableSchema + m_pCollectionMeta->iServerWiring);

    ASSERT(0 != m_pCollectionMeta->iHeap);
    m_pHeap             = pTableSchema + m_pCollectionMeta->iHeap;

    m_pTableDataHeap    = reinterpret_cast<const ULONG *>(m_pCollectionMeta->iFixedTableRows ? pTableSchema + m_pCollectionMeta->iFixedTableRows : 0);
    return S_OK;
}

ULONG TTableSchema::GetPooledHeapPointerSize(const unsigned char *p) const
{
    ASSERT(0 != m_pCollectionMeta);
    if(0==p)
        return 0;

    //Make sure the user doesn't pass some arbitrary pointer.  It MUST be a valid pointer within the heap.
    ASSERT(p > reinterpret_cast<const unsigned char *>(m_pCollectionMeta) + m_pCollectionMeta->iHeap);
    ASSERT(p < reinterpret_cast<const unsigned char *>(m_pCollectionMeta) + m_pCollectionMeta->iHeap + m_pCollectionMeta->cbHeap);
    return (*(reinterpret_cast<const ULONG *>(p) - 1));
}

}//End of namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\xmltable\metabase_xmltable_com.cpp ===
//  Copyright (C) 2000-2001 Microsoft Corporation.  All rights reserved.

#include "precomp.hxx"

// -----------------------------------------
// TMetabase_XMLtable: IUnknown
// -----------------------------------------

// =======================================================================
STDMETHODIMP TMetabase_XMLtable::QueryInterface(REFIID riid, void **ppv)
{
    if (NULL == ppv)
        return E_INVALIDARG;
    *ppv = NULL;


    if (riid == IID_ISimpleTableAdvanced)
    {
        *ppv = (ISimpleTableAdvanced*)(this);
    }
    else if (riid == IID_ISimpleTableRead2)
    {
        *ppv = (ISimpleTableRead2*)(this);
    }
    else if (riid == IID_ISimpleTableWrite2)
    {
        *ppv = (ISimpleTableWrite2*)(this);
    }
    else if (riid == IID_ISimpleTableController)
    {
        *ppv = (ISimpleTableController*)(this);
    }
    else if (riid == IID_ISimpleTableInterceptor)
    {
        *ppv = (ISimpleTableInterceptor*)(this);
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = (ISimpleTableWrite2*)(this);
    }

    if (NULL != *ppv)
    {
        ((ISimpleTableWrite2*)this)->AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

// =======================================================================
STDMETHODIMP_(ULONG) TMetabase_XMLtable::AddRef()
{
    return InterlockedIncrement((LONG*) &m_cRef);

}

// =======================================================================
STDMETHODIMP_(ULONG) TMetabase_XMLtable::Release()
{
    long cref = InterlockedDecrement((LONG*) &m_cRef);
    if (cref == 0)
    {
        delete this;
    }
    return cref;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\xmltable\sdtxml.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
//  SDTxml.cpp : Implementation of CXmlSDT

#include "precomp.hxx"

//  This is a read/write data table that comes from an XML document.

extern HMODULE g_hModule;

TXmlParsedFileCache CXmlSDT::m_XmlParsedFileCache;
CSafeAutoCriticalSection  CXmlSDT::m_SACriticalSection_XmlParsedFileCache;
const VARIANT_BOOL  CXmlSDT::kvboolTrue = -1;
const VARIANT_BOOL  CXmlSDT::kvboolFalse=  0;

LONG                CXmlSDT::m_InsertUnique=0x00490056;

#define LOG_POPULATE_ERROR1(x, hr, str1)     LOG_ERROR(Interceptor,(&m_spISTError.p,                       /*ppErrInterceptor*/ \
                                                                    m_pISTDisp,                            /*pDisp           */ \
                                                                    hr,                                    /*hrErrorCode     */ \
                                                                    ID_CAT_CAT,                            /*ulCategory      */ \
                                                                    x,                                     /*ulEvent         */ \
                                                                    str1,                                  /*szString1       */ \
                                                                    eSERVERWIRINGMETA_Core_XMLInterceptor, /*ulInterceptor   */ \
                                                                    m_wszTable,                            /*szTable         */ \
                                                                    eDETAILEDERRORS_Populate,              /*OperationType   */ \
                                                                    (ULONG) -1,                                    /*ulRow           */ \
                                                                    (ULONG) -1,                                    /*ulColumn        */ \
                                                                    m_wszURLPath,                          /*szConfigSource  */ \
                                                                    eDETAILEDERRORS_ERROR,                 /*eType           */ \
                                                                    0,                                     /*pData           */ \
                                                                    0,                                     /*cbData          */ \
                                                                    0,                                     /*MajorVersion    */ \
                                                                    0))                                    /*MinorVersion    */

#define LOG_POPULATE_ERROR4(x, hr, str1, str2, str3, str4)  LOG_ERROR(Interceptor,                                              \
                                                                   (&m_spISTError.p,                       /*ppErrInterceptor*/ \
                                                                    m_pISTDisp,                            /*pDisp           */ \
                                                                    hr,                                    /*hrErrorCode     */ \
                                                                    ID_CAT_CAT,                            /*ulCategory      */ \
                                                                    x,                                     /*ulEvent         */ \
                                                                    str1,                                  /*szString1       */ \
                                                                    str2,                                  /*szString2       */ \
                                                                    str3,                                  /*szString3       */ \
                                                                    str4,                                  /*szString4       */ \
                                                                    eSERVERWIRINGMETA_Core_XMLInterceptor, /*ulInterceptor   */ \
                                                                    m_wszTable,                            /*szTable         */ \
                                                                    eDETAILEDERRORS_Populate,              /*OperationType   */ \
                                                                    (ULONG) -1,                                    /*ulRow           */ \
                                                                    (ULONG) -1,                                    /*ulColumn        */ \
                                                                    m_wszURLPath,                          /*szConfigSource  */ \
                                                                    eDETAILEDERRORS_ERROR,                 /*eType           */ \
                                                                    0,                                     /*pData           */ \
                                                                    0,                                     /*cbData          */ \
                                                                    (ULONG) -1,                                    /*MajorVersion    */ \
                                                                    (ULONG) -1))                                   /*MinorVersion    */

#define LOG_UPDATE_ERROR1(x, hr, col, str1)     LOG_ERROR(Interceptor,(&m_spISTError.p,                       /*ppErrInterceptor*/ \
                                                                    m_pISTDisp,                            /*pDisp           */ \
                                                                    hr,                                    /*hrErrorCode     */ \
                                                                    ID_CAT_CAT,                            /*ulCategory      */ \
                                                                    x,                                     /*ulEvent         */ \
                                                                    str1,                                  /*szString1       */ \
                                                                    eSERVERWIRINGMETA_Core_XMLInterceptor, /*ulInterceptor   */ \
                                                                    m_wszTable,                            /*szTable         */ \
                                                                    eDETAILEDERRORS_UpdateStore,           /*OperationType   */ \
                                                                    m_iCurrentUpdateRow,                   /*ulRow           */ \
                                                                    col,                                   /*ulColumn        */ \
                                                                    m_wszURLPath,                          /*szConfigSource  */ \
                                                                    eDETAILEDERRORS_ERROR,                 /*eType           */ \
                                                                    0,                                     /*pData           */ \
                                                                    0,                                     /*cbData          */ \
                                                                    (ULONG) -1,                                    /*MajorVersion    */ \
                                                                    (ULONG) -1))                                   /*MinorVersion    */

#define LOG_UPDATE_ERROR2(x, hr, col, str1, str2)   LOG_ERROR(Interceptor,(&m_spISTError.p,                       /*ppErrInterceptor*/ \
                                                                    m_pISTDisp,                            /*pDisp           */ \
                                                                    hr,                                    /*hrErrorCode     */ \
                                                                    ID_CAT_CAT,                            /*ulCategory      */ \
                                                                    x,                                     /*ulEvent         */ \
                                                                    str1,                                  /*szString1       */ \
                                                                    str2,                                  /*szString2       */ \
                                                                    eSERVERWIRINGMETA_Core_XMLInterceptor, /*ulInterceptor   */ \
                                                                    m_wszTable,                            /*szTable         */ \
                                                                    eDETAILEDERRORS_UpdateStore,           /*OperationType   */ \
                                                                    m_iCurrentUpdateRow,                   /*ulRow           */ \
                                                                    col,                                   /*ulColumn        */ \
                                                                    m_wszURLPath,                          /*szConfigSource  */ \
                                                                    eDETAILEDERRORS_ERROR,                 /*eType           */ \
                                                                    0,                                     /*pData           */ \
                                                                    0,                                     /*cbData          */ \
                                                                    (ULONG) -1,                                    /*MajorVersion    */ \
                                                                    (ULONG) -1))                                   /*MinorVersion    */

HRESULT TXmlSDTBase::GetURLFromString(LPCWSTR wsz)
{
    if(NULL == wsz)
        return E_ST_OMITDISPENSER;

    m_wszURLPath[m_kcwchURLPath-1] = 0x00;//make sure it's NULL terminated
    wcsncpy(m_wszURLPath, wsz, m_kcwchURLPath);

    if(m_wszURLPath[m_kcwchURLPath-1] != 0x00)
        return E_ST_OMITDISPENSER;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CXmlSDT
// Constructor and destructor
// ==================================================================
CXmlSDT::CXmlSDT() :
                m_acolmetas(0)
                ,m_apValue(0)
                ,m_BaseElementLevel(0)
                ,m_bAtCorrectLocation(true)
                ,m_bEnumPublicRowName_ContainedTable_ParentFound(false)
                ,m_bEnumPublicRowName_NotContainedTable_ParentFound(false)
                ,m_bInsideLocationTag(false)
                ,m_bIsFirstPopulate(true)
                ,m_bMatchingParentOfBasePublicRowElement(true)
                ,m_bSiblingContainedTable(false)
                ,m_bValidating(true)
                ,m_cCacheHit(0)
                ,m_cCacheMiss(0)
                ,m_cchLocation(0)
                ,m_cchTablePublicName(0)
                ,m_cPKs(0)
                ,m_cRef(0)
                ,m_cTagMetaValues(0)
                ,m_fCache(0)
                ,m_iCurrentUpdateRow((ULONG)-1)
                ,m_iPublicRowNameColumn((ULONG)-1)
                ,m_IsIntercepted(0)
                ,m_iCol_TableRequiresAdditionChildElement((ULONG)-1)
                ,m_iSortedColumn(0)
                ,m_iSortedFirstChildLevelColumn((ULONG)-1)
                ,m_iSortedFirstParentLevelColumn((ULONG)-1)
                ,m_iXMLBlobColumn((ULONG)-1)
                ,m_LevelOfBasePublicRow(0)
                ,m_one(1)
                ,m_kPrime(97)
                ,m_kXMLSchemaName(L"ComCatMeta_v6")
                ,m_fLOS(0)
                ,m_pISTDisp(0)
                ,m_pISTW2(0)
                ,m_two(2)
                ,m_wszTable(0)
                ,m_pXmlParsedFile(0)
{
    m_wszURLPath[0] = 0x00;
    memset(&m_TableMetaRow, 0x00, sizeof(m_TableMetaRow));
}

// ==================================================================
CXmlSDT::~CXmlSDT()
{
    if(m_acolmetas && m_aQuery)
        for(unsigned long iColumn=0; iColumn<CountOfColumns(); ++iColumn)
        {
            switch(m_acolmetas[iColumn].dbType)
            {
            case DBTYPE_UI4:
                delete reinterpret_cast<ULONG *>(m_aQuery[iColumn].pData);
                break;
            case DBTYPE_WSTR:
                delete [] reinterpret_cast<LPWSTR>(m_aQuery[iColumn].pData);
                break;
            }
        }

    if(m_apValue)
        for(unsigned long iColumn=0; iColumn<CountOfColumns(); ++iColumn)
            delete [] m_apValue[iColumn];
}



HRESULT CXmlSDT::AppendNewLineWithTabs(ULONG cTabs, IXMLDOMDocument * pXMLDoc, IXMLDOMNode * pNodeToAppend, ULONG cNewlines)
{
    ASSERT(cTabs<200);
    ASSERT(cNewlines<25);

    HRESULT hr;

    WCHAR wszNewlineWithTabs[256];
    WCHAR *pwszCurrent = wszNewlineWithTabs;

    //This makes the table element tabbed in once.  The 0th sorted column tells how deep to additionally tab in.
    while(cNewlines--)
    {
        *pwszCurrent++ = L'\r';
        *pwszCurrent++ = L'\n';
    }

    while(cTabs--)
        *pwszCurrent++ = L'\t';

    *pwszCurrent = 0x00;//NULL terminate it

    CComPtr<IXMLDOMText>    pNode_Newline;
    TComBSTR                bstrNewline(wszNewlineWithTabs);
    if(FAILED(hr = pXMLDoc->createTextNode(bstrNewline, &pNode_Newline)))return hr;
    return pNodeToAppend->appendChild(pNode_Newline, 0);
}


//This is called recursively
HRESULT CXmlSDT::BuildXmlBlob(const TElement * i_pElement, WCHAR * &io_pBuffer, ULONG & io_cchBlobBufferSize, ULONG & io_cchInBlob) const
{
    HRESULT hr;
    ULONG   ulLevelOfBlobRoot = i_pElement->m_LevelOfElement;

    while(i_pElement && i_pElement->IsValid() && i_pElement->m_LevelOfElement>=ulLevelOfBlobRoot)
    {
        switch(i_pElement->m_ElementType)
        {
        case XML_COMMENT:
            {
                // ASSERT(i_pElement->m_LevelOfElement > pElementThis->m_LevelOfElement);//we can't have a comment at the same level

                ULONG cchSizeRequired = 7+io_cchInBlob+i_pElement->m_ElementNameLength;
                if(cchSizeRequired > io_cchBlobBufferSize)
                {
                    io_cchBlobBufferSize = ((cchSizeRequired *2) + 0xFFF) & -0x1000;//double and round up to the next page boundary
                    io_pBuffer = reinterpret_cast<WCHAR *>(CoTaskMemRealloc(io_pBuffer, io_cchBlobBufferSize*sizeof(WCHAR)));
                    if(0 == io_pBuffer)
                        return E_OUTOFMEMORY;
                }
                io_pBuffer[io_cchInBlob++] = L'<';
                io_pBuffer[io_cchInBlob++] = L'!';
                io_pBuffer[io_cchInBlob++] = L'-';
                io_pBuffer[io_cchInBlob++] = L'-';

                memcpy(io_pBuffer+io_cchInBlob, i_pElement->m_ElementName, i_pElement->m_ElementNameLength * sizeof(WCHAR));
                io_cchInBlob += i_pElement->m_ElementNameLength;

                io_pBuffer[io_cchInBlob++] = L'-';
                io_pBuffer[io_cchInBlob++] = L'-';
                io_pBuffer[io_cchInBlob++] = L'>';
            }
            break;
        case XML_ELEMENT:
            {
                if(fEndTag == (i_pElement->m_NodeFlags & fBeginEndTag))//if we found the end tag
                {
                    //Now fill out the closing tag for this element
                    ULONG cchSizeRequired = 3+io_cchInBlob+i_pElement->m_ElementNameLength;
                    if(cchSizeRequired > io_cchBlobBufferSize)
                    {
                        io_cchBlobBufferSize = ((cchSizeRequired *2) + 0xFFF) & -0x1000;//double and round up to the next page boundary
                        io_pBuffer = reinterpret_cast<WCHAR *>(CoTaskMemRealloc(io_pBuffer, io_cchBlobBufferSize*sizeof(WCHAR)));
                        if(0 == io_pBuffer)
                            return E_OUTOFMEMORY;
                    }
                    //Full closing tag  (ie <Element attr="foo">x</Element>)
                    io_pBuffer[io_cchInBlob++] = L'<';
                    io_pBuffer[io_cchInBlob++] = L'/';

                    memcpy(io_pBuffer+io_cchInBlob, i_pElement->m_ElementName, i_pElement->m_ElementNameLength * sizeof(WCHAR));
                    io_cchInBlob += i_pElement->m_ElementNameLength;

                    io_pBuffer[io_cchInBlob++] = L'>';
                    if(i_pElement->m_LevelOfElement==ulLevelOfBlobRoot)
                        goto exit;
                }
                else //begin tag (or maybe and begin/end tag)
                {
                    ULONG cchSizeRequired = io_cchInBlob+2+i_pElement->m_ElementNameLength;//+2 so we have room for the '/>'
                    if(cchSizeRequired > io_cchBlobBufferSize)
                    {
                        io_cchBlobBufferSize = ((cchSizeRequired *2) + 0xFFF) & -0x1000;//double and round up to the next page boundary
                        io_pBuffer = reinterpret_cast<WCHAR *>(CoTaskMemRealloc(io_pBuffer, io_cchBlobBufferSize*sizeof(WCHAR)));
                        if(0 == io_pBuffer)
                            return E_OUTOFMEMORY;
                    }
                    //Start building the XML Blob from this element
                    io_pBuffer[io_cchInBlob++] = L'<';
                    memcpy(io_pBuffer+io_cchInBlob, i_pElement->m_ElementName, i_pElement->m_ElementNameLength * sizeof(WCHAR));
                    io_cchInBlob += i_pElement->m_ElementNameLength;

                    for(ULONG iAttr=0;iAttr<i_pElement->m_NumberOfAttributes;++iAttr)
                    {
                        //Do we need to grow the buffer (the 5 is for the 4 chars inside the for loop, and one more for the L'>'). The 7 is to account for the
                        //possibility that ALL characters need to be escaped.
                        ULONG cchSizeRequiredLocal = 5+io_cchInBlob+i_pElement->m_aAttribute[iAttr].m_NameLength+7*(i_pElement->m_aAttribute[iAttr].m_ValueLength);
                        if(cchSizeRequiredLocal > io_cchBlobBufferSize)
                        {
                            io_cchBlobBufferSize = ((cchSizeRequiredLocal *2) + 0xFFF) & -0x1000;//double and round up to the next page boundary
                            io_pBuffer = reinterpret_cast<WCHAR *>(CoTaskMemRealloc(io_pBuffer, io_cchBlobBufferSize*sizeof(WCHAR)));
                            if(0 == io_pBuffer)
                                return E_OUTOFMEMORY;
                        }

                        io_pBuffer[io_cchInBlob++] = L' ';
                        memcpy(io_pBuffer+io_cchInBlob, i_pElement->m_aAttribute[iAttr].m_Name, i_pElement->m_aAttribute[iAttr].m_NameLength * sizeof(WCHAR));
                        io_cchInBlob += i_pElement->m_aAttribute[iAttr].m_NameLength;
                        io_pBuffer[io_cchInBlob++] = L'=';
                        io_pBuffer[io_cchInBlob++] = L'\"';
                        //if non of the characters are escaped chars then it's just a memcpy
                        ULONG cchCopied;
                        if(FAILED(hr = MemCopyPlacingInEscapedChars(io_pBuffer+io_cchInBlob, i_pElement->m_aAttribute[iAttr].m_Value, i_pElement->m_aAttribute[iAttr].m_ValueLength, cchCopied)))
                            return hr;
                        io_cchInBlob += cchCopied;
                        io_pBuffer[io_cchInBlob++] = L'\"';
                    }
                    if(fBeginEndTag == (i_pElement->m_NodeFlags & fBeginEndTag))
                        io_pBuffer[io_cchInBlob++] = L'/';
                    io_pBuffer[io_cchInBlob++] = L'>';
                }
            }
            break;
        case XML_WHITESPACE://and it's treated exactly like whitespaces
            {
                ULONG cchSizeRequired = io_cchInBlob+i_pElement->m_ElementNameLength;
                if(cchSizeRequired > io_cchBlobBufferSize)
                {
                    io_cchBlobBufferSize = ((cchSizeRequired *2) + 0xFFF) & -0x1000;//double and round up to the next page boundary
                    io_pBuffer = reinterpret_cast<WCHAR *>(CoTaskMemRealloc(io_pBuffer, io_cchBlobBufferSize*sizeof(WCHAR)));
                    if(0 == io_pBuffer)
                        return E_OUTOFMEMORY;
                }
                memcpy(io_pBuffer+io_cchInBlob, i_pElement->m_ElementName, i_pElement->m_ElementNameLength * sizeof(WCHAR));
                io_cchInBlob += i_pElement->m_ElementNameLength;
            }
            break;
        case XML_PCDATA:    //PCDATA in this context means Element Content
            {                                        //account for escaped characters so worst case is every character is escaped to 7 characters.
                ULONG cchSizeRequired = io_cchInBlob+7*(i_pElement->m_ElementNameLength);
                if(cchSizeRequired > io_cchBlobBufferSize)
                {
                    io_cchBlobBufferSize = ((cchSizeRequired *2) + 0xFFF) & -0x1000;//double and round up to the next page boundary
                    io_pBuffer = reinterpret_cast<WCHAR *>(CoTaskMemRealloc(io_pBuffer, io_cchBlobBufferSize*sizeof(WCHAR)));
                    if(0 == io_pBuffer)
                        return E_OUTOFMEMORY;
                }
                ULONG cchCopied;
                if(FAILED(hr = MemCopyPlacingInEscapedChars(io_pBuffer+io_cchInBlob, i_pElement->m_ElementName, i_pElement->m_ElementNameLength, cchCopied)))
                    return hr;
                io_cchInBlob += cchCopied;
            }
            break;
        default:
            break;//do nothing with node types that we know nothing about
        }
        i_pElement = i_pElement->Next();
    }
exit:
    return S_OK;
}//BuildXmlBlob


HRESULT CXmlSDT::CreateNewNode(IXMLDOMDocument * i_pXMLDoc, IXMLDOMNode * i_pNode_Parent, IXMLDOMNode ** o_ppNode_New)
{
    HRESULT hr;

    //If there is no XMLBlob column, OR the XMLBlob column is NULL, then create one from scratch
    if(-1 == m_iXMLBlobColumn || 0 == m_apvValues[m_iXMLBlobColumn])
    {
        CComVariant varElement(L"element");

        TComBSTR    bstr_NameSpace;
        if(FAILED(hr = i_pNode_Parent->get_namespaceURI(&bstr_NameSpace)))
            return hr;//Get the namespace of the table

        if(!IsEnumPublicRowNameTable())
        {
            if(FAILED(hr = i_pXMLDoc->createNode(varElement, m_bstrPublicRowName, bstr_NameSpace, o_ppNode_New)))
                return hr;//make the new element of that same namespace
        }
        else //If we're using an enum as the public row name
        {
            ULONG ui4 = *reinterpret_cast<ULONG *>(m_apvValues[m_iPublicRowNameColumn]);
            ASSERT(0 != m_aTagMetaIndex[m_iPublicRowNameColumn].m_cTagMeta && "fCOLUMNMETA_ENUM bit set and have no TagMeta");//Not all columns have tagmeta, those elements of the array are set to a count of 0.  Assert this isn't one of those.
                                                 //It is Chewbacca to have the fCOLUMNMETA_ENUM bit set and have no TagMeta.
            unsigned long iTag, cTag;
            for(iTag = m_aTagMetaIndex[m_iPublicRowNameColumn].m_iTagMeta, cTag = m_aTagMetaIndex[m_iPublicRowNameColumn].m_cTagMeta;cTag;++iTag,--cTag)//TagMeta was queried for ALL columns, m_aTagMetaIndex[iColumn].m_iTagMeta indicates which row to start with and m_cTagMeta indicates the count (for this column)
            {
                if(*m_aTagMetaRow[iTag].pValue == ui4)
                {
                    CComBSTR bstrPublicRowName = m_aTagMetaRow[iTag].pPublicName;
                    if(FAILED(hr = i_pXMLDoc->createNode(varElement, bstrPublicRowName, bstr_NameSpace, o_ppNode_New)))
                        return hr;//make the new element of that same namespace
                    break;
                }
            }
            if(0 == cTag)
            {
                // IVANPASH BUG #563169
                // Because of the horrible implementation of _ultow Prefix is complaning about potential buffer overflow
                // in MultiByteToWideChar indirectly called by _ultow. To avoid the warning I am increasing
                // the size to 40 to match _ultow local buffer.
                WCHAR szUI4[40];
                szUI4[0] = szUI4[39] = L'\0';
                _ultow(ui4, szUI4, 10);
                LOG_UPDATE_ERROR2(IDS_COMCAT_XML_BOGUSENUMVALUEINWRITECACHE, E_SDTXML_INVALID_ENUM_OR_FLAG, m_iPublicRowNameColumn, m_abstrColumnNames[m_iPublicRowNameColumn].m_str, szUI4);
                return E_SDTXML_INVALID_ENUM_OR_FLAG;
            }
        }
    }
    else//Use the XMLBlob column value as the starting point to the new node
    {
        CComPtr<IXMLDOMDocument> spXmlDoc;
        if(FAILED(hr = CoCreateInstance(_CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, _IID_IXMLDOMDocument, (void**)&spXmlDoc)))
            return hr;

        CComBSTR                 bstrXmlBlob = reinterpret_cast<LPCWSTR>(m_apvValues[m_iXMLBlobColumn]);
        VARIANT_BOOL             bSuccess;
        if(FAILED(hr = spXmlDoc->loadXML(bstrXmlBlob, &bSuccess)))
            return hr;
        if(bSuccess != kvboolTrue)//If the XMLBlob fails to parse, then fail
            return E_SDTXML_XML_FAILED_TO_PARSE;

        CComPtr<IXMLDOMElement>             spElementDoc;
        if(FAILED(hr = spXmlDoc->get_documentElement(&spElementDoc)))
            return hr;

        CComBSTR bstrElementName;
        if(FAILED(hr = spElementDoc->get_tagName(&bstrElementName)))
            return hr;

        if(!m_aPublicRowName[m_iXMLBlobColumn].IsEqual(bstrElementName.m_str, bstrElementName.Length()))
            return E_SDTXML_XML_FAILED_TO_PARSE;

        if(FAILED(hr = spElementDoc->QueryInterface(IID_IXMLDOMNode, reinterpret_cast<void **>(o_ppNode_New))))
            return hr;
    }
    return S_OK;
}


//=================================================================================
// Function: CXmlSDT::CreateStringFromMultiString
//
// Synopsis: Creates a string from a multistring. Every \0 is replaced with a pipe ('|')
//           symbol, and every '|' symbol is escaped with another '|' symbol
//
// Arguments: [i_wszMulti] - multi string to convert
//            [o_pwszString] - string that represents the multistring. Caller is
//                             responsible for deleting the string
//
//=================================================================================
HRESULT
CXmlSDT::CreateStringFromMultiString(LPCWSTR i_wszMulti, LPWSTR * o_pwszString) const
{
    ASSERT (i_wszMulti != 0);
    ASSERT (o_pwszString != 0);

    // initialize the output variable
    *o_pwszString = 0;

    // get the length of the multistring
    SIZE_T iLen = 0;
    for (LPCWSTR pCur = i_wszMulti; *pCur != L'\0'; pCur = i_wszMulti + iLen)
    {
         iLen += wcslen (pCur) + 1;
    }

    if (iLen == 0)
        return S_OK;

    // because '|' is replace by '||', we need to allocate twice the amount of memory
    *o_pwszString = new WCHAR [iLen * 2];
    if (*o_pwszString == 0)
    {
        return E_OUTOFMEMORY;
    }

    ULONG insertIdx=0;
    for (ULONG idx = 0; idx < iLen; ++idx)
    {
        switch (i_wszMulti[idx])
        {
        case L'|':
            // add additional pipe character
            (*o_pwszString)[insertIdx++] = L'|';
            break;

        case L'\0':
            // pipe character is separator
            (*o_pwszString)[insertIdx++] = L'|';
            continue;

        default:
            // do nothing;
            break;
        }
        (*o_pwszString)[insertIdx++] = i_wszMulti[idx];
    }


    // replace last char with null terminator
    (*o_pwszString)[insertIdx-1] = L'\0';

    return S_OK;
}


HRESULT CXmlSDT::FillInColumn(ULONG iColumn, LPCWSTR pwcText, ULONG ulLen, ULONG dbType, ULONG MetaFlags, bool &bMatch)
{
    HRESULT hr;
    //length of 0 on a string means a 0 length string, for every other type it means NULL
    if(0==ulLen && DBTYPE_WSTR!=dbType)
    {
        delete [] m_apValue[iColumn];
        m_aSize[iColumn] = 0;
        m_apValue[iColumn] = 0;
		bMatch = true;
        return S_OK;
    }

    switch(dbType)                          //This is to prevent string compare from AVing on NULL parameter.
    {
    case DBTYPE_UI4:
        {
            DWORD       ui4;
            if(FAILED(hr = GetColumnValue(iColumn, pwcText, ui4, ulLen)))return hr;
            //If the Query's dbType is 0 then we're not querying this column, so consider it a match
            bMatch = (0 == m_aQuery[iColumn].dbType || *reinterpret_cast<ULONG *>(m_aQuery[iColumn].pData) == ui4);
            if( bMatch )
            {
                delete [] m_apValue[iColumn];
                m_aSize[iColumn] = 0;
                m_apValue[iColumn] = new unsigned char [sizeof(ULONG)];
                if(0 == m_apValue[iColumn])
                    return E_OUTOFMEMORY;
                if(MetaFlags & fCOLUMNMETA_FIXEDLENGTH)
                    m_aSize[iColumn] = sizeof(ULONG);
                memcpy(m_apValue[iColumn], &ui4, sizeof(ULONG));
            }
            break;
        }
    case DBTYPE_WSTR:
        if(MetaFlags & fCOLUMNMETA_MULTISTRING)
        {
            bMatch = (0 == m_aQuery[iColumn].dbType || 0 == MemWcharCmp(iColumn, reinterpret_cast<LPWSTR>(m_aQuery[iColumn].pData), pwcText, ulLen));
            if( bMatch )
            {
                delete [] m_apValue[iColumn];
                m_aSize[iColumn] = 0;
                m_apValue[iColumn] = new unsigned char [(ulLen + 2) * sizeof(WCHAR)];//ulLen + 2.  Since this is a multisz we need two NULLs at the end (this is worst case, single string needing a second NULL)
                if(0 == m_apValue[iColumn])
                    return E_OUTOFMEMORY;

                LPWSTR pMultiSZ = reinterpret_cast<LPWSTR>(m_apValue[iColumn]);

                //Now convert the '|'s to NULLs and conver the "||"s to '|'
                for(ULONG iMultiSZ=0; iMultiSZ<ulLen; ++iMultiSZ)
                {
                    if(pwcText[iMultiSZ] != L'|')
                        *pMultiSZ++ = pwcText[iMultiSZ];
                    else if(pwcText[iMultiSZ+1] == L'|')
                    {
                        *pMultiSZ++ = L'|';//Bump the index again, this is the only double character that gets mapped to a single character
                        ++iMultiSZ;
                    }
                    else
                        *pMultiSZ++ = 0x00;
                }
                *pMultiSZ++ = 0x00;
                *pMultiSZ++ = 0x00;
                m_aSize[iColumn] = (ULONG) ((reinterpret_cast<unsigned char *>(pMultiSZ) - reinterpret_cast<unsigned char *>(m_apValue[iColumn])));
            }
            break;
        }
        else
        {
            bMatch = false;
            if (0 == m_aQuery[iColumn].dbType)
            {
                bMatch = true;
            }
            else
            {
                LPCWSTR wszData = reinterpret_cast<LPWSTR>(m_aQuery[iColumn].pData);
                if ((wcslen (wszData) == ulLen) &&
                    (0 == MemWcharCmp(iColumn, wszData, pwcText, ulLen)))
                {
                    bMatch = true;
                }
            }

            if (bMatch)
            {
                delete [] m_apValue[iColumn];
                m_aSize[iColumn] = 0;
                m_apValue[iColumn] = new unsigned char [(ulLen + 1) * sizeof(WCHAR)];
                if(0 == m_apValue[iColumn])
                    return E_OUTOFMEMORY;
                reinterpret_cast<LPWSTR>(m_apValue[iColumn])[ulLen] = 0;//NULL terminate the thing
                if(MetaFlags & fCOLUMNMETA_FIXEDLENGTH)
                    m_aSize[iColumn] = (ulLen + 1) * sizeof(WCHAR);
                memcpy(m_apValue[iColumn], pwcText, ulLen * sizeof(WCHAR));
            }
            break;
        }
    case DBTYPE_GUID:
        {
            GUID        guid;
            if(FAILED(hr = GetColumnValue(iColumn, pwcText, guid, ulLen)))return hr;
            bMatch = (0 == m_aQuery[iColumn].dbType || 0 == memcmp(m_aQuery[iColumn].pData, &guid, sizeof(GUID)));
            if( bMatch )
            {
                delete [] m_apValue[iColumn];
                m_aSize[iColumn] = 0;
                m_apValue[iColumn] = new unsigned char [sizeof(GUID)];
                if(0 == m_apValue[iColumn])
                    return E_OUTOFMEMORY;
                if(MetaFlags & fCOLUMNMETA_FIXEDLENGTH)
                    m_aSize[iColumn] = sizeof(GUID);
                memcpy(m_apValue[iColumn], &guid, sizeof(GUID));
            }
            break;
        }

    case DBTYPE_BYTES:
        {//Some of the tables use this data type but the parser returns the BYTES as a string.  We'll have to convert the string to hex ourselves.
            delete [] m_apValue[iColumn];
            m_apValue[iColumn] = 0;
            m_aSize[iColumn] = 0;
            if(FAILED(hr = GetColumnValue(iColumn, pwcText, m_apValue[iColumn], m_aSize[iColumn], ulLen)))return hr;
            bMatch = (0 == m_aQuery[iColumn].dbType || (m_aQuery[iColumn].cbSize == m_aSize[iColumn] && 0 == memcmp(m_aQuery[iColumn].pData, m_apValue[iColumn], m_aSize[iColumn])));
            break;
        }
    default:
        {
            ASSERT(false && "SDTXML - An Unsupported data type was specified\r\n");
            return E_SDTXML_NOTSUPPORTED;//An Unsupported data type was specified
        }
    }
    return S_OK;
}


HRESULT CXmlSDT::FillInPKDefaultValue(ULONG i_iColumn, bool & o_bMatch)
{
    ASSERT(0 == m_apValue[i_iColumn]);

    o_bMatch = true;
    //Should the value be Defaulted
    if(     (m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_PRIMARYKEY)
        &&  0 == (m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_MULTISTRING)//we don't deal with MultiSZ PK DefaultValues
        &&  (DBTYPE_BYTES != m_acolmetas[i_iColumn].dbType)//we don't want to deal with the acbSizes issue, so we don't support defaulting DBTYPE_BYTES PK columns
        &&  (0 != m_aDefaultValue[i_iColumn]))
    {
        ASSERT(0 != m_acbDefaultValue[i_iColumn]);//if we have a NON-NULL PK default value pointer, then we have to have a valid size
        m_apValue[i_iColumn] = new unsigned char [m_acbDefaultValue[i_iColumn]];
        if(0 == m_apValue[i_iColumn])
            return E_OUTOFMEMORY;
        memcpy(m_apValue[i_iColumn], m_aDefaultValue[i_iColumn], m_acbDefaultValue[i_iColumn]);
    }

    if(     fCOLUMNMETA_NOTNULLABLE == (m_acolmetas[i_iColumn].fMeta & (fCOLUMNMETA_NOTNULLABLE | fCOLUMNMETA_NOTPERSISTABLE))
        &&  (0 == m_apValue[i_iColumn]) && (0 == m_aDefaultValue[i_iColumn])) //NOTNULLABLE but the value is NULL and the DefaultValue is NULL, then error
    {
        LOG_POPULATE_ERROR1(IDS_COMCAT_XML_NOTNULLABLECOLUMNISNULL, E_ST_VALUENEEDED, m_awstrColumnNames[i_iColumn]);
        return E_ST_VALUENEEDED;
    }

    //The only way m_apValue[i_iColumn] can be NON NULL is for the above code to have filled it in.

    if(0 != m_aQuery[i_iColumn].dbType)//This indicates that there is a query to be considered
    {
        if(0 != m_aQuery[i_iColumn].pData)//a non NULL value
        {
            if(0 == m_apValue[i_iColumn] && 0 == m_aDefaultValue[i_iColumn])
                o_bMatch = false;//if the query data is NOT NULL but the column IS NULL, then no match
            else
            {
                ASSERT(m_aDefaultValue[i_iColumn]);//We CAN'T have a NON NULL m_apValue and have a NULL DefaultValue.

                //if both the query and the value are NOT NULL, then we need to compare
                //PKs have their default value filled in here; but NON PKs are set to NULL and the fast cache defaults them
                //either way we'll comepare the default value with the query to see if it's a match

                //Now that we've defaulted the PK value, we need to check to see if it matches the Query (if one was given)
                switch(m_acolmetas[i_iColumn].dbType)
                {
                case DBTYPE_UI4:
                    o_bMatch = (*reinterpret_cast<ULONG *>(m_aQuery[i_iColumn].pData) == *reinterpret_cast<ULONG *>(m_aDefaultValue[i_iColumn]));
                    break;
                case DBTYPE_WSTR:
                    ASSERT(0 == (m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_MULTISTRING));//We don't support query by MULTISZ
                    o_bMatch = (0==StringCompare(i_iColumn, reinterpret_cast<LPCWSTR>(m_aQuery[i_iColumn].pData), reinterpret_cast<LPCWSTR>(m_aDefaultValue[i_iColumn])));
                    break;
                case DBTYPE_BYTES:
                    o_bMatch =      (m_aQuery[i_iColumn].cbSize == m_acbDefaultValue[i_iColumn])
                                &&  (0 == memcmp(m_aQuery[i_iColumn].pData, m_aDefaultValue[i_iColumn], m_acbDefaultValue[i_iColumn]));
                    break;
                default:
                    ASSERT(false && "Query By unsupported type");//consider it a match
                    break;
                }
            }
        }
        else if(0 == m_aQuery[i_iColumn].pData && (0 != m_apValue[i_iColumn]) || (0 != m_aDefaultValue[i_iColumn]))
           o_bMatch = false;//if the query data is NULL but the column is NOT NULL, then no match
    }

    return S_OK;
}

HRESULT CXmlSDT::FillInXMLBlobColumn(const TElement & i_Element, bool & o_bMatch)
{
    //XML Blob column is this entire element, it's contents, it's children, and it's closing tag
    ULONG                       cchInBlob           = 0;
    ULONG                       cchBlobBufferSize   = 0x1000;//4k buffer to start with
    HRESULT                     hr;
    TSmartPointerArray<WCHAR>   saBlob = reinterpret_cast<WCHAR *>(CoTaskMemAlloc(cchBlobBufferSize * sizeof(WCHAR)));
    if(0 == saBlob.m_p)
        return E_OUTOFMEMORY;

    const TElement * pElement = &i_Element;
    if(FAILED(hr = BuildXmlBlob(pElement, saBlob.m_p, cchBlobBufferSize, cchInBlob)))
        return hr;

    return FillInColumn(m_iXMLBlobColumn, saBlob, cchInBlob, DBTYPE_WSTR, m_acolmetas[m_iXMLBlobColumn].fMeta, o_bMatch);
}


HRESULT CXmlSDT::FindSiblingParentNode(IXMLDOMElement * i_pElementRoot, IXMLDOMNode ** o_ppNode_SiblingParent)
{
    HRESULT hr;

    *o_ppNode_SiblingParent = 0;

    ASSERT(m_aPublicRowName[m_aColumnsIndexSortedByLevel[m_iSortedFirstParentLevelColumn]].GetFirstPublicRowName() ==
           m_aPublicRowName[m_aColumnsIndexSortedByLevel[m_iSortedFirstParentLevelColumn]].GetLastPublicRowName());//This parent element may not be EnumPublicRowName (for now)

    CComBSTR bstrSiblingParentRowName = m_aPublicRowName[m_aColumnsIndexSortedByLevel[m_iSortedFirstParentLevelColumn]].GetFirstPublicRowName();

    CComPtr<IXMLDOMNodeList> spNodeList_SiblingParent;
    //if the sibling parent doesn't exist then fail
    if(FAILED(i_pElementRoot->getElementsByTagName(bstrSiblingParentRowName, &spNodeList_SiblingParent))
                    || 0==spNodeList_SiblingParent.p)
    {                                                                                               /*-1 indicates 'no column'*/
        LOG_UPDATE_ERROR1(IDS_COMCAT_XML_PARENTTABLEDOESNOTEXIST, E_SDTXML_PARENT_TABLE_DOES_NOT_EXIST, (ULONG) -1, bstrSiblingParentRowName);
        return E_SDTXML_PARENT_TABLE_DOES_NOT_EXIST;
    }

    if(0 == m_cchLocation)//if there is no query by location, then we have to eliminate the tags by the correct
    {                     //name but at the wrong level
        CComPtr<IXMLDOMNodeList> spNodeListWithoutLocation;
        if(FAILED(hr = ReduceNodeListToThoseNLevelsDeep(spNodeList_SiblingParent, m_BaseElementLevel, &spNodeListWithoutLocation)))
            return hr;

        spNodeList_SiblingParent.Release();
        spNodeList_SiblingParent = spNodeListWithoutLocation;
    }

    while(true)//while we still have nodes in the list of SiblingParents.
    {
        CComPtr<IXMLDOMNode> spNode_SiblingParent;
        if(FAILED(hr = spNodeList_SiblingParent->nextNode(&spNode_SiblingParent)))
            return hr;
        if(0 == spNode_SiblingParent.p)//no locations
        {                                                                                           /*-1 indicates 'no column'*/
            LOG_UPDATE_ERROR1(IDS_COMCAT_XML_PARENTTABLEDOESNOTEXIST, E_SDTXML_PARENT_TABLE_DOES_NOT_EXIST, (ULONG) -1, L"");
            return E_SDTXML_PARENT_TABLE_DOES_NOT_EXIST;
        }

        ULONG iCurrentLevel=0;
        CComPtr<IXMLDOMNode> spNodeTemp = spNode_SiblingParent;
        //from this SiblingParent node, walk the ancestors, matching up the PKs
        bool bColumnMatch=true;
        ASSERT(-1 != m_iSortedFirstChildLevelColumn);
        for(int iSortedColumn=m_iSortedFirstChildLevelColumn-1; iSortedColumn!=-1 && bColumnMatch; --iSortedColumn)
        {
            ULONG iColumn   = m_aColumnsIndexSortedByLevel[iSortedColumn];

            while(iCurrentLevel < m_aLevelOfColumnAttribute[iColumn])
            {
                CComPtr<IXMLDOMNode> pNode_Parent;
                if(FAILED(hr = spNodeTemp->get_parentNode(&pNode_Parent)))
                    return hr;
                if(pNode_Parent==0)
                    return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;

                spNodeTemp.Release();
                spNodeTemp = pNode_Parent;
                ++iCurrentLevel;
            }

            //All columns from 0 to (m_iSortedFirstChildLevelColumn-1) MUST be PrimaryKeys
            ASSERT(m_acolmetas[iColumn].fMeta & fCOLUMNMETA_PRIMARYKEY);

            if(m_acolmetas[iColumn].fMeta & fCOLUMNMETA_NOTPERSISTABLE)
                continue;//if this PK is NOT persistable, then consider it a match and keep going

            CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> spElementTemp = spNodeTemp;
            if(0 == spElementTemp.p)
                return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;

            CComVariant varColumnValue;
            if(FAILED(spElementTemp->getAttribute(m_abstrColumnNames[iColumn], &varColumnValue)))
                return hr;//this is a persistable PK so it must exist

            if(FAILED(hr = IsMatchingColumnValue(iColumn, varColumnValue.bstrVal, bColumnMatch)))
                return hr;
        }
        if(bColumnMatch)
        {
            *o_ppNode_SiblingParent = spNode_SiblingParent.p;
            spNode_SiblingParent.p = 0;//prevent the smart pointer from releasing the interface
            return S_OK;
        }
        spNode_SiblingParent.Release();
    }
    return S_OK;
}


HRESULT CXmlSDT::GetColumnValue(unsigned long i_iColumn, LPCWSTR wszAttr, GUID &o_guid, unsigned long i_cchLen)
{
    UNREFERENCED_PARAMETER(i_iColumn);
    UNREFERENCED_PARAMETER(i_cchLen);

    if(RPC_S_OK != UuidFromString(const_cast<LPWSTR>(wszAttr), &o_guid))//Then convert it to a guid
        return E_ST_VALUEINVALID;
    return S_OK;
}


HRESULT CXmlSDT::GetColumnValue(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned char * &o_byArray, unsigned long &o_cbArray, unsigned long i_cchLen)
{
    HRESULT     hr;

    UNREFERENCED_PARAMETER(i_iColumn);
    UNREFERENCED_PARAMETER(i_cchLen);

    o_cbArray = (ULONG)wcslen(wszAttr)/2;//If someone has an odd number of characters in this attribute then the odd one will be ignored
    o_byArray = new unsigned char[o_cbArray];

    if(0 == o_byArray)
        return E_OUTOFMEMORY;

    if(FAILED(hr = StringToByteArray(wszAttr, o_byArray)))
    {
        LOG_POPULATE_ERROR1(IDS_COMCAT_XML_BOGUSBYTECHARACTER, E_ST_VALUEINVALID, wszAttr);
        return E_ST_VALUEINVALID;//E_SDTXML_BOGUSATTRIBUTEVALUE;
    }

    return S_OK;
}

int CXmlSDT::MemWcharCmp(ULONG i_iColumn, LPCWSTR i_str1, LPCWSTR i_str2, ULONG i_cch) const
{
    //It is safe to do the memcmp without verifying that the mem blocks are valid since
    //this is really like a str compare where one of the strings may not be NULL terminated.
    //We know that non of the strings are at the end of a segment since one always comes from
    //the XML cache, and the other comes from a static string or the Fixed tables heap.

	// the documenation of _memicmp says that it compare char's, which is correct. However, when
	// you want to compare WCHARs, you need to multiply with sizeof(WCHAR)
    if(m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_CASEINSENSITIVE)
        return _memicmp(i_str1, i_str2, i_cch * sizeof(WCHAR));

    return memcmp(i_str1, i_str2, i_cch*sizeof(WCHAR));
}



HRESULT CXmlSDT::GetColumnValue(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned long &o_ui4, unsigned long i_cchLen)
{
    if(m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_BOOL)
    {
        static WCHAR * kwszBoolStringsCaseInsensitive[] = {L"false", L"true", L"0", L"1", L"no", L"yes", L"off", L"on", 0};
        static WCHAR * kwszBoolStringsCaseSensitive[]   = {L"false", L"true", 0};

        WCHAR ** wszBoolStrings = kwszBoolStringsCaseSensitive;
        if(m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_CASEINSENSITIVE)
            wszBoolStrings = kwszBoolStringsCaseInsensitive;

        unsigned long iBoolString;
        if(i_cchLen)
        {
            for(iBoolString=0; wszBoolStrings[iBoolString] &&
                (0 != MemWcharCmp(i_iColumn, wszBoolStrings[iBoolString], wszAttr, i_cchLen)); ++iBoolString);
        }
        else
        {
            ULONG cchAttr = (ULONG)wcslen(wszAttr);//MemCmp needs a strlen
            for(iBoolString=0; wszBoolStrings[iBoolString] &&
                (0 != MemWcharCmp(i_iColumn, wszBoolStrings[iBoolString], wszAttr, cchAttr)); ++iBoolString);
        }

        if(0 == wszBoolStrings[iBoolString])
        {
			if(m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_CASEINSENSITIVE)
			{
				LOG_POPULATE_ERROR1(IDS_COMCAT_XML_BOGUSBOOLEANSTRING, E_ST_VALUEINVALID, wszAttr);
			}
			else
			{
				LOG_POPULATE_ERROR1(IDS_COMCAT_XML_BOGUSSTRICTBOOLEANSTRING, E_ST_VALUEINVALID, wszAttr);
			}
            return E_ST_VALUEINVALID;
        }

        o_ui4 = (iBoolString & 0x01);
    }
    else if(m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_ENUM)
    {
        ASSERT(0 != m_aTagMetaIndex[i_iColumn].m_cTagMeta);//Not all columns have tagmeta, those elements of the array are set to 0.  Assert this isn't one of those.

        for(unsigned long iTag = m_aTagMetaIndex[i_iColumn].m_iTagMeta, cTag = m_aTagMetaIndex[i_iColumn].m_cTagMeta; cTag;++iTag, --cTag)//m_pTagMeta was queried for ALL columns, m_aiTagMeta[iColumn] indicates which row to start with
        {
            ASSERT(*m_aTagMetaRow[iTag].pColumnIndex == i_iColumn);

            //string compare the tag to the PublicName of the Tag in the meta.
            if(i_cchLen)
            {
                if(0 == MemWcharCmp(i_iColumn, m_aTagMetaRow[iTag].pPublicName, wszAttr, i_cchLen))//NOTE: MemCmp 3rd param is cch NOT cb
                {  //As above, it's OK to memicmp since we'll stop at the terminating NULL, and we know that the string isn't located at the end of a segment
                    o_ui4 = *m_aTagMetaRow[iTag].pValue;
                    return S_OK;
                }
            }
            else
            {
                if(0 == StringCompare(i_iColumn, m_aTagMetaRow[iTag].pPublicName, wszAttr))
                {
                    o_ui4 = *m_aTagMetaRow[iTag].pValue;
                    return S_OK;
                }
            }
        }
        {
            WCHAR wszEnum[256];
            wcsncpy(wszEnum, wszAttr, (i_cchLen>0 && i_cchLen<256) ? i_cchLen : 255);
            wszEnum[255] = 0x00;//Make sure it's NULL terminated
            DBGPRINTF(( DBG_CONTEXT,
                        "Enum (%s) was not found in the TagMeta for Column %d (%s).", wszEnum, i_iColumn, m_awstrColumnNames[i_iColumn] ));
            LOG_POPULATE_ERROR4(IDS_COMCAT_XML_BOGUSENUMVALUE, E_SDTXML_INVALID_ENUM_OR_FLAG,
                            wszEnum,
                            m_aTagMetaRow[m_aTagMetaIndex[i_iColumn].m_iTagMeta].pPublicName,
                            m_aTagMetaIndex[i_iColumn].m_cTagMeta>1 ? m_aTagMetaRow[m_aTagMetaIndex[i_iColumn].m_iTagMeta+1].pPublicName : 0,
                            m_aTagMetaIndex[i_iColumn].m_cTagMeta>1 ? m_aTagMetaRow[m_aTagMetaIndex[i_iColumn].m_iTagMeta+2].pPublicName : 0);
        }
        return  E_SDTXML_INVALID_ENUM_OR_FLAG;
    }
    else if(m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_FLAG)
    {
        ASSERT(0 != m_aTagMetaIndex[i_iColumn].m_cTagMeta);//Not all columns have tagmeta, those elements of the array are set to 0.  Assert this isn't one of those.
        if(0==i_cchLen)
            i_cchLen = (ULONG) wcslen(wszAttr);

        TSmartPointerArray<wchar_t> szAttr = new wchar_t [i_cchLen+1];
        if (szAttr == 0)
            return E_OUTOFMEMORY;

        memcpy(szAttr, wszAttr, i_cchLen*sizeof(WCHAR));
        szAttr[i_cchLen]=0x00;
        LPWSTR wszTag = wcstok(szAttr, L" ,|\t\n\r");

        o_ui4 = 0;//flags start as zero
        unsigned long iTag = m_aTagMetaIndex[i_iColumn].m_iTagMeta;

        while(wszTag && iTag<(m_aTagMetaIndex[i_iColumn].m_iTagMeta + m_aTagMetaIndex[i_iColumn].m_cTagMeta))//m_pTagMeta was queried for ALL columns, m_aiTagMeta[iColumn] indicates which row to start with
        {
            ASSERT(*m_aTagMetaRow[iTag].pColumnIndex == i_iColumn);

            //string compare the tag to the PublicName of the Tag in the meta.
            if(0 == StringCompare(i_iColumn, m_aTagMetaRow[iTag].pPublicName, wszTag))
            {
                o_ui4 |= *m_aTagMetaRow[iTag].pValue;
                wszTag = wcstok(NULL, L" ,|\t\n\r");//next flag
                iTag = m_aTagMetaIndex[i_iColumn].m_iTagMeta;//reset the loop
            }
            else//if they're not equal then move on to the next TagMeta
                ++iTag;
        }
        if(wszTag)
        {
            LOG_POPULATE_ERROR4(IDS_COMCAT_XML_BOGUSFLAGVALUE, E_SDTXML_INVALID_ENUM_OR_FLAG,
                                wszAttr,
                                m_aTagMetaRow[m_aTagMetaIndex[i_iColumn].m_iTagMeta].pPublicName,
                                m_aTagMetaIndex[i_iColumn].m_cTagMeta>1 ? m_aTagMetaRow[m_aTagMetaIndex[i_iColumn].m_iTagMeta+1].pPublicName : 0,
                                m_aTagMetaIndex[i_iColumn].m_cTagMeta>1 ? m_aTagMetaRow[m_aTagMetaIndex[i_iColumn].m_iTagMeta+2].pPublicName : 0);
            return E_SDTXML_INVALID_ENUM_OR_FLAG;
        }
    }
    else
    {
        o_ui4 = static_cast<unsigned long>(wcstoul(wszAttr, 0, 10));
    }
    return S_OK;
}

//Get the UI4 value whether it's an enum, flag or regular ui4
HRESULT CXmlSDT::GetColumnValue(unsigned long i_iColumn, IXMLDOMAttribute * i_pAttr, GUID &o_guid)
{
    HRESULT hr;

    CComVariant var_Attr;
    if(FAILED(hr = i_pAttr->get_value(&var_Attr)))return hr;

    return GetColumnValue(i_iColumn, var_Attr.bstrVal, o_guid);
}


HRESULT CXmlSDT::GetColumnValue(unsigned long i_iColumn, IXMLDOMAttribute * i_pAttr, unsigned char * &o_byArray, unsigned long &o_cbArray)
{
    HRESULT hr;

    CComVariant          var_Attr;
    if(FAILED(hr = i_pAttr->get_value(&var_Attr)))return hr;

    return GetColumnValue(i_iColumn, var_Attr.bstrVal, o_byArray, o_cbArray);
}


//Get the UI4 value whether it's an enum, flag or regular ui4
HRESULT CXmlSDT::GetColumnValue(unsigned long i_iColumn, IXMLDOMAttribute * i_pAttr, unsigned long &o_ui4)
{
    HRESULT hr;

    CComVariant var_Attr;
    if(FAILED(hr = i_pAttr->get_value(&var_Attr)))return hr;

    return GetColumnValue(i_iColumn, var_Attr.bstrVal, o_ui4);
}


CXmlSDT::eESCAPE CXmlSDT::GetEscapeType(WCHAR i_wChar) const
{
    static eESCAPE kWcharToEscape[0x80] =
    {
      /* 00-0F */ eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEnone,          eESCAPEnone,          eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEnone,          eESCAPEillegalxml,    eESCAPEillegalxml,
      /* 10-1F */ eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,
      /* 20-2F */ eESCAPEnone,          eESCAPEnone,          eESCAPEquote,         eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEamp,           eESCAPEapos,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,
      /* 30-3F */ eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPElt,            eESCAPEnone,          eESCAPEgt,            eESCAPEnone,
      /* 40-4F */ eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,
      /* 50-5F */ eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,
      /* 60-6F */ eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,
      /* 70-7F */ eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone
    };

    if(i_wChar<=0x7F)
        return kWcharToEscape[i_wChar];

    if(i_wChar<=0xD7FF || (i_wChar>=0xE000 && i_wChar<=0xFFFD))
        return eESCAPEashex;

    return eESCAPEillegalxml;
}


HRESULT CXmlSDT::GetMatchingNode(IXMLDOMNodeList *pNodeList_ExistingRows, CComPtr<IXMLDOMNode> &pNode_Matching)
{
    if(*m_TableMetaRow.pMetaFlags & fTABLEMETA_OVERWRITEALLROWS)
        return S_FALSE;//All of the rows in the table should have already been removed.

    HRESULT hr;

    pNode_Matching.Release();//make sure it's NULL

    if(FAILED(hr = pNodeList_ExistingRows->reset()))return hr;

	ULONG cCountOfColumns = CountOfColumns ();

    while(true)//search each row trying to match all PKs
    {
        CComPtr<IXMLDOMNode> pNode_Row;
        if(FAILED(hr = pNodeList_ExistingRows->nextNode(&pNode_Row)))return hr;

        if(0 == pNode_Row.p)
            return S_FALSE;//no matching node found

        //We have to ignore text nodes.
        DOMNodeType nodetype;
        if(FAILED(hr = pNode_Row->get_nodeType(&nodetype)))return hr;
        if(NODE_ELEMENT != nodetype)
		{
            continue;
		}

        bool bMatch = true;
        unsigned long iSortedColumn=0;
        for(; iSortedColumn<cCountOfColumns && bMatch; ++iSortedColumn)//if we find a PK column that doesn't match then bail to the next row
        {
            unsigned long iColumn=m_aColumnsIndexSortedByLevel[iSortedColumn];
            if(m_acolmetas[iColumn].fMeta & fCOLUMNMETA_PRIMARYKEY)
            {
                CComPtr<IXMLDOMNode> pNode_RowTemp = pNode_Row;

                unsigned int nLevelOfColumnAttribute = m_aLevelOfColumnAttribute[iColumn];//Only (PK | FK) columns should have a non zero value here
                if(nLevelOfColumnAttribute>0)
                {
                    while(nLevelOfColumnAttribute--)
                    {
                        CComPtr<IXMLDOMNode> pNode_Parent;
                        if(FAILED(hr = pNode_RowTemp->get_parentNode(&pNode_Parent)))
                            return hr;
                        if(pNode_Parent==0)
                            return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;

                        pNode_RowTemp.Release();
                        pNode_RowTemp = pNode_Parent;
                    }
                }
                else if(m_bSiblingContainedTable
                                    && iSortedColumn>=m_iSortedFirstParentLevelColumn
                                    && iSortedColumn<m_iSortedFirstChildLevelColumn)
                {
                    CComPtr<IXMLDOMNode> pNode_Parent;
                    if(FAILED(hr = pNode_RowTemp->get_parentNode(&pNode_Parent)))
                        return hr;
                    if(pNode_Parent==0)
                        return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;

                    while(true)//find the previous sibling matching the public row name
                    {
                        CComPtr<IXMLDOMNode> pNode_Sibling;
                        if(FAILED(pNode_RowTemp->get_previousSibling(&pNode_Sibling)))
                            return S_OK;//if we run out of siblings then no matching node found
                        if(pNode_Sibling==0)
                            return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;

                        pNode_RowTemp.Release();
                        pNode_RowTemp = pNode_Sibling;

                        CComBSTR bstrNodeName;
                        if(FAILED(pNode_RowTemp->get_baseName(&bstrNodeName)))//if it's some sort of node that
                            continue;// doesn't have a baseName then it's not the element we're looking for

                        if(m_aPublicRowName[iColumn].IsEqual(bstrNodeName.m_str, bstrNodeName.Length()))
                            break;//if this sibling matches the PublicRowName then, we've found the correct 'parent' node.
                    }
                }

                if(m_awstrChildElementName[iColumn].c_str())//This attribute comes from the child
                {
                    CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> spElement_Row = pNode_RowTemp;
                    CComPtr<IXMLDOMNodeList>                        spNodeList_Children;
                    CComBSTR                                        bstrChildElementName = m_awstrChildElementName[iColumn].c_str();
                    if(0 == bstrChildElementName.m_str)
                        return E_OUTOFMEMORY;
                    if(FAILED(hr = spElement_Row->getElementsByTagName(bstrChildElementName, &spNodeList_Children)))
                        return hr;

                    //It might be more appropriate to use getChildren, then walk the list and find the first node that's an Element.
                    CComPtr<IXMLDOMNode> spChild;
                    if(FAILED(hr = spNodeList_Children->nextNode(&spChild)))
                        return hr;
                    if(spChild == 0)//no children
                    {
                        bMatch = false;
                        continue;
                    }
                    pNode_RowTemp.Release();
                    pNode_RowTemp = spChild;//make this the node we examine
                }

                CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement_Row = pNode_RowTemp;
                if(0 == pElement_Row.p)
                {
                    CComBSTR nodename;
                    if(SUCCEEDED(pNode_RowTemp->get_nodeName(&nodename)))
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                                    "QueryInterface failed on Node %s.",nodename.m_str ));
                    }

                    return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;
                }

                if(m_acolmetas[iColumn].fMeta & fCOLUMNMETA_NOTPERSISTABLE)
                {   //After we've located the correct level node, we can consider all PK NOTPERSITABLE columns as a match
                    CComBSTR bstrElementName;
                    if(FAILED(hr = pElement_Row->get_baseName(&bstrElementName)))
                        return hr;
                    bMatch = m_aPublicRowName[iColumn].IsEqual(bstrElementName.m_str, bstrElementName.Length());
                    continue;
                }

                if(0 == m_apvValues[iColumn])//NULL primarykeys are not supported
                {
                    LOG_UPDATE_ERROR1(IDS_COMCAT_XML_PRIMARYKEYISNULL, E_ST_VALUENEEDED, iColumn, m_abstrColumnNames[iColumn].m_str);
                    return E_ST_VALUENEEDED;
                }

                CComVariant varColumnValue;
                if(m_iPublicRowNameColumn == iColumn)
                {
					varColumnValue.vt = VT_BSTR;
                    if(FAILED(hr = pElement_Row->get_baseName(&varColumnValue.bstrVal)))return hr;

                    //Since this is an enum public row name - we need to check to see if it's one of the
                    //enums, or some other random element (if we don't do this we'll get an error "illegal
                    //enum value"
                    if(!m_aPublicRowName[iColumn].IsEqual(varColumnValue.bstrVal, (unsigned int)wcslen(varColumnValue.bstrVal)))
                    {
                        bMatch = false;
                        continue;
                    }
                }
                else
                {
					// we already know the element name is correct for ChildElement
					if(!m_awstrChildElementName[iColumn].c_str())
					{
						//If this column isn't an enum public row, then we need to make sure that the element name matches
						CComBSTR bstrElementName;
						if(FAILED(hr = pElement_Row->get_baseName(&bstrElementName)))
							return hr;
						if(!m_aPublicRowName[iColumn].IsEqual(bstrElementName.m_str, bstrElementName.Length()))
						{
							bMatch = false;
							continue;
						}
					}

                    if (FAILED (hr = pElement_Row->getAttribute (m_abstrColumnNames[iColumn], &varColumnValue)))
						return hr;

                   	// getAttribute returns false when no attribute with the given name is found. so use the default value
					// instead
					if (hr == S_FALSE)
                    {
                        //This is to deal with PK DefaultedValues
                        switch(m_acolmetas[iColumn].dbType)
                        {
                        case DBTYPE_UI4:
                            {
                                if(     m_aDefaultValue[iColumn]
                                    &&  *reinterpret_cast<ULONG *>(m_apvValues[iColumn]) == *reinterpret_cast<ULONG *>(m_aDefaultValue[iColumn]))
                                {
                                    bMatch = true;
                                    continue;
                                }
                                break;
                            }
                        case DBTYPE_WSTR:
                            {
                                if(     m_aDefaultValue[iColumn]
                                    &&  0 == (m_acolmetas[iColumn].fMeta & fCOLUMNMETA_MULTISTRING)
                                    &&  0 == StringCompare(iColumn, reinterpret_cast<LPCWSTR>(m_apvValues[iColumn]), reinterpret_cast<LPCWSTR>(m_aDefaultValue[iColumn])))
                                {
                                    bMatch = true;
                                    continue;
                                }
                                break;
                            }
                        }
                        bMatch = false;
                        continue;
                    }
                }

                switch(m_acolmetas[iColumn].dbType)
                {
                case DBTYPE_UI4:
                    {
                        DWORD       ui4;
                        if(FAILED(hr = GetColumnValue(iColumn, varColumnValue.bstrVal, ui4)))return hr;
                        bMatch = (ui4 == *reinterpret_cast<ULONG *>(m_apvValues[iColumn]));
                        break;
                    }
                case DBTYPE_WSTR:
                    {
                        if (m_acolmetas[iColumn].fMeta & fCOLUMNMETA_MULTISTRING)
                        {
                            TSmartPointerArray<WCHAR> wszMS;
                            hr = CreateStringFromMultiString ((LPCWSTR) m_apvValues[iColumn], &wszMS);
                            if (FAILED (hr))
                            {
                                return hr;
                            }
                            bMatch = (0 == StringCompare(iColumn, varColumnValue.bstrVal, wszMS));
                        }
                        else
                        {
                            bMatch = (0 == StringCompare(iColumn, varColumnValue.bstrVal, reinterpret_cast<LPWSTR>(m_apvValues[iColumn])));
                        }
                    }
                    break;
                case DBTYPE_GUID:
                    {
                        GUID        guid;
                        if(FAILED(hr = GetColumnValue(iColumn, varColumnValue.bstrVal, guid)))return hr;

                        bMatch = (0 == memcmp(&guid, reinterpret_cast<GUID *>(m_apvValues[iColumn]), sizeof(guid)));
                        break;
                    }
                case DBTYPE_BYTES:
                    {
                        TSmartPointerArray<unsigned char> byArray;
                        unsigned long   cbArray;
                        if(FAILED(hr = GetColumnValue(iColumn, varColumnValue.bstrVal, byArray.m_p, cbArray)))return hr;

                        if(cbArray != m_aSizes[iColumn])//first match the sizes
                        {
                            bMatch = false;
                            break;
                        }

                        bMatch = (0 == memcmp(byArray, reinterpret_cast<unsigned char *>(m_apvValues[iColumn]), m_aSizes[iColumn]));
                        break;
                    }
                }//switch(dbType)
            }//if(fMeta & PK)
        }//for(iSortedColumn...)

        if(iSortedColumn == cCountOfColumns && bMatch)//if we made it through all of the columns without finding a mismatch then we found our row.
        {
            if(IsBaseElementLevelNode(pNode_Row))
            {
                pNode_Matching = pNode_Row;
                break;
            }
        }
    }
    return S_OK;
}//GetMatchingNode


HRESULT CXmlSDT::GetMetaTable(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, CComPtr<ISimpleTableRead2> &pMetaTable) const
{
    STQueryCell         qcellMeta;                  // Query cell for grabbing meta table.

    UNREFERENCED_PARAMETER(i_wszDatabase);

    qcellMeta.pData     = (LPVOID)i_wszTable;
    qcellMeta.eOperator = eST_OP_EQUAL;
    qcellMeta.iCell     = iCOLUMNMETA_Table;
    qcellMeta.dbType    = DBTYPE_WSTR;
    qcellMeta.cbSize    = 0;

// Obtain our dispenser
#ifdef XML_WIRING
    CComPtr<ISimpleDataTableDispenser>     pSimpleDataTableDispenser;      // Dispenser for the Meta Table

    HRESULT hr;
    if(FAILED(hr = CoCreateInstance(clsidSDTXML, 0, CLSCTX_INPROC_SERVER, IID_ISimpleDataTableDispenser,  reinterpret_cast<void **>(&pSimpleDataTableDispenser))))
        return hr;

    return pSimpleDataTableDispenser->GetTable (wszDATABASE_META, wszTABLE_COLUMNMETA, (LPVOID) &qcellMeta, (LPVOID)&m_one,
                        eST_QUERYFORMAT_CELLS, 0, 0, (LPVOID*) &pMetaTable);
#else
    return ((IAdvancedTableDispenser *)m_pISTDisp.p)->GetTable (wszDATABASE_META, wszTABLE_COLUMNMETA, (LPVOID) &qcellMeta, (LPVOID)&m_one, eST_QUERYFORMAT_CELLS, m_fLOS & fST_LOS_EXTENDEDSCHEMA, (LPVOID*) &pMetaTable);
#endif
}//GetMetaTable


HRESULT CXmlSDT::GetResursiveColumnPublicName(tTABLEMETARow &i_TableMetaRow, tCOLUMNMETARow &i_ColumnMetaRow, ULONG i_iColumn, wstring &o_wstrColumnPublicName,  TPublicRowName &o_ColumnPublicRowName, unsigned int & o_nLevelOfColumnAttribute, wstring &o_wstrChildElementName)
{
    HRESULT hr;

    if(*i_ColumnMetaRow.pMetaFlags & fCOLUMNMETA_FOREIGNKEY && *i_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_ISCONTAINED)//If this column is a foreign key within a Contained table
    {
        // This is the relation required to determine containment
        CComPtr<ISimpleTableRead2>  pRelationMeta;
        if(FAILED(hr = Dispenser()->GetTable(wszDATABASE_META, wszTABLE_RELATIONMETA, NULL, NULL, eST_QUERYFORMAT_CELLS, m_fLOS & fST_LOS_EXTENDEDSCHEMA, reinterpret_cast<void **>(&pRelationMeta))))
            return hr;

        tRELATIONMETARow    RelationMetaRow;
        ULONG               aRelationMetaSizes[cRELATIONMETA_NumberOfColumns];
        ULONG               i;

        // initialize the relation meta
        memset (&RelationMetaRow, 0x00, sizeof(tRELATIONMETARow));

        for(i=0;true;++i)//Linear search for the RelationMetaRow whose ForeignTable matches this one AND has USE_CONTAINMENT flag set.
        {
            if(FAILED(hr = pRelationMeta->GetColumnValues(i, cRELATIONMETA_NumberOfColumns, NULL, aRelationMetaSizes, reinterpret_cast<void **>(&RelationMetaRow))))return hr;
            if((*RelationMetaRow.pMetaFlags & fRELATIONMETA_USECONTAINMENT) &&
                0 == StringInsensitiveCompare(RelationMetaRow.pForeignTable, i_TableMetaRow.pInternalName))//There should only be one matching foreign table that has USECONTAINMENT flag set.
                break;//leave the contents of the RelationMetaRow structure and exit
        }

        //Now walk the column indexes looking for the one that matches i_iColumn
        for(i=0; i<(aRelationMetaSizes[iRELATIONMETA_ForeignColumns]/4) && i_iColumn!=reinterpret_cast<ULONG *>(RelationMetaRow.pForeignColumns)[i];++i);
        if (i == (aRelationMetaSizes[iRELATIONMETA_ForeignColumns]/4))
        {
            o_wstrColumnPublicName      = i_ColumnMetaRow.pPublicColumnName;
            if(0 == o_wstrColumnPublicName.c_str())return E_OUTOFMEMORY;

            if(*i_ColumnMetaRow.pSchemaGeneratorFlags & fCOLUMNMETA_VALUEINCHILDELEMENT)
            {
                o_wstrChildElementName = i_TableMetaRow.pChildElementName;
                if(0 == o_wstrChildElementName.c_str())return E_OUTOFMEMORY;
            }

            if(0==i_TableMetaRow.pPublicRowName)//Since this is a primary table, it MUST have a static public row name
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "PublicRowName not defined for %s\r\n", i_TableMetaRow.pInternalName ));
                ASSERT(false && "PublicRowName not defined");
                return E_SDTXML_PUBLICROWNAME_MISSING_FROM_META;
            }
            return o_ColumnPublicRowName.Init(i_TableMetaRow.pPublicRowName);
        }

        //Only now do we really know that this FK is foreign to the primary table that this table is contained within.
        if(*RelationMetaRow.pMetaFlags & fRELATIONMETA_CONTAINASSIBLING)
        {
            if(0 == (*i_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_NOTSCOPEDBYTABLENAME))
                return E_SDTXML_NOTSUPPORTED;
            if(o_nLevelOfColumnAttribute != 0)
                return E_SDTXML_NOTSUPPORTED;
            //The parent table is at the same level as the child.  Also, we only allow this at the child most level.
            m_abSiblingContainedColumn[i_iColumn] = true;
            m_bSiblingContainedTable = true;
        }
        else
        {
            ++o_nLevelOfColumnAttribute;//Since this attribute is contained within another table, it is another level above the base Table row element
            if(0 == (*i_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_NOTSCOPEDBYTABLENAME))
                ++o_nLevelOfColumnAttribute;//If the table is SCOPEDBYTABLENAME element then it is another level above the base Table row element
        }

        STQueryCell             qcellMeta[2];                  // Query cell for grabbing meta table.
        qcellMeta[0].pData      = RelationMetaRow.pPrimaryTable;
        qcellMeta[0].eOperator  = eST_OP_EQUAL;
        qcellMeta[0].iCell      = iTABLEMETA_InternalName;
        qcellMeta[0].dbType     = DBTYPE_WSTR;
        qcellMeta[0].cbSize     = 0;

        //Get the TableMeta row
        CComPtr<ISimpleTableRead2> pTableMeta_PrimaryTable;
        if(FAILED(hr = Dispenser()->GetTable (wszDATABASE_META, wszTABLE_TABLEMETA, qcellMeta, &m_one, eST_QUERYFORMAT_CELLS, m_fLOS & fST_LOS_EXTENDEDSCHEMA, reinterpret_cast<void **>(&pTableMeta_PrimaryTable))))return hr;

        tTABLEMETARow          TableMetaRow_PrimaryTable;
        if(FAILED(hr = pTableMeta_PrimaryTable->GetColumnValues(0, cTABLEMETA_NumberOfColumns, NULL, NULL, reinterpret_cast<void **>(&TableMetaRow_PrimaryTable))))return hr;

        //Reuse the query cells for the ColumnMeta
        qcellMeta[0].iCell      = iCOLUMNMETA_Table;

        ULONG iColumn_PrimaryTable = reinterpret_cast<ULONG *>(RelationMetaRow.pPrimaryColumns)[i];
        qcellMeta[1].pData      = &iColumn_PrimaryTable;
        qcellMeta[1].eOperator  = eST_OP_EQUAL;
        qcellMeta[1].iCell      = iCOLUMNMETA_Index;
        qcellMeta[1].dbType     = DBTYPE_UI4;
        qcellMeta[1].cbSize     = 0;

        CComPtr<ISimpleTableRead2> pColumnMeta_PrimaryTable;
        if(FAILED(hr = Dispenser()->GetTable (wszDATABASE_META, wszTABLE_COLUMNMETA, qcellMeta, &m_two, eST_QUERYFORMAT_CELLS, m_fLOS & fST_LOS_EXTENDEDSCHEMA, reinterpret_cast<void **>(&pColumnMeta_PrimaryTable))))return hr;

        tCOLUMNMETARow          ColumnMetaRow_PrimaryTable;
        if(FAILED(hr = pColumnMeta_PrimaryTable->GetColumnValues(0, cCOLUMNMETA_NumberOfColumns, NULL, NULL, reinterpret_cast<void **>(&ColumnMetaRow_PrimaryTable))))return hr;

        //The stored level for a foreign row that is fCOLUMNMETA_VALUEINCHILDELEMENT, is wrong; but the actual value of zero is reserved to indicate that
        //the attribute is located within the element that describes the row (not the sibling where this element would live).  So we leave it wrong
        //and consider the fCOLUMNMETA_VALUEINCHILDELEMENT bit to find the correct element.

        return GetResursiveColumnPublicName(TableMetaRow_PrimaryTable, ColumnMetaRow_PrimaryTable, iColumn_PrimaryTable, o_wstrColumnPublicName,  o_ColumnPublicRowName, o_nLevelOfColumnAttribute, o_wstrChildElementName);
    }
    else
    {
        o_wstrColumnPublicName      = i_ColumnMetaRow.pPublicColumnName;
        if(0 == o_wstrColumnPublicName.c_str())return E_OUTOFMEMORY;

        if(*i_ColumnMetaRow.pSchemaGeneratorFlags & fCOLUMNMETA_VALUEINCHILDELEMENT)
        {
            o_wstrChildElementName = i_TableMetaRow.pChildElementName;
            if(0 == o_wstrChildElementName.c_str())return E_OUTOFMEMORY;
        }

        if(*i_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_NOTSCOPEDBYTABLENAME)
        {
            if(o_nLevelOfColumnAttribute+1 > m_BaseElementLevel)
                m_BaseElementLevel = o_nLevelOfColumnAttribute+1;
        }
        else
        {
            if(o_nLevelOfColumnAttribute+2 > m_BaseElementLevel)
                m_BaseElementLevel = o_nLevelOfColumnAttribute+2;
        }

        if(i_TableMetaRow.pPublicRowName)
            return o_ColumnPublicRowName.Init(i_TableMetaRow.pPublicRowName);
        else
        {
            //Leave the o_ColumnPublicRowName uninitialized if we're using an enum as the public row name, we'll fill it in later
            if(*i_ColumnMetaRow.pSchemaGeneratorFlags & fCOLUMNMETA_USEASPUBLICROWNAME)
            {
                if(IsEnumPublicRowNameTable() && m_iPublicRowNameColumn!=*i_ColumnMetaRow.pIndex)
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "Two columns of table (%s) are marked as fCOLUMNMETA_USEASPUBLICROWNAME (%d) & (%d)\r\n", i_TableMetaRow.pInternalName, m_iPublicRowNameColumn, *i_ColumnMetaRow.pIndex ));
                }

                //Leave o_ColumnPublicRowName uninitialized for this row, we'll set it up at the end
                ASSERT(!IsEnumPublicRowNameTable() || m_iPublicRowNameColumn==*i_ColumnMetaRow.pIndex);//We can only have one column whose enum values indicate the possible public row names
                ASSERT(0 == o_nLevelOfColumnAttribute);//The level of the column attribute whose enum values indicate the possible public row names MUST be at the base level (the child-most level)
                ASSERT(*i_ColumnMetaRow.pMetaFlags & fCOLUMNMETA_ENUM);//This column MUST be an enum
                m_iPublicRowNameColumn = *i_ColumnMetaRow.pIndex;//Remember which column has the list of tags that idenitify the possible public row names
            }
        }

    }
    return S_OK;
}


HRESULT CXmlSDT::InsertNewLineWithTabs(ULONG cTabs, IXMLDOMDocument * pXMLDoc, IXMLDOMNode * pNodeInsertBefore, IXMLDOMNode * pNodeParent)
{
    HRESULT hr;

    WCHAR wszNewlineWithTabs[256];
    wcscpy(wszNewlineWithTabs, L"\r\n");//This makes the table element tabbed in once.  The 0th sorted column tells how deep to additionally tab in.

    wszNewlineWithTabs[2+cTabs] = 0x00;
    while(cTabs--)
        wszNewlineWithTabs[2+cTabs] = L'\t';

    CComPtr<IXMLDOMText>    pNode_Newline;
    TComBSTR                bstrNewline(wszNewlineWithTabs);
    if(FAILED(hr = pXMLDoc->createTextNode(bstrNewline, &pNode_Newline)))
        return hr;
    CComVariant varNode = pNodeInsertBefore;
    return pNodeParent->insertBefore(pNode_Newline, varNode, 0);
}



//This is a wrapper for InternalSimpleInitialize (thus the name), it just gets the meta information THEN calls InternalSimpleInitialize.
HRESULT CXmlSDT::InternalComplicatedInitialize(LPCWSTR i_wszDatabase)
{
    ASSERT(m_wszTable);//We should have made a copy of the i_tid (passed into GetTable) already

    HRESULT hr;

    if(FAILED(hr = ObtainPertinentTableMetaInfo()))return hr;

    if(m_fLOS & fST_LOS_READWRITE)
    {
        m_bstr_name           =  L"name";
        m_bstrPublicTableName =  m_TableMetaRow.pPublicName;
        m_bstrPublicRowName   =  m_TableMetaRow.pPublicRowName ? m_TableMetaRow.pPublicRowName : L"";
    }
    // WARNING: Possible data loss on IA64
    m_cchTablePublicName = (ULONG)wcslen(m_TableMetaRow.pPublicName);

    m_fCache             |= *m_TableMetaRow.pMetaFlags;

    CComPtr<ISimpleTableRead2>   pColumnMeta;// Meta table.
    if(FAILED(hr = GetMetaTable(i_wszDatabase, m_wszTable, pColumnMeta)))return hr;

    m_BaseElementLevel = (*m_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_NOTSCOPEDBYTABLENAME) ? 1 : 2;

//    // Determine column count and allocate necessary meta structures:
//    VERIFY(SUCCEEDED(hr = pColumnMeta->GetTableMeta(0, 0, &CountOfColumns(), 0)));//The number of rows in the meta table Is the number of columns in the table itself.
//    if(FAILED(hr))
//        return hr;

    if(FAILED(hr = SetArraysToSize()))return hr;

    tCOLUMNMETARow          ColumnMetaRow;
    unsigned long           LargestLevelOfColumnAttribute = 0;
    unsigned long           iColumn;
    unsigned long           cbColumns[cCOLUMNMETA_NumberOfColumns];

    for (iColumn = 0;; iColumn++)
    {
        if(E_ST_NOMOREROWS == (hr = pColumnMeta->GetColumnValues(iColumn, cCOLUMNMETA_NumberOfColumns, 0,
                            cbColumns, reinterpret_cast<void **>(&ColumnMetaRow))))// Next row:
        {
            ASSERT(CountOfColumns() == iColumn);
            if(CountOfColumns() != iColumn)return E_SDTXML_UNEXPECTED; // Assert expected column count.
            break;
        }
        else
        {
            if(FAILED(hr))
            {
                ASSERT(false && "GetColumnValues FAILED with something other than E_ST_NOMOREROWS");
                return hr;
            }
        }

        //Don't care about the iOrder column but we'll get it anyway since it's easier to do.
        m_acolmetas[iColumn].dbType = *ColumnMetaRow.pType;
        m_acolmetas[iColumn].cbSize = *ColumnMetaRow.pSize;
        m_acolmetas[iColumn].fMeta  = *ColumnMetaRow.pMetaFlags;

        if(0 == ColumnMetaRow.pPublicColumnName)return E_SDTXML_UNEXPECTED;//The meta should have failed to load in this case

        if(m_acolmetas[iColumn].fMeta & fCOLUMNMETA_PRIMARYKEY)//This is to deal with Defaulting PKs (since the fast cache can't deal with it.)
        {
            ++m_cPKs;
        }
        //WARNING!! Just keeping track of the pointer itself, this could be dangerous if the meta were written info the fastcache,
        m_aDefaultValue[iColumn]  =  ColumnMetaRow.pDefaultValue;//then went away when we released the ColumnMeta interface
        m_acbDefaultValue[iColumn]=  cbColumns[iCOLUMNMETA_DefaultValue];

        if(*ColumnMetaRow.pSchemaGeneratorFlags & fCOLUMNMETA_XMLBLOB)
            m_iXMLBlobColumn = iColumn;

        if(FAILED(hr = GetResursiveColumnPublicName(m_TableMetaRow, ColumnMetaRow, iColumn, m_awstrColumnNames[iColumn], m_aPublicRowName[iColumn], m_aLevelOfColumnAttribute[iColumn], m_awstrChildElementName[iColumn])))
            return hr;

        //This is needed for Inserts, so we create the child node too.  More than one column is allowed to live in the child
        if(0==m_aLevelOfColumnAttribute[iColumn] && 0!=m_awstrChildElementName[iColumn].c_str())//node; but all must come from
            m_iCol_TableRequiresAdditionChildElement = iColumn;//the same child.  We don't support cols from different children.

        if(m_fLOS & fST_LOS_READWRITE)
        {   //These introduce oleaut32.dll so they are only used when we're going to use the DOM.  The read only case we use
            m_abstrColumnNames[iColumn]     = m_awstrColumnNames[iColumn];//the Node Factory.
        }


        if(m_aLevelOfColumnAttribute[iColumn] > LargestLevelOfColumnAttribute)
            LargestLevelOfColumnAttribute = m_aLevelOfColumnAttribute[iColumn];
    }
    ++m_BaseElementLevel;//one more to account for the <configuration> element

    //These variables are needed to ValidateWriteCache and to validate on Populate as well
    m_saiPKColumns = new ULONG [m_cPKs];
    if(0 == m_saiPKColumns.m_p)
        return E_OUTOFMEMORY;

    ULONG iPK=0;
    for(iColumn=0; iPK<m_cPKs; ++iColumn)
    {
        ASSERT(iColumn<CountOfColumns());
        if(m_acolmetas[iColumn].fMeta & fCOLUMNMETA_PRIMARYKEY)
            m_saiPKColumns[iPK++] = iColumn;
    }


    //After we have the ColumnMeta info, get the TagMeta
    if(FAILED(hr = ObtainPertinentTagMetaInfo()))
        return hr;
    if(IsEnumPublicRowNameTable())
        hr = m_aPublicRowName[m_iPublicRowNameColumn].Init(&m_aTagMetaRow[m_aTagMetaIndex[m_iPublicRowNameColumn].m_iTagMeta], m_aTagMetaIndex[m_iPublicRowNameColumn].m_cTagMeta);

    //Sort the column indexes by their level so we read the highest level atrributes first.
    unsigned long iSorted = 0;
    for(int Level=LargestLevelOfColumnAttribute; Level >= 0; --Level)
    {
        for(iColumn = 0; iColumn < CountOfColumns(); ++iColumn)
        {
            if(m_aLevelOfColumnAttribute[iColumn] == static_cast<unsigned long>(Level))
            {
                m_aColumnsIndexSortedByLevel[iSorted++] = iColumn;
                if(IsEnumPublicRowNameTable() && 0 == Level)//I'm not sure if this is necessary.  But we are now initializing the 0 level PublicRowName to be the list of enum values specified for column 'm_iPublicRowNameColumn'
                    m_aPublicRowName[iColumn].Init(&m_aTagMetaRow[m_aTagMetaIndex[m_iPublicRowNameColumn].m_iTagMeta], m_aTagMetaIndex[m_iPublicRowNameColumn].m_cTagMeta);
            }
        }
    }
    if(m_bSiblingContainedTable)//if this is a SiblingContainedTable, we need to verify that the SiblingContainedColumn are
    {                           //listed before the child most columns
        for(int iSortedColumn=CountOfColumns()-1;iSortedColumn>0 &&
                    0==m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[iSortedColumn]]; --iSortedColumn)
        {
            if(false == m_abSiblingContainedColumn[m_aColumnsIndexSortedByLevel[iSortedColumn]])\
            {
                m_iSortedFirstChildLevelColumn = iSortedColumn;
                if(static_cast<int>(CountOfColumns()-1)!=iSortedColumn &&//if this isn't the last column, check to see if the next one is a Sibling
                    true == m_abSiblingContainedColumn[m_aColumnsIndexSortedByLevel[iSortedColumn+1]])//ContainedColumn
                {
                    ASSERT(false && "The columns must be sorted with the SiblingParent columns BEFORE the Child columns");
                    return E_SDTXML_NOTSUPPORTED;//if it is then we have a bogus table definition.  CatUtil doesn't currently
                }                                //validate this condition so we'll do it at run time.
            }
            else
            {
                m_iSortedFirstParentLevelColumn = iSortedColumn;
                if(static_cast<int>(CountOfColumns()-1)==iSortedColumn)
                {
                    ASSERT(false && "The columns must be sorted with the SiblingParent columns BEFORE the Child columns");
                    return E_SDTXML_NOTSUPPORTED;//The last column can't be a SiblingContainedColumn
                }
            }

        }
    }
    ASSERT(iSorted == CountOfColumns());
    ASSERT(!IsNameValueTable());

    return hr;
}


bool CXmlSDT::IsBaseElementLevelNode(IXMLDOMNode * i_pNode)
{
    ASSERT(i_pNode && "Idiot passing NULL!!! CXmlSDT::IsBaseElementLevelNode(NULL)");
    CComPtr<IXMLDOMNode> spNode_Temp = i_pNode;

    unsigned int nLevelOfColumnAttribute = 0;//Only (PK | FK) columns should have a non zero value here
    while(true)
    {
        CComPtr<IXMLDOMNode> spNode_Parent;
        if(FAILED(spNode_Temp->get_parentNode(&spNode_Parent)) || spNode_Parent==0)
        {
            return (nLevelOfColumnAttribute == m_BaseElementLevel) ? true : false;
        }
        ++nLevelOfColumnAttribute;

        spNode_Temp.Release();
        spNode_Temp = spNode_Parent;
    }
    return false;
}


HRESULT CXmlSDT::IsCorrectXMLSchema(IXMLDOMDocument *pXMLDoc) const
{
    HRESULT hr;

    ASSERT(pXMLDoc);

    //This is kind of a long road to get to the XML Schema name but here goes...
    //Get the XML Root Node
    CComPtr<IXMLDOMElement>     pRootNodeOfXMLDocument;
    if(FAILED(hr = pXMLDoc->get_documentElement(&pRootNodeOfXMLDocument)))
        return hr;
    ASSERT(pRootNodeOfXMLDocument);

    //From that get the Definition node
    CComPtr<IXMLDOMNode>        pDefinitionNode;
    if(FAILED(hr = pRootNodeOfXMLDocument->get_definition(&pDefinitionNode)))
        return hr;
    ASSERT(pDefinitionNode);

    //From that we get the DOMDocument of the schema
    CComPtr<IXMLDOMDocument>    pSchemaDocument;
    if(FAILED(hr = pDefinitionNode->get_ownerDocument(&pSchemaDocument)))
        return hr;
    ASSERT(pSchemaDocument);

    //Get the schema's root element
    CComPtr<IXMLDOMElement>     pSchemaRootElement;
    if(FAILED(hr = pSchemaDocument->get_documentElement(&pSchemaRootElement)))
        return hr;
    ASSERT(pSchemaRootElement);

    //get the Name attribute
    CComVariant                 XMLSchemaName;
    if(FAILED(hr = pSchemaRootElement->getAttribute(m_bstr_name, &XMLSchemaName)))
        return hr;

    if(XMLSchemaName.vt != VT_BSTR)
        return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;

    return (0 == StringCompare(XMLSchemaName.bstrVal, m_kXMLSchemaName)) ? S_OK : E_SDTXML_WRONG_XMLSCHEMA;//If the XML Schema doesn't match then we can't continue
}


HRESULT CXmlSDT::IsMatchingColumnValue(ULONG i_iColumn, LPCWSTR i_wszColumnValue, bool & o_bMatch)
{
    HRESULT hr;
    switch(m_acolmetas[i_iColumn].dbType)
    {
    case DBTYPE_UI4:
        {
            if(0 == i_wszColumnValue)
            {              //This covers the NULL case
                o_bMatch = (m_aDefaultValue[i_iColumn]==m_apvValues[i_iColumn]) ||
                            (*reinterpret_cast<ULONG *>(m_aDefaultValue[i_iColumn]) ==
                             *reinterpret_cast<ULONG *>(m_apvValues[i_iColumn]));
            }
            else
            {
                DWORD       ui4;
                if(FAILED(hr = GetColumnValue(i_iColumn, i_wszColumnValue, ui4)))
                    return hr;
                o_bMatch = (ui4 == *reinterpret_cast<ULONG *>(m_apvValues[i_iColumn]));
            }
            break;
        }
    case DBTYPE_WSTR:
        {
            if(0 == i_wszColumnValue)
            {
                if (m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_MULTISTRING)
                {   //we don't default MULTISZ PKs
                    o_bMatch = false;
                    break;
                }

                o_bMatch = (m_aDefaultValue[i_iColumn]==m_apvValues[i_iColumn]) ||
                            (0 == StringCompare(i_iColumn, reinterpret_cast<LPWSTR>(m_aDefaultValue[i_iColumn]),
                                                           reinterpret_cast<LPWSTR>(m_apvValues[i_iColumn])));
            }
            else
            {
                if (m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_MULTISTRING)
                {
                    TSmartPointerArray<WCHAR> wszMS;
                    hr = CreateStringFromMultiString ((LPCWSTR) m_apvValues[i_iColumn], &wszMS);
                    if (FAILED (hr))
                    {
                        return hr;
                    }
                    o_bMatch = (0 == StringCompare(i_iColumn, i_wszColumnValue, wszMS));
                }
                else
                {
                    o_bMatch = (0 == StringCompare(i_iColumn, i_wszColumnValue, reinterpret_cast<LPWSTR>(m_apvValues[i_iColumn])));
                }
            }
        }
        break;
    case DBTYPE_GUID:
        {
            if(0 == i_wszColumnValue)
            {
                o_bMatch = (m_aDefaultValue[i_iColumn]==m_apvValues[i_iColumn]) ||
                            (0 == memcmp(m_aDefaultValue[i_iColumn], m_apvValues[i_iColumn], sizeof(GUID)));
            }
            else
            {
                GUID        guid;
                if(FAILED(hr = GetColumnValue(i_iColumn, i_wszColumnValue, guid)))
                    return hr;

                o_bMatch = (0 == memcmp(&guid, reinterpret_cast<GUID *>(m_apvValues[i_iColumn]), sizeof(guid)));
            }
            break;
        }
    case DBTYPE_BYTES:
        {
            if(0 == i_wszColumnValue)
            {
                o_bMatch = (m_aDefaultValue[i_iColumn]==m_apvValues[i_iColumn]) ||
                           (m_aSizes[i_iColumn] == m_acbDefaultValue[i_iColumn]
                            &&  0 == memcmp(m_aDefaultValue[i_iColumn], m_apvValues[i_iColumn], m_aSizes[i_iColumn]));
            }
            else
            {
                TSmartPointerArray<unsigned char> byArray;
                unsigned long   cbArray;
                if(FAILED(hr = GetColumnValue(i_iColumn, i_wszColumnValue, byArray.m_p, cbArray)))return hr;

                if(cbArray != m_aSizes[i_iColumn])//first match the sizes
                {
                    o_bMatch = false;
                    break;
                }

                o_bMatch = (0 == memcmp(byArray, reinterpret_cast<unsigned char *>(m_apvValues[i_iColumn]), m_aSizes[i_iColumn]));
            }
            break;
        }
    }//switch(dbType)
    return S_OK;
}


HRESULT CXmlSDT::LoadDocumentFromURL(IXMLDOMDocument *pXMLDoc)
{
    HRESULT hr;

    ASSERT(pXMLDoc);

	VERIFY(SUCCEEDED(hr = pXMLDoc->put_async(kvboolFalse)));//We want the parse to be synchronous

    if(FAILED(hr))
        return hr;

    if(FAILED(hr = pXMLDoc->put_resolveExternals(kvboolTrue)))
        return hr;//we need all of the external references resolved

    VARIANT_BOOL    bSuccess;
    CComVariant     xml(m_wszURLPath);

	// check for memory allocation error
	if (xml.vt == VT_ERROR)
		return xml.scode;

    if(FAILED(hr = pXMLDoc->load(xml,&bSuccess)))
        return hr;

    return (bSuccess == kvboolTrue) ? S_OK : E_SDTXML_UNEXPECTED;
}


HRESULT CXmlSDT::MemCopyPlacingInEscapedChars(LPWSTR o_DestinationString, LPCWSTR i_SourceString, ULONG i_cchSourceString, ULONG & o_cchCopied) const
{

    static LPWSTR   wszSingleQuote= L"&apos;";
    static LPWSTR   wszQuote      = L"&quot;";
    static LPWSTR   wszAmp        = L"&amp;";
    static LPWSTR   wszlt         = L"&lt;";
    static LPWSTR   wszgt         = L"&gt;";
    const  ULONG    cchSingleQuote= 6;
    const  ULONG    cchQuote      = 6;
    const  ULONG    cchAmp        = 5;
    const  ULONG    cchlt         = 4;
    const  ULONG    cchgt         = 4;

    LPWSTR  pDest = o_DestinationString;

    for(;i_cchSourceString--; ++i_SourceString)
    {
        switch(GetEscapeType(*i_SourceString))
        {
        case eESCAPEnone:
            *pDest++ = *i_SourceString;
            break;
        case eESCAPEgt:
            memcpy(pDest, wszgt, cchgt * sizeof(WCHAR));
            pDest += cchgt;
            break;
        case eESCAPElt:
            memcpy(pDest, wszlt, cchlt * sizeof(WCHAR));
            pDest += cchlt;
            break;
        case eESCAPEapos:
            memcpy(pDest, wszSingleQuote, cchSingleQuote * sizeof(WCHAR));
            pDest += cchSingleQuote;
            break;
        case eESCAPEquote:
            memcpy(pDest, wszQuote, cchQuote * sizeof(WCHAR));
            pDest += cchQuote;
            break;
        case eESCAPEamp:
            memcpy(pDest, wszAmp, cchAmp * sizeof(WCHAR));
            pDest += cchAmp;
            break;
        case eESCAPEashex:
            pDest += wsprintf(pDest, L"&#x%04hX;", *i_SourceString);
            break;
        case eESCAPEillegalxml:
            return E_ST_VALUEINVALID;
        default:
            ASSERT(false && "Invalid eESCAPE enum");
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }
    }
    // WARNING: Possible data loss on IA64
    o_cchCopied = (ULONG)(pDest-o_DestinationString);//return the count of WCHARs copied
    return S_OK;
}


HRESULT CXmlSDT::MyPopulateCache(ISimpleTableWrite2* i_pISTW2)
{
    HRESULT hr;

    CComQIPtr<ISimpleTableController, &IID_ISimpleTableController> pISTController = i_pISTW2;
    if(0 == pISTController.p)return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;

    if(0 == (m_fLOS & fST_LOS_REPOPULATE) && !m_bIsFirstPopulate)//If this is not the first Populate and Repopulate LOS was not requirested, return error
        return E_ST_LOSNOTSUPPORTED;

    if((m_fLOS & fST_LOS_UNPOPULATED) && m_bIsFirstPopulate)
    {   //Then populate an empty cache
        if (FAILED(hr = pISTController->PrePopulateCache (0)))
            return hr;
        if (FAILED(hr = pISTController->PostPopulateCache ()))
            return hr;
        m_bIsFirstPopulate = false;
        return S_OK;
    }
    m_bIsFirstPopulate = false;

    ASSERT(i_pISTW2);
    ASSERT(m_wszTable);

    if (FAILED(hr = pISTController->PrePopulateCache (0))) return hr;

    //We use Node Factory parsing for Read and ReadWrite tables.
    if(0==(m_fLOS & fST_LOS_NOCACHEING))
    {
        if(!m_XmlParsedFileCache.IsInitialized())
        {
            CSafeLock XmlParsedFileCache(m_SACriticalSection_XmlParsedFileCache);
            DWORD dwRes = XmlParsedFileCache.Lock();
            if(ERROR_SUCCESS != dwRes)
            {
                return HRESULT_FROM_WIN32(dwRes);
            }

            if(FAILED(hr = m_XmlParsedFileCache.Initialize(TXmlParsedFileCache::CacheSize_mini)))return hr;
            //Unlock the cache
        }
        m_pXmlParsedFile = m_XmlParsedFileCache.GetXmlParsedFile(m_wszURLPath);
    }
    else
    {
        m_pXmlParsedFile = &m_XmlParsedFile;
    }


    DWORD dwAttributes = GetFileAttributes(m_wszURLPath);

    if(-1 == dwAttributes)//if GetFileAttributes fails then the file does not exist
    {
        if(m_fLOS & fST_LOS_READWRITE)//if read write table, then we have an empty table
            return pISTController->PostPopulateCache ();
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            LOG_POPULATE_ERROR1(IDS_COMCAT_FILE_NOT_FOUND, hr, m_wszURLPath);
            return hr;
        }
    }
    else if(FILE_ATTRIBUTE_READONLY&dwAttributes && fST_LOS_READWRITE&m_fLOS)
    {
        LOG_POPULATE_ERROR1(IDS_COMCAT_XML_FILENOTWRITEABLE, E_SDTXML_FILE_NOT_WRITABLE, m_wszURLPath);
        return E_SDTXML_FILE_NOT_WRITABLE;//if the file is READONLY and the user wants a WRITABLE table, then error
    }

	m_spHashTable = new CXmlHashTable;
	if (m_spHashTable == 0)
	{
		return E_OUTOFMEMORY;
	}

	hr = m_spHashTable->Init (11);
	if (FAILED (hr))
	{
        DBGPRINTF(( DBG_CONTEXT,
                    "Unable to intializes hashtable" ));
		return hr;
	}

    m_pISTW2 = i_pISTW2;
    hr = m_pXmlParsedFile->Parse(*this, m_wszURLPath);

    //Reset these state variables, for the next time we parse. (No sense waiting 'til the next parse to reinitialize them).
    m_LevelOfBasePublicRow = 0;
    m_bAtCorrectLocation = (0 == m_cchLocation);
    m_bInsideLocationTag = false;
    m_pISTW2 = 0;
	m_spHashTable.Delete();  // get rid of the memory hold by the hashtable

    //clean up (this is also done in the dtor so don't hassle cleaning up if an error occurs and we return prematurely.)
    for(unsigned long iColumn=0; iColumn<*m_TableMetaRow.pCountOfColumns; ++iColumn)
    {
        delete [] m_apValue[iColumn];
        m_apValue[iColumn] = 0;
    }
    if(E_ERROR_OPENING_FILE == hr)
        return E_ST_INVALIDQUERY;
    if(FAILED(hr) && E_SDTXML_DONE != hr)
    {
        HRESULT hrRtn = hr;

        //This will give us an event log entry
        CComPtr<IXMLDOMDocument> pXMLDoc;
        if(FAILED(hr = CoCreateInstance(_CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, _IID_IXMLDOMDocument, (void**)&pXMLDoc)))
            return hr;//Instantiate the XMLParser
        //We use the DOM to parse the ReadWrite table.  This gives better validation and error reporting.
        ParseXMLFile(pXMLDoc, m_bValidating);
        return hrRtn;//pass back the hr that was returned from the NodeFactory parse.
    }

    if (FAILED(hr = pISTController->PostPopulateCache ()))
        return hr;
    return S_OK;
}


HRESULT CXmlSDT::MyUpdateStore(ISimpleTableWrite2* i_pISTW2)
{
    HRESULT hr;

    ASSERT(i_pISTW2);

    if(!(m_fLOS & fST_LOS_READWRITE))
        return E_NOTIMPL;

    CComQIPtr<ISimpleTableController, &IID_ISimpleTableController> pISTController = i_pISTW2;ASSERT(pISTController.p);
    if(0 == pISTController.p)
        return E_SDTXML_UNEXPECTED;

    bool    bError = false;
    if(FAILED(hr = ValidateWriteCache(pISTController, i_pISTW2, bError)))
        return hr;

    if(bError)//if there is an error in validation then no need to continue
        return E_ST_DETAILEDERRS;



    CComPtr<IXMLDOMDocument> pXMLDoc;
    if(FAILED(hr = CoCreateInstance(_CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, _IID_IXMLDOMDocument, (void**)&pXMLDoc)))
        return hr;//Instantiate the XMLParser

    if(-1 == GetFileAttributes(m_wszURLPath))//if GetFileAttributes fails then the file does not exist
    {   //if the file does not exist, then we need to create a empty configuration XML string as a starting point.
        VARIANT_BOOL    bSuccess;
        TComBSTR        bstrBlankComCatDataXmlDocument = L"<?xml version =\"1.0\"?>\r\n<configuration>\r\n</configuration>";

        if(FAILED(hr = pXMLDoc->put_preserveWhiteSpace(kvboolTrue)))
            return hr;

        if(FAILED(hr = pXMLDoc->loadXML(bstrBlankComCatDataXmlDocument, &bSuccess)))
            return hr;
        if(bSuccess != kvboolTrue)//The above string IS valid XML so it should always parse successfully - but the parser may have problems (like out of memory)
            return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;
    }
    else
        if(FAILED(hr = ParseXMLFile(pXMLDoc, m_bValidating)))
            return hr;                                                                      //Validate the XML file

    //Turn off validation since technically newline text nodes are not permitted (since elements are supposed to be empty), and we use them to pretty up the XML.
    if(FAILED(hr = pXMLDoc->put_validateOnParse(kvboolFalse)))
        return hr;

    m_cCacheHit  = 0;
    m_cCacheMiss = 0;

    CComPtr<IXMLDOMElement> spElementRoot;//This is the element scoping the configuration.  It's either the <configuration> element OR the matching <Location> element.
    if(m_cchLocation)
    {
        CComBSTR bstrLocation = L"location";
        CComBSTR bstrPath     = L"path";

        CComPtr<IXMLDOMNodeList> spNodeList_Location;
        if(FAILED(hr = pXMLDoc->getElementsByTagName(bstrLocation, &spNodeList_Location)))return hr;

        while(true)//find the matching location
        {
            CComPtr<IXMLDOMNode> spNextLocation;
            if(FAILED(hr = spNodeList_Location->nextNode(&spNextLocation)))
                return hr;
            if(spNextLocation == 0)//no locations
                return E_SDTXML_PARENT_TABLE_DOES_NOT_EXIST;

            CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> spElementLocation = spNextLocation;
            if(0 == spElementLocation.p)
                continue;//go to the next one

            CComVariant varLocation;
            if(FAILED(spElementLocation->getAttribute(bstrPath, &varLocation)))
                continue;

            if(0 != StringInsensitiveCompare(varLocation.bstrVal, m_saLocation))
                continue;

            spElementRoot = spElementLocation;//This location tag is like the root for this config table
            break;
        }
    }
    else
    {   //If no Location specified, the just use the root <configuration> element as the scoping root element.
        if(FAILED(hr = pXMLDoc->get_documentElement(&spElementRoot)))
            return hr;
    }

    //This is used only if IsEnumPublicRowName - because we can't getElementsByTagName on the row itself, we have to get it on the parent instead.
    TComBSTR    ParentPublicRowName;
    TComBSTR *  pParentTagName;
    if(IsEnumPublicRowNameTable() && (*m_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_NOTSCOPEDBYTABLENAME))
    {
        pParentTagName = reinterpret_cast<TComBSTR *>(&ParentPublicRowName);
        for(ULONG iColumn=0;iColumn<CountOfColumns();++iColumn)
            if(1 == m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[iColumn]])
            {
                ParentPublicRowName = m_aPublicRowName[m_aColumnsIndexSortedByLevel[iColumn]].GetFirstPublicRowName();
                break;
            }
    }
    else
        pParentTagName = reinterpret_cast<TComBSTR *>(&m_bstrPublicTableName);


    CComPtr<IXMLDOMNodeList>        pNodeList;
    TListOfXMLDOMNodeLists          *pListOfLists = NULL;//This is only used if we're using an enum as the public row name
    CComPtr<IXMLDOMNodeList>        spListOfLists;

    if(IsEnumPublicRowNameTable())
    {
        pListOfLists = new TListOfXMLDOMNodeLists;//This gives a ref count of zero
        if(0 == pListOfLists)
            return E_OUTOFMEMORY;
        spListOfLists = pListOfLists;

        CComPtr<IXMLDOMNodeList> pNodeListOfParentElements;
        if(SUCCEEDED(spElementRoot->getElementsByTagName(*pParentTagName, &pNodeListOfParentElements)))
        {
            if(0 == m_cchLocation)//if there is no query by location
            {
                CComPtr<IXMLDOMNodeList> pNodeListOfParentElementsWithoutLocation;
                if(FAILED(hr = ReduceNodeListToThoseNLevelsDeep(pNodeListOfParentElements, m_BaseElementLevel-1, &pNodeListOfParentElementsWithoutLocation)))
                    return hr;

                pNodeListOfParentElements.Release();
                pNodeListOfParentElements = pNodeListOfParentElementsWithoutLocation;
            }

            long cParentElements;
            if(FAILED(hr = pNodeListOfParentElements->get_length(&cParentElements)))
                return hr;
            if(FAILED(hr = pListOfLists->SetCountOfLists(cParentElements)))
                return hr;
            while(cParentElements--)
            {
                CComPtr<IXMLDOMNode>     pNode;
                if(FAILED(hr = pNodeListOfParentElements->nextNode(&pNode)))
                    return hr;


                CComPtr<IXMLDOMNodeList> pNodeListOfTablesChildren;//These should be the Table's rows
				if (FAILED(hr = pNode->get_childNodes (&pNodeListOfTablesChildren)))
					return hr;

                if(FAILED(hr = pListOfLists->AddToList(pNodeListOfTablesChildren)))
                    return hr;
            }

            pNodeList = spListOfLists;//this bumps the ref count to one.
        }
    }
    else
    {
        if(FAILED(hr = spElementRoot->getElementsByTagName(m_bstrPublicRowName, &pNodeList)))
            return hr;

        if(0 == m_cchLocation)//if there is no query by location
        {
            CComPtr<IXMLDOMNodeList> pNodeListWithoutLocation;
            if(FAILED(hr = ReduceNodeListToThoseNLevelsDeep(pNodeList, m_BaseElementLevel, &pNodeListWithoutLocation)))
                return hr;

            pNodeList.Release();
            pNodeList = pNodeListWithoutLocation;
        }
    }

    // performance optimization. Use nextnode instead of get_length, because we only need to
    // know if we have existing node or not. In case size is important, use get_length (but pay
    // the performance penalty).
    CComPtr<IXMLDOMNode> spNextItem;
    if(FAILED(hr = pNodeList->nextNode (&spNextItem)))
        return hr;

    long cExistingRows=(spNextItem != 0) ? 1 : 0;

    //This kind of table has all of its rows removed everytime UpdateStore is called.
    if(*m_TableMetaRow.pMetaFlags & fTABLEMETA_OVERWRITEALLROWS)
    {
        while(spNextItem)
        {
            if(FAILED(hr = RemoveElementAndWhiteSpace(spNextItem)))
                return hr;
            spNextItem.Release();

            if(FAILED(hr = pNodeList->nextNode (&spNextItem)))
                return hr;
        }
        cExistingRows = 0;
    }


    bool    bSomethingToFlush   = false;
    DWORD   eAction;
    ULONG   iRow;

    for(iRow = 0; ; iRow++)
    {
        // Get the ro action
        if(FAILED(hr = pISTController->GetWriteRowAction(iRow, &eAction)))
        {
            if(hr == E_ST_NOMOREROWS)
                hr = S_OK;
            break;
        }

        m_iCurrentUpdateRow = iRow;//This is for error logging purposes only

        switch(eAction)
        {
        // call the appropriate plugin function
        case eST_ROW_INSERT:
            hr = XMLInsert(i_pISTW2, pXMLDoc, spElementRoot, iRow, pNodeList, cExistingRows);
            break;
        case eST_ROW_UPDATE:
            if(*m_TableMetaRow.pMetaFlags & fTABLEMETA_OVERWRITEALLROWS)
                hr = E_SDTXML_UPDATES_NOT_ALLOWED_ON_THIS_KIND_OF_TABLE;
            else
                hr = XMLUpdate(i_pISTW2, pXMLDoc, spElementRoot, iRow, pNodeList, cExistingRows, 0);
            break;
        case eST_ROW_DELETE:
            if(*m_TableMetaRow.pMetaFlags & fTABLEMETA_OVERWRITEALLROWS)
                hr = S_OK;//Al rows are implicitly deleted for these tables.
            else
                hr = XMLDelete(i_pISTW2, pXMLDoc, spElementRoot, iRow, pNodeList, cExistingRows);
            break;
        case eST_ROW_IGNORE:
            continue;
        default:
            ASSERT(false && "Invalid Action returned from InternalGetWriteRowAction");
            continue;
        }

        if(E_OUTOFMEMORY == hr)
        {
            m_pLastPrimaryTable.Release();//Release the caching temporary variables.
            m_pLastParent.Release();      //Release the caching temporary variables.
            return E_OUTOFMEMORY;//No need to continue if we get this kind of error.
        }
        else if (FAILED (hr))
        {   // Add detailed error
            STErr ste;

            ste.iColumn = (ULONG) iST_ERROR_ALLCOLUMNS;
            ste.iRow = iRow;
            ste.hr = hr;

            DBGPRINTF(( DBG_CONTEXT,
                        "Detailed error: hr = 0x%x", hr ));

            hr = pISTController->AddDetailedError(&ste);
            ASSERT(SUCCEEDED(hr));//Not sure what to do if this fails.
            bError = true;
        }
        else
            bSomethingToFlush = true;//Flush only if OnInsert, OnUpdate or OnDelete succeeded.
    }

    m_pLastPrimaryTable.Release();//Release the caching temporary variables.
    m_pLastParent.Release();      //Release the caching temporary variables.
    if(0 != m_cCacheMiss)//Prevent a divide by 0
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "UpdateStore    Cache Hits-%8d       Cache Misses-%8d       Hit Ratio- %f %%", m_cCacheHit, m_cCacheMiss, (100.0 * m_cCacheHit)/(m_cCacheHit+m_cCacheMiss) ));
    }

    if(bSomethingToFlush && !bError)//Only save if there's something to save AND no errors occurred.
    {
        CComVariant varFileName(m_wszURLPath);
        hr = pXMLDoc->save(varFileName);

		// due to a bug in the FileSystem functions on Win9X, we always unload the cache at this point. The reason is that
		// the file stamp of the saved file does not always get updated properly, causing all kind of weird behavior. Forcing
		// the unload of the cache enforces a file read the next time data is needed, working around the problem
		if (m_XmlParsedFileCache.IsInitialized())
		{
			TXmlParsedFile * pXmlParsedFile = m_XmlParsedFileCache.GetXmlParsedFile(m_wszURLPath);
			if (pXmlParsedFile)
			{
				// flush the cache
				pXmlParsedFile->Unload ();
			}
		}

        if(0==(m_fLOS & fST_LOS_NOCACHEING) && m_pXmlParsedFile)//This keeps us from having to force a flush of the disk write cache.  If the user asks for this table
            m_pXmlParsedFile->Unload();//again, but the write cache hasn't been flushed, then we need to repopulate from disk (NOT from our ParsedFile cache).
    }

    return bError ? E_ST_DETAILEDERRS : hr;//hr may NOT be S_OK.  It's possible to have an error but no Detailed Errors (in which case bError is false but hr it NOT S_OK).
}


HRESULT CXmlSDT::ObtainPertinentTableMetaInfo()
{
    HRESULT hr;

    STQueryCell Query;
    Query.pData     = (void*) m_wszTable;
    Query.eOperator =eST_OP_EQUAL;
    Query.iCell     =iTABLEMETA_InternalName;
    Query.dbType    =DBTYPE_WSTR;
    Query.cbSize    =0;

    if(FAILED(hr = Dispenser()->GetTable(wszDATABASE_META, wszTABLE_TABLEMETA, &Query, &m_one, eST_QUERYFORMAT_CELLS, m_fLOS & fST_LOS_EXTENDEDSCHEMA, reinterpret_cast<void**>(&m_pTableMeta))))
        return hr;

    if(FAILED(hr = m_pTableMeta->GetColumnValues(0, cTABLEMETA_NumberOfColumns, NULL, NULL, reinterpret_cast<void**>(&m_TableMetaRow))))return hr;
    m_iPublicRowNameColumn = *m_TableMetaRow.pPublicRowNameColumn;

    return S_OK;
}

HRESULT CXmlSDT::ObtainPertinentTagMetaInfo()
{
    HRESULT hr;

    //Now that we have the ColumnMeta setup, setup the TagMeta
    STQueryCell Query;
    Query.pData     = (void*) m_wszTable;
    Query.eOperator =eST_OP_EQUAL;
    Query.iCell     =iTAGMETA_Table;
    Query.dbType    =DBTYPE_WSTR;
    Query.cbSize    =0;

    //Optain the TagMeta table
    if(FAILED(hr = Dispenser()->GetTable (wszDATABASE_META, wszTABLE_TAGMETA, &Query, &m_one, eST_QUERYFORMAT_CELLS, m_fLOS & fST_LOS_EXTENDEDSCHEMA, (void**) &m_pTagMeta)))
        return hr;

    ULONG cRows;
    if(FAILED(hr = m_pTagMeta->GetTableMeta(0,0,&cRows,0)))return hr;

    if (cRows != 0)
    {
        m_aTagMetaRow = new tTAGMETARow[cRows];
        if(0 == m_aTagMetaRow.m_p)
            return E_OUTOFMEMORY;
    }

// Build tag column indexes:
    ULONG iColumn, iRow;
    for(iRow = 0, iColumn = ~0ul;iRow<cRows; ++iRow)
    {
        if(FAILED(hr = m_pTagMeta->GetColumnValues (iRow, cTAGMETA_NumberOfColumns, NULL, NULL, reinterpret_cast<void **>(&m_aTagMetaRow[iRow]))))
            return hr;

        if(iColumn != *m_aTagMetaRow[iRow].pColumnIndex)
        {
            iColumn = *m_aTagMetaRow[iRow].pColumnIndex;
            m_aTagMetaIndex[iColumn].m_iTagMeta = iRow;
        }
        ++m_aTagMetaIndex[iColumn].m_cTagMeta;
    }

    return S_OK;
}


HRESULT CXmlSDT::ParseXMLFile(IXMLDOMDocument *pXMLDoc, bool bValidating)//defaults to validating against the DTD or XML schema
{
    HRESULT hr;

    ASSERT(pXMLDoc);

    if(FAILED(hr = pXMLDoc->put_preserveWhiteSpace(kvboolTrue)))//kvboolFalse)))
        return hr;
    if(FAILED(hr = pXMLDoc->put_validateOnParse(bValidating ? kvboolTrue : kvboolFalse)))//Tell parser whether to validate according to an XML schema or DTD
        return hr;

    if(FAILED(LoadDocumentFromURL(pXMLDoc)))
    {   //If the load failed then let's spit out as much information as possible about what went wrong
        CComPtr<IXMLDOMParseError> pXMLParseError;
        long lErrorCode, lFilePosition, lLineNumber, lLinePosition;
        TComBSTR bstrReasonString, bstrSourceString, bstrURLString;

        if(FAILED(hr = pXMLDoc->get_parseError(&pXMLParseError)))       return hr;
        if(FAILED(hr = pXMLParseError->get_errorCode(&lErrorCode)))     return hr;
        if(FAILED(hr = pXMLParseError->get_filepos(&lFilePosition)))    return hr;
        if(FAILED(hr = pXMLParseError->get_line(&lLineNumber)))         return hr;
        if(FAILED(hr = pXMLParseError->get_linepos(&lLinePosition)))    return hr;
        if(FAILED(hr = pXMLParseError->get_reason(&bstrReasonString)))  return hr;
        if(FAILED(hr = pXMLParseError->get_srcText(&bstrSourceString))) return hr;
        if(FAILED(hr = pXMLParseError->get_url(&bstrURLString)))        return hr;

        LOG_ERROR(Interceptor, (&m_spISTError, m_pISTDisp, lErrorCode, ID_CAT_CAT, IDS_COMCAT_XML_PARSE_ERROR,
                        L" ",
                        (bstrReasonString.m_str ? bstrReasonString.m_str : L""),
                        (bstrSourceString.m_str ? bstrSourceString.m_str : L""),
                        eSERVERWIRINGMETA_Core_XMLInterceptor,
                        m_wszTable,
                        eDETAILEDERRORS_Populate,
                        lLineNumber,
                        lLinePosition,
                        (bstrURLString.m_str ? bstrURLString.m_str : L"")));

        ASSERT(S_OK != lErrorCode);
        return  lErrorCode;
    }
    //Not only does the XML file have to be Valid and Well formed, but its schema must match the one this C++ file was written to.
    return  S_OK;
}


HRESULT CXmlSDT::ReduceNodeListToThoseNLevelsDeep(IXMLDOMNodeList * i_pNodeList, ULONG i_nLevel, IXMLDOMNodeList **o_ppNodeListReduced) const
{
    HRESULT                 hr;

    CComPtr<TXMLDOMNodeList> pNodeListReduced = new TXMLDOMNodeList;
    if(0 == pNodeListReduced.p)
        return E_OUTOFMEMORY;

    CComPtr<IXMLDOMNode>    spNextItem;
    if(FAILED(hr = i_pNodeList->nextNode(&spNextItem)))
        return hr;

    while(spNextItem)
    {
        ULONG                cLevels = 0;

        CComPtr<IXMLDOMNode> spNodeParent;
        if(FAILED(hr = spNextItem->get_parentNode(&spNodeParent)))
            return hr;
        while(spNodeParent)
        {
            ++cLevels;
            CComPtr<IXMLDOMNode> spNodeTemp = spNodeParent;
            spNodeParent.Release();
            if(FAILED(hr = spNodeTemp->get_parentNode(&spNodeParent)))
                return hr;
        }
        if(cLevels == i_nLevel)
            if(FAILED(hr = pNodeListReduced->AddToList(spNextItem)))
                return hr;

        spNextItem.Release();
        if(FAILED(hr = i_pNodeList->nextNode(&spNextItem)))
            return hr;
    }

    *o_ppNodeListReduced = reinterpret_cast<IXMLDOMNodeList *>(pNodeListReduced.p);
    (*o_ppNodeListReduced)->AddRef();//AddRef before returning

    return S_OK;
}


HRESULT CXmlSDT::RemoveElementAndWhiteSpace(IXMLDOMNode *pNode)
{
    HRESULT hr;
    CComPtr<IXMLDOMNode> pNode_Parent;
    if(FAILED(hr = pNode->get_parentNode(&pNode_Parent)))
        return hr;
    if(pNode_Parent==0)
        return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;

    CComPtr<IXMLDOMNode> spSibling;
    pNode->get_previousSibling(&spSibling);

    pNode_Parent->removeChild(pNode, 0);

    while(spSibling)
    {
        DOMNodeType type;
        if(FAILED(hr = spSibling->get_nodeType(&type)))
            return hr;

        CComPtr<IXMLDOMNode> spSibling0;
        spSibling->get_previousSibling(&spSibling0);

        if(NODE_TEXT != type)
            break;

        pNode_Parent->removeChild(spSibling, 0);

        spSibling.Release();
        spSibling = spSibling0;
    }
    return S_OK;
}


HRESULT CXmlSDT::ScanAttributesAndFillInColumn(const TElement &i_Element, ULONG i_iColumn, bool &o_bMatch)
{
    HRESULT hr;
    ULONG   iAttribute=0;

    o_bMatch  = false;//We'll either find the matching attr and compare to the Query, OR we'll find NO attr and compare it with the query
    for(; iAttribute<i_Element.m_NumberOfAttributes; ++iAttribute)
    {
        LPCWSTR pwcText;
        ULONG   ulLen;

        ASSERT( m_iPublicRowNameColumn != i_iColumn );

        if( m_awstrColumnNames[i_iColumn].length()      != i_Element.m_aAttribute[iAttribute].m_NameLength                                                      ||
                0                                       != memcmp(i_Element.m_aAttribute[iAttribute].m_Name, m_awstrColumnNames[i_iColumn], sizeof(WCHAR)*i_Element.m_aAttribute[iAttribute].m_NameLength))
                continue;

        //We matched the column name to the attribute name
        pwcText = i_Element.m_aAttribute[iAttribute].m_Value;
        ulLen   = i_Element.m_aAttribute[iAttribute].m_ValueLength;

        if(0 == m_aQuery[i_iColumn].dbType || 0 != m_aQuery[i_iColumn].pData)//If no query OR the query data is NOT NULL then proceed.
        {
            if(FAILED(hr = FillInColumn(i_iColumn, pwcText, ulLen, m_acolmetas[i_iColumn].dbType, m_acolmetas[i_iColumn].fMeta, o_bMatch)))
                return hr;
            if(!o_bMatch)//If not a match then we're done with this element and this level.
                return S_OK;
        }
        break;//we found the node that matches the column so bail.
    }
    if(iAttribute == i_Element.m_NumberOfAttributes && !o_bMatch)//if we made it through the list without finding a match then the column is NULL
    {
        delete [] m_apValue[i_iColumn];
        m_apValue[i_iColumn] = 0;
        m_aSize[i_iColumn] = 0;

        if(FAILED(hr = FillInPKDefaultValue(i_iColumn, o_bMatch)))//If this column is a PK with a DefaultValue, then fill it in.
            return hr;                                            //if it's not a PK then compare with the query
        if(!o_bMatch)//If not a match then we're done with this element and this level.
            return S_OK;
    }
    return S_OK;
}//ScanAttributesAndFillInColumn


HRESULT CXmlSDT::SetArraysToSize()
{
    if(CountOfColumns()<=m_kColumns)//We only need to do allocations when the number of columns exceeds m_kColumns.
    {
        m_abSiblingContainedColumn          = m_fixed_abSiblingContainedColumn;
        m_abstrColumnNames                  = m_fixed_abstrColumnNames;
        m_aPublicRowName                    = m_fixed_aPublicRowName;
        m_acolmetas                         = m_fixed_acolmetas;
        m_aLevelOfColumnAttribute           = m_fixed_aLevelOfColumnAttribute;
        m_aQuery                            = m_fixed_aQuery;
        m_apvValues                         = m_fixed_apvValues;
        m_aSizes                            = m_fixed_aSizes;
        m_aStatus                           = m_fixed_aStatus;
        m_awstrColumnNames                  = m_fixed_awstrColumnNames;
        m_aColumnsIndexSortedByLevel        = m_fixed_aColumnsIndexSortedByLevel;
        m_aSize                             = m_fixed_aSize;
        m_apValue                           = m_fixed_apValue;
        m_aTagMetaIndex                     = m_fixed_aTagMetaIndex;
        m_aDefaultValue                     = m_fixed_aDefaultValue;
        m_acbDefaultValue                   = m_fixed_acbDefaultValue;
        m_awstrChildElementName             = m_fixed_awstrChildElementName;
    }
    else
    {
        m_alloc_abSiblingContainedColumn    = new bool            [CountOfColumns()];
        m_alloc_abstrColumnNames            = new TComBSTR        [CountOfColumns()];
        m_alloc_aPublicRowName              = new TPublicRowName  [CountOfColumns()];
        m_alloc_acolmetas                   = new SimpleColumnMeta[CountOfColumns()];
        m_alloc_aLevelOfColumnAttribute     = new unsigned int    [CountOfColumns()];
        m_alloc_aQuery                      = new STQueryCell     [CountOfColumns()];
        m_alloc_apvValues                   = new LPVOID          [CountOfColumns()];
        m_alloc_aSizes                      = new ULONG           [CountOfColumns()];
        m_alloc_aStatus                     = new ULONG           [CountOfColumns()];
        m_alloc_awstrColumnNames            = new wstring         [CountOfColumns()];
        m_alloc_aColumnsIndexSortedByLevel  = new unsigned int    [CountOfColumns()];
        m_alloc_aSize                       = new unsigned long   [CountOfColumns()];
        m_alloc_apValue                     = new unsigned char * [CountOfColumns()];
        m_alloc_aTagMetaIndex               = new TTagMetaIndex   [CountOfColumns()];
        m_alloc_aDefaultValue               = new unsigned char * [CountOfColumns()];
        m_alloc_acbDefaultValue             = new unsigned long   [CountOfColumns()];
        m_alloc_awstrChildElementName       = new wstring         [CountOfColumns()];


        if(!m_alloc_abSiblingContainedColumn      ||
           !m_alloc_abstrColumnNames              ||
           !m_alloc_aPublicRowName                ||
           !m_alloc_acolmetas                     ||
           !m_alloc_aLevelOfColumnAttribute       ||
           !m_alloc_aQuery                        ||
           !m_alloc_apvValues                     ||
           !m_alloc_aSizes                        ||
           !m_alloc_aStatus                       ||
           !m_alloc_awstrColumnNames              ||
           !m_alloc_aColumnsIndexSortedByLevel    ||
           !m_alloc_aSize                         ||
           !m_alloc_apValue                       ||
           !m_alloc_aTagMetaIndex                 ||
           !m_alloc_aDefaultValue                 ||
           !m_alloc_acbDefaultValue               ||
           !m_alloc_awstrChildElementName)
           return E_OUTOFMEMORY;

        m_abSiblingContainedColumn          = m_alloc_abSiblingContainedColumn;
        m_abstrColumnNames                  = m_alloc_abstrColumnNames;
        m_aPublicRowName                    = m_alloc_aPublicRowName;
        m_acolmetas                         = m_alloc_acolmetas;
        m_aLevelOfColumnAttribute           = m_alloc_aLevelOfColumnAttribute;
        m_aQuery                            = m_alloc_aQuery;
        m_apvValues                         = m_alloc_apvValues;
        m_aSizes                            = m_alloc_aSizes;
        m_aStatus                           = m_alloc_aStatus;
        m_awstrColumnNames                  = m_alloc_awstrColumnNames;
        m_aColumnsIndexSortedByLevel        = m_alloc_aColumnsIndexSortedByLevel;
        m_aSize                             = m_alloc_aSize;
        m_apValue                           = m_alloc_apValue;
        m_aTagMetaIndex                     = m_alloc_aTagMetaIndex;
        m_aDefaultValue                     = m_alloc_aDefaultValue;
        m_acbDefaultValue                   = m_alloc_acbDefaultValue;
        m_awstrChildElementName             = m_alloc_awstrChildElementName;
    }

	// always allocate these
	m_apvValuesTmp						= new LPVOID		  [CountOfColumns()];
	m_aSizesTmp							= new ULONG			  [CountOfColumns()];
	if (m_apvValuesTmp == 0 || m_aSizesTmp == 0)
		return E_OUTOFMEMORY;

    memset(m_abSiblingContainedColumn  ,0x00, CountOfColumns() * sizeof(bool              ));
    memset(m_acolmetas                 ,0x00, CountOfColumns() * sizeof(SimpleColumnMeta  ));
    memset(m_aLevelOfColumnAttribute   ,0x00, CountOfColumns() * sizeof(unsigned int      ));
    memset(m_aQuery                    ,0x00, CountOfColumns() * sizeof(STQueryCell       ));
    memset(m_apvValues                 ,0x00, CountOfColumns() * sizeof(LPVOID            ));
    memset(m_aSizes                    ,0x00, CountOfColumns() * sizeof(ULONG             ));
    memset(m_aStatus                   ,0x00, CountOfColumns() * sizeof(ULONG             ));
    memset(m_aColumnsIndexSortedByLevel,0x00, CountOfColumns() * sizeof(unsigned int      ));
    memset(m_aSize                     ,0x00, CountOfColumns() * sizeof(unsigned long     ));
    memset(m_apValue                   ,0x00, CountOfColumns() * sizeof(unsigned char *   ));
    memset(m_aDefaultValue             ,0x00, CountOfColumns() * sizeof(unsigned char *   ));
    memset(m_acbDefaultValue           ,0x00, CountOfColumns() * sizeof(unsigned long     ));
	memset(m_aSizesTmp				   ,0x00, CountOfColumns() * sizeof(ULONG			  ));
	memset(m_apvValuesTmp			   ,0x00, CountOfColumns() * sizeof(LPVOID			  ));

    return S_OK;
}//SetArraysToSize


//Get the UI4 value whether it's an enum, flag or regular ui4
HRESULT CXmlSDT::SetColumnValue(unsigned long i_iColumn, IXMLDOMElement * i_pElement, unsigned long i_ui4)
{
    if(m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_BOOL)
    {
        CComVariant varValue(i_ui4 == 0 ? L"false" : L"true");
        return i_pElement->setAttribute(m_abstrColumnNames[i_iColumn], varValue);
    }
    else if(m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_ENUM)
    {
        ASSERT(0 != m_aTagMetaIndex[i_iColumn].m_cTagMeta);//Not all columns have tagmeta, those elements of the array are set to 0.  Assert this isn't one of those.
        for(unsigned long iTag = m_aTagMetaIndex[i_iColumn].m_iTagMeta, cTag = m_aTagMetaIndex[i_iColumn].m_cTagMeta; cTag; ++iTag, --cTag)//m_pTagMeta was queried for ALL columns, m_aiTagMeta[iColumn] indicates which row to start with
        {
            ASSERT(*m_aTagMetaRow[iTag].pColumnIndex == i_iColumn);

            //string compare the tag to the PublicName of the Tag in the meta.
            if(*m_aTagMetaRow[iTag].pValue == i_ui4)
            {
                CComVariant varValue(m_aTagMetaRow[iTag].pPublicName);
                return i_pElement->setAttribute(m_abstrColumnNames[i_iColumn], varValue);
            }
        }

        WCHAR szUI4[12];
        szUI4[11] = 0x00;
        _ultow(i_ui4, szUI4, 10);
        LOG_UPDATE_ERROR2(IDS_COMCAT_XML_BOGUSENUMVALUEINWRITECACHE, E_SDTXML_INVALID_ENUM_OR_FLAG, i_iColumn, m_abstrColumnNames[i_iColumn].m_str, szUI4)
        return E_SDTXML_INVALID_ENUM_OR_FLAG;
    }
    else if(m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_FLAG)
    {
        ASSERT(0 != m_aTagMetaIndex[i_iColumn].m_cTagMeta);//Not all columns have tagmeta, those elements of the array are set to 0.  Assert this isn't one of those.

        WCHAR wszValue[1024];
        wszValue[0] = 0x00;

        unsigned long iTag = m_aTagMetaIndex[i_iColumn].m_iTagMeta;
        unsigned long cTag = m_aTagMetaIndex[i_iColumn].m_cTagMeta;

        if(0==*m_aTagMetaRow[0].pValue && 0==i_ui4)
        {   //I'm assuming that if a flag value of zero is defined that it must be first
            wcscpy(wszValue, m_aTagMetaRow[0].pPublicName);
        }
        else
        {
            for(; cTag && 0!=i_ui4; ++iTag, --cTag)//m_pTagMeta was queried for ALL columns, m_aiTagMeta[iColumn] indicates which row to start with
            {
                ASSERT(*m_aTagMetaRow[iTag].pColumnIndex == i_iColumn);

                //A flag value may have more than one bit set (that's why I don't just have if(*m_aTagMetaRow[iTag].pValue & i_ui4)
                if(*m_aTagMetaRow[iTag].pValue && (*m_aTagMetaRow[iTag].pValue == (*m_aTagMetaRow[iTag].pValue & i_ui4)))
                {
                    if(wszValue[0] != 0x00)
                        wcscat(wszValue, L" | ");
                    wcscat(wszValue, m_aTagMetaRow[iTag].pPublicName);
                }
                i_ui4 ^= *m_aTagMetaRow[iTag].pValue;//This prevents us from walking the tags that aren't used.  This means, most used flags should be
            }                                        //the lower order bits
            if(0!=i_ui4)
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Flag bits (%d) for Column (%d) are undefined in TagMeta.", i_iColumn, i_ui4 ));
            }
        }
        if(0 == wszValue[0])//if the resulting string is L"" then remove the attribute
        {   //this happens when no tag value of zero is defined but the flag value is zero
            return i_pElement->removeAttribute(m_abstrColumnNames[i_iColumn]);
        }

        CComVariant varValue(wszValue);
        return i_pElement->setAttribute(m_abstrColumnNames[i_iColumn], varValue);
    }
    //otherwise just write the number
    // IVANPASH BUG #563171
    // Because of the horrible implementation of _ultow Prefix is complaning about potential buffer overflow
    // in MultiByteToWideChar indirectly called by _ultow. To avoid the warning I am increasing
    // the size to 40 to match _ultow local buffer.
    WCHAR wszUI4[40];
    wszUI4[0] = wszUI4[39] = L'\0';
    _ultow(i_ui4, wszUI4, 10);

    CComVariant varValue(wszUI4);
    return i_pElement->setAttribute(m_abstrColumnNames[i_iColumn], varValue);
}

HRESULT CXmlSDT::SetRowValues(IXMLDOMNode *pNode_Row, IXMLDOMNode *pNode_RowChild)
{
    HRESULT hr;

    CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> spElement_Child;//NULL unless there is a column that comes from the child
    CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> spElement_Row = pNode_Row;
    if(0 == spElement_Row.p)
        return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;

    if(0 != pNode_RowChild)
    {
        spElement_Child = pNode_RowChild;
        if(0 == spElement_Child.p)
            return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;
    }
    else if(-1 != m_iCol_TableRequiresAdditionChildElement)
    {
        CComBSTR                    bstrChildElementName = m_awstrChildElementName[m_iCol_TableRequiresAdditionChildElement].c_str();
        CComPtr<IXMLDOMNodeList>    spNodeList_Children;

        if(FAILED(hr = spElement_Row->getElementsByTagName(bstrChildElementName, &spNodeList_Children)))
            return hr;

        CComPtr<IXMLDOMNode> spChild;
        if(FAILED(hr = spNodeList_Children->nextNode(&spChild)))
            return hr;
        ASSERT(spChild != 0);//no children

        spElement_Child = spChild;
        if(0 == spElement_Child.p)
            return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;
    }

    ULONG iSortedColumn = m_bSiblingContainedTable ? m_iSortedFirstChildLevelColumn : 0;
    for(; iSortedColumn<CountOfColumns(); ++iSortedColumn)
    {
        ULONG iColumn = m_aColumnsIndexSortedByLevel[iSortedColumn];
        if(0 != m_aLevelOfColumnAttribute[iColumn])//We're only setting attributes that belong in this element
            continue;
        if(m_iPublicRowNameColumn == iColumn)
            continue;//This column is already taken care of if it is the element name

        IXMLDOMElement *pElement_Row = 0==m_awstrChildElementName[iColumn].c_str() ? spElement_Row.p : spElement_Child.p;
        ASSERT(pElement_Row);

        //Validate against the column's meta - if the column is PERSISTABLE and NOTNULLABLE
        if(     0 == m_apvValues[iColumn]
            &&  fCOLUMNMETA_NOTNULLABLE == (m_acolmetas[iColumn].fMeta & (fCOLUMNMETA_NOTPERSISTABLE | fCOLUMNMETA_NOTNULLABLE)))
        {
            if((m_acolmetas[iColumn].fMeta & fCOLUMNMETA_PRIMARYKEY) && m_aDefaultValue[iColumn])
            {
                //The user inserted a Row with a NULL PK; BUT the PK has a DefaultValue, so everything is OK
            }
            else
            {
                LOG_UPDATE_ERROR1(IDS_COMCAT_XML_NOTNULLABLECOLUMNISNULL, E_ST_VALUENEEDED, (ULONG) -1, m_abstrColumnNames[iColumn].m_str);
                return E_ST_VALUENEEDED;
            }
        }

        if( m_iXMLBlobColumn == iColumn                                         ||
                    0 == m_apvValues[iColumn]                                   ||
                    (m_aStatus[iColumn] & fST_COLUMNSTATUS_DEFAULTED)           ||
                    (m_acolmetas[iColumn].fMeta & fCOLUMNMETA_NOTPERSISTABLE))
        {
            pElement_Row->removeAttribute(m_abstrColumnNames[iColumn]);
        }
        else
        {
            switch(m_acolmetas[iColumn].dbType)
            {
            case DBTYPE_UI4:
                {
                    if(     m_acolmetas[iColumn].fMeta & fCOLUMNMETA_PRIMARYKEY  //If we (the XML Interceptor) defaulted the PK value, then don't write it out.
                        &&  m_aDefaultValue[iColumn]
                        &&  *reinterpret_cast<ULONG *>(m_apvValues[iColumn]) == *reinterpret_cast<ULONG *>(m_aDefaultValue[iColumn]))
                    {
                        pElement_Row->removeAttribute(m_abstrColumnNames[iColumn]);
                        break;
                    }
                    if(FAILED(hr = SetColumnValue(iColumn, pElement_Row, *reinterpret_cast<ULONG *>(m_apvValues[iColumn]))))
                        return hr;
                    break;
                }
            case DBTYPE_WSTR:
                {
                    CComVariant varValue;

                    if(     m_acolmetas[iColumn].fMeta & fCOLUMNMETA_PRIMARYKEY  //If we (the XML Interceptor) defaulted the PK value, then don't write it out.
                        &&  0 == (m_acolmetas[iColumn].fMeta & fCOLUMNMETA_MULTISTRING)
                        &&  m_aDefaultValue[iColumn]
                        &&  0 == StringCompare(iColumn, reinterpret_cast<LPWSTR>(m_apvValues[iColumn]), reinterpret_cast<LPCWSTR>(m_aDefaultValue[iColumn])))
                    {
                        pElement_Row->removeAttribute(m_abstrColumnNames[iColumn]);
                        break;
                    }

                    if (m_acolmetas[iColumn].fMeta & fCOLUMNMETA_MULTISTRING)
                    {
                        TSmartPointerArray<WCHAR> wszMS;
                        hr = CreateStringFromMultiString ((LPCWSTR) m_apvValues[iColumn], &wszMS);
                        if (FAILED (hr))
                        {
                            return hr;
                        }
                        varValue = wszMS;
                    }
                    else
                    {
                        varValue = reinterpret_cast<LPCWSTR>(m_apvValues[iColumn]);
                    }
                    if(FAILED(hr = pElement_Row->setAttribute(m_abstrColumnNames[iColumn], varValue)))
                            return hr;
                }
                break;
            case DBTYPE_GUID:
                {
                    LPWSTR wszGuid = 0;
                    if(FAILED(hr = UuidToString(reinterpret_cast<UUID *>(m_apvValues[iColumn]), &wszGuid)))
                        return hr;

                    CComVariant varValue(wszGuid);
                    if(FAILED(hr = RpcStringFree(&wszGuid)))
                        return hr;
                    if(FAILED(hr = pElement_Row->setAttribute(m_abstrColumnNames[iColumn], varValue)))
                        return hr;
                    break;
                }
            case DBTYPE_BYTES:
                {
                    TSmartPointerArray<WCHAR> wszArray = new WCHAR[(m_aSizes[iColumn]*2)+1];//allow two WCHARs for each byte and one for the NULL
                    if(0 == wszArray.m_p)
                        return E_OUTOFMEMORY;

                    ByteArrayToString(reinterpret_cast<unsigned char *>(m_apvValues[iColumn]), m_aSizes[iColumn], wszArray);

                    CComVariant     varValue(wszArray);
                    hr = pElement_Row->setAttribute(m_abstrColumnNames[iColumn], varValue);
                    if(FAILED(hr))return hr;
                    break;
                }
            default:
                ASSERT(false && "Unknown dbType");
            }//switch(dbType)
        }//else m_apvValues[iColumn]
    }
    return S_OK;
}


HRESULT CXmlSDT::ValidateWriteCache(ISimpleTableController* i_pISTController, ISimpleTableWrite2* i_pISTW2, bool & o_bDetailedError)
{
    //The following information is NOT spec'd in SimpleTableV2.doc.  So this
    //constitutes the spec for XML's validation of the WriteCache.

    //There are several possibilities:
    //1.1   A row is has a WriteRowAction of eST_ROW_INSERT
    //      A second row (matching the first's PK) is marked as eST_ROW_INSERT
    //      Result:
    //      Detailed Error - (All rows matching the PK have a Detailed Error
    //                        added and no further validation of these rows
    //                        is done).
    //
    //1.2   A row is has a WriteRowAction of eST_ROW_INSERT
    //      A second row (matching the first's PK) is marked as eST_ROW_UPDATE
    //      Result:
    //      1st row marked as eST_ROW_IGNORE
    //      2nd row marked as eST_ROW_INSERT
    //      Stop processing 1st row (processing of the 2nd row will handle
    //                      additional conflicting PKs).
    //
    //1.3   A row is has a WriteRowAction of eST_ROW_INSERT
    //      A second row (matching the first's PK) is marked as eST_ROW_DELETE
    //      Result:
    //      1st row marked as eST_ROW_IGNORE.
    //      Stop processing 1st row (processing of the 2nd row will handle
    //                      additional conflicting PKs).
    //
    //1.4   A row is has a WriteRowAction of eST_ROW_INSERT
    //      A second row (matching the first's PK) is marked as eST_ROW_IGNORE
    //      Result:
    //      None action, continue validating against 1st row
    //
    //
    //2.1   A row is has a WriteRowAction of eST_ROW_UPDATE
    //      A second row (matching the first's PK) is marked as eST_ROW_INSERT
    //      Result:
    //      Detailed Error - (All rows matching the PK have a Detailed Error
    //                        added and no further validation of these rows
    //                        is done).
    //
    //2.2   A row is has a WriteRowAction of eST_ROW_UPDATE
    //      A second row (matching the first's PK) is marked as eST_ROW_UPDATE
    //      Result:
    //      1st row marked as eST_ROW_IGNORE.
    //      Stop processing 1st row (processing of the 2nd row will handle
    //                      additional conflicting PKs).
    //
    //2.3   A row is has a WriteRowAction of eST_ROW_UPDATE
    //      A second row (matching the first's PK) is marked as eST_ROW_DELETE
    //      Result:
    //      1st row marked as eST_ROW_IGNORE
    //      Stop processing 1st row (processing of the 2nd row will handle
    //                      additional conflicting PKs).
    //
    //2.4   A row is has a WriteRowAction of eST_ROW_UPDATE
    //      A second row (matching the first's PK) is marked as eST_ROW_IGNORE
    //      Result:
    //      None action, continue validating against 1st row
    //
    //
    //
    //3.1   A row is has a WriteRowAction of eST_ROW_DELETE
    //      A second row (matching the first's PK) is marked as eST_ROW_INSERT
    //      Result:
    //      1st row marked as eST_ROW_IGNORE
    //      2nd row marked as eST_ROW_UPDATE
    //      Stop processing 1st row (processing of the 2nd row will handle
    //                      additional conflicting PKs).
    //
    //3.2   A row is has a WriteRowAction of eST_ROW_DELETE
    //      A second row (matching the first's PK) is marked as eST_ROW_UPDATE
    //      Result:
    //      Detailed Error - (All rows matching the PK have a Detailed Error
    //                        added and no further validation of these rows
    //                        is done).
    //
    //3.3   A row is has a WriteRowAction of eST_ROW_DELETE
    //      A second row (matching the first's PK) is marked as eST_ROW_DELETE
    //      Result:
    //      1st row marked as eST_ROW_IGNORE.
    //      Stop processing 1st row (processing of the 2nd row will handle
    //                      additional conflicting PKs).
    //
    //3.4   A row is has a WriteRowAction of eST_ROW_DELETE
    //      A second row (matching the first's PK) is marked as eST_ROW_IGNORE
    //      Result:
    //      None action, continue validating against 1st row
    //
    //
    //

    ULONG                       cRowsInWriteCache;
    DWORD                       eRowAction, eMatchingRowAction;
    HRESULT                     hr;
    //Each row in the WriteCache has an Action.  If there is a conflict (ie. two row having
    //the same PK are marked as eST_ROW_INSERT), then a detailed error is logged and the
    //rows in conflict should be ignored in further validation.  So we build an array of
    //bools to indicate whether to ignore the row.  We don't want to actually change the
    //Action because the user will need this information to correct the error.
    TSmartPointerArray<bool>    saRowHasDetailedErrorLogged;

    //Just counting the rows in the WriteCache, so we can alloc the saRowHasDetailedErrorLogged.
    for(cRowsInWriteCache=0; ; ++cRowsInWriteCache)
    {
        if(FAILED(hr = i_pISTController->GetWriteRowAction(cRowsInWriteCache, &eRowAction)))
        {
            if(hr != E_ST_NOMOREROWS)
                return hr;
            break;//we found the last row
        }
    }

    if(1 == cRowsInWriteCache || 0 == cRowsInWriteCache)//if there's only one row then there's no possibility for a conflict
        return S_OK;

    //We could defer this allocation 'til we actually have an error; but the logic is easier to
    saRowHasDetailedErrorLogged = new bool [cRowsInWriteCache];//follow if we just do it up front.
    if(0 == saRowHasDetailedErrorLogged.m_p)
        return E_OUTOFMEMORY;

    //Start with all columns NULL.
    memset(m_apvValues, 0x00, CountOfColumns() * sizeof(void *));
    memset(m_aSizes,    0x00, CountOfColumns() * sizeof(ULONG));
    memset(saRowHasDetailedErrorLogged, 0x00, cRowsInWriteCache * sizeof(bool));

    //If we go to the last row, there'll be nothing to compare it to, so end as the second last row in the WriteCache
    for(ULONG iRow = 0; iRow<(cRowsInWriteCache-1); ++iRow)
    {
        if(saRowHasDetailedErrorLogged[iRow])
            continue;//If this row has already been added to the DetailedError list, then there's nothing to validate

        // Get the action
        if(FAILED(hr = i_pISTController->GetWriteRowAction(iRow, &eRowAction)))
        {
            ASSERT(false && "We already counted the rows in the WriteCache, we should never fail GetWriteRowAction");
            return hr;
        }

        STErr ste;
        ULONG iMatchingRow = iRow;//We start at one past the last matching row (starting one past the row we're comparing to).

        //ste.hr determines whether we log an error
        memset(&ste, 0x00, sizeof(STErr));

        //Get the PK columns to pass to GetWriteRowIndexBySearch
        if(m_cPKs>1)
        {
            if(FAILED(hr = i_pISTW2->GetWriteColumnValues(iRow, m_cPKs, m_saiPKColumns, 0, m_aSizes, m_apvValues)))
                return hr;
        }
        else
        {
            if(FAILED(hr = i_pISTW2->GetWriteColumnValues(iRow, m_cPKs, m_saiPKColumns, 0, &m_aSizes[m_saiPKColumns[0]], &m_apvValues[m_saiPKColumns[0]])))
                return hr;
        }

        //If there's something wrong with iRow we log a detailed error by setting ste with a failed ste.hr.
        //This indicates that all rows matching the PK are also logged with a detailed error.  Also, in the
        //error condition, all the rows matching iRow's PK are marked as eST_ROW_IGNORE (including iRow itself).

        bool bContinueProcessingCurrentRow=true;
        while(bContinueProcessingCurrentRow)
        {
            if(FAILED(hr = i_pISTW2->GetWriteRowIndexBySearch(iMatchingRow+1, m_cPKs, m_saiPKColumns, m_aSizes, m_apvValues, &iMatchingRow)))
            {
                if(hr != E_ST_NOMOREROWS)
                    return hr;
                break;
            }

            //This shouldn't happen because when we find a row that is in error, we find all matching rows and log
            //detailed errors on those row too.  So the 'if(saRowHasDetailedErrorLogged[iRow])' just inside the for
            //startment above should take care of this.
            ASSERT(false == saRowHasDetailedErrorLogged[iMatchingRow]);

            if(saRowHasDetailedErrorLogged[iRow])
            {
                //Something was wrong with one of the earlier rows matching this one's PK.  So that invalidates this
                //row as well.
                ste.hr = E_ST_ROWCONFLICT;
            }
            else
            {
                if(FAILED(hr = i_pISTController->GetWriteRowAction(iMatchingRow, &eMatchingRowAction)))
                    return hr;
                switch(eRowAction)
                {
                case eST_ROW_INSERT:
                    {
                        switch(eMatchingRowAction)
                        {
                        case eST_ROW_INSERT://Same result for all three of these.
                        //1.1   A row is has a WriteRowAction of eST_ROW_INSERT
                        //      A second row (matching the first's PK) is marked as eST_ROW_INSERT
                        //      Result:
                        //      Detailed Error - (All rows matching the PK are marked as
                        //                        eST_ROW_IGNORE and Detailed Error is added)
                        //
                            ste.hr = E_ST_ROWCONFLICT;//This indicates to log a DetailedError below, on iMatchingRow.
                            break;
                        case eST_ROW_UPDATE:
                        //1.2   A row is has a WriteRowAction of eST_ROW_INSERT
                        //      A second row (matching the first's PK) is marked as eST_ROW_UPDATE
                        //      Result:
                        //      1st row marked as eST_ROW_IGNORE
                        //      2nd row marked as eST_ROW_INSERT
                        //      Stop processing 1st row (processing of the 2nd row will handle
                        //                      additional conflicting PKs).
                        //
                            if(FAILED(hr = i_pISTController->SetWriteRowAction(iRow, eST_ROW_IGNORE)))
                                return hr;
                            if(FAILED(hr = i_pISTController->SetWriteRowAction(iMatchingRow, eST_ROW_INSERT)))
                                return hr;
                            bContinueProcessingCurrentRow = false;
                            break;
                        case eST_ROW_DELETE:
                        //1.3   A row is has a WriteRowAction of eST_ROW_INSERT
                        //      A second row (matching the first's PK) is marked as eST_ROW_DELETE
                        //      Result:
                        //      1st row marked as eST_ROW_IGNORE.
                        //      Stop processing 1st row (processing of the 2nd row will handle
                        //                      additional conflicting PKs).
                            if(FAILED(hr = i_pISTController->SetWriteRowAction(iRow, eST_ROW_IGNORE)))
                                return hr;
                            bContinueProcessingCurrentRow = false;
                            break;
                        case eST_ROW_IGNORE:
                        //1.4   A row is has a WriteRowAction of eST_ROW_INSERT
                        //      A second row (matching the first's PK) is marked as eST_ROW_IGNORE
                        //      Result:
                        //      None action, continue validating against 1st row
                            break;
                        default:
                            ASSERT(false && "Invalid Action returned from GetWriteRowAction");
                            continue;
                        }
                    }
                    break;
                case eST_ROW_UPDATE:
                    {
                        switch(eMatchingRowAction)
                        {
                        case eST_ROW_INSERT:
                        //2.1   A row is has a WriteRowAction of eST_ROW_UPDATE
                        //      A second row (matching the first's PK) is marked as eST_ROW_INSERT
                        //      Result:
                        //      Detailed Error - (All rows matching the PK are marked as
                        //                        eST_ROW_IGNORE and Detailed Error is added)
                        //
                            ste.hr = E_ST_ROWCONFLICT;//This indicates to log a DetailedError below, on iMatchingRow.
                            break;
                        case eST_ROW_UPDATE:
                        //2.2   A row is has a WriteRowAction of eST_ROW_UPDATE
                        //      A second row (matching the first's PK) is marked as eST_ROW_UPDATE
                        //      Result:
                        //      1st row marked as eST_ROW_IGNORE.
                        //      Stop processing 1st row (processing of the 2nd row will handle
                        //                      additional conflicting PKs).
                            if(FAILED(hr = i_pISTController->SetWriteRowAction(iRow, eST_ROW_IGNORE)))
                                return hr;
                            bContinueProcessingCurrentRow = false;
                            break;
                        case eST_ROW_DELETE:
                        //2.3   A row is has a WriteRowAction of eST_ROW_UPDATE
                        //      A second row (matching the first's PK) is marked as eST_ROW_DELETE
                        //      Result:
                        //      1st row marked as eST_ROW_IGNORE
                        //      Stop processing 1st row (processing of the 2nd row will handle
                        //                      additional conflicting PKs).
                            if(FAILED(hr = i_pISTController->SetWriteRowAction(iRow, eST_ROW_IGNORE)))
                                return hr;
                            bContinueProcessingCurrentRow = false;
                            break;
                        case eST_ROW_IGNORE:
                        //2.4   A row is has a WriteRowAction of eST_ROW_UPDATE
                        //      A second row (matching the first's PK) is marked as eST_ROW_IGNORE
                        //      Result:
                        //      None action, continue validating against 1st row
                            break;
                        default:
                            ASSERT(false && "Invalid Action returned from GetWriteRowAction");
                            continue;
                        }
                    }
                    break;
                case eST_ROW_DELETE:
                    {
                        switch(eMatchingRowAction)
                        {
                        case eST_ROW_INSERT:
                        //3.1   A row is has a WriteRowAction of eST_ROW_DELETE
                        //      A second row (matching the first's PK) is marked as eST_ROW_INSERT
                        //      Result:
                        //      1st row marked as eST_ROW_IGNORE
                        //      2nd row marked as eST_ROW_UPDATE
                        //      Stop processing 1st row (processing of the 2nd row will handle
                        //                      additional conflicting PKs).
                            if(FAILED(hr = i_pISTController->SetWriteRowAction(iRow, eST_ROW_IGNORE)))
                                return hr;
                            if(FAILED(hr = i_pISTController->SetWriteRowAction(iMatchingRow, eST_ROW_UPDATE)))
                                return hr;
                            bContinueProcessingCurrentRow = false;
                            break;
                        case eST_ROW_UPDATE:
                        //3.2   A row is has a WriteRowAction of eST_ROW_DELETE
                        //      A second row (matching the first's PK) is marked as eST_ROW_UPDATE
                        //      Result:
                        //      Detailed Error - (All rows matching the PK are marked as
                        //                        eST_ROW_IGNORE and Detailed Error is added)
                            ste.hr = E_ST_ROWCONFLICT;//This indicates to log a DetailedError below, on iMatchingRow.
                            break;
                        case eST_ROW_DELETE:
                        //3.3   A row is has a WriteRowAction of eST_ROW_DELETE
                        //      A second row (matching the first's PK) is marked as eST_ROW_DELETE
                        //      Result:
                        //      1st row marked as eST_ROW_IGNORE.
                        //      Stop processing 1st row (processing of the 2nd row will handle
                        //                      additional conflicting PKs).
                            if(FAILED(hr = i_pISTController->SetWriteRowAction(iRow, eST_ROW_IGNORE)))
                                return hr;
                            bContinueProcessingCurrentRow = false;
                            break;
                        case eST_ROW_IGNORE:
                        //3.4   A row is has a WriteRowAction of eST_ROW_DELETE
                        //      A second row (matching the first's PK) is marked as eST_ROW_IGNORE
                        //      Result:
                        //      None action, continue validating against 1st row
                            break;
                        default:
                            ASSERT(false && "Invalid Action returned from GetWriteRowAction");
                            continue;
                        }
                    }
                    break;
                case eST_ROW_IGNORE:
                    //      No other processing needs to be done
                    bContinueProcessingCurrentRow = false;
                    break;
                default:
                    ASSERT(false && "Invalid Action returned from GetWriteRowAction");
                    break;
                }
            }

            if(FAILED(ste.hr))
            {   // Add detailed error
                if(false == saRowHasDetailedErrorLogged[iRow])
                {   //if we haven't already logged iRow as a DetailedError then do it now
                    ste.iColumn = (ULONG) iST_ERROR_ALLCOLUMNS;
                    ste.iRow    = iRow;
                    //ste.hr is set above to trigger this DetailedError

                    saRowHasDetailedErrorLogged[iRow] = true;

                    DBGPRINTF(( DBG_CONTEXT,
                                "Detailed error: hr = 0x%x", hr ));

                    hr = i_pISTController->AddDetailedError(&ste);
                    ASSERT(SUCCEEDED(hr));//Not sure what to do if this fails.
                    o_bDetailedError = true;//at least on DetailedError was logged
                }

                ste.iColumn = (ULONG) iST_ERROR_ALLCOLUMNS;
                ste.iRow = iMatchingRow;

                DBGPRINTF(( DBG_CONTEXT,
                            "Detailed error: hr = 0x%x", hr ));

                hr = i_pISTController->AddDetailedError(&ste);
                ASSERT(SUCCEEDED(hr));//Not sure what to do if this fails.

                saRowHasDetailedErrorLogged[iMatchingRow] = true;//No further processing for this row
                //o_bDetailedError = true; no need for this since all DetailedErrors are reported to iRow first
                ste.hr = S_OK;//reset the error.
            }//FAILED(ste.hr)

        }//while(bContinueProcessingCurrentRow)
    }//for(iRow = 0; ; iRow++)

    return S_OK;
}//ValidateWriteCache


HRESULT CXmlSDT::XMLDelete(ISimpleTableWrite2 *pISTW2, IXMLDOMDocument *pXMLDoc, IXMLDOMElement *pElementRoot, unsigned long iRow, IXMLDOMNodeList *pNodeList_ExistingRows, long cExistingRows)
{
    UNREFERENCED_PARAMETER(pXMLDoc);
    UNREFERENCED_PARAMETER(pElementRoot);

    if(0 == cExistingRows)//the row may have already been deleted, which is OK
        return S_OK;

    HRESULT hr;

    if(FAILED(hr = pISTW2->GetWriteColumnValues(iRow, CountOfColumns(), 0, m_aStatus, m_aSizes, m_apvValues)))return hr;

    CComPtr<IXMLDOMNode> pNode_Matching;
    if(FAILED(hr = GetMatchingNode(pNodeList_ExistingRows, pNode_Matching)))
        return hr;//using the ColumnValues we just got, match up with a Node in the list

    if(0 == pNode_Matching.p)//if the node doesn't already exist then presume that it's already been deleted, which is OK.
        return S_OK;

    return RemoveElementAndWhiteSpace(pNode_Matching);
}


HRESULT CXmlSDT::XMLInsert(ISimpleTableWrite2 *pISTW2, IXMLDOMDocument *pXMLDoc, IXMLDOMElement *pElementRoot, unsigned long iRow, IXMLDOMNodeList *pNodeList_ExistingRows, long cExistingRows)
{
    HRESULT     hr;
    CComVariant null;//initialized as 'Cleared'
    bool bParentNodeCreated = false;

    ASSERT(pXMLDoc);

    if(FAILED(hr = pISTW2->GetWriteColumnValues(iRow, CountOfColumns(), 0, m_aStatus, m_aSizes, m_apvValues)))
        return hr;

    CComPtr<IXMLDOMNode> pNode_Matching;
    if(FAILED(hr = GetMatchingNode(pNodeList_ExistingRows, pNode_Matching)))
        return hr;//using the ColumnValues we just got, match up with a Node in the list

    if(0 != pNode_Matching.p)//if we found a node matching this one's PKs then we can't add this one.
    {
		if (m_fLOS & fST_LOS_INSERT_OR_UPDATE)
		{
			// do something
			return XMLUpdate (pISTW2, pXMLDoc, pElementRoot, iRow, pNodeList_ExistingRows, cExistingRows, pNode_Matching.p);
		}
		else
		{
			LOG_UPDATE_ERROR1(IDS_COMCAT_XML_ROWALREADYEXISTS, E_ST_ROWALREADYEXISTS, (ULONG) -1, L"");
			return E_ST_ROWALREADYEXISTS;
		}
    }


    //OK now we need to find or create this new row's parent
    CComPtr<IXMLDOMNode>    pNode_SiblingParent;
    CComPtr<IXMLDOMNode>    pNode_Parent;

    if(m_bSiblingContainedTable)
    {
        if(FAILED(hr = FindSiblingParentNode(pElementRoot, &pNode_SiblingParent)))
            return hr;

        if(FAILED(hr = pNode_SiblingParent->get_parentNode(&pNode_Parent)))
            return hr;
    }
    //If the table is contained, then the parent (or grandparent) must already exist, so look for it.
    else if(*m_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_ISCONTAINED)//If this table is contained with another, then we need to find the parent table element
    {                                                                 //that should contain this table.
        //So first find the FKs that belong only one level up (two levels if this table is SCOPEDBYTABLENAME
        unsigned long iFKColumn, iLevel;

        iLevel = (*m_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_NOTSCOPEDBYTABLENAME) ? 1 : 2;

        for(iFKColumn=0; iFKColumn< CountOfColumns(); ++iFKColumn)
        {   //find the first FK that is at iLevel (one or two), so we know what PublicRowName to search for
            if(m_aLevelOfColumnAttribute[iFKColumn] == iLevel)
                break;
        }
        ASSERT(iFKColumn < CountOfColumns());

        //Before we scan the parent list, let's see if the last parent we saw matches
        if(m_pLastPrimaryTable.p)
        {
            CComPtr<IXMLDOMNode> pNode_Row = m_pLastPrimaryTable;

            bool bMatch=true;
            for(unsigned long iColumn=0; bMatch && iColumn < *m_TableMetaRow.pCountOfColumns; ++iColumn)
            {
                if(m_aLevelOfColumnAttribute[iColumn] < iLevel)//We're just trying to match up all of the FKs that describe the containment
                    continue;

                CComPtr<IXMLDOMNode> pNode_RowTemp = pNode_Row;
                //Depending on the column, we may need to look at an element a few levels up.
                unsigned int nLevelOfColumnAttribute = m_aLevelOfColumnAttribute[iColumn] - iLevel;//Only (PK | FK) columns should have a non zero value here
                while(nLevelOfColumnAttribute--)
                {   //Find the correct level of ancestor
                    CComPtr<IXMLDOMNode> pNode_Parent;
                    if(FAILED(hr = pNode_RowTemp->get_parentNode(&pNode_Parent)))
                        return hr;

                    if(pNode_Parent==0)
                        return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;

                    pNode_RowTemp.Release();
                    pNode_RowTemp = pNode_Parent;
                }
                if(m_awstrChildElementName[iColumn].c_str())//This attribute comes from the child
                {
                    CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> spElement_Row = pNode_RowTemp;
                    CComPtr<IXMLDOMNodeList>                        spNodeList_Children;
                    CComBSTR                                        bstrChildElementName = m_awstrChildElementName[iColumn].c_str();
                    if(0 == bstrChildElementName.m_str)
                        return E_OUTOFMEMORY;
                    if(FAILED(hr = spElement_Row->getElementsByTagName(bstrChildElementName, &spNodeList_Children)))
                        return hr;

                    //It might be more appropriate to use getChildren, then walk the list and find the first node that's an Element.
                    CComPtr<IXMLDOMNode> spChild;
                    if(FAILED(hr = spNodeList_Children->nextNode(&spChild)))
                        return hr;
                    if(spChild == 0)//no children
                    {
                        bMatch = false;
                        continue;
                    }
                    pNode_RowTemp.Release();
                    pNode_RowTemp = spChild;//make this the node we examine
                }
                //Now that we've got the right row, get the IXMLDOMElement interface to it.
                CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement_Row = pNode_RowTemp;
                if(0 == pElement_Row.p)return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;

                if(m_acolmetas[iColumn].fMeta & fCOLUMNMETA_NOTPERSISTABLE)
                {
                    CComBSTR bstrElementName;
                    if(FAILED(hr = pElement_Row->get_baseName(&bstrElementName)))
                        return hr;
                    bMatch = m_aPublicRowName[iColumn].IsEqual(bstrElementName.m_str, bstrElementName.Length());
                    continue;
                }
                CComPtr<IXMLDOMAttribute> pNode_Attr;
                if(FAILED(hr = pElement_Row->getAttributeNode(m_abstrColumnNames[iColumn], &pNode_Attr)))return hr;
                if((0 == pNode_Attr.p) && (0 == m_aDefaultValue[iColumn]))
                {
                    bMatch = false;
                    DBGPRINTF(( DBG_CONTEXT,
                                "We found the element that matches the public row, no attributes and no default value!\n" ));
                    continue;
                }
                if(0==m_awstrChildElementName[iColumn].c_str())//We already know the parent matches if we got the attribute from the child
                {                                              //In fact, because of the late implementation of this feature, the m_aPublicRowName
                                                               //for this column is actually WRONG; but fixing it breaks something else.
                    //The parent element name must match
                    CComBSTR bstrElementName;
                    if(FAILED(hr = pElement_Row->get_baseName(&bstrElementName)))
                        return hr;
                    if(!m_aPublicRowName[iColumn].IsEqual(bstrElementName.m_str, bstrElementName.Length()))
                    {
                        bMatch = false;
                        continue;
                    }
                }

                CComVariant var_Attr;
                if(0 != pNode_Attr.p)
                {
                    if(FAILED(hr = pNode_Attr->get_value(&var_Attr)))
                        return hr;
                }

                if(FAILED(hr = IsMatchingColumnValue(iColumn, (0 != pNode_Attr.p) ? var_Attr.bstrVal : 0, bMatch)))
                    return hr;
            }

            if(bMatch)//If we walked all the columns and none were a mismatch then we know where the new row belongs
                pNode_Parent = m_pLastParent;
        }

        if(0 == pNode_Parent.p)
        {
            ++m_cCacheMiss;
            //Get the list of rows that match the PrimaryTable's PublicRowName
            CComPtr<IXMLDOMNodeList> pList_Parent;
            if(FAILED(hr = pElementRoot->getElementsByTagName(CComBSTR(m_aPublicRowName[iFKColumn].GetFirstPublicRowName()), &pList_Parent)))return hr;

            if(0 == m_cchLocation)//if there is no query by location, then we have to eliminate the tags by the correct
            {                     //name but at the wrong level
                CComPtr<IXMLDOMNodeList> spNodeListWithoutLocation;
                if(FAILED(hr = ReduceNodeListToThoseNLevelsDeep(pList_Parent, m_BaseElementLevel-iLevel, &spNodeListWithoutLocation)))
                    return hr;

                pList_Parent.Release();
                pList_Parent = spNodeListWithoutLocation;
            }

            unsigned long cParentTags;
            if(FAILED(hr = pList_Parent->get_length(reinterpret_cast<long *>(&cParentTags))))return hr;

            //Walk the PrimaryTable rows looking for a match
            while(cParentTags--)
            {
                CComPtr<IXMLDOMNode> pNode_Row;
                if(FAILED(hr = pList_Parent->nextNode(&pNode_Row)))return hr;

                //We have to ignore text nodes.
                DOMNodeType nodetype;
                if(FAILED(hr = pNode_Row->get_nodeType(&nodetype)))return hr;
                if(NODE_ELEMENT != nodetype)
                    continue;

                bool bMatch=true;
                for(unsigned long iColumn=0; bMatch && iColumn < *m_TableMetaRow.pCountOfColumns; ++iColumn)
                {
                    if(m_aLevelOfColumnAttribute[iColumn] < iLevel)//We're just trying to match up all of the FKs that describe the containment
                        continue;

                    CComPtr<IXMLDOMNode> pNode_RowTemp = pNode_Row;
                    //Depending on the column, we may need to look at an element a few levels up.
                    unsigned int nLevelOfColumnAttribute = m_aLevelOfColumnAttribute[iColumn] - iLevel;//Only (PK | FK) columns should have a non zero value here
                    while(nLevelOfColumnAttribute--)
                    {   //Find the correct level of ancestor
                        CComPtr<IXMLDOMNode> pNode_Parent;
                        if(FAILED(hr = pNode_RowTemp->get_parentNode(&pNode_Parent)))
                            return hr;

                        if(pNode_Parent==0)
                            return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;

                        pNode_RowTemp.Release();
                        pNode_RowTemp = pNode_Parent;
                    }
                    if(m_awstrChildElementName[iColumn].c_str())//This attribute comes from the child
                    {
                        CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> spElement_Row = pNode_RowTemp;
                        CComPtr<IXMLDOMNodeList>                        spNodeList_Children;
                        CComBSTR                                        bstrChildElementName = m_awstrChildElementName[iColumn].c_str();
                        if(0 == bstrChildElementName.m_str)
                            return E_OUTOFMEMORY;
                        if(FAILED(hr = spElement_Row->getElementsByTagName(bstrChildElementName, &spNodeList_Children)))
                            return hr;

                        //It might be more appropriate to use getChildren, then walk the list and find the first node that's an Element.
                        CComPtr<IXMLDOMNode> spChild;
                        if(FAILED(hr = spNodeList_Children->nextNode(&spChild)))
                            return hr;
                        if(spChild == 0)//no children
                        {
                            bMatch = false;
                            continue;
                        }
                        pNode_RowTemp.Release();
                        pNode_RowTemp = spChild;//make this the node we examine
                    }
                    //Now that we've got the right row, get the IXMLDOMElement interface to it.
                    CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement_Row = pNode_RowTemp;
                    if(0 == pElement_Row.p)return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;

                    if(m_acolmetas[iColumn].fMeta & fCOLUMNMETA_NOTPERSISTABLE)
                    {
                        CComBSTR bstrElementName;
                        if(FAILED(hr = pElement_Row->get_baseName(&bstrElementName)))
                            return hr;
                        bMatch = m_aPublicRowName[iColumn].IsEqual(bstrElementName.m_str, bstrElementName.Length());
                        continue;
                    }

                    CComPtr<IXMLDOMAttribute> pNode_Attr;
                    if(FAILED(hr = pElement_Row->getAttributeNode(m_abstrColumnNames[iColumn], &pNode_Attr)))return hr;
                    if((0 == pNode_Attr.p) && (0 == m_aDefaultValue[iColumn]))
                    {
                        bMatch = false;
                        DBGPRINTF(( DBG_CONTEXT,
                                    "We found the element that matches the public row, no attributes and no default value!\n" ));
                        continue;
                    }

                    if(0==m_awstrChildElementName[iColumn].c_str())//We already know the parent matches if we got the attribute from the child
                    {                                              //In fact, because of the late implementation of this feature, the m_aPublicRowName
                                                                   //for this column is actually WRONG; but fixing it breaks something else.
                        //The parent element name must match
                        CComBSTR bstrElementName;
                        if(FAILED(hr = pElement_Row->get_baseName(&bstrElementName)))
                            return hr;
                        if(!m_aPublicRowName[iColumn].IsEqual(bstrElementName.m_str, bstrElementName.Length()))
                        {
                            bMatch = false;
                            continue;
                        }
                    }

                    CComVariant var_Attr;
                    if(0 != pNode_Attr.p)
                    {
                        if(FAILED(hr = pNode_Attr->get_value(&var_Attr)))
                            return hr;
                    }

                    if(FAILED(hr = IsMatchingColumnValue(iColumn, (0 != pNode_Attr.p) ? var_Attr.bstrVal : 0, bMatch)))
                        return hr;
                }

                if(bMatch)//If we walked all the columns and none were a mismatch then we know where the new row belongs
                {
                    m_pLastPrimaryTable.Release();
                    m_pLastPrimaryTable = pNode_Row;
                    if(*m_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_NOTSCOPEDBYTABLENAME)
                    {   //If the row exists directly under this PrimaryTable row, then we already have the parent
                        pNode_Parent = pNode_Row;
                        m_pLastParent.Release();
                        m_pLastParent = pNode_Parent;
                        break;
                    }
                    else
                    {   //otherwise we need to search to see if a PublicTableName element already exists under this element
                        CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement_Row = pNode_Row;
                        CComPtr<IXMLDOMNodeList> pNode_List;


						// getElementsByTagName returns all children recursively, so also grand children, grand grand
						// children, etc are returned. So we have to loop through all the children, and ensure that we
						// only consider the direct children of pElement_Row.
                        if(FAILED(hr = pElement_Row->getElementsByTagName(m_bstrPublicTableName, &pNode_List)))
                            return hr;

						// get current element name
						CComBSTR bstrElement_RowName;
						hr = pElement_Row->get_baseName (&bstrElement_RowName);
						if (FAILED (hr))
						{
							return hr;
						}

						for (;;) // we break out for loop when there are no more children or found correct child.
						{
							CComPtr<IXMLDOMNode> spChildNode;
							hr = pNode_List->nextNode(&spChildNode);
							if (FAILED (hr))
							{
								return hr;
							}
							if (spChildNode.p == 0)
							{
								pNode_Parent = 0;
								break;
							}

							CComPtr<IXMLDOMNode> spParentNode;
							hr = spChildNode->get_parentNode(&spParentNode);
							if (FAILED (hr))
							{
								return hr;
							}

							CComBSTR bstrParentName;

							hr = spParentNode->get_baseName (&bstrParentName);
							if (FAILED (hr))
							{
								return hr;
							}

							if (StringCompare((LPWSTR) bstrParentName, (LPWSTR) bstrElement_RowName) == 0)
							{
								pNode_Parent = spChildNode;
								break;
							}
						}

                        if(0 == pNode_Parent.p)//if the public table name does not already exist, we need to create it
                        {
                            CComPtr<IXMLDOMNode> pNode_New;
                            CComVariant varElement(L"element");

                            TComBSTR bstr_NameSpace;
                            if(FAILED(hr = pNode_Row->get_namespaceURI(&bstr_NameSpace)))
                                return hr;//Get the namespace of the table
                            if(FAILED(hr = pXMLDoc->createNode(varElement, m_bstrPublicTableName, bstr_NameSpace, &pNode_New)))
                                return hr;//make the new element of that same namespace
                            if(FAILED(hr = pXMLDoc->put_validateOnParse(kvboolFalse)))//Tell parser whether to validate according to an XML schema or DTD
                                return hr;

							CComPtr<IXMLDOMNode> spFirstChild;
							ULONG cNewLineChars = 0;
							ULONG cTabs			= m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[0]];
							if (FAILED(hr = pNode_Row->get_firstChild(&spFirstChild)))
								return hr;

							if (spFirstChild.p == 0)
							{
								cNewLineChars = 1;
							}
							else
							{
								cTabs--;
							}

                            //We don't care about the error here, it will just mean that the XML is unformatted.
                            AppendNewLineWithTabs(cTabs, pXMLDoc, pNode_Row, cNewLineChars);

                            //Add the newly create element under the PrimaryTable's row.
                            if(FAILED(hr = pNode_Row->appendChild(pNode_New, &pNode_Parent)))
                                return hr;

                            //We don't care about the error here, it will just mean that the XML is unformatted.
                            AppendNewLineWithTabs(m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[0]] -1, pXMLDoc, pNode_Row);
                            bParentNodeCreated = true;
                        }
                        m_pLastParent.Release();
                        m_pLastParent = pNode_Parent;
                        break;
                    }
                }
            }
            if(0 == pNode_Parent.p)//If we walked the list of PrimaryTable's PublicRows and didn't find a match then we cannot proceed.  With containment,
            {                      //the PrimaryTable needs to already exist.
                LOG_UPDATE_ERROR1(IDS_COMCAT_XML_PARENTTABLEDOESNOTEXIST, E_SDTXML_PARENT_TABLE_DOES_NOT_EXIST, (ULONG) -1, L"");
                return E_SDTXML_PARENT_TABLE_DOES_NOT_EXIST;
            }
        }
        else
        {
            ++m_cCacheHit;
        }
    }
    else
    {   //If no containment
        if(0 == cExistingRows)
        {
            //If no existing rows
            if(0 == (*m_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_NOTSCOPEDBYTABLENAME))
            {
                //It's still possible that the PublicTableName element exists.  If it is then we don't need to create it.
                CComPtr<IXMLDOMNodeList> pNodeList;
                if(FAILED(hr = pElementRoot->getElementsByTagName(m_bstrPublicTableName, &pNodeList)))return hr;

                if(0 == m_cchLocation)//if there is no query by location
                {
                    CComPtr<IXMLDOMNodeList> pNodeListWithoutLocation;
                    if(FAILED(hr = ReduceNodeListToThoseNLevelsDeep(pNodeList, m_BaseElementLevel-1, &pNodeListWithoutLocation)))
                        return hr;

                    pNodeList.Release();
                    pNodeList = pNodeListWithoutLocation;
                }
                if(FAILED(hr = pNodeList->nextNode(&pNode_Parent)))return hr;
            }

            if(!pNode_Parent)
            {
                if(0 == (*m_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_NOTSCOPEDBYTABLENAME))
                {   //if PublicRows are scoped by the Table's PublicName, then create the TablePublicName element
                    //Create the outer TableName element, this becomes the parent to the row to be inserted
                    CComPtr<IXMLDOMNode> pNode_New;
                    CComVariant varElement(L"element");

                    TComBSTR bstr_NameSpace;
                    if(FAILED(hr = pElementRoot->get_namespaceURI(&bstr_NameSpace)))
                        return hr;//Get the namespace of the table
                    if(FAILED(hr = pXMLDoc->createNode(varElement, m_bstrPublicTableName, bstr_NameSpace, &pNode_New)))
                        return hr;//make the new element of that same namespace

                    //We don't care about the error here, it will just mean that the XML is unformatted.
                    AppendNewLineWithTabs(m_BaseElementLevel-2, pXMLDoc, pElementRoot, 0);

                    if(FAILED(hr = pElementRoot->appendChild(pNode_New, &pNode_Parent)))
                        return hr;

                    //We don't care about the error here, it will just mean that the XML is unformatted.
                    AppendNewLineWithTabs(0, pXMLDoc, pElementRoot);//we added at the root, so newline only
                    bParentNodeCreated = true;
                }
                else
                {   //if not scoped, then the root is the parent
                    pNode_Parent = pElementRoot;
                }
            }
        }
        else
        {   //If a row already exists (and is not contained) then the first row's parent is the parent of the new row as well.
            CComPtr<IXMLDOMNode> pNode_FirstRow;
            if(FAILED(hr = pNodeList_ExistingRows->reset()))return hr;

            if(FAILED(hr = pNodeList_ExistingRows->nextNode(&pNode_FirstRow)))return hr;

            if(FAILED(hr = pNode_FirstRow->get_parentNode(&pNode_Parent)))
                return hr;

            if(pNode_Parent==0)
                return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;
        }
    }

    CComPtr<IXMLDOMNode> spNodeNew;
    if(FAILED(hr = CreateNewNode(pXMLDoc, pNode_Parent, &spNodeNew)))
        return hr;

    CComPtr<IXMLDOMNode> spNodeNew_Child;
    if(-1 != m_iCol_TableRequiresAdditionChildElement)//sometimes values come from a child element.  So create the child too.
    {
        CComPtr<IXMLDOMNode>    spNode_NewChildTemp;
        CComVariant             varElement(L"element");

        TComBSTR                bstr_NameSpace;
        if(FAILED(hr = pNode_Parent->get_namespaceURI(&bstr_NameSpace)))
            return hr;//Get the namespace of the table

        CComBSTR bstrChildElementName = m_awstrChildElementName[m_iCol_TableRequiresAdditionChildElement].c_str();
        if(0 == bstrChildElementName.m_str)
            return E_OUTOFMEMORY;

        if(FAILED(hr = pXMLDoc->createNode(varElement, bstrChildElementName, bstr_NameSpace, &spNode_NewChildTemp)))
            return hr;//make the new element of that same namespace

        AppendNewLineWithTabs(2+m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[0]], pXMLDoc, spNodeNew);
        if(FAILED(hr = spNodeNew->appendChild(spNode_NewChildTemp, &spNodeNew_Child)))
            return hr;
		AppendNewLineWithTabs(1+m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[0]], pXMLDoc, spNodeNew);
    }

    if(FAILED(hr = SetRowValues(spNodeNew, spNodeNew_Child)))
        return hr;
    if(FAILED(hr = pXMLDoc->put_validateOnParse(kvboolFalse)))//Tell parser whether to validate according to an XML schema or DTD
        return hr;


    if(m_bSiblingContainedTable)
    {
        CComPtr<IXMLDOMNode> pNodeRowToInsertBefore;
        CComPtr<IXMLDOMNode> pNodeJustInserted;
        if(FAILED(hr = pNode_SiblingParent->get_nextSibling(&pNodeRowToInsertBefore)) || 0==pNodeRowToInsertBefore.p)
        {   //if there are no XML siblings, then this is the first row (associated with this SiblingParent)
            if(FAILED(hr = pNode_Parent->appendChild(spNodeNew, &pNodeJustInserted)))
                return hr;
            AppendNewLineWithTabs(m_BaseElementLevel, pXMLDoc, pNode_Parent);
        }
        else
        {   //if there is a XML Sibling, the insert the new row before the existing one.
            CComVariant varNode = pNodeRowToInsertBefore;
            if(FAILED(hr = pNode_Parent->insertBefore(spNodeNew, varNode, &pNodeJustInserted)))
                return hr;
            //if this fails, it's not the end of the world (necessarily).
            InsertNewLineWithTabs(m_BaseElementLevel-1, pXMLDoc, pNodeJustInserted, pNode_Parent);
        }
    }
    else
    {
        //We don't care about the error here, it will just mean that the XML is unformatted.
        if(bParentNodeCreated)//add a newline + tabs
            AppendNewLineWithTabs(m_BaseElementLevel-1, pXMLDoc, pNode_Parent);
        else
		{
			ULONG cNewLines = 0;
			ULONG cNrTabs = 1;
			CComPtr<IXMLDOMNode> spFirstChild;
			hr = pNode_Parent->get_firstChild (&spFirstChild);
			if (FAILED (hr))
			{
				return hr;
			}
			if (spFirstChild.p == 0)
			{
				cNewLines = 1;
				cNrTabs = m_BaseElementLevel - 1;
			}

            AppendNewLineWithTabs(cNrTabs,pXMLDoc, pNode_Parent, cNewLines);//The next element is always one level higher so insert a single tab
		}

        //insert the new node into the table
        if(FAILED(hr = pNode_Parent->appendChild(spNodeNew, 0)))
            return hr;

        AppendNewLineWithTabs(m_BaseElementLevel-2, pXMLDoc, pNode_Parent);

    }

    return S_OK;
}


HRESULT CXmlSDT::XMLUpdate(ISimpleTableWrite2 *pISTW2, IXMLDOMDocument *pXMLDoc, IXMLDOMElement *pElementRoot, unsigned long iRow, IXMLDOMNodeList *pNodeList_ExistingRows, long cExistingRows, IXMLDOMNode * i_pNode_Matching)
{
    UNREFERENCED_PARAMETER(pElementRoot);

    if(0 == cExistingRows)
    {
        LOG_UPDATE_ERROR1(IDS_COMCAT_XML_ROWDOESNOTEXIST, E_ST_ROWDOESNOTEXIST, (ULONG) -1, L"");
        return E_ST_ROWDOESNOTEXIST;
    }

    HRESULT hr;

    if(FAILED(hr = pISTW2->GetWriteColumnValues(iRow, CountOfColumns(), 0, m_aStatus, m_aSizes, m_apvValues)))
        return hr;

    CComPtr<IXMLDOMNode> pNode_Matching = i_pNode_Matching;
	if (pNode_Matching.p == 0)
	{
	    if(FAILED(hr = GetMatchingNode(pNodeList_ExistingRows, pNode_Matching)))
		    return hr;//using the ColumnValues we just got, match up with a Node in the list

		if(0 == pNode_Matching.p)
		{
			LOG_UPDATE_ERROR1(IDS_COMCAT_XML_ROWDOESNOTEXIST, E_ST_ROWDOESNOTEXIST, (ULONG) -1, L"");
			return E_ST_ROWDOESNOTEXIST;
		}
	}

    //if there isn't an XMLBlob column OR it's value is NULL, then just update as usual
    if(-1 == m_iXMLBlobColumn || 0 == m_apvValues[m_iXMLBlobColumn])
        return SetRowValues(pNode_Matching);


    //XMLBlob specific
    //But if there is an XMLBlob, remove then do an update by doing Delete and Insert
    CComPtr<IXMLDOMNode> spNodeParent;
    if(FAILED(hr = pNode_Matching->get_parentNode(&spNodeParent)))
        return hr;

    if(FAILED(hr = RemoveElementAndWhiteSpace(pNode_Matching)))
        return hr;

    CComPtr<IXMLDOMNode> spNodeNew;
    if(FAILED(hr = CreateNewNode(pXMLDoc, spNodeParent, &spNodeNew)))
        return hr;
    if(FAILED(hr = SetRowValues(spNodeNew)))
        return hr;
    if(FAILED(hr = pXMLDoc->put_validateOnParse(kvboolFalse)))//Tell parser whether to validate according to an XML schema or DTD
        return hr;

    CComPtr<IXMLDOMText> pNode_Newline;
    TComBSTR    bstrNewline(IsScopedByTableNameElement() ? L"\t" : L"\r\n\t");
    if(FAILED(hr = pXMLDoc->createTextNode(bstrNewline, &pNode_Newline)))
        return hr;
    CComVariant null;//initialized as 'Cleared'
    if(FAILED(hr = spNodeParent->insertBefore(pNode_Newline, null, 0)))
        return hr;

    //and finally insert the new node into the table
    if(FAILED(hr = spNodeParent->appendChild(spNodeNew, 0)))return hr;

    //We don't care about the error here, it will just mean that the XML is unformatted.
    AppendNewLineWithTabs(IsScopedByTableNameElement() ? 1+m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[0]] : 0, pXMLDoc, spNodeParent);
    return S_OK;
}


// ------------------------------------
// ISimpleTableInterceptor
// ------------------------------------
STDMETHODIMP CXmlSDT::Intercept(    LPCWSTR i_wszDatabase,  LPCWSTR i_wszTable, ULONG i_TableID, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD i_eQueryFormat,
                                    DWORD i_fLOS,           IAdvancedTableDispenser* i_pISTDisp,    LPCWSTR /*i_wszLocator unused*/,
                                    LPVOID i_pSimpleTable,  LPVOID* o_ppvSimpleTable)
{
    HRESULT hr;

    //If we've already been called to Intercept, then fail
    if(0 != m_IsIntercepted)return E_UNEXPECTED;

    //Some basic parameter validation:
    if(i_pSimpleTable)return E_INVALIDARG;//We're at the bottom of the Table hierarchy.  A table under us is Chewbacca.  This is NOT a logic table.
    if(0 == i_pISTDisp)return E_INVALIDARG;
    if(0 == o_ppvSimpleTable)return E_INVALIDARG;

    ASSERT(0 == *o_ppvSimpleTable && "This should be NULL.  Possible memory leak or just an uninitialized variable.");
    *o_ppvSimpleTable = 0;

    if(eST_QUERYFORMAT_CELLS != i_eQueryFormat)return E_ST_QUERYNOTSUPPORTED;//Verify query type.
    // For the CookDown process we have a logic table that sits above this during PopulateCache time.
    // Hence we should support fST_LOS_READWRITE
    if(fST_LOS_MARSHALLABLE & i_fLOS)return E_ST_LOSNOTSUPPORTED;//check table flags

    //We're delay loading OleAut32 so we need to know if it exists before continueing with a read/write table.  Otherwise we'll get an exception the first time we try to use OleAut32.
    {
        static bool bOleAut32Exists = false;
        if(!bOleAut32Exists)
        {
            WCHAR szOleAut32[MAX_PATH+13];//make room for the wcscat

            DWORD rtn = GetSystemDirectory(szOleAut32, MAX_PATH);
            if(0 == rtn || rtn >= MAX_PATH)
                return E_UNEXPECTED;
            wcscat(szOleAut32, L"\\OleAut32.dll");
            if(-1 == GetFileAttributes(szOleAut32))
                return E_UNEXPECTED;//This file should always be there.  It's installed with the system.
            bOleAut32Exists = true;
        }
    }

    //Now that we're done with parameter validation
    //Store for later use the query string and type
    m_fLOS=i_fLOS;

    //Create this singleton for future use
    m_pISTDisp = i_pISTDisp;
    m_wszTable = i_wszTable;

    //This has nothing to do with InternalSimpleInitialize.  This just gets the meta and saves some of it in a more accessible form.
    //This calls GetTable for the meta.  It should probably call the IST (that we get from GetMemoryTable).
    hr = InternalComplicatedInitialize(i_wszDatabase);
    if(FAILED(hr))return hr;

    STQueryCell *   pQueryCell = (STQueryCell*) i_QueryData;    // Query cell array from caller.

    for(unsigned long iColumn=0; iColumn<*m_TableMetaRow.pCountOfColumns; ++iColumn)
    {
        m_aQuery[iColumn].pData  = 0;
        m_aQuery[iColumn].dbType = 0;
    }

    bool    bNonSpecialQuerySpecified = false;
    int     nQueryCount = i_QueryMeta ? *reinterpret_cast<ULONG *>(i_QueryMeta) : 0;
    while(nQueryCount--)//Get the only query cell we care about, and save the information.
    {
        if(pQueryCell[nQueryCount].iCell & iST_CELL_SPECIAL)
        {
            switch(pQueryCell[nQueryCount].iCell)
            {
            case iST_CELL_LOCATION:
                if(pQueryCell[nQueryCount].pData     != 0                  &&
                   pQueryCell[nQueryCount].eOperator == eST_OP_EQUAL       &&
                   pQueryCell[nQueryCount].dbType    == DBTYPE_WSTR        )
                {
                    ++m_BaseElementLevel;

                    m_cchLocation = (ULONG) wcslen(reinterpret_cast<WCHAR *>(pQueryCell[nQueryCount].pData));
                    m_saLocation = new WCHAR [m_cchLocation + 1];
                    if(0 == m_saLocation.m_p)
                        return E_OUTOFMEMORY;
                    wcscpy(m_saLocation, reinterpret_cast<WCHAR *>(pQueryCell[nQueryCount].pData));
                    m_bAtCorrectLocation = false;//this indicates that we need to search for the location first
                }
                break;
            case iST_CELL_FILE:
                if(pQueryCell[nQueryCount].pData     != 0                  &&
                   pQueryCell[nQueryCount].eOperator == eST_OP_EQUAL       &&
                   pQueryCell[nQueryCount].dbType    == DBTYPE_WSTR        )
                {
                    if(FAILED(hr = GetURLFromString(reinterpret_cast<WCHAR *>(pQueryCell[nQueryCount].pData))))
                    {
                        if(0 == pQueryCell[nQueryCount].pData)
                        {
                            LOG_POPULATE_ERROR1(IDS_COMCAT_XML_FILENAMENOTPROVIDED, hr, 0);
                        }
                        else
                        {
                            LOG_POPULATE_ERROR1(IDS_COMCAT_XML_FILENAMETOOLONG, hr, reinterpret_cast<WCHAR *>(pQueryCell[nQueryCount].pData));
                        }
                        return hr;
                    }
                }
                break;
            default:
                break;//do nothing on those SPECIAL cells that we don't understand.
            }
        }
        else if(pQueryCell[nQueryCount].iCell < *m_TableMetaRow.pCountOfColumns)
        {
            if(pQueryCell[nQueryCount].dbType    != m_acolmetas[pQueryCell[nQueryCount].iCell].dbType   ||
               pQueryCell[nQueryCount].eOperator != eST_OP_EQUAL                                        ||//We only support EQUAL for now.
               fCOLUMNMETA_NOTPERSISTABLE         & m_acolmetas[pQueryCell[nQueryCount].iCell].fMeta    ||
               0                                 != m_aQuery[pQueryCell[nQueryCount].iCell].pData)//currently we only support one query per column
                return E_ST_INVALIDQUERY;

            bNonSpecialQuerySpecified = true;
            //copy all but pData
            memcpy(&m_aQuery[pQueryCell[nQueryCount].iCell].eOperator, &pQueryCell[nQueryCount].eOperator, sizeof(STQueryCell)-sizeof(LPVOID));
            switch(pQueryCell[nQueryCount].dbType)
            {
                case DBTYPE_UI4:
                    if(0 == pQueryCell[nQueryCount].pData)//pData can't be NULL for this type
                    {   //if we already had a non-NULL query for this column then FAIL
                        if(m_aQuery[pQueryCell[nQueryCount].iCell].pData)
                            return E_ST_INVALIDQUERY;
                        break;//otherwise NULL is an OK query
                    }
                    {
                        ULONG * pUI4 = new ULONG;
                        if(0 == pUI4)
                            return E_OUTOFMEMORY;
                        m_aQuery[pQueryCell[nQueryCount].iCell].pData = pUI4;
                        *pUI4 = *reinterpret_cast<ULONG *>(pQueryCell[nQueryCount].pData);
                        break;
                    }
                case DBTYPE_WSTR:
                    if(m_acolmetas[pQueryCell[nQueryCount].iCell].fMeta & fCOLUMNMETA_MULTISTRING)
                        return E_ST_INVALIDQUERY;//TODO: We don't yet support query on MULTISZ columns

                    if(pQueryCell[nQueryCount].pData)
                    {
                        LPWSTR pString = new WCHAR[wcslen(reinterpret_cast<LPWSTR>(pQueryCell[nQueryCount].pData)) + 1];
                        if(0 == pString)
                            return E_OUTOFMEMORY;
                        m_aQuery[pQueryCell[nQueryCount].iCell].pData = pString;
                        wcscpy(pString, reinterpret_cast<LPWSTR>(pQueryCell[nQueryCount].pData));
                    }
                    else
                    {   //if we already had a non-NULL query for this column then FAIL
                        if(m_aQuery[pQueryCell[nQueryCount].iCell].pData)
                            return E_ST_INVALIDQUERY;
                        //otherwise NULL is an OK query
                        m_aQuery[pQueryCell[nQueryCount].iCell].pData = 0;
                    }
                    break;
                case DBTYPE_GUID:
                    DBGPRINTF(( DBG_CONTEXT,
                                "Don't support query by GUID" ));
                    ASSERT(false && "Don't support query by GUID");
                    return E_ST_INVALIDQUERY;
                case DBTYPE_BYTES:
                    DBGPRINTF(( DBG_CONTEXT,
                                "Don't support query by BYTES" ));
                    ASSERT(false && "Don't support query by BYTES");
                    return E_ST_INVALIDQUERY;
                default:
                    ASSERT(false && "Don't support this type in a query");
                    return E_ST_INVALIDQUERY;
            }
        }
        else
            return E_ST_INVALIDQUERY;
    }
    if(0x00 == m_wszURLPath[0])//The user must supply a URLPath (which must be a filename for writeable tables).
    {
        LOG_POPULATE_ERROR1(IDS_COMCAT_XML_FILENAMENOTPROVIDED, E_SDTXML_FILE_NOT_SPECIFIED, 0);
        return E_SDTXML_FILE_NOT_SPECIFIED;
    }

    // Place the most likely FALSE condition first
    if((*m_TableMetaRow.pMetaFlags & fTABLEMETA_OVERWRITEALLROWS) && bNonSpecialQuerySpecified && (i_fLOS & fST_LOS_READWRITE))
        return E_ST_INVALIDQUERY;//We don't support this.  Since a write will result in the entire table being overwritten - what would it mean
                                 //to specify a query?  In that case would I wipe out only those rows matching the query?  Or the whole thing?
                                 //I'm going to avoid the confusion completely by dis-allowing queries on this type of table (unless
                                 //the user is asking for a read-only table which makes the writing issue moot).

    hr = i_pISTDisp->GetMemoryTable(i_wszDatabase, i_wszTable, i_TableID, 0, 0, i_eQueryFormat, i_fLOS, reinterpret_cast<ISimpleTableWrite2 **>(o_ppvSimpleTable));
    if(FAILED(hr))return hr;

    InterlockedIncrement(&m_IsIntercepted);//We can only be called to Intercept once.

    return S_OK;
}


// ------------------------------------
// IInterceptorPlugin
// ------------------------------------
STDMETHODIMP CXmlSDT::OnPopulateCache(ISimpleTableWrite2* i_pISTW2)
{
    SetErrorInfo(0, 0);
    HRESULT hr = MyPopulateCache(i_pISTW2);

    m_spISTError.Release();//If we had an error, the SetErrorInfo did an AddRef.  We don't want to keep a ref count any longer.
    return hr;
}


STDMETHODIMP CXmlSDT::OnUpdateStore(ISimpleTableWrite2* i_pISTW2)
{
    SetErrorInfo(0,0);
    HRESULT hr = MyUpdateStore(i_pISTW2);

    m_spISTError.Release();//If we had an error, the SetErrorInfo did an AddRef.  We don't want to keep a ref count any longer.
    return hr;
}


// ------------------------------------
// TXmlParsedFileNodeFactory
// ------------------------------------
HRESULT CXmlSDT::CreateNode(const TElement &Element)//IXMLNodeSource * i_pSource, PVOID i_pNodeParent, USHORT i_cNumRecs, XML_NODE_INFO ** i_apNodeInfo, unsigned long CurrentLevel)
{
    //The other types are needed for XMLBlobs only.  They are handled by calling Element.Next(), so we only need to
    if(XML_ELEMENT != Element.m_ElementType || !(Element.m_NodeFlags & fBeginTag))// acknowledge XML_ELEMENTs
        return S_OK;

    if(m_LevelOfBasePublicRow && (Element.m_LevelOfElement + m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[0]]) < m_LevelOfBasePublicRow)
        return E_SDTXML_DONE;//We're done

    if(1==Element.m_LevelOfElement)
    {
        m_bInsideLocationTag = (8/*wcslen(L"location")*/ == Element.m_ElementNameLength && 0 == memcmp(Element.m_ElementName, L"location", Element.m_ElementNameLength * sizeof(WCHAR)));
        if(fBeginEndTag == (Element.m_NodeFlags & fBeginEndTag))//We can't be inside a location when it's like: <location path="foo"/>
            m_bInsideLocationTag = false;
    }

    if(m_bInsideLocationTag && 0==m_cchLocation && 1<Element.m_LevelOfElement)
        return S_OK;

    if(!m_bAtCorrectLocation)
    {
        ASSERT(m_cchLocation>0);
        ASSERT(m_saLocation.m_p != 0);
        if(1!=Element.m_LevelOfElement)
            return S_OK;
        if(8/*wcslen(L"location")*/ != Element.m_ElementNameLength || 0 != memcmp(Element.m_ElementName, L"location", Element.m_ElementNameLength * sizeof(WCHAR)))
            return S_OK;

        ULONG iLocationAttr=0;
        for(;iLocationAttr<Element.m_NumberOfAttributes; ++iLocationAttr)
        {
            if( 4/*wcslen(L"path")*/    != Element.m_aAttribute[iLocationAttr].m_NameLength        ||
                0                       != memcmp(Element.m_aAttribute[iLocationAttr].m_Name, L"path", sizeof(WCHAR)*Element.m_aAttribute[iLocationAttr].m_NameLength))
                continue;
            if( m_cchLocation           != Element.m_aAttribute[iLocationAttr].m_ValueLength       ||
                0                       != _memicmp(Element.m_aAttribute[iLocationAttr].m_Value, m_saLocation, m_cchLocation * sizeof(WCHAR)))
                return S_OK;
            m_bAtCorrectLocation = true;
            break;
        }
        if(!m_bAtCorrectLocation)
            return S_OK;
    }
    else if(1==Element.m_LevelOfElement && m_cchLocation)//if we were at the correct location AND we hit another Level 1 element then
    {                                   //we're not at the correct location anymore
        m_bAtCorrectLocation = false;
        return E_SDTXML_DONE;//We're done
    }

    //This is kind of a hack.  IMembershipCondition is the child of CodeGroup (which is an XML Blob; but it's also the PublicRowName of
    //FullTrustAssembly.  So we get confused when we seen an IMembershipCondition because ALL of the parent elements match up. EXCEPT,
    //for one, the FullTrustAssemblies element, which we would normally ignore since it's just the TableName scoping and has no real use
    //(no columns come from this element).  And normally we would prevent two different IMembershipCondition elements when compiling the
    //meta; but it's inside a blob.  Thus our dilema.  We won't be solving this for the general case.  We'll just fix the particular
    //problem as it relates to FullTrustAssembly.  We'll do this by comparing the element name with the Table's PublicName when the
    //table IS SCOPEDBYTABLENAME (TableMeta::SchemaGeneratorFlags NOTSCOPEDBYTABLENAME is NOT set);  AND we're at one level above the
    //m_LevelOfBasePublicRow.

    //if this table is SCOPED BY TABLENAME,  AND we've already determined the m_LevelOfBasePublicRow,
    if(IsScopedByTableNameElement() && m_LevelOfBasePublicRow>0)
    {
        if(Element.m_LevelOfElement<(m_LevelOfBasePublicRow-1))
        {   //if we at a level above the parent, then set to TRUE
            m_bMatchingParentOfBasePublicRowElement = true;
        }
        else if((m_LevelOfBasePublicRow-1)==Element.m_LevelOfElement)
        {   //if we're at one level above the m_LevelOfBasePublicRow, then compare the element name with the Table's PublicName
            m_bMatchingParentOfBasePublicRowElement = false;
            if(m_cchTablePublicName != Element.m_ElementNameLength)
                return S_OK;
            if(0 != memcmp(Element.m_ElementName, m_TableMetaRow.pPublicName, Element.m_ElementNameLength * sizeof(WCHAR)))
                return S_OK;
            m_bMatchingParentOfBasePublicRowElement = true;
        }
        //if we're below the level of the SCOPING PARENT element, then rely on the value as set before when we last compared the parent element name.
    }
    else
    {   //if there's not SCOPINGTABLENAME parent OR if we haven't determined the correct m_LevelOfBasePublicRow, then consider it a match.
        m_bMatchingParentOfBasePublicRowElement = true;
    }

    //if we're not under the correct parent then bail right away
    if(!m_bMatchingParentOfBasePublicRowElement)
        return S_OK;

    HRESULT hr;
    unsigned long iSortedColumn = m_iSortedColumn;

    //If we're not even at the correct level, then we can bail out right away.
    if(m_LevelOfBasePublicRow)
    {
        if(m_bSiblingContainedTable && m_LevelOfBasePublicRow==Element.m_LevelOfElement)
        {
            if(m_aPublicRowName[m_aColumnsIndexSortedByLevel[m_iSortedFirstParentLevelColumn]].IsEqual(Element.m_ElementName, Element.m_ElementNameLength))
            {
                iSortedColumn   = m_iSortedFirstParentLevelColumn;
                m_iSortedColumn = m_iSortedFirstParentLevelColumn;
            }
            else if(m_aPublicRowName[m_aColumnsIndexSortedByLevel[m_iSortedFirstChildLevelColumn]].IsEqual(Element.m_ElementName, Element.m_ElementNameLength))
            {
                iSortedColumn   = m_iSortedFirstChildLevelColumn;
                m_iSortedColumn = m_iSortedFirstChildLevelColumn;
            }
            else
            {
                return S_OK;//must be a comment or some other element
            }
        }
        else
        {
            //as we go back up in level (smaller number) we need to decrement the iSortedColumn to match the column level.
            if(Element.m_LevelOfElement < (m_LevelOfBasePublicRow - m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[iSortedColumn]]))
            {   //If we're at a level less than or equal to the previous columns level,
                if(m_bEnumPublicRowName_NotContainedTable_ParentFound)
                    return E_SDTXML_DONE;
                if(iSortedColumn && (Element.m_LevelOfElement <= (m_LevelOfBasePublicRow - m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[iSortedColumn-1]])))
                {   //then we need to decroment m_iSortedColumn to a column of this level or less
                    while(Element.m_LevelOfElement <= (m_LevelOfBasePublicRow - m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[iSortedColumn]]))
                    {
                        --iSortedColumn;
                        if(~0x00 == iSortedColumn)
                            break;
                    }
                    m_iSortedColumn = ++iSortedColumn;
                }
            }
            //This is NOT an else if, the decrement above may have resulted in the level being greater than the level of the row we're interested in.
            if(Element.m_LevelOfElement > (m_LevelOfBasePublicRow - m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[iSortedColumn]]))
                return S_OK;
        }
    }

    //EnumPublicRowName tables either need to be scoped by their table name OR by their parent table.  We have the case covered if
    //the EnumPublicRowName table is contained under another table; but there is a problem when the EnumPublicRowName table is
    //only scoped by its TableName element.  If we only search for elements matching the EnumPublicRowName(s) then we will erroroneously
    //match row names from a different table.  To prevent this we need to keep track of, not only what level, but whether the element
    //we're checking is a child of the TableName element.  Since our internal structure isn't a tree structure and doesn't have a pointer
    //to the parent element, we need to check for it as we go and remember whether we've seen it.

    if(!m_bEnumPublicRowName_NotContainedTable_ParentFound && IsEnumPublicRowNameTable() && !IsContainedTable())//if this table is NOT contained.
    {
        ASSERT(IsScopedByTableNameElement());
        if(!IsScopedByTableNameElement())
            return E_SDTXML_UNEXPECTED;//Catutil should enforce this but doesn't right now (now is 2/3/00)

        //Is the table name a match with the current node?
        if(0 == memcmp(Element.m_ElementName, m_TableMetaRow.pPublicName, Element.m_ElementNameLength * sizeof(WCHAR)) && 0x00==m_TableMetaRow.pPublicName[Element.m_ElementNameLength])
        {//if so remember the m_LevelOfBasePublicRow
            m_LevelOfBasePublicRow = 1 + Element.m_LevelOfElement;//1 level below this element.
            m_bEnumPublicRowName_NotContainedTable_ParentFound = true;
        }
        //If this IS the TableName element, then we set the bool and return
        //If this is NOT the TableName element, (and since we haven't already seen the TableName element) there's no need to continue.
        return S_OK;
    }
    else if(IsEnumPublicRowNameTable() && IsContainedTable() && IsScopedByTableNameElement())
    {
        //Is the table name a match with the current node?
        if(0 == m_LevelOfBasePublicRow && 0 == memcmp(Element.m_ElementName, m_TableMetaRow.pPublicName, Element.m_ElementNameLength * sizeof(WCHAR)) && 0x00==m_TableMetaRow.pPublicName[Element.m_ElementNameLength])
        {//if so remember the m_LevelOfBasePublicRow
            m_LevelOfBasePublicRow = 1 + Element.m_LevelOfElement;//1 level below this element.
            m_bEnumPublicRowName_ContainedTable_ParentFound = true;
            return S_OK;
        }
        else if(0 != m_LevelOfBasePublicRow && (m_LevelOfBasePublicRow == 1 + Element.m_LevelOfElement))//Everytime we're at the parent element level, check to see that the parent matches
        {
            m_bEnumPublicRowName_ContainedTable_ParentFound = (0 == memcmp(Element.m_ElementName, m_TableMetaRow.pPublicName, Element.m_ElementNameLength * sizeof(WCHAR)) && 0x00==m_TableMetaRow.pPublicName[Element.m_ElementNameLength]);
            return S_OK;
        }
        if(m_LevelOfBasePublicRow == Element.m_LevelOfElement && !m_bEnumPublicRowName_ContainedTable_ParentFound)
            return S_OK;//If we're at the BasePublicRow and we haven't found the scoped TableName element, there's no need to process this element
    }





    if(!m_aPublicRowName[m_aColumnsIndexSortedByLevel[iSortedColumn]].IsEqual(Element.m_ElementName, Element.m_ElementNameLength))
        return S_OK;//If the tag name of this element doesn't match the PublicRowName of the column we're looking for then ignore it.

    if(0 == m_LevelOfBasePublicRow)//The first time we find a match of the parent most PublicRowName, we can set
    {                              //the level of the base public row.
        ASSERT(0 == iSortedColumn);//the 0th sorted column is the parent most column.
        m_LevelOfBasePublicRow = m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[0]] + Element.m_LevelOfElement;
    }

    //Continue traversing through the columns until we reach the last column, OR one that's at a different level, OR one that doesn't match the query.
    unsigned long Level = m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[iSortedColumn]];

    //if we have an EnumPublicRowName, then fill it in first
    if(m_LevelOfBasePublicRow==Element.m_LevelOfElement && IsEnumPublicRowNameTable())
    {
        unsigned long iColumn = m_iPublicRowNameColumn;

        LPCWSTR pwcText = Element.m_ElementName;
        ULONG   ulLen   = Element.m_ElementNameLength;

        bool bMatch = false;
        if(0 == m_aQuery[iColumn].dbType || 0 != m_aQuery[iColumn].pData)//If no query OR the query data is NOT NULL then proceed.
        {
            if(FAILED(hr = FillInColumn(iColumn, pwcText, ulLen, m_acolmetas[iColumn].dbType, m_acolmetas[iColumn].fMeta,
                        bMatch)))return hr;
            if(!bMatch)//If not a match then we're done with this element and this level.
                return S_OK;
        }
    }

    ULONG iSortedColumnExit = CountOfColumns();
    if(m_bSiblingContainedTable && iSortedColumn==m_iSortedFirstParentLevelColumn)
    {   //if we're at Level zero and this is a SiblingContainedTable, we need to know whether we're populating
        //the parent or the child columns
        iSortedColumnExit = m_iSortedFirstChildLevelColumn;
    }

    for(;iSortedColumn<iSortedColumnExit && Level == m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[iSortedColumn]]; ++iSortedColumn)
    {
        unsigned long iColumn = m_aColumnsIndexSortedByLevel[iSortedColumn];
        if(m_iPublicRowNameColumn==iColumn)//The EnumPublicRowNameColumn has already been filled in.
            continue;
        //Walk the Node array to find the attribute that matches this column
        bool            bMatch      = false;


        //If the column is NOTPERSISTABLE but a PRIMARYKEY we fill it in with anything so that it's not NULL
        //This is a hack bacause the fast cache can't deal with NULL PK or even Defaulted PK.
        if((m_acolmetas[iColumn].fMeta & (fCOLUMNMETA_NOTPERSISTABLE|fCOLUMNMETA_PRIMARYKEY))==
                                         (fCOLUMNMETA_NOTPERSISTABLE|fCOLUMNMETA_PRIMARYKEY))
        {
            if(m_acolmetas[iColumn].fMeta & fCOLUMNMETA_INSERTUNIQUE)
            {
                if( m_acolmetas[iColumn].dbType != DBTYPE_UI4 &&
                    m_acolmetas[iColumn].dbType != DBTYPE_WSTR)//This should be validated in CatUtil
				{
				    ASSERT(false && "fCOLUMNMETA_INSERTUNIQUE columns must be of type DBTYPE_UI4 or DBTYPE_WSTR.  CatUtil should enforce this!");
                    return E_SDTXML_NOTSUPPORTED;
				}

                WCHAR wszInsertUnique[3];
                wszInsertUnique[2] = 0x00;
                *reinterpret_cast<LONG *>(wszInsertUnique) = InterlockedIncrement(&m_InsertUnique);
                if(FAILED(hr = FillInColumn(iColumn, wszInsertUnique, 2, m_acolmetas[iColumn].dbType, m_acolmetas[iColumn].fMeta, bMatch)))//I chose l"00" because it is a valid UI4, Byte array and string
                    return hr;
            }
            else
            {
                if(FAILED(hr = FillInColumn(iColumn, L"00", 2, m_acolmetas[iColumn].dbType, m_acolmetas[iColumn].fMeta, bMatch)))//I chose l"00" because it is a valid UI4, Byte array and string
                    return hr;
            }
        }
        else if(m_iXMLBlobColumn == iColumn)
        {
            bool bMatchTemp=false;
            FillInXMLBlobColumn(Element, bMatchTemp);
            if(!bMatchTemp)//If not a match then we're done with this element and this level.
                return S_OK;
        }
        else
        {
            if(0 != m_awstrChildElementName[iColumn].c_str())
            {   //Now we need to walk the children looking for one that matches the TableMeta::ChildElementName
                DWORD LevelOfChildElement = Element.m_LevelOfElement + 1;
                TElement *pNextElement = Element.Next();
                ASSERT(pNextElement);//This can't happen.  We can't be at the end of the file and make it this far

                while((pNextElement->m_LevelOfElement >= Element.m_LevelOfElement)//advance past PCDATA, WHITESPACES and COMMENTs
                        && (pNextElement->m_ElementType != XML_ELEMENT))          //but if we ever see an element at a level above
                {                                                                 //i_Element.m_LevelOfElement then we're in error
                    pNextElement = pNextElement->Next();
                    ASSERT(pNextElement);//This can't happen.  As soon as we're one level above, we bail, so this shouldn't be able to happen
                }

                if(LevelOfChildElement != pNextElement->m_LevelOfElement)//in this case the value is treated as NULL
                {
                    delete [] m_apValue[iColumn];
                    m_apValue[iColumn] = 0;
                    m_aSize[iColumn] = 0;

                    if(FAILED(hr = FillInPKDefaultValue(iColumn, bMatch)))//If this column is a PK with a DefaultValue, then fill it in.
                        return hr;
                    if(!bMatch)//If not a match then we're done with this element and this level.
                        return S_OK;
                }
                else //we found an element
                {
                    if(pNextElement->m_ElementNameLength == m_awstrChildElementName[iColumn].length()
                        && 0==memcmp(pNextElement->m_ElementName, m_awstrChildElementName[iColumn].c_str(), sizeof(WCHAR)*pNextElement->m_ElementNameLength))
                    {
                        if(FAILED(hr = ScanAttributesAndFillInColumn(*pNextElement, iColumn, bMatch)))
                            return hr;
                        if(!bMatch)//If not a match then we're done with this element and this level.
                            return S_OK;
                    }
                    else//For now I'm assuming that the first Element under this one should be the ChildElement we're looking for
                    {   //if it doesn't exist, the treat it as NULL
                        if(FAILED(hr = FillInPKDefaultValue(iColumn, bMatch)))//If this column is a PK with a DefaultValue, then fill it in.
                            return hr;                                        //if it's not a PK then compare with the query
                        if(!bMatch)//If not a match then we're done with this element and this level.
                            return S_OK;
                    }
                }
            }
            else
            {
                if(FAILED(hr = ScanAttributesAndFillInColumn(Element, iColumn, bMatch)))
                    return hr;
                if(!bMatch)//If not a match then we're done with this element and this level.
                    return S_OK;
            }
        }
    }

    //If we reached the last column then we're ready to add the row to the cache
    if(iSortedColumn==CountOfColumns())
    {
        ASSERT(m_pISTW2);
		hr = SmartAddRowToWriteCache (m_aSize, reinterpret_cast<void **>(m_apValue));
		if (FAILED (hr))
		{
			return hr;
		}
    }
    else
    {
        //If we didn't reach the end of the list, the we've incremented iSortedColumn to the next lower level element.  So we'll continue
        //checking and assigning columns at the child.
        m_iSortedColumn = iSortedColumn;
    }


    return S_OK;
}//CreateNode

//=================================================================================
// Function: CXmlSDT::SmartAddRowToWriteCache
//
// Synopsis: Adds a row to the write cache if the row does not exist, and returns an
//           error if the row already exists. It uses a hashtable to quickly determine
//           if a row does exist or not
//
// Arguments: [i_acbSizes] - size of columns
//            [i_apvValues] - columns of new row
//
// Return Value:
//=================================================================================
HRESULT
CXmlSDT::SmartAddRowToWriteCache (ULONG *i_acbSizes, LPVOID *i_apvValues)
{
	ASSERT (i_acbSizes != 0);
	ASSERT (i_apvValues!= 0);

	HRESULT hr = S_OK;
	ULONG hash = 0;
	hash = CalculateHash (i_acbSizes, i_apvValues);

	const CHashNode *pNode = m_spHashTable->GetItem (hash);
	while (pNode != 0)
	{
		// need temp variables here
		hr = m_pISTW2->GetWriteColumnValues (pNode->idx, m_cPKs, m_saiPKColumns, 0, m_aSizesTmp, m_apvValuesTmp);
		if (FAILED (hr))
		{
			return hr;
		}

		bool fEqual;
		hr = IsEqualRow (m_aSizesTmp, m_apvValuesTmp, i_acbSizes, i_apvValues, &fEqual);
		if (FAILED (hr))
		{
			return hr;
		}
		if (fEqual)
		{
			LOG_ERROR(Interceptor,(&m_spISTError.p                         /*ppErrInterceptor*/
                                   ,m_pISTDisp                             /*pDisp           */
                                   ,E_ST_ROWALREADYEXISTS                  /*hrErrorCode     */
                                   ,ID_CAT_CAT                             /*ulCategory      */
                                   ,IDS_COMCAT_XML_POPULATE_ROWALREADYEXISTS /*ulEvent         */
                                   ,L""                                    /*szString1       */
                                   ,eSERVERWIRINGMETA_Core_XMLInterceptor  /*ulInterceptor   */
                                   ,m_wszTable                             /*szTable         */
                                   ,eDETAILEDERRORS_Populate               /*OperationType   */
                                   ,pNode->idx                             /*ulRow           */
                                   ,(ULONG)-1                              /*ulColumn        */
                                   ,m_wszURLPath                           /*szConfigSource  */
                                   ,eDETAILEDERRORS_ERROR                  /*eType           */
                                   ,0                                      /*pData           */
                                   ,0                                      /*cbData          */
                                   ,0                                      /*MajorVersion    */
                                   ,0));                                   /*MinorVersion    */

            return E_ST_ROWALREADYEXISTS;
		}


		pNode = pNode->pNext;
	}

	// we only get here when no dups have been found, so add the row to the write cache
	ULONG iRow;
	hr = m_pISTW2->AddRowForInsert(&iRow);
	if (FAILED (hr))
    {
		return hr;
	}

	hr = m_pISTW2->SetWriteColumnValues(iRow, CountOfColumns(), 0, i_acbSizes, i_apvValues);
	if (FAILED (hr))
	{
		return hr;
	}

	// and add it to the hashtable
	hr = m_spHashTable->AddItem (hash, iRow);
	if (FAILED (hr))
	{
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CXmlSDT::CalculateHash
//
// Synopsis: Calculates a hash number from the primary keys. This number is used to
//           quickly search for duplicates in the hashtable that holds the entries in the
//           write cache during Populate
//
// Arguments: [i_acbSizes] - sizes of columns for the row
//            [i_apvValues] - column values for row for which we want to calculate the hash
//
// Return Value: hash value (32 bit integer value)
//=================================================================================
ULONG
CXmlSDT::CalculateHash (ULONG *i_acbSizes, LPVOID *i_apvValues)
{
	ASSERT (i_acbSizes != 0);
	ASSERT (i_apvValues != 0);

	// loop through the primary key columns, and calculate the hash
	ULONG hash = 0;
	for (ULONG idx=0; idx < m_cPKs; ++idx)
	{
		ULONG colIdx = m_saiPKColumns[idx];
		SimpleColumnMeta * pColMeta = m_acolmetas + colIdx;
		ASSERT (pColMeta->fMeta & fCOLUMNMETA_PRIMARYKEY);

		switch (pColMeta->dbType)
		{
		case DBTYPE_UI4:
			{
				ULONG idxVal = *((ULONG *) (i_apvValues[colIdx]));
				hash = CXmlHashTable::CalcHashForBytes (hash, (BYTE *)&idxVal, sizeof(idxVal));
				break;
			}

		case DBTYPE_WSTR:
			{
				// I don't think that multi-string PKs are allowed, but we have support for it anyway
				 if (pColMeta->fMeta & fCOLUMNMETA_MULTISTRING)
				 {
					 LPWSTR wszStr = (LPWSTR) (i_apvValues[colIdx]);
					 while (wszStr[0] != L'\0')
					 {
						hash = CXmlHashTable::CalcHashForString (hash, wszStr, pColMeta->fMeta & fCOLUMNMETA_CASEINSENSITIVE);
						wszStr = wszStr + wcslen(wszStr) + 1;
					 }
				 }
				 else
				 {
					 LPWSTR wszStr = (LPWSTR) (i_apvValues[colIdx]);
					 hash = CXmlHashTable::CalcHashForString (hash, wszStr, pColMeta->fMeta & fCOLUMNMETA_CASEINSENSITIVE);
				 }
				break;
			}

		case DBTYPE_GUID:
			{
				GUID * pGuid = (GUID *) (i_apvValues[colIdx]);
				hash = CXmlHashTable::CalcHashForBytes (hash, (BYTE *) pGuid, sizeof(GUID));
			}
			break;

		case DBTYPE_BYTES:
			{
				BYTE *pBytes = (BYTE *) (i_apvValues[colIdx]);
				ULONG cBytes = i_acbSizes[colIdx];
				ASSERT (cBytes != 0);
				hash = CXmlHashTable::CalcHashForBytes (hash, pBytes, cBytes);
			}
			break;

		default:
			ASSERT (false && "Unsupported datatype");
			break;
		}
	}

	return hash;
}

//=================================================================================
// Function: CXmlSDT::IsEqualRow
//
// Synopsis: Compares the primary key columns of two rows, and figures out if they are
//           equal or not.
//
// Arguments: [i_acbSizesLHS] - sizes array for first row
//            [i_apvValuesLHS] - values array for first row
//            [i_acbSizesRHS] - sizes array for second row
//            [i_apvValuesRHS] - values array for second row
//            [o_pfEqual] - return true if rows are equal, false else
//=================================================================================
HRESULT
CXmlSDT::IsEqualRow (ULONG *i_acbSizesLHS, LPVOID *i_apvValuesLHS, ULONG *i_acbSizesRHS, LPVOID *i_apvValuesRHS, bool *o_pfEqual)
{
	ASSERT (i_acbSizesRHS != 0);
	ASSERT (i_apvValuesRHS != 0);
	ASSERT (i_acbSizesLHS != 0);
	ASSERT (i_apvValuesLHS != 0);
	ASSERT (o_pfEqual != 0);

	*o_pfEqual = false;

	// only check the primary key values
	for (ULONG idx=0; idx < m_cPKs; ++idx)
	{
		ULONG colIdx = m_saiPKColumns[idx];

		SimpleColumnMeta * pColMeta = m_acolmetas + colIdx;
		ASSERT (pColMeta->fMeta & fCOLUMNMETA_PRIMARYKEY);

		switch (pColMeta->dbType)
		{
		case DBTYPE_UI4:
			{
				ULONG idxLHSVal = *((ULONG *) (i_apvValuesLHS[colIdx]));
				ULONG idxRHSVal = *((ULONG *) (i_apvValuesRHS[colIdx]));
				if (idxRHSVal != idxLHSVal)
				{
					return S_OK; // not equal, so jump out
				}
			}
			break;

		case DBTYPE_WSTR:
			{
				 LPWSTR wszStrLHS = (LPWSTR) (i_apvValuesLHS[colIdx]);
				 LPWSTR wszStrRHS = (LPWSTR) (i_apvValuesRHS[colIdx]);
				 // I don't think we support multi-string PK, but we support it anyway
				 if (pColMeta->fMeta & fCOLUMNMETA_MULTISTRING)
				 {
					 // loop through all the string in the multistring, and compare each
					 // of them
					 while (wszStrLHS[0] != '\0' && wszStrRHS[0] != '\0')
					 {
						 if (StringCompare (colIdx, wszStrLHS, wszStrRHS) != 0)
						 {
							 return S_OK;	// not equal, so jump out
						 }
						 wszStrLHS = wszStrLHS + wcslen (wszStrLHS) + 1;
						 wszStrRHS = wszStrRHS + wcslen (wszStrRHS) + 1;
					 }
				 }
				 else
				 {
					 if (StringCompare (colIdx, wszStrLHS, wszStrRHS) != 0)
					 {
						 return S_OK;
					 }
				 }
			}
			break;

		case DBTYPE_GUID:
			{
				GUID * pLHSVal = (GUID *) (i_apvValuesLHS[colIdx]);
				GUID * pRHSVal = (GUID *) (i_apvValuesRHS[colIdx]);
				if (*pLHSVal != *pRHSVal)
				{
					// not equal, so jump out
					return S_OK;
				}
			}
			break;

		case DBTYPE_BYTES:
			{
				 BYTE * pBytesLHS = (BYTE *) (i_apvValuesLHS[colIdx]);
				 ULONG  cBytesLHS = i_acbSizesLHS[colIdx];
				 ASSERT (cBytesLHS != 0);
				 BYTE * pBytesRHS = (BYTE *) (i_apvValuesRHS[colIdx]);
				 ULONG  cBytesRHS = i_acbSizesRHS[colIdx];
				 ASSERT (cBytesRHS != 0);

				 if (cBytesLHS != cBytesRHS ||
					 memcmp (pBytesLHS, pBytesRHS, cBytesLHS) != 0)
				 {
					 // not equal, so jump out
					 return S_OK;
				 }
			}
			break;

		default:
			ASSERT (false && "Unsupported datatype");
			break;
		}
	}

	*o_pfEqual = true;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\xmltable\stringroutines.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

//Size of ByteArray is assumed to be large enough
//It should be (wcslen(i_String)/2).  It takes 2 characters to represent a byte and the terminating NULL is ignored.
//HRESULT will return E_FAIL if any of the characters in the string are invalid hex characters
HRESULT StringToByteArray(LPCWSTR i_String, unsigned char * o_ByteArray);

//If i_String is NOT NULL terminated, call this function.
HRESULT StringToByteArray(LPCWSTR i_String, unsigned char * o_ByteArray, ULONG i_cchString);

//The size of the o_String is assumed to be large enough to hold the string representation of the byte array.
//This function can never fail.
void ByteArrayToString(const unsigned char * i_ByteArray, ULONG i_cbByteArray, LPWSTR o_String);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\xmltable\tcombstr.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

typedef CComBSTR TComBSTR;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\xmltable\sdtxml_com.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "precomp.hxx"

// -----------------------------------------
// CXmlSDT: IUnknown
// -----------------------------------------

// =======================================================================
STDMETHODIMP CXmlSDT::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv)
		return E_INVALIDARG;
	*ppv = NULL;

	if (riid == IID_ISimpleTableInterceptor)
	{
		*ppv = (ISimpleTableInterceptor*) this;
	}
	if (riid == IID_IInterceptorPlugin)
	{
		*ppv = (IInterceptorPlugin*) this;
	}
	else if (riid == IID_IUnknown)
	{
		*ppv = (ISimpleTableInterceptor*) this;
	}

	if (NULL != *ppv)
	{
		((IInterceptorPlugin*)this)->AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}
}

// =======================================================================
STDMETHODIMP_(ULONG) CXmlSDT::AddRef()
{
	return InterlockedIncrement((LONG*) &m_cRef);

}

// =======================================================================
STDMETHODIMP_(ULONG) CXmlSDT::Release()
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\xmltable\sdtxml.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

// class TXmlSDTBase
//
// This is a base class for sharing XML utility functions which are used by all XML interceptors.  It should
// NOT contain anything DOM specific or XML Node Factory specific.
class TXmlSDTBase
{
public:
    TXmlSDTBase(){}
protected:
    //const members
    enum
    {
        m_kcwchURLPath  = 7+MAX_PATH
    };

    //non-static members
    WCHAR       m_wszURLPath[m_kcwchURLPath];// Fully qualified URL path (can beof the type: file://c:/windows/system32/comcatmeta.xml)

    //protected methods
    HRESULT     GetURLFromString(LPCWSTR wsz);
};


// ------------------------------------------------------------------
// class CXmlSDT:
// ------------------------------------------------------------------
class CXmlSDT :
    public      TXmlSDTBase ,
    public      TMSXMLBase ,
    public      IInterceptorPlugin  ,
    public      TXmlParsedFileNodeFactory
{
public:
    CXmlSDT ();
    virtual ~CXmlSDT ();

//IUnknown
public:
    STDMETHOD (QueryInterface)      (REFIID riid, OUT void **ppv);
    STDMETHOD_(ULONG,AddRef)        ();
    STDMETHOD_(ULONG,Release)       ();


//ISimpleTableInterceptor
public:
    STDMETHOD (Intercept)               (
                                         LPCWSTR                    i_wszDatabase,
                                         LPCWSTR                    i_wszTable,
                                         ULONG                      i_TableID,
                                         LPVOID                     i_QueryData,
                                         LPVOID                     i_QueryMeta,
                                         DWORD                      i_eQueryFormat,
                                         DWORD                      i_fLOS,
                                         IAdvancedTableDispenser*   i_pISTDisp,
                                         LPCWSTR                    i_wszLocator,
                                         LPVOID                     i_pSimpleTable,
                                         LPVOID*                    o_ppvSimpleTable
                                        );

//public      IInterceptorPlugin : ISimpleTableInterceptor
public:
    STDMETHOD (OnPopulateCache)         (ISimpleTableWrite2* i_pISTW2);
    STDMETHOD (OnUpdateStore)           (ISimpleTableWrite2* i_pISTW2);


//TXmlParsedFileNodeFactory routines
public:
    virtual HRESULT  CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid,  LPVOID * ppv) const {return TMSXMLBase::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, riid, ppv);}
    virtual HRESULT  CreateNode      (const TElement &Element);

//private data types
private:
    enum eESCAPE
    {
        eESCAPEillegalxml,
        eESCAPEnone,
        eESCAPEamp,
        eESCAPEapos,//Single quote
        eESCAPEquote,
        eESCAPElt,
        eESCAPEgt,
        eESCAPEashex,
    };

// Helper functions
private:
    IAdvancedTableDispenser * Dispenser() {return m_pISTDisp;}
    HRESULT     AppendNewLineWithTabs(ULONG cTabs, IXMLDOMDocument * pXMLDoc, IXMLDOMNode * pNodeToAppend, ULONG cNewlines=1);
    HRESULT     BuildXmlBlob(const TElement * i_pElement, WCHAR * &io_pBuffer, ULONG & io_cchBlobBufferSize, ULONG & io_cchInBlob) const;
    HRESULT     CreateNewNode(IXMLDOMDocument * i_pXMLDoc, IXMLDOMNode * i_pNode_Parent, IXMLDOMNode ** ppNode_New);
    HRESULT     CreateStringFromMultiString(LPCWSTR i_wszMulti, LPWSTR * o_pwszString) const;
    HRESULT     FillInColumn(ULONG iColumn, LPCWSTR pwcText, ULONG ulLen, ULONG dbType, ULONG fMeta, bool &bMatch);
    HRESULT     FillInPKDefaultValue(ULONG i_iColumn, bool & o_bMatch);
    HRESULT     FillInXMLBlobColumn(const TElement & i_Element, bool & o_bMatch);
    HRESULT     FindNodeFromGuidID(IXMLDOMDocument *pXMLDoc, LPCWSTR guidID, IXMLDOMNode **ppNode) const;
    HRESULT     FindSiblingParentNode(IXMLDOMElement * i_pElementRoot, IXMLDOMNode ** o_ppNode_SiblingParent);
    HRESULT     GetColumnValue(unsigned long i_iColumn, IXMLDOMAttribute * i_pAttr, GUID &o_guid);
    HRESULT     GetColumnValue(unsigned long i_iColumn, IXMLDOMAttribute * i_pAttr, unsigned char * &o_byArray, unsigned long &o_cbArray);
    HRESULT     GetColumnValue(unsigned long i_iColumn, IXMLDOMAttribute * i_pAttr, unsigned long &o_ui4);
    HRESULT     GetColumnValue(unsigned long i_iColumn, LPCWSTR wszAttr, GUID &o_guid, unsigned long i_cchLen=0);
    HRESULT     GetColumnValue(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned char * &o_byArray, unsigned long &o_cbArray, unsigned long i_cchLen=0);
    HRESULT     GetColumnValue(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned long &o_ui4, unsigned long i_cchLen=0);
    eESCAPE     GetEscapeType(WCHAR i_wChar) const;
    HRESULT     GetMatchingNode(IXMLDOMNodeList *pNodeList_ExistingRows, CComPtr<IXMLDOMNode> &pNode_Matching);
    HRESULT     GetMetaTable(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, CComPtr<ISimpleTableRead2> &pMetaTable) const;
    HRESULT     GetResursiveColumnPublicName(tTABLEMETARow &i_TableMetaRow, tCOLUMNMETARow &i_ColumnMetaRow, ULONG i_iColumn, wstring &o_wstrColumnPublicName,  TPublicRowName &o_ColumnPublicRowName, unsigned int & o_nLevelOfColumnAttribute, wstring &o_wstrChildElementName);
    HRESULT     InsertNewLineWithTabs(ULONG i_cTabs, IXMLDOMDocument * i_pXMLDoc, IXMLDOMNode * i_pNodeInsertBefore, IXMLDOMNode * i_pNodeParent);
    HRESULT     InternalComplicatedInitialize(LPCWSTR i_wszDatabase);
    inline HRESULT InternalSetWriteColumn(ISimpleTableWrite2 *pISTW2, ULONG i_iRow, ULONG i_iColumn, ULONG i_cbSize, LPVOID i_pvValue)
                    {return pISTW2->SetWriteColumnValues(i_iRow, 1, &i_iColumn, &i_cbSize, &i_pvValue);}
    bool        IsBaseElementLevelNode(IXMLDOMNode * i_pNode);
    bool        IsContainedTable() const {return 0!=(*m_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_ISCONTAINED);}
    HRESULT     IsCorrectXMLSchema(IXMLDOMDocument *pXMLDoc) const;
    bool        IsEnumPublicRowNameTable() const {return (-1 != m_iPublicRowNameColumn);}
    HRESULT     IsMatchingColumnValue(ULONG i_iColumn, LPCWSTR i_wszColumnValue, bool & o_bMatch);
    bool        IsNameValueTable() const {return (*m_TableMetaRow.pMetaFlags & fTABLEMETA_NAMEVALUEPAIRTABLE) ? true : false;}
    bool        IsScopedByTableNameElement() const {return 0==(*m_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_NOTSCOPEDBYTABLENAME);}
    HRESULT     LoadDocumentFromURL(IXMLDOMDocument *pXMLDoc);
    int         MemWcharCmp(ULONG i_iColumn, LPCWSTR i_str1, LPCWSTR i_str2, ULONG i_cch) const;
    HRESULT     MemCopyPlacingInEscapedChars(LPWSTR o_DestinationString, LPCWSTR i_SourceString, ULONG i_cchSourceString, ULONG & o_cchCopied) const;
    HRESULT     MyPopulateCache(ISimpleTableWrite2* i_pISTW2);
    HRESULT     MyUpdateStore(ISimpleTableWrite2* i_pISTW2);
    HRESULT     ObtainPertinentRelationMetaInfo();
    HRESULT     ObtainPertinentTableMetaInfo();
    HRESULT     ObtainPertinentTagMetaInfo();
    HRESULT     ParseXMLFile(IXMLDOMDocument *pXMLDoc, bool bValidating=true);
    HRESULT     ReduceNodeListToThoseNLevelsDeep(IXMLDOMNodeList * i_pNodeList, ULONG i_nLevel, IXMLDOMNodeList **o_ppNodeListReduced) const;
    HRESULT     RemoveElementAndWhiteSpace(IXMLDOMNode *pNode);
    HRESULT     ScanAttributesAndFillInColumn(const TElement &i_Element, ULONG i_iColumn, bool &o_bMatch);
    HRESULT     SetArraysToSize();
    HRESULT     SetColumnValue(unsigned long i_iColumn, IXMLDOMElement * i_pElement, unsigned long i_ui4);
    HRESULT     SetRowValues(IXMLDOMNode *pNode_Row, IXMLDOMNode *pNode_RowChild=0);
    int         SizeOf(LPCWSTR wsz) const {return (int)(wcslen(wsz)+1)*sizeof(WCHAR);}
    inline int  StringInsensitiveCompare(LPCWSTR sz1, LPCWSTR sz2) const
                {
                    return _wcsicmp(sz1, sz2);
                }
    inline int  StringCompare(LPCWSTR sz1, LPCWSTR sz2) const
                {
                    if(*sz1 != *sz2)
                        return -1;
                    return wcscmp(sz1, sz2);
                }
    inline int  StringCompare(ULONG i_iColumn, LPCWSTR sz1, LPCWSTR sz2) const
                {
                    if(m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_CASEINSENSITIVE)
                        return StringInsensitiveCompare(sz1, sz2);
                    return StringCompare(sz1, sz2);
                }
    HRESULT     ValidateWriteCache(ISimpleTableController* i_pISTController, ISimpleTableWrite2* i_pISTW2, bool & o_bDetailedError);
    HRESULT     XMLDelete(ISimpleTableWrite2 *pISTW2, IXMLDOMDocument *pXMLDoc, IXMLDOMElement *pElementRoot, unsigned long iRow, IXMLDOMNodeList *pNodeList_ExistingRows, long cExistingRows);
    HRESULT     XMLInsert(ISimpleTableWrite2 *pISTW2, IXMLDOMDocument *pXMLDoc, IXMLDOMElement *pElementRoot, unsigned long iRow, IXMLDOMNodeList *pNodeList_ExistingRows, long cExistingRows);
    HRESULT     XMLUpdate(ISimpleTableWrite2 *pISTW2, IXMLDOMDocument *pXMLDoc, IXMLDOMElement *pElementRoot, unsigned long iRow, IXMLDOMNodeList *pNodeList_ExistingRows, long cExistingRows, IXMLDOMNode * i_pNode_Matching);

	HRESULT		SmartAddRowToWriteCache (ULONG *i_acbSizes, LPVOID *i_apvValues);
	HRESULT     IsEqualRow (ULONG *i_acbSizesLHS, LPVOID *i_apvValuesLHS, ULONG *i_acbSizesRHS, LPVOID *i_apvValuesRHS, bool *o_pfEqual);
	ULONG		CalculateHash (ULONG *i_acbSizes, LPVOID *i_apvValues);

// Private member variables
private:
    static const VARIANT_BOOL kvboolTrue, kvboolFalse;
    ULONG       CountOfColumns() const {ASSERT(m_TableMetaRow.pCountOfColumns);return m_TableMetaRow.pCountOfColumns ? *m_TableMetaRow.pCountOfColumns : 0;}

    class TTagMetaIndex
    {
    public:
        TTagMetaIndex() : m_iTagMeta((unsigned long)-1), m_cTagMeta(0){}
        unsigned long m_iTagMeta;//Index into the TagMeta (for this table)
        unsigned long m_cTagMeta;//Number of tags for this column
    };
    //We list the const members first.
    TComBSTR                            m_bstr_name;
    const LPCWSTR                       m_kXMLSchemaName;           // This is the XML Schema name that is used to validate the XML document

    //We have this problem where we need a bunch of arrays, each of size m_cColumns.  To reduce the number of allocations we'll create these arrays as
    //fixed size and hope that most tables will have no more than m_kColumns.
    enum
    {
        m_kColumns = 10
    };

    //Here are the 'fixed' size arrays
    bool                                    m_fixed_abSiblingContainedColumn[m_kColumns];
    TComBSTR                                m_fixed_abstrColumnNames[m_kColumns];
    TPublicRowName                          m_fixed_aPublicRowName[m_kColumns];
    SimpleColumnMeta                        m_fixed_acolmetas[m_kColumns];
    unsigned int                            m_fixed_aLevelOfColumnAttribute[m_kColumns];
    STQueryCell                             m_fixed_aQuery[m_kColumns];
    LPVOID                                  m_fixed_apvValues[m_kColumns];
    ULONG                                   m_fixed_aSizes[m_kColumns];
    ULONG                                   m_fixed_aStatus[m_kColumns];
    wstring                                 m_fixed_awstrColumnNames[m_kColumns];
    unsigned int                            m_fixed_aColumnsIndexSortedByLevel[m_kColumns];//Node Factory variable (see below)
    unsigned long                           m_fixed_aSize[m_kColumns];                     //Node Factory variable (see below)
    unsigned char *                         m_fixed_apValue[m_kColumns];                   //Node Factory variable (see below)
    TTagMetaIndex                           m_fixed_aTagMetaIndex[m_kColumns];
    unsigned char *                         m_fixed_aDefaultValue[m_kColumns];
    unsigned long                           m_fixed_acbDefaultValue[m_kColumns];
    wstring                                 m_fixed_awstrChildElementName[m_kColumns];       //Some columns are marked as VALUEINCHILDELEMENT, we need to get those attributes from the child element named wszChildElementName

    //Here are the 'alloc'd arrays.  These are used when the table has more than m_kColumns columns.
    TSmartPointerArray<bool>                m_alloc_abSiblingContainedColumn;   //This indicates which columns are marked as Sibling containment
    TSmartPointerArray<TComBSTR>            m_alloc_abstrColumnNames;           // Array of ColumnNames
    TSmartPointerArray<TPublicRowName>      m_alloc_aPublicRowName;             // Since some attributes come from higher level elements
    TSmartPointerArray<SimpleColumnMeta>    m_alloc_acolmetas;                  // Array of SimpleColumnMeta determined from Meta info
    TSmartPointerArray<unsigned int>        m_alloc_aLevelOfColumnAttribute;    // For FK columns, this indicates whether the attribute comes from the primary table.  If 1, the attribute exists in the parent.  If 2 it exists in the grand parent.  Currently 0,1 & 2 are the only legel values.
    TSmartPointerArray<STQueryCell>         m_alloc_aQuery;                     //@@@ We currently support one query cell per column.  This is bogus; but easier to implement for now.
    TSmartPointerArray<LPVOID>              m_alloc_apvValues;                  // Array of void pointers, this is useful getting all of the columns in a table.
    TSmartPointerArray<ULONG>               m_alloc_aSizes;                     // Array of sizes, useful when getting all of the columns
    TSmartPointerArray<ULONG>               m_alloc_aStatus;                    // Array of status, useful when getting all of the columns
    TSmartPointerArray<wstring>             m_alloc_awstrColumnNames;           // Same as the BSTR array above, except this doesn't require OleAut32.dll.  This makes for a smaller working set in the read only case.
    TSmartPointerArray<unsigned int>        m_alloc_aColumnsIndexSortedByLevel; // Node Factory variable (see below)
    TSmartPointerArray<unsigned long>       m_alloc_aSize;                      // Node Factory variable (see below)
    TSmartPointerArray<unsigned char *>     m_alloc_apValue;  //This is the row cache.  Each column has a growable buffer.  NOTICE! Only that array is a SmartPointer, so each column value buffer has to be deleted after the last row is populated.
    TSmartPointerArray<TTagMetaIndex>       m_alloc_aTagMetaIndex;
    TSmartPointerArray<unsigned char *>     m_alloc_aDefaultValue;
    TSmartPointerArray<unsigned long>       m_alloc_acbDefaultValue;
    TSmartPointerArray<wstring>             m_alloc_awstrChildElementName;       //Some columns are marked as VALUEINCHILDELEMENT, we need to get those attributes from the child element named wszChildElementName

    //These either point to the 'fixed' size arrays when the table has m_kColumns or less, or the 'alloc'd arrays when the talbe has more than m_kColumns
    bool             *                      m_abSiblingContainedColumn;
    TComBSTR         *                      m_abstrColumnNames;
    TPublicRowName   *                      m_aPublicRowName;
    SimpleColumnMeta *                      m_acolmetas;
    unsigned int     *                      m_aLevelOfColumnAttribute;
    STQueryCell      *                      m_aQuery;
    LPVOID           *                      m_apvValues;
    ULONG            *                      m_aSizes;
    ULONG            *                      m_aStatus;
    wstring          *                      m_awstrColumnNames;
    unsigned int     *                      m_aColumnsIndexSortedByLevel;       // Node Factory variable. This is needed so we get the ancestor tables first.
    unsigned long    *                      m_aSize;                            // Node Factory variable. This is the size of the m_apValue buffer.
    unsigned char    **                     m_apValue;                          // Node Factory variable. This is the row cache.  Each column has a growable buffer.  NOTICE! Only that array is a SmartPointer, so each column value buffer has to be deleted after the last row is populated.
    TTagMetaIndex    *                      m_aTagMetaIndex;                    // Array of indexes into the TagMeta each column that has TagMeta will have a non ~0 value
    unsigned char    **                     m_aDefaultValue;
    unsigned long    *                      m_acbDefaultValue;
    wstring          *                      m_awstrChildElementName;

    TSmartPointerArray<tTAGMETARow>     m_aTagMetaRow;              // This is a copy of the TagMeta for this table. m_aiTagMeta for each column points into this array if the column has tag meta
    TSmartPointerArray<ULONG>           m_saiPKColumns;
    ULONG                               m_BaseElementLevel;
    bool                                m_bAtCorrectLocation;       // If the query is for a table within a particular location, then this bool indicates whether we've found the correct location
    bool                                m_bEnumPublicRowName_ContainedTable_ParentFound;
    bool                                m_bEnumPublicRowName_NotContainedTable_ParentFound;//This is to keep track of the parent of this special kind of table.  And when we reach a close tag for the parent we can bail.
    bool                                m_bInsideLocationTag;
    bool                                m_bIsFirstPopulate;         //If m_bIsFirstPopulate and LOS_UNPOPULATED then create an empty cache.
    bool                                m_bMatchingParentOfBasePublicRowElement;// If the parent element isn't what it's supposed to be then we ignore all its children
    bool                                m_bSiblingContainedTable;   // This indicates whether this table is a SiblingContainedTable (its parent table is found in the sibling element instead of the parent element)
    TComBSTR                            m_bstrPublicTableName;      // These come from the table meta
    TComBSTR                            m_bstrPublicRowName;        // There is a need for the base PublicRowName aside from the array of PublicRowNames above
    bool                                m_bValidating;              // If we don't validate, then the parse should be a bit faster
    ULONG                               m_cCacheMiss;
    ULONG                               m_cCacheHit;
    ULONG                               m_cchLocation;              // If we're querying for a table within a particular location, this will be Non zero
    ULONG                               m_cchTablePublicName;       // This makes comparing the Table's PublicName a faster, becuase we can first compare the strlen
    ULONG                               m_cPKs;
    ULONG                               m_cRef;                     // Interface reference count.
    ULONG                               m_cTagMetaValues;           // Count Of TagMeta entries for the table
    DWORD                               m_fCache;                   // Cache flags.
    ULONG                               m_iCol_TableRequiresAdditionChildElement;//This is an index to a column that comes fromt the child.  Needed to Inserts.
    ULONG                               m_iCurrentUpdateRow;
    unsigned int                        m_iPublicRowNameColumn;     // Some tables use an enum value as the public row name, this is an index to the column with the enum.  If this is not one of those types of tables, then this value is -1.
    LONG                                m_IsIntercepted;            // Table flags (from caller).
    unsigned long                       m_iSortedColumn;//This indicates which column we're looking for.  We look for columns in order of
                                                        //their relative level to the base public row.  So the most ancestor attributes are
                                                        //matched first.
    ULONG                               m_iSortedFirstChildLevelColumn;   // For use with SiblingContainedTables.  This is an index to the first column that comes from the child most element
    ULONG                               m_iSortedFirstParentLevelColumn;  // For use with SiblingContainedTables.  This is an index to the first column that comes from the sibling parent
    ULONG                               m_iXMLBlobColumn;           // -1 if no XML Blob column exists
    ULONG                               m_fLOS;                     // Remember if READONLY and fail UpdateStore if it is.
    ULONG                               m_one;
    CComPtr<IAdvancedTableDispenser>    m_pISTDisp;
    CComPtr<IXMLDOMNode>                m_pLastPrimaryTable;
    CComPtr<IXMLDOMNode>                m_pLastParent;
    CComPtr<ISimpleTableRead2>          m_pTableMeta;
    CComPtr<ISimpleTableRead2>          m_pTagMeta;
    TSmartPointerArray<WCHAR>           m_saLocation;
    CComPtr<ISimpleTableWrite2>         m_spISTError;
    tTABLEMETARow                       m_TableMetaRow;
    ULONG                               m_two;
    LPCWSTR                             m_wszTable;                 // The Table ID is given to us in the query (as a GUID pointer of course)

	TSmartPointer<CXmlHashTable>		m_spHashTable;				// hash table used during read

    const unsigned long                 m_kPrime;

    unsigned long                       m_LevelOfBasePublicRow;
    ISimpleTableWrite2 *                m_pISTW2;       //This is valid only during OnPopulate.  It is required since NodeFactory doesn't pass back user data.
    TXmlParsedFile     *                m_pXmlParsedFile;
    TXmlParsedFile                      m_XmlParsedFile;//This one is used if no caching is done

    static LONG                         m_InsertUnique;

    //This static member is guarded by a critical section.  The only time it needs to be guarded is when allocating.
    static TXmlParsedFileCache          m_XmlParsedFileCache;
    static CSafeAutoCriticalSection     m_SACriticalSection_XmlParsedFileCache;

	TSmartPointerArray<LPVOID> m_apvValuesTmp; // temporary array to avoid tons of new/deletes
    TSmartPointerArray<ULONG>  m_aSizesTmp;    // temporary sizes array to avoid tons of new/deletes


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\xmltable\stringroutines.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "precomp.hxx"

static WCHAR * kByteToWchar[256] =
{
    L"00",    L"01",    L"02",    L"03",    L"04",    L"05",    L"06",    L"07",    L"08",    L"09",    L"0a",    L"0b",    L"0c",    L"0d",    L"0e",    L"0f",
    L"10",    L"11",    L"12",    L"13",    L"14",    L"15",    L"16",    L"17",    L"18",    L"19",    L"1a",    L"1b",    L"1c",    L"1d",    L"1e",    L"1f",
    L"20",    L"21",    L"22",    L"23",    L"24",    L"25",    L"26",    L"27",    L"28",    L"29",    L"2a",    L"2b",    L"2c",    L"2d",    L"2e",    L"2f",
    L"30",    L"31",    L"32",    L"33",    L"34",    L"35",    L"36",    L"37",    L"38",    L"39",    L"3a",    L"3b",    L"3c",    L"3d",    L"3e",    L"3f",
    L"40",    L"41",    L"42",    L"43",    L"44",    L"45",    L"46",    L"47",    L"48",    L"49",    L"4a",    L"4b",    L"4c",    L"4d",    L"4e",    L"4f",
    L"50",    L"51",    L"52",    L"53",    L"54",    L"55",    L"56",    L"57",    L"58",    L"59",    L"5a",    L"5b",    L"5c",    L"5d",    L"5e",    L"5f",
    L"60",    L"61",    L"62",    L"63",    L"64",    L"65",    L"66",    L"67",    L"68",    L"69",    L"6a",    L"6b",    L"6c",    L"6d",    L"6e",    L"6f",
    L"70",    L"71",    L"72",    L"73",    L"74",    L"75",    L"76",    L"77",    L"78",    L"79",    L"7a",    L"7b",    L"7c",    L"7d",    L"7e",    L"7f",
    L"80",    L"81",    L"82",    L"83",    L"84",    L"85",    L"86",    L"87",    L"88",    L"89",    L"8a",    L"8b",    L"8c",    L"8d",    L"8e",    L"8f",
    L"90",    L"91",    L"92",    L"93",    L"94",    L"95",    L"96",    L"97",    L"98",    L"99",    L"9a",    L"9b",    L"9c",    L"9d",    L"9e",    L"9f",
    L"a0",    L"a1",    L"a2",    L"a3",    L"a4",    L"a5",    L"a6",    L"a7",    L"a8",    L"a9",    L"aa",    L"ab",    L"ac",    L"ad",    L"ae",    L"af",
    L"b0",    L"b1",    L"b2",    L"b3",    L"b4",    L"b5",    L"b6",    L"b7",    L"b8",    L"b9",    L"ba",    L"bb",    L"bc",    L"bd",    L"be",    L"bf",
    L"c0",    L"c1",    L"c2",    L"c3",    L"c4",    L"c5",    L"c6",    L"c7",    L"c8",    L"c9",    L"ca",    L"cb",    L"cc",    L"cd",    L"ce",    L"cf",
    L"d0",    L"d1",    L"d2",    L"d3",    L"d4",    L"d5",    L"d6",    L"d7",    L"d8",    L"d9",    L"da",    L"db",    L"dc",    L"dd",    L"de",    L"df",
    L"e0",    L"e1",    L"e2",    L"e3",    L"e4",    L"e5",    L"e6",    L"e7",    L"e8",    L"e9",    L"ea",    L"eb",    L"ec",    L"ed",    L"ee",    L"ef",
    L"f0",    L"f1",    L"f2",    L"f3",    L"f4",    L"f5",    L"f6",    L"f7",    L"f8",    L"f9",    L"fa",    L"fb",    L"fc",    L"fd",    L"fe",    L"ff"
};

static unsigned char kWcharToNibble[128] = //0xff is an illegal value, the illegal values should be weeded out by the parser
{ //    0       1       2       3       4       5       6       7       8       9       a       b       c       d       e       f
/*00*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*10*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*20*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*30*/  0x0,    0x1,    0x2,    0x3,    0x4,    0x5,    0x6,    0x7,    0x8,    0x9,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*40*/  0xff,   0xa,    0xb,    0xc,    0xd,    0xe,    0xf,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*50*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*60*/  0xff,   0xa,    0xb,    0xc,    0xd,    0xe,    0xf,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*70*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
};

HRESULT StringToByteArray(LPCWSTR i_String, unsigned char * o_ByteArray)
{
    ASSERT(i_String);
    ASSERT(o_ByteArray);

    unsigned char chNibble;
    //We have to consider strings with an odd number of characters (like "A9D").  In this case we ignore the last nibble (the 'D')
    while(*i_String && *(i_String+1))
    {
        if(0 != ((*i_String)&(~0x007f)))//is the WCHAR outside the legal range of lower 128 ASCII
            return E_ST_VALUEINVALID;

        chNibble     =  kWcharToNibble[(*i_String++)&0x007f];//The first character is the high nibble
        if(0xff == chNibble)            //is the WCHAR one of the legal BYTE characters (0-9, a-f, A-F)
            return E_ST_VALUEINVALID;

        *o_ByteArray =  chNibble << 4;

        if(0 != ((*i_String)&(~0x007f)))//is the WCHAR outside the legal range of lower 128 ASCII
            return E_ST_VALUEINVALID;

        chNibble     = kWcharToNibble[(*i_String++)&0x007f];   //The second is the low nibble
        if(0xff == chNibble)            //is the WCHAR one of the legal BYTE characters (0-9, a-f, A-F)
            return E_ST_VALUEINVALID;

        *o_ByteArray |= chNibble;
		o_ByteArray++;
    }
    return S_OK;
}

HRESULT StringToByteArray(LPCWSTR i_String, unsigned char * o_ByteArray, ULONG i_cchString)
{
    ASSERT(i_String);
    ASSERT(o_ByteArray);

    //We have to consider strings with an odd number of characters (like "A9D").  In this case we ignore the last nibble (the 'D')
    unsigned char chNibble;
    while(i_cchString>1)
    {
        if(0 != ((*i_String)&(~0x007f)))
            return E_ST_VALUEINVALID;

        chNibble     =  kWcharToNibble[(*i_String++)&0x007f];//The first character is the high nibble
        if(0xff == chNibble)            //is the WCHAR one of the legal BYTE characters (0-9, a-f, A-F)
            return E_ST_VALUEINVALID;

        *o_ByteArray =  chNibble << 4;

        if(0 != ((*i_String)&(~0x007f)))//is the WCHAR outside the legal range of lower 128 ASCII
            return E_ST_VALUEINVALID;

        chNibble     = kWcharToNibble[(*i_String++)&0x007f];   //The second is the low nibble
        if(0xff == chNibble)            //is the WCHAR one of the legal BYTE characters (0-9, a-f, A-F)
            return E_ST_VALUEINVALID;

        *o_ByteArray |= chNibble;

		o_ByteArray++;
        i_cchString -=2;
    }
    return S_OK;
}

void ByteArrayToString(const unsigned char * i_ByteArray, ULONG i_cbByteArray, LPWSTR o_String)
{
    ASSERT(i_ByteArray);
    ASSERT(i_cbByteArray > 0);
    ASSERT(o_String);

    while(i_cbByteArray--)
    {
        o_String[0] = kByteToWchar[*i_ByteArray][0];//kByteToWchar[*i_ByteArray] is pointing to a two wchar string array (like L"c7").
        o_String[1] = kByteToWchar[*i_ByteArray][1];//So copy the L'c', then copy the L'7'.
        ++i_ByteArray;
        o_String += 2;
    }
    *o_String = L'\0';//NULL terminate the string
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\xmltable\tlistofxmldomnodelists.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#pragma once

//This class was designed so that we could have one XMLNodeList made up of many XMLNodeLists.  This is useful when
//we want to get all the children of multiple Nodes.  At this time there is no need to make the list growable.  Users
//should indicate up front how large the list of lists should be.
class TListOfXMLDOMNodeLists : public _unknown<IXMLDOMNodeList>
{
public:
    TListOfXMLDOMNodeLists() : m_SizeMax(0), m_SizeCurrent(0), m_iCurrent(0), m_fIsEmpty(true) {}
    ~TListOfXMLDOMNodeLists(){}

    HRESULT AddToList(IXMLDOMNodeList *pList)
    {
        HRESULT hr;
        ASSERT(m_SizeCurrent < m_SizeMax);

        m_aXMLDOMNodeList.m_p[m_SizeCurrent++] = pList;

		CComPtr<IXMLDOMNode> spDOMNode;
		hr = pList->get_item(0, &spDOMNode);
		if (spDOMNode.p != 0)
		{
			m_fIsEmpty = false;
		}

        return S_OK;
    }
    HRESULT SetCountOfLists(unsigned long Size)
    {
        m_SizeMax = Size;
        m_aXMLDOMNodeList = new CComPtr<IXMLDOMNodeList>[Size];
        return (!m_aXMLDOMNodeList) ? E_OUTOFMEMORY : S_OK;
    }
//IDispatch methods
    STDMETHOD (GetTypeInfoCount)    (UINT *)        {return E_NOTIMPL;}
    STDMETHOD (GetTypeInfo)         (UINT,
                                     LCID,
                                     ITypeInfo **)  {return E_NOTIMPL;}
    STDMETHOD (GetIDsOfNames)       (REFIID ,
                                     LPOLESTR *,
                                     UINT,
                                     LCID,
                                     DISPID *)      {return E_NOTIMPL;}
    STDMETHOD (Invoke)              (DISPID,
                                     REFIID,
                                     LCID,
                                     WORD,
                                     DISPPARAMS *,
                                     VARIANT *,
                                     EXCEPINFO *,
                                     UINT *)        {return E_NOTIMPL;}
//IXMLDOMNodeList methods
    STDMETHOD (get_item)            (long index,
                                     IXMLDOMNode **)
    {
        UNREFERENCED_PARAMETER(index);

        return E_NOTIMPL;
    }

    STDMETHOD (get_length)          (long * listLength)
    {
        UNREFERENCED_PARAMETER(listLength);
		return E_NOTIMPL;
    }
    STDMETHOD (nextNode)            (IXMLDOMNode ** nextItem)
    {
        *nextItem = 0;

		if (m_fIsEmpty)
			return S_OK;

        HRESULT hr;
        if(FAILED(hr = m_aXMLDOMNodeList[m_iCurrent]->nextNode(nextItem)))return hr;
        if(nextItem)//If we found the next node then return
            return S_OK;
        if(++m_iCurrent==m_SizeCurrent)//if we reached the end of the last list, then return, otherwise bump the iCurrent and get the nextNode of the next list
            return S_OK;
        return m_aXMLDOMNodeList[m_iCurrent]->nextNode(nextItem);
    }
    STDMETHOD (reset)               (void)
    {
        HRESULT hr;
        for(m_iCurrent=0; m_iCurrent<m_SizeCurrent; ++m_iCurrent)
        {   //reset all of the individual lists
            if(FAILED(hr = m_aXMLDOMNodeList[m_iCurrent]->reset()))return hr;
        }
        //now point to the 0th one
        m_iCurrent = 0;
        return S_OK;
    }
    STDMETHOD (get__newEnum)        (IUnknown **)   {return E_NOTIMPL;}

private:
    TSmartPointerArray<CComPtr<IXMLDOMNodeList> >   m_aXMLDOMNodeList;
    unsigned long                                   m_iCurrent;
    unsigned long                                   m_SizeMax;
    unsigned long                                   m_SizeCurrent;
	bool											m_fIsEmpty;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\xmltable\tpublicrowname.h ===
//  Copyright (C) 1999 Microsoft Corporation.  All rights reserved.
#pragma once

class TPublicRowName
{
public:
    TPublicRowName() : m_cPublicRowNames(0){}
    HRESULT Init(LPCWSTR wszPublicRowName)
    {
        m_cPublicRowNames       = 1;
        m_awstrPublicRowName    = m_fixed_awstrPublicRowName;
        m_awstrPublicRowName[0] = wszPublicRowName;
        return (m_awstrPublicRowName[0].c_str() == 0) ? E_OUTOFMEMORY : S_OK;
    }
    HRESULT Init(tTAGMETARow *aTags, int cTags)
    {
        m_cPublicRowNames       = cTags;
        if(m_cPublicRowNames <= m_kFixedSize)
        {
            m_awstrPublicRowName        = m_fixed_awstrPublicRowName;
        }
        else
        {
            m_alloc_awstrPublicRowName  = new wstring[m_cPublicRowNames];
			if (m_alloc_awstrPublicRowName == 0)
				return E_OUTOFMEMORY;

            m_awstrPublicRowName        = m_alloc_awstrPublicRowName;
        }

        for(unsigned int i=0; i<m_cPublicRowNames; ++i)
        {
            m_awstrPublicRowName[i] = aTags[i].pPublicName;
            if(m_awstrPublicRowName[i].c_str() == 0)
                return E_OUTOFMEMORY;
        }
        return S_OK;
    }

    bool IsEqual(LPCWSTR wsz, unsigned int StringLength) const
    {
        ASSERT(0 != m_cPublicRowNames);
        for(unsigned int i=0; i<m_cPublicRowNames; ++i)
        {
            if(StringLength == m_awstrPublicRowName[i].length() && 0 == memcmp(wsz, (LPCWSTR) m_awstrPublicRowName[i], StringLength * sizeof(WCHAR)))
                return true;
        }
        return false;
    }
    LPCWSTR GetFirstPublicRowName() const {return m_awstrPublicRowName[0].c_str();}
    LPCWSTR GetLastPublicRowName() const {return m_awstrPublicRowName[m_cPublicRowNames-1].c_str();}
private:
    enum
    {
        m_kFixedSize = 3  //This leaves enough room for 'Insert', 'Update' and 'Delete' and other triplet directives.
    };
    wstring                         m_fixed_awstrPublicRowName[m_kFixedSize];
    TSmartPointerArray<wstring>     m_alloc_awstrPublicRowName;
    wstring *                       m_awstrPublicRowName;
    unsigned int                    m_cPublicRowNames;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\xmltable\txmldomnodelist.h ===
//  Copyright (C) 1999 Microsoft Corporation.  All rights reserved.
#pragma once

//We need to be able to take an XMLDOMNodeList and further refine the list.  IXMLDOMNodeList doesn't allow us to do that, so this class will.
//For example,  I can call GetElementsByTagName, then walk the resulting list, and add each Node that has a given Attribute to my TXMLDOMNodeList.
//I can then pass this new list around as an IXMLDOMNodeList.
//
//This class was implemented to Add items to the list - it does NOT support removing them!
class TXMLDOMNodeList : public _unknown<IXMLDOMNodeList>
{
public:
    TXMLDOMNodeList() : m_cItems(0), m_pCurrent(reinterpret_cast<LinkedXMLDOMNodeItem *>(-1)), m_pFirst(0), m_pLast(0){}
    ~TXMLDOMNodeList()
    {
        //delete the whole list (the XMLDOMNode smart pointers will release themselves
        while(m_pFirst)
        {
            m_pCurrent = m_pFirst->m_pNext;
            delete m_pFirst;
            m_pFirst = m_pCurrent;
        }
    }

    HRESULT AddToList(IXMLDOMNode *pNode)
    {
        ASSERT(pNode && "Idiot passing NULL!!! TXMLDOMNodeList::AddToList(NULL).");

        LinkedXMLDOMNodeItem *  pNewItem = new LinkedXMLDOMNodeItem(pNode);
        if(0 == pNewItem)
            return E_OUTOFMEMORY;

        if(0 == m_pLast)
        {
            ASSERT(0 == m_cItems);
            ASSERT(0 == m_pFirst);

            m_pFirst = pNewItem;
            m_pLast  = pNewItem;
        }
        else
        {
            m_pLast->m_pNext    = pNewItem;
            m_pLast             = pNewItem;
        }

        ++m_cItems;
        return S_OK;
    }
//IDispatch methods
    STDMETHOD (GetTypeInfoCount)    (UINT *)        {return E_NOTIMPL;}
    STDMETHOD (GetTypeInfo)         (UINT,
                                     LCID,
                                     ITypeInfo **)  {return E_NOTIMPL;}
    STDMETHOD (GetIDsOfNames)       (REFIID ,
                                     LPOLESTR *,
                                     UINT,
                                     LCID,
                                     DISPID *)      {return E_NOTIMPL;}
    STDMETHOD (Invoke)              (DISPID,
                                     REFIID,
                                     LCID,
                                     WORD,
                                     DISPPARAMS *,
                                     VARIANT *,
                                     EXCEPINFO *,
                                     UINT *)        {return E_NOTIMPL;}
//IXMLDOMNodeList methods
    STDMETHOD (get_item)            (long index,
                                     IXMLDOMNode **)
    {
        UNREFERENCED_PARAMETER(index);

        return E_NOTIMPL;
    }

    STDMETHOD (get_length)          (long * listLength)
    {
        ASSERT(listLength && "Passing NULL!!! TXMLDOMNodeList::get_length(NULL)");
        *listLength = m_cItems;
        return S_OK;
    }
    STDMETHOD (nextNode)            (IXMLDOMNode ** nextItem)
    {
        ASSERT(nextItem && "Passing NULL!!! TXMLDOMNodeList::nextNode(NULL)");

        *nextItem = 0;
        if(0 == m_cItems)
            return S_OK;
        if(0 == m_pCurrent)
            return S_OK;

        if(-1 == reinterpret_cast<INT_PTR>(m_pCurrent))
            m_pCurrent = m_pFirst;
        else
            m_pCurrent = m_pCurrent->m_pNext;

        if(0 == m_pCurrent)
            return S_OK;

        *nextItem =  m_pCurrent->m_spNode;
        (*nextItem)->AddRef();
        return S_OK;
    }
    STDMETHOD (reset)               (void)
    {
        m_pCurrent = reinterpret_cast<LinkedXMLDOMNodeItem *>(-1);//zero indicated that we're at the end of the list: -1 indicates that we're at the beginning
        return S_OK;
    }
    STDMETHOD (get__newEnum)        (IUnknown **)   {return E_NOTIMPL;}

private:
    struct LinkedXMLDOMNodeItem
    {
        LinkedXMLDOMNodeItem(IXMLDOMNode *pNode) : m_spNode(pNode), m_pNext(0){}
        CComPtr<IXMLDOMNode> m_spNode;
        LinkedXMLDOMNodeItem *m_pNext;
    };

    unsigned long           m_cItems;
    LinkedXMLDOMNodeItem *  m_pCurrent;
    LinkedXMLDOMNodeItem *  m_pFirst;
    LinkedXMLDOMNodeItem *  m_pLast;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\xmltable\xmlhashtable.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name:
    xmlhashtable.h

Header: $

Abstract: Implements a hash table for rows during populate cache. Used to validate if we
          have duplicate rows (rows with same PK).

Author:
    marcelv     6/11/2001 09:48:27      Initial Release

Revision History:

 --**************************************************************************/

#pragma once


struct CHashNode
{
    ULONG idx;			// index into write cache
    CHashNode *pNext;   // pointer to next node
};

class CXmlHashTable
{
public:
    CXmlHashTable ();
    ~CXmlHashTable ();

    HRESULT Init (ULONG i_NrSignificantBits);
    HRESULT AddItem (ULONG hash, ULONG i_iIdx);
 	const CHashNode * GetItem (ULONG hash);

    void PrintStats ();
    void PrintBucketStats ();

    static ULONG CalcHashForBytes (ULONG i_hash, BYTE *pBytes, ULONG cNrBytes);
	static ULONG CalcHashForString (ULONG i_hash, LPCWSTR wszString, BOOL fCaseInsensitive);

private:
	ULONG CalcFinalHash (ULONG i_hash);

	struct CBucket
	{
		CHashNode *pFirst;
	};

    CBucket * m_aBuckets;			// array with hash buckets
    ULONG     m_cSignificantBits;   // number of significant bits for hashing (2^(nr bits) = nr of buckets)
    ULONG     m_cBuckets;			// number of hash buckets
	bool      m_fInitialized;		// is the hash table initialized
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\config\src\stores\xmltable\xmlhashtable.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name:
    xmlhashtable.cpp

    $Header: $

    Abstract:

    Author:
    marcelv     6/11/2001 09:54:41      Initial Release

    Revision History:

    --**************************************************************************/
#include "precomp.hxx"

//=================================================================================
// Function: CXmlHashTable::CXmlHashTable
//
// Synopsis: constructor
//=================================================================================
CXmlHashTable::CXmlHashTable ()
{
    m_aBuckets			= 0;
	m_cSignificantBits	= 0;
    m_cBuckets			= 0;
	m_fInitialized		= false;
}

//=================================================================================
// Function: CXmlHashTable::~CXmlHashTable
//
// Synopsis: destructor. Get rid of all the nodes in the hashtable
//=================================================================================
CXmlHashTable::~CXmlHashTable ()
{
    for (ULONG idx=0; idx < m_cBuckets; ++idx)
    {
        CBucket * pBucket = m_aBuckets + idx;

        CHashNode *pNode = pBucket->pFirst;
        while (pNode != 0)
        {
            CHashNode *pNextNode = pNode->pNext;
            delete pNode;
            pNode = pNextNode;
        }
    }

    delete[] m_aBuckets;
	m_aBuckets = 0;
}

//=================================================================================
// Function: CXmlHashTable::Init
//
// Synopsis: Initializes the hash table, with 2^(i_NrSignificantBits) buckets. The reason
//           to have a power of two as buckets is that the used hash function is independent
//           of the number of buckets (and works best if number of buckets is power of two)
//
// Arguments: [i_NrSignificantBits] - number of bits in the hash key (2^ nr of buckets)
//=================================================================================
HRESULT
CXmlHashTable::Init (ULONG i_NrSignificantBits)
{
    ASSERT (i_NrSignificantBits != 0);
	ASSERT (i_NrSignificantBits < 32);
	ASSERT (!m_fInitialized);

    m_cSignificantBits = i_NrSignificantBits;
    m_cBuckets = 1 << m_cSignificantBits;

    m_aBuckets = new CBucket [m_cBuckets];
    if (m_aBuckets == 0)
    {
        return E_OUTOFMEMORY;
    }
    memset (m_aBuckets, 0, sizeof (CBucket) * m_cBuckets);
	m_fInitialized = true;

    return S_OK;
}

//=================================================================================
// Function: CXmlHashTable::CalcFinalHash
//
// Synopsis: Find the correct bucket by doing some final hashing
//
// Arguments: [i_hash] - hash to convert
//
// Return Value: bucket id of hash value
//=================================================================================
ULONG
CXmlHashTable::CalcFinalHash (ULONG i_hash)
{
	ASSERT (m_fInitialized);
	return (i_hash ^ (i_hash>>10) ^ (i_hash >> 20)) & (m_cBuckets -1);
}

//=================================================================================
// Function: CXmlHashTable::AddItem
//
// Synopsis: Add a new item to the hash table
//
// Arguments: [i_hash] - hash of item
//            [i_iIdx] - index of item in write cache
//=================================================================================
HRESULT
CXmlHashTable::AddItem (ULONG i_hash, ULONG i_iIdx)
{
	ASSERT (m_fInitialized);

	ULONG hash = CalcFinalHash (i_hash);
	ASSERT (hash < m_cBuckets);

	CBucket * pBucket = m_aBuckets + hash;

	// create a new node, and add it to the beginning of the bucket
    CHashNode * pNewNode = new CHashNode;
    if (pNewNode == 0)
    {
        return E_OUTOFMEMORY;
    }
    pNewNode->idx	= i_iIdx;
 	pNewNode->pNext = pBucket->pFirst;
	pBucket->pFirst = pNewNode;

    return S_OK;
}

//=================================================================================
// Function: CXmlHashTable::CalcHashForBytes
//
// Synopsis: Calculate the hash for a byte value. Do not use this for strings
//
// Arguments: [i_hash] - starting hash value
//            [pBytes] - byte array
//            [cNrBytes] - number of bytes
//=================================================================================
ULONG
CXmlHashTable::CalcHashForBytes (ULONG i_hash, BYTE *pBytes, ULONG cNrBytes)
{
    ULONG cTotalBytes = cNrBytes;
    for (ULONG idx = 0; cNrBytes > 3; cNrBytes -=4, idx +=4)
    {
        i_hash +=  *((ULONG *)(pBytes + idx));
        i_hash += (i_hash<<10);
        i_hash ^= (i_hash>>6);
    }


    while (cNrBytes != 0)
    {
            // and hash in the last four bytes
            unsigned char * ch = pBytes + cTotalBytes - cNrBytes - 1;
            i_hash +=  (ULONG ) *ch;
            i_hash += (i_hash<<10);
            i_hash ^= (i_hash>>6);
            cNrBytes--;
    }

    i_hash += (i_hash<<3);
    i_hash ^= (i_hash>>11);
    i_hash += (i_hash<<15);

    return i_hash;
}

//=================================================================================
// Function: CXmlHashTable::CalcHashForString
//
// Synopsis: Calculate the hash for a LPWSTR
//
// Arguments: [i_hash] - initial hash value
//            [wszString] - string to calc value for
//            [fCaseInsensitive] - is the string case insensitive or not
//
// Return Value: hash value
//=================================================================================
ULONG
CXmlHashTable::CalcHashForString (ULONG i_hash, LPCWSTR wszString, BOOL fCaseInsensitive)
{
	ULONG cLen = (ULONG)wcslen(wszString);

	// repeat some code, so that we don't have to check the caseinsensitive flag all the time
	if (fCaseInsensitive)
	{
		for (ULONG idx = 0; idx < cLen; ++idx)
		{
	        i_hash +=  towlower(wszString[idx]);
		    i_hash += (i_hash<<10);
			i_hash ^= (i_hash>>6);
		}
	}
	else
	{
		for (ULONG idx = 0; idx < cLen; ++idx)
		{
	        i_hash +=  wszString[idx];
		    i_hash += (i_hash<<10);
			i_hash ^= (i_hash>>6);
		}
    }

    i_hash += (i_hash<<3);
    i_hash ^= (i_hash>>11);
    i_hash += (i_hash<<15);

    return i_hash;

}

//=================================================================================
// Function: CXmlHashTable::GetItem
//
// Synopsis: Get a list of hash nodes for hash i_hash
//
// Arguments: [i_hash] - hash to use to find correct bucket
//
// Return Value: list with nodes which have that particular hash value
//=================================================================================
const CHashNode *
CXmlHashTable::GetItem (ULONG i_hash)
{
	ASSERT (m_fInitialized);

	ULONG hash = CalcFinalHash (i_hash);
	ASSERT (hash < m_cBuckets);

    CBucket *pBucket = m_aBuckets + hash;
    return pBucket->pFirst;
}

//=================================================================================
// Function: CXmlHashTable::PrintStats
//
// Synopsis: Print statistics about the hash table
//=================================================================================
void
CXmlHashTable::PrintStats ()
{
	ASSERT (m_fInitialized);

    ULONG cNrEmptyBuckets = 0;
    ULONG cNrMultiNodeBuckets = 0;
    ULONG cMaxBucketSize = 0;
    ULONG cNrElements = 0;

    for (ULONG idx=0; idx < m_cBuckets; ++idx)
    {
        CBucket * pBucket = m_aBuckets + idx;
        CHashNode *pNode = pBucket->pFirst;
        if (pNode == 0)
        {
            cNrEmptyBuckets++;
        }
        else
        {
            if (pNode->pNext != 0)
            {
                cNrMultiNodeBuckets++;
            }
            ULONG cBucketSize = 0;
            while (pNode != 0)
            {
                cNrElements++;
                pNode = pNode->pNext;
                ++cBucketSize;
            }

            cMaxBucketSize = max (cMaxBucketSize, cBucketSize);
        }
    }

    DBGPRINTF(( DBG_CONTEXT,
                "Number of elements             : %d\n", cNrElements ));
    DBGPRINTF(( DBG_CONTEXT,
                "Number of buckets              : %d\n", m_cBuckets ));
    DBGPRINTF(( DBG_CONTEXT,
                "Number of empty buckets        : %d\n", cNrEmptyBuckets ));
    DBGPRINTF(( DBG_CONTEXT,
                "Number of multi-node buckets   : %d\n", cNrMultiNodeBuckets ));
    DBGPRINTF(( DBG_CONTEXT,
                "Max bucket size                : %d\n", cMaxBucketSize ));
}

//=================================================================================
// Function: CXmlHashTable::PrintBucketStats
//
// Synopsis: Print Bucket Statistics
//=================================================================================
void
CXmlHashTable::PrintBucketStats ()
{
	ASSERT (m_fInitialized);

    for (ULONG idx=0; idx < m_cBuckets; ++idx)
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[%d] ", idx ));
        CBucket *pBucket = m_aBuckets + idx;
        CHashNode *pNode = pBucket->pFirst;
        while (pNode != 0)
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "%d ", pNode->idx ));
            pNode = pNode->pNext;
        }
        DBGPRINTF(( DBG_CONTEXT,
                    "\n" ));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\icepick.inc ===
#
# Instrument with ICECAP on free builds (if we have a valid pointer to
# the ICEPICK tool).
#

!IF "$(ICEPICK_CMD)" != ""
!IF $(FREEBUILD)
POST_BUILD_CMD=$(ICEPICK_CMD) $@ $(ICEPICK_OPTIONS) -OUTPUT:.\$(@B).xyz && copy $(@B).xyz $@ && copy $(@B).pdb $(@R).pdb && del $(@B).xyz $(@B).pdb
!ENDIF
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\application_table.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    application_table.cxx

Abstract:

    This class is a hashtable which manages the set of applications.

    Threading: Always called on the main worker thread.

Author:

    Seth Pollack (sethp)        03-Nov-1998

Revision History:

--*/



#include "precomp.h"



/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities 
    which may hold a reference to this object to release that reference 
    (and not take any more), in order to break reference cycles. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
APPLICATION_TABLE::Terminate(
    )
{

    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;

    
    //
    // BUGBUG Iterating in order to clean up, remove, and delete each 
    // element of the table is difficult to do with lkhash today.
    // GeorgeRe plans to fix this eventually. For now, the alternative
    // is to iterate through the table building up in list of all the 
    // elements, and then go through the list and shutdown, remove, and
    // delete each element -- yuck!!
    //
    // Once this gets fixed, we can see if it is valuable to unify any
    // table management code between the app pool, virtual site,
    // and application tables.
    //
    
    LIST_ENTRY DeleteListHead;
    PLIST_ENTRY pDeleteListEntry = NULL;
    APPLICATION * pApplication = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;
    HRESULT hr = S_OK;


    InitializeListHead( &DeleteListHead );

    
    CountOfElementsInTable = Size();


    //
    // Note that for good form we grab the write lock since we will be 
    // modifying objects in the table (although no other thread should 
    // touch this data structure anyways).
    //
    
    SuccessCount = Apply( 
                        DeleteApplicationAction,
                        &DeleteListHead,
                        LKL_WRITELOCK
                        );
    
    DBG_ASSERT( SuccessCount == CountOfElementsInTable );


    // now for each, clean it up, remove it from the table, and delete it
    
    while (  ! IsListEmpty( &DeleteListHead )  )
    {
    
        pDeleteListEntry = RemoveHeadList( &DeleteListHead );

        DBG_ASSERT( pDeleteListEntry != NULL );

        pApplication = APPLICATION::ApplicationFromDeleteListEntry( pDeleteListEntry );


        // remove it from the table

        ReturnCode = DeleteRecord( pApplication );

        if ( ReturnCode != LK_SUCCESS )
        {

            hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Removing application from hashtable failed\n"
                ));

        }

        
        //
        // All remaining shutdown work is done in it's destructor.
        //

        delete pApplication;
    
    }


    return;

}   // APPLICATION_TABLE::Terminate



/***************************************************************************++

Routine Description:

    A routine that may be applied to all APPLICATIONs in the hashtable
    to prepare for termination. Conforms to the PFnRecordAction prototype.

Arguments:

    pApplication - The application.

    pDeleteListHead - List head into which to insert the application for
    later deletion.

Return Value:

    LK_ACTION - LKA_SUCCEEDED always.

--***************************************************************************/

// note: static!
LK_ACTION
APPLICATION_TABLE::DeleteApplicationAction(
    IN APPLICATION * pApplication, 
    IN VOID * pDeleteListHead
    )
{

    DBG_ASSERT( pApplication != NULL );
    DBG_ASSERT( pDeleteListHead != NULL );


    InsertHeadList( 
        ( PLIST_ENTRY ) pDeleteListHead,
        pApplication->GetDeleteListEntry()
        );


    return LKA_SUCCEEDED;
    
}   // APPLICATION_TABLE::DeleteApplicationAction



#if DBG
/***************************************************************************++

Routine Description:

    Debug dump the table.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
APPLICATION_TABLE::DebugDump(
    )
{

    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;


    CountOfElementsInTable = Size();


    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Dumping application table; total count: %lu\n",
            CountOfElementsInTable
            ));
    }


    SuccessCount = Apply( 
                        DebugDumpApplicationAction,
                        NULL
                        );
    
    DBG_ASSERT( SuccessCount == CountOfElementsInTable );


    return;

}   // APPLICATION_TABLE::DebugDump



/***************************************************************************++

Routine Description:

    A routine that may be applied to all APPLICATIONs in the hashtable
    to perform a debug dump. Conforms to the PFnRecordAction prototype.

Arguments:

    pApplication - The application.

    pIgnored - Ignored.

Return Value:

    LK_ACTION - LKA_SUCCEEDED always.

--***************************************************************************/

// note: static!
LK_ACTION
APPLICATION_TABLE::DebugDumpApplicationAction(
    IN APPLICATION * pApplication, 
    IN VOID * pIgnored
    )
{

    DBG_ASSERT( pApplication != NULL );
    UNREFERENCED_PARAMETER( pIgnored );


    pApplication->DebugDump();
    

    return LKA_SUCCEEDED;
    
}   // APPLICATION_TABLE::DebugDumpApplicationAction
#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\applicationstore.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    applicationstore.cxx

Abstract:

    Reads application configuration

Author:

    Bilal Alam (balam)          27-May-2001

Revision History:

--*/

#include "precomp.h"

HRESULT
APPLICATION_DATA_OBJECT::SetFromMetabaseData(
    METADATA_GETALL_RECORD *       pProperties,
    DWORD                          cProperties,
    BYTE *                         pbBase
)
/*++

Routine Description:

    Setup a application data object from metabase properties

Arguments:

    pProperties - Array of metadata properties
    cProperties - Count of metadata properties
    pbBase - Base of offsets in metadata properties

Return Value:

    HRESULT

--*/
{
    DWORD                   dwCounter;
    PVOID                   pvDataPointer;
    METADATA_GETALL_RECORD* pCurrentRecord;
    HRESULT                 hr;
    
    if ( pProperties == NULL || pbBase == NULL )
    {
        DBG_ASSERT ( pProperties != NULL && pbBase != NULL );

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // for each property evaluate what it tells us.
    //
    for ( dwCounter = 0;
          dwCounter < cProperties;
          dwCounter++ )
    {
        pCurrentRecord = &(pProperties[ dwCounter ]);

        pvDataPointer = (PVOID) ( pbBase + pCurrentRecord->dwMDDataOffset );

        switch ( pCurrentRecord->dwMDIdentifier )
        {
            case MD_APP_APPPOOL_ID:

                hr = _strAppPoolId.Copy( (WCHAR*) pvDataPointer );
                if ( FAILED( hr ) )
                {
                    return hr;
                }
            break;
        }
    }
    
    return NO_ERROR;
} 

VOID
APPLICATION_DATA_OBJECT::Compare(
    DATA_OBJECT *                  pDataObject
)
/*++

Routine Description:

    Compare a given application object with this one.  This routine sets the
    changed flags as appropriate

Arguments:

    pDataObject - New object to compare to

Return Value:

    None

--*/
{
    APPLICATION_DATA_OBJECT *          pApplicationObject;
    
    if ( pDataObject == NULL )
    {

        DBG_ASSERT ( pDataObject != NULL );

        return;
    }
    
    pApplicationObject = (APPLICATION_DATA_OBJECT*) pDataObject;
    DBG_ASSERT( pApplicationObject->CheckSignature() );

    // 
    // If the application is not in WAS then assume that all the
    // values have changed, because WAS will want to know about all
    // of them.
    //
    if ( pApplicationObject->QueryInWas() )
    {
        //
        // if we are in BC mode, or if the app pool id is the same, mark
        // this application as if the app pool id has not changed.
        //
        if (  GetWebAdminService()->IsBackwardCompatibilityEnabled()  ||
              _strAppPoolId.EqualsNoCase ( pApplicationObject->_strAppPoolId )  )
        {
            _fAppPoolIdChanged = FALSE;
        }

    }
}

const WCHAR *
APPLICATION_DATA_OBJECT::QueryAppPoolId(
)
/*++

Routine Description:
    
    Get the app pool id for the application object.

Arguments:

    None

Return Value:

    const WCHAR *  pointing to the app pool id for the app.

--*/
{

    //  On any action we may need to look up the pool id.

    if ( GetWebAdminService()->
         IsBackwardCompatibilityEnabled() )
    {
        return &wszDEFAULT_APP_POOL;
    }
    else
    {
        return _strAppPoolId.QueryStr();
    }
}

BOOL
APPLICATION_DATA_OBJECT::QueryHasChanged(
    VOID
) const
/*++

Routine Description:
    
    Has anything in this object changed

Arguments:

    None

Return Value:

    TRUE if something has changed (duh!)

--*/
{
    return _fAppPoolIdChanged;
}


DATA_OBJECT *
APPLICATION_DATA_OBJECT::Clone(
    VOID
)
/*++

Routine Description:

    Clone application object

Arguments:

    None

Return Value:

    DATA_OBJECT *

--*/
{
    APPLICATION_DATA_OBJECT *       pClone;
    HRESULT                         hr;
    
    pClone = new APPLICATION_DATA_OBJECT;
    if ( pClone == NULL )
    {
        return NULL;
    }
        
    hr = pClone->_strAppPoolId.Copy( _strAppPoolId );
    if ( FAILED( hr ) )
    {
        delete pClone;
        return NULL;
    }
    
    hr = pClone->_applicationKey.Create( _applicationKey.QueryApplicationUrl(),
                                         _applicationKey.QuerySiteId() );
    if ( FAILED( hr ) )
    {
        delete pClone;
        return NULL;
    }
    
    pClone->_fAppPoolIdChanged = _fAppPoolIdChanged;

    CloneBasics ( pClone );
    
    return pClone;
}

VOID
APPLICATION_DATA_OBJECT::SelfValidate(
    VOID
)
/*++

Routine Description:

    Check this object's internal validity    

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // never bother validating if we are deleting
    //
    if ( !QueryWillWasKnowAboutObject() )
    {
        return;
    }

    //
    // To have a valid keys these should not be able
    // to happen, if they do we will investigate how
    // and decide if we should log or not.
    //
    DBG_ASSERT ( QuerySiteId() > 0 );
    DBG_ASSERT ( QueryApplicationUrl() != NULL &&
                 *(QueryApplicationUrl()) != L'\0' );

    //
    // Resonably this should also not be able to happen
    // unless someone sets the AppPoolId to "" specifically
    //
    if ( _strAppPoolId.IsEmpty() )
    {
        GetWebAdminService()->
        GetWMSLogger()->
        LogApplicationAppPoolIdEmpty( QuerySiteId(),
                                      QueryApplicationUrl(),
                                      QueryInWas() );
        
         SetSelfValid( FALSE );
    }
}

HRESULT
APPLICATION_DATA_OBJECT_TABLE::ReadFromMetabase(
    IMSAdminBase *              pAdminBase
)
/*++

Routine Description:

    Read all the applications from the metabase and build up a table

Arguments:

    pAdminBase - ABO pointer

Return Value:

    HRESULT

--*/
{
    return ReadFromMetabasePath( pAdminBase, L"/LM/W3SVC", TRUE );
}

HRESULT
APPLICATION_DATA_OBJECT_TABLE::ReadFromMetabasePath(
    IMSAdminBase *              pAdminBase,
    WCHAR *                     pszMetaPath,
    BOOL                        fMultiThreaded
)
/*++

Routine Description:

    Read all the applications from the metabase and build up a table

Arguments:

    pAdminBase - ABO pointer
    pszMetaPath - Metabase path
    fMultiThreaded - whether or not to do this multithreaded

Return Value:

    HRESULT

--*/
{
    MB                          mb( pAdminBase );
    BOOL                        fRet;
    STACK_BUFFER(               bufPaths, 2048 );
    
    fRet = mb.Open( pszMetaPath, METADATA_PERMISSION_READ );
    if ( !fRet )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    fRet = mb.GetDataPaths( L"",
                            MD_APP_APPPOOL_ID,
                            STRING_METADATA,
                            &bufPaths );
    if ( !fRet )
    { 
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    MULTIPLE_THREAD_READER reader;
    return reader.DoWork(this, &mb, (LPWSTR) bufPaths.QueryPtr(), fMultiThreaded);
}

HRESULT 
APPLICATION_DATA_OBJECT_TABLE::DoThreadWork(
    LPWSTR                 pszString,
    LPVOID                 pContext
)
/*++

Routine Description:

    Read one application from the metabase and build up a table entry

Arguments:

    pszString - Application to read
    pContext - MB pointer opened to w3svc node

Return Value:

    HRESULT

--*/
{
    BOOL                        fRet;
    WCHAR *                     pszPaths = NULL;
    APPLICATION_DATA_OBJECT *   pApplicationObject = NULL;
    HRESULT                     hr = S_OK;
    STACK_BUFFER(               bufProperties, 512 );
    DWORD                       cProperties;
    DWORD                       dwDataSetNumber;
    DWORD                       dwSiteId = 0;
    WCHAR *                     pszEnd = NULL;
    LK_RETCODE                  lkrc;
    
    MB * mb = (MB*) pContext;
    pszPaths = pszString;

    DBG_ASSERT(pContext && pszString);

    //
    // We only care about rooted application paths 
    // (/LM/W3SVC/<n>/ROOT/*)
    //
    
    if ( pszPaths[ 0 ] == L'/' &&
         pszPaths[ 1 ] == L'\0' )
    {
        goto exit;
    }
    
    //
    // Check for <n>
    //
        
    dwSiteId = wcstoul( pszPaths + 1, &pszEnd, 10 );
    if ( dwSiteId == 0 )
    {
        //
        // This isn't a site at all.  Therefore we don't care about
        // this application.  
        //
            
        goto exit;
    }
    
    //
    // Check for the /ROOT/ and skip past if we found it
    //
    
    if ( _wcsnicmp( pszEnd, L"/ROOT/", 6 ) != 0 )
    {
        goto exit;
    }
    
    //
    // Skip past the "/ROOT"
    //
    
    pszEnd += 5;
    
    //
    // We have an application
    //
        
    fRet = mb->GetAll( pszPaths,
                      METADATA_INHERIT | METADATA_PARTIAL_PATH | METADATA_NON_SECURE_ONLY,
                      IIS_MD_UT_SERVER,
                      &bufProperties,
                      &cProperties,
                      &dwDataSetNumber );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }
    
    //
    // Create and initialize object
    //
    
    pApplicationObject = new APPLICATION_DATA_OBJECT();
    if ( pApplicationObject == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }
    
    hr = pApplicationObject->Create( pszEnd, dwSiteId );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    
    hr = pApplicationObject->SetFromMetabaseData(
                 ( METADATA_GETALL_RECORD * ) bufProperties.QueryPtr(),
                 cProperties,
                 ( PBYTE ) bufProperties.QueryPtr() );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    
    IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    " Inserting Site '%d''s Application '%S' from the metadata tables \n",
                    pApplicationObject->QuerySiteId(),
                    pApplicationObject->QueryApplicationUrl()));
    }


    //
    // Insert into hash table
    //
    
    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    //
    // General rule about inserting into tables:
    //
    // For Initial Processing and Complete processing caused by
    // a change notification, we will always ignore inserting a
    // object if we fine an object all ready in the table.  This is because
    // during a change notification if a record was added by the change
    // notification code, it will be more correct ( like knowing if ServerCommand
    // actually changed ), then the new generic record that was read because
    // of a change to a hire node.  Also during initial read we should
    // not have to make this decision so we can still ignore if we do see it.
    //
    // For Change Processing we will need to evaluate the change that 
    // all ready exists and compare it with the new change to decide 
    // what change we should make.
    //
    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    lkrc = InsertRecord( (DATA_OBJECT*) pApplicationObject );
    if ( lkrc != LK_SUCCESS && lkrc != LK_KEY_EXISTS )
    {
        hr = HRESULT_FROM_WIN32( lkrc );
        goto exit;
    }

    hr = S_OK;

exit:

    if ( pApplicationObject )
    {
        pApplicationObject->DereferenceDataObject();
        pApplicationObject = NULL;
    }

    return hr;
}

HRESULT
APPLICATION_DATA_OBJECT_TABLE::ReadFromMetabaseChangeNotification(
    IMSAdminBase *              pAdminBase,
    MD_CHANGE_OBJECT            pcoChangeList[],
    DWORD                       dwMDNumElements,
    DATA_OBJECT_TABLE*          pMasterTable
)
/*++

Routine Description:

    Change change notification by building a new table

Arguments:

    pAdminBase - ABO pointer
    pcoChangeList - Properties which have changed
    dwMDNumElements - Number of properties which have changed

Return Value:

    HRESULT

--*/
{
    HRESULT                     hr = S_OK;
    DWORD                       i;
    WCHAR *                     pszPath = NULL;
    WCHAR *                     pszPathEnd = NULL;
    APPLICATION_DATA_OBJECT *   pApplicationObject = NULL;
    MB                          mb( pAdminBase );
    LK_RETCODE                  lkrc;
    BOOL                        fRet;
    DWORD                       dwSiteId;
    STACK_STRU(                 strAppPoolId, 256 );
    BOOL                        fReadAllObjects = FALSE;

    APPLICATION_DATA_OBJECT_TABLE* pMasterAppTable = ( APPLICATION_DATA_OBJECT_TABLE* ) pMasterTable;

    for ( i = 0; i < dwMDNumElements; i++ )
    {
        //
        // We only care about W3SVC properties 
        //

        IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        " Evaluation change notification for %S to see if applications care about it \n",
                        pcoChangeList[ i ].pszMDPath ));
        }
        
        if( _wcsnicmp( pcoChangeList[ i ].pszMDPath,
                       DATA_STORE_SERVER_MB_PATH,
                       DATA_STORE_SERVER_MB_PATH_CCH ) != 0 )
        {
            continue;
        }

        //
        // If a property changed at the W3SVC level, then we need to 
        // re-evaluate all the apps (i.e. read all the metabase props) once
        //
        
        if ( wcslen( pcoChangeList[ i ].pszMDPath ) == 
             DATA_STORE_SERVER_MB_PATH_CCH )
        {
            fReadAllObjects = TRUE;
            continue;

        }

        //
        // Evaluate which site changed
        //
        
        pszPath = pcoChangeList[ i ].pszMDPath + DATA_STORE_SERVER_MB_PATH_CCH;
        DBG_ASSERT( *pszPath != L'\0' );
        
        dwSiteId = wcstoul( pszPath, &pszPathEnd, 10 );
        
        //
        // We only care about sites
        //
        
        if ( dwSiteId == 0 )
        {
            continue;
        }
        
        DBG_ASSERT ( pszPathEnd );

        //
        // If not at least as deep as root, then ignore
        //
        
        if ( _wcsnicmp( pszPathEnd, L"/ROOT/", 6 ) != 0 )
        {

            // at this point it might be a deletion on a site.  if it is
            // then we want to delete all the applications that point to
            // this site.

            if (  pcoChangeList[ i ].dwMDChangeType & MD_CHANGE_TYPE_DELETE_OBJECT &&
                  ( ( pszPathEnd[0] == L'\0' ) || 
                    ( pszPathEnd[0] == L'/' && 
                      pszPathEnd[1] == L'\0') ) )
            {

                // if we are deleting a site, then we need to delete
                // all applications beneath it as well.

                // first change all entries in this table for this app to a delete.
                hr = DeleteSubApplications( NULL, dwSiteId, NULL, FALSE );
                if ( FAILED ( hr ) )
                {
                    goto exit;
                }

                // then add deletion references for any references in the master table.
                hr = DeleteSubApplications( pMasterAppTable, dwSiteId, NULL, FALSE );
                if ( FAILED ( hr ) )
                {
                    goto exit;
                }
        
            } // end of if we are on a real site being deleted

            continue;
        }
        
        //
        // Skip past /ROOT
        //
        
        pszPathEnd += 5;

        //
        // If this was a delete, then we're OK to add a row with it
        //

        BOOL fDeleteOnlyThisUrl = FALSE;

        //
        // If we are being told to delete a property on the application
        // we need to make sure that the property is not the AppPoolId.  If
        // it is then we are basically being told to delete the object.
        //
        if ( pcoChangeList[ i ].dwMDChangeType & MD_CHANGE_TYPE_DELETE_DATA )
        {
            for ( DWORD j = 0; j < pcoChangeList[ i ].dwMDNumDataIDs; j++ )
            {
                if ( pcoChangeList[ i ].pdwMDDataIDs[ j ] == MD_APP_APPPOOL_ID )
                {
                    // We are basically just deleting the object so change the
                    // change action to show this.

                    pcoChangeList[ i ].dwMDChangeType = pcoChangeList[ i ].dwMDChangeType |
                                                        MD_CHANGE_TYPE_DELETE_OBJECT;

                    fDeleteOnlyThisUrl = TRUE;

                }
            }
        }

        // 
        // Now if we are removing this application, let's get to it.
        //
        if ( pcoChangeList[ i ].dwMDChangeType & MD_CHANGE_TYPE_DELETE_OBJECT )
        {
            // if we are deleting an application, then we need to delete
            // all applications beneath it as well.

            // first change all entries in this table for this app to a delete.
            hr = DeleteSubApplications( NULL, dwSiteId, pszPathEnd, fDeleteOnlyThisUrl );
            if ( FAILED ( hr ) )
            {
                goto exit;
            }

            // then add deletion references for any references in the master table.
            hr = DeleteSubApplications( pMasterAppTable, dwSiteId, pszPathEnd, fDeleteOnlyThisUrl );
            if ( FAILED ( hr ) )
            {
                goto exit;
            }
        }
        else
        {

            //
            // If this is an insert/update, we need to first check whether
            // there is an actual application at the path in question
            //
        
            fRet = mb.Open( pcoChangeList[ i ].pszMDPath, 
                            METADATA_PERMISSION_READ );
            if ( !fRet )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );

                // if we can not find the key then a delete
                // for the object is on it's way, so we can 
                // ignore this change notification.
                if ( hr == HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) )
                {
                    hr = S_OK;
                    continue;
                }

                goto exit;
            }
        
            fRet = mb.GetStr( L"",
                              MD_APP_APPPOOL_ID,
                              IIS_MD_UT_SERVER,
                              &strAppPoolId,
                              0 );

            // close the metabase so that we can get
            // the next item in the loop if we need to
            // without this call we can get told the path
            // is not found.

            mb.Close();

            if ( fRet )
            {
                //
                // We have an application here!
                //
        
                pApplicationObject = new APPLICATION_DATA_OBJECT;
                if ( pApplicationObject == NULL )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    goto exit;
                }
      
                hr = pApplicationObject->Create( pszPathEnd,
                                                 dwSiteId );
                if ( FAILED( hr ) )
                {
                    goto exit;
                } 

                IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "AppPoolId = '%S' \n ",
                                strAppPoolId.QueryStr() ));
                }

                hr = pApplicationObject->SetAppPoolId( strAppPoolId.QueryStr() );
                if ( FAILED( hr ) )
                {
                    goto exit;
                }

                IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "AppPoolId = '%S' \n ",
                                pApplicationObject->QueryAppPoolId() ));
                }

                IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                " Inserting Site '%d''s Application '%S' from the metadata tables \n",
                                pApplicationObject->QuerySiteId(),
                                pApplicationObject->QueryApplicationUrl()));
                }

                //
                // Insert into the table
                //

                // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                //
                // General rule about inserting into tables:
                //
                // For Initial Processing and Complete processing caused by
                // a change notification, we will always ignore inserting a
                // object if we fine an object all ready in the table.  This is because
                // during a change notification if a record was added by the change
                // notification code, it will be more correct ( like knowing if ServerCommand
                // actually changed ), then the new generic record that was read because
                // of a change to a hire node.  Also during initial read we should
                // not have to make this decision so we can still ignore if we do see it.
                //
                // For Change Processing we will need to evaluate the change that 
                // all ready exists and compare it with the new change to decide 
                // what change we should make.
                //
                // For the case of application since it doesn't have any special property like
                // ServerCommand or AppPoolCommand that we need to know that it has changed
                // we can always just take the second record regardless of what is happening.
                // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                
                lkrc = InsertRecord( (DATA_OBJECT*) pApplicationObject, TRUE );
                if ( lkrc != LK_SUCCESS )
                {
                    hr = HRESULT_FROM_WIN32( lkrc );
                    goto exit;
                }
            
                pApplicationObject->DereferenceDataObject();
                pApplicationObject = NULL;
            }
        }
    }  // end of loop.

    //
    // if we saw something along the way that is going to cause us to need
    // to re-read all the objects, now is the time to do it.
    //
    if ( fReadAllObjects )
    {
        hr = ReadFromMetabasePath( pAdminBase, L"/LM/W3SVC", TRUE);
        if ( FAILED( hr ) )
        {
            goto exit;
        }
    }
        
exit:

    if ( pApplicationObject )
    {
        pApplicationObject->DereferenceDataObject();
        pApplicationObject = NULL;
    }

    return hr;
}

//static
LK_ACTION
APPLICATION_DATA_OBJECT_TABLE::CreateWASObjectsAction(
    IN DATA_OBJECT * pObject, 
    IN LPVOID 
    )
/*++

Routine Description:

    Handles determining if the application data object
    should be created in WAS's known apps

Arguments:

    IN DATA_OBJECT* pObject = the app to decide about
    IN LPVOID pTableVoid    = pointer back to the table the
                              pObject is from

Return Value:

    LK_ACTION

--*/
{
    
    DBG_ASSERT ( pObject );

    APPLICATION_DATA_OBJECT* pAppObject = (APPLICATION_DATA_OBJECT*) pObject;
    DBG_ASSERT( pAppObject->CheckSignature() );

    //
    // For both Inserts and Updates we call Modify application
    // this is because we allow WAS to determine if the application
    // exists or not.  It could exist if it is the root app and was
    // created for us.
    //
    if ( pAppObject->QueryShouldWasInsert() )
    {
        GetWebAdminService()->
             GetUlAndWorkerManager()->
             ModifyApplication( pAppObject );
    }
        
    return LKA_SUCCEEDED;
}

//static
LK_ACTION
APPLICATION_DATA_OBJECT_TABLE::UpdateWASObjectsAction(
    IN DATA_OBJECT * pObject, 
    IN LPVOID 
    )
/*++

Routine Description:

    Handles determining if the application data object
    should be updated in WAS's known apps

Arguments:

    IN DATA_OBJECT* pObject = the app to decide about
    IN LPVOID pTableVoid    = pointer back to the table the
                              pObject is from

Return Value:

    LK_ACTION

--*/
{
    
    DBG_ASSERT ( pObject );

    APPLICATION_DATA_OBJECT* pAppObject = (APPLICATION_DATA_OBJECT*) pObject;
    DBG_ASSERT( pAppObject->CheckSignature() );

    if ( pAppObject->QueryShouldWasUpdate() )
    {
        GetWebAdminService()->
             GetUlAndWorkerManager()->
             ModifyApplication( pAppObject );
    }
        
    return LKA_SUCCEEDED;
}

//static
LK_ACTION
APPLICATION_DATA_OBJECT_TABLE::DeleteWASObjectsAction(
    IN DATA_OBJECT * pObject, 
    IN LPVOID 
    )
/*++

Routine Description:

    Handles determining if the application data object
    should be deleted from WAS's known apps

Arguments:

    IN DATA_OBJECT* pObject = the app to decide about
    IN LPVOID pTableVoid    = pointer back to the table the
                              pObject is from

Return Value:

    LK_ACTION

--*/
{
    
    DBG_ASSERT ( pObject );

    APPLICATION_DATA_OBJECT* pAppObject = (APPLICATION_DATA_OBJECT*) pObject;
    DBG_ASSERT( pAppObject->CheckSignature() );

    if ( pAppObject->QueryShouldWasDelete() )
    {
        GetWebAdminService()->
             GetUlAndWorkerManager()->
             DeleteApplication( pAppObject->QueryApplicationUrl(),
                                pAppObject->QuerySiteId() );
    }
        
    return LKA_SUCCEEDED;
}

HRESULT
APPLICATION_DATA_OBJECT_TABLE::DeleteSubApplications(
    IN APPLICATION_DATA_OBJECT_TABLE* pTableToFindObjectsIn, 
    IN DWORD dwSiteId,
    IN LPWSTR pwszAppUrl,
    IN BOOL fDeleteOnlyThisUrl
    )
/*++

Routine Description:

    Deletes applications that exist under sites or other
    applications that are being deleted.

Arguments:

    IN APPLICATION_DATA_OBJECT_TABLE* pTableToFindObjectsIn = If null delete from current table.
    IN DWORD dwSiteId = Site Id of applications being deleted
    IN LPWSTR pwszAppUrl = AppUrl that must be contained in app to cause deletion ( if NULL, delete 
                           all applications for the site ).
    IN BOOL fDeleteOnlyThisUrl = Only applies if a specific URL is given.  If it is TRUE we will only
                                 delete the exact URL and none below it.

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    APPLICATION_DATA_OBJECT_TABLE* pTableToSearch = pTableToFindObjectsIn;
    APPLICATION_DATA_OBJECT* pOrigAppObject = NULL;

    // number of characters in the app url not counting the null
    DWORD cchInAppUrl = ( pwszAppUrl == NULL ) ? 0 : (DWORD) wcslen( pwszAppUrl );

    // remove the ending slash from the equation.
    if ( cchInAppUrl > 0 && 
         pwszAppUrl[cchInAppUrl-1] == '/' )
    {
        // Don't worry about the final '/'
        cchInAppUrl = cchInAppUrl - 1;
    }

    // If we were passed in a NULL for the table to search than we
    // really want to search the same table we are updating.
    //
    if ( pTableToSearch == NULL )
    {
        pTableToSearch = this;
    }

    // Now walk through the table and identify if the record we find 
    // is actually this record.

    for ( APPLICATION_DATA_OBJECT_TABLE::iterator appiter = pTableToSearch->begin();
          appiter != end();
          ++appiter )
    {
        
        pOrigAppObject = (APPLICATION_DATA_OBJECT*) appiter.Record();
        DBG_ASSERT( pOrigAppObject->CheckSignature() );

        // Found an application who's site matches the one being deleted
        if ( pOrigAppObject->QuerySiteId() == dwSiteId )
        {
            // if we are deleting the site, then delete this one
            // or if we are deleting the root application, then delete
            // all applications below it.
            if ( pwszAppUrl == NULL || cchInAppUrl == 0 )
            {

                // delete it.

                hr = DeleteThisURLFromTable( pOrigAppObject, pTableToFindObjectsIn );
                if ( FAILED ( hr ) )
                {
                    goto exit;
                }
            
            }
            else
            {
                //
                // we have all ready removed the '/' from the length above, so 
                // now we just need to make sure that if we find a match, it is 
                // ended with either a null or a slash.
                //
                DBG_ASSERT ( cchInAppUrl > 0 );

                if ( wcsncmp ( pwszAppUrl, pOrigAppObject->QueryApplicationUrl(), cchInAppUrl ) == 0 ) 
                { 
                    // do we want to only delete the specific url, or do we want to delete
                    // all urls under it as well. 
                    if ( fDeleteOnlyThisUrl )
                    {
                        //
                        // so if either the one we are comparing to is null terminated or
                        // null terminated directly after the trailing slash, then we can
                        // delete it.
                        //
                        if ( pOrigAppObject->QueryApplicationUrl()[cchInAppUrl] == '\0' ||
                             ( pOrigAppObject->QueryApplicationUrl()[cchInAppUrl] == '/'  && 
                               pOrigAppObject->QueryApplicationUrl()[cchInAppUrl+1] == '\0' ) )
                        {
                            // delete it.
                            hr = DeleteThisURLFromTable( pOrigAppObject, pTableToFindObjectsIn );
                            if ( FAILED ( hr ) )
                            {
                                goto exit;
                            }

                        }
                    }
                    else
                    {
                        //
                        // if the string we found ends with either a null or a slash then
                        // we should delete it.  We know this string has enough characters
                        // because it passed the above check.
                        //
                        if ( pOrigAppObject->QueryApplicationUrl()[cchInAppUrl] == '\0' ||
                             pOrigAppObject->QueryApplicationUrl()[cchInAppUrl] == '/' )
                        {
                            // delete it.
                            hr = DeleteThisURLFromTable( pOrigAppObject, pTableToFindObjectsIn );
                            if ( FAILED ( hr ) )
                            {
                                goto exit;
                            }

                        }
                    }
                }
                else
                {
                    // the url does not match so we don't need to do anything
                    // but move on.
                }

            } // end of URL specific check

        }  // end of site id matching

    }  // end of loop walking applications looking for site.

exit:

    return hr;
}


HRESULT
APPLICATION_DATA_OBJECT_TABLE::DeleteThisURLFromTable(
    IN APPLICATION_DATA_OBJECT* pOrigAppObject, 
    IN APPLICATION_DATA_OBJECT_TABLE* pTableFoundIn
    )
/*++

Routine Description:

    Adds an entry to delete a specific application from 
    a table.

Arguments:

    IN APPLICATION_DATA_OBJECT* pOrigAppObject = The object that we want deleted 
    IN APPLICATION_DATA_OBJECT_TABLE* pTableFoundIn = The table we were looking in.  If it is null then
                                                      we are looking in this table and the object is from
                                                      the same table that we are trying to alter, so we
                                                      don't have to clone and add.

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;
    APPLICATION_DATA_OBJECT *   pApplicationObject = NULL;
    LK_RETCODE                  lkrc;


    DBG_ASSERT ( pOrigAppObject );

    IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    " Deleting Site '%d''s Application '%S' from the metadata tables \n",
                    pOrigAppObject->QuerySiteId(),
                    pOrigAppObject->QueryApplicationUrl()));
    }

    // If the table found in is null then we are working on the same table
    // and all we have to do is change the DeleteWhenDone on the object.
    if ( pTableFoundIn == NULL )
    {
         pOrigAppObject->SetDeleteWhenDone( TRUE );
    }
    else
    {
        // We are putting an entry into a table that doesn't have an entry
        // yet, so we need to clone the object and insert it.

        pApplicationObject = ( APPLICATION_DATA_OBJECT* ) pOrigAppObject->Clone();
        if ( pApplicationObject == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto exit;
        }

        pApplicationObject->SetDeleteWhenDone( TRUE );

        //
        // Insert into the table
        //

        // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        //
        // General rule about inserting into tables:
        //
        // For Initial Processing and Complete processing caused by
        // a change notification, we will always ignore inserting a
        // object if we find an object all ready in the table.  This is because
        // during a change notification if a record was added by the change
        // notification code, it will be more correct ( like knowing if ServerCommand
        // actually changed ), then the new generic record that was read because
        // of a change to a hire node.  Also during initial read we should
        // not have to make this decision so we can still ignore if we do see it.
        //
        // For Change Processing we will need to evaluate the change that 
        // all ready exists and compare it with the new change to decide 
        // what change we should make.
        //
        // For the case of application since it doesn't have any special property like
        // ServerCommand or AppPoolCommand that we need to know that it has changed
        // we can always just take the second record regardless of what is happening.
        // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        lkrc = InsertRecord( (DATA_OBJECT*) pApplicationObject, TRUE );
        if ( lkrc != LK_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( lkrc );
            goto exit;
        }
    }
exit:

    if ( pApplicationObject )
    {
        pApplicationObject->DereferenceDataObject();
        pApplicationObject = NULL;
    }

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\application.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    application.h

Abstract:

    The IIS web admin service application class definition.

Author:

    Seth Pollack (sethp)        04-Nov-1998

Revision History:

--*/


#ifndef _APPLICATION_H_
#define _APPLICATION_H_



//
// forward references
//

class APP_POOL;
class VIRTUAL_SITE;
class UL_AND_WORKER_MANAGER;

//
// common #defines
//

#define APPLICATION_SIGNATURE       CREATE_SIGNATURE( 'APLN' )
#define APPLICATION_SIGNATURE_FREED CREATE_SIGNATURE( 'aplX' )

//
// structs, enums, etc.
//

// app id struct needed by the hashtable
struct APPLICATION_ID
{

    DWORD VirtualSiteId;
    STRU  ApplicationUrl;
    
};

//
// prototypes
//

class APPLICATION
{

public:

    APPLICATION(
        );

    virtual
    ~APPLICATION(
        );

    HRESULT
    Initialize(
        IN APPLICATION_DATA_OBJECT * pAppObject,
        IN VIRTUAL_SITE * pVirtualSite,
        IN APP_POOL * pAppPool
        );

    VOID
    SetConfiguration(
        IN APPLICATION_DATA_OBJECT * pAppObject,
        IN APP_POOL * pAppPool
        );

    VOID
    ReregisterURLs(
        );

    VOID
    RegisterLoggingProperties(
        );

    inline
    APP_POOL *
    GetAppPool(
        )
        const
    { return m_pAppPool; }

    inline
    const APPLICATION_ID *
    GetApplicationId(
        )
        const
    { return &m_ApplicationId; }

    inline
    PLIST_ENTRY
    GetVirtualSiteListEntry(
        )
    { return &m_VirtualSiteListEntry; }

    static
    APPLICATION *
    ApplicationFromVirtualSiteListEntry(
        IN const LIST_ENTRY * pVirtualSiteListEntry
        );

    inline
    PLIST_ENTRY
    GetAppPoolListEntry(
        )
    { return &m_AppPoolListEntry; }

    static
    APPLICATION *
    ApplicationFromAppPoolListEntry(
        IN const LIST_ENTRY * pAppPoolListEntry
        );

    inline
    PLIST_ENTRY
    GetDeleteListEntry(
        )
    { return &m_DeleteListEntry; }

    static
    APPLICATION *
    ApplicationFromDeleteListEntry(
        IN const LIST_ENTRY * pDeleteListEntry
        );

    VOID
    ConfigureMaxBandwidth(
        );

    VOID
    ConfigureMaxConnections(
        );

    VOID
    ConfigureConnectionTimeout(
        );

#if DBG
    VOID
    DebugDump(
        );

#endif  // DBG

    VOID
    SetAppPool(
        IN APP_POOL * pAppPool
        );

    BOOL 
    InMetabase(
        )
    { return m_InMetabase; }

private:

	APPLICATION( const APPLICATION & );
	void operator=( const APPLICATION & );

    HRESULT 
    ActivateConfigGroup(
        );

    HRESULT
    InitializeConfigGroup(
        );

    VOID
    AddUrlsToConfigGroup(
        );

    VOID
    SetConfigGroupAppPoolInformation(
        );

    HRESULT
    SetConfigGroupStateInformation(
        IN HTTP_ENABLED_STATE NewState
        );

    HRESULT
    RegisterSiteIdWithHttpSys(
        );

    DWORD m_Signature;

    APPLICATION_ID m_ApplicationId;

    // used by the associated VIRTUAL_SITE to keep a list of its APPLICATIONs
    LIST_ENTRY m_VirtualSiteListEntry;

    // used by the associated APP_POOL to keep a list of its APPLICATIONs
    LIST_ENTRY m_AppPoolListEntry;

    VIRTUAL_SITE * m_pVirtualSite;

    APP_POOL * m_pAppPool;

    // UL configuration group
    HTTP_CONFIG_GROUP_ID m_UlConfigGroupId;

    // Is UL currently logging information?
    BOOL m_ULLogging;

    // used for building a list of APPLICATIONs to delete
    LIST_ENTRY m_DeleteListEntry;   
    
    // used to remember if the metabase told us
    // about an application, or we created it for
    // ourselves.
    BOOL m_InMetabase;

};  // class APPLICATION

#endif  // _APPLICATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\application_table.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    application_table.h

Abstract:

    The IIS web admin service application table class definition.

Author:

    Seth Pollack (sethp)        03-Nov-1998

Revision History:

--*/


#ifndef _APPLICATION_TABLE_H_
#define _APPLICATION_TABLE_H_



//
// prototypes
//

class APPLICATION_TABLE
    : public CTypedHashTable< APPLICATION_TABLE, APPLICATION, const APPLICATION_ID * >
{

public:

    APPLICATION_TABLE(
        )
        : CTypedHashTable< APPLICATION_TABLE, APPLICATION, const APPLICATION_ID * >
                ( "APPLICATION_TABLE" )
    { /* do nothing*/ }

    virtual
    ~APPLICATION_TABLE(
        )
    { DBG_ASSERT( Size() == 0 ); }

    static
    const APPLICATION_ID *
    ExtractKey(
        IN const APPLICATION * pApplication
        )  
    { return pApplication->GetApplicationId(); }
    
    static
    DWORD
    CalcKeyHash(
        IN const APPLICATION_ID * Key
        ) 
    { return HashStringNoCase( Key->ApplicationUrl.QueryStr(), Key->VirtualSiteId ); }
    
    static
    bool
    EqualKeys(
        IN const APPLICATION_ID * Key1,
        IN const APPLICATION_ID * Key2
        )
    { return ( ( Key1->VirtualSiteId == Key2->VirtualSiteId ) && 
               ( CompareStringNoCase( Key1->ApplicationUrl.QueryStr(), 
                                      Key2->ApplicationUrl.QueryStr() ) == 0 ) ); }
    
    static
    void
    AddRefRecord(
        IN APPLICATION * pApplication,
        IN int IncrementAmount
        ) 
    { /* do nothing*/ 
        UNREFERENCED_PARAMETER( pApplication );
        UNREFERENCED_PARAMETER( IncrementAmount );
    }

    VOID
    Terminate(
        );

    static
    LK_ACTION
    DeleteApplicationAction(
        IN APPLICATION * pApplication, 
        IN VOID * pDeleteListHead
        );


#if DBG
    VOID
    DebugDump(
        );

    static
    LK_ACTION
    DebugDumpApplicationAction(
        IN APPLICATION * pApplication, 
        IN VOID * pIgnored
        );
#endif  // DBG

private:

 	APPLICATION_TABLE( const APPLICATION_TABLE & );
	void operator=( const APPLICATION_TABLE & );


};  // APPLICATION_TABLE



#endif  // _APPLICATION_TABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\app_pool.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    app_pool.cxx

Abstract:

    This class encapsulates a single app pool. 

    Threading: For the class itself, Reference(), Dereference(), and the
    destructor may be called on any thread; all other work is done on the 
    main worker thread.

Author:

    Seth Pollack (sethp)        01-Oct-1998

Revision History:

--*/



#include "precomp.h"
#include <Aclapi.h>


//
// local prototypes
//

/***************************************************************************++

Routine Description:

    Constructor for the APP_POOL class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

APP_POOL::APP_POOL(
    )
{

    //
    // Set the initial reference count to 1, in order to represent the
    // reference owned by the creator of this instance.
    //

    m_RefCount = 1;


    m_InAppPoolTable = FALSE;

    m_State = UninitializedAppPoolState; 

    m_pConfig = NULL;

    m_AppPoolHandle = NULL;

    m_WaitingForDemandStart = FALSE;

    InitializeListHead( &m_WorkerProcessListHead );
    m_WorkerProcessCount = 0;

    InitializeListHead( &m_ApplicationListHead );
    m_ApplicationCount = 0;

    m_TotalWorkerProcessRotations = 0;

    m_TotalWorkerProcessFailures = 0;
    
    m_RecentWorkerProcessFailures = 0;
    m_RecentFailuresWindowBeganTickCount = 0;
    
    m_DeleteListEntry.Flink = NULL;
    m_DeleteListEntry.Blink = NULL; 

    m_pJobObject = NULL;

    m_hrForDeletion = S_OK;

    m_hrLastReported = S_OK;

    m_MaxProcessesToLaunch = 0;

    m_NumWPStartedOnWayToMaxProcess = 0;

    m_Signature = APP_POOL_SIGNATURE;

}   // APP_POOL::APP_POOL



/***************************************************************************++

Routine Description:

    Destructor for the APP_POOL class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

APP_POOL::~APP_POOL(
    )
{

    DBG_ASSERT( m_Signature == APP_POOL_SIGNATURE );

    m_Signature = APP_POOL_SIGNATURE_FREED;

    DBG_ASSERT( m_RefCount == 0 );

    DBG_ASSERT( m_InAppPoolTable == FALSE );

    DBG_ASSERT( m_State == DeletePendingAppPoolState );

    DBG_ASSERT( m_AppPoolHandle == NULL );

    DBG_ASSERT( ! m_WaitingForDemandStart );


    //
    // This should not go away with any of its worker processes still around.
    //

    DBG_ASSERT( IsListEmpty( &m_WorkerProcessListHead ) );
    DBG_ASSERT( m_WorkerProcessCount == 0 );


    //
    // This should not go away with any applications still referring to it.
    //

    DBG_ASSERT( IsListEmpty( &m_ApplicationListHead ) );
    DBG_ASSERT( m_ApplicationCount == 0 );

    DBG_ASSERT ( m_pJobObject == NULL );

    //
    // Free any separately allocated config.
    //

    if ( m_pConfig )
    {
        m_pConfig->Dereference();
        m_pConfig = NULL;
    }


}   // APP_POOL::~APP_POOL



/***************************************************************************++

Routine Description:

    Increment the reference count for this object. Note that this method must 
    be thread safe, and must not be able to fail. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
APP_POOL::Reference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedIncrement( &m_RefCount );


    // 
    // The reference count should never have been less than zero; and
    // furthermore once it has hit zero it should never bounce back up;
    // given these conditions, it better be greater than one now.
    //
    
    DBG_ASSERT( NewRefCount > 1 );


    return;

}   // APP_POOL::Reference



/***************************************************************************++

Routine Description:

    Decrement the reference count for this object, and cleanup if the count 
    hits zero. Note that this method must be thread safe, and must not be
    able to fail. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
APP_POOL::Dereference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedDecrement( &m_RefCount );

    // ref count should never go negative
    DBG_ASSERT( NewRefCount >= 0 );

    if ( NewRefCount == 0 )
    {
        // time to go away

        IF_DEBUG( WEB_ADMIN_SERVICE_REFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Reference count has hit zero in APP_POOL instance, deleting (ptr: %p; id: %S)\n",
                this,
                GetAppPoolId()
                ));
        }

        delete this;

    }   

    return;
    
}   // APP_POOL::Dereference



/***************************************************************************++

Routine Description:

    Execute a work item on this object.

Arguments:

    pWorkItem - The work item to execute.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::ExecuteWorkItem(
    IN const WORK_ITEM * pWorkItem
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );
    DBG_ASSERT( GetWebAdminService()->IsBackwardCompatibilityEnabled() == FALSE );

    DBG_ASSERT( pWorkItem != NULL );

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        CHKINFO((
            DBG_CONTEXT, 
            "Executing work item with serial number: %lu in APP_POOL (ptr: %p; id: %S) with operation: %p\n",
            pWorkItem->GetSerialNumber(),
            this,
            GetAppPoolId(),
            pWorkItem->GetOpCode()
            ));
    }


    switch ( pWorkItem->GetOpCode() )
    {

        case DemandStartAppPoolWorkItem:
            hr = DemandStartWorkItem();
            if ( FAILED ( hr ) ) 
            {
                // ignore, we will have logged errors 
                // about this, so we can now ignore the failure.
                // this only returns an error code for BC mode
                // which does not go this path.

                hr = S_OK;
            }
        break;

        default:

            // invalid work item!
            DBG_ASSERT( FALSE );
            
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;
            
    }

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Executing work item on APP_POOL failed\n"
            ));

    }

    return hr;
    
}   // APP_POOL::ExecuteWorkItem



/***************************************************************************++

Routine Description:

    Initialize the app pool instance.

Arguments:

    pAppPoolObject - The configuration parameters for this app pool. 

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
APP_POOL::Initialize(
    IN APP_POOL_DATA_OBJECT* pAppPoolObject 
    )
{
    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;

    // Security descriptor variables for locking the app pool
    // down to just the Local System
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    PSID psidLocalSystem = NULL;
    PACL pACL = NULL;

    EXPLICIT_ACCESS ea;

    SECURITY_DESCRIPTOR sd = {0};
    SECURITY_ATTRIBUTES sa = {0};

    // Security descriptor variables for locking the app pool 
    // down also to the initial user.  If we get change notifications
    // working this code will be removed.
    BUFFER SidAndAttributes;  // Holds the SID and ATTRIBUTES for the token.

    HANDLE hControlChannel;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( pAppPoolObject != NULL );

    if ( pAppPoolObject == NULL )
    {
        return E_INVALIDARG;
    }

    //
    // First, make copy of the ID string.
    //

    hr = m_AppPoolId.Copy( pAppPoolObject->QueryAppPoolId() );
    if ( FAILED ( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Copying in app pool id from config object failed\n"
            ));

        goto exit;
    }

    //
    // Local System shall have all rights to the 
    // App_pool.  Until we have completed the config
    // work the Local System will be the only one 
    // with access.
    
    //
    // Get a sid that represents LOCAL_SYSTEM.
    //
    if(! AllocateAndInitializeSid( &SIDAuthNT, 1,
                 SECURITY_LOCAL_SYSTEM_RID,
                 0, 0, 0, 0, 0, 0, 0,
                 &psidLocalSystem ) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating Local System SID failed\n"
            ));

        goto exit;
    }
    
    SecureZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));

    //
    // Now setup the access structure to allow 
    // read access for the trustee.
    //
    ea.grfAccessPermissions = GENERIC_ALL;
    ea.grfAccessMode = GRANT_ACCESS;
    ea.grfInheritance= NO_INHERITANCE;
    ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ea.Trustee.ptstrName  = (LPTSTR) psidLocalSystem;

    //
    // In addition to ACLing local system we also need
    // to acl the worker process identity so we can access
    // the app pool from the other worker process.
    //

    //
    // Now we have the objects, we can go ahead and
    // setup the entries in the ACL.
    //

    // Create a new ACL that contains the new ACEs.
    //
    Win32Error = SetEntriesInAcl(1, &ea, NULL, &pACL);
    if ( Win32Error != ERROR_SUCCESS ) 
    {
        hr = HRESULT_FROM_WIN32(Win32Error);
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting ACE's into ACL failed.\n"
            ));

        goto exit;
    }

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) 
    {  
        hr = HRESULT_FROM_WIN32(GetLastError());
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing the security descriptor failed\n"
            ));

        goto exit;
    } 

    if (!SetSecurityDescriptorDacl(&sd, 
            TRUE,     // fDaclPresent flag   
            pACL, 
            FALSE))   // not a default DACL 
    {  
        hr = HRESULT_FROM_WIN32(GetLastError());
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting the DACL on the security descriptor failed\n"
            ));

        goto exit;
    } 

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle = FALSE;


    //
    // Finally we can create the app pool secured correctly.
    //
    Win32Error = HttpCreateAppPool(
                        &m_AppPoolHandle,           // returned handle
                        m_AppPoolId.QueryStr(),     // app pool ID
                        &sa,                        // security attributes
                        HTTP_OPTION_CONTROLLER      // controller
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't create app pool handle\n"
            ));

        goto exit;
    }

    //
    // Associate the app pool handle with the control channel
    //

    hControlChannel = GetWebAdminService()->GetUlAndWorkerManager()->
                        GetUlControlChannel();

    if ( !hControlChannel )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't retreive control channel handle\n"
            ));

        goto exit;
    }
    else
    {
        HTTP_APP_POOL_CONTROL_CHANNEL  CCInfo;

        CCInfo.Flags.Present = 1;
        CCInfo.ControlChannel = hControlChannel;
        
        hr = HttpSetAppPoolInformation(
                m_AppPoolHandle, 
                HttpAppPoolControlChannelInformation,
                reinterpret_cast<VOID *>(&CCInfo),
                sizeof(CCInfo)
                );

        if ( FAILED( hr ) )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Setting control channel on app pool failed\n"
                ));

            // "there's nothing to see here, move along..."
        }
    }

    //
    // Associate the app pool handle with the work queue's completion port.
    //
    
    hr = GetWebAdminService()->GetWorkQueue()->
                BindHandleToCompletionPort( 
                    m_AppPoolHandle, 
                    0
                    );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Binding app pool handle to completion port failed\n"
            ));

        goto exit;
    }


    //
    // Set the configuration information.
    //
    hr = SetConfiguration( pAppPoolObject, TRUE ); 
    if ( FAILED( hr ) )
    {
        // Logging will be done below, but if we did
        // not get atleast the initial configuration set
        // then this app pool is not usable.
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Set configuration failed\n"
            ));

        goto exit;
    }

    //
    // Set the state to running. We must do this before posting the
    // demand start wait, as demand start requests are only acted on
    // if the app pool is in the running state. 
    //
    ProcessStateChangeCommand( MD_APPPOOL_COMMAND_START , FALSE, HttpAppPoolEnabled );

exit:

    if (psidLocalSystem) 
    {
        FreeSid(psidLocalSystem);
        psidLocalSystem = NULL;
    }

    if (pACL) 
    {
        LocalFree(pACL);
        pACL = NULL;
    }

    return hr;
    
}   // APP_POOL::Initialize

/***************************************************************************++

Routine Description:

    Reset the app_pool to allow access to the current configured user.

Arguments:

    AccessMode - can be SET_ACCESS or REVOKE_ACCESS

Return Value:

    VOID

--***************************************************************************/

VOID
APP_POOL::ResetAppPoolAccess(
    IN ACCESS_MODE AccessMode,
    IN APP_POOL_CONFIG_STORE* pConfig
    )
{
    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;

    BUFFER SidAndAttributes;  // Holds the SID and ATTRIBUTES for the token.
    PSID psidUser = NULL;     // Will eventually point to the sid that is 
                              // created in the buffer space, don't free it.

    EXPLICIT_ACCESS ea;       // Used to describe an ACE for adding to a ACL.

    PACL pACL = NULL;         // Pointer to the new ACL to add to the security
                              // info.

    PACL                 pOldDACL = NULL;

    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD   SizeofTokenUser = 0;

    DBG_ASSERT ( AccessMode == SET_ACCESS || AccessMode == REVOKE_ACCESS );

    //
    // if the current token is the LOCAL_SYSTEM token
    // then we do not need to do anything, it all ready
    // has full access to the app_pool.
    //

    if ( NULL == pConfig ||
         NULL == pConfig->GetWorkerProcessToken() ||
         pConfig->GetWorkerProcessToken() == GetWebAdminService()->GetLocalSystemTokenCacheEntry() )
    {
        // no configuration changes needed.
        return;
    }

    // 
    // We need to get the sid from the token, first call the lookup 
    // to determine the size of the 
    //
    if (GetTokenInformation( pConfig->GetWorkerProcessToken(),
                              TokenUser,
                              NULL,
                              0,
                              &SizeofTokenUser ) )
    {
        //
        // if this worked, then there is a problem because
        // this call should fail with INSUFFICIENT_BUFFER_SIZE
        //
        hr = E_FAIL;
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Did not error when we expected to\n"
            ));

        goto exit;
    }
    else
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        if ( hr != HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Failed to get the size of the sid for the token\n"
                ));

            goto exit;
        }
        else
        {
            // ERROR_INSUFFICIENT_BUFFER is not a real error.
            hr = S_OK;
        }
    }

    //
    // Now resize the buffer to be the right size
    if ( ! SidAndAttributes.Resize( SizeofTokenUser ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Failed to resize the buffer to the correct size\n"
            ));

        goto exit;
    }

    //
    // Zero out the memory just to be safe.
    //
    SecureZeroMemory ( SidAndAttributes.QueryPtr(), SizeofTokenUser );


    //
    // Now use the GetTokenInformation routine to get the
    // security SID.
    //
    if (!GetTokenInformation( pConfig->GetWorkerProcessToken(),
                              TokenUser,
                              SidAndAttributes.QueryPtr(),
                              SizeofTokenUser,
                              &SizeofTokenUser ) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Error getting the account SID based on the token\n"
            ));

        goto exit;
    }

    // Set the psidUser to point to the sid that has been returned.
    psidUser = ( ( PTOKEN_USER ) (SidAndAttributes.QueryPtr()))->User.Sid;

    
    SecureZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));

    //
    // Now setup the access structure to allow 
    // read and synchronize access for the trustee.
    //
    ea.grfAccessPermissions = GENERIC_READ | SYNCHRONIZE;
    ea.grfAccessMode = AccessMode;
    ea.grfInheritance= NO_INHERITANCE;
    ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea.Trustee.TrusteeType = TRUSTEE_IS_USER;
    ea.Trustee.ptstrName  = (LPTSTR) psidUser;

    //
    // The pOldDACL is just a pointer into memory owned 
    // by the pSD, so only free the pSD.
    //
    Win32Error = GetSecurityInfo( m_AppPoolHandle,
                                  SE_FILE_OBJECT, 
                                  DACL_SECURITY_INFORMATION,
                                  NULL,        // owner SID
                                  NULL,        // primary group SID
                                  &pOldDACL,   // PACL*
                                  NULL,        // PACL*
                                  &pSD );      // Security Descriptor 
    if ( Win32Error != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32(Win32Error);

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not get security info for the app pool handle \n"
            ));

        goto exit;
    }

    //
    // Create a new ACL that contains the new ACEs.
    //
    Win32Error = SetEntriesInAcl(1, &ea, pOldDACL, &pACL);
    if ( Win32Error != ERROR_SUCCESS ) 
    {
        hr = HRESULT_FROM_WIN32(Win32Error);
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting ACE's into ACL failed.\n"
            ));

        goto exit;
    }

    Win32Error = SetSecurityInfo(m_AppPoolHandle, 
                                  SE_FILE_OBJECT, 
                                  DACL_SECURITY_INFORMATION,  // SecurityInfo flag
                                  NULL,   // Not setting because not specified by SecurityInfo flag to be set.
                                  NULL,   // Not setting because not specified by SecurityInfo flag to be set.
                                  pACL, 
                                  NULL);  // Not setting because not specified by SecurityInfo flag to be set.
    if ( Win32Error != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32(Win32Error);
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not set new security info \n"
            ));

        goto exit;
    }

exit:

    if( pSD != NULL ) 
    {
        LocalFree((HLOCAL) pSD); 
    }

    if( pACL != NULL ) 
    {
        LocalFree((HLOCAL) pACL); 
    }

    // Log the failure instead of returning an error.
    if ( FAILED ( hr ) )
    {
        const WCHAR * EventLogStrings[1];

        EventLogStrings[0] = GetAppPoolId();

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_APP_POOL_HANDLE_NOT_SECURED,                 // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),   // count of strings
                EventLogStrings,                                       // array of strings
                hr                                                     // error code
                );

    }

}


/***************************************************************************++

Routine Description:

    Accept a set of configuration parameters for this app pool. 

Arguments:

    pAppPoolObject - The configuration for this app pool.
    
    fInitializing - Are we in the initialization phase.

Return Value:

    HRESULT - all errors are logged to the event log, however during initialization
              we need to know if the basic pieces just didn't happen.

--***************************************************************************/

HRESULT
APP_POOL::SetConfiguration(
    IN APP_POOL_DATA_OBJECT* pAppPoolObject,
    IN BOOL fInitializing
    )
{

    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;
    BOOL JobObjectChangedBetweenEnabledAndDisabled = FALSE;
    BOOL IdentityChanged = FALSE;
    
    DBG_ASSERT( pAppPoolObject != NULL );
    if ( pAppPoolObject == NULL )
    {
        return E_INVALIDARG;
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "New configuration for app pool (ptr: %p; id: %S)\n",
            this,
            GetAppPoolId()
            ));
    }

    APP_POOL_CONFIG_STORE* pNewConfig = new APP_POOL_CONFIG_STORE();
    if ( pNewConfig == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating memory for configuration failed\n"
            ));

        const WCHAR * EventLogStrings[1];
        EventLogStrings[0] = pAppPoolObject->QueryAppPoolId();

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_FAILED_TO_SET_APP_POOL_CONFIGURATION,   // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                hr                                      // error code
                );

        return hr;
    }

    //
    // If this routine can not initialize some of it's data
    // it will do what it can an leave the rest to gracefully
    // cause errors later.  It returns VOID.
    //
    pNewConfig->Initialize( pAppPoolObject );

    //
    // Note that we rely on the config store to ensure that the configuration
    // data are valid. 
    //

    //
    // If the app pool identity changed or
    // even if all the properties didn't change
    // but the token was NULL before and is no longer NULL
    // then we need to reacl.
    //
   if ( pAppPoolObject->QueryAppPoolIdentityTypeChanged() ||     
        ( pAppPoolObject->QueryAppPoolIdentityType() == SpecificUserAppPoolUserType &&
          ( pAppPoolObject->QueryWAMUserNameChanged() ||
            pAppPoolObject->QueryWAMUserPassChanged() ) )  ||
        ( m_pConfig->GetWorkerProcessToken() == NULL &&
          pNewConfig->GetWorkerProcessToken() != NULL )  )
   {
        IdentityChanged = TRUE;
          
        // 
        // if we had a valid token before we want to revoke it's 
        // privledges on the app_pool before setting up a new
        // token.  if a worker process has the app_pool open they
        // will be able to continue to use it even if we have 
        // revoked their access.
        //
        ResetAppPoolAccess ( REVOKE_ACCESS, m_pConfig );

        // 
        // now that we have changed the worker process token
        // we are ready to secure to the new worker process token.
        //
        ResetAppPoolAccess ( SET_ACCESS, pNewConfig );

    }

    //
    // Configure the job object if we need to.
    // if there is an error, we will log an event and move on.
    //

    if ( pAppPoolObject->QueryCPUResetIntervalChanged() ||
         pAppPoolObject->QueryCPULimitChanged() ||
         pAppPoolObject->QueryCPUActionChanged() )
    {
        HandleJobObjectChanges(pNewConfig,
                                    &JobObjectChangedBetweenEnabledAndDisabled);
    }


    //
    // Once we are done with the app pool security change we can now
    // release the old configuration and set the new configuration in.
    //
    if ( m_pConfig )
    {
        m_pConfig->Dereference();
    }

    // Don't need to addref it because it takes the addref from the
    // new above.
    m_pConfig = pNewConfig;

    //
    // set it to null here so we 
    // know that this variable no longer
    // owns this object.
    //
    pNewConfig = NULL;

    //
    // Inform UL of new app pool configuration.
    //

    //
    // See if the app pool load balancer behavior has changed 
    // and if so, handle it.
    //

    if ( pAppPoolObject->QueryLoadBalancerTypeChanged() )
    {
        HTTP_LOAD_BALANCER_CAPABILITIES BalancerCapabilities;
        
        if ( m_pConfig->GetLoadBalancerType() == 1 )
        {
            BalancerCapabilities = HttpLoadBalancerBasicCapability;
        }
        else
        {
            DBG_ASSERT ( m_pConfig->GetLoadBalancerType() == 2 );
            
            BalancerCapabilities = HttpLoadBalancerSophisticatedCapability;
        }

        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Setting app pool's (ptr: %p; id: %S) Load balancer type to: %lu\n",
                this,
                GetAppPoolId(),
                BalancerCapabilities
                ));
        }

        Win32Error = HttpSetAppPoolInformation(
                            m_AppPoolHandle,        // app pool handle
                            HttpAppPoolLoadBalancerInformation,
                                                    // information class
                            reinterpret_cast <VOID *> ( &BalancerCapabilities ),
                                                    // data
                            sizeof( BalancerCapabilities )
                                                    // data length
                            );

        if ( Win32Error != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32( Win32Error );

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Setting app pool load balancer information failed\n"
                ));

            //
            // We tried, press on.
            //

            const WCHAR * EventLogStrings[1];
            EventLogStrings[0] = GetAppPoolId();

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_FAILED_TO_SET_LOAD_BALANCER_CAP,   // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    hr        // error code
                    );


            hr = S_OK;
        }

    }


    //
    // See if the app pool max queue length has been set or changed, 
    // and if so, handle it.
    //

    if ( pAppPoolObject->QueryAppPoolQueueLengthChanged() )
    {
        ULONG QueueLength = m_pConfig->GetUlAppPoolQueueLength();

        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Setting app pool's (ptr: %p; id: %S) UL queue length max: %lu\n",
                this,
                GetAppPoolId(),
                QueueLength
                ));
        }

        Win32Error = HttpSetAppPoolInformation(
                            m_AppPoolHandle,        // app pool handle
                            HttpAppPoolQueueLengthInformation,
                                                    // information class
                            reinterpret_cast <VOID *> ( &QueueLength ),
                                                    // data
                            sizeof( QueueLength )
                                                    // data length
                            );

        if ( Win32Error != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32( Win32Error );

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Setting app pool information failed\n"
                ));

            //
            // We tried, press on.
            //
            const WCHAR * EventLogStrings[1];
            EventLogStrings[0] = GetAppPoolId();

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_FAILED_TO_SET_QUEUE_LENGTH,   // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    hr        // error code
                    );

            hr = S_OK;
        }

    }
    

#if DBG
    //
    // Dump the configuration.
    //

    DebugDump();
#endif  // DBG

    //
    // Process any ServerCommand that may want us to alter the state of the 
    // app pool.  We only honor this in FC mode, because you can not stop
    // and app pool in BC mode.
    //
    if ( pAppPoolObject->QueryAppPoolCommandChanged() &&
         !GetWebAdminService()->IsBackwardCompatibilityEnabled() )
    {
        //
        // verify that the app pool command actually changed to 
        // a valid setting. if it did not then we will log an event
        // that says we are not going to process this command.
        //
        //
        if  ( ( pAppPoolObject->QueryAppPoolCommand() == MD_APPPOOL_COMMAND_START ) || 
              ( pAppPoolObject->QueryAppPoolCommand() == MD_APPPOOL_COMMAND_STOP ) )
        {
            ProcessStateChangeCommand( 
                                        pAppPoolObject->QueryAppPoolCommand(),  // command to perform
                                        TRUE,                     // it is a direct command
                                        HttpAppPoolDisabled_ByAdministrator
                                        );
        }
        else
        {
            //
            // not a valid command so we need to log an event.
            //
            GetWebAdminService()->
            GetWMSLogger()->
            LogAppPoolCommand( GetAppPoolId(),
                               pAppPoolObject->QueryAppPoolCommand(),
                               TRUE);

        }
    }

    //
    // If allowed, rotate all worker processes to ensure that the config 
    // changes take effect. 
    //
    // Only recycle if it was a property that affects the worker processes.
    //
    if ( !fInitializing &&
         !GetWebAdminService()->IsBackwardCompatibilityEnabled() && 
         ( pAppPoolObject->QueryPeriodicRestartTimeChanged() ||
           pAppPoolObject->QueryPeriodicRestartRequestsChanged() ||
           pAppPoolObject->QueryPeriodicRestartScheduleChanged() ||
           pAppPoolObject->QueryPeriodicRestartMemoryChanged() ||
           pAppPoolObject->QueryPeriodicRestartMemoryPrivateChanged() ||
           pAppPoolObject->QueryIdleTimeoutChanged() ||
           pAppPoolObject->QuerySMPAffinitizedChanged() ||
           pAppPoolObject->QuerySMPProcessorAffinityMaskChanged() ||
           pAppPoolObject->QueryPingIntervalChanged() ||
           pAppPoolObject->QueryPingingEnabledChanged() ||
           pAppPoolObject->QueryStartupTimeLimitChanged() ||
           pAppPoolObject->QueryShutdownTimeLimitChanged() ||
           pAppPoolObject->QueryPingResponseTimeChanged() ||
           pAppPoolObject->QueryOrphanWorkerProcessChanged() ||
           pAppPoolObject->QueryOrphanActionExecutableChanged() ||
           pAppPoolObject->QueryOrphanActionParametersChanged() ||
           pAppPoolObject->QueryMaxProcessesChanged() ||
           JobObjectChangedBetweenEnabledAndDisabled ||
           IdentityChanged ) )
    {

        HandleConfigChangeAffectingWorkerProcesses();
    }

    return S_OK;

}   // APP_POOL::SetConfiguration

/***************************************************************************++

Routine Description:

    Handles deciding if we need a job object enabled or disabled
    and then has the job object class, carry it out.

Arguments:

    IN APP_POOL_CONFIG_STORE* pNewAppPoolConfig,
    OUT BOOL* pJobObjectChangedBetweenEnabledAndDisabled = Out parameter that tells
                                            if the enabled / disabled state has
                                            changed.
    

Return Value:

    VOID

--***************************************************************************/

VOID
APP_POOL::HandleJobObjectChanges(
    IN APP_POOL_CONFIG_STORE* pNewAppPoolConfig,
    OUT BOOL* pJobObjectChangedBetweenEnabledAndDisabled
    )
{
    HRESULT hr = S_OK;

    DBG_ASSERT ( pJobObjectChangedBetweenEnabledAndDisabled );
    DBG_ASSERT ( pNewAppPoolConfig );

    if ( pNewAppPoolConfig == NULL ||
         pJobObjectChangedBetweenEnabledAndDisabled == NULL )
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    *pJobObjectChangedBetweenEnabledAndDisabled = FALSE;

    //
    // Never do anything with the job object in backward 
    // compatibility mode.
    //
    if ( GetWebAdminService()->IsBackwardCompatibilityEnabled() )
    {
        return;
    }

    // if either of these equals zero then we will not be enabling
    // the job objects at this time.
    BOOL fWillBeEnabled = ( pNewAppPoolConfig->GetCPUResetInterval() != 0 &&
                            pNewAppPoolConfig->GetCPULimit() != 0 );


    // predict if we should be recycling the worker processes.
    // even if something goes wrong below it just means an extra
    // recycle, so go for it.
    *pJobObjectChangedBetweenEnabledAndDisabled = 
                ( (  fWillBeEnabled && !m_pJobObject  ) ||
                  ( !fWillBeEnabled &&  m_pJobObject  ) );

    // if we aren't enabled and we won't be enabled
    // then we should be able to just blow off the change
    if ( !fWillBeEnabled  && !m_pJobObject )
    {
        // Go ahead and just return S_OK;
        return;
    }

    // Do we need to create a new job object?
    if ( !m_pJobObject && fWillBeEnabled )
    {
        //
        // Allocate a new job object for the app pool.
        //
        m_pJobObject = new JOB_OBJECT;
        if ( m_pJobObject == NULL )
        {
            HRESULT hrTemp = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);

            UNREFERENCED_PARAMETER ( hrTemp );
            DPERROR(( 
                DBG_CONTEXT,
                hrTemp,
                "Failed to allocate the job object object\n"
                ));

            goto exit;
        }

        //
        // Initialize the new job object so it is ready to 
        // have limits set on it.
        //
        hr = m_pJobObject->Initialize(this);
        if ( FAILED ( hr ) )
        {
    
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Initialization of the job object failed\n"
                ));

            m_pJobObject->Dereference();
            m_pJobObject = NULL;

            goto exit;
        }

    }

    //                  
    // if we all ready have a job object ( even if we just created it )
    // and we are going to still be enabled, we just need to change
    // the settings on the job object.
    //
    if ( fWillBeEnabled )
    {
        DBG_ASSERT ( m_pJobObject );
        m_pJobObject->SetConfiguration( pNewAppPoolConfig->GetCPUResetInterval(), 
                                             pNewAppPoolConfig->GetCPULimit(),
                                             pNewAppPoolConfig->GetCPUAction());
    }

    // 
    // last case is if we are enabled and we are being turned off.
    //
    if ( !fWillBeEnabled && m_pJobObject )
    {
        // in this case we need to turn off the job object

        //
        // tell the job object to terminate ( this will queue a 
        // work item that will mark when the job object
        // terminated after we dequeue this marker we know
        // that it is safe to destroy the work item the job
        // object was passing back to us.
        //

        m_pJobObject->Terminate();

        // 
        // The job object will wait on it's own.  We need to sever
        // the ties between the job object and the app pool now.
        //
        m_pJobObject->Dereference();
        m_pJobObject = NULL;
    }

exit:

    if ( FAILED ( hr ) ) 
    {
        // Log the error for the Job Object Change Failure

        const WCHAR * EventLogStrings[1];
        EventLogStrings[0] = GetAppPoolId();

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_FAILED_TO_CONFIGURE_JOB_OBJECT,   // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                hr                                     // error code
                );

    }

} // APP_POOL::HandleJobObjectChanges()




/***************************************************************************++

Routine Description:

    Register an application as being part of this app pool.

Arguments:

    pApplication - Pointer to the APPLICATION instance.

Return Value:

    VOID

--***************************************************************************/

VOID
APP_POOL::AssociateApplication(
    IN APPLICATION * pApplication
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pApplication != NULL );
    if ( pApplication == NULL )
    {
        return;
    }

    InsertHeadList( 
        &m_ApplicationListHead, 
        pApplication->GetAppPoolListEntry() 
        );
        
    m_ApplicationCount++;

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Associated application %lu:\"%S\" with app pool \"%S\"; app count now: %lu\n",
            ( pApplication->GetApplicationId() )->VirtualSiteId,
            ( pApplication->GetApplicationId() )->ApplicationUrl.QueryStr(),
            m_AppPoolId.QueryStr(),
            m_ApplicationCount
            ));
    }
    
}   // APP_POOL::AssociateApplication



/***************************************************************************++

Routine Description:

    Remove the registration of an application that is part of this app
    pool.

Arguments:

    pApplication - Pointer to the APPLICATION instance.

Return Value:

    VOID

--***************************************************************************/

VOID
APP_POOL::DissociateApplication(
    IN APPLICATION * pApplication
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( pApplication != NULL );
    if ( pApplication == NULL )
    {
        return;
    }

    RemoveEntryList( pApplication->GetAppPoolListEntry() );
    ( pApplication->GetAppPoolListEntry() )->Flink = NULL; 
    ( pApplication->GetAppPoolListEntry() )->Blink = NULL; 

    m_ApplicationCount--;

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Dissociated application %lu:\"%S\" from app pool \"%S\"; app count now: %lu\n",
            ( pApplication->GetApplicationId() )->VirtualSiteId,
            ( pApplication->GetApplicationId() )->ApplicationUrl.QueryStr(),
            m_AppPoolId.QueryStr(),
            m_ApplicationCount
            ));
    }

}   // APP_POOL::DissociateApplication



/***************************************************************************++

Routine Description:

    Handle the fact that there has been an unplanned worker process failure.

Arguments:

    BOOL  ShutdownPoolRegardless - Will shutdown the app pool regardless of 
                                   whether RFP is enabled or if we have hit
                                   enough failures to cause RFP to activated.

Return Value:

    VOID

--***************************************************************************/

VOID
APP_POOL::ReportWorkerProcessFailure(
    BOOL  ShutdownPoolRegardless
    )
{

    DWORD TickCount = 0;
    const WCHAR * EventLogStrings[1];

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );
    DBG_ASSERT( GetWebAdminService()->IsBackwardCompatibilityEnabled() == FALSE );
    DBG_ASSERT( m_pConfig );

    EventLogStrings[0] = m_AppPoolId.QueryStr();

    // Always update the count of total WP Failures
    m_TotalWorkerProcessFailures++;

#if DBG
    if ( ReadDwordParameterValueFromRegistry( REGISTRY_VALUE_W3SVC_BREAK_ON_WP_ERROR, 0 ) )
    {
        DBG_ASSERT ( FALSE );
    }
#endif

    //
    // First process it if it is shutdown always.  In this case, we really 
    // don't care about being over any limits.  There may be a window when
    // we get two of these failures queued before we actually shutdown, but
    // that should be rare if not impossible and the worst that will happen
    // should be some extra error messages.
    //
    if ( ShutdownPoolRegardless )
    {
        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Shutting down app pool because of one time fatal failure (ptr: %p; id: %S)\n",
                this,
                GetAppPoolId()
                ));
        }

        //
        // Log an event: engaging rapid fail protection.
        //

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_RAPID_FAIL_PROTECTION_REGARDLESS,        // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                0                                       // error code
                );

        ProcessStateChangeCommand( MD_APPPOOL_COMMAND_STOP , 
                                FALSE,
                                HttpAppPoolDisabled_RapidFailProtection );

        return;
    }

    if ( m_pConfig->IsRapidFailProtectionEnabled() ) 
    {
        //
        // See if it's time to reset the tick count which is used to remember
        // when the time window began that we use for counting recent rapid
        // failures. 
        // Note that tick counts are in milliseconds. Tick counts roll over 
        // every 49.7 days, but the arithmetic operation works correctly 
        // anyways in this case.
        //

        TickCount = GetTickCount();

        if ( ( TickCount - m_RecentFailuresWindowBeganTickCount ) > ( m_pConfig->GetRapidFailProtectionIntervalMS() ) )
        {
            //
            // It's time to reset the time window, and the recent fail count.
            //

            IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
            {
                DBGPRINTF((
                    DBG_CONTEXT, 
                    "Resetting rapid repeated failure count and time window in app pool (ptr: %p; id: %S)\n",
                    this,
                    GetAppPoolId()
                    ));
            }

            m_RecentFailuresWindowBeganTickCount = TickCount;
            m_RecentWorkerProcessFailures = 0;
        }


        //
        // Update counters.
        //

        m_RecentWorkerProcessFailures++;

        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Total WP failures: %lu; recent WP failures: %lu for app pool (ptr: %p; id: %S)\n",
                m_TotalWorkerProcessFailures,
                m_RecentWorkerProcessFailures,
                this,
                GetAppPoolId()
                ));
        }

        //
        // At this point we know we are not in the shutdown always case
        // We need to determine if we are over the limit, and if we are
        // then we should log and maybe shutdown.
        //
        //
        // Check the recent fail count against the limit. We only do it
        // once until something like the limit changes, window changes or
        // properties change.
        //

        if ( m_RecentWorkerProcessFailures >= m_pConfig->GetRapidFailProtectionMaxCrashes() )
        {
            // Handle turning off appliations in UL for the 
            // failed apppool.
            //
            IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
            {
                DBGPRINTF((
                    DBG_CONTEXT, 
                    "Enagaging rapid fail protection in app pool (ptr: %p; id: %S)\n",
                    this,
                    GetAppPoolId()
                    ));
            }

            //
            // Log an event: engaging rapid fail protection.
            //

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_RAPID_FAIL_PROTECTION,        // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    0                                       // error code
                    );

            ProcessStateChangeCommand( MD_APPPOOL_COMMAND_STOP , 
                                            FALSE,
                                            HttpAppPoolDisabled_RapidFailProtection );

        } // end of being over limit

    }  // End of rapid fail protection being enabled

}   // APP_POOL::ReportWorkerProcessFailure



/***************************************************************************++

Routine Description:

    Start the new worker process which will replace a currently running one.
    Once the new worker process is ready (or if it failed to start 
    correctly), we begin shutdown of the old worker process.

Arguments:

    pWorkerProcessToReplace - Pointer to the worker process to replace,
    once we have started its replacement. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::RequestReplacementWorkerProcess(
    IN WORKER_PROCESS * pWorkerProcessToReplace
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pWorkerProcessToReplace != NULL );

    if ( pWorkerProcessToReplace == NULL )
    {
        return E_INVALIDARG;
    }


    //
    // Check to see if we should actually create the new replacement process. 
    //

    if ( ! IsOkToReplaceWorkerProcess() )
    {
        //
        // Signal to callers that we are not going to replace.
        //
        
        hr = E_FAIL;

        goto exit;
    }

    //
    // Create a replacement. 
    //

    hr = CreateWorkerProcess( 
                ReplaceWorkerProcessStartReason, 
                pWorkerProcessToReplace
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating worker process failed\n"
            ));

        goto exit;
    }


    //
    // Update counters.
    //

    m_TotalWorkerProcessRotations++;


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Total WP rotations: %lu for app pool (ptr: %p; id: %S)\n",
            m_TotalWorkerProcessRotations,
            this,
            GetAppPoolId()
            ));
    }


exit:

    return hr;
    
}   // APP_POOL::RequestReplacementWorkerProcess


/***************************************************************************++

Routine Description:

    Adds a worker process to the job object, while it is still in
    suspended mode.  This way any job's it creates will also be added.

Arguments:

    WORKER_PROCESS* pWorkerProcess

Return Value:

    VOID

--***************************************************************************/
VOID
APP_POOL::AddWorkerProcessToJobObject(
    WORKER_PROCESS* pWorkerProcess
    )
{
    HRESULT hr = S_OK;

    DBG_ASSERT ( pWorkerProcess );

    if ( pWorkerProcess == NULL )
    {
        return;
    }

    //
    // In BC mode the job object will be null so 
    // we won't need to really do anything here.
    //

    if ( m_pJobObject )
    {
        DBG_ASSERT ( pWorkerProcess->GetProcessHandle() );

        hr = m_pJobObject->AddWorkerProcess(  pWorkerProcess->GetProcessHandle() );
        if ( FAILED( hr ) )
        {
            const WCHAR * EventLogStrings[2];
            WCHAR StringizedProcessId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];

            // String is declared to be long enough to handle 
            // the max size of a DWORD, which should be what this call
            // returns.
            _snwprintf( StringizedProcessId, 
                        sizeof( StringizedProcessId ) / sizeof ( WCHAR ), L"%lu", 
                        pWorkerProcess->GetRegisteredProcessId() );

            // To make prefast happy we null terminate, however the string was setup to take 
            // exactly the max size the snwprintf (including the null) can provide, 
            // so we don't worry about losing data.
            StringizedProcessId[ MAX_STRINGIZED_ULONG_CHAR_COUNT - 1 ] = '\0';

            EventLogStrings[0] = StringizedProcessId;
            EventLogStrings[1] = GetAppPoolId();


            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_WP_NOT_ADDED_TO_JOBOBJECT,                   // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),   // count of strings
                    EventLogStrings,                                       // array of strings
                    hr                                                     // error code
                    );
            
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Adding worker process %lu to the job object representing App Pool '%S' failed\n",
                pWorkerProcess->GetRegisteredProcessId(),
                GetAppPoolId()
                ));

            //
            // Forget the failure now.  And continue to deal with the worker process
            // as if nothing was wrong.  The worst that will happen is the worker process
            // will not be monitored as part of the job.
            //
            hr = S_OK;
        }
    }

} // end APP_POOL::AddWorkerProcessToJobObject


/***************************************************************************++

Routine Description:

    Informs this app pool that one of its worker processes has 
    completed its start-up attempt. This means that the worker process has
    either reached the running state correctly, or suffered an error which
    prevented it from doing so (but was not fatal to the service as a whole). 

    This notification allows the app pool to do any processing that
    was pending on the start-up of a worker process.

Arguments:

    StartReason - The reason the worker process was started.

Return Value:

    VOID

--***************************************************************************/

VOID
APP_POOL::WorkerProcessStartupAttemptDone(
    IN WORKER_PROCESS_START_REASON StartReason
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    switch( StartReason )
    {

    case ReplaceWorkerProcessStartReason:

        //
        // Nothing to do here.
        //

        //
        // We should not be getting ReplaceWorkerProcessStartReason in 
        // backward compatibility mode.
        //

        DBG_ASSERT(GetWebAdminService()->IsBackwardCompatibilityEnabled() == FALSE);
        
        break;


    case DemandStartWorkerProcessStartReason:

        //
        // If we are in backward compatiblity mode 
        // we need to finish the service starting
        //
        if (GetWebAdminService()->IsBackwardCompatibilityEnabled())
        {
            GetWebAdminService()->InetinfoRegistered();
        }

        //
        // See if we should start waiting for another demand start notification
        // from UL for this app pool. If we are in backward compatibility mode, 
        // then we are not going to do the WaitForDemandStartIfNeeded here, we will
        // issue a wait only if something happens to the current worker process.
        //

        WaitForDemandStartIfNeeded();

        break;


    default:

        // invalid start reason!
        DBG_ASSERT( FALSE );
    
        break;
        
    }
    
}   // APP_POOL::WorkerProcessStartupAttemptDone



/***************************************************************************++

Routine Description:

    Remove a worker process object from the list on this app pool object. 

Arguments:

    pWorkerProcess - The worker process object to remove.

Return Value:

    VOID

--***************************************************************************/

VOID
APP_POOL::RemoveWorkerProcessFromList(
    IN WORKER_PROCESS * pWorkerProcess
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );
    DBG_ASSERT( pWorkerProcess != NULL );
    if ( pWorkerProcess != NULL )
    {

        RemoveEntryList( pWorkerProcess->GetAppPoolListEntry() );
        ( pWorkerProcess->GetAppPoolListEntry() )->Flink = NULL; 
        ( pWorkerProcess->GetAppPoolListEntry() )->Blink = NULL; 

        m_WorkerProcessCount--;

        //
        // Clean up the reference to the worker process that the app 
        // pool holds. Because each worker process is reference counted, it 
        // will delete itself as soon as it's reference count hits zero.
        //

        pWorkerProcess->Dereference();

    }

    //
    // See if we should start waiting for another demand start notification
    // from UL for this app pool.  Even in Backward Compatibility mode we 
    // should initiate this wait here, because inetinfo.exe may be recycling
    // and we may need to get another worker process up.
    //

    WaitForDemandStartIfNeeded();

    //
    // See if shutdown is underway, and if so if it has completed now 
    // that this worker process is gone. 
    //
    
    CheckIfShutdownUnderwayAndNowCompleted();

    
}   // APP_POOL::RemoveWorkerProcessFromList



/***************************************************************************++

Routine Description:

    Kick off gentle shutdown of this app pool, by telling all of its worker
    processes to shut down. 

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
APP_POOL::Shutdown(
    )
{

    DWORD Win32Error = ERROR_SUCCESS;
    HTTP_APP_POOL_ENABLED_STATE NewHttpAppPoolState
            = HttpAppPoolDisabled_ByAdministrator;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    //
    // Update our state to remember that we are shutting down.
    // We won't mark the state in the metabase until we have 
    // shutdown.

    // Issue:  We could mark the metabase state as shutting down.
    //

    m_State = ShutdownPendingAppPoolState;

    //
    // Tell http that the app pool is disabled.
    //

    Win32Error = HttpSetAppPoolInformation(
                        m_AppPoolHandle,                // app pool handle
                        HttpAppPoolStateInformation,    // information class
                        reinterpret_cast <VOID *> ( &NewHttpAppPoolState ),  // data
                        sizeof( HTTP_APP_POOL_ENABLED_STATE )    // data length
                        );
    if ( Win32Error != NO_ERROR )
    {
        
        const WCHAR * EventLogStrings[1];
        EventLogStrings[0] = GetAppPoolId();

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_FAILED_TO_DISABLE_APP_POOL,   // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                HRESULT_FROM_WIN32( Win32Error )        // error code
                );

        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32( Win32Error ),
            "Disabling app pool in http failed\n"
            ));
       
        // Press on in the face of errors.
        //
        // Actually if we don't complete this routine then
        // we may end up not shutting down the server. And a 
        // failure here should not stop us from shutting it down.
    }

    //
    // Shut down the worker processes belonging to this app pool.
    //

    ShutdownAllWorkerProcesses();

    //
    // See if shutdown has already completed. This could happen if we have
    // no worker processes that need to go through the clean shutdown 
    // handshaking. 
    //
    
    CheckIfShutdownUnderwayAndNowCompleted();


}   // APP_POOL::Shutdown

/***************************************************************************++

Routine Description:

    Request all worker processes from this app pool to send counters. 

Arguments:

    None

Return Value:

    DWORD  - Number of wp's to wait for.

--***************************************************************************/

DWORD
APP_POOL::RequestCounters(
    )
{

    PLIST_ENTRY pListEntry = NULL;
    PLIST_ENTRY pNextListEntry = NULL;
    WORKER_PROCESS * pWorkerProcess = NULL;
    DWORD NumberProcesses = 0;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    //
    // If this app pool is not in a running state, then it is either not
    // initialized yet, or it is shutting down.  In either case, skip requesting
    // counters from it's worker process.  The worker processes will send counters
    // on shutdown so don't worry about not getting them if the app pool is 
    // shutting down.
    //
    if ( m_State != RunningAppPoolState )
    {
        return 0;
    }

    pListEntry = m_WorkerProcessListHead.Flink;

    while ( pListEntry != &m_WorkerProcessListHead )
    {

        DBG_ASSERT( pListEntry != NULL );

        pNextListEntry = pListEntry->Flink;

        pWorkerProcess = WORKER_PROCESS::WorkerProcessFromAppPoolListEntry( pListEntry );

        //
        // Ask the worker process to request counters.
        // 

        if ( pWorkerProcess->RequestCounters() )
        {
            NumberProcesses++;
        }


        pListEntry = pNextListEntry;
        
    }

    return NumberProcesses;

}   // APP_POOL::RequestCounters


/***************************************************************************++

Routine Description:

    Request all worker processes reset there perf counter state.
Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
APP_POOL::ResetAllWorkerProcessPerfCounterState(
    )
{

    PLIST_ENTRY pListEntry = NULL;
    PLIST_ENTRY pNextListEntry = NULL;
    WORKER_PROCESS * pWorkerProcess = NULL;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    pListEntry = m_WorkerProcessListHead.Flink;

    while ( pListEntry != &m_WorkerProcessListHead )
    {

        DBG_ASSERT( pListEntry != NULL );

        pNextListEntry = pListEntry->Flink;

        pWorkerProcess = WORKER_PROCESS::WorkerProcessFromAppPoolListEntry( pListEntry );

        //
        // Ask the worker process to request counters.
        // 

        pWorkerProcess->ResetPerfCounterState();

        pListEntry = pNextListEntry;
        
    }

}   // APP_POOL::ResetAllWorkerProcessPerfCounterState



/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities 
    which may hold a reference to this object to release that reference 
    (and not take any more), in order to break reference cycles. 

    Note that this function may cause the instance to delete itself; 
    instance state should not be accessed when unwinding from this call. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
APP_POOL::Terminate(
    )
{

    PLIST_ENTRY pListEntry = NULL;
    WORKER_PROCESS * pWorkerProcess = NULL;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    //
    // Issue: Should this move to the end?  Do we need to have changed the m_State value
    // before we do any of this work?
    //
    // Set the virtual site state to stopped.  (In Metabase does not affect UL)
    //
    ChangeState( DeletePendingAppPoolState, m_hrForDeletion );

    //
    // Shutdown the job object and make sure that 
    // we get a valid hresult returned (if we are 
    // not in BC Mode).  If we are the JobObject
    // will be NULL.
    //

    if ( m_pJobObject )
    {
        m_pJobObject->Terminate();
        m_pJobObject->Dereference();
        m_pJobObject = NULL;
    }

    while ( m_WorkerProcessCount > 0 )
    {
    
        pListEntry = m_WorkerProcessListHead.Flink;

        //
        // The list shouldn't be empty, since the count was greater than zero.
        //
        
        DBG_ASSERT( pListEntry != &m_WorkerProcessListHead );


        pWorkerProcess = WORKER_PROCESS::WorkerProcessFromAppPoolListEntry( pListEntry );


        //
        // Terminate the worker process. Note that the worker process 
        // will call back to remove itself from this list inside this call.
        //

        pWorkerProcess->Terminate();

    }

    DBG_ASSERT( IsListEmpty( &m_WorkerProcessListHead ) );


    //
    // Note that closing the handle will cause the demand start i/o 
    // (if any) to complete as cancelled, allowing us to at that point
    // clean up its reference count.
    //
    
    if ( m_AppPoolHandle != NULL )
    {
        DBG_REQUIRE( CloseHandle( m_AppPoolHandle ) );
        m_AppPoolHandle = NULL;
    }

    //
    // Tell our parent to remove this instance from it's data structures,
    // and dereference the instance. 
    //

    if ( IsInAppPoolTable() )
    {

        GetWebAdminService()->GetUlAndWorkerManager()->RemoveAppPoolFromTable( this );      


        //
        // Note: that may have been our last reference, so don't do any
        // more work here.
        //

    }
   

    return;
    
}   // APP_POOL::Terminate


/***************************************************************************++

Routine Description:

    A static class method to "upcast" from the delete list LIST_ENTRY 
    pointer of a APP_POOL to the APP_POOL as a whole.

Arguments:

    pDeleteListEntry - A pointer to the m_DeleteListEntry member of a 
    APP_POOL.

Return Value:

    The pointer to the containing APP_POOL.

--***************************************************************************/

// note: static!
APP_POOL *
APP_POOL::AppPoolFromDeleteListEntry(
    IN const LIST_ENTRY * pDeleteListEntry
)
{

    APP_POOL * pAppPool = NULL;

    DBG_ASSERT( pDeleteListEntry != NULL );

    //  get the containing structure, then verify the signature
    pAppPool = CONTAINING_RECORD(
                            pDeleteListEntry,
                            APP_POOL,
                            m_DeleteListEntry
                            );

    DBG_ASSERT( pAppPool->m_Signature == APP_POOL_SIGNATURE );

    return pAppPool;

}   // APP_POOL::AppPoolFromDeleteListEntry



/***************************************************************************++

Routine Description:

    Check whether this app pool should be waiting to receive demand start
    requests, and if so, issue the wait.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
APP_POOL::WaitForDemandStartIfNeeded(
    )
{
    // we never wait on demand starts in BC mode.
    // just ignore them.
    if ( GetWebAdminService()->IsBackwardCompatibilityEnabled() )
    {
        return;
    }

    //
    // Check to see if we are in a state where we should even bother 
    // waiting for a demand start notification.
    //

    if ( ! IsOkToCreateWorkerProcess() )
    {
        return;
    }


    //
    // If we are already waiting for a demand start, don't wait again.
    //

    if ( m_WaitingForDemandStart )
    {
        return;
    }

    WaitForDemandStart();

}   // APP_POOL::WaitForDemandStartIfNeeded

/***************************************************************************++

Routine Description:

    Function exposes publicly the DemandStartWorkItem function
    only in backward compatibility mode.  It asserts and does
    nothing in the forward compatibility mode.

Arguments:

    None.

Return Value:

    HRESULT - need to know this fails so we either fail to startup the service
              or if we are trying to recover from a crash, we want to shutdown
              if we can not do this.

--***************************************************************************/

HRESULT
APP_POOL::DemandStartInBackwardCompatibilityMode(
    )
{

    // In backward compatibility mode there is only one
    // application and it is the default application so
    // we never worry that we are on the right application.
    DBG_ASSERT(GetWebAdminService()->IsBackwardCompatibilityEnabled());

    if (GetWebAdminService()->IsBackwardCompatibilityEnabled())
    {
        return DemandStartWorkItem();
    }
    else
    {
        return S_OK;
    }

}   // APP_POOL::DemandStartInBackwardCompatibilityMode


#if DBG
/***************************************************************************++

Routine Description:

    Dump out key internal data structures.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
APP_POOL::DebugDump(
    )
{

    PLIST_ENTRY pListEntry = NULL;
    APPLICATION * pApplication = NULL;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT ( m_pConfig );

    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "********App pool (ptr: %p; id: %S)\n",
            this,
            GetAppPoolId()
            ));
    }
    

    //
    // List config for this app pool.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Periodic restart period (in minutes; zero means disabled): %lu\n",
            m_pConfig->GetPeriodicProcessRestartPeriodInMinutes()
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Periodic restart request count (zero means disabled): %lu\n",
            m_pConfig->GetPeriodicProcessRestartRequestCount()
            ));


        DBGPRINTF((
            DBG_CONTEXT, 
            "--Restart based on virtual memory usage (in kB; zero means disabled): %lu\n",
            m_pConfig->GetPeriodicProcessRestartMemoryUsageInKB()
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Restart based on private bytes memory usage (in kB; zero means disabled): %lu\n",
            m_pConfig->GetPeriodicProcessRestartMemoryPrivateUsageInKB()
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Periodic restart schedule (MULTISZ - only first value printed) - %S\n",
            ( (m_pConfig->GetPeriodicProcessRestartSchedule() != NULL ) ? 
               m_pConfig->GetPeriodicProcessRestartSchedule():L"<empty>" )
            ));



        DBGPRINTF((
            DBG_CONTEXT, 
            "--Max (steady state) process count: %lu\n",
            m_pConfig->GetMaxSteadyStateProcessCount()
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--SMP affinitization enabled: %S\n",
            ( m_pConfig->GetSMPAffinitized() ? L"TRUE" : L"FALSE" )
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--SMP affinitization processor mask: %p\n",
            m_pConfig->GetSMPAffinitizedProcessorMask()
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Pinging enabled: %S\n",
            ( m_pConfig->IsPingingEnabled() ? L"TRUE" : L"FALSE" )
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Idle timeout (zero means disabled): %lu\n",
            m_pConfig->GetIdleTimeoutInMinutes()
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Rapid fail protection enabled: %S\n",
            ( m_pConfig->IsRapidFailProtectionEnabled() ? L"TRUE" : L"FALSE" )
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Rapid fail protection time limit ( in milliseconds ) : %lu\n",
            m_pConfig->GetRapidFailProtectionIntervalMS()
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Rapid fail protection max crashes : %lu\n",
            m_pConfig->GetRapidFailProtectionMaxCrashes()
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Orphan processes for debugging enabled: %S\n",
            ( m_pConfig->IsOrphaningProcessesForDebuggingEnabled() ? L"TRUE" : L"FALSE" )
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Startup time limit (in seconds): %lu\n",
            m_pConfig->GetStartupTimeLimitInSeconds()
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Shutdown time limit (in seconds): %lu\n",
            m_pConfig->GetShutdownTimeLimitInSeconds()
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Ping interval (in seconds): %lu\n",
            m_pConfig->GetPingIntervalInSeconds()
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Ping response time limit (in seconds): %lu\n",
            m_pConfig->GetPingResponseTimeLimitInSeconds()
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Disallow overlapping rotation (false means overlap is ok): %S\n",
            ( m_pConfig->IsDisallowOverlappingRotationEnabled() ? L"TRUE" : L"FALSE" )
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Orphan action executable: %S\n",
            ( m_pConfig->GetOrphanActionExecutable() ? m_pConfig->GetOrphanActionExecutable() : L"<none>" )
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Orphan action parameters: %S\n",
            ( m_pConfig->GetOrphanActionParameters() ? m_pConfig->GetOrphanActionParameters() : L"<none>" )
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--UL app pool queue length max: %lu\n",
            m_pConfig->GetUlAppPoolQueueLength()
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Disallow rotation on config changes (false means rotation is ok): %S\n",
            ( m_pConfig->IsDisallowRotationOnConfigChangesEnabled() ? L"TRUE" : L"FALSE" )
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--CPUAction (0 - log, 1 - kill, 2 - trace?, 3 - throttle?): %d\n",
            ( m_pConfig->GetCPUAction() )
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--CPULimit (0-100,000): %d\n",
            ( m_pConfig->GetCPULimit() )
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--CPUResetInterval (minutes): %d\n",
            ( m_pConfig->GetCPUResetInterval() )
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Disable action executable: %S\n",
            ( m_pConfig->GetDisableActionExecutable() ? m_pConfig->GetDisableActionExecutable() : L"<none>" )
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Disable action parameters: %S\n",
            ( m_pConfig->GetDisableActionParameters() ? m_pConfig->GetDisableActionParameters() : L"<none>" )
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Load Balancer Type: %d\n",
            ( m_pConfig->GetLoadBalancerType() )
            ));

    }

    //
    // List the applications of this app pool.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            ">>>>App pool's applications:\n"
            ));
    }


    pListEntry = m_ApplicationListHead.Flink;

    while ( pListEntry != &m_ApplicationListHead )
    {
    
        DBG_ASSERT( pListEntry != NULL );

        pApplication = APPLICATION::ApplicationFromAppPoolListEntry( pListEntry );


        IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                ">>>>>>>>Application of site: %lu with path: %S\n",
                pApplication->GetApplicationId()->VirtualSiteId,
                pApplication->GetApplicationId()->ApplicationUrl.QueryStr()
                ));
        }


        pListEntry = pListEntry->Flink;

    }


    return;
    
}   // APP_POOL::DebugDump
#endif  // DBG



/***************************************************************************++

Routine Description:

    Wait asynchronously for a demand start request from UL for this app 
    pool. This is done by posting an async i/o to UL. This i/o will be 
    completed by UL to request that a worker process be started for this
    app pool.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
APP_POOL::WaitForDemandStart(
    )
{

    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;
    WORK_ITEM * pWorkItem = NULL; 


    //
    // Create a work item to use for the async i/o, so that the resulting
    // work can be serviced on the main worker thread via the work queue.
    // 

    hr = GetWebAdminService()->GetWorkQueue()->GetBlankWorkItem( &pWorkItem );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not get a blank work item\n"
            ));

        goto exit;
    }


    pWorkItem->SetWorkDispatchPointer( this );
    
    pWorkItem->SetOpCode( DemandStartAppPoolWorkItem );


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        CHKINFO((
            DBG_CONTEXT, 
            "About to issue demand start for app pool (ptr: %p; id: %S) using work item with serial number: %li\n",
            this,
            GetAppPoolId(),
            pWorkItem->GetSerialNumber()
            ));
    }


    Win32Error = HttpWaitForDemandStart(
                        m_AppPoolHandle,            // app pool handle
                        NULL,                       // buffer (not needed)
                        0,                          // buffer length (not needed)
                        NULL,                       // bytes returned (not needed)
                        pWorkItem->GetOverlapped()  // OVERLAPPED
                        );

    if ( Win32Error == NO_ERROR )
    {
        Win32Error = ERROR_IO_PENDING;
    }

    if ( Win32Error != ERROR_IO_PENDING )
    {
        DBG_ASSERT( Win32Error != NO_ERROR );


        hr = HRESULT_FROM_WIN32( Win32Error );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Issuing demand start async i/o failed\n"
            ));


        //
        // If queueing failed, free the work item here. (In the success case,
        // it will be freed once it is serviced.)
        //
        GetWebAdminService()->GetWorkQueue()->FreeWorkItem( pWorkItem );

        goto exit;
    }


    m_WaitingForDemandStart = TRUE;


exit:

    if ( FAILED ( hr ) )
    {
        const WCHAR * EventLogStrings[1];
        EventLogStrings[0] = GetAppPoolId();

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_FAILED_TO_WAIT_FOR_DEMAND_START,   // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                hr                                      // error code
                );
    }

}   // APP_POOL::WaitForDemandStart



/***************************************************************************++

Routine Description:

    Respond to a demand start request from UL by attempting to start a new 
    worker process.

Arguments:

    None.

Return Value:

    HRESULT - This path is used for BC mode, so we need to return an HRESULT
              because we can't keep the service running if BC mode fails.

--***************************************************************************/

HRESULT
APP_POOL::DemandStartWorkItem(
    )
{

    //
    // Since we've come out of the wait for demand start, clear the flag.
    //

    m_WaitingForDemandStart = FALSE;


    //
    // Check to see if we should actually create the new process. 
    //

    if ( ! IsOkToCreateWorkerProcess() )
    {
        return S_OK;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Demand start request received for app pool (ptr: %p; id: %S); creating worker process\n",
            this,
            GetAppPoolId()
            ));
    }


    //
    // Create the process.
    //

    return CreateWorkerProcess( 
                DemandStartWorkerProcessStartReason, 
                NULL
                );



}   // APP_POOL::DemandStartWorkItem



/***************************************************************************++

Routine Description:

    Check whether it is ok to create a new worker process. 

Arguments:

    None.

Return Value:

    BOOL - TRUE if it is ok to create a worker process, FALSE if not.

--***************************************************************************/

BOOL
APP_POOL::IsOkToCreateWorkerProcess(
    )
    const
{

    BOOL OkToCreate = TRUE; 

    
    //
    // If we are in some state other than the normal running state (for
    // example, if we are shutting down), don't create more worker 
    // processes.
    //

    if ( m_State != RunningAppPoolState )
    {
        OkToCreate = FALSE; 

        goto exit;
    }


    //
    // in BC Mode we don't care about the number of worker processes created
    // this is because we may still have one that is shutting down while we have
    // another one being started due to an inetinfo crash and iisreset being 
    // enabled.
    //

    //
    // Don't create new processes if we would exceed the configured limit.
    // or if we are in backward compatibility mode, ignore the limit and
    // never allow a second worker process to be created. (just in case)
    //

    if ( m_WorkerProcessCount >= m_MaxProcessesToLaunch  
         &&  GetWebAdminService()->IsBackwardCompatibilityEnabled() == FALSE )
    {
        OkToCreate = FALSE; 

        goto exit;
    }

exit:

    // We should never ask for a worker process to be created and
    // be denied in backward compatibility mode.
    //
    // Worst case is a low memory situation and the server goes down
    // but this is better than if the svchost side stays up and the
    // inetinfo part is not up.
    if ( !OkToCreate &&
         GetWebAdminService()->IsBackwardCompatibilityEnabled() )
    {           
        GetWebAdminService()->RequestStopService(FALSE);
    }

    return OkToCreate; 

}   // APP_POOL::IsOkToCreateWorkerProcess



/***************************************************************************++

Routine Description:

    Check whether it is ok to replace a worker process. 

Arguments:

    None.

Return Value:

    BOOL - TRUE if it is ok to replace a worker process, FALSE if not.

--***************************************************************************/

BOOL
APP_POOL::IsOkToReplaceWorkerProcess(
    )
    const
{

    BOOL OkToReplace = TRUE; 
    ULONG ProcessesGoingAwaySoon = 0;
    ULONG SteadyStateProcessCount = 0;

    DBG_ASSERT ( m_pConfig );
    
    //
    // If we are in some state other than the normal running state (for
    // example, if we are shutting down), don't replace processes.
    //

    if ( m_State != RunningAppPoolState )
    {
        OkToReplace = FALSE; 

        goto exit;
    }


    if ( m_pConfig->IsDisallowOverlappingRotationEnabled() )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "For app pool (ptr: %p; id: %S), disallowing replace because overlapping replacement not allowed\n",
                this,
                GetAppPoolId()
                ));
        }

        OkToReplace = FALSE; 

        goto exit;
    }


    //
    // If the maximum number of processes has been adjusted down on 
    // the fly, we disallow replacement of processes while the steady
    // state process count remains over the new maximum. (This will
    // casue a process requesting replacement to instead just spin 
    // down, helping us throttle down to the new max.) To do this, we 
    // check the current number of processes that are *not* being 
    // replaced against the current max. 
    //

    ProcessesGoingAwaySoon = GetCountOfProcessesGoingAwaySoon();

    SteadyStateProcessCount = m_WorkerProcessCount - ProcessesGoingAwaySoon;

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "For app pool (ptr: %p; id: %S), total WPs: %lu; steady state WPs: %lu; WPs going away soon: %lu; max steady state allowed: %lu\n",
            this,
            GetAppPoolId(),
            m_WorkerProcessCount,
            SteadyStateProcessCount,
            ProcessesGoingAwaySoon,
            m_MaxProcessesToLaunch
            ));
    }


    if ( SteadyStateProcessCount > m_MaxProcessesToLaunch )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "For app pool (ptr: %p; id: %S), disallowing replace because we are over the process count limit\n",
                this,
                GetAppPoolId()
                ));
        }

        OkToReplace = FALSE; 

        goto exit;
    }

exit:

    return OkToReplace; 

}   // APP_POOL::IsOkToReplaceWorkerProcess



/***************************************************************************++

Routine Description:

    Determine the set of worker processes that are currently being replaced.

Arguments:

    None.

Return Value:

    ULONG - The count of processes being replaced. 

--***************************************************************************/

ULONG
APP_POOL::GetCountOfProcessesGoingAwaySoon(
    )
    const
{

    PLIST_ENTRY pListEntry = NULL;
    PLIST_ENTRY pNextListEntry = NULL;
    WORKER_PROCESS * pWorkerProcess = NULL;
    ULONG ProcessesGoingAwaySoon = 0;


    //
    // Count the number of processes being replaced.
    //


    pListEntry = m_WorkerProcessListHead.Flink;


    while ( pListEntry != &m_WorkerProcessListHead )
    {

        DBG_ASSERT( pListEntry != NULL );

        pNextListEntry = pListEntry->Flink;

        pWorkerProcess = WORKER_PROCESS::WorkerProcessFromAppPoolListEntry( pListEntry );


        if ( pWorkerProcess->IsGoingAwaySoon() )
        {
            ProcessesGoingAwaySoon++;
        }


        pListEntry = pNextListEntry;
        
    }


    return ProcessesGoingAwaySoon;

}   // APP_POOL::GetCountOfProcessesGoingAwaySoon



/***************************************************************************++

Routine Description:

    Create a new worker process for this app pool.

Arguments:

    StartReason - The reason the worker process is being started.

    pWorkerProcessToReplace - If the worker process is being created to replace
    an existing worker process, this parameter identifies that predecessor 
    process; NULL otherwise.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::CreateWorkerProcess(
    IN WORKER_PROCESS_START_REASON StartReason,
    IN WORKER_PROCESS * pWorkerProcessToReplace OPTIONAL
    )
{

    HRESULT hr = S_OK;
    WORKER_PROCESS * pWorkerProcess = NULL;

    //
    // If we are on the first worker process then
    // regardless of how we got here we need to 
    // reset staggering.  
    //
    if ( m_WorkerProcessCount == 0 )
    {
        ResetStaggering();
    }

    // If we are in web garden mode...
    if ( m_MaxProcessesToLaunch > 1 )
    {
        if ( m_NumWPStartedOnWayToMaxProcess < m_MaxProcessesToLaunch )
        {
            // once this value becomes equal to MaxProcessesToLaunch
            // we will no longer stager on creation of the worker processes
            m_NumWPStartedOnWayToMaxProcess++;
        }
        else
        {
            // If we aren't updating the number then we must be at 
            // the max case.
            DBG_ASSERT ( m_NumWPStartedOnWayToMaxProcess == m_MaxProcessesToLaunch );
        }
    }
    else
    {
        // If we are not in web garden mode than always pass 
        // the max processes value, so we don't stager.
        m_NumWPStartedOnWayToMaxProcess = m_MaxProcessesToLaunch;
    }

    DBG_ASSERT ( m_NumWPStartedOnWayToMaxProcess > 0 && 
                 m_NumWPStartedOnWayToMaxProcess <= m_MaxProcessesToLaunch );

    //
    // need to also pass the MaxProcessesToLaunch 
    // because the number in the config
    // may not be being honored yet.
    //
    pWorkerProcess = new WORKER_PROCESS( 
                                this,
                                m_pConfig,
                                StartReason,
                                pWorkerProcessToReplace,
                                m_MaxProcessesToLaunch,
                                m_NumWPStartedOnWayToMaxProcess
                                );

    if ( pWorkerProcess == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating WORKER_PROCESS failed\n"
            ));


        //
        // If we couldn't even create the object, then it certainly isn't
        // going to be able to tell us when it's startup attempt is done;
        // so instead we attempt to do it here.
        //

        WorkerProcessStartupAttemptDone( StartReason );

        goto exit;
    }


    InsertHeadList( &m_WorkerProcessListHead, pWorkerProcess->GetAppPoolListEntry() );
    m_WorkerProcessCount++;

    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Initializing new worker process\n"
            ));
    }


    pWorkerProcess->Initialize();

exit:

    return hr;
    
}   // APP_POOL::CreateWorkerProcess

/***************************************************************************++

Routine Description:

    Disables the application pool by stopping all the worker processes,
    marking the app pool to not issue any more demand starts to Ul, and
    pausing all the applications associated with the app pool. 

Arguments:

    None.

Return Value:

    HRESULT

Note:

    Disabling an app pool will initiate process shutdown, but it is possible that
    all the processes will not have shutdown by the time the app pool is re-enabled.
    If the MaxProcesses is set to 3 and there are 3 worker processes still hanging
    around even though the app pool has been disabled, when the app pool is re-enabled
    we will not issue a demand start.  However once a worker process either shutsdown
    correctly or is killed or orphaned due to the worker process timeout it will tell
    the AppPool that it is gone and the app pool will again check to see if it can issue
    a new demand start to http.  Since enabling the app pool will allow you to pickup
    changes to the max processes the new max processes will be used for the decision even
    on the old worker processes shutting down.

--***************************************************************************/

VOID
APP_POOL::DisableAppPool(
    HTTP_APP_POOL_ENABLED_STATE DisabledReason
    )
{

    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;

    //
    // Only disable running applications.
    //
    if ( m_State != RunningAppPoolState ) 
    {
        return;
    }

    //
    // Tell http that the app pool is disabled.
    //

    Win32Error = HttpSetAppPoolInformation(
                        m_AppPoolHandle,                // app pool handle
                        HttpAppPoolStateInformation,    // information class
                        reinterpret_cast <VOID *> ( &DisabledReason ),  // data
                        sizeof( HTTP_APP_POOL_ENABLED_STATE )    // data length
                        );
    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );

        const WCHAR * EventLogStrings[1];
        EventLogStrings[0] = GetAppPoolId();

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_FAILED_TO_DISABLE_APP_POOL,   // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                hr                                      // error code
                );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Disabling app pool in http failed\n"
            ));

        // press on, http may still have the app pool enabled, but
        // we will not spin up wp's and we will report it as disabled in 
        // the metabase.
        hr = S_OK;
    }

    // 
    // Stop the worker processes.
    ShutdownAllWorkerProcesses();

    HRESULT hrForMetabase = S_OK;

    //
    // If we are in rapid fail protection, we want to have the UI
    // show an error so we are going to set the Win32Error to E_FAIL.
    // We just don't have a better hresult and we don't have a way of
    // creating our own.
    //

    if ( DisabledReason == HttpAppPoolDisabled_RapidFailProtection )
    {
        hrForMetabase = E_FAIL;
    }

    ChangeState ( DisabledAppPoolState, hrForMetabase );

    if ( DisabledReason != HttpAppPoolDisabled_ByAdministrator )
    {
        // Launch Auto Shutdown Command
        RunDisableAction();
    }

}   // APP_POOL::DisableAppPool

/***************************************************************************++

Routine Description:

    Enables an application pool that has previously been disabled. 

Arguments:

    BOOL DirectCommand - Is this a direct command.

Return Value:

    HRESULT

Note:

    Disabling an app pool will initiate process shutdown, but it is possible that
    all the processes will not have shutdown by the time the app pool is re-enabled.
    If the MaxProcesses is set to 3 and there are 3 worker processes still hanging
    around even though the app pool has been disabled, when the app pool is re-enabled
    we will not issue a demand start.  However once a worker process either shutsdown
    correctly or is killed or orphaned due to the worker process timeout it will tell
    the AppPool that it is gone and the app pool will again check to see if it can issue
    a new demand start to http.  Since enabling the app pool will allow you to pickup
    changes to the max processes the new max processes will be used for the decision even
    on the old worker processes shutting down.

--***************************************************************************/
VOID
APP_POOL::EnableAppPool(
    BOOL DirectCommand
    )
{

    HRESULT hr = S_OK;
    HTTP_APP_POOL_ENABLED_STATE NewHttpAppPoolState = HttpAppPoolEnabled;
    DWORD Win32Error = NO_ERROR;

    //
    // Only enable, disabled applications.
    //
    if ( m_State != DisabledAppPoolState &&
         m_State != UninitializedAppPoolState ) 
    {
        // 
        // For now we simply return ok if it is not a
        // disabled application.  I am adding the assert
        // because I believe the internal path
        // never should get here.  
        //
        DBG_ASSERT ( m_State == DisabledAppPoolState ||
                     m_State == UninitializedAppPoolState );

        return;
    }
    
    ResetStaggering();

    //
    // Reset the RFP properties so we can determine if 
    // we need to go into RFP again.
    //
    m_RecentWorkerProcessFailures = 0;
    m_RecentFailuresWindowBeganTickCount = 0;

    // if this is a direct command, then we need to reset
    // the job object stuff.  The only way a pool get's 
    // enabled is at initialization time ( and the job object
    // will not have fired ), when it's a direct command, or if
    // the job object timer has fired ( and in this case we don't
    // have to reenable the job object because it will have been
    // done for us.
    if ( m_pJobObject && DirectCommand )
    {
        m_pJobObject->UpdateJobObjectMonitoring( FALSE );
    }

    Win32Error = HttpSetAppPoolInformation(
                        m_AppPoolHandle,                // app pool handle
                        HttpAppPoolStateInformation,    // information class
                        reinterpret_cast <VOID *> ( &NewHttpAppPoolState ),  // data
                        sizeof( HTTP_APP_POOL_ENABLED_STATE )    // data length
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );

        const WCHAR * EventLogStrings[1];
        EventLogStrings[0] = GetAppPoolId();

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_APP_POOL_ENABLE_FAILED,   // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                hr                                      // error code
                );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Enabling app pool state in http failed\n"
            ));

        return;

    }

    //
    // Http is queueing request so we are officially 
    // running now.
    //

    ChangeState ( RunningAppPoolState, S_OK );

    //
    // See if we should wait asynchronously for a demand start notification
    // from UL for this app pool.  If we are in backward compatibility mode, 
    // then we are not going to do the WaitForDemandStartIfNeeded here, we will
    // request a DemandStartWorkItem once we have finished configuring the system.
    //
    // Note that EnableAppPool will only be called in BC mode when the app
    // pool is first created.  We don't support the ServerCommand to start
    // and stop the app pool.
    //

    WaitForDemandStartIfNeeded();

}   // APP_POOL::EnableAppPool


/***************************************************************************++

Routine Description:

    Whenever we hit zero WP's or are going to restart all WP's at the same
    time we need to turn back on staggering.  This call will handle doing this.

Arguments:

    None

Return Value:

    Void

--***************************************************************************/
VOID
APP_POOL::ResetStaggering(
    )
{
    DBG_ASSERT ( m_pConfig );

    //
    // Update the MaxProcesses we can use.
    //
    // A side affect of how we are doing this, is if the app pool is
    // restarted due to Job Objects and the max process was changed
    // before the job object took affect, the restart will cause the
    // new value to be used.
    //
    m_MaxProcessesToLaunch = m_pConfig->GetMaxSteadyStateProcessCount();

    // Reset the m_NumWPStartedOnWayToMaxProcess flag, so even if we are
    // held up by a few random worker processes still shutting down, we 
    // will still stager as we create the first new set.
    m_NumWPStartedOnWayToMaxProcess = 0;
}

/***************************************************************************++

Routine Description:

    Attempt to apply a state change command to this object. This could
    fail if the state change is invalid.  In other words, if the state is
    not an acceptable state to be changing to.

Arguments:

    Command - The requested state change command.

    DirectCommand - Whether or not the user is directly controlling this
    app pool or not.  Basically if it is direct then the state will be written
    back to the metabase.  If it is not the state will not be written back.

Return Value:

    VOID

--***************************************************************************/

VOID
APP_POOL::ProcessStateChangeCommand(
    IN DWORD Command,
    IN BOOL DirectCommand,
    IN HTTP_APP_POOL_ENABLED_STATE DisabledReason
    )
{

    DWORD ServiceState = 0;
    APP_POOL_STATE AppPoolState = m_State;

    //
    // We only support these two commands on an app pool.
    // This assert may be overactive if config is not safe
    // guarding against the other values.
    //
    DBG_ASSERT ( Command == MD_APPPOOL_COMMAND_START  || 
                 Command == MD_APPPOOL_COMMAND_STOP );

    if ( Command != MD_APPPOOL_COMMAND_START  &&
         Command != MD_APPPOOL_COMMAND_STOP )
    {
        return;
    }

    //
    // Determine the current state of affairs.
    //

    ServiceState = GetWebAdminService()->GetServiceState();


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Received state change command for app pool: %S; command: %lu, app pool state: %lu, service state: %lu\n",
            m_AppPoolId.QueryStr(),
            Command,
            AppPoolState,
            ServiceState
            ));
    }


    //
    // Update the autostart setting if appropriate.
    //

    if ( DirectCommand )
    {

        //
        // Set autostart to TRUE for a direct start command; set it
        // to FALSE for a direct stop command.
        //

        m_pConfig->SetAutoStart(( Command == MD_APPPOOL_COMMAND_START ) ? TRUE : FALSE );

        GetWebAdminService()->GetConfigAndControlManager()->GetConfigManager()->
            SetAppPoolAutostart(
                m_AppPoolId.QueryStr(),
                m_pConfig->IsAutoStartEnabled()
                );

    }


    //
    // Figure out which command has been issued, and see if it should
    // be acted on or ignored, given the current state.
    //
    // There is a general rule of thumb that a child entity (such as
    // an virtual site) cannot be made more "active" than it's parent
    // entity currently is (the service). 
    //

    switch ( Command )
    {

    case MD_APPPOOL_COMMAND_START:

        //
        // If the site is stopped, then start it. If it's in any other state,
        // this is an invalid state transition.
        //
        // Note that the service must be in the started or starting state in 
        // order to start a site.
        //

        if ( ( ( AppPoolState == UninitializedAppPoolState ) ||
               ( AppPoolState == DisabledAppPoolState ) ) &&
             ( ( ServiceState == SERVICE_RUNNING ) ||
               ( ServiceState == SERVICE_START_PENDING ) ) )
        {

            //
            // If this is a flowed (not direct) command, and autostart is false, 
            // then ignore this command. In other words, the user has indicated
            // that this pool should not be started at service startup, etc.
            //

            // 
            // Issue:  Since we set the AutoStart above in the Direct case, this
            //         decision does not have to be so complicated.
            //

            if ( ( ! DirectCommand ) && ( ! m_pConfig->IsAutoStartEnabled() ) )
            {

                IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
                {
                    DBGPRINTF((
                        DBG_CONTEXT, 
                        "Ignoring flowed site start command because autostart is false for app pool: %S\n",
                        GetAppPoolId()
                        ));
                }

            }
            else
            {

                EnableAppPool( DirectCommand );

            }

        }
        else
        {
            // If we are all ready running and we are being asked
            // to run, then the metabase may have bad information in it
            // so we should fix it.
            if ( DirectCommand && ( AppPoolState == RunningAppPoolState ) )
            {
                RecordState();
            }

            // Otherwise just ignore the command.
        }

        break;

    case MD_APPPOOL_COMMAND_STOP:

        //
        // If the site is started, then stop it. If it's in 
        // any other state, this is an invalid state transition.
        //
        // Note that since we are making the app pool less active,
        // we can ignore the state of the service.  
        //

        if ( ( AppPoolState == RunningAppPoolState ) )
        {

            DisableAppPool( DisabledReason );

        } 
        else
        {
            // If we are not running and we are being asked
            // to not run, then the metabase may have bad information in it
            // so we should fix it.
            if ( DirectCommand )
            {
                RecordState();
            }

            // Otherwise just ignore the command.
        }

        break;


    default:

        //
        // Invalid command!
        //

        DBG_ASSERT ( FALSE ) ;

        break;

    }

}   // APP_POOL::ProcessStateChangeCommand

/***************************************************************************++

Routine Description:

    Update the state of this object.

Arguments:

    NewState - The state we are attempting to change the app pool to.

    WriteToMetabase - Flag to notify if we should actually update the metabase 
                      with the new state or not.

Return Value:

    VOID

--***************************************************************************/

VOID
APP_POOL::ChangeState(
    IN APP_POOL_STATE NewState,
    IN HRESULT Error
    )
{

    m_State = NewState;
    m_hrLastReported = Error;

    RecordState();

}   // APP_POOL::ChangeState

/***************************************************************************++

Routine Description:

    Write the current state of this object to the metabase

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/
VOID
APP_POOL::RecordState(
    )
{

    DWORD ConfigState = 0;

    if ( m_State == RunningAppPoolState ) 
    {
        ConfigState = MD_APPPOOL_STATE_STARTED;
    }
    else
    {
        ConfigState = MD_APPPOOL_STATE_STOPPED;
    }

    GetWebAdminService()->GetConfigAndControlManager()->GetConfigManager()->
        SetAppPoolStateAndError(
            m_AppPoolId.QueryStr(),
            ConfigState,
            ( FAILED( m_hrLastReported ) ? WIN32_FROM_HRESULT( m_hrLastReported ) : NO_ERROR )
            );

}   // APP_POOL::RecordState

/***************************************************************************++

Routine Description:

    Recycles all worker processes in an app pool.

Arguments:

    MessageId if we need to event log.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
APP_POOL::RecycleWorkerProcesses(
    DWORD MessageId
    )
{

    DBG_ASSERT( GetWebAdminService()->IsBackwardCompatibilityEnabled() == FALSE );

    //
    // Only recycle enabled app pools.
    //
    if ( m_State != RunningAppPoolState ) 
    {
        return HRESULT_FROM_WIN32( ERROR_OBJECT_NOT_FOUND );
    }

    ReplaceAllWorkerProcesses( MessageId );

    return S_OK;

}   // APP_POOL::RecycleWorkerProcesses

/***************************************************************************++

Routine Description:

    There has a been a config change that requires rotating the worker 
    processes for this app pool, in order to fully effect the change. If
    it is allowed, rotate them all. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

VOID
APP_POOL::HandleConfigChangeAffectingWorkerProcesses(
    )
{
    
    if ( m_pConfig->IsDisallowRotationOnConfigChangesEnabled() )
    {
        //
        // We are not allowed to rotate on config changes. 
        //

        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "NOT rotating worker processes of app pool (ptr: %p; id: %S) on config change, as this behavior has been configured off\n",
                this,
                GetAppPoolId()
                ));
        }

        return;
    }


    //
    // Rotate all worker processes to ensure that the config changes take 
    // effect. 
    //

    ReplaceAllWorkerProcesses( WAS_EVENT_RECYCLE_POOL_CONFIG_CHANGE );


}   // APP_POOL::HandleConfigChangeAffectingWorkerProcesses

/***************************************************************************++

Routine Description:

    Shut down all worker processes serving this app pool.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
APP_POOL::ShutdownAllWorkerProcesses(
    )
{

    PLIST_ENTRY pListEntry = NULL;
    PLIST_ENTRY pNextListEntry = NULL;
    WORKER_PROCESS * pWorkerProcess = NULL;


    pListEntry = m_WorkerProcessListHead.Flink;


    while ( pListEntry != &m_WorkerProcessListHead )
    {

        DBG_ASSERT( pListEntry != NULL );

        pNextListEntry = pListEntry->Flink;

        pWorkerProcess = WORKER_PROCESS::WorkerProcessFromAppPoolListEntry( pListEntry );


        //
        // Shutdown the worker process. Note that the worker process will
        // eventually clean itself up and remove itself from this list;
        // this could happen later, but it also could happen immediately!
        // This is the reason we captured the next list entry pointer 
        // above, instead of trying to access the memory after the object
        // may have gone away.
        //

        pWorkerProcess->Shutdown( TRUE );

        pListEntry = pNextListEntry;
        
    }

}   // APP_POOL::ShutdownAllWorkerProcesses



/***************************************************************************++

Routine Description:

    Rotate all worker processes serving this app pool.

Arguments:

    MessageId if we need to event log.

Return Value:

    VOID

--***************************************************************************/

VOID
APP_POOL::ReplaceAllWorkerProcesses(
    DWORD MessageId
    )
{

    PLIST_ENTRY pListEntry = NULL;
    PLIST_ENTRY pNextListEntry = NULL;
    WORKER_PROCESS * pWorkerProcess = NULL;
    BOOL fFoundAWorkerProcess = FALSE;

    // 
    // We are going to restart all worker processes so reset the 
    // staggering algorithm properties, including picking up changes
    // to MaxProcesses.
    ResetStaggering();

    pListEntry = m_WorkerProcessListHead.Flink;

    while ( pListEntry != &m_WorkerProcessListHead )
    {

        DBG_ASSERT( pListEntry != NULL );

        pNextListEntry = pListEntry->Flink;

        pWorkerProcess = WORKER_PROCESS::WorkerProcessFromAppPoolListEntry( pListEntry );

        fFoundAWorkerProcess = TRUE;

        //
        // Tell the worker process to get itself replaced.
        //

        pWorkerProcess->InitiateReplacement();

        pListEntry = pNextListEntry;
        
    }

    // If there was an active worker process then see if we should
    // print out a message for recycling the app pool.
    if ( fFoundAWorkerProcess )
    {
        DWORD BitToCheck = 0;

        // Figure out if the message is turned on.
        switch ( MessageId )
        {
            // Recovery is key'd off of config change as well
            case WAS_EVENT_RECYCLE_POOL_RECOVERY:
                BitToCheck = MD_APP_POOL_RECYCLE_CONFIG_CHANGE;
            break;

            case WAS_EVENT_RECYCLE_POOL_CONFIG_CHANGE:
                BitToCheck = MD_APP_POOL_RECYCLE_CONFIG_CHANGE;
            break;

            case WAS_EVENT_RECYCLE_POOL_ADMIN_REQUESTED:
                BitToCheck = MD_APP_POOL_RECYCLE_ON_DEMAND;
            break;

            default:
                // in this case the BitToCheck will be zero
                // and we just won't print a message, no real
                // bad path for retail.
                DBG_ASSERT( FALSE );
        
            break;
        }

        if ( ( GetRecycleLoggingFlags() & BitToCheck ) != 0 )
        {

            const WCHAR * EventLogStrings[1];
            EventLogStrings[0] = GetAppPoolId();


            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    MessageId,                              // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    S_OK                                    // error code
                    );
        }
    }

}   // APP_POOL::ReplaceAllWorkerProcesses


/***************************************************************************++

Routine Description:

    See if shutdown is underway. If it is, see if shutdown has finished. If
    it has, clean up this instance. 

    Note that this function may cause the instance to delete itself; 
    instance state should not be accessed when unwinding from this call. 

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
APP_POOL::CheckIfShutdownUnderwayAndNowCompleted(
    )
{



    //
    // Are we shutting down?
    //

    if ( m_State == ShutdownPendingAppPoolState )
    {

        //
        // If so, have all the worker processes gone away, meaning that 
        // we are done?
        //

        if ( m_WorkerProcessCount == 0 )
        {

            //
            // Clean up this instance.
            //

            Terminate( );

        }

    }


}   // APP_POOL::CheckIfShutdownUnderwayAndNowCompleted


/***************************************************************************++

Routine Description:

    Perform the configured action (if any) on the disabled app pool.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
APP_POOL::RunDisableAction(
    )
{
    HRESULT hr = S_OK;

    // string will be "1=<LPCWSTR>\0"  
    BUFFER Environment;

    DBG_ASSERT ( !m_AppPoolId.IsEmpty() );

    //
    // 4 = the amount of space needed for the 1= and the two null terminators.
    //
    if ( ! Environment.Resize( (DWORD) ( 4 + m_AppPoolId.QueryCCH() ) * sizeof WCHAR ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Failed to resize the buffer to the correct size\n"
            ));

        goto exit;
    }

    //
    // Set up an environment block with just the one expansion we want, namely
    // that %1% expands to the app pool id.
    //

    // 
    // Buffer above is sized to be able to take the app pool id,
    // plus 4 characters, 2 for the '1=' and 2 for the final NULLs.
    //
    _snwprintf( 
        ( LPWSTR ) Environment.QueryPtr(), 
        Environment.QuerySize() / sizeof ( WCHAR ), 
        L"1=%ws%c", 
        m_AppPoolId.QueryStr(), 
        L'\0'
        );

    RunAction( m_pConfig->GetDisableActionExecutable(),
                    m_pConfig->GetDisableActionParameters(),
                    Environment.QueryPtr(),
                    m_AppPoolId.QueryStr(),
                    WAS_EVENT_AUTO_SHUTDOWN_ACTION_FAILED_1 );

exit:

    if ( FAILED ( hr ) )
    {
        const WCHAR * EventLogStrings[1];
        EventLogStrings[0] = GetAppPoolId();

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_AUTO_SHUTDOWN_ACTION_FAILED_2,   // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                hr        // error code
                );
    }

}   // APP_POOL::RunDisableAction

/***************************************************************************++

Routine Description:

    Returns the recycle logging setting

Arguments:

    None.

Return Value:

    DWORD

Note:

    // For most properties the worker process uses we
    // read their configuration from the config passed to
    // the worker process. But for this one I want it to
    // be able to change on the fly, since it is used at
    // both the app pool and worker process level, so I 
    // am exposing it on the app pool directly.


--***************************************************************************/

DWORD
APP_POOL::GetRecycleLoggingFlags(
    )
{
    if ( m_pConfig )
    {
        return m_pConfig->GetRecycleLoggingFlags();
    }
    else
    {
        return 0;
    }
}


/***************************************************************************++

Routine Description:

    Return the count of bytes in MULTISZ including terminating zeroes. 

Arguments:

    pString - MULTISZ string

Return Value:

    DWORD - The number of bytes
    
--***************************************************************************/

DWORD 
GetMultiszByteLength(
    LPWSTR pString
    )
{
    if( pString == 0 )
    {
        return 0;
    }
    DWORD cbString = 0;
    while( * pString != 0 || 
           *(pString + 1) != 0 )
    {
        pString++; 
        cbString++;
    }
    cbString = (cbString + 2) * sizeof (WCHAR);
    return cbString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\apppoolstore.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    apppoolstore.cxx

Abstract:

    Reads app pool configuration

Author:

    Emily Kruglick (emilyk)          27-May-2001

Revision History:

--*/

#include "precomp.h"

HRESULT
APP_POOL_DATA_OBJECT::Create(
    LPCWSTR pAppPoolId
)
/*++

Routine Description:

    Initialize an app pool data object to suitable defaults

Arguments:

    None

Return Value:

    HRESULT

--*/
{

    HRESULT             hr = S_OK;

    DBG_ASSERT ( pAppPoolId != NULL );
    if ( pAppPoolId == NULL )
    {
        return E_INVALIDARG;
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "PoolId being created is : '%S' \n",
                   pAppPoolId ));
    }

    // first initialize the app pool 
    hr = _poolKey.SetAppPoolId( pAppPoolId );
    if ( FAILED ( hr ) )
    {
        goto exit;
    }
    
    //
    // These defaults need to remain in sync with 
    // the defaults in the mbschema file.
    //
    _dwIdleTimeout = 10;                    // minutes    
    _dwPeriodicRestartTime = MBCONST_PERIODIC_RESTART_TIME_DEFAULT;    
    _dwPeriodicRestartRequests = 10000;        
    _dwPeriodicRestartMemory = MBCONST_PERIODIC_RESTART_VIRTUAL_MEMORY_DEFAULT;           // kilobytes    
    _dwPeriodicRestartMemoryPrivate = MBCONST_PERIODIC_RESTART_PRIVATE_MEMORY_DEFAULT;    // kilobytes    

    // like stru's you don't initialize this.
    // _mszPeriodicRestartSchedule = NULL;         // no range

    _dwMaxProcesses = 1;                        // range = 0 to 4294967

    _fPingingEnabled = TRUE;
    _dwPingInterval = MBCONST_PING_INTERVAL_DEFAULT;    // seconds   
    _dwPingResponseTime = 60; // seconds    // range >= 1 && <= 4294967

    _fRapidFailProtection = TRUE;
    _dwRapidFailProtectionInterval = MBCONST_RAPID_FAIL_INTERVAL_DEFAULT;    // range >= 1 
    _dwRapidFailProtectionMaxCrashes = MBCONST_RAPID_FAIL_CRASHES_DEFAULT;   // range >= 1 

    _fSMPAffinitized = FALSE;
    _dwSMPProcessorAffinityMask = 4294967295; 

    _fOrphanWorkerProcess = FALSE;
    // no default for _strOrphanActionExecutable because it all ready is NULL
    // no default for _strOrphanActionParameters because it all ready is NULL

    // no default for _strDisableActionExecutable because it all ready is NULL
    // no default for _strDisableActionParameters because it all ready is NULL

    _dwLoadBalancerType = 2;  // Allow 503's to be returned by default.

    _dwStartupTimeLimit = MBCONST_WP_STARTUP_TIMELIMIT_DEFAULT;  // seconds   // range >= 1 && <= 4294967
    _dwShutdownTimeLimit = 60; // seconds   // range >= 1 && <= 4294967

    _fDisallowOverlappingRotation = FALSE;
    _dwDisallowRotationOnConfigChange = FALSE;

    _dwAppPoolQueueLength = MBCONST_APP_POOL_QUEUE_LENGTH_DEFAULT;  

    // No defaults for _strWAMUserName & _strWAMUserPass
    // since they are all ready null.
    _dwAppPoolIdentityType = 0;     // no range

    _dwCPUAction = 0;        // range <= 3
    _dwCPULimit = 0;         // range <= 100000
    _dwCPUResetInterval = 5; // range <= 1440

    // note app pool command does not have a default
    // setting it to zero just to make sure there are
    // problems if it is used and not set by metabase
    _dwAppPoolCommand = 0;  // range 1 - 2.

    _fAppPoolAutoStart = TRUE;

    _dwRecycleLoggingFlags = 0x00000008;  // turns on only memory based recycling.

exit:

    return hr;
}

//virtual
DATA_OBJECT *
APP_POOL_DATA_OBJECT::Clone(
    VOID
)
/*++

Routine Description:

    Clone AppPool object

Arguments:

    None

Return Value:

    DATA_OBJECT *

--*/
{
    APP_POOL_DATA_OBJECT *      pClone = NULL;
    HRESULT                     hr = S_OK;
    
    pClone = new APP_POOL_DATA_OBJECT;
    if ( pClone == NULL )
    {
        return NULL;
    }
    
    // copy over property values
    pClone->_dwPeriodicRestartTime = _dwPeriodicRestartTime;
    pClone->_dwPeriodicRestartRequests = _dwPeriodicRestartRequests;
    pClone->_dwPeriodicRestartMemory = _dwPeriodicRestartMemory;
    pClone->_dwPeriodicRestartMemoryPrivate = _dwPeriodicRestartMemoryPrivate;
    pClone->_dwMaxProcesses = _dwMaxProcesses;
    pClone->_fPingingEnabled = _fPingingEnabled;
    pClone->_dwIdleTimeout = _dwIdleTimeout;
    pClone->_fRapidFailProtection = _fRapidFailProtection;
    pClone->_fSMPAffinitized = _fSMPAffinitized;
    pClone->_dwSMPProcessorAffinityMask = _dwSMPProcessorAffinityMask;
    pClone->_fOrphanWorkerProcess = _fOrphanWorkerProcess;
    pClone->_dwStartupTimeLimit = _dwStartupTimeLimit;
    pClone->_dwShutdownTimeLimit = _dwShutdownTimeLimit;
    pClone->_dwPingInterval = _dwPingInterval;
    pClone->_dwPingResponseTime = _dwPingResponseTime;
    pClone->_fDisallowOverlappingRotation = _fDisallowOverlappingRotation;
    pClone->_dwAppPoolQueueLength = _dwAppPoolQueueLength;
    pClone->_dwDisallowRotationOnConfigChange = _dwDisallowRotationOnConfigChange;
    pClone->_dwAppPoolIdentityType = _dwAppPoolIdentityType;
    pClone->_dwCPUAction = _dwCPUAction;  
    pClone->_dwCPULimit = _dwCPULimit;  
    pClone->_dwCPUResetInterval = _dwCPUResetInterval;
    pClone->_dwAppPoolCommand = _dwAppPoolCommand;
    pClone->_fAppPoolAutoStart = _fAppPoolAutoStart;
    pClone->_dwRapidFailProtectionInterval = _dwRapidFailProtectionInterval;  
    pClone->_dwRapidFailProtectionMaxCrashes = _dwRapidFailProtectionMaxCrashes;
    pClone->_dwLoadBalancerType = _dwLoadBalancerType;
    pClone->_dwRecycleLoggingFlags = _dwRecycleLoggingFlags;

    // copy over change flags
    pClone->_fPeriodicRestartTimeChanged = _fPeriodicRestartTimeChanged;
    pClone->_fPeriodicRestartRequestsChanged = _fPeriodicRestartRequestsChanged;
    pClone->_fPeriodicRestartMemoryChanged = _fPeriodicRestartMemoryChanged;
    pClone->_fPeriodicRestartMemoryPrivateChanged = _fPeriodicRestartMemoryPrivateChanged;
    pClone->_fPeriodicRestartScheduleChanged = _fPeriodicRestartScheduleChanged;
    pClone->_fMaxProcessesChanged = _fMaxProcessesChanged;
    pClone->_fPingingEnabledChanged = _fPingingEnabledChanged;
    pClone->_fIdleTimeoutChanged = _fIdleTimeoutChanged;
    pClone->_fRapidFailProtectionChanged = _fRapidFailProtectionChanged;
    pClone->_fSMPAffinitizedChanged = _fSMPAffinitizedChanged;
    pClone->_fSMPProcessorAffinityMaskChanged = _fSMPProcessorAffinityMaskChanged;
    pClone->_fOrphanWorkerProcessChanged = _fOrphanWorkerProcessChanged;
    pClone->_fStartupTimeLimitChanged = _fStartupTimeLimitChanged;
    pClone->_fShutdownTimeLimitChanged = _fShutdownTimeLimitChanged;
    pClone->_fPingIntervalChanged = _fPingIntervalChanged;
    pClone->_fPingResponseTimeChanged = _fPingResponseTimeChanged;
    pClone->_fDisallowOverlappingRotationChanged = _fDisallowOverlappingRotationChanged;
    pClone->_fOrphanActionExecutableChanged = _fOrphanActionExecutableChanged;
    pClone->_fOrphanActionParametersChanged = _fOrphanActionParametersChanged;
    pClone->_fAppPoolQueueLengthChanged = _fAppPoolQueueLengthChanged;
    pClone->_fDisallowRotationOnConfigChangeChanged = _fDisallowRotationOnConfigChangeChanged;
    pClone->_fWAMUserNameChanged = _fWAMUserNameChanged;  
    pClone->_fWAMUserPassChanged = _fWAMUserPassChanged;  
    pClone->_fAppPoolIdentityTypeChanged = _fAppPoolIdentityTypeChanged;
    pClone->_fCPUActionChanged = _fCPUActionChanged;  
    pClone->_fCPULimitChanged = _fCPULimitChanged;  
    pClone->_fCPUResetIntervalChanged  = _fCPUResetIntervalChanged;
    pClone->_fAppPoolCommandChanged  = _fAppPoolCommandChanged;
    pClone->_fAppPoolAutoStartChanged = _fAppPoolAutoStartChanged;
    pClone->_fRapidFailProtectionIntervalChanged = _fRapidFailProtectionIntervalChanged;  
    pClone->_fRapidFailProtectionMaxCrashesChanged = _fRapidFailProtectionMaxCrashesChanged;
    pClone->_fDisableActionExecutableChanged = _fDisableActionExecutableChanged;
    pClone->_fDisableActionParametersChanged = _fDisableActionParametersChanged;
    pClone->_fLoadBalancerTypeChanged = _fLoadBalancerTypeChanged;
    pClone->_fRecycleLoggingFlagsChanged = _fRecycleLoggingFlagsChanged;

    if ( !_mszPeriodicRestartSchedule.Clone( &pClone->_mszPeriodicRestartSchedule ) )
    {
        delete pClone;
        return NULL;
    }
    
    hr = pClone->_strOrphanActionExecutable.Copy( _strOrphanActionExecutable );
    if ( FAILED( hr ) )
    {
        delete pClone;
        return NULL;
    }
    
    hr = pClone->_strOrphanActionParameters.Copy( _strOrphanActionParameters );
    if ( FAILED( hr ) )
    {
        delete pClone;
        return NULL;
    }

    hr = pClone->_strDisableActionExecutable.Copy( _strDisableActionExecutable );
    if ( FAILED( hr ) )
    {
        delete pClone;
        return NULL;
    }
    
    hr = pClone->_strDisableActionParameters.Copy( _strDisableActionParameters );
    if ( FAILED( hr ) )
    {
        delete pClone;
        return NULL;
    }
    
    hr = pClone->_strWAMUserName.Copy( _strWAMUserName );
    if ( FAILED( hr ) )
    {
        delete pClone;
        return NULL;
    }
    
    hr = pClone->_strWAMUserPass.Copy( _strWAMUserPass );
    if ( FAILED( hr ) )
    {   
        delete pClone;
        return NULL;
    }

    // need to copy the hash of the password as well.
    memcpy ( pClone->_bWAMUserPassHash, _bWAMUserPassHash, MD5_HASH_SIZE );
    
    hr = pClone->_poolKey.SetAppPoolId( _poolKey.QueryAppPoolId() );
    if ( FAILED( hr ) )
    {
        delete pClone;
        return NULL;
    }
    
    CloneBasics ( pClone );

    return pClone;
}

//virtual
HRESULT
APP_POOL_DATA_OBJECT::SetFromMetabaseData(
    METADATA_GETALL_RECORD *       pProperties,
    DWORD                          cProperties,
    BYTE *                         pbBase
)
/*++

Routine Description:

    Setup a app pool data object from metabase properties

Arguments:

    pProperties - Array of metadata properties
    cProperties - Count of metadata properties
    pbBase - Base of offsets in metadata properties

Return Value:

    HRESULT

--*/
{
    DWORD                   dwCounter;
    PVOID                   pvDataPointer    = NULL;
    METADATA_GETALL_RECORD* pCurrentProperty = NULL;
    HRESULT                 hr               = S_OK;
    DWORD                   cchMultisz        = 0;
    DWORD                   dwNumStrings     = 0;
    
    if ( pProperties == NULL || pbBase == NULL )
    {

        DBG_ASSERT ( pProperties != NULL &&
                     pbBase != NULL );

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // walk through all the properties for the app pool
    //
    for ( dwCounter = 0;
          dwCounter < cProperties;
          dwCounter++ )
    {
        pCurrentProperty = &(pProperties[ dwCounter ]);
   
        pvDataPointer = (PVOID) ( pbBase + pCurrentProperty->dwMDDataOffset );

        switch ( pCurrentProperty->dwMDIdentifier )
        {

            case MD_APPPOOL_PERIODIC_RESTART_TIME:
                DBG_ASSERT ( pvDataPointer );
                _dwPeriodicRestartTime = *((DWORD *) pvDataPointer );
            break;

            case MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT:
                DBG_ASSERT ( pvDataPointer );
                _dwPeriodicRestartRequests = *((DWORD *) pvDataPointer );
            break;

            case MD_APPPOOL_PERIODIC_RESTART_MEMORY:
                DBG_ASSERT ( pvDataPointer );
                _dwPeriodicRestartMemory = *((DWORD *) pvDataPointer );
            break;

            case MD_APPPOOL_PERIODIC_RESTART_PRIVATE_MEMORY:
                DBG_ASSERT ( pvDataPointer );
                _dwPeriodicRestartMemoryPrivate = *((DWORD *) pvDataPointer );
            break;

            case MD_APPPOOL_PERIODIC_RESTART_SCHEDULE:

                cchMultisz = MULTISZ::CalcLength( (WCHAR*) pvDataPointer, &dwNumStrings );

                if ( ! _mszPeriodicRestartSchedule.Copy( (WCHAR*) pvDataPointer, cchMultisz * sizeof( WCHAR )) )
                {
                    hr = GetLastError();
                    goto exit;
                }

                IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
                {
                    DBGPRINTF((DBG_CONTEXT,
                               "Orig Restart Schedule = '%S'\n"
                               "Restart Schedule = : '%S' \n",
                               ( WCHAR* ) pvDataPointer,
                               _mszPeriodicRestartSchedule.QueryStr()  ));
                }

            break;

            case MD_APPPOOL_MAX_PROCESS_COUNT:
                DBG_ASSERT ( pvDataPointer );
                _dwMaxProcesses = *((DWORD *) pvDataPointer );
            break;

            case MD_APPPOOL_PINGING_ENABLED:
                DBG_ASSERT ( pvDataPointer );
                _fPingingEnabled =!!*((DWORD *) pvDataPointer );
            break;

            case MD_APPPOOL_IDLE_TIMEOUT:
                DBG_ASSERT ( pvDataPointer );
                _dwIdleTimeout = *((DWORD *) pvDataPointer );
            break;

            case MD_APPPOOL_RAPID_FAIL_PROTECTION_ENABLED:
                DBG_ASSERT ( pvDataPointer );
                _fRapidFailProtection =!!*((DWORD *) pvDataPointer );
            break;

            case MD_APPPOOL_SMP_AFFINITIZED:
                DBG_ASSERT ( pvDataPointer );
                _fSMPAffinitized =!!*((DWORD *) pvDataPointer );
            break;

            case MD_APPPOOL_SMP_AFFINITIZED_PROCESSOR_MASK:
                DBG_ASSERT ( pvDataPointer );
                _dwSMPProcessorAffinityMask = *((DWORD *) pvDataPointer );
            break;

            case MD_APPPOOL_ORPHAN_PROCESSES_FOR_DEBUGGING:
                DBG_ASSERT ( pvDataPointer );
                _fOrphanWorkerProcess =!!*((DWORD *) pvDataPointer );
            break;

            case MD_APPPOOL_STARTUP_TIMELIMIT:
                DBG_ASSERT ( pvDataPointer );
                _dwStartupTimeLimit = *((DWORD *) pvDataPointer );
            break;

            case MD_APPPOOL_SHUTDOWN_TIMELIMIT:
                DBG_ASSERT ( pvDataPointer );
                _dwShutdownTimeLimit = *((DWORD *) pvDataPointer );
            break;

            case MD_APPPOOL_PING_INTERVAL:
                DBG_ASSERT ( pvDataPointer );
                _dwPingInterval = *((DWORD *) pvDataPointer );
            break;

            case MD_APPPOOL_PING_RESPONSE_TIMELIMIT:
                DBG_ASSERT ( pvDataPointer );
                _dwPingResponseTime = *((DWORD *) pvDataPointer );
            break;

            case MD_APPPOOL_DISALLOW_OVERLAPPING_ROTATION:
                DBG_ASSERT ( pvDataPointer );
                _fDisallowOverlappingRotation =!!*((DWORD *) pvDataPointer );
            break;

            case MD_APPPOOL_ORPHAN_ACTION_EXE:

                hr = _strOrphanActionExecutable.Copy( (WCHAR*) pvDataPointer );
                if ( FAILED( hr ) )
                {
                    goto exit;
                }

            break;

            case MD_APPPOOL_ORPHAN_ACTION_PARAMS:

                hr = _strOrphanActionParameters.Copy( (WCHAR*) pvDataPointer );
                if ( FAILED( hr ) )
                {
                    goto exit;
                }

            break;

            case MD_APPPOOL_UL_APPPOOL_QUEUE_LENGTH:
                DBG_ASSERT ( pvDataPointer );
                _dwAppPoolQueueLength = *((DWORD *) pvDataPointer );
            break;

            case MD_APPPOOL_DISALLOW_ROTATION_ON_CONFIG_CHANGE:
                DBG_ASSERT ( pvDataPointer );
                _dwDisallowRotationOnConfigChange =!!*((DWORD *) pvDataPointer );
            break;

            case MD_APPPOOL_IDENTITY_TYPE:
                DBG_ASSERT ( pvDataPointer );
                _dwAppPoolIdentityType = *((DWORD *) pvDataPointer );
            break;

            case MD_CPU_ACTION:
                DBG_ASSERT ( pvDataPointer );
                _dwCPUAction = *((DWORD *) pvDataPointer );
            break;

            case MD_CPU_LIMIT:
                DBG_ASSERT ( pvDataPointer );
                _dwCPULimit = *((DWORD *) pvDataPointer );
            break;

            case MD_CPU_RESET_INTERVAL:
                DBG_ASSERT ( pvDataPointer );
                _dwCPUResetInterval = *((DWORD *) pvDataPointer );
            break;

            case MD_APPPOOL_COMMAND:
                DBG_ASSERT ( pvDataPointer );
                _dwAppPoolCommand = *((DWORD *) pvDataPointer );
            break;

            case MD_APPPOOL_AUTO_START:
                DBG_ASSERT ( pvDataPointer );
                _fAppPoolAutoStart =!!*((DWORD *) pvDataPointer );
            break;

            case MD_RAPID_FAIL_PROTECTION_INTERVAL:
                DBG_ASSERT ( pvDataPointer );
                _dwRapidFailProtectionInterval = *((DWORD *) pvDataPointer );
            break;

            case MD_RAPID_FAIL_PROTECTION_MAX_CRASHES:
                DBG_ASSERT ( pvDataPointer );
                _dwRapidFailProtectionMaxCrashes = *((DWORD *) pvDataPointer );
            break;

            case MD_WAM_USER_NAME:

                hr = _strWAMUserName.Copy( (WCHAR*) pvDataPointer );
                if ( FAILED( hr ) )
                {
                    goto exit;
                }

            break;

            case MD_WAM_PWD:

                hr = _strWAMUserPass.Copy( (WCHAR*) pvDataPointer );
                if ( FAILED( hr ) )
                {
                    goto exit;
                }

                // make sure the buffer is empty just in case
                // the hash doesn't fill it all.
                SecureZeroMemory ( _bWAMUserPassHash, MD5_HASH_SIZE );

                // figure out the hash of the password.
                hr = GetWebAdminService()->
                     GetConfigAndControlManager()->
                     GetConfigManager()->
                     GetHashData( (BYTE*) _strWAMUserPass.QueryStr(),
                                  _strWAMUserPass.QueryCB(),
                                  _bWAMUserPassHash,
                                  MD5_HASH_SIZE );

                if ( FAILED ( hr ) )
                {
                    goto exit;
                }

/*
This code is unsafe for 64 bit, but is helpful in debugging 
during development so I am leaving it here, commented out.
                DBGPRINTF(( DBG_CONTEXT,
                           "Password = %S, Hash is %x, %x, %x, %x \n",
                           _strWAMUserPass.QueryStr(),
                           (( DWORD* ) _bWAMUserPassHash)[0],
                           (( DWORD* ) _bWAMUserPassHash)[1],
                           (( DWORD* ) _bWAMUserPassHash)[2],
                           (( DWORD* ) _bWAMUserPassHash)[3] ));
*/
            break;

            case MD_APPPOOL_AUTO_SHUTDOWN_EXE:

                hr = _strDisableActionExecutable.Copy( (WCHAR*) pvDataPointer );
                if ( FAILED( hr ) )
                {
                    goto exit;
                }

            break;

            case MD_APPPOOL_AUTO_SHUTDOWN_PARAMS:

                hr = _strDisableActionParameters.Copy( (WCHAR*) pvDataPointer );
                if ( FAILED( hr ) )
                {
                    goto exit;
                }

            break;

            case MD_LOAD_BALANCER_CAPABILITIES:
                DBG_ASSERT ( pvDataPointer );
                _dwLoadBalancerType = *((DWORD *) pvDataPointer );
            break;
            // ok to just ignore properties we don't care about.

            case MD_APP_POOL_LOG_EVENT_ON_RECYCLE:
                DBG_ASSERT ( pvDataPointer );
                _dwRecycleLoggingFlags = *((DWORD *) pvDataPointer);
            break;
                
        }  // end of switch statement
            
    } // end of loop

exit:

    return hr;
    
} // end of APP_POOL_DATA_OBJECT::SetFromMetabaseData

VOID
APP_POOL_DATA_OBJECT::UpdateMetabaseWithErrorState(
    )
/*++

Routine Description:

    Updates the metabase to let folks know
    that this pool is stopped and that the error
    is invalid argument because a property is wrong.

Arguments:

    None.

Return Value:

    None

--*/
{ 
    GetWebAdminService()->
         GetConfigAndControlManager()->
         GetConfigManager()->
         SetAppPoolStateAndError( QueryAppPoolId(),
                                  MD_APPPOOL_STATE_STOPPED, 
                                  ERROR_INVALID_PARAMETER );

    SetIsResponsibleForErrorReporting( FALSE );

}
              
VOID
APP_POOL_DATA_OBJECT::Compare(
    DATA_OBJECT *                  pDataObject
)
/*++

Routine Description:

    Compare a given app pool object with this one.  This routine sets the
    changed flags as appropriate

Arguments:

    pDataObject - New object to compare to

Return Value:

    HRESULT

--*/
{
    APP_POOL_DATA_OBJECT *          pAppPoolObject;
    
    if ( pDataObject == NULL )
    {
        DBG_ASSERT ( pDataObject != NULL );
        return;
    }
    
    pAppPoolObject = (APP_POOL_DATA_OBJECT*) pDataObject;
    DBG_ASSERT( pAppPoolObject->CheckSignature() );

    //
    // Only if the object is all ready in WAS, is it an option
    // to set the flags to not changed.  If WAS does not know about
    // the object, then it may end up being told to create the new
    // object and if that happens we want it to honor all the properties.
    //
    if ( pAppPoolObject->QueryInWas() )
    {

        if ( _fPingingEnabled == pAppPoolObject->_fPingingEnabled )
        {
            _fPingingEnabledChanged = FALSE;
        }

        if ( _fRapidFailProtection == pAppPoolObject->_fRapidFailProtection )
        {
            _fRapidFailProtectionChanged = FALSE;
        }

        if ( _fSMPAffinitized == pAppPoolObject->_fSMPAffinitized )
        {
            _fSMPAffinitizedChanged = FALSE;
        }

        if ( _fOrphanWorkerProcess == pAppPoolObject->_fOrphanWorkerProcess )
        {
            _fOrphanWorkerProcessChanged = FALSE;
        }

        if ( _fDisallowOverlappingRotation == pAppPoolObject->_fDisallowOverlappingRotation )
        {
            _fDisallowOverlappingRotationChanged = FALSE;
        }

        if ( _dwPeriodicRestartTime == pAppPoolObject->_dwPeriodicRestartTime )
        {
            _fPeriodicRestartTimeChanged = FALSE;
        }

        if ( _dwPeriodicRestartRequests == pAppPoolObject->_dwPeriodicRestartRequests )
        {
            _fPeriodicRestartRequestsChanged = FALSE;
        }

        if ( _dwPeriodicRestartMemory == pAppPoolObject->_dwPeriodicRestartMemory )
        {
            _fPeriodicRestartMemoryChanged = FALSE;
        }

        if ( _dwPeriodicRestartMemoryPrivate == pAppPoolObject->_dwPeriodicRestartMemoryPrivate )
        {
            _fPeriodicRestartMemoryPrivateChanged = FALSE;
        }

        if ( _dwMaxProcesses == pAppPoolObject->_dwMaxProcesses )
        {
            _fMaxProcessesChanged = FALSE;
        }

        if ( _dwIdleTimeout == pAppPoolObject->_dwIdleTimeout )
        {
            _fIdleTimeoutChanged = FALSE;
        }

        if ( _dwSMPProcessorAffinityMask == pAppPoolObject->_dwSMPProcessorAffinityMask )
        {
            _fSMPProcessorAffinityMaskChanged = FALSE;
        }

        if ( _dwStartupTimeLimit == pAppPoolObject->_dwStartupTimeLimit )
        {
            _fStartupTimeLimitChanged = FALSE;
        }

        if ( _dwShutdownTimeLimit == pAppPoolObject->_dwShutdownTimeLimit )
        {
            _fShutdownTimeLimitChanged = FALSE;
        }

        if ( _dwPingInterval == pAppPoolObject->_dwPingInterval )
        {
            _fPingIntervalChanged = FALSE;
        }

        if ( _dwPingResponseTime == pAppPoolObject->_dwPingResponseTime )
        {
            _fPingResponseTimeChanged = FALSE;
        }

        if ( _dwRapidFailProtectionMaxCrashes == pAppPoolObject->_dwRapidFailProtectionMaxCrashes )
        {
            _fRapidFailProtectionMaxCrashesChanged = FALSE;
        }

        if ( _dwRapidFailProtectionInterval == pAppPoolObject->_dwRapidFailProtectionInterval )
        {
            _fRapidFailProtectionIntervalChanged = FALSE;
        }

        if ( _fAppPoolAutoStart == pAppPoolObject->_fAppPoolAutoStart )
        {
            _fAppPoolAutoStartChanged = FALSE;
        }

        if ( _dwCPUResetInterval == pAppPoolObject->_dwCPUResetInterval )
        {
            _fCPUResetIntervalChanged = FALSE;
        }
    
        if ( _dwCPULimit == pAppPoolObject->_dwCPULimit )
        {
            _fCPULimitChanged = FALSE;
        }
    
        if ( _dwCPUAction == pAppPoolObject->_dwCPUAction )
        {
            _fCPUActionChanged = FALSE;
        }
    
        if ( _dwAppPoolIdentityType == pAppPoolObject->_dwAppPoolIdentityType )
        {
            _fAppPoolIdentityTypeChanged = FALSE;
        }
    
        if ( _dwDisallowRotationOnConfigChange == pAppPoolObject->_dwDisallowRotationOnConfigChange )
        {
            _fDisallowRotationOnConfigChangeChanged = FALSE;
        }
    
        if ( _dwAppPoolQueueLength == pAppPoolObject->_dwAppPoolQueueLength )
        {
            _fAppPoolQueueLengthChanged = FALSE;
        }
    
        if (_strOrphanActionExecutable.Equals( pAppPoolObject->_strOrphanActionExecutable ) )
        {
            _fOrphanActionExecutableChanged = FALSE;
        }

        if ( _strOrphanActionParameters.Equals( pAppPoolObject->_strOrphanActionParameters ) )
        {
            _fOrphanActionParametersChanged = FALSE;
        }
    
        if ( _strWAMUserName.Equals( pAppPoolObject->_strWAMUserName ) )
        {
            _fWAMUserNameChanged = FALSE;
        }

        // if the hashes are equal than the password did not change.
        if ( memcmp ( _bWAMUserPassHash, pAppPoolObject->_bWAMUserPassHash, MD5_HASH_SIZE ) == 0 )
        {
            _fWAMUserPassChanged = FALSE;
        }
    
        //
        // we could do a case insenstive check in this case, but since it probably
        // won't change just because of case sensitivity and because the consecuences of
        // processing it if it was only a case change are not that great ( the worker 
        // processes will recycle ), we will go ahead and save time by just doing a case
        // sensetive compare.
        //
        if (   ( _mszPeriodicRestartSchedule.QueryCB() == 
                 pAppPoolObject->_mszPeriodicRestartSchedule.QueryCB() ) &&
               ( memcmp( _mszPeriodicRestartSchedule.QueryStr(), 
                         pAppPoolObject->_mszPeriodicRestartSchedule.QueryStr(),
                         _mszPeriodicRestartSchedule.QueryCB() ) == 0 ) )
        {
            _fPeriodicRestartScheduleChanged = FALSE;
        }

        if (_strDisableActionExecutable.Equals( pAppPoolObject->_strDisableActionExecutable ) )
        {
            _fDisableActionExecutableChanged = FALSE;
        }

        if ( _strDisableActionParameters.Equals( pAppPoolObject->_strDisableActionParameters ) )
        {
            _fDisableActionParametersChanged = FALSE;
        }

        if ( _dwLoadBalancerType == pAppPoolObject->_dwLoadBalancerType )
        {
            _fLoadBalancerTypeChanged = FALSE;
        }

        if ( _dwRecycleLoggingFlags == pAppPoolObject->_dwRecycleLoggingFlags )
        {
            _fRecycleLoggingFlagsChanged = FALSE;
        }

    }
}

VOID
APP_POOL_DATA_OBJECT::SelfValidate(
    VOID
)
/*++

Routine Description:

    Check this object's internal validity    

Arguments:

    None

Return Value:

    None

--*/
{
    LPCWSTR pAppPoolId = _poolKey.QueryAppPoolId();
    
    //
    // never bother validating if we are deleting
    // or ignoring this record.
    //
    if ( !QueryWillWasKnowAboutObject() )
    {
        return;
    }


    DBG_ASSERT ( pAppPoolId );

    // Todo:  Should we check that the apppool id has characters in it?

    if ( pAppPoolId[0] == '\0' )
    {
        // Issue:  Is this even possible?

        // Empty string for the app pool name,  
        // invalidate the app pool.
        GetWebAdminService()->
        GetWMSLogger()->
        LogAppPoolIdNull( QueryInWas() );

        SetSelfValid( FALSE );
    }
    else if ( wcslen ( pAppPoolId ) > 256  )
    {
        // App Pool Keys must be less than 256 characters.
        // if it is not then invalidate the app pool.

        GetWebAdminService()->
        GetWMSLogger()->
        LogAppPoolIdTooLong( pAppPoolId,
                             (DWORD) wcslen ( pAppPoolId ),
                             256,
                             QueryInWas() );

        SetSelfValid( FALSE );
    }

}// end of   APP_POOL_DATA_OBJECT::SelfValidate
    
BOOL
APP_POOL_DATA_OBJECT::QueryHasChanged(
    VOID
) const
/*++

Routine Description:
    
    Has anything in this object changed

Arguments:

    None

Return Value:

    TRUE if something has changed (duh!)

--*/
{ 

    if (    _fPeriodicRestartTimeChanged        ||
            _fPeriodicRestartRequestsChanged    ||
            _fPeriodicRestartMemoryChanged      ||
            _fPeriodicRestartMemoryPrivateChanged  ||
            _fPeriodicRestartScheduleChanged    ||
            _fMaxProcessesChanged               ||
            _fPingingEnabledChanged             ||
            _fIdleTimeoutChanged                ||
            _fRapidFailProtectionChanged        ||
            _fSMPAffinitizedChanged             ||
            _fSMPProcessorAffinityMaskChanged   ||
            _fOrphanWorkerProcessChanged        ||
            _fStartupTimeLimitChanged           ||
            _fShutdownTimeLimitChanged          ||
            _fPingIntervalChanged               ||
            _fPingResponseTimeChanged           ||
            _fDisallowOverlappingRotationChanged  ||
            _fOrphanActionExecutableChanged     ||
            _fOrphanActionParametersChanged     ||
            _fAppPoolQueueLengthChanged         ||
            _fDisallowRotationOnConfigChangeChanged  ||
            _fWAMUserNameChanged                ||  
            _fWAMUserPassChanged                ||  
            _fAppPoolIdentityTypeChanged        ||
            _fCPUActionChanged                  ||  
            _fCPULimitChanged                   ||  
            _fCPUResetIntervalChanged           ||
            _fAppPoolCommandChanged             ||
            _fAppPoolAutoStartChanged           ||
            _fRapidFailProtectionIntervalChanged  ||  
            _fRapidFailProtectionMaxCrashesChanged ||
            _fDisableActionExecutableChanged ||
            _fDisableActionParametersChanged ||
            _fLoadBalancerTypeChanged ||
            _fRecycleLoggingFlagsChanged )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


HRESULT
APP_POOL_DATA_OBJECT_TABLE::ReadFromMetabase(
    IMSAdminBase *              pAdminBase
)
/*++

Routine Description:

    Read all the app pools from the metabase and builds up a table

Arguments:

    pAdminBase - ABO pointer

Return Value:

    HRESULT

--*/
{
    return ReadFromMetabasePrivate(pAdminBase, TRUE);
}

HRESULT
APP_POOL_DATA_OBJECT_TABLE::ReadFromMetabasePrivate(
    IMSAdminBase *              pAdminBase,
    BOOL                        fMultiThreaded
)
/*++

Routine Description:

    Read all the app pools from the metabase and builds up a table

Arguments:

    pAdminBase - ABO pointer
    fMultiThreaded - whether or not to do this multithreaded

Return Value:

    HRESULT

--*/
{
    MB                      mb( pAdminBase );
    BUFFER                  bufPaths;
    BOOL                    fRet;
    
    //
    // Choose an arbitrarily large buffer (if its too small that just means
    // we'll make two ABO calls -> no big deal
    //
    
    fRet = bufPaths.Resize( CHILD_PATH_BUFFER_SIZE );
    if ( !fRet )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    //
    // Open the app pools key.
    //
    fRet = mb.Open( L"/LM/W3SVC/APPPOOLS", 
                    METADATA_PERMISSION_READ );
    if ( !fRet )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    fRet = mb.GetChildPaths( L"",
                             &bufPaths );
    if ( !fRet )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    MULTIPLE_THREAD_READER reader;
    return reader.DoWork(this, &mb, (LPWSTR) bufPaths.QueryPtr(), fMultiThreaded);
}

HRESULT
APP_POOL_DATA_OBJECT_TABLE::DoThreadWork(
    LPWSTR                 pszString,
    LPVOID                 pContext
)
/*++

Routine Description:

    Main thread worker routine

Arguments:

    pszString - app pool to add to table
    pContext - MB* opened to w3svc/apppools

Return Value:

    DWORD

--*/
{
    MB *                    mb = (MB*) pContext;
    BOOL                    fRet;
    WCHAR                  *achAppPoolId = pszString;
    STACK_BUFFER(           bufProperties, 512 );
    DWORD                   cProperties;
    STACK_BUFFER(           bufPropertiesFile, 512 );
    DWORD                   cPropertiesFile;
    DWORD                   dwDataSetNumber;
    HRESULT                 hr = S_OK;
    APP_POOL_DATA_OBJECT *  pAppPoolObject = NULL;
    LK_RETCODE              lkrc;

    DBG_ASSERT(pContext && pszString);

    //
    // Get an individuals app pool data ( server properties )
    //
    fRet = mb->GetAll( achAppPoolId,
                      METADATA_INHERIT | METADATA_PARTIAL_PATH,
                      IIS_MD_UT_SERVER,
                      &bufProperties,
                      &cProperties,
                      &dwDataSetNumber );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }

    //
    // Get an individuals app pool data ( file properties )
    //
    fRet = mb->GetAll( achAppPoolId,
                      METADATA_INHERIT | METADATA_PARTIAL_PATH,
                      IIS_MD_UT_FILE,
                      &bufPropertiesFile,
                      &cPropertiesFile,
                      &dwDataSetNumber );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }

            
    //
    // Create a app pool config
    //
    pAppPoolObject = new APP_POOL_DATA_OBJECT();
    if ( pAppPoolObject == NULL )
    {
         hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
         goto exit;
    }
    
    //
    // Set the id into the object.
    //
    hr = pAppPoolObject->Create( achAppPoolId );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    
    //
    // Read the configuration from the metabase ( for the server variables )
    //
    hr = pAppPoolObject->SetFromMetabaseData( (METADATA_GETALL_RECORD*) 
                                        bufProperties.QueryPtr(),
                                        cProperties,
                                        (PBYTE) bufProperties.QueryPtr() );
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    //
    // Read the configuration from the metabase ( for the file variables )
    //
    hr = pAppPoolObject->SetFromMetabaseData( (METADATA_GETALL_RECORD*) 
                                        bufPropertiesFile.QueryPtr(),
                                        cPropertiesFile,
                                        (PBYTE) bufPropertiesFile.QueryPtr() );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    
    //
    // Finally, add the site to the hash table
    //

    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    //
    // General rule about inserting into tables:
    //
    // For Initial Processing and Complete processing caused by
    // a change notification, we will always ignore inserting a
    // object if we fine an object all ready in the table.  This is because
    // during a change notification if a record was added by the change
    // notification code, it will be more correct ( like knowing if ServerCommand
    // actually changed ), then the new generic record that was read because
    // of a change to a hire node.  Also during initial read we should
    // not have to make this decision so we can still ignore if we do see it.
    //
    // For Change Processing we will need to evaluate the change that 
    // all ready exists and compare it with the new change to decide 
    // what change we should make.
    //
    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    lkrc = InsertRecord( (DATA_OBJECT*) pAppPoolObject );
    if ( lkrc != LK_SUCCESS && lkrc != LK_KEY_EXISTS )
    {
        hr = HRESULT_FROM_WIN32( lkrc );
        goto exit;
    }

    hr = S_OK;
    
exit:

    //
    // if we made it to the part where we insert it into
    // the table there will be another reference around 
    // to keep it alive.
    //
    if ( pAppPoolObject )
    {
        pAppPoolObject->DereferenceDataObject();
        pAppPoolObject = NULL;
    }

    return hr;
    
}

HRESULT
APP_POOL_DATA_OBJECT_TABLE::ReadFromMetabaseChangeNotification(
    IMSAdminBase *              pAdminBase,
    MD_CHANGE_OBJECT            pcoChangeList[],
    DWORD                       dwMDNumElements,
    DATA_OBJECT_TABLE*          pMasterTable
)
/*++

Routine Description:

    Change change notification by building a new table

Arguments:

    pAdminBase - ABO pointer
    pcoChangeList - Properties which have changed
    dwMDNumElements - Number of properties which have changed

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = S_OK;

    DWORD                   i = 0;
    WCHAR *                 pszAppPoolId = NULL;
    WCHAR *                 pszPathEnd = NULL;
    APP_POOL_DATA_OBJECT *  pAppPoolObject = NULL;

    MB                      mb( pAdminBase );
    STACK_BUFFER(           bufProperties, 512 );
    DWORD                   cProperties = 0;
    STACK_BUFFER(           bufPropertiesFile, 512 );
    DWORD                   cPropertiesFile = 0;
    DWORD                   dwDataSetNumber = 0;

    LK_RETCODE              lkrc;
    BOOL                    fRet;
    BOOL                    fInitFromMetabase = TRUE;
    BOOL                    fReadAllObjects = FALSE;

    DWORD                   dwLastError;

    UNREFERENCED_PARAMETER ( pMasterTable );
    //
    // Go through each change notification 
    // in the batch.
    //
    for ( i = 0; i < dwMDNumElements; i++ )
    {
        //
        // If there is no path then just ignore this,
        // it's a bad notification.
        //
        if ( pcoChangeList[ i ].pszMDPath == NULL )
        {
            DBG_ASSERT ( pcoChangeList[ i ].pszMDPath != NULL );
            continue;
        }

        DWORD chMDPath = (DWORD) wcslen( pcoChangeList[ i ].pszMDPath );

        //
        // We only care about W3SVC properties
        //
        if( ( chMDPath < DATA_STORE_SERVER_MB_PATH_CCH ) ||
            ( _wcsnicmp( pcoChangeList[ i ].pszMDPath,
                       DATA_STORE_SERVER_MB_PATH,
                       DATA_STORE_SERVER_MB_PATH_CCH ) != 0 ) )
        {
            continue;
        }
        
        //
        // If a property changed at the W3SVC level, then we need to 
        // re-evaluate all the app pools (i.e. read all the metabase props) once
        //
        // Example of properties that cause us to care about the w3svc key
        // are the WAMUserName and Password properties.
        //

        //
        // Issue: Someday we may want to change this to only re-read if it
        // is a property that matters to app pools.
        
        if ( chMDPath == DATA_STORE_SERVER_MB_PATH_CCH )
        {
            fReadAllObjects = TRUE;
            continue;
        }

        //
        // We also only care about the APPPOOL properties unless
        // we are on the W3SVC property and we handled that above.
        //
        if( ( chMDPath < DATA_STORE_SERVER_APP_POOLS_MB_PATH_CCH ) ||
            ( _wcsnicmp( pcoChangeList[ i ].pszMDPath,
                       DATA_STORE_SERVER_APP_POOLS_MB_PATH,
                       DATA_STORE_SERVER_APP_POOLS_MB_PATH_CCH ) != 0 ) )
        {
            continue;
        }

        //
        // We also need to re-read all if it is a APPPOOLS level key
        //
        if( chMDPath == DATA_STORE_SERVER_APP_POOLS_MB_PATH_CCH ) 
        {
            fReadAllObjects = TRUE;
            continue;
        }
            

        //
        // Evaluate which app pool has changed
        //
        
        pszAppPoolId = pcoChangeList[ i ].pszMDPath + DATA_STORE_SERVER_APP_POOLS_MB_PATH_CCH;

        // assert that we are past the ending slash
        DBG_ASSERT( *pszAppPoolId != L'/' );

        //
        // Need to figure out where the app pool key ends
        //
        pszPathEnd = pszAppPoolId;
        while ( *pszPathEnd != L'\0' && *pszPathEnd != '/' )
        {
            pszPathEnd++;
        }

        //
        // We only care about pool properties set at the pool level (not
        // deeper) So if we are on a forward slash and there are characters
        // following it, move on to the next entry.
        //
        
        if ( ( *pszPathEnd == L'/' &&
                pszPathEnd[ 1 ] != L'\0' ) )
        {
            continue;
        }

        //
        // We are going to process it, however we don't want the 
        // pszAppPoolId to end with a slash so.
        *pszPathEnd = L'\0';
        
        //
        // What type of data action is this?
        //
        if ( pcoChangeList[ i ].dwMDChangeType & MD_CHANGE_TYPE_DELETE_OBJECT )
        {
            fInitFromMetabase = FALSE;
        }
        else
        {
            fInitFromMetabase = TRUE;
        }       
        
        //
        // Create a app pool object
        //
        
        pAppPoolObject = new APP_POOL_DATA_OBJECT();
        if ( pAppPoolObject == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto exit;
        }
            
        hr = pAppPoolObject->Create( pszAppPoolId );
        if ( FAILED( hr ) )
        {
            goto exit;
        }

        //
        // before we go looking in the metabase, we need to 
        // mark the server command if it really changed.
        //
        if ( pcoChangeList[ i ].dwMDChangeType & MD_CHANGE_TYPE_SET_DATA )
        {
            // we need to check the Columns that changed if we find one
            // is the ServerCommand we want to honor it.

            for ( DWORD j = 0; j < pcoChangeList[ i ].dwMDNumDataIDs; j++ )
            {
                if ( pcoChangeList[ i ].pdwMDDataIDs[ j ] == MD_APPPOOL_COMMAND )
                {
                    pAppPoolObject->SetAppPoolCommandChanged( TRUE );
                    break;
                }
            }
        }
        
        //
        // Read the metabase now
        //

        if ( fInitFromMetabase )
        {
            fRet = mb.Open( L"", METADATA_PERMISSION_READ );
            if ( !fRet )
            {
                DBG_ASSERT ( fRet );
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto exit;
            }

            fRet = mb.GetAll( pcoChangeList[ i ].pszMDPath,
                              METADATA_INHERIT | METADATA_PARTIAL_PATH,
                              IIS_MD_UT_SERVER,
                              &bufProperties,
                              &cProperties,
                              &dwDataSetNumber );

            if ( fRet )
            {
                // if the above call worked then we can get the file
                // data as well.
                fRet = mb.GetAll( pcoChangeList[ i ].pszMDPath,
                                  METADATA_INHERIT | METADATA_PARTIAL_PATH,
                                  IIS_MD_UT_FILE,
                                  &bufPropertiesFile,
                                  &cPropertiesFile,
                                  &dwDataSetNumber );

            }
                
            dwLastError = fRet ? ERROR_SUCCESS : GetLastError(); 

            mb.Close();

            if ( !fRet )
            {
                // if we can not find the key then a delete
                // for the object is on it's way, so we can 
                // ignore this change notification.

                if ( dwLastError == ERROR_PATH_NOT_FOUND ||
                     dwLastError == ERROR_FILE_NOT_FOUND )
                {
                    pAppPoolObject->DereferenceDataObject();
                    pAppPoolObject = NULL;

                    continue;
                }
                    
                hr = HRESULT_FROM_WIN32( dwLastError );

                goto exit;
            }
            
            hr = pAppPoolObject->SetFromMetabaseData( (METADATA_GETALL_RECORD*) 
                                                bufProperties.QueryPtr(),
                                                cProperties,
                                                (PBYTE) bufProperties.QueryPtr() );
            if ( FAILED( hr ) )
            {
                goto exit;
            }

            hr = pAppPoolObject->SetFromMetabaseData( (METADATA_GETALL_RECORD*) 
                                                bufPropertiesFile.QueryPtr(),
                                                cPropertiesFile,
                                                (PBYTE) bufPropertiesFile.QueryPtr() );
            if ( FAILED( hr ) )
            {
                goto exit;
            }

        }
        else
        {
            // we are on a delete so mark the object to delete.
            pAppPoolObject->SetDeleteWhenDone( TRUE );
        }
            
        //
        // Finally, add the site to the hash table
        //
        
        // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        //
        // General rule about inserting into tables:
        //
        // For Initial Processing and Complete processing caused by
        // a change notification, we will always ignore inserting a
        // object if we fine an object all ready in the table.  This is because
        // during a change notification if a record was added by the change
        // notification code, it will be more correct ( like knowing if ServerCommand
        // actually changed ), then the new generic record that was read because
        // of a change to a hire node.  Also during initial read we should
        // not have to make this decision so we can still ignore if we do see it.
        //
        // For Change Processing we will need to evaluate the change that 
        // all ready exists and compare it with the new change to decide 
        // what change we should make.
        //
        // In this case if we find a record all ready existing we need to determine
        // and we are inserting an update that does not have the ServerCommand set
        // we need to determine if the original record had the ServerCommand set, if
        // it did we don't want to insert the new record, otherwise we will.
        // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        lkrc = InsertRecord( (DATA_OBJECT*) pAppPoolObject );
        if ( lkrc != LK_SUCCESS )
        {
            // So we found an existing key, now we have to decide
            // what to do.
            if ( lkrc == LK_KEY_EXISTS )
            {
                BOOL fOverwrite = TRUE;

                // If the new object is not a deletion and it does
                // not all ready have the AppPoolCommandChange set
                // we will need to decide if we should not overwrite
                // the existing object.  If the new object is a deletion
                // or it does have the app pool command set then we 
                // will go ahead with it because the old object just
                // doesn't matter to us.

                if ( !pAppPoolObject->QueryDeleteWhenDone() &&
                     !pAppPoolObject->QueryAppPoolCommandChanged() )
                {
                    APP_POOL_DATA_OBJECT *  pFoundObject = NULL;

                    // Find the existing record in the table
                    // and check if the AppPoolCommand has changed
                    // if it has not then we can overwrite it.

                    lkrc = FindKey( pAppPoolObject->QueryKey(),
                                   ( DATA_OBJECT** )&pFoundObject );

                    // we just were told this record existed so
                    // make sure we weren't lied to.
                    DBG_ASSERT ( lkrc == LK_SUCCESS && pFoundObject != NULL );

                    //
                    // Only if the old object was a simple update
                    // and it had the AppPoolCommand set do we honor
                    // that object.
                    //
                    if ( !pFoundObject->QueryDeleteWhenDone() &&
                         pFoundObject->QueryAppPoolCommandChanged() )
                    {
                        fOverwrite = FALSE;
                    }

                    // release the found object
                    if ( pFoundObject )
                    {
                        pFoundObject->DereferenceDataObject();
                        pFoundObject = NULL;
                    }
                }

                if ( fOverwrite )
                {
                    lkrc = InsertRecord( (DATA_OBJECT*) pAppPoolObject, TRUE );
                    if ( lkrc != LK_SUCCESS )
                    {
                        hr = HRESULT_FROM_WIN32( lkrc );
                        goto exit;
                    }
                }

            }
            else
            {
                hr = HRESULT_FROM_WIN32( lkrc );
                goto exit;
            }
        }

        pAppPoolObject->DereferenceDataObject();
        pAppPoolObject = NULL;

    }  // do the next change notification.

    //
    // if we detected that a higher up change might affect
    // the app pools, then re-read all the app pool properties.
    //
    if ( fReadAllObjects )
    {
        hr = ReadFromMetabasePrivate( pAdminBase, FALSE );
    }

  
exit:
    
    if ( pAppPoolObject )
    {
        pAppPoolObject->DereferenceDataObject();
        pAppPoolObject = NULL;
    }

    return hr;
}

//static
LK_ACTION
APP_POOL_DATA_OBJECT_TABLE::CreateWASObjectsAction(
    IN DATA_OBJECT* pObject, 
    IN LPVOID
    )
/*++

Routine Description:

    Handles determining if the app pool data object
    should be inserted into WAS's known app pools

Arguments:

    IN DATA_OBJECT* pObject = the app pool to decide about

Return Value:

    LK_ACTION

--*/

{
    
    DBG_ASSERT ( pObject );

    APP_POOL_DATA_OBJECT* pAppPool = (APP_POOL_DATA_OBJECT*) pObject;
    DBG_ASSERT( pAppPool->CheckSignature() );

    if ( pAppPool->QueryShouldWasInsert() )
    {
        GetWebAdminService()->
             GetUlAndWorkerManager()->
             CreateAppPool( pAppPool );
    }
        
    return LKA_SUCCEEDED;
}

//static
LK_ACTION
APP_POOL_DATA_OBJECT_TABLE::UpdateWASObjectsAction(
    IN DATA_OBJECT* pObject, 
    IN LPVOID 
    )
/*++

Routine Description:

    Handles determining if the app pool data object
    should be updated in WAS's known app pools

Arguments:

    IN DATA_OBJECT* pObject = the app pool to decide about

Return Value:

    LK_ACTION

--*/
{
    
    DBG_ASSERT ( pObject );

    APP_POOL_DATA_OBJECT* pAppPool = (APP_POOL_DATA_OBJECT*) pObject;
    DBG_ASSERT( pAppPool->CheckSignature() );

    if ( pAppPool->QueryShouldWasUpdate() )
    {
        GetWebAdminService()->
             GetUlAndWorkerManager()->
             ModifyAppPool( pAppPool );
    }
        
    return LKA_SUCCEEDED;
}

//static
LK_ACTION
APP_POOL_DATA_OBJECT_TABLE::DeleteWASObjectsAction(
    IN DATA_OBJECT* pObject, 
    IN LPVOID 
    )
/*++

Routine Description:

    Handles determining if the app pool data object
    should be deleted from WAS's known app pools

Arguments:

    IN DATA_OBJECT* pObject = the app pool to decide about

Return Value:

    LK_ACTION

--*/
{
    
    DBG_ASSERT ( pObject );

    APP_POOL_DATA_OBJECT* pAppPool = (APP_POOL_DATA_OBJECT*) pObject;
    DBG_ASSERT( pAppPool->CheckSignature() );

    if ( pAppPool->QueryShouldWasDelete() )
    {
        GetWebAdminService()->
             GetUlAndWorkerManager()->
             DeleteAppPool( pAppPool, 
                            pAppPool->QueryDeleteWhenDone() ? S_OK : E_INVALIDARG );
    }
        
    return LKA_SUCCEEDED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\application.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    application.cxx

Abstract:

    This class encapsulates a single application.

    Threading: Always called on the main worker thread.

Author:

    Seth Pollack (sethp)        04-Nov-1998

Revision History:

--*/

#include "precomp.h"

/***************************************************************************++

Routine Description:

    Constructor for the APPLICATION class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

APPLICATION::APPLICATION(
    )
{

    m_ApplicationId.VirtualSiteId = INVALID_VIRTUAL_SITE_ID;

    m_VirtualSiteListEntry.Flink = NULL;
    m_VirtualSiteListEntry.Blink = NULL;

    m_AppPoolListEntry.Flink = NULL;
    m_AppPoolListEntry.Blink = NULL;

    m_pVirtualSite = NULL;

    m_pAppPool = NULL;

    m_UlConfigGroupId = HTTP_NULL_ID;

    m_DeleteListEntry.Flink = NULL;
    m_DeleteListEntry.Blink = NULL;

    m_ULLogging = FALSE;

    m_InMetabase = FALSE;

    m_Signature = APPLICATION_SIGNATURE;

}   // APPLICATION::APPLICATION



/***************************************************************************++

Routine Description:

    Destructor for the APPLICATION class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

APPLICATION::~APPLICATION(
    )
{
    DWORD Win32Error = NO_ERROR;

    DBG_ASSERT( m_Signature == APPLICATION_SIGNATURE );
    m_Signature = APPLICATION_SIGNATURE_FREED;

    //
    // Delete the UL config group.
    // need to do this before Dissociating the Application because
    // this may cause another application to be created, and UL has
    // to of released the first application.
    //

    // If we run out of memory during initialization we may get
    // into a state where this is still NULL.  In this case,
    // then we don't need to do any cleanup for these items.
    if ( m_UlConfigGroupId != HTTP_NULL_ID )
    {
        Win32Error = HttpDeleteConfigGroup(
                            GetWebAdminService()->GetUlAndWorkerManager()->GetUlControlChannel(),
                                                        // control channel
                            m_UlConfigGroupId           // config group ID
                            );

        if ( Win32Error != ERROR_SUCCESS )
        {
            const WCHAR * EventLogStrings[2];

            WCHAR StringizedSiteId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];

            _ultow(m_ApplicationId.VirtualSiteId, StringizedSiteId, 10);

            EventLogStrings[0] = m_ApplicationId.ApplicationUrl.QueryStr();
            EventLogStrings[1] = StringizedSiteId;

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_DELETE_CONFIG_GROUP_FAILED,   // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    HRESULT_FROM_WIN32( Win32Error )        // error code
                    );

            // need to press on now that we logged the error.
            Win32Error = ERROR_SUCCESS;
        }
    }

    m_UlConfigGroupId = HTTP_NULL_ID;

    //
    // Clear the virtual site and app pool associations.
    //

    if ( m_pVirtualSite != NULL )
    {
        m_pVirtualSite->DissociateApplication( this );
        m_pVirtualSite = NULL;
    }


    if ( m_pAppPool != NULL )
    {
        m_pAppPool->DissociateApplication( this );

        //
        // Dereference the app pool object, since it is reference counted
        // and we have been holding a pointer to it.
        //

        m_pAppPool->Dereference();

        m_pAppPool = NULL;
    }

}   // APPLICATION::~APPLICATION



/***************************************************************************++

Routine Description:

    Initialize the application instance.

Arguments:

    IN APPLICATION_DATA_OBJECT * pAppObject,
    IN VIRTUAL_SITE * pVirtualSite,
    IN APP_POOL * pAppPool

Return Value:

    HRESULT - can fail because of memory problems or configuring http issues

--***************************************************************************/

HRESULT
APPLICATION::Initialize(
    IN APPLICATION_DATA_OBJECT * pAppObject,
    IN VIRTUAL_SITE * pVirtualSite,
    IN APP_POOL * pAppPool
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT( pAppObject != NULL );
    DBG_ASSERT( pVirtualSite != NULL );
    DBG_ASSERT( pAppPool != NULL );

    if ( pAppObject == NULL ||
         pVirtualSite == NULL ||
         pAppPool == NULL )
    {
        return E_INVALIDARG;
    }

    //
    // First, copy the application id.
    //

    hr = m_ApplicationId.ApplicationUrl.Copy ( pAppObject->QueryApplicationUrl() );
    if ( FAILED( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Allocating memory failed\n"
            ));

        goto exit;
    }

    m_ApplicationId.VirtualSiteId = pAppObject->QuerySiteId();

    //
    // The virtual site IDs better match.
    //

    DBG_ASSERT( m_ApplicationId.VirtualSiteId == pVirtualSite->GetVirtualSiteId() );

    //
    // Next, set up the virtual site association.
    //

    pVirtualSite->AssociateApplication( this );

    //
    // Only set this pointer if the association succeeded.
    //

    m_pVirtualSite = pVirtualSite;


    //
    // Set up the UL config group.
    //

    hr = InitializeConfigGroup();
    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Initializing config group failed\n"
            ));

        goto exit;
    }


    //
    // Set the initial configuration, including telling UL about it. 
    //

    SetConfiguration( pAppObject, pAppPool );

    //
    // Activate the application, whether or not it can accept 
    // requests is dependent on the app pool.
    //
    hr = ActivateConfigGroup();
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "activating the config group failed\n"
            ));

        goto exit;
    }

exit:

    return hr;

}   // APPLICATION::Initialize

/***************************************************************************++

Routine Description:

    Accept a set of configuration parameters for this application. 

Arguments:

    pAppObject - The configuration for this application. 

Return Value:

    VOID

--***************************************************************************/

VOID
APPLICATION::SetConfiguration(
    IN APPLICATION_DATA_OBJECT * pAppObject,
    IN APP_POOL* pAppPool
    )
{

    DBG_ASSERT( pAppObject != NULL );
    DBG_ASSERT( pAppPool != NULL );

    if ( pAppObject == NULL || pAppPool == NULL )
    {
        return;
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "New configuration for application of site: %lu with path: %S\n",
            GetApplicationId()->VirtualSiteId,
            GetApplicationId()->ApplicationUrl.QueryStr()
            ));
    }

    // Remember if the application is in the metabase.
    m_InMetabase = pAppObject->QueryInMetabase();

    //
    // See if the app pool has been set or changed, and if so, handle it.
    //

    if ( pAppObject->QueryAppPoolIdChanged() )
    {
        SetAppPool( pAppPool );
    }

#if DBG
    //
    // Dump the configuration.
    //

    DebugDump();
#endif  // DBG

}   // APPLICATION::SetConfiguration


/***************************************************************************++

Routine Description:

    Re-register all URLs with UL, by tossing the currently registered ones,
    and re-doing the registration. This is done when the site bindings 
    change.

Arguments:

    None.

Return Value:

    VOID ( while we don't return an error a side affect of not being able
           to register a URL is to shutdown the site. )

--***************************************************************************/

VOID
APPLICATION::ReregisterURLs(
    )
{

    DWORD Win32Error = NO_ERROR;
    HRESULT hr = S_OK;

    DBG_ASSERT( m_UlConfigGroupId != HTTP_NULL_ID );

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Bindings change: removing all URLs registered for config group of application of site: %lu with path: %S\n",
            GetApplicationId()->VirtualSiteId,
            GetApplicationId()->ApplicationUrl.QueryStr()
            ));
    }

    Win32Error = HttpRemoveAllUrlsFromConfigGroup(
                        GetWebAdminService()->GetUlAndWorkerManager()->GetUlControlChannel(),
                                                        // control channel
                        m_UlConfigGroupId               // config group id
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );

        const WCHAR * EventLogStrings[2];

        WCHAR StringizedSiteId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];

        _ultow(m_ApplicationId.VirtualSiteId, StringizedSiteId, 10);

        EventLogStrings[0] = m_ApplicationId.ApplicationUrl.QueryStr();
        EventLogStrings[1] = StringizedSiteId;

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_REMOVING_ALL_URLS_FAILED,              // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                hr                                      // error code
                );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Removing all URLs from config group failed\n"
            ));

        // press on in the case of errors
        hr = S_OK;
        Win32Error = ERROR_SUCCESS;
    }

    //
    // Add the URL(s) which represent this app to the config group.
    //

    AddUrlsToConfigGroup();

}   // APPLICATION::ReregisterURLs



/***************************************************************************++

Routine Description:

    A static class method to "upcast" from a LIST_ENTRY to an APPLICATION.

Arguments:

    pListEntry - A pointer to the m_VirtualSiteListEntry member of an
    APPLICATION.

Return Value:

    The pointer to the containing APPLICATION.

--***************************************************************************/

// note: static!
APPLICATION *
APPLICATION::ApplicationFromVirtualSiteListEntry(
    IN const LIST_ENTRY * pVirtualSiteListEntry
)
{

    APPLICATION * pApplication = NULL;

    DBG_ASSERT( pVirtualSiteListEntry != NULL );

    //  get the containing structure, then verify the signature
    pApplication = CONTAINING_RECORD(
                        pVirtualSiteListEntry,
                        APPLICATION,
                        m_VirtualSiteListEntry
                        );

    DBG_ASSERT( pApplication->m_Signature == APPLICATION_SIGNATURE );

    return pApplication;

}   // APPLICATION::ApplicationFromVirtualSiteListEntry



/***************************************************************************++

Routine Description:

    A static class method to "upcast" from a LIST_ENTRY to an APPLICATION.

Arguments:

    pListEntry - A pointer to the m_AppPoolListEntry member of an
    APPLICATION.

Return Value:

    The pointer to the containing APPLICATION.

--***************************************************************************/

// note: static!
APPLICATION *
APPLICATION::ApplicationFromAppPoolListEntry(
    IN const LIST_ENTRY * pAppPoolListEntry
)
{

    APPLICATION * pApplication = NULL;

    DBG_ASSERT( pAppPoolListEntry != NULL );

    //  get the containing structure, then verify the signature
    pApplication = CONTAINING_RECORD(
                        pAppPoolListEntry,
                        APPLICATION,
                        m_AppPoolListEntry
                        );

    DBG_ASSERT( pApplication->m_Signature == APPLICATION_SIGNATURE );

    return pApplication;

}   // APPLICATION::ApplicationFromAppPoolListEntry



/***************************************************************************++

Routine Description:

    A static class method to "upcast" from the delete list LIST_ENTRY
    pointer of an APPLICATION to the APPLICATION as a whole.

Arguments:

    pDeleteListEntry - A pointer to the m_DeleteListEntry member of an
    APPLICATION.

Return Value:

    The pointer to the containing APPLICATION.

--***************************************************************************/

// note: static!
APPLICATION *
APPLICATION::ApplicationFromDeleteListEntry(
    IN const LIST_ENTRY * pDeleteListEntry
)
{

    APPLICATION * pApplication = NULL;

    DBG_ASSERT( pDeleteListEntry != NULL );

    //  get the containing structure, then verify the signature
    pApplication = CONTAINING_RECORD(
                            pDeleteListEntry,
                            APPLICATION,
                            m_DeleteListEntry
                            );

    DBG_ASSERT( pApplication->m_Signature == APPLICATION_SIGNATURE );

    return pApplication;

}   // APPLICATION::ApplicationFromDeleteListEntry



#if DBG
/***************************************************************************++

Routine Description:

    Dump out key internal data structures.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
APPLICATION::DebugDump(
    )
{
    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "********Application of site: %lu with path: %S; member of app pool: %S;\n",
            GetApplicationId()->VirtualSiteId,
            GetApplicationId()->ApplicationUrl.QueryStr(),
            m_pAppPool ? m_pAppPool->GetAppPoolId() : L"NULL"

            ));
    }

    return;

}   // APPLICATION::DebugDump
#endif  // DBG

/***************************************************************************++

Routine Description:

    Activate the config group in HTTP.SYS if the parent app pool is active.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/
HRESULT 
APPLICATION::ActivateConfigGroup()
{
    HRESULT hr = S_OK;

    // not sure why we would get here and not have the 
    // config group setup. so I am adding the assert.
    DBG_ASSERT (  m_UlConfigGroupId != HTTP_NULL_ID );

    if  ( m_UlConfigGroupId != HTTP_NULL_ID )
    {
        hr = SetConfigGroupStateInformation( HttpEnabledStateActive );

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Enabling config group failed\n"
                ));

            goto exit;
        }

    }

exit:
    return hr;
}

/***************************************************************************++

Routine Description:

    Associate this application with an application pool. 

Arguments:

    pAppPool - The new application pool with which this application should
    be associated.

Return Value:

    HRESULT

--***************************************************************************/

VOID
APPLICATION::SetAppPool(
    IN APP_POOL * pAppPool
    )
{

    DBG_ASSERT( pAppPool != NULL );

    if ( pAppPool == NULL )
    {
        return;
    }

    //
    // First, remove the association with the old app pool, if any.
    //

    if ( m_pAppPool != NULL )
    {
        m_pAppPool->DissociateApplication( this );

        //
        // Dereference the app pool object, since it is reference counted
        // and we have been holding a pointer to it.
        //

        m_pAppPool->Dereference();

        m_pAppPool = NULL;
    }

    pAppPool->AssociateApplication( this );

    //
    // Only set this pointer if the association succeeded.
    //

    m_pAppPool = pAppPool;

    //
    // Reference the app pool object, since it is reference counted
    // and we will be holding a pointer to it.
    //

    m_pAppPool->Reference();


    //
    // Let UL know about the new configuration.
    //

    SetConfigGroupAppPoolInformation();

}   // APPLICATION::SetAppPool



/***************************************************************************++

Routine Description:

    Initialize the UL config group associated with this application.

    Note:  Must always be called after the Virtual Site knows about this application
           because there is an error route where the VS may be asked to remove
           all the applications config group info, and this must work.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APPLICATION::InitializeConfigGroup(
    )
{

    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;


    //
    // First, create the config group.
    //
    DBG_ASSERT (  m_UlConfigGroupId == HTTP_NULL_ID );


    Win32Error = HttpCreateConfigGroup(
                        GetWebAdminService()->GetUlAndWorkerManager()->GetUlControlChannel(),
                                                    // control channel
                        &m_UlConfigGroupId          // returned config group ID
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Creating config group failed\n"
            ));

        goto exit;
    }


    //
    // Add the URL(s) which represent this app to the config group.
    //

    //
    // We do not care if this fails, 
    // because if it does we will have deactivated 
    // the site.  Therefore we are not checking the 
    // returned hresult.
    // 
    AddUrlsToConfigGroup();

    //
    // Assuming we have a URL then we can configure the SiteId and 
    // Logging information if this is the default site.
    //
    DBG_ASSERT( !m_ApplicationId.ApplicationUrl.IsEmpty() );
    if ( wcscmp(m_ApplicationId.ApplicationUrl.QueryStr(), L"/") == 0)
    {
        //
        // This only happens during initalization of a config group.  
        // Site Id will not change for a default application so once
        // we have done this registration, we don't worry about
        // config changes for the SiteId.
        //
        hr = RegisterSiteIdWithHttpSys();
        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Setting site on default url failed\n"
                ));

            goto exit;

        }

        // The rest of the settings can be reset through configuration
        // changes, so if they fail we log but we go on.

        // Never configure site logging services if centralized is enabled.
        if ( GetWebAdminService()->IsCentralizedLoggingEnabled() == FALSE )
        {
            RegisterLoggingProperties();
        }

        ConfigureMaxBandwidth();

        ConfigureMaxConnections();

        ConfigureConnectionTimeout();
    }

exit:

    return hr;

}   // APPLICATION::InitializeConfigGroup



/***************************************************************************++

Routine Description:

    Determine the set of fully-qualified URLs which represent this
    application, and register each of them with the config group.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

VOID
APPLICATION::AddUrlsToConfigGroup(
    )
{

    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;
    HTTP_URL_CONTEXT UrlContext = 0;
    STRU UrlToRegister;
    LPCWSTR pPrefix = NULL;

    DBG_ASSERT (  m_UlConfigGroupId != HTTP_NULL_ID );
    DBG_ASSERT( m_pVirtualSite != NULL );
    DBG_ASSERT( !m_ApplicationId.ApplicationUrl.IsEmpty());

    if ( m_pVirtualSite->GetState() != MD_SERVER_STATE_STARTED )
    {
        //
        // If the virtual site is not started then don't add 
        // any urls to HTTP.SYS.  Simply return with success
        // because this is the expected behavior if the site
        // is not started.
        //

        hr = S_OK;

        goto exit;
    }

    m_pVirtualSite->ResetUrlPrefixIterator();

    // loop for each prefix
    while ( ( pPrefix = m_pVirtualSite->GetNextUrlPrefix() ) != NULL )
    {

        hr = UrlToRegister.Copy( pPrefix );
        if ( FAILED ( hr ) )
        {
            DPERROR((
                DBG_CONTEXT,
                hr,
                "Copying to STRU failed\n"
                ));

            goto exit;
        }

        hr = UrlToRegister.Append( m_ApplicationId.ApplicationUrl );
        if ( FAILED ( hr ) )
        {
            DPERROR((
                DBG_CONTEXT,
                hr,
                "Appending to STRU failed\n"
                ));

            goto exit;
        }

        //
        // Next, register the URL.
        //

        //
        // For the URL context, stuff the site id in the high 32 bits.
        //

        UrlContext = m_pVirtualSite->GetVirtualSiteId();
        UrlContext = UrlContext << 32;


        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "About to register fully qualified URL: %S; site id: %lu; URL context: %#I64x\n",
                UrlToRegister.QueryStr(),
                m_pVirtualSite->GetVirtualSiteId(),
                UrlContext
                ));
        }


        Win32Error = HttpAddUrlToConfigGroup(
                            GetWebAdminService()->GetUlAndWorkerManager()->GetUlControlChannel(),
                                                        // control channel
                            m_UlConfigGroupId,          // config group ID
                            UrlToRegister.QueryStr(),   // fully qualified URL
                            UrlContext                  // URL context
                            );

        if ( Win32Error != NO_ERROR )
        {

            hr = HRESULT_FROM_WIN32( Win32Error );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Adding URL to config group failed: %S\n",
                UrlToRegister.QueryStr()
                ));

            goto exit;

        }

        // Reset it if we get here so we don't report
        // that this URL caused us an issue below if we
        // get there.
        UrlToRegister.Reset();

    }


exit:

    //
    // If we failed to configure the bindings
    // then we need to log an event and 
    // shutdown the site.
    //
    if (  FAILED ( hr ) ) 
    {

        // If we have a url then let the users know which one,
        // other wise just let them know there was a problem.
        if ( !UrlToRegister.IsEmpty() )
        {
            const WCHAR * EventLogStrings[2];

            WCHAR StringizedSiteId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
            DWORD MessageId = WAS_EVENT_BINDING_FAILURE_GENERIC;

            _ultow(m_ApplicationId.VirtualSiteId, StringizedSiteId, 10);

            EventLogStrings[0] = UrlToRegister.QueryStr();
            EventLogStrings[1] = StringizedSiteId;

            switch ( hr )
            {
               case ( E_INVALIDARG ):
                    MessageId = WAS_EVENT_BINDING_FAILURE_INVALID_URL;
               break;
                    
               case ( HRESULT_FROM_WIN32( ERROR_HOST_UNREACHABLE ) ):
                    MessageId = WAS_EVENT_BINDING_FAILURE_UNREACHABLE;
               break;

               case ( HRESULT_FROM_WIN32( ERROR_UNEXP_NET_ERR )  ):
                    MessageId = WAS_EVENT_BINDING_FAILURE_INVALID_ADDRESS;
               break;

               case ( HRESULT_FROM_WIN32( ERROR_ALLOTTED_SPACE_EXCEEDED )  ):
                    MessageId = WAS_EVENT_BINDING_FAILURE_OUT_OF_SPACE;
               break;
                
               case ( HRESULT_FROM_WIN32( ERROR_ALREADY_EXISTS ) ):
                    MessageId = WAS_EVENT_BINDING_FAILURE_CONFLICT;
               break;

               default:
                    MessageId = WAS_EVENT_BINDING_FAILURE_GENERIC;
               break;
            }
            
            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    MessageId,              // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    hr                                      // error code
                    );
        }
        else
        {
            const WCHAR * EventLogStrings[1];

            WCHAR StringizedSiteId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
            _ultow(m_ApplicationId.VirtualSiteId, StringizedSiteId, 10);

            EventLogStrings[0] = StringizedSiteId;

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_BINDING_FAILURE_2,              // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    hr                                      // error code
                    );
        }

        //
        // FailedToBindUrlsForSite does not return an hresult
        // because it is used when we are trying to handle a hresult
        // all ready and any errors it might wonder into it just
        // has to handle.
        //
        m_pVirtualSite->ApplyStateChangeCommand(
                                    MD_SERVER_COMMAND_STOP,
                                    MD_SERVER_STATE_STOPPED,
                                    hr
                                    );

    }  // end of if (FAILED ( hr ))

}   // APPLICATION::AddUrlsToConfigGroup



/***************************************************************************++

Routine Description:

    Set the app pool property on the config group.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
APPLICATION::SetConfigGroupAppPoolInformation(
    )
{

    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;
    HTTP_CONFIG_GROUP_APP_POOL AppPoolInformation;


    DBG_ASSERT( m_pAppPool != NULL );
    DBG_ASSERT (  m_UlConfigGroupId != HTTP_NULL_ID );

    AppPoolInformation.Flags.Present = 1;
    AppPoolInformation.AppPoolHandle = m_pAppPool->GetAppPoolHandle();

    Win32Error = HttpSetConfigGroupInformation(
                        GetWebAdminService()->GetUlAndWorkerManager()->GetUlControlChannel(),
                                                            // control channel
                        m_UlConfigGroupId,                  // config group ID
                        HttpConfigGroupAppPoolInformation,  // information class
                        &AppPoolInformation,                // data to set
                        sizeof( AppPoolInformation )        // data length
                        );

    if ( Win32Error != NO_ERROR )
    {
        WCHAR StringizedSiteId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
        const WCHAR * EventLogStrings[2];

        hr = HRESULT_FROM_WIN32( Win32Error );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Setting config group app pool information failed\n"
            ));

        _ultow(m_ApplicationId.VirtualSiteId, StringizedSiteId, 10);

        EventLogStrings[0] = m_ApplicationId.ApplicationUrl.QueryStr();
        EventLogStrings[1] = StringizedSiteId;

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_SET_APP_POOL_FOR_CG_IN_HTTP_FAILED,   // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                hr                                      // error code
                );

        // need to press on now that we logged the error.
        Win32Error = ERROR_SUCCESS;
    }

}   // APPLICATION::SetConfigGroupAppPoolInformation

/***************************************************************************++

Routine Description:

    Activate or deactivate UL's HTTP request handling for this config group.

Arguments:

    NewState - The state to set, from the HTTP_ENABLED_STATE enum.

Return Value:

    HRESULT - Failure will be handled and logged
              in the Create Application which is the
              only time this call is used.

--***************************************************************************/

HRESULT
APPLICATION::SetConfigGroupStateInformation(
    IN HTTP_ENABLED_STATE NewState
    )
{

    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;
    HTTP_CONFIG_GROUP_STATE ConfigGroupState;

    DBG_ASSERT( m_UlConfigGroupId != HTTP_NULL_ID );

    ConfigGroupState.Flags.Present = 1;
    ConfigGroupState.State = NewState;

    Win32Error = HttpSetConfigGroupInformation(
                        GetWebAdminService()->GetUlAndWorkerManager()->GetUlControlChannel(),
                                                            // control channel
                        m_UlConfigGroupId,                  // config group ID
                        HttpConfigGroupStateInformation,    // information class
                        &ConfigGroupState,                  // data to set
                        sizeof( ConfigGroupState )          // data length
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Setting config group state failed\n"
            ));

    }

    return hr;

}   // APPLICATION::SetConfigGroupStateInformation



/***************************************************************************++

Routine Description:

    Set the logging properties on the config group.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
APPLICATION::RegisterLoggingProperties(
    )
{

    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;
    HTTP_CONFIG_GROUP_LOGGING LoggingInformation;

    DBG_ASSERT (  m_UlConfigGroupId != HTTP_NULL_ID );

    // If UL is already logging or if we are trying to tell
    // UL to start logging than we should pass the info down.
    if ( m_ULLogging || m_pVirtualSite->LoggingEnabled() )
    {

        // Always set the present flag it is intrinsic to UL.
        LoggingInformation.Flags.Present = 1;

        // Determine if logging is enabled at all.  If it is then
        // update all properties.  If it is not then just update the
        // property to disable logging.

        LoggingInformation.LoggingEnabled = (m_pVirtualSite->LoggingEnabled() == TRUE);
        IF_DEBUG( WEB_ADMIN_SERVICE_LOGGING )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Logging Enabled: %d\n",
                LoggingInformation.LoggingEnabled 
                ));
        }

        if ( LoggingInformation.LoggingEnabled )
        {
            if (   !m_pVirtualSite->GetLogFileDirectory() 
                || !m_pVirtualSite->GetVirtualSiteDirectory())
            {
                HRESULT hrTemp = E_INVALIDARG;

                UNREFERENCED_PARAMETER ( hrTemp );

                DPERROR((
                    DBG_CONTEXT,
                    hrTemp,
                    "Skipping UL Configuration of Logging, LogFile or VirtualSite Directory was NULL\n"
                    ));

                // Don't bubble up an error from here because we don't want to cause WAS to shutdown.
                return;
            }

            LoggingInformation.LogFileDir.Length = (USHORT) wcslen(m_pVirtualSite->GetLogFileDirectory()) * sizeof(WCHAR);
            LoggingInformation.LogFileDir.MaximumLength = LoggingInformation.LogFileDir.Length + (1 * sizeof(WCHAR));
            LoggingInformation.LogFileDir.Buffer = m_pVirtualSite->GetLogFileDirectory();

            IF_DEBUG( WEB_ADMIN_SERVICE_LOGGING )
            {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "Log File Length: %d; Log File Max Length: %d; Log File Path: %S\n",
                    LoggingInformation.LogFileDir.Length,
                    LoggingInformation.LogFileDir.MaximumLength,
                    LoggingInformation.LogFileDir.Buffer
                    ));
            }

            LoggingInformation.LogFormat = m_pVirtualSite->GetLogFileFormat();

            IF_DEBUG( WEB_ADMIN_SERVICE_LOGGING )
            {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "Logging Format: %d\n",
                    LoggingInformation.LogFormat
                    ));
            }


            LoggingInformation.LogPeriod = m_pVirtualSite->GetLogPeriod();
            LoggingInformation.LogFileTruncateSize = m_pVirtualSite->GetLogFileTruncateSize();
            LoggingInformation.LogExtFileFlags = m_pVirtualSite->GetLogExtFileFlags();
            LoggingInformation.LocaltimeRollover =  ( m_pVirtualSite->GetLogFileLocaltimeRollover() == TRUE ) ;
            LoggingInformation.SelectiveLogging = HttpLogAllRequests;


            IF_DEBUG( WEB_ADMIN_SERVICE_LOGGING )
            {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "LogPeriod: %d; LogTruncateSize: %d; LogExtFileFlags: %d LogFileLocaltimeRollover: %S\n",
                    LoggingInformation.LogPeriod,
                    LoggingInformation.LogFileTruncateSize,
                    LoggingInformation.LogExtFileFlags,
                    LoggingInformation.LocaltimeRollover ? L"TRUE" : L"FALSE"
                    ));
            }
    
        }
        else
        {
            // Just for sanity sake, set defaults for the properties before
            // passing the disable logging to UL.
            LoggingInformation.LogFileDir.Length = 0;
            LoggingInformation.LogFileDir.MaximumLength = 0;
            LoggingInformation.LogFileDir.Buffer = NULL;
            LoggingInformation.LogFormat = HttpLoggingTypeMaximum;
            LoggingInformation.LogPeriod = 0;
            LoggingInformation.LogFileTruncateSize = 0;
            LoggingInformation.LogExtFileFlags = 0;
            LoggingInformation.LocaltimeRollover = FALSE;
            LoggingInformation.SelectiveLogging = HttpSelectiveLoggingMaximum;
        }

        Win32Error = HttpSetConfigGroupInformation(
                            GetWebAdminService()->GetUlAndWorkerManager()->GetUlControlChannel(),
                                                                // control channel
                            m_UlConfigGroupId,                  // config group ID
                            HttpConfigGroupLogInformation,      // information class
                            &LoggingInformation,                // data to set
                            sizeof( LoggingInformation )        // data length
                            );

        if ( Win32Error != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32( Win32Error );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Setting config group logging information failed\n"
                ));

            DWORD dwMessageId;

            switch  ( Win32Error  )
            {
                case ( ERROR_PATH_NOT_FOUND ):
                    //
                    // If we got back this error, then we assume that the problem was that the drive
                    // letter mapped to a network path, and could not be used.  Http.sys does not
                    // support working with mapped drives.
                    //
                    dwMessageId = WAS_EVENT_LOG_DIRECTORY_MAPPED_NETWORK_DRIVE;
                break;

                case ( ERROR_INVALID_NAME ):
                case ( ERROR_BAD_NETPATH ):
                    //
                    // UNC machine or share name is not valid.
                    //
                    dwMessageId = WAS_EVENT_LOG_DIRECTORY_MACHINE_OR_SHARE_INVALID;
                break;

                case ( ERROR_ACCESS_DENIED ):
                    //
                    // The account that the server is running under does not
                    // have access to the particular network share.
                    //
                    dwMessageId = WAS_EVENT_LOG_DIRECTORY_ACCESS_DENIED;
                break;

                case ( ERROR_NOT_SUPPORTED ):
                    // 
                    // The log file directory name is not fully qualified, 
                    // for instance, it could be missing the drive letter.
                    //
                    dwMessageId = WAS_EVENT_LOG_DIRECTORY_NOT_FULLY_QUALIFIED;
                break;

                default:
                    //
                    // Something was wrong with the logging properties, but
                    // we are not sure what.
                    //
                    dwMessageId = WAS_EVENT_LOGGING_FAILURE;
            }

            //
            // Log an event: Configuring the log information in UL failed..
            //

            const WCHAR * EventLogStrings[1];
            WCHAR StringizedSiteId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
            _ultow(m_ApplicationId.VirtualSiteId, StringizedSiteId, 10);

            EventLogStrings[0] = StringizedSiteId;

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    dwMessageId,         // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    hr                                      // error code
                    );


            // press on ...
            hr = S_OK;

        }
        else
        {
            // Remember if UL is now logging. 
            if (LoggingInformation.LoggingEnabled)
            {
                m_ULLogging = TRUE;
            }
            else
            {
                m_ULLogging = FALSE;
            }

        }

    }

}   // APPLICATION::RegisterLoggingProperties

/***************************************************************************++

Routine Description:

    Tell HTTP.SYS what the SiteId for this application is.
    This actually declares this application as the root application.

Arguments:

    None.

Return Value:

    HRESULT - Failure will be handled and
              logged in CreateApplication.

--***************************************************************************/

HRESULT
APPLICATION::RegisterSiteIdWithHttpSys(
    )
{
    DWORD Win32Error = 0;

    DBG_ASSERT (  m_UlConfigGroupId != HTTP_NULL_ID );

    HTTP_CONFIG_GROUP_SITE SiteConfig;

    SiteConfig.SiteId = m_ApplicationId.VirtualSiteId;

    Win32Error = HttpSetConfigGroupInformation(
                    GetWebAdminService()->GetUlAndWorkerManager()->GetUlControlChannel(),
                                                        // control channel
                    m_UlConfigGroupId,                  // config group ID
                    HttpConfigGroupSiteInformation,     // information class
                    &SiteConfig,                        // data to set
                    sizeof( SiteConfig )                // data length
                    );

    if ( Win32Error != NO_ERROR )
    {
        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32( Win32Error ),
            "Setting site id information in http.sys failed\n"
            ));
    }

    return S_OK;

}   // APPLICATION::RegisterSiteIdWithHttpSys

/***************************************************************************++

Routine Description:

    Tell HTTP.SYS what the max connections value is for the site.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
APPLICATION::ConfigureMaxConnections(
    )
{  
    DBG_ASSERT ( m_pVirtualSite );

    DBG_ASSERT (  m_UlConfigGroupId != HTTP_NULL_ID );

    HTTP_CONFIG_GROUP_MAX_CONNECTIONS connections;

    connections.Flags.Present = 1;
    connections.MaxConnections = m_pVirtualSite->GetMaxConnections();

    DWORD Win32Error = 0;

    IF_DEBUG ( WEB_ADMIN_SERVICE_WMS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Setting max connections for site %d application '%S' to %d \n",
                    m_ApplicationId.VirtualSiteId, 
                    m_ApplicationId.ApplicationUrl.QueryStr(),
                    connections.MaxConnections ));
    }

    Win32Error = HttpSetConfigGroupInformation(
                    GetWebAdminService()->GetUlAndWorkerManager()->GetUlControlChannel(),
                                                        // control channel
                    m_UlConfigGroupId,                  // config group ID
                    HttpConfigGroupConnectionInformation,     // information class
                    &connections,                        // data to set
                    sizeof( connections )                // data length
                    );

    if ( Win32Error != NO_ERROR )
    {
        const WCHAR * EventLogStrings[1];
        WCHAR StringizedSiteId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];

        HRESULT hr = HRESULT_FROM_WIN32( Win32Error );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Setting connection max information in http.sys failed\n"
            ));

        _ultow(m_ApplicationId.VirtualSiteId, StringizedSiteId, 10);
        EventLogStrings[0] = StringizedSiteId;

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_SET_SITE_MAX_CONNECTIONS_FAILED,   // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                hr                                      // error code
                );

        // need to press on now that we logged the error.
        Win32Error = ERROR_SUCCESS;
        hr = S_OK;

    }

}   // APPLICATION::ConfigureMaxConnections

/***************************************************************************++

Routine Description:

    Tell HTTP.SYS what the Max Bandwidth for this application is.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
APPLICATION::ConfigureMaxBandwidth(
    )
{
     
    DBG_ASSERT ( m_pVirtualSite );

    DBG_ASSERT (  m_UlConfigGroupId != HTTP_NULL_ID );

    HTTP_CONFIG_GROUP_MAX_BANDWIDTH bandwidth;

    bandwidth.Flags.Present = 1;
    bandwidth.MaxBandwidth = m_pVirtualSite->GetMaxBandwidth();

    DWORD Win32Error = 0;

    Win32Error = HttpSetConfigGroupInformation(
                    GetWebAdminService()->GetUlAndWorkerManager()->GetUlControlChannel(),
                                                        // control channel
                    m_UlConfigGroupId,                  // config group ID
                    HttpConfigGroupBandwidthInformation,     // information class
                    &bandwidth,                        // data to set
                    sizeof( bandwidth )                // data length
                    );

    if ( Win32Error != NO_ERROR )
    {
        const WCHAR * EventLogStrings[1];
        WCHAR StringizedSiteId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];

        _ultow(m_ApplicationId.VirtualSiteId, StringizedSiteId, 10);

        EventLogStrings[0] = StringizedSiteId;

        if ( Win32Error == ERROR_INVALID_FUNCTION )
        {

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_HTTP_PSCHED_NOT_INSTALLED_SITE,              // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    0                                       // error code
                    );

            DPERROR((
                DBG_CONTEXT,
                HRESULT_FROM_WIN32( Win32Error ),
                "Bandwidth failed because PSCHED is not installed for site %d\n",
                m_ApplicationId.VirtualSiteId
                ));
        }
        else
        {

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_HTTP_CONFIG_GROUP_BANDWIDTH_SETTING_FAILED,                // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),           // count of strings
                    EventLogStrings,                                               // array of strings
                    HRESULT_FROM_WIN32( Win32Error )                               // error code
                    );

            DPERROR((
                DBG_CONTEXT,
                HRESULT_FROM_WIN32( Win32Error ),
                "Changing config groups max bandwidth failed on site %d\n",
                m_ApplicationId.VirtualSiteId
                ));
        }
    }

}   // APPLICATION::ConfigureMaxBandwidth

/***************************************************************************++

Routine Description:

    Tell HTTP.SYS the ConnectionTimeout for this application.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
APPLICATION::ConfigureConnectionTimeout(
    )
{
     
    DBG_ASSERT ( m_pVirtualSite );
    DBG_ASSERT (  m_UlConfigGroupId != HTTP_NULL_ID );

    DWORD ConnectionTimeout = m_pVirtualSite->GetConnectionTimeout();
    DWORD Win32Error = 0;

    Win32Error = HttpSetConfigGroupInformation(
                    GetWebAdminService()->GetUlAndWorkerManager()->GetUlControlChannel(),
                                                        // control channel
                    m_UlConfigGroupId,                  // config group ID
                    HttpConfigGroupConnectionTimeoutInformation,     // information class
                    &ConnectionTimeout,                        // data to set
                    sizeof( ConnectionTimeout )                // data length
                    );

    if ( Win32Error != NO_ERROR )
    {
        const WCHAR * EventLogStrings[1];
        WCHAR StringizedSiteId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];

        HRESULT hr = HRESULT_FROM_WIN32( Win32Error );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Setting connection timeout information in http.sys failed\n"
            ));

        _ultow(m_ApplicationId.VirtualSiteId, StringizedSiteId, 10);
        EventLogStrings[0] = StringizedSiteId;

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_SET_SITE_CONNECTION_TIMEOUT_FAILED,   // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                hr                                      // error code
                );

        // need to press on now that we logged the error.
        Win32Error = ERROR_SUCCESS;
        hr = S_OK;
    }

}   // APPLICATION::ConfigureConnectionTimeout
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\app_pool.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    app_pool.h

Abstract:

    The IIS web admin service app pool class definition.

Author:

    Seth Pollack (sethp)        01-Oct-1998

Revision History:

--*/


#ifndef _APP_POOL_H_
#define _APP_POOL_H_



//
// forward references
//

class WORKER_PROCESS;
class UL_AND_WORKER_MANAGER;
class APP_POOL_CONFIG_STORE;


//
// common #defines
//

#define APP_POOL_SIGNATURE       CREATE_SIGNATURE( 'APOL' )
#define APP_POOL_SIGNATURE_FREED CREATE_SIGNATURE( 'apoX' )

#define wszDEFAULT_APP_POOL  L"DefaultAppPool"

//
// structs, enums, etc.
//

// app pool user types
enum APP_POOL_USER_TYPE
{
    //
    // The app pool runs as local system.
    //
    LocalSystemAppPoolUserType = 0,

    // 
    // The app pool runs as local service
    //
    LocalServiceAppPoolUserType,

    //
    // The app pool runs as network service
    //
    NetworkServiceAppPoolUserType,

    //
    // The app pool runs as the specified user
    //
    SpecificUserAppPoolUserType

};

// app pool states
enum APP_POOL_STATE
{

    //
    // The object is not yet initialized.
    //
    UninitializedAppPoolState = 1,

    //
    // The app pool is running normally.
    //
    RunningAppPoolState,

    //
    // The app pool has been disabled
    // 
    DisabledAppPoolState,

    //
    // The app pool is shutting down. It may be waiting for it's 
    // worker processes to shut down too. 
    //
    ShutdownPendingAppPoolState,

    //
    // This object instance can go away as soon as it's reference 
    // count hits zero.
    //
    DeletePendingAppPoolState,

};


// reasons to start a worker process
enum WORKER_PROCESS_START_REASON
{

    //
    // Starting because of a demand start notification from UL.
    //
    DemandStartWorkerProcessStartReason = 1,

    //
    // Starting as a replacement for an another running worker process.
    //
    ReplaceWorkerProcessStartReason,

};


// APP_POOL work items
enum APP_POOL_WORK_ITEM
{

    //
    // Process a request from UL to demand start a new worker process.
    //
    DemandStartAppPoolWorkItem = 1
   
};

//
// prototypes
//

class APP_POOL
    : public WORK_DISPATCH
{

public:

    APP_POOL(
        );

    virtual
    ~APP_POOL(
        );

    virtual
    VOID
    Reference(
        );

    virtual
    VOID
    Dereference(
        );

    virtual
    HRESULT
    ExecuteWorkItem(
        IN const WORK_ITEM * pWorkItem
        );

    HRESULT
    Initialize(
        IN APP_POOL_DATA_OBJECT* pAppPoolObject 
        );

    HRESULT
    SetConfiguration(
        IN APP_POOL_DATA_OBJECT* pAppPoolObject,
        IN BOOL fInitializing       
        );

    inline
    VOID
    MarkAsInAppPoolTable(
        )
    { m_InAppPoolTable = TRUE; }

    inline
    VOID
    MarkAsNotInAppPoolTable(
        )
    { m_InAppPoolTable = FALSE; }

    inline
    BOOL
    IsInAppPoolTable(
        )
        const
    { return m_InAppPoolTable; }

    inline
    LPCWSTR
    GetAppPoolId(
        )
        const
    {
        return m_AppPoolId.QueryStr(); 
    }

    inline
    HANDLE
    GetAppPoolHandle(
        )
        const
    { return m_AppPoolHandle; }


    VOID
    AssociateApplication(
        IN APPLICATION * pApplication
        );

    VOID
    DissociateApplication(
        IN APPLICATION * pApplication
        );

    VOID
    ReportWorkerProcessFailure(
        BOOL  ShutdownPoolRegardless
        );

    HRESULT
    RequestReplacementWorkerProcess(
        IN WORKER_PROCESS * pWorkerProcessToReplace
        );

    VOID
    AddWorkerProcessToJobObject(
        WORKER_PROCESS* pWorkerProcess
        );


    VOID
    WorkerProcessStartupAttemptDone(
        IN WORKER_PROCESS_START_REASON StartReason
        );

    VOID
    RemoveWorkerProcessFromList(
        IN WORKER_PROCESS * pWorkerProcess
        );

    DWORD
    GetRecycleLoggingFlags(
        );

    VOID
    Shutdown(
        );

    DWORD
    RequestCounters(
        );

    VOID
    ResetAllWorkerProcessPerfCounterState(
        );

    VOID
    Terminate(
        );

    inline
    PLIST_ENTRY
    GetDeleteListEntry(
        )
    { return &m_DeleteListEntry; }

    static
    APP_POOL *
    AppPoolFromDeleteListEntry(
        IN const LIST_ENTRY * pDeleteListEntry
        );

    VOID
    WaitForDemandStartIfNeeded(
        );

    HRESULT
    DemandStartInBackwardCompatibilityMode(
        );

    VOID
    DisableAppPool(
        IN HTTP_APP_POOL_ENABLED_STATE DisabledReason
        );

    VOID
    EnableAppPool(
        BOOL DirectCommand
        );

    HRESULT
    RecycleWorkerProcesses(
        DWORD MessageId
        );

    VOID
    ProcessStateChangeCommand(
        IN DWORD Command,
        IN BOOL DirectCommand,
        IN HTTP_APP_POOL_ENABLED_STATE DisabledReason
        );

    BOOL
    IsAppPoolRunning(
        )
    {   return ( m_State == RunningAppPoolState ); }

    VOID
    RecordState(
        );

    VOID
    SetHrForDeletion(
        IN HRESULT hrToReport
        )
    {  m_hrForDeletion = hrToReport; }

#if DBG
    VOID
    DebugDump(
        );
#endif  // DBG

private:

    VOID
    HandleJobObjectChanges(
        IN APP_POOL_CONFIG_STORE* pNewAppPoolConfig,
        OUT BOOL* pJobObjectChangedBetweenEnabledAndDisabled
        );

    VOID
    ResetAppPoolAccess(
        IN ACCESS_MODE AccessMode,
        IN APP_POOL_CONFIG_STORE* pConfig
        );

    VOID
    WaitForDemandStart(
        );

    HRESULT
    DemandStartWorkItem(
        );

    BOOL
    IsOkToCreateWorkerProcess(
        )
        const;

    BOOL
    IsOkToReplaceWorkerProcess(
        )
        const;

    ULONG
    GetCountOfProcessesGoingAwaySoon(
        )
        const;

    HRESULT
    CreateWorkerProcess(
        IN WORKER_PROCESS_START_REASON StartReason,
        IN WORKER_PROCESS * pWorkerProcessToReplace OPTIONAL
        );

    VOID
    HandleConfigChangeAffectingWorkerProcesses(
        );


    VOID
    ShutdownAllWorkerProcesses(
        );

    VOID
    ReplaceAllWorkerProcesses(
        DWORD MessageId
        );


    VOID
    CheckIfShutdownUnderwayAndNowCompleted(
        );

    VOID
    ChangeState(
        IN APP_POOL_STATE   NewState,
        IN HRESULT          Error
        );

    VOID
    RunDisableAction(
        );

    VOID 
    ResetStaggering(
        );

    DWORD m_Signature;

    LONG m_RefCount;

    // are we in the parent app pool table?
    BOOL m_InAppPoolTable;

    APP_POOL_STATE m_State;

    STRU m_AppPoolId;

    JOB_OBJECT* m_pJobObject;

    APP_POOL_CONFIG_STORE* m_pConfig;

    // UL app pool handle
    HANDLE m_AppPoolHandle;

    BOOL m_WaitingForDemandStart;

    // worker processes for this app pool
    LIST_ENTRY m_WorkerProcessListHead;
    ULONG m_WorkerProcessCount;

    // applications associated with this app pool
    LIST_ENTRY m_ApplicationListHead;
    ULONG m_ApplicationCount;

    // number of planned process rotations done
    ULONG m_TotalWorkerProcessRotations;

    // keep track of worker process failures
    ULONG m_TotalWorkerProcessFailures;
    
    // watch for flurries of failures
    ULONG m_RecentWorkerProcessFailures;
    DWORD m_RecentFailuresWindowBeganTickCount;
    
    // used for building a list of APP_POOLs to delete
    LIST_ENTRY m_DeleteListEntry;

    // hresult to report to the metabase 
    // when we write to the metabase.
    HRESULT m_hrForDeletion;

    // hresult to report to the metabase 
    // when we write to the metabase.
    HRESULT m_hrLastReported;

    // max processes that is currently in effect
    // the config information may have a newer value
    // but this is the value we honor, it only changes
    // when an app pool is Enabled 
    DWORD m_MaxProcessesToLaunch;

    // if MaxProcesses is greater than 1 then we
    // may need to stager each worker process that
    // starts up.  this keeps track of the number
    // of worker processes we have started until 
    // we get up to the MaxProcess Limit
    DWORD m_NumWPStartedOnWayToMaxProcess;


};  // class APP_POOL


//
// helper functions 
//

// BUGBUG: find better home for GetMultiszByteLength

DWORD 
GetMultiszByteLength(
    LPWSTR pString
    );


#endif  // _APP_POOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\app_pool_table.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    app_pool_table.h

Abstract:

    The IIS web admin service app pool table class definition.

Author:

    Seth Pollack (sethp)        01-Oct-1998

Revision History:

--*/


#ifndef _APP_POOL_TABLE_H_
#define _APP_POOL_TABLE_H_



//
// prototypes
//

class APP_POOL_TABLE
    : public CTypedHashTable< APP_POOL_TABLE, APP_POOL, const WCHAR * >
{

public:

    APP_POOL_TABLE(
        )
        : CTypedHashTable< APP_POOL_TABLE, APP_POOL, const WCHAR * >
                ( "APP_POOL_TABLE" )
    { /* do nothing*/ }

    ~APP_POOL_TABLE(
        )
    { DBG_ASSERT( Size() == 0 ); }

    static
    const WCHAR *
    ExtractKey(
        IN const APP_POOL * pAppPool
        )  
    { return pAppPool->GetAppPoolId(); }
    
    static
    DWORD
    CalcKeyHash(
        IN const WCHAR * Key
        ) 
    { return HashStringNoCase( Key ); }
    
    static
    bool
    EqualKeys(
        IN const WCHAR * Key1,
        IN const WCHAR * Key2
        )
    { 

        return ( CompareStringNoCase( Key1, Key2 ) == 0 );
    }
    
    static
    void
    AddRefRecord(
        IN APP_POOL * pAppPool,
        IN int IncrementAmount
        ) 
    { /* do nothing*/ 
        UNREFERENCED_PARAMETER( pAppPool );
        UNREFERENCED_PARAMETER( IncrementAmount );    
    }

    VOID
    Shutdown(
        );

    DWORD
    RequestCounters(
        );

    VOID
    ResetAllWorkerProcessPerfCounterState(
        );

    VOID
    Terminate(
        );

    static
    LK_ACTION
    DeleteAppPoolAction(
        IN APP_POOL * pAppPool, 
        IN VOID * pDeleteListHead
        );

    static
    LK_ACTION
    RecordPoolStatesAction(
        IN APP_POOL * pAppPool, 
        IN VOID * pfRecycleAsWell
        );


#if DBG
    VOID
    DebugDump(
        );

    static
    LK_ACTION
    DebugDumpAppPoolAction(
        IN APP_POOL * pAppPool, 
        IN VOID * pIgnored
        );
#endif  // DBG

private:

    APP_POOL_TABLE( const APP_POOL_TABLE & );
    void operator=( const APP_POOL_TABLE & );


};  // APP_POOL_TABLE



#endif  // _APP_POOL_TABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\com_registration.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    com_registration.cxx

Abstract:

    Entry points for registering and unregistering the COM pieces of
    the IIS web admin service.

Author:

    Seth Pollack (sethp)        18-Feb-2000

Revision History:

--*/



#include "precomp.h"

static const WCHAR g_szAPPID[] = L"AppID";
static const WCHAR g_szCLSID[] = L"CLSID";
static const WCHAR g_szINTERFACE[] = L"Interface";

static WCHAR * g_pwchCLSID_W3Control = NULL;
static WCHAR * g_pwchIID_W3Control = NULL;


/***************************************************************************++

Routine Description:

    Frees strings for GUIDS

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/
static
void
FreeGlobalGUIDStrings()
{
    delete [] g_pwchCLSID_W3Control;
    g_pwchCLSID_W3Control = NULL;

    delete [] g_pwchIID_W3Control;
    g_pwchIID_W3Control = NULL;

    return;
}

/***************************************************************************++

Routine Description:

    Allocates strings for GUIDS

Arguments:

    None.

Return Value:

    HRESULT - S_OK if strings allocated else E_OUTOFMEMORY;

--***************************************************************************/
static 
HRESULT
AllocateGlobalGUIDStrings()
{
    HRESULT hr = S_OK;
    int iRet;

    DBG_ASSERT(NULL == g_pwchCLSID_W3Control);
    DBG_ASSERT(NULL == g_pwchIID_W3Control);

    // get the string representation for CLSID_W3Control
    g_pwchCLSID_W3Control = new WCHAR[MAX_PATH];
    if (NULL == g_pwchCLSID_W3Control)
    {
        hr = E_OUTOFMEMORY;
        goto error_exit;
    }
    iRet = StringFromGUID2(CLSID_W3Control,         // GUID to convert
                           g_pwchCLSID_W3Control,   // storage for GUID
                           MAX_PATH                 // number of characters
                          );
    DBG_ASSERT(0 != iRet);

    // get the string representation for IID_IW3Control
    g_pwchIID_W3Control = new WCHAR[MAX_PATH];
    if (NULL == g_pwchIID_W3Control)
    {
        hr = E_OUTOFMEMORY;
        goto error_exit;
    }

    iRet = StringFromGUID2(IID_IW3Control,          // GUID to convert
                           g_pwchIID_W3Control,     // storage for GUID
                           MAX_PATH                 // number of characters
                          );
    DBG_ASSERT(0 != iRet);

    return S_OK;

error_exit:

    FreeGlobalGUIDStrings();
    return hr;
}

#pragma prefast(push)
#pragma prefast(disable:209, "Don't complain about using size of when we need byte count") 

/***************************************************************************++

Routine Description:

    Registers COM pieces. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

STDAPI
DllRegisterServer(
    )
{

    DWORD Win32Error = NO_ERROR;
    HKEY KeyHandle = NULL;
    HKEY KeyHandle2 = NULL;
    ACL LaunchAcl;
    HRESULT hr = S_OK;
    BUFFER bufSD;
    DWORD  dwBytesNeeded;
    SECURITY_DESCRIPTOR sd = {0};
    PSID    psidLocalSystem = NULL;


    // when copying and appending - use this
    STACK_STRU(struTemp, 256);

    hr = AllocateGlobalGUIDStrings();
    if (FAILED(hr))
    {
        goto exit;
    }
    
    //
    // Set the AppID key.
    //

    // create string of the form: AppID\{...}
    struTemp.Copy(g_szAPPID);
    struTemp.Append(L"\\");
    struTemp.Append(g_pwchCLSID_W3Control);

    // Security on this key is inherited from the parent key 
    // in the registry.
    Win32Error = RegCreateKeyEx(
                        HKEY_CLASSES_ROOT,
                        struTemp.QueryStr(),
                        NULL, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_ALL_ACCESS, 
                        NULL,
                        &KeyHandle, 
                        NULL
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }

    Win32Error = RegSetValueEx(
                        KeyHandle,
                        L"",
                        NULL, 
                        REG_SZ, 
                        ( BYTE * )( L"IIS W3 Control" ),
                        sizeof( L"IIS W3 Control" )
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }

    //
    // Create the LaunchPermissions property
    //

    //
    // Get a sid that represents the Administrators group.
    //
    Win32Error = AllocateAndCreateWellKnownSid( WinLocalSystemSid,
                                           &psidLocalSystem );
    if ( Win32Error != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32(Win32Error);
        goto exit;
    }

    //
    // initialize an empty acl, which will be what we want
    // to write to the registry to block all launch permissions,
    // however it doesn't seem to block local system launching so
    // we do have to be careful not to launch W3SVC when calling from inetinfo
    //
    if ( !InitializeAcl( &LaunchAcl, sizeof( LaunchAcl ), ACL_REVISION ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    if (!SetSecurityDescriptorDacl(&sd,
            TRUE,     // fDaclPresent flag
            &LaunchAcl,
            FALSE))   // not a default DACL
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    if (!SetSecurityDescriptorOwner(&sd,
            psidLocalSystem,     // fDaclPresent flag
            FALSE))   // not a default DACL
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    if (!SetSecurityDescriptorGroup(&sd,
            psidLocalSystem,      // fDaclPresent flag
            FALSE))         // not a default DACL
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }


    dwBytesNeeded = bufSD.QuerySize();

    if ( !MakeSelfRelativeSD( &sd,
                             (PSECURITY_DESCRIPTOR) bufSD.QueryPtr(),
                             &dwBytesNeeded ) )
    {
        Win32Error = GetLastError();
        if ( Win32Error != ERROR_INSUFFICIENT_BUFFER )
        {
            hr = HRESULT_FROM_WIN32(Win32Error);
            goto exit;
        }

        if ( !bufSD.Resize(dwBytesNeeded ) )
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        if ( !MakeSelfRelativeSD( &sd,
                                 (PSECURITY_DESCRIPTOR) bufSD.QueryPtr(),
                                 &dwBytesNeeded ) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }
    }

    Win32Error = RegSetValueEx(
                        KeyHandle,
                        L"LaunchPermission",
                        NULL, 
                        REG_BINARY, 
                        reinterpret_cast<BYTE *>( bufSD.QueryPtr() ),
                        dwBytesNeeded
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }
        
    
    Win32Error = RegSetValueEx(
                        KeyHandle,
                        L"LocalService",
                        NULL, 
                        REG_SZ, 
                        ( BYTE * )( WEB_ADMIN_SERVICE_NAME_W ),
                        sizeof( WEB_ADMIN_SERVICE_NAME_W )
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }

    DBG_REQUIRE( RegCloseKey( KeyHandle ) == NO_ERROR );
    KeyHandle = NULL;

    //
    // Set the CLSID key.
    //

    // create string of the form: CLSID\{....}
    struTemp.Copy(g_szCLSID);
    struTemp.Append(L"\\");
    struTemp.Append(g_pwchCLSID_W3Control);

    // inherits it's security from the CLSID key
    Win32Error = RegCreateKeyEx(
                        HKEY_CLASSES_ROOT,
                        struTemp.QueryStr(),
                        NULL, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_ALL_ACCESS, 
                        NULL,
                        &KeyHandle, 
                        NULL
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }


    Win32Error = RegSetValueEx(
                        KeyHandle,
                        L"",
                        NULL, 
                        REG_SZ, 
                        ( BYTE * )( L"IIS W3 Control" ),
                        sizeof( L"IIS W3 Control" )
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }

    Win32Error = RegSetValueEx(
                        KeyHandle,
                        L"AppID",
                        NULL, 
                        REG_SZ, 
                        ( BYTE * )( g_pwchCLSID_W3Control ),
                        (DWORD) (wcslen(g_pwchCLSID_W3Control) + 1) * sizeof( WCHAR )  // byte size of string with trailing NULL
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }

    DBG_REQUIRE( RegCloseKey( KeyHandle ) == NO_ERROR );
    KeyHandle = NULL;


    //
    // Register the interface proxy/stub.
    //

    // create string of form: CLSID\{...}
    struTemp.Copy(g_szCLSID);
    struTemp.Append(L"\\");
    struTemp.Append(g_pwchIID_W3Control);

    Win32Error = RegCreateKeyEx(
                        HKEY_CLASSES_ROOT,
                        struTemp.QueryStr(),
                        NULL, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_ALL_ACCESS, 
                        NULL,
                        &KeyHandle, 
                        NULL
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }

    Win32Error = RegSetValueEx(
                        KeyHandle,
                        L"",
                        NULL, 
                        REG_SZ, 
                        ( BYTE * )( L"IIS W3 Control Interface ProxyStub" ),
                        sizeof( L"IIS W3 Control Interface ProxyStub" )
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }


    Win32Error = RegCreateKeyEx(
                        KeyHandle,
                        L"InprocServer32",
                        NULL, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_ALL_ACCESS, 
                        NULL,
                        &KeyHandle2, 
                        NULL
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }

    Win32Error = RegSetValueEx(
                        KeyHandle2,
                        L"",
                        NULL, 
                        REG_SZ, 
                        ( BYTE * )( L"inetsrv\\w3ctrlps.dll" ),
                        sizeof( L"inetsrv\\w3ctrlps.dll" )
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }


    Win32Error = RegSetValueEx(
                        KeyHandle2,
                        L"ThreadingModel",
                        NULL, 
                        REG_SZ, 
                        ( BYTE * )( L"Both" ),
                        sizeof( L"Both" )
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }


    DBG_REQUIRE( RegCloseKey( KeyHandle2 ) == NO_ERROR );
    KeyHandle2 = NULL;

    DBG_REQUIRE( RegCloseKey( KeyHandle ) == NO_ERROR );
    KeyHandle = NULL;


    //
    // Register the interface.
    //

    // create a string of the form: Interface\{...}
    struTemp.Copy(g_szINTERFACE);
    struTemp.Append(L"\\");
    struTemp.Append(g_pwchIID_W3Control);

    Win32Error = RegCreateKeyEx(
                        HKEY_CLASSES_ROOT,
                        struTemp.QueryStr(),
                        NULL, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_ALL_ACCESS, 
                        NULL,
                        &KeyHandle, 
                        NULL
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }

    Win32Error = RegSetValueEx(
                        KeyHandle,
                        L"",
                        NULL, 
                        REG_SZ, 
                        ( BYTE * )( L"IW3Control" ),
                        sizeof( L"IW3Control" )
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }


    Win32Error = RegCreateKeyEx(
                        KeyHandle,
                        L"ProxyStubClsid32",
                        NULL, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_ALL_ACCESS, 
                        NULL,
                        &KeyHandle2, 
                        NULL
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }

    Win32Error = RegSetValueEx(
                        KeyHandle2,
                        L"",
                        NULL, 
                        REG_SZ, 
                        ( BYTE * )g_pwchIID_W3Control,
                        (DWORD) (wcslen(g_pwchIID_W3Control) + 1) * sizeof( WCHAR ) // byte size of string with trailing NULL
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
        goto exit;
    }


    DBG_REQUIRE( RegCloseKey( KeyHandle2 ) == NO_ERROR );
    KeyHandle2 = NULL;

    DBG_REQUIRE( RegCloseKey( KeyHandle ) == NO_ERROR );
    KeyHandle = NULL;


exit:

    FreeWellKnownSid(&psidLocalSystem);

    if ( FAILED( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "DllRegisterServer failed\n"
            ));
    }


    if ( KeyHandle != NULL )
    {
        DBG_REQUIRE( RegCloseKey( KeyHandle ) == NO_ERROR );
        KeyHandle = NULL;
    }

    if ( KeyHandle2 != NULL )
    {
        DBG_REQUIRE( RegCloseKey( KeyHandle2 ) == NO_ERROR );
        KeyHandle2 = NULL;
    }

    FreeGlobalGUIDStrings();

    return hr;

}   // DllRegisterServer

#pragma prefast(pop)


/***************************************************************************++

Routine Description:

    Unregisters COM pieces. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

STDAPI
DllUnregisterServer(
    )
{

    HRESULT hr = S_OK;

    // when copying and appending - use this buffer 
    STACK_STRU(struTemp, 256);
    STACK_STRU(struTemp2, 256);

    hr = AllocateGlobalGUIDStrings();
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Delete AppID.
    //

    // create string of the form: AppID\{...}
    struTemp.Copy(g_szAPPID);
    struTemp.Append(L"\\");
    struTemp.Append(g_pwchCLSID_W3Control);

    DBG_REQUIRE( RegDeleteKey( HKEY_CLASSES_ROOT, struTemp.QueryStr() ) == NO_ERROR );

    //
    // Delete CLSID.
    //

    // create string of the form: CLSID\{....}
    struTemp.Copy(g_szCLSID);
    struTemp.Append(L"\\");
    struTemp.Append(g_pwchCLSID_W3Control);

    DBG_REQUIRE( RegDeleteKey( HKEY_CLASSES_ROOT, struTemp.QueryStr() ) == NO_ERROR );


    //
    // Delete the interface proxy/stub.
    //

    // create string of form: CLSID\{...}
    struTemp.Copy(g_szCLSID);
    struTemp.Append(L"\\");
    struTemp.Append(g_pwchIID_W3Control);

    // need to delete the sub key's first
    struTemp2.Copy(struTemp.QueryStr());
    struTemp2.Append(L"\\");
    struTemp2.Append(L"InprocServer32");

    // first delete the sub key.
    DBG_REQUIRE( RegDeleteKey( HKEY_CLASSES_ROOT, struTemp2.QueryStr() ) == NO_ERROR );

    // then delete the top key
    DBG_REQUIRE( RegDeleteKey( HKEY_CLASSES_ROOT, struTemp.QueryStr() ) == NO_ERROR );


    //
    // Delete the interface.
    //

    // create a string of the form: Interface\{...}
    struTemp.Copy(g_szINTERFACE);
    struTemp.Append(L"\\");
    struTemp.Append(g_pwchIID_W3Control);

    // need to delete the sub key's first
    struTemp2.Copy(struTemp.QueryStr());
    struTemp2.Append(L"\\");
    struTemp2.Append(L"ProxyStubClsid32");

    // first delete the sub key.
    DBG_REQUIRE( RegDeleteKey( HKEY_CLASSES_ROOT, struTemp2.QueryStr() ) == NO_ERROR );
    
    // then delete the top key
    DBG_REQUIRE( RegDeleteKey( HKEY_CLASSES_ROOT, struTemp.QueryStr() ) == NO_ERROR );


    FreeGlobalGUIDStrings();
    return hr;

}   // DllUnregisterServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\changeprocessor.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    changeprocessor.cxx

Abstract:

    These routines handle the pre processing of change
    notifications before they are passed to the main thread.

Author:

    Emily Kruglick (emilyk)        28-May-2001

Revision History:

--*/



#include  "precomp.h"


/***************************************************************************++

Routine Description:

    Constructor for the CHANGE_PROCESSOR class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CHANGE_PROCESSOR::CHANGE_PROCESSOR(
    )
{

    //
    // Set the initial reference count to 1, in order to represent the
    // reference owned by the creator of this instance.
    //

    m_RefCount = 1;

    m_ExitWorkLoop = FALSE;

    m_hBlockEvent = NULL;

    m_State = UninitializedChangeProcessorState;

    m_Signature = CHANGE_PROCESSOR_SIGNATURE;

}   // CHANGE_PROCESSOR::CHANGE_PROCESSOR



/***************************************************************************++

Routine Description:

    Destructor for the CHANGE_PROCESSOR class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CHANGE_PROCESSOR::~CHANGE_PROCESSOR(
    )
{

    DBG_ASSERT( m_Signature == CHANGE_PROCESSOR_SIGNATURE );

    m_Signature = CHANGE_PROCESSOR_SIGNATURE_FREED;

    DBG_ASSERT ( m_State == ShutDownChangeProcessorState );

    DBG_ASSERT ( m_hBlockEvent == NULL );

    DBG_ASSERT ( m_RefCount == 0 );



}   // CHANGE_PROCESSOR_CHANGE::~CHANGE_PROCESSOR_CHANGE



/***************************************************************************++

Routine Description:

    Increment the reference count for this object. Note that this method must
    be thread safe, and must not be able to fail.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
CHANGE_PROCESSOR::Reference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedIncrement( &m_RefCount );


    //
    // The reference count should never have been less than zero; and
    // furthermore once it has hit zero it should never bounce back up;
    // given these conditions, it better be greater than one now.
    //
    
    DBG_ASSERT( NewRefCount > 1 );


    return;

}   // CHANGE_PROCESSOR::Reference



/***************************************************************************++

Routine Description:

    Decrement the reference count for this object, and cleanup if the count
    hits zero. Note that this method must be thread safe, and must not be
    able to fail.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
CHANGE_PROCESSOR::Dereference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedDecrement( &m_RefCount );

    // ref count should never go negative
    DBG_ASSERT( NewRefCount >= 0 );

    if ( NewRefCount == 0 )
    {
        // time to go away

        IF_DEBUG( WEB_ADMIN_SERVICE_REFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Reference count has hit zero in CHANGE_PROCESSOR instance, deleting (ptr: %p)\n",
                this
                ));
        }

        delete this;

    }

    return;

}   // CHANGE_PROCESSOR::Dereference



/***************************************************************************++

Routine Description:

    Execute a work item on this object.

Arguments:

    pWorkItem - The work item to execute.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CHANGE_PROCESSOR::ExecuteWorkItem(
    IN const WORK_ITEM * pWorkItem
    )
{

    //
    // Either we are on the config thread, or we will be ignoring the work items because
    // we are actually just trying to shutdown the config thread.  This is special cased
    // because we are cleaning up the queue on the main thread now.
    //
    DBG_ASSERT( ON_CONFIG_WORKER_THREAD || ( m_State == ShuttingDownChangeProcessorState ) );
    DBG_ASSERT( pWorkItem != NULL );


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        CHKINFO((
            DBG_CONTEXT,
            "Executing work item with serial number: %lu in CHANGE_PROCESSOR (ptr: %p) with operation: %p\n",
            pWorkItem->GetSerialNumber(),
            this,
            pWorkItem->GetOpCode()
            ));
    }

    if ( m_State == RunningChangeProcessorState )
    {

        switch ( pWorkItem->GetOpCode() )
        {

            case ExitChangeThreadItemWorkItem:

                // don't need to do anything, just exit
                // however we need this call to wake up
                // this thread if no changes are happening.

            break;  

            case RehookNotificationsChangeThreadItemWorkItem:

                RehookChangeNotifications();
            break;

            default:

                // invalid work item!
                DBG_ASSERT( FALSE );
        
            break;

        }

    }
    else
    {
        // if we aren't running but have been asked to execute then
        // I can only assume that we are in the shutting down phase
        // all other phases should not get us here.
        DBG_ASSERT ( m_State == ShuttingDownChangeProcessorState );

        // if it is the shutdown phase we will ignore these changes.
    }

    return S_OK;

}   // CHANGE_PROCESSOR::ExecuteWorkItem

/***************************************************************************++

Routine Description:

    Initialize the change processor so that both threads can use
    the queueing mechanism.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
CHANGE_PROCESSOR::Initialize(
    )
{
    HRESULT hr = S_OK;

    DBG_ASSERT ( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT ( m_State == UninitializedChangeProcessorState );

    hr = m_ConfigWorkQueue.Initialize();
    if ( FAILED( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't initialize config work queue\n"
            ));

        goto exit;

    }

    DBG_ASSERT ( m_hBlockEvent == NULL );

    m_hBlockEvent = CreateEvent( NULL,   // SD
                                    TRUE,   // must call reset
                                    FALSE,  // initially not signaled
                                    NULL ); // not named 

    if ( m_hBlockEvent == NULL )
    {
        hr = GetLastError();

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Failed to initialize blocking event\n"
            ));

        // need to stop the work queue if we are
        // not going to succeed in initialization
        m_ConfigWorkQueue.Terminate();

        goto exit;

    }

    m_State = InitializedChangeProcessorState;

exit:

    // if we fail here for any reason, we need to make sure that
    // the event handle still equals null.  WAS will guarantee that
    // it will call the SetEvent for every path that succeeds in 
    // initializing this object, but if initalization fails the handle
    // had better be NULL or else we will block waiting for the event
    // handle to signal in an assert and never shutdown.

    DBG_ASSERT ( ( FAILED ( hr ) && m_hBlockEvent == NULL ) ||
                 ( SUCCEEDED ( hr ) && m_hBlockEvent != NULL ) );

    return hr;

}

/***************************************************************************++

Routine Description:

    Terminates the change processor 

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/
VOID
CHANGE_PROCESSOR::Terminate(
    )
{

    DBG_ASSERT ( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT ( m_State == ShuttingDownChangeProcessorState ||
                 m_State == InitializedChangeProcessorState );

    //
    // Shut down the work queue. This must be done after all things which can 
    // generate new work items are shut down, as this operation will free any 
    // remaining work items. This includes for example work items that were 
    // pending on real async i/o; in such cases the i/o must be canceled first, 
    // in order to complete the i/o and release the work item, so that we can 
    // then clean it up here.
    //
    // Once this has completed, we are also guaranteed that no more work items
    // can be created. 
    //
    m_ConfigWorkQueue.Terminate();

    if ( m_hBlockEvent )
    {
        CloseHandle( m_hBlockEvent );
        m_hBlockEvent = NULL;
    }

    // we have completed shutdown as of now.
    m_State = ShutDownChangeProcessorState;

}

/***************************************************************************++

Routine Description:

    Starts the notification work queue. 

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/
VOID
CHANGE_PROCESSOR::RunNotificationWorkQueue(
    )
{

    // Verify that we are on the secondary thread,
    // this routine is only allowed there.
    DBG_ASSERT ( ON_CONFIG_WORKER_THREAD );

    DBG_ASSERT ( m_State == InitializedChangeProcessorState );

    m_State = RunningChangeProcessorState;

    StartListeningForChangeNotifications();

    //
    // Now go ahead and loop through the items
    // on the queue.  If m_ExitWorkLoop gets set we will
    // stop listening.
    //
    while ( ! m_ExitWorkLoop )
    {
        // The work items handled on the config thread should never
        // return a failure.
        DBG_REQUIRE( m_ConfigWorkQueue.ProcessWorkItem() == S_OK );            
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Config worker thread has exited it's work loop\n"
            ));
    }

    m_State = ShuttingDownChangeProcessorState;

    GetWebAdminService()->
        GetConfigAndControlManager()->
        GetConfigManager()->
        StopListeningToMetabaseChanges();

}

/***************************************************************************++

Routine Description:

    Start listening to the change notifications of the metabase.  As part
    of starting to listen we wait for an event to be set that will tell us
    it is ok for us to start processing the notifications that may be in the
    queue.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/
VOID
CHANGE_PROCESSOR::StartListeningForChangeNotifications(
    )
{
    HRESULT hr = S_OK;
 
    DBG_ASSERT ( ON_CONFIG_WORKER_THREAD );
    
    // call the config manager to start listening for 
    // change notifications.  Note:  If this fails it
    // will have held on to the hresult on the CONFIG_MANAGER
    // object and will cause an error to be reported when we
    // signal the startup thread.
 
    hr = GetWebAdminService()->
              GetConfigAndControlManager()->
              GetConfigManager()->
              StartListeningForChangeNotifications();

    if ( FAILED ( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Start listening for change notifications failed, service will not start\n"
            ));

        // we still need to do the rest of this setup work.
        hr = S_OK;
    }   

    //
    // Ping the confige manager event that we have hooked up to change notifications
    //
    GetWebAdminService()->
      GetConfigAndControlManager()->
      GetConfigManager()->
      SignalMainThreadToContinueAfterConfigThreadInitialization();

    //
    // Block until we are done configuring the system.  At that point we can start
    // processing change notifications that we have queued.
    //
    DBG_ASSERT ( m_hBlockEvent );
    DBG_REQUIRE ( WaitForSingleObject( m_hBlockEvent, INFINITE ) == WAIT_OBJECT_0 );

}

/***************************************************************************++

Routine Description:

    Re-establishes listening to the change notifications, then asks the
    config_manager to determine if any changes have been missed.  Once done it
    allows change processing to continue as usual.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/
VOID
CHANGE_PROCESSOR::RehookChangeNotifications(
    )
{
   
    DBG_ASSERT ( ON_CONFIG_WORKER_THREAD );

    if ( m_State == RunningChangeProcessorState ) 
    {

        // The first step of the processing metabase crash
        // will be to start listening for change notifications 
        // again.
        GetWebAdminService()->
             GetConfigAndControlManager()->
             GetConfigManager()->
             ProcessMetabaseCrashOnConfigThread();
    }


}

/***************************************************************************++

Routine Description:

    Changes the flag on the worker loop so we will exit this
    thread.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/
VOID
CHANGE_PROCESSOR::RequestShutdown(
    )
{

    DBG_ASSERT ( ON_MAIN_WORKER_THREAD );

    // Unlike the main work queue, which is on it's main 
    // thread when it wants to shutdown so it only has to flip
    // the switch.  This routine is not called from it's own 
    // thread, so after fliping the switch we need to queue a 
    // work item so we will immediately pickup that we should
    // be shutting down.

    m_ExitWorkLoop = TRUE;

    DBG_ASSERT ( m_State != UninitializedChangeProcessorState &&
                 m_State != ShutDownChangeProcessorState );
    //
    // Will take it's own reference on this change object.
    //
    HRESULT hr = m_ConfigWorkQueue.GetAndQueueWorkItem(
                            this ,
                            ExitChangeThreadItemWorkItem
                            );
    if ( FAILED( hr ) )
    {
        // Issue:  Should we log here?

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't queue start listening work item\n"
            ));

    }

}

/***************************************************************************++

Routine Description:

    Queues a work item to the Config Thread to re-establish change 
    listening for change notifications.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/
VOID
CHANGE_PROCESSOR::RequestRehookNotifications(
    )
{
    DBG_ASSERT ( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT ( m_State != UninitializedChangeProcessorState &&
                 m_State != ShutDownChangeProcessorState );

    //
    // Will take it's own reference on this change object.
    //
    HRESULT hr = m_ConfigWorkQueue.GetAndQueueWorkItem(
                            this ,
                            RehookNotificationsChangeThreadItemWorkItem
                            );

    if ( FAILED( hr ) )
    {
    
        // Issue Should we log here?

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't queue rehook of change notifications\n"
            ));

    }

}

/***************************************************************************++

Routine Description:

    Set the blocking event, which allows changes to be processed.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
CHANGE_PROCESSOR::SetBlockingEvent(
    )
{
    HRESULT hr = S_OK;

    DBG_ASSERT ( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT ( m_hBlockEvent != NULL );

    if ( !SetEvent( m_hBlockEvent ) )
    {
        hr = GetLastError();

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Failed to set blocking event\n"
            ));
    }

    return hr;
}

/***************************************************************************++

Routine Description:

    Queues a metabase change notification to the config thread to handle
    figuring out what to do with the change notification.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/
VOID
CHANGE_PROCESSOR::StartMBChangeItem(
    DWORD               dwMDNumElements,
    MD_CHANGE_OBJECT    pcoChangeList[]
    )
{
    DBG_ASSERT ( !ON_MAIN_WORKER_THREAD );
    DBG_ASSERT ( !ON_CONFIG_WORKER_THREAD );

    DBG_ASSERT ( m_State != UninitializedChangeProcessorState &&
                 m_State != ShutDownChangeProcessorState );

    HRESULT hr = S_OK;

    if ( pcoChangeList == NULL )
    {
        return;
    }

    MB_CHANGE_ITEM* pChangeItem = new MB_CHANGE_ITEM();
    if ( pChangeItem == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating memory failed\n"
            ));

        goto exit;
    }

    DumpMetabaseChange( dwMDNumElements,
                        pcoChangeList );

    //
    // Copy in the metabase change information
    //
    hr = pChangeItem->Initialize(dwMDNumElements,
                                 pcoChangeList );
    if ( FAILED ( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Failed to initialize the mb change item\n"
            ));

        goto exit;
    }

    //
    // Will take it's own reference on this change object.
    //
    hr = m_ConfigWorkQueue.GetAndQueueWorkItem(
                            pChangeItem,
                            ProcessMBChangeItemWorkItem
                            );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't queue change notification work item\n"
            ));

        goto exit;
    }

exit:
 
    if ( pChangeItem )
    {
        pChangeItem->Dereference();
        pChangeItem = NULL;
    }

    if ( FAILED ( hr ) )
    {
        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_WMS_FAILED_TO_COPY_CHANGE_NOT,       // message id
                0,           // count of strings
                NULL,        // array of strings
                hr           // error code
                );
    }

}


/***************************************************************************++

Routine Description:

    Dequeues the next work item and checks to see if we care about it, if we
    don't it will continue looping until we don't get a work item or we do care
    about the work item.

Arguments:

    DWORD               dwMDNumElements,
    MD_CHANGE_OBJECT    pcoChangeList[]

Return Value:

    VOID

--***************************************************************************/
VOID
CHANGE_PROCESSOR::DropAllUninterestingMBChanges(
    DWORD               dwMDNumElements,
    MD_CHANGE_OBJECT    pcoChangeList[]
    )
{
    DBG_ASSERT ( ON_CONFIG_WORKER_THREAD );
    DBG_ASSERT ( m_State == RunningChangeProcessorState );

    HRESULT hr = S_OK;
    BOOL fIgnoreNewItem = FALSE;
    WORK_ITEM* pWorkItem = NULL;
    WORK_DISPATCH* pDispatch = NULL;

    // Rule #1:  Only skip if we are looking at change notifications
    //           that have only one element.
    if ( dwMDNumElements != 1 )
    {
        return;
    }

    // Rule #2:  Only skip if we are on just an insert or a set data
    if ( pcoChangeList[0].dwMDChangeType != MD_CHANGE_TYPE_SET_DATA &&
         pcoChangeList[0].dwMDChangeType != MD_CHANGE_TYPE_ADD_OBJECT &&
         pcoChangeList[0].dwMDChangeType != ( MD_CHANGE_TYPE_SET_DATA | MD_CHANGE_TYPE_ADD_OBJECT ) )
    {
        return;
    }

    //
    // Note, the life of this work item is still owned by the queue,
    // we are just getting to peak at it.
    //
    do
    {
        fIgnoreNewItem = FALSE;

        hr = m_ConfigWorkQueue.AdvancePeakWorkItem ( &pWorkItem );
        if ( FAILED ( hr ) )
        {
            DPERROR((
                DBG_CONTEXT,
                hr,
                "Failed getting an advanced peak at the next work item\n"
                ));

            // we don't really worry about the failure here.
            // we will deal with getting the next item next time.
            return;
        }

        if ( pWorkItem )
        {
            pDispatch = pWorkItem->QueryWorkDispatchPointer();
            if ( pDispatch->IsMBChangeItem() )
            {
                if ( pWorkItem->GetOpCode() == ProcessMBChangeItemWorkItem )
                {
                    MB_CHANGE_ITEM* pMBChangeItem = ( MB_CHANGE_ITEM* ) pDispatch ;
                    DBG_ASSERT ( pMBChangeItem->CheckSignature() );

                    if ( pMBChangeItem->CanIgnoreWorkItem( pcoChangeList[0].pszMDPath ) )
                    {
                        m_ConfigWorkQueue.DropAdvancedWorkItem();
                        fIgnoreNewItem = TRUE;
                    }
                }
            }

            pWorkItem = NULL;
        }

    } while ( fIgnoreNewItem );

}

/***************************************************************************++

Routine Description:

    Dumps the metabase change notifications for debugging

Arguments:

    IN DWORD               dwMDNumElements,
    IN MD_CHANGE_OBJECT    pcoChangeList[]

Return Value:

    VOID

--***************************************************************************/
VOID 
DumpMetabaseChange ( 
    IN DWORD               dwMDNumElements,
    IN MD_CHANGE_OBJECT    pcoChangeList[]

    )
{

    static DWORD NumChangeNot = 0;

    IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
    {

        NumChangeNot++;

        DBGPRINTF((
            DBG_CONTEXT, 
            "\n ------------  Dumping Change notification %d, Num Changes %d, ----------------\n",
            NumChangeNot,
            dwMDNumElements));

        for ( DWORD i = 0; i < dwMDNumElements; i++ )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Path = '%S', Change Type = %d, Number columns affected = %d\n",
                pcoChangeList[i].pszMDPath,
                pcoChangeList[i].dwMDChangeType,
                pcoChangeList[i].dwMDNumDataIDs));

            for ( DWORD j = 0; j < pcoChangeList[i].dwMDNumDataIDs; j++ )
            {
                DBGPRINTF((
                    DBG_CONTEXT, 
                    "       Column Id %d \n",
                    pcoChangeList[i].pdwMDDataIDs[j]));
            }
        }

        DBGPRINTF((
            DBG_CONTEXT, 
            "\n ------------  Done Dumping Change Notification ------------ \n"
            ));

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\app_pool_table.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    app_pool_table.cxx

Abstract:

    This class is a hashtable which manages the set of app pools.

    Threading: Always called on the main worker thread.

Author:

    Seth Pollack (sethp)        01-Oct-1998

Revision History:

--*/



#include "precomp.h"



/***************************************************************************++

Routine Description:

    Shutdown all app pools in the table.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
APP_POOL_TABLE::Shutdown(
    )
{

    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;

    
    //
    // BUGBUG Iterating in order to clean up, remove, and delete each 
    // element of the table is difficult to do with lkhash today.
    // GeorgeRe plans to fix this eventually. For now, the alternative
    // is to iterate through the table building up in list of all the 
    // elements, and then go through the list and shutdown, remove, and
    // delete each element -- yuck!!
    //
    // Once this gets fixed, we can see if it is valuable to unify any
    // table management code between the app pool, virtual site,
    // and application tables.
    //
    
    LIST_ENTRY DeleteListHead;
    PLIST_ENTRY pDeleteListEntry = NULL;
    APP_POOL * pAppPool = NULL;

    InitializeListHead( &DeleteListHead );

    
    CountOfElementsInTable = Size();


    //
    // Note that for good form we grab the write lock since we will be 
    // modifying objects in the table (although no other thread should 
    // touch this data structure anyways).
    //
    
    SuccessCount = Apply( 
                        DeleteAppPoolAction,
                        &DeleteListHead,
                        LKL_WRITELOCK
                        );
    
    DBG_ASSERT( SuccessCount == CountOfElementsInTable );


    // now for each, shut it down
    
    while (  ! IsListEmpty( &DeleteListHead )  )
    {
    
        pDeleteListEntry = RemoveHeadList( &DeleteListHead );

        DBG_ASSERT( pDeleteListEntry != NULL );

        pAppPool = APP_POOL::AppPoolFromDeleteListEntry( pDeleteListEntry );


        //
        // Shutdown the app pool. Because each app pool is reference
        // counted, it will delete itself as soon as it's reference
        // count hits zero.
        //
        
        pAppPool->Shutdown();

    }

}   // APP_POOL_TABLE::Shutdown

/***************************************************************************++

Routine Description:

    RequestCounters from all app pools in the table.

Arguments:

    None

Return Value:

    DWORD

--***************************************************************************/

DWORD
APP_POOL_TABLE::RequestCounters(
    )
{

    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;

    // TODO:  We just copied how deletes were done, there is no need
    //        to do counters this way, we should change this for performance sake.
    
    //
    // BUGBUG Iterating in order to clean up, remove, and delete each 
    // element of the table is difficult to do with lkhash today.
    // GeorgeRe plans to fix this eventually. For now, the alternative
    // is to iterate through the table building up in list of all the 
    // elements, and then go through the list and shutdown, remove, and
    // delete each element -- yuck!!
    //
    // Once this gets fixed, we can see if it is valuable to unify any
    // table management code between the app pool, virtual site,
    // and application tables.
    //
    
    LIST_ENTRY DeleteListHead;
    PLIST_ENTRY pDeleteListEntry = NULL;
    APP_POOL * pAppPool = NULL;
    DWORD TotalProcesses = 0;

    InitializeListHead( &DeleteListHead );
    
    CountOfElementsInTable = Size();

    //
    // Note that for good form we grab the write lock since we will be 
    // modifying objects in the table (although no other thread should 
    // touch this data structure anyways).
    //
    
    SuccessCount = Apply( 
                        DeleteAppPoolAction,
                        &DeleteListHead,
                        LKL_WRITELOCK
                        );
    
    DBG_ASSERT( SuccessCount == CountOfElementsInTable );

    // now for each, shut it down
    
    while (  ! IsListEmpty( &DeleteListHead )  )
    {   
        pDeleteListEntry = RemoveHeadList( &DeleteListHead );

        DBG_ASSERT( pDeleteListEntry != NULL );

        pAppPool = APP_POOL::AppPoolFromDeleteListEntry( pDeleteListEntry );
        
        //
        // Clear out the number of processes.  Since Request Counters
        // just replaces this value, this isn't neccessary, but it is
        // clean.
        //
        TotalProcesses += pAppPool->RequestCounters();
    }

    return TotalProcesses;

}   // APP_POOL_TABLE::RequestCounters


/***************************************************************************++

Routine Description:

    Reset all worker processes's perf counter state so that they
    will accept incoming perf counter messages.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
APP_POOL_TABLE::ResetAllWorkerProcessPerfCounterState(
    )
{

    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;

    // TODO:  We just copied how deletes were done, there is no need
    //        to do counters this way, we should change this for performance sake.
    
    //
    // BUGBUG Iterating in order to clean up, remove, and delete each 
    // element of the table is difficult to do with lkhash today.
    // GeorgeRe plans to fix this eventually. For now, the alternative
    // is to iterate through the table building up in list of all the 
    // elements, and then go through the list and shutdown, remove, and
    // delete each element -- yuck!!
    //
    // Once this gets fixed, we can see if it is valuable to unify any
    // table management code between the app pool, virtual site,
    // and application tables.
    //
    
    LIST_ENTRY DeleteListHead;
    PLIST_ENTRY pDeleteListEntry = NULL;
    APP_POOL * pAppPool = NULL;

    InitializeListHead( &DeleteListHead );

    
    CountOfElementsInTable = Size();


    //
    // Note that for good form we grab the write lock since we will be 
    // modifying objects in the table (although no other thread should 
    // touch this data structure anyways).
    //
    
    SuccessCount = Apply( 
                        DeleteAppPoolAction,
                        &DeleteListHead,
                        LKL_WRITELOCK
                        );
    
    DBG_ASSERT( SuccessCount == CountOfElementsInTable );


    // now for each, shut it down
    
    while (  ! IsListEmpty( &DeleteListHead )  )
    {
    
        pDeleteListEntry = RemoveHeadList( &DeleteListHead );

        DBG_ASSERT( pDeleteListEntry != NULL );

        pAppPool = APP_POOL::AppPoolFromDeleteListEntry( pDeleteListEntry );
        
        //
        // Clear out the number of processes.  Since Request Counters
        // just replaces this value, this isn't neccessary, but it is
        // clean.
        //
        pAppPool->ResetAllWorkerProcessPerfCounterState();

    }

}   // APP_POOL_TABLE::ResetAllWorkerProcessPerfCounterState



/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities 
    which may hold a reference to this object to release that reference 
    (and not take any more), in order to break reference cycles. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
APP_POOL_TABLE::Terminate(
    )
{

    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;

    
    //
    // BUGBUG Iterating in order to clean up, remove, and delete each 
    // element of the table is difficult to do with lkhash today.
    // GeorgeRe plans to fix this eventually. For now, the alternative
    // is to iterate through the table building up in list of all the 
    // elements, and then go through the list and shutdown, remove, and
    // delete each element -- yuck!!
    //
    // Once this gets fixed, we can see if it is valuable to unify any
    // table management code between the app pool, virtual site,
    // and application tables.
    //
    
    LIST_ENTRY DeleteListHead;
    PLIST_ENTRY pDeleteListEntry = NULL;
    APP_POOL * pAppPool = NULL;


    InitializeListHead( &DeleteListHead );

    
    CountOfElementsInTable = Size();


    //
    // Note that for good form we grab the write lock since we will be 
    // modifying objects in the table (although no other thread should 
    // touch this data structure anyways).
    //
    
    SuccessCount = Apply( 
                        DeleteAppPoolAction,
                        &DeleteListHead,
                        LKL_WRITELOCK
                        );
    
    DBG_ASSERT( SuccessCount == CountOfElementsInTable );


    // now for each, terminate it
    
    while (  ! IsListEmpty( &DeleteListHead )  )
    {
    
        pDeleteListEntry = RemoveHeadList( &DeleteListHead );

        DBG_ASSERT( pDeleteListEntry != NULL );

        pAppPool = APP_POOL::AppPoolFromDeleteListEntry( pDeleteListEntry );


        //
        // Terminate the app pool. Because each app pool is reference
        // counted, it will delete itself as soon as it's reference
        // count hits zero.
        //

        pAppPool->Terminate( );
        
    }

}   // APP_POOL_TABLE::Terminate



/***************************************************************************++

Routine Description:

    A routine that may be applied to all APP_POOLs in the hashtable
    to prepare for shutdown or termination. Conforms to the PFnRecordAction 
    prototype.

Arguments:

    pAppPool - The app pool.

    pDeleteListHead - List head into which to insert the app pool for
    later deletion.

Return Value:

    LK_ACTION - LKA_SUCCEEDED always.

--***************************************************************************/

// note: static!
LK_ACTION
APP_POOL_TABLE::DeleteAppPoolAction(
    IN APP_POOL * pAppPool, 
    IN VOID * pDeleteListHead
    )
{

    DBG_ASSERT( pAppPool != NULL );
    DBG_ASSERT( pDeleteListHead != NULL );

    InsertHeadList( 
        ( PLIST_ENTRY ) pDeleteListHead,
        pAppPool->GetDeleteListEntry()
        );


    return LKA_SUCCEEDED;
    
}   // APP_POOL_TABLE::DeleteAppPoolAction

/***************************************************************************++

Routine Description:

    Records the current state of all app pools as well as possibly recycling
    the app pool.

Arguments:

    pAppPool - The app pool.

    pfRecycleAsWell - Tells if we need to recycle as well as recording the states.

Return Value:

    LK_ACTION - LKA_SUCCEEDED always.

--***************************************************************************/
// note: static!
LK_ACTION
APP_POOL_TABLE::RecordPoolStatesAction(
    IN APP_POOL * pAppPool, 
    IN VOID * pfRecycleAsWell
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT( pAppPool != NULL );
    DBG_ASSERT( pfRecycleAsWell != NULL );

    // In BC mode we don't recycle the worker processes, but we will 
    // still need to record the state of the default app pool back
    // to the metabase.
    if ( ( GetWebAdminService()->IsBackwardCompatibilityEnabled() == FALSE )
         && ( ( *(BOOL*)pfRecycleAsWell ) == TRUE ))
    {
        // let the worker processes know that they should recycle.
        hr = pAppPool->RecycleWorkerProcesses( WAS_EVENT_RECYCLE_POOL_RECOVERY );
        if ( FAILED( hr ) )
        {
            // It could not be running and in that case it is not an error
            // however if it is running and there is an error then we should
            // log a warning.
            if ( hr != HRESULT_FROM_WIN32( ERROR_OBJECT_NOT_FOUND ))
            {
    
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Recyceling the worker process failed\n"
                    ));

                const WCHAR * EventLogStrings[1];

                EventLogStrings[0] = pAppPool->GetAppPoolId();

                GetWebAdminService()->GetEventLog()->
                    LogEvent(
                        WAS_EVENT_RECYCLE_APP_POOL_FAILURE,       // message id
                        sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                                // count of strings
                        EventLogStrings,                        // array of strings
                        hr                                       // error code
                        );
            }

            //
            // Ignore if we got object not found
            // because in that case we are just trying
            // to recycle an app pool that is not running.
            //
            hr = S_OK;
        }
    }

    // let the metabase know that the state of the app pool has changed
    pAppPool->RecordState();

    return LKA_SUCCEEDED;
    
}   // APP_POOL_TABLE::RecordPoolStatesAction


#if DBG
/***************************************************************************++

Routine Description:

    Debug dump the table.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
APP_POOL_TABLE::DebugDump(
    )
{

    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;


    CountOfElementsInTable = Size();


    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Dumping app pool table; total count: %lu\n",
            CountOfElementsInTable
            ));
    }


    SuccessCount = Apply( 
                        DebugDumpAppPoolAction,
                        NULL
                        );
    
    DBG_ASSERT( SuccessCount == CountOfElementsInTable );

}   // APP_POOL_TABLE::DebugDump



/***************************************************************************++

Routine Description:

    A routine that may be applied to all APP_POOLs in the hashtable
    to perform a debug dump. Conforms to the PFnRecordAction prototype.

Arguments:

    pAppPool - The app pool.

    pIgnored - Ignored.

Return Value:

    LK_ACTION - LKA_SUCCEEDED always.

--***************************************************************************/

// note: static!
LK_ACTION
APP_POOL_TABLE::DebugDumpAppPoolAction(
    IN APP_POOL * pAppPool, 
    IN VOID * pIgnored
    )
{

    DBG_ASSERT( pAppPool != NULL );
    UNREFERENCED_PARAMETER( pIgnored );


    pAppPool->DebugDump();

    return LKA_SUCCEEDED;
    
}   // APP_POOL_TABLE::DebugDumpAppPoolAction
#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\app_pool_config_store.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    app_pool_config_store.cxx

Abstract:

    This class encapsulates a single app pool's configuration data
    as it will be stored for use in managing the app pool and the
    worker processes that belong to the app pool.

Author:

    Emily B. Kruglick ( EmilyK )        19-May-2001

Revision History:

--*/



#include "precomp.h"


//
// local prototypes
//
HRESULT
CreateTokenForUser(
    IN  LPCWSTR pUserName,
    IN  LPCWSTR pUserPassword,
    IN  DWORD  LogonMethod,
    OUT TOKEN_CACHE_ENTRY** ppTokenCacheEntry
    );


VOID
ApplyRangeCheck( 
    DWORD   dwValue,
    LPCWSTR pAppPoolId,
    LPCWSTR pPropertyName,
    DWORD   dwDefaultValue,
    DWORD   dwMinValue,
    DWORD   dwMaxValue,
    DWORD*  pdwValueToUse 
    );

/***************************************************************************++

Routine Description:

    Constructor for the APP_POOL_CONFIG_STORE class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

APP_POOL_CONFIG_STORE::APP_POOL_CONFIG_STORE(
    )
{

    //
    // Set the initial reference count to 1, in order to represent the
    // reference owned by the creator of this instance.
    //

    m_RefCount = 1;

// Worker Process Control Properties

    m_PeriodicProcessRestartPeriodInMinutes = 0;
    m_PeriodicProcessRestartRequestCount = 0;
    m_pPeriodicProcessRestartSchedule = NULL;
    m_PeriodicProcessRestartMemoryUsageInKB = 0;
    m_PeriodicProcessRestartMemoryPrivateUsageInKB = 0;
    m_PingingEnabled = FALSE;
    m_IdleTimeoutInMinutes = 0;
    m_OrphanProcessesForDebuggingEnabled = FALSE;
    m_StartupTimeLimitInSeconds = 0;
    m_ShutdownTimeLimitInSeconds = 0;
    m_PingIntervalInSeconds = 0;
    m_PingResponseTimeLimitInSeconds = 0;
    m_pWorkerProcessTokenCacheEntry = NULL;

// App Pool Control Properties

    m_CPUAction = 0;
    m_CPULimit = 0;
    m_CPUResetInterval = 0;
    m_DisallowRotationOnConfigChanges = FALSE;
    m_UlAppPoolQueueLength = 0;
    m_MaxSteadyStateProcessCount = 0;
    m_SMPAffinitized = FALSE;
    m_SMPAffinitizedProcessorMask = 0;
    m_RapidFailProtectionEnabled = FALSE;
    m_RapidFailProtectionIntervalMS = 0;
    m_RapidFailProtectionMaxCrashes = 0;
    m_RecycleLoggingFlags = 0x00000008;
    m_DisallowOverlappingRotation = TRUE;
    m_LoadBalancerType = 0;
    m_AutoStart = FALSE;

    m_Signature = APP_POOL_CONFIG_STORE_SIGNATURE;

}   // APP_POOL_CONFIG::APP_POOL_CONFIG



/***************************************************************************++

Routine Description:

    Destructor for the APP_POOL_CONFIG class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

APP_POOL_CONFIG_STORE::~APP_POOL_CONFIG_STORE(
    )
{

    DBG_ASSERT( m_Signature == APP_POOL_CONFIG_STORE_SIGNATURE );

    m_Signature = APP_POOL_CONFIG_STORE_SIGNATURE_FREED;

    DBG_ASSERT( m_RefCount == 0 );

    if ( m_pPeriodicProcessRestartSchedule != NULL )
    {
        GlobalFree ( m_pPeriodicProcessRestartSchedule );
        m_pPeriodicProcessRestartSchedule = NULL;
    }

    if ( m_pWorkerProcessTokenCacheEntry != NULL )
    {
        m_pWorkerProcessTokenCacheEntry->DereferenceCacheEntry();
        m_pWorkerProcessTokenCacheEntry = NULL;
    };


}   // APP_POOL_CONFIG::~APP_POOL_CONFG



/***************************************************************************++

Routine Description:

    Increment the reference count for this object. Note that this method must 
    be thread safe, and must not be able to fail. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
APP_POOL_CONFIG_STORE::Reference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedIncrement( &m_RefCount );


    // 
    // The reference count should never have been less than zero; and
    // furthermore once it has hit zero it should never bounce back up;
    // given these conditions, it better be greater than one now.
    //
    
    DBG_ASSERT( NewRefCount > 1 );


    return;

}   // APP_POOL_CONFIG::Reference



/***************************************************************************++

Routine Description:

    Decrement the reference count for this object, and cleanup if the count 
    hits zero. Note that this method must be thread safe, and must not be
    able to fail. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
APP_POOL_CONFIG_STORE::Dereference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedDecrement( &m_RefCount );

    // ref count should never go negative
    DBG_ASSERT( NewRefCount >= 0 );

    if ( NewRefCount == 0 )
    {
        // time to go away

        IF_DEBUG( WEB_ADMIN_SERVICE_REFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Reference count has hit zero in APP_POOL_CONFIG instance, deleting (ptr: %p;)\n",
                this
                ));
        }

        delete this;

    }
    

    return;
    
}   // APP_POOL_CONFIG::Dereference

/***************************************************************************++

Routine Description:

    Initialize the data in the app pool config store

Arguments:

    pAppPoolObject -- The data object to initialize from.

Return Value:

    VOID.  -- Routine is fault tolerant, if there are problems some configuration
              will be left as NULL, however if it is NULL, later it will generate
              the appropriate errors.

--***************************************************************************/
VOID
APP_POOL_CONFIG_STORE::Initialize(
    IN APP_POOL_DATA_OBJECT* pAppPoolObject
    )
{
    HRESULT hr = S_OK;
    DWORD   dwAppPoolIdentity = 2;  // defaulted to Network Service just to be safe.

    DBG_ASSERT( pAppPoolObject != NULL );

    //
    // these properties matter whether or not we are in BC mode
    // 
    //
    ApplyRangeCheck( pAppPoolObject->QueryStartupTimeLimit(),
                                               pAppPoolObject->QueryAppPoolId(),
                                               MBCONST_WP_STARTUP_TIMELIMIT_NAME,
                                               MBCONST_WP_STARTUP_TIMELIMIT_DEFAULT,  // default value
                                               MBCONST_WP_STARTUP_TIMELIMIT_LOW,   // min value
                                               MBCONST_WP_STARTUP_TIMELIMIT_HIGH, // max value
                                               &m_StartupTimeLimitInSeconds );

    ApplyRangeCheck( pAppPoolObject->QueryShutdownTimeLimit(),
                                               pAppPoolObject->QueryAppPoolId(),
                                               L"ShutdownTimeLimit",
                                               60,  // default value
                                               1,   // min value
                                               MAX_SECONDS_IN_ULONG_OF_MILLISECONDS, // max value
                                               &m_ShutdownTimeLimitInSeconds );

    // issue:  is this really a configurable property in bc mode?
    ApplyRangeCheck( pAppPoolObject->QueryLoadBalancerType(),
                                               pAppPoolObject->QueryAppPoolId(),
                                               L"LoadBalancerCapabilities",
                                               2,  // default value
                                               1,   // min value
                                               2, // max value
                                               &m_LoadBalancerType );
    
    ApplyRangeCheck( pAppPoolObject->QueryAppPoolQueueLength(),
                                               pAppPoolObject->QueryAppPoolId(),
                                               MBCONST_APP_POOL_QUEUE_LENGTH_NAME,
                                               MBCONST_APP_POOL_QUEUE_LENGTH_DEFAULT,  // default value
                                               MBCONST_APP_POOL_QUEUE_LENGTH_LOW,   // min value
                                               MBCONST_APP_POOL_QUEUE_LENGTH_HIGH, // max value
                                               &m_UlAppPoolQueueLength );

    //
    // now handle the properties that only matter in specific modes
    //
    if ( GetWebAdminService()->
         IsBackwardCompatibilityEnabled() )
    {
        //
        // in BC mode we default all of these to off.
        //
        m_PeriodicProcessRestartPeriodInMinutes = 0;
        m_PeriodicProcessRestartRequestCount = 0;
        m_PeriodicProcessRestartMemoryUsageInKB = 0;
        m_PeriodicProcessRestartMemoryPrivateUsageInKB = 0;
        m_PingingEnabled = FALSE;
        m_PingIntervalInSeconds = 0;
        m_PingResponseTimeLimitInSeconds = 0;
        m_IdleTimeoutInMinutes = 0;
        m_OrphanProcessesForDebuggingEnabled = FALSE;
        m_CPUAction = 0;
        m_CPULimit = 0;
        m_CPUResetInterval = 0;

        m_DisallowRotationOnConfigChanges = TRUE;
        m_MaxSteadyStateProcessCount = 1;
        m_SMPAffinitized = FALSE;
        m_SMPAffinitizedProcessorMask = 0;
        m_RapidFailProtectionEnabled = FALSE;
        m_RapidFailProtectionMaxCrashes = 0;
        m_RapidFailProtectionIntervalMS = 0;
        m_RecycleLoggingFlags = 0;
        m_DisallowOverlappingRotation = TRUE;
        m_AutoStart = TRUE;

        //
        // These should still be null from creation
        //

        DBG_ASSERT ( m_pWorkerProcessTokenCacheEntry == NULL );

        // In BC mode the token is still used for things like acl'ing
        // named pipes and the app pool.  It just needs to be be local
        // system, in this case.
        SetTokenForWorkerProcesses(NULL,  // ignore the user name
                                   NULL,  // ignore the password
                                   LocalSystemAppPoolUserType,
                                   pAppPoolObject->QueryAppPoolId());
        
        DBG_ASSERT ( m_OrphanActionExecutable.IsEmpty() );
        DBG_ASSERT ( m_OrphanActionParameters.IsEmpty() );
        DBG_ASSERT ( m_DisableActionExecutable.IsEmpty() );
        DBG_ASSERT ( m_DisableActionParameters.IsEmpty() );
        DBG_ASSERT ( m_pPeriodicProcessRestartSchedule == NULL );

    }
    else
    {
        // 
        // Set properties for FC mode.
        //

        ApplyRangeCheck( pAppPoolObject->QueryPeriodicRestartTime(),
                                                   pAppPoolObject->QueryAppPoolId(),
                                                   MBCONST_PERIODIC_RESTART_TIME_NAME,
                                                   MBCONST_PERIODIC_RESTART_TIME_DEFAULT,   // default value
                                                   MBCONST_PERIODIC_RESTART_TIME_LOW,       // min value
                                                   MBCONST_PERIODIC_RESTART_TIME_HIGH,      // max value
                                                   &m_PeriodicProcessRestartPeriodInMinutes );

        m_PeriodicProcessRestartRequestCount = pAppPoolObject->QueryPeriodicRestartRequests();

        ApplyRangeCheck( pAppPoolObject->QueryPeriodicRestartMemory(),
                                                   pAppPoolObject->QueryAppPoolId(),
                                                   MBCONST_PERIODIC_RESTART_VIRTUAL_MEMORY_NAME,
                                                   MBCONST_PERIODIC_RESTART_VIRTUAL_MEMORY_DEFAULT,     // default value
                                                   MBCONST_PERIODIC_RESTART_VIRTUAL_MEMORY_LOW,         // min value
                                                   MBCONST_PERIODIC_RESTART_VIRTUAL_MEMORY_HIGH,        // max value
                                                   &m_PeriodicProcessRestartMemoryUsageInKB );

        ApplyRangeCheck( pAppPoolObject->QueryPeriodicRestartMemoryPrivate(),
                                                   pAppPoolObject->QueryAppPoolId(),
                                                   MBCONST_PERIODIC_RESTART_PRIVATE_MEMORY_NAME,
                                                   MBCONST_PERIODIC_RESTART_PRIVATE_MEMORY_DEFAULT,    // default value
                                                   MBCONST_PERIODIC_RESTART_PRIVATE_MEMORY_LOW,     // min value
                                                   MBCONST_PERIODIC_RESTART_PRIVATE_MEMORY_HIGH,  // max value
                                                   &m_PeriodicProcessRestartMemoryPrivateUsageInKB );
        
        m_IdleTimeoutInMinutes = pAppPoolObject->QueryIdleTimeout();

        //
        // If the idle timeout is greater than the periodic restart timeout then it will 
        // never fire.  This check has been carried over from the catalog store.
        //
        if ( m_IdleTimeoutInMinutes > m_PeriodicProcessRestartPeriodInMinutes &&
             m_PeriodicProcessRestartPeriodInMinutes != 0 )
        {
            GetWebAdminService()->
            GetWMSLogger()->
            LogIdleTimeoutGreaterThanRestartPeriod( pAppPoolObject->QueryAppPoolId(),
                                                    m_IdleTimeoutInMinutes,
                                                    m_PeriodicProcessRestartPeriodInMinutes,
                                                    10,
                                                    MBCONST_PERIODIC_RESTART_TIME_DEFAULT,
                                                    TRUE );

            m_IdleTimeoutInMinutes = 10;
            m_PeriodicProcessRestartPeriodInMinutes = MBCONST_PERIODIC_RESTART_TIME_DEFAULT;

        }

        m_OrphanProcessesForDebuggingEnabled = pAppPoolObject->QueryOrphanWorkerProcess();

        m_PingingEnabled = pAppPoolObject->QueryPingingEnabled();

        if ( m_PingingEnabled )
        {
            //
            // if pinging is enabled, but either the ping interval or the
            // ping response timelimit is invalid ( only 0 is not allowed )
            // then we need to log a warning and use the default value for
            // the interval or response time.
            //

            ApplyRangeCheck( pAppPoolObject->QueryPingInterval(),
                                                       pAppPoolObject->QueryAppPoolId(),
                                                       MBCONST_PING_INTERVAL_NAME,
                                                       MBCONST_PING_INTERVAL_DEFAULT,  // default value
                                                       MBCONST_PING_INTERVAL_LOW,    // min value
                                                       MBCONST_PING_INTERVAL_HIGH,  // max value
                                                       &m_PingIntervalInSeconds );

            ApplyRangeCheck( pAppPoolObject->QueryPingResponseTime(),
                                                       pAppPoolObject->QueryAppPoolId(),
                                                       L"PingResponseTime",
                                                       60,    // default value
                                                       1,     // min value
                                                       MAX_SECONDS_IN_ULONG_OF_MILLISECONDS,  // max value
                                                       &m_PingResponseTimeLimitInSeconds );
        }

        ApplyRangeCheck( pAppPoolObject->QueryCPUAction(),
                                                   pAppPoolObject->QueryAppPoolId(),
                                                   L"CPUAction",
                                                   0,     // default value
                                                   0,     // min value
                                                   1,     // max value
                                                   &m_CPUAction );

        ApplyRangeCheck( pAppPoolObject->QueryCPULimit(),
                                                   pAppPoolObject->QueryAppPoolId(),
                                                   L"CPULimit",
                                                   0,     // default value
                                                   0,     // min value
                                                   100000,     // max value
                                                   &m_CPULimit );

        ApplyRangeCheck( pAppPoolObject->QueryCPUResetInterval(),
                                                   pAppPoolObject->QueryAppPoolId(),
                                                   L"CPUResetInterval",
                                                   0,        // default value
                                                   0,        // min value
                                                   1440,     // max value
                                                   &m_CPUResetInterval );

        m_DisallowRotationOnConfigChanges = pAppPoolObject->QueryDisallowRotationOnConfigChange();

        ApplyRangeCheck( pAppPoolObject->QueryMaxProcesses(),
                                                   pAppPoolObject->QueryAppPoolId(),
                                                   L"MaxProcesses",
                                                   1,            // default value
                                                   1,            // min value
                                                   UINT_MAX,     // max value
                                                   &m_MaxSteadyStateProcessCount );
        
        m_SMPAffinitized = pAppPoolObject->QuerySMPAffinitized();
        if ( m_SMPAffinitized )
        {
            // if affinity is on we are going to fix the processor mask 
            // to only let it contain processors that are currently available
            // on the machine.  We do not event log this change and it will
            // be documented to describe this behavior.  Per BillKar 10/11/2001.
            m_SMPAffinitizedProcessorMask = pAppPoolObject->QuerySMPProcessorAffinityMask() &
                                            GetWebAdminService()->GetSystemActiveProcessMask();
        }
    
        m_RapidFailProtectionEnabled = pAppPoolObject->QueryRapidFailProtection();

        if ( m_RapidFailProtectionEnabled )
        {
            DWORD RapidFailProtectionIntervalInMinutes = 0; 

            ApplyRangeCheck( pAppPoolObject->QueryRapidFailProtectionInterval(),
                                                       pAppPoolObject->QueryAppPoolId(),
                                                       MBCONST_RAPID_FAIL_INTERVAL_NAME,
                                                       MBCONST_RAPID_FAIL_INTERVAL_DEFAULT,    // default value
                                                       MBCONST_RAPID_FAIL_INTERVAL_LOW,     // min value
                                                       MBCONST_RAPID_FAIL_INTERVAL_HIGH,  // max value
                                                       &RapidFailProtectionIntervalInMinutes );

            //
            // the above call returned the interval 
            // in minutes, it should really be converted
            // to milliseconds before being used
            //
            m_RapidFailProtectionIntervalMS = RapidFailProtectionIntervalInMinutes 
                                              * ONE_MINUTE_IN_MILLISECONDS;

            ApplyRangeCheck( pAppPoolObject->QueryRapidFailProtectionMaxCrashes(),
                                                       pAppPoolObject->QueryAppPoolId(),
                                                       MBCONST_RAPID_FAIL_CRASHES_NAME,
                                                       MBCONST_RAPID_FAIL_CRASHES_DEFAULT,    // default value
                                                       MBCONST_RAPID_FAIL_CRASHES_LOW,     // min value
                                                       MBCONST_RAPID_FAIL_CRASHES_HIGH,  // max value
                                                       &m_RapidFailProtectionMaxCrashes );

        }  

        //
        // We don't do any check on the flags, any value is valid even if it is not in use yet.
        //
        m_RecycleLoggingFlags = pAppPoolObject->QueryRecycleLoggingFlags();
    
        m_DisallowOverlappingRotation = pAppPoolObject->QueryDisallowOverlappingRotation();

        m_AutoStart = pAppPoolObject->QueryAppPoolAutoStart();

        // Figure out the token for the worker processes to start under.

        DBG_ASSERT ( m_pWorkerProcessTokenCacheEntry == NULL );

        ApplyRangeCheck( pAppPoolObject->QueryAppPoolIdentityType(),
                                               pAppPoolObject->QueryAppPoolId(),
                                               L"AppPoolIdentityType",
                                               2,  // default value  ( Network Service )
                                               0,  // min value
                                               3,  // max value
                                               &dwAppPoolIdentity );

        SetTokenForWorkerProcesses(pAppPoolObject->QueryWAMUserName(),
                                        pAppPoolObject->QueryWAMUserPass(),
                                        dwAppPoolIdentity,
                                        pAppPoolObject->QueryAppPoolId());

        // Copy in the orphan action information.

        DBG_ASSERT ( m_OrphanActionExecutable.IsEmpty() );

        if ( pAppPoolObject->QueryOrphanActionExecutable() != NULL &&
             pAppPoolObject->QueryOrphanActionExecutable()[0] != '\0' )
        {

            hr = m_OrphanActionExecutable.Copy ( pAppPoolObject->QueryOrphanActionExecutable() );
            if ( FAILED ( hr ) )
            {
            
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Allocating memory failed, ignoring and continuing\n"
                    ));

                hr = S_OK;

            }

            DBG_ASSERT ( m_OrphanActionParameters.IsEmpty() );

            // only if we have an executable do the parameters matter.

            if ( pAppPoolObject->QueryOrphanActionParameters() != NULL &&
                 pAppPoolObject->QueryOrphanActionParameters()[0] != '\0' )
            {

                hr = m_OrphanActionParameters.Copy ( pAppPoolObject->QueryOrphanActionParameters() );
                if ( FAILED ( hr ) )
                {
                    DPERROR(( 
                        DBG_CONTEXT,
                        hr,
                        "Allocating memory failed, ignoring and continuing\n"
                        ));

                    hr = S_OK;

                }
            }

        }

        // Copy in the disable action information.

        DBG_ASSERT ( m_DisableActionExecutable.IsEmpty() );

        if ( pAppPoolObject->QueryDisableActionExecutable() != NULL &&
             pAppPoolObject->QueryDisableActionExecutable()[0] != '\0' )
        {

            hr = m_DisableActionExecutable.Copy ( pAppPoolObject->QueryDisableActionExecutable() );
            if ( FAILED ( hr ) )
            {
            
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Allocating memory failed, ignoring and continuing\n"
                    ));

                hr = S_OK;

            }

            DBG_ASSERT ( m_DisableActionParameters.IsEmpty() );

            // only if we have an executable do the parameters matter.

            if ( pAppPoolObject->QueryDisableActionParameters() != NULL &&
                 pAppPoolObject->QueryDisableActionParameters()[0] != '\0' )
            {

                hr = m_DisableActionParameters.Copy ( pAppPoolObject->QueryDisableActionParameters() );
                if ( FAILED ( hr ) )
                {
                    DPERROR(( 
                        DBG_CONTEXT,
                        hr,
                        "Allocating memory failed, ignoring and continuing\n"
                        ));

                    hr = S_OK;

                }
            }

        }
       
        //
        // copy in the periodic process restart schedule work
        //

        DBG_ASSERT ( m_pPeriodicProcessRestartSchedule == NULL );

        if ( pAppPoolObject->QueryPeriodicRestartSchedule() != NULL )
        {
            DWORD cbRestartSchedule = GetMultiszByteLength( const_cast <LPWSTR> (pAppPoolObject->QueryPeriodicRestartSchedule()) );
            m_pPeriodicProcessRestartSchedule = ( LPWSTR )GlobalAlloc( GMEM_FIXED,  cbRestartSchedule );

            if ( m_pPeriodicProcessRestartSchedule == NULL )
            {
                hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Allocating memory for pPeriodicProcessRestartSchedule failed\n"
                    ));

            }
            else
            {

                // copies the number of bytes.  this string was declared
                // to be of this many bytes so it's fine to copy them.
                memcpy( m_pPeriodicProcessRestartSchedule, 
                        pAppPoolObject->QueryPeriodicRestartSchedule(), 
                        cbRestartSchedule );

                IF_DEBUG ( WEB_ADMIN_SERVICE_WMS )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "First entry in Schedule %S\n",
                                pAppPoolObject->QueryPeriodicRestartSchedule() ));
                }

            }
        }

    }  // end of FC mode

} // APP_POOL_CONFIG_STORE::Initialize

/***************************************************************************++

Routine Description:

    Function will set the m_WorkerProccessLaunchToken to be the correct
    token to launch all worker processes under.  If it fails we will log
    an error in the calling function, and then leave it alone.  We will fail
    any attempt to launch a worker process.

Arguments:

    LPWSTR pUserName
    LPWSTR pUserPassword
    APP_POOL_USER_TYPE usertype

Return Value:

    VOID

--***************************************************************************/
VOID 
APP_POOL_CONFIG_STORE::SetTokenForWorkerProcesses(
    IN LPCWSTR pUserName,
    IN LPCWSTR pUserPassword,
    IN DWORD usertype,
    IN LPCWSTR pAppPoolId
    )
{
    HRESULT hr = S_OK;

    //
    // Only if we created the worker process token using a LogonUser do
    // we need to close the token before re-assigning it.
    //
    if ( m_pWorkerProcessTokenCacheEntry != NULL )
    {
        m_pWorkerProcessTokenCacheEntry->DereferenceCacheEntry();
        m_pWorkerProcessTokenCacheEntry = NULL;
    }

    switch (usertype)
    {
        case (LocalSystemAppPoolUserType):
            m_pWorkerProcessTokenCacheEntry = GetWebAdminService()->GetLocalSystemTokenCacheEntry();
            m_pWorkerProcessTokenCacheEntry->ReferenceCacheEntry();
        break;

        case (LocalServiceAppPoolUserType):
            m_pWorkerProcessTokenCacheEntry = GetWebAdminService()->GetLocalServiceTokenCacheEntry();
            m_pWorkerProcessTokenCacheEntry->ReferenceCacheEntry();
        break;

        case(NetworkServiceAppPoolUserType):
            m_pWorkerProcessTokenCacheEntry = GetWebAdminService()->GetNetworkServiceTokenCacheEntry();
            m_pWorkerProcessTokenCacheEntry->ReferenceCacheEntry();
        break;

        case (SpecificUserAppPoolUserType):

            if ( pUserName && pUserPassword )  
            {
                hr = CreateTokenForUser(pUserName,
                                        pUserPassword,
                                        LOGON32_LOGON_BATCH,
                                        &m_pWorkerProcessTokenCacheEntry);

                if ( FAILED (hr) )
                {
                    goto exit;
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
                goto exit;
            }

        break;

        default:

            DBG_ASSERT( FALSE );
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

    }


exit:

    if ( FAILED ( hr ) )
    {
        const WCHAR * EventLogStrings[1];

        EventLogStrings[0] = pAppPoolId ? pAppPoolId : L"<null>";

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_PROCESS_IDENTITY_FAILURE,       // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                hr                                       // error code
                );


    }

} //  APP_POOL_CONFIG_STORE::SetTokenForWorkerProcesses

/***************************************************************************++

Routine Description:

    Function will return a token representing the user the worker processes
    are to run as.

Arguments:

    IN  LPWSTR UserName        -- User the token should represent
    IN  LPWSTR UserPassword    -- Password the token should represent
    OUT HANDLE* pUserToken     -- Token that was created (will be null if we failed)

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
CreateTokenForUser(
    IN  LPCWSTR pUserName,
    IN  LPCWSTR pUserPassword,
    IN  DWORD  LogonMethod,
    OUT TOKEN_CACHE_ENTRY** ppTokenCacheEntry
    )
{
    HRESULT hr      = S_OK;
    DWORD   dwErr   = ERROR_SUCCESS;
    DWORD   dwLogonError = ERROR_SUCCESS;
    TOKEN_CACHE_ENTRY * pTempTokenCacheEntry = NULL;

    DBG_ASSERT(ppTokenCacheEntry);
    DBG_ASSERT(pUserName);
    DBG_ASSERT(pUserPassword);

    //
    // Set the default out parameter.
    //
    *ppTokenCacheEntry = NULL;

    //
    // Attempt to logon as the user.
    //
    hr = GetWebAdminService()->GetTokenCache().GetCachedToken(
                    const_cast < LPWSTR > ( pUserName ),                    // user name
                    L"",                                                    // domain
                    const_cast < LPWSTR > ( pUserPassword ),                // password
                    LogonMethod,                 // type of logon
                    FALSE,                       // do not use subauth 
                    FALSE,                       // not UPN logon
                    NULL,                        // do not register remote IP addr
                    &pTempTokenCacheEntry,       // returned token cache entry
                    &dwLogonError                // Logon Error
                    );

    if (FAILED(hr))
    {
        DBG_ASSERT(NULL == pTempTokenCacheEntry);
        goto exit;
    }

    if (NULL == pTempTokenCacheEntry)
    {
        hr = HRESULT_FROM_WIN32(dwLogonError);
        goto exit;
    }


    // Adjust the token to make sure that administrators have the
    // appropriate privledges.
    dwErr = GetWebAdminService()->
            GetSecurityDispenser()->AdjustTokenForAdministrators( 
                                       pTempTokenCacheEntry->QueryPrimaryToken() );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not adjust the users token to allow administrator rights\n"
            ));

        goto exit;
    }

    *ppTokenCacheEntry = pTempTokenCacheEntry;

exit:

    return hr;

} // end CreateTokenForUser


/***************************************************************************++

Routine Description:

    Function checks if the dword value is within the appropriate range, and
    if it is not it logs an error.  Depending on whether it is value passed in is
    valid or not, the routine will return the value to use ( either the value passed
    in or the default value ).

Arguments:

    DWORD   dwValue             The value to check
    LPCWSTR pAppPoolId          The app pool id to use if we need to log
    LPCWSTR pPropertyName       The property name to use if we need to log
    DWORD   dwDefaultValue      The default value for the property
    DWORD   dwMinValue          The minimum value in the range
    DWORD   dwMaxValue          The maximum value in the range
    DWORD*  pdwValueToUse       The value that WAS should use for this property

Return Value:

    VOID

--***************************************************************************/
VOID
ApplyRangeCheck( 
    DWORD   dwValue,
    LPCWSTR pAppPoolId,
    LPCWSTR pPropertyName,
    DWORD   dwDefaultValue,
    DWORD   dwMinValue,
    DWORD   dwMaxValue,
    DWORD*  pdwValueToUse 
    )
{
    DBG_ASSERT ( pdwValueToUse != NULL );

    if  ( ( dwValue < dwMinValue ) || 
          ( dwValue > dwMaxValue ) )
    {
        GetWebAdminService()->
        GetWMSLogger()->
        LogRangeAppPool( pAppPoolId,
                         pPropertyName,
                         dwValue,
                         dwMinValue,
                         dwMaxValue,
                         dwDefaultValue,
                         TRUE );

        *pdwValueToUse = dwDefaultValue;
    }
    else
    {
        *pdwValueToUse = dwValue;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\app_pool_config_store.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    app_pool_config_store.h

Abstract:

    The IIS web admin service app pool config class definition.

Author:

    Emily B. Kruglick ( EmilyK )        19-May-2001

Revision History:

--*/


#ifndef _APP_POOL_CONFIG_STORE_H_
#define _APP_POOL_CONFIG_STORE_H_



//
// forward references
//

//
// common #defines
//

#define APP_POOL_CONFIG_STORE_SIGNATURE       CREATE_SIGNATURE( 'APCS' )
#define APP_POOL_CONFIG_STORE_SIGNATURE_FREED CREATE_SIGNATURE( 'apcX' )

//
// prototypes
//

// app pool configuration class
class APP_POOL_CONFIG_STORE
{
public:
    APP_POOL_CONFIG_STORE(
        );

    virtual
    ~APP_POOL_CONFIG_STORE(
        );

    virtual
    VOID
    Reference(
        );

    virtual
    VOID
    Dereference(
        );

    VOID
    Initialize(
        APP_POOL_DATA_OBJECT* pAppPoolObject
        );

    HANDLE
    GetWorkerProcessToken(
        )
    {
        if (m_pWorkerProcessTokenCacheEntry)
        {
            return m_pWorkerProcessTokenCacheEntry->QueryPrimaryToken();
        }
        else
        {
            return NULL;
        }
    }

    inline
    ULONG
    GetPeriodicProcessRestartPeriodInMinutes(
        )
        const
    { return m_PeriodicProcessRestartPeriodInMinutes; }

    inline
    ULONG
    GetPeriodicProcessRestartRequestCount(
        )
        const
    { return m_PeriodicProcessRestartRequestCount; }

    inline
    ULONG
    GetPeriodicProcessRestartMemoryUsageInKB(
        )
        const
    { return m_PeriodicProcessRestartMemoryUsageInKB; }

    inline
    ULONG
    GetPeriodicProcessRestartMemoryPrivateUsageInKB(
        )
        const
    { return m_PeriodicProcessRestartMemoryPrivateUsageInKB; }

    inline
    LPWSTR
    GetPeriodicProcessRestartSchedule(
        )
        const
    { return m_pPeriodicProcessRestartSchedule; }

    inline
    BOOL
    IsPingingEnabled(
        )
        const
    { return m_PingingEnabled; }

    inline
    ULONG
    GetPingIntervalInSeconds(
        )
        const
    { return m_PingIntervalInSeconds; }

    inline
    ULONG
    GetPingResponseTimeLimitInSeconds(
        )
        const
    { return m_PingResponseTimeLimitInSeconds; }

    inline
    ULONG
    GetStartupTimeLimitInSeconds(
        )
        const
    { return m_StartupTimeLimitInSeconds; }

    inline
    ULONG
    GetShutdownTimeLimitInSeconds(
        )
        const
    { return m_ShutdownTimeLimitInSeconds; }

    inline
    BOOL
    IsOrphaningProcessesForDebuggingEnabled(
        )
        const
    { return m_OrphanProcessesForDebuggingEnabled; }

    inline
    LPCWSTR
    GetOrphanActionExecutable(
        )
        const
    {
        if ( m_OrphanActionExecutable.IsEmpty() )
        {
            return NULL;
        }
        else
        {    
            return m_OrphanActionExecutable.QueryStr(); 
        }
    }

    inline
    LPCWSTR
    GetOrphanActionParameters(
        )
        const
    { 
        if ( m_OrphanActionParameters.IsEmpty() )
        {
            return NULL;
        }
        else
        {    
            return m_OrphanActionParameters.QueryStr(); 
        }
    }

    inline
    ULONG
    GetIdleTimeoutInMinutes(
        )
        const
    { return m_IdleTimeoutInMinutes; }

    inline
    BOOL
    IsAutoStartEnabled(
        )
        const
    { return m_AutoStart; }

    inline
    VOID
    SetAutoStart(
        BOOL AutoStart
        )
    { m_AutoStart = AutoStart; }

    inline
    ULONG
    GetCPUResetInterval(
        )
        const
    { return m_CPUResetInterval; }

    inline
    ULONG
    GetCPULimit(
        )
        const
    { return m_CPULimit; }
    
    inline
    ULONG
    GetCPUAction(
        )
        const
    { return m_CPUAction; }

    inline
    ULONG
    GetUlAppPoolQueueLength(
        )
        const
    { return m_UlAppPoolQueueLength; }

    inline
    ULONG
    GetRapidFailProtectionIntervalMS(
        )
        const
    { return m_RapidFailProtectionIntervalMS; }

    inline
    ULONG
    GetRapidFailProtectionMaxCrashes(
        )
        const
    { return m_RapidFailProtectionMaxCrashes; }

    inline
    ULONG
    GetRecycleLoggingFlags(
        )
        const
    { return m_RecycleLoggingFlags; }

    inline
    BOOL
    IsRapidFailProtectionEnabled(
        )
        const
    { return m_RapidFailProtectionEnabled; }

    inline
    ULONG
    GetMaxSteadyStateProcessCount(
        )
        const
    { return m_MaxSteadyStateProcessCount; }

    inline
    ULONG
    GetSMPAffinitized(
        )
        const
    { return m_SMPAffinitized; }

    inline
    DWORD_PTR
    GetSMPAffinitizedProcessorMask(
        )
        const
    { return m_SMPAffinitizedProcessorMask; }

    inline
    BOOL
    IsDisallowOverlappingRotationEnabled(
        )
        const
    { return m_DisallowOverlappingRotation; }

    inline
    BOOL
    IsDisallowRotationOnConfigChangesEnabled(
        )
        const
    { return m_DisallowRotationOnConfigChanges; }

    inline
    LPCWSTR
    GetDisableActionExecutable(
        )
        const
    { 
        if ( m_DisableActionExecutable.IsEmpty() )
        {
            return NULL;
        }
        else
        {
            return m_DisableActionExecutable.QueryStr();
        }
    }

    inline
    LPCWSTR
    GetDisableActionParameters(
        )
        const
    { 
        if ( m_DisableActionParameters.IsEmpty() )
        {
            return NULL;
        }
        else
        {
            return m_DisableActionParameters.QueryStr();
        }
    }

    inline
    ULONG
    GetLoadBalancerType(
        )
        const
    { return m_LoadBalancerType; }

private:

    VOID 
    SetTokenForWorkerProcesses(
        IN LPCWSTR pUserName,
        IN LPCWSTR pUserPassword,
        IN DWORD usertype,
        IN LPCWSTR pAppPoolId
        );

    DWORD m_Signature;

    LONG m_RefCount;

// Worker Process Control Properties

    //
    // How often to rotate worker processes based on time, in minutes. 
    // Zero means disabled.
    //
    ULONG m_PeriodicProcessRestartPeriodInMinutes;

    //
    // How often to rotate worker processes based on requests handled. 
    // Zero means disabled.
    //
    ULONG m_PeriodicProcessRestartRequestCount;

    //
    // How often to rotate worker processes based on schedule
    // MULTISZ array of time information
    //                    <time>\0<time>\0\0
    //                    time is of military format hh:mm 
    //                    (hh>=0 && hh<=23)
    //                    (mm>=0 && hh<=59)time, in minutes. 
    // NULL or empty string means disabled.
    //
    LPWSTR m_pPeriodicProcessRestartSchedule;

    //
    // How often to rotate worker processes based on amount of VM used by process
    // Zero means disabled.
    //
    ULONG m_PeriodicProcessRestartMemoryUsageInKB;

    //
    // How often to rotate worker processes based on amount of private bytes used by process
    // Zero means disabled.
    //
    ULONG m_PeriodicProcessRestartMemoryPrivateUsageInKB;

    //
    // Whether pinging is enabled. 
    //
    BOOL m_PingingEnabled;

    //
    // The idle timeout period for worker processes, in minutes. 
    // Zero means disabled.
    //
    ULONG m_IdleTimeoutInMinutes;

    //
    // Whether orphaning of worker processes for debugging is enabled. 
    //
    BOOL m_OrphanProcessesForDebuggingEnabled;

    //
    // How long a worker process is given to start up, in seconds. 
    // This is measured from when the process is launched, until it
    // registers with the Web Admin Service. 
    //
    ULONG m_StartupTimeLimitInSeconds;

    //
    // How long a worker process is given to shut down, in seconds. 
    // This is measured from when the process is asked to shut down, 
    // until it finishes and exits. 
    //
    ULONG m_ShutdownTimeLimitInSeconds;

    //
    // The ping interval for worker processes, in seconds. 
    // This is the interval between ping cycles. This value is ignored
    // if pinging is not enabled. 
    //
    ULONG m_PingIntervalInSeconds;

    //
    // The ping response time limit for worker processes, in seconds. 
    // This value is ignored if pinging is not enabled. 
    //
    ULONG m_PingResponseTimeLimitInSeconds;

    //
    // The command to run on an orphaned worker process. Only used
    // if orphaning is enabled, and if this field is non-NULL.
    //
    STRU m_OrphanActionExecutable;

    //
    // The parameters for the executable to run on an orphaned worker process. Only used
    // if the pOrphanActionExecutable is used.
    //
    STRU m_OrphanActionParameters;

    // 
    // Identity Token for starting up the app pools worker process identities
    //
    TOKEN_CACHE_ENTRY* m_pWorkerProcessTokenCacheEntry;


// App Pool Control Properties

    //
    // What action to take if the job object user time limit fires.
    DWORD m_CPUAction;

    //
    // How many 1/1000th % of the processor time can the job use.
    DWORD m_CPULimit;

    //
    // Over how long do we monitor for the CPULimit (in minutes).
    DWORD m_CPUResetInterval;


    //
    // Whether worker processes should be rotated on configuration 
    // changes, including for example changes to app pool settings that
    // require a process restart to take effect; or site or app control
    // operation (start/stop/pause/continue) that require rotation to
    // guarantee component unloading. TRUE means this rotation
    // is not allowed (which may delay new settings taking effect, 
    // may prevent component unloading, etc.); FALSE means it is allowed. 
    //
    BOOL m_DisallowRotationOnConfigChanges;

    //
    // The maximum number of requests that UL will queue on this app
    // pool, waiting for service by a worker process. 
    //
    ULONG m_UlAppPoolQueueLength;

    //
    // The maximum number of worker processes (in a steady state; 
    // transiently, there may be more than this number running during 
    // process rotation). In a typical configuration this is set to one. 
    // A number greater than one is used for web gardens.
    //
    ULONG m_MaxSteadyStateProcessCount;

    //
    // Whether worker processes for this app pool should be hard affinitized 
    // to processors. If this option is enabled, then the max steady state
    // process count is cropped down to the number of processors configured 
    // to be used (if the configured max exceeds that count of processors). 
    //
    BOOL m_SMPAffinitized;

    //
    // If this app pool is running in SMP affinitized mode, this mask can be
    // used to limit which of the processors on the machine are used by this
    // app pool. 
    //
    DWORD_PTR m_SMPAffinitizedProcessorMask;

    //
    // Whether rapid, repeated failure protection is enabled (by 
    // automatically pausing all apps in the app pool in such cases.)
    //
    BOOL m_RapidFailProtectionEnabled;

    //
    // Window for a specific number of failures to take place in.
    //
    DWORD m_RapidFailProtectionIntervalMS;
    //
    // Number of failures that should cause an app pool to go 
    // into rapid fail protection.
    //
    DWORD m_RapidFailProtectionMaxCrashes;

    //
    // Flags that govern if recycling informationals are printed.
    //
    DWORD m_RecycleLoggingFlags;

    //
    // Whether a replacement worker process can be created while the
    // one being replaced is still alive. TRUE means this overlap
    // is not allowed; FALSE means it is allowed.
    //
    BOOL m_DisallowOverlappingRotation;

    //
    // The command to run on an a disabled app pool.
    //
    STRU m_DisableActionExecutable;

    //
    // The parameters for the executable to run on an a disabled app pool.
    //
    STRU m_DisableActionParameters;

    //
    // The type of load balancing behavior expect by the server.
    //
    DWORD m_LoadBalancerType;

    // 
    // Do we start this app pool on startup?
    BOOL m_AutoStart;


};



#endif  // _APP_POOL_CONFIG_STORE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\config_and_control_manager.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    config_and_control_manager.cxx

Abstract:

    The IIS web admin service configuration and control manager class 
    implementation. This class owns access to all configuration data, 
    both via the catalog config store apis and the metabase apis; as well
    as control commands that come in through our control api. 

    Threading: Always called on the main worker thread.

Author:

    Seth Pollack (sethp)        16-Feb-2000

Revision History:

--*/



#include  "precomp.h"



/***************************************************************************++

Routine Description:

    Constructor for the CONFIG_AND_CONTROL_MANAGER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONFIG_AND_CONTROL_MANAGER::CONFIG_AND_CONTROL_MANAGER(
    )
    :
    m_ConfigManager()
{

    m_pControlApiClassFactory = NULL;

    m_CoInitialized = FALSE;

    m_ProcessChanges = TRUE;

    m_ClassObjectCookie = 0;

    m_Signature = CONFIG_AND_CONTROL_MANAGER_SIGNATURE;

}   // CONFIG_AND_CONTROL_MANAGER::CONFIG_AND_CONTROL_MANAGER



/***************************************************************************++

Routine Description:

    Destructor for the CONFIG_AND_CONTROL_MANAGER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONFIG_AND_CONTROL_MANAGER::~CONFIG_AND_CONTROL_MANAGER(
    )
{

    DBG_ASSERT( m_Signature == CONFIG_AND_CONTROL_MANAGER_SIGNATURE );

    m_Signature = CONFIG_AND_CONTROL_MANAGER_SIGNATURE_FREED;

    DBG_ASSERT( m_pControlApiClassFactory == NULL );

    // Don't assert about m_ProcessChanges being false, because
    // it could be that we didn't actually get far enough in initialization
    // to change it from true.  This will happen if initializing the queue
    // fails.

    DBG_ASSERT( m_CoInitialized == FALSE );


}   // CONFIG_AND_CONTROL_MANAGER::~CONFIG_AND_CONTROL_MANAGER



/***************************************************************************++

Routine Description:

    Initialize the configuration manager.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_AND_CONTROL_MANAGER::Initialize(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    hr = CoInitializeEx(
                NULL,                   // reserved
                COINIT_MULTITHREADED    // threading model
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing COM failed\n"
            ));

        goto exit;
    }

    m_CoInitialized = TRUE;


    //
    // Read the initial configuration.
    //

    hr = m_ConfigManager.Initialize();
    if ( FAILED( hr ) )
    {
    
        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_CONFIG_MANAGER_INITIALIZATION_FAILED,              // message id
                0,                                                     // count of strings
                NULL,                                                  // array of strings
                hr                                                     // error code
                );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing configuration manager failed\n"
            ));

        goto exit;
    }


    //
    // Set up the control api class factory.
    //

    hr = InitializeControlApiClassFactory();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing control api class factory failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // CONFIG_AND_CONTROL_MANAGER::Initialize



/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities 
    which may hold a reference to this object to release that reference 
    (and not take any more), in order to break reference cycles. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
CONFIG_AND_CONTROL_MANAGER::Terminate(
    )
{

    //
    // Stop processing config change notifications and control operations 
    // now, if we haven't already.
    //

    StopChangeProcessing();


    //
    // Terminate the config manager. This will also ensure that config
    // change processing stops, as that could generate new WORK_ITEMs.
    //
    
    m_ConfigManager.Terminate();


    //
    // CoUninitialize. Make sure we do it on the same thread we CoInitialize'd
    // on originally.
    //

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    CoFreeUnusedLibrariesEx(0, 0);

    if ( m_CoInitialized )
    {
        CoUninitialize();
        m_CoInitialized = FALSE;
    }

}   // CONFIG_AND_CONTROL_MANAGER::Terminate



/***************************************************************************++

Routine Description:

    Discontinue accepting and processing config changes and control 
    operations. This can be safely called multiple times. 

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
CONFIG_AND_CONTROL_MANAGER::StopChangeProcessing(
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    if ( m_ProcessChanges )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Disabling config change and control operation processing\n"
                ));
        }

        m_ProcessChanges = FALSE;

        //
        // Tear down the control api class factory. This will prevent new 
        // callers from being able to get our control interface. 
        //

        TerminateControlApiClassFactory();

        //
        // Turn off config change processing.
        //

        m_ConfigManager.StopChangeProcessing();

        //
        // Note that control operation processing if turned off implicitly
        // as soon as we set m_ProcessChanges to FALSE.
        //

    }

}   // CONFIG_AND_CONTROL_MANAGER::StopChangeProcessing


/***************************************************************************++

Routine Description:

    Create and register the class factory for the control api.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_AND_CONTROL_MANAGER::InitializeControlApiClassFactory(
    )
{

    HRESULT hr = S_OK;


    //
    // Create the class factory.
    //

    DBG_ASSERT( m_pControlApiClassFactory == NULL );
    
    m_pControlApiClassFactory = new CONTROL_API_CLASS_FACTORY();

    if ( m_pControlApiClassFactory == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating CONTROL_API_CLASS_FACTORY failed\n"
            ));

        goto exit;
    }


    //
    // Register it with COM.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Registering control api class factory\n"
            ));
    }

    hr = CoRegisterClassObject(
                CLSID_W3Control,                // CLSID
                m_pControlApiClassFactory,      // class factory pointer
                CLSCTX_LOCAL_SERVER,                  // allowed class contexts
                REGCLS_MULTIPLEUSE,             // multi-use
                &m_ClassObjectCookie            // returned cookie
                ); 

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Registering class object failed\n"
            ));

        //
        // Clean up the class object now, since we couldn't register it.
        //

        m_pControlApiClassFactory->Release();
        m_pControlApiClassFactory = NULL;


        goto exit;
    }


exit:

    return hr;

}   // CONFIG_AND_CONTROL_MANAGER::InitializeControlApiClassFactory



/***************************************************************************++

Routine Description:

    Revoke and clean up the class factory for the control api.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
CONFIG_AND_CONTROL_MANAGER::TerminateControlApiClassFactory(
    )
{

    //
    // Only clean up if we haven't already.
    //

    if ( m_pControlApiClassFactory != NULL )
    {

        //
        // Unregister it with COM.
        //

        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Revoking control api class factory\n"
                ));
        }

        DBG_REQUIRE( SUCCEEDED( CoRevokeClassObject( m_ClassObjectCookie ) ) );


        //
        // Clean up the class object.
        //

        m_pControlApiClassFactory->Release();
        m_pControlApiClassFactory = NULL;

    }


    return;

}   // CONFIG_AND_CONTROL_MANAGER::TerminateControlApiClassFactory
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\control_api.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    control_api.h

Abstract:

    The IIS web admin service control api class definition.

Author:

    Seth Pollack (sethp)        15-Feb-2000

Revision History:

--*/



#ifndef _CONTROL_API_H_
#define _CONTROL_API_H_



//
// common #defines
//

#define CONTROL_API_SIGNATURE       CREATE_SIGNATURE( 'CAPI' )
#define CONTROL_API_SIGNATURE_FREED CREATE_SIGNATURE( 'capX' )



//
// prototypes
//


class CONTROL_API
    : public IW3Control
{

public:

    CONTROL_API(
        );

    virtual
    ~CONTROL_API(
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    QueryInterface(
        IN REFIID iid,
        OUT VOID ** ppObject
        );

    virtual
    ULONG
    STDMETHODCALLTYPE
    AddRef(
        );

    virtual
    ULONG
    STDMETHODCALLTYPE
    Release(
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    RecycleAppPool(
        IN LPCWSTR szAppPool
        );

private:

    HRESULT
    MarshallCallToMainWorkerThread(
        IN CONTROL_API_CALL_METHOD Method,
        IN DWORD_PTR Param0 OPTIONAL = 0,
        IN DWORD_PTR Param1 OPTIONAL = 0,
        IN DWORD_PTR Param2 OPTIONAL = 0,
        IN DWORD_PTR Param3 OPTIONAL = 0
        );


    DWORD m_Signature;

    LONG m_RefCount;


};  // class CONTROL_API



#endif  // _CONTROL_API_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\config_and_control_manager.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    config_and_control_manager.h

Abstract:

    The IIS web admin service configuration and control manager class 
    definition.

Author:

    Seth Pollack (sethp)        16-Feb-2000

Revision History:

--*/



#ifndef _CONFIG_AND_CONTROL_MANAGER_H_
#define _CONFIG_AND_CONTROL_MANAGER_H_



//
// common #defines
//

#define CONFIG_AND_CONTROL_MANAGER_SIGNATURE        CREATE_SIGNATURE( 'CCMG' )
#define CONFIG_AND_CONTROL_MANAGER_SIGNATURE_FREED  CREATE_SIGNATURE( 'ccmX' )



//
// prototypes
//


class CONFIG_AND_CONTROL_MANAGER
{

public:

    CONFIG_AND_CONTROL_MANAGER(
        );

    virtual
    ~CONFIG_AND_CONTROL_MANAGER(
        );

    HRESULT
    Initialize(
        );

    VOID
    Terminate(
        );

    VOID
    StopChangeProcessing(
        );

    inline
    CONFIG_MANAGER *
    GetConfigManager(
        )
    { 
        return &m_ConfigManager;
    }

    inline
    BOOL
    IsChangeProcessingEnabled(
        )
    { 
        return m_ProcessChanges;
    }


private:

	CONFIG_AND_CONTROL_MANAGER( const CONFIG_AND_CONTROL_MANAGER & );
	void operator=( const CONFIG_AND_CONTROL_MANAGER & );

    HRESULT
    InitializeControlApiClassFactory(
        );

    VOID
    TerminateControlApiClassFactory(
        );


    DWORD m_Signature;

    // brokers configuration state and changes
    CONFIG_MANAGER m_ConfigManager;

    // class factory for the control api
    CONTROL_API_CLASS_FACTORY * m_pControlApiClassFactory;

    BOOL m_CoInitialized;

    BOOL m_ProcessChanges;

    DWORD m_ClassObjectCookie;


};  // class CONFIG_AND_CONTROL_MANAGER



#endif  // _CONFIG_AND_CONTROL_MANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\config_manager.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    config_manager.cxx

Abstract:

    The IIS web admin service configuration manager class implementation.
    This class manages access to configuration metadata, as well as
    handling dynamic configuration changes.

    Threading: Access to configuration metadata is done on the main worker
    thread. Configuration changes arrive on COM threads (i.e., secondary
    threads), and so work items are posted to process the changes on the main
    worker thread.

Author:

    Seth Pollack (sethp)        5-Jan-1999

Revision History:

--*/



#include  "precomp.h"

//
// This is declared in iiscnfg.h but it is ansii and we need unicode.
#define IIS_MD_SVC_INFO_PATH_W            L"Info"

DWORD WINAPI
ChangeNotificationLauncher(
    LPVOID lpParameter   // thread data
    );

// callback for inetinfo monitor.
VOID
NotifyOfInetinfoFailure(
    INETINFO_CRASH_ACTION CrashAction
    );

/***************************************************************************++

Routine Description:

    Constructor for the CONFIG_MANAGER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONFIG_MANAGER::CONFIG_MANAGER(
    )
{

    //
    // critical section used while we are addref'ing the
    // AboManager and while we are changing the AboManager
    // for a new one.
    //

    //
    // this can throw in low memory conditions,
    // but if it does it's during startup
    // and the W3SVC just will not startup.
    //
    InitializeCriticalSection ( &m_AboCritSec );

    m_pAboManager = NULL;

    m_ListenerThreadId = 0;

    m_hListener = NULL;

    m_pChangeProcessor = NULL;

    m_pCurrentAppTable = NULL;

    m_pCurrentSiteTable = NULL;

    m_ProcessChanges = FALSE;

    m_NumChangesProcessed = 0;

    // needs to start at one, because the first time
    // we hook up the admin base object it will drop to zero.
    m_MetabaseIsInCrashedState = 1;

    // always assume that it is working unless the 
    // shutdown log has been called.
    m_InetinfoMonitorFatalErrors = 0;

    m_ConfigThreadProcessingDisabled = 0;

    m_hCryptProvider = NULL;

    m_hSignalConfigInitializationComplete = NULL;

    m_hrConfigThreadInitialization = E_FAIL;

    m_InInitializationPhase = FALSE;

    m_NumberOfPoolStateWritingFailed = 0;

    m_NumberOfSiteStateWritingFailed = 0;


    m_Signature = CONFIG_MANAGER_SIGNATURE;

}   // CONFIG_MANAGER::CONFIG_MANAGER



/***************************************************************************++

Routine Description:

    Destructor for the CONFIG_MANAGER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONFIG_MANAGER::~CONFIG_MANAGER(
    )
{
    DBG_ASSERT( m_Signature == CONFIG_MANAGER_SIGNATURE );

    m_Signature = CONFIG_MANAGER_SIGNATURE_FREED;

    DBG_ASSERT ( m_hListener == NULL );
    DBG_ASSERT ( m_ListenerThreadId == 0 );
    DBG_ASSERT ( m_pAboManager == NULL );

    if ( m_pChangeProcessor )
    {
        m_pChangeProcessor->Dereference();
        m_pChangeProcessor = NULL;
    }

    DBG_ASSERT ( m_hCryptProvider == NULL );

    DBG_ASSERT ( m_hSignalConfigInitializationComplete == NULL );

    DeleteCriticalSection ( &m_AboCritSec );

}   // CONFIG_MANAGER::~CONFIG_MANAGER



/***************************************************************************++

Routine Description:

    Initialize the configuration manager.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::Initialize(
    )
{


    HRESULT hr = S_OK;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT ( m_hCryptProvider == NULL );


    // setup the crypt context so that we can
    // has passwords and compare the hashes.
    if ( !CryptAcquireContext( &m_hCryptProvider,
                               NULL,
                               NULL,
                               PROV_RSA_FULL,
                               CRYPT_VERIFYCONTEXT ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "unable to initialize crypt provider for hashing passwords\n"
            ));

        goto exit;
    }

    //
    // need to setup to monitor the inetinfo process because we are
    // going to establish an interface to it, and we need to make sure
    // that we know if something happens to it.
    //
    hr = StartIISAdminMonitor(&NotifyOfInetinfoFailure);
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not initialize iisadmin monitor\n"
            ));

        goto exit;
    }


    m_pChangeProcessor = new CHANGE_PROCESSOR();
    if ( m_pChangeProcessor == NULL )
    {
        hr = E_OUTOFMEMORY;

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not create the change processor object \n"
            ));

        goto exit;
    }

    //
    // need to let the change processor setup any
    // crutial pieces before we are use it.
    // if this fails we need to get rid of the
    // change processor, because otherwise we will
    // end up calling the shutdown on it and we
    // are not setup correctly to do this.
    //
    hr = m_pChangeProcessor->Initialize();
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to initialize the Change Processor \n"
            ));

        m_pChangeProcessor->Dereference();
        m_pChangeProcessor = NULL;

        goto exit;
    }


    //
    // used to create the metabase interface.
    //
    hr = ReestablishAdminBaseObject();
    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Creating metabase base failed\n"
            ));

        goto exit;
    }

    //
    // ReestablishAdminBaseObject() created a new heap at CoCreateInstance
    // make it (and all of the other process heaps) Low Fragmentation Heaps
    //
    MakeAllProcessHeapsLFH();

    //
    // Configure the metabase to advertise the features the
    // server supports.
    //
    AdvertiseServiceInformationInMB();

    //
    // Steps are:
    //
    // 1) Create the CNP Thread which will
    // 2)    Issue a blocking work item to the CNP Thread
    // 3)    Start listener for change notifications.
    // 4) InitializeDataObjects
    // 5) PerformCrossValidation
    // 6) PassDataObjects To WAS
    //

    hr = LaunchChangeNotificationListener();
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to launch change notifcation listener\n"
            ));

        goto exit;
    }

    hr = ReadDataFromMetabase ( &m_AppPoolTable,
                                &m_SiteTable,
                                &m_AppTable,
                                &m_GlobalStore );
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed retrieving data from metabase\n"
            ));

        goto exit;
    }

    hr = CrossValidateDataObjects();
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed cross validating data from metabase\n"
            ));

        goto exit;
    }

    m_AppPoolTable.Dump();
    m_SiteTable.Dump();
    m_AppTable.Dump();

    m_pCurrentAppTable = &m_AppTable;
    m_pCurrentSiteTable = &m_SiteTable;

    m_InInitializationPhase = TRUE;

    CreateGlobalData();

    m_AppPoolTable.CreateWASObjects();
    m_SiteTable.CreateWASObjects();
    m_AppTable.CreateWASObjects();

    m_pCurrentAppTable = NULL;
    m_pCurrentSiteTable = NULL;

    m_AppPoolTable.ClearDeletedObjects();
    m_SiteTable.ClearDeletedObjects();
    m_AppTable.ClearDeletedObjects();
    m_GlobalStore.ClearDeletedObjects();

    m_ProcessChanges = TRUE;

    // We don't want to be in the initalization phase
    // anymore when we try to re-record these states.
    // If we fail we want the errors logged.
    m_InInitializationPhase = FALSE;

    if ( m_NumberOfPoolStateWritingFailed > 0 )
    {
        m_NumberOfPoolStateWritingFailed = 0;

        GetWebAdminService()->
        GetUlAndWorkerManager()->
        RecordPoolStates(FALSE);
    }

    if ( m_NumberOfSiteStateWritingFailed > 0 )
    {
        m_NumberOfSiteStateWritingFailed = 0;

        GetWebAdminService()->
        GetUlAndWorkerManager()->
        RecordSiteStates();
    }

exit:

    // In case we error'd out we don't want to stay
    // marked as in the initialization phase.
    m_InInitializationPhase = FALSE;

    //
    // whether we failed or not, we need to make
    // sure that the config thread no longer is
    // blocking change notifications.  this way if
    // we fail and are trying to shutdown the thread
    // will be responsive to shutting down.
    //
    HRESULT hr2 = S_OK;

    if ( m_pChangeProcessor )
    {
        hr2 = m_pChangeProcessor->SetBlockingEvent();
        if ( FAILED ( hr2 ) )
        {
            // issue, if this does fail, we will end
            // up not being able to shutdown.  need to
            // decide how likely a failure here is and
            // what a workaround to the hang is.
            DPERROR((
                DBG_CONTEXT,
                hr2,
                "Failed to start processing change notifications \n"
                ));
        }

        //
        // If we are failing this function and we did not launch the
        // config thread, but created the Change Processor we really
        // want to destroy the Change Processor so we don't end up
        // running queued items on the main thread during shutdown.
        //
        if ( FAILED ( hr ) || FAILED ( hr2 ) )
        {
            if ( m_hListener == NULL )
            {
                // Since we have the ChangeProcessor object
                // we made it passed the Initialize call so
                // we need to call the terminate before releasing
                // the object.
                m_pChangeProcessor->Terminate();
                m_pChangeProcessor->Dereference();
                m_pChangeProcessor = NULL;
            }
        }

    }

    //
    // the secondary hresult only really matters if
    // everything was going all right and we failed to
    // set the blocking event.  In this case, we are also
    // going to have a problem and not be able to shutdown.
    //
    if ( SUCCEEDED ( hr ) )
    {
        return hr2;
    }
    else
    {
        return hr;
    }

}   // CONFIG_MANAGER::Initialize

/***************************************************************************++

Routine Description:

    Sets the event that let's the main thread continue after starting up
    the configuration thread.

Arguments:

    None.

Return Value:

    VOID.

--***************************************************************************/
VOID
CONFIG_MANAGER::SignalMainThreadToContinueAfterConfigThreadInitialization(
    )
{
    DBG_ASSERT( ON_CONFIG_WORKER_THREAD );

    DBG_ASSERT( m_hSignalConfigInitializationComplete );

    DBG_REQUIRE ( SetEvent ( m_hSignalConfigInitializationComplete ) );
}

/***************************************************************************++

Routine Description:

    Launches a thread to listen to change notifications.

Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT
CONFIG_MANAGER::LaunchChangeNotificationListener(
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT ( m_hListener == NULL );
    DBG_ASSERT ( m_pAboManager );

    DBG_ASSERT ( m_pChangeProcessor != NULL );
    DBG_ASSERT ( m_hSignalConfigInitializationComplete == NULL );

    //
    // Need to create an event so that we can wait for the change notification
    // thread to complete it's initialization phase.
    //
    m_hSignalConfigInitializationComplete = CreateEvent( NULL,   // SD
                                                        TRUE,   // must call reset
                                                        FALSE,  // initially not signaled
                                                        NULL ); // not named

    if ( m_hSignalConfigInitializationComplete == NULL )
    {
        hr = GetLastError();

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to initialize blocking event to wait on config thread starting\n"
            ));

        goto exit;
    }


    m_hListener = CreateThread ( NULL,
                        // Big initial size to prevent stack overflows
                        IIS_DEFAULT_INITIAL_STACK_SIZE,
                        &ChangeNotificationLauncher,
                        m_pChangeProcessor,
                        0,
                        &m_ListenerThreadId );

    if ( m_hListener == NULL )
    {
        hr = GetLastError();
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to launch the thread to handle change notifications\n"
            ));

        goto exit;
    }

    GetWebAdminService()->SetConfigThreadId( m_ListenerThreadId );

    // now wait for the config thread to do it's thing.
    DBG_REQUIRE ( WaitForSingleObject( m_hSignalConfigInitializationComplete, INFINITE ) == WAIT_OBJECT_0 );

    DBG_ASSERT ( hr == S_OK );

    // Now send back out any error we may have experienced, this will cause startup to fail.
    hr = m_hrConfigThreadInitialization;

exit:

    // We no longer need the event now.
    if ( m_hSignalConfigInitializationComplete )
    {
        CloseHandle( m_hSignalConfigInitializationComplete );
        m_hSignalConfigInitializationComplete = NULL;
    }

    return hr;
}


/***************************************************************************++

Routine Description:

    Populates each of the three LKRHashes with the
    appropriate data from the metabase.

Arguments:

    None.

Return Value:

    HRESULT.  -- Failure will result in either initialization failing
                 or an event log because we failed while trying to rehook
                 to the metabase after a crash.

--***************************************************************************/
HRESULT
CONFIG_MANAGER::ReadDataFromMetabase(
    APP_POOL_DATA_OBJECT_TABLE*     pAppPoolTable,
    SITE_DATA_OBJECT_TABLE*         pSiteTable,
    APPLICATION_DATA_OBJECT_TABLE*  pAppTable,
    GLOBAL_DATA_STORE*              pGlobalStore
    )
{
    HRESULT hr = S_OK;
    ABO_MANAGER* pAboManager = NULL;

    DBG_ASSERT ( m_pAboManager );

    DBG_ASSERT ( pAppPoolTable );
    DBG_ASSERT ( pSiteTable );
    DBG_ASSERT ( pAppTable );
    DBG_ASSERT ( pGlobalStore );

    // enter the critical section just long
    // enough to make sure the ABO you add ref
    // is the ABO that we hold onto.
    EnterCriticalSection ( &m_AboCritSec );
    pAboManager = m_pAboManager;
    pAboManager->ReferenceAboManager();
    LeaveCriticalSection ( &m_AboCritSec );

    //
    // Setup the Global data.
    //
    hr = pGlobalStore->ReadFromMetabase( pAboManager->GetAdminBasePtr() );
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to initialize the global data from the metabase\n"
            ));

        goto exit;
    }

    DBG_ASSERT ( pGlobalStore->QueryGlobalDataObject() );

    pGlobalStore->QueryGlobalDataObject()->SelfValidate();

    //
    // Setup the AppPoolTable with fresh data.
    //
    hr = pAppPoolTable->ReadFromMetabase( pAboManager->GetAdminBasePtr() );
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to initialize the app pool table with data from the metabase\n"
            ));

        goto exit;
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Size of Pool Table = %d\n",
            pAppPoolTable->Size() ));
    }


    pAppPoolTable->PerformSelfValidation();


    //
    // Setup the SitesTable with fresh data.
    //
    hr = pSiteTable->ReadFromMetabase( pAboManager->GetAdminBasePtr() );
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to initialize the site table with data from the metabase\n"
            ));

        goto exit;
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Size of Site Table = %d\n",
            pSiteTable->Size() ));
    }


    pSiteTable->PerformSelfValidation();

    //
    // Setup the AppPoolTable with fresh data.
    //
    hr = pAppTable->ReadFromMetabase( pAboManager->GetAdminBasePtr() );
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to initialize the applications table with data from the metabase\n"
            ));

        goto exit;
    }

    pAppTable->PerformSelfValidation();

    IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Size of App Table = %d\n",
            pAppTable->Size() ));
    }

exit:

    if ( pAboManager )
    {
        pAboManager->DereferenceAboManager();
        pAboManager = NULL;
    }

    return hr;

}

/***************************************************************************++

Routine Description:

    Creates and returns three LKRHashes that contain the information
    neccessary to process the change notification.

Arguments:

    None.

Return Value:

    HRESULT  -- Error is logged above and changes are dropped

--***************************************************************************/
HRESULT
CONFIG_MANAGER::CreateTempDataObjectTables(
    IN DWORD               dwMDNumElements,
    IN MD_CHANGE_OBJECT    pcoChangeList[],
    OUT APP_POOL_DATA_OBJECT_TABLE** ppAppPoolTable,
    OUT SITE_DATA_OBJECT_TABLE** ppSiteTable,
    OUT APPLICATION_DATA_OBJECT_TABLE** ppApplicationTable,
    OUT GLOBAL_DATA_STORE** ppGlobalStore
    )
{
    HRESULT hr = S_OK;

    APP_POOL_DATA_OBJECT_TABLE*     pAppPoolTable = NULL;
    SITE_DATA_OBJECT_TABLE*         pSiteTable = NULL;
    APPLICATION_DATA_OBJECT_TABLE*  pApplicationTable = NULL;
    GLOBAL_DATA_STORE*              pGlobalStore = NULL;
    ABO_MANAGER*                    pAboManager = NULL;

    DBG_ASSERT( ON_CONFIG_WORKER_THREAD );

    DBG_ASSERT( ppAppPoolTable && *ppAppPoolTable == NULL );
    DBG_ASSERT( ppSiteTable && *ppSiteTable == NULL );
    DBG_ASSERT( ppApplicationTable && *ppApplicationTable == NULL );
    DBG_ASSERT( ppGlobalStore && *ppGlobalStore == NULL );

    DBG_ASSERT ( dwMDNumElements > 0 );
    DBG_ASSERT ( pcoChangeList );

    // enter the critical section just long
    // enough to make sure the ABO you add ref
    // is the ABO that we hold onto.
    EnterCriticalSection ( &m_AboCritSec );
    DBG_ASSERT ( m_pAboManager );
    pAboManager = m_pAboManager;
    pAboManager->ReferenceAboManager();
    LeaveCriticalSection ( &m_AboCritSec );

    //
    // Need to create all the objects.
    //

    pAppPoolTable = new APP_POOL_DATA_OBJECT_TABLE();
    if ( pAppPoolTable == NULL )
    {
        hr = E_OUTOFMEMORY;

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to allocate temp table\n"
            ));

        goto exit;
    }

    pSiteTable = new SITE_DATA_OBJECT_TABLE();
    if ( pSiteTable == NULL )
    {
        hr = E_OUTOFMEMORY;

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to allocate temp table\n"
            ));

        goto exit;
    }

    pApplicationTable = new APPLICATION_DATA_OBJECT_TABLE();
    if ( pApplicationTable == NULL )
    {
        hr = E_OUTOFMEMORY;

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to allocate temp table\n"
            ));

        goto exit;
    }

    pGlobalStore = new GLOBAL_DATA_STORE();
    if ( pGlobalStore == NULL )
    {
        hr = E_OUTOFMEMORY;

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to allocate temp table\n"
            ));

        goto exit;
    }

    //
    // Setup the Global data.
    //
    hr = pGlobalStore->ReadFromMetabaseChangeNotification(
                                        pAboManager->GetAdminBasePtr(),
                                        pcoChangeList,
                                        dwMDNumElements,
                                        &m_GlobalStore);
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to initialize the temp global data from the metabase change\n"
            ));

        goto exit;
    }

    //
    // Setup the AppPoolTable with fresh data.
    //
    hr = pAppPoolTable->ReadFromMetabaseChangeNotification(
                                        pAboManager->GetAdminBasePtr(),
                                        pcoChangeList,
                                        dwMDNumElements,
                                        &m_AppPoolTable);
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to initialize the temp app pool data from the metabase change\n"
            ));

        goto exit;
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Size of Temp Pool Table = %d\n",
            pAppPoolTable->Size() ));
    }



    //
    // Setup the Site table with fresh data.
    //
    hr = pSiteTable->ReadFromMetabaseChangeNotification(
                                        pAboManager->GetAdminBasePtr(),
                                        pcoChangeList,
                                        dwMDNumElements,
                                        &m_SiteTable);
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to initialize the temp site data from the metabase change\n"
            ));

        goto exit;
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Size of temp site table = %d\n",
            pSiteTable->Size() ));
    }


    //
    // Setup the application table with fresh data.
    //
    hr = pApplicationTable->ReadFromMetabaseChangeNotification(
                                        pAboManager->GetAdminBasePtr(),
                                        pcoChangeList,
                                        dwMDNumElements,
                                        &m_AppTable);
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to initialize the temp app data from the metabase change\n"
            ));

        goto exit;
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Size of temp app table = %d\n",
            pApplicationTable->Size() ));
    }


exit:

    if ( FAILED ( hr ) )
    {
        if ( pApplicationTable )
        {
            delete pApplicationTable;
            pApplicationTable = NULL;
        }

        if ( pSiteTable )
        {
            delete pSiteTable;
            pSiteTable = NULL;
        }

        if ( pAppPoolTable )
        {
            delete pAppPoolTable;
            pAppPoolTable = NULL;
        }

        if ( pGlobalStore )
        {
            delete pGlobalStore;
            pGlobalStore = NULL;
        }
    }

    if ( pAboManager )
    {
        pAboManager->DereferenceAboManager();
        pAboManager = NULL;
    }

    // set the out parameters.
    *ppAppPoolTable     = pAppPoolTable;
    *ppSiteTable        = pSiteTable;
    *ppApplicationTable = pApplicationTable;
    *ppGlobalStore      = pGlobalStore;

    return hr;

}  // end of CONFIG_MANAGER::CreateTempDataObjectTables

/***************************************************************************++

Routine Description:

    Merges the temp tables into the main tables and then self validates
    all the main tables.

Arguments:

    IN APP_POOL_DATA_OBJECT_TABLE*      pAppPoolTable,
    IN SITE_DATA_OBJECT_TABLE*          pSiteTable,
    IN APPLICATION_DATA_OBJECT_TABLE*   pApplicationTable,
    IN GLOBAL_DATA_STORE*               pGlobalStore

Return Value:

    HRESULT. -- End up being logged by calling functions.

--***************************************************************************/
HRESULT
CONFIG_MANAGER::MergeAndSelfValidateTables(
    IN APP_POOL_DATA_OBJECT_TABLE*      pAppPoolTable,
    IN SITE_DATA_OBJECT_TABLE*          pSiteTable,
    IN APPLICATION_DATA_OBJECT_TABLE*   pApplicationTable,
    IN GLOBAL_DATA_STORE*               pGlobalStore
    )
{
    HRESULT hr = S_OK;

    DBG_ASSERT( ON_CONFIG_WORKER_THREAD );

    DBG_ASSERT( pAppPoolTable );
    DBG_ASSERT( pSiteTable );
    DBG_ASSERT( pApplicationTable );
    DBG_ASSERT( pGlobalStore );

    //
    // Need to merge each table and then validate it.
    //

    //
    // Merge the Global data.
    //
    hr = m_GlobalStore.MergeTable( pGlobalStore );
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to merge the global data\n"
            ));

        goto exit;
    }

    DBG_ASSERT ( m_GlobalStore.QueryGlobalDataObject() );

    m_GlobalStore.QueryGlobalDataObject()->SelfValidate();

    //
    // Merge the AppPoolTable with fresh data.
    //
    hr = m_AppPoolTable.MergeTable( pAppPoolTable );
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to merge the app pool data\n"
            ));

        goto exit;
    }

    m_AppPoolTable.PerformSelfValidation();


    IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Size of Pool Orig Table = %d, Temp Table %d\n",
            m_AppPoolTable.Size(),
            pAppPoolTable->Size() ));

    }

    //
    // Merge the Site table with fresh data.
    //
    hr = m_SiteTable.MergeTable( pSiteTable );
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to merge the site data\n"
            ));

        goto exit;
    }

    m_SiteTable.PerformSelfValidation();

    IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Size of site Orig Table = %d, Temp Table %d\n",
            m_SiteTable.Size(),
            pSiteTable->Size() ));
    }


    //
    // Merge the application table with fresh data.
    //
    hr = m_AppTable.MergeTable( pApplicationTable );
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to merge the application data\n"
            ));

        goto exit;
    }

    m_AppTable.PerformSelfValidation();

    IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Size of app Orig Table = %d, Temp Table %d\n",
            m_AppTable.Size(),
            pApplicationTable->Size() ));
    }


exit:

    return hr;

}  // end of CONFIG_MANAGER::MergeAndSelfValidateTables

/***************************************************************************++

Routine Description:

    Performs cross validation of the three data tables

Arguments:

    None.

Return Value:

    HRESULT.  -- either will be called during initalization and server
                 will not start, or will be logged by outside calling routine.

--***************************************************************************/
HRESULT
CONFIG_MANAGER::CrossValidateDataObjects(
    )
{
    SITE_DATA_OBJECT *              pSiteObject = NULL;
    APPLICATION_DATA_OBJECT_KEY     applicationKey;
    APPLICATION_DATA_OBJECT *       pApplicationObject;
    APP_POOL_DATA_OBJECT_KEY        appPoolKey;
    SITE_DATA_OBJECT_KEY            siteKey;
    APP_POOL_DATA_OBJECT *          pAppPoolObject = NULL;
    HRESULT                         hr;
    LK_RETCODE                      lkrc;

    //
    // Step 1: Validate that all applications have valid apppools.
    //

    for ( APPLICATION_DATA_OBJECT_TABLE::iterator iter = m_AppTable.begin();
          iter != m_AppTable.end();
          ++iter )
    {
        pApplicationObject = (APPLICATION_DATA_OBJECT*) iter.Record();
        DBG_ASSERT( pApplicationObject->CheckSignature() );

        //
        // Only cross validate the application if we suspect that WAS will
        // no about the object once the change is complete.
        //
        if ( pApplicationObject->QueryWillWasKnowAboutObject() )
        {

            IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Application '%S' for site '%d' AppPoolId = '%S' \n ",
                            pApplicationObject->QueryApplicationUrl(),
                            pApplicationObject->QuerySiteId(),
                            pApplicationObject->QueryAppPoolId() ));
            }

            //
            // check for the valid app pool.
            //

            hr = appPoolKey.SetAppPoolId( pApplicationObject->QueryAppPoolId() );
            if ( FAILED( hr ) )
            {
                return hr;
            }

            lkrc = m_AppPoolTable.FindKey( &appPoolKey,
                                           (DATA_OBJECT**) &pAppPoolObject );
            if ( lkrc != LK_SUCCESS )
            {
                //
                // This application is invalid
                //

                pApplicationObject->SetCrossValid( FALSE );
            }
            else
            {
                DBG_ASSERT( pAppPoolObject != NULL );

                //
                // if the app pool will not be in WAS then this
                // application is not valid.
                //
                if ( !pAppPoolObject->QueryWillWasKnowAboutObject()  )
                {
                    pApplicationObject->SetCrossValid( FALSE );
                }

                pAppPoolObject->DereferenceDataObject();
            }

            //
            // if this applicaiton is no longer valid because we
            // failed finding an app pool to match it, then we need
            // to log an error here before continuing on and ignoring the application.
            //
            if ( pApplicationObject->QueryCrossValid() == FALSE )
            {
                GetWebAdminService()->
                GetWMSLogger()->
                LogApplicationInvalidDueToMissingAppPoolId(
                                      pApplicationObject->QuerySiteId(),
                                      pApplicationObject->QueryApplicationUrl(),
                                      pApplicationObject->QueryAppPoolId(),
                                      pApplicationObject->QueryInWas());

            }


        }

    }

    //
    // Step 2: Validate sites which means
    //         a) If the site has a root application, is that app valid
    //         b) If the site does not have a root app, its is inherited
    //            AppPoolId valid
    //

    for ( SITE_DATA_OBJECT_TABLE::iterator siteiter = m_SiteTable.begin();
          siteiter != m_SiteTable.end();
          ++siteiter )
    {
        pSiteObject = (SITE_DATA_OBJECT*) siteiter.Record();
        DBG_ASSERT( pSiteObject->CheckSignature() );

        //
        // Does that application already exist?
        //

        //
        // Only cross validate the one's that we expect WAS to care about.
        //
        if ( pSiteObject->QueryWillWasKnowAboutObject() )
        {

            hr = applicationKey.Create( L"/", pSiteObject->QuerySiteId() );
            if ( FAILED( hr ) )
            {
                return hr;
            }

            lkrc = m_AppTable.FindKey( &applicationKey,
                                       (DATA_OBJECT**) &pApplicationObject );
            if ( lkrc != LK_SUCCESS )
            {
                //
                // No root application, does at least the AppPool look valid?
                //

                //
                // This is coming from a STRU so it won't ever be NULL
                // but just to be safe we do the check.  However after that
                // we also need to make sure that it is not just an empty string,
                // which is what it would be if it were NULL.
                //
                if ( pSiteObject->QueryAppPoolId() == NULL ||
                     pSiteObject->QueryAppPoolId()[0] == '\0' )
                {
                    pSiteObject->SetCrossValid( FALSE );
                }
                else
                {
                    //
                    // Lookup the AppPool
                    //

                    hr = appPoolKey.SetAppPoolId( pSiteObject->QueryAppPoolId() );
                    if ( FAILED( hr ) )
                    {
                        return hr;
                    }

                    lkrc = m_AppPoolTable.FindKey( &appPoolKey,
                                                   (DATA_OBJECT**) &pAppPoolObject );
                    if ( lkrc != LK_SUCCESS )
                    {
                        pSiteObject->SetCrossValid( FALSE );
                    }
                    else
                    {
                        DBG_ASSERT( pAppPoolObject != NULL );

                        if ( !pAppPoolObject->QueryWillWasKnowAboutObject() )
                        {
                            pSiteObject->SetCrossValid( FALSE );
                        }

                        pAppPoolObject->DereferenceDataObject();
                    }
                }

                if ( pSiteObject->QueryCrossValid() == FALSE )
                {
                    GetWebAdminService()->
                    GetWMSLogger()->
                    LogSiteInvalidDueToMissingAppPoolId(
                                          pSiteObject->QuerySiteId(),
                                          pSiteObject->QueryAppPoolId(),
                                          pSiteObject->QueryInWas());

                }

            }
            else
            {

                //
                // We found a root application, check its validity
                //

                DBG_ASSERT( pApplicationObject != NULL );

                //
                // We only care if it is self valid or cross valid
                // if it is marked to be deleted this is fine, because
                // the virtual site should create a new application
                // to take it's place.
                //
                if ( !pApplicationObject->QuerySelfValid() ||
                     !pApplicationObject->QueryCrossValid()  )
                {
                    pSiteObject->SetCrossValid( FALSE );

                    GetWebAdminService()->
                    GetWMSLogger()->
                    LogSiteInvalidDueToMissingAppPoolIdOnRootApp(
                                          pSiteObject->QuerySiteId(),
                                          pApplicationObject->QueryAppPoolId(),
                                          pSiteObject->QueryInWas());

                }

                pApplicationObject->DereferenceDataObject();
            }
        }
    }

    //
    // Step 3: Validate that all applications have valid sites.
    //

    for ( APPLICATION_DATA_OBJECT_TABLE::iterator iter = m_AppTable.begin();
          iter != m_AppTable.end();
          ++iter )
    {
        pApplicationObject = (APPLICATION_DATA_OBJECT*) iter.Record();
        DBG_ASSERT( pApplicationObject->CheckSignature() );

        //
        // Only cross validate the application if it is marked as self valid,
        // cross valid and is not being deleted.
        //
        //
        if ( pApplicationObject->QueryWillWasKnowAboutObject() )
        {

            IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Validating site exits on Application '%S' for site '%d' AppPoolId = '%S' \n ",
                            pApplicationObject->QueryApplicationUrl(),
                            pApplicationObject->QuerySiteId(),
                            pApplicationObject->QueryAppPoolId() ));
            }

            siteKey.SetSiteId( pApplicationObject->QuerySiteId() );

            lkrc = m_SiteTable.FindKey( &siteKey,
                                           (DATA_OBJECT**) &pSiteObject );
            if ( lkrc != LK_SUCCESS )
            {
                //
                // This application is invalid
                //

                //
                // For site's we shouldn't see applications for sites
                // that don't really exist.
                //
                DBG_ASSERT ( lkrc == LK_SUCCESS );

                pApplicationObject->SetCrossValid( FALSE );
            }
            else
            {
                DBG_ASSERT( pSiteObject != NULL );

                if ( !pSiteObject->QueryWillWasKnowAboutObject() )
                {
                    pApplicationObject->SetCrossValid( FALSE );
                }

                pSiteObject->DereferenceDataObject();
            }

            //
            // if this applicaiton is no longer valid because we
            // failed finding an app pool to match it, then we need
            // to log an error here before continuing on and ignoring the application.
            //
            if ( pApplicationObject->QueryCrossValid() == FALSE )
            {
                GetWebAdminService()->
                GetWMSLogger()->
                LogApplicationInvalidDueToMissingSite(
                                      pApplicationObject->QuerySiteId(),
                                      pApplicationObject->QueryApplicationUrl(),
                                      pApplicationObject->QueryInWas());

            }

        }

    }

    return S_OK;
}

/***************************************************************************++

Routine Description:

    Initializes the global data for the W3SVC

Arguments:

    None.

Return Value:

    VOID.

--***************************************************************************/

VOID
CONFIG_MANAGER::CreateGlobalData(
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    GLOBAL_DATA_OBJECT* pGlobalObject = m_GlobalStore.QueryGlobalDataObject();
    DBG_ASSERT ( pGlobalObject );

    // Next tell the WEB_ADMIN_SERVICE if we are doing Centralized or Site Logging.
    GetWebAdminService()->
         SetGlobalBinaryLogging( pGlobalObject->
                                   QueryGlobalBinaryLoggingEnabled() );

    // Now tell the UL_MANAGER to update it's properties.
    m_GlobalStore.UpdateWASObjects();

}   // CONFIG_MANAGER::CreateGlobalData



/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities
    which may hold a reference to this object to release that reference
    (and not take any more), in order to break reference cycles.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
CONFIG_MANAGER::Terminate(
    )
{

    // Wait for Config thread to shutdown.  We will
    // have called the RequestShutdown before now and
    // the thread should of ended.
    if ( m_hListener != NULL )
    {
        WaitForSingleObject(m_hListener, INFINITE);
        CloseHandle( m_hListener );
        m_hListener = NULL;
        m_ListenerThreadId = 0;
    }

    //
    // Now that the config thread has finished we can
    // run through the last of the events in the queue
    // Note, that if the m_pChangeProcessor exists, then
    // it was initalized successfully and terminate should
    // be called.
    //
    if ( m_pChangeProcessor )
    {
        m_pChangeProcessor->Terminate();
    }

    //
    // We have to keep monitoring, until we know that we are done doing
    // any writes ( the first time we know this is when Terminate is called
    // on the config manager, because at this point, the apppool. apps, and sites
    // have all ready been terminated ), and after the config thread has exited,
    // so we know they will not be using the metabase.
    //
    StopIISAdminMonitor();

    // release the main reference on
    // the admin base object manager
    EnterCriticalSection ( &m_AboCritSec );
    if ( m_pAboManager )
    {
        m_pAboManager->DereferenceAboManager();
        m_pAboManager = NULL;
    }
    LeaveCriticalSection ( &m_AboCritSec );

    if ( m_hCryptProvider )
    {
        CryptReleaseContext( m_hCryptProvider, 0 );
        m_hCryptProvider = NULL;
    }

}   // CONFIG_MANAGER::Terminate



/***************************************************************************++

Routine Description:

    Process a configuration change notification.

Arguments:

    pChange - The configuration change description object.

Return Value:

    VOID

--***************************************************************************/

VOID
CONFIG_MANAGER::ProcessConfigChange(
    IN WAS_CHANGE_ITEM * pChange
    )
{
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    if ( m_ProcessChanges )
    {
        DBG_ASSERT ( m_pCurrentAppTable == NULL );
        DBG_ASSERT ( m_pCurrentSiteTable == NULL );

        m_pCurrentAppTable = pChange->QueryAppTable();
        m_pCurrentSiteTable = pChange->QuerySiteTable();

        pChange->ProcessChanges();

        m_pCurrentAppTable = NULL;
        m_pCurrentSiteTable = NULL;

    }

}   // CONFIG_MANAGER::ProcessConfigChange



/***************************************************************************++

Routine Description:

    Discontinue both listening for configuration changes, and also
    processing those config changes that have already been queued but not
    yet handled. This can be safely called multiple times.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
CONFIG_MANAGER::StopChangeProcessing(
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    if ( m_pChangeProcessor )
    {
        m_pChangeProcessor->RequestShutdown();
    }

    m_ProcessChanges = FALSE;

}   // CONFIG_MANAGER::StopChangeProcessing

/***************************************************************************++

Routine Description:

    Creates a new Admin Base Object, so we can continue
    working with the metabase.

Arguments:

    None.

Return Value:

    HRESULT  -- will cause the server to shutdown, but it means either
                we were not able to recover from inetinfo crash, or that
                we failed during startup.

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReestablishAdminBaseObject(
    )
{

    HRESULT hr = S_OK;
    ABO_MANAGER* pAboManagerOld = NULL;
    ABO_MANAGER* pAboManagerNew = NULL;
    IMSAdminBase* pIMSAdminBaseReplacement = NULL;
    CHANGE_LISTENER* pChangeListener = NULL;


    DBG_ASSERT ( ON_MAIN_WORKER_THREAD );

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Creating new interface to the metabase\n"
            ));
    }

    //
    // Now co-create a new one.
    //
    hr = CoCreateInstance(
                CLSID_MSAdminBase,                  // CLSID
                NULL,                               // controlling unknown
                CLSCTX_SERVER,                      // desired context
                IID_IMSAdminBase,                   // IID
                reinterpret_cast <VOID**> ( &pIMSAdminBaseReplacement )     // returned interface
                );

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Creating metabase base failed\n"
            ));

        goto exit;
    }

    //
    // And setup a new change listener.
    //

    DBG_ASSERT ( m_pChangeProcessor != NULL );

    pChangeListener = new CHANGE_LISTENER( m_pChangeProcessor );
    if ( pChangeListener == NULL )
    {
        // need to release the ABO object if we
        // didn't get to where the ABO_MANAGER owns it.
        pIMSAdminBaseReplacement->Release();
        pIMSAdminBaseReplacement = NULL;

        hr = E_OUTOFMEMORY;
        goto exit;
    }


    //
    // Create a new ABO Manager
    //

    pAboManagerNew = new ABO_MANAGER ( pIMSAdminBaseReplacement,
                                       pChangeListener );
    if ( pAboManagerNew == NULL )
    {
        // need to release the ABO object if we
        // didn't get to where the ABO_MANAGER owns it.
        pIMSAdminBaseReplacement->Release();
        pIMSAdminBaseReplacement = NULL;

        pChangeListener->Release();
        pChangeListener = NULL;

        hr = E_OUTOFMEMORY;

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Creating new abo manager object failed\n"
            ));

        goto exit;
    }

    //
    // Get the AboManager, this code represents
    // the main reference on the object, so we
    // don't have to add ref it here.  Or worry
    // about anyone changing it, since only this code
    // on the main thread will change it.
    //
    pAboManagerOld = m_pAboManager;

    // now we have to enter the critical section so we
    // can change the pAboManagerObject and make sure
    // no one else is AddRef'ing it at the same time.
    EnterCriticalSection ( &m_AboCritSec );
    m_pAboManager = pAboManagerNew;
    LeaveCriticalSection ( &m_AboCritSec );

    // at this point writes can be allowed to the
    // metabase again.
    InterlockedDecrement( &m_MetabaseIsInCrashedState );

    // release the main reference on the abo manager,
    // if someone else has it referenced it will hang
    // around until they release it, but no one will
    // be getting it from the CONFIG_MANAGER anymore.
    if ( pAboManagerOld )
    {
        // before you release it, we need to stop
        // listening on it.

        pAboManagerOld->GetChangeListener()->StopListening( pAboManagerOld->GetAdminBasePtr() );

        pAboManagerOld->DereferenceAboManager();
        pAboManagerOld = NULL;
    }

exit:

    return hr;

}   // CONFIG_MANAGER::ReestablishAdminBaseObject

/***************************************************************************++

Routine Description:

    Notifies the catalog that there has been a problem with inetinfo
    and has the catalog rehook up for change notifications.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
CONFIG_MANAGER::RehookChangeProcessing(
    )
{


    DBG_ASSERT ( ON_MAIN_WORKER_THREAD );

    if ( m_pChangeProcessor )
    {
        m_pChangeProcessor->RequestRehookNotifications();
        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Rehooking config change processing\n"
                ));
        }
    }

}   // CONFIG_MANAGER::RehookChangeProcessing

/***************************************************************************++

Routine Description:

    Write the virtual site state and error value back to the config store.

Arguments:

    VirtualSiteId - The virtual site.

    ServerState - The value to write for the ServerState property.

    Win32Error - The value to write for the Win32Error property.

Return Value:

    VOID

--***************************************************************************/

VOID
CONFIG_MANAGER::SetVirtualSiteStateAndError(
    IN DWORD VirtualSiteId,
    IN DWORD ServerState,
    IN DWORD Win32Error
    )
{
    HRESULT     hr = S_OK;
    DWORD       dwErr = ERROR_SUCCESS;
    BOOL        fRet;
    WCHAR       achSitePath[ 256 ];
    DWORD       dwOldWin32Error = 0;
    ABO_MANAGER* pAboManager = NULL;

    if ( m_MetabaseIsInCrashedState == 0 )
    {
        EnterCriticalSection ( &m_AboCritSec );
        pAboManager = m_pAboManager;
        pAboManager->ReferenceAboManager();
        LeaveCriticalSection ( &m_AboCritSec );

        MB          mb( pAboManager->GetAdminBasePtr() );

        // size of achSitePath is definitely
        // big enough for this string to be created
        wsprintfW( achSitePath,
                   L"/LM/W3SVC/%d/",
                   VirtualSiteId );

        fRet = mb.Open( achSitePath, METADATA_PERMISSION_READ |
                                     METADATA_PERMISSION_WRITE );
        if ( !fRet )
        {
            dwErr = GetLastError();

            //
            // if we get path not found here, and we are trying
            // to write the state for a site out, it may very
            // well mean that the site has just been deleted.  In
            // this case we do  not want to write it because it
            // will cause extra entries to be left in the metabase.
            //
            if ( dwErr == ERROR_PATH_NOT_FOUND )
            {
                IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
                {
                    DBGPRINTF((DBG_CONTEXT,
                               "Not writing state %d, for site %d, with error %d "
                               "because the site does not exist in the metabase \n",
                               ServerState,
                               VirtualSiteId,
                               Win32Error ));
                }

                hr = S_OK;
                goto exit;
            }

            hr = HRESULT_FROM_WIN32( dwErr );
            goto exit;
        }

        fRet = mb.SetDword( L"",
                            MD_SERVER_STATE,
                            IIS_MD_UT_SERVER,
                            ServerState,
                            METADATA_VOLATILE );
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto exit;
        }

        fRet = mb.GetDword( L"",
                            MD_WIN32_ERROR,
                            IIS_MD_UT_SERVER,
                            &dwOldWin32Error );
        if ( !fRet ||
             dwOldWin32Error != Win32Error )
        {

            fRet = mb.SetDword( L"",
                                MD_WIN32_ERROR,
                                IIS_MD_UT_SERVER,
                                Win32Error,
                                METADATA_VOLATILE );
            if ( !fRet )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto exit;
            }
        }
    }

exit:

    if ( pAboManager )
    {
        pAboManager->DereferenceAboManager();
        pAboManager = NULL;
    }

    if ( FAILED ( hr ) )
    {
        // In the initalization phase if we have failures we will try
        // to rewrite them all again, so we don't need to log errors here.
        if ( m_InInitializationPhase == FALSE )
        {
            const WCHAR * EventLogStrings[3];

            WCHAR wszSiteId[MAX_STRINGIZED_ULONG_CHAR_COUNT];
            WCHAR wszErrorCode[MAX_STRINGIZED_ULONG_CHAR_COUNT];
            WCHAR wszState[MAX_STRINGIZED_ULONG_CHAR_COUNT];

            _ultow(VirtualSiteId, wszSiteId, 10);
            _ultow(Win32Error, wszErrorCode, 10);
            _ultow(ServerState, wszState, 10);

            EventLogStrings[0] = wszSiteId;
            EventLogStrings[1] = wszState;
            EventLogStrings[2] = wszErrorCode;

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_RECORD_SITE_STATE_FAILURE,       // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    hr                                       // error code
                    );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Recording the state %d and win32error %d of the site %d failed\n",
                VirtualSiteId,
                Win32Error,
                VirtualSiteId
                ));
        }

        m_NumberOfSiteStateWritingFailed++;
    }

}   // CONFIG_MANAGER::SetVirtualSiteStateAndError



/***************************************************************************++

Routine Description:

    Write the virtual site autostart property back to the config store.

Arguments:

    VirtualSiteId - The virtual site.

    Autostart - The value to write for the autostart property.

Return Value:

    VOID

--***************************************************************************/

VOID
CONFIG_MANAGER::SetVirtualSiteAutostart(
    IN DWORD VirtualSiteId,
    IN BOOL Autostart
    )
{
    HRESULT     hr = S_OK;
    DWORD       dwErr = ERROR_SUCCESS;
    BOOL        fRet;
    WCHAR       achSitePath[ 256 ];
    ABO_MANAGER* pAboManager = NULL;

    if ( m_MetabaseIsInCrashedState == 0 )
    {
        EnterCriticalSection ( &m_AboCritSec );
        pAboManager = m_pAboManager;
        pAboManager->ReferenceAboManager();
        LeaveCriticalSection ( &m_AboCritSec );

        MB          mb( pAboManager->GetAdminBasePtr() );

        // size of achSitePath is definitely
        // big enough for this string to be created
        wsprintfW( achSitePath,
                   L"/LM/W3SVC/%d/",
                   VirtualSiteId );

        fRet = mb.Open( achSitePath, METADATA_PERMISSION_WRITE );
        if ( !fRet )
        {
            dwErr = GetLastError();

            //
            // it is possible for the site to have been deleted while we
            // were processing a previous change.  In this case we do not
            // want to write the site info back out, but it is not an error.
            //
            if ( dwErr == ERROR_PATH_NOT_FOUND )
            {
                IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
                {
                    DBGPRINTF((DBG_CONTEXT,
                               "Not writing auto start '%S', for site %d "
                               "because the site does not exist in the metabase \n",
                               Autostart ? L"TRUE" : L"FALSE",
                               VirtualSiteId));
                }

                hr = S_OK;
                goto exit;
            }

            hr = HRESULT_FROM_WIN32( dwErr );
            goto exit;

        }

        fRet = mb.SetDword( L"",
                            MD_SERVER_AUTOSTART,
                            IIS_MD_UT_SERVER,
                            Autostart,
                            0 );
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto exit;
        }
    }

exit:

    if ( pAboManager )
    {
        pAboManager->DereferenceAboManager();
        pAboManager = NULL;
    }

    if ( FAILED ( hr ) )
    {
        GetWebAdminService()->GetWASLogger()->
            LogSiteError(
                WAS_SITE_AUTO_START_WRITE_FAILED,
                hr,
                VirtualSiteId
                );
    }

}   // CONFIG_MANAGER::SetVirtualSiteAutostart

/***************************************************************************++

Routine Description:

    Write the app pool state back to the config store.

Arguments:

    IN LPCWSTR pAppPoolId  -  App Pool whose state changed.

    IN DWORD ServerState - The value to write for the ServerState property.

Return Value:

    VOID

--***************************************************************************/
VOID
CONFIG_MANAGER::SetAppPoolStateAndError(
    IN LPCWSTR pAppPoolId,
    IN DWORD ServerState,
    IN DWORD Win32Error
    )
{
    HRESULT     hr = S_OK;
    DWORD       dwErr = ERROR_SUCCESS;
    BOOL        fRet;
    STACK_STRU( strAppPoolPath, 256 );
    DWORD       dwOldWin32Error;
    ABO_MANAGER* pAboManager = NULL;

    DBG_ASSERT ( pAppPoolId );

    if ( m_MetabaseIsInCrashedState == 0)
    {
        EnterCriticalSection ( &m_AboCritSec );
        pAboManager = m_pAboManager;
        pAboManager->ReferenceAboManager();
        LeaveCriticalSection ( &m_AboCritSec );

        MB          mb( pAboManager->GetAdminBasePtr() );

        hr = strAppPoolPath.Copy( DATA_STORE_SERVER_APP_POOLS_MB_PATH );
        if ( FAILED( hr ) )
        {
            goto exit;
        }

        hr = strAppPoolPath.Append( pAppPoolId );
        if ( FAILED( hr ) )
        {
            goto exit;
        }

        fRet = mb.Open( strAppPoolPath.QueryStr(), METADATA_PERMISSION_READ |
                                     METADATA_PERMISSION_WRITE );
        if ( !fRet )
        {
            dwErr = GetLastError();

            //
            // if we get path not found here, and we are trying
            // to write the state for a app pool out, it may very
            // well mean that the pool has just been deleted.  In
            // this case we do  not want to write it because it
            // will cause extra entries to be left in the metabase.
            //
            if ( dwErr == ERROR_PATH_NOT_FOUND )
            {
                IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
                {
                    DBGPRINTF((DBG_CONTEXT,
                               "Not writing state %d, for app pool '%S', with error %d "
                               "because the pool does not exist in the metabase \n",
                               ServerState,
                               pAppPoolId,
                               Win32Error ));
                }

                hr = S_OK;
                goto exit;
            }

            hr = HRESULT_FROM_WIN32( dwErr );
            goto exit;
        }

        fRet = mb.SetDword( L"",
                            MD_APPPOOL_STATE,
                            IIS_MD_UT_SERVER,
                            ServerState,
                            METADATA_VOLATILE );
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto exit;
        }

        fRet = mb.GetDword( L"",
                            MD_WIN32_ERROR,
                            IIS_MD_UT_SERVER,
                            &dwOldWin32Error );
        if ( !fRet ||
             dwOldWin32Error != Win32Error )
        {
            fRet = mb.SetDword( L"",
                                MD_WIN32_ERROR,
                                IIS_MD_UT_SERVER,
                                Win32Error,
                                METADATA_VOLATILE );
            if ( !fRet )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto exit;
            }
        }
    }

exit:

    if ( pAboManager )
    {
        pAboManager->DereferenceAboManager();
        pAboManager = NULL;
    }

    if ( FAILED ( hr ) )
    {
        // In the initalization phase if we have failures we will try
        // to rewrite them all again, so we don't need to log errors here.
        if ( m_InInitializationPhase == FALSE )
        {
            const WCHAR * EventLogStrings[3];

            WCHAR wszErrorCode[MAX_STRINGIZED_ULONG_CHAR_COUNT];
            WCHAR wszState[MAX_STRINGIZED_ULONG_CHAR_COUNT];

            _ultow(Win32Error, wszErrorCode, 10);
            _ultow(ServerState, wszState, 10);

            EventLogStrings[0] = pAppPoolId;
            EventLogStrings[1] = wszState;
            EventLogStrings[2] = wszErrorCode;

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_RECORD_APP_POOL_STATE_FAILURE,       // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    hr                                       // error code
                    );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Recording the state %d and win32error %d of the app pool %S failed\n",
                ServerState,
                Win32Error,
                pAppPoolId
                ));
        }

        m_NumberOfPoolStateWritingFailed++;
    }

}   // CONFIG_MANAGER::SetAppPoolStateAndError



/***************************************************************************++

Routine Description:

    Write the app pool autostart property back to the config store.

Arguments:

    pAppPoolId - The app pool id for the app pool that's changing.

    Autostart - The value to write for the autostart property.

Return Value:

    VOID

--***************************************************************************/
VOID
CONFIG_MANAGER::SetAppPoolAutostart(
    IN LPCWSTR pAppPoolId,
    IN BOOL Autostart
    )
{
    HRESULT     hr = S_OK;
    DWORD       dwErr = ERROR_SUCCESS;
    BOOL        fRet;
    STACK_STRU( strAppPoolPath, 256 );
    ABO_MANAGER* pAboManager = NULL;

    if ( m_MetabaseIsInCrashedState == 0 )
    {
        EnterCriticalSection ( &m_AboCritSec );
        pAboManager = m_pAboManager;
        pAboManager->ReferenceAboManager();
        LeaveCriticalSection ( &m_AboCritSec );

        MB          mb( pAboManager->GetAdminBasePtr() );

        hr = strAppPoolPath.Copy( DATA_STORE_SERVER_APP_POOLS_MB_PATH );
        if ( FAILED( hr ) )
        {
            goto exit;
        }

        hr = strAppPoolPath.Append( pAppPoolId );
        if ( FAILED( hr ) )
        {
            goto exit;
        }

        fRet = mb.Open( strAppPoolPath.QueryStr(), METADATA_PERMISSION_WRITE );
        if ( !fRet )
        {
            dwErr = GetLastError();

            //
            // it is possible for the pool to have been deleted while we
            // were processing a previous change.  In this case we do not
            // want to write the pool info back out, but it is not an error.
            //
            if ( dwErr == ERROR_PATH_NOT_FOUND )
            {
                IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
                {
                    DBGPRINTF((DBG_CONTEXT,
                               "Not writing auto start '%S', for app pool '%S' "
                               "because the pool does not exist in the metabase \n",
                               Autostart ? L"TRUE" : L"FALSE",
                               pAppPoolId));
                }

                hr = S_OK;
                goto exit;
            }

            hr = HRESULT_FROM_WIN32( dwErr );
            goto exit;
        }

        fRet = mb.SetDword( L"",
                            MD_APPPOOL_AUTO_START,
                            IIS_MD_UT_SERVER,
                            Autostart,
                            0 );
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto exit;
        }
    }

exit:

    if ( pAboManager )
    {
        pAboManager->DereferenceAboManager();
        pAboManager = NULL;
    }

    if ( FAILED ( hr ) )
    {
        const WCHAR * EventLogStrings[1];
        EventLogStrings[0] = pAppPoolId;

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_FAILED_TO_UPDATE_AUTOSTART_FOR_APPPOOL,   // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                hr                                      // error code
                );
    }

}   // CONFIG_MANAGER::SetAppPoolAutostart

/***************************************************************************++

Routine Description:

    Configures the metabase to advertise the capabilities of the server.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
VOID
CONFIG_MANAGER::AdvertiseServiceInformationInMB(
    )
{

    HRESULT hr = S_OK;
    DWORD productType = 0;
    DWORD capabilities = 0;
    BOOL fRet;
    HKEY  hkey = NULL;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    // Note:  This function runs only once, during startup and
    //        on the main thread.  It is not possible for this
    //        pointer to be switched out, since that also only
    //        happens on the main thread.  So we are forgoing
    //        the critical section here.

    MB          mb( m_pAboManager->GetAdminBasePtr() );

    fRet = mb.Open( L"/LM/W3SVC/Info", METADATA_PERMISSION_READ |
                                       METADATA_PERMISSION_WRITE );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Openning the info key in advertise failed\n"
            ));

        goto exit;
    }

    //
    // set the version
    //
    fRet = mb.SetDword( L"",
                        MD_SERVER_VERSION_MAJOR,
                        IIS_MD_UT_SERVER,
                        IIS_SERVER_VERSION_MAJOR,
                        0 );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed setting the Major Version\n"
            ));

        // press on in the face of errors.
    }

    fRet = mb.SetDword( L"",
                        MD_SERVER_VERSION_MINOR,
                        IIS_MD_UT_SERVER,
                        IIS_SERVER_VERSION_MINOR,
                        0 );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed setting the Minor Version\n"
            ));

        // press on in the face of errors.
    }

    //
    // set platform type
    //

    switch (IISGetPlatformType()) {

        case PtNtServer:
            productType = INET_INFO_PRODUCT_NTSERVER;
            capabilities = IIS_CAP1_NTS;
            break;
        case PtNtWorkstation:
            productType = INET_INFO_PRODUCT_NTWKSTA;
            capabilities = IIS_CAP1_NTW;
            break;
        default:
            productType = INET_INFO_PRODUCT_UNKNOWN;
            capabilities = IIS_CAP1_NTW;
    }

    fRet = mb.SetDword( L"",
                        MD_SERVER_PLATFORM,
                        IIS_MD_UT_SERVER,
                        productType,
                        0 );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed setting the product type\n"
            ));


        // press on in the face of errors.
    }

    //
    //  Check to see if FrontPage is installed
    //

    if ( !RegOpenKeyExA( HKEY_LOCAL_MACHINE,
                        REG_FP_PATH,
                        0,
                        KEY_READ,
                        &hkey ))
    {
        capabilities |= IIS_CAP1_FP_INSTALLED;

        DBG_REQUIRE( !RegCloseKey( hkey ));
    }

    //
    // In IIS 5.1 we also set the IIS_CAP1_DIGEST_SUPPORT and IIS_CAP1_NT_CERTMAP_SUPPORT
    // based on whether or not domain controllers and active directories were around.  These
    // properties are used by the UI to determine if they should allow the user to enable
    // these options.  In IIS 6.0 we are going to set these to true and let the UI configure
    // systems to use these whether or not the server is setup to support them.  The worker
    // processes should gracefully fail calls, if it is not setup.  This decision is based
    // on the fact that we don't want to do long running operations during the service startup.
    // TaylorW, SergeiA, Jaroslav and I (EmilyK) have all agreed to this for Beta 2.  It most likely
    // won't change for RTM if there no issues arise from this.

    capabilities |= IIS_CAP1_DIGEST_SUPPORT;
    capabilities |= IIS_CAP1_NT_CERTMAP_SUPPORT;

    //
    // Set the capabilities flag
    //
    fRet = mb.SetDword( L"",
                        MD_SERVER_CAPABILITIES,
                        IIS_MD_UT_SERVER,
                        capabilities,
                        0 );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed setting the product type\n"
            ));


        // press on in the face of errors.
    }

exit:

    return;

} // CONFIG_MANAGER::AdvertiseServiceInformationInMB


/***************************************************************************++

Routine Description:

    Sets up the listening to change notifications.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

DWORD WINAPI
ChangeNotificationLauncher(
    LPVOID lpParameter   // thread data
    )
{
    DBG_ASSERT ( lpParameter );

    CHANGE_PROCESSOR* pChangeProcessor = ( CHANGE_PROCESSOR* ) lpParameter;
    DBG_ASSERT ( pChangeProcessor->CheckSignature() );

    pChangeProcessor->RunNotificationWorkQueue();

    return ERROR_SUCCESS;

}

/***************************************************************************++

Routine Description:

    Checks to see if a root creation for a site is coming.  If it is
    then we just return true, if it is not we will add one for the site.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
BOOL
CONFIG_MANAGER::IsRootCreationInNotificationsForSite(
    SITE_DATA_OBJECT* pSiteObject
    )
{
    APPLICATION_DATA_OBJECT_KEY     appKey;
    HRESULT                         hr;
    LK_RETCODE                      lkrc;
    APPLICATION_DATA_OBJECT *       pApplicationObject = NULL;

    DBG_ASSERT( m_pCurrentAppTable != NULL );

    // create the key we are looking for
    hr = appKey.Create( L"/",
                        pSiteObject->QuerySiteId() );
    if ( FAILED( hr ) )
    {
        return FALSE;
    }

    // now find it
    lkrc = m_pCurrentAppTable->FindKey( &appKey,
                                        (DATA_OBJECT**) &pApplicationObject );
    if ( lkrc != LK_SUCCESS )
    {
        // we didn't find it so we need one with the
        // site app pool information included.
        pApplicationObject = new APPLICATION_DATA_OBJECT;
        if ( pApplicationObject == NULL )
        {
            return FALSE;
        }

        hr = pApplicationObject->Create( L"/", pSiteObject->QuerySiteId() );
        if ( FAILED( hr ) )
        {
            pApplicationObject->DereferenceDataObject();
            return FALSE;
        }

        hr = pApplicationObject->SetAppPoolId( pSiteObject->QueryAppPoolId() );
        if ( FAILED( hr ) )
        {
            pApplicationObject->DereferenceDataObject();
            return FALSE;
        }

        pApplicationObject->SetInMetabase( FALSE );

        lkrc = m_pCurrentAppTable->InsertRecord( pApplicationObject );

        pApplicationObject->DereferenceDataObject();

        return lkrc == LK_SUCCESS ? TRUE : FALSE;
    }
    else
    {
        //
        // verifing that if we did find it that
        // we will be asking WAS to insert it.
        //
        // If there is one here, and it was invalidated
        // it should of invalidated the site, so we
        // should not get here.
        //
        DBG_ASSERT( pApplicationObject != NULL );

        DBG_ASSERT( pApplicationObject->QueryShouldWasInsert() );

        pApplicationObject->DereferenceDataObject();

        return FALSE;
    }
}


/***************************************************************************++

Routine Description:

    Check if the site is being deleted in this change notification.  If it
    is we won't create a fake application for the site.

Arguments:

    DWORD dwSiteId

Return Value:

    HRESULT

--***************************************************************************/
BOOL
CONFIG_MANAGER::IsSiteDeletionInCurrentNotifications(
    DWORD dwSiteId
    )
{
    SITE_DATA_OBJECT_KEY     siteKey;
    LK_RETCODE               lkrc = LK_SUCCESS;
    SITE_DATA_OBJECT*        pSiteObject = NULL;
    BOOL                     retval = FALSE;

    //
    // if we are not in a current change notification
    // the site table could be NULL, in this case we
    // must be shutting down, so lie and tell WAS that
    // a deletion is coming.
    //
    if ( m_pCurrentSiteTable == NULL )
    {
       return TRUE;
    }

    siteKey.SetSiteId( dwSiteId );

    lkrc = m_pCurrentSiteTable->FindKey( &siteKey,
                                        (DATA_OBJECT**) &pSiteObject );
    if ( lkrc != LK_SUCCESS )
    {
        retval = FALSE;
    }
    else
    {
        // we found the site, but i WAS going to delete it?

        DBG_ASSERT ( pSiteObject );
        if ( pSiteObject->QueryShouldWasDelete() )
        {
            retval = TRUE;
        }
        else
        {
            retval = FALSE;
        }
    }

    if ( pSiteObject )
    {
        pSiteObject->DereferenceDataObject();
        pSiteObject = NULL;
    }

    return retval;

}


/***************************************************************************++

Routine Description:

    Routine is called by a MB_CHANGE_ITEM on the configuration thread.  It
    handles processing the whole change notification and packaging the results
    up to be sent to the main thread.

Arguments:

    MB_CHANGE_ITEM* pChangeItem

Return Value:

    VOID

--***************************************************************************/
VOID
CONFIG_MANAGER::ProcessMetabaseChangeOnConfigThread(
    MB_CHANGE_ITEM* pChangeItem
    )
{
    HRESULT hr = S_OK;

    APP_POOL_DATA_OBJECT_TABLE* pAppPoolTable = NULL;
    SITE_DATA_OBJECT_TABLE* pSiteTable = NULL;
    APPLICATION_DATA_OBJECT_TABLE* pAppTable = NULL;
    GLOBAL_DATA_STORE* pGlobalStore = NULL;


    DBG_ASSERT ( pChangeItem );

    //
    // if we are not processing change configurations than,
    // don't bother doing this work.  If we are in the middle of
    // this work when we start shutting down the config manager
    // we will be able to complete it and queue it and the work
    // will be ignored when it is dequeued.
    //
    if ( !m_ProcessChanges || m_ConfigThreadProcessingDisabled != 0 )
    {
        return;
    }

    // It is possible that this is called on the main thread, during shutdown
    // but at that point the above condition would stop the code from reaching
    // this point.

    DBG_ASSERT ( ON_CONFIG_WORKER_THREAD );


    m_NumChangesProcessed++;

    DBG_ASSERT ( m_pChangeProcessor );

    m_pChangeProcessor->DropAllUninterestingMBChanges(
                                        pChangeItem->QueryNumberOfChanges(),
                                        pChangeItem->QueryChangeObject() );

    DumpMetabaseChange( pChangeItem->QueryNumberOfChanges(),
                        pChangeItem->QueryChangeObject());

    // Steps to process the metabase change.
    // 1)  Call RFMCN on each table.
    // 2)  Call the finish processing routine to massage the data.

    hr = CreateTempDataObjectTables( pChangeItem->QueryNumberOfChanges(),
                                     pChangeItem->QueryChangeObject(),
                                     &pAppPoolTable,
                                     &pSiteTable,
                                     &pAppTable,
                                     &pGlobalStore );
    if ( FAILED ( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Creating temporary change tables failed\n"
            ));

        goto exit;
    }


    hr = FinishChangeProcessingOnConfigThread( pAppPoolTable,
                                               pSiteTable,
                                               pAppTable,
                                               pGlobalStore );
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to finish processing the config change\n"
            ));

        goto exit;
    }

exit:

    if ( pAppPoolTable )
    {
        delete pAppPoolTable;
        pAppPoolTable = NULL;
    }

    if ( pSiteTable )
    {
        delete pSiteTable;
        pSiteTable = NULL;
    }

    if ( pAppTable )
    {
        delete pAppTable;
        pAppTable = NULL;
    }

    if ( pGlobalStore )
    {
        delete pGlobalStore;
        pGlobalStore = NULL;
    }

    if ( FAILED( hr ) )
    {
        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_WMS_FAILED_TO_PROCESS_CHANGE_NOTIFICATION,       // message id
                0,           // count of strings
                NULL,        // array of strings
                hr           // error code
                );
    }

}

/***************************************************************************++

Routine Description:

    Routine is called to complete the change processing on the config thread
    after the data has been read in from the metabase.

Arguments:

    None

Return Value:

    HRESULT  -- Hresult get's logged by calling functions.

--***************************************************************************/
HRESULT
CONFIG_MANAGER::FinishChangeProcessingOnConfigThread(
    APP_POOL_DATA_OBJECT_TABLE*     pAppPoolTable,
    SITE_DATA_OBJECT_TABLE*         pSiteTable,
    APPLICATION_DATA_OBJECT_TABLE*  pAppTable,
    GLOBAL_DATA_STORE*              pGlobalStore
    )
{
    HRESULT hr = S_OK;

    DBG_ASSERT ( ON_CONFIG_WORKER_THREAD );
    DBG_ASSERT ( pAppPoolTable );
    DBG_ASSERT ( pSiteTable );
    DBG_ASSERT ( pAppTable );
    DBG_ASSERT ( pGlobalStore );


    // Steps to process the metabase change.
    // 1)  Call Merge on each table.
    // 2)  Call Self Validate on each table.
    // 3)  Call Cross Validation routine.
    // 4)  Walk the table adding a copy of each
    //     item WAS should process to a new
    //     WAS_CHANGE_ITEM.
    // 5)  Queue the WAS_CHANGE_ITEM to the main
    //     thread.


    IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "\n **********  Starting to dump the temp data table *********** \n"  ));
    }

    pAppPoolTable->Dump();
    pSiteTable->Dump();
    pAppTable->Dump();
    if ( pGlobalStore->QueryGlobalDataObject() )
    {
        pGlobalStore->QueryGlobalDataObject()->Dump();
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "\n **********  Done with dump the temp data table ************* \n"  ));
    }

    hr = MergeAndSelfValidateTables( pAppPoolTable,
                                     pSiteTable,
                                     pAppTable,
                                     pGlobalStore );
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "merging and self validating tables failed\n"
            ));

        goto exit;
    }

    hr = CrossValidateDataObjects();
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed cross validating data from metabase\n"
            ));

        goto exit;
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "\n *********  Starting to dump the real data table *********** \n"  ));
    }

    m_AppPoolTable.Dump();
    m_SiteTable.Dump();
    m_AppTable.Dump();
    if ( m_GlobalStore.QueryGlobalDataObject() )
    {
        m_GlobalStore.QueryGlobalDataObject()->Dump();
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "\n *********  Done with dump the real data table ********** \n"  ));
    }

    hr = SendMainThreadChanges();
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to send the changes to the main thread\n"
            ));

        goto exit;
    }

    // need to clean up the safe tables so they are
    // ready to go with the next set of change notifications.
    m_AppPoolTable.ClearDeletedObjects();
    m_SiteTable.ClearDeletedObjects();
    m_AppTable.ClearDeletedObjects();
    m_GlobalStore.ClearDeletedObjects();

    IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Completed processing a change on the change processing thread \n"  ));
    }

exit:

    return hr;
}

/***************************************************************************++

Routine Description:

    Routine is called by the change processor on the config thread when
    we need to handle recoving from an inetinfo crash..

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/
VOID
CONFIG_MANAGER::ProcessMetabaseCrashOnConfigThread(
    )
{
    // todo, actually figure out any changes missed.
    DBG_ASSERT ( ON_CONFIG_WORKER_THREAD );


    HRESULT hr = S_OK;

    APP_POOL_DATA_OBJECT_TABLE      AppPoolTable;
    SITE_DATA_OBJECT_TABLE          SiteTable;
    APPLICATION_DATA_OBJECT_TABLE   AppTable;
    GLOBAL_DATA_STORE               GlobalStore;

    // Before we do anything we need to Rehook a listener
    // for metabase changes.

    hr = StartListeningForChangeNotifications();
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to rehook listener for metabase changes \n"
            ));

        goto exit;
    }

    // Steps to process the metabase change.
    // 1)  Call RFM for each table.
    // 2)  Use the safe tables to create delete entries if needed.
    // 3)  Let the change processing flow

    hr = ReadDataFromMetabase ( &AppPoolTable,
                                &SiteTable,
                                &AppTable,
                                &GlobalStore );
    if ( FAILED ( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Creating temporary change tables failed\n"
            ));

        goto exit;
    }

    CalculcateDeletesFromTables ( &AppPoolTable,
                                       &SiteTable,
                                       &AppTable );

    hr = FinishChangeProcessingOnConfigThread( &AppPoolTable,
                                               &SiteTable,
                                               &AppTable,
                                               &GlobalStore );
    if ( FAILED ( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to finish processing the config change\n"
            ));

        goto exit;
    }

    InterlockedDecrement( &m_ConfigThreadProcessingDisabled );

exit:

    if ( FAILED ( hr ) )
    {
        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_NOTIFICATION_REHOOKUP_FAILURE,  // message id
                0,                                      // count of strings
                NULL,                                   // array of strings
                hr                                      // error code
                );
    }
}


/***************************************************************************++

Routine Description:

    Adds deletion entries if needed.

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/
VOID
CONFIG_MANAGER::CalculcateDeletesFromTables(
    APP_POOL_DATA_OBJECT_TABLE*     pAppPoolTable,
    SITE_DATA_OBJECT_TABLE*         pSiteTable,
    APPLICATION_DATA_OBJECT_TABLE*  pAppTable
    )
{
    DBG_ASSERT ( ON_CONFIG_WORKER_THREAD );
    DBG_ASSERT ( pAppPoolTable );
    DBG_ASSERT ( pSiteTable );
    DBG_ASSERT ( pAppTable );

    HRESULT hr = S_OK;

    hr = pAppPoolTable->DeclareDeletions ( (DATA_OBJECT_TABLE*) &m_AppPoolTable );
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed while declaring deletions for app pools\n"
            ));

        goto exit;
    }

    hr = pSiteTable->DeclareDeletions ( (DATA_OBJECT_TABLE*) &m_SiteTable );
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed while declaring deletions for sites\n"
            ));

        goto exit;
    }

    hr = pAppTable->DeclareDeletions ( (DATA_OBJECT_TABLE*) &m_AppTable );
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed while declaring deletions for apps\n"
            ));

        goto exit;
    }

exit:

    if ( FAILED ( hr ) )
    {
        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_WMS_FAILED_TO_DETERMINE_DELETIONS,       // message id
                0,           // count of strings
                NULL,        // array of strings
                hr           // error code
                );
    }
}
/***************************************************************************++

Routine Description:

    Copies over the items that have changed and prepares them to be transported
    to the main thread and processed by WAS.

Arguments:

    None

Return Value:

    HRESULT  - Failures here will be logged above.

--***************************************************************************/
HRESULT
CONFIG_MANAGER::SendMainThreadChanges(
    )
{
    WAS_CHANGE_ITEM *       pChangeItem = NULL;
    HRESULT                 hr;

    //
    // Create a WAS change item and initialize it with the necessary
    // rows
    //

    pChangeItem = new WAS_CHANGE_ITEM;
    if ( pChangeItem == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    hr = pChangeItem->CopyChanges( &m_GlobalStore,
                                   &m_SiteTable,
                                   &m_AppTable,
                                   &m_AppPoolTable );
    if ( FAILED( hr ) )
    {
        pChangeItem->Dereference();
        return hr;
    }

    //
    // Off to the main thread for processing
    //

    hr = QueueWorkItemFromSecondaryThread(
            pChangeItem,
            ProcessChangeConfigChangeWorkItem
            );

    pChangeItem->Dereference();

    return hr;
}

/***************************************************************************++

Routine Description:

    Callback function to handle the different issues arrising from inetinfo
    crashing.

Arguments:

    INETINFO_CRASH_ACTION CrashAction

Return Value:

    VOID

--***************************************************************************/
VOID
NotifyOfInetinfoFailure(
    INETINFO_CRASH_ACTION CrashAction
    )
{
    HRESULT hr = S_OK;

    switch ( CrashAction)
    {
        case ( NotifyAfterInetinfoCrash ):

            //
            // if the monitor is running then we know that
            // we have a config manager object and we can
            // mark it as inetinfo has crashed.
            //
            GetWebAdminService()->
            GetConfigAndControlManager()->
            GetConfigManager()->
            RecordInetinfoCrash();

        break;

        case ( ShutdownAfterInetinfoCrash ):

            // we need to call shutdown ( we will all ready
            // have flagged that inetinfo crashed ).

            hr = GetWebAdminService()->RequestStopService( FALSE );
            if ( FAILED ( hr ) )
            {
                DPERROR((
                    DBG_CONTEXT,
                    hr,
                    "Stopping the service due to inetinfo crash had a problem\n"
                    ));
            }

        break;

        case ( RehookAfterInetinfoCrash ):

            hr = GetWebAdminService()->QueueRecoveryFromInetinfoCrash();
            if ( FAILED ( hr ) )
            {
                DPERROR((
                    DBG_CONTEXT,
                    hr,
                    "Recovering from inetinfo crash had a problem\n"
                    ));
            }

        break;

        case ( SystemFailureMonitoringInetinfo ):

            //
            // flag that we are no longer monitoring
            // so we won't assume on shutdown that this 
            // caused the shutdown.
            //
            GetWebAdminService()->
            GetConfigAndControlManager()->
            GetConfigManager()->
            RecordInetinfoMonitorStopped();

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_INETINFO_MONITOR_FAILED,  // message id
                    0,                                      // count of strings
                    NULL,                                   // array of strings
                    0                                      // error code
                    );
        break;

        default:
            // in this case the BitToCheck will be zero
            // and we just won't print a message, no real
            // bad path for retail.
            DBG_ASSERT( FALSE );
    }

    if ( FAILED ( hr ) )
    {
        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_INETINFO_RESPONSE_FAILED,  // message id
                0,                                      // count of strings
                NULL,                                   // array of strings
                hr                                      // error code
                );
    }

}

/***************************************************************************++

Routine Description:

    Creates MD5 hash of input buffer

Arguments:

    buffData - data to hash
    buffHash - buffer that receives hash; is assumed to be big enough to
               contain MD5 hash

Return Value:

    HRESULT.  -- This is called when reading properties from metabase,
                 it will be handled there the same way as we would handle
                 an out of memory case.

--***************************************************************************/
HRESULT
CONFIG_MANAGER::GetHashData(
    IN PBYTE    pOrigValue,
    IN DWORD    cbOrigValue,
    OUT PBYTE   pHash,
    IN DWORD    cbHashBuffer
    )
{
    HCRYPTHASH      hHash   = NULL;
    HRESULT         hr      = S_OK;
    DWORD           cbHash  = 0;

    DBG_ASSERT( cbOrigValue == 0 || pOrigValue );
    DBG_ASSERT( cbHashBuffer >= MD5_HASH_SIZE );
    DBG_ASSERT( m_hCryptProvider != NULL );

    if ( !CryptCreateHash( m_hCryptProvider,
                           CALG_MD5,
                           0,
                           0,
                           &hHash ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }

    if ( !CryptHashData( hHash,
                         pOrigValue,
                         cbOrigValue,
                         0 ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }

    cbHash = cbHashBuffer;
    if ( !CryptGetHashParam( hHash,
                             HP_HASHVAL,
                             pHash,
                             &cbHash,
                             0 ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }

    DBG_ASSERT ( cbHash == cbHashBuffer );

exit:

    if ( hHash != NULL )
    {
        CryptDestroyHash( hHash );
    }

    return hr;
}

/***************************************************************************++

Routine Description:

    Start listening to the change notifications of the metabase.  As part
    of starting to listen we wait for an event to be set that will tell us
    it is ok for us to start processing the notifications that may be in the
    queue.

Arguments:

    None.

Return Value:

    HRESULT  -- This function is used both at startup and at reconfigure.
                At startup the hrResult will be picked up after we believe
                that we have started up the config thread.  And will be stop
                the server.

                In the second case, it is called on the config thread once
                inetinfo has crashed.  In that case the error will be caught
                and logged above.

--***************************************************************************/
HRESULT
CONFIG_MANAGER::StartListeningForChangeNotifications(
    )
{
    ABO_MANAGER* pAboManager = NULL;

    DBG_ASSERT( ON_CONFIG_WORKER_THREAD );

    EnterCriticalSection ( &m_AboCritSec );
    pAboManager = m_pAboManager;
    pAboManager->ReferenceAboManager();
    LeaveCriticalSection ( &m_AboCritSec );

    //
    // save off the hr from here, so that if we are in initalization we can
    // report the error and fail to startup.  This is the only place this error
    // is set, except for the initialization that takes place before this thread
    // is started.
    //

    m_hrConfigThreadInitialization = pAboManager->GetChangeListener()->StartListening( pAboManager->GetAdminBasePtr() );
    if ( FAILED ( m_hrConfigThreadInitialization ) )
    {
        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_NOTIFICATION_HOOKUP_FAILURE,  // message id
                0,                                      // count of strings
                NULL,                                   // array of strings
                m_hrConfigThreadInitialization                                      // error code
                );

        DPERROR((
            DBG_CONTEXT,
            m_hrConfigThreadInitialization,
            "failed to hook up for notifications\n"
            ));
    }

    if ( pAboManager )
    {
        pAboManager->DereferenceAboManager();
        pAboManager = NULL;
    }

    return m_hrConfigThreadInitialization;

}


/***************************************************************************++

Routine Description:

    Stops listening to changes so we can shutdown the config thread.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/
VOID
CONFIG_MANAGER::StopListeningToMetabaseChanges(
    )
{
    ABO_MANAGER* pAboManager = NULL;

    DBG_ASSERT ( ON_CONFIG_WORKER_THREAD );

    EnterCriticalSection ( &m_AboCritSec );
    pAboManager = m_pAboManager;
    pAboManager->ReferenceAboManager();
    LeaveCriticalSection ( &m_AboCritSec );

    // if we have a change listener pointer it is time to delete
    // the object.

    pAboManager->GetChangeListener()->StopListening( pAboManager->GetAdminBasePtr() );

    if ( pAboManager )
    {
        pAboManager->DereferenceAboManager();
        pAboManager = NULL;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\config_manager.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    config_manager.h

Abstract:

    The IIS web admin service configuration manager class definition.

Author:

    Seth Pollack (sethp)        5-Jan-1999

Revision History:

--*/



#ifndef _CONFIG_MANAGER_H_
#define _CONFIG_MANAGER_H_

class CHANGE_LISTENER;
class MB_CHANGE_ITEM;

//
// common #defines
//

#define CONFIG_MANAGER_SIGNATURE        CREATE_SIGNATURE( 'CFGM' )
#define CONFIG_MANAGER_SIGNATURE_FREED  CREATE_SIGNATURE( 'cfgX' )

//
// prototypes
//
class ABO_MANAGER
{
public:

    ABO_MANAGER( 
        IMSAdminBase * pIMSAdminBase,
        CHANGE_LISTENER * pChangeListener
        )
        : m_pAdminBaseObject( pIMSAdminBase ),
          m_pChangeListener( pChangeListener ),
          m_RefCount ( 1 )
    {
    }

    VOID
    ReferenceAboManager(
        )
    {
        LONG NewRefCount = 0;

        NewRefCount = InterlockedIncrement( &m_RefCount );

        // 
        // The reference count should never have been less than zero; and
        // furthermore once it has hit zero it should never bounce back up;
        // given these conditions, it better be greater than one now.
        //

        DBG_ASSERT( NewRefCount > 1 );

        return;
    }

    VOID
    DereferenceAboManager(
        )
    {
        LONG NewRefCount = 0;

        NewRefCount = InterlockedDecrement( &m_RefCount );

        // ref count should never go negative
        DBG_ASSERT( NewRefCount >= 0 );

        if ( NewRefCount == 0 )
        {
            delete this;
        }

        return;
    }

    IMSAdminBase*
    GetAdminBasePtr(
        )
    { 
        DBG_ASSERT ( m_pAdminBaseObject != NULL );
        return m_pAdminBaseObject;
    }

    CHANGE_LISTENER*
    GetChangeListener(
        )
    { 
        DBG_ASSERT ( m_pChangeListener != NULL );
        return m_pChangeListener;
    }

private:
    
   ~ABO_MANAGER(
        )
    { 
        DBG_ASSERT ( m_RefCount == 0 );
        
        if ( m_pAdminBaseObject != NULL )
        {
            m_pAdminBaseObject->Release();
            m_pAdminBaseObject = NULL;
        }

        if ( m_pChangeListener != NULL )
        {
            m_pChangeListener->Release();
            m_pChangeListener = NULL;
        }
    }

   IMSAdminBase* m_pAdminBaseObject;
   CHANGE_LISTENER* m_pChangeListener;
   LONG          m_RefCount;

};        

class CONFIG_MANAGER
{

public:

    CONFIG_MANAGER(
        );

    virtual
    ~CONFIG_MANAGER(
        );

    HRESULT
    Initialize(
        );

    VOID
    Terminate(
        );

    VOID
    ProcessConfigChange(
        IN WAS_CHANGE_ITEM * pChange
        );

    VOID
    StopChangeProcessing(
        );

    VOID
    RehookChangeProcessing(
        );

    VOID
    SetVirtualSiteStateAndError(
        IN DWORD VirtualSiteId,
        IN DWORD ServerState,
        IN DWORD Win32Error
        );

    VOID
    SetVirtualSiteAutostart(
        IN DWORD VirtualSiteId,
        IN BOOL Autostart
        );

    VOID
    SetAppPoolStateAndError(
        IN LPCWSTR pAppPoolId,
        IN DWORD ServerState,
        IN DWORD Win32Error
        );

    VOID
    SetAppPoolAutostart(
        IN LPCWSTR pAppPoolId,
        IN BOOL Autostart
        );

    VOID
    ProcessMetabaseChangeOnConfigThread(
        MB_CHANGE_ITEM* pChangeItem
        );

    VOID
    ProcessMetabaseCrashOnConfigThread(
        );

    BOOL
    IsRootCreationInNotificationsForSite(
        SITE_DATA_OBJECT* pSiteObject
        );

    BOOL
    IsSiteDeletionInCurrentNotifications(
        DWORD dwSiteId
        );

    HRESULT
    ReestablishAdminBaseObject(
        );

    VOID
    RecordInetinfoCrash(
        )
    {
        InterlockedIncrement( &m_MetabaseIsInCrashedState );
        InterlockedIncrement( &m_ConfigThreadProcessingDisabled );
    }

    VOID
    RecordInetinfoMonitorStopped(
        )
    {
        InterlockedIncrement( &m_InetinfoMonitorFatalErrors );
    }

    BOOL
    QueryInetinfoInCrashedState(
        )
    {
        return m_MetabaseIsInCrashedState != 0;
    }

    BOOL
    QueryMonitoringInetinfo(
        )
    {
        // We only expect it to be incremented once.
        DBG_ASSERT ( m_InetinfoMonitorFatalErrors >= 0 &&
                     m_InetinfoMonitorFatalErrors <= 1 );

        return m_InetinfoMonitorFatalErrors == 0;
    }

    HRESULT
    GetHashData( 
        IN PBYTE    pOrigValue,
        IN DWORD    cbOrigValue,
        OUT PBYTE   pHash,
        IN DWORD    cbHashBuffer
        );

    HRESULT
    StartListeningForChangeNotifications(
        );

    VOID
    StopListeningToMetabaseChanges(
        );

    VOID
    SignalMainThreadToContinueAfterConfigThreadInitialization(
        );

private:

	CONFIG_MANAGER( const CONFIG_MANAGER & );
	void operator=( const CONFIG_MANAGER & );

    VOID
    CalculcateDeletesFromTables(
        APP_POOL_DATA_OBJECT_TABLE*     pAppPoolTable,
        SITE_DATA_OBJECT_TABLE*         pSiteTable,
        APPLICATION_DATA_OBJECT_TABLE*  pAppTable
        );

    HRESULT
    FinishChangeProcessingOnConfigThread(
        APP_POOL_DATA_OBJECT_TABLE*     pAppPoolTable,
        SITE_DATA_OBJECT_TABLE*         pSiteTable,
        APPLICATION_DATA_OBJECT_TABLE*  pAppTable,
        GLOBAL_DATA_STORE*              pGlobalStore
        );

    HRESULT
    ReadDataFromMetabase(
        APP_POOL_DATA_OBJECT_TABLE*     pAppPoolTable,
        SITE_DATA_OBJECT_TABLE*         pSiteTable,
        APPLICATION_DATA_OBJECT_TABLE*  pAppTable,
        GLOBAL_DATA_STORE*              pGlobalStore
        );

    HRESULT
    CreateTempDataObjectTables(
        IN DWORD               dwMDNumElements,
        IN MD_CHANGE_OBJECT    pcoChangeList[],
        OUT APP_POOL_DATA_OBJECT_TABLE** ppAppPoolTable,
        OUT SITE_DATA_OBJECT_TABLE** ppSiteTable,
        OUT APPLICATION_DATA_OBJECT_TABLE** ppApplicationTable,
        OUT GLOBAL_DATA_STORE** ppGlobalStore
        );

    HRESULT
    MergeAndSelfValidateTables(
        IN APP_POOL_DATA_OBJECT_TABLE*      pAppPoolTable,
        IN SITE_DATA_OBJECT_TABLE*          pSiteTable,
        IN APPLICATION_DATA_OBJECT_TABLE*   pApplicationTable,
        IN GLOBAL_DATA_STORE*               pGlobalStore
        );

    HRESULT
    SendMainThreadChanges(
        );

    HRESULT
    LaunchChangeNotificationListener(
        );

    HRESULT
    CrossValidateDataObjects(
        );

    VOID
    CreateGlobalData(
        );

    VOID
    AdvertiseServiceInformationInMB(
        );


    DWORD m_Signature;

    //
    // Critical Section to control access to the
    // ABO object while it is being changed.
    //
    CRITICAL_SECTION m_AboCritSec;

    //
    // Point to access the metabase through
    //
    ABO_MANAGER* m_pAboManager;

    //
    // Table that holds information about the
    // app pools that WAS is working with.
    // Note:  This table is initialized on the 
    // main thread, after initialization it is 
    // used only by the CNP thread
    //
    APP_POOL_DATA_OBJECT_TABLE m_AppPoolTable;

    //
    // Table that holds information about the
    // sites that WAS is working with.
    // Note:  This table is initialized on the 
    // main thread, after initialization it is 
    // used only by the CNP thread
    //
    SITE_DATA_OBJECT_TABLE m_SiteTable;

    //
    // Table that holds information about the
    // applications that WAS is working with.
    // Note:  This table is initialized on the 
    // main thread, after initialization it is 
    // used only by the CNP thread
    //
    APPLICATION_DATA_OBJECT_TABLE m_AppTable;

    //
    // Store contains one record that represents
    // the global data for W3SVC.
    // Note:  This store is initialized on the 
    // main thread, after initialization it is 
    // used only by the CNP thread
    //
    GLOBAL_DATA_STORE m_GlobalStore;

    // 
    // handles processing the configuration changes
    // before they reach the WAS thread.
    //
    CHANGE_PROCESSOR* m_pChangeProcessor;

    DWORD m_ListenerThreadId;

    HANDLE m_hListener;

    HANDLE m_hSignalConfigInitializationComplete;

    HRESULT m_hrConfigThreadInitialization;

    //
    // current config change 
    //

    APPLICATION_DATA_OBJECT_TABLE * m_pCurrentAppTable;

    SITE_DATA_OBJECT_TABLE * m_pCurrentSiteTable;

    BOOL m_ProcessChanges;

    LONG m_MetabaseIsInCrashedState;

    LONG m_InetinfoMonitorFatalErrors;

    LONG m_ConfigThreadProcessingDisabled;

    DWORD m_NumChangesProcessed;

    // used for generating hash's of passwords.
    HCRYPTPROV m_hCryptProvider;

    BOOL m_InInitializationPhase;
    BOOL m_NumberOfPoolStateWritingFailed;
    BOOL m_NumberOfSiteStateWritingFailed;

};  // class CONFIG_MANAGER



#endif  // _CONFIG_MANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\control_api.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    control_api.cxx

Abstract:

    The IIS web admin service control api class implementation. 
    This class receives and processes calls on the control api.

    Threading: Calls arrive on COM threads (i.e., secondary threads), and 
    so work items are posted to process the changes on the main worker thread.

Author:

    Seth Pollack (sethp)        15-Feb-2000

Revision History:

--*/



#include  "precomp.h"

BOOL
IsLocalSystemTheCaller();

/***************************************************************************++

Routine Description:

    Constructor for the CONTROL_API class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONTROL_API::CONTROL_API(
    )
{

    //
    // Set the initial reference count to 1, in order to represent the
    // reference owned by the creator of this instance.
    //

    m_RefCount = 1;

    m_Signature = CONTROL_API_SIGNATURE;

}   // CONTROL_API::CONTROL_API



/***************************************************************************++

Routine Description:

    Destructor for the CONTROL_API class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONTROL_API::~CONTROL_API(
    )
{

    DBG_ASSERT( m_Signature == CONTROL_API_SIGNATURE );

    m_Signature = CONTROL_API_SIGNATURE_FREED;

    DBG_ASSERT( m_RefCount == 0 );


}   // CONTROL_API::~CONTROL_API



/***************************************************************************++

Routine Description:

    Standard IUnknown::QueryInterface.

Arguments:

    iid - The requested interface id.

    ppObject - The returned interface pointer, or NULL on failure.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CONTROL_API::QueryInterface(
    IN REFIID iid,
    OUT VOID ** ppObject
    )
{

    HRESULT hr = S_OK;


    if ( ppObject == NULL )
    {
        hr = E_INVALIDARG;

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "QueryInterface on CONTROL_API object failed, bad pointer\n"
            ));

        goto exit;
    }


    if ( iid == IID_IUnknown || iid == IID_IW3Control )
    {
        *ppObject = reinterpret_cast< IW3Control * > ( this );

        AddRef();
    }
    else
    {
        *ppObject = NULL;
        
        hr = E_NOINTERFACE;

        goto exit;
    }


exit:

    return hr;

}   // CONTROL_API::QueryInterface



/***************************************************************************++

Routine Description:

    Standard IUnknown::AddRef.

Arguments:

    None.

Return Value:

    ULONG - The new reference count.

--***************************************************************************/

ULONG
STDMETHODCALLTYPE
CONTROL_API::AddRef(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedIncrement( &m_RefCount );


    //
    // The reference count should never have been less than zero; and
    // furthermore once it has hit zero it should never bounce back up;
    // given these conditions, it better be greater than one now.
    //
    
    DBG_ASSERT( NewRefCount > 1 );


    return ( ( ULONG ) NewRefCount );

}   // CONTROL_API::AddRef



/***************************************************************************++

Routine Description:

    Standard IUnknown::Release.

Arguments:

    None.

Return Value:

    ULONG - The new reference count.

--***************************************************************************/

ULONG
STDMETHODCALLTYPE
CONTROL_API::Release(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedDecrement( &m_RefCount );

    // ref count should never go negative
    DBG_ASSERT( NewRefCount >= 0 );

    if ( NewRefCount == 0 )
    {
        // time to go away

        IF_DEBUG( WEB_ADMIN_SERVICE_REFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Reference count has hit zero in CONTROL_API, deleting (ptr: %p)\n",
                this
                ));
        }


        delete this;


    }


    return ( ( ULONG ) NewRefCount );

}   // CONTROL_API::Release

/***************************************************************************++

Routine Description:

    Returns the current process model that the server is running under.

Arguments:

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CONTROL_API::RecycleAppPool(
    IN LPCWSTR szAppPool
    )
{

    HRESULT hr = S_OK;

    //
    // Security Check, only local system is allowed
    // to call this function.  See comment in the 
    // IsLocalSystemTheCaller function to understand
    // why we do it this way.
    // 
    if ( !IsLocalSystemTheCaller() )
    {
        return E_ACCESSDENIED;
    }

    //
    // Complain if we are asked for the current mode
    // but are not given an appropriate place to store
    // it.
    //
    if ( szAppPool == NULL )
    {
        return E_INVALIDARG;
    }

    //
    // Go ahead and marshall the call to the main thread
    // this will allow for us to do the check and set the
    // current mode variable.
    //
    hr = MarshallCallToMainWorkerThread(
                RecycleAppPoolControlApiCallMethod,
                ( DWORD_PTR ) szAppPool
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Failed to marshall to the main thread to recycle app pool %S.\n",
            szAppPool
            ));

    }

    return hr;

}   // CONTROL_API::RecycleAppPool

/***************************************************************************++

Routine Description:

    Marshall the call to the main worker thread for processing; then
    return the results.

Arguments:

    Method - The method being called. 

    Param0 ... ParamN - The parameter values for the method. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONTROL_API::MarshallCallToMainWorkerThread(
    IN CONTROL_API_CALL_METHOD Method,
    IN DWORD_PTR Param0 OPTIONAL,
    IN DWORD_PTR Param1 OPTIONAL,
    IN DWORD_PTR Param2 OPTIONAL,
    IN DWORD_PTR Param3 OPTIONAL
    )
{

    HRESULT hr = S_OK;
    CONTROL_API_CALL * pControlApiCall = NULL;


    DBG_ASSERT( ! ON_MAIN_WORKER_THREAD );

    //
    // Create an object to hold the call.
    //

    pControlApiCall = new CONTROL_API_CALL();
    if ( pControlApiCall == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating CONTROL_API_CALL failed\n"
            ));

        goto exit;
    }


    hr = pControlApiCall->Initialize(
                                Method,
                                Param0,
                                Param1,
                                Param2,
                                Param3
                                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing control api call failed\n"
            ));

        goto exit;
    }


    //
    // Post to the main worker thread for processing.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "About to create/queue work item for processing control api call, CONTROL_API_CALL (ptr: %p)\n",
            pControlApiCall
            ));
    }


    hr = QueueWorkItemFromSecondaryThread(
            pControlApiCall,
            ProcessCallControlApiCallWorkItem
            );
    if ( FAILED ( hr ) )
    {
        goto exit;
    }


    //
    // Now that we've queued the call, wait on the per-call event
    // so that we know when the call has been processed. Once this
    // event has been signalled, the work is done, the return code
    // is available, and output parameters have been set.
    //

    DBG_REQUIRE( WaitForSingleObject( pControlApiCall->GetEvent(), INFINITE ) == WAIT_OBJECT_0 );


    //
    // Pull out the return code from the processed call.
    //

    DBG_ASSERT( hr == S_OK );

    hr = pControlApiCall->GetReturnCode();


exit:

    if ( pControlApiCall != NULL )
    {
        pControlApiCall->Dereference();
        pControlApiCall = NULL;
    }

    return hr;

}   // CONTROL_API::MarshallCallToMainWorkerThread

/***************************************************************************++

Routine Description:

    Routine will validate that the local system was actually the identity
    of the person who requested this operation.  Since this is an internal interface
    that is exposed to the public through the wamreg stuff, only wamreg should be
    calling us, and he runs as Local System.

    We can not lock this interface down with AccessPermissions because calling
    CoInitializeSecurity overrides the AccessPermission settings on the AppId and
    svchost.exe calls the CoInitializeSecurity for us and does not let us configure
    the parameters to be sent in for our access permissions.

Arguments:

    None.

Return Value:

    Bool

--***************************************************************************/

BOOL 
IsLocalSystemTheCaller()
{

    HRESULT hr = S_OK;
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // We assume we are not being called by local system until
    // we figure out that we are.
    //
    BOOL fIsLocalSystem = FALSE;
    DWORD dwBytesNeeded = 0;

    BUFFER bufSidAtt(20);
    SID_AND_ATTRIBUTES* pSidAtt = NULL;  

    BOOL fImpersonating = FALSE;
    HANDLE ThreadToken = NULL;

    // 
    // Take on the identity of the caller.
    //
    hr = CoImpersonateClient();
    if ( FAILED ( hr ) ) 
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Failed to CoImpersonateClient to check if local system was calling the interface\n"
            ));

        goto exit;
    }

    fImpersonating = TRUE;

    //
    // We were able to become the client.  Now we need to 
    // figure out who that is.
    //
    if ( !OpenThreadToken( GetCurrentThread(),
                            TOKEN_READ,
                            TRUE,
                            &ThreadToken ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(GetLastError()),
            "Failed to open the thread token\n"
            ));

        goto exit;
    }

    if ( !GetTokenInformation( ThreadToken,
                                  TokenUser,
                                  bufSidAtt.QueryPtr(),
                                  bufSidAtt.QuerySize(),
                                  &dwBytesNeeded ) )
    {
        dwErr = GetLastError();

        if ( dwErr == ERROR_INSUFFICIENT_BUFFER )
        {
            DBG_ASSERT ( dwBytesNeeded > bufSidAtt.QuerySize() );

            // Attempt to resize to the correct size if needed
            if ( !bufSidAtt.Resize( dwBytesNeeded ) )
            {
                DPERROR(( 
                    DBG_CONTEXT,
                    HRESULT_FROM_WIN32(GetLastError()),
                    "Failed to allocate space for token information\n"
                    ));

                goto exit;
            }

            // if we don't succeed here, just fail out.
            if ( !GetTokenInformation( ThreadToken,
                                      TokenUser,
                                      bufSidAtt.QueryPtr(),
                                      bufSidAtt.QuerySize(),
                                      &dwBytesNeeded ) )
            {
                DPERROR(( 
                    DBG_CONTEXT,
                    HRESULT_FROM_WIN32(GetLastError()),
                    "Failed to get token information\n"
                    ));

                goto exit;
            }
        }
        else
        {
            //
            // it didn't fail with insufficient buffer so
            // we don't need to resize, but we do need to spew.
            //
            DPERROR(( 
                DBG_CONTEXT,
                HRESULT_FROM_WIN32(GetLastError()),
                "Failed to get token information\n"
                ));

            goto exit;
        }

    }    
        
    pSidAtt = reinterpret_cast<SID_AND_ATTRIBUTES*>(bufSidAtt.QueryPtr());

    DBG_ASSERT ( pSidAtt->Sid != NULL );
    DBG_ASSERT ( GetWebAdminService()->GetLocalSystemSid() != NULL );

    //
    // At this point we should have the sid to compare.
    //
    if ( EqualSid( pSidAtt->Sid, GetWebAdminService()->GetLocalSystemSid() ) )
    {
        fIsLocalSystem = TRUE;
    }

exit:

    // if we openned the thread token, close it.
    if ( ThreadToken != NULL )
    {
        CloseHandle ( ThreadToken );
        ThreadToken = NULL;
    }

    // if we succeeded in impersonating go back to
    // not impersonating.
    if ( fImpersonating )
    {
        hr = CoRevertToSelf();
        if (FAILED(hr))
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Failed to Revert To Self after checking if local system was calling the interface\n"
                ));
        }

    }

    return fIsLocalSystem;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\control_api_call.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    control_api_call.cxx

Abstract:

    The IIS web admin service control api call class implementation. 
    This class is used to queue control api calls to the main worker thread.

    Threading: Control api calls arrive on COM threads (i.e., secondary 
    threads), and so instances of this class are created on secondary threads.
    Actual processing of control api calls happens on the main worker thread.

Author:

    Seth Pollack (sethp)        23-Feb-2000

Revision History:

--*/



#include  "precomp.h"



/***************************************************************************++

Routine Description:

    Constructor for the CONTROL_API_CALL class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONTROL_API_CALL::CONTROL_API_CALL(
    )
{

    //
    // Set the initial reference count to 1, in order to represent the
    // reference owned by the creator of this instance.
    //

    m_RefCount = 1;


    m_Event = NULL;


    m_Method = InvalidControlApiCallMethod;

    m_Param0 = 0;
    m_Param1 = 0;
    m_Param2 = 0;
    m_Param3 = 0;

    m_ReturnCode = S_OK;

    m_Signature = CONTROL_API_CALL_SIGNATURE;

}   // CONTROL_API_CALL::CONTROL_API_CALL



/***************************************************************************++

Routine Description:

    Destructor for the CONTROL_API_CALL class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONTROL_API_CALL::~CONTROL_API_CALL(
    )
{

    DBG_ASSERT( m_Signature == CONTROL_API_CALL_SIGNATURE );

    m_Signature = CONTROL_API_CALL_SIGNATURE_FREED;

    DBG_ASSERT( m_RefCount == 0 );


    if ( m_Event != NULL )
    {
        DBG_REQUIRE( CloseHandle( m_Event ) );
        m_Event = NULL;
    }

}   // CONTROL_API_CALL::~CONTROL_API_CALL



/***************************************************************************++

Routine Description:

    Increment the reference count for this object. Note that this method must
    be thread safe, and must not be able to fail.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
CONTROL_API_CALL::Reference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedIncrement( &m_RefCount );


    //
    // The reference count should never have been less than zero; and
    // furthermore once it has hit zero it should never bounce back up;
    // given these conditions, it better be greater than one now.
    //
    
    DBG_ASSERT( NewRefCount > 1 );


    return;

}   // CONTROL_API_CALL::Reference



/***************************************************************************++

Routine Description:

    Decrement the reference count for this object, and cleanup if the count
    hits zero. Note that this method must be thread safe, and must not be
    able to fail.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
CONTROL_API_CALL::Dereference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedDecrement( &m_RefCount );

    // ref count should never go negative
    DBG_ASSERT( NewRefCount >= 0 );

    if ( NewRefCount == 0 )
    {
        // time to go away

        IF_DEBUG( WEB_ADMIN_SERVICE_REFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Reference count has hit zero in CONTROL_API_CALL instance, deleting (ptr: %p)\n",
                this
                ));
        }


        delete this;


    }


    return;

}   // CONTROL_API_CALL::Dereference



/***************************************************************************++

Routine Description:

    Execute a work item on this object.

Arguments:

    pWorkItem - The work item to execute.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONTROL_API_CALL::ExecuteWorkItem(
    IN const WORK_ITEM * pWorkItem
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( pWorkItem != NULL );


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        CHKINFO((
            DBG_CONTEXT,
            "Executing work item with serial number: %lu in CONTROL_API_CALL (ptr: %p) with operation: %p\n",
            pWorkItem->GetSerialNumber(),
            this,
            pWorkItem->GetOpCode()
            ));
    }


    switch ( pWorkItem->GetOpCode() )
    {

    case ProcessCallControlApiCallWorkItem:

        ProcessCall();

        break;

    default:

        // invalid work item!
        DBG_ASSERT( FALSE );
        
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;

    }


    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Executing work item on CONTROL_API_CALL failed\n"
            ));

    }


    return hr;

}   // CONTROL_API_CALL::ExecuteWorkItem



/***************************************************************************++

Routine Description:

    Initialize this instance. 

Arguments:

    Method - The method being called. 

    Param0 ... ParamN - The parameter values for the method. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONTROL_API_CALL::Initialize(
    IN CONTROL_API_CALL_METHOD Method,
    IN DWORD_PTR Param0 OPTIONAL,
    IN DWORD_PTR Param1 OPTIONAL,
    IN DWORD_PTR Param2 OPTIONAL,
    IN DWORD_PTR Param3 OPTIONAL
    )
{

    HRESULT hr = S_OK;


    //
    // Create the event used for signalling the calling thread.
    //

    m_Event = CreateEvent(
                    NULL,                   // default security
                    FALSE,                  // auto-reset
                    FALSE,                  // not signalled to start
                    NULL                    // un-named
                    );

    if ( m_Event == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Creating event failed\n"
            ));

        goto exit;
    }


    //
    // Copy parameters.
    //

    m_Method = Method;

    m_Param0 = Param0;
    m_Param1 = Param1;
    m_Param2 = Param2;
    m_Param3 = Param3;


exit:

    return hr;

}   // CONTROL_API_CALL::Initialize



/***************************************************************************++

Routine Description:

    Process a call, once it has been marshalled to the main worker thread. 

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
CONTROL_API_CALL::ProcessCall(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    //
    // If we have turned off control operation processing, then bail out.
    //

    if ( ! GetWebAdminService()->GetConfigAndControlManager()->IsChangeProcessingEnabled() )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Ignoring control operation because we are no longer processing them (CONTROL_API_CALL ptr: %p)\n",
                this
                ));
        }

        goto exit;
    }


    switch ( m_Method )
    {

        case RecycleAppPoolControlApiCallMethod:

            DBG_ASSERT ( m_Param0 );

            hr = GetWebAdminService()->GetUlAndWorkerManager()->
                    RecycleAppPool(
                        ( LPCWSTR ) m_Param0
                        );

        break;

        default:

            // invalid method!
            DBG_ASSERT( FALSE );
        
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;

    }


    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Processing control api call failed\n"
            ));

        goto exit;
    }


exit:

    //
    // Capture the return value, to give to the original calling 
    // thread.
    //

    m_ReturnCode = hr;

    hr = S_OK;

    //
    // Signal the original calling thread that the work is done.
    //

    DBG_REQUIRE( SetEvent( GetEvent() ) );

}   // CONTROL_API_CALL::ProcessCall
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\control_api_call.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    control_api_call.h

Abstract:

    The IIS web admin service control api call class definition.

Author:

    Seth Pollack (sethp)        23-Feb-2000

Revision History:

--*/



#ifndef _CONTROL_API_CALL_H_
#define _CONTROL_API_CALL_H_



//
// common #defines
//

#define CONTROL_API_CALL_SIGNATURE          CREATE_SIGNATURE( 'CCAL' )
#define CONTROL_API_CALL_SIGNATURE_FREED    CREATE_SIGNATURE( 'ccaX' )



//
// structs, enums, etc.
//

// CONTROL_API_CALL work items
enum CONTROL_API_CALL_WORK_ITEM
{

    //
    // Process a configuration change.
    //
    ProcessCallControlApiCallWorkItem = 1,
    
};


// CONTROL_API_CALL methods
enum CONTROL_API_CALL_METHOD
{

    InvalidControlApiCallMethod,

    RecycleAppPoolControlApiCallMethod,

    MaximumControlApiCallMethod,
    
};



//
// prototypes
//


class CONTROL_API_CALL
    : public WORK_DISPATCH
{

public:

    CONTROL_API_CALL(
        );

    virtual
    ~CONTROL_API_CALL(
        );

    virtual
    VOID
    Reference(
        );

    virtual
    VOID
    Dereference(
        );

    virtual
    HRESULT
    ExecuteWorkItem(
        IN const WORK_ITEM * pWorkItem
        );

    HRESULT
    Initialize(
        IN CONTROL_API_CALL_METHOD Method,
        IN DWORD_PTR Param0 OPTIONAL,
        IN DWORD_PTR Param1 OPTIONAL,
        IN DWORD_PTR Param2 OPTIONAL,
        IN DWORD_PTR Param3 OPTIONAL
        );

    inline
    HANDLE
    GetEvent(
        )
        const
    { return m_Event; }

    inline
    HRESULT
    GetReturnCode(
        )
        const
    { return m_ReturnCode; }


private:

    VOID
    ProcessCall(
        );


    DWORD m_Signature;

    LONG m_RefCount;


    //
    // The COM call blocks on this event.
    //

    HANDLE m_Event;


    //
    // The method and parameters of the call.
    //

    CONTROL_API_CALL_METHOD m_Method;

    DWORD_PTR m_Param0;
    DWORD_PTR m_Param1;
    DWORD_PTR m_Param2;
    DWORD_PTR m_Param3;


    //
    // The return code passed back from the main worker thread.
    //

    HRESULT m_ReturnCode;


};  // class CONTROL_API_CALL



#endif  // _CONTROL_API_CALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\control_api_class_factory.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    control_api_class_factory.cxx

Abstract:

    The IIS web admin service control api class factory class implementation. 
    This class creates instances of the control api.

    Threading: Calls arrive on COM threads (i.e., secondary threads), and 
    are processed directly on those threads.

Author:

    Seth Pollack (sethp)        15-Feb-2000

Revision History:

--*/



#include  "precomp.h"



/***************************************************************************++

Routine Description:

    Constructor for the CONTROL_API_CLASS_FACTORY class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONTROL_API_CLASS_FACTORY::CONTROL_API_CLASS_FACTORY(
    )
{

    //
    // Set the initial reference count to 1, in order to represent the
    // reference owned by the creator of this instance.
    //

    m_RefCount = 1;

    m_Signature = CONTROL_API_CLASS_FACTORY_SIGNATURE;

}   // CONTROL_API_CLASS_FACTORY::CONTROL_API_CLASS_FACTORY



/***************************************************************************++

Routine Description:

    Destructor for the CONTROL_API_CLASS_FACTORY class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONTROL_API_CLASS_FACTORY::~CONTROL_API_CLASS_FACTORY(
    )
{

    DBG_ASSERT( m_Signature == CONTROL_API_CLASS_FACTORY_SIGNATURE );

    m_Signature = CONTROL_API_CLASS_FACTORY_SIGNATURE_FREED;

    DBG_ASSERT( m_RefCount == 0 );


}   // CONTROL_API_CLASS_FACTORY::~CONTROL_API_CLASS_FACTORY



/***************************************************************************++

Routine Description:

    Standard IUnknown::QueryInterface.

Arguments:

    iid - The requested interface id.

    ppObject - The returned interface pointer, or NULL on failure.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CONTROL_API_CLASS_FACTORY::QueryInterface(
    IN REFIID iid,
    OUT VOID ** ppObject
    )
{

    HRESULT hr = S_OK;


    if ( ppObject == NULL )
    {
        hr = E_INVALIDARG;

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "QueryInterface on CONTROL_API_CLASS_FACTORY object failed, bad pointer\n"
            ));

        goto exit;
    }


    if ( iid == IID_IUnknown || iid == IID_IClassFactory )
    {
        *ppObject = reinterpret_cast<IClassFactory*> ( this );

        AddRef();
    }
    else
    {
        *ppObject = NULL;
        
        hr = E_NOINTERFACE;

        //
        // OLE32 will call looking for this interface when we are trying to disconnect
        // clients and shutdown.  It is fine that we do not support it, it will use
        // the standard marshaler's implementation.  We just don't want to spew an
        // error when nothing really went wrong.
        //
        if ( iid != IID_IMarshal )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "QueryInterface on CONTROL_API_CLASS_FACTORY object failed, IID not supported\n"
            ));
        }

        goto exit;
    }


exit:

    return hr;

}   // CONTROL_API_CLASS_FACTORY::QueryInterface



/***************************************************************************++

Routine Description:

    Standard IUnknown::AddRef.

Arguments:

    None.

Return Value:

    ULONG - The new reference count.

--***************************************************************************/

ULONG
STDMETHODCALLTYPE
CONTROL_API_CLASS_FACTORY::AddRef(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedIncrement( &m_RefCount );


    //
    // The reference count should never have been less than zero; and
    // furthermore once it has hit zero it should never bounce back up;
    // given these conditions, it better be greater than one now.
    //
    
    DBG_ASSERT( NewRefCount > 1 );


    return ( ( ULONG ) NewRefCount );

}   // CONTROL_API_CLASS_FACTORY::AddRef



/***************************************************************************++

Routine Description:

    Standard IUnknown::Release.

Arguments:

    None.

Return Value:

    ULONG - The new reference count.

--***************************************************************************/

ULONG
STDMETHODCALLTYPE
CONTROL_API_CLASS_FACTORY::Release(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedDecrement( &m_RefCount );

    // ref count should never go negative
    DBG_ASSERT( NewRefCount >= 0 );

    if ( NewRefCount == 0 )
    {
        // time to go away

        IF_DEBUG( WEB_ADMIN_SERVICE_REFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Reference count has hit zero in CONTROL_API_CLASS_FACTORY, deleting (ptr: %p)\n",
                this
                ));
        }


        delete this;


    }


    return ( ( ULONG ) NewRefCount );

}   // CONTROL_API_CLASS_FACTORY::Release



/***************************************************************************++

Routine Description:

    Create a new instance of the control api object. 

Arguments:

    pControllingUnknown - The controlling unknown for aggregation. Must be
    NULL.

    iid - The requested interface id.

    ppObject - The returned interface pointer, or NULL on failure.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CONTROL_API_CLASS_FACTORY::CreateInstance(
    IN IUnknown * pControllingUnknown,
    IN REFIID iid,
    OUT VOID ** ppObject
    )
{

    HRESULT hr = S_OK;
    CONTROL_API * pControlApi = NULL;


    DBG_ASSERT( ! ON_MAIN_WORKER_THREAD );


    //
    // Validate and initialize output parameters.
    //

    if ( ppObject == NULL )
    {
        hr = E_INVALIDARG;

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating control api instance failed, bad pointer\n"
            ));

        goto exit;
    }

    *ppObject = NULL;


    if ( pControllingUnknown != NULL )
    {
        hr = CLASS_E_NOAGGREGATION;

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating control api instance failed, aggregation attempted\n"
            ));

        goto exit;
    }


    //
    // Create the instance.
    //

    pControlApi = new CONTROL_API();

    if ( pControlApi == NULL )
    {
        hr = E_OUTOFMEMORY;
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating CONTROL_API failed\n"
            ));

        goto exit;
    }


    //
    // Note that QueryInterface() will add a reference.
    //

    hr = pControlApi->QueryInterface( iid, ppObject );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "QueryInterface on control api instance failed\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_REFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Created new instance of control api object: %p\n",
            *ppObject
            ));
    }


exit:

    //
    // Release our reference.
    //

    if ( pControlApi != NULL )
    {
        pControlApi->Release();
        pControlApi = NULL; 
    }


    return hr;

}   // CONTROL_API_CLASS_FACTORY::CreateInstance



/***************************************************************************++

Routine Description:

    Lock or unlock the class factory.

Arguments:

    Lock - TRUE to lock, FALSE to unlock.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CONTROL_API_CLASS_FACTORY::LockServer(
    IN BOOL Lock
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ! ON_MAIN_WORKER_THREAD );


    if ( Lock )
    {
        AddRef();
    }
    else
    {
        Release();
    }


    return hr;

}   // CONTROL_API_CLASS_FACTORY::LockServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\control_api_class_factory.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    control_api_class_factory.h

Abstract:

    The IIS web admin service control api class factory class definition.

Author:

    Seth Pollack (sethp)        15-Feb-2000

Revision History:

--*/



#ifndef _CONTROL_API_CLASS_FACTORY_H_
#define _CONTROL_API_CLASS_FACTORY_H_



//
// common #defines
//

#define CONTROL_API_CLASS_FACTORY_SIGNATURE         CREATE_SIGNATURE( 'CACF' )
#define CONTROL_API_CLASS_FACTORY_SIGNATURE_FREED   CREATE_SIGNATURE( 'cacX' )



//
// prototypes
//


class CONTROL_API_CLASS_FACTORY
    : public IClassFactory
{

public:

    CONTROL_API_CLASS_FACTORY(
        );

    virtual
    ~CONTROL_API_CLASS_FACTORY(
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    QueryInterface(
        IN REFIID iid,
        OUT VOID ** ppObject
        );

    virtual
    ULONG
    STDMETHODCALLTYPE
    AddRef(
        );

    virtual
    ULONG
    STDMETHODCALLTYPE
    Release(
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    CreateInstance(
        IN IUnknown * pControllingUnknown,
        IN REFIID iid,
        OUT VOID ** ppObject
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    LockServer(
        IN BOOL Lock
        );


private:


    DWORD m_Signature;

    LONG m_RefCount;


};  // class CONTROL_API_CLASS_FACTORY



#endif  // _CONTROL_API_CLASS_FACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\logerror.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    logerror.cxx

Abstract:

    Event logging of was errors

Author:

    Emily Kruglick      4/12/2002

Revision History:

--*/

#include "precomp.h"

VOID 
WAS_ERROR_LOGGER::LogApplicationError(
    DWORD dwMessageId,
    HRESULT hr,
    DWORD dwSiteId,
    LPCWSTR pUrl
    )
{
    const WCHAR * EventLogStrings[2];
    WCHAR StringizedSiteId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];

    _ultow(dwSiteId, StringizedSiteId, 10);

    EventLogStrings[0] = StringizedSiteId;
    EventLogStrings[1] = pUrl;

    GetWebAdminService()->GetEventLog()->
        LogEvent(
            dwMessageId,                                // message id
            sizeof(EventLogStrings)/sizeof(WCHAR*),     // count of strings
            EventLogStrings,                            // array of strings
            hr                                          // error code
            );

}

VOID 
WAS_ERROR_LOGGER::LogSiteError(
    DWORD dwMessageId,
    HRESULT hr,
    DWORD dwSiteId
    )
{
    const WCHAR * EventLogStrings[1];
    WCHAR StringizedSiteId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];

    _ultow(dwSiteId, StringizedSiteId, 10);

    EventLogStrings[0] = StringizedSiteId;

    GetWebAdminService()->GetEventLog()->
        LogEvent(
            dwMessageId,                                // message id
            sizeof(EventLogStrings)/sizeof(WCHAR*),     // count of strings
            EventLogStrings,                            // array of strings
            hr                                          // error code
            );

}

VOID 
WAS_ERROR_LOGGER::LogAppPoolError(
    DWORD dwMessageId,
    HRESULT hr,
    LPCWSTR pAppPoolId
    )
{
    const WCHAR * EventLogStrings[1];

    EventLogStrings[0] = pAppPoolId;

    GetWebAdminService()->GetEventLog()->
        LogEvent(
            dwMessageId,                                // message id
            sizeof(EventLogStrings)/sizeof(WCHAR*),     // count of strings
            EventLogStrings,                            // array of strings
            hr                                          // error code
            );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\globalstore.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    globalstore.cxx

Abstract:

    Read global settings

Author:

    Bilal Alam (balam)               27-May-2001

Revision History:

--*/

#include "precomp.h"

HRESULT
GLOBAL_DATA_OBJECT::SetFromMetabaseData(
    METADATA_GETALL_RECORD *       pProperties,
    DWORD                          cProperties,
    BYTE *                         pbBase
)
/*++

Routine Description:

    Read global configuration from metabase props

Arguments:

    pProperties - Array of metadata properties
    cProperties - Count of metadata properties
    pbBase - Base of offsets in metadata properties

Return Value:

    HRESULT

--*/
{
    DWORD                   dwCounter;
    PVOID                   pvDataPointer;
    METADATA_GETALL_RECORD* pCurrentRecord = NULL;
    HRESULT                 hr = S_OK;

    if ( pProperties == NULL )
    {
        DBG_ASSERT( pProperties != NULL );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    for ( dwCounter = 0;
          dwCounter < cProperties;
          dwCounter++ )
    {
        pCurrentRecord = &(pProperties[ dwCounter ]);

        pvDataPointer = (PVOID) ( pbBase + pCurrentRecord->dwMDDataOffset );

        switch ( pCurrentRecord->dwMDIdentifier )
        {
            case MD_MAX_GLOBAL_BANDWIDTH:
                _dwMaxBandwidth = *(DWORD*) pvDataPointer;
                break;

            case MD_CONNECTION_TIMEOUT:
                _dwConnectionTimeout = *(DWORD*) pvDataPointer;
                break;

            case MD_DEMAND_START_THRESHOLD:
                _dwDemandStartLimit = *(DWORD*) pvDataPointer;
                break;

            case MD_HEADER_WAIT_TIMEOUT:
                _dwHeaderWaitTimeout = *(DWORD*) pvDataPointer;
                break;

            case MD_MIN_FILE_BYTES_PER_SEC:
                _dwMinFileBytesSec = *(DWORD*) pvDataPointer;
                break;

            case MD_GLOBAL_LOG_IN_UTF_8:
                _fLogInUtf8 = !! *(DWORD*) pvDataPointer;
                break;

            case MD_GLOBAL_BINARY_LOGGING_ENABLED:
                _fGlobalBinaryLoggingEnabled = !! *(DWORD*) pvDataPointer;
                break;

            case MD_LOGFILE_DIRECTORY:
                hr = _strLogFileDirectory.Copy( (WCHAR*) pvDataPointer );
                if ( FAILED( hr ) )
                {
                    return hr;
                }
                break;

            case MD_LOGFILE_PERIOD:
                _dwLogFilePeriod = *((DWORD *) pvDataPointer );
                break;

            case MD_LOGFILE_TRUNCATE_SIZE:
                _dwLogFileTruncateSize = *((DWORD *) pvDataPointer );
                break;

        }
    }

    return S_OK;
}

DATA_OBJECT *
GLOBAL_DATA_OBJECT::Clone(
    VOID
)
/*++

Routine Description:

    Clone global data object

Arguments:

    None

Return Value:

    DATA_OBJECT *

--*/
{
    GLOBAL_DATA_OBJECT *        pClone;
    HRESULT                 hr;

    pClone = new GLOBAL_DATA_OBJECT;
    if ( pClone == NULL )
    {
        return NULL;
    }

    pClone->_fMaxBandwidthChanged           = _fMaxBandwidthChanged;
    pClone->_fConnectionTimeoutChanged      = _fConnectionTimeoutChanged;
    pClone->_fHeaderWaitTimeoutChanged      = _fHeaderWaitTimeoutChanged;
    pClone->_fMinFileBytesSecChanged        = _fMinFileBytesSecChanged;
    pClone->_fLogInUtf8Changed              = _fLogInUtf8Changed;
    pClone->_fFilterFlagsChanged            = _fFilterFlagsChanged;
    pClone->_fLogFilePeriodChanged          = _fLogFilePeriodChanged;
    pClone->_fLogFileTruncateSizeChanged    = _fLogFileTruncateSizeChanged;
    pClone->_fLogFileDirectoryChanged       = _fLogFileDirectoryChanged;
    pClone->_fDemandStartLimitChanged       = _fDemandStartLimitChanged;

    pClone->_dwMaxBandwidth                 = _dwMaxBandwidth;
    pClone->_dwConnectionTimeout            = _dwConnectionTimeout;
    pClone->_dwHeaderWaitTimeout            = _dwHeaderWaitTimeout;
    pClone->_dwMinFileBytesSec              = _dwMinFileBytesSec;
    pClone->_fLogInUtf8                     = _fLogInUtf8;
    pClone->_dwFilterFlags                  = _dwFilterFlags;
    pClone->_fGlobalBinaryLoggingEnabled    = _fGlobalBinaryLoggingEnabled;
    pClone->_dwLogFilePeriod                = _dwLogFilePeriod;
    pClone->_dwLogFileTruncateSize          = _dwLogFileTruncateSize;
    pClone->_dwDemandStartLimit             = _dwDemandStartLimit;

    hr = pClone->_strLogFileDirectory.Copy( _strLogFileDirectory );
    if ( FAILED( hr ) )
    {
        delete pClone;
        return NULL;
    }

    CloneBasics ( pClone );

    return pClone;
}


HRESULT
GLOBAL_DATA_OBJECT::ReadFilterFlags(
    IMSAdminBase *              pAdminBase
)
/*++

Routine Description:

    Read the funky filter flags

Arguments:

    pAdminBase - ABO

Return Value:

    None

--*/
{
    MB              mb( pAdminBase );
    BOOL            fRet;
    STACK_STRU(     strFilterOrder, 245 );
    WCHAR *         pszFilter;
    DWORD           dwFilterFlags = 0;
    WCHAR *         pszComma;
    DWORD           dwFlag;

    fRet = mb.Open( L"LM/W3SVC/FILTERS/" );
    if ( !fRet )
    {
        //
        // I guess its OK to not have a filter key (i.e. we should still be
        // able to run
        //

        return NO_ERROR;
    }

    fRet = mb.GetStr( NULL,
                      MD_FILTER_LOAD_ORDER,
                      IIS_MD_UT_SERVER,
                      &strFilterOrder );
    if ( !fRet )
    {
        return NO_ERROR;
    }

    pszFilter = strFilterOrder.QueryStr();
    while ( *pszFilter != L'\0' )
    {
        pszComma = wcschr( pszFilter, L',' );
        if ( pszComma != NULL )
        {
            *pszComma = L'\0';
        }

        while ( iswspace( *pszFilter ) )
        {
            pszFilter++;
        }

        fRet = mb.GetDword( pszFilter,
                            MD_FILTER_FLAGS,
                            IIS_MD_UT_SERVER,
                            &dwFlag );
        if ( fRet )
        {
            dwFilterFlags |= dwFlag;
        }

        if ( pszComma != NULL )
        {
            pszFilter = pszComma + 1;
        }
        else
        {
            break;
        }
    }

    _dwFilterFlags = dwFilterFlags;

    return NO_ERROR;
}

VOID
GLOBAL_DATA_OBJECT::Compare(
    DATA_OBJECT *               pDataObject
)
/*++

Routine Description:

    Compare the given data object to this one

Arguments:

    pDataObject - Data object to compare to

Return Value:

    None

--*/
{
    GLOBAL_DATA_OBJECT *        pGlobalObject = (GLOBAL_DATA_OBJECT*) pDataObject;

    DBG_ASSERT ( pDataObject );

    DBG_ASSERT( pGlobalObject->CheckSignature() );

    //
    // If the application is not in WAS then assume that all the
    // values have changed, because WAS will want to know about all
    // of them.
    //
    if ( pGlobalObject->QueryInWas() )
    {

        if ( _dwMaxBandwidth == pGlobalObject->_dwMaxBandwidth )
        {
            _fMaxBandwidthChanged = FALSE;
        }

        if ( _dwConnectionTimeout == pGlobalObject->_dwConnectionTimeout )
        {
            _fConnectionTimeoutChanged = FALSE;
        }

        if ( _dwDemandStartLimit == pGlobalObject->_dwDemandStartLimit )
        {
            _fDemandStartLimitChanged = FALSE;
        }

        if ( _dwHeaderWaitTimeout == pGlobalObject->_dwHeaderWaitTimeout )
        {
            _fHeaderWaitTimeoutChanged = FALSE;
        }

        if ( _dwMinFileBytesSec == pGlobalObject->_dwMinFileBytesSec )
        {
            _fMinFileBytesSecChanged = FALSE;
        }

        if ( _fLogInUtf8 == pGlobalObject->_fLogInUtf8 )
        {
            _fLogInUtf8Changed = FALSE;
        }

        if ( _dwFilterFlags == pGlobalObject->_dwFilterFlags )
        {
            _fFilterFlagsChanged = FALSE;
        }

        if ( _dwLogFilePeriod == pGlobalObject->_dwLogFilePeriod )
        {
            _fLogFilePeriodChanged = FALSE;
        }

        if ( _dwLogFileTruncateSize == pGlobalObject->_dwLogFileTruncateSize )
        {
            _fLogFileTruncateSizeChanged = FALSE;
        }

        if ( _strLogFileDirectory.Equals( pGlobalObject->_strLogFileDirectory ) )
        {
            _fLogFileDirectoryChanged = FALSE;
        }

    }
}

HRESULT
GLOBAL_DATA_OBJECT::Create(
    VOID
)
/*++

Routine Description:

    Set defaults for global data object, the constructor
    sets all values to zero and false.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;
    _dwConnectionTimeout = MBCONST_CONNECTION_TIMEOUT_DEFAULT;

    _dwLogFilePeriod = 1;
    _dwLogFileTruncateSize = 2000000;

    _dwMinFileBytesSec = 240;  // in bytes

    _dwDemandStartLimit = 0xFFFFFFFF;

    hr = _strLogFileDirectory.Copy( LOG_FILE_DIRECTORY_DEFAULT );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    return NO_ERROR;
}

VOID
GLOBAL_DATA_OBJECT::SelfValidate(
    VOID
)
/*++

Routine Description:

    Validate internal properties

Arguments:

    None

Return Value:

    None

--*/
{
    // there are no properties on w3svc that need
    // to be self validated because no properties
    // should be able to make us through out this object.
}

BOOL
GLOBAL_DATA_OBJECT::QueryHasChanged(
    VOID
) const
/*++

Routine Description:

    Has this object changed?

Arguments:

    None

Return Value:

    TRUE if it has

--*/
{
    if ( _fMaxBandwidthChanged ||
         _fConnectionTimeoutChanged ||
         _fHeaderWaitTimeoutChanged ||
         _fMinFileBytesSecChanged ||
         _fLogInUtf8Changed ||
         _fFilterFlagsChanged ||
         _fLogFilePeriodChanged ||
         _fLogFileTruncateSizeChanged ||
         _fLogFileDirectoryChanged ||
         _fDemandStartLimitChanged
         )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


HRESULT
GLOBAL_DATA_STORE::ReadFromMetabase(
    IMSAdminBase *              pAdminBase
)
/*++

Routine Description:

    Read global config from metabase

Arguments:

    pAdminBase - ABO

Return Value:

    HRESULT

--*/
{
    MB                      mb( pAdminBase );
    BOOL                    fRet;
    STACK_BUFFER(           bufProperties, 512 );
    DWORD                   cProperties;
    DWORD                   dwDataSetNumber;
    HRESULT                 hr = S_OK;
    GLOBAL_DATA_OBJECT *    pGlobalObject = NULL;

    //
    // since this function is called once per object, we should
    // not have a pGlobalDataObject until this function is completed.
    // cleanup logic below depends on this.
    //
    DBG_ASSERT ( _pGlobalDataObject == NULL );

    fRet = mb.Open( L"LM/W3SVC", METADATA_PERMISSION_READ );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }

    fRet = mb.GetAll( L"",
                      METADATA_INHERIT | METADATA_PARTIAL_PATH,
                      IIS_MD_UT_SERVER,
                      &bufProperties,
                      &cProperties,
                      &dwDataSetNumber );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }

    pGlobalObject = new GLOBAL_DATA_OBJECT;
    if ( pGlobalObject == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }

    hr = pGlobalObject->Create();
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    hr = pGlobalObject->SetFromMetabaseData( (METADATA_GETALL_RECORD*)
                                             bufProperties.QueryPtr(),
                                             cProperties,
                                             (PBYTE) bufProperties.QueryPtr() );
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    hr = pGlobalObject->ReadFilterFlags( pAdminBase );
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    _pGlobalDataObject = pGlobalObject;

exit:

    // If we did not save the global object
    // then something when wrong and we can
    // release the reference if we have a reference.
    if (   _pGlobalDataObject == NULL
           &&   pGlobalObject != NULL )
    {
        pGlobalObject->DereferenceDataObject();
        pGlobalObject = NULL;
    }

    return hr;
}

HRESULT
GLOBAL_DATA_STORE::ReadFromMetabaseChangeNotification(
    IMSAdminBase *              pAdminBase,
    MD_CHANGE_OBJECT            pcoChangeList[],
    DWORD                       dwMDNumElements,
    GLOBAL_DATA_STORE*          pMasterStore
)
/*++

Routine Description:

    Handle metabase change notifications

Arguments:

    pAdminBase - ABO
    pcoChangeList - Properties which changed
    dwMDNumElements - Number of elements

Return Value:

    HRESULT

--*/
{
    DWORD                   i;
    BOOL                    fReadAgain = FALSE;
    WCHAR *                 pszPath;

    UNREFERENCED_PARAMETER( pMasterStore );
    for ( i = 0; i < dwMDNumElements; i++ )
    {
        //
        // We only care about W3SVC properties (duh!)
        //

        if( _wcsnicmp( pcoChangeList[ i ].pszMDPath,
                       DATA_STORE_SERVER_MB_PATH,
                       DATA_STORE_SERVER_MB_PATH_CCH ) != 0 )
        {
            continue;
        }

        //
        // If a property changed at the W3SVC level, then we need to
        // reread global config
        //

        if ( wcslen( pcoChangeList[ i ].pszMDPath ) ==
             DATA_STORE_SERVER_MB_PATH_CCH )
        {
            fReadAgain = TRUE;
            break;
        }

        pszPath = pcoChangeList[ i ].pszMDPath + DATA_STORE_SERVER_MB_PATH_CCH;

        //
        // If a property changed at the W3SVC/filter level, then we need to
        // reread global config
        //

        if ( _wcsnicmp( pszPath,
                        L"Filters",
                        7 ) == 0 )
        {
            fReadAgain = TRUE;
            break;
        }
    }

    if ( fReadAgain )
    {
        return ReadFromMetabase( pAdminBase );
    }

    return S_OK;
}

HRESULT
GLOBAL_DATA_STORE::MergeTable(
    GLOBAL_DATA_STORE *         pGlobalDataTable
)
/*++

Routine Description:

    Merge given global table with this one

Arguments:

    pGlobalDataTable - Table to merge in

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( _pGlobalDataObject != NULL );

    if ( pGlobalDataTable == NULL )
    {
        DBG_ASSERT( pGlobalDataTable != NULL );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    GLOBAL_DATA_OBJECT* pNewGlobalObject = pGlobalDataTable->_pGlobalDataObject;

    if ( pNewGlobalObject == NULL )
    {
        // no data to merge.
        return S_OK;
    }

    pNewGlobalObject->SetInWas( _pGlobalDataObject->QueryInWas() );

    //
    // we should never be told to delete these values and we should
    // never be told that this record is not in WAS.
    //
    DBG_ASSERT ( !pNewGlobalObject->QueryDeleteWhenDone() );
    DBG_ASSERT ( pNewGlobalObject->QueryInWas() == TRUE );

    pNewGlobalObject->Compare( _pGlobalDataObject );

    //
    // release the current data object and grab
    // a reference on the new data object for the store.
    //

    _pGlobalDataObject->DereferenceDataObject();
    _pGlobalDataObject = pNewGlobalObject;
    _pGlobalDataObject->ReferenceDataObject();

    return S_OK;
}

HRESULT
GLOBAL_DATA_STORE::CopyInteresting(
    GLOBAL_DATA_STORE *         pGlobalStore
)
/*++

Routine Description:

    Handles copying any records that WAS will care about
    into a new table so WAS can work off of it when it
    gets to it.

Arguments:

    IN GLOBAL_DATA_STORE * pGlobalStore = the table that will
               contain the copies of the objects WAS cares about.

Return Value:

    LK_ACTION

--*/

{

    GLOBAL_DATA_OBJECT* pCloneObject = NULL;

    DBG_ASSERT( pGlobalStore != NULL );
    DBG_ASSERT( pGlobalStore->_pGlobalDataObject == NULL );

    DBG_ASSERT( _pGlobalDataObject != NULL );

    if ( !_pGlobalDataObject->QueryDoesWasCareAboutObject() )
    {
       return S_OK;
    }

    // make a clone of the data object
    pCloneObject = (GLOBAL_DATA_OBJECT*) _pGlobalDataObject->Clone();
    if ( pCloneObject == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    // now save the clone in store that was passed in.
    pGlobalStore->_pGlobalDataObject = pCloneObject;

    return S_OK;

}

VOID
GLOBAL_DATA_STORE::UpdateWASObjects(
    )
/*++

Routine Description:

    Handles determining if the global data object
    should be updated in WAS

Arguments:

    None

Return Value:

    HRESULT

--*/

{

    if ( _pGlobalDataObject )
    {

        DBG_ASSERT ( !_pGlobalDataObject->QueryDeleteWhenDone()  );

        GetWebAdminService()->
             GetUlAndWorkerManager()->
             ModifyGlobalData( _pGlobalDataObject );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\job_object.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    job_object.cxx

Abstract:

    This class encapsulates a single job object. 

    Threading: For the class itself, Reference(), Dereference(), and the
    destructor may be called on any thread; all other work is done on the 
    main worker thread.

Author:

    Emily Kruglick (EmilyK)    30-Nov-2000

Revision History:

--*/

#include "precomp.h"


//
// local prototypes
//

//
// Callback function that lets us know
// when the job object interval has expired
// so we can reset the job object.
//
VOID
JobObjectTimerCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    );


/***************************************************************************++

Routine Description:

    Constructor for the JOB_OBJECT class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

JOB_OBJECT::JOB_OBJECT(
    )
{
    //
    // Set the initial reference count to 1, in order to represent the
    // reference owned by the creator of this instance.
    //

    m_RefCount = 1;


    m_pAppPool = NULL;

    m_hJobObject = NULL;

    m_JobObjectTimerHandle = NULL;

    m_pWorkItem = NULL;

    m_State = NotInitalizedJobObjectState; 

    m_Signature = JOB_OBJECT_SIGNATURE;

}   // JOB_OBJECT::JOB_OBJECT



/***************************************************************************++

Routine Description:

    Destructor for the JOB_OBJECT class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

JOB_OBJECT::~JOB_OBJECT(
    )
{

    DBG_ASSERT( m_Signature == JOB_OBJECT_SIGNATURE );

    m_Signature = JOB_OBJECT_SIGNATURE_FREED;

    DBG_ASSERT( m_RefCount == 0 );

    //
    // The app pool should of been Dereferenced in the shutdown call,
    // and should now be NULL.
    //
    DBG_ASSERT ( m_pAppPool == NULL );

    DBG_ASSERT ( m_hJobObject == NULL );

    DBG_ASSERT( m_State == NotInitalizedJobObjectState );

    DBG_ASSERT ( m_JobObjectTimerHandle == NULL );

    DBG_ASSERT ( m_pWorkItem == NULL );

}   // JOB_OBJECT::~JOB_OBJECT


/***************************************************************************++

Routine Description:

    Increment the reference count for this object. Note that this method must 
    be thread safe, and must not be able to fail. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
JOB_OBJECT::Reference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedIncrement( &m_RefCount );


    // 
    // The reference count should never have been less than zero; and
    // furthermore once it has hit zero it should never bounce back up;
    // given these conditions, it better be greater than one now.
    //
    
    DBG_ASSERT( NewRefCount > 1 );


    return;

}   // JOB_OBJECT::Reference



/***************************************************************************++

Routine Description:

    Decrement the reference count for this object, and cleanup if the count 
    hits zero. Note that this method must be thread safe, and must not be
    able to fail. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
JOB_OBJECT::Dereference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedDecrement( &m_RefCount );

    // ref count should never go negative
    DBG_ASSERT( NewRefCount >= 0 );

    if ( NewRefCount == 0 )
    {
        // time to go away

        IF_DEBUG( WEB_ADMIN_SERVICE_REFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Reference count has hit zero in JOB_OBJECT instance, deleting (ptr: %p;)\n",
                this
                ));
        }


        delete this;


    }
    

    return;
    
}   // JOB_OBJECT::Dereference

/***************************************************************************++

Routine Description:

    Execute a work item on this object.

Arguments:

    pWorkItem - The work item to execute.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
JOB_OBJECT::ExecuteWorkItem(
    IN const WORK_ITEM * pWorkItem
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );
    DBG_ASSERT( GetWebAdminService()->IsBackwardCompatibilityEnabled() == FALSE );

    DBG_ASSERT( pWorkItem != NULL );


    IF_DEBUG( WEB_ADMIN_SERVICE_QOS )
    {
        CHKINFO((
            DBG_CONTEXT, 
            "Executing work item with serial number: %lu in JOB_OBJECT (ptr: %p) with operation: %p\n",
            pWorkItem->GetSerialNumber(),
            this,
            pWorkItem->GetOpCode()
            ));
    }


    switch ( pWorkItem->GetOpCode() )
    {

        case JobObjectHitLimitWorkItem:

            //
            // We only care about when the worker processes user mode processor time hits
            // the limit we set.  There are several other times that the job objects will 
            // answer back, but we can ignore them.
            //
            // It should also be noted that the job objects store their message id in the
            // size of bytes transferred through the completion port.
            //

            if ( pWorkItem->GetNumberOfBytesTransferred() == 
                                JOB_OBJECT_MSG_END_OF_JOB_TIME )
            {
                ProcessLimitHit();
            }

        break;

        case JobObjectResetTimerFiredWorkItem:
            ProcessTimerFire();
        break;

        case ReleaseWorkItemJobObjectWorkItem:
            ReleaseWorkItem();
        break;

        default:

            // invalid work item!
            DBG_ASSERT( FALSE );
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;
        
    }


    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Executing work item on JOB_OBJECT failed\n"
            ));

    }

    // Note: Reporting a failure here, will stop the w3svc.  We should
    // never report any failures that are not fatal.

    return hr;
    
}   // JOB_OBJECT::ExecuteWorkItem



/***************************************************************************++

Routine Description:

    Initialize the job object instance.

Arguments:

    pAppPool - will be refcounted by the app pool when it is passed in to the 
               job object.  will be released by the job object on terminate.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
JOB_OBJECT::Initialize(
    IN APP_POOL* pAppPool
    )
{
    HRESULT hr = S_OK;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );
    DBG_ASSERT ( pAppPool );

    if ( pAppPool == NULL )
    {
        return E_INVALIDARG;
    }

    // Grab the app pool and ref count it.
    m_pAppPool = pAppPool;
    m_pAppPool->Reference();

    DBG_ASSERT ( m_pWorkItem == NULL );
    hr = GetWebAdminService()->GetWorkQueue()->GetBlankWorkItem( &m_pWorkItem );
    if ( FAILED( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not create a work item for the job object\n"
            ));

        goto exit;
    }

    DBG_ASSERT ( m_pWorkItem );

    //
    // Setup the work dispatch pointer to point to the JOB_OBJECT
    // so we can handle any limits that are hit.
    //
    m_pWorkItem->SetWorkDispatchPointer(this);
    m_pWorkItem->SetOpCode( ( ULONG_PTR ) JobObjectHitLimitWorkItem );
    
    //
    // If shutdown happens before a callback comes in, we will 
    // never get a callback on this work item.
    //
    m_pWorkItem->MarkToNotAutoDelete();

    DBG_ASSERT ( m_hJobObject == NULL );

    m_hJobObject = CreateJobObject( NULL,   // use default security descriptor
                                    NULL ); // don't name the job object.

    if ( m_hJobObject == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating the job object for the app pool failed\n"
            ));

        // Issue, should we log an event and disable job objects?
        
        goto exit;
    }

    // since we are not naming the job object, we should never
    // get a job object that all ready exists.
    DBG_ASSERT ( GetLastError () != ERROR_ALREADY_EXISTS );

    hr = GetWebAdminService()->GetWorkQueue()->
         BindJobToCompletionPort ( m_hJobObject,
                                   m_pWorkItem->GetOverlapped());
    if ( FAILED ( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Binding the job object to the completion port failed\n"
            ));


        goto exit;
    }

    JOBOBJECT_END_OF_JOB_TIME_INFORMATION JobAction;
    
    JobAction.EndOfJobTimeAction = JOB_OBJECT_POST_AT_END_OF_JOB; 
    if ( !SetInformationJobObject( m_hJobObject, 
                                   JobObjectEndOfJobTimeInformation, 
                                   &JobAction,
                                   sizeof ( JobAction ) ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "setting the job action failed\n"
            ));
    
        goto exit;
    }

    m_State = DisabledJobObjectState;

exit:

    IF_DEBUG( WEB_ADMIN_SERVICE_QOS )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Initializing of the job object is returning %08x \n"
            "work_item %08x, job_object %08x\n",
            hr,
            m_pWorkItem ? m_pWorkItem : NULL,
            this
            ));
    }

    //
    // If we fail on any of the above pieces, the 
    // terminate routine will handle the cleanup.
    //
    // Need to verify that it will be called
    // and that the queueing to release the work
    // item will work.

    return hr;
    
}   // JOB_OBJECT::Initialize

/***************************************************************************++

Routine Description:

    Adds a worker process to the job object.

Arguments:

    hWorkerProcess = The worker process to add to the object.

Return Value:

    HRESULT

Note:  We don't remove worker processes from the job object because we assume
       that the worker process will be removed when it is shutdown.

--***************************************************************************/

HRESULT
JOB_OBJECT::AddWorkerProcess(
    IN HANDLE hWorkerProcess
    )
{
    HRESULT hr = S_OK;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );
    DBG_ASSERT ( hWorkerProcess );
    DBG_ASSERT ( m_hJobObject );

    if ( hWorkerProcess == NULL )
    {
        return E_INVALIDARG;
    }

    if ( !AssignProcessToJobObject( m_hJobObject, hWorkerProcess ) )
    {
        //
        // Issue:  If the wp exits to quickly this may fail because the
        //         worker process does not exist anymore.  In this case
        //         this is actually not a failure.
        //

        hr = HRESULT_FROM_WIN32( GetLastError() );
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Adding a worker process to the job object failed\n"
            ));
        
        goto exit;
    }

exit:

    IF_DEBUG( WEB_ADMIN_SERVICE_QOS )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Adding a worker process to the Job Object is returning %08x\n",
            hr
            ));
    }

    return hr;
    
}   // JOB_OBJECT::AddWorkerProcess


/***************************************************************************++

Routine Description:

    Terminates the job object

Arguments:

Return Value:

    VOID

--***************************************************************************/

VOID
JOB_OBJECT::Terminate(
    )
{
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT ( m_State != ShuttingDownJobObjectState );

    m_State = ShuttingDownJobObjectState;

    if ( m_pAppPool )
    {
        m_pAppPool->Dereference();
        m_pAppPool = NULL;
    }
    
    //
    // If we are in the middle of timing the job 
    // object we need to cancel the timer now.
    // After this point we know that the job object
    // will not be calling us back with the
    // work item we gave it.  However it could of 
    // put things in our queue before now that we have 
    // not processed, so once we have cancelled it 
    // we will queue a marker to let us know when we 
    // can safely release the work item associated 
    // with this job object.
    //
    CancelJobObjectTimer();

    if ( m_hJobObject ) 
    {
        CloseHandle( m_hJobObject );
        m_hJobObject = NULL;
    }

    //
    // Mark the queue so we know when we are guaranteed to not
    // get anymore completions for the work item we own.
    //
    // We ignore the hr value coming back here, there is nothing
    // we can do if we didn't queue this.
    //
    QueueWorkItemFromSecondaryThread( (WORK_DISPATCH*) this,
                                      ReleaseWorkItemJobObjectWorkItem );                                     


    IF_DEBUG( WEB_ADMIN_SERVICE_QOS )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Termination of the job object is complete.\n"
            ));
    }

    
}   // JOB_OBJECT::Terminate


/***************************************************************************++

Routine Description:

    Sets a set of configuration information for the job object as it 
    relates to the app pool that it belongs to.

Arguments:

    DWORD CpuResetInterval = The amount of time to monitor over.  If the limit
                             hits this value minues the amount of time that has passed
                             for this monitoring session equals the amount of time 
                             that we wait before resetting the monitoring and possibly
                             preforming the action again (assuming the action was not
                             recycling everything).

    DWORD CpuLimit = The amount of processor time the processes can use over the 
                     amount of time defined by the CpuResetInterval.

    DWORD CpuAction = The action to be performed when the limit is reached.

Return Value:

    HRESULT

--***************************************************************************/

VOID
JOB_OBJECT::SetConfiguration(
    IN DWORD CpuResetInterval,
    IN DWORD CpuLimit,
    IN DWORD CpuAction
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );
    //
    // Save the values away.
    //
    m_CpuResetInterval = CpuResetInterval;
    m_CpuLimit = CpuLimit;

    DBG_ASSERT ( CpuAction < NumberOfJobObjectActions ) ;

    m_CpuAction = ( JOB_OBJECT_ACTION ) CpuAction;

    UpdateJobObjectMonitoring( TRUE );

}   // JOB_OBJECT::SetConfiguration

/***************************************************************************++

Routine Description:

    Updates the job object with the current monitoring information.

Arguments:

    BOOL DoRestartIfNeccessary  - tells if we should restart the app pool if neccessary.

Return Value:

    VOID

--***************************************************************************/

VOID
JOB_OBJECT::UpdateJobObjectMonitoring(
    BOOL DoRestartIfNeccessary
    )
{
    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );
    DBG_ASSERT ( m_State != NotInitalizedJobObjectState && 
                 m_State != ShuttingDownJobObjectState );

    DBG_ASSERT ( m_pAppPool );

    //
    // Cancel the job object timer before updating 
    // the job object, because the update will start
    // another timer if need be.
    //
    CancelJobObjectTimer();

    // if we disabled the app pool during this last time limit
    // we need to enable the app pool now.  This means that if
    // the configuration changes on a job object that has fired
    // we will pick start the app pool back up when the config
    // changes
    if ( m_State == KillActionFiredJobObjectState && DoRestartIfNeccessary )
    {
        m_pAppPool->ProcessStateChangeCommand( MD_APPPOOL_COMMAND_START, 
                                                    FALSE,
                                                    HttpAppPoolEnabled );        
    }

    //
    // in case we don't set it to monitor.
    m_State = DisabledJobObjectState;

    // llJobLimit is in 100-nanoseconds.

    // CpuLimit is in 1/1000th percent (in other words divide CpuResetInterval by 100,000).
    // CpuResetInterval is in Minutes.
    //
    // The calculation:
    //
    // CpuResetInterval * CpuLimit / 100,000  gives you the amount of minutes of job time.
    // 
    // Now multiply that by:
    //        60 (to get it in seconds)
    //      1000 (to get in in milliseconds)
    //      1000 (to get it in microseconds)
    //      10 (to get in in 100-nanoseconds  (1000 nanoseconds / 100 nanoseconds)
    //
    //
    // All this simplifies out to CpuLimit * CpuResetInterval * 6000.
    //
    // Issue:  Are we looking at overflow problems??

    LONGLONG llJobLimit = m_CpuLimit * m_CpuResetInterval * 6000;

    JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;

    // If the properties are equal to zero then we will simply turn this puppy off
    // by not setting the job limit.

    SecureZeroMemory ( &BasicLimitInformation, sizeof ( BasicLimitInformation ) );

    //
    // If the Job Limit is set to zero then we still configure the server
    // because we need to tell it not to monitor the Job Time at all.  In 
    // other words we need to configure it to have LimitFlags = 0.
    //
    if ( llJobLimit > 0 )
    {
        BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_JOB_TIME;

        BasicLimitInformation.PerJobUserTimeLimit.QuadPart = llJobLimit;
    }

    if ( !SetInformationJobObject( m_hJobObject, 
                                   JobObjectBasicLimitInformation, 
                                   &BasicLimitInformation,
                                   sizeof ( BasicLimitInformation ) ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "setting the limit on the job object failed\n"
            ));
    
        const WCHAR * EventLogStrings[1];

        EventLogStrings[0] = m_pAppPool->GetAppPoolId();

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_JOB_OBJECT_UPDATE_FAILED,       // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                hr                                       // error code
                );

        // We don't want to flow this error anymore, otherwise we can end 
        // up shutting down the w3svc.
        hr = S_OK;

        goto exit;
    }


    //
    // If we did set a job limit then we need to start a timer
    //
    if ( llJobLimit > 0 )
    {
        m_State = RunningJobObjectState;

        hr = BeginJobObjectTimer();
        if ( FAILED ( hr ) )
        {
            // We are not timing the object, chances are the limit
            // will eventually get hit.

            // The BeginJobObjectTimer has all ready spewed the error.
            const WCHAR * EventLogStrings[1];

            EventLogStrings[0] = m_pAppPool->GetAppPoolId();

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_JOB_OBJECT_TIMER_START_FAILED,       // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    hr                                       // error code
                    );
            
            hr = S_OK;
            goto exit;

        }
    }


exit:

    IF_DEBUG( WEB_ADMIN_SERVICE_QOS )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Updating the job limit is returning %08x\n",
            hr
            ));
    }

}   // JOB_OBJECT::UpdateJobObjectMonitoring

/***************************************************************************++

Routine Description:

    Handles performing the appropriate action when a job object hits it's limit.
    This will also resetup monitoring if need be.

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/
VOID
JOB_OBJECT::ProcessLimitHit(
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    //
    // Make sure we don't attempt to log if we have all ready 
    // released the app pool.
    if ( m_State != RunningJobObjectState || m_pAppPool == NULL )
    {
        return;
    }

    m_State = HitConstraintJobObjectState;

    const WCHAR * EventLogStrings[1];

    EventLogStrings[0] = m_pAppPool->GetAppPoolId();

    GetWebAdminService()->GetEventLog()->
        LogEvent(
            WAS_EVENT_JOB_LIMIT_HIT,       // message id
            sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                    // count of strings
            EventLogStrings,                        // array of strings
            0                                       // error code
            );

    if ( m_CpuAction == KillJobObjectAction )
    {
        m_State = KillActionFiredJobObjectState;

        m_pAppPool->ProcessStateChangeCommand( MD_APPPOOL_COMMAND_STOP,
                                                            FALSE,
                                                            HttpAppPoolDisabled_JobObjectFired );
    }

}

/***************************************************************************++

Routine Description:

    Handles the resetting the job object monitoring since the amount
    of time to monitor over has been hit.

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/
VOID
JOB_OBJECT::ProcessTimerFire(
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    if ( m_State != ShuttingDownJobObjectState )
    {
        //
        // Tell the job object about the limit again to refresh it.
        //

        UpdateJobObjectMonitoring( TRUE );
    }    
}

/***************************************************************************++

Routine Description:

    Lets go of the work item we are holding for the life of this object.

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/
VOID
JOB_OBJECT::ReleaseWorkItem(
    )
{
    WORK_ITEM* pTemp = m_pWorkItem;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );
    DBG_ASSERT ( ShuttingDownJobObjectState == m_State );

    //
    // If we have a work item we can safely release it now
    // because we have verified that the job object will not
    // be using it.
    //
    // The work item may hold the last refernce on the job object
    // so be ready for the job object to go away.
    //
    m_pWorkItem = NULL;
    m_State = NotInitalizedJobObjectState;

    if ( pTemp ) 
    {
        GetWebAdminService()->GetWorkQueue()->FreeWorkItem( pTemp );
    }

}

/***************************************************************************++

Routine Description:

    Start a timer to monitor the length of time the job object has to monitor
    before the limit should be reset.

Arguments:

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
JOB_OBJECT::BeginJobObjectTimer(
    )
{

    HRESULT hr = S_OK;
    NTSTATUS Status = STATUS_SUCCESS;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( GetWebAdminService()->GetSharedTimerQueue() != NULL );

    DBG_ASSERT( m_JobObjectTimerHandle == NULL );

    IF_DEBUG( WEB_ADMIN_SERVICE_QOS )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Beginning job object timer\n"
            ));
    }

    Status = RtlCreateTimer(
                    GetWebAdminService()->GetSharedTimerQueue(),
                                                                        // timer queue
                    &m_JobObjectTimerHandle,                            // returned timer handle
                    JobObjectTimerCallback,                             // callback function
                    this,                                               // context
                    m_CpuResetInterval * ONE_MINUTE_IN_MILLISECONDS,    // initial firing time
                    0,                                      // subsequent firing period
                    WT_EXECUTEINWAITTHREAD                  // execute callback directly
                    );

    if ( ! NT_SUCCESS ( Status ) )
    {
        hr = HRESULT_FROM_NT( Status );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not create job object timer\n"
            ));

    }

    return hr;

}   // JOB_OBJECT::BeginJobObjectTimer


/***************************************************************************++

Routine Description:

    Stop the job object timer, if present

Arguments:

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
JOB_OBJECT::CancelJobObjectTimer(
    )
{

    HRESULT hr = S_OK;
    NTSTATUS Status = STATUS_SUCCESS;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );
    DBG_ASSERT( GetWebAdminService()->GetSharedTimerQueue() != NULL );


    //
    // If the timer is not present, we're done here.
    //

    if ( m_JobObjectTimerHandle == NULL )
    {
        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Cancelling job object timer\n"
            ));
    }


    //
    // Note that we wait for any running timer callbacks to finish.
    //

    Status = RtlDeleteTimer(
                    GetWebAdminService()->GetSharedTimerQueue(),
                                                          // the owning timer queue
                    m_JobObjectTimerHandle,             // timer to cancel
                    INVALID_HANDLE_VALUE                  // wait for callbacks to finish
                    );

    if ( ! NT_SUCCESS ( Status ) )
    {
        hr = HRESULT_FROM_NT( Status );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not cancel job object timer\n"
            ));

        goto exit;
    }

    m_JobObjectTimerHandle = NULL;


exit:

    return hr;

}   // JOB_OBJECT::CancelJobObjectTimer

/***************************************************************************++

Routine Description:

    The callback function let's us know when the reset interval 
    for the job limit has been exceeded.  Whether or not we have 
    hit the limit, we need to reset the job object.

Arguments:

    Context - A context value, used to pass the "this" pointer of the
    JOB_OBJECT object.

    Ignored - Ignored.

Return Value:

    None.

--***************************************************************************/

VOID
JobObjectTimerCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    )
{

    UNREFERENCED_PARAMETER( Ignored );

    DBG_ASSERT ( Context != NULL );

    JOB_OBJECT* pJobObject = reinterpret_cast<JOB_OBJECT*>( Context );

    UNREFERENCED_PARAMETER( pJobObject );
    DBG_ASSERT ( pJobObject->CheckSignature() );

    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "About to create/queue work item for Job "
            "Object limit to be reset (ptr: %p)\n",
            pJobObject
            ));
    }

    //
    // We ignore the hr value coming back here, there is nothing
    // we can do if we didn't queue this.
    //

    QueueWorkItemFromSecondaryThread(
        reinterpret_cast<WORK_DISPATCH*>( Context ),
        JobObjectResetTimerFiredWorkItem
        );


    return;

}   // JobObjectTimerCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\datastore.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    datastore.cxx

Abstract:

    Base class for handling metabase data

Author:

    Emily Kruglick (EmilyK)          27-May-2001

Revision History:

--*/

#include "precomp.h"

VOID
DATA_OBJECT_TABLE::PerformSelfValidation(
    )
/*++

Routine Description:

    Walk this table and validate all the data
    in the table.

Arguments:

    NULL

Return Value:

    VOID

--*/
{

    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;
 
    CountOfElementsInTable = Size();

    //
    // Note that for good form we grab the write lock since we will be 
    // modifying objects in the table (although no other thread should 
    // touch this data structure anyways).
    //
    SuccessCount = Apply( 
                        ValidateObjectAction,
                        NULL,
                        LKL_WRITELOCK
                        );
    
    DBG_ASSERT( SuccessCount == CountOfElementsInTable );
    
}

HRESULT
DATA_OBJECT_TABLE::CopyInteresting(
    DATA_OBJECT_TABLE *     pDestinationTable
)
/*++

Routine Description:

    Copy interesting (non-ignorred) rows to destination table

Arguments:

    pDestinationTable - Table to receive interesting rows

Return Value:

    HRESULT

--*/
{
    DATA_OBJECT *           pDataObject;
    DATA_OBJECT *           pCloneObject;
    LK_RETCODE              lkrc;
    
    if ( pDestinationTable == NULL )
    {

        DBG_ASSERT ( pDestinationTable != NULL );
        
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    for ( DATA_OBJECT_TABLE::iterator iter = begin();
          iter != end();
          ++iter )
    {
        pDataObject = iter.Record();
        DBG_ASSERT( pDataObject != NULL );
        DBG_ASSERT( pDataObject->CheckSignature() );
        
        //
        // If it is ignored, then don't copy
        //
        
        if ( !pDataObject->QueryDoesWasCareAboutObject() )
        {
            continue;
        }

        pCloneObject = pDataObject->Clone();
        if ( pCloneObject == NULL )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }        
        
        lkrc = pDestinationTable->InsertRecord( pCloneObject );
        if ( lkrc != LK_SUCCESS )
        {
            pCloneObject->DereferenceDataObject();
            return HRESULT_FROM_WIN32( lkrc );
        }
        
        pCloneObject->DereferenceDataObject();
    }
    
    return NO_ERROR;
}

HRESULT
DATA_OBJECT_TABLE::DeclareDeletions(
    DATA_OBJECT_TABLE* pMasterObjectTable
    )
/*++++
Routine Description:

    Routine looks through the master table finding any records that
    do not exist in the table it owns.  If it finds one that does not
    exist it will insert a deletion in it's table.

Arguments:

    DATA_OBJECT_TABLE* pMasterObjectTable

Return Value:

    HRESULT
+++*/

{
    DATA_OBJECT *           pObjectToSeeIfItExists = NULL;
    DATA_OBJECT *           pObjectFoundInNewTable = NULL;
    DATA_OBJECT *           pCloneObject = NULL;
    LK_RETCODE              lkrc;
    
    if ( pMasterObjectTable == NULL )
    {
        DBG_ASSERT ( pMasterObjectTable != NULL );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
        
    //
    // Now find all the deleted entries by iterating the safe table and 
    // checking whether entry exists in new table
    //

    for ( DATA_OBJECT_TABLE::iterator delIter = pMasterObjectTable->begin();
          delIter != pMasterObjectTable->end();
          ++delIter )
    {
        pObjectToSeeIfItExists = delIter.Record();
        DBG_ASSERT( pObjectToSeeIfItExists != NULL );
        DBG_ASSERT( pObjectToSeeIfItExists->CheckSignature() );
        
        lkrc = FindKey( pObjectToSeeIfItExists->QueryKey(),
                                   &pObjectFoundInNewTable );
        if ( lkrc == LK_SUCCESS )
        {
            // it exists, if this is the case then we 
            // don't really need to do anything.

            // if we have experienced a failure in the metabase, then
            // we may have to re-write this objects state to the 
            // metabase, so once again this object is responsible for
            // writing it's state, unless the object is in WAS.

            if ( !pObjectToSeeIfItExists->QueryInWas() )
            {
                pObjectToSeeIfItExists->SetIsResponsibleForErrorReporting( TRUE );
            }
            
            DBG_ASSERT( pObjectFoundInNewTable != NULL );
            
            pObjectFoundInNewTable->DereferenceDataObject();
        }
        else
        {
            // assume that we just didn't find it.
            DBG_ASSERT( lkrc == LK_NO_SUCH_KEY );
            
            pCloneObject = pObjectToSeeIfItExists->Clone();
            if ( pCloneObject == NULL )
            {
                return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            }
            
            pCloneObject->SetDeleteWhenDone( TRUE );
            
            lkrc = InsertRecord( pCloneObject );
            
            pCloneObject->DereferenceDataObject();
            pCloneObject = NULL;
            
            if ( lkrc != LK_SUCCESS )
            {
                return HRESULT_FROM_WIN32( lkrc );
            }
        }
    }
    
    return S_OK;
}


HRESULT
DATA_OBJECT_TABLE::MergeTable(
    DATA_OBJECT_TABLE *         pMergeTable
)
/*++

Routine Description:

    Merge the given table into this table

Arguments:

    pMergeTable - Table to merge in

Return Value:

    HRESULT

--*/
{
    DATA_OBJECT *               pIterObject = NULL;
    DATA_OBJECT *               pFoundObject = NULL;
    LK_RETCODE                  lkrc;
    HRESULT                     hr = S_OK;
    
    if ( pMergeTable == NULL )
    {
        DBG_ASSERT ( pMergeTable != NULL );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Iterate thru all the merge table entries
    //
    
    for ( DATA_OBJECT_TABLE::iterator iter = pMergeTable->begin();
          iter != pMergeTable->end();
          ++iter )
    {
        pIterObject = (DATA_OBJECT*) iter.Record();
        
        DBG_ASSERT( pIterObject->CheckSignature() );
        
        //
        // Find the object in this table
        //
        DBG_ASSERT( pFoundObject == NULL );
        
        lkrc = FindKey( pIterObject->QueryKey(),
                        ( DATA_OBJECT** )&pFoundObject );
        if ( lkrc != LK_SUCCESS )
        {
            // it is not a real error if we did not find the record
            if ( lkrc != LK_NO_SUCH_KEY )
            {
                DBG_ASSERT( lkrc == LK_NO_SUCH_KEY );
                hr = HRESULT_FROM_WIN32( lkrc );
                goto exit;
            }

            //
            // If we couldn't find the object, and it was not a delete, then
            // add the object
            //

            if ( !pIterObject->QueryDeleteWhenDone() )
            {
                lkrc = InsertRecord( pIterObject );
                if ( lkrc != LK_SUCCESS )
                {
                    DBG_ASSERT( lkrc == LK_SUCCESS );
                    hr = HRESULT_FROM_WIN32( lkrc );
                    goto exit;
                }
            }
            else
            {
                //
                // We wanted to delete, and it is already gone.  That should
                // be OK.
                //
            }
        }
        else
        {

            DBG_ASSERT( pFoundObject != NULL );

            pIterObject->SetInWas( pFoundObject->QueryInWas() );
                       
            pIterObject->Compare( pFoundObject );
           
            lkrc = InsertRecord( pIterObject, true );
            if ( lkrc != LK_SUCCESS )
            {
                DBG_ASSERT( lkrc == LK_SUCCESS );
                hr = HRESULT_FROM_WIN32( lkrc );
                goto exit;
            }
        }

        if ( pFoundObject )
        {
            pFoundObject->DereferenceDataObject();
            pFoundObject = NULL;
        }

    }  // end of loop

exit:

    if ( pFoundObject )
    {
        pFoundObject->DereferenceDataObject();
        pFoundObject = NULL;
    }
    
    return NO_ERROR;
}

// note: static!
LK_ACTION
DATA_OBJECT_TABLE::ValidateObjectAction(
    IN DATA_OBJECT* pObject, 
    IN LPVOID pIgnored
    )
/*++

Routine Description:

    Asks each object to validate itself.

Arguments:

    IN DATA_OBJECT* pObject, 
    IN LPVOID pUnused

Return Value:

    LK_ACTION

--*/
{
    UNREFERENCED_PARAMETER( pIgnored );
    DBG_ASSERT( pObject != NULL );

    DATA_OBJECT* pDataObject = (DATA_OBJECT*) pObject;

    DBG_ASSERT(pDataObject->CheckSignature());

    pDataObject->SelfValidate();

    return LKA_SUCCEEDED;
}  

//static
LK_ACTION
DATA_OBJECT_TABLE::DumpObjectAction(
    IN DATA_OBJECT* pObject, 
    IN LPVOID pIgnored
    )
/*++

Routine Description:

    Asks each object to validate itself.

Arguments:

    IN DATA_OBJECT* pObject, 
    IN LPVOID pUnused

Return Value:

    LK_ACTION

--*/
{
    DBG_ASSERT( pObject != NULL );
    DBG_ASSERT( pObject->CheckSignature() );

    UNREFERENCED_PARAMETER( pIgnored );

    pObject->Dump();
    
    return LKA_SUCCEEDED;
}  

//static
LK_PREDICATE
DATA_OBJECT_TABLE::DeletePredicate(
    IN DATA_OBJECT *        pDataObject,
    VOID *                  pvState
)
/*++

Routine Description:

    Predicate to delete marked-for-deleted objects

Arguments:

    pDataObject - Data object to check for deletion
    pvState - Unused

Return Value:

    LKP_PERFORM - do the delete,
    LKP_NO_ACTION - do nothing

--*/
{
    UNREFERENCED_PARAMETER ( pvState );
    
    DBG_ASSERT( pDataObject != NULL );
    DBG_ASSERT( pDataObject->CheckSignature() );
    
    if ( pDataObject->QueryDeleteWhenDone() == TRUE ||
         pDataObject->QueryInMetabase() == FALSE )
    {
        return LKP_PERFORM;
    }
    else
    {
        // report errors back to the metabase on
        // objects that did not make it to was.
        if ( pDataObject->QueryIsResponsibleForErrorReporting() &&
             !pDataObject->QueryDeleteWhenDone() &&
             ( !pDataObject->QuerySelfValid() ||
               !pDataObject->QueryCrossValid() ) )
        {
            pDataObject->UpdateMetabaseWithErrorState();
        }

        //
        // Do other finishing steps
        //
        
        if ( pDataObject->QueryWillWasKnowAboutObject() )
        {
            // Mark that WAS knows about the object
            pDataObject->SetInWas( TRUE );

            // reset all the changed fields to show that
            // nothing has changed.
            pDataObject->ResetChangedFields( FALSE );
        }
        else
        {
            // Mark that WAS does not know about this object
            pDataObject->SetInWas( FALSE );

            // Mark all the change properties as changed so that
            // the next time this object becomes valid all the
            // data is looked at by WAS.  Note that I thought about
            // optimizing this to only reset when we switched from
            // being in WAS to not being in WAS, but we might leave 
            // in a ServerCommand setting from a previous change
            // that was ignored.
            pDataObject->ResetChangedFields( TRUE );

        }

        //
        // Get these ready for the next time around.
        //
        pDataObject->SetSelfValid( TRUE );
        pDataObject->SetCrossValid( TRUE );

        // return no action so we don't delete this record.
        
        return LKP_NO_ACTION;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\job_object.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    job_object.h

Abstract:

    The IIS web admin service job object class definition.

Author:

    Emily Kruglick (emilyk)        30-Nov-2000

Revision History:

--*/


#ifndef _JOB_OBJECT_H_
#define _JOB_OBJECT_H_



//
// forward references
//




//
// common #defines
//

#define JOB_OBJECT_SIGNATURE       CREATE_SIGNATURE( 'JOBO' )
#define JOB_OBJECT_SIGNATURE_FREED CREATE_SIGNATURE( 'jobX' )


//
// structs, enums, etc.
//


// job object states
enum JOB_OBJECT_STATE
{

    //
    // The object is not yet initialized or
    // it was in use but has been shutdown.
    //
    NotInitalizedJobObjectState = 0,

    //
    // The job object exists but we are not currently
    // using it.
    DisabledJobObjectState,

    //
    // The job object is running (waiting for a problem)
    //
    RunningJobObjectState,

    //
    // The job object hit the time constraint.
    //
    HitConstraintJobObjectState,

    //
    // Hit the contraint and disabled
    KillActionFiredJobObjectState,

    //
    // Job object is in the middle of shutting down
    ShuttingDownJobObjectState,



};

// JOB_OBJECT work items
enum JOB_OBJECT_WORK_ITEM
{

    //
    // Hit the limit and need to do the 
    // appropriate action.
    //
    JobObjectHitLimitWorkItem = 1,

    //
    // Timer fired, time to reset the 
    // job object.
    //
    JobObjectResetTimerFiredWorkItem,

    //
    // It is ok to release the work item
    // for this job object.
    ReleaseWorkItemJobObjectWorkItem 
    
};

// job object actions
enum JOB_OBJECT_ACTION
{

    //
    // Just log
    LogJobObjectAction = 0,

    //
    // Log & Shutdown the app pool
    KillJobObjectAction,

    //
    // Max and invalid action
    NumberOfJobObjectActions

/*
    // We currently do not support
    // these items.  We may need before
    // we ship, so I am leaving them here
    // but commented out.
    //
    // Log & Turn on tracing
    TraceJobObjectAction,

    //
    // Log & throttle back the processes
    ThrottleJobObjectAction
*/

};

//
// prototypes
//

class JOB_OBJECT
    : public WORK_DISPATCH
{

public:

    JOB_OBJECT(
        );

    virtual
    ~JOB_OBJECT(
        );

    virtual
    VOID
    Reference(
        );

    virtual
    VOID
    Dereference(
        );

    virtual
    HRESULT
    ExecuteWorkItem(
        IN const WORK_ITEM * pWorkItem
        );

    HRESULT
    Initialize(
        IN APP_POOL* pAppPool
        );

    VOID
    Terminate(
        );

    VOID
    SetConfiguration(
        DWORD CpuResetInterval,
        DWORD CpuLimit,
        DWORD CpuAction
        );

    HRESULT
    AddWorkerProcess(
        IN HANDLE hWorkerProcess
        );

    BOOL
    CheckSignature(
        )
    { 
        return ( m_Signature == JOB_OBJECT_SIGNATURE ); 
    }

    VOID
    UpdateJobObjectMonitoring(
        BOOL DoRestartIfNeccessary
        );

private:

    VOID
    ProcessLimitHit(
        );

    VOID
    ProcessTimerFire(
        );

    VOID
    ReleaseWorkItem(
        );

    HRESULT
    BeginJobObjectTimer(
        );

    HRESULT
    CancelJobObjectTimer(
        );

    DWORD m_Signature;

    LONG m_RefCount;

    JOB_OBJECT_STATE m_State;

    //
    // Parent application pool to use
    // to perform any necessary actions in
    // the case that the limit is hit.
    //
    APP_POOL* m_pAppPool;

    //
    // The amount of time to monitor over.  If the limit
    // hits this value minues the amount of time that has passed
    // for this monitoring session equals the amount of time 
    // that we wait before resetting the monitoring and possibly
    // preforming the action again (assuming the action was not
    // recycling everything).
    //
    DWORD m_CpuResetInterval;

    //
    // The amount of processor time the processes can use over the 
    // amount of time defined by the CpuResetInterval.
    // 
    DWORD m_CpuLimit;

    // 
    // The action to be performed when the limit is reached.
    // 
    JOB_OBJECT_ACTION m_CpuAction;

    //
    // The job object that this class uses to be notified when
    // limits are hit.
    //
    HANDLE m_hJobObject;

    //
    // The handle for the Job Object timer.
    //
    HANDLE m_JobObjectTimerHandle;

    //
    // Work item for job object call backs.
    //
    WORK_ITEM* m_pWorkItem; 


};  // class JOB_OBJECT



#endif  // _JOB_OBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\main.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    main.cxx

Abstract:

    Main service entry points for for the IIS web admin service.

Author:

    Seth Pollack (sethp)        22-Jul-1998

Revision History:

--*/



#include "precomp.h"



//
// global variables
//


// debug support
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();


//
// Global pointer to the service object. Should not be used directly
// outside of this file; use GetWebAdminService() instead.
//

WEB_ADMIN_SERVICE *g_pWebAdminService = NULL;

BOOL g_RegisterServiceCalled = FALSE;


//
// Function only exists so we can tell SCM that 
// we are stopped if we did not succeed in starting.
//
VOID
FakeServiceControlHandler(
    IN DWORD 
    )
{
}

/***************************************************************************++

Routine Description:

    The dll entry point. Used to set up debug libraries, etc.

Arguments:

    DllHandle - The dll module handle for this dll. Does not need to be
    closed.

    Reason - The dll notification reason.

    pReserved - Reserved, not used.

Return Value:

    BOOL

--***************************************************************************/

extern "C"
BOOL
WINAPI
DllMain(
    HINSTANCE DllHandle,
    DWORD Reason,
    LPVOID pReserved
    )
{

    BOOL Success = TRUE;
    HRESULT hr = S_OK;


    UNREFERENCED_PARAMETER( pReserved );


    switch ( Reason )
    {

    case DLL_PROCESS_ATTACH:



        CREATE_DEBUG_PRINT_OBJECT( WEB_ADMIN_SERVICE_NAME_A );

#if DBG
        LOAD_DEBUG_FLAGS_FROM_REG_STR( REGISTRY_KEY_W3SVC_PARAMETERS_A, DEBUG_FLAG_ERROR );
#else // DBG
        LOAD_DEBUG_FLAGS_FROM_REG_STR( REGISTRY_KEY_W3SVC_PARAMETERS_A, 0 );
#endif // DBG

        DBG_OPEN_MEMORY_LOG();

        Success = VALID_DEBUG_PRINT_OBJECT();

        if ( ! Success )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Debug print object is not valid\n"
                ));

            goto exit;
        }


        Success = DisableThreadLibraryCalls( DllHandle );

        if ( ! Success )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Disabling thread library calls failed\n"
                ));

            goto exit;
        }

        break;

    case DLL_PROCESS_DETACH:

        //
        // If this DLL is being invoked because of REGSVR32, then we will
        // not have created the service.
        //

        if ( g_pWebAdminService != NULL )
        {
            //
            // We are now completely done with service execution.
            //

            g_pWebAdminService->Dereference();

            g_pWebAdminService = NULL;
        }

        DELETE_DEBUG_PRINT_OBJECT();

        break;

    default:

        break;

    }


exit:

    return Success;

}   // DllMain

/***************************************************************************++

Routine Description:

    This function conforms to the LPTHREAD_START_ROUTINE prototype.

    This function is called on a separate thread created by ServiceMain.
    We take this thread and make it into our "main worker thread" for service
    execution.

Arguments:

        lpParameter - Not used, should be NULL.

Return Value:

        Win32 error.  Does not return until service is stopped.

--***************************************************************************/

DWORD WINAPI
WASServiceThreadProc(
    LPVOID              /*lpParameter*/
    )
{
    HRESULT             hr = S_OK;
    DWORD               dwError = ERROR_SUCCESS;

    //
    // Ensure that on service re-start we are truly re-initialized.
    //

    DBG_ASSERT( g_pWebAdminService == NULL );

    g_pWebAdminService = new WEB_ADMIN_SERVICE;
    if ( g_pWebAdminService == NULL )
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        hr = HRESULT_FROM_WIN32( dwError );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Allocating WEB_ADMIN_SERVICE failed\n"
            ));

        //
        // Error handling note: If we were not able to even create the web
        // admin service object, we are dead in the water. The SCM will
        // eventually time out and clean up.
        //

        goto exit;
    }

    g_pWebAdminService->ExecuteService();

exit:
    return dwError;

}   // WASServiceThreadProc


/***************************************************************************++

Routine Description:

    The main entry point called by svchost, the service hosting exe. This
    function conforms to the LPSERVICE_MAIN_FUNCTIONW prototype.

    This function is called on a thread spun for us by the service controller.
    We take this thread and make it into our "main worker thread" for service
    execution.

Arguments:

    ArgumentCount - Count of command line arguments.

    ArgumentValues - Array of command line argument strings.

Return Value:

    None.

--***************************************************************************/

VOID
ServiceMain(
    IN DWORD ArgumentCount,
    IN LPWSTR * ArgumentValues
    )
{
	// Locals
	HRESULT				hr = S_OK;
	DWORD				dwError = ERROR_SUCCESS;
	HANDLE				hThread = NULL;
	DWORD				dwThreadId = 0;

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "ServiceMain entrypoint called\n"
            ));
    }


    //
    // We're not expecting any command line arguments besides the
    // service name.
    //

    DBG_ASSERT( ArgumentCount == 1 );
    DBG_ASSERT( ArgumentValues != NULL );
    DBG_ASSERT( _wcsicmp( ArgumentValues[0], WEB_ADMIN_SERVICE_NAME_W ) == 0 );

    UNREFERENCED_PARAMETER ( ArgumentCount );
    UNREFERENCED_PARAMETER ( ArgumentValues );

    // Create a separate thread
    hThread = CreateThread( NULL,
                            // Big initial size to prevent stack overflows
                            IIS_DEFAULT_INITIAL_STACK_SIZE,
                            WASServiceThreadProc,
                            NULL,
                            0,
                            &dwThreadId);

    // If failed
	if ( hThread == NULL )
	{
		// Get the error
		dwError = GetLastError();

		// Convert it to HRESULT
		hr = HRESULT_FROM_WIN32( dwError );
        DPERROR((
            DBG_CONTEXT,
            hr,
            "CreateThread() failed\n"
            ));

		goto exit;
	}

    // Wait for the service shutdown
	if ( WaitForSingleObject( hThread, INFINITE ) == WAIT_FAILED )
	{
		// Get the error
		dwError = GetLastError();

		// Convert it to HRESULT
		hr = HRESULT_FROM_WIN32( dwError );
        DPERROR((
            DBG_CONTEXT,
            hr,
            "WaitForSingleObject() failed\n"
            ));

		goto exit;
	}


    // Get the exit code
	if ( !GetExitCodeThread( hThread, &dwError ) )
	{
		// Get the error
		dwError = GetLastError();

		// Convert it to HRESULT
		hr = HRESULT_FROM_WIN32( dwError );
        DPERROR((
            DBG_CONTEXT,
            hr,
            "GetExitCodeThread() failed\n"
            ));

		goto exit;
	}

    DBG_ASSERT( dwError != STILL_ACTIVE );

    // If WASServiceThreadProc failed
	if ( dwError != ERROR_SUCCESS )
	{
		// Convert it to HRESULT
		hr = HRESULT_FROM_WIN32( dwError );
        DPERROR((
            DBG_CONTEXT,
            hr,
            "WASServiceThreadProc() failed\n"
            ));
	}

exit:
	if ( hThread != NULL )
	{
	    // Close the handle
		CloseHandle( hThread );
	}

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Service exiting\n"
            ));
    }

    if ( !g_RegisterServiceCalled )
    {
        SERVICE_STATUS_HANDLE hServiceStatusHandle = NULL_SERVICE_STATUS_HANDLE;
        SERVICE_STATUS ServiceStatus;

        hServiceStatusHandle = RegisterServiceCtrlHandler(
                                    WEB_ADMIN_SERVICE_NAME_W,   // service name
                                    FakeServiceControlHandler       // handler function
                                    );

        if ( hServiceStatusHandle != NULL_SERVICE_STATUS_HANDLE )
        {
            ServiceStatus.dwServiceType             = SERVICE_WIN32_SHARE_PROCESS;
            ServiceStatus.dwControlsAccepted        = SERVICE_ACCEPT_STOP
                                                      | SERVICE_ACCEPT_PAUSE_CONTINUE
                                                      | SERVICE_ACCEPT_SHUTDOWN;

            ServiceStatus.dwCurrentState = SERVICE_STOPPED;
            ServiceStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
            ServiceStatus.dwServiceSpecificExitCode = (DWORD) E_FAIL;
            ServiceStatus.dwCheckPoint = 0;
            ServiceStatus.dwWaitHint = 0;

            //
            // We hope this works, but if not there isn't much
            // else that we really are going to do, so we don't
            // check the error handle.
            //

            SetServiceStatus(
                            hServiceStatusHandle, 
                            &ServiceStatus
                            );


            // Services Handle does not need to be closed per MSDN.
        }
    }

    return;

}   // ServiceMain



/***************************************************************************++

Routine Description:

    Return the global web admin service instance. May be called by any thread.

Arguments:

    None.

Return Value:

    The global web admin service instance.

--***************************************************************************/

WEB_ADMIN_SERVICE *
GetWebAdminService(
    )
{

    DBG_ASSERT( g_pWebAdminService != NULL );

    return g_pWebAdminService;

}   // GetWebAdminService
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\mb_change_item.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    mb_change_item.cxx

Abstract:

    This class handles capturing a change sent by the metabase
    and queuing that change to be handled on the config thread.

Author:

    Emily Kruglick (emilyk)        28-May-2001

Revision History:

--*/



#include  "precomp.h"



/***************************************************************************++

Routine Description:

    Constructor for the MB_CHANGE_ITEM class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

MB_CHANGE_ITEM::MB_CHANGE_ITEM(
    )
{


    //
    // Set the initial reference count to 1, in order to represent the
    // reference owned by the creator of this instance.
    //

    m_RefCount = 1;

    m_pcoChangeList = NULL;

    m_dwMDNumElements = 0;

    m_Signature = MB_CHANGE_ITEM_SIGNATURE;

}   // MB_CHANGE_ITEM::MB_CHANGE_ITEM



/***************************************************************************++

Routine Description:

    Destructor for the MB_CHANGE_ITEM class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

MB_CHANGE_ITEM::~MB_CHANGE_ITEM(
    )
{

    ULONG i = 0;

    DBG_ASSERT( m_RefCount == 0 );
    DBG_ASSERT( m_Signature == MB_CHANGE_ITEM_SIGNATURE );

    m_Signature = MB_CHANGE_ITEM_SIGNATURE_FREED;

    if ( m_pcoChangeList )
    {
        for ( i = 0; i < m_dwMDNumElements; i++ )
        {
            if ( m_pcoChangeList[i].pszMDPath )
            {
                DBG_REQUIRE( GlobalFree( m_pcoChangeList[i].pszMDPath ) == NULL );
                m_pcoChangeList[i].pszMDPath = NULL;
            }

            if ( m_pcoChangeList[i].pdwMDDataIDs )
            {
                DBG_REQUIRE( GlobalFree( m_pcoChangeList[i].pdwMDDataIDs ) == NULL );
                m_pcoChangeList[i].pdwMDDataIDs = NULL;
            }
        }

        DBG_REQUIRE( GlobalFree( m_pcoChangeList ) == NULL );
        m_pcoChangeList = NULL;
    }

}   // MB_CHANGE_ITEM::~MB_CHANGE_ITEM



/***************************************************************************++

Routine Description:

    Increment the reference count for this object. Note that this method must
    be thread safe, and must not be able to fail.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
MB_CHANGE_ITEM::Reference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedIncrement( &m_RefCount );

    //
    // The reference count should never have been less than zero; and
    // furthermore once it has hit zero it should never bounce back up;
    // given these conditions, it better be greater than one now.
    //
    
    DBG_ASSERT( NewRefCount > 1 );


    return;

}   // MB_CHANGE_ITEM::Reference



/***************************************************************************++

Routine Description:

    Decrement the reference count for this object, and cleanup if the count
    hits zero. Note that this method must be thread safe, and must not be
    able to fail.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
MB_CHANGE_ITEM::Dereference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedDecrement( &m_RefCount );

    // ref count should never go negative
    DBG_ASSERT( NewRefCount >= 0 );

    if ( NewRefCount == 0 )
    {
        // time to go away

        IF_DEBUG( WEB_ADMIN_SERVICE_REFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Reference count has hit zero in MB_CHANGE_ITEM instance, deleting (ptr: %p)\n",
                this
                ));
        }


        delete this;


    }


    return;

}   // MB_CHANGE_ITEM::Dereference



/***************************************************************************++

Routine Description:

    Execute a work item on this object.

Arguments:

    pWorkItem - The work item to execute.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
MB_CHANGE_ITEM::ExecuteWorkItem(
    IN const WORK_ITEM * pWorkItem
    )
{

    HRESULT hr = S_OK;

    // This routine can be run on the config thread or the main thread.
    // It will be run on the main thread during shutdown.

    DBG_ASSERT( pWorkItem != NULL );

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        CHKINFO((
            DBG_CONTEXT,
            "Executing work item with serial number: %lu in MB_CHANGE_ITEM (ptr: %p) with operation: %p\n",
            pWorkItem->GetSerialNumber(),
            this,
            pWorkItem->GetOpCode()
            ));
    }


    switch ( pWorkItem->GetOpCode() )
    {

        case ProcessMBChangeItemWorkItem:

            GetWebAdminService()->GetConfigAndControlManager()->GetConfigManager()->
                    ProcessMetabaseChangeOnConfigThread( this );

        break;

        default:

            // invalid work item!
            DBG_ASSERT( FALSE );

            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;

    }

    return hr;

}   // MB_CHANGE_ITEM::ExecuteWorkItem



/***************************************************************************++

Routine Description:

    Initialize this instance. 

Arguments:

    IN DWORD               dwMDNumElements = number of elements changing
    IN MD_CHANGE_OBJECT    pcoChangeList[] = change list for those elements

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
MB_CHANGE_ITEM::Initialize(
    IN DWORD               dwMDNumElements,
    IN MD_CHANGE_OBJECT    pcoChangeList[]
    )
{

    HRESULT hr = S_OK;
    ULONG i = 0;

    DBG_ASSERT( dwMDNumElements > 0 );
    DBG_ASSERT( pcoChangeList != NULL );

    DBG_ASSERT ( m_pcoChangeList == NULL );
    DBG_ASSERT ( m_dwMDNumElements == 0 );

    m_pcoChangeList = ( MD_CHANGE_OBJECT* )GlobalAlloc( 
                      GMEM_FIXED, ( sizeof( MD_CHANGE_OBJECT ) 
                                     * dwMDNumElements ) );

    if ( m_pcoChangeList == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating memory failed\n"
            ));

        goto exit;
    }
    
    // memory allocated based on size of memory sent in.
    // there is an assumption here that the number of elements
    // is not a lie.
    memcpy ( m_pcoChangeList, pcoChangeList, sizeof( MD_CHANGE_OBJECT ) 
                                             * dwMDNumElements );

    // 
    // Before we do anything that could fail, go through and NULL
    // the pointers we just copied so we don't end up possibly leaving them 
    // set to some invalid memory.
    //
    for ( i = 0; i < dwMDNumElements; i++ )
    {
        m_pcoChangeList[i].pszMDPath = NULL;
        m_pcoChangeList[i].pdwMDDataIDs = NULL;
    }

    //
    // Walk the ChangeList object copying over
    // the LPWSTRS.
    //
    for ( i = 0; i < dwMDNumElements; i++ )
    {
        //
        // If this is NULL, then the memcpy 
        // would of copied the null so we are done.
        //
        if ( pcoChangeList[i].pszMDPath )
        {
            m_pcoChangeList[i].pszMDPath = (LPWSTR) GlobalAlloc( 
                                 GMEM_FIXED,  ( wcslen( pcoChangeList[i].pszMDPath ) + 1 ) 
                                               * sizeof(WCHAR)  );

            if ( m_pcoChangeList[i].pszMDPath == NULL )
            {
                hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Allocating memory failed\n"
                    ));

                goto exit;
            }

            // the size of the buffer was based on the len of this request
            // so we are not concerned that there will be a buffer overflow
            wcscpy( m_pcoChangeList[i].pszMDPath, pcoChangeList[i].pszMDPath );
        }

        if ( pcoChangeList[i].pdwMDDataIDs )
        {
            m_pcoChangeList[i].pdwMDDataIDs = (DWORD*) GlobalAlloc( 
                                             GMEM_FIXED,  m_pcoChangeList[i].dwMDNumDataIDs
                                                                    * sizeof ( DWORD ) );

            if ( m_pcoChangeList[i].pdwMDDataIDs == NULL )
            {
                hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Allocating memory failed\n"
                    ));

                goto exit;
            }

            // number of id's is based on the number of id's we were told about.
            memcpy ( m_pcoChangeList[i].pdwMDDataIDs, 
                     pcoChangeList[i].pdwMDDataIDs, 
                     m_pcoChangeList[i].dwMDNumDataIDs * sizeof ( DWORD ) );
        }

    }

    m_dwMDNumElements = dwMDNumElements;

exit:
    
    //
    // destructor will tear down anything we need destroyed.
    //

    return hr;

}   // MB_CHANGE_ITEM::Initialize

/***************************************************************************++

Routine Description:

    Figures out based on the work item base whether the work item can be ignored.

Arguments:

    IN LPCWSTR  pszPathOfOriginalItem - the path from the change notification 
                                        that we are comparing this to.

Return Value:

    BOOL 

--***************************************************************************/

BOOL 
MB_CHANGE_ITEM::CanIgnoreWorkItem(
    IN LPCWSTR  pszPathOfOriginalItem
    )
{

    //
    // the work item base should all ready have been checked for some
    // base requirements before any extra records are researched.
    //
    DBG_ASSERT ( pszPathOfOriginalItem );

    if ( m_dwMDNumElements != 1 ) 
    {
        return FALSE;
    }

    // if it is not a set, then process it.
    if ( m_pcoChangeList[0].dwMDChangeType != MD_CHANGE_TYPE_SET_DATA )
    {
        return FALSE;
    }


    // if it is a server command or app pool command we can't skip it.
    for ( DWORD i = 0; i < m_pcoChangeList[0].dwMDNumDataIDs; i++ )
    {
        if ( m_pcoChangeList[0].pdwMDDataIDs[i] == MD_SERVER_COMMAND ||
             m_pcoChangeList[0].pdwMDDataIDs[i] == MD_APPPOOL_COMMAND )
        {
            return FALSE;
        }
    }

    if ( pszPathOfOriginalItem == NULL ||
         m_pcoChangeList[0].pszMDPath == NULL  ||
         wcscmp ( pszPathOfOriginalItem, m_pcoChangeList[0].pszMDPath ) != 0 )
    {
        return FALSE;
    }

    // we can ignore this work item.
    return TRUE;

}   // MB_CHANGE_ITEM::CanIgnoreWorkItem
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\perf_manager.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    perf_manager.cxx

Abstract:

    This class manages all the performance counters for W3SVC.

Author:

    Emily Kruglick (EmilyK)       29-Aug-2000

Revision History:

Alignment Notes:

  ( need a place to keep this info so it will live here )

  Coming from UL the data all comes in aligned using structures so
  we do not worry about aligning that data.

  Coming from WP the sites data does not need to be aligned
  because it does not contain ULongs so we do not worry about it.
  However the Global data ( that follows the sites must start on a
  8 byte boundary, so we do align for it ( see below ) ).

  Going out to perf counters we align by making sure that each
  counter set is divisable by 8 byte.  If a counter gets added
  that would throw this off, we will also add a bogus field.



--*/



#include "precomp.h"
#include "perfcount.h"
#include <Aclapi.h>

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Mapping of properties from the input struct to the display struct.
//
struct PROP_MAP
{
    DWORD PropDisplayOffset;
    DWORD PropInputId;
};

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Mapping of properties in the display struct
//
struct PROP_MAX_DESC
{
    ULONG SafetyOffset;
    ULONG DisplayOffset;
    ULONG size;
};


//
// Macros
//


//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Macro defining the max fileds for cache counters
//
#define DECLARE_MAX_GLOBAL(Counter)  \
        {   \
        FIELD_OFFSET( GLOBAL_MAX_DATA, Counter ),\
        FIELD_OFFSET( W3_GLOBAL_COUNTER_BLOCK, Counter ),\
        RTL_FIELD_SIZE( W3_GLOBAL_COUNTER_BLOCK, Counter )\
    }

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Macro defining the mapping of worker process cache counters
// to their display offset.
//
#define WPGlobalMapMacro(display_counter, wp_counter)  \
    { FIELD_OFFSET ( W3_GLOBAL_COUNTER_BLOCK, display_counter), WPGlobalCtrs ## wp_counter }


//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Macro defining the mapping of ul cache counters
// to their display offset.
//
#define ULGlobalMapMacro(display_counter, wp_counter)  \
    { FIELD_OFFSET ( W3_GLOBAL_COUNTER_BLOCK, display_counter), HttpGlobalCounter ## wp_counter }

//
// Global variables
//

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
//
// Mapping of GLOBAL MAX Fields as they are passed in from
// the perf manager to how the fields are displayed out.
//
PROP_MAX_DESC g_aIISGlobalMaxDescriptions[] =
{
    DECLARE_MAX_GLOBAL ( MaxFileCacheMemoryUsage )
};
DWORD g_cIISGlobalMaxDescriptions = sizeof( g_aIISGlobalMaxDescriptions ) / sizeof( PROP_MAX_DESC );

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
//
// Mapping of performance counter data from the form it comes in
// as to the form that it goes out to perfmon as.
//
PROP_MAP g_aIISWPGlobalMappings[] =
{
    WPGlobalMapMacro (CurrentFilesCached, CurrentFilesCached),
    WPGlobalMapMacro (TotalFilesCached, TotalFilesCached),
    WPGlobalMapMacro (FileCacheHits, FileCacheHits),
    WPGlobalMapMacro (FileCacheHitRatio, FileCacheHits),
    WPGlobalMapMacro (FileCacheMisses, FileCacheMisses),
    WPGlobalMapMacro (FileCacheHitRatio, FileCacheMisses),
    WPGlobalMapMacro (FileCacheFlushes, FileCacheFlushes),
    WPGlobalMapMacro (CurrentFileCacheMemoryUsage, CurrentFileCacheMemoryUsage),
    WPGlobalMapMacro (MaxFileCacheMemoryUsage, MaxFileCacheMemoryUsage),
    WPGlobalMapMacro (ActiveFlushedFiles, ActiveFlushedFiles),
    WPGlobalMapMacro (TotalFlushedFiles, TotalFlushedFiles),
    WPGlobalMapMacro (CurrentUrisCached, CurrentUrisCached),
    WPGlobalMapMacro (TotalUrisCached, TotalUrisCached),
    WPGlobalMapMacro (UriCacheHits, UriCacheHits),
    WPGlobalMapMacro (UriCacheHitRatio, UriCacheHits),
    WPGlobalMapMacro (UriCacheMisses, UriCacheMisses),
    WPGlobalMapMacro (UriCacheHitRatio, UriCacheMisses),
    WPGlobalMapMacro (UriCacheFlushes, UriCacheFlushes),
    WPGlobalMapMacro (TotalFlushedUris, TotalFlushedUris),
    WPGlobalMapMacro (CurrentBlobsCached, CurrentBlobsCached),
    WPGlobalMapMacro (TotalBlobsCached, TotalBlobsCached),
    WPGlobalMapMacro (BlobCacheHits, BlobCacheHits),
    WPGlobalMapMacro (BlobCacheHitRatio, BlobCacheHits),
    WPGlobalMapMacro (BlobCacheMisses, BlobCacheMisses),
    WPGlobalMapMacro (BlobCacheHitRatio, BlobCacheMisses),
    WPGlobalMapMacro (BlobCacheFlushes, BlobCacheFlushes),
    WPGlobalMapMacro (TotalFlushedBlobs, TotalFlushedBlobs)
};
DWORD g_cIISWPGlobalMappings = sizeof( g_aIISWPGlobalMappings ) / sizeof( PROP_MAP );

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
//
// Mapping of performance counter data from the form it comes in
// as to the form that it goes out to perfmon as.
//
PROP_MAP g_aIISULGlobalMappings[] =
{
    ULGlobalMapMacro (UlCurrentUrisCached, CurrentUrisCached),
    ULGlobalMapMacro (UlTotalUrisCached, TotalUrisCached),
    ULGlobalMapMacro (UlUriCacheHits, UriCacheHits),
    ULGlobalMapMacro (UlUriCacheHitRatio, UriCacheHits),
    ULGlobalMapMacro (UlUriCacheMisses, UriCacheMisses),
    ULGlobalMapMacro (UlUriCacheHitRatio, UriCacheMisses),
    ULGlobalMapMacro (UlUriCacheFlushes, UriCacheFlushes),
    ULGlobalMapMacro (UlTotalFlushedUris, TotalFlushedUris)
};
DWORD g_cIISULGlobalMappings = sizeof( g_aIISULGlobalMappings ) / sizeof( PROP_MAP );

//
// local prototypes
//

//
// Callback function that runs when the
// counters timer fires.
//
VOID
PerfCounterTimerCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    );

//
// Callback function that runs when we
// have run out of time to gather the
// perf counters.
//
VOID
PerfCounterGatheringTimerCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    );

//
// Launched on a separate thread to wait on perf
// counter requests.
//
DWORD WINAPI
PerfCountPing(
    LPVOID lpParameter
    );

HRESULT
AdjustProcessSecurityToAllowPowerUsersToWait(
    );

//
// Public PERF_MANAGER functions
//

/***************************************************************************++

Routine Description:

    Constructor for the PERF_MANAGER class.

Arguments:

    None

Return Value:

    None.

--***************************************************************************/

PERF_MANAGER::PERF_MANAGER(
    )
{


    m_State = UninitializedPerfManagerState;

    m_hPerfCountThread = NULL;

    m_NumProcessesToWaitFor = 0;

    //
    // Set the initial reference count to 1, in order to represent the
    // reference owned by the creator of this instance.
    //

    m_RefCount = 1;

    m_PerfCountThreadId = 0;

    m_PerfCounterTimerHandle = NULL;

    m_PerfCounterGatheringTimerHandle = NULL;

    SecureZeroMemory ( &m_MaxGlobalCounters, sizeof( GLOBAL_MAX_DATA ) );

    SecureZeroMemory ( &m_GlobalCounters, sizeof( W3_GLOBAL_COUNTER_BLOCK ) );

    m_GlobalCounters.PerfCounterBlock.ByteLength = sizeof (W3_GLOBAL_COUNTER_BLOCK);

    m_pHttpSiteBuffer = NULL;

    m_HttpSiteBufferLen = 0;

    m_NextValidOffset = 0;

    m_InstanceInfoHaveChanged = FALSE;

    m_Signature = PERF_MANAGER_SIGNATURE;

}   // PERF_MANAGER::PERF_MANAGER



/***************************************************************************++

Routine Description:

    Destructor for the PERF_MANAGER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

PERF_MANAGER::~PERF_MANAGER(
    )
{

    DBG_ASSERT( m_Signature == PERF_MANAGER_SIGNATURE );

    m_Signature = PERF_MANAGER_SIGNATURE_FREED;

    DBG_ASSERT ( m_State == UninitializedPerfManagerState ||
                 m_State == TerminatingPerfManagerState );
    //
    // Terminate will have Canceled any timers,
    // but we will assert just to make sure terminate
    // got a chance to do it's job.
    //

    DBG_ASSERT ( m_PerfCounterTimerHandle == NULL );

    DBG_ASSERT ( m_PerfCounterGatheringTimerHandle == NULL );

    //
    // This means we are waiting for the thread to exit
    //
    if ( m_hPerfCountThread != NULL )
    {
        WaitForSingleObject (m_hPerfCountThread, INFINITE );
        CloseHandle ( m_hPerfCountThread );
        m_hPerfCountThread = NULL;
    }

    if ( m_pHttpSiteBuffer != NULL )
    {
        m_HttpSiteBufferLen = 0;

        delete[] m_pHttpSiteBuffer;
        m_pHttpSiteBuffer = NULL;
    }


}   // PERF_MANAGER::~PERF_MANAGER


/***************************************************************************++

Routine Description:

    Increment the reference count for this object. Note that this method must
    be thread safe, and must not be able to fail.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
PERF_MANAGER::Reference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedIncrement( &m_RefCount );

    //
    // The reference count should never have been less than zero; and
    // furthermore once it has hit zero it should never bounce back up;
    // given these conditions, it better be greater than one now.
    //

    DBG_ASSERT( NewRefCount > 1 );


    return;

}   // PERF_MANAGER::Reference



/***************************************************************************++

Routine Description:

    Decrement the reference count for this object, and cleanup if the count
    hits zero. Note that this method must be thread safe, and must not be
    able to fail.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
PERF_MANAGER::Dereference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedDecrement( &m_RefCount );

    // ref count should never go negative
    DBG_ASSERT( NewRefCount >= 0 );

    if ( NewRefCount == 0 )
    {
        // time to go away

        IF_DEBUG( WEB_ADMIN_SERVICE_REFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Reference count has hit zero in PERF_MANAGER instance, deleting (ptr: %p; )\n",
                this
                ));
        }


        delete this;


    }


    return;

}   // PERF_MANAGER::Dereference



/***************************************************************************++

Routine Description:

    Execute a work item on this object.

Arguments:

    pWorkItem - The work item to execute.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
PERF_MANAGER::ExecuteWorkItem(
    IN const WORK_ITEM * pWorkItem
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( pWorkItem != NULL );

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        CHKINFO((
            DBG_CONTEXT,
            "Executing work item with serial number: %lu "
            "in PERF_MANAGER (ptr: %p; ) with operation: %p\n",
            pWorkItem->GetSerialNumber(),
            this,
            pWorkItem->GetOpCode()
            ));
    }


    switch ( pWorkItem->GetOpCode() )
    {

    case PerfCounterPingFiredWorkItem:
        ProcessPerfCounterPingFired();
        break;

    case PerfCounterGatheringTimerFiredWorkItem:
        ProcessPerfCounterGatheringTimerFired();
        break;

    default:

        // invalid work item!
        DBG_ASSERT( FALSE );
        
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;

    }

    if ( FAILED( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Executing work item on PERF_MANAGER failed\n"
            ));

    }

    return hr;

}   // PERF_MANAGER::ExecuteWorkItem

/***************************************************************************++

Routine Description:

    Initialize the performance counter manager.  Including setting up
    the first blocks of shared memory for the ctr libraries to use one their
    first requests for our data.  The counters on the first request will
    all be zero however.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
PERF_MANAGER::Initialize(
        )
{

    HRESULT hr = S_OK;
    DWORD   dwErr = ERROR_SUCCESS;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT ( m_State == UninitializedPerfManagerState );

    //
    // Initialize the controller for write access.
    //
    dwErr = m_SharedManager.Initialize(TRUE);
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );
        goto exit;
    }

    //
    // Initialize the counter sets for tracking
    // the cache and site counters.
    //
    dwErr = m_SharedManager.CreateNewCounterSet(
                                     SITE_COUNTER_SET
                                     );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto exit;
    }

    dwErr = m_SharedManager.CreateNewCounterSet(
                                     GLOBAL_COUNTER_SET
                                     );
    if ( dwErr != ERROR_SUCCESS  )
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto exit;
    }

    //
    // For the global counters we also need to have
    // the memory setup.  The sites memory will be
    // established in the CompleteCounterUpdate call.
    //

    hr = m_SharedManager.ReallocSharedMemIfNeccessary ( GLOBAL_COUNTER_SET , 1 );
    if ( FAILED ( hr ) )
    {
        //
        // If we fail to re-allocate memory,
        // then we can not really go on, because
        // we never try again to allocate the
        // global perf counter files.
        //

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Error allocating global shared memory. "
            "Turning off perf counter publishing, "
            "you must restart w3svc to reactivate them\n"
            ));

        goto exit;
    }

    //
    // Change the state so we will be able to call
    // the completion routine and initialize the memory
    // to zeros.
    //
    m_State = GatheringPerfManagerState;

    //
    // Now tell ourselves that we are done gathering
    // and we are ready to publish the counters.  This
    // will publish all zero's but atleast the page will
    // have the instance information that it needs.
    //
    CompleteCounterUpdate();

    hr = AdjustProcessSecurityToAllowPowerUsersToWait();
    if (FAILED (hr))
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to adjust process security thread \n"
            ));

        goto exit;
    }

    //
    // Launch the thread that will wait for pings to tell
    // it to refresh counters.
    //
    hr = LaunchPerfCounterWaitingThread();
    if (FAILED (hr))
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to launch the perf counter waiting thread \n"
            ));

        goto exit;
    }

    //
    // Setup a timer that will remind us every so often to
    // gather counters, whether or not we are being asked
    // to publish them.
    //
    BeginPerfCounterTimer();

exit:

    if ( FAILED (hr) )
    {
        m_State = UninitializedPerfManagerState;
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {

        DBGPRINTF((
            DBG_CONTEXT,
            "Initializing the Perf Manager is returning: %x\n",
            hr
            ));

    }

    return hr;

}   // PERF_MANAGER::Initialize


/***************************************************************************++

Routine Description:

    Routine will go through the blob of data provide by a worker process
    and will determine what counters need to be updated.
    It will then update those counters.

Arguments:

    IN DWORD MessageLength - Number of bytes in the blob following.
    IN LPVOID MessageData  - The data that will be merged with the counters.

Return Value:

    BOOL -  TRUE - Data looked ok
            FALSE - WP lied about data sizes

--***************************************************************************/
BOOL
PERF_MANAGER::RecordCounters(
    IN DWORD MessageLength,
    IN const BYTE* pMessageData
    )
{

    BOOL fExpectedWPTampering = FALSE;

    //
    // MessageLength can be zero if a sick worker process is
    // just trying to take himself out of the count of worker processes
    // to wait on.
    //

    if ( MessageLength != 0 )
    {
        IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Received message with length %d\n",
                MessageLength
                ));
        }

        // First piece of the message is the number of instances.
        // Second piece will be an instances data.
        // Use the instances data to identify the instance and then
        // let the aggregation code add the counters in for that instance.

        DBG_ASSERT(pMessageData);

        //
        // Validate that we at least have the number of counters in the message.
        // Do not trust that the info in this message is valid since it came 
        // from the worker process.
        //

        if ( MessageLength < sizeof(DWORD) )
        {
            DBG_ASSERT( MessageLength >= sizeof(DWORD) );
            
            fExpectedWPTampering = TRUE;

            goto exit;
        }

        DWORD NumInstances = *((DWORD*)pMessageData);

        // Make sure that we have the right amount of memory for the amount
        // of counters we are suppose to look at.  Note that we will also have
        // to do another check below to make sure with the alignment that we are still
        // ok.
        if ( MessageLength < sizeof(DWORD) + 
                             sizeof(IISWPSiteCounters) * NumInstances +  
                             sizeof(IISWPGlobalCounters) )
        {
            DBG_ASSERT ( MessageLength >= sizeof(DWORD) + 
                                          sizeof(IISWPSiteCounters) * NumInstances +  
                                          sizeof(IISWPGlobalCounters) );
            fExpectedWPTampering = TRUE;

            goto exit;
        }

        if ( NumInstances > 0 )
        {
            //
            // Next reference the first set of site counters.
            //
            IISWPSiteCounters* pSiteCounters =
                        (IISWPSiteCounters*)(((LPBYTE) pMessageData ) + sizeof(DWORD));

            IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
            {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "Message contains %d sites\n",
                    *(DWORD*)pMessageData
                    ));
            }

            //
            // Loop through all instances processing the counters into
            // the virtual site objects.
            //
            for (DWORD i = 0; i < NumInstances; i++, pSiteCounters++)
            {
                //
                // Debug mode printing of counter values.
                //
                DumpWPSiteCounters(pSiteCounters);

                //
                // Once we have verified we have enough room, we can then
                // process the counters.
                //
                FindAndAggregateSiteCounters( WPCOUNTERS,
                                              pSiteCounters->SiteID,
                                              pSiteCounters );
            }

        } // Finished with sites.

        //
        // Following sites will be the global counters.
        //
        IISWPGlobalCounters* pGlobalCounters = (IISWPGlobalCounters*)
                                               ( (LPBYTE) pMessageData
                                                + sizeof(DWORD)
                                                + (NumInstances * sizeof (IISWPSiteCounters)));

        //
        // Global counters contain some ULONGLONG values so we align it to
        // ULONGLONG and that is how the wp sends in the value too
        //
        pGlobalCounters = (IISWPGlobalCounters *)(((DWORD_PTR)pGlobalCounters + 7) & ~7);

        IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "pGlobalCounters = %x, sizeof(IISWPGlobalCounters) = %d, pMessageData = %x\n",
                pGlobalCounters,
                sizeof(IISWPGlobalCounters),
                pMessageData
                ));
        }

        //
        // Need to check the space left based on the length sent in again.  We do
        // this again here because we had to account for alignment of the memory.
        //
        if ( ( ((LPBYTE)pGlobalCounters + sizeof( IISWPGlobalCounters ) ) 
                         < (LPBYTE) pMessageData ) ||
             ( (DWORD)((LPBYTE)pGlobalCounters + sizeof(IISWPGlobalCounters)
                          - (LPBYTE)pMessageData) != MessageLength ) )
        {
            //
            // Make sure we have exactly enough space left for the global counters to exist.
            //
            DBG_ASSERT ( ( ((LPBYTE)pGlobalCounters + sizeof( IISWPGlobalCounters ) ) 
                                    >= (LPBYTE) pMessageData ) &&
                         ( (DWORD)((LPBYTE)pGlobalCounters + sizeof(IISWPGlobalCounters)
                                       - (LPBYTE)pMessageData) == MessageLength ) );

            fExpectedWPTampering = TRUE;

            goto exit;
        }

        //
        // Debug mode printing of the counters.
        //
        DumpWPGlobalCounters( pGlobalCounters );

        //
        // Things look good, go ahead and add in the global
        // counter values.
        //

        AggregateGlobalCounters ( WPCOUNTERS, (LPVOID) pGlobalCounters );
    }

exit:


    //
    // Once done with recording the counters we need to decrement
    // the number of worker processe we are waiting on.  This is done
    // whether or not counters were received because we could just be
    // attempting to take a sick wp out of the waiting loop.
    //

    DecrementWaitingProcesses();

    //
    // Now that everything has been handled sufficently we can
    // let the caller know if we suspect tamering with the data.
    //
    if ( fExpectedWPTampering )
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }


} // End of PERF_MANAGER::RecordCounters

/***************************************************************************++

Routine Description:

    Terminates the perf manager.  This function will tell the waiting thread
    to terminate and will clean up the perf virtual site table.  However it will
    not wait for the waiting thread to terminate.  That is left for the destructor.

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_MANAGER::Terminate()
{
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT ( m_State == GatheringPerfManagerState ||
                 m_State == IdlePerfManagerState );

    //
    // Note:  There is no guarantee that initialize was called
    //        before this is called, so do not assume anything
    //        has been setup in here.
    //

    m_State = TerminatingPerfManagerState;

    CancelPerfCounterTimer();

    CancelPerfCounterGatheringTimer();

    m_SharedManager.PingWASToRefreshCounters();

    //
    // Tell the shared memory that the memory it has is no longer valid, but
    // don't give it new memory.  This will cause it to start returning nothing.
    // It will also leave it in a state to return data if we come up data later.
    //

    m_SharedManager.StopPublishing();

    //
    // The destructors will let go of all shared memory.
    //
} // end PERF_MANAGER::Terminate

/***************************************************************************++

Routine Description:

    Copies in the the counter information for a particular instance
    of the counters represented by the VirtualSite that is passed in.

Arguments:

    IN VIRTUAL_SITE* pVirtualSite - A pointer to the VirtualSite
                                    that we are working with.

    IN BOOL          StructChanged - Tells if we need to relay the instance
                                     header information as well as resetting
                                     the offset for the site.

    IN ULONG*        pMemoryOffset - Used to figure out where the counter's
                                      information actually goes in the files.

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_MANAGER::SetupVirtualSite(
    IN VIRTUAL_SITE* pVirtualSite
    )
{

    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    // verify that we are actually gathering and thus
    // should be publishing.
    DBG_ASSERT ( m_State == GatheringPerfManagerState );

    // Make sure we have a virtual site to work with.
    DBG_ASSERT( pVirtualSite != NULL );

    //
    // If the structure changed then we need to
    // save the new memory offset with the virtual
    // site, so we won't have to figure it out again
    // until the next structural change.
    //
    if ( m_InstanceInfoHaveChanged )
    {
        pVirtualSite->SetMemoryOffset( m_NextValidOffset );
    }


    LPWSTR pServerComment = NULL;
    if ( pVirtualSite->CheckAndResetServerCommentChanged() || m_InstanceInfoHaveChanged )
    {
        // Write in the server comment.
        pServerComment = pVirtualSite->GetVirtualSiteName();

        // If a name changes then we do need to update
        // the second piece of shared memory as well.
        m_SharedManager.SetUpdateNeeded( SITE_COUNTER_SET,
                                         TRUE );
    }

    //
    // Setup the Instance Counter Information
    // This will copy in the instance name, as well as setting
    // up the instance header block.  It will also copy
    // over the counter values.
    //

    m_SharedManager.CopyInstanceInformation(
                                  SITE_COUNTER_SET
                                , pServerComment
                                , pVirtualSite->GetMemoryOffset()
                                , pVirtualSite->GetCountersPtr()
                                , pVirtualSite->GetDisplayMap()
                                , pVirtualSite->GetSizeOfDisplayMap()
                                , m_InstanceInfoHaveChanged
                                , &m_NextValidOffset );


}

/***************************************************************************++

Routine Description:

    Routine will setup the _Total Instance for sites.

Arguments:

    IN BOOL          StructChanged - Tells if we need to relay the instance
                                     header information.

    IN ULONG*        pMemoryOffset - Used to figure out where the counter's
                                      information actually goes in the files.

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_MANAGER::SetupTotalSite(
    IN BOOL          StructChanged
    )
{

    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    // we are publishing so counters so we had better be in
    // the gathering state.
    DBG_ASSERT ( m_State == GatheringPerfManagerState );

    //
    // remember if we are dealing with a structural change.
    //
    m_InstanceInfoHaveChanged = StructChanged;

    //
    // Setup the Instance Counter Information
    // This will copy in the instance name, as well as zero'ing
    // all the counter values and correctly adjusting byte lengths
    // in the data header.
    //
    // Note, unlike the instance case in the function above
    // we do not pass counters here.  They will be aggregated
    // from the specific instance counters.
    //
    m_SharedManager.CopyInstanceInformation(
                                  SITE_COUNTER_SET
                                , L"_Total"
                                , 0       // the _TotalSite is always the 0 offset.
                                , NULL
                                , NULL
                                , 0
                                , m_InstanceInfoHaveChanged
                                , &m_NextValidOffset );


}

//
// Private PERF_MANAGER functions
//


/***************************************************************************++

Routine Description:

    Routine determines where the global counters came from and
    aggregates them into the correct holding block.

Arguments:

    COUNTER_SOURCE_ENUM CounterSource - Identifier of the where
                                        the counters are coming from. (WP or UL)
    IN LPVOID pCountersToAddIn - Cache counters in either the Wp or UL structure.

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_MANAGER::AggregateGlobalCounters(
    COUNTER_SOURCE_ENUM CounterSource,
    IN LPVOID pCountersToAddIn
    )
{
    //
    // Validate that we are in a mode where we can
    // receive counters.
    //
    DBG_ASSERT ( m_State == GatheringPerfManagerState ||
                 m_State == IdlePerfManagerState );

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    HTTP_PROP_DESC* pInputPropDesc = NULL;
    PROP_MAP*       pPropMap = NULL;
    DWORD           MaxCounters = 0;

    //
    // Choose the appropriate counter definitions
    // to navigate through the counters and aggregate
    // them into the display counters.
    //
    if ( CounterSource == WPCOUNTERS )
    {
        pInputPropDesc = aIISWPGlobalDescription;
        pPropMap = g_aIISWPGlobalMappings;
        MaxCounters = sizeof ( g_aIISWPGlobalMappings ) / sizeof ( PROP_MAP );
    }
    else
    {
        DBG_ASSERT ( CounterSource == ULCOUNTERS );

        pInputPropDesc = aIISULGlobalDescription;
        pPropMap = g_aIISULGlobalMappings;
        MaxCounters = sizeof ( g_aIISULGlobalMappings ) / sizeof ( PROP_MAP );
    }

    //
    // Retrieve a pointer to the global counters structure
    // that holds the counters before they go to shared memory.
    //
    LPVOID pCounterBlock = &m_GlobalCounters;

    DWORD PropInputId = 0;

    for (  DWORD PropDisplayId = 0;
            PropDisplayId < MaxCounters;
            PropDisplayId++ )
    {
        //
        // Figure out for this display entry what the
        // entry in the incoming mapping array is.
        //
        PropInputId = pPropMap[PropDisplayId].PropInputId;

        //
        // Depending on the size of the property we are
        // dealing with, handle the update.
        //
        if ( pInputPropDesc[PropInputId].Size == sizeof( DWORD ) )
        {

            DWORD* pDWORDToUpdate = (DWORD*) ( (LPBYTE) pCounterBlock
                                + pPropMap[PropDisplayId].PropDisplayOffset );

            DWORD* pDWORDToUpdateWith =  (DWORD*) ( (LPBYTE) pCountersToAddIn
                                + pInputPropDesc[PropInputId].Offset );

            //
            // Based on current configuration of the system.
            // This is happinging on the main thread.
            // which means that more than one can not happen
            // at the same time so it does not need to be
            // an interlocked exchange.
            //

            *pDWORDToUpdate = *pDWORDToUpdate + *pDWORDToUpdateWith;


        }
        else
        {
            DBG_ASSERT ( pInputPropDesc[PropInputId].Size ==
                                                    sizeof( ULONGLONG ) );

            ULONGLONG* pQWORDToUpdate = (ULONGLONG*) ( (LPBYTE) pCounterBlock
                               + pPropMap[PropDisplayId].PropDisplayOffset );

            ULONGLONG* pQWORDToUpdateWith =
                                    (ULONGLONG*) ( (LPBYTE) pCountersToAddIn
                                      + pInputPropDesc[PropInputId].Offset );

            //
            // Based on current configuration of the system.
            // This is happinging on the main thread.
            // which means that more than one can not happen
            // at the same time so it does not need to be
            // an interlocked exchange.
            //


            *pQWORDToUpdate = *pQWORDToUpdate + *pQWORDToUpdateWith;

        }

    }

}  // End of AggregateGlobalCounters

/***************************************************************************++

Routine Description:

    Routine will look up a particular site's counter block and will
    aggregate in the counters for that block.

Arguments:

    IN IISWPSiteCounters* pCounters - counters to add in.

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_MANAGER::FindAndAggregateSiteCounters(
    COUNTER_SOURCE_ENUM CounterSource,
    DWORD SiteId,
    IN LPVOID pCounters
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT ( m_State == GatheringPerfManagerState ||
                 m_State == IdlePerfManagerState );

    DBG_ASSERT ( SiteId != 0 );
    //
    // The virtual site returned is not ref counted so it is only
    // valid to use during this work item, on the main thread.
    //
    VIRTUAL_SITE* pVirtualSite = GetWebAdminService()->
                                GetUlAndWorkerManager()->
                                GetVirtualSite(SiteId);

    //
    // It is completely possible to get counters for a Site we no longer
    // think exists.  If this is the case then we simply ignore the counters.
    //
    if ( pVirtualSite )
    {
        pVirtualSite->AggregateCounters ( CounterSource, pCounters );
    }

}


/***************************************************************************++

Routine Description:

    Whenever a worker process that we are waiting for responds with perf
    counters, we decrement the number of waiting processes.  If the count
    hits zero than we know we can go ahead and publish the counters.  If
    a worker process responds that we are not waiting for, we may still
    process the counters, but we do not affect the overall count, nor can it
    trigger us to publish counters.

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_MANAGER::DecrementWaitingProcesses(
    )
{
    //
    // If we get a report on counters and are not
    // in the gathering state, then it really doesn't
    // matter to our count, so don't bother changing it.
    //
    if ( m_State == GatheringPerfManagerState )
    {
        m_NumProcessesToWaitFor--;

        if ( m_NumProcessesToWaitFor == 0 )
        {
            CompleteCounterUpdate();
        }
    }

}


/***************************************************************************++

Routine Description:

    Launches the perf counter waiting thread that will let us know
    when the perf library wants counters refreshed.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
PERF_MANAGER::LaunchPerfCounterWaitingThread(
    )
{
    HRESULT hr = S_OK;

    //
    // This is called right after our initalization sets up the first
    // blocks of counter memory.  It will leave it in the Idle state
    // before calling this.
    //
    DBG_ASSERT ( m_State == IdlePerfManagerState );

    m_hPerfCountThread = CreateThread(   NULL           // use current threads security
                                        // Big initial size to prevent stack overflows
                                        , IIS_DEFAULT_INITIAL_STACK_SIZE
                                        , &PerfCountPing
                                        , this          // pass this object in.
                                        , 0             // don't create suspended
                                        , &m_PerfCountThreadId);
    if (m_hPerfCountThread == NULL)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError());
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not spin up thread to wait for event\n"
            ));

        goto exit;
    }

exit:

    return hr;

}  // end PERF_MANAGER::LaunchPerfCounterWaitingThread


/***************************************************************************++

Routine Description:

    Routine will force the counter update to complete if the
    counter update is still going on, any counters not in at this
    point will be counted in the next gathering.

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_MANAGER::ProcessPerfCounterGatheringTimerFired(
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    //
    // If we are still waiting, go ahead and complete
    // the counter gathering.  This will mean any worker
    // process that has not answered will be ignored.
    //
    if ( m_State == GatheringPerfManagerState )
    {
        CompleteCounterUpdate();
    }
    else
    {
        CancelPerfCounterGatheringTimer();
    }
}

/***************************************************************************++

Routine Description:

    Routine handles a request for performance counter updates.

    If an update is all ready going on it will simply ignore the new request.

    Runs only on the main thread, using the sites table and app pool tables
    as well as the worker process objects to coordinate gathering of the counters.

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_MANAGER::ProcessPerfCounterPingFired(
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    if ( m_State != IdlePerfManagerState )
    {
        //
        // It is not really an error to request an update at any
        // point.  However we may not really do anything if we
        // are not in the idle state.
        //
        IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Not kicking off a counter gathering because"
                " the state was not idle m_State: %d\n",
                (DWORD) m_State
                ));
        }

        return;
    }

    //
    // Transition the state so that we know we
    // have begun updating counters.  Note that
    // m_State should only be changed the main thread
    //
    m_State = GatheringPerfManagerState;

    //
    // Send out a message to every active worker process
    // and ask that we get it's counters now.
    //
    RequestWorkerProcessGatherCounters();

    //
    // Get UL's counters.
    //
    RequestAndProcessULCounters();

    //
    // There are no worker processes to wait for.
    //
    if (  m_NumProcessesToWaitFor == 0 )
    {
        CompleteCounterUpdate();
    }

}

/***************************************************************************++

Routine Description:

    Routine will ask all the worker process objects to send an IPM
    request to each worker process requesting their counters.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_MANAGER::RequestWorkerProcessGatherCounters(
    )
{
    DWORD NumProcessesToWaitFor = 0;

    DBG_ASSERT ( m_State == GatheringPerfManagerState );

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    //
    // We may still be waiting for a worker process who didn't make
    // the window before.  If this is the case, then while we won't
    // ask the worker process for counters again, he will be included
    // in the NumProcessesToWaitFor.  If he missed the window before, but
    // has all ready returned counters, he will not be included in the number
    // to wait for.  In summary, the NumProcessesToWaitFor takes into account
    // stragling counters from previous attempts.
    //
    NumProcessesToWaitFor = GetWebAdminService()->
                            GetUlAndWorkerManager()->
                            RequestCountersFromWorkerProcesses();

    IF_DEBUG ( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Number of process to wait for is = %d \n",
            NumProcessesToWaitFor
            ));
    }

    //
    // Since we have possesion of the main thread, so no I/O operations could
    // of been handled yet, we do not need to worry about synchronizing the
    // this increment.
    //

    m_NumProcessesToWaitFor = NumProcessesToWaitFor;

    //
    // Ignore a failure here.  If it failed then we will
    // spew it (within this call), and continue without the timer.
    //
    BeginPerfCounterGatheringTimer();

}

/***************************************************************************++

Routine Description:

  Routine loops through the site counters provided by HTTP.SYS and aggregates
  them into the appropriate site values.

Arguments:

  DWORD SizeOfBuffer is the size that HTTP.SYS says it used of the buffer.
  DWORD NumInstances is the number of instances that the buffer contains.

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_MANAGER::RecordHttpSiteCounters(
    DWORD SizeOfBuffer,
    DWORD NumInstances
    )
{

    //
    // Counters can only come in from HTTP.SYS while
    // we are in the gathering mode.
    //
    DBG_ASSERT ( m_State == GatheringPerfManagerState );

    //
    // First assert that the Site buffer actually exists.
    //

    DBG_ASSERT( m_pHttpSiteBuffer != NULL || ( SizeOfBuffer == 0 && NumInstances == 0 ));

    //
    // Next reference the first set of site counters.
    //
    HTTP_SITE_COUNTERS* pSiteCounters =
                (HTTP_SITE_COUNTERS*) m_pHttpSiteBuffer;

    if ( SizeOfBuffer < sizeof( HTTP_SITE_COUNTERS ) * NumInstances )
    {
        DBG_ASSERT ( SizeOfBuffer >= sizeof( HTTP_SITE_COUNTERS ) * NumInstances );

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_HTTP_SITE_COUNTER_SIZE_FAILURE,           // message id
                0,                                            // count of strings
                NULL,                                         // array of strings
                S_OK                                            // error code
                );

        return;
    }

    //
    // Loop through all instances processing the counters into
    // the virtual site objects.
    //
    for (DWORD i = 0; i < NumInstances; i++, pSiteCounters++)
    {
        //
        // Debug mode printing of counter values.
        //
        DumpULSiteCounters( pSiteCounters );

        //
        // Once we have verified we have enough room, we can then
        // process the counters.
        //
        FindAndAggregateSiteCounters( ULCOUNTERS,
                                      pSiteCounters->SiteId,
                                      pSiteCounters );
    }

} // End of PERF_MANAGER::RecordHttpSiteCounters

/***************************************************************************++

Routine Description:

    Routine will ask UL for it's counters and compile them into the
    correct places in shared memory.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_MANAGER::RequestAndProcessULCounters(
    )
{
    DWORD Win32Error = NO_ERROR;
    HRESULT hr       = S_OK;
    DWORD NumInstances = 0;
    DWORD SizeOfBuffer = sizeof( HTTP_GLOBAL_COUNTERS );

    DBG_ASSERT ( m_State == GatheringPerfManagerState );

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    HTTP_GLOBAL_COUNTERS GlobalBlock;

    //
    // Clear the memory block we will be giving to UL
    // so we know any values in here were set by UL.
    //
    SecureZeroMemory ( &GlobalBlock, sizeof( HTTP_GLOBAL_COUNTERS ) );

    //
    // Make a request of from UL for the Global Counters
    //

    HANDLE hControlChannel = GetWebAdminService()->
                                GetUlAndWorkerManager()->
                                GetUlControlChannel();

    Win32Error = HttpGetCounters(hControlChannel,
                  HttpCounterGroupGlobal,
                  &SizeOfBuffer,
                  &GlobalBlock,
                  &NumInstances);
    if ( Win32Error != NO_ERROR )
    {
        //
        // When asking for globals, we are out of sync if we
        // don't all ready know the size of the buffer to provide.
        //

        DBG_ASSERT ( Win32Error != ERROR_MORE_DATA );

        hr = HRESULT_FROM_WIN32( Win32Error );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Retrieving global counters from ul failed. \n"
            ));


        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_PERF_COUNTER_HTTP_GLOBALS_FAILURE,          // message id
                0,                                            // count of strings
                NULL,                                         // array of strings
                hr                                            // error code
                );

        hr = S_OK;

    }
    else
    {
        //
        // Global better only return 1 instance.
        //

        DBG_ASSERT ( NumInstances == 1 );
        DBG_ASSERT ( SizeOfBuffer == sizeof ( HTTP_GLOBAL_COUNTERS ) );

        //
        // Debug print of counters.
        //
        DumpULGlobalCounters(&GlobalBlock);

        //
        // Once we have the counters we need to process them.
        //
        AggregateGlobalCounters ( ULCOUNTERS, (LPVOID) &GlobalBlock );

    }

    //
    // Make a request of UL for the Site counters
    //

    //
    // Figure out the buffering size and get the counters from HttpSys.
    hr = RequestSiteHttpCounters(hControlChannel, &SizeOfBuffer, &NumInstances);

    //
    // Global better only return 1 instance.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Got site counters:  \n"
            "   NumInstances = %d  \n"
            "   SizeOfBuffer used = %d \n"
            "   ActualSizeOfBuffer = %d \n",
            NumInstances,
            SizeOfBuffer,
            m_HttpSiteBufferLen
            ));
    }

    // Only record the site counters if we actually got the site counters.
    if ( SUCCEEDED ( hr ) )
    {
        RecordHttpSiteCounters(SizeOfBuffer, NumInstances);
    }

}

/***************************************************************************++

Routine Description:

    Routine will request the site counters from HTTP.SYS.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
PERF_MANAGER::RequestSiteHttpCounters(
    HANDLE hControlChannel,
    DWORD* pSpaceNeeded,
    DWORD* pNumInstances
    )
{
    DWORD Win32Error = NO_ERROR;
    HRESULT hr       = S_OK;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( pNumInstances );
    DBG_ASSERT( pSpaceNeeded );

    *pNumInstances = 0;
    *pSpaceNeeded = 0;

    //
    // First we must make sure we have enough space for the site
    // counters in the buffer.  We will only reallocate memory
    // if we don't have enough memory in the first place.  HTTP.SYS
    // can still tell us we have too little memory, if we guess wrong.
    //
    DWORD NumSites = GetWebAdminService()->
                                GetUlAndWorkerManager()->
                                GetNumberofVirtualSites();

    // Don't bother asking for site counters if we don't
    // have any sites configured.
    if ( NumSites > 0 )
    {
        *pSpaceNeeded = NumSites * sizeof ( HTTP_SITE_COUNTERS );

        //
        // Since we remember how much space we have allocated for this
        // we can check to see if it is enough to collect the counters
        // we expect.
        //
        hr = SizeHttpSitesBuffer( pSpaceNeeded );
        if ( FAILED (hr) )
        {
            goto exit;
        }

        DBG_ASSERT ( m_pHttpSiteBuffer );
        //
        // Make a request of from UL for the Site Counters
        //
        //
        // Note, since WAS configures the number of sites HTTP
        // knows about we are assuming that WAS will always be able
        // to calculate the correct buffer size.  It might become
        // apparent that this assumption is false, but until it
        // does we are intentionally not handling the case where
        // the buffer size is too small.
        Win32Error = HttpGetCounters(hControlChannel,
                      HttpCounterGroupSite,
                      pSpaceNeeded,
                      m_pHttpSiteBuffer,
                      pNumInstances);

        if ( Win32Error != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32( Win32Error );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Retrieving site counters from HTTP.SYS failed. \n"
                ));

        }
    }

exit:

    if ( FAILED ( hr ) )
    {
        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_PERF_COUNTER_HTTP_SITE_FAILURE,           // message id
                0,                                            // count of strings
                NULL,                                         // array of strings
                hr                                            // error code
                );
    }

    return hr;

}

/***************************************************************************++

Routine Description:

    Routine alters the m_pHttpSitesBuffer to be of the size requested.
    If the buffer is all ready bigger than the size requested no changes
    are made, however the size requested is altered so we are aware that
    we are actually passing more space than expected.

Arguments:

    DWORD* pSpaceNeeded - Coming in it is the size we expect to need
                          Going out it is the size we actually have

Return Value:

    HRESULT - Can return E_OUTOFMEMORY if allocations failed.

--***************************************************************************/
HRESULT
PERF_MANAGER::SizeHttpSitesBuffer(
    DWORD* pSpaceNeeded
    )
{
    HRESULT hr = S_OK;
    DBG_ASSERT ( pSpaceNeeded );

    if ( *pSpaceNeeded > m_HttpSiteBufferLen )
    {
        //
        // If we all ready have allocated space,
        // get rid of it.
        //
        if ( m_pHttpSiteBuffer )
        {
            delete[] m_pHttpSiteBuffer;
        }

        //
        // allocate the new space, if this fails,
        // we should not go on with getting counters
        // from HTTP.SYS.
        //
        // if we don't have enough memory we will
        // just not get the counters
        //
        m_pHttpSiteBuffer = new BYTE[*pSpaceNeeded];
        if ( m_pHttpSiteBuffer == NULL )
        {
            // Not good, we can't complete getting
            // counters here.

            // need to set the BufferLen to zero as
            // well so we can recover next time.
            m_HttpSiteBufferLen = 0;

            hr = E_OUTOFMEMORY;

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Error allocating space to get HTTP.SYS site "
                "counters in. \n"
                ));

            goto exit;

        }

        m_HttpSiteBufferLen = *pSpaceNeeded;
    }
    else
    {
        //
        // Issue-10/23/2000-EmilyK Shrink the site buffer?
        //
        // Do we want to shrink the site buffer, if we are
        // extremely larger than expected?
        //

        //
        // Change space needed to correctly tell HTTP.SYS how
        // much space they are being passed.
        //
        *pSpaceNeeded = m_HttpSiteBufferLen;
    }

    //
    // Assuming we have a buffer, we should clear the buffer
    // before passing it down to the Http.sys.
    //
    if ( m_pHttpSiteBuffer )
    {
        //
        // Clear the memory block we will be giving to UL
        // so we know any values in here were set by UL.
        //
        SecureZeroMemory ( m_pHttpSiteBuffer, m_HttpSiteBufferLen );
    }


exit:

    return hr;
}

/***************************************************************************++

Routine Description:

    Routine runs when we have completed updating counters.  It will
    fix the maximum values and will change the control information to
    point to the new active counters.  It will also change state so
    new requests can be received.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_MANAGER::CompleteCounterUpdate(
    )
{
    HRESULT hr = S_OK;

    DBG_ASSERT ( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( m_State == GatheringPerfManagerState );

    CancelPerfCounterGatheringTimer();

    //
    // Now that we have gotten all the performance counters
    // we need to do the following:
    //
    // 1)  Figure out if we need more memory allocated. (StructChanged)
    // 2)  Figure out if sites have gone away. (StructChanged)
    // 3)  Walk the sites table (for each site do):
    //       a)  pass in the current offset for the memory.
    //       b)  if there has been a struct change copy in
    //           the instance information. store the offset.
    //       c)  adjust max values (as well as store back adjusted values)
    //       d)  copy in the counters
    //       g)  increment the _Total with the new values.
    //       h)  zero out the appropriate site counters.
    // 4)  Publish the new page to the user.
    // 5)  Copy the page over if update was needed.

    //
    // Figure out if any sites have been deleted
    // or added since the last time we got counters.
    //
    BOOL SiteStructChanged = GetWebAdminService()->
                             GetUlAndWorkerManager()->
                             CheckSiteChangeFlag();

    //
    // If they have then we may need to re-allocate memory.
    //
    if ( SiteStructChanged )
    {

        //
        // Tell shared memory the new number of instances that we now have and
        // let it reallocate the memory if neccessary.  Remember that we also need
        // space for the _Total instance.
        //
        DWORD NumVirtualSites = GetWebAdminService()->
                                GetUlAndWorkerManager()->
                                GetNumberofVirtualSites();

        hr = m_SharedManager.ReallocSharedMemIfNeccessary(
                                                            SITE_COUNTER_SET,
                                                            NumVirtualSites + 1);
        if ( FAILED ( hr ) )
        {
            // Need to log some error here...

            //
            // If we fail to re-allocate memory,
            // then we can not really go on, because
            // the next time through we will assume
            // that we atleast started with valid memory
            // which if no new changes had come in, we
            // will try to write to the invalid memory.
            // For now we will simply turn off counters
            // if this fails.  If we find there are valid
            // ways to get into this state, we can re-look
            // at being able to suspend counter publishing
            // and have it turn back on.
            //

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Error reallocating the shared memory, turning of perf counter publishing, you must restart w3svc to reactivate them\n"
                ));

            goto exit;
        }
        else
        {
            // we were able to re-allocated the memory
            // so we can now declare that the site info
            // has not changed.
            GetWebAdminService()->
                 GetUlAndWorkerManager()->
                 ResetSiteChangeFlag();        
        }    
    }

    //
    // Now let UL walk through the tables and
    // have each one of the sites report to
    // the perf manager their values.
    //

    GetWebAdminService()->
    GetUlAndWorkerManager()->
    ReportVirtualSitePerfInfo( this , SiteStructChanged );

    //
    // Fix the actual service uptime now.
    //
    m_SharedManager.UpdateTotalServiceTime( GetCurrentTimeInSeconds()
                           - GetWebAdminService()->ServiceStartTime() );

    //
    // Need to report the Global Counters as well.
    //
    ReportGlobalPerfInfo();

    //
    // Once the information has all been reported
    // then we can publish the page.
    //

    m_SharedManager.PublishCounters();

exit:

    if ( FAILED ( hr ) )
    {
        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_PERF_COUNTER_PUBLISHING_FAILURE,          // message id
                0,                                            // count of strings
                NULL,                                         // array of strings
                hr                                            // error code
                );

        GetWebAdminService()->
        GetUlAndWorkerManager()->
        ReportVirtualSitePerfInfo( NULL , SiteStructChanged );

        ClearAppropriatePerfValues();
    }

    //
    // Now that the counters have been placed in
    // shared memory, and the hold tanks have been
    // adjusted for new counters to come in, we
    // can go ahead and tell all the worker processes
    // that they can accept new counters.
    //
    GetWebAdminService()->
    GetUlAndWorkerManager()->
    ResetAllWorkerProcessPerfCounterState();

    m_State = IdlePerfManagerState;
}

/***************************************************************************++

Routine Description:

    Routine take the global counters that we have gathered and
    places them into shared memory.

Arguments:

    None.

Return Value:

    None

--***************************************************************************/
VOID
PERF_MANAGER::ReportGlobalPerfInfo()
{

    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT ( m_State == GatheringPerfManagerState );

    //
    // Since we are done we can now adjust any max values.
    //
    AdjustMaxValues();

    //
    // Setup the Instance Counter Information
    // This will copy in the instance name, as well as zero'ing
    // all the counter values and correctly adjusting byte lengths
    // in the data header.
    //

    ULONG Unused = 0;

    m_SharedManager.CopyInstanceInformation(
                                  GLOBAL_COUNTER_SET
                                , NULL
                                , 0
                                , &m_GlobalCounters
                                , NULL
                                , 0
                                , FALSE
                                , &Unused );



    //
    // Clear the appropriate values from the site so that we are
    // ready to get the next set of counters in.
    //
    ClearAppropriatePerfValues();


} // end of PERF_MANAGER::ReportGlobalPerfInfo

/***************************************************************************++

Routine Description:

    Routine figures out the maximum value for the counters
    and saves it back into the MaxCounters Structure.

Arguments:

    NONE

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_MANAGER::AdjustMaxValues(
    )
{
    DBG_ASSERT ( m_State == GatheringPerfManagerState );

    //
    // Walk through all the MAX property descriptions.
    //
    for (   ULONG PropMaxId = 0 ;
            PropMaxId < g_cIISGlobalMaxDescriptions;
            PropMaxId++ )
    {

        if ( g_aIISGlobalMaxDescriptions[PropMaxId].size == sizeof( DWORD ) )
        {
            DWORD* pDWORDAsIs = (DWORD*) ( (LPBYTE) &m_GlobalCounters
                       + g_aIISGlobalMaxDescriptions[PropMaxId].DisplayOffset );

            DWORD* pDWORDToSwapWith =  (DWORD*) ( (LPBYTE) &m_MaxGlobalCounters
                        + g_aIISGlobalMaxDescriptions[PropMaxId].SafetyOffset );


            if ( *pDWORDAsIs < *pDWORDToSwapWith )
            {
                //
                // We have seen a max that is greater than the
                // max we are now viewing.
                //
                *pDWORDAsIs = *pDWORDToSwapWith;
            }
            else
            {
                //
                // We have a new max so save it in the safety structure
                //
                *pDWORDToSwapWith = *pDWORDAsIs;
            }

        }
        else
        {
            DBG_ASSERT ( g_aIISGlobalMaxDescriptions[PropMaxId].size ==
                                                                sizeof( ULONGLONG ) );

            ULONGLONG* pQWORDAsIs = (ULONGLONG*) ( (LPBYTE) &m_GlobalCounters
                         + g_aIISGlobalMaxDescriptions[PropMaxId].DisplayOffset );

            ULONGLONG* pQWORDToSwapWith =  (ULONGLONG*) ( (LPBYTE) &m_MaxGlobalCounters
                         + g_aIISGlobalMaxDescriptions[PropMaxId].SafetyOffset );


            if ( *pQWORDAsIs < *pQWORDToSwapWith )
            {
                //
                // We have seen a max that is greater than the
                // max we are now viewing.
                //
                *pQWORDAsIs = *pQWORDToSwapWith;
            }
            else
            {
                //
                // We have a new max so save it in the safety structure
                //
                *pQWORDToSwapWith = *pQWORDAsIs;
            }

        }  // end of decision on which size of data we are dealing with

    } // end of for loop

} // end of PERF_MANAGER::AdjustMaxValues


/***************************************************************************++

Routine Description:

    Routine clears out the appropriate global values so that we are
    ready to gather perf counters again.

Arguments:

    None.

Return Value:

    None

--***************************************************************************/
VOID
PERF_MANAGER::ClearAppropriatePerfValues()
{
    HTTP_PROP_DESC* pInputPropDesc = NULL;
    PROP_MAP*       pPropMap = NULL;
    DWORD           MaxCounters = 0;
    DWORD           PropInputId = 0;
    DWORD           PropDisplayId = 0;
    LPVOID          pCounterBlock = &m_GlobalCounters;

    DBG_ASSERT ( m_State == GatheringPerfManagerState );

    //
    // First walk through the WP Counters and Zero appropriately
    //
    pInputPropDesc = aIISWPGlobalDescription;
    pPropMap = g_aIISWPGlobalMappings;
    MaxCounters = g_cIISWPGlobalMappings;

    for (   PropDisplayId = 0 ;
            PropDisplayId < MaxCounters;
            PropDisplayId++ )
    {
        PropInputId = pPropMap[PropDisplayId].PropInputId;

        if ( pInputPropDesc[PropInputId].WPZeros == FALSE )
        {
            if ( pInputPropDesc[PropInputId].Size == sizeof ( DWORD ) )
            {
                *((DWORD*)( (LPBYTE) pCounterBlock + pPropMap[PropDisplayId].PropDisplayOffset )) = 0;
            }
            else // Handle QWORD
            {
                DBG_ASSERT ( pInputPropDesc[PropInputId].Size == sizeof ( ULONGLONG ) );

                *((ULONGLONG*)( (LPBYTE) pCounterBlock + pPropMap[PropDisplayId].PropDisplayOffset )) = 0;
            }
        }
    }

    //
    // Now walk through the UL Counters and Zero appropriately
    //
    pInputPropDesc = aIISULGlobalDescription;
    pPropMap = g_aIISULGlobalMappings;
    MaxCounters = g_cIISULGlobalMappings;

    for (   PropDisplayId = 0 ;
            PropDisplayId < MaxCounters;
            PropDisplayId++ )
    {
        PropInputId = pPropMap[PropDisplayId].PropInputId;

        if ( pInputPropDesc[PropInputId].WPZeros == FALSE )
        {
            if ( pInputPropDesc[PropInputId].Size == sizeof ( DWORD ) )
            {
                *((DWORD*)( (LPBYTE) pCounterBlock + pPropMap[PropDisplayId].PropDisplayOffset )) = 0;
            }
            else // Handle QWORD
            {
                DBG_ASSERT ( pInputPropDesc[PropInputId].Size == sizeof ( ULONGLONG ) );

                *((ULONGLONG*)( (LPBYTE) pCounterBlock + pPropMap[PropDisplayId].PropDisplayOffset )) = 0;
            }
        }
    }


} // end of PERF_MANAGER::ClearAppropriatePerfValues

/***************************************************************************++

Routine Description:

    Start a perf counter timer to make sure we don't wait forever for
    counters to be returned.  If any worker process does not return in
    the time allowed then there numbers will be left out of the total.

Arguments:

Return Value:

    VOID

--***************************************************************************/

VOID
PERF_MANAGER::BeginPerfCounterGatheringTimer(
    )
{

    HRESULT hr = S_OK;
    NTSTATUS Status = STATUS_SUCCESS;

    DBG_ASSERT( GetWebAdminService()->GetSharedTimerQueue() != NULL );

    DBG_ASSERT( m_PerfCounterGatheringTimerHandle == NULL );

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Beginning perf counter gathering timer\n"
            ));
    }

    Status = RtlCreateTimer(
                    GetWebAdminService()->GetSharedTimerQueue(),
                                                            // timer queue
                    &m_PerfCounterGatheringTimerHandle,     // returned timer handle
                    PerfCounterGatheringTimerCallback,      // callback function
                    this,                                   // context
                    PERF_COUNTER_GATHERING_TIMER_PERIOD,    // initial firing time
                    0,                                      // subsequent firing period
                    WT_EXECUTEINWAITTHREAD                  // execute callback directly
                    );

    if ( ! NT_SUCCESS ( Status ) )
    {

        hr = HRESULT_FROM_NT( Status );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not create perf counter gathering timer\n"
            ));


        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_PERF_COUNTER_GATHER_TIMER_BEGIN_FAILURE,               // message id
                0,                                            // count of strings
                NULL,                                         // array of strings
                hr                                            // error code
                );

    }

}   // PERF_MANAGER::BeginPerfCounterGatheringTimer



/***************************************************************************++

Routine Description:

    Stop the perf counter gathering timer, if present

Arguments:

Return Value:

    VOID

--***************************************************************************/

VOID
PERF_MANAGER::CancelPerfCounterGatheringTimer(
    )
{

    HRESULT hr = S_OK;
    NTSTATUS Status = STATUS_SUCCESS;


    DBG_ASSERT( GetWebAdminService()->GetSharedTimerQueue() != NULL );

    //
    // If the timer is not present, we're done here.
    //

    if ( m_PerfCounterGatheringTimerHandle == NULL )
    {
        return;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Cancelling perf counter timer\n"
            ));
    }


    //
    // Note that we wait for any running timer callbacks to finish.
    // Otherwise, there could be a race where the callback runs after
    // this worker process instance has been deleted, and so gives out
    // a bad pointer.
    //

    Status = RtlDeleteTimer(
                    GetWebAdminService()->GetSharedTimerQueue(),
                                                          // the owning timer queue
                    m_PerfCounterGatheringTimerHandle,             // timer to cancel
                    INVALID_HANDLE_VALUE                  // wait for callbacks to finish
                    );

    if ( ! NT_SUCCESS ( Status ) )
    {
        hr = HRESULT_FROM_NT( Status );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not cancel perf counter gathering timer\n"
            ));

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_PERF_COUNTER_GATHER_TIMER_CANCEL_FAILURE,               // message id
                0,                                            // count of strings
                NULL,                                         // array of strings
                hr                                            // error code
                );

        return;
    }

    m_PerfCounterGatheringTimerHandle = NULL;

}   // PERF_MANAGER::CancelPerfCounterGatheringTimer

/***************************************************************************++

Routine Description:

    Start the perf counter timer, to make sure we are gathering counters
    ever so often regardless of whether or not they are being asked for.

    This is so we do not lose too many counters if a process crashes.  We will
    not lose any counters on a regular shutdown because the process will
    deliver it's counters before it shutsdown.

Arguments:

Return Value:

    VOID

--***************************************************************************/

VOID
PERF_MANAGER::BeginPerfCounterTimer(
    )
{

    HRESULT hr = S_OK;
    NTSTATUS Status = STATUS_SUCCESS;


    DBG_ASSERT( GetWebAdminService()->GetSharedTimerQueue() != NULL );

    DBG_ASSERT( m_PerfCounterTimerHandle == NULL );


    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Beginning perf counter gathering timer\n"
            ));
    }


    Status = RtlCreateTimer(
                    GetWebAdminService()->GetSharedTimerQueue(),
                                                            // timer queue
                    &m_PerfCounterTimerHandle,              // returned timer handle
                    PerfCounterTimerCallback,               // callback function
                    this,                                   // context
                    PERF_COUNTER_TIMER_PERIOD,              // initial firing time
                    PERF_COUNTER_TIMER_PERIOD,              // subsequent firing period
                    WT_EXECUTEINWAITTHREAD                  // execute callback directly
                    );

    if ( ! NT_SUCCESS ( Status ) )
    {
        hr = HRESULT_FROM_NT( Status );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not create perf counter timer\n"
            ));

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_PERF_COUNTER_TIMER_FAILURE,               // message id
                0,                                            // count of strings
                NULL,                                         // array of strings
                hr                                            // error code
                );
    }


}   // PERF_MANAGER::BeginPerfCounterTimer

/***************************************************************************++

Routine Description:

    Stop the perf counter timer, if present

Arguments:

Return Value:

    VOID

--***************************************************************************/

VOID
PERF_MANAGER::CancelPerfCounterTimer(
    )
{

    HRESULT hr = S_OK;
    NTSTATUS Status = STATUS_SUCCESS;


    DBG_ASSERT( GetWebAdminService()->GetSharedTimerQueue() != NULL );


    //
    // If the timer is not present, we're done here.
    //

    if ( m_PerfCounterTimerHandle == NULL )
    {
        return;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Cancelling perf counter timer\n"
            ));
    }


    //
    // Note that we wait for any running timer callbacks to finish.
    // Otherwise, there could be a race where the callback runs after
    // this worker process instance has been deleted, and so gives out
    // a bad pointer.
    //

    Status = RtlDeleteTimer(
                    GetWebAdminService()->GetSharedTimerQueue(),
                                                          // the owning timer queue
                    m_PerfCounterTimerHandle,             // timer to cancel
                    INVALID_HANDLE_VALUE                  // wait for callbacks to finish
                    );

    if ( ! NT_SUCCESS ( Status ) )
    {
        hr = HRESULT_FROM_NT( Status );

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_PERF_COUNTER_TIMER_CANCEL_FAILURE,               // message id
                0,                                            // count of strings
                NULL,                                         // array of strings
                hr                                            // error code
                );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not cancel perf counter timer\n"
            ));

        return;
    }

    m_PerfCounterTimerHandle = NULL;


}   // PERF_MANAGER::CancelPerfCounterTimer


//
// Private (debug) PERF_MANAGER functions
//

/***************************************************************************++

Routine Description:

    Debug dumps all the UL Cache counters exactly as retrieved from UL.

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_MANAGER::DumpULGlobalCounters(
    HTTP_GLOBAL_COUNTERS* pCounters
    )
{
    DBG_ASSERT (pCounters);

    UNREFERENCED_PARAMETER( pCounters);
    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "UL Counters for global\n"
            "   :  CurrentUrisCached %d\n"
            "   :  TotalUrisCached %d\n"
            "   :  UriCacheHits %d\n"
            "   :  UriCacheMisses %d\n"
            "   :  UriCacheFlushes %d\n"
            "   :  TotalFlushedUris %d\n",
            pCounters->CurrentUrisCached,
            pCounters->TotalUrisCached,
            pCounters->UriCacheHits,
            pCounters->UriCacheMisses,
            pCounters->UriCacheFlushes,
            pCounters->TotalFlushedUris
            ));

    }
}

/***************************************************************************++

Routine Description:

    Debug dumps all the UL Site counters exactly as retrieved from UL.

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_MANAGER::DumpULSiteCounters(
    HTTP_SITE_COUNTERS* pCounters
    )
{
    DBG_ASSERT (pCounters);

    UNREFERENCED_PARAMETER( pCounters);
    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {

        DBGPRINTF((
            DBG_CONTEXT,
            "UL Counters for site %d\n"
            "   :  BytesSent %I64d\n"
            "   :  BytesReceived %I64d\n"
            "   :  BytesTransfered %I64d\n"
            "   :  CurrentConns %d\n"
            "   :  MaxConnections %d\n"
            "   :  ConnAttempts %d\n"
            "   :  GetReqs %d\n"
            "   :  HeadReqs %d\n"
            "   :  AllReqs %d\n"
            "   :  MeasuredIoBandwidthUsage %d\n"
            "   :  CurrentBlockedBandwidthBytes %d\n"
            "   :  TotalBlockedBandwidthBytes %d\n\n",
            pCounters->SiteId,
            pCounters->BytesSent,
            pCounters->BytesReceived,
            pCounters->BytesTransfered,
            pCounters->CurrentConns,
            pCounters->MaxConnections,
            pCounters->ConnAttempts,
            pCounters->GetReqs,
            pCounters->HeadReqs,
            pCounters->AllReqs,
            pCounters->MeasuredIoBandwidthUsage,
            pCounters->CurrentBlockedBandwidthBytes,
            pCounters->TotalBlockedBandwidthBytes
            ));

    }

}

/***************************************************************************++

Routine Description:

    Debug dumps all the WP Cache counters exactly as retrieved from UL.

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_MANAGER::DumpWPGlobalCounters(
    IISWPGlobalCounters* pCounters
    )
{
    DBG_ASSERT (pCounters);

    UNREFERENCED_PARAMETER( pCounters);
    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "WP Counters for global\n"
            "   :   CurrentFilesCached %d \n"
            "   :   TotalFilesCached %d \n"
            "   :   FileCacheHits %d \n"
            "   :   FileCacheMisses %d \n"
            "   :   FileCacheFlushes %d \n"
            "   :   CurrentFileCacheMemoryUsage %I64d \n"
            "   :   MaxFileCacheMemoryUsage %I64d \n"
            "   :   ActiveFlushedFiles %d \n"
            "   :   TotalFlushedFiles %d \n"
            "   :   CurrentUrisCached %d \n"
            "   :   TotalUrisCached %d \n"
            "   :   UriCacheHits %d \n"
            "   :   UriCacheMisses %d \n"
            "   :   UriCacheFlushes %d \n"
            "   :   TotalFlushedUris %d \n"
            "   :   CurrentBlobsCached %d \n"
            "   :   TotalBlobsCached %d \n"
            "   :   BlobCacheHits %d \n"
            "   :   BlobCacheMisses %d \n"
            "   :   BlobCacheFlushes %d \n"
            "   :   TotalFlushedBlobs %d \n",
            pCounters-> CurrentFilesCached,
            pCounters-> TotalFilesCached,
            pCounters-> FileCacheHits,
            pCounters-> FileCacheMisses,
            pCounters-> FileCacheFlushes,
            pCounters-> CurrentFileCacheMemoryUsage,
            pCounters-> MaxFileCacheMemoryUsage,
            pCounters-> ActiveFlushedFiles,
            pCounters-> TotalFlushedFiles,
            pCounters-> CurrentUrisCached,
            pCounters-> TotalUrisCached,
            pCounters-> UriCacheHits,
            pCounters-> UriCacheMisses,
            pCounters-> UriCacheFlushes,
            pCounters-> TotalFlushedUris,
            pCounters-> CurrentBlobsCached,
            pCounters-> TotalBlobsCached,
            pCounters-> BlobCacheHits,
            pCounters-> BlobCacheMisses,
            pCounters-> BlobCacheFlushes,
            pCounters-> TotalFlushedBlobs
            ));

    }



}

/***************************************************************************++

Routine Description:

    Debug dumps all the WP Site counters exactly as retrieved from UL.

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_MANAGER::DumpWPSiteCounters(
    IISWPSiteCounters* pCounters
    )
{
    DBG_ASSERT (pCounters);

    UNREFERENCED_PARAMETER( pCounters);
    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {

        DBGPRINTF((
            DBG_CONTEXT,
            "WP Counters for site %d\n"
            "   :  FilesSent  %d\n"
            "   :  FilesReceived  %d\n"
            "   :  FilesTransferred  %d\n"
            "   :  CurrentAnonUsers  %d\n"
            "   :  CurrentNonAnonUsers  %d\n"
            "   :  AnonUsers  %d\n"
            "   :  NonAnonUsers  %d\n"
            "   :  MaxAnonUsers  %d\n"
            "   :  MaxNonAnonUsers  %d\n"
            "   :  LogonAttempts  %d\n"
            "   :  GetReqs  %d\n"
            "   :  OptionsReqs  %d\n"
            "   :  PostReqs  %d\n"
            "   :  HeadReqs  %d\n"
            "   :  PutReqs  %d\n"
            "   :  DeleteReqs  %d\n"
            "   :  TraceReqs  %d\n"
            "   :  MoveReqs  %d\n"
            "   :  CopyReqs  %d\n"
            "   :  MkcolReqs  %d\n"
            "   :  PropfindReqs  %d\n"
            "   :  ProppatchReqs  %d\n"
            "   :  SearchReqs  %d\n"
            "   :  LockReqs  %d\n"
            "   :  UnlockReqs  %d\n"
            "   :  OtherReqs  %d\n"
            "   :  CurrentCgiReqs  %d\n"
            "   :  CgiReqs  %d\n"
            "   :  MaxCgiReqs  %d\n"
            "   :  CurrentIsapiExtReqs  %d\n"
            "   :  IsapiExtReqs  %d\n"
            "   :  MaxIsapiExtReqs  %d\n",
            pCounters->SiteID,
            pCounters->FilesSent,
            pCounters->FilesReceived,
            pCounters->FilesTransferred,
            pCounters->CurrentAnonUsers,
            pCounters->CurrentNonAnonUsers,
            pCounters->AnonUsers,
            pCounters->NonAnonUsers,
            pCounters->MaxAnonUsers,
            pCounters->MaxNonAnonUsers,
            pCounters->LogonAttempts,
            pCounters->GetReqs,
            pCounters->OptionsReqs,
            pCounters->PostReqs,
            pCounters->HeadReqs,
            pCounters->PutReqs,
            pCounters->DeleteReqs,
            pCounters->TraceReqs,
            pCounters->MoveReqs,
            pCounters->CopyReqs,
            pCounters->MkcolReqs,
            pCounters->PropfindReqs,
            pCounters->ProppatchReqs,
            pCounters->SearchReqs,
            pCounters->LockReqs,
            pCounters->UnlockReqs,
            pCounters->OtherReqs,
            pCounters->CurrentCgiReqs,
            pCounters->CgiReqs,
            pCounters->MaxCgiReqs,
            pCounters->CurrentIsapiExtReqs,
            pCounters->IsapiExtReqs,
            pCounters->MaxIsapiExtReqs
            ));

    }
}

//
// global routines
//

/***************************************************************************++

Routine Description:

    Routine is launched on the perf counter thread.  It will spin until
    it is told to shutdown by the PERF_MANAGER termination routine.

Arguments:

    LPVOID lpParameter - Pointer to PERF_MANAGER.

Return Value:

    HRESULT

--***************************************************************************/
DWORD WINAPI PerfCountPing(
    LPVOID lpParameter
    )
{
    PERF_MANAGER* pManager = (PERF_MANAGER*) lpParameter;

    DBG_ASSERT (pManager);

    PERF_MANAGER_STATE state = pManager->GetPerfState();

    // Wait on the WASPerfCountEvent
    // If we are in shutdown mode just end, otherwise
    // tick off a gathering of perf counters (if we
    // are not all ready gathering) and then wait again.

    while ( state != TerminatingPerfManagerState )
    {

        pManager->WaitOnPerfEvent();

        //
        // Get the new state so we know if we should
        // continue processing or not.
        //
        state = pManager->GetPerfState();

        //
        // Since we are still running we need
        // to start up the W3WP code now.
        //
        // The function on the main thread will determine
        // if we actually want to gather now or just dismiss
        // the request.
        //
        if ( state != TerminatingPerfManagerState )
        {
            //
            // Ignoring a failure here, if we can not
            // add this, then we are just not going to
            // collect counters.
            //
            QueueWorkItemFromSecondaryThread(
                       reinterpret_cast<WORK_DISPATCH*>( pManager ),
                       PerfCounterPingFiredWorkItem
                );
        }
    }

    return ERROR_SUCCESS;
}

/***************************************************************************++

Routine Description:

    The callback function invoked by the perf counter timer. It simply
    posts a work item for the main worker thread.

Arguments:

    Context - A context value, used to pass the "this" pointer of the
    PERF_MANAGER object.

    Ignored - Ignored.

Return Value:

    None.

--***************************************************************************/

VOID
PerfCounterTimerCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    )
{

    UNREFERENCED_PARAMETER( Ignored );

    DBG_ASSERT ( Context != NULL );

    PERF_MANAGER* pManager = reinterpret_cast<PERF_MANAGER*>( Context );

    UNREFERENCED_PARAMETER( pManager );
    DBG_ASSERT ( pManager->CheckSignature() );


    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "About to create/queue work item for perf "
            "counters to be gathered (timer fired) (ptr: %p)\n",
            pManager
            ));
    }

    //
    // Ignoring a failure here, if we can not
    // add this, then we are just not going to
    // collect counters.
    //

    QueueWorkItemFromSecondaryThread(
        reinterpret_cast<WORK_DISPATCH*>( Context ),
        PerfCounterPingFiredWorkItem
        );


    return;

}   // PerfCounterTimerCallback

/***************************************************************************++

Routine Description:

    The callback function invoked by the perf counter gathering timer. It
    posts a work item for the main worker thread.

Arguments:

    Context - A context value, used to pass the "this" pointer of the
    PERF_MANAGER object.

    Ignored - Ignored.

Return Value:

    None.

--***************************************************************************/

VOID
PerfCounterGatheringTimerCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    )
{

    UNREFERENCED_PARAMETER( Ignored );

    DBG_ASSERT ( Context != NULL );

    PERF_MANAGER* pManager = reinterpret_cast<PERF_MANAGER*>( Context );

    UNREFERENCED_PARAMETER( pManager );
    DBG_ASSERT ( pManager->CheckSignature() );

    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "About to create/queue work item for perf "
            "counters to be gathered (timer fired) (ptr: %p)\n",
            pManager
            ));
    }

    //
    // Ignoring a failure here, if we can not
    // add this, then we are just not going to
    // collect counters.
    //

    QueueWorkItemFromSecondaryThread(
        reinterpret_cast<WORK_DISPATCH*>( Context ),
        PerfCounterGatheringTimerFiredWorkItem
        );


    return;

}   // PerfCounterGatheringTimerCallback


/***************************************************************************++

Routine Description:

    Supporting function that alters the security of the process to
    allow the perf lib processes to monitor when this process goes away.

    Allowed to wait are:

        Power Users
        Sys Ops
        Perf Mon Users
        Perf Log Users

Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT
AdjustProcessSecurityToAllowPowerUsersToWait(
    )
{
    HRESULT hr = S_OK;
    DWORD   dwErr = ERROR_SUCCESS;
    EXPLICIT_ACCESS ea[4];
    PSID psidPowerUser = NULL;
    PSID psidSystemOperator = NULL;
    PSID psidPerfMonUser = NULL;
    PSID psidPerfLogUser = NULL;
    PACL pNewDACL = NULL;
    PACL pOldDACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    HANDLE hProcess = GetCurrentProcess();

    //
    // Get a sid that represents the POWER_USERS group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinPowerUsersSid,
                                        &psidPowerUser );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Creating Power User SID failed\n"
            ));

        goto exit;
    }


    //
    // Get a sid that represents the SYSTEM_OPERATORS group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinSystemOperatorsSid,
                                        &psidSystemOperator );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Creating System Operators SID failed\n"
            ));

        goto exit;
    }

    //
    // Get a sid that represents the PERF LOG USER group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinPerfLoggingUsersSid,
                                        &psidPerfLogUser );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Creating perf log user SID failed\n"
            ));

        goto exit;
    }

    //
    // Get a sid that represents the PERF MON USER group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinPerfMonitoringUsersSid,
                                        &psidPerfMonUser );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Creating perf mon user SID failed\n"
            ));

        goto exit;
    }

    //
    // Now Get the SD for the Process.
    //

    //
    // The pOldDACL is just a pointer into memory owned
    // by the pSD, so only free the pSD.
    //
    dwErr = GetSecurityInfo( hProcess,
                                  SE_KERNEL_OBJECT,
                                  DACL_SECURITY_INFORMATION,
                                  NULL,        // owner SID
                                  NULL,        // primary group SID
                                  &pOldDACL,   // PACL*
                                  NULL,        // PACL*
                                  &pSD );      // Security Descriptor
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32(dwErr);

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not get security info for the current process \n"
            ));

        goto exit;
    }

    // Initialize an EXPLICIT_ACCESS structure for the new ACE.

    SecureZeroMemory(ea, sizeof(ea));
    SetExplicitAccessSettings(  &(ea[0]),
                                SYNCHRONIZE,
                                GRANT_ACCESS,
                                psidPowerUser );

    SetExplicitAccessSettings(  &(ea[1]),
                                SYNCHRONIZE,
                                GRANT_ACCESS,
                                psidSystemOperator );

    SetExplicitAccessSettings(  &(ea[2]),
                                SYNCHRONIZE,
                                GRANT_ACCESS,
                                psidPerfMonUser );

    SetExplicitAccessSettings(  &(ea[3]),
                                SYNCHRONIZE,
                                GRANT_ACCESS,
                                psidPerfLogUser );

    //
    // Add the power user acl to the list.
    //
    dwErr = SetEntriesInAcl(sizeof(ea)/sizeof(EXPLICIT_ACCESS),
                            ea,
                            pOldDACL,
                            &pNewDACL);

    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not set Acls into security descriptor \n"
            ));

        goto exit;
    }

    //
    // Attach the new ACL as the object's DACL.
    //
    dwErr = SetSecurityInfo(hProcess,
                                  SE_KERNEL_OBJECT,
                                  DACL_SECURITY_INFORMATION,  // SecurityInfo flag
                                  NULL,  // Not setting because not specified by SecurityInfo flag to be set.
                                  NULL,  // Not setting because not specified by SecurityInfo flag to be set.
                                  pNewDACL,
                                  NULL); // Not setting because not specified by SecurityInfo flag to be set.
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not set process security info \n"
            ));

        goto exit;
    }

exit:

    FreeWellKnownSid(&psidPowerUser);
    FreeWellKnownSid(&psidSystemOperator);
    FreeWellKnownSid(&psidPerfLogUser);
    FreeWellKnownSid(&psidPerfMonUser);

    if( pSD != NULL )
    {
        LocalFree((HLOCAL) pSD);
        pSD = NULL;
    }

    if( pNewDACL != NULL )
    {
        LocalFree((HLOCAL) pNewDACL);
        pNewDACL = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\perf_manager.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    perf_manager.h

Abstract:

    The IIS web admin service perf manager class definition.

Author:

    Emily Kruglick (EmilyK)        29-Aug-2000

Revision History:

--*/


#ifndef _PERF_MANAGER_H_
#define _PERF_MANAGER_H_



//
// common #defines
//

#define PERF_MANAGER_SIGNATURE        CREATE_SIGNATURE( 'PRFC' )
#define PERF_MANAGER_SIGNATURE_FREED  CREATE_SIGNATURE( 'prfX' )

#define PERF_COUNTER_TIMER_PERIOD ( 300 * ONE_SECOND_IN_MILLISECONDS )  // 5 minutes

#define PERF_COUNTER_GATHERING_TIMER_PERIOD ( 60 * ONE_SECOND_IN_MILLISECONDS )  // 1 minute

//
// structs, enums, etc.
//

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Holding spot for the maximum cache counters.
//
struct GLOBAL_MAX_DATA
{
    ULONGLONG MaxFileCacheMemoryUsage;
};

//
// Perf manager state
// 
enum PERF_MANAGER_STATE
{

    //
    // Has not been initialized yet.
    // 
    UninitializedPerfManagerState = 1,

    //
    // Has been initialized and has
    // data waiting for the grabbing
    // and is not in the middle of updating
    // the counter values.
    //
    IdlePerfManagerState,

    //
    // Is in the middle of grabbing new
    // perf counter data from the worker 
    // processes and from UL.  
    //
    GatheringPerfManagerState,

    //
    // We have started the shutdown phase
    // this object will do no more work but
    // clean it'self up and die.
    //
    TerminatingPerfManagerState,

};

// PERF_MANAGER work items
enum PERF_MANAGER_WORK_ITEM
{

    //
    // Time to gather performance counters.
    //
    PerfCounterPingFiredWorkItem = 1,

    //
    // Timer fired to finish collecting perf counters.
    //
    PerfCounterGatheringTimerFiredWorkItem

};

//
// prototypes
//

class PERF_MANAGER
    : public WORK_DISPATCH
{
public:

    PERF_MANAGER(
        );

    virtual
    ~PERF_MANAGER(
        );

    virtual
    VOID
    Reference(
        );

    virtual
    VOID
    Dereference(
        );

    virtual
    HRESULT
    ExecuteWorkItem(
        IN const WORK_ITEM * pWorkItem
        );


    HRESULT
    Initialize(
        );

    VOID
    Terminate(
        );

    VOID
    SetupVirtualSite(
        IN VIRTUAL_SITE* pVirtualSite
        );

    VOID
    SetupTotalSite(
        IN BOOL          StructChanged
        );

    HRESULT
    Shutdown(
        );

    PERF_MANAGER_STATE
    GetPerfState(
        )
    { return m_State; };

    BOOL 
    RecordCounters(
        IN DWORD MessageLength,
        IN const BYTE* pMessageData
        );

    BOOL
    CheckSignature(
        )
    { return (m_Signature == PERF_MANAGER_SIGNATURE); }

    VOID
    WaitOnPerfEvent(
        )
    {
        m_SharedManager.WaitOnPerfEvent();
    }

private:

    VOID
    DumpWPSiteCounters(
        IISWPSiteCounters* pCounters
        );

    VOID 
    DumpWPGlobalCounters(
        IISWPGlobalCounters* pCounters
        );

    VOID
    DumpULGlobalCounters(
        HTTP_GLOBAL_COUNTERS* pCounters
        );

    VOID 
    DumpULSiteCounters(
        HTTP_SITE_COUNTERS* pCounters
        );

    HRESULT
    LaunchPerfCounterWaitingThread(
        );

    VOID
    ProcessPerfCounterPingFired(
        );

    VOID
    RequestWorkerProcessGatherCounters(
        );

    VOID
    RequestAndProcessULCounters(
        );

    VOID
    CompleteCounterUpdate(
        );

    VOID
    FindAndAggregateSiteCounters(
        COUNTER_SOURCE_ENUM CounterSource,
        DWORD SiteId,
        IN LPVOID pCounters
        );

    VOID
    AggregateGlobalCounters(
        COUNTER_SOURCE_ENUM CounterSource,
        IN LPVOID pCounters
        );

    VOID
    ReportGlobalPerfInfo(
        );

    VOID
    ClearAppropriatePerfValues(
        );

    VOID 
    DecrementWaitingProcesses(
        );

    VOID
    BeginPerfCounterTimer(
        );

    VOID
    CancelPerfCounterTimer(
        );

    VOID
    BeginPerfCounterGatheringTimer(
        );

    VOID
    CancelPerfCounterGatheringTimer(
        );

    VOID
    ProcessPerfCounterGatheringTimerFired(
        );

    VOID
    AdjustMaxValues(
        );

    HRESULT
    RequestSiteHttpCounters(
        HANDLE hControlChannel,
        DWORD* pSpaceNeeded,
        DWORD* pNumInstances
        );

    HRESULT
    SizeHttpSitesBuffer(
        DWORD* pSpaceNeeded
        );

    VOID 
    RecordHttpSiteCounters(
        DWORD SizeOfBuffer,
        DWORD NumInstances
        );


    DWORD m_Signature;

    // Only changeable on the main thread
    PERF_MANAGER_STATE m_State;

    LONG m_RefCount;

    //
    // Shared Manager for counter shared memory.
    //
    PERF_SM_MANAGER m_SharedManager;

    //
    // Handle to the pref count thread
    // that is waiting on pings to request 
    // counter refreshes.
    //
    HANDLE m_hPerfCountThread;

    //
    // The Thread Id for the perf thread
    //
    DWORD  m_PerfCountThreadId;

    //
    // Contains the number of processes
    // we are waiting to hear from.
    //
    DWORD m_NumProcessesToWaitFor;

    //
    // saftey for global counters;
    W3_GLOBAL_COUNTER_BLOCK m_GlobalCounters;

    //
    // saftey for max values.
    GLOBAL_MAX_DATA m_MaxGlobalCounters;

    //
    // Handle to the timer that is causing us to gather counters.
    //
    HANDLE m_PerfCounterTimerHandle;

    //
    // Handle to the timer that is causing us to finish gather counters
    // if the wp's are not responsive enough.
    //
    HANDLE m_PerfCounterGatheringTimerHandle;

    //
    // Block of memory for retrieving site counters from HTTP.SYS.
    //

    LPBYTE m_pHttpSiteBuffer;

    //
    // Size (bytes) of the site counter retrieval block.
    //
    DWORD m_HttpSiteBufferLen;

    // 
    // These two member variables must be initalized in a SetupTotal
    // call before being used in the SetupInstance calls that follow.
    //
    //
    // Holds the next valid offset to start counters at, for use
    // during copying of counters to shared memory.
    //
    ULONG m_NextValidOffset;

    //
    // Rememmbers if instance numbers or definitions have changed 
    // since last gathering.  If they have then during the current
    // gathering all counter offsets must be recalcualated.
    //
    BOOL m_InstanceInfoHaveChanged;

};  // class PERF_MANAGER



#endif  // _PERF_MANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\messaging_handler.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    messaging_handler.h

Abstract:

    The IIS web admin service message handling class definition. This
    is used for interacting with the IPM (inter-process messaging) support, 
    in order to send and receive messages, and so forth. 

Author:

    Seth Pollack (sethp)        02-Mar-1999

Revision History:

--*/


#ifndef _MESSAGING_HANDLER_H_
#define _MESSAGING_HANDLER_H_



//
// forward references
//

class WORKER_PROCESS;



//
// common #defines
//

#define MESSAGING_HANDLER_SIGNATURE        CREATE_SIGNATURE( 'MSGH' )
#define MESSAGING_HANDLER_SIGNATURE_FREED  CREATE_SIGNATURE( 'msgX' )



//
// prototypes
//

class MESSAGING_WORK_ITEM
{
private:
    IPM_OPCODE  m_opcode;
    BYTE *      m_pbData;
    DWORD       m_dwDataLen;
    BOOL        m_fMessageValid;
    
public:
    MESSAGING_WORK_ITEM()
    {
        m_opcode = IPM_OP_MAXIMUM;
        m_pbData = NULL;
        m_dwDataLen = 0;
        m_fMessageValid = FALSE;
    }

    virtual ~MESSAGING_WORK_ITEM()
    {
        delete[] m_pbData;
        m_pbData = NULL;
        
        m_dwDataLen = 0;
        m_opcode = IPM_OP_MAXIMUM;
        m_fMessageValid = FALSE;
    }

    HRESULT
    SetData(IPM_OPCODE opcode, DWORD dwDataLen, const BYTE * pbData)
    {
        DBG_ASSERT(NULL == m_pbData);
        m_pbData = new BYTE[dwDataLen];
        if ( NULL == m_pbData )
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }

        m_opcode = opcode;
        m_dwDataLen = dwDataLen;

        memcpy(m_pbData, pbData, dwDataLen);

        m_fMessageValid = TRUE;
        
        return S_OK;
    }

    IPM_OPCODE GetOpcode() const { return m_opcode; }
    const BYTE * GetData() const { return m_pbData; }
    DWORD GetDataLen() const { return m_dwDataLen; }
    BOOL IsMessageValid() const { return m_fMessageValid; }
}; // MESSAGING_WORK_ITEM

    
class MESSAGING_HANDLER :
    public IPM_MESSAGE_ACCEPTOR,
    public WORK_DISPATCH
{

public:

    MESSAGING_HANDLER(
       );

    virtual
    ~MESSAGING_HANDLER(
        );

    HRESULT
    Initialize(
        IN WORKER_PROCESS * pWorkerProcess
        );

    VOID
    Terminate(
        );


    //
    // WORK_DISPATCH methods.
    //

    virtual
    HRESULT 
    ExecuteWorkItem(IN const WORK_ITEM * pWorkItem);

    virtual
    VOID 
    Reference();

    virtual
    VOID
    Dereference();
    
    //
    // MESSAGE_ACCEPTOR methods.
    //
    
    virtual
    VOID
    AcceptMessage(
        IN const IPM_MESSAGE * pMessage
        );

    virtual
    VOID
    PipeConnected(
        );
        
    virtual
    VOID
    PipeDisconnected(
        IN HRESULT Error
        );

    virtual
    VOID
    PipeMessageInvalid(
        );

    //
    // for WORKER_PROCESS
    // 

    LPWSTR
    QueryPipeName()
    {
        return m_PipeName.QueryStr();
    }

    //
    // Messages to send.
    //

    HRESULT
    SendPing(
        );

    HRESULT
    RequestCounters(
        );

    HRESULT
    SendShutdown(
        IN BOOL ShutdownImmediately
        );

    HRESULT
    SendPeriodicProcessRestartPeriodInMinutes(
        IN DWORD PeriodicProcessRestartPeriodInMinutes
        );
       
    HRESULT
    SendPeriodicProcessRestartSchedule(
        IN LPWSTR pPeriodicProcessRestartSchedule
        );

    HRESULT
    SendPeriodicProcessRestartMemoryUsageInKB(
        IN DWORD PeriodicProcessRestartMemoryUsageInKB,
        IN DWORD PeriodicProcessRestartPrivateBytesInKB
        );

    //
    // Handle received messages. 
    //

    VOID
    HandlePingReply(
        IN const MESSAGING_WORK_ITEM * pMessage
        );

    VOID
    HandleShutdownRequest(
        IN const MESSAGING_WORK_ITEM * pMessage
        );

    VOID
    HandleCounters(
        IN const MESSAGING_WORK_ITEM * pMessage
        );

    VOID
    HandleHresult(
        IN const MESSAGING_WORK_ITEM * pMessage
        );

    VOID
    HandleGetPid(
        IN const MESSAGING_WORK_ITEM * pMessage
        );
    
    VOID
    PipeDisconnectedMainThread(
        IN HRESULT Error
        );

    VOID
    PipeMessageInvalidMainThread(
        );
    
private:

    HRESULT
    SendMessage(
        IN enum IPM_OPCODE  opcode,
        IN DWORD            dwDataLen,
        IN BYTE *           pbData 
        );

    DWORD m_Signature;

    IPM_MESSAGE_PIPE * m_pPipe;

    WORKER_PROCESS * m_pWorkerProcess;

    STRU m_PipeName;

    LONG m_RefCount;

    HRESULT m_hrPipeError;
};  // class MESSAGING_HANDLER



#endif  // _MESSAGING_HANDLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\multithreadreader.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    multithreadreader.cxx

Abstract:

    A multiple thread callback helper class

Author:

    Jeffrey Wall (jeffwall) 6/5/02

Revision History:

--*/

#include "precomp.h"

MULTIPLE_THREAD_READER::MULTIPLE_THREAD_READER()
        : _cProcessors( 0 ),
          _cCurrentProcessor( 0 ),
          _pmszString( NULL ),
          _pCallback( NULL )
{
}
MULTIPLE_THREAD_READER::~MULTIPLE_THREAD_READER()
{
    DBG_ASSERT(NULL == _pCallback);
    DBG_ASSERT(NULL == _pmszString);
    DBG_ASSERT(NULL == _pCallback);
    DBG_ASSERT(0 == _cCurrentProcessor);
}

HRESULT
MULTIPLE_THREAD_READER::DoWork(
    MULTIPLE_THREAD_READER_CALLBACK * pCallback, 
    LPVOID pContext,
    WCHAR * pmszString,
    BOOL fMultiThreaded /* = TRUE */
)
/*++

Routine Description:

    Create number of processor threads
    Start the threads, wait for them to finish
    Report the first error found, otherwise S_OK

    If unable to create new threads, fallback to using the current thread
    
Arguments:

    pCallback - Interface to have threads callback on
    pContext - VOID* to pass to callback
    pmszString - MultiSz to advance through
    fMultiThreaded - whether or not to use number of processor threads

Return Value:

    S_OK if all threads succeed, otherwise first found error from callback function

--*/
{
    HANDLE                  rgHandles[ 64 ];
    BOOL fRet;
    HRESULT hr = S_OK;;
    DWORD dwExitCode;
    // Find the number of processors on this system
    SYSTEM_INFO         systemInfo;
    GetSystemInfo( &systemInfo );
    _cProcessors = systemInfo.dwNumberOfProcessors;

    // cap _cProcessors to be MAXIMUM_WAIT_OBJECTS because of limitation of WaitForMultipleObjects
    if (_cProcessors > MAXIMUM_WAIT_OBJECTS)
    {
        _cProcessors = MAXIMUM_WAIT_OBJECTS;
    }

    // Setup the data threads will need to callback
    _pmszString = pmszString;
    _pCallback = pCallback;
    _pContext = pContext;


    if (!fMultiThreaded)
    {
        // if multithreaded isn't set, don't use the number of processors
        _cProcessors = 1;
    }

    if (1 == _cProcessors)
    {
        // if we only have 1 processor, just use this thread to do the reading
        hr = ReadThread();
        goto exit;
    }
    
    //
    // create all the threads
    //
#pragma prefast(push)
#pragma prefast(disable:258, "Don't complain about the TerminateThread usage") 

    for ( DWORD i = 0; i < _cProcessors; i++ )
    {
        rgHandles[ i ] = CreateThread( NULL,
                                       // Big initial size to prevent stack overflows
                                       IIS_DEFAULT_INITIAL_STACK_SIZE,
                                       (LPTHREAD_START_ROUTINE)BeginReadThread,
                                       this,
                                       CREATE_SUSPENDED,
                                       NULL );
        if ( rgHandles[ i ] == NULL )
        {
            //
            // Clear all existing threads
            //

            for ( DWORD j = 0; j < i; i++ )
            {
                // TerminateThread use here is OK.  We created the threads suspended for exactly this reason.
                TerminateThread( rgHandles[ j ], 0 );
                CloseHandle( rgHandles[ j ] );
                rgHandles[ j ] = NULL;
            }

            //
            // Use the current thread only
            //

            _cProcessors = 1;
            hr = ReadThread();
            goto exit;
        }
    }

#pragma prefast(pop)

    //
    // Now start up the threads
    //

    for ( i = 0; i < _cProcessors; i++ )
    {
        DBG_ASSERT( rgHandles[ i ] != NULL );

        ResumeThread( rgHandles[ i ] );
    }

    //
    // Now wait for the threads to finish
    //

    WaitForMultipleObjects( _cProcessors,
                            rgHandles,
                            TRUE,
                            INFINITE );

    //
    // Get the return values for each thread
    //

    for ( i = 0; i < _cProcessors; i++ )
    {
        DBG_ASSERT( rgHandles[ i ] != NULL );

        fRet = GetExitCodeThread( rgHandles[ i ], &dwExitCode );
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        if ( dwExitCode != S_OK )
        {
            // the cast to HRESULT is because the BeginReadThread function returns an HRESULT, not a DWORD
            hr = (HRESULT) dwExitCode;
            break;
        }
    }

    //
    // Close all the thread handles
    //

    for ( i = 0; i < _cProcessors; i++ )
    {
        DBG_ASSERT( rgHandles[ i ] != NULL );

        CloseHandle( rgHandles[ i ] );
        rgHandles[ i ] = NULL;
    }
exit:
    _pmszString = NULL;
    _pCallback = NULL;
    _pContext = NULL;
    _cCurrentProcessor = 0;

    return hr;
}

WCHAR *
MULTIPLE_THREAD_READER::Advance(
        WCHAR *                     pmszString,
        DWORD                       cPlaces
    )
/*++

Routine Description:

    Advance cPlaces places

Arguments:

    pmszString - MultiSz to advance through
    cPlaces - Places to advance

Return Value:

    Position advanced to

--*/
{
    DWORD                   cCursor = 0;
    WCHAR *                 pszCursor = NULL;
    
    if ( pmszString == NULL )
    {
        DBG_ASSERT( FALSE );
        SetLastError( ERROR_INVALID_PARAMETER );
        return NULL;
    }
    
    pszCursor = pmszString;
    
    for ( cCursor = 0; cCursor < cPlaces; cCursor++ )
    {
        pszCursor += wcslen( pszCursor ) + 1;
        if ( pszCursor[ 0 ] == L'\0' )
        {
            pszCursor = NULL;
            break;
        }
    }
    
    return pszCursor;
}

// static
HRESULT
MULTIPLE_THREAD_READER::BeginReadThread(
    PVOID                   pvArg
)
/*++

Routine Description:

    static function to call real ReadThread function

Arguments:

    pvArg - pointer to this

Return Value:

    Value from ReadThread, or failure of CoInitiazeEx

--*/
{
    HRESULT hr = S_OK;

    hr = CoInitializeEx(
                NULL,                   // reserved
                COINIT_MULTITHREADED    // threading model
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing COM failed\n"
            ));

        return hr;
    }

    MULTIPLE_THREAD_READER * pThis = (MULTIPLE_THREAD_READER*)pvArg;

    hr = pThis->ReadThread();

    CoUninitialize();

    return hr;
}

HRESULT
MULTIPLE_THREAD_READER::ReadThread(
)
/*++

Routine Description:

    For each Nth string in _pmszString, call the callback function with the string

Arguments:
    void

Return Value:

    S_OK, or first error returned from callback

--*/
{
    HRESULT       hr = S_OK;
    
    DWORD         cCurrentProcessor;
    LPWSTR        pszNext;

    DBG_ASSERT(_pCallback);
    DBG_ASSERT(_pmszString);

    cCurrentProcessor = InterlockedIncrement( (LPLONG) &_cCurrentProcessor ) - 1;
    DBG_ASSERT(cCurrentProcessor < _cProcessors);
    
    pszNext = Advance( _pmszString, cCurrentProcessor );
    if ( pszNext == NULL )
    {
        goto exit;
    }

    for ( ; pszNext != NULL; pszNext = Advance( pszNext, _cProcessors ) )
    {
        hr = _pCallback->DoThreadWork( pszNext, _pContext );
        if (FAILED(hr))
        {
            goto exit;
        }
    }

    hr = S_OK;
exit:
    return hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\main.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    main.h

Abstract:

    The IIS web admin service header for the service bootstrap code.

Author:

    Seth Pollack (sethp)        04-Nov-1998

Revision History:

--*/


#ifndef _MAIN_H_
#define _MAIN_H_



//
// forward references
//

class WEB_ADMIN_SERVICE;



//
// registry paths
//


//
// helper functions
//

//
// Access the global web admin service pointer.
//

WEB_ADMIN_SERVICE *
GetWebAdminService(
    );

extern BOOL g_RegisterServiceCalled;

//
// common, service-wide #defines
//

#define MAX_STRINGIZED_ULONG_CHAR_COUNT 11      // "4294967295", including the terminating null

#define MAX_ULONG 0xFFFFFFFF

#define SECONDS_PER_MINUTE 60

#define ONE_SECOND_IN_MILLISECONDS 1000

#define ONE_MINUTE_IN_MILLISECONDS ( SECONDS_PER_MINUTE * ONE_SECOND_IN_MILLISECONDS )

#define MAX_MINUTES_IN_ULONG_OF_MILLISECONDS ( MAX_ULONG / ( SECONDS_PER_MINUTE * ONE_SECOND_IN_MILLISECONDS ) )

#define MAX_SECONDS_IN_ULONG_OF_MILLISECONDS ( MAX_ULONG / ONE_SECOND_IN_MILLISECONDS )

#define MAX_KB_IN_ULONG_OF_BYTES ( MAX_ULONG / 1024 )

#define MIN( a, b ) ( (a) < (b) ? (a) : (b) )
#define MAX( a, b ) ( (a) > (b) ? (a) : (b) )

#define LOG_FILE_DIRECTORY_DEFAULT L"%windir%\\system32\\logfiles"

// Log File Prefix.
#define LOG_FILE_DIRECTORY_PREFIX L"\\W3SVC"

// Size in characters, not including the NULL terminator.
#define CCH_IN_LOG_FILE_DIRECTORY_PREFIX ( sizeof(LOG_FILE_DIRECTORY_PREFIX) / sizeof(WCHAR) ) - 1

// {4DC3E181-E14B-4a21-B022-59FC669B0914}
static const GUID W3SVC_SSL_OWNER_GUID = 
{ 0x4dc3e181, 0xe14b, 0x4a21, { 0xb0, 0x22, 0x59, 0xfc, 0x66, 0x9b, 0x9, 0x14 } };

#endif  // _MAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\precomp.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master include file.

Author:

    Seth Pollack (sethp)        22-Jul-1998

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_



// ensure that all GUIDs are initialized
#define INITGUID


// main project include
#include <iis.h>


// other standard includes
#include <winsvc.h>
#include <Aclapi.h>
#include <Wincrypt.h>
#include <tdi.h>

#include <winsock2.h>
#include <ws2tcpip.h>

// local debug header
#include "wasdbgut.h"

// other project includes
#include <http.h>
#include <httpp.h>

// pragma is temporary work around unitl this file 
// can compile with level 4 warnings
#pragma warning(push, 3) 
#include <lkrhash.h>
#pragma warning(pop)


// pragma is temporary work around unitl this file 
// can compile with level 4 warnings
#include <mbconsts.h>
#pragma warning(push, 3) 
#include <multisz.hxx>
#pragma warning(pop)
#include <lock.hxx>
#include <eventlog.hxx>
#include <pipedata.hxx>
#include <useracl.h>
#include <wpif.h>
#include <w3ctrlps.h>
#include <winperf.h>
#include <perf_sm.h>
#include <timer.h>
#include <streamfilt.h>
#include <iadmw.h>
#include <iiscnfg.h>
#include <iiscnfgp.h>
#include <inetinfo.h>
#include <secfcns_all.h>
#include <adminmonitor.h>

// pragma is temporary work around unitl this file 
// can compile with level 4 warnings
#pragma warning(push, 3) 
#include "tokencache.hxx"
#pragma warning(pop)

#include "regconst.h"

// pragma is temporary work around unitl this file 
// can compile with level 4 warnings
#pragma warning(push, 3) 
#include "mb.hxx"
#pragma warning(pop)

#include "mb_notify.h"
#include <helpfunc.hxx>

#pragma warning(push, 3) 
#include <asppdef.h>
#pragma warning(pop)

// local includes
#include "main.h"
#include "wmserror.hxx"
#include "logerror.hxx"
#include "work_dispatch.h"
#include "work_item.h"
#include "messaging_handler.h"
#include "work_queue.h"
#include "multithreadreader.hxx"
#include "mb_change_item.hxx"
#include "changeprocessor.hxx"
#include "datastore.hxx"
#include "globalstore.hxx"
#include "applicationstore.hxx"
#include "sitestore.hxx"
#include "apppoolstore.hxx"
#include "was_change_item.h"
#include "application.h"
#include "application_table.h"
#include "wpcounters.h"
#include "perfcount.h"
#include "virtual_site.h"
#include "virtual_site_table.h"
#include "job_object.h"
#include "app_pool.h"
#include "app_pool_config_store.h"
#include "app_pool_table.h"
#include "worker_process.h"
#include "perf_manager.h"
#include "ul_and_worker_manager.h"
#include "control_api_call.h"
#include "control_api.h"
#include "control_api_class_factory.h"
#include "config_manager.h"
#include "config_and_control_manager.h"
#include "web_admin_service.h"
#include "iismsg.h"


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\messaging_handler.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    messaging_handler.cxx

Abstract:

    This class encapsulates the message handling functionality (over IPM)
    that is used by a worker process.

    Threading: Always called on the main worker thread, except the
    destructor, which may be called on any thread.

Author:

    Seth Pollack (sethp)        02-Mar-1999

Revision History:

--*/



#include "precomp.h"


/***************************************************************************++

Routine Description:

    Constructor for the MESSAGING_HANDLER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

MESSAGING_HANDLER::MESSAGING_HANDLER(
    )
{


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    m_pPipe = NULL;

    m_pWorkerProcess = NULL;

    m_Signature = MESSAGING_HANDLER_SIGNATURE;

    m_RefCount = 1;

    m_hrPipeError = S_OK;
}   // MESSAGING_HANDLER::MESSAGING_HANDLER



/***************************************************************************++

Routine Description:

    Destructor for the MESSAGING_HANDLER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

MESSAGING_HANDLER::~MESSAGING_HANDLER(
    )
{

    DBG_ASSERT( m_Signature == MESSAGING_HANDLER_SIGNATURE );

    m_Signature = MESSAGING_HANDLER_SIGNATURE_FREED;

    DBG_ASSERT( m_pPipe == NULL );

    DBG_ASSERT( m_pWorkerProcess == NULL );

    DBG_ASSERT( 0  == m_RefCount );

}   // MESSAGING_HANDLER::~MESSAGING_HANDLER


/***************************************************************************++

Routine Description:

    Increment the reference count for this object. Note that this method must
    be thread safe, and must not be able to fail.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
MESSAGING_HANDLER::Reference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedIncrement( &m_RefCount );


    //
    // The reference count should never have been less than zero; and
    // furthermore once it has hit zero it should never bounce back up;
    // given these conditions, it better be greater than one now.
    //

    DBG_ASSERT( NewRefCount > 1 );


    return;

}   // MESSAGING_HANDLER::Reference



/***************************************************************************++

Routine Description:

    Decrement the reference count for this object, and cleanup if the count
    hits zero. Note that this method must be thread safe, and must not be
    able to fail.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
MESSAGING_HANDLER::Dereference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedDecrement( &m_RefCount );

    // ref count should never go negative
    DBG_ASSERT( NewRefCount >= 0 );

    if ( NewRefCount == 0 )
    {
        // time to go away

        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Reference count has hit zero in MESSAGING_HANDLER instance, deleting (ptr: %p)\n",
                this
                ));
        }


        delete this;


    }


    return;

}   // MESSAGING_HANDLER::Dereference


/***************************************************************************++

Routine Description:

    Initialize this instance.

Arguments:

    pWorkerProcess - The parent worker process object of this instance.

    pszPipeName - An optional force of the name.  If NULL, a randomly generated name is used

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
MESSAGING_HANDLER::Initialize(
    IN WORKER_PROCESS * pWorkerProcess
    )
{

    HRESULT hr = S_OK;
    DWORD   dwErr = ERROR_SUCCESS;
    DWORD   iCount = 0;

    PSECURITY_ATTRIBUTES   pSa = NULL;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    if (GetWebAdminService()->IsBackwardCompatibilityEnabled())
    {
        dwErr = GetSecurityAttributesForHandle(GetWebAdminService()->GetLocalSystemTokenCacheEntry()->QueryPrimaryToken(),
                                              &pSa);
        if ( dwErr != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( dwErr );
            goto exit;
        }
    }
    else
    {
        dwErr = GetSecurityAttributesForHandle(pWorkerProcess->GetWorkerProcessToken(), &pSa);
        if ( dwErr != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( dwErr );
            goto exit;
        }

    }

    //
    // Get a pipe name, we will try 10 times if names are taken.
    //
    do 
    {

        dwErr = GenerateNameWithGUID( L"\\\\.\\pipe\\iisipm",
                                    &m_PipeName );
        if ( dwErr != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( dwErr );
            goto exit;
        }

        hr = IPM_MESSAGE_PIPE::CreateIpmMessagePipe(this, // callback object
                                                  m_PipeName.QueryStr(), // pipe name to create
                                                  TRUE, // create server side of named pipe
                                                  pSa, // security attribute for pipe
                                                  &m_pPipe); // CreateIpmMessagePipe


        iCount++;

    } while ( hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) && iCount < 10 );

    // If the CreateIpmMessagePipe failed then 
    // handle the error.
    if ( FAILED( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Creating message pipe failed\n"
            ));

        goto exit;
    }

    // Need to store this pipe name under W3SVC Parameters key
    if (GetWebAdminService()->IsBackwardCompatibilityEnabled())
    {
        // At this point we know we have the pipe name, so we can write it to the registry.
        dwErr = SetStringParameterValueInAnyService(
                    REGISTRY_KEY_W3SVC_PARAMETERS_W, 
                    REGISTRY_VALUE_INETINFO_W3WP_IPM_NAME_W,
                    m_PipeName.QueryStr() );

        if ( dwErr != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( dwErr );
            goto exit;
        }
    }


    DBG_ASSERT( m_pPipe != NULL );


    //
    // Since we have set up a pipe, we need to reference our parent
    // WORKER_PROCESS, so that while there are any outstanding i/o
    // operations on the pipe, we won't go away. We'll Dereference
    // later, when the pipe gets cleaned up.
    //

    m_pWorkerProcess = pWorkerProcess;
    m_pWorkerProcess->Reference();


exit:

    if (pSa)
    {
        FreeSecurityAttributes(pSa);
        pSa = NULL;
    }

    return hr;

}   // MESSAGING_HANDLER::Initialize



/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities
    which may hold a reference to this object to release that reference
    (and not take any more), in order to break reference cycles.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
MESSAGING_HANDLER::Terminate(
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    if ( m_pWorkerProcess != NULL )
    {

        m_pWorkerProcess->Dereference();

        //
        // set the worker process to NULL so we don't forward any additional messages
        // past this point

        m_pWorkerProcess = NULL;
    }

    //
    // Cleanup the pipe, if present.
    //
    if ( m_pPipe != NULL )
    {

        m_pPipe->DestroyIpmMessagePipe();

        //
        // Set the pipe to NULL, so that we don't try to initiate any new
        // work on it now.
        //

        m_pPipe = NULL;

    }


}   // MESSAGING_HANDLER::Terminate



/***************************************************************************++

Routine Description:

    Accept an incoming message.

Arguments:

    pMessage - The arriving message.

Return Value:

    VOID -- If we have a problem here, a message may be missed, but it will
            only really be missed due to memory issues, so there isn't much 
            we can do.

--***************************************************************************/

VOID
MESSAGING_HANDLER::AcceptMessage(
    IN const IPM_MESSAGE * pMessage
    )
{
    HRESULT hr = S_OK;

    DBG_ASSERT( !ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( pMessage != NULL );

    MESSAGING_WORK_ITEM * pMessageWorkItem = new MESSAGING_WORK_ITEM;
    if (NULL == pMessageWorkItem)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {

        hr = pMessageWorkItem->SetData(pMessage->GetOpcode(),
                                      pMessage->GetDataLen(),
                                      pMessage->GetData());
    }

    if (FAILED(hr))
    {
        delete pMessageWorkItem;
        pMessageWorkItem = NULL;

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not capture data from pMessage\n"
            ));

        return;
    }


    hr = QueueWorkItemFromSecondaryThread(
            this,
            reinterpret_cast<ULONG_PTR>(pMessageWorkItem)
            );

    if (FAILED(hr))
    {
        delete pMessageWorkItem;
        pMessageWorkItem = NULL;

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not capture data from pMessage\n"
            ));

    }

}

/***************************************************************************++

Routine Description:

    Decode and handle a piece of work for the MESSAGING_HANDLER

Arguments:

    pWorkItem - WORK_ITEM with an OPCODE that is a IPM_MESSAGE
                if the IPM_MESSAGE is NULL, PipeDisconnected has been called


Return Value:

    HRESULT

--***************************************************************************/
HRESULT
MESSAGING_HANDLER::ExecuteWorkItem(
    IN const WORK_ITEM * pWorkItem
    )
{
    HRESULT hr = S_OK;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );
    DBG_ASSERT( pWorkItem != NULL );

    const MESSAGING_WORK_ITEM * pMessage =
        reinterpret_cast<const MESSAGING_WORK_ITEM*>(pWorkItem->GetOpCode());

    // if the worker process is NULL, then the worker process has called terminate, therefore
    // don't forward any messages along anymore
    if ( NULL == m_pWorkerProcess )
    {
        hr = S_OK;
        goto exit;
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_IPM )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "MESSAGING_HANDLER::ExecuteWorkItem called (WORKER_PROCESS ptr: %p; pid: %lu; realpid: %lu)\n",
            m_pWorkerProcess,
            m_pWorkerProcess->GetProcessId(),
            m_pWorkerProcess->GetRegisteredProcessId()
            ));
    }

    //
    // a NULL MESSAGING_WORK_ITEM is a signal that the pipe has been disconnected
    //
    if ( NULL == pMessage )
    {
        PipeDisconnectedMainThread(m_hrPipeError);
        goto exit;
    }

    //
    // an invalid pipe message is a signal that the pipe received a malformed message
    //
    if ( !pMessage->IsMessageValid() )
    {
        PipeMessageInvalidMainThread();
        goto exit;
    }

    switch ( pMessage->GetOpcode() )
    {
    case IPM_OP_PING_REPLY:

        HandlePingReply( pMessage );

        break;


    case IPM_OP_WORKER_REQUESTS_SHUTDOWN:

        HandleShutdownRequest( pMessage );

        break;

    case IPM_OP_SEND_COUNTERS:

        HandleCounters( pMessage );

        break;

    case IPM_OP_GETPID:

        HandleGetPid( pMessage );

        break;

    case IPM_OP_HRESULT:

        HandleHresult( pMessage );

        break;

    default:

        //
        // invalid opcode!
        //

#pragma warning(push)
#pragma warning(disable: 4127)
        DBG_ASSERT( FALSE );
#pragma warning(pop)
        
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;

    }

exit:

    delete pMessage;

    return hr;

}   // MESSAGING_HANDLER::ExecuteWorkItem



/***************************************************************************++

Routine Description:

    Handle the fact that the pipe has been connected by the worker process.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
MESSAGING_HANDLER::PipeConnected(
    )
{

    DBG_ASSERT( !ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( m_pPipe != NULL );

    IF_DEBUG( WEB_ADMIN_SERVICE_IPM )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "MESSAGING_HANDLER(%p)::PipeConnected called (WORKER_PROCESS ptr: %p)\n",
            this,
            m_pWorkerProcess
            ));
    }

    return;
} // MESSAGING_HANDLER::PipeConnected



/***************************************************************************++

Routine Description:

    Handle the fact that the pipe has disconnected. The pipe object will
    self-destruct after returning from this call.

Arguments:

    Error - The return code associated with the disconnect.

Return Value:

    VOID

--***************************************************************************/

VOID
MESSAGING_HANDLER::PipeDisconnected(
    IN HRESULT Error
    )
{
    DBG_ASSERT(S_OK == m_hrPipeError);
    m_hrPipeError = Error;

    //
    // Ignore the hresult because we can't
    // really do anything with this if it fails.
    //
    QueueWorkItemFromSecondaryThread(this, 0); // zero signals that pipe has disconnected
    return;
}

VOID
MESSAGING_HANDLER::PipeDisconnectedMainThread(
    IN HRESULT Error
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );
    DBG_ASSERT( m_pWorkerProcess != NULL );

    IF_DEBUG( WEB_ADMIN_SERVICE_IPM )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "MESSAGING_HANDLER::PipeDisconnected called (WORKER_PROCESS ptr: %p; pid: %lu; realpid: %lu)\n",
            m_pWorkerProcess,
            m_pWorkerProcess->GetProcessId(),
            m_pWorkerProcess->GetRegisteredProcessId()
            ));
    }

    //
    // If the parameter Error contains a failed HRESULT, this method
    // is being called because something went awry in communication
    // with the worker process. In this case, we notify the
    // WORKER_PROCESS.
    //

    if ( FAILED( Error ) )
    {
        m_pWorkerProcess->IpmErrorOccurred( Error );
    }

    // the worker process pointer may be NULL after the call to IpmErrorOccurred
    // therefore, we check it before we dereference
    if (m_pWorkerProcess)
    {
        // if the pointer is still valid, don't call back anymore - release our reference
        m_pWorkerProcess->Dereference();
        m_pWorkerProcess = NULL;
    }

}   // MESSAGING_HANDLER::PipeDisconnected


/***************************************************************************++

Routine Description:

    Handle the fact that the pipe has received an unexpected or malformed message

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/

VOID
MESSAGING_HANDLER::PipeMessageInvalid(
        )
{
    HRESULT hr = S_OK;

    DBG_ASSERT( !ON_MAIN_WORKER_THREAD );

    MESSAGING_WORK_ITEM * pMessageWorkItem = new MESSAGING_WORK_ITEM;
    if (NULL == pMessageWorkItem)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not allocate for invalid pipe message work item"
            ));

        return;
    }

    // note: don't call pMessageWorkItem->SetData here.  We have no data and need to communicate that to ExecuteWorkItem

    hr = QueueWorkItemFromSecondaryThread(
            this,
            reinterpret_cast<ULONG_PTR>(pMessageWorkItem)
            );

    if (FAILED(hr))
    {
        delete pMessageWorkItem;
        pMessageWorkItem = NULL;

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not queue invalid pipe message work item from secondary thread"
            ));

    }

    return;
}

/***************************************************************************++

Routine Description:

    The messaging handler determined the data sent from the worker
    process was not valid.  We need to notify the worker process that
    something is wrong with the data received and let it terminate.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/
VOID
MESSAGING_HANDLER::PipeMessageInvalidMainThread(
        )
{
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );
    DBG_ASSERT( m_pWorkerProcess != NULL );

    IF_DEBUG( WEB_ADMIN_SERVICE_IPM )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "MESSAGING_HANDLER::PipeMessageInvalidMainThread called (WORKER_PROCESS ptr: %p; pid: %lu; realpid: %lu)\n",
            m_pWorkerProcess,
            m_pWorkerProcess->GetProcessId(),
            m_pWorkerProcess->GetRegisteredProcessId()
            ));
    }

    m_pWorkerProcess->UntrustedIPMTransferReceived();

    return;
}

/***************************************************************************++

Routine Description:

    Ping the worker process to check if it is still responsive.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
MESSAGING_HANDLER::SendPing(
    )
{
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    return SendMessage(IPM_OP_PING,
                      0,
                      NULL);
}   // MESSAGING_HANDLER::SendPing

/***************************************************************************++

Routine Description:

    RequestCounters from the worker process.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
MESSAGING_HANDLER::RequestCounters(
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    return SendMessage(IPM_OP_REQUEST_COUNTERS,    // opcode
                      0,                  // data length
                      NULL);
}   // MESSAGING_HANDLER::RequestCounters


/***************************************************************************++

Routine Description:

    Tell the worker process to initiate clean shutdown.

Arguments:

    ShutdownTimeLimitInMilliseconds - Number of milliseconds that this
    worker process has in which to complete clean shutdown. If this time
    is exceeded, the worker process will be terminated.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
MESSAGING_HANDLER::SendShutdown(
    IN BOOL ShutdownImmediately
    )
{
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );
    return SendMessage(IPM_OP_SHUTDOWN,                // opcode
                      sizeof( ShutdownImmediately ),   // data length
                      reinterpret_cast<BYTE*>( &ShutdownImmediately ) // pointer to data
                      );
}   // MESSAGING_HANDLER::SendShutdown


/***************************************************************************++

Routine Description:

    Tell the WORKER_PROCESS the real PID value of the worker process

Arguments:

    pMessage - IPM_MESSAGE with the remote pid

Return Value:

    VOID

--***************************************************************************/

VOID
MESSAGING_HANDLER::HandleGetPid(
    IN const MESSAGING_WORK_ITEM * pMessage
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );
    DBG_ASSERT( m_pWorkerProcess != NULL );
    DBG_ASSERT( m_pPipe != NULL );

    IF_DEBUG( WEB_ADMIN_SERVICE_IPM )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "MESSAGING_HANDLER::PipeConnected called (WORKER_PROCESS ptr: %p; pid: %lu; realpid: %lu)\n",
            m_pWorkerProcess,
            m_pWorkerProcess->GetProcessId(),
            m_pWorkerProcess->GetRegisteredProcessId()
            ));
    }

    DBG_ASSERT(pMessage->GetDataLen() == sizeof(DWORD));

    m_pWorkerProcess->WorkerProcessRegistrationReceived( *((DWORD*)pMessage->GetData()) );

}   // MESSAGING_HANDLER::HandleGetPid


/***************************************************************************++

Routine Description:

    Handle a ping reply message from the worker process.

Arguments:

    pMessage - The arriving message.

Return Value:

    HRESULT

--***************************************************************************/

VOID
MESSAGING_HANDLER::HandlePingReply(
    IN const MESSAGING_WORK_ITEM * pMessage
    )
{
    UNREFERENCED_PARAMETER ( pMessage );
    
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pMessage != NULL );


    //
    // Validate the message data.
    // Not expecting any message body.
    //

    DBG_ASSERT ( pMessage->GetDataLen() == 0 );

    m_pWorkerProcess->PingReplyReceived();

}   // MESSAGING_HANDLER::HandlePingReply

/***************************************************************************++

Routine Description:

    Handle a message containing counter information from a worker process

Arguments:

    pMessage - The arriving message.

Return Value:

    VOID

--***************************************************************************/

VOID
MESSAGING_HANDLER::HandleCounters(
    IN const MESSAGING_WORK_ITEM * pMessage
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );
    DBG_ASSERT( pMessage != NULL );

    //
    // Tell the worker process to handle it's counters.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {

        DBGPRINTF((
            DBG_CONTEXT,
            "Receiving Perf Count Message with length %d\n",
            pMessage->GetDataLen()
            ));

    }

    m_pWorkerProcess->RecordCounters(pMessage->GetDataLen(),
                                             pMessage->GetData());

}   // MESSAGING_HANDLER::HandleCounters

/***************************************************************************++

Routine Description:

    Handle a message containing an hresult from a worker process

Arguments:

    pMessage - The arriving message.

Return Value:

    VOID

--***************************************************************************/

VOID
MESSAGING_HANDLER::HandleHresult(
    IN const MESSAGING_WORK_ITEM * pMessage
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pMessage != NULL );

    //
    // Tell the worker process to handle it's counters.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_IPM )
    {

        DBGPRINTF((
            DBG_CONTEXT,
            "Receiving hresult message with length %d\n",
            pMessage->GetDataLen()
            ));

    }

    DBG_ASSERT ( pMessage->GetDataLen() == sizeof ( HRESULT ) );

    BYTE *pMessTemp = const_cast < BYTE* >( pMessage->GetData() );

    HRESULT* phTemp =  reinterpret_cast< HRESULT* > ( pMessTemp );

    m_pWorkerProcess->HandleHresult(*phTemp);

}   // MESSAGING_HANDLER::HandleHresult


/***************************************************************************++

Routine Description:

    Handle a shutdown request message from the worker process.

Arguments:

    pMessage - The arriving message.

Return Value:

    VOID

--***************************************************************************/

VOID
MESSAGING_HANDLER::HandleShutdownRequest(
    IN const MESSAGING_WORK_ITEM * pMessage
    )
{

    IPM_WP_SHUTDOWN_MSG ShutdownRequestReason = IPM_WP_MINIMUM;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );
    DBG_ASSERT( pMessage != NULL );

    //
    // Malformed message! Assert on debug builds; on retail builds,
    // ignore the message.
    //

    DBG_ASSERT( ( pMessage->GetDataLen() == sizeof( IPM_WP_SHUTDOWN_MSG ) ) &&
                ( pMessage->GetData() != NULL ) );


    ShutdownRequestReason = ( IPM_WP_SHUTDOWN_MSG ) ( * ( pMessage->GetData() ) );

    m_pWorkerProcess->ShutdownRequestReceived( ShutdownRequestReason );

}   // MESSAGING_HANDLER::HandleShutdownRequest

/***************************************************************************++

Routine Description:

    Send Worker Process Recycler related parameter

Arguments:

    SendPeriodicProcessRestartPeriodInMinutes

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
MESSAGING_HANDLER::SendPeriodicProcessRestartPeriodInMinutes(
    IN DWORD PeriodicProcessRestartPeriodInMinutes
    )
{
    return SendMessage(
               IPM_OP_PERIODIC_PROCESS_RESTART_PERIOD_IN_MINUTES,
               sizeof( PeriodicProcessRestartPeriodInMinutes ),
               (PBYTE) &PeriodicProcessRestartPeriodInMinutes
               );

}   // MESSAGING_HANDLER::SendPeriodicProcessRestartPeriodInMinutes


/***************************************************************************++

Routine Description:

    Send Worker Process Recycler related parameter

Arguments:

    pPeriodicProcessRestartSchedule

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
MESSAGING_HANDLER::SendPeriodicProcessRestartSchedule(
    IN LPWSTR pPeriodicProcessRestartSchedule
    )
{
    return SendMessage(
               IPM_OP_PERIODIC_PROCESS_RESTART_SCHEDULE,
               GetMultiszByteLength( pPeriodicProcessRestartSchedule ),
               (PBYTE) pPeriodicProcessRestartSchedule
               );
}   // MESSAGING_HANDLER::SendPeriodicProcessRestartSchedule


/***************************************************************************++

Routine Description:

    Send Worker Process Recycler related parameter

Arguments:

    PeriodicProcessRestartMemoryUsageInKB

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
MESSAGING_HANDLER::SendPeriodicProcessRestartMemoryUsageInKB(
    IN DWORD PeriodicProcessRestartMemoryUsageInKB,
    IN DWORD PeriodicProcessRestartPrivateBytesInKB
    )
{
    DWORD adwRecyclingMemoryValues[ 2 ];
    //
    // serialize Recycling memory values to be sent to worker process
    //
    adwRecyclingMemoryValues[ 0 ] = PeriodicProcessRestartMemoryUsageInKB;
    adwRecyclingMemoryValues[ 1 ] = PeriodicProcessRestartPrivateBytesInKB;
    
    return SendMessage(
               IPM_OP_PERIODIC_PROCESS_RESTART_MEMORY_USAGE_IN_KB,
               sizeof( adwRecyclingMemoryValues ),
               (PBYTE) adwRecyclingMemoryValues
               );
}   // MESSAGING_HANDLER::SendPeriodicProcessRestartMemoryUsageInKB


/***************************************************************************++

Routine Description:

    Send Message - wrapper of pipe's WriteMessage()
    It performs some validations before making WriteMessage() call

Arguments:
    opcode      - opcode
    dwDataLen,  - data length
    pbData      - pointer to data


Return Value:

    HRESULT

--***************************************************************************/
HRESULT
MESSAGING_HANDLER::SendMessage(
    IN enum IPM_OPCODE  opcode,
    IN DWORD            dwDataLen,
    IN BYTE *           pbData
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    if ( m_pPipe == NULL )
    {
        //
        // The pipe is not valid; it may have self-destructed due to error.
        // Bail out.
        //

        hr = ERROR_PIPE_NOT_CONNECTED;

        goto exit;
    }

    hr = m_pPipe->WriteMessage(
                        opcode,        // opcode
                        dwDataLen,     // data length
                        pbData         // pointer to data
                        );

    // There are some failures that are OK.
    // we just mask them away - PipeDisconnect will be called by
    // the pipe mechanism
    if ( HRESULT_FROM_WIN32(ERROR_BAD_PIPE) == hr ||
       HRESULT_FROM_WIN32(ERROR_BROKEN_PIPE) == hr ||
       HRESULT_FROM_WIN32(ERROR_PIPE_NOT_CONNECTED  )  == hr ||
       HRESULT_FROM_WIN32(ERROR_NO_DATA) == hr)
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Masking Pipe Write failure of 0x%x\n",
            hr));
        hr = S_OK;
    }

    if ( FAILED( hr ) )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Sending message %d to worker process failed. hr =0x%x\n",
            opcode,
            hr
            ));

        goto exit;
    }


exit:

    return hr;

}   // MESSAGING_HANDLER::SendMessage
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\virtual_site.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    virtual_site.h

Abstract:

    The IIS web admin service virtual site class definition.

Author:

    Seth Pollack (sethp)        04-Nov-1998

Revision History:

--*/


#ifndef _VIRTUAL_SITE_H_
#define _VIRTUAL_SITE_H_


//
// common #defines
//

#define VIRTUAL_SITE_SIGNATURE          CREATE_SIGNATURE( 'VSTE' )
#define VIRTUAL_SITE_SIGNATURE_FREED    CREATE_SIGNATURE( 'vstX' )


#define INVALID_VIRTUAL_SITE_ID 0xFFFFFFFF

// MAX_SIZE_OF_SITE_DIRECTORY is equal to size of the 
// Directory Name Prefix plus the maximum number size
// that itow can return when converting an integer into
// a wchar (this includes null termination).
#define MAX_SIZE_OF_SITE_DIRECTORY_NAME sizeof(LOG_FILE_DIRECTORY_PREFIX) + (MAX_STRINGIZED_ULONG_CHAR_COUNT * sizeof(WCHAR))

//
// structs, enums, etc.
//

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Structure for handling maximum
// values of the site perf counters.
//
struct W3_MAX_DATA
{
    DWORD MaxAnonymous;
    DWORD MaxConnections;
    DWORD MaxCGIRequests;
    DWORD MaxBGIRequests;
    DWORD MaxNonAnonymous;
};


struct SITE_SSL_CONFIG_DATA
{
    BUFFER      bufSockAddrs;
    DWORD       dwSockAddrCount;
    DWORD       dwSslHashLength;
    BUFFER      bufSslHash;
    STRU        strSslCertStoreName;
    DWORD       dwDefaultCertCheckMode;
    DWORD       dwDefaultRevocationFreshnessTime;
    DWORD       dwDefaultRevocationUrlRetrievalTimeout;
    STRU        strDefaultSslCtrLdentifier;
    STRU        strSslCtrlStoreName;
    DWORD       dwDefaultFlags;
};


//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
enum COUNTER_SOURCE_ENUM
{
    ULCOUNTERS = 0,
    WPCOUNTERS = 1
};

//
// prototypes
//

class VIRTUAL_SITE
{

public:

    VIRTUAL_SITE(
        );

    virtual
    ~VIRTUAL_SITE(
        );

    HRESULT
    Initialize(
        IN SITE_DATA_OBJECT* pSiteObject
        );

    HRESULT
    SetConfiguration(
        IN SITE_DATA_OBJECT* pSiteObject,
        IN BOOL fInitializing
        );

    VOID
    AggregateCounters(
        IN COUNTER_SOURCE_ENUM CounterSource,
        IN LPVOID pCountersToAddIn
        );

    VOID
    AdjustMaxValues(
        );


    VOID
    ClearAppropriatePerfValues(
        );

    inline
    DWORD
    GetVirtualSiteId(
        )
        const
    { return m_VirtualSiteId; }

    LPWSTR
    GetVirtualSiteDirectory(
        )
    {
        WCHAR buf[MAX_STRINGIZED_ULONG_CHAR_COUNT];
        HRESULT hr = S_OK;

        if ( m_VirtualSiteDirectory.IsEmpty() )
        {
            hr = m_VirtualSiteDirectory.Copy ( LOG_FILE_DIRECTORY_PREFIX );
            if ( FAILED ( hr ) ) 
            {
                DPERROR((
                    DBG_CONTEXT,
                    hr,
                    "Out of memory allocating the VirtualSiteDirectory\n" ));

            }
            else
            {
                // Copy in the virtual site id (in wchar form).
                _ultow(m_VirtualSiteId
                    , buf
                    , 10);

                hr = m_VirtualSiteDirectory.Append( buf );
                if ( FAILED ( hr ) ) 
                {
                    DPERROR((
                        DBG_CONTEXT,
                        hr,
                        "Failed to append the site to the virtual directory \n" ));

                }
            }
        }

        return m_VirtualSiteDirectory.QueryStr();
    }

    LPWSTR
    GetVirtualSiteName(
        )
    {  
        return m_ServerComment;
    }


    VOID
    AssociateApplication(
        IN APPLICATION * pApplication
        );

    VOID
    DissociateApplication(
        IN APPLICATION * pApplication
        );

    VOID
    ResetUrlPrefixIterator(
        );

    LPCWSTR
    GetNextUrlPrefix(
        );

    VOID
    RecordState(
        );

    inline
    PLIST_ENTRY
    GetDeleteListEntry(
        )
    { return &m_DeleteListEntry; }

    static
    VIRTUAL_SITE *
    VirtualSiteFromDeleteListEntry(
        IN const LIST_ENTRY * pDeleteListEntry
        );


#if DBG
    VOID
    DebugDump(
        );

#endif  // DBG


    VOID
    ProcessStateChangeCommand(
        IN DWORD Command,
        IN BOOL DirectCommand,
        OUT DWORD * pNewState
        );

   
    inline
    DWORD
    GetState(
        )
        const
    { return m_State; }


    BOOL 
    LoggingEnabled(
        )
    {
        return (( m_LoggingFormat < HttpLoggingTypeMaximum )
                 && ( m_LoggingEnabled ));
    }

    HTTP_LOGGING_TYPE
    GetLogFileFormat(
        )
    { return m_LoggingFormat; }


    LPWSTR 
    GetLogFileDirectory(
        )
    {   return m_LogFileDirectory;   }

    DWORD
    GetLogPeriod(
        )
    { return m_LoggingFilePeriod; }

    DWORD
    GetLogFileTruncateSize(
        )
    { return m_LoggingFileTruncateSize; }
        
    DWORD
    GetLogExtFileFlags(
        )
    { return m_LoggingExtFileFlags; }

    DWORD
    GetLogFileLocaltimeRollover(
        )
    { return m_LogFileLocaltimeRollover; }
    
    BOOL    
    CheckAndResetServerCommentChanged(
        )
    {
        //
        // Save the server comment setting
        //
        BOOL ServerCommentChanged = m_ServerCommentChanged;

        //
        // reset it appropriately.
        //
        m_ServerCommentChanged = FALSE;

        //
        // now return the value we saved.
        //
        return ServerCommentChanged;
    }

    VOID
    SetMemoryOffset(
        IN ULONG MemoryOffset
        )
    {
        //
        // A memory offset of zero means that
        // we have not set the offset yet.  
        // 
        // Zero is reserved for _Total.
        // 
        DBG_ASSERT ( MemoryOffset != 0 );
        m_MemoryOffset = MemoryOffset;
    }

    ULONG
    GetMemoryOffset(
        )
    { 
        //
        // A memory offset of zero means that
        // we have not set the offset yet.  If
        // we attempt to get it and have not set
        // it then we are in trouble.
        // 
        // Zero is reserved for _Total.
        // 
        DBG_ASSERT ( m_MemoryOffset != 0 );
        return m_MemoryOffset; 
    }


    W3_COUNTER_BLOCK*
    GetCountersPtr(
        )
    { return &m_SiteCounters; }

    PROP_DISPLAY_DESC*
    GetDisplayMap(
        );

    DWORD
    GetSizeOfDisplayMap(
        );

    DWORD
    GetMaxBandwidth(
        )
    { return m_MaxBandwidth; }

    DWORD
    GetMaxConnections(
        )
    { return m_MaxConnections; }

    DWORD
    GetConnectionTimeout(
        )
    { return m_ConnectionTimeout; }

    VOID
    ApplyStateChangeCommand(
        IN DWORD Command,
        IN DWORD NewState,
        IN HRESULT hrReturned
        );

    VOID
    SetHrForDeletion(
        IN HRESULT hrToReport
        )
    {  m_hrForDeletion = hrToReport; }

private:

    VOID
    AddSSLConfigStoreForSiteChanges(
        );

    VOID
    RemoveSSLConfigStoreForSiteChanges(
        );

    VOID
    SaveSSLConfigStoreForSiteChanges(
        IN SITE_DATA_OBJECT* pSiteObject
        );


    VOID
    ChangeState(
        IN DWORD NewState,
        IN HRESULT Error
        );

    HRESULT
    ControlAllApplicationsOfSite(
        IN DWORD Command
        );

    VOID
    NotifyApplicationsOfBindingChange(
        );

    HRESULT
    NotifyDefaultApplicationOfLoggingChanges(
        );

    HRESULT
    EvaluateLoggingChanges(
        IN SITE_DATA_OBJECT* pSiteObject
        );
    
    DWORD m_Signature;

    DWORD m_VirtualSiteId;

    STRU m_VirtualSiteDirectory;

    // ServerComment is truncated at the max name length for
    // a perf counter instance, this is all it is used for.
    WCHAR m_ServerComment[MAX_INSTANCE_NAME];

    // current state for this site, set to a W3_CONTROL_STATE_xxx value
    DWORD m_State;

    // applications associated with this virtual site
    LIST_ENTRY m_ApplicationListHead;

    ULONG m_ApplicationCount;

    // virtual site bindings (aka URL prefixes)
    MULTISZ m_Bindings;

    // current position of the iterator
    LPCWSTR m_pIteratorPosition;

    // autostart state
    BOOL m_Autostart;

    // Is Logging Enabled for the site?
    BOOL m_LoggingEnabled;

    // Type of logging
    HTTP_LOGGING_TYPE m_LoggingFormat;

    // The log file directory in the form
    // appropriate for passing to UL.
    LPWSTR m_LogFileDirectory;

    // The log file period for the site.
    DWORD m_LoggingFilePeriod;

    // The log file truncation size.
    DWORD m_LoggingFileTruncateSize;

    // The log file extension flags
    DWORD m_LoggingExtFileFlags;

    // Whether to roll the time over according to
    // local time.
    BOOL m_LogFileLocaltimeRollover;

    //
    // The MaxBandwidth allowed for the site.
    //
    DWORD m_MaxBandwidth;

    // 
    // The MaxConnections allowed for the site.
    //
    DWORD m_MaxConnections;

    //
    // The Connection timeout for the site.
    //
    DWORD m_ConnectionTimeout;

    // used for building a list of VIRTUAL_SITEs to delete
    LIST_ENTRY m_DeleteListEntry;

    // track if the server comment has changed since the 
    // last time perf counters were given out.
    BOOL m_ServerCommentChanged;

    // memory reference pointer to perf counter
    // data.
    ULONG m_MemoryOffset;

    //
    // saftey counter block for the site.
    W3_COUNTER_BLOCK m_SiteCounters;

    //
    // saftey for max values.
    W3_MAX_DATA m_MaxSiteCounters;

    //
    // Site Start Time
    //
    DWORD m_SiteStartTime;

    //
    // Root application for the site.
    //
    APPLICATION* m_pRootApplication;

    STRU m_AppPoolIdForRootApp;

    // hresult to report to the metabase 
    // when we write to the metabase.
    HRESULT m_hrForDeletion;

    // hresult to report to the metabase 
    // when we write to the metabase.
    HRESULT m_hrLastReported;

    // holds all the SOCKADDRS that 
    // are configured in http for the site
    BUFFER m_bufSockAddrsInHTTP;

    // tracks the count of addrs in 
    // the buffer.
    DWORD m_dwSockAddrsInHTTPCount;

    SITE_SSL_CONFIG_DATA* m_pSslConfigData;

};  // class VIRTUAL_SITE



#endif  // _VIRTUAL_SITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\sitestore.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    sitestore.cxx

Abstract:

    Reads site configuration

Author:

    Bilal Alam (balam)          27-May-2001

Revision History:

--*/

#include "precomp.h"

//
// This is needed to disable w4 complaining
// about how we disable prefast complaining
// about use of TerminateThread.
//
#ifndef _PREFAST_
#pragma warning(disable:4068)
#endif

HRESULT
SITE_DATA_OBJECT::Create(
    VOID
)
/*++

Routine Description:

    Initialize a site data object to suitable defaults

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;

    _fAutoStart = TRUE;
    _dwLogType = 1;
    _dwLogFilePeriod = 1;
    _dwLogFileTruncateSize = 2000000;
    _dwLogExtFileFlags = MD_DEFAULT_EXTLOG_FIELDS;
    _fLogFileLocaltimeRollover = FALSE;
    _dwMaxBandwidth = 0xFFFFFFFF;
    _dwMaxConnections = 0;
    _dwConnectionTimeout = MBCONST_CONNECTION_TIMEOUT_DEFAULT;
    _dwServerCommand = 0;

    hr = _strLogPluginClsid.Copy( L"" );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = _strLogFileDirectory.Copy( LOG_FILE_DIRECTORY_DEFAULT );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = _strServerComment.Copy( L"" );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = _strCertStoreName.Copy( L"" );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    _cSockAddrs = 0;
    _cbCertHash = 0;

    hr = _strDefaultSslCtlIdentifier.Copy( L"" );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = _strDefaultSslCtlStoreName.Copy( L"" );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    _dwDefaultCertCheckMode = 0;
    _dwDefaultRevocationFreshnessTime = 0;
    _dwDefaultRevocationUrlRetrievalTimeout = 0;
    _dwDefaultFlags = 0;

    return NO_ERROR;
}

DATA_OBJECT *
SITE_DATA_OBJECT::Clone(
    VOID
)
/*++

Routine Description:

    Clone site object

Arguments:

    None

Return Value:

    DATA_OBJECT *

--*/
{
    SITE_DATA_OBJECT *      pClone;
    HRESULT                 hr;

    pClone = new SITE_DATA_OBJECT( _siteKey.QuerySiteId() );
    if ( pClone == NULL )
    {
        return NULL;
    }

    pClone->_fBindingsChanged  = _fBindingsChanged;
    pClone->_fAutoStartChanged  = _fAutoStartChanged;
    pClone->_fLogTypeChanged  = _fLogTypeChanged;
    pClone->_fLogFilePeriodChanged  = _fLogFilePeriodChanged;
    pClone->_fLogFileTruncateSizeChanged  = _fLogFileTruncateSizeChanged;
    pClone->_fLogExtFileFlagsChanged  = _fLogExtFileFlagsChanged;
    pClone->_fLogFileLocaltimeRolloverChanged  = _fLogFileLocaltimeRolloverChanged;
    pClone->_fLogPluginClsidChanged  = _fLogPluginClsidChanged;
    pClone->_fLogFileDirectoryChanged  = _fLogFileDirectoryChanged;
    pClone->_fServerCommentChanged  = _fServerCommentChanged;
    pClone->_fServerCommandChanged  = _fServerCommandChanged;
    pClone->_fMaxBandwidthChanged  = _fMaxBandwidthChanged;
    pClone->_fMaxConnectionsChanged  = _fMaxConnectionsChanged;
    pClone->_fConnectionTimeoutChanged  = _fConnectionTimeoutChanged;
    pClone->_fAppPoolIdChanged  = _fAppPoolIdChanged;
    pClone->_fSockAddrsChanged  = _fSockAddrsChanged;
    pClone->_fCertHashChanged  = _fCertHashChanged;
    pClone->_fCertStoreNameChanged = _fCertStoreNameChanged;
    pClone->_fDefaultCertCheckModeChanged = _fDefaultCertCheckModeChanged;              
    pClone->_fDefaultRevocationFreshnessTimeChanged = _fDefaultRevocationFreshnessTimeChanged;    
    pClone->_fDefaultRevocationUrlRetrievalTimeoutChanged = _fDefaultRevocationUrlRetrievalTimeoutChanged;
    pClone->_fDefaultSslCtlIdentifierChanged  = _fDefaultSslCtlIdentifierChanged;          
    pClone->_fDefaultSslCtlStoreNameChanged = _fDefaultSslCtlStoreNameChanged;           
    pClone->_fDefaultFlagsChanged = _fDefaultFlagsChanged;

    pClone->_fAutoStart = _fAutoStart;
    pClone->_dwLogType = _dwLogType;
    pClone->_dwLogFilePeriod = _dwLogFilePeriod;
    pClone->_dwLogFileTruncateSize = _dwLogFileTruncateSize;
    pClone->_dwLogExtFileFlags = _dwLogExtFileFlags;
    pClone->_fLogFileLocaltimeRollover = _fLogFileLocaltimeRollover;
    pClone->_dwMaxBandwidth = _dwMaxBandwidth;
    pClone->_dwMaxConnections = _dwMaxConnections;
    pClone->_dwConnectionTimeout = _dwConnectionTimeout;
    pClone->_dwServerCommand = _dwServerCommand;
    pClone->_cSockAddrs = _cSockAddrs;  // Actual addrs are done below.
    pClone->_cbCertHash = _cbCertHash;  // Actual cert are done below.
    pClone->_dwDefaultCertCheckMode = _dwDefaultCertCheckMode;
    pClone->_dwDefaultRevocationFreshnessTime = _dwDefaultRevocationFreshnessTime;
    pClone->_dwDefaultRevocationUrlRetrievalTimeout = _dwDefaultRevocationUrlRetrievalTimeout;
    pClone->_dwDefaultFlags = _dwDefaultFlags;

    hr = pClone->_strAppPoolId.Copy( _strAppPoolId );
    if ( FAILED( hr ) )
    {
        delete pClone;
        return NULL;
    }

    // Make sure we have enough room for the copy of the sock addrs.
    if ( !pClone->_bufSockAddrs.Resize( _bufSockAddrs.QuerySize() ))
    {
        delete pClone;
        return NULL;
    }

    // Copy over the sock addrs.  Since we just resized, this should fit exactly.
    memcpy( pClone->_bufSockAddrs.QueryPtr(), _bufSockAddrs.QueryPtr(), _bufSockAddrs.QuerySize() );

    // Make sure we have enough room for the copy of the certificate hash.
    if ( !pClone->_bufCertHash.Resize( _bufCertHash.QuerySize() ) )
    {
        delete pClone;
        return NULL;
    }

    // Copy over the certificate hash.  Since we just resized, this should fit exactly.
    memcpy( pClone->_bufCertHash.QueryPtr(), _bufCertHash.QueryPtr(), _bufCertHash.QuerySize() );

    if ( !_mszBindings.Clone( &pClone->_mszBindings ) )
    {
        delete pClone;
        return NULL;
    }

    hr = pClone->_strCertStoreName.Copy( _strCertStoreName );
    if ( FAILED( hr ) )
    {
        delete pClone;
        return NULL;
    }

    hr = pClone->_strDefaultSslCtlIdentifier.Copy( _strDefaultSslCtlIdentifier );
    if ( FAILED( hr ) )
    {
        delete pClone;
        return NULL;
    }

    hr = pClone->_strDefaultSslCtlStoreName.Copy( _strDefaultSslCtlStoreName );
    if ( FAILED( hr ) )
    {
        delete pClone;
        return NULL;
    }

    hr = pClone->_strLogPluginClsid.Copy( _strLogPluginClsid );
    if ( FAILED( hr ) )
    {
        delete pClone;
        return NULL;
    }

    hr = pClone->_strLogFileDirectory.Copy( _strLogFileDirectory );
    if ( FAILED( hr ) )
    {
        delete pClone;
        return NULL;
    }

    hr = pClone->_strServerComment.Copy( _strServerComment );
    if ( FAILED( hr ) )
    {
        delete pClone;
        return NULL;
    }

    CloneBasics ( pClone );

    return pClone;
}

HRESULT
SITE_DATA_OBJECT::SetupBindings(
    WCHAR *                     pszBindings,
    BOOL                        fIsSecure
)
/*++

Routine Description:

    Setup site object bindings (i.e. create the UL friendly URL representing
    the bindings)

Arguments:

    pszBindings - MULTISZ representing binding
    fIsSecure - Are these secure bindings?

Return Value:

    HRESULT

--*/
{
    WCHAR *                 pszCurrentBindings;
    HRESULT                 hr = S_OK;
    WCHAR *                 pszProtocol;
    DWORD                   cchProtocol;
    STACK_STRU(             strPrefix, 256 );
    BOOL                    fRet = FALSE;
    SOCKADDR                SockAddr;
    SOCKADDR*               pSockAddrs = NULL;

    if ( pszBindings == NULL )
    {
        DBG_ASSERT( pszBindings != NULL );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if ( fIsSecure )
    {
        pszProtocol = L"https://";
    }
    else
    {
        pszProtocol = L"http://";
    }
    cchProtocol = (DWORD) wcslen( pszProtocol );

    //
    // Iterate thru all the bindings
    //

    pszCurrentBindings = pszBindings;
    while ( *pszCurrentBindings != L'\0' )
    {
        strPrefix.Reset();
        memset ( &SockAddr, 0, sizeof(SOCKADDR) );

        hr = BindingStringToUrlPrefix( pszCurrentBindings,
                                       pszProtocol,
                                       cchProtocol,
                                       &strPrefix,
                                       &SockAddr);
        if ( FAILED( hr ) )
        {
            return hr;
        }

        fRet = _mszBindings.Append( strPrefix );
        if ( !fRet )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }

        if ( fIsSecure )
        {
            if ( _bufSockAddrs.QuerySize() < ( ( _cSockAddrs + 1 ) * sizeof(SOCKADDR) ) )
            {
                // Need to resize the SockAddrs.
                if ( ! _bufSockAddrs.Resize( ( _cSockAddrs + 1 ) * sizeof(SOCKADDR) ) )
                {
                    hr = E_OUTOFMEMORY;
                    return hr;
                }

            }

            // get the start of the array and then advance
            // the number of known addrs and add this one.
            pSockAddrs = (SOCKADDR*) _bufSockAddrs.QueryPtr();
            memcpy( &(pSockAddrs[_cSockAddrs]),
                    &SockAddr,
                    sizeof(SockAddr) );

            _cSockAddrs++;
        }

        pszCurrentBindings += wcslen( pszCurrentBindings ) + 1;
    }

    return NO_ERROR;
}

HRESULT
SITE_DATA_OBJECT::BindingStringToUrlPrefix(
    IN LPCWSTR pBindingString,
    IN LPCWSTR pProtocolString,
    IN ULONG ProtocolStringCharCountSansTermination,
    OUT STRU * pUrlPrefix,
    OUT SOCKADDR * pSockAddr
)
/*++

Routine Description:

    Convert a single metabase style binding string into the UL format
    used for URL prefixes.

    The metabase format is "ip-address:ip-port:host-name". The port must
    always be present; the ip-address and host-name are both optional,
    and may be left empty. However, it is illegal to specify both (this is
    a slight restriction over what we allowed in earlier versions of IIS).

    The UL format is "[http|https]://[ip-address|host-name|*]:ip-port".
    All pieces of information (protocol, address information, and port)
    must be present. The "*" means accept any ip-address or host-name.

Arguments:

    pBindingString - The metabase style binding string to convert.

    pProtocolString - The protocol string, for example "http://".

    ProtocolStringCharCountSansTermination - The count of characters in
    the protocol string, without the terminating null.

    pUrlPrefix - The resulting UL format URL prefix.

    pSockAddr - Ptr to a SOCKADDR that represents this binding.

Return Value:

    HRESULT

--*/
{

    HRESULT hr = S_OK;

    LPCWSTR IpAddress = NULL;
    LPCWSTR pszPartIpAddress = NULL;
    DWORD cPartAddresses = 0;   // counts the parts of the address we see.
    DWORD dwPartIpAddress = 0;  // holds part of the addresss in number form

    LPCWSTR IpPort = NULL;
    DWORD   dwPort = 0;
    LPCWSTR pszEnd = NULL;

    LPCWSTR HostName = NULL;
    ULONG IpAddressCharCountSansTermination = 0;
    ULONG IpPortCharCountSansTermination = 0;
    BOOL fSawOnlyMaxValue = TRUE;
    BOOL fSawOnlyMinValue = TRUE;
    SOCKADDR_IN* pSockAddrIn = NULL;


    DBG_ASSERT( pBindingString != NULL );
    DBG_ASSERT( pProtocolString != NULL );
    DBG_ASSERT( pUrlPrefix != NULL );
    DBG_ASSERT( pSockAddr != NULL );

    if ( pBindingString == NULL ||
         pProtocolString == NULL ||
         pUrlPrefix == NULL ||
         pSockAddr == NULL )
    {
        return E_INVALIDARG;
    }

    //
    // Find the various parts of the binding.
    //

    IpAddress = pBindingString;

    IpPort = wcschr( IpAddress, L':' );
    if ( IpPort == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

        goto exit;
    }

    IpPort++;

    HostName = wcschr( IpPort, L':' );
    if ( HostName == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

        goto exit;
    }

    HostName++;


    //
    // Validate the ip address.
    //

    if ( *IpAddress == L':' )
    {
        // no ip address specified

        IpAddress = NULL;
    }
    else
    {
        IpAddressCharCountSansTermination = (ULONG) DIFF( IpPort - IpAddress ) - 1;

        // need to validate that the IpAddress is either * or in the form
        // xxx.xxx.xxx.xxx ( where x = a digit )

        if ( *IpAddress == L'*' )
        {
            // make sure that we only have a '*'
            if ( IpAddressCharCountSansTermination != 1 )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

                goto exit;
            }
        }
        else
        {
            // not the wild card so now we need to make sure that it is
            // xxx.xxx.xxx.xxx ( where x is a digit 0 to 9 )

            // 15 is the number of characters in a full ip address
            // not counting the termination.
            if ( IpAddressCharCountSansTermination > 15 )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

                goto exit;
            }

            pszPartIpAddress = IpAddress;

            //
            // because of the port finding above you are
            // guaranteed only to get here if a : is somewhere
            // in the string.
            //
            while ( *pszPartIpAddress != L':' )
            {
                // we should always start on a number.  if we don't
                // then there is no number between a dot and a : and
                // we are invalid.
                if ( *pszPartIpAddress >= L'0' && *pszPartIpAddress <= L'9' )
                {
                    // find out what the first number is, and what follows it.
                    dwPartIpAddress = wcstoul( pszPartIpAddress, (WCHAR**) &pszEnd, 10 );

                    // if it was not followed by a colon or dot then it is
                    // invalid
                    if ( pszEnd == NULL ||
                        ( *pszEnd != L':' &&
                          *pszEnd != L'.' ) )
                    {
                        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                        goto exit;
                    }

                    // if it is greater than 255 than it is invalid
                    if ( dwPartIpAddress > 255 )
                    {
                        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                        goto exit;
                    }

                    // if the address is not zero then remember we
                    // saw a none zero value.
                    if ( dwPartIpAddress != 0 )
                    {
                        fSawOnlyMinValue = FALSE;
                    }

                    // if the address is not 255 then remember we
                    // saw a number less than 255.
                    if ( dwPartIpAddress != 255 )
                    {
                        fSawOnlyMaxValue = FALSE;
                    }

                    // we have seen a valid address.
                    cPartAddresses++;

                    // if we have seen more than 4 parts of an address
                    // then it is invalid.
                    if ( cPartAddresses > 4 )
                    {
                        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                        goto exit;
                    }

                    // now to figure out where to start looking at the
                    // next number.  Advance tha address to the pointer
                    // that follows the number we just looked at.  if it
                    // is a dot then we need to advance one more character.
                    // However, if a dot is followed by a colon it is invalid
                    // so make sure that it is not by checking the next character
                    // as well.
                    pszPartIpAddress = pszEnd;
                    if ( *pszPartIpAddress == L'.' )
                    {
                        // advance past the dot hopefully to a digit.
                        pszPartIpAddress++;

                        // if we see a colon complain, because otherwise we
                        // will stop and think this is ok.
                        if ( *pszPartIpAddress == L':' )
                        {
                            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                            goto exit;
                        }
                    }
                }
                else
                {
                    // if we are not on a digit then it is an error.
                    hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                    goto exit;
                }
            }

            // either we saw no parts or we saw all
            // 4 parts, anything else is a failure.
            if (  cPartAddresses != 0 &&
                  cPartAddresses != 4 )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto exit;
            }


            // If we saw some parts then we had better seen
            // one that was more than the min value ( 0 ) and
            // we had better seen one that was less than the max ( 255 )
            if (  cPartAddresses == 4 &&
                 ( fSawOnlyMinValue ||
                   fSawOnlyMaxValue ) )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto exit;
            }

        }  // end of IPAddress not starting with a *.

    } // end of validation of IPAddress.


    //
    // Validate the ip port.
    //

    if ( *IpPort == L':' )
    {
        // no ip port specified in binding string
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
        goto exit;
    }

    IpPortCharCountSansTermination = (ULONG) DIFF( HostName - IpPort ) - 1;

    // need to make sure the value is a number between 1-65535 and
    // that it is only numbers before the next colon.

    dwPort = wcstoul( IpPort, (WCHAR**) &pszEnd, 10 );
    if ( dwPort == 0 ||
         pszEnd == NULL ||
         *pszEnd != L':' ||
         dwPort > 0xFFFF )  // 65535
    {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
        goto exit;
    }

    //
    // Validate the host-name.
    //

    if ( *HostName == L'\0' )
    {
        // no host-name specified

        HostName = NULL;
    }

    //
    // Now create the UL-style URL prefix.
    //

    hr = pUrlPrefix->Append( pProtocolString, ProtocolStringCharCountSansTermination );

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Appending to string failed\n"
            ));

        goto exit;
    }

    //
    // Determine whether to use host-name, ip address, or "*".
    //

    if ( IpAddress != NULL )
    {
        if ( HostName != NULL )
        {
            //
            // if we have both IpAddress and host name, we
            // will append the host name at this point and the IP
            // later after the port.
            //
            hr = pUrlPrefix->Append( HostName );

        }
        else
        {
            hr = pUrlPrefix->Append( IpAddress, IpAddressCharCountSansTermination );
        }
    }
    else
    {
        if ( HostName != NULL )
        {
            hr = pUrlPrefix->Append( HostName );
        }
        else
        {
            hr = pUrlPrefix->Append( L"*", 1 );
        }
    }

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Appending to string failed\n"
            ));

        goto exit;
    }


    hr = pUrlPrefix->Append( L":", 1 );
    if ( FAILED( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Appending to string failed\n"
            ));

        goto exit;
    }


    hr = pUrlPrefix->Append( IpPort, IpPortCharCountSansTermination );
    if ( FAILED( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Appending to string failed\n"
            ));

        goto exit;
    }

    //
    // If we have both the host header and the ip we
    // will have all ready added the host name, but now
    // we need to add the IP to the end.
    //
    if ( IpAddress != NULL && HostName != NULL )
    {
        hr = pUrlPrefix->Append( L":", 1 );
        if ( FAILED( hr ) )
        {
            DPERROR((
                DBG_CONTEXT,
                hr,
                "Appending to string failed\n"
                ));

            goto exit;
        }

        hr = pUrlPrefix->Append( IpAddress, IpAddressCharCountSansTermination );
        if ( FAILED( hr ) )
        {
            DPERROR((
                DBG_CONTEXT,
                hr,
                "Appending to string failed\n"
                ));

            goto exit;
        }

    }

    IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Converted metabase binding: '%S' to UL binding: '%S'\n",
            pBindingString,
            pUrlPrefix->QueryStr()
            ));
    }


    // Everything went ok, so now we will make the SockAddr
    // for the SSL configuration.  We need to set the port and
    // IP address in.
    
    pSockAddrIn = (SOCKADDR_IN*) pSockAddr;
    pSockAddrIn->sin_family = AF_INET;

    // We can cast because we know the port is less than 
    // or equals 0xFFFF per checks above
    pSockAddrIn->sin_port = htons( (USHORT) dwPort );

    // default it to wild card.
    pSockAddrIn->sin_addr.s_addr = INADDR_ANY;

    // now set it if wild card is not correct.
    if ( IpAddress != NULL )
    {
        STRA strAnsi;

        // Need to convert it to Ansi
        hr = strAnsi.CopyW( IpAddress, IpAddressCharCountSansTermination );
        if ( FAILED ( hr ) ) 
        {
            goto exit;
        }

        // Now convert it to a ULONG.
        pSockAddrIn->sin_addr.s_addr = inet_addr( strAnsi.QueryStr() );

        DBG_ASSERT ( pSockAddrIn->sin_addr.s_addr != INADDR_NONE );
    }

exit:

    //
    // CODEWORK log an event if there was a bad binding string? If so,
    // need to pass down the site information so we can log which site
    // has the bad binding.
    //

    return hr;
}

HRESULT
SITE_DATA_OBJECT::SetFromMetabaseData(
    METADATA_GETALL_RECORD *       pProperties,
    DWORD                          cProperties,
    BYTE *                         pbBase
)
/*++

Routine Description:

    Setup a site data object from metabase properties

Arguments:

    pProperties - Array of metadata properties
    cProperties - Count of metadata properties
    pbBase - Base of offsets in metadata properties

Return Value:

    HRESULT

--*/
{
    DWORD                   dwCounter;
    PVOID                   pvDataPointer;
    METADATA_GETALL_RECORD* pCurrentRecord;
    HRESULT                 hr;
    BOOL                    fInvalidBindings = FALSE;
    DWORD                   fAlwaysNegoClientCert = FALSE;
    BOOL                    fMapper = FALSE;

    if ( pProperties == NULL || pbBase == NULL )
    {
        DBG_ASSERT( pProperties != NULL && 
                    pbBase != NULL );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    for ( dwCounter = 0;
          dwCounter < cProperties;
          dwCounter++ )
    {
        pCurrentRecord = &(pProperties[ dwCounter ]);

        pvDataPointer = (PVOID) ( pbBase + pCurrentRecord->dwMDDataOffset );

        switch ( pCurrentRecord->dwMDIdentifier )
        {
        case MD_APP_APPPOOL_ID:
            hr = _strAppPoolId.Copy( (WCHAR*) pvDataPointer );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            break;

        case MD_SERVER_BINDINGS:

            // Problems with bindings will cause the site to become
            // invalid.  If there are issues while trying to read in
            // the site's binding information, we will leave the binding
            // strings empty.  This will cause the SelfValidation to fail
            // later.  Because both Secure and Server Bindings affect this
            // string, either can invalidate the site based on it's bindings,
            // so we must remember if one all ready has and not setup bindings
            // based on the other property in this case.
            if ( !fInvalidBindings )
            {
                hr = SetupBindings( (WCHAR*) pvDataPointer, FALSE );
                if ( FAILED( hr ) )
                {
                    //
                    // in this case we have a problem with the bindings,
                    // but we don't really want to return an error here,
                    // because it will cause the server to shutdown.  Instead
                    // leaving the binding string empty will allow us to
                    // report an error during self validation.
                    //

                    fInvalidBindings = TRUE;
                    _mszBindings.Reset();

                    hr = S_OK;
                }
            }
            break;

        case MD_SECURE_BINDINGS:

            // Problems with bindings will cause the site to become
            // invalid.  If there are issues while trying to read in
            // the site's binding information, we will leave the binding
            // strings empty.  This will cause the SelfValidation to fail
            // later.  Because both Secure and Server Bindings affect this
            // string, either can invalidate the site based on it's bindings,
            // so we must remember if one all ready has and not setup bindings
            // based on the other property in this case.
            if ( !fInvalidBindings )
            {
                hr = SetupBindings( (WCHAR*) pvDataPointer, TRUE );
                if ( FAILED( hr ) )
                {
                    //
                    // in this case we have a problem with the bindings,
                    // but we don't really want to return an error here,
                    // because it will cause the server to shutdown.  Instead
                    // leaving the binding string empty will allow us to
                    // report an error during self validation.
                    //

                    fInvalidBindings = TRUE;

                    _mszBindings.Reset();

                    hr = S_OK;
                }
            }
            break;

        case MD_SERVER_AUTOSTART:
            _fAutoStart = !!*((DWORD *) pvDataPointer );
            break;

        case MD_LOG_TYPE:
            _dwLogType = *((DWORD *) pvDataPointer );
            break;

        case MD_LOGFILE_PERIOD:
            _dwLogFilePeriod = *((DWORD *) pvDataPointer );
            break;

        case MD_LOGFILE_TRUNCATE_SIZE:
            _dwLogFileTruncateSize = *((DWORD *) pvDataPointer );
            break;

        case MD_LOGEXT_FIELD_MASK:
            _dwLogExtFileFlags = *((DWORD *) pvDataPointer );
            break;

        case MD_LOGFILE_LOCALTIME_ROLLOVER:
            _fLogFileLocaltimeRollover = !!*((DWORD *) pvDataPointer );
            break;

        case MD_LOG_PLUGIN_ORDER:
            hr = _strLogPluginClsid.Copy( (WCHAR*) pvDataPointer );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            break;

        case MD_LOGFILE_DIRECTORY:
            hr = _strLogFileDirectory.Copy( (WCHAR*) pvDataPointer );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            break;

        case MD_SERVER_COMMENT:
            hr = _strServerComment.Copy( (WCHAR*) pvDataPointer );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            break;

        case MD_SERVER_COMMAND:
            _dwServerCommand = *( (DWORD*) pvDataPointer );
            break;

        case MD_MAX_BANDWIDTH:
            _dwMaxBandwidth = *((DWORD *) pvDataPointer );
            break;

        case MD_MAX_CONNECTIONS:

            _dwMaxConnections = *((DWORD *) pvDataPointer );

            IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Setting max connections, %d %d \n",
                            _dwMaxConnections ));
            }

            break;

        case MD_CONNECTION_TIMEOUT:
            _dwConnectionTimeout = *((DWORD *) pvDataPointer );
            
        break;

        case MD_SSL_CERT_HASH:

            DBG_ASSERT( pvDataPointer != NULL );

            if( !_bufCertHash.Resize( pCurrentRecord->dwMDDataLen ) )
            {
                hr = E_OUTOFMEMORY;
                return hr;
            }

            memcpy ( _bufCertHash.QueryPtr(), 
                     pvDataPointer, 
                     pCurrentRecord->dwMDDataLen );

            _cbCertHash = pCurrentRecord->dwMDDataLen;

        break;

        case MD_SSL_CERT_STORE_NAME:

            hr = _strCertStoreName.Copy( (WCHAR*) pvDataPointer );
            if ( FAILED( hr ) )
            {
                return hr;
            }

        break;

        case MD_SSL_CTL_IDENTIFIER:

            hr = _strDefaultSslCtlIdentifier.Copy( (WCHAR*) pvDataPointer );
            if ( FAILED( hr ) )
            {
                return hr;
            }

        break;

        case MD_SSL_CTL_STORE_NAME:

            hr = _strDefaultSslCtlStoreName.Copy( (WCHAR*) pvDataPointer );
            if ( FAILED( hr ) )
            {
                return hr;
            }

        break;

        case MD_CERT_CHECK_MODE:
            _dwDefaultCertCheckMode = *((DWORD *) pvDataPointer );
            
        break;

        case MD_REVOCATION_FRESHNESS_TIME:
            _dwDefaultRevocationFreshnessTime = *((DWORD *) pvDataPointer );
            
        break;

        case MD_REVOCATION_URL_RETRIEVAL_TIMEOUT:
            _dwDefaultRevocationUrlRetrievalTimeout = *((DWORD *) pvDataPointer );
            
        break;

        case MD_SSL_USE_DS_MAPPER:
            
            fMapper = !!*((DWORD *) pvDataPointer );

            if ( fMapper )
            {
                _dwDefaultFlags = _dwDefaultFlags | HTTP_SERVICE_CONFIG_SSL_FLAG_USE_DS_MAPPER;
            }

        break;

        case MD_SSL_ALWAYS_NEGO_CLIENT_CERT:

            fAlwaysNegoClientCert = !!*((DWORD *) pvDataPointer );

            if ( fAlwaysNegoClientCert )
            {
                _dwDefaultFlags = _dwDefaultFlags | HTTP_SERVICE_CONFIG_SSL_FLAG_NEGOTIATE_CLIENT_CERT;
            }

        break;

        }
    }

    return NO_ERROR;
}

VOID
SITE_DATA_OBJECT::UpdateMetabaseWithErrorState(
    )
/*++

Routine Description:

    Updates the metabase to let folks know
    that this site is stopped and that the error
    is invalid argument because a property is wrong.

Arguments:

    None.

Return Value:

    None

--*/
{

    GetWebAdminService()->
             GetConfigAndControlManager()->
             GetConfigManager()->
             SetVirtualSiteStateAndError( QuerySiteId(),
                                          MD_SERVER_STATE_STOPPED,
                                          ERROR_INVALID_PARAMETER );

    SetIsResponsibleForErrorReporting( FALSE );
}


VOID
SITE_DATA_OBJECT::Compare(
    DATA_OBJECT *                  pDataObject
)
/*++

Routine Description:

    Compare a given site object with this one.  This routine sets the
    changed flags as appropriate

Arguments:

    pDataObject - New object to compare to

Return Value:

    None

--*/
{
    SITE_DATA_OBJECT *          pSiteObject;

    if ( pDataObject == NULL )
    {
        DBG_ASSERT( pDataObject != NULL );
        return;
    }

    pSiteObject = (SITE_DATA_OBJECT*) pDataObject;
    DBG_ASSERT( pSiteObject->CheckSignature() );

    //
    // If the application is not in WAS then assume that all the
    // values have changed, because WAS will want to know about all
    // of them.
    //
    if ( pSiteObject->QueryInWas() )
    {

        //
        // we could do a case insenstive check in this case, but since it probably
        // won't change just because of case sensitivity and because the consecuences of
        // processing it if it was only a case change are not that great,
        // we will go ahead and save time by just doing a case
        // sensetive compare.
        //

        if ( _mszBindings.QueryCB() == pSiteObject->_mszBindings.QueryCB() &&
             memcmp( _mszBindings.QueryStr(),
                     pSiteObject->_mszBindings.QueryStr(),
                     _mszBindings.QueryCB() ) == 0 )
        {
            _fBindingsChanged = FALSE;
        }

        if ( _fAutoStart == pSiteObject->_fAutoStart )
        {
            _fAutoStartChanged = FALSE;
        }

        if ( _dwLogType == pSiteObject->_dwLogType )
        {
            _fLogTypeChanged = FALSE;
        }

        if ( _dwLogFilePeriod == pSiteObject->_dwLogFilePeriod )
        {
            _fLogFilePeriodChanged = FALSE;
        }

        if ( _dwLogFileTruncateSize == pSiteObject->_dwLogFileTruncateSize )
        {
            _fLogFileTruncateSizeChanged = FALSE;
        }

        if ( _dwLogExtFileFlags == pSiteObject->_dwLogExtFileFlags )
        {
            _fLogExtFileFlagsChanged = FALSE;
        }

        if ( _fLogFileLocaltimeRollover == pSiteObject->_fLogFileLocaltimeRollover )
        {
            _fLogFileLocaltimeRolloverChanged = FALSE;
        }

        if ( _strLogPluginClsid.Equals( pSiteObject->_strLogPluginClsid ) )
        {
            _fLogPluginClsidChanged = FALSE;
        }

        if ( _strLogFileDirectory.Equals( pSiteObject->_strLogFileDirectory ) )
        {
            _fLogFileDirectoryChanged = FALSE;
        }

        if ( _strServerComment.Equals( pSiteObject->_strServerComment ) )
        {
            _fServerCommentChanged = FALSE;
        }

        if ( _strCertStoreName.Equals( pSiteObject->_strCertStoreName ) )
        {
            _fCertStoreNameChanged = FALSE;
        }

        if ( _dwMaxBandwidth == pSiteObject->_dwMaxBandwidth )
        {
            _fMaxBandwidthChanged = FALSE;
        }

        IF_DEBUG( WEB_ADMIN_SERVICE_WMS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Evaluating max connections, %d %d \n",
                        _dwMaxConnections,
                        pSiteObject->_dwMaxConnections ));
        }

        if ( _dwMaxConnections == pSiteObject->_dwMaxConnections )
        {
            _fMaxConnectionsChanged = FALSE;
        }

        if ( _dwConnectionTimeout == pSiteObject->_dwConnectionTimeout )
        {
            _fConnectionTimeoutChanged = FALSE;
        }

        if ( _strAppPoolId.Equals( pSiteObject->_strAppPoolId ) )
        {
            _fAppPoolIdChanged = FALSE;
        }

        if ( ( _cSockAddrs == 0 &&  pSiteObject->_cSockAddrs == 0 ) ||
             (  ( _cSockAddrs == pSiteObject->_cSockAddrs ) && 
                ( _bufSockAddrs.QuerySize() >= ( _cSockAddrs * sizeof(SOCKADDR) ) ) &&
                ( pSiteObject->_bufSockAddrs.QuerySize() >= ( pSiteObject->_cSockAddrs * sizeof(SOCKADDR) ) ) &&
                ( memcmp ( _bufSockAddrs.QueryPtr(), 
                           pSiteObject->_bufSockAddrs.QueryPtr(), 
                           _cSockAddrs * sizeof(SOCKADDR) ) == 0 )
             )
           )
        {
            _fSockAddrsChanged = FALSE;
        }

        if ( ( _cbCertHash == 0 && pSiteObject->_cbCertHash == 0 ) ||
             (  ( _cbCertHash == pSiteObject->_cbCertHash ) && 
                ( _bufCertHash.QuerySize() >= _cbCertHash ) &&
                ( pSiteObject->_bufCertHash.QuerySize() >= _cbCertHash ) &&
                ( memcmp ( _bufCertHash.QueryPtr(), 
                           pSiteObject->_bufCertHash.QueryPtr(), 
                           _cbCertHash ) == 0 ) ) )
        {
            _fCertHashChanged = FALSE;
        }

        if ( _strCertStoreName.Equals( pSiteObject->_strCertStoreName ) )
        {
            _fCertStoreNameChanged = FALSE;
        }

        if ( _strDefaultSslCtlIdentifier.Equals( pSiteObject->_strDefaultSslCtlIdentifier ) )
        {
            _fDefaultSslCtlIdentifierChanged = FALSE;
        }

        if ( _strDefaultSslCtlStoreName.Equals( pSiteObject->_strDefaultSslCtlStoreName ) )
        {
            _fDefaultSslCtlStoreNameChanged = FALSE;
        }

        if ( _dwDefaultCertCheckMode == pSiteObject->_dwDefaultCertCheckMode )
        {
            _fDefaultCertCheckModeChanged = FALSE;
        }

        if ( _dwDefaultRevocationFreshnessTime == pSiteObject->_dwDefaultRevocationFreshnessTime )
        {
            _fDefaultRevocationFreshnessTimeChanged = FALSE;
        }

        if ( _dwDefaultRevocationUrlRetrievalTimeout == pSiteObject->_dwDefaultRevocationUrlRetrievalTimeout )
        {
            _fDefaultRevocationUrlRetrievalTimeoutChanged = FALSE;
        }

        if ( _dwDefaultFlags == pSiteObject->_dwDefaultFlags )
        {
            _fDefaultFlagsChanged = FALSE;
        }

    } // end of in WAS check
}

BOOL
SITE_DATA_OBJECT::QueryHasChanged(
    VOID
) const
/*++

Routine Description:

    Has anything in this object changed

Arguments:

    None

Return Value:

    TRUE if something has changed (duh!)

--*/
{
    if ( _fBindingsChanged ||
         _fAutoStartChanged ||
         _fLogTypeChanged ||
         _fLogFilePeriodChanged ||
         _fLogFileTruncateSizeChanged ||
         _fLogExtFileFlagsChanged ||
         _fLogFileLocaltimeRolloverChanged ||
         _fLogPluginClsidChanged ||
         _fLogFileDirectoryChanged ||
         _fServerCommentChanged ||
         _fServerCommandChanged ||
         _fMaxBandwidthChanged ||
         _fMaxConnectionsChanged ||
         _fConnectionTimeoutChanged ||
         _fAppPoolIdChanged ||
         _fSockAddrsChanged  ||
         _fCertHashChanged  ||
         _fCertStoreNameChanged ||
         _fDefaultCertCheckModeChanged ||              
         _fDefaultRevocationFreshnessTimeChanged  ||   
         _fDefaultRevocationUrlRetrievalTimeoutChanged ||
         _fDefaultSslCtlIdentifierChanged  ||          
         _fDefaultSslCtlStoreNameChanged ||           
         _fDefaultFlagsChanged  )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

VOID
SITE_DATA_OBJECT::SelfValidate(
    VOID
)
/*++

Routine Description:

    Check this object's internal validity

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD                   dwSiteId = (( SITE_DATA_OBJECT_KEY* ) QueryKey())->QuerySiteId();

    //
    // never bother validating if we are deleting
    // or ignoring this record.
    //
    if ( !QueryWillWasKnowAboutObject() )
    {
        return;
    }

    //
    // we ignore all keys that are not numbers greater than 0
    // so if we get a site with 0 for it's id, this is bad.
    //
    DBG_ASSERT ( dwSiteId != 0 );

    //
    // if the bindings are not valid
    // then we need to report an
    // error back for them.  Note that
    // any validation of them will have been
    // done when we created the binging multisz
    // structure during reading in.  If it failed
    // the bindings string will be empty.
    //
    if ( _mszBindings.IsEmpty() )
    {
        GetWebAdminService()->
        GetWMSLogger()->
        LogSiteBinding( dwSiteId,
                        QueryInWas());

        SetSelfValid( FALSE );

        return;
    }

    if ( _strAppPoolId.IsEmpty() )
    {
        GetWebAdminService()->
        GetWMSLogger()->
        LogSiteAppPoolId( dwSiteId,
                          QueryInWas() );

        SetSelfValid( FALSE );

        return;
    }
}

HRESULT
SITE_DATA_OBJECT_TABLE::ReadFromMetabase(
    IMSAdminBase *             pAdminBase
)
/*++

Routine Description:

    Read all sites in a multiple-threaded manner

Arguments:

    pAdminBase - ABO pointer

Return Value:

    HRESULT

--*/
{
    return ReadFromMetabasePrivate(pAdminBase, TRUE);
}

HRESULT
SITE_DATA_OBJECT_TABLE::ReadFromMetabasePrivate(
    IMSAdminBase *             pAdminBase,
    BOOL                       fMultiThreaded
)
/*++

Routine Description:

    Read all sites in a passed-in-threaded manner

Arguments:

    pAdminBase - ABO pointer
    fMultiThreaded - one thread on multiple threads

Return Value:

    HRESULT

--*/
{
    BOOL                    fRet;
    MB                      mb( pAdminBase );
    BUFFER                  bufPaths;
    
    //
    // Choose an arbitrarily large buffer (if its too small that just means
    // we'll make two ABO calls -> no big deal
    //
    
    fRet = bufPaths.Resize( CHILD_PATH_BUFFER_SIZE );
    if ( !fRet )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    //
    // Get the child paths
    //
    
    fRet = mb.Open( L"LM/W3SVC", METADATA_PERMISSION_READ );
    if ( !fRet )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    fRet = mb.GetChildPaths( L"",
                             &bufPaths );
    if ( !fRet )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    MULTIPLE_THREAD_READER reader;
    return reader.DoWork(this, &mb, (LPWSTR) bufPaths.QueryPtr(), fMultiThreaded);
}

HRESULT
SITE_DATA_OBJECT_TABLE::ReadFromMetabaseChangeNotification(
    IMSAdminBase *              pAdminBase,
    MD_CHANGE_OBJECT            pcoChangeList[],
    DWORD                       dwMDNumElements,
    DATA_OBJECT_TABLE*          pMasterTable
)
/*++

Routine Description:

    Change change notification by building a new table

Arguments:

    pAdminBase - ABO pointer
    pcoChangeList - Properties which have changed
    dwMDNumElements - Number of properties which have changed

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = S_OK;
    DWORD                   i;
    DWORD                   dwSiteId;
    WCHAR *                 pszPath = NULL;
    WCHAR *                 pszPathEnd = NULL;
    SITE_DATA_OBJECT *      pSiteObject = NULL;
    MB                      mb( pAdminBase );
    STACK_BUFFER(           bufProperties, 512 );
    DWORD                   cProperties;
    DWORD                   dwDataSetNumber;
    LK_RETCODE              lkrc;
    BOOL                    fRet;
    DWORD                   dwLastError;
    BOOL                    fReadAllObjects = FALSE;

    UNREFERENCED_PARAMETER ( pMasterTable );

    for ( i = 0; i < dwMDNumElements; i++ )
    {
        //
        // We only care about W3SVC properties (duh!)
        //

        if( _wcsnicmp( pcoChangeList[ i ].pszMDPath,
                       DATA_STORE_SERVER_MB_PATH,
                       DATA_STORE_SERVER_MB_PATH_CCH ) != 0 )
        {
            continue;
        }

        //
        // If a property changed at the W3SVC level, then we need to
        // re-evaluate all the sites (i.e. read all the metabase props) once
        //

        if ( wcslen( pcoChangeList[ i ].pszMDPath ) ==
             DATA_STORE_SERVER_MB_PATH_CCH )
        {
            fReadAllObjects = TRUE;
            continue;
        }

        //
        // Evaluate which site changed
        //

        pszPath = pcoChangeList[ i ].pszMDPath + DATA_STORE_SERVER_MB_PATH_CCH;
        DBG_ASSERT( *pszPath != L'\0' );

        dwSiteId = wcstoul( pszPath, &pszPathEnd, 10 );

        //
        // We only care about sites
        //

        if ( dwSiteId == 0 )
        {
            continue;
        }

        //
        // We only care about site properties set at the site level (not
        // deeper)
        //

        if ( !( *pszPathEnd == L'/' &&
                pszPathEnd[ 1 ] == L'\0' ) )
        {
            continue;
        }

        //
        // Create a site object
        //

        pSiteObject = new SITE_DATA_OBJECT( dwSiteId );
        if ( pSiteObject == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto exit;
        }

        hr = pSiteObject->Create();
        if ( FAILED( hr ) )
        {
            goto exit;
        }

        //
        // before we go looking in the metabase, we need to
        // mark the server command if it really changed.
        //
        if ( pcoChangeList[ i ].dwMDChangeType & MD_CHANGE_TYPE_SET_DATA )
        {
            // we need to check the Columns that changed if we find one
            // is the ServerCommand we want to honor it.

            for ( DWORD j = 0; j < pcoChangeList[ i ].dwMDNumDataIDs; j++ )
            {
                if ( pcoChangeList[ i ].pdwMDDataIDs[ j ] == MD_SERVER_COMMAND )
                {
                    pSiteObject->SetServerCommandChanged( TRUE );
                    break;
                }
            }
        }

        //
        // If we are deleting the site, then mark it as such
        // otherwise read it's info from the metabase.
        //
        if (  pcoChangeList[ i ].dwMDChangeType & MD_CHANGE_TYPE_DELETE_OBJECT  )
        {
            pSiteObject->SetDeleteWhenDone( TRUE );
        }
        else
        {
            // read the data from the metabase.

            fRet = mb.Open( L"", METADATA_PERMISSION_READ );

            if ( !fRet )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto exit;
            }

            fRet = mb.GetAll( pcoChangeList[ i ].pszMDPath,
                              METADATA_INHERIT | METADATA_PARTIAL_PATH | METADATA_NON_SECURE_ONLY, 
                              IIS_MD_UT_SERVER,
                              &bufProperties,
                              &cProperties,
                              &dwDataSetNumber );

            dwLastError = fRet ? ERROR_SUCCESS : GetLastError();

            mb.Close();

            if ( !fRet )
            {
                // if we can not find the key then a delete
                // for the object is on it's way, so we can
                // ignore this change notification.

                if ( dwLastError == ERROR_PATH_NOT_FOUND ||
                     dwLastError == ERROR_FILE_NOT_FOUND )
                {
                    pSiteObject->DereferenceDataObject();
                    pSiteObject = NULL;

                    continue;
                }

                hr = HRESULT_FROM_WIN32( dwLastError );
                goto exit;
            }

            hr = pSiteObject->SetFromMetabaseData( (METADATA_GETALL_RECORD*)
                                                bufProperties.QueryPtr(),
                                                cProperties,
                                                (PBYTE) bufProperties.QueryPtr() );
            if ( FAILED( hr ) )
            {
                goto exit;
            }
        }

        //
        // Finally, add the site to the hash table
        //
        // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        //
        // General rule about inserting into tables:
        //
        // For Initial Processing and Complete processing caused by
        // a change notification, we will always ignore inserting a
        // object if we fine an object all ready in the table.  This is because
        // during a change notification if a record was added by the change
        // notification code, it will be more correct ( like knowing if ServerCommand
        // actually changed ), then the new generic record that was read because
        // of a change to a hire node.  Also during initial read we should
        // not have to make this decision so we can still ignore if we do see it.
        //
        // For Change Processing we will need to evaluate the change that
        // all ready exists and compare it with the new change to decide
        // what change we should make.
        //
        // In this case if we find a record all ready existing we need to determine
        // and we are inserting an update that does not have the ServerCommand set
        // we need to determine if the original record had the ServerCommand set, if
        // it did we don't want to insert the new record, otherwise we will.
        // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


        lkrc = InsertRecord( (DATA_OBJECT*) pSiteObject );
        if ( lkrc != LK_SUCCESS  )
        {
            // So we found an existing key, now we have to decide
            // what to do.
            if ( lkrc == LK_KEY_EXISTS )
            {
                BOOL fOverwrite = TRUE;

                // If the new object is not a deletion and it does
                // not all ready have the AppPoolCommandChange set
                // we will need to decide if we should not overwrite
                // the existing object.  If the new object is a deletion
                // or it does have the app pool command set then we
                // will go ahead with it because the old object just
                // doesn't matter to us.

                if ( !pSiteObject->QueryDeleteWhenDone() &&
                     !pSiteObject->QueryServerCommandChanged() )
                {
                    SITE_DATA_OBJECT *  pFoundObject = NULL;

                    // Find the existing record in the table
                    // and check if the AppPoolCommand has changed
                    // if it has not then we can overwrite it.

                    lkrc = FindKey( pSiteObject->QueryKey(),
                                   ( DATA_OBJECT** )&pFoundObject );

                    // we just were told this record existed so
                    // make sure we weren't lied to.
                    DBG_ASSERT ( lkrc == LK_SUCCESS && pFoundObject != NULL );

                    //
                    // Only if the old object was a simple update
                    // and it had the ServerCommand set do we honor
                    // that object.
                    //
                    if ( !pFoundObject->QueryDeleteWhenDone() &&
                         pFoundObject->QueryServerCommandChanged() )
                    {
                        fOverwrite = FALSE;
                    }

                    // release the found object
                    if ( pFoundObject )
                    {
                        pFoundObject->DereferenceDataObject();
                        pFoundObject = NULL;
                    }
                }

                if ( fOverwrite )
                {
                    lkrc = InsertRecord( (DATA_OBJECT*) pSiteObject, TRUE );
                    if ( lkrc != LK_SUCCESS )
                    {
                        hr = HRESULT_FROM_WIN32( lkrc );
                        goto exit;
                    }
                }

            }
            else
            {
                hr = HRESULT_FROM_WIN32( lkrc );
                goto exit;
            }
        }

        pSiteObject->DereferenceDataObject();
        pSiteObject = NULL;

    }

    //
    // if we detected that a higher up change might affect
    // the sites, then re-read all the app pool properties.
    //

    if ( fReadAllObjects )
    {
        hr = ReadFromMetabasePrivate( pAdminBase, FALSE );
    }

exit:

    if ( pSiteObject )
    {
        pSiteObject->DereferenceDataObject();
        pSiteObject = NULL;
    }

    return hr;
}

HRESULT
SITE_DATA_OBJECT_TABLE::DoThreadWork(
    LPWSTR                 pszString,
    LPVOID                 pContext
)
/*++

Routine Description:

    Main thread worker routine

Arguments:

    pszString - site id to potentially load
    pContext - MB pointer opened to w3svc node

Return Value:

    DWORD

--*/
{
    MB *                    mb = (MB *) pContext;
    BOOL                    fRet;
    STACK_BUFFER(           bufProperties, 512 );
    DWORD                   cProperties;
    DWORD                   dwDataSetNumber;
    HRESULT                 hr = S_OK;
    DWORD                   dwSiteId;
    WCHAR *                 pszEnd = NULL;
    SITE_DATA_OBJECT *      pSiteObject = NULL;
    LK_RETCODE              lkrc;

    WCHAR *                 pszSite = pszString;

    DBG_ASSERT(pContext && pszString);

    fRet = mb->GetAll( pszSite,
                      METADATA_INHERIT | METADATA_PARTIAL_PATH | METADATA_NON_SECURE_ONLY,
                      IIS_MD_UT_SERVER,
                      &bufProperties,
                      &cProperties,
                      &dwDataSetNumber );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }

    //
    // Determine the site ID.  If invalid, just skip to next
    //

    dwSiteId = wcstoul( pszSite, &pszEnd, 10 );
    if ( dwSiteId == 0 )
    {
        hr = S_OK;
        goto exit;
    }

    //
    // Create a site config
    //

    pSiteObject = new SITE_DATA_OBJECT( dwSiteId );
    if ( pSiteObject == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto exit;
    }

    hr = pSiteObject->Create();
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    //
    // Read the configuration from the metabase
    //

    hr = pSiteObject->SetFromMetabaseData( (METADATA_GETALL_RECORD*)
                                        bufProperties.QueryPtr(),
                                        cProperties,
                                        (PBYTE) bufProperties.QueryPtr() );
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    //
    // Finally, add the site to the hash table
    //

    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    //
    // General rule about inserting into tables:
    //
    // For Initial Processing and Complete processing caused by
    // a change notification, we will always ignore inserting a
    // object if we fine an object all ready in the table.  This is because
    // during a change notification if a record was added by the change
    // notification code, it will be more correct ( like knowing if ServerCommand
    // actually changed ), then the new generic record that was read because
    // of a change to a hire node.  Also during initial read we should
    // not have to make this decision so we can still ignore if we do see it.
    //
    // For Change Processing we will need to evaluate the change that
    // all ready exists and compare it with the new change to decide
    // what change we should make.
    //
    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    lkrc = InsertRecord( (DATA_OBJECT*) pSiteObject );
    if ( lkrc != LK_SUCCESS && lkrc != LK_KEY_EXISTS )
    {
        hr = HRESULT_FROM_WIN32( lkrc );
        goto exit;
    }

    hr = S_OK;

exit:

    if ( pSiteObject )
    {
        pSiteObject->DereferenceDataObject();
        pSiteObject = NULL;
    }

    return hr;
}

//static
LK_ACTION
SITE_DATA_OBJECT_TABLE::CreateWASObjectsAction(
    IN DATA_OBJECT * pObject,
    IN LPVOID 
    )
/*++

Routine Description:

    Handles determining if the site data object
    should be added to WAS's known sites

Arguments:

    IN DATA_OBJECT* pObject = the site to decide about
    IN LPVOID pTableVoid    = pointer back to the table the
                              pObject is from

Return Value:

    LK_ACTION

--*/

{

    DBG_ASSERT ( pObject );

    SITE_DATA_OBJECT* pSiteObject = (SITE_DATA_OBJECT*) pObject;
    DBG_ASSERT( pSiteObject->CheckSignature() );

    if ( pSiteObject->QueryShouldWasInsert() )
    {
        GetWebAdminService()->
             GetUlAndWorkerManager()->
             CreateVirtualSite( pSiteObject );
    }

    return LKA_SUCCEEDED;
}

//static
LK_ACTION
SITE_DATA_OBJECT_TABLE::UpdateWASObjectsAction(
    IN DATA_OBJECT * pObject,
    IN LPVOID 
    )
/*++

Routine Description:

    Handles determining if the site data object
    should be updated in WAS's known sites

Arguments:

    IN DATA_OBJECT* pObject = the site to decide about

Return Value:

    LK_ACTION

--*/
{

    DBG_ASSERT ( pObject );

    SITE_DATA_OBJECT* pSiteObject = (SITE_DATA_OBJECT*) pObject;
    DBG_ASSERT( pSiteObject->CheckSignature() );

    if ( pSiteObject->QueryShouldWasUpdate() )
    {
        GetWebAdminService()->
             GetUlAndWorkerManager()->
             ModifyVirtualSite( pSiteObject );
    }

    return LKA_SUCCEEDED;
}

//static
LK_ACTION
SITE_DATA_OBJECT_TABLE::DeleteWASObjectsAction(
    IN DATA_OBJECT * pObject,
    IN LPVOID 
    )
/*++

Routine Description:

    Handles determining if the site data object
    should be deleted from WAS's known sites

Arguments:

    IN DATA_OBJECT* pObject = the site to decide about

Return Value:

    LK_ACTION

--*/
{

    DBG_ASSERT ( pObject );

    SITE_DATA_OBJECT* pSiteObject = (SITE_DATA_OBJECT*) pObject;
    DBG_ASSERT( pSiteObject->CheckSignature() );

    if ( pSiteObject->QueryShouldWasDelete() )
    {
        GetWebAdminService()->
             GetUlAndWorkerManager()->
             DeleteVirtualSite( pSiteObject,
                                pSiteObject->QueryDeleteWhenDone() ? S_OK : E_INVALIDARG );
    }

    return LKA_SUCCEEDED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\virtual_site_table.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    virtual_site_table.cxx

Abstract:

    This class is a hashtable which manages the set of virtual sites.

    Threading: Always called on the main worker thread.

Author:

    Seth Pollack (sethp)        03-Nov-1998

Revision History:

--*/



#include "precomp.h"



/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities 
    which may hold a reference to this object to release that reference 
    (and not take any more), in order to break reference cycles. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
VIRTUAL_SITE_TABLE::Terminate(
    )
{

    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;

    
    //
    // BUGBUG Iterating in order to clean up, remove, and delete each 
    // element of the table is difficult to do with lkhash today.
    // GeorgeRe plans to fix this eventually. For now, the alternative
    // is to iterate through the table building up in list of all the 
    // elements, and then go through the list and shutdown, remove, and
    // delete each element -- yuck!!
    //
    // Once this gets fixed, we can see if it is valuable to unify any
    // table management code between the app pool, virtual site,
    // and application tables.
    //
    LIST_ENTRY DeleteListHead;
    PLIST_ENTRY pDeleteListEntry = NULL;
    VIRTUAL_SITE * pVirtualSite = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;
    HRESULT hr = S_OK;


    InitializeListHead( &DeleteListHead );

    
    CountOfElementsInTable = Size();


    //
    // Note that for good form we grab the write lock since we will be 
    // modifying objects in the table (although no other thread should 
    // touch this data structure anyways).
    //
    
    SuccessCount = Apply( 
                        DeleteVirtualSiteAction,
                        &DeleteListHead,
                        LKL_WRITELOCK
                        );
    
    DBG_ASSERT( SuccessCount == CountOfElementsInTable );


    // now for each, clean it up, remove it from the table, and delete it
    
    while (  ! IsListEmpty( &DeleteListHead )  )
    {
    
        pDeleteListEntry = RemoveHeadList( &DeleteListHead );

        DBG_ASSERT( pDeleteListEntry != NULL );

        pVirtualSite = VIRTUAL_SITE::VirtualSiteFromDeleteListEntry( pDeleteListEntry );

        // remove it from the table

        ReturnCode = DeleteRecord( pVirtualSite );

        if ( ReturnCode != LK_SUCCESS )
        {

            hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Removing virtual site from hashtable failed\n"
                ));

        }


        //
        // All remaining shutdown work for the virtual site is done 
        // in it's destructor.
        //

        delete pVirtualSite;

    }


    return;

}   // VIRTUAL_SITE_TABLE::Terminate

/***************************************************************************++

Routine Description:

    Setup the _Total counters instance and then walk through each of the 
    sites and let them dump their counters shared memory.

Arguments:

    PERF_MANAGER* pManager - The perf manager that controls the shared memory.
    BOOL StructChanged     - whether or not we need to resetup all the shared memory.

Return Value:

    None.

--***************************************************************************/

VOID
VIRTUAL_SITE_TABLE::ReportPerformanceInfo(
    PERF_MANAGER* pManager,
    BOOL StructChanged
    )
{

    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;
 

    if ( pManager )
    {
        //
        // Need to add in an entry for the _Total counters
        // even if we aren't going to have any sites.
        //
        pManager->SetupTotalSite( StructChanged );
    }

    CountOfElementsInTable = Size();

    //
    // Note that for good form we grab the write lock since we will be 
    // modifying objects in the table (although no other thread should 
    // touch this data structure anyways).
    //
    SuccessCount = Apply( 
                        ReportCountersVirtualSiteAction,
                        (LPVOID) pManager,
                        LKL_WRITELOCK
                        );
    
    DBG_ASSERT( SuccessCount == CountOfElementsInTable );


    return;

}   // VIRTUAL_SITE_TABLE::ReportPerformanceInfo


/***************************************************************************++

Routine Description:

    A routine that may be applied to all VIRTUAL_SITEs in the hashtable
    to prepare for termination. Conforms to the PFnRecordAction prototype.

Arguments:

    pVirtualSite - The virtual site.

    pDeleteListHead - List head into which to insert the virtual site for
    later deletion.

Return Value:

    LK_ACTION - LKA_SUCCEEDED always.

--***************************************************************************/

// note: static!
LK_ACTION
VIRTUAL_SITE_TABLE::DeleteVirtualSiteAction(
    IN VIRTUAL_SITE * pVirtualSite, 
    IN VOID * pDeleteListHead
    )
{

    DBG_ASSERT( pVirtualSite != NULL );
    DBG_ASSERT( pDeleteListHead != NULL );


    InsertHeadList( 
        ( PLIST_ENTRY ) pDeleteListHead,
        pVirtualSite->GetDeleteListEntry()
        );


    return LKA_SUCCEEDED;
    
}   // VIRTUAL_SITE_TABLE::DeleteVirtualSiteAction

/***************************************************************************++

Routine Description:

    Has the virtual site record it's current state in the metabase.

Arguments:

    pVirtualSite - The virtual site.

    pIgnored - Needed for signature but not used.

Return Value:

    LK_ACTION - LKA_SUCCEEDED always.

--***************************************************************************/
// note: static!
LK_ACTION
VIRTUAL_SITE_TABLE::RecordVirtualSiteStatesAction(
    IN VIRTUAL_SITE * pVirtualSite, 
    IN VOID * pIgnored
    )
{

    DBG_ASSERT( pVirtualSite != NULL );
    UNREFERENCED_PARAMETER( pIgnored );

    // let the metabase know that the state of the app pool has changed
    pVirtualSite->RecordState();

    return LKA_SUCCEEDED;
    
}   // VIRTUAL_SITE_TABLE::RecordVirtualSiteStatesAction


/***************************************************************************++

Routine Description:

    A routine that may be applied to all VIRTUAL_SITEs in the hashtable
    to report perf counters.

Arguments:

    pVirtualSite - The virtual site.

    VOID* pManagerVoid - The perf manager used to process the site info.


Return Value:

    LK_ACTION - LKA_SUCCEEDED always.

--***************************************************************************/

// note: static!
LK_ACTION
VIRTUAL_SITE_TABLE::ReportCountersVirtualSiteAction(
    IN VIRTUAL_SITE* pVirtualSite, 
    IN LPVOID pManagerVoid
    )
{

    DBG_ASSERT( pVirtualSite != NULL );

    PERF_MANAGER* pManager = (PERF_MANAGER*) pManagerVoid;

    DBG_ASSERT( pManager == NULL || pManager->CheckSignature());

    // For each site we want to do:
    //
    //       a)  adjust the max values of the site counters
    //       b)  if there has been a struct change copy in
    //           the instance information and store the offset.
    //       c)  copy in the counter values
    //       d)  increment the _Total with the new values.
    //       e)  zero out the appropriate sites counters

    //
    // This routine can be called with a NULL Manager,
    // if we are only trying to cleanup the Site Information
    // because something went wrong when gathering counters.
    //
    if ( pManager )
    {
        //
        // First let the site adjust it's MaxValues
        //
        pVirtualSite->AdjustMaxValues();

        //
        // The OffsetInMemory will be incremented each time 
        // we assign a new site space in the block.  So the 
        // next site can use the Offset to find it's spot.
        //
        pManager->SetupVirtualSite( pVirtualSite );
    }

    //
    // Now that the counters have been reported we can
    // zero out the appropriate ones.
    //
    pVirtualSite->ClearAppropriatePerfValues();

    return LKA_SUCCEEDED;
    
}   // VIRTUAL_SITE_TABLE::ReportCountersVirtualSiteAction


#if DBG
/***************************************************************************++

Routine Description:

    Debug dump the table.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
VIRTUAL_SITE_TABLE::DebugDump(
    )
{

    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;


    CountOfElementsInTable = Size();


    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Dumping virtual site table; total count: %lu\n",
            CountOfElementsInTable
            ));
    }


    SuccessCount = Apply( 
                        DebugDumpVirtualSiteAction,
                        NULL
                        );
    
    DBG_ASSERT( SuccessCount == CountOfElementsInTable );


    return;

}   // VIRTUAL_SITE_TABLE::DebugDump



/***************************************************************************++

Routine Description:

    A routine that may be applied to all VIRTUAL_SITEs in the hashtable
    to perform a debug dump. Conforms to the PFnRecordAction prototype.

Arguments:

    pVirtualSite - The virtual site.

    pIgnored - Ignored.

Return Value:

    LK_ACTION - LKA_SUCCEEDED always.

--***************************************************************************/

// note: static!
LK_ACTION
VIRTUAL_SITE_TABLE::DebugDumpVirtualSiteAction(
    IN VIRTUAL_SITE * pVirtualSite, 
    IN VOID * pIgnored
    )
{

    DBG_ASSERT( pVirtualSite != NULL );
    UNREFERENCED_PARAMETER( pIgnored );


    pVirtualSite->DebugDump();
    

    return LKA_SUCCEEDED;
    
}   // VIRTUAL_SITE_TABLE::DebugDumpVirtualSiteAction
#endif  // DBG



/***************************************************************************++

Routine Description:

    Process a site control operation, for all sites. 

Arguments:

    Command - The command issued.

Return Value:

    VOID

--***************************************************************************/

VOID
VIRTUAL_SITE_TABLE::ControlAllSites(
    IN DWORD Command
    )
{

    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;


    CountOfElementsInTable = Size();


    SuccessCount = Apply( 
                        ControlAllSitesVirtualSiteAction,
                        &Command
                        );


    //
    // Control operations can reasonably fail, depending on the current
    // state of a particular site. So ignore errors here. 
    //

}   // VIRTUAL_SITE_TABLE::ControlAllSites



/***************************************************************************++

Routine Description:

    A routine that may be applied to all virtual sites in the hashtable
    to send a state control command. Conforms to the PFnRecordAction 
    prototype.

Arguments:

    pVirtualSite - The app pool.

    pCommand - The command to apply to the site.

Return Value:

    LK_ACTION

--***************************************************************************/

// note: static!
LK_ACTION
VIRTUAL_SITE_TABLE::ControlAllSitesVirtualSiteAction(
    IN VIRTUAL_SITE * pVirtualSite, 
    IN VOID * pCommand
    )
{

    DWORD NewState = MD_SERVER_STATE_INVALID;

    DBG_ASSERT( pVirtualSite != NULL );
    DBG_ASSERT( pCommand != NULL );

    //
    // Process the state change command. 
    //

    pVirtualSite->ProcessStateChangeCommand( * ( reinterpret_cast<DWORD*>( pCommand ) ), FALSE, &NewState );

    return LKA_SUCCEEDED;
    
}   // VIRTUAL_SITE_TABLE::ControlAllSitesVirtualSiteAction
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\ul_and_worker_manager.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    ul_and_worker_manager.h

Abstract:

    The IIS web admin service UL and worker manager class definition.

Author:

    Seth Pollack (sethp)        01-Oct-1998

Revision History:

--*/


#ifndef _UL_AND_WORKER_MANAGER_H_
#define _UL_AND_WORKER_MANAGER_H_



//
// forward references
//

class WEB_ADMIN_SERVICE;



//
// common #defines
//

#define UL_AND_WORKER_MANAGER_SIGNATURE         CREATE_SIGNATURE( 'ULWM' )
#define UL_AND_WORKER_MANAGER_SIGNATURE_FREED   CREATE_SIGNATURE( 'ulwX' )



//
// structs, enums, etc.
//

// UL&WM states
enum UL_AND_WORKER_MANAGER_STATE
{

    //
    // The object is not yet initialized.
    //
    UninitializedUlAndWorkerManagerState = 1,

    //
    // The UL&WM is running normally.
    //
    RunningUlAndWorkerManagerState,

    //
    // The UL&WM is shutting down. It may be waiting for it's 
    // app pools to shut down too. 
    //
    ShutdownPendingUlAndWorkerManagerState,

    //
    // The UL&WM is now doing it's termination cleanup work. 
    //
    TerminatingUlAndWorkerManagerState,

};

//
// prototypes
//

class UL_AND_WORKER_MANAGER
{

public:

    UL_AND_WORKER_MANAGER(
        );

    virtual
    ~UL_AND_WORKER_MANAGER(
        );

    HRESULT
    Initialize(
        );

    VOID
    CreateAppPool(
        IN APP_POOL_DATA_OBJECT* pAppPoolObject
        );

    VOID
    CreateVirtualSite(
        IN SITE_DATA_OBJECT* pSiteObject
        );

    VOID
    CreateApplication(
        IN APPLICATION_DATA_OBJECT *  pAppObject
        );

    VOID
    DeleteAppPool(
        IN APP_POOL_DATA_OBJECT *  pAppObject,
        IN HRESULT hrToReport
        );

    VOID
    DeleteVirtualSite(
        IN SITE_DATA_OBJECT* pSiteObject,
        IN HRESULT hrToReport
        );

    VOID
    DeleteApplication(
        IN LPWSTR  pApplicationUrl,
        IN DWORD   VirtualSiteId
        );

    HRESULT
    DeleteApplicationInternal(
        IN APPLICATION** ppApplication
        );

    VOID
    ModifyAppPool(
        IN APP_POOL_DATA_OBJECT* pAppPoolObject
        );

    VOID
    ModifyVirtualSite(
        IN SITE_DATA_OBJECT* pSiteObject
        );

    VOID
    ModifyApplication(
        IN APPLICATION_DATA_OBJECT *  pAppObject
        );

    VOID
    ModifyGlobalData(
        IN GLOBAL_DATA_OBJECT* pGlobalObject
        );

    HRESULT
    RecycleAppPool(
        IN LPCWSTR pAppPoolId
        );

    VOID
    ControlAllSites(
        IN DWORD Command
        );

    HRESULT
    ActivateUl(
        );

    VOID
    DeactivateUl(
        );

    inline
    HANDLE
    GetUlControlChannel(
        )
        const
    {
        DBG_ASSERT( m_UlControlChannel != NULL );
        return m_UlControlChannel;
    }

    VOID
    Shutdown(
        );

    VOID
    Terminate(
        );

    HRESULT 
    StartInetinfoWorkerProcess(
        );
     

#if DBG
    VOID
    DebugDump(
        );
#endif  // DBG

    VOID
    RemoveAppPoolFromTable(
        IN APP_POOL * pAppPool
        );

    VOID
    ActivatePerfCounters(
        );

    VOID
    ActivateASPCounters(
        );

    PERF_MANAGER*
    GetPerfManager(
        )
    { 
        //
        // Note this can be null 
        // if perf counters are not
        // enabled.
        // 

        return m_pPerfManager;
    }

    CASPPerfManager*
    GetAspPerfManager(
        )
    {  
        if ( m_ASPPerfInit )
        {
            return &m_ASPPerfManager;
        }
        else
        {
            return NULL;
        }
    }
    

    DWORD
    RequestCountersFromWorkerProcesses(
        )
    {
        return m_AppPoolTable.RequestCounters();
    }

    VOID
    ResetAllWorkerProcessPerfCounterState(
        )
    {
        m_AppPoolTable.ResetAllWorkerProcessPerfCounterState();
    }

    VOID
    ReportVirtualSitePerfInfo(
        PERF_MANAGER* pManager,
        BOOL          StructChanged
        )
    {
        m_VirtualSiteTable.ReportPerformanceInfo(pManager, StructChanged);
    }

    DWORD
    GetNumberofVirtualSites(
        )
    {
        return m_VirtualSiteTable.Size();
    }

    VIRTUAL_SITE*
    GetVirtualSite(
        IN DWORD SiteId
        );

    BOOL 
    CheckSiteChangeFlag(
        )
    {
        return m_SitesHaveChanged;
    }

    VOID 
    ResetSiteChangeFlag(
        )
    {
        //
        // reset it appropriately.
        //
        m_SitesHaveChanged = FALSE;
    }

    HRESULT
    RecoverFromInetinfoCrash(
        );

    BOOL
    AppPoolsExist(
        )
    {
        return ( m_AppPoolTable.Size() > 0 );
    }

    VOID
    RecordSiteStates(
        );

    VOID
    RecordPoolStates(
        BOOL fRecycleAsWell
        );

private:

	UL_AND_WORKER_MANAGER( const UL_AND_WORKER_MANAGER & );
	void operator=( const UL_AND_WORKER_MANAGER & );

    HRESULT
    SetUlMasterState(
        IN HTTP_ENABLED_STATE NewState
        );

    VOID
    CheckIfShutdownUnderwayAndNowCompleted(
        );

    VOID
    ConfigureLogging(
        IN GLOBAL_DATA_OBJECT* pGlobalObject
        );

    VOID
    DeleteSSLConfigStoreInfo(
        );

    DWORD m_Signature;

    // object state
    UL_AND_WORKER_MANAGER_STATE m_State;

    // hashtable of app pools
    APP_POOL_TABLE m_AppPoolTable;

    // hashtable of virtual sites
    VIRTUAL_SITE_TABLE m_VirtualSiteTable;

    // hashtable of applications
    APPLICATION_TABLE m_ApplicationTable;

    // performance counters manager
    PERF_MANAGER* m_pPerfManager;

    // ASP Perf counter stuff
    CASPPerfManager  m_ASPPerfManager;

    // Did ASP Perf init correctly.
    BOOL m_ASPPerfInit;

    // has UL been initialized
    BOOL m_UlInitialized;

    // UL control
    HANDLE m_UlControlChannel;

    BOOL m_SitesHaveChanged;
};  // class UL_AND_WORKER_MANAGER



#endif  // _UL_AND_WORKER_MANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\virtual_site.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    virtual_site.cxx

Abstract:

    This class encapsulates a single virtual site. 

    Threading: Always called on the main worker thread.

Author:

    Seth Pollack (sethp)        04-Nov-1998

Revision History:

--*/


#include "precomp.h"
#include "ilogobj.hxx"
#include <limits.h>

VOID
ApplyRangeCheck( 
    DWORD   dwValue,
    DWORD   dwSiteId,
    LPCWSTR pPropertyName,
    DWORD   dwDefaultValue,
    DWORD   dwMinValue,
    DWORD   dwMaxValue,
    DWORD*  pdwValueToUse 
    );

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Structure for mapping counters from the structure they come
// in as to the structure they go out as.
//
struct PROP_MAP
{
    DWORD PropDisplayOffset;
    DWORD PropInputId;
};

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Structure for mapping MAX counters from the structure they are
// stored as to the structure they go out as.
//
struct PROP_MAX_DESC
{
    ULONG SafetyOffset;
    ULONG DisplayOffset;
    ULONG size;
};


//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Macro for defining mapping of MAX site counters.
//
#define DECLARE_MAX_SITE(Counter)  \
        {   \
        FIELD_OFFSET( W3_MAX_DATA, Counter ),\
        FIELD_OFFSET( W3_COUNTER_BLOCK, Counter ),\
        RTL_FIELD_SIZE( W3_COUNTER_BLOCK, Counter )\
    }

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Mapping of Site MAX Fields as they are passed in from
// the perf manager to how the fields are displayed out.
//
PROP_MAX_DESC g_aIISSiteMaxDescriptions[] =
{
    DECLARE_MAX_SITE ( MaxAnonymous ),
    DECLARE_MAX_SITE ( MaxConnections ),
    DECLARE_MAX_SITE ( MaxCGIRequests ),
    DECLARE_MAX_SITE ( MaxBGIRequests ),
    DECLARE_MAX_SITE ( MaxNonAnonymous )
};
DWORD g_cIISSiteMaxDescriptions = sizeof (g_aIISSiteMaxDescriptions) / sizeof( PROP_MAX_DESC );


//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Mapping of performance counter data from the form it comes in
// as to the form that it goes out to perfmon as.
//
PROP_MAP g_aIISWPSiteMappings[] =
{
    { FIELD_OFFSET( W3_COUNTER_BLOCK, FilesSent), WPSiteCtrsFilesSent },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, FilesReceived), WPSiteCtrsFilesReceived },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, FilesTotal), WPSiteCtrsFilesTransferred },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, CurrentAnonymous), WPSiteCtrsCurrentAnonUsers },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, CurrentNonAnonymous), WPSiteCtrsCurrentNonAnonUsers },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalAnonymous), WPSiteCtrsAnonUsers },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalNonAnonymous), WPSiteCtrsNonAnonUsers },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, MaxAnonymous), WPSiteCtrsMaxAnonUsers },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, MaxNonAnonymous), WPSiteCtrsMaxNonAnonUsers },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, LogonAttempts), WPSiteCtrsLogonAttempts },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalOptions), WPSiteCtrsOptionsReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalPosts), WPSiteCtrsPostReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalGets), WPSiteCtrsGetReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalHeads), WPSiteCtrsHeadReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalPuts), WPSiteCtrsPutReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalDeletes), WPSiteCtrsDeleteReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalTraces), WPSiteCtrsTraceReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalMove), WPSiteCtrsMoveReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalCopy), WPSiteCtrsCopyReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalMkcol), WPSiteCtrsMkcolReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalPropfind), WPSiteCtrsPropfindReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalProppatch), WPSiteCtrsProppatchReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalSearch), WPSiteCtrsSearchReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalLock), WPSiteCtrsLockReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalUnlock), WPSiteCtrsUnlockReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalOthers), WPSiteCtrsOtherReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalCGIRequests), WPSiteCtrsCgiReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalBGIRequests), WPSiteCtrsIsapiExtReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, CurrentCGIRequests), WPSiteCtrsCurrentCgiReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, CurrentBGIRequests), WPSiteCtrsCurrentIsapiExtReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, MaxCGIRequests), WPSiteCtrsMaxCgiReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, MaxBGIRequests), WPSiteCtrsMaxIsapiExtReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalNotFoundErrors), WPSiteCtrsNotFoundErrors },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalLockedErrors), WPSiteCtrsLockedErrors },
};
DWORD g_cIISWPSiteMappings = sizeof (g_aIISWPSiteMappings) / sizeof( PROP_MAP );


//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
#define ULSiteMapMacro(display_counter, ul_counter) \
    { FIELD_OFFSET( W3_COUNTER_BLOCK, display_counter), HttpSiteCounter ## ul_counter }

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Mapping of site data in the form it comes from UL to the form
// it goes out to be displayed in.
//
PROP_MAP aIISULSiteMappings[] =
{
    ULSiteMapMacro ( BytesSent, BytesSent ),
    ULSiteMapMacro ( BytesReceived, BytesReceived ),
    ULSiteMapMacro ( BytesTotal, BytesTransfered ),
    ULSiteMapMacro ( CurrentConnections, CurrentConns ),
    ULSiteMapMacro ( MaxConnections, MaxConnections ),

    ULSiteMapMacro ( ConnectionAttempts, ConnAttempts ),
    ULSiteMapMacro ( TotalGets, GetReqs ),
    ULSiteMapMacro ( TotalHeads, HeadReqs ),
    
    ULSiteMapMacro ( TotalRequests, AllReqs ),
    ULSiteMapMacro ( MeasuredBandwidth, MeasuredIoBandwidthUsage ),
    ULSiteMapMacro ( TotalBlockedBandwidthBytes, TotalBlockedBandwidthBytes ),
    ULSiteMapMacro ( CurrentBlockedBandwidthBytes, CurrentBlockedBandwidthBytes ),

};
DWORD cIISULSiteMappings = sizeof (aIISULSiteMappings) / sizeof( PROP_MAP );

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Mapping of performance counter data in the form it goes out,
// this is used to handle calculating totals.
//
PROP_DISPLAY_DESC aIISSiteDescription[] =
{
    { FIELD_OFFSET( W3_COUNTER_BLOCK, FilesSent),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, FilesSent) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, FilesReceived),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, FilesReceived) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, FilesTotal),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, FilesTotal) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, CurrentAnonymous),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, CurrentAnonymous) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, CurrentNonAnonymous),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, CurrentNonAnonymous) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalAnonymous),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalAnonymous) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalNonAnonymous),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalNonAnonymous) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, MaxAnonymous),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, MaxAnonymous) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, MaxNonAnonymous),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, MaxNonAnonymous) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, LogonAttempts),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, LogonAttempts) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalOptions),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalOptions) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalPosts),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalPosts) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalGets),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalGets) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalHeads),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalHeads) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalPuts),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalPuts) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalDeletes),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalDeletes) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalTraces),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalTraces) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalMove),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalMove) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalCopy),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalCopy) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalMkcol),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalMkcol) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalPropfind),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalPropfind) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalProppatch),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalProppatch) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalSearch),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalSearch) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalLock),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalLock) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalUnlock),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalUnlock) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalOthers),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalOthers) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalCGIRequests),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalCGIRequests) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalBGIRequests),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalBGIRequests) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalRequests),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalRequests) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalLockedErrors),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalLockedErrors) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, CurrentCGIRequests),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, CurrentCGIRequests) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, CurrentBGIRequests),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, CurrentBGIRequests) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, MaxCGIRequests),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, MaxCGIRequests) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, MaxBGIRequests),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, MaxBGIRequests) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalNotFoundErrors),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalNotFoundErrors) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, BytesSent),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, BytesSent) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, BytesReceived),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, BytesReceived) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, BytesTotal),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, BytesTotal) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, CurrentConnections),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, CurrentConnections) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, MaxConnections),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, MaxConnections) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, ConnectionAttempts),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, ConnectionAttempts) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, MeasuredBandwidth),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, MeasuredBandwidth) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalBlockedBandwidthBytes),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalBlockedBandwidthBytes) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, CurrentBlockedBandwidthBytes),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, CurrentBlockedBandwidthBytes) },
};
DWORD cIISSiteDescription = sizeof (aIISSiteDescription) / sizeof( PROP_DISPLAY_DESC );


/***************************************************************************++

Routine Description:

    Constructor for the VIRTUAL_SITE class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VIRTUAL_SITE::VIRTUAL_SITE(
    )
{

    m_VirtualSiteId = INVALID_VIRTUAL_SITE_ID;

    m_State = MD_SERVER_STATE_STOPPED; 

    InitializeListHead( &m_ApplicationListHead );

    m_ApplicationCount = 0;

    m_pIteratorPosition = NULL;

    m_Autostart = TRUE;

    m_DeleteListEntry.Flink = NULL;
    m_DeleteListEntry.Blink = NULL; 

    m_LogFileDirectory = NULL;

    m_LoggingEnabled = FALSE;

    m_LoggingFormat = HttpLoggingTypeMaximum;

    m_LoggingFilePeriod = 0;

    m_LoggingFileTruncateSize = 0;

    m_LoggingExtFileFlags = 0;

    m_LogFileLocaltimeRollover = 0;

    m_ServerCommentChanged = FALSE;

    m_MemoryOffset = NULL;

    //
    // Tracks start time of the virtual site.
    //
    m_SiteStartTime = 0;

    //
    // Clear out all the counter data
    // and then set the size of the counter data into
    // the structure.
    //
    SecureZeroMemory ( &m_MaxSiteCounters, sizeof( W3_MAX_DATA ) );

    SecureZeroMemory ( &m_SiteCounters, sizeof( W3_COUNTER_BLOCK ) );

    m_SiteCounters.PerfCounterBlock.ByteLength = sizeof ( W3_COUNTER_BLOCK );

    //
    // Make sure the root application for the site is set to NULL.
    //
    m_pRootApplication = NULL;

    m_MaxConnections = ULONG_MAX;

    m_MaxBandwidth = ULONG_MAX;

    m_ConnectionTimeout = MBCONST_CONNECTION_TIMEOUT_DEFAULT;

    m_hrForDeletion = S_OK;

    m_hrLastReported = S_OK;

    m_dwSockAddrsInHTTPCount = 0;

    m_pSslConfigData = NULL;

    m_Signature = VIRTUAL_SITE_SIGNATURE;

}   // VIRTUAL_SITE::VIRTUAL_SITE



/***************************************************************************++

Routine Description:

    Destructor for the VIRTUAL_SITE class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VIRTUAL_SITE::~VIRTUAL_SITE(
    )
{

    DBG_ASSERT( m_Signature == VIRTUAL_SITE_SIGNATURE );

    m_Signature = VIRTUAL_SITE_SIGNATURE_FREED;

    //
    // Set the virtual site state to stopped.  (In Metabase does not affect UL)
    //

    ChangeState( MD_SERVER_STATE_STOPPED, m_hrForDeletion );

    //
    // The virtual site should not go away with any applications still 
    // referring to it, unless it created the application.
    //
    if ( m_pRootApplication )
    {
        DBG_ASSERT ( m_pRootApplication->InMetabase() == FALSE );

        // ignoring the return value here, because there isn't much
        // we can do with it.  basically just do the best we can 
        // at deleting the application.

        // The DeleteApplicationInternal code will loop around and cause
        // this site to mark it's m_pRootApplication to be NULL.  However it
        // will also set the variable passed in to NULL at the end.  Either way
        // we end up with it being NULL after this call.
        DBG_REQUIRE ( GetWebAdminService()->
             GetUlAndWorkerManager()->
             DeleteApplicationInternal( &m_pRootApplication ) == S_OK );

    }

    RemoveSSLConfigStoreForSiteChanges();
    
    DBG_ASSERT( IsListEmpty( &m_ApplicationListHead ) );
    DBG_ASSERT( m_ApplicationCount == 0 );
    DBG_ASSERT( m_pRootApplication == NULL );

    if (m_LogFileDirectory)
    {
        DBG_REQUIRE( GlobalFree( m_LogFileDirectory ) == NULL );
        m_LogFileDirectory = NULL;  
    }

    if ( m_pSslConfigData )
    {
        delete m_pSslConfigData;
        m_pSslConfigData = NULL;
    }

}   // VIRTUAL_SITE::~VIRTUAL_SITE



/***************************************************************************++

Routine Description:

    Initialize the virtual site instance.

Arguments:

    pSiteObject - The configuration for this virtual site. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
VIRTUAL_SITE::Initialize(
    IN SITE_DATA_OBJECT* pSiteObject
    )
{

    HRESULT hr = S_OK;
    DWORD NewState = MD_SERVER_STATE_INVALID; 


    DBG_ASSERT( pSiteObject != NULL );

    m_VirtualSiteId = pSiteObject->QuerySiteId();

    //
    // Set the initial configuration.
    //

    hr = SetConfiguration( pSiteObject, TRUE );
    if ( FAILED( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting virtual site configuration failed\n"
            ));

        goto exit;
    }

    //
    // Finally, attempt to start the virtual site. Note that this
    // is not a direct command, because it is happening due to service
    // startup, site addition, etc.
    //

    ProcessStateChangeCommand( MD_SERVER_COMMAND_START, FALSE, &NewState );

exit:

    return hr;
    
}   // VIRTUAL_SITE::Initialize



/***************************************************************************++

Routine Description:

    Accept a set of configuration parameters for this virtual site. 

Arguments:

    pSiteObject - The configuration for this virtual site.
    fInitializing - Used to tell if we should honor the autostart property

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
VIRTUAL_SITE::SetConfiguration(
    IN SITE_DATA_OBJECT* pSiteObject,
    IN BOOL fInitializing
    )
{

    HRESULT hr = S_OK;
    BOOL Success = TRUE;
    APPLICATION_DATA_OBJECT* pAppObject = NULL;
    DWORD NewState = 0;

    DBG_ASSERT( pSiteObject != NULL );

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "New configuration for virtual site %lu\n",
            m_VirtualSiteId            
            ));
    }


    //
    // On initial startup only, read the auto start flag.
    //

    if ( fInitializing )
    {
        m_Autostart = pSiteObject->QueryAutoStart();
    }

    if ( pSiteObject->QuerySSLCertStuffChanged() )
    {
        // Copy all the Cert Stuff to member variables.
        SaveSSLConfigStoreForSiteChanges(pSiteObject);
    }

    //
    // See if the bindings have been set or changed, and if so, handle it.
    //

    if ( pSiteObject->QueryBindingsChanged() )
    {
        //
        // Copy the bindings. Note that this automatically frees any old  
        // bindings being held. 
        //
        Success = m_Bindings.Copy( *(pSiteObject->QueryBindings()) );
        if ( ! Success )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() ); 

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Copying bindings failed\n"
                ));

            goto exit;
        }

        //
        // Since the bindings changed, inform all apps in this virtual site
        // to re-register their fully qualified URLs with UL.
        //

        NotifyApplicationsOfBindingChange();

    }
    else
    {
        // The bindings did not change, but the SSL stuff did,
        // then we won't be doing any binding changes but we still
        // need to drop and re-add the ssl stuff.
        if ( pSiteObject->QuerySSLCertStuffChanged() )
        {
            RemoveSSLConfigStoreForSiteChanges();

            if ( m_State == MD_SERVER_STATE_STARTED )
            {
                AddSSLConfigStoreForSiteChanges();
            }
        }
    }

    if (  pSiteObject->QueryMaxBandwidthChanged() )
    {

        ApplyRangeCheck ( pSiteObject->QueryMaxBandwidth(),
                          pSiteObject->QuerySiteId(),
                          MBCONST_MAX_BANDWIDTH_NAME,
                          MBCONST_MAX_BANDWIDTH_DEFAULT,  // default value
                          MBCONST_MAX_BANDWIDTH_LOW,      // start of range
                          MBCONST_MAX_BANDWIDTH_HIGH,     // end of range
                          &m_MaxBandwidth );

        if ( m_pRootApplication )
        {
            //
            // if we have the root application we can now set
            // the properties.  if not, it will be taken care
            // of when the root application is configured.
            //

            m_pRootApplication->ConfigureMaxBandwidth();
        }
    }

    if ( pSiteObject->QueryMaxConnectionsChanged() )
    {
        m_MaxConnections = pSiteObject->QueryMaxConnections();

        if ( GetWebAdminService()->RunningOnPro() &&
             m_MaxConnections > 40 )
        {
            const WCHAR * EventLogStrings[2];

            WCHAR StringizedSiteId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
            _ultow(m_VirtualSiteId, StringizedSiteId, 10);

            WCHAR StringizedMaxConnectionValue[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
            _ultow(m_MaxConnections, StringizedMaxConnectionValue, 10 );

            // pApplication is used above so this won't be null here, or we 
            // would of all ready had problems.  And GetApplicationId will not
            // return NULL since it returns a pointer to a member variable.
            EventLogStrings[0] = StringizedSiteId;
            EventLogStrings[1] = StringizedMaxConnectionValue;

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_MAX_CONNECTIONS_GREATER_THAN_PRO_MAX,              // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    0                                       // error code
                    );

            m_MaxConnections = 40;
        }

        if ( m_pRootApplication )
        {
            //
            // if we have the root application we can now set
            // the properties.  if not, it will be taken care
            // of when the root application is configured.
            //

            m_pRootApplication->ConfigureMaxConnections();
        }

    }

    if (  pSiteObject->QueryConnectionTimeoutChanged() )
    {

        ApplyRangeCheck ( pSiteObject->QueryConnectionTimeout(),
                          pSiteObject->QuerySiteId(),
                          MBCONST_CONNECTION_TIMEOUT_NAME,
                          MBCONST_CONNECTION_TIMEOUT_DEFAULT,  // default value
                          MBCONST_CONNECTION_TIMEOUT_LOW,      // start of range
                          MBCONST_CONNECTION_TIMEOUT_HIGH,     // end of range
                          &m_ConnectionTimeout );

        if ( m_pRootApplication )
        {
            //
            // if we have the root application we can now set
            // the properties.  if not, it will be taken care
            // of when the root application is configured.
            //

            m_pRootApplication->ConfigureConnectionTimeout();
        }

    }

    if ( pSiteObject->QueryServerCommentChanged() )
    {

        
        if ( pSiteObject->QueryServerComment() != NULL && 
             pSiteObject->QueryServerComment()[0] != '\0' )
        {
            DWORD len = (DWORD) wcslen ( pSiteObject->QueryServerComment() ) + 1;

            //
            // Based on the if above, we should never get a length of 
            // less than one.
            //
            DBG_ASSERT (len > 1);

            //
            // Truncate if the comment is too long.
            //
            if ( len > MAX_INSTANCE_NAME )
            {
                len = MAX_INSTANCE_NAME;
            }

            // Since we knowingly truncate if the ServerComment is
            // too long, we are not worried about buffer overrun here.
            wcsncpy ( m_ServerComment, pSiteObject->QueryServerComment(), len );

            // 
            // null terminate the last character if we need 
            // just in case we copied all the way to the end.
            //
            m_ServerComment[ MAX_INSTANCE_NAME - 1 ] = '\0';

        }
        else
        {
            //
            // If there is no server comment then use W3SVC and the site id.
            //

            //
            // MAX_INSTANCE_NAME is less than "W3SVC<number>"
            wsprintf( m_ServerComment, L"W3SVC%d", m_VirtualSiteId );
        }
        
        // save the new server comment and mark it
        // as not updated in perf counters.

        m_ServerCommentChanged = TRUE;

    }

    //
    // Only process site logging properties if centralized is false.
    //
    if ( GetWebAdminService()->IsCentralizedLoggingEnabled() == FALSE )
    {
        hr = EvaluateLoggingChanges( pSiteObject );
        if ( FAILED(hr) )
        {
            DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Evaluating changes in logging properties failed\n"
            ));

            goto exit;
        }

        // Only notify the default application of logging changes 
        // if some logging changes were made.  If none were made
        // than EvaluateLoggingChanges will return S_FALSE.
        if ( hr == S_OK )
        {
            // Need to refresh the default application log information in UL.
            hr = NotifyDefaultApplicationOfLoggingChanges();
            if ( FAILED( hr ) )
            {
        
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Notifying default app of logging changes failed\n"
                    ));

                goto exit;
            }
        }
        else
        {
            DBG_ASSERT ( hr == S_FALSE );

            // If hr was S_FALSE, we don't want to pass it
            // back out of this function, so reset it.
            hr = S_OK;
        }
    }

    //
    // If the SiteAppPoolId has changed we need to
    // figure out if there is a valid root application.
    // If there is not one, and there is not one coming
    // in the change notification, we will create one
    // using the Site's AppPoolId.
    //
    if ( pSiteObject->QueryAppPoolIdChanged() )
    {
        // get rid of old site id.
        m_AppPoolIdForRootApp.Reset();

        // now set it to new set
        hr = m_AppPoolIdForRootApp.Copy ( pSiteObject->QueryAppPoolId() );
        if ( FAILED ( hr ) )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Failed to copy app pool id for root string \n"
                ));

            goto exit;
        }

        if ( m_pRootApplication == NULL )
        {
            // later we should check the return value and clean up this function
            // but for now, we know we will create the root app if needed
            GetWebAdminService()->
                    GetConfigAndControlManager()->
                    GetConfigManager()->
                    IsRootCreationInNotificationsForSite( pSiteObject );
            
        }
        else // We have a root application, but we might
             // need to reset it's app pool anyway.
        {
            if ( m_pRootApplication->InMetabase() == FALSE )
            {
                //
                // Since we know we have a root application
                // go through and modify it.  If a notification
                // to change the application itself exist we
                // will pick it up after this change and process
                // it then.
                //

                pAppObject = new APPLICATION_DATA_OBJECT();
                if ( pAppObject == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    goto exit;
                }

                hr = pAppObject->Create( L"/", m_VirtualSiteId );
                if ( FAILED ( hr ) )
                {
                    goto exit;
                }

                hr = pAppObject->SetAppPoolId( m_AppPoolIdForRootApp.QueryStr() );
                if ( FAILED ( hr ) )
                {
                    goto exit;
                }

                //
                // If we get a modification directly on the application
                // this will be true and we will change the InMetabase
                // setting on the application.  To avoid it being changed
                // here we must set this to false on the new record.
                //
                pAppObject->SetInMetabase( FALSE );

                GetWebAdminService()->
                        GetUlAndWorkerManager()->
                        ModifyApplication( pAppObject );
            }
        }
    }

    if ( pSiteObject->QueryServerCommandChanged() )
    {
        //
        // verify that the server command actually changed to 
        // a valid setting. if it did not then we will log an event
        // that says we are not going to process this command.
        //
        // Issue: Do we want to set Win32Error?
        //

        if  ( ( pSiteObject->QueryServerCommand() >= MD_SERVER_COMMAND_START ) && 
              ( pSiteObject->QueryServerCommand() <= MD_SERVER_COMMAND_CONTINUE ) )
        {
            ProcessStateChangeCommand( pSiteObject->QueryServerCommand(), TRUE, &NewState );
        }
        else
        {
            //
            // not a valid command so we need to log an event.
            //
            GetWebAdminService()->
            GetWMSLogger()->
            LogServerCommand( m_VirtualSiteId,
                              pSiteObject->QueryServerCommand(),
                              TRUE );
        }
    }


#if DBG
    //
    // Dump the configuration.
    //

    DebugDump();
#endif  // DBG


exit:

    if ( pAppObject )
    {
        pAppObject->DereferenceDataObject();
        pAppObject = NULL;
    }

    return hr;

}   // VIRTUAL_SITE::SetConfiguration

/***************************************************************************++

Routine Description:

    Routine adds the counters sent in to the counters the site is holding.

Arguments:

    COUNTER_SOURCE_ENUM CounterSource - Identifier of the where
                                        the counters are coming from.
    IN LPVOID pCountersToAddIn - Pointer to the counters to add in.


Return Value:

    VOID

--***************************************************************************/
VOID
VIRTUAL_SITE::AggregateCounters(
    IN COUNTER_SOURCE_ENUM CounterSource,
    IN LPVOID pCountersToAddIn
    )
{

    HTTP_PROP_DESC* pInputPropDesc = NULL;
    PROP_MAP*       pPropMap = NULL;
    DWORD           MaxCounters = 0;

    DBG_ASSERT ( pCountersToAddIn );

    //
    // Determine what mapping arrays to use.
    //
    if ( CounterSource == WPCOUNTERS )
    {
        pInputPropDesc = aIISWPSiteDescription;
        pPropMap = g_aIISWPSiteMappings;
        MaxCounters = g_cIISWPSiteMappings; 
    }
    else
    {
        DBG_ASSERT ( CounterSource == ULCOUNTERS );

        pInputPropDesc = aIISULSiteDescription;
        pPropMap = aIISULSiteMappings;
        MaxCounters = cIISULSiteMappings; 
    }

    LPVOID pCounterBlock = &m_SiteCounters;

    DWORD  PropInputId = 0;
    DWORD  PropDisplayId = 0;

    //
    // Go through each counter and handle it appropriately.
    //
    for (   PropDisplayId = 0 ; 
            PropDisplayId < MaxCounters; 
            PropDisplayId++ )
    {
        PropInputId = pPropMap[PropDisplayId].PropInputId;

        if ( pInputPropDesc[PropInputId].Size == sizeof( DWORD ) )
        {
            DWORD* pDWORDToUpdate = (DWORD*) ( (LPBYTE) pCounterBlock 
                                    + pPropMap[PropDisplayId].PropDisplayOffset );

            DWORD* pDWORDToUpdateWith =  (DWORD*) ( (LPBYTE) pCountersToAddIn 
                                    + pInputPropDesc[PropInputId].Offset );

            //
            // Based on current configuration of the system.  
            // This is happinging on the main thread.
            // which means that more than one can not happen 
            // at the same time so it does not need to be
            // an interlocked exchange.
            //

            *pDWORDToUpdate = *pDWORDToUpdate + *pDWORDToUpdateWith;


        }
        else
        {
            DBG_ASSERT ( pInputPropDesc[PropInputId].Size == sizeof( ULONGLONG ) );

            ULONGLONG* pQWORDToUpdate = (ULONGLONG*) ( (LPBYTE) pCounterBlock 
                                    + pPropMap[PropDisplayId].PropDisplayOffset );

            ULONGLONG* pQWORDToUpdateWith =  (ULONGLONG*) ( (LPBYTE) pCountersToAddIn 
                                    + pInputPropDesc[PropInputId].Offset );

            //
            // Based on current configuration of the system.  
            // This is happinging on the main thread.
            // which means that more than one can not happen 
            // at the same time so it does not need to be
            // an interlocked exchange.
            //

            *pQWORDToUpdate = *pQWORDToUpdate + *pQWORDToUpdateWith;

        }
            
    }
    
}  // VIRTUAL_SITE::AggregateCounters

/***************************************************************************++

Routine Description:

    Routine figures out the maximum value for the counters
    and saves it back into the MaxCounters Structure.

Arguments:

    NONE

Return Value:

    VOID

--***************************************************************************/
VOID
VIRTUAL_SITE::AdjustMaxValues(
    )
{

    for (   ULONG PropMaxId = 0 ; 
            PropMaxId < g_cIISSiteMaxDescriptions; 
            PropMaxId++ )
    {

        if ( g_aIISSiteMaxDescriptions[PropMaxId].size == sizeof( DWORD ) )
        {
            DWORD* pDWORDAsIs = (DWORD*) ( (LPBYTE) &m_SiteCounters 
                                    + g_aIISSiteMaxDescriptions[PropMaxId].DisplayOffset );

            DWORD* pDWORDToSwapWith =  (DWORD*) ( (LPBYTE) &m_MaxSiteCounters 
                                    + g_aIISSiteMaxDescriptions[PropMaxId].SafetyOffset );

            
            if ( *pDWORDAsIs < *pDWORDToSwapWith )
            {
                //
                // We have seen a max that is greater than the
                // max we are now viewing.
                //
                *pDWORDAsIs = *pDWORDToSwapWith;
            }
            else
            {
                //
                // We have a new max so save it in the safety structure
                //
                *pDWORDToSwapWith = *pDWORDAsIs;
            }

        }
        else
        {
            DBG_ASSERT ( g_aIISSiteMaxDescriptions[PropMaxId].size == sizeof( ULONGLONG ) );

            ULONGLONG* pQWORDAsIs = (ULONGLONG*) ( (LPBYTE) &m_SiteCounters 
                                    + g_aIISSiteMaxDescriptions[PropMaxId].DisplayOffset );

            ULONGLONG* pQWORDToSwapWith =  (ULONGLONG*) ( (LPBYTE) &m_MaxSiteCounters 
                                    + g_aIISSiteMaxDescriptions[PropMaxId].SafetyOffset );

            
            if ( *pQWORDAsIs < *pQWORDToSwapWith )
            {
                //
                // We have seen a max that is greater than the
                // max we are now viewing.
                //
                *pQWORDAsIs = *pQWORDToSwapWith;
            }
            else
            {
                //
                // We have a new max so save it in the safety structure
                //
                *pQWORDToSwapWith = *pQWORDAsIs;
            }

        }  // end of decision on which size of data we are dealing with
            
    } // end of for loop

    //
    // Figure out the appropriate ServiceUptime and save it in as well.
    //

    if (  m_SiteStartTime != 0 )
    {
        m_SiteCounters.ServiceUptime = GetCurrentTimeInSeconds() - m_SiteStartTime;
    }
    else
    {
        m_SiteCounters.ServiceUptime = 0;
    }
    
} // end of VIRTUAL_SITE::AdjustMaxValues

/***************************************************************************++

Routine Description:

    Routine will zero out any values that should be zero'd before we
    gather performance counters again.

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/
VOID
VIRTUAL_SITE::ClearAppropriatePerfValues(
    )
{

    HTTP_PROP_DESC* pInputPropDesc = NULL;
    PROP_MAP*       pPropMap = NULL;
    DWORD           MaxCounters = 0;
    DWORD           PropInputId = 0;
    DWORD           PropDisplayId = 0;
    LPVOID          pCounterBlock = &m_SiteCounters;

    //
    // First walk through the WP Counters and Zero appropriately
    //
    pInputPropDesc = aIISWPSiteDescription;
    pPropMap = g_aIISWPSiteMappings;
    MaxCounters = g_cIISWPSiteMappings; 

    for (   PropDisplayId = 0 ; 
            PropDisplayId < MaxCounters; 
            PropDisplayId++ )
    {
        PropInputId = pPropMap[PropDisplayId].PropInputId;

        if ( pInputPropDesc[PropInputId].WPZeros == FALSE )
        {
            if ( pInputPropDesc[PropInputId].Size == sizeof ( DWORD ) )
            {
                *((DWORD*)( (LPBYTE) pCounterBlock + 
                                        pPropMap[PropDisplayId].PropDisplayOffset )) = 0;
            }
            else // Handle QWORD
            {
                DBG_ASSERT ( pInputPropDesc[PropInputId].Size == sizeof ( ULONGLONG ) );

                *((ULONGLONG*)( (LPBYTE) pCounterBlock + 
                                        pPropMap[PropDisplayId].PropDisplayOffset )) = 0;
            }
        }
    }

    //
    // Now walk through the UL Counters and Zero appropriately
    //
    pInputPropDesc = aIISULSiteDescription;
    pPropMap = aIISULSiteMappings;
    MaxCounters = cIISULSiteMappings; 

    for (   PropDisplayId = 0 ; 
            PropDisplayId < MaxCounters; 
            PropDisplayId++ )
    {
        PropInputId = pPropMap[PropDisplayId].PropInputId;

        if ( pInputPropDesc[PropInputId].WPZeros == FALSE )
        {
            if ( pInputPropDesc[PropInputId].Size == sizeof ( DWORD ) )
            {
                *((DWORD*)( (LPBYTE) pCounterBlock + 
                                         pPropMap[PropDisplayId].PropDisplayOffset )) = 0;
            }
            else // Handle QWORD
            {
                DBG_ASSERT ( pInputPropDesc[PropInputId].Size == sizeof ( ULONGLONG ) );

                *((ULONGLONG*)( (LPBYTE) pCounterBlock + 
                                         pPropMap[PropDisplayId].PropDisplayOffset )) = 0;
            }
        }
    }
    
}  // VIRTUAL_SITE::ClearAppropriatePerfValues

/***************************************************************************++

Routine Description:

    Routine returns the display map for sites.

Arguments:

    None

Return Value:

    PROP_DISPLAY_DESC*

--***************************************************************************/
PROP_DISPLAY_DESC*
VIRTUAL_SITE::GetDisplayMap(
    )
{

    return aIISSiteDescription;

} // VIRTUAL_SITE::GetDisplayMap


/***************************************************************************++

Routine Description:

    Routine returns the size of the display map.

Arguments:

    None

Return Value:

    DWORD

--***************************************************************************/
DWORD
VIRTUAL_SITE::GetSizeOfDisplayMap(
        )
{

    return cIISSiteDescription;

} // VIRTUAL_SITE::GetSizeOfDisplayMap



/***************************************************************************++

Routine Description:

    Register an application as being part of this virtual site.

Arguments:

    pApplication - Pointer to the APPLICATION instance.

Return Value:

    VOID

--***************************************************************************/

VOID
VIRTUAL_SITE::AssociateApplication(
    IN APPLICATION * pApplication
    )
{

    DBG_ASSERT( pApplication != NULL );

    InsertHeadList( 
        &m_ApplicationListHead, 
        pApplication->GetVirtualSiteListEntry() 
        );
        
    m_ApplicationCount++;

    //
    // If we do not know which is the root application,
    // we should check to see if this might be it.
    //
    if ( m_pRootApplication == NULL )
    {
        LPCWSTR pApplicationUrl = pApplication->GetApplicationId()->ApplicationUrl.QueryStr();

        if (pApplicationUrl && wcscmp(pApplicationUrl, L"/") == 0)
        {
            m_pRootApplication = pApplication;
        }
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Associated application %lu:\"%S\" with virtual site %lu; app count now: %lu\n",
            ( pApplication->GetApplicationId() )->VirtualSiteId,
            ( pApplication->GetApplicationId() )->ApplicationUrl.QueryStr(),
            m_VirtualSiteId,
            m_ApplicationCount
            ));
    }
    
}   // VIRTUAL_SITE::AssociateApplication



/***************************************************************************++

Routine Description:

    Remove the registration of an application that is part of this virtual 
    site.

Arguments:

    pApplication - Pointer to the APPLICATION instance.

Return Value:

    VOID

--***************************************************************************/

VOID
VIRTUAL_SITE::DissociateApplication(
    IN APPLICATION * pApplication
    )
{

    HRESULT hr = S_OK;
    APPLICATION_DATA_OBJECT* pAppObject = NULL;


    DBG_ASSERT( pApplication != NULL );


    RemoveEntryList( pApplication->GetVirtualSiteListEntry() );
    ( pApplication->GetVirtualSiteListEntry() )->Flink = NULL; 
    ( pApplication->GetVirtualSiteListEntry() )->Blink = NULL; 
    
    m_ApplicationCount--;

    //
    // If we are holding the root application, verify
    // that this is not it. Otherwise we should release
    // it as well.
    //
    if ( m_pRootApplication == pApplication )
    {
        // if the pointer was the same application
        // we are working on, then let go of the 
        // application.

        m_pRootApplication = NULL;

        // Check if the application we are releasing is in the metabase
        // then we might need to create a false application.  But only if
        // we are not about to get a change notification telling us to delete
        // the site.  ( The check on the change notificaiton also takes care of 
        // the part where there is no notification that is in progress, thus we
        // are shutting down and should not create the root app anyway.
        if ( pApplication->InMetabase() && 
             GetWebAdminService()->
             GetConfigAndControlManager()->
             GetConfigManager()->
             IsSiteDeletionInCurrentNotifications(m_VirtualSiteId) == FALSE )
        {
            pAppObject = new APPLICATION_DATA_OBJECT();
            if ( pAppObject == NULL )
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            hr = pAppObject->Create( L"/", m_VirtualSiteId );
            if ( FAILED ( hr ) )
            {
                goto exit;
            }

            hr = pAppObject->SetAppPoolId( m_AppPoolIdForRootApp.QueryStr() );
            if ( FAILED ( hr ) )
            {
                goto exit;
            }

            //
            // If we get a modification directly on the application
            // this will be true and we will change the InMetabase
            // setting on the application.  To avoid it being changed
            // here we must set this to false on the new record.
            //
            pAppObject->SetInMetabase( FALSE );

            //
            // The old application should all ready be out of the 
            // tables because we are in the middle of it's destructor
            // call.
            //
            GetWebAdminService()->
                    GetUlAndWorkerManager()->
                    CreateApplication( pAppObject );

            // at this point the new root application should of
            // be put in place.
            DBG_ASSERT ( m_pRootApplication != NULL );
           
        }
    }
    
    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Dissociated application %lu:\"%S\" from virtual site %lu; app count now: %lu\n",
            ( pApplication->GetApplicationId() )->VirtualSiteId,
            ( pApplication->GetApplicationId() )->ApplicationUrl.QueryStr(),
            m_VirtualSiteId,
            m_ApplicationCount
            ));
    }

exit:

    if ( pAppObject )
    {
        pAppObject->DereferenceDataObject();
        pAppObject = NULL;
    }

    // A failure here probably means that we just got rid of the
    // root application for a site, but we failed to create a new
    // root application for the site.  In this case, we may show the
    // site as started but have no URL's registered with HTTP.SYS.
    //
    if ( FAILED ( hr ) )
    {
        const WCHAR * EventLogStrings[2];

        WCHAR StringizedSiteId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
        _ultow(m_VirtualSiteId, StringizedSiteId, 10);

        // pApplication is used above so this won't be null here, or we 
        // would of all ready had problems.  And GetApplicationId will not
        // return NULL since it returns a pointer to a member variable.
        EventLogStrings[0] = pApplication->GetApplicationId()->ApplicationUrl.QueryStr();
        EventLogStrings[1] = StringizedSiteId;

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_DISSOCIATE_APPLICATION_FAILED,              // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                hr                                      // error code
                );
    }
    
}   // VIRTUAL_SITE::DissociateApplication



/***************************************************************************++

Routine Description:

    Reset the URL prefix iterator for this virtual site back to the 
    beginning of the list of prefixes.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
VIRTUAL_SITE::ResetUrlPrefixIterator(
    )
{

    m_pIteratorPosition = NULL;

    return;

}   // VIRTUAL_SITE::ResetUrlPrefixIterator



/***************************************************************************++

Routine Description:

    Return the next URL prefix, and advance the position of the iterator. 
    If there are no prefixes left, return NULL.

Arguments:

    None.

Return Value:

    LPCWSTR - The URL prefix, or NULL if the iterator is that the end of the
    list.

--***************************************************************************/

LPCWSTR
VIRTUAL_SITE::GetNextUrlPrefix(
    )
{

    LPCWSTR pUrlPrefixToReturn = NULL;

    //
    // See if we are at the beginning, or already part way through
    // the sequence.
    //

    if ( m_pIteratorPosition == NULL )
    {
        pUrlPrefixToReturn = m_Bindings.First();
    }
    else
    {
        pUrlPrefixToReturn = m_Bindings.Next( m_pIteratorPosition );
    }


    //
    // Remember where we are in the sequence for next time.
    //

    m_pIteratorPosition = pUrlPrefixToReturn;


    return pUrlPrefixToReturn;

}   // VIRTUAL_SITE::GetNextUrlPrefix



/***************************************************************************++

Routine Description:

    A static class method to "upcast" from the delete list LIST_ENTRY 
    pointer of a VIRTUAL_SITE to the VIRTUAL_SITE as a whole.

Arguments:

    pDeleteListEntry - A pointer to the m_DeleteListEntry member of a 
    VIRTUAL_SITE.

Return Value:

    The pointer to the containing VIRTUAL_SITE.

--***************************************************************************/

// note: static!
VIRTUAL_SITE *
VIRTUAL_SITE::VirtualSiteFromDeleteListEntry(
    IN const LIST_ENTRY * pDeleteListEntry
)
{

    VIRTUAL_SITE * pVirtualSite = NULL;

    DBG_ASSERT( pDeleteListEntry != NULL );

    //  get the containing structure, then verify the signature
    pVirtualSite = CONTAINING_RECORD(
                            pDeleteListEntry,
                            VIRTUAL_SITE,
                            m_DeleteListEntry
                            );

    DBG_ASSERT( pVirtualSite->m_Signature == VIRTUAL_SITE_SIGNATURE );

    return pVirtualSite;

}   // VIRTUAL_SITE::VirtualSiteFromDeleteListEntry



#if DBG
/***************************************************************************++

Routine Description:

    Dump out key internal data structures.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
VIRTUAL_SITE::DebugDump(
    )
{

    LPCWSTR pPrefix = NULL;
    PLIST_ENTRY pListEntry = NULL;
    APPLICATION * pApplication = NULL;


    //
    // Output the site id, and its set of URL prefixes.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "\n********Virtual site id: %lu; \n"
            "         ConnectionTimeout: %u\n"
            "         MaxConnections: %u\n"
            "         MaxBandwidth: %u\n"
            "         Url prefixes:\n",
            GetVirtualSiteId(),
            m_ConnectionTimeout,
            m_MaxConnections,
            m_MaxBandwidth
            ));
    }

    ResetUrlPrefixIterator();

    while ( ( pPrefix = GetNextUrlPrefix() ) != NULL )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                ">>>>>>>>%S\n",
                pPrefix
                ));
        }

    }


    //
    // List config for this site.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Autostart: %S\n",
            ( m_Autostart ? L"TRUE" : L"FALSE" )
            ));

    }


    //
    // List the applications of this site.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            ">>>>Virtual site's applications:\n"
            ));
    }


    pListEntry = m_ApplicationListHead.Flink;

    while ( pListEntry != &m_ApplicationListHead )
    {
    
        DBG_ASSERT( pListEntry != NULL );

        pApplication = APPLICATION::ApplicationFromVirtualSiteListEntry( pListEntry );


        IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                ">>>>>>>>%S\n",
                pApplication->GetApplicationId()->ApplicationUrl.QueryStr()
                ));
        }


        pListEntry = pListEntry->Flink;

    }


    return;
    
}   // VIRTUAL_SITE::DebugDump
#endif  // DBG



/***************************************************************************++

Routine Description:

    Attempt to apply a state change command to this object. This could
    fail if the state change is invalid. 

Arguments:

    Command - The requested state change command.

    DirectCommand - TRUE if the command was targetted directly at this
    virtual site, FALSE if it is an inherited command due to a direct 
    command to the service. 

    pNewState - The state of this object after attempting to apply the 
    command.

Return Value:

    VOID

--***************************************************************************/

VOID
VIRTUAL_SITE::ProcessStateChangeCommand(
    IN DWORD Command,
    IN BOOL DirectCommand,
    OUT DWORD * pNewState
    )
{

    HRESULT hr = S_OK;
    DWORD VirtualSiteState = MD_SERVER_STATE_INVALID;
    DWORD ServiceState = 0;


    //
    // Determine the current state of affairs.
    //

    VirtualSiteState = GetState();
    ServiceState = GetWebAdminService()->GetServiceState();


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Received state change command for virtual site: %lu; command: %lu, site state: %lu, service state: %lu\n",
            m_VirtualSiteId,
            Command,
            VirtualSiteState,
            ServiceState
            ));
    }

    //
    // If we are being asked to start a site
    // and we are running on pro
    // and there are is ready 1 site started
    // and this site is stopped, then
    // we are about to go over the number of sites
    // you can start and we must set the site to stopped.
    //
    if ( Command == MD_SERVER_COMMAND_START &&
         GetWebAdminService()->RunningOnPro() &&
         GetWebAdminService()->NumberOfSitesStarted() >= 1 &&
         VirtualSiteState == MD_SERVER_STATE_STOPPED )
    {
        const WCHAR * EventLogStrings[1];

        WCHAR StringizedSiteId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
        _ultow(m_VirtualSiteId, StringizedSiteId, 10);

        ChangeState( MD_SERVER_STATE_STOPPED, ERROR_NOT_SUPPORTED );

        EventLogStrings[0] = StringizedSiteId;

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_SITE_START_FAILED_DUE_TO_PRO_LIMIT,              // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                (DWORD) HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED) // error code
                );

        return;
    }


    //
    // Update the autostart setting if appropriate.
    //

    if ( DirectCommand && 
         ( ( Command == MD_SERVER_COMMAND_START ) || 
           ( Command == MD_SERVER_COMMAND_STOP ) ) )
    {

        //
        // Set autostart to TRUE for a direct start command; set it
        // to FALSE for a direct stop command.
        //

        m_Autostart = ( Command == MD_SERVER_COMMAND_START ) ? TRUE : FALSE;

        GetWebAdminService()->GetConfigAndControlManager()->GetConfigManager()->
            SetVirtualSiteAutostart(
                m_VirtualSiteId,
                m_Autostart
                );
    }


    //
    // Figure out which command has been issued, and see if it should
    // be acted on or ignored, given the current state.
    //
    // There is a general rule of thumb that a child entity (such as
    // an virtual site) cannot be made more "active" than it's parent
    // entity currently is (the service). 
    //

    switch ( Command )
    {

    case MD_SERVER_COMMAND_START:

        //
        // If the site is stopped, then start it. If it's in any other state,
        // this is an invalid state transition.
        //
        // Note that the service must be in the started or starting state in 
        // order to start a site.
        //

        if ( VirtualSiteState == MD_SERVER_STATE_STOPPED &&
             ( ( ServiceState == SERVICE_RUNNING ) || ( ServiceState == SERVICE_START_PENDING ) ) )
        {

            //
            // If this is a flowed (not direct) command, and autostart is false, 
            // then ignore this command. In other words, the user has indicated
            // that this site should not be started at service startup, etc.
            //

            if ( ( ! DirectCommand ) && ( ! m_Autostart ) )
            {

                IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
                {
                    DBGPRINTF((
                        DBG_CONTEXT, 
                        "Ignoring flowed site start command because autostart is false for virtual site: %lu\n",
                        m_VirtualSiteId
                        ));
                }

            }
            else
            {

                ApplyStateChangeCommand(
                        MD_SERVER_COMMAND_START,
                        MD_SERVER_STATE_STARTED,
                        S_OK
                        );

            }

        }
        else
        {
            // If we are not running and we are being asked
            // to not run, then the metabase may have bad information in it
            // so we should fix it.
            if ( DirectCommand && ( VirtualSiteState == MD_SERVER_STATE_STARTED ) )
            {
                RecordState();
            }

            // Otherwise just ignore the command.
        }

        break;

    case MD_SERVER_COMMAND_STOP:

        //
        // If the site is started or paused, then stop it. If it's in 
        // any other state, this is an invalid state transition.
        //
        // Note that since we are making the site less active,
        // we can ignore the state of the service.  
        //

        if ( ( VirtualSiteState == MD_SERVER_STATE_STARTED ) ||
             ( VirtualSiteState == MD_SERVER_STATE_PAUSED ) )
        {

            //
            // CODEWORK Consider only changing the state to be 
            // MD_SERVER_STATE_STOPPING here, and then waiting until
            // all current worker processes have been rotated or shut
            // down (in order to unload components) before setting the
            // MD_SERVER_STATE_STOPPED state. 
            //

            ApplyStateChangeCommand(
                    MD_SERVER_COMMAND_STOP,
                    MD_SERVER_STATE_STOPPED,
                    S_OK
                    );

        } 
        else
        {
            // If we are not running and we are being asked
            // to not run, then the metabase may have bad information in it
            // so we should fix it.
            if ( DirectCommand && ( VirtualSiteState == MD_SERVER_STATE_STOPPED ) )
            {
                RecordState();
            }

            // Otherwise just ignore the command.
        }

        break;

    case MD_SERVER_COMMAND_PAUSE:

        //
        // If the site is started, then pause it. If it's in any other
        // state, this is an invalid state transition.
        //
        // Note that since we are making the site less active,
        // we can ignore the state of the service.  
        //

        if ( VirtualSiteState == MD_SERVER_STATE_STARTED ) 
        {

            ApplyStateChangeCommand(
                    MD_SERVER_COMMAND_PAUSE,
                    MD_SERVER_STATE_PAUSED,
                    S_OK
                    );

        } 
        else
        {
            // If we are not running and we are being asked
            // to not run, then the metabase may have bad information in it
            // so we should fix it.
            if ( DirectCommand && ( VirtualSiteState == MD_SERVER_STATE_PAUSED ) )
            {
                RecordState();
            }

            // Otherwise just ignore the command.
        }

        break;

    case MD_SERVER_COMMAND_CONTINUE:

        //
        // If the site is paused, then continue it. If it's in any other 
        // state, this is an invalid state transition.
        //
        // Note that the service must be in the started or continuing state 
        // in order to start a site.
        //

        if ( VirtualSiteState == MD_SERVER_STATE_PAUSED &&
             ( ( ServiceState == SERVICE_RUNNING ) || ( ServiceState == SERVICE_CONTINUE_PENDING ) ) )
        {

            ApplyStateChangeCommand(
                    MD_SERVER_COMMAND_CONTINUE,
                    MD_SERVER_STATE_STARTED,
                    S_OK
                    );

        } 
        else
        {
            // If we are not running and we are being asked
            // to not run, then the metabase may have bad information in it
            // so we should fix it.
            if ( DirectCommand && ( VirtualSiteState == MD_SERVER_STATE_STARTED ) )
            {
                RecordState();
            }

            // Otherwise just ignore the command.
        }

        break;

    default:

        //
        // Invalid command!
        //

        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;

    }

    //
    // Set the out parameter.
    //

    *pNewState = GetState();

}   // VIRTUAL_SITE::ProcessStateChangeCommand



/***************************************************************************++

Routine Description:

    Apply a state change command that has already been validated, by updating
    the state of this site, and also flowing the command to this site's apps.

Arguments:

    Command - The requested state change command.

    DirectCommand - TRUE if the command was targetted directly at this
    virtual site, FALSE if it is an inherited command due to a direct 
    command to the service. 

    NewState - The new state of this object. 

Return Value:

    VOID

--***************************************************************************/

VOID
VIRTUAL_SITE::ApplyStateChangeCommand(
    IN DWORD Command,
    IN DWORD NewState,
    IN HRESULT hrReturned
    )
{

    ChangeState( NewState, hrReturned );

    //
    // Alter the urls to either be there or not
    // be there based on the new settings of the site.
    //
    // This will fail if we are starting and we 
    // have invalid sites, in that case we do want
    // to jump over setting up the start time for 
    // the virtual site. 
    //

    NotifyApplicationsOfBindingChange( );

    //
    // Need to update the start tick time if we are starting  
    // or stopping a virtual site.
    //

    if ( Command == MD_SERVER_COMMAND_STOP )
    {
        m_SiteStartTime =  0;
    }
  
    if ( Command == MD_SERVER_COMMAND_START )
    {
        m_SiteStartTime = GetCurrentTimeInSeconds();
    }

}   // VIRTUAL_SITE::ApplyStateChangeCommand

/***************************************************************************++

Routine Description:

    Update the state of this object.

Arguments:

    NewState - The new state of this object. 

    Error - The error value, if any, to be written out to the config store
    for compatibility. 

Return Value:

    VOID

--***************************************************************************/

VOID
VIRTUAL_SITE::ChangeState(
    IN DWORD NewState,
    IN HRESULT Error
    )
{

    //
    // If we are not in the stopped or invalid state
    // and we are transitioning to the stopped state
    // we need to decrement the number of running sites.
    //
    if ( m_State != MD_SERVER_STATE_STOPPED &&
         NewState == MD_SERVER_STATE_STOPPED )
    {
        GetWebAdminService()->DecrementSitesStarted();
    }
  
    //
    // If we are not running and we are transitioning
    // to the running state
    // we need to decrement the number of running sites.
    //
    if (   m_State == MD_SERVER_STATE_STOPPED  &&
           NewState == MD_SERVER_STATE_STARTED )
    {
        GetWebAdminService()->IncrementSitesStarted();
    }

    m_State = NewState;
    m_hrLastReported = Error;

    RecordState( );

}   // VIRTUAL_SITE::ChangeState

/***************************************************************************++

Routine Description:

    Update the state of this object in the metabase

Arguments:

Return Value:

    VOID

--***************************************************************************/

VOID
VIRTUAL_SITE::RecordState(
    )
{

    GetWebAdminService()->GetConfigAndControlManager()->GetConfigManager()->
        SetVirtualSiteStateAndError(
            m_VirtualSiteId,
            m_State,
            ( FAILED( m_hrLastReported ) ? WIN32_FROM_HRESULT( m_hrLastReported ) : NO_ERROR )
            );

}   // VIRTUAL_SITE::RecordState



/***************************************************************************++

Routine Description:

    Notify default application to update it's logging information.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
VIRTUAL_SITE::NotifyDefaultApplicationOfLoggingChanges(
    )
{

    HRESULT hr = S_OK;
    //
    // if we have a root application then tell
    // the application about the properties.  If not
    // we will find out about them when we configure
    // the application for the first time.
    //
    if ( m_pRootApplication )
    {
        m_pRootApplication->RegisterLoggingProperties();
    }

    return hr;

}   // VIRTUAL_SITE::NotifyDefaultApplicationOfLoggingChanges


/***************************************************************************++

Routine Description:

    Notify all applications in this site that the site bindings have changed.

    Note: This is also used if we are trying to remove or add all urls for the site.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
VIRTUAL_SITE::NotifyApplicationsOfBindingChange(
    )
{

    PLIST_ENTRY pListEntry = NULL;
    PLIST_ENTRY pNextListEntry = NULL;
    APPLICATION * pApplication = NULL;


    // Before notifying the applications that the bindings
    // have changed we want to first delete any SSL Config
    // for this site, and then recreate the new SSL Config
    // if the site is started.

    RemoveSSLConfigStoreForSiteChanges();

    if ( m_State == MD_SERVER_STATE_STARTED )
    {
        AddSSLConfigStoreForSiteChanges();
    }


    pListEntry = m_ApplicationListHead.Flink;

    while ( pListEntry != &m_ApplicationListHead )
    {
        DBG_ASSERT( pListEntry != NULL );

        pNextListEntry = pListEntry->Flink;

        pApplication = APPLICATION::ApplicationFromVirtualSiteListEntry( pListEntry );

        //
        // Tell the application to re-register it's fully qualified URLs.
        //

        pApplication->ReregisterURLs();

        pListEntry = pNextListEntry;
    }

}   // VIRTUAL_SITE::NotifyApplicationsOfBindingChange


/***************************************************************************++

Routine Description:

    Evaluate (and process) any log file changes.

Arguments:

    pSiteObject - configuration info for this change.

Return Value:

    HRESULT
        S_FALSE = No Logging Changes
        S_OK    = Logging Changes ocurred

--***************************************************************************/

HRESULT
VIRTUAL_SITE::EvaluateLoggingChanges(
    IN SITE_DATA_OBJECT* pSiteObject
    )
{
    BOOL LoggingHasChanged = FALSE;

    DBG_ASSERT ( ON_MAIN_WORKER_THREAD );
    DBG_ASSERT ( pSiteObject );

    // LogType
    if ( pSiteObject->QueryLogTypeChanged() )
    {
        DWORD dwLogType = 0;

        ApplyRangeCheck ( pSiteObject->QueryLogType(),
                          pSiteObject->QuerySiteId(),
                          L"LogType",
                          1,  // default value
                          0,  // start of range
                          1,  // end of range
                          &dwLogType );

        m_LoggingEnabled = (dwLogType == 1);

        LoggingHasChanged = TRUE;

    }

    // LogFormat
    if ( pSiteObject->QueryLogPluginClsidChanged()  )
    {
        // If the logging type is set to maximum then we don't support
        // the particular type of logging that has been asked for.
        m_LoggingFormat = HttpLoggingTypeMaximum;

        // Validate that the clsid actually exists before using it.
        if ( pSiteObject->QueryLogPluginClsid() )
        {
            if (_wcsicmp ( pSiteObject->QueryLogPluginClsid()
                        , EXTLOG_CLSID) == 0)
            {
                m_LoggingFormat = HttpLoggingTypeW3C;
            }
            else if ( _wcsicmp ( pSiteObject->QueryLogPluginClsid()
                            , ASCLOG_CLSID) == 0)
            {
                m_LoggingFormat = HttpLoggingTypeIIS;
            }
            else if (_wcsicmp ( pSiteObject->QueryLogPluginClsid()
                            , NCSALOG_CLSID) == 0)
            {
                m_LoggingFormat = HttpLoggingTypeNCSA;
            }
        }

        LoggingHasChanged = TRUE;
    }

    // LogFileDirectory
    if ( pSiteObject->QueryLogFileDirectoryChanged() )
    {
        // First cleanup if we all ready had a log file directory stored.
        if (m_LogFileDirectory != NULL)
        {
            DBG_REQUIRE( GlobalFree( m_LogFileDirectory ) == NULL );
            m_LogFileDirectory = NULL;  
        }

        DBG_ASSERT ( pSiteObject->QueryLogFileDirectory() );
        DBG_ASSERT ( GetVirtualSiteDirectory() );

        LPCWSTR pLogFileDirectory = pSiteObject->QueryLogFileDirectory();

        // Figure out what the length of the new directory path is that 
        // the config store is giving us.
        DWORD ConfigLogFileDirLength = 
              ExpandEnvironmentStrings(pLogFileDirectory, NULL, 0);

        //
        // The catalog should always give me a valid log file directory.
        //
        DBG_ASSERT ( ConfigLogFileDirLength > 0 );

        // Figure out the length of the directory path that we will be
        // appending to the config store's path.
        DWORD VirtualSiteDirLength = (DWORD) wcslen(GetVirtualSiteDirectory());

        DBG_ASSERT ( VirtualSiteDirLength > 0 );

        // Allocate enough space for the new directory path.
        // If this fails than we know that we have a memory issue.

        // ExpandEnvironmentStrings gives back a length including the null termination,
        // so we do not need an extra space for the terminator.
        
        m_LogFileDirectory = 
            ( LPWSTR )GlobalAlloc( GMEM_FIXED
                                , (ConfigLogFileDirLength + VirtualSiteDirLength) * sizeof(WCHAR)
                                );

        if ( m_LogFileDirectory )
        { 
            // Copy over the original part of the directory path from the config file
            DWORD cchInExpandedString = 
                ExpandEnvironmentStrings (    pLogFileDirectory
                                            , m_LogFileDirectory
                                            , ConfigLogFileDirLength);

            UNREFERENCED_PARAMETER( cchInExpandedString );
            DBG_ASSERT (cchInExpandedString == ConfigLogFileDirLength);

            // First make sure that there is atleast one character
            // besides the null (that is included in the ConfigLogFileDirLength
            // before checking that the last character (back one to access the zero based
            // array and back a second one to avoid the terminating NULL) is
            // a slash.  If it is than change it to a null, since we are going
            // to add a slash with the \\W3SVC directory name anyway.
            if ( ConfigLogFileDirLength > 1 
                && m_LogFileDirectory[ConfigLogFileDirLength-2] == L'\\')
            {
                m_LogFileDirectory[ConfigLogFileDirLength-2] = '\0';
            }

            // m_LogFileDirectory buffer size is created based on 
            // the size of data we are about to copy in, so wcscat
            // can be viewed as safe in this case.
            DBG_REQUIRE( wcscat( m_LogFileDirectory,
                                 GetVirtualSiteDirectory()) 
                            == m_LogFileDirectory);

            LoggingHasChanged = TRUE;
        }
        else
        {      
            HRESULT hrTemp = E_OUTOFMEMORY;

            UNREFERENCED_PARAMETER( hrTemp );
            DPERROR(( 
                DBG_CONTEXT,
                hrTemp,
                "Allocating memory failed\n"
                ));
        }
    }

    // LogFilePeriod
    if ( pSiteObject->QueryLogFilePeriodChanged() )
    {
        ApplyRangeCheck ( pSiteObject->QueryLogFilePeriod(),
                          pSiteObject->QuerySiteId(),
                          L"LogFilePeriod",
                          1,  // default value
                          0,  // start of range
                          4,  // end of range
                          &m_LoggingFilePeriod );

        LoggingHasChanged = TRUE;
    }

    // LogFileTrucateSize
    if ( pSiteObject->QueryLogFileTruncateSizeChanged() )
    {
        m_LoggingFileTruncateSize = pSiteObject->QueryLogFileTruncateSize();
        LoggingHasChanged = TRUE;
    }

    // LogExtFileFlags
    if ( pSiteObject->QueryLogExtFileFlagsChanged() )
    {
        m_LoggingExtFileFlags = pSiteObject->QueryLogExtFileFlags();
        LoggingHasChanged = TRUE;
    }

    // LogFileLocaltimeRollover
    if ( pSiteObject->QueryLogFileLocaltimeRolloverChanged() )
    {
        m_LogFileLocaltimeRollover = pSiteObject->QueryLogFileLocaltimeRollover();
        LoggingHasChanged = TRUE;
    }

    //
    // If there have been some logging changes
    // then we must first make sure the logging values
    // are acceptable.
    //
    if (LoggingHasChanged)
    {

        if ( m_LoggingFileTruncateSize < HTTP_MIN_ALLOWED_TRUNCATE_SIZE_FOR_LOG_FILE && 
             m_LoggingFilePeriod == HttpLoggingPeriodMaxSize &&
             m_LoggingFormat < HttpLoggingTypeMaximum)
        {
            WCHAR SizeLog[MAX_STRINGIZED_ULONG_CHAR_COUNT];
            _ultow(m_LoggingFileTruncateSize, SizeLog, 10);

            // Log an error.
            const WCHAR * EventLogStrings[2];

            EventLogStrings[0] = GetVirtualSiteName();
            EventLogStrings[1] = SizeLog;

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_LOG_FILE_TRUNCATE_SIZE,        // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    0                                       // error code
                    );

            //
            // Set it to a default of 1 Mb.
            //
            m_LoggingFileTruncateSize = HTTP_MIN_ALLOWED_TRUNCATE_SIZE_FOR_LOG_FILE;
        
        }

        
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }

} 

/***************************************************************************++

Routine Description:

    Save the configuration from the pSiteObject into the m_SslConfigData
    member variable for later use.

Arguments:

    pSiteObject - configuration info for this change.

Return Value:

    VOID

--***************************************************************************/
VOID
VIRTUAL_SITE::SaveSSLConfigStoreForSiteChanges(
    IN SITE_DATA_OBJECT* pSiteObject
    )
{
    
    HRESULT                 hr          = S_OK;
    SITE_SSL_CONFIG_DATA*   pSslConfig  = NULL;

    DBG_ASSERT( pSiteObject );

    pSslConfig = new SITE_SSL_CONFIG_DATA;
    if ( pSslConfig == NULL )
    {
        // if we can't allocated memory right now
        // we are just going to ignore the change.
        return;
    }

    if ( !pSslConfig->bufSockAddrs.Resize( pSiteObject->QuerySockAddrsCount() * sizeof(SOCKADDR) ))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    memcpy( pSslConfig->bufSockAddrs.QueryPtr(), 
            pSiteObject->QuerySockAddrs()->QueryPtr(),
            pSiteObject->QuerySockAddrsCount() * sizeof(SOCKADDR) );

    pSslConfig->dwSockAddrCount = pSiteObject->QuerySockAddrsCount();

    // if we can resize and put the 
    // new certificate in then save the new
    // information. 
    if ( !pSslConfig->bufSslHash.Resize( pSiteObject->QueryCertHashBytes() ) )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    memcpy( pSslConfig->bufSslHash.QueryPtr(), 
            pSiteObject->QueryCertHash()->QueryPtr(), 
            pSiteObject->QueryCertHashBytes() );

    pSslConfig->dwSslHashLength = pSiteObject->QueryCertHashBytes();

    hr = pSslConfig->strSslCertStoreName.Copy( pSiteObject->
                                               QueryCertStoreName()->
                                               QueryStr() );
    if ( FAILED ( hr ) )
    {
        goto exit;
    }

    pSslConfig->dwDefaultCertCheckMode = 
                pSiteObject->QueryDefaultCertCheckMode();

    pSslConfig->dwDefaultRevocationFreshnessTime = 
                pSiteObject->QueryDefaultRevocationFreshnessTime();

    pSslConfig->dwDefaultRevocationUrlRetrievalTimeout = 
                pSiteObject->QueryDefaultRevocationUrlRetrievalTimeout();

    hr = pSslConfig->strDefaultSslCtrLdentifier.Copy( pSiteObject->
                                                      QueryDefaultSslCtlIdentifier()->
                                                      QueryStr());
    if ( FAILED ( hr ) )
    {
        goto exit;
    }

    hr = pSslConfig->strSslCtrlStoreName.Copy( pSiteObject->
                                               QueryDefaultSslCtlStoreName()->
                                               QueryStr() );
    if ( FAILED ( hr ) )
    {
        goto exit;
    }

    pSslConfig->dwDefaultFlags = pSiteObject->QueryDefaultFlags();

exit:

    if ( SUCCEEDED ( hr ) ) 
    {
        if ( m_pSslConfigData )
        {
            delete m_pSslConfigData;
        }

        m_pSslConfigData = pSslConfig;
    }
    else
    {
        delete pSslConfig;
    }

}  // VIRTUAL_SITE::SaveSSLConfigStoreForSiteChanges



/***************************************************************************++

Routine Description:

    Add the SSL Config store based on changes made to SockAddrs.

Arguments:

Return Value:

    VOID

--***************************************************************************/
VOID
VIRTUAL_SITE::AddSSLConfigStoreForSiteChanges(
    )

{
    HRESULT                         hr          = S_OK;
    DWORD                           WinError    = ERROR_SUCCESS;
    SOCKADDR_IN*                    pSockAddr   = NULL;
    HTTP_SERVICE_CONFIG_SSL_SET     Config;
    HTTP_SERVICE_CONFIG_SSL_QUERY   QueryParam;
    BUFFER                          bufSSLEntry;
    DWORD                           BytesNeeded = 0;
    PHTTP_SERVICE_CONFIG_SSL_SET    pSSLInfo    = NULL;
    DWORD                           dwMessageId = 0;


    if ( m_pSslConfigData == NULL )
    {
        // No data to configure.
        return;
    }

    // Now add the new ones, since we deleted before this we should not run 
    // into any duplicated sockaddrs.  We will log errors if we do.

    // Set the pointer to the new sock addres.
    pSockAddr = (SOCKADDR_IN*)m_pSslConfigData->bufSockAddrs.QueryPtr();

    // Walk through all the addrs in the array.
    for ( DWORD i = 0; i < m_pSslConfigData->dwSockAddrCount; i++ )
    {
        dwMessageId = 0;

        // Only add the ones that have certificates.
        if ( m_pSslConfigData->dwSslHashLength > 0 )
        {
            Config.KeyDesc.pIpPort = (SOCKADDR*)pSockAddr;
            Config.ParamDesc.SslHashLength = m_pSslConfigData->dwSslHashLength;
            Config.ParamDesc.pSslHash = m_pSslConfigData->bufSslHash.QueryPtr();

            Config.ParamDesc.AppId = W3SVC_SSL_OWNER_GUID;

            Config.ParamDesc.pSslCertStoreName = m_pSslConfigData->strSslCertStoreName.QueryStr();
            Config.ParamDesc.DefaultCertCheckMode = m_pSslConfigData->dwDefaultCertCheckMode;
            Config.ParamDesc.DefaultRevocationFreshnessTime = m_pSslConfigData->
                                                              dwDefaultRevocationFreshnessTime;
            Config.ParamDesc.DefaultRevocationUrlRetrievalTimeout = m_pSslConfigData->
                                                                    dwDefaultRevocationUrlRetrievalTimeout;
            Config.ParamDesc.pDefaultSslCtlIdentifier = m_pSslConfigData->
                                                        strDefaultSslCtrLdentifier.
                                                        QueryStr();
            Config.ParamDesc.pDefaultSslCtlStoreName = m_pSslConfigData->
                                                       strSslCtrlStoreName.
                                                       QueryStr();
            Config.ParamDesc.DefaultFlags = m_pSslConfigData->dwDefaultFlags;

            WinError = HttpSetServiceConfiguration( NULL, HttpServiceConfigSSLCertInfo,
                                         &Config,
                                         sizeof(Config),
                                         NULL );

            if ( WinError == ERROR_ALREADY_EXISTS )
            {
                hr = S_OK;
                WinError = ERROR_SUCCESS;

                ZeroMemory(&QueryParam, sizeof(QueryParam));

                QueryParam.QueryDesc = HttpServiceConfigQueryExact;
                QueryParam.KeyDesc.pIpPort = (SOCKADDR*)pSockAddr;

                // Get the configuration for the record we just colided with
                for ( ; ; )
                {

                    WinError = HttpQueryServiceConfiguration(
                                NULL,
                                HttpServiceConfigSSLCertInfo,
                                &QueryParam,
                                sizeof(QueryParam),
                                bufSSLEntry.QueryPtr(),
                                bufSSLEntry.QuerySize(),
                                &BytesNeeded,
                                NULL );

                    if ( WinError == ERROR_SUCCESS )
                    {
                        break;
                    }

                    if ( WinError != ERROR_INSUFFICIENT_BUFFER )
                    {
                        hr = HRESULT_FROM_WIN32(WinError);
                        break;
                    }

                    if ( !bufSSLEntry.Resize( BytesNeeded ) )
                    {
                        hr = E_OUTOFMEMORY;
                        break;
                    }

                }

                if ( FAILED ( hr ) )
                {
                    // we had some sort of problem getting the data
                    // deal with it here.
                    dwMessageId = WAS_SSL_QUERY_SITE_CONFIG_FAILED;
                }
                else
                {
                    // we got the record so we can decide 
                    // the event log to write.

                    DBG_ASSERT ( sizeof( HTTP_SERVICE_CONFIG_SSL_SET ) <= bufSSLEntry.QuerySize() );

                    pSSLInfo = ( PHTTP_SERVICE_CONFIG_SSL_SET ) bufSSLEntry.QueryPtr();

                    if ( IsEqualGUID ( pSSLInfo->ParamDesc.AppId, W3SVC_SSL_OWNER_GUID ) )
                    {
                        dwMessageId = WAS_SSL_SET_SITE_CONFIG_COLLISION_IIS;
                    }
                    else
                    {
                        dwMessageId = WAS_SSL_SET_SITE_CONFIG_COLLISION_OTHER;
                    }

                }
            }
            else
            {
                if ( WinError == ERROR_SUCCESS )
                {
                    // if the resize doesn't work then we just end up not
                    // tracking this entry, and we will get errors later
                    // if we try and update the entry, because we will think
                    // that it was from another site.  small price to pay for
                    // being out of memory.

                    if ( m_bufSockAddrsInHTTP.Resize( sizeof(SOCKADDR) * 
                                                      ( m_dwSockAddrsInHTTPCount + 1 )))
                    {
                        SOCKADDR* ptr = (SOCKADDR*) m_bufSockAddrsInHTTP.QueryPtr();
                        memcpy( (LPVOID) &(ptr[ m_dwSockAddrsInHTTPCount ]), 
                                pSockAddr,
                                sizeof(SOCKADDR) );

                        m_dwSockAddrsInHTTPCount++;
                    }
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(WinError);
                    dwMessageId = WAS_SSL_SET_SITE_CONFIG_FAILED;
                }
            }

            // We have some sort of error to report, so report it now.
            if ( dwMessageId != 0 )
            {
                const WCHAR * EventLogStrings[1];

                WCHAR StringizedSiteId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
                _ultow(m_VirtualSiteId, StringizedSiteId, 10);

                EventLogStrings[0] = StringizedSiteId;

                GetWebAdminService()->GetEventLog()->
                    LogEvent(
                        dwMessageId,         // message id
                        sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                                // count of strings
                        EventLogStrings,                        // array of strings
                        hr                                      // error code
                        );

                DPERROR(( DBG_CONTEXT,
                          hr,
                          "Failed setting a ssl configuration for site %d\r\n",
                          m_VirtualSiteId));
            }  // end of reporting the error 

        } // end of check for the certificate

        pSockAddr++;

    } // Now try and set the next value

}  // VIRTUAL_SITE::AddSSLConfigStoreForSiteChanges

/***************************************************************************++

Routine Description:

    Removes the SSL Config store based on info the site set.

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/
VOID
VIRTUAL_SITE::RemoveSSLConfigStoreForSiteChanges(
    )

{
    DWORD                           WinError    = ERROR_SUCCESS;
    SOCKADDR_IN*                    pSockAddr   = NULL;
    HTTP_SERVICE_CONFIG_SSL_SET     Config;

    // Nothing to do in this case.
    if ( m_dwSockAddrsInHTTPCount == 0 )
    {
        return;
    }

    // Set the pointer to the new sock addres.
    pSockAddr = (SOCKADDR_IN*)m_bufSockAddrsInHTTP.QueryPtr();

    // Walk through all the addrs in the array.
    for ( DWORD i = 0; i < m_dwSockAddrsInHTTPCount; i++ )
    {
        // Only add the ones that have certificates.
        Config.KeyDesc.pIpPort = (SOCKADDR*)pSockAddr;

        WinError = HttpDeleteServiceConfiguration( 
                                     NULL,
                                     HttpServiceConfigSSLCertInfo,
                                     &Config,
                                     sizeof(Config),
                                     NULL );

        if ( WinError != ERROR_SUCCESS )
        {
            const WCHAR * EventLogStrings[1];

            WCHAR StringizedSiteId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
            _ultow(m_VirtualSiteId, StringizedSiteId, 10);

            EventLogStrings[0] = StringizedSiteId;

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_SSL_DELETE_SITE_CONFIG_FAILED,         // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    HRESULT_FROM_WIN32(WinError)            // error code
                    );

            DPERROR(( DBG_CONTEXT,
                      HRESULT_FROM_WIN32(WinError),
                      "Failed deleting a ssl configuration for site %d\r\n",
                      m_VirtualSiteId));

        }  // end of reporting the error 

        pSockAddr++;

    } // Now try and delete the next value

    // Assume that we have now removed all the entries.
    m_dwSockAddrsInHTTPCount = 0;

}  // VIRTUAL_SITE::RemoveSSLConfigStoreForSiteChanges

/***************************************************************************++

Routine Description:

    Checks if a value is in the range or not, and if not returns the default
    to use instead.  It will also log an error to the event log for the site.

Arguments:

    DWORD   dwValue,
    DWORD   dwSiteId,
    LPCWSTR pPropertyName,
    DWORD   dwDefaultValue,
    DWORD   dwMinValue,
    DWORD   dwMaxValue,
    DWORD*  pdwValueToUse 

Return Value:

    HRESULT

--***************************************************************************/
VOID
ApplyRangeCheck( 
    DWORD   dwValue,
    DWORD   dwSiteId,
    LPCWSTR pPropertyName,
    DWORD   dwDefaultValue,
    DWORD   dwMinValue,
    DWORD   dwMaxValue,
    DWORD*  pdwValueToUse 
    )
{
    DBG_ASSERT ( pdwValueToUse != NULL );

    if  ( ( dwValue < dwMinValue ) || 
          ( dwValue > dwMaxValue ) )
    {
        GetWebAdminService()->
        GetWMSLogger()->
        LogRangeSite( dwSiteId,
                      pPropertyName,
                      dwValue,
                      dwMinValue,
                      dwMaxValue,
                      dwDefaultValue,
                      TRUE );

        *pdwValueToUse = dwDefaultValue;
    }
    else
    {
        *pdwValueToUse = dwValue;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\virtual_site_table.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    virtual_site_table.h

Abstract:

    The IIS web admin service virtual site table class definition.

Author:

    Seth Pollack (sethp)        03-Nov-1998

Revision History:

--*/


#ifndef _VIRTUAL_SITE_TABLE_H_
#define _VIRTUAL_SITE_TABLE_H_

class PERF_MANAGER;

//
// prototypes
//

class VIRTUAL_SITE_TABLE
    : public CTypedHashTable< VIRTUAL_SITE_TABLE, VIRTUAL_SITE, DWORD >
{

public:

    VIRTUAL_SITE_TABLE(
        )
        : CTypedHashTable< VIRTUAL_SITE_TABLE, VIRTUAL_SITE, DWORD >
                ( "VIRTUAL_SITE_TABLE" )
    { /* do nothing*/ }

    virtual
    ~VIRTUAL_SITE_TABLE(
        )
    { DBG_ASSERT( Size() == 0 ); }

    static
    DWORD
    ExtractKey(
        IN const VIRTUAL_SITE * pVirtualSite
        )  
    { return pVirtualSite->GetVirtualSiteId(); }
    
    static
    DWORD
    CalcKeyHash(
        IN DWORD Key
        ) 
    { return Hash( Key ); }
    
    static
    bool
    EqualKeys(
        IN DWORD Key1,
        IN DWORD Key2
        )
    { return (  Key1 == Key2 ); }
    
    static
    void
    AddRefRecord(
        IN VIRTUAL_SITE * pVirtualSite,
        IN int IncrementAmount
        ) 
    { /* do nothing*/ 
        UNREFERENCED_PARAMETER( pVirtualSite );
        UNREFERENCED_PARAMETER( IncrementAmount );    
    }

    VOID
    Terminate(
        );

    static
    LK_ACTION
    DeleteVirtualSiteAction(
        IN VIRTUAL_SITE * pVirtualSite, 
        IN VOID * pDeleteListHead
        );

    static
    LK_ACTION
    RecordVirtualSiteStatesAction(
        IN VIRTUAL_SITE * pVirtualSite, 
        IN VOID * pIgnored
        );

    VOID
    ReportPerformanceInfo(
        IN PERF_MANAGER* pManager,
        IN BOOL          StructChanged
        );

#if DBG
    VOID
    DebugDump(
        );

    static
    LK_ACTION
    DebugDumpVirtualSiteAction(
        IN VIRTUAL_SITE * pVirtualSite, 
        IN VOID * pIgnored
        );
#endif  // DBG


    VOID
    ControlAllSites(
        IN DWORD Command
        );

    static
    LK_ACTION
    ControlAllSitesVirtualSiteAction(
        IN VIRTUAL_SITE * pVirtualSite, 
        IN VOID * pCommand
        );

    static
    LK_ACTION
    ReportCountersVirtualSiteAction(
        IN VIRTUAL_SITE* pVirtualSite, 
        IN LPVOID pManagerVoid
        );

private:

   	VIRTUAL_SITE_TABLE( const VIRTUAL_SITE_TABLE & );
	void operator=( const VIRTUAL_SITE_TABLE & );


    BOOL m_SitesHaveChanged;

};  // VIRTUAL_SITE_TABLE



#endif  // _VIRTUAL_SITE_TABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\ul_and_worker_manager.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    ul_and_worker_manager.cxx

Abstract:

    This class manages all the major run-time state, and drives UL.sys and
    the worker processes.

    Threading: Always called on the main worker thread.

Author:

    Seth Pollack (sethp)        01-Oct-1998

Revision History:

--*/



#include "precomp.h"

#include <httpfilt.h>

/***************************************************************************++

Routine Description:

    Constructor for the UL_AND_WORKER_MANAGER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

UL_AND_WORKER_MANAGER::UL_AND_WORKER_MANAGER(
    )
    :
    m_AppPoolTable(),
    m_VirtualSiteTable(),
    m_ApplicationTable()
{


    m_State = UninitializedUlAndWorkerManagerState;

    m_pPerfManager = NULL;

    m_ASPPerfInit = FALSE;

    m_UlInitialized = FALSE;

    m_UlControlChannel = NULL;

    m_SitesHaveChanged = TRUE;

    m_Signature = UL_AND_WORKER_MANAGER_SIGNATURE;

}   // UL_AND_WORKER_MANAGER::UL_AND_WORKER_MANAGER



/***************************************************************************++

Routine Description:

    Destructor for the UL_AND_WORKER_MANAGER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

UL_AND_WORKER_MANAGER::~UL_AND_WORKER_MANAGER(
    )
{

    DBG_ASSERT( m_Signature == UL_AND_WORKER_MANAGER_SIGNATURE );

    m_Signature = UL_AND_WORKER_MANAGER_SIGNATURE_FREED;

    DBG_ASSERT( m_State == UninitializedUlAndWorkerManagerState ||
                m_State == TerminatingUlAndWorkerManagerState );

    if ( m_pPerfManager )
    {
        m_pPerfManager->Dereference();
        m_pPerfManager = NULL;
    }

    if ( m_UlControlChannel != NULL )
    {
        DBG_REQUIRE( CloseHandle( m_UlControlChannel ) );
        m_UlControlChannel = NULL;
    }


    if ( m_UlInitialized )
    {
        HttpTerminate(0, NULL);
        m_UlInitialized = FALSE;
    }


}   // UL_AND_WORKER_MANAGER::~UL_AND_WORKER_MANAGER



/***************************************************************************++

Routine Description:

    Initialize by opening the UL control channel.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::Initialize(
    )
{

    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;
    DWORD NumTries = 1;
    HTTPAPI_VERSION HttpVersion = HTTPAPI_VERSION_1;

    Win32Error = HttpInitialize(
                         HttpVersion,
                         HTTP_INITIALIZE_CONFIG,  // allow setting of config
                         NULL                     // reserved
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Couldn't initialize UL\n"
            ));

        goto exit;
    }

    m_UlInitialized = TRUE;

    Win32Error = HttpOpenControlChannel(
                        &m_UlControlChannel,        // returned handle
                        0                           // synchronous i/o
                        );

    //
    // We might get access denied if we tried to
    // open the control channel too soon after closing it.
    //
    while ( Win32Error == ERROR_ACCESS_DENIED && NumTries <= 5 )
    {

        Sleep ( 1000 );  // 1 second

        Win32Error = HttpOpenControlChannel(
                            &m_UlControlChannel,        // returned handle
                            0                           // synchronous i/o
                            );

        NumTries++;
    }

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Couldn't open UL control channel\n"
            ));

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_HTTP_CONTROL_CHANNEL_OPEN_FAILED,                  // message id
                0,                                                     // count of strings
                NULL,                                                  // array of strings
                hr                                                     // error code
                );

        goto exit;
    }

    DeleteSSLConfigStoreInfo();

    m_State = RunningUlAndWorkerManagerState;

exit:

    return hr;

}   // UL_AND_WORKER_MANAGER::Initialize



/***************************************************************************++

Routine Description:

    Create a new app pool.

Arguments:

    pAppPoolObject - The configuration parameters for this app pool.

Return Value:

    VOID

--***************************************************************************/

VOID
UL_AND_WORKER_MANAGER::CreateAppPool(
    IN APP_POOL_DATA_OBJECT* pAppPoolObject
    )
{

    HRESULT hr = S_OK;
    APP_POOL * pAppPool = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;

#if DBG
    APP_POOL * pExistingAppPool = NULL;
#endif  // DBG


    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( pAppPoolObject != NULL );
    DBG_ASSERT( pAppPoolObject->QueryAppPoolId() != NULL );

    // if we are in BC mode then we
    // only create the DefaultAppPool App Pool
    // all others can be ignored.
    if ( ( GetWebAdminService()->
           IsBackwardCompatibilityEnabled() ) &&
         ( _wcsicmp( pAppPoolObject->QueryAppPoolId()
                 , wszDEFAULT_APP_POOL  ) != 0 ) )
    {
        hr = S_OK;
        goto exit;
    }

    // ensure that we're not creating a app pool that already exists
    DBG_ASSERT( m_AppPoolTable.FindKey(
                                    pAppPoolObject->QueryAppPoolId(),
                                    &pExistingAppPool
                                    )
                == LK_NO_SUCH_KEY );


    pAppPool = new APP_POOL();

    if ( pAppPool == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Allocating APP_POOL failed\n"
            ));

        goto exit;
    }


    hr = pAppPool->Initialize( pAppPoolObject );

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Initializing app pool object failed\n"
            ));

        pAppPool->Dereference();
        pAppPool = NULL;

        goto exit;
    }


    ReturnCode = m_AppPoolTable.InsertRecord( pAppPool );

    if ( ReturnCode != LK_SUCCESS )
    {

        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Inserting app pool into hashtable failed\n"
            ));

        goto exit;
    }


    pAppPool->MarkAsInAppPoolTable();


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "New app pool: %S added to app pool hashtable; total number now: %lu\n",
            pAppPoolObject->QueryAppPoolId(),
            m_AppPoolTable.Size()
            ));
    }


exit:

    if ( FAILED( hr ) && ( pAppPool != NULL ) )
    {

        //
        // Terminate and dereference pAppPool now, since we won't be able to
        // find it in the table later.
        //

        DBG_ASSERT( ! ( pAppPool->IsInAppPoolTable() ) );

        pAppPool->Terminate( );

        pAppPool->Dereference();

        pAppPool = NULL;

    }

    if ( FAILED ( hr ) )
    {
        GetWebAdminService()->GetWASLogger()->
            LogAppPoolError(
                WAS_APPPOOL_CREATE_FAILED,
                hr,
                pAppPoolObject->QueryAppPoolId()
                );
    }

}   // UL_AND_WORKER_MANAGER::CreateAppPool



/***************************************************************************++

Routine Description:

    Create a virtual site.

Arguments:

    pSiteObject - The configuration for this virtual site.

Return Value:

    VOID

--***************************************************************************/

VOID
UL_AND_WORKER_MANAGER::CreateVirtualSite(
    IN SITE_DATA_OBJECT* pSiteObject
    )
{

    HRESULT hr = S_OK;
    VIRTUAL_SITE * pVirtualSite = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;

#if DBG
    VIRTUAL_SITE * pExistingVirtualSite = NULL;
#endif  // DBG


    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( pSiteObject != NULL );

    // ensure that we're not creating a virtual site that already exists
    DBG_ASSERT( m_VirtualSiteTable.FindKey(
                                        pSiteObject->QuerySiteId(),
                                        &pExistingVirtualSite
                                        )
                == LK_NO_SUCH_KEY );


    pVirtualSite = new VIRTUAL_SITE();

    if ( pVirtualSite == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Allocating VIRTUAL_SITE failed\n"
            ));

        goto exit;
    }


    hr = pVirtualSite->Initialize( pSiteObject );

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Initializing virtual site object failed\n"
            ));

        goto exit;
    }


    ReturnCode = m_VirtualSiteTable.InsertRecord( pVirtualSite );

    if ( ReturnCode != LK_SUCCESS )
    {

        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Inserting virtual site into hashtable failed\n"
            ));

        goto exit;
    }

    m_SitesHaveChanged = TRUE;

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "New virtual site: %lu added to virtual site hashtable; total number now: %lu\n",
            pSiteObject->QuerySiteId(),
            m_VirtualSiteTable.Size()
            ));
    }


exit:

    if ( FAILED( hr ) && ( pVirtualSite != NULL ) )
    {

        //
        // Clean up pVirtualSite now, since we won't be able to find it
        // in the table later. All shutdown work is done in it's destructor.
        //

        delete pVirtualSite;

        pVirtualSite = NULL;
    }

    if ( FAILED ( hr ) )
    {
        GetWebAdminService()->GetWASLogger()->
            LogSiteError(
                WAS_SITE_CREATE_FAILED,
                hr,
                pSiteObject->QuerySiteId()
                );
    }

}   // UL_AND_WORKER_MANAGER::CreateVirtualSite


/***************************************************************************++

Routine Description:

    Create an application. This may only be done after the virtual site and
    the app pool used by this application have been created.

Arguments:

    pAppObject - The configuration parameters for this application.

Return Value:

    VOID

--***************************************************************************/

VOID
UL_AND_WORKER_MANAGER::CreateApplication(
    IN APPLICATION_DATA_OBJECT *  pAppObject
    )
{

    HRESULT             hr              = S_OK;
    APPLICATION_ID      ApplicationId;
    VIRTUAL_SITE *      pVirtualSite    = NULL;
    APP_POOL *          pAppPool        = NULL;
    APPLICATION *       pApplication    = NULL;
    LK_RETCODE          ReturnCode      = LK_SUCCESS;

#if DBG
    APPLICATION * pExistingApplication = NULL;
#endif  // DBG

    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( pAppObject->QueryApplicationUrl() != NULL );
    DBG_ASSERT( pAppObject->QueryAppPoolId() != NULL );

    ApplicationId.VirtualSiteId = pAppObject->QuerySiteId();
    hr = ApplicationId.ApplicationUrl.Copy( pAppObject->QueryApplicationUrl() );
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed memory allocation when checking if created application exists\n"
            ));

        goto exit;
    }

    // ensure that we're not creating an application that already exists
    DBG_ASSERT( m_ApplicationTable.FindKey(
                                        &ApplicationId,
                                        &pExistingApplication
                                        )
                == LK_NO_SUCH_KEY );


    //
    // Look up the virtual site and app pool. These must already
    // exist.
    //

    // Note:  Virtual Sites, App Pools and Applications don't add ref
    //        the way LKRHASH tables do so we don't have to worry
    //        about ref counting on objects retrieved through the LKRHASH.
    //
    ReturnCode = m_VirtualSiteTable.FindKey(
                                        pAppObject->QuerySiteId(),
                                        &pVirtualSite
                                        );

    if ( ReturnCode != LK_SUCCESS )
    {
        if ( ReturnCode == LK_NO_SUCH_KEY )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Attempting to create application ( site %d, url %S ) that references a non-existent virtual site\n",
                pAppObject->QueryApplicationUrl(),
                pAppObject->QuerySiteId()
                ));

            DBG_ASSERT( ReturnCode != LK_NO_SUCH_KEY );

        }
        else
        {
            hr = HRESULT_FROM_LK_RETCODE( ReturnCode );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Looking up virtual site referenced by application failed\n"
                ));
        }

        goto exit;
    }


    // Note:  Virtual Sites, App Pools and Applications don't add ref
    //        the way LKRHASH tables do so we don't have to worry
    //        about ref counting on objects retrieved through the LKRHASH.
    //
    ReturnCode = m_AppPoolTable.FindKey(
                                    pAppObject->QueryAppPoolId(),
                                    &pAppPool
                                    );

    if ( ReturnCode != LK_SUCCESS )
    {
        if ( ReturnCode == LK_NO_SUCH_KEY )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Attempting to create application ( site %d, url %S ) that references a non-existent app pool %S\n",
                pAppObject->QuerySiteId(),
                pAppObject->QueryApplicationUrl(),
                pAppObject->QueryAppPoolId()
                ));

            DBG_ASSERT( ReturnCode != LK_NO_SUCH_KEY );

        }
        else
        {
            hr = HRESULT_FROM_LK_RETCODE( ReturnCode );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Looking up app pool referenced by application failed\n"
                ));
        }

        goto exit;
    }


    pApplication = new APPLICATION();
    if ( pApplication == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Allocating APPLICATION failed\n"
            ));

        goto exit;
    }


    hr = pApplication->Initialize(
                            pAppObject,
                            pVirtualSite,
                            pAppPool
                            );

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Initializing application object failed\n"
            ));

        goto exit;
    }


    ReturnCode = m_ApplicationTable.InsertRecord( pApplication );

    if ( ReturnCode != LK_SUCCESS )
    {

        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Inserting application into hashtable failed\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "New application in site: %lu with path: %S, assigned to app pool: %S, with app index %lu, added to application hashtable; total number now: %lu\n",
            pAppObject->QuerySiteId(),
            pAppObject->QueryApplicationUrl(),
            pAppPool->GetAppPoolId(),
            m_ApplicationTable.Size()
            ));
    }


exit:

    if ( FAILED( hr ) && ( pApplication != NULL ) )
    {

        //
        // Clean up pApplication now, since we won't be able to find it
        // in the table later. All shutdown work is done in it's destructor.
        //

        delete pApplication;

        pApplication = NULL;
    }

    if ( FAILED ( hr ) )
    {
        GetWebAdminService()->GetWASLogger()->
            LogApplicationError(
                WAS_APPLICATION_CREATE_FAILED,
                hr,
                pAppObject->QuerySiteId(),
                pAppObject->QueryApplicationUrl()
                );
    }

}   // UL_AND_WORKER_MANAGER::CreateApplication



/***************************************************************************++

Routine Description:

    Delete an app pool.

Arguments:

    pAppPoolId - ID for the app pool to be deleted.

Return Value:

    VOID

--***************************************************************************/

VOID
UL_AND_WORKER_MANAGER::DeleteAppPool(
    IN APP_POOL_DATA_OBJECT *  pAppPoolObject,
    IN HRESULT hrToReport
    )
{

    HRESULT hr = S_OK;
    APP_POOL * pAppPool = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;


    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pAppPoolObject != NULL );
    DBG_ASSERT( pAppPoolObject->QueryAppPoolId() != NULL );

    // if we are in BC mode then we
    // only delete the DefaultAppPool App Pool
    // all others can be ignored.
    //
    // CODEWORK:  Should we allow the default app pool
    // to be deleted through this path?
    if ( ( GetWebAdminService()->
           IsBackwardCompatibilityEnabled() ) &&
         ( _wcsicmp( pAppPoolObject->QueryAppPoolId()
                 , wszDEFAULT_APP_POOL  ) != 0 ) )
    {
        hr = S_OK;
        goto exit;
    }


    //
    // Look up the app pool in our data structures.
    //

    // Note:  Virtual Sites, App Pools and Applications don't add ref
    //        the way LKRHASH tables do so we don't have to worry
    //        about ref counting on objects retrieved through the LKRHASH.
    //
    ReturnCode = m_AppPoolTable.FindKey(
                                    pAppPoolObject->QueryAppPoolId(),
                                    &pAppPool
                                    );

    if ( ReturnCode != LK_SUCCESS )
    {

        //
        // It should be there! Assert in debug builds.
        //
        DBG_ASSERT( ReturnCode != LK_NO_SUCH_KEY );


        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Finding app pool to delete in hashtable failed\n"
            ));

        goto exit;
    }

    pAppPool->SetHrForDeletion ( hrToReport );

    //
    // Terminate the app pool object. As part of the object's cleanup,
    // it will call RemoveAppPoolFromTable() to remove itself from the
    // app pool hashtable.
    //
    // Termination (as opposed to clean shutdown) is slightly rude, but
    // doing shutdown here introduces a number of nasty races and other
    // problems. For example, someone could delete an app pool,
    // then re-add an app pool with the same name immediately after.
    // If the original app pool hasn't shut down yet, then the two
    // id's will conflict in the table (not to mention conflicting on
    // trying to grab the same app pool id in UL). We could just fail
    // such config change calls, but then our WAS internal state gets
    // out of sync with the config store state, without any easy way
    // for the customer to figure out what's going on.
    //
    // BUGBUG Can we live with terminating instead of clean shutdown in
    // this scenario? EricDe says yes, 1/20/00.
    //
    // Note that at this point there should not be any applications
    // still assigned to this app pool.
    //

    pAppPool->Terminate( );


exit:

    if ( FAILED ( hr ) )
    {
        GetWebAdminService()->GetWASLogger()->
            LogAppPoolError(
                WAS_APPPOOL_DELETE_FAILED,
                hr,
                pAppPoolObject->QueryAppPoolId()
                );
    }

}   // UL_AND_WORKER_MANAGER::DeleteAppPool



/***************************************************************************++

Routine Description:

    Delete a virtual site.

Arguments:

    VirtualSiteId - ID for the virtual site to delete.

Return Value:

    VOID

--***************************************************************************/

VOID
UL_AND_WORKER_MANAGER::DeleteVirtualSite(
    IN SITE_DATA_OBJECT* pSiteObject,
    IN HRESULT hrToReport
    )
{

    HRESULT hr = S_OK;
    VIRTUAL_SITE * pVirtualSite = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;


    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( pSiteObject );


    //
    // Look up the virtual site in our data structures.
    //

    // Note:  Virtual Sites, App Pools and Applications don't add ref
    //        the way LKRHASH tables do so we don't have to worry
    //        about ref counting on objects retrieved through the LKRHASH.
    //
    ReturnCode = m_VirtualSiteTable.FindKey(
                                        pSiteObject->QuerySiteId(),
                                        &pVirtualSite
                                        );

    if ( ReturnCode != LK_SUCCESS )
    {

        //
        // It should be there! Assert in debug builds.
        //
        DBG_ASSERT( ReturnCode != LK_NO_SUCH_KEY );


        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Finding virtual site to delete in hashtable failed\n"
            ));

        goto exit;
    }


    ReturnCode = m_VirtualSiteTable.DeleteRecord( pVirtualSite );

    if ( ReturnCode != LK_SUCCESS )
    {

        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Removing virtual site from hashtable failed\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Virtual site: %lu removed from hashtable; total number now: %lu\n",
            pSiteObject->QuerySiteId(),
            m_VirtualSiteTable.Size()
            ));
    }

    pVirtualSite->SetHrForDeletion ( hrToReport );

    //
    // Clean up and delete the virtual site object. All shutdown work is
    // done in it's destructor.
    //

    //
    // Note that any apps in this site must already have been deleted.
    // The destructor for this object will assert if this is not the case.
    //

    delete pVirtualSite;

    m_SitesHaveChanged = TRUE;

exit:

    if ( FAILED ( hr ) )
    {
        GetWebAdminService()->GetWASLogger()->
            LogSiteError(
                WAS_SITE_DELETE_FAILED,
                hr,
                pSiteObject->QuerySiteId()
                );
    }

}   // UL_AND_WORKER_MANAGER::DeleteVirtualSite



/***************************************************************************++

Routine Description:

    Delete an application.

Arguments:

    pAppObject - The application information for this site.

Return Value:

    VOID

--***************************************************************************/

VOID
UL_AND_WORKER_MANAGER::DeleteApplication(
    IN LPWSTR  pApplicationUrl,
    IN DWORD   VirtualSiteId
    )
{

    HRESULT hr = S_OK;
    APPLICATION_ID ApplicationId;
    APPLICATION * pApplication = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;


    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( pApplicationUrl != NULL );

    ApplicationId.VirtualSiteId = VirtualSiteId;
    hr = ApplicationId.ApplicationUrl.Copy( pApplicationUrl );
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed memory allocation when checking if created application exists\n"
            ));

        goto exit;
    }


    //
    // Look up the application in our data structures.
    //

    // Note:  Virtual Sites, App Pools and Applications don't add ref
    //        the way LKRHASH tables do so we don't have to worry
    //        about ref counting on objects retrieved through the LKRHASH.
    //
    ReturnCode = m_ApplicationTable.FindKey(
                                        &ApplicationId,
                                        &pApplication
                                        );

    if ( ReturnCode == LK_NO_SUCH_KEY )
    {
        //
        // We will get delete notifications for applications
        // that we were not told about.  In this case simply
        // ignore the delete application and continue.
        //

        IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Received a change notification for an "
                "application '%S' with Site Id '%d' that does not exist\n",
                pApplicationUrl,
                VirtualSiteId
                ));
        }

        goto exit;
    }

    if ( ReturnCode != LK_SUCCESS )
    {

        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Finding application to delete in hashtable failed\n"
            ));

        goto exit;

    }

    //
    // If the application is not in the metabase then
    // we don't want to honor the delete.  We only will
    // honor application deletes when the metabase has
    // told us to create the application.
    //
    if ( pApplication->InMetabase() == FALSE )
    {
        hr = S_OK;

        IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Received a delete notification for an "
                "application '%S' with Site Id '%d' that the metabase "
                "code did not tell us to create, so we are ignoring it\n",
                pApplicationUrl,
                VirtualSiteId
                ));
        }


        goto exit;
    }

    // Note there is a side affect of this deletion that will cause
    // the pApplication Object to be invalid after this call.
    hr = DeleteApplicationInternal(&pApplication);

exit:

    if ( FAILED ( hr ) )
    {
        GetWebAdminService()->GetWASLogger()->
            LogApplicationError(
                WAS_APPLICATION_DELETE_FAILED,
                hr,
                VirtualSiteId,
                pApplicationUrl
                );
    }

}   // UL_AND_WORKER_MANAGER::DeleteApplication

/***************************************************************************++

Routine Description:

    Delete an application ( internal )

Arguments:

    ppApplication - Ptr to the ptr to the application to be deleted.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::DeleteApplicationInternal(
    IN APPLICATION** ppApplication
    )
{

    HRESULT hr = S_OK;
    LK_RETCODE ReturnCode = LK_SUCCESS;

    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT ( ppApplication && *ppApplication );

    ReturnCode = m_ApplicationTable.DeleteRecord( *ppApplication );

    if ( ReturnCode != LK_SUCCESS )
    {

        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Removing application from hashtable failed\n"
            ));

        goto exit;
    }

    //
    // Clean up and delete the application object. All shutdown work is
    // done in it's destructor.
    //

    delete *ppApplication;

    *ppApplication = NULL;


exit:

    return hr;

}   // UL_AND_WORKER_MANAGER::DeleteApplicationInternal


/***************************************************************************++

Routine Description:

    Modify the global data for the server.  ( Also used to initialize it )

Arguments:

    pGlobalObject - The new configuration values for the server.

Return Value:

    VOID

--***************************************************************************/

VOID
UL_AND_WORKER_MANAGER::ModifyGlobalData(
    IN GLOBAL_DATA_OBJECT* pGlobalObject
    )
{

    HRESULT hr = S_OK;
    DWORD   Win32Error = ERROR_SUCCESS;
    static BOOL    fConfiguredSSL = FALSE;

    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pGlobalObject != NULL );

    //
    // Make the configuration changes.
    //

    //
    // Configure Centralized Logging
    //
    ConfigureLogging( pGlobalObject );

    //
    // If logging in UTF 8 has changed then tell UL.
    //
    if ( pGlobalObject->QueryLogInUTF8Changed() )
    {
        HTTP_CONTROL_CHANNEL_UTF8_LOGGING LogInUTF8 =
                            ( pGlobalObject->QueryLogInUTF8() == TRUE );

        IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Configuring control channel for logging in UTF8 %S\n",
                pGlobalObject->QueryLogInUTF8() ? L"TRUE" : L"FALSE"
                ));
        }

        //
        // let http.sys know about it.
        //
        Win32Error = HttpSetControlChannelInformation(
                            m_UlControlChannel,                    // control channel
                            HttpControlChannelUTF8Logging,  // information class
                            &LogInUTF8,                          // data to set
                            sizeof( LogInUTF8 )                  // data length
                            );

        if ( Win32Error != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32( Win32Error );

            const WCHAR * EventLogStrings[1];

            EventLogStrings[0] = L"LogInUTF8";

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_HTTP_CONTROL_CHANNEL_CONFIG_FAILED,                // message id
                    1,                                                     // count of strings
                    EventLogStrings,                                       // array of strings
                    hr                                                     // error code
                    );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Changing control channel logging in utf8 failed\n"
                ));

        }
    }

    //
    // If max bandwidth has changed then tell UL about it.
    //
    if ( pGlobalObject->QueryMaxBandwidthChanged() )
    {
        HTTP_BANDWIDTH_LIMIT bandwidth = pGlobalObject->QueryMaxBandwidth();

        // MaxBandwidth must be >= HTTP_MIN_ALLOWED_BANDWIDTH_THROTTLING_RATE

        if ( pGlobalObject->QueryMaxBandwidth() < MBCONST_MAX_GLOBAL_BANDWIDTH_LOW ||
             pGlobalObject->QueryMaxBandwidth() > MBCONST_MAX_GLOBAL_BANDWIDTH_HIGH )
        {
            // Report that we are using the default instead
            // of the value provided because the value provided
            // is invalid.

            GetWebAdminService()->
            GetWMSLogger()->
            LogRangeGlobal( MBCONST_MAX_GLOBAL_BANDWIDTH_NAME,
                            pGlobalObject->QueryMaxBandwidth(),
                            MBCONST_MAX_GLOBAL_BANDWIDTH_LOW,
                            MBCONST_MAX_GLOBAL_BANDWIDTH_HIGH,
                            MBCONST_MAX_GLOBAL_BANDWIDTH_DEFAULT,
                            TRUE );

            bandwidth = MBCONST_MAX_GLOBAL_BANDWIDTH_DEFAULT;
        }

        IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Configuring control channel MaxBandwidth to %u\n",
                bandwidth
                ));
        }

        //
        // let http.sys know about it.
        //
        Win32Error = HttpSetControlChannelInformation(
                            m_UlControlChannel,                     // control channel
                            HttpControlChannelBandwidthInformation, // information class
                            &bandwidth,                             // data to set
                            sizeof( bandwidth )                     // data length
                            );

        if ( Win32Error != NO_ERROR )
        {
            if ( Win32Error == ERROR_INVALID_FUNCTION )
            {
                GetWebAdminService()->GetEventLog()->
                    LogEvent(
                        WAS_HTTP_PSCHED_NOT_INSTALLED,                // message id
                        0,                                            // count of strings
                        NULL,                                         // array of strings
                        0                                             // error code
                        );

                DPERROR((
                    DBG_CONTEXT,
                    hr,
                    "Bandwidth failed because PSCHED is not installed\n"
                    ));
            }
            else
            {
                hr = HRESULT_FROM_WIN32( Win32Error );

                const WCHAR * EventLogStrings[1];

                EventLogStrings[0] = L"MaxBandwidth";

                GetWebAdminService()->GetEventLog()->
                    LogEvent(
                        WAS_HTTP_CONTROL_CHANNEL_CONFIG_FAILED,                // message id
                        1,                                                     // count of strings
                        EventLogStrings,                                       // array of strings
                        hr                                                     // error code
                        );

                DPERROR((
                    DBG_CONTEXT,
                    hr,
                    "Changing control channel max bandwidth failed\n"
                    ));
            }

        }
    }

    //
    // If any of the connection info has changed then
    // pass the info on down to UL.
    //
    if ( pGlobalObject->QueryConnectionTimeoutChanged() ||
         pGlobalObject->QueryMinFileBytesSecChanged() ||
         pGlobalObject->QueryHeaderWaitTimeoutChanged() )
    {
        HTTP_CONTROL_CHANNEL_TIMEOUT_LIMIT ConnectionInfo;
        DWORD connectiontimeout = pGlobalObject->QueryConnectionTimeout();
        DWORD headerwaittimeout = pGlobalObject->QueryHeaderWaitTimeout();

        if ( connectiontimeout > MBCONST_CONNECTION_TIMEOUT_HIGH )
        {
            // Report that we are using the default instead
            // of the value provided because the value provided
            // is invalid.

            GetWebAdminService()->
            GetWMSLogger()->
            LogRangeGlobal( MBCONST_CONNECTION_TIMEOUT_NAME,
                            connectiontimeout,
                            MBCONST_CONNECTION_TIMEOUT_LOW,
                            MBCONST_CONNECTION_TIMEOUT_HIGH,
                            MBCONST_CONNECTION_TIMEOUT_DEFAULT,
                            TRUE );

            connectiontimeout = MBCONST_CONNECTION_TIMEOUT_DEFAULT;
        }

        if ( headerwaittimeout > MBCONST_HEADER_WAIT_TIMEOUT_HIGH )
        {
            // Report that we are using the default instead
            // of the value provided because the value provided
            // is invalid.

            GetWebAdminService()->
            GetWMSLogger()->
            LogRangeGlobal( MBCONST_HEADER_WAIT_TIMEOUT_NAME,
                            headerwaittimeout,
                            MBCONST_HEADER_WAIT_TIMEOUT_LOW,
                            MBCONST_HEADER_WAIT_TIMEOUT_HIGH,
                            MBCONST_HEADER_WAIT_TIMEOUT_DEFAULT,
                            TRUE );

            headerwaittimeout = MBCONST_HEADER_WAIT_TIMEOUT_DEFAULT;
        }
      

        ConnectionInfo.ConnectionTimeout = connectiontimeout;  // Seconds
        ConnectionInfo.HeaderWaitTimeout = headerwaittimeout;  // Seconds
        ConnectionInfo.MinFileKbSec      = pGlobalObject->QueryMinFileBytesSec();    // Bytes/Seconds

        IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Configuring control channel ConnectionInfo\n"
                "       ConnectionTimeout = %u\n"
                "       HeaderWaitTimeout = %u\n"
                "       MinFileBytesSec = %u\n",
                connectiontimeout,
                headerwaittimeout,
                pGlobalObject->QueryMinFileBytesSec()
                ));
        }

        //
        // let http.sys know about it.
        //
        Win32Error = HttpSetControlChannelInformation(
                            m_UlControlChannel,                    // control channel
                            HttpControlChannelTimeoutInformation,  // information class
                            &ConnectionInfo,                          // data to set
                            sizeof( ConnectionInfo )                  // data length
                            );

        if ( Win32Error != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32( Win32Error );

            const WCHAR * EventLogStrings[1];

            EventLogStrings[0] = L"Connection Info";

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_HTTP_CONTROL_CHANNEL_CONFIG_FAILED,                // message id
                    1,                                                     // count of strings
                    EventLogStrings,                                       // array of strings
                    hr                                                     // error code
                    );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Changing control channel connection info failed\n"
                ));

        }
    }

    //
    // If we are in BC mode and the filter flags have changed 
    // or if we are in FC mode and we have not guaranteed that
    // we are only filtering SSL then configure the SSL routing.
    //
    if ( ( pGlobalObject->QueryFilterFlagsChanged() &&
           GetWebAdminService()->
             IsBackwardCompatibilityEnabled() ) ||
         ( fConfiguredSSL == FALSE &&
           GetWebAdminService()->
             IsBackwardCompatibilityEnabled() == FALSE ) )
    {
        HTTP_CONTROL_CHANNEL_FILTER controlFilter;

        //
        // Attach the filter to the control channel.
        //

        SecureZeroMemory(&controlFilter, sizeof(controlFilter));

        controlFilter.Flags.Present = 1;
        controlFilter.FilterHandle = NULL;

        if ( GetWebAdminService()->
             IsBackwardCompatibilityEnabled() )
        {
            controlFilter.FilterOnlySsl =
                (( pGlobalObject->QueryFilterFlags() & SF_NOTIFY_READ_RAW_DATA )
                   ? false : true );
        }
        else
        {
            controlFilter.FilterOnlySsl = true;
            fConfiguredSSL = TRUE;
        }

        IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Configuring control channel Filter settings \n"
                "   FilterOnlySsl to %u\n",
                controlFilter.FilterOnlySsl
                ));
        }


        Win32Error = HttpSetControlChannelInformation(
                                m_UlControlChannel,
                                HttpControlChannelFilterInformation,
                                &controlFilter,
                                sizeof(controlFilter)
                                );

        if ( Win32Error != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32( Win32Error );

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_HTTP_CONTROL_CHANNEL_FILTER_CONFIG_FAILED,         // message id
                    0,                                                     // count of strings
                    NULL,                                                  // array of strings
                    hr                                                     // error code
                    );


            DPERROR((
                DBG_CONTEXT,
                hr,
                "Couldn't attach the filter to control channel\n"
                ));
        }

    }

    // 
    // If the Demand Start Threshold has changed, send it back down.
    //
    if ( pGlobalObject->QueryDemandStartLimitChanged() )
    {
        HTTP_CONTROL_CHANNEL_DEMAND_START_THRESHOLD DemandStartInfo;
        DWORD dwDemandStartThreshold = pGlobalObject->QueryDemandStartLimit();

        // First validate the value
        if ( dwDemandStartThreshold < MBCONST_DEMAND_START_THRESHOLD_LOW ||
             dwDemandStartThreshold > MBCONST_DEMAND_START_THRESHOLD_HIGH )
        {
            // Report that we are using the default instead
            // of the value provided because the value provided
            // is invalid.

            GetWebAdminService()->
            GetWMSLogger()->
            LogRangeGlobal( MBCONST_DEMAND_START_THRESHOLD_NAME,
                            dwDemandStartThreshold,
                            MBCONST_DEMAND_START_THRESHOLD_LOW,
                            MBCONST_DEMAND_START_THRESHOLD_HIGH,
                            MBCONST_DEMAND_START_THRESHOLD_DEFAULT,
                            TRUE );

            dwDemandStartThreshold = MBCONST_DEMAND_START_THRESHOLD_DEFAULT;
        }

        DemandStartInfo.Flags.Present = 1;
        DemandStartInfo.DemandStartThreshold = dwDemandStartThreshold;  // # processes

        IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Configuring control channel DemandStartThreshold = %u\n",
                DemandStartInfo.DemandStartThreshold
                ));
        }

        //
        // let http.sys know about it.
        //
        Win32Error = HttpSetControlChannelInformation(
                            m_UlControlChannel,                    // control channel
                            HttpControlChannelDemandStartThreshold,// information class
                            &DemandStartInfo,                      // data to set
                            sizeof( DemandStartInfo )              // data length
                            );

        if ( Win32Error != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32( Win32Error );

            const WCHAR * EventLogStrings[1];

            EventLogStrings[0] = MBCONST_DEMAND_START_THRESHOLD_NAME;

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_HTTP_CONTROL_CHANNEL_CONFIG_FAILED,                // message id
                    1,                                                     // count of strings
                    EventLogStrings,                                       // array of strings
                    hr                                                     // error code
                    );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Changing control channel Demand Start Threshold failed\n"
                ));

        }
    
    }

}   // UL_AND_WORKER_MANAGER::ModifyGlobalData

/***************************************************************************++

Routine Description:

    Configure's logging if centralized logging is turned on.

Arguments:

    pGlobalObject - The new configuration values for the server.

Return Value:

    VOID

--***************************************************************************/

VOID
UL_AND_WORKER_MANAGER::ConfigureLogging(
    IN GLOBAL_DATA_OBJECT* pGlobalObject
    )
{

    HRESULT hr = S_OK;
    DWORD   Win32Error = ERROR_SUCCESS;
    LPWSTR pLogFileDirectory = NULL;

    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pGlobalObject != NULL );

    //
    // Make the configuration changes.
    //

    //
    // Configure Centralized Logging
    //

    // Check if centralized configuration needs to be configured...
    if ( GetWebAdminService()->IsCentralizedLoggingEnabled() &&
         ( pGlobalObject->QueryLogFilePeriodChanged() ||
           pGlobalObject->QueryLogFileTruncateSizeChanged() ||
           pGlobalObject->QueryLogFileDirectoryChanged() ) )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Logging Properties ( as they come in from metabase ) are \n "
                        "   GlobalBinaryLoggingEnabled = %S \n"
                        "   LogFilePeriod = %d, %S \n"
                        "   LogFileTruncateSize = %d, %S \n"
                        "   LogFileDirectory = %S, %S \n",
                        pGlobalObject->QueryGlobalBinaryLoggingEnabled() ? L"TRUE"  : L"FALSE",
                        pGlobalObject->QueryLogFilePeriod(),
                        pGlobalObject->QueryLogFilePeriodChanged() ? L"TRUE" : L"FALSE",
                        pGlobalObject->QueryLogFileTruncateSize(),
                        pGlobalObject->QueryLogFileTruncateSizeChanged() ? L"TRUE"  : L"FALSE",
                        pGlobalObject->QueryLogFileDirectory() ? pGlobalObject->QueryLogFileDirectory() : L"<NULL>",
                        pGlobalObject->QueryLogFileDirectoryChanged() ? L"TRUE"  : L"FALSE" ));
        }

        HTTP_CONTROL_CHANNEL_BINARY_LOGGING BinaryLoggingProps;

        BinaryLoggingProps.Flags.Present = 1;
        BinaryLoggingProps.LoggingEnabled = TRUE;
        BinaryLoggingProps.LocaltimeRollover = FALSE;

       // Figure out what the length of the new directory path is that
        // the config store is giving us.
        DWORD ConfigLogFileDirLength =
              ExpandEnvironmentStrings( pGlobalObject->QueryLogFileDirectory(), NULL, 0);

        if ( ConfigLogFileDirLength == 0 )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Centralized Logging Configuration failed first ExpandEnvironmentStrings call\n" ));

            goto exit;
        }


        // Allocate enough space for the new directory path.
        // If this fails than we know that we have a memory issue.

        // ExpandEnvironmentStrings gives back a length including the null termination,
        // so we do not need an extra space for the terminator.

        pLogFileDirectory =
            ( LPWSTR )GlobalAlloc( GMEM_FIXED,
                                   ( ConfigLogFileDirLength + CCH_IN_LOG_FILE_DIRECTORY_PREFIX ) * sizeof(WCHAR)
                                 );

        if ( pLogFileDirectory == NULL )
        {
            hr = E_OUTOFMEMORY;

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Out of memory allocating the LogFileDirectory space to expand into \n" ));

            goto exit;
        }

        // Expand the Log File Path
        DWORD cchInExpandedString =
            ExpandEnvironmentStrings (    pGlobalObject->QueryLogFileDirectory()
                                        , pLogFileDirectory
                                        , ConfigLogFileDirLength );
        if ( cchInExpandedString == 0 )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Centralized Logging Configuration failed second ExpandEnvironmentStrings call\n" ));

            goto exit;
        }

        DBG_ASSERT (cchInExpandedString == ConfigLogFileDirLength);

        // First make sure that there is atleast one character
        // besides the null (that is included in the ConfigLogFileDirLength
        // before checking that the last character (back one to access the zero based
        // array and back a second one to avoid the terminating NULL) is
        // a slash.  If it is than change it to a null, since we are going
        // to add a slash with the \\W3SVC directory name anyway.
        if ( ConfigLogFileDirLength > 1
            && pLogFileDirectory[ConfigLogFileDirLength-2] == L'\\')
        {
            pLogFileDirectory[ConfigLogFileDirLength-2] = '\0';
        }

        // wcscat will null terminate.
        // we are not worried about the case where the length is longer
        // than the buffer size, because the buffer has been created
        // based on the size of strings that are being copied in.
        DBG_REQUIRE( wcscat( pLogFileDirectory,
                             LOG_FILE_DIRECTORY_PREFIX )
                        == pLogFileDirectory);


        // The actual length of the string may be effected by whether or not a slash was
        // provided when the string was passed in.  Because of this we will simply calculate
        // the length of the string again now.
        BinaryLoggingProps.LogFileDir.Length = (USHORT) wcslen(pLogFileDirectory) * sizeof(WCHAR);
        BinaryLoggingProps.LogFileDir.MaximumLength = BinaryLoggingProps.LogFileDir.Length + (1 * sizeof(WCHAR));
        BinaryLoggingProps.LogFileDir.Buffer = pLogFileDirectory;

        // Log File Period
        if ( pGlobalObject->QueryLogFilePeriod() > 4 )
        {
            GetWebAdminService()->
            GetWMSLogger()->
            LogRangeGlobal( L"LogFilePeriod",
                            pGlobalObject->QueryLogFilePeriod(),
                            0,  // Starting value
                            4,  // Ending value
                            1,  // Default value
                            TRUE );

            BinaryLoggingProps.LogPeriod = 1;
        }
        else
        {
            BinaryLoggingProps.LogPeriod = pGlobalObject->QueryLogFilePeriod();
        }

        // Log File Truncate Size
        if ( pGlobalObject->QueryLogFileTruncateSize() < HTTP_MIN_ALLOWED_TRUNCATE_SIZE_FOR_LOG_FILE &&
             BinaryLoggingProps.LogPeriod == HttpLoggingPeriodMaxSize )
        {
            WCHAR SizeLog[MAX_STRINGIZED_ULONG_CHAR_COUNT];
            _ultow(pGlobalObject->QueryLogFileTruncateSize(), SizeLog, 10);

            // Log an error.
            const WCHAR * EventLogStrings[1];

            EventLogStrings[0] = SizeLog;

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_GLOBAL_LOG_FILE_TRUNCATE_SIZE,        // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    0                                       // error code
                    );

            BinaryLoggingProps.LogFileTruncateSize = HTTP_MIN_ALLOWED_TRUNCATE_SIZE_FOR_LOG_FILE;
        }
        else
        {
            // Logging size is ok, just as it is.
            BinaryLoggingProps.LogFileTruncateSize = pGlobalObject->QueryLogFileTruncateSize();
        }

        //
        // let http.sys know about it.
        //
        Win32Error = HttpSetControlChannelInformation(
                            m_UlControlChannel,                    // control channel
                            HttpControlChannelBinaryLogging,       // information class
                            &BinaryLoggingProps,                          // data to set
                            sizeof( BinaryLoggingProps )                  // data length
                            );

        if ( Win32Error != NO_ERROR )
        {
            WCHAR bufPeriod[MAX_STRINGIZED_ULONG_CHAR_COUNT];
            WCHAR bufTruncate[MAX_STRINGIZED_ULONG_CHAR_COUNT];

            hr = HRESULT_FROM_WIN32( Win32Error );

            const WCHAR * EventLogStrings[4];

            _ultow( BinaryLoggingProps.LogPeriod, bufPeriod, 10 );
            _ultow( BinaryLoggingProps.LogFileTruncateSize, bufTruncate, 10 );

            EventLogStrings[0] = L"TRUE";
            EventLogStrings[1] = pLogFileDirectory ? pLogFileDirectory : L"<null>";
            EventLogStrings[2] = bufPeriod;
            EventLogStrings[3] = bufTruncate;

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_HTTP_CONTROL_CHANNEL_LOGGING_CONFIG_FAILED,        // message id
                    sizeof ( EventLogStrings ) / sizeof ( const WCHAR * ), // count of strings
                    EventLogStrings,                                       // array of strings
                    hr                                                     // error code
                    );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Changing control channel logging info failed\n"
                "   GlobalBinaryLoggingEnabled = %S \n"
                "   LogPeriod = %d, %S \n"
                "   LogFileTruncateSize = %d, %S \n"
                "   LogFileDirectory = %S, %S \n",
                pGlobalObject->QueryGlobalBinaryLoggingEnabled() ? L"TRUE"  : L"FALSE",
                BinaryLoggingProps.LogPeriod,
                pGlobalObject->QueryLogFilePeriodChanged() ? L"TRUE" : L"FALSE",
                BinaryLoggingProps.LogFileTruncateSize,
                pGlobalObject->QueryLogFileTruncateSizeChanged() ? L"TRUE"  : L"FALSE",
                pLogFileDirectory ? pLogFileDirectory : L"<NULL>",
                pGlobalObject->QueryLogFileDirectoryChanged() ? L"TRUE"  : L"FALSE" ));

            // Ignore this error so it doesn't get logged twice.
            hr = S_OK;

        } // end of error result from win32

    }  // end of if Centralized Logging

exit:

    if ( pLogFileDirectory )
    {
        GlobalFree ( pLogFileDirectory );
        pLogFileDirectory = NULL;
    }

    if ( FAILED ( hr ) )
    {
        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_CENTRALIZED_LOGGING_NOT_CONFIGURED,         // message id
                0,                                              // count of strings
                NULL,                                           // array of strings
                hr                                              // error code
                );
    }

}   // UL_AND_WORKER_MANAGER::ConfigureLogging

/***************************************************************************++

Routine Description:

    Modify an app pool.

Arguments:

    pAppPoolId - ID for the app pool to be modified.

    pNewAppPoolConfig - The new configuration values for the app pool.

    pWhatHasChanged - Which particular configuration values were changed.

Return Value:

    VOID

--***************************************************************************/

VOID
UL_AND_WORKER_MANAGER::ModifyAppPool(
    IN APP_POOL_DATA_OBJECT* pAppPoolObject
    )
{

    HRESULT hr = S_OK;
    APP_POOL * pAppPool = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;


    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pAppPoolObject != NULL );
    DBG_ASSERT( pAppPoolObject->QueryAppPoolId() != NULL );

    // if we are in BC mode then we
    // only modify the DefaultAppPool App Pool
    // all others can be ignored.
    if ( ( GetWebAdminService()->
           IsBackwardCompatibilityEnabled() ) &&
         ( _wcsicmp( pAppPoolObject->QueryAppPoolId()
                 , wszDEFAULT_APP_POOL  ) != 0 ) )
    {
        hr = S_OK;
        goto exit;
    }

    //
    // Look up the app pool in our data structures.
    //

    ReturnCode = m_AppPoolTable.FindKey(
                                    pAppPoolObject->QueryAppPoolId(),
                                    &pAppPool
                                    );

    if ( ReturnCode != LK_SUCCESS )
    {

        //
        // It should be there! Assert in debug builds.
        //
        DBG_ASSERT( ReturnCode != LK_NO_SUCH_KEY );


        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Finding app pool to modify in hashtable failed\n"
            ));

        goto exit;
    }

    //
    // Make the configuration changes.
    //

    // This routine returns an error here, but we ignore it.
    // If it errors the old configuration will still be in place
    // and we will have all ready logged an error.
    pAppPool->SetConfiguration( pAppPoolObject, FALSE );

exit:

    if ( FAILED ( hr ) )
    {
        GetWebAdminService()->GetWASLogger()->
            LogAppPoolError(
                WAS_APPPOOL_MODIFY_FAILED,
                hr,
                pAppPoolObject->QueryAppPoolId()
                );
    }

}   // UL_AND_WORKER_MANAGER::ModifyAppPool



/***************************************************************************++

Routine Description:

    Modify a virtual site.

Arguments:

    pSiteObject - The new configuration values for the virtual
    site.

Return Value:

    VOID

--***************************************************************************/

VOID
UL_AND_WORKER_MANAGER::ModifyVirtualSite(
    IN SITE_DATA_OBJECT* pSiteObject
    )
{

    HRESULT hr = S_OK;
    VIRTUAL_SITE * pVirtualSite = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;

    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( pSiteObject != NULL );

    //
    // Look up the virtual site in our data structures.
    //

    ReturnCode = m_VirtualSiteTable.FindKey(
                                        pSiteObject->QuerySiteId(),
                                        &pVirtualSite
                                        );

    if ( ReturnCode != LK_SUCCESS )
    {
        //
        // It should be there! Assert in debug builds.
        //
        DBG_ASSERT( ReturnCode != LK_NO_SUCH_KEY );

        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Finding virtual site to modify in hashtable failed\n"
            ));

        goto exit;
    }


    //
    // Make the configuration changes.
    //

    hr = pVirtualSite->SetConfiguration( pSiteObject, FALSE );
    if ( FAILED( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Setting new virtual site configuration failed\n"
            ));

        goto exit;
    }


exit:

    if ( FAILED ( hr ) )
    {
        GetWebAdminService()->GetWASLogger()->
            LogSiteError(
                WAS_SITE_MODIFY_FAILED,
                hr,
                pSiteObject->QuerySiteId()
                );
    }

}   // UL_AND_WORKER_MANAGER::ModifyVirtualSite



/***************************************************************************++

Routine Description:

    Modify an application.

Arguments:

    pAppObject - The new configuration values for the application.

Return Value:

    VOID

--***************************************************************************/

VOID
UL_AND_WORKER_MANAGER::ModifyApplication(
   IN APPLICATION_DATA_OBJECT *  pAppObject
   )
{

    HRESULT hr = S_OK;
    APPLICATION_ID ApplicationId;
    APPLICATION * pApplication = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;
    APP_POOL * pAppPool = NULL;

    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pAppObject != NULL );
    DBG_ASSERT( pAppObject->QueryApplicationUrl() != NULL );
    DBG_ASSERT( pAppObject->QueryAppPoolId() != NULL );

    ApplicationId.VirtualSiteId = pAppObject->QuerySiteId();
    hr = ApplicationId.ApplicationUrl.Copy ( pAppObject->QueryApplicationUrl() );
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed memory allocation when checking if created application exists\n"
            ));

        goto exit;
    }


    //
    // Look up the application in our data structures.
    //

    ReturnCode = m_ApplicationTable.FindKey(
                                        &ApplicationId,
                                        &pApplication
                                        );

    if ( ReturnCode == LK_NO_SUCH_KEY )
    {
        // It is a new application and should be treated
        // that way.

        CreateApplication( pAppObject );
        return;
    }

    if ( ReturnCode != LK_SUCCESS )
    {

        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Finding application to modify in hashtable failed\n"
            ));

        goto exit;
    }


    //
    // Resolve the app pool id to it's corresponding app pool object.
    //

    ReturnCode = m_AppPoolTable.FindKey(
                                    pAppObject->QueryAppPoolId(),
                                    &pAppPool
                                    );

    if ( ReturnCode != LK_SUCCESS )
    {

        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Looking up app pool referenced by application failed\n"
            ));

        goto exit;
    }

    //
    // Make the configuration changes.
    //

    pApplication->SetConfiguration( pAppObject, pAppPool );


exit:

    if ( FAILED ( hr ) )
    {
        GetWebAdminService()->GetWASLogger()->
            LogApplicationError(
                WAS_APPLICATION_MODIFY_FAILED,
                hr,
                pAppObject->QuerySiteId(),
                pAppObject->QueryApplicationUrl()
                );
    }

}   // UL_AND_WORKER_MANAGER::ModifyApplication

/***************************************************************************++

Routine Description:

    Routine will ask all the worker processes to recycle.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
UL_AND_WORKER_MANAGER::RecoverFromInetinfoCrash(
    )
{
    HRESULT hr = S_OK;

    // 1) In BC mode launch a worker process.
    // 2) In FC mode recycle all worker processes.
    // 3) Write all the states of the app pools to the metabase.


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    // Step 1 & 2, decide which mode and what we should be doing to the worker
    // processes.
    if ( GetWebAdminService()->IsBackwardCompatibilityEnabled() )
    {
        hr = StartInetinfoWorkerProcess();

        if ( FAILED( hr ) )
        {
            DPERROR((
                DBG_CONTEXT,
                hr,
                "Failed to start the worker process in inetinfo\n"
                ));

            goto exit;
        }
    }

    // We need to write state for the app pools for both
    // BC and FC mode.  However in FC mode we will also
    // recycle the worker processes.
    RecordPoolStates( TRUE );
    RecordSiteStates();

exit:

    return hr;

} // UL_AND_WORKER_MANAGER::RecoverFromInetinfoCrash

/***************************************************************************++

Routine Description:

    Routine will go through all app pools and record their states.

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/
VOID
UL_AND_WORKER_MANAGER::RecordPoolStates(
    BOOL fRecycleAsWell
    )
{
    DWORD SuccessCount = 0;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    SuccessCount = m_AppPoolTable.Apply( APP_POOL_TABLE::RecordPoolStatesAction,
                                         &fRecycleAsWell );

    DBG_ASSERT ( SuccessCount == m_AppPoolTable.Size() );

} // UL_AND_WORKER_MANAGER::RecoverFromInetinfoCrash

/***************************************************************************++

Routine Description:

    Routine will go through all app pools and record their states.

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/
VOID
UL_AND_WORKER_MANAGER::RecordSiteStates(
    )
{
    DWORD SuccessCount = 0;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    SuccessCount = m_VirtualSiteTable.Apply( VIRTUAL_SITE_TABLE::RecordVirtualSiteStatesAction,
                                   NULL );

    DBG_ASSERT ( SuccessCount == m_VirtualSiteTable.Size() );

} // UL_AND_WORKER_MANAGER::RecoverFromInetinfoCrash

/***************************************************************************++

Routine Description:

    Recycle a specific application pool

Arguments:

    IN LPCWSTR pAppPoolId = The app pool id we want to recycle.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
UL_AND_WORKER_MANAGER::RecycleAppPool(
    IN LPCWSTR pAppPoolId
    )
{
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );
    DBG_ASSERT ( pAppPoolId );

    HRESULT hr = S_OK;
    LK_RETCODE ReturnCode = LK_SUCCESS;
    APP_POOL* pAppPool = NULL;

    if ( GetWebAdminService()->IsBackwardCompatibilityEnabled() )
    {
        hr = HRESULT_FROM_WIN32( ERROR_OBJECT_NOT_FOUND );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Tried to recycle the default app pool \n"
            ));

        goto exit;
    }

    //
    // Find the default app pool from the app pool table.
    //

    ReturnCode = m_AppPoolTable.FindKey(pAppPoolId, &pAppPool);
    if ( ReturnCode != LK_SUCCESS )
    {
        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Finding default application in hashtable failed\n"
            ));

        //
        // If there is a problem getting the object from the
        // hash table assume that the object is not found.
        //
        hr = HRESULT_FROM_WIN32( ERROR_OBJECT_NOT_FOUND );

        goto exit;
    }


    hr = pAppPool->RecycleWorkerProcesses( WAS_EVENT_RECYCLE_POOL_ADMIN_REQUESTED );
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Recycling the app pool failed \n"
            ));

        goto exit;
    }

exit:

    return hr;
}


/***************************************************************************++

Routine Description:

    Process a site control operation, for all sites.

Arguments:

    Command - The command issued.

Return Value:

    VOID

--***************************************************************************/

VOID
UL_AND_WORKER_MANAGER::ControlAllSites(
    IN DWORD Command
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    m_VirtualSiteTable.ControlAllSites( Command );

}   // UL_AND_WORKER_MANAGER::ControlAllSites



/***************************************************************************++

Routine Description:

    Turn UL's HTTP request handling on.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::ActivateUl(
    )
{

    return SetUlMasterState( HttpEnabledStateActive );

}   // UL_AND_WORKER_MANAGER::ActivateUl



/***************************************************************************++

Routine Description:

    Turn UL's HTTP request handling off.

Arguments:

    None.

Return Value:

    VOID - If this fails there is nothing we can do, so we just return void.

--***************************************************************************/

VOID
UL_AND_WORKER_MANAGER::DeactivateUl(
    )
{

    SetUlMasterState( HttpEnabledStateInactive );

}   // UL_AND_WORKER_MANAGER::DeactivateUl



/***************************************************************************++

Routine Description:

    Kick off gentle shutdown of the UL&WM.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
UL_AND_WORKER_MANAGER::Shutdown(
    )
{

    m_State = ShutdownPendingUlAndWorkerManagerState;


    //
    // Tell UL to stop processing new requests.
    //

    DeactivateUl();


    //
    // Kick off clean shutdown of all app pools. Once all the app pools
    // have shut down (meaning that all of their worker processes have
    // shut down too), we will call back into the web admin service
    // object to complete shutdown.
    //
    m_AppPoolTable.Shutdown();

    //
    // See if shutdown has already completed. This could happen if we have
    // no app pools that have any real shutdown work to do.
    //

    CheckIfShutdownUnderwayAndNowCompleted();

}   // UL_AND_WORKER_MANAGER::Shutdown



/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities
    which may hold a reference to this object to release that reference
    (and not take any more), in order to break reference cycles.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
UL_AND_WORKER_MANAGER::Terminate(
    )
{

    m_State = TerminatingUlAndWorkerManagerState;


    //
    // Tell UL to stop processing new requests.
    //

    DeactivateUl();

    //
    // Note that we must clean up applications before the virtual sites
    // and app pools with which they are associated.
    //

    m_ApplicationTable.Terminate();

    m_VirtualSiteTable.Terminate();

    m_AppPoolTable.Terminate();

    if ( m_pPerfManager )
    {
        m_pPerfManager->Terminate();
    }

    if ( m_ASPPerfInit )
    {
        m_ASPPerfManager.UnInit();
        m_ASPPerfInit = FALSE;
    }

}   // UL_AND_WORKER_MANAGER::Terminate

/***************************************************************************++

Routine Description:

    In backward compatibility mode this function will find the Default App
    Pool entry from the table and will request that it launches the inetinfo
    worker process.  All timer work is handled by the worker process and
    app pool objects

    This function is not used in Forward Compatibility mode.

Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::StartInetinfoWorkerProcess(
    )
{

    HRESULT hr = S_OK;
    LK_RETCODE ReturnCode = LK_SUCCESS;
    APP_POOL* pDefaultAppPool = NULL;

    //
    // Find the default app pool from the app pool table.
    //

    ReturnCode = m_AppPoolTable.FindKey(wszDEFAULT_APP_POOL, &pDefaultAppPool);
    if ( ReturnCode != LK_SUCCESS )
    {
        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Finding default application in hashtable failed\n"
            ));

        goto exit;
    }

    //
    // Now tell the default app pool that it should demand
    // start a worker process in inetinfo.
    //

    hr = pDefaultAppPool->DemandStartInBackwardCompatibilityMode();

exit:

    return hr;

}   // UL_AND_WORKER_MANAGER::StartInetinfoWorkerProcess



#if DBG
/***************************************************************************++

Routine Description:

    Dump out key internal data structures.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
UL_AND_WORKER_MANAGER::DebugDump(
    )
{

    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "******************************\n"
            ));
    }


    m_AppPoolTable.DebugDump();

    m_VirtualSiteTable.DebugDump();

    m_ApplicationTable.DebugDump();


    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "******************************\n"
            ));
    }


    return;

}   // UL_AND_WORKER_MANAGER::DebugDump
#endif  // DBG



/***************************************************************************++

Routine Description:

    Remove an app pool object from the table of app pools. This method is
    used by app pool objects to remove themselves once they are done
    cleaning up. It should not be called outside of UL&WM owned code.

Arguments:

    pAppPool - The app pool object to remove.

Return Value:

    VOID

--***************************************************************************/

VOID
UL_AND_WORKER_MANAGER::RemoveAppPoolFromTable(
    IN APP_POOL * pAppPool
    )
{

    LK_RETCODE ReturnCode = LK_SUCCESS;


    DBG_ASSERT( pAppPool != NULL );


    //
    // Remove the app pool from the table.
    //

    ReturnCode = m_AppPoolTable.DeleteRecord( pAppPool );

    if ( ReturnCode != LK_SUCCESS )
    {

        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_LK_RETCODE( ReturnCode ),
            "Removing app pool from hashtable failed\n"
            ));

        //
        // Assert in debug builds. In retail, press on...
        //

        DBG_ASSERT( ReturnCode == LK_SUCCESS );

    }


    pAppPool->MarkAsNotInAppPoolTable();


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "App pool: %S deleted from app pool hashtable; total number now: %lu\n",
            pAppPool->GetAppPoolId(),
            m_AppPoolTable.Size()
            ));
    }


    //
    // Clean up the reference. Because each app pool is reference counted,
    // it will delete itself as soon as it's reference count hits zero.
    //

    pAppPool->Dereference();


    //
    // See if shutdown is underway, and if so if it has completed now
    // that this app pool is gone.
    //

    CheckIfShutdownUnderwayAndNowCompleted();


}   // UL_AND_WORKER_MANAGER::RemoveAppPoolFromTable

/***************************************************************************++

Routine Description:

    Sets up performance counter structures using the virtual site's table.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
UL_AND_WORKER_MANAGER::ActivatePerfCounters(
    )
{
    HRESULT hr = S_OK;
    DBG_ASSERT ( m_pPerfManager == NULL );

    m_pPerfManager = new PERF_MANAGER;
    if ( m_pPerfManager == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = m_pPerfManager->Initialize();
    if ( FAILED (hr) )
    {
        m_pPerfManager->Dereference();
        m_pPerfManager = NULL;
        goto exit;
    }

exit:

    if ( FAILED (hr) ) 
    {
        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_PERF_COUNTER_INITIALIZATION_FAILURE,               // message id
                0,                                                     // count of strings
                NULL,                                                  // array of strings
                hr                                                     // error code
                );
    }

}   // UL_AND_WORKER_MANAGER::ActivatePerfCounters

/***************************************************************************++

Routine Description:

    Initializes the ASP Counters.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
UL_AND_WORKER_MANAGER::ActivateASPCounters(
    )
{
    HRESULT hr = S_OK;

    DBG_ASSERT ( m_ASPPerfInit == FALSE );

    hr = m_ASPPerfManager.Init(GetWebAdminService()->
                               IsBackwardCompatibilityEnabled());
    if ( FAILED (hr) )
    {
        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_ASP_PERF_COUNTER_INITIALIZATION_FAILURE,
                0,                                                     // count of strings
                NULL,                                                  // array of strings
                hr                                                     // error code
                );
    }
    else
    {
        m_ASPPerfInit = TRUE;
    }

}   // UL_AND_WORKER_MANAGER::ActivatePerfCounters

/***************************************************************************++

Routine Description:

    Activate or deactivate UL's HTTP request handling.

Arguments:

    NewState - The new state to set, from the UL_ENABLED_STATE enum.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::SetUlMasterState(
    IN HTTP_ENABLED_STATE NewState
    )
{

    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;

    //
    // only change the state if we have the control channel.
    // if there was a problem while initializing the service
    // then we may have only partially completed initialization
    // but we will still be called for termination.  We don't
    // want to complain if the control channel is not initialized.
    //
    if ( m_UlControlChannel )
    {
        Win32Error = HttpSetControlChannelInformation(
                            m_UlControlChannel,                 // control channel
                            HttpControlChannelStateInformation, // information class
                            &NewState,                          // data to set
                            sizeof( NewState )                  // data length
                            );

        if ( Win32Error != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32( Win32Error );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Changing control channel state failed\n"
                ));

        }
    }


    return hr;

}   // UL_AND_WORKER_MANAGER::SetUlMasterState

/***************************************************************************++

Routine Description:

    See if shutdown is underway. If it is, see if shutdown has finished. If
    it has, then call back to the web admin service to tell it that we are
    done.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
UL_AND_WORKER_MANAGER::CheckIfShutdownUnderwayAndNowCompleted(
    )
{

    //
    // Are we shutting down?
    //

    if ( m_State == ShutdownPendingUlAndWorkerManagerState )
    {

        //
        // If so, have all the app pools gone away, meaning that we are
        // done?
        //

        if ( m_AppPoolTable.Size() == 0 )
        {

            //
            // Tell the web admin service that we are done with shutdown.
            //

            GetWebAdminService()->UlAndWorkerManagerShutdownDone();

        }

    }

}   // UL_AND_WORKER_MANAGER::CheckIfShutdownUnderwayAndNowCompleted

/***************************************************************************++

Routine Description:

    Lookup a virtual site and return a pointer to it.
Arguments:

    IN DWORD SiteId  -  The key to find the site by.

Return Value:

    VIRTUAL_SITE* A pointer to the virtual site
                  represented by the SiteId passed in.

    Note:  The VIRTUAL_SITE returned is not ref counted
           so it is only valid to use on the main thread
           during this work item.

    Note2: This can and will return a NULL if the site is not found.

--***************************************************************************/
VIRTUAL_SITE*
UL_AND_WORKER_MANAGER::GetVirtualSite(
    IN DWORD SiteId
    )
{
    VIRTUAL_SITE* pVirtualSite = NULL;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    LK_RETCODE ReturnCode = LK_SUCCESS;

    // Need to look up the site pointer.

    ReturnCode = m_VirtualSiteTable.FindKey(SiteId,
                                  &pVirtualSite);

    //
    // Since we are dependent on the id's that
    // the worker process sends us, it is entirely possible
    // that we can not find the site.  There for if spewing is
    // on just tell us about it and go on.
    //
    if ( ReturnCode != LK_SUCCESS )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Did not find site %d in the hash table "
                "(this can happen if the site was deleted but the wp had all ready accessed it)\n",
                SiteId
                ));
        }

        // Just make sure that the virtual site still is null
        DBG_ASSERT ( pVirtualSite == NULL );

        goto exit;
    }

exit:

    return pVirtualSite;
}

/***************************************************************************++

Routine Description:

    Deletes all IIS owned entries from the SSL Config Store.

Arguments:

    None

Return Value:

    None

--***************************************************************************/
VOID
UL_AND_WORKER_MANAGER::DeleteSSLConfigStoreInfo(
    )
{

    HRESULT                        hr = S_OK;
    DWORD                          Status = ERROR_SUCCESS;
    HTTP_SERVICE_CONFIG_SSL_QUERY  QueryParam;
    BUFFER                         bufSSLEntry;
    DWORD                          BytesNeeded = 0;
    PHTTP_SERVICE_CONFIG_SSL_SET   pSSLInfo = NULL;

    ZeroMemory(&QueryParam, sizeof(QueryParam));

    QueryParam.QueryDesc = HttpServiceConfigQueryNext;

    while ( Status == ERROR_SUCCESS )
    {
        Status = HttpQueryServiceConfiguration(
                    NULL,
                    HttpServiceConfigSSLCertInfo,
                    &QueryParam,
                    sizeof(QueryParam),
                    bufSSLEntry.QueryPtr(),
                    bufSSLEntry.QuerySize(),
                    &BytesNeeded,
                    NULL );

        if( Status == ERROR_INSUFFICIENT_BUFFER )
        {
            if ( !bufSSLEntry.Resize(BytesNeeded) )
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            Status = ERROR_SUCCESS;
        }
        else
        {
            if( Status == ERROR_SUCCESS )
            {
                DBG_ASSERT ( sizeof( HTTP_SERVICE_CONFIG_SSL_SET ) <= bufSSLEntry.QuerySize() );

                pSSLInfo = ( PHTTP_SERVICE_CONFIG_SSL_SET ) bufSSLEntry.QueryPtr();

                if ( IsEqualGUID ( pSSLInfo->ParamDesc.AppId, W3SVC_SSL_OWNER_GUID ) )
                {
                    // We own the entry so we can delete it.
                    Status = HttpDeleteServiceConfiguration( 
                                NULL,
                                HttpServiceConfigSSLCertInfo,
                                bufSSLEntry.QueryPtr(),
                                sizeof( HTTP_SERVICE_CONFIG_SSL_SET ),
                                NULL );

                    if ( Status != ERROR_SUCCESS )
                    {
                        hr = HRESULT_FROM_WIN32(Status);
                        goto exit;
                    }
                }
                else
                {

                    QueryParam.dwToken++;
                }
            }
        }
    }

    if ( Status != ERROR_NO_MORE_ITEMS )
    {
        DBG_ASSERT( Status != ERROR_SUCCESS );

        hr = HRESULT_FROM_WIN32(Status);
    }
    else
    {
        Status = ERROR_SUCCESS;
    }

exit:

    if ( FAILED ( hr ) )
    {

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_HTTP_SSL_ENTRY_CLEANUP_FAILED,                  // message id
                0,                                                  // count of strings
                NULL,                                               // array of strings
                hr                                                  // error code
                );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to cleanup all SSL entries on startup \n"
            ));

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\was_change_item.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    WAS_CHANGE_ITEM.h

Abstract:

    The IIS web admin service configuration change class definition
    for passing change notifications to the main thread of WAS

Author:

    Emily Kruglick (emilyk)        28-May-2001

Revision History:

--*/



#ifndef _WAS_CHANGE_ITEM_H_
#define _WAS_CHANGE_ITEM_H_

class GLOBAL_DATA_STORE;
class APP_POOL_DATA_OBJECT_TABLE;
class SITE_DATA_OBJECT_TABLE;
class APPLICATION_DATA_OBJECT_TABLE;

//
// common #defines
//

#define WAS_CHANGE_ITEM_SIGNATURE         CREATE_SIGNATURE( 'WCWI' )
#define WAS_CHANGE_ITEM_SIGNATURE_FREED   CREATE_SIGNATURE( 'wcwX' )

//
// structs, enums, etc.
//

// WAS_CHANGE_ITEM work items
typedef enum _WAS_CHANGE_ITEM_WORK_ITEM
{

    //
    // Process a configuration change.
    //
    ProcessChangeConfigChangeWorkItem = 1,
    
} WAS_CHANGE_ITEM_WORK_ITEM;



//
// prototypes
//


class WAS_CHANGE_ITEM
    : public WORK_DISPATCH
{

public:

    WAS_CHANGE_ITEM(
        );

    virtual
    ~WAS_CHANGE_ITEM(
        );

    virtual
    VOID
    Reference(
        );

    virtual
    VOID
    Dereference(
        );

    virtual
    HRESULT
    ExecuteWorkItem(
        IN const WORK_ITEM * pWorkItem
        );

    HRESULT
    CopyChanges(
        IN GLOBAL_DATA_STORE *                 pGlobalStore,
        IN SITE_DATA_OBJECT_TABLE *            pSiteTable,
        IN APPLICATION_DATA_OBJECT_TABLE *     pApplicationTable,
        IN APP_POOL_DATA_OBJECT_TABLE *        pAppPoolTable
        );

    VOID
    ProcessChanges(
        );

    GLOBAL_DATA_STORE * 
    QueryGlobalStore(
        )
    {
        return &m_GlobalStore;
    }


    APPLICATION_DATA_OBJECT_TABLE *
    QueryAppTable(
        ) 
    {
        return &m_AppTable;
    }

    SITE_DATA_OBJECT_TABLE *
    QuerySiteTable(
        ) 
    {
        return &m_SiteTable;
    }

    APP_POOL_DATA_OBJECT_TABLE *
    QueryAppPoolTable(
        ) 
    {
        return &m_AppPoolTable;
    }

private:

	WAS_CHANGE_ITEM( const WAS_CHANGE_ITEM & );
	void operator=( const WAS_CHANGE_ITEM & );

    DWORD m_Signature;

    LONG m_RefCount;

    GLOBAL_DATA_STORE m_GlobalStore;

    APP_POOL_DATA_OBJECT_TABLE m_AppPoolTable;

    SITE_DATA_OBJECT_TABLE m_SiteTable;

    APPLICATION_DATA_OBJECT_TABLE m_AppTable;

};  // class WAS_CHANGE_ITEM



#endif  // _WAS_CHANGE_ITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\ap\was\dll\web_admin_service.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    web_admin_service.h

Abstract:

    The IIS web admin service class definition. 

Author:

    Seth Pollack (sethp)        23-Jul-1998

Revision History:

--*/


#ifndef _WEB_ADMIN_SERVICE_H_
#define _WEB_ADMIN_SERVICE_H_

// registry helper
DWORD
ReadDwordParameterValueFromRegistry(
    IN LPCWSTR RegistryValueName,
    IN DWORD DefaultValue
    );


//
// common #defines
//

#define WEB_ADMIN_SERVICE_SIGNATURE         CREATE_SIGNATURE( 'WASV' )
#define WEB_ADMIN_SERVICE_SIGNATURE_FREED   CREATE_SIGNATURE( 'wasX' )


//
// BUGBUG The service, dll, event source, etc. names are likely to change;
// decide on the real ones. 
//

#define WEB_ADMIN_SERVICE_NAME_W    L"w3svc"
#define WEB_ADMIN_SERVICE_NAME_A    "w3svc"

#define WEB_ADMIN_SERVICE_DLL_NAME_W    L"iisw3adm.dll"

#define WEB_ADMIN_SERVICE_EVENT_SOURCE_NAME L"W3SVC"

#define WEB_ADMIN_SERVICE_STARTUP_WAIT_HINT         ( 180 * ONE_SECOND_IN_MILLISECONDS )  // 3 minutes
#define WEB_ADMIN_SERVICE_STATE_CHANGE_WAIT_HINT    ( 20 * ONE_SECOND_IN_MILLISECONDS ) // 20 seconds
#define WEB_ADMIN_SERVICE_STATE_CHANGE_TIMER_PERIOD \
            ( WEB_ADMIN_SERVICE_STATE_CHANGE_WAIT_HINT / 2 )

#define NULL_SERVICE_STATUS_HANDLE  ( ( SERVICE_STATUS_HANDLE ) NULL )

//
// structs, enums, etc.
//

// WEB_ADMIN_SERVICE work items
enum WEB_ADMIN_SERVICE_WORK_ITEM
{

    //
    // Start the service.
    //
    StartWebAdminServiceWorkItem = 1,

    //
    // Stop the service.
    //
    StopWebAdminServiceWorkItem,

    //
    // Pause the service.
    //
    PauseWebAdminServiceWorkItem,

    //
    // Continue the service.
    //
    ContinueWebAdminServiceWorkItem,

    //
    // Recover from inetinfo crash.
    //
    RecoverFromInetinfoCrashWebAdminServiceWorkItem,
    
};

// WEB_ADMIN_SERVICE work items
enum ENABLED_ENUM
{
    //
    // Flag has not been set.
    //
    ENABLED_INVALID = -1,

    //
    // Flag is disabled
    //
    ENABLED_FALSE,

    //
    // Flag is enabled.
    //
    ENABLED_TRUE,
    
};


//
// prototypes
//

class WEB_ADMIN_SERVICE 
    : public WORK_DISPATCH
{

public:

    WEB_ADMIN_SERVICE(
        );

    virtual
    ~WEB_ADMIN_SERVICE(
        );

    virtual
    VOID
    Reference(
        );

    virtual
    VOID
    Dereference(
        );

    virtual
    HRESULT
    ExecuteWorkItem(
        IN const WORK_ITEM * pWorkItem
        );

    VOID
    ExecuteService(
        );

    inline
    WORK_QUEUE *
    GetWorkQueue(
        )
    { return &m_WorkQueue; }

    inline
    UL_AND_WORKER_MANAGER *
    GetUlAndWorkerManager(
        )
    { 
        DBG_ASSERT( ON_MAIN_WORKER_THREAD );
        return &m_UlAndWorkerManager;
    }

    inline
    CONFIG_AND_CONTROL_MANAGER *
    GetConfigAndControlManager(
        )
    { 
        return &m_ConfigAndControlManager;
    }

    inline
    EVENT_LOG *
    GetEventLog(
        )
    { return &m_EventLog; }

    inline
    WAS_ERROR_LOGGER *
    GetWASLogger(
        )
    { return &m_ErrLogger; }

    inline
    WMS_ERROR_LOGGER*
    GetWMSLogger(
        )
    { return &m_WMSLogger; }

    inline
    HANDLE
    GetSharedTimerQueue(
        )
    { return m_SharedTimerQueueHandle; }

    inline
    LPCWSTR
    GetCurrentDirectory(
        )
        const
    {
        return m_CurrentDirectory.QueryStr();
    }

    inline
    TOKEN_CACHE&
    GetTokenCache(
        )         
    {
        return m_TokenCache;
    }

    inline
    TOKEN_CACHE_ENTRY *
    GetLocalSystemTokenCacheEntry(
        )
        const
    {
        DBG_ASSERT( m_pLocalSystemTokenCacheEntry != NULL );
        return m_pLocalSystemTokenCacheEntry;
    }

    inline
    TOKEN_CACHE_ENTRY *
    GetLocalServiceTokenCacheEntry(
        )
        const
    {
        DBG_ASSERT( m_pLocalServiceTokenCacheEntry != NULL );
        return m_pLocalServiceTokenCacheEntry;
    }

    inline
    TOKEN_CACHE_ENTRY *
    GetNetworkServiceTokenCacheEntry(
        )
        const
    {
        DBG_ASSERT( m_pNetworkServiceTokenCacheEntry != NULL );
        return m_pNetworkServiceTokenCacheEntry;
    }

    inline
    BOOL
    IsBackwardCompatibilityEnabled(
        )
        const
    {
        // Compatibilty should always be set before this function is called.
        DBG_ASSERT( m_BackwardCompatibilityEnabled != ENABLED_INVALID);

        return (m_BackwardCompatibilityEnabled == ENABLED_TRUE);
    }

    inline
    BOOL
    IsCentralizedLoggingEnabled(
        )
        const
    {
        // CentralizedLoggingEnabled should always be set before this function is called.
        DBG_ASSERT( m_CentralizedLoggingEnabled != ENABLED_INVALID);

        return ( m_CentralizedLoggingEnabled == ENABLED_TRUE );
    }

    VOID
    SetGlobalBinaryLogging(
        BOOL CentralizedLoggingEnabled
        );     

    inline
    DWORD
    GetMainWorkerThreadId(
        )
        const
    { return m_MainWorkerThreadId; }

    inline
    DWORD
    GetConfigWorkerThreadId(
        )
        const
    { return m_ConfigWorkerThreadId; }

    inline
    DWORD
    GetServiceState(
        )
        const
    {
        //
        // Note: no explicit synchronization is necessary on this thread-
        // shared variable because this is an aligned 32-bit read.
        //

        return m_ServiceStatus.dwCurrentState;
    }

    VOID
    FatalErrorOnSecondaryThread(
            IN HRESULT SecondaryThreadError
        );

    HRESULT
    InterrogateService(
        );

    HRESULT
    InitiateStopService(
        );

    HRESULT
    InitiatePauseService(
        );

    HRESULT
    InitiateContinueService(
        );

    HRESULT
    UpdatePendingServiceStatus(
        );

    VOID
    UlAndWorkerManagerShutdownDone(
        );

    VOID 
    InetinfoRegistered(
        );

    HRESULT 
    LaunchInetinfo(
        );

    DWORD
    ServiceStartTime(
        )
    { 
        return m_ServiceStartTime; 
    }

    HRESULT
    RequestStopService(
        IN BOOL EnableStateCheck
        );

    HRESULT 
    RecoverFromInetinfoCrash(
        );

    HRESULT
    QueueRecoveryFromInetinfoCrash(
        );

    PSID
    GetLocalSystemSid(
        );


    VOID 
    SetHrToReportToSCM(
        HRESULT hrToReport
        )
    {
        m_hrToReportToSCM = hrToReport;
    }

    CSecurityDispenser*
    GetSecurityDispenser(
        )
    { return &m_SecurityDispenser; }

    VOID
    SetConfigThreadId(
        DWORD ConfigThreadId
        )
    {
        m_ConfigWorkerThreadId = ConfigThreadId;
    }

    DWORD_PTR
    GetSystemActiveProcessMask(
        );

    BOOL
    RunningOnPro(
        )
    { return m_fOnPro; }

    DWORD
    NumberOfSitesStarted(
        )
    { return m_NumSitesStarted; }

    VOID
    IncrementSitesStarted(
        )
    { m_NumSitesStarted++; }

    VOID
    DecrementSitesStarted(
        )
    { m_NumSitesStarted--; }

    LPWSTR
    GetWPDesktopString(
        )
    { 
        if  ( m_strWPDesktop.IsEmpty() )
        {
            return NULL;
        }
        else
        {
            return m_strWPDesktop.QueryStr();
        }
    }


private:

	WEB_ADMIN_SERVICE( const WEB_ADMIN_SERVICE & );
	void operator=( const WEB_ADMIN_SERVICE & );

    HRESULT
    StartWorkQueue(
        );

    HRESULT
    MainWorkerThread(
        );

    HRESULT
    StartServiceWorkItem(
        );

    HRESULT
    FinishStartService(
        );

    VOID
    StopServiceWorkItem(
        );

    VOID
    FinishStopService(
        );

    HRESULT
    PauseServiceWorkItem(
        );

    HRESULT
    FinishPauseService(
        );

    HRESULT
    ContinueServiceWorkItem(
        );

    HRESULT
    FinishContinueService(
        );

    HRESULT
    BeginStateTransition(
        IN DWORD NewState,
        IN BOOL  EnableStateCheck
        );

    HRESULT
    FinishStateTransition(
        IN DWORD NewState,
        IN DWORD ExpectedPreviousState
        );

    BOOL
    IsServiceStateChangePending(
        )
        const;

    HRESULT
    UpdateServiceStatus(
        IN DWORD State,
        IN DWORD Win32ExitCode,
        IN DWORD ServiceSpecificExitCode,
        IN DWORD CheckPoint,
        IN DWORD WaitHint
        );
        
    HRESULT
    ReportServiceStatus(
        );

    VOID
    SetBackwardCompatibility(
        );  
    
    HRESULT
    SetOnPro(
        );

    HRESULT
    InitializeInternalComponents(
        );

    HRESULT
    DetermineCurrentDirectory(
        );

    HRESULT
    CreateCachedWorkerProcessTokens(
        );

    HRESULT
    InitializeOtherComponents(
        );

    HRESULT
    SetupSharedWPDesktop(
        );

    BOOL
    W3SVCRunningInteractive(
        );

    HRESULT
    GenerateWPDesktop(
        );

    VOID
    Shutdown(
        );

    VOID
    TerminateServiceAndReportFinalStatus(
        IN HRESULT Error
        );

    VOID
    Terminate(
        );

    HRESULT
    CancelPendingServiceStatusTimer(
        IN BOOL BlockOnCallbacks
        );

    HRESULT
    DeleteTimerQueue(
        );


    DWORD m_Signature;


    LONG m_RefCount;


    // the work queue
    WORK_QUEUE m_WorkQueue;


    // drives UL.sys and worker processes
    UL_AND_WORKER_MANAGER m_UlAndWorkerManager;


    // brokers configuration state and changes, as well as control operations
    CONFIG_AND_CONTROL_MANAGER m_ConfigAndControlManager;


    // event logging
    EVENT_LOG m_EventLog;

    //
    // Prevent races in accessing the service state structure,
   