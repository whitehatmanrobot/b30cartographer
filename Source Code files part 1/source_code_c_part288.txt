rned storage must be released and both
//              release mechanisms must be called if both data items are
//              returned.
//
//--------------------------------------------------------------------------

HRESULT GetDataFromStorage(IDataObject *pDataObj, FORMATETC *pformatetc,
        STGMEDIUM *pmedium, IStorage **ppstg)
{
    HRESULT         hresult;
    STGMEDIUM       memmedium;      // for the memory-based IStorage
    ILockBytes *    pLockBytes;
    BOOL            fDeleteOnRelease = FALSE;
    FORMATETC       fetctemp;


    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN GetDataFromStorage ( %p , %p , %p"
        " )\n", NULL, pDataObj, pformatetc, pmedium));

#if DBG ==1
    if( pmedium )
    {
        Assert(pmedium->tymed == TYMED_HGLOBAL);
    }
#endif // DBG ==1

    Assert(pformatetc->tymed & TYMED_ISTORAGE);

    // don't stomp on the in-parameter
    fetctemp = *pformatetc;
    fetctemp.tymed = TYMED_ISTORAGE;


    _xmemset(&memmedium, 0, sizeof(STGMEDIUM));
    memmedium.tymed = TYMED_ISTORAGE;

    // the only time we want the hglobal that the storage will be
    // constructed from to be automatically deleted is if the caller
    // only requested a storage to be returned.

    if( ppstg && !pmedium )
    {
        fDeleteOnRelease = TRUE;
    }

    hresult = UtCreateStorageOnHGlobal( NULL,
                fDeleteOnRelease,
                &(memmedium.pstg), &pLockBytes);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    // first try to do a GetDataHere call

    hresult = pDataObj->GetDataHere( &fetctemp, &memmedium );

    if( hresult != NOERROR )
    {
        STGMEDIUM       appmedium;      // a medium that is filled
                        // in by the app

        _xmemset(&appmedium, 0, sizeof(STGMEDIUM));

        // hmmm, that didn't work, try for a plain GetData call
        hresult = pDataObj->GetData(&fetctemp, &appmedium);

        if( hresult == NOERROR )
        {
            // now do the CopyTo

            hresult = appmedium.pstg->CopyTo(0, NULL, NULL,
                    memmedium.pstg);

            // we are now done with the app supplied medium
            ReleaseStgMedium(&appmedium);
        }
    }

    // release the storage unless there's no error and the
    // caller requested a copy

    if( ppstg && hresult == NOERROR )
    {
        *ppstg = memmedium.pstg;
        // we need to do a Commit here to flush cached data to
        // disk (in this case, to the hglobal).  The release
        // below in the alternate code path will automatically
        // cause a Commit
        memmedium.pstg->Commit(STGC_DEFAULT);
    }
    else
    {
        memmedium.pstg->Release();
    }

    // now retrieve the HGLOBAL from the storage.  NB! It is very
    // important to do this *after* the release; the final release
    // on the storage causes a Commit.  (Alternately, we can simply
    // call Commit--see above).

    if( hresult == NOERROR && pmedium )
    {
        hresult = GetHGlobalFromILockBytes(pLockBytes,
                &(pmedium->hGlobal));
    }

    pLockBytes->Release();

errRtn:
    LEDebugOut((DEB_ITRACE, "%p OUT GetDataFromStorage ( %lx )\n",
        NULL, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetDataFromStream
//
//  Synopsis:   Calls GetData[Here] for TYMED_ISTREAM and returns the
//              results on an HGLOBAL
//
//  Effects:
//
//  Arguments:  [pDataObj]      -- the source data object
//              [pformatetc]    -- the formatetc to retrieve
//              [pmedium]       -- where to put the resulting HGlobal.
//                                 (may be NULL)
//              [ppstm]         -- where to put the stream ( may be NULL )
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  we create a stream on memory
//              first try to GetDataHere to that stream, if that fails, then
//              do a GetData and CopyTo the returned stream to our memory
//              stream.
//
//  History:    dd-mmm-yy Author    Comment
//              11-Apr-94 alexgo    author
//
//  Notes:      NB!!: The caller takes ownership fo the data returned, either
//              GlobalFree or Release (or both) must be called.
//
//--------------------------------------------------------------------------

HRESULT GetDataFromStream(IDataObject *pDataObj, FORMATETC *pformatetc,
        STGMEDIUM *pmedium, IStream **ppstm)
{
    HRESULT         hresult;
    STGMEDIUM       memmedium;      // for the memory-based IStream
    HGLOBAL         hglobal = NULL;
    BOOL            fDeleteOnRelease = FALSE;
    FORMATETC       fetctemp;


    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN GetDataFromStream ( %p , %p , %p )\n",
        NULL, pDataObj, pformatetc, pmedium));

    // the only time we want the underlying hglobal for the stream to
    // be automatically deleted is if the caller only wanted the
    // stream returned.

    if( ppstm && !pmedium )
    {
        fDeleteOnRelease = TRUE;
    }

    Assert( pformatetc->tymed & TYMED_ISTREAM );

    // don't stomp on the in-parameter
    fetctemp = *pformatetc;
    fetctemp.tymed = TYMED_ISTREAM;


    _xmemset(&memmedium, 0, sizeof(STGMEDIUM));
    memmedium.tymed = TYMED_ISTREAM;

    hresult = CreateStreamOnHGlobal( NULL,
                fDeleteOnRelease,
                &(memmedium.pstm));

    if( hresult != NOERROR )
    {
        goto logRtn;
    }


    // first try to do a GetDataHere call

    hresult = pDataObj->GetDataHere( &fetctemp, &memmedium );

    if( hresult != NOERROR )
    {
      if (hresult == E_OUTOFMEMORY)
      {
        goto errRtn;
      }

        STGMEDIUM       appmedium;      // a medium that is filled
                        // in by the app
        LARGE_INTEGER   li;
        ULARGE_INTEGER  uli;
        ULARGE_INTEGER  uliWritten;
#if DBG == 1
        ULARGE_INTEGER  uliEnd;
#endif

        _xmemset(&appmedium, 0, sizeof(STGMEDIUM));

        // hmmm, that didn't work, try for a plain GetData call
        hresult = pDataObj->GetData( &fetctemp, &appmedium );

        if( hresult != NOERROR )
        {
            // oh well, we tried.  Cleanup and away we go
            goto errRtn;
        }

        // now do the CopyTo.  In order to do this, we need
        // to get the size of the returned stream, reset its
        // seek pointer to the beginning and then do a stream
        // CopyTo.

        LISet32(li, 0);

        hresult = appmedium.pstm->Seek(li, STREAM_SEEK_CUR, &uli);

        if( hresult != NOERROR )
        {
            ReleaseStgMedium(&appmedium);
            goto errRtn;
        }

#if DBG == 1

        // According to the spec, the end of the data should be
        // positioned at the current seek pointer (which is
        // not necessarily the end of the stream).  Here we will
        // see if the current seek pointer is at the *end* of the
        // stream.  If the current seek is NOT equal to the end,
        // then there is a good chance of a bug somewhere in the
        // system (so we'll print a warning)

        hresult = appmedium.pstm->Seek(li, STREAM_SEEK_END, &uliEnd);

        // we don't return on error for debug builds so retail
        // and debug have exactly the same behaviour

        if( hresult == NOERROR )
        {
            // compare the two seek pointers.  The high parts
            // *must* be zero (or we're hosed, since all of
            // this is taking place in memory

            Assert(uliEnd.HighPart == 0);

            LEWARN(uliEnd.LowPart != uli.LowPart,
                "Stream seek pointer "
                "not at end, possible error");
        }
        else
        {
            LEDebugOut((DEB_ERROR, "ERROR!: IStream->Seek failed!"
                "\n"));
            // FALL-THROUGH!!  This is deliberate--even
            // though we're in an error case, we want
            // debug && retail to have the same behaviour
            // (besides, we'll most likely fail in the
            // Seek call below).
        }

#endif // DBG == 1


        // now backup to the beginning

        hresult = appmedium.pstm->Seek(li, STREAM_SEEK_SET, NULL);

        if( hresult != NOERROR )
        {
            ReleaseStgMedium(&appmedium);
            goto errRtn;
        }

        // now that we know how many bytes to copy, actually do so.

        hresult = appmedium.pstm->CopyTo(memmedium.pstm, uli,
                NULL, &uliWritten);

        if( hresult == NOERROR )
        {
            // make sure we got enough data
            if( uli.LowPart != uliWritten.LowPart )
            {
                // we probably ran out of memory
                // trying to resize the memory stream
                hresult = ResultFromScode(E_OUTOFMEMORY);
            }
        }

        // we are now done with the app supplied medium
        ReleaseStgMedium(&appmedium);
    }

    // now fetch the hglobal from the [resized] memory stream

    if( hresult == NOERROR )
    {
        hresult = GetHGlobalFromStream(memmedium.pstm, &hglobal);
    }

errRtn:

    // if the caller wanted the stream, then give it to him
    // (only if there was no error)
    // otherwise, release it

    if( hresult == NOERROR && ppstm )
    {
        *ppstm = memmedium.pstm;
        // we do not need to call Commit in this case; our
        // implementation of memory streams guarantees that
        // the underlying hglobal always contains flushed
        // information.
    }
    else
    {
        if(memmedium.pstm)
        {
            memmedium.pstm->Release();
        }
    }

    // if there was an error, then would have never allocated the
    // hglobal

    if( hresult == NOERROR && pmedium)
    {
        pmedium->hGlobal = hglobal;
    }

logRtn:
    LEDebugOut((DEB_ITRACE, "%p OUT GetDataFromStream ( %lx )\n",
        NULL, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetNative
//
//  Synopsis:   Retrieves or syntesizes OLE1 Native data format
//
//  Effects:
//
//  Arguments:  [pDataObj]      -- the source data object
//              [pmedium]       -- where to put the data
//
//  Requires:   pmedium->tymed must be TYMED_HGLOBAL
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//              cfNative is an OLE1 format consisting of an aribtrary
//              hGlobal.  It is up to the source app to interpret any
//              data therein; OLE1 containers merely store and forward it.
//
//              first fetch either EmbedSource or EmbeddedObject
//              then check to see if that NATIVE_STREAM exists.  If so,
//              then this was an object created from an OLE1 server and
//              we should just offer it's native data.
//              Otherwise, the object is an OLE2 object, and we should
//              offer it's storage as the native data.
//
//  History:    dd-mmm-yy Author    Comment
//              10-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT GetNative( IDataObject *pDataObj, STGMEDIUM *pmedium)
{
    HRESULT         hresult;
    IStorage *      pstg = NULL;
    IStream *       pstm = NULL;
    UINT            cf;
    HGLOBAL         hNative = NULL;
    DWORD           dwSize = 0;
    LPVOID          pv;
    FORMATETC       formatetc;


    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN GetNative ( %p , %p )\n", NULL,
        pDataObj, pmedium));

    Assert(pmedium->tymed == TYMED_HGLOBAL);

    if( SSIsClipboardFormatAvailable(g_cfEmbeddedObject) )
    {
        cf = g_cfEmbeddedObject;
    }
    else if( SSIsClipboardFormatAvailable(g_cfEmbedSource) )
    {
        cf = g_cfEmbedSource;
    }
    else
    {
        hresult = ResultFromScode(E_UNEXPECTED);
        LEDebugOut((DEB_ERROR, "ERROR!: Native data should not "
            "be on clipboard!!\n"));
        goto errRtn;
    }

    INIT_FORETC(formatetc);
    formatetc.cfFormat = (CLIPFORMAT) cf;
    formatetc.tymed = TYMED_ISTORAGE;

    hresult = GetDataFromStorage(pDataObj, &formatetc, pmedium, &pstg);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    hresult = pstg->OpenStream(OLE10_NATIVE_STREAM, NULL, STGM_SALL, 0,
            &pstm);

    if( hresult == NOERROR )
    {
        // we had ole1 data originally, just use it.

        hresult = StRead(pstm, &dwSize, sizeof(DWORD));

        if( hresult != NOERROR )
        {
            goto errRtn;
        }

        hNative = GlobalAlloc((GMEM_SHARE | GMEM_MOVEABLE), dwSize);

        if( !hNative )
        {
            LEDebugOut((DEB_WARN, "WARNING: GlobalAlloc failed!"
                "\n"));
            hresult = ResultFromScode(E_OUTOFMEMORY);
            goto errRtn;
        }

        pv = GlobalLock(hNative);

        if( !pv )
        {
            LEDebugOut((DEB_WARN, "WARNING: GlobalLock failed!"
                "\n"));
            hresult = ResultFromScode(E_OUTOFMEMORY);
            goto errRtn;
        }

        // now copy the data from the stream into the hglobal

        hresult = StRead(pstm, pv, dwSize);

        GlobalUnlock(hNative);

        if( hresult != NOERROR )
        {
            goto errRtn;
        }

        // this is bit is counter-intuitive.  The hglobal
        // we have in pmedium->hGlobal still has a storage on
        // top of it, so we must release our stream, then
        // the storage, and finally free the hglobal so we
        // don't leak memory.  We've already allocated another
        // hglobal in this routine to return the Native data.

        pstm->Release();
        pstg->Release();
        GlobalFree(pmedium->hGlobal);

        // now we assign pmedium->hGlobal to the hglobal we
        // just created so we can pass it out

        pmedium->hGlobal = hNative;

        // don't release the streams again
        goto logRtn;

    }
    else
    {
        // storage for an OLE2 object.  pmedium->hGlobal
        // should already contain the data we need to put
        // on the clipboard (from the GetDataFromStorage call)

        Assert(pmedium->hGlobal);
        hresult = NOERROR;
    }

errRtn:
    if( pstm )
    {
        pstm->Release();
    }

    if( pstg )
    {
        pstg->Release();
    }

    if( hresult != NOERROR )
    {
        GlobalFree(pmedium->hGlobal);
    }

logRtn:

    LEDebugOut((DEB_ITRACE, "%p OUT GetNative ( %lx ) [ %lx ]\n",
        NULL, hresult, pmedium->hGlobal));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetObjectLink
//
//  Synopsis:   Synthesizes OLE1 ObjectLink format from LinkSource data
//
//  Effects:
//
//  Arguments:  [pDataObj]      -- the source data object
//              [pmedium]       -- where to put the data
//
//  Requires:   pmedium->tymed must be TYMED_HGLOBAL
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Get the LinkSource data, which contains a serialized
//              moniker.  Load the moniker from the stream and parse it
//              to retrieve the file name and item name (if available).
//              Get the class ID of the link source from either the
//              LinkSource stream or from LinkSrcDescriptor.
//              Once these strings are converted to ANSI, we can build
//              the ObjectLink format, which looks like:
//
//              classname\0filename\0itemname\0\0
//
//  History:    dd-mmm-yy Author    Comment
//              10-Jun-94 alexgo    author
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT GetObjectLink( IDataObject *pDataObj, STGMEDIUM *pmedium)
{
    HRESULT         hresult;
    IStream *       pstm = NULL;
    IMoniker *      pmk = NULL;
    CLSID           clsid;
    LPOLESTR        pszFile = NULL,
            pszClass = NULL,
            pszItem = NULL;
    LPSTR           pszFileA = NULL,
            pszClassA = NULL,
            pszItemA = NULL,
            pszObjectLink;
    DWORD           cbszFileA = 0,
            cbszClassA = 0,
            cbszItemA = 0;
    LARGE_INTEGER   li;
    FORMATETC       formatetc;


    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN GetObjectLink ( %p , %p )\n", NULL,
        pDataObj, pmedium));

    Assert(pmedium->tymed == TYMED_HGLOBAL);

    // fetch LinkSource data

    INIT_FORETC(formatetc);
    formatetc.cfFormat = g_cfLinkSource;
    formatetc.tymed = TYMED_ISTREAM;

    hresult = GetDataFromStream(pDataObj, &formatetc, NULL, &pstm);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    // reset the stream seek pointer to the beginning

    LISet32(li, 0);
    hresult = pstm->Seek(li, STREAM_SEEK_SET, NULL);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    // load the moniker from the stream, so we can parse out
    // it's underlying file and item name

    hresult = OleLoadFromStream(pstm, IID_IMoniker, (LPLPVOID)&pmk);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    hresult = Ole10_ParseMoniker(pmk, &pszFile, &pszItem);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    // now fetch the class ID so we can construct the ClassName

    hresult = ReadClassStm(pstm, &clsid);

    if( hresult != NOERROR )
    {
        // it is possible that the stream does not contain
        // the clsid of the link source.  In this case, we should
        // fetch it from the LinkSourceDescriptor

        hresult = GetDataFromDescriptor(pDataObj, &clsid,
                g_cfLinkSrcDescriptor,
                USE_NORMAL_CLSID, NULL, NULL);

        if( hresult != NOERROR )
        {
            goto errRtn;
        }
    }

    hresult = ProgIDFromCLSID(clsid, &pszClass);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    // by this point, we should have all of our strings.  Convert
    // them to ANSI and stuff them in an hglobal.


    hresult = UtPutUNICODEData(_xstrlen(pszClass)+1, pszClass, &pszClassA,
            NULL, &cbszClassA);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }
    else if( pszClassA == NULL )
    {
        hresult = ResultFromScode(E_FAIL);
        goto errRtn;
    }

    hresult = UtPutUNICODEData(_xstrlen(pszFile)+1, pszFile, &pszFileA,
            NULL, &cbszFileA);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    // we are allowed to have a NULL item name

    if( pszItem )
    {
        hresult = UtPutUNICODEData(_xstrlen(pszItem)+1, pszItem,
                &pszItemA, NULL, &cbszItemA);

        if( hresult != NOERROR )
        {
            goto errRtn;
        }
    }

    // we allocate 2 extra bytes for terminating '\0''s. (if the
    // item name is NULL, we should be safe and terminate it with a
    // zero as well, so we'll end up with 3 \0's at the end.
    pmedium->hGlobal = GlobalAlloc((GMEM_MOVEABLE | GMEM_SHARE ),
                cbszClassA + cbszFileA + cbszItemA + 2);

    if( !pmedium->hGlobal )
    {
        hresult = ResultFromScode(E_OUTOFMEMORY);
        goto errRtn;
    }

    pszObjectLink = (LPSTR)GlobalLock(pmedium->hGlobal);

    if( !pszObjectLink )
    {
        hresult = ResultFromScode(E_OUTOFMEMORY);
        goto errRtn;
    }

    _xmemcpy(pszObjectLink, pszClassA, cbszClassA);
    pszObjectLink += cbszClassA;
    _xmemcpy(pszObjectLink, pszFileA, cbszFileA);
    pszObjectLink += cbszFileA;
    if( pszItemA )
    {
        _xmemcpy(pszObjectLink, pszItemA, cbszItemA);
        pszObjectLink += cbszItemA;
    }
    else
    {
        *pszObjectLink = '\0';
        pszObjectLink++;
    }

    *pszObjectLink = '\0';

    GlobalUnlock(pmedium->hGlobal);

errRtn:
    if( pmk )
    {
        pmk->Release();
    }

    if( pszClass )
    {
        PubMemFree(pszClass);
    }

    if( pszFile )
    {
        PubMemFree(pszFile);
    }

    if( pszItem )
    {
        PubMemFree(pszItem);
    }

    if( pszClassA )
    {
        PubMemFree(pszClassA);
    }

    if( pszFileA )
    {
        PubMemFree(pszFileA);
    }

    if( pszItemA )
    {
        PubMemFree(pszItemA);
    }

    if( pstm )
    {
        pstm->Release();
    }

    if( hresult != NOERROR )
    {
        if( pmedium->hGlobal )
        {
            GlobalFree(pmedium->hGlobal);
            pmedium->hGlobal = NULL;
        }
    }

    LEDebugOut((DEB_ITRACE, "%p OUT GetObjectLink ( %lx ) [ %lx ]\n",
        NULL, hresult, pmedium->hGlobal));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Function:   GetOwnerLink
//
//  Synopsis:   Synthesizes OLE1 OwnerLink format from ObjectDescriptor data
//
//  Effects:
//
//  Arguments:  [pDataObj]      -- the source data object
//              [pmedium]       -- where to put the data
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  fetch the clsid and SrcOfCopy string from data offered
//              in cfObjectDescriptor.  Then turn the class ID into
//              the prog ID and then turn all strings into ANSI.  From
//              this, we can build the OwnerLink format data, which looks
//              like:
//                      szClass\0SrcOfCopy\0\0\0
//
//  History:    dd-mmm-yy Author    Comment
//              10-Jun-94 alexgo    author
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT GetOwnerLink( IDataObject *pDataObj, STGMEDIUM *pmedium)
{
    HRESULT         hresult;
    LPOLESTR        pszSrcOfCopy = NULL,
            pszClass = NULL;
    LPSTR           pszSrcOfCopyA = NULL,
            pszClassA = NULL,
            pszOwnerLink;
    DWORD           cbszClassA = 0,
            cbszSrcOfCopyA;
    CLSID           clsid;


    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN GetOwnerLink ( %p , %p )\n", NULL,
        pDataObj, pmedium));

    hresult = GetDataFromDescriptor(pDataObj, &clsid,
            g_cfObjectDescriptor, USE_STANDARD_LINK,
            &pszSrcOfCopy, NULL);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    // 16bit code called wProgIDFromCLSID, but in when
    // constructing ObjectLink, simply called ProgIDFromCLSID
    // directly.  The w version of the function special-cases
    // the prog-id string for a Link object (specifically, "OLE2Link")

    // we need to do it here to handle the case of copying an OLE2
    // link object to an ole1 container, and then copying the object
    // from the ole1 container back to an ole2 container.

    hresult = wProgIDFromCLSID(clsid, &pszClass);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    // now convert all our data to ANSI

    hresult = UtPutUNICODEData(_xstrlen(pszClass)+1, pszClass,
            &pszClassA, NULL, &cbszClassA);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    hresult = UtPutUNICODEData(_xstrlen(pszSrcOfCopy)+1, pszSrcOfCopy,
            &pszSrcOfCopyA, NULL, &cbszSrcOfCopyA);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    // now allocate an HGLOBAL for OwnerLink and stuff the
    // string data in there.  We alloc 2 extra bytes for
    // the terminating NULL characters.

    pmedium->hGlobal = GlobalAlloc((GMEM_MOVEABLE | GMEM_SHARE |
                GMEM_ZEROINIT),
                cbszClassA + cbszSrcOfCopyA + 2);

    if( !pmedium->hGlobal )
    {
        hresult = ResultFromScode(E_OUTOFMEMORY);
        goto errRtn;
    }

    pszOwnerLink = (LPSTR)GlobalLock(pmedium->hGlobal);

    if( !pszOwnerLink )
    {
        hresult = ResultFromScode(E_OUTOFMEMORY);
        goto errRtn;
    }

    _xmemcpy(pszOwnerLink, pszClassA, cbszClassA);
    pszOwnerLink += cbszClassA;
    _xmemcpy(pszOwnerLink, pszSrcOfCopyA, cbszSrcOfCopyA);
    pszOwnerLink += cbszSrcOfCopyA;

    *pszOwnerLink = '\0';
    pszOwnerLink++;
    *pszOwnerLink = '\0';

    GlobalUnlock(pmedium->hGlobal);

errRtn:

    if( pszClass )
    {
        PubMemFree(pszClass);
    }

    if( pszSrcOfCopy )
    {
        PubMemFree(pszSrcOfCopy);
    }


    if( pszClassA )
    {
        PubMemFree(pszClassA);
    }

    if( pszSrcOfCopyA )
    {
        PubMemFree(pszSrcOfCopyA);
    }

    if( hresult != NOERROR )
    {
        if( pmedium->hGlobal )
        {
            GlobalFree(pmedium->hGlobal);
            pmedium->hGlobal = NULL;
        }
    }

    LEDebugOut((DEB_ITRACE, "%p OUT GetOwnerLink ( %lx ) [ %lx ]\n",
        NULL, hresult, pmedium->hGlobal));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetPrivateClipboardWindow (internal)
//
//  Synopsis:   Finds the private ole-clipboard window associated with
//              the current appartment (creating one if necessary).
//
//  Effects:
//
//  Arguments:  [fFlags]        -- if CLIP_CREATEIFNOTTHERE, then a window
//                                 will be created if none already exists
//                                 if CLIP_QUERY, the current clipboard
//                                 window (if any) will be returned.
//
//  Requires:
//
//  Returns:    HWND (NULL on failure)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HWND GetPrivateClipboardWindow( CLIPWINDOWFLAGS fFlags )
{
    HWND    hClipWnd = 0;
    HRESULT hr;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN GetPrivateClipboardWindow ( %lx )\n",
        NULL, fFlags));

    COleTls tls(hr);
    if (SUCCEEDED(hr))
    {
	hClipWnd = tls->hwndClip;

	if( !hClipWnd && (fFlags & CLIP_CREATEIFNOTTHERE) )
	{
	    // NOTE: do not need to Stack Switch since the
	    //	the windows is in ole itself.

	    if (ClipboardInitialize())
	    {
		hClipWnd = ClpCreateWindowEx(NULL,vszClipboardWndClass, NULL,
		    WS_POPUP, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
		    CW_USEDEFAULT, 
#ifdef HWND_MESSAGE // HWND_MESSAGE is not yet defined on Chicago.
		    HWND_MESSAGE, 
#else
		    NULL,
#endif // HWND_MESSAGE
		    NULL, g_hmodOLE2, NULL);

		// if we can't create the window, print an error
		LEERROR(!hClipWnd, "Unable to create private clipboard win");

		// now set the hwnd into our thread-local storage
		tls->hwndClip = hClipWnd;
	    }
	}
    }
    LEDebugOut((DEB_ITRACE, "%p OUT GetPrivateClipboardWindow ( %lx )\n",
        NULL, hClipWnd));


    // hClipWnd should always be a valid window

#if DBG ==1
    if( hClipWnd )
    {
        Assert(IsWindow(hClipWnd));
    }
#endif // DBG == 1

    return hClipWnd;
}

//+-------------------------------------------------------------------------
//
//  Function:   HandleFromHandle
//
//  Synopsis:   Calls IDataObject->GetData for the given format and returns
//              the resulting handle (duplicated if necessary).
//
//  Effects:
//
//  Arguments:  [pDataObj]      -- the source data object
//              [pformatetc]    -- the formatetc
//              [pmedium]       -- the tymed to use for GetData and where
//                                 to return the data
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  if data object sets pUnkForRelease after the GetData call,
//              we'll duplicate the returned data.  Otherwise, we just pass
//              out the results of GetData
//
//  History:    dd-mmm-yy Author    Comment
//              11-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT HandleFromHandle(IDataObject *pDataObj, FORMATETC *pformatetc,
        STGMEDIUM *pmedium)
{
    HRESULT         hresult;
    STGMEDIUM       tempmedium;


    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN HandleFromHandle ( %p , %p , %p )\n",
        NULL, pDataObj, pformatetc, pmedium));

    _xmemset(&tempmedium, 0, sizeof(STGMEDIUM));

    hresult = pDataObj->GetData(pformatetc, &tempmedium);

    if( hresult == NOERROR )
    {
        if( tempmedium.pUnkForRelease )
        {
            pmedium->hGlobal = OleDuplicateData(
                tempmedium.hGlobal, pformatetc->cfFormat,
                GMEM_MOVEABLE | GMEM_DDESHARE );

            if( !pmedium->hGlobal )
            {
                hresult = ResultFromScode(E_OUTOFMEMORY);
                // fall through so we release the original
                // data
            }
            // now release the original data
            ReleaseStgMedium(&tempmedium);
        }
        else
        {
            pmedium->hGlobal = tempmedium.hGlobal;
        }
    }

    // we don't ever try a GetDataHere for handles

    LEDebugOut((DEB_ITRACE, "%p OUT HandleFromHandle ( %lx )\n",
        hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   MapCFToFormatetc
//
//  Synopsis:   Given a clipboard format, find the corresponding formatetc
//              in our private data
//
//  Effects:
//
//  Arguments:  [hClipWnd]      -- the hwnd of our private clipboard window
//              [cf]            -- the clipboard format in question
//              [pformatec]     -- the formatetc to fill in
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              12-Aug-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT MapCFToFormatetc( HWND hClipWnd, UINT cf, FORMATETC *pformatetc )
{
FORMATETCDATAARRAY *pFormatEtcDataArray;
HRESULT		hresult = S_FALSE;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN MapCFToFormatetc ( %x , %p )\n",
        NULL, cf, pformatetc));

    pFormatEtcDataArray = (FORMATETCDATAARRAY *) GetWindowLongPtr( hClipWnd, WL_ClipPrivateData );

    LEERROR(!pFormatEtcDataArray, "No private clipboard data!!");
    Assert(pFormatEtcDataArray);
    
    if( pFormatEtcDataArray )
    {
    DWORD dwNumFormats = pFormatEtcDataArray->_cFormats;
    FORMATETCDATA *pFormatEtcData = &(pFormatEtcDataArray->_FormatEtcData[0]);

        Assert(pFormatEtcDataArray->_dwSig == 0);

        while( dwNumFormats-- )
        {
            if(pFormatEtcData->_FormatEtc.cfFormat == cf)
            {

                *pformatetc = pFormatEtcData->_FormatEtc;
		if (pformatetc->ptd)
		{
		    pformatetc->ptd = (DVTARGETDEVICE *)
					((BYTE *) pFormatEtcDataArray + (ULONG_PTR) pformatetc->ptd );
		}

                hresult = S_OK;
                break;
            }

	    ++pFormatEtcData;
        }
    }

    if( S_FALSE == hresult )
    {
        // Win95 will ask to RenderFormats that it is synthesizing.
        // Under NT the only time this should fail is if the caller asked for one of 
        // our synthesized OLE 1.0 formats.
        AssertSz( (cf == g_cfObjectLink) || (cf == g_cfOwnerLink) || (cf == g_cfNative),"Unknown Format");

        INIT_FORETC(*pformatetc);
        pformatetc->cfFormat = (CLIPFORMAT) cf;
        pformatetc->tymed = TYMED_HGLOBAL;
    }

    LEDebugOut((DEB_ITRACE, "%p OUT MapCFToFormatec ( )\n", NULL ));

    return hresult;
}

//+-------------------------------------------------------------------------
//  Function:   OleFlushClipboard
//
//  Synopsis:   Removes the data object from the clipboard (as the app is
//              going away).  The formats it supports will be rendered on
//              the clipboard so that the data may still be 'pasted' by
//              other apps.
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:   the caller must be the owner of the clipboard
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  1. Make sure the caller is the clipboard window owner
//              2. flush format data onto the clipboard
//              3. remove the clipboard data object
//
//  History:    dd-mmm-yy Author    Comment
//              16-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDAPI OleFlushClipboard( void )
{
    OLETRACEIN((API_OleFlushClipboard, NOPARAM));

    HRESULT         hresult;
    HWND            hClipWnd;
    HANDLE          handle;
    FORMATETCDATAARRAY  *pFormatEtcDataArray;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN OleFlushClipboard ( )\n", NULL));


    if( (hClipWnd = VerifyCallerIsClipboardOwner()) == NULL)
    {
        //caller is not the clipboard owner, so return with an
        //error
        hresult = ResultFromScode(E_FAIL);
        goto errRtn;
    }

    //
    // BEGIN: OPENCLIPBOARD
    //

    // now open the clipboard so we can add and remove data

    hresult = OleOpenClipboard(hClipWnd, NULL);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    // now go through all of the formats on the clipboard and render
    // each one.   Doing a GetClipboardData will force rendering for
    // any as yet unrendered formats

    // on error we have to live with clipboard not being flushed properly.

    pFormatEtcDataArray = (FORMATETCDATAARRAY *) GetWindowLongPtr( hClipWnd, WL_ClipPrivateData );

    if (pFormatEtcDataArray)
    {
        FORMATETCDATA *pCurFormat;
        FORMATETCDATA *pNextFreeLocation; // location to copy FormatEtc to if Rendered Data.
        DWORD dwNumFormats = pFormatEtcDataArray->_cFormats;
        DWORD dwFlushedFormats = 0;
        FORMATETCDATAARRAY *pClipFormatEtcDataArray;
        HANDLE	    hglobal;
        BOOL fPersistDataObjOnFlush;
        
        fPersistDataObjOnFlush =  (pFormatEtcDataArray->_dwMiscArrayFlags 
                                   & FETC_PERSIST_DATAOBJ_ON_FLUSH);
            
    	pNextFreeLocation = pCurFormat = &(pFormatEtcDataArray->_FormatEtcData[0]);

    	// loop through enumerator updating it as we go.
    	// warning: RenderFormat will be using the Same structure so it must always be
    	// valid when GetClipboardData is Called.

        if (!fPersistDataObjOnFlush)
        {
            // this is the normal path most calls will take 
            
            while( dwNumFormats-- )
            {		
                if (TRUE == pCurFormat->fSaveOnFlush)
                {
                    // we ignore the return of GetClipboardData.  Even if
                    // fails, we ought to flush as many as we can and then
                    // remove our data object.

                    *pNextFreeLocation = *pCurFormat;
                    ++pNextFreeLocation;
                    ++dwFlushedFormats;

                    handle = SSGetClipboardData(pCurFormat->_FormatEtc.cfFormat);

                    LEWARN( !handle, "GetClipboardData failed!");
                }
                ++pCurFormat;
                
       	    } // while

            // We will not offer these if PersistDataObjOnFlush is requested.
            
            if (pFormatEtcDataArray->_dwMiscArrayFlags & FETC_OFFER_OLE1) 
            {
                handle = SSGetClipboardData(g_cfNative);
                LEWARN( !handle, "GetClipboardData failed for cfNative!");
                handle = SSGetClipboardData(g_cfOwnerLink);
                LEWARN( !handle, "GetClipboardData failed for cfOwnerLink!");
            }
            
            if (pFormatEtcDataArray->_dwMiscArrayFlags & FETC_OFFER_OBJLINK)
            {
                handle = SSGetClipboardData(g_cfObjectLink);
                LEWARN( !handle, "GetClipboardData failed!");
            }
        }
        else
        {   
            // This is the special path if the provider requested that we
            // persist the data Object at OleFlushCB time, instead of 
            // flushing individual formats.
            while( dwNumFormats-- )
            {		
                if (pCurFormat->_FormatEtc.cfFormat 
                        == g_cfOleClipboardPersistOnFlush)
                {
                    // We will flush on this single format if the app requested
                    // PersistDataObjOnFlush functionality. The idea being that 
                    // since the app is requesting this functionality it is
                    // indicating that after OleFlushClipboard a paste will 
                    // will require the real object to be re-hydrated.

                    // Since that is the case, there is not much point flushing 
                    // other formats as the real object should be around  
                    // at Paste time to provide data for all other formats 
                    // directly.

                    *pNextFreeLocation = *pCurFormat;
                    ++pNextFreeLocation;
                    ++dwFlushedFormats;

                    handle = SSGetClipboardData(pCurFormat->_FormatEtc.cfFormat);
                    LEWARN( !handle, "GetClipboardData failed!");
                    
                    break;  // we are done
                }
                ++pCurFormat;
            } // while

            // Now do our SaveToStream magic if the clipboard data object 
            // owner requested for it.

            HANDLE	    hglobal;
            // Get the IDataObject pointer from the clipboard
            IDataObject *lpDataObj = (IDataObject *) GetProp(hClipWnd, 
                                                CLIPBOARD_DATA_OBJECT_PROP);
            Assert(lpDataObj);

            hglobal = PersistDataObjectToHGlobal(lpDataObj);

            LEWARN(!hglobal, "Could not persist data object!");
            // We cannot do much if this fails. We will just not be able
            // to rehydrate the DataObject when someone calls OleGetClipboard

            if (hglobal)
            {
                if (SSSetClipboardData(g_cfMoreOlePrivateData, hglobal))
                {
                    hglobal = NULL; //Clipboard takes ownership
                }
                else
                {
                    LEWARN(FALSE, 
                            "SetClipboardData failed for cfMoreOlePrivateData");
                    GlobalFree(hglobal);
                    hglobal = NULL;
                }
            }

            // Turn off the flags so they get copied correctly in g_cfOlePrivateData.
            pFormatEtcDataArray->_dwMiscArrayFlags &= ~FETC_OFFER_OLE1;
            pFormatEtcDataArray->_dwMiscArrayFlags &= ~FETC_OFFER_OBJLINK;
            
        } // if fPersistDataObjOnFlush

        // upate the number of Formats.
    	pFormatEtcDataArray->_cFormats = dwFlushedFormats; 
    	
    	// Data has been rendered and Enumerator Data has been updated..
    	// update the enumerator on the clipboard. This is necessary even if
    	// it doesn't change to update the Sequence Number.

        // REVIEW: Should we keep the enumerator around at all
        // in PersistDataObjOnFlush case?

        if ( hglobal = GlobalAlloc((GMEM_MOVEABLE|GMEM_DDESHARE),
                          pFormatEtcDataArray->_dwSize) )
        {
            if(pClipFormatEtcDataArray = (FORMATETCDATAARRAY *) GlobalLock(
                                      hglobal))
            {
                _xmemcpy (pClipFormatEtcDataArray,
                    pFormatEtcDataArray,
                    pFormatEtcDataArray->_dwSize);
                
                GlobalUnlock(hglobal);

                if(SSSetClipboardData(g_cfOlePrivateData, hglobal))
                {
                    hglobal = NULL; // on success clipboard takes ownsership
                }
            }

            if (hglobal)
            {
                GlobalFree(hglobal);
            }
        }
   } //if pFormatEtcDataArray

   // Note: pFormatEtcDataArray is PrivMemFree-d in RemoveClipboardDataObject

    // now get rid of the data object on the clipboard && local
    // clipboard window

    hresult = RemoveClipboardDataObject(hClipWnd,
                    CLIPWND_REMOVEFROMCLIPBOARD);

    // now close the clipboard
    if( !SSCloseClipboard() )
    {
        LEDebugOut((DEB_WARN, "WARNING: Can't close clipboard!\n"));
        // if hresult != NOERROR, then RemoveClipboardDataObject
        // failed--as it would be the first failure, we do not want
        // to mask that error code with CLIPBRD_E_CANT_CLOSE.
        if( hresult == NOERROR )
        {
            hresult = ResultFromScode(CLIPBRD_E_CANT_CLOSE);
        }
    }

    //
    // END: CLOSECLIPBOARD
    //

errRtn:
    LEDebugOut((DEB_TRACE, "%p OUT OleFlushClipboard ( %lx )\n", NULL,
        hresult));

    OLETRACEOUT((API_OleFlushClipboard, hresult));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleGetClipboard
//
//  Synopsis:   Retrieves an IDataObject * from the clipboard.
//
//  Effects:
//
//  Arguments:  [ppDataObj]     -- where to put the data object pointer
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//              Excepting a hack for 16bit, we open the clipboard and
//              prefetch any private clipboard formats we may have
//              put there (currently g_cfDataObject and g_cfOlePrivateData).
//
//              We then always create a fake data object to return to the
//              caller.  The QueryInterface on this data object is tweaked
//              in such a way to preserve identity (see CClipDataObject::
//              QueryInterface).  This fake data object always tries to
//              satisfy requests (such as QueryGetData) locally by using
//              information stored internally (from g_cfOlePrivateData) or
//              by looking on the clipboard.  This has a significant
//              speed advantage.  If there is a real data object on the
//              clipboard, then we will fetch the interface only when
//              needed.  See clipdata.cpp for more details. 
//              NOTE: In the async support (persist on flush) case, we do 
//              not use this Fake data object. Read further below about
//              the persist on flush mechanism.
//
//              To retrieve the marshalled IDataObject pointer, we first
//              look for g_cfDataObject on the clipboard and retrieve the
//              hGlobal associated with that format.  The hGlobal contains
//              the window handle of the private clipboard window of the
//              process that called OleSetClipboard.  We use this window
//              handle to RPC over to the server process and get the
//              IDataObject data transfer object.  This is exactly the same
//              mechanism used by Drag'n'Drop.  As mentioned above, we do
//              this only when necessary as an optimization.
//
//              Async Clipboard (Persist on Flush) Mechanism:
//              ---------------------------------------------
//              We have added a capability for the clipboard data object to
//              re-hydrate itself when someone calls OleGetClipboard after 
//              OleFlushClipboard. The idea being that OleFlushClipboard forces
//              a data object to flush *all* its formats which may be expensive
//              to flush and also that lindex etc are not honored during 
//              flushing. So some data object providers find that inefficient.
//
//              To get the async capability, a data object must offer data on 
//              a format called "OleClipboardPersistOnFlush". This works 
//              as a flag telling OLE to use this async mechanism. Also, the 
//              DataObject *must* support IPersistStream for the magic to work.
//              
//              When OleSetClipboard is called, if we notice this special format
//              we set a flag during SetClipboardFormats. Then, during OleFlushCB
//              we flush only this single format. OLE does not care otherwise for 
//              what data is offered on this format. However, to keep things simple 
//              we will ask people to keep ptd=NULL, dwAspect=CONTENT, lindex=-1, 
//              and tymed=HGLOBAL. 
//              
//              More importantly, during OleFlushCB, we save the DataObject into
//              a stream, wrap it in an HGLOBAL and store it on the clipboard in 
//              a private format called "MoreOlePrivateData".
//              
//              When OleGetClipboard is called, the availability of this private 
//              format on the clipboard is a signal that we should recreate 
//              the DataObject from its persisted state and hand it to the caller, 
//              instead of using the standard way (of handing back an OLE wrapper).
//              Thus, once OleGetCB succeeds, the client is directly talking to 
//              the real DataObject and OLE is completely out of the way (except
//              that we keep the DataObject handed out in the TLS so that 
//              repeated OleGetCBs are fast).
//
//
//  History:    dd-mmm-yy Author    Comment
//              30-Jun-94 alexgo    added a hack for hosehead 16bit apps
//              16-May-94 alexgo    reduced the amount of work done between
//                                  Open and CloseClipboard
//              16-Mar-94 alexgo    author
//
//  Notes:      We must only hold the clipboard open for a small amount of
//              time because apps are calling OleGetClipboard to poll the
//              clipboard state during idle time.  If the clipboard is held
//              open for a long period of time, this leads to frequent
//              collisions between multiple apps running simultaneously.
//              In particular, we should not make any rpc's during the time
//              in which we hold the clipboard open.
//
//              If we are in WOW and the caller of OleGetClipboard is
//              the clipboard owner, then we will simply return the data
//              object straight from our private clipboard window.  We
//              need to do this because some 16bit apps (such as Project)
//              have broken reference counting.  See comments below in
//              the code.
//
//--------------------------------------------------------------------------

STDAPI OleGetClipboard( IDataObject **ppDataObj )
{
    OLETRACEIN((API_OleGetClipboard, PARAMFMT("ppDataObj= %p"), ppDataObj));
    LEDebugOut((DEB_TRACE, "%p _IN OleGetClipboard(%p)\n", NULL, ppDataObj));

    // Local variables
    HRESULT hresult = S_OK;
    HWND hClipWnd = NULL;        // clipboard owner
    HGLOBAL hOlePrivateData = NULL;

    // Validation checks
    VDATEHEAP();
    VDATEPTROUT_LABEL(ppDataObj, IDataObject *, errNoChkRtn, hresult);
    *ppDataObj = NULL;

    //
    // HACK ALERT!!!!
    //

    // 16bit Project has a cute reference counting scheme; if they
    // own the clipboard, they just call Release on the data object
    // they put on the clipboard instead of the data object we
    // return from OleGetClipboard (thanks guys).
    //
    // to work around this, if we are in wow and the caller owns
    // the clipboard, we simply AddRef the data object given to us
    // in OleSetClipboard and return it.
    //
    // We do NOT do this for 32bit OLE for several reasons:
    //      1. Even though the caller owns the clipboard, he
    //      does not necessarily control the data object given to
    //      OleSetClipboard (for example, he can get a data object
    //      from IOO::GetClipboardData).  Thus, it is important
    //      that we wrap the data object on the clipboard
    //      (see comments above in the algorithm section)
    //      2. Hopefully, the new algorithm makes it harder for
    //      apps to get away with doing bad stuff

    if( IsWOWThread() )
    {
        hClipWnd = VerifyCallerIsClipboardOwner();

        if( hClipWnd != NULL )
        {
            // the caller does own the clipboard, just
            // return the data object put there

            *ppDataObj = (IDataObject *)GetProp( hClipWnd,
                    CLIPBOARD_DATA_OBJECT_PROP);

            if( *ppDataObj )
            {
                (*ppDataObj)->AddRef();
                hresult = NOERROR;
                // leave the OleGetClipboard
            }


            // else FALL-THROUGH!!
            // This is the case where the clipboard has
            // been flushed but the calling app is still the
            // 'owner'.  We need to construct a fake data
            // object in this case.
        }
    } // end of 16-bit Hack.

    // see if there is a DataObject that has been handed out.
    if (NULL == *ppDataObj)
    {
        GetClipDataObjectFromTLS(ppDataObj);    	
        // *ppDataObj will be non-NULL if this succeeds.
        if (*ppDataObj)
        {
            hresult = NOERROR;
        }
    }


    // If still don't have a DataObject try to retrieve one from the Clipboard.
    if (NULL == *ppDataObj)
    {
        if (SSIsClipboardFormatAvailable(g_cfMoreOlePrivateData))
        {
            // This indicates that someone has called OleFlushClipboard and
            // requested the persistDataObjOnFlush option.
            hresult = CreateClipDataObjectFromPersistedData(ppDataObj);
        }
        else 
        {
            // This is the normal route that most calls will take!
            hresult = CreateWrapperClipDataObjectFromFormatsArray(ppDataObj);
        }
    }

#if DBG == 1
    // make the data object is non-NULL on success and NULL on failure
    if( hresult != NOERROR )
    {
        Assert(*ppDataObj == NULL);
    }
    else
    {
        Assert(*ppDataObj != NULL);
    }
#endif  // DBG == 1

    LEDebugOut((DEB_TRACE, "%p OUT OleGetClipboard ( %lx ) [ %p ]\n",
        NULL, hresult, *ppDataObj));

    // register the new IDataObject interface for HookOle
    CALLHOOKOBJECTCREATE(hresult,CLSID_NULL,IID_IDataObject,
                    (IUnknown **)ppDataObj);

errNoChkRtn:

    OLETRACEOUT((API_OleGetClipboard, hresult));
    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Function:   GetClipDataObjectFromTLS
//
//  Synopsis:   Get the cached dataObject pointer from TLS if fresh.
//
//  Arguments:  [ppDataObj] Out pointer for returning pDataObject    
//
//  Returns:    void (caller must use the out parameter).
//
//  Algorithm:  1. check if the dataObject we have in TLS is up to date.
//              2. if uptodate, AddRef it and return
//              3. if not, Release the TLS data object and clear the field.
//
//  History:    dd-mmm-yy   Author    Comment
//              02-May-99   MPrabhu   Created
//
//+-------------------------------------------------------------------------

void GetClipDataObjectFromTLS(IDataObject **ppDataObj)
{
    Assert(ppDataObj && *ppDataObj==NULL);
    HRESULT hresult;

    COleTls tls(hresult);

    if (SUCCEEDED(hresult))
    {   
        // attempt to get from TLS  
        if (tls->pDataObjClip)
        {
            // Is the dataObject up to date?
            if (GetClipboardSequenceNumber() == tls->dwClipSeqNum)
            {
                // It is up to date, AddRef it as appropriate.
                if (tls->fIsClipWrapper)
                {
                    // We handed out the wrapper. Weak AddRef.
                    ((CClipDataObject*)tls->pDataObjClip)->AddRef();	 // !!!!should not not not be strong increment.
                }
                else
                {
                    // We do a strong AddRef ... with the callers
                    // responsibility to call Release() corresponding
                    // to each successful call to OleGetClipboard.
                    (tls->pDataObjClip)->AddRef();
                }
                *ppDataObj = tls->pDataObjClip;
            }
            else
            {
                // Our cached data object is stale. Clear it.
                // !!this should be a strong release on the data object.
                if (tls->fIsClipWrapper)
                {                
                    ((CClipDataObject*)tls->pDataObjClip)->InternalRelease(); 
                }
                else
                {
                    (tls->pDataObjClip)->Release();
                }
                
                // Clear the tls dataObj as it is useless.
                tls->pDataObjClip = NULL;
                *ppDataObj = NULL;

                // Reset the fIsClipWrapper to the more common possibility
                // This is just to play it safe.
                tls->fIsClipWrapper = TRUE;
            }
        }
        else
        {
            // Don't have a data object in TLS
            *ppDataObj = NULL;
        }
    }
    else
    {
        // Tls contructor failed
        *ppDataObj = NULL;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   SetClipDataObjectInTLS
//
//  Synopsis:   Set the given DataObject in TLS.
//
//  Arguments:  [pDataObj]      DataObject pointer to set in TLS
//              [dwClipSeqNum]  Win32 ClipBrd Sequence Number corresponding 
//                              to this data object.
//                              
//              [fIsClipWrapper]Is this our wrapper dataObject?    
//
//  Returns:    void
//
//  Algorithm:  1. Set the fields in the TLS, AddRefing the dataObject
//              as appropriate.
//
//  History:    dd-mmm-yy   Author    Comment
//              02-May-99   MPrabhu   Created
//
//+-------------------------------------------------------------------------

void SetClipDataObjectInTLS(
            IDataObject *pDataObj, 
            DWORD dwClipSeqNum, 
            BOOL fIsClipWrapper)
{
    HRESULT hresult;

    COleTls tls(hresult);
    if (SUCCEEDED(hresult))
    {
        Assert(NULL == tls->pDataObjClip); 
        // We must do a Strong AddRef!
        if (fIsClipWrapper)
        {
            ((CClipDataObject *) pDataObj)->InternalAddRef();
        }
        else
        {
            pDataObj->AddRef(); 
        }
        tls->pDataObjClip = pDataObj;
        // We need to remember this so that we can do the right
        // thing later (call the correct AddRef, Release etc).
        tls->fIsClipWrapper = fIsClipWrapper;
        tls->dwClipSeqNum = dwClipSeqNum;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   CreateClipDataObjectFromPersistedData
//
//  Synopsis:   Creates the real DataObject from persisted data. This is used
//              during OleGetClipboard for the persist-on-flush case.
//
//  Arguments:  [ppDataObj]     Out pointer for returning the IDataObject*
//
//  Returns:    HRESULT
//
//  Algorithm:  1. Open clipboard and get a copy of the persisted data.
//              2. Load the DataObject from the persisted form.
//              3. Set in TLS if DataObject is loaded successfully.
//
//  History:    dd-mmm-yy   Author    Comment
//              02-May-99   MPrabhu   Created
//
//+-------------------------------------------------------------------------

HRESULT CreateClipDataObjectFromPersistedData(IDataObject **ppDataObj)
{
    HRESULT hresult;
    HGLOBAL hMoreOlePrivateData, hMoreOlePrivateDataCopy;
    DWORD dwClipSequenceNumber;
    
    // This format has to be on the clipboard if we are here.
    Assert(SSIsClipboardFormatAvailable(g_cfMoreOlePrivateData));

    // Get Sequence first in case Clipboard Changes while setting up DataObject.
    dwClipSequenceNumber = GetClipboardSequenceNumber();

    // The original data object provider called OleFlushClipboard
    // and requested the PersistDataObjOnFlush support

    // We have the data object persisted in a Stream on hGlobal
    // wrapped in our private format ("MoreOlePrivateData").

    // Open the clipboard in preparation  for the get
    
    //
    //  BEGIN: OPENCLIPBOARD
    //
    hresult = OleOpenClipboard(NULL, NULL);

    if (SUCCEEDED(hresult))
    {
        hMoreOlePrivateData = SSGetClipboardData(g_cfMoreOlePrivateData);
        AssertSz(hMoreOlePrivateData,
            "Could not get clipboard data for cfMoreOlePrivateData!");

        // We make a copy of the global private data to not keep
        // the clipboard locked for too long.
        hMoreOlePrivateDataCopy = UtDupGlobal(
                                    hMoreOlePrivateData,
                                    0 );   //GMEM_FIXED (GlobalAlloc flags)
                                   
#if DBG == 1
        BOOL fCloseClipSucceeded =
#endif // DBG

        SSCloseClipboard();

#if DBG == 1
        // We only report this error in debug
        if (!fCloseClipSucceeded)
        {
            LEDebugOut((DEB_ERROR, "ERROR: CloseClipboard failed!\n"));
        }
#endif // DBG

        //
        //  END: CLOSECLIPBOARD
        //


        // Try to revive the DataObject from the serialized stream
        if (hMoreOlePrivateDataCopy)
        {
            hresult = LoadPersistedDataObjectFromHGlobal(
                            hMoreOlePrivateDataCopy,
                            ppDataObj) ;

            AssertSz(SUCCEEDED(hresult), 
                "Failed to load DataObj from MoreOlePrivateData!"); 
        }
        else 
        {
            hresult = E_OUTOFMEMORY;
            *ppDataObj = NULL;
        }

        if (SUCCEEDED(hresult))
        {
            // Hold on to the dataObject pointer so that subsequent 
            // OleGetClipboard calls are fast.
            SetClipDataObjectInTLS(
                    *ppDataObj, 
                    dwClipSequenceNumber, 
                    FALSE /*fIsWrapper*/ );
        }
    }
    else
    {
        // OpenClipboard failed.
        *ppDataObj = NULL;
        LEDebugOut((DEB_ERROR, "ERROR: OleOpenClipboard failed!\n"));
    }
    return hresult;        
}

//+-------------------------------------------------------------------------
//
//  Function:   CreateWrapperClipDataObjectFromFormatsArray
//
//  Synopsis:   Creates a fake wrapper data object based on the formatEtcArray
//              on the clipboard. 
//
//  Arguments:  [ppDataObj]     Out pointer for returning the IDataObject*
//
//  Returns:    HRESULT
//
//  Algorithm:  1. Open clipboard and get a copy of the format array data.
//              2. Create the wrapper data object (CClipDataObject).
//              3. Set in TLS if everything went well.
//              [See notes of OleGetClipboard for more details].
//
//  History:    dd-mmm-yy   Author    Comment
//              02-May-99   MPrabhu   Created from the original OleGetClipBrd
//              16-Sep-99   a-olegi   Fixed regression from NT4
//
//+-------------------------------------------------------------------------

HRESULT CreateWrapperClipDataObjectFromFormatsArray(IDataObject **ppDataObj)
{
    HRESULT hresult;
    DWORD	    dwClipSequenceNumber;
    FORMATETCDATAARRAY  *pFormatEtcDataArray = NULL;


    // Get Sequence first in case Clipboard Changes while setting up DataObject.
    dwClipSequenceNumber = GetClipboardSequenceNumber();

    //
    // BEGIN: OPENCLIPBOARD
    //
    hresult = OleOpenClipboard(NULL, NULL);

    if(SUCCEEDED(hresult))
    {
        // Try to fetch the formatetc data.  Note that we may
        // not need to use this data if we can successfully rpc
        // over to the clipboard data source process to get the original
        // data object.

        // again, we don't worry about capturing errors here; if something
        // fails, then prgFormats will remain NULL

        if( SSIsClipboardFormatAvailable(g_cfOlePrivateData) )
        {
    	    HGLOBAL		        hOlePrivateData;
    	    FORMATETCDATAARRAY  *pClipFormats;

            hOlePrivateData = SSGetClipboardData(g_cfOlePrivateData);

            if( hOlePrivateData)
            {
                // hOlePrivateData is an hglobal with a
                // zero terminated array of formatetcs in it.
                //
                // we count them up and copy into an
                // *allocated* peice of memory, which may get passed
                // to our fake clipboard data object.

                pClipFormats = (FORMATETCDATAARRAY *)GlobalLock(hOlePrivateData);

                // jsimmons - windows bug 357734.  This code previously assumed
                // that GlobalLock could never fail.  Well, we have user dumps
                // to prove otherwise.  The cause of the failure is unknown.  
                Win4Assert((pClipFormats != NULL) && "GlobalLock failed!");
				
                if (!pClipFormats)
                {
                    hresult = HRESULT_FROM_WIN32(GetLastError());
                }
                else if( (pClipFormats->_dwSig == 0) && (pClipFormats->_dwSize > 0) )
                {

                    // mfeingol - Windows bug 124621
                    //
                    // This is needed for 32/64 interop
                    // We could be receiving a FORMATETCDATAARRAY from
                    // a 32 or a 64 bit process here, and because FORMATETC
                    // structures contain a pointer field, the blobs we get from
                    // the clipboard look different depending on their origin.
                    //
                    // This code could still run into trouble if we have some kind
                    // of network clipboard operating here, but for local machine
                    // operations and 32/64 bit interop, we should be okay
                    
                    size_t stSize;
                    GetCopiedFormatEtcDataArraySize (pClipFormats, &stSize);
                
                    // Signature must be zero and _cFormats > 0 
                    pFormatEtcDataArray = (FORMATETCDATAARRAY *)PrivMemAlloc(
                                                        stSize);

                    // Oleg Ivanov (a-olegi)  9/16  NTBUG #382054
                    //
                    // Fixed regression from NT4. We must not blindly copy data
                    // from OlePrivateData. Rather, we will be conservative
                    // and check if each format is available. This fixes issues
                    // with major applications like Lotus 1-2-3 on Windows 2000.

                    if( pFormatEtcDataArray )
                    {
                        // Properly translate the clipboard's FORMATETCDATAARRAY into
                        // something we understand
                        CopyFormatEtcDataArray (pFormatEtcDataArray, pClipFormats, stSize, TRUE);
                        Assert(pFormatEtcDataArray->_cRefs == 1); 
                    }
                    else
                    {
                        hresult = E_OUTOFMEMORY;
                    }                    
                    GlobalUnlock(hOlePrivateData);
                }
            } //if (hOlePrivateData)

        } //if g_cfOlePrivateData is available 

        if( !SSCloseClipboard() )
        {
            LEDebugOut((DEB_ERROR, "ERROR: CloseClipboard failed!\n"));
            ; // no-op to keep the compiler happy.
        }

        //
        // END: CLOSECLIPBOARD
        //
        
        if (SUCCEEDED(hresult))
        {
            // Create our own clipboard data object. We will return
            // this wrapper data object to the caller
            // ownership of pFormatEtcDataArray is taken over by the ClipData.
            hresult = CClipDataObject::Create(  
                            ppDataObj,      
                            pFormatEtcDataArray);
        }

        // if the Create call succeeds, the fake data object
        // will take ownership of the formatetc array.  If it
        // failed, we should free it.

        if (SUCCEEDED(hresult))
        {
            // Remeber DataObject handed out so can use it again.
            SetClipDataObjectInTLS(
                    *ppDataObj, 
                    dwClipSequenceNumber, 
                    TRUE /*fIsWrapper*/);
        }
        else
        {
            if(pFormatEtcDataArray )
            {
                PrivMemFree(pFormatEtcDataArray);
            }
        }
    }
    else
    {
        // OpenClipboard failed.
        *ppDataObj = NULL;
        LEDebugOut((DEB_ERROR, "ERROR: OleOpenClipboard failed!\n"));
    }
    return hresult;
}
    
//+-------------------------------------------------------------------------
//
//  Function:   OleIsCurrentClipboard
//
//  Synopsis:   returns NOERROR if the given data object is still on the
//              clipboard, false otherwise.
//
//  Effects:
//
//  Arguments:  [pDataObj]      -- the data object to check against
//
//  Requires:   g_cfDataObject must be registered
//
//  Returns:    S_OK, S_FALSE
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  1. Verify caller is the clipboard owner
//              2. Compare the data object pointer on our private clipboard
//              window against the data object pointer given by the caller
//
//  History:    dd-mmm-yy Author    Comment
//              12-Aug-94 alexgo    optimized
//              16-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDAPI OleIsCurrentClipboard( IDataObject *pDataObj )
{
    OLETRACEIN((API_OleIsCurrentClipboard, PARAMFMT("pDataObj= %p"), pDataObj));

    HRESULT         hresult = ResultFromScode(S_FALSE);
    HWND            hClipWnd;
    IDataObject *   pClipDataObject = NULL;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN OleIsCurrentClipboard ( %p )\n",
        NULL, pDataObj));

    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IDataObject,(IUnknown **)&pDataObj);

    if( pDataObj == NULL )
    {
        Assert(hresult == ResultFromScode(S_FALSE));
        goto errRtn;
    }

    // the caller must be the current clipboard owner

    if( (hClipWnd = VerifyCallerIsClipboardOwner()) == NULL )
    {
        LEDebugOut((DEB_WARN,
            "WARNING: Caller not clipboard owner\n"));
        Assert(hresult == ResultFromScode(S_FALSE));
        goto errRtn;
    }


    // In order for the data object to *really* be on the clipboard,
    // the g_cfDataObject must have the HWND of the private clipboard
    // window (even if we still have the DataObject pointer stuck
    // on the private clipboard window)

    // HOWEVER, the data on the clipboard may change at any point
    // in time that we don't hold it open.  In order to check this data,
    // we'd have to open the clipboard (a shared resource).  Since
    // we don't get any useful information from this check, we don't
    // bother doing it.


    // now get the pointer property from the window

    pClipDataObject = (IDataObject *)GetProp(hClipWnd,
                    CLIPBOARD_DATA_OBJECT_PROP);

    // since we are in the same process, we can directly compare
    // these pointers.
    if( pClipDataObject == pDataObj)
    {
        hresult = NOERROR;
    }
    else
    {
        hresult = ResultFromScode(S_FALSE);
    }

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT OleIsCurrentClipboard ( %lx )\n",
        NULL, hresult));

    OLETRACEOUT((API_OleIsCurrentClipboard, hresult));

    return hresult;

}

//+-------------------------------------------------------------------------
//
//  Function:   OleOpenClipboard (internal)
//
//  Synopsis:   Opens the clipboard
//
//  Effects:
//
//  Arguments:  [hClipWnd]      -- open the clipboard with this window
//                                 may be NULL.
//              [phClipWnd]     -- where to put the clipboard owner
//                                 may be NULL
//
//  Requires:
//
//  Returns:    NOERROR: the clipboard was opened successfully
//              CLIPBRD_E_CANT_OPEN: could not open the clipboard
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  If we can't open the clipboard, we sleep for a bit and then
//              try again (in case we collided with another app).  This
//              algorithm may need to be improved.
//
//  History:    dd-mmm-yy Author    Comment
//              17-May-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT OleOpenClipboard( HWND hClipWnd, HWND *phClipWnd )
{
    HRESULT         hresult = NOERROR;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN OleOpenClipboard ( %p )\n", NULL,
        phClipWnd ));

    if( hClipWnd == NULL )
    {
        // go ahead and create a clipboard window if we don't already
        // have one
        hClipWnd = GetPrivateClipboardWindow(CLIP_CREATEIFNOTTHERE);
    }

    if( !hClipWnd )
    {
        hresult = ResultFromScode(E_FAIL);
    }
    else if( !SSOpenClipboard(hClipWnd) )
    {
        // OpenClipboard will fail if another window (i.e. another
        // process or thread) has it open

        // sleep for a bit and then try again

        LEDebugOut((DEB_WARN, "WARNING: First try to open clipboard "
            "failed!, sleeping 1 second\n"));

        Sleep(0);       // give up our time quanta and allow somebody
                // else to get scheduled in.

        if( !SSOpenClipboard(hClipWnd) )
        {
            LEDebugOut((DEB_WARN,
                "WARNING: Unable to open clipboard on "
                "second try\n"));
            hresult = ResultFromScode(CLIPBRD_E_CANT_OPEN);
        }
    }

    if( phClipWnd )
    {
        *phClipWnd = hClipWnd;
    }

    LEDebugOut((DEB_ITRACE, "%p OUT OleOpenClipboard ( %lx ) "
        "[ %p ]\n", NULL, hresult, (phClipWnd)? *phClipWnd : 0));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleSetClipboard
//
//  Synopsis:   puts the given IDataObject on the clipboard
//
//  Effects:
//
//  Arguments:  [pDataObj]      -- the data object to put on the clipboard
//                                 if NULL, the clipboard is cleared
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  1. clear the clipboard of any data object and other data
//              that may be there.
//              2. Set [pDataOjbect] as the new clipboard data object
//              3. Set any downlevel formats on the clipboard for delayed
//              rendering.
//
//  History:    dd-mmm-yy Author    Comment
//              25-Nov-96 gopalk    Fail the call if OleInitialize has not
//                                  been called
//              11-Apr-94 alexgo    added support for downlevel formats
//              24-Mar-94 alexgo    allow NULL for pDataObject
//              16-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDAPI OleSetClipboard( IDataObject *pDataObject )
{
    OLETRACEIN((API_OleSetClipboard, PARAMFMT("pDataObject= %p"), pDataObject));
    LEDebugOut((DEB_TRACE, "%p _IN OleSetClipboard(%p)\n", NULL, pDataObject));

    // Local variables
    HRESULT         hresult = NOERROR;
    HWND            hClipWnd;

    // Validation checks
    VDATEHEAP();
    if(!IsOleInitialized()) {
        hresult = CO_E_NOTINITIALIZED;
        goto logRtn;
    }

    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IDataObject,(IUnknown **)&pDataObject);

    //
    //
    // BEGIN: OPENCLIPBOARD
    //
    //

    hresult = OleOpenClipboard(NULL, &hClipWnd);

    if( hresult != NOERROR )
    {
        goto logRtn;
    }

    // now clear the data and take ownership of the clipboard with
    // an EmptyClipboard call.  Note that EmptyClipboard will call
    // back to our private clipboard window proc (ClipboardWndProc)
    // with a WM_DESTROYCLIPBOARD message.  ClipboardWndProc will
    // remove any existing data objects (and do the IDO->Release).

    if( !SSEmptyClipboard() )
    {
        LEDebugOut((DEB_WARN, "WARNING: Unable to empty clipboard\n"));
	hresult = ResultFromScode(CLIPBRD_E_CANT_EMPTY);
        goto errRtn;
    }

    // NULL is a legal value for pDataObject.  Basically, it says
    // "clear the clipboard" (which was done above in the EmptyClipboard
    // call).

    if( pDataObject )
    {
        // now we set the data object onto the clipboard

        hresult = SetClipboardDataObject(hClipWnd, pDataObject);
    
        if( hresult == NOERROR )
        {
            // now set all of our downlevel formats on the
            // clipboard

             hresult = SetClipboardFormats(hClipWnd, pDataObject);
        }
    }

errRtn:
    // now close the clipboard.

    if( !SSCloseClipboard() )
    {
        LEDebugOut((DEB_WARN, "WARNING: Unable to close clipboard\n"));

        // don't overwrite an earlier error code!
        if( hresult == NOERROR )
        {
            hresult = ResultFromScode(CLIPBRD_E_CANT_CLOSE);
        }
    }

    //
    //
    // END: CLOSECLIPBOARD
    //
    //

logRtn:

    LEDebugOut((DEB_TRACE, "%p OUT OleSetClipboard ( %p ) \n", NULL,
        hresult));

    OLETRACEOUT((API_OleSetClipboard, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   PersistDataObjectToHGlobal (internal)
//
//  Synopsis:   Saves the clibboard data object to a stream.
//
//  Arguments:  [lpDataObj]      -- IDataobject pointer to persist
//
//  Returns:    HGLOBAL
//
//  Algorithm:  1. Ask DataObject to persist itself into a stream created
//              on an HGLOBAL and return the underlying HGLOBAL.
//
//  History:    dd-mmm-yy Author    Comment
//              03-Mar-99 mprabhu   author
//
//+-------------------------------------------------------------------------
HGLOBAL PersistDataObjectToHGlobal( IDataObject *pDataObj )
{
    HRESULT         hr = NOERROR;
    HGLOBAL         hglobal = NULL;
    IPersistStream *lpPS = NULL;
    IStream        *lpStm;

    hr = pDataObj->QueryInterface(IID_IPersistStream, (void **)&lpPS);
    // We are in this function only because IDataObject owner promised to
    // support this mechanism.
    AssertSz(SUCCEEDED(hr), 
            "DataObject promised to but does not support IPersistStream");
    
    hr = CreateStreamOnHGlobal( 
                NULL,     // allocate hGlobal
                FALSE,    // do not delete on Release() since
                &lpStm ); // the Win32 Clipboard will take ownership of hGlobal

                   

    if (SUCCEEDED(hr)) 
    {
        // Request the data object to save itself to the stream.
        hr = OleSaveToStream(lpPS, lpStm);
        if (SUCCEEDED(hr))
        {
            // Get the hGlobal under the stream
            // (This gets handed over to the Win32 Clipboard)
            hr = GetHGlobalFromStream(lpStm, &hglobal);
            Assert(SUCCEEDED(hr));
        }
    }
    if (lpPS)
        lpPS->Release();

    return hglobal;
}

//+-------------------------------------------------------------------------
//
//  Function:   LoadPersistedDataObjectFromHGlobal (internal)
//
//  Synopsis:   Loads the clibboard data object from an HGLOBAL
//
//  Arguments:  [hMorePrivateData] -- [in]  a copy of hMoreOlePrivateData
//              [ppDataObj]        -- [out] loaded IDataObect
//
//  Requires:   the clipboard must be open
//
//  Returns:    HRESULT
//
//  Algorithm:  1. Wrap the HGLOBAL in a stream and call OleLoadFromStream.
//
//  History:    dd-mmm-yy Author    Comment
//              03-Mar-99 mprabhu   author
//
//+-------------------------------------------------------------------------
HRESULT LoadPersistedDataObjectFromHGlobal( 
                HGLOBAL hMorePrivateData, 
                IDataObject **ppDataObj )
{
    HRESULT hr;
    IStream *lpStm;
    AssertSz(hMorePrivateData, "NULL private data handle!");
    
    hr = CreateStreamOnHGlobal(
             hMorePrivateData,   
             TRUE,      //delete on Release
             &lpStm);

    if (SUCCEEDED(hr))
    {
        hr = OleLoadFromStream(lpStm, IID_IDataObject, (void **)ppDataObj);
        lpStm->Release();
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   RemoveClipboardDataObject (internal)
//
//  Synopsis:   removes the g_cfDataObject format from the clipboard
//              along with the associated information on the private
//              clipboard window
//
//  Effects:    the DataObject pointer will be released.
//
//  Arguments:  [hClipWnd]      -- handle to the private clipboard window
//              [fFlags]        -- if CLIPWND_REMOVEFROMCLIPBOARD, then we
//                                 will remove g_cfDataObject from the clipboard
//
//  Requires:   the clipboard must be open
//              g_cfDataObject must be set
//
//  Returns:    HRESULT
//
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  we first remove the g_cfDataObject format from the clipboard
//              if fFlags == CLIPWND_REMOVEFROMCLIPBOARD (see comments
//              regarding this in Notes) and then remove the properties on our
//              local private clipboard window, and finally release the data
//              object pointer
//
//  History:    dd-mmm-yy Author    Comment
//              16-Mar-94 alexgo    author
//
//  Notes:      This function succeeds if there is no clipboard data object.
//
//              OleSetClipboard also calls this function to remove any data
//              object that may be present from a previous OleSetClipboard
//              call.  (Note that the call is indirect; OleSetClipboard will
//              call EmptyClipboard, which will get to our clipboard window
//              proc with a WM_DESTROYCLIPBOARD message).  OleFlushClipboard
//              will also call this function.
//
//              CLIPWND_REMOVEFROMCLIPBOARD (and CLIPWND_IGNORECLIPBOARD)
//              are used to handle the two different cases in which we
//              need to remove the clipboard data object:
//                      1. Somebody has called EmptyClipboard().  We will
//                      get a WM_DESTROYCLIPBOARD message in our private
//                      clipboard window proc.  If we have an AddRef'ed
//                      pointer on the clipboard (well, really on our
//                      private clipboard window), it is imperative that
//                      we do the corresponding Release.  However, since
//                      we are doing this as a result of EmptyClipboard,
//                      there is no need to futz with data on the clipboard
//                      (as it's all being deleted anyway).
//
//                      2. We are in an OleFlushClipboard call.  Here we
//                      *want* the rest of the clipboard to remain (except
//                      for our data object pointer), so we just need to
//                      disable the g_cfDataObject information.
//                      this is currently implemented by
//                      EmptyClipboard, which will change once the data object
//                      is implemented.
//
//--------------------------------------------------------------------------

HRESULT RemoveClipboardDataObject( HWND hClipWnd, DWORD fFlags )
{
    HRESULT         hresult = NOERROR;
    IDataObject *   pDataObj;
    FORMATETCDATAARRAY * pFormatEtcDataArray = NULL;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN RemoveClipboardDataObject ( %lx , "
        "%lx )\n", NULL, hClipWnd, fFlags ));

    Assert(g_cfDataObject);

    // get && remove the data object pointer.  We rely on
    // RemoveProp to correctly handle the race condition (somebody
    // else doing a GetProp simultaneously with our call).

    //
    // We must not delete the property since some 16-bit applications
    // rely on OleIsCurrentClipboard() during the IDataObject->Release().
    //
    pDataObj = (IDataObject *)GetProp(hClipWnd, CLIPBOARD_DATA_OBJECT_PROP);

    // now get && remove && free our private clipboard data
    pFormatEtcDataArray = (FORMATETCDATAARRAY *) SetWindowLongPtr( hClipWnd, 
                                                    WL_ClipPrivateData,     
                                                    (LONG_PTR) 0 );

    if( pFormatEtcDataArray )
    {
    	Assert(pFormatEtcDataArray->_cRefs == 1); // should be only person holding onto the FormatEtcDataArray.
        PrivMemFree(pFormatEtcDataArray);
    }

    // if there is no data object, then we may have already
    // removed it (from a previous call here).
    
    if( pDataObj )
    {
        DWORD dwAssignAptID;

        // pDataObj was AddRef'ed in SetClipboardDataObject
        if( !(fFlags & CLIPWND_DONTCALLAPP) )
        {
            pDataObj->Release();
        }


        // now get rid of our endpoint property.  If pDataObj is
        // NULL, then there is no need to do this (which is why the
        // call is in this if block!)

        hresult = UnAssignEndpointProperty(hClipWnd,&dwAssignAptID);

        //
        //  Now we can remove the property after the IDataObject->Release().
        //
        RemoveProp(hClipWnd, CLIPBOARD_DATA_OBJECT_PROP);
    }
    // else HRESULT == NOERROR from initialization

    if( (fFlags & CLIPWND_REMOVEFROMCLIPBOARD) &&
        SSIsClipboardFormatAvailable(g_cfDataObject) )
    {
        HGLOBAL         hMem;
        HWND *          phMem;

        // since we can't simply remove g_cfDataObject from the clipboard
        // (and keep all the other formats), we'll simply replace
        // the value (the HWND of our private clipboard window) with a
        // NULL.  Note that we only do this if g_cfDataObject really
        // exists on the clipboard (see the conditional test above)

    	 hMem = GlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE,
                sizeof(HWND));

        if( !hMem )
        {
            LEDebugOut((DEB_WARN, "WARNING: GlobalAlloc failed!!"
                "\n"));
            hresult = ResultFromScode(E_OUTOFMEMORY);
            // keep trying to remove the rest of our state
            goto errRtn;
        }

        phMem = (HWND *)GlobalLock(hMem);

        if( !phMem )
        {
            LEDebugOut((DEB_WARN, "WARNING: GlobalLock failed!!"
                "\n"));
            GlobalFree(hMem);
            hresult = ResultFromScode(E_OUTOFMEMORY);
            // keep trying to remove the rest of our state
            goto errRtn;
        }

        *phMem = NULL;

        GlobalUnlock(hMem);

        if( !SSSetClipboardData(g_cfDataObject, hMem) )
        {
            LEDebugOut((DEB_WARN, "WARNING: Can't RESET clipboard"
                " data with SetClipboardData\n"));
            GlobalFree(hMem);

            // FALL THROUGH!!  This is deliberate.  Even if
            // we can't NULL out the data on the clipboard, we
            // ought to at least try to remove the rpc endpoints
            // and so forth on our private clipboard window.
        }
    }

errRtn:

    LEDebugOut((DEB_ITRACE, "%p OUT RemoveClipboardDataObject ( %lx )\n",
        NULL, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   RenderFormat, private
//
//  Synopsis:   Grab the content data for the given clipboard format and
//              put it on the clipboard
//
//  Effects:
//
//  Arguments:  [hClipWnd]      -- the clipboard window
///             [pDataObj]      -- the data object from which to get the
//                                 data
//              [cf]            -- the clipboard format to put on the
//                                 clipboard
//
//  Requires:   the clipboard must be open for this function to work
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  if format ==
//              g_cfNative:
//                      copy either OLE10_NATIVE_STREAM (if available) into
//                      an hglobal or put the entire storage from EmbedSource
//                      or EmbeddedObject on top an hglobal
//              g_cfOwnerLink:
//                      synthesize from g_cfObjectDescriptor
//              g_cfObjectLink:
//                      synthesize from g_cfLinkSource if not offered
//                      directly by the app
//              all others:
//                      find the formatetc corresponding to the clipboard
//                      format and ask for data directly using that
//                      formatetc.  In the case of multiple TYMED's, we
//                      prefer TYMED_ISTORAGE, then TYMED_ISTREAM, then
//                      handle based mediums.  TYMED_FILE is not supported.
//
//  History:    dd-mmm-yy Author    Comment
//              30-Jan-97 rogerg    RenderFormat will not Render formats to the native
//                                  clipboard if not a format the Clipboard knows about
//                                  and it is not on an HGLOBAL.
//              11-Aug-94 alexgo    optimized; now use the object's original
//                                  formatetc for GetData calls.
//              10-Jun-94 alexgo    added OLE1 support
//              11-Apr-94 alexgo    author
//
//  Notes:      In the ideal world, we simply ask for TYMED_HGLOBAL and
//              DVASPECT_CONTENT and then stuff the resulting hglobal onto
//              the clipboard.  However, this would require apps honoring
//              the contractual obligations of an interface, which, of course,
//              doesn't happen.
//
//              The 16bit code effectively special cased certain formats,
//              notably cfEmbeddedOjbect, g_cfLinkSource, and g_cfEmbedSource.
//              The algorithm above implements behaviour similar to the
//              16bit sources.  Note that new apps can take advantage of
//              this functionality for app-defined formats and simplify
//              their data transfer IDataObject implementations.
//
//--------------------------------------------------------------------------

HRESULT RenderFormat( HWND hClipWnd, UINT cf, IDataObject *pDataObj )
{
HRESULT         hresult = E_FAIL;
STGMEDIUM       medium;
FORMATETC       formatetc;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN RenderFormat ( %u , %p )\n", NULL,
        cf, pDataObj));


    _xmemset(&medium, 0, sizeof(STGMEDIUM));
    medium.tymed = TYMED_HGLOBAL;

    if( cf == g_cfNative )
    {
        // OLE1 format: synthesize from OLE2 data
        hresult = GetNative(pDataObj, &medium);
    }
    else if( cf == g_cfOwnerLink )
    {
        // OLE1 format: synthesize from OLE2 data
        hresult = GetOwnerLink(pDataObj, &medium);
    }
    else if( cf == g_cfObjectLink )
    {
        // ObjectLink is a special OLE1 format.  The 16bit OLE
        // allowed apps to pass their own ObjectLink data, so
        // we preserve that behaviour here.  First check to see
        // if we can fetch it directly; if not, then we synthesize
        // it.
        
        Assert(NOERROR != hresult);

        if(S_OK == MapCFToFormatetc(hClipWnd, cf, &formatetc))
        {
	    hresult = HandleFromHandle(pDataObj, &formatetc, &medium);
        }

        if(NOERROR != hresult)
        {
            hresult = GetObjectLink(pDataObj, &medium);
        }
    }
    else if( cf == g_cfScreenPicture && IsWOWThread() )
    {
        //
        // HACK ALERT!!!
        //

        // this is a really evil hack.  XL 16bit puts a data format
        // "Screen Picture" on the clipboard (which is really nothing
        // more than a metafile).  However, since neither OLE nor
        // Windows knows anything about this metafile (it's just a
        // 4byte number to us), the metafile is invalid after XL shuts
        // down.
        //
        // The cute part is that Word 6 uses Screen Picture data
        // first (even if it' is invalid).  As a result, without
        // this hack, you can't paste any objects from XL into Word after
        // XL has shut down.
        //
        // The hack is to never allow "Screen Picture" data to ever be
        // realized onto the clipboard.  Word 6 then defaults to its
        // "normal" OLE2 processing.

        hresult = E_FAIL;
    }
    else
    {
        // find the original formatetc given to us by the data
        // object and use that to fetch the data

	Assert(NOERROR != hresult);
		
        if (S_OK == MapCFToFormatetc(hClipWnd, cf, &formatetc))
        {
	    // get the data according to the medium specified in formatetc
    
	    if( (formatetc.tymed & TYMED_ISTORAGE) )
	    {
	        hresult = GetDataFromStorage(pDataObj, &formatetc,
	                &medium, NULL);
	    }
	    else if( (formatetc.tymed & TYMED_ISTREAM) )
	    {
	        hresult = GetDataFromStream(pDataObj, &formatetc,
	                &medium, NULL);
	    }
	    else
	    {

            Assert(NOERROR != hresult);

	        // we don't support TYMED_FILE
	        formatetc.tymed &= ~(TYMED_FILE);
    
            // if the clipboard format is  cf > 0xC000 then make sure only TYMED_HGLOBAL
            // is rendered to the clibpoard. The native clipboard just puts the DWORD on the
            // clipboard regardless of the data. 
            // NT 5.0 Change in behavior: This will break an application if it put a DWORD with a TYMED other 
            //   than HGLOBAL and a native clipboard application tries to get it. .

            if (cf > 0xC000)
            {
                formatetc.tymed &= TYMED_HGLOBAL;
            }

	        // we don't need to do any more checking on the
	        // formatetc.  Even if we have a 'bogus' formatetc,
	        // it's what the app told us it could support.

            if (TYMED_NULL != formatetc.tymed) // Don't try to render TYMED_NULL
            {
	            hresult = HandleFromHandle(pDataObj, 
                            &formatetc,
	                        &medium);
            }
	    }
	}

    }

    // if hresult is NOERROR, then we have successfully retrieved
    // an HGLOBAL that can simply be stuffed onto the clipboard.

    if(NOERROR == hresult)
    {

	    Assert(NULL != medium.hGlobal);

        if( !SSSetClipboardData(cf, medium.hGlobal ) )
        {
            LEDebugOut((DEB_WARN, "WARNING: SetClipboardData "
                "failed!\n"));

            // Can Crash GlobalFree in Cases if pass in garbage. 
            __try
            {
                ReleaseStgMedium(&medium);
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
            }


            hresult = ResultFromScode(CLIPBRD_E_CANT_SET);
        }
    }

    LEDebugOut((DEB_ITRACE, "%p OUT RenderFormat ( %lx )\n", NULL,
        hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   SetClipboardDataObject (internal)
//
//  Synopsis:   Puts an IDataObject on the private clipboard window
//              and a handle to the clipboard window on the clipboard
//
//  Effects:    pDataObject will get AddRef'ed
//
//  Arguments:  [hClipWnd]      -- handle to the private clipboard window
//              [pDataObject]   -- the data object
//
//  Requires:   the clipboard must be open
//              g_cfDataObject must already be registered
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  We take the private clipboard window (passed as an
//              argument) and put the data object pointer on it
//              it as a private property.  We also attach an rpc endpoint
//              to this window as a public property and then put the
//              window handle on the clipboard.  OleGetClipboard will
//              retrieve this window handle, get the rpc endpoint, and
//              rpc over here (the set clipboard process) to get the
//              IDataObject pointer (marshalled, of course ;-)
//
//  History:    dd-mmm-yy Author    Comment
//              16-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT SetClipboardDataObject( HWND hClipWnd ,
        IDataObject *pDataObject )
{
HRESULT         hresult;
HWND *          phMem;
HANDLE          hMem;
DWORD dwAssignAptID;


    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN SetClipboardDataObject ( %lx ,%p )\n",
        NULL, hClipWnd, pDataObject ));

    AssertSz(pDataObject, "Invalid data object");
    Assert(g_cfDataObject);

    // try to assign an endpoint property to the window

    if( (hresult = AssignEndpointProperty(hClipWnd)) != NOERROR)
    {
        goto errRtn;
    }

    // put the data object pointer on the window

    if( !SetProp(hClipWnd, CLIPBOARD_DATA_OBJECT_PROP, pDataObject) )
    {

        // uh-oh, try to back out, but don't worry if we fail
        // from now on.
        LEDebugOut((DEB_WARN, "WARNING: Unable to SetProp for the "
            "data object pointer\n"));
        UnAssignEndpointProperty(hClipWnd,&dwAssignAptID);
        hresult = ResultFromScode(E_FAIL);
        goto errRtn;
    }

    // now allocate memory for the HWND of the private clipboard
    // window and put that on the clipboard

    hMem = GlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE, sizeof(HWND));

    if( !hMem )
    {
        LEDebugOut((DEB_WARN, "WARNING: GlobalAlloc failed!!\n"));
        hresult = ResultFromScode(E_OUTOFMEMORY);
        goto cleanup;
    }

    phMem = (HWND *)GlobalLock(hMem);

    if( !phMem )
    {
        LEDebugOut((DEB_WARN, "WARNING: GlobalLock failed!!\n"));
        hresult = ResultFromScode(E_OUTOFMEMORY);
        goto cleanup;
    }

    *phMem = hClipWnd;

    GlobalUnlock(hMem);

    if( !SSSetClipboardData( g_cfDataObject, hMem ) )
    {
        LEDebugOut((DEB_WARN, "WARNING: SetClipboardData for "
            "g_cfDataObject failed (%lx) !!\n", GetLastError()));
        hresult = ResultFromScode(CLIPBRD_E_CANT_SET);
        goto cleanup;
    }

    pDataObject->AddRef();

    hresult = NOERROR;

    goto errRtn;

cleanup:

    UnAssignEndpointProperty(hClipWnd,&dwAssignAptID);

    RemoveProp(hClipWnd, CLIPBOARD_DATA_OBJECT_PROP);
    if( hMem )
    {
        GlobalFree(hMem);
    }

errRtn:

    LEDebugOut((DEB_ITRACE, "%p OUT SetClipboardDataObject ( %lx )\n",
        NULL, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   SetClipboardFormats
//
//  Synopsis:   enumerates the formats available from the data object and
//              sets up the clipboard to delay-render those formats.
//
//  Effects:
//
//  Arguments:  [hClipWnd]      -- the clipboard window
//              [pDataObj]      -- the data object
//
//  Requires:   the clipboard must be open
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Simply enumerate all of the formats available on the object
//              and set each up for delayed rendereing (via
//              SetClipboardData(cf, NULL)).  We also keep track of the
//              "real" formatetc for each clipboard format that we'll render.
//              These formatetc's are placed in an array and put on the
//              clipboard as g_cfOlePrivateData.
//
//              See Notes below for more discussion on this.
//
//              OLE1 support:  In order to allow OLE1 containers to
//              paste OLE2 objects, we have to offer OLE1 formats in addition
//              to OLE2 data.  We'll offer OLE1 formats as follows:
//
//              g_cfNative:     if either EmbedSource or EmbeddedObject
//                              is available AND we can offer OwnerLink
//              g_cfOwnerLink:  if ObjectDescriptor is available AND
//                              we can offer Native
//              g_cfObjectLink: if LinkSource is available
//
//              We will offer the formats in in the order above.
//
//  History:    dd-mmm-yy Author    Comment
//		4/13/95	  rogerg    Bug#10731 Graph 5.0 does not Include
//				    its ObjectDescriptor in its enumerator
//              22-Feb-95 alexgo    restored broken 16bit behavior to
//                                  make Lotus Freelance work
//              11-Apr-94 alexgo    author
//
//  Notes:      For every clipboard format, we could do a QueryGetData
//              to see if RenderFormat would actually succeed.  However,
//              this relies on the QueryGetData from the app to be both
//              fast and accurate (definitely an unwarranted assumption).
//
//              Of course, by *not* doing a QueryGetData, we are assuming
//              that the formats enumerated by the data object are all
//              "legal" for clipboard transmission.
//
//              The "real" purpose of g_cfOlePrivateData is to allow us to
//              determine whether private clipboard formats where originally
//              IStorage based.  This is especially important for
//              OleFlushClipboard and copy/pasting mutiple objects.  Transfer
//              of multiple objects relies on private clipboard formats, which,
//              in some apps, are only available on IStorage.
//
//              These same apps rely on the Formatetc enumerator (or
//              QueryGetData) to tell them that the private format is available
//              on a storage (since it wasn't always in 16bit OLE).  Since we
//              *can* offer it to them on a storage (see clipdata.cpp), it
//              is important that we preserve the fact that the data originally
//              came from a storage.
//
//              Instead of always *testing* the data at enumerator or Query
//              time, we simply save the formatetc now (with [potentially]
//              modified fields such as ptd).
//
//              Also note that RenderFormat uses the information in
//              OlePrivateData when trying to render clipboard formats.
//
//--------------------------------------------------------------------------

HRESULT SetClipboardFormats( HWND hClipWnd, IDataObject *pDataObj )
{
    IEnumFORMATETC *        pIEnum;
    HRESULT                 hresult;
    FORMATETC               formatetc;
    HGLOBAL                 hglobal, hcopy;
    FORMATETCDATAARRAY*	    pFormatEtcDataArray;
    FORMATETCDATAARRAY*	  pFormatEtcDataArrayCopy;
    DWORD		        dwSize =0;
    FORMATETCDATA	    *pFormatEtcData;
    BYTE		    *pbDvTarget = NULL;
    DWORD		    cFormats = 0;
    BOOL                    fOfferNative = FALSE,
                            fOfferedNative = FALSE,
                            fOfferObjectLink = FALSE;
    CLSID                   clsid;
    DWORD                   dwStatus;
    BOOL                    fHaveObjectDescriptor=FALSE;

    // Flag to tell us if the data object owner wants us to use the 
    // special SaveToStream/LoadFromStream mechanish at OleFlushCB.
    BOOL                    fPersistDataObjOnFlush=FALSE; 

    VDATEHEAP();


    LEDebugOut((DEB_ITRACE, "%p _IN SetClipboardFormats ( %p )\n",
        NULL, pDataObj));



    // get the formatetc enumerator

    hresult = pDataObj->EnumFormatEtc(DATADIR_GET, &pIEnum);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    // count up the available formats

    pIEnum->Reset();    // Nt bug 284810
    
    while( (hresult = pIEnum->Next(1, &formatetc, NULL)) == NOERROR )
    {
	    // Bump the entry count
	    cFormats++;

	    // Bump the size by the size of another FormatEtcData.
	    dwSize += sizeof(FORMATETCDATA);

	    // Is there a device target associated with the FORMATETC?
	    if (formatetc.ptd != NULL)
	    {
	        // Bump the size required by the size of the target device
	        dwSize += formatetc.ptd->tdSize;
            
	        // Free the target device
	        CoTaskMemFree(formatetc.ptd);
	    }

        if (g_cfObjectDescriptor == formatetc.cfFormat)
            fHaveObjectDescriptor = TRUE;
    }


    // Bug#10731 - If no ObjectDescriptor in Enumertor increment cFormats in case we have to add it
    // when we add the EmbedSource
    if (!fHaveObjectDescriptor)
    {
        dwSize += sizeof(FORMATETCDATA);
    }

    dwSize += sizeof(FORMATETCDATAARRAY); // add space for _cFormats and one extra FORMATETC for FALSE in 

    // for our locally cached copy of the formats
    pFormatEtcDataArrayCopy = (FORMATETCDATAARRAY *) PrivMemAlloc(dwSize);

    if( pFormatEtcDataArrayCopy == NULL )
    {
        hresult = E_OUTOFMEMORY;
        goto errRtn;
    }

    // since some of these may be duplicated clipboard formats, we
    // are potentially allocating more memory than we need, but that's
    // OK.

    hglobal = GlobalAlloc((GMEM_MOVEABLE | GMEM_DDESHARE),dwSize);

    if (hglobal == NULL)
    {
        pIEnum->Release();
        hresult = ResultFromScode(E_OUTOFMEMORY);
        goto errRtn;
    }

    pFormatEtcDataArray = (FORMATETCDATAARRAY *)GlobalLock(hglobal);

    if( pFormatEtcDataArray == NULL )
    {
        GlobalFree(hglobal);
        pIEnum->Release();
        hresult = ResultFromScode(E_OUTOFMEMORY);
        goto errRtn;
    }

    _xmemset(pFormatEtcDataArray, 0, dwSize); 

    // This is the pointer to where we will copy the data from the
    // enumeration.
    pFormatEtcData = &pFormatEtcDataArray->_FormatEtcData[0];

    // put DvTarget past last valid FormatEtc + 1 to handle S_FALSE enumerator case.
    pbDvTarget = (BYTE *) (&pFormatEtcDataArray->_FormatEtcData[cFormats + 1]); 

    cFormats = 0;
    pIEnum->Reset();

    while( (hresult = pIEnum->Next(1, &(pFormatEtcData->_FormatEtc), NULL)) 
                ==  NOERROR )
    {
        // Excel5, 16bit, would offer data in it's enumerator
        // that you couldn't actually fetch.  Since this causes
        // Paste Special behaviour to be broken, we have to fix it
        // here.

        if( IsWOWThread() )
        {
            hresult = pDataObj->QueryGetData(&(pFormatEtcData->_FormatEtc));
            if( hresult != NOERROR )
            {
                // free the target device (if there is one)
                if( pFormatEtcData->_FormatEtc.ptd )
                {
                    LEDebugOut((DEB_WARN, "WARNING: Non-NULL ptd!\n"));
                    CoTaskMemFree(pFormatEtcData->_FormatEtc.ptd);
                }
                continue;
            }
        }
        
        // Update ptd if one exists. Even if fail later doesn't matter since just won't
        // have a FormatEtc that points to the ptd.
        if (pFormatEtcData->_FormatEtc.ptd != NULL)
        { 
            // Copy the device target data
    	    memcpy( pbDvTarget,
    	        pFormatEtcData->_FormatEtc.ptd,
    	        (pFormatEtcData->_FormatEtc.ptd)->tdSize );

     	    // Free the target device data
            CoTaskMemFree(pFormatEtcData->_FormatEtc.ptd);
 
            // NOTE: For this shared memory structure, we override the
            // FORMATETC field so that it is that offset to the DVTARGETDEVICE
            // from the beginning of the shared memory rather than a direct
            // pointer to the structure. This is because we can't guarantee
            // the base of shared memory in different processes.

            pFormatEtcData->_FormatEtc.ptd = (DVTARGETDEVICE *)
                (pbDvTarget - (BYTE *) pFormatEtcDataArray);

            // Bump pointer of where to copy target to next available
            // byte for copy.
            pbDvTarget += ((DVTARGETDEVICE *) pbDvTarget)->tdSize;
	    
    	    Assert(dwSize >= (DWORD) (pbDvTarget - (BYTE *) pFormatEtcDataArray));
        }

        // we first need to check to see if the clipboard format is a
        // user-defined GDI format.  We do not know how to duplicate
        // these, so we can't satisfy the GetData request.

        if( pFormatEtcData->_FormatEtc.cfFormat >= CF_GDIOBJFIRST &&
            pFormatEtcData->_FormatEtc.cfFormat <= CF_GDIOBJLAST )
        {
            LEDebugOut((DEB_WARN, "WARNING: caller attempted to "
                "use a special GDI format (%lx)\n",
                pFormatEtcData->_FormatEtc.cfFormat));

            // keep going though and get the rest of the clipboard formats
            continue;
        }

        // HACK ALERT!!!
        if( IsWOWThread() )
        {
            // Word6 offers CF_BITMAP on HGLOBAL in it's enumerator
            // but only succeeds the GetData call if TYMED_GDI is
            // specified.  So patch up the formatetc to reflect
            // something more accurate.
            if( (pFormatEtcData->_FormatEtc.cfFormat == CF_BITMAP ||
                pFormatEtcData->_FormatEtc.cfFormat == CF_PALETTE ) &&
                pFormatEtcData->_FormatEtc.tymed == TYMED_HGLOBAL )
            {
                pFormatEtcData->_FormatEtc.tymed = TYMED_GDI;
            }
        }

        // determine if we should offer any OLE1 formats etc...

        if( pFormatEtcData->_FormatEtc.cfFormat == g_cfEmbeddedObject ||
            pFormatEtcData->_FormatEtc.cfFormat == g_cfEmbedSource )
        {
            fOfferNative = TRUE;
        }
        else if( pFormatEtcData->_FormatEtc.cfFormat == g_cfLinkSource )
        {
            fOfferObjectLink = TRUE;
            // if the app offers ObjectLink itself, then we'll
            // consider a private clipboard format and set
            // it up for delayed rendering as any other format.
            // We'll check for this down below.
        }
        else if ( pFormatEtcData->_FormatEtc.cfFormat
                                            == g_cfOleClipboardPersistOnFlush )
        {
            if (!fPersistDataObjOnFlush)
            {
                Assert(pFormatEtcData->_FormatEtc.ptd == NULL);
                Assert(pFormatEtcData->_FormatEtc.dwAspect == DVASPECT_CONTENT);
                Assert(pFormatEtcData->_FormatEtc.lindex == -1);
                Assert(pFormatEtcData->_FormatEtc.tymed & TYMED_HGLOBAL);
                fPersistDataObjOnFlush = TRUE;
            }
            else
            {
                AssertSz(FALSE, 
                    "Multiple cfOleClipboardPersistOnFlush offered by object.");
                // We will use only the first instance.
            }
        }

    	// Bug#18669 - if dwAspect was set to NULL the 16 bit dlls would
    	// set it to content. 
    	if ( (NULL == pFormatEtcData->_FormatEtc.dwAspect) && IsWOWThread() )
    	{
    	    pFormatEtcData->_FormatEtc.dwAspect = DVASPECT_CONTENT;
    	    pFormatEtcData->_FormatEtc.lindex = -1; // CorelDraw also has a lindex of 0.
    	}

        // BUG 69893: Equation editor sets lindex to 0
        // Change it to -1
        if(pFormatEtcData->_FormatEtc.lindex == 0) {
            LEDebugOut((DEB_WARN, "WARNING: Changing lindex from 0 to -1\n"));
            pFormatEtcData->_FormatEtc.lindex = -1;
        }

    	// if going to add to clipboard increment enumerator, else
    	// current information will get overwritten.

        // if we haven't already setup this clipboard format, do so now.
        if(!SSIsClipboardFormatAvailable(pFormatEtcData->_FormatEtc.cfFormat) )
        {
            pFormatEtcData->fSaveOnFlush = TRUE;
            
    	    // no way to catch any errors
            SSSetClipboardData(pFormatEtcData->_FormatEtc.cfFormat, NULL); 

            // Bug#10731 If we are adding the EmbedSource but there was no Object Descriptor in
            //  the Enumerator, see if we can add the Object Descriptor now.

            if ( (pFormatEtcData->_FormatEtc.cfFormat == g_cfEmbedSource) 
                    && !fHaveObjectDescriptor)
            {
                FORMATETC fetcObjDescriptor;
                
                fetcObjDescriptor.cfFormat = g_cfObjectDescriptor;
                fetcObjDescriptor.ptd = NULL;
                fetcObjDescriptor.dwAspect = DVASPECT_CONTENT;
                fetcObjDescriptor.lindex =   -1;
                fetcObjDescriptor.tymed = TYMED_HGLOBAL ;

                if (S_OK == pDataObj->QueryGetData(&fetcObjDescriptor))
                {
        		    ++pFormatEtcData; // increment formatEtc to next format.
        		    ++cFormats; // increment number of formats in enumerator.

                    SSSetClipboardData(g_cfObjectDescriptor, NULL);
                    pFormatEtcData->_FormatEtc = fetcObjDescriptor;
                    pFormatEtcData->fSaveOnFlush = TRUE;
                }
            }
        }

        // Bump the pointer in the table of FORMATETCs to the next slot
        ++pFormatEtcData;
    	++cFormats;

    	Assert( dwSize >= (DWORD) ( (BYTE *) pFormatEtcData - (BYTE *) pFormatEtcDataArray));
    	Assert( dwSize >= (DWORD) ( (BYTE *) pbDvTarget - (BYTE *) pFormatEtcDataArray));

        // HACK ALERT!!!!  Lotus Freelance 2.1 depends on getting
        // cfNative *before* presentation formats (like CF_METAFILEPICT).
        // Therefore, we emulate OLE16 behaviour and offer cfNative
        // and cfOwnerLink immediately *after* cfEmbeddedObject or
        // cfEmbedSource.
        //
        // NB!  This hack destroys the exact ordering of formats
        // offered by the data object given in OleSetClipboard

        if( fOfferNative && !fOfferedNative )
        {
            // even if the calls below fail, don't put OLE1 formats
            // the clipboard again.

            fOfferedNative = TRUE;
            // this call will fail if CF_OBJECTDESCRIPTOR is not
            // available

            hresult = GetDataFromDescriptor(pDataObj, &clsid,
                        g_cfObjectDescriptor,
                        USE_NORMAL_CLSID, NULL, NULL);

            // we do not want static objects like metafiles and
            // dib's to be treated as embeddings by OLE1 containers.
            // They will be able to better handle the data as just
            // a plain metafile

            if( hresult == NOERROR &&
                !IsEqualCLSID(clsid, CLSID_StaticMetafile) &&
                !IsEqualCLSID(clsid, CLSID_StaticDib) &&
                !IsEqualCLSID(clsid, CLSID_Picture_EnhMetafile))
            {
                SSSetClipboardData(g_cfNative, NULL);
                SSSetClipboardData(g_cfOwnerLink, NULL);
                pFormatEtcDataArray->_dwMiscArrayFlags |= FETC_OFFER_OLE1;
            }
        }
    }
    
    // Set FormatEtcDataArray Header Data.
    pFormatEtcDataArray->_cFormats = cFormats;
    pFormatEtcDataArray->_dwSig = 0;
    pFormatEtcDataArray->_cRefs = 1;
    pFormatEtcDataArray->_dwSize = dwSize;
    pFormatEtcDataArray->_fIs64BitArray = IS_WIN64;

    if (fPersistDataObjOnFlush)
    {
        pFormatEtcDataArray->_dwMiscArrayFlags |= FETC_PERSIST_DATAOBJ_ON_FLUSH;
    }


    // we don't need to do this now because we'll reset hresult
    // to NOERROR below.  Note that this does mean that we'll
    // ignore any failure from the enumerator.  We do this for two
    // reasons:
    //      1. The enumerator really should *not* fail on anything;
    //      all it should do is memcmp some stuff into the formatetc
    //      that we pass in.  If it decides to fail at some point,
    //      then we'll just put on the clipboard whatever was
    //      enumerated 'til that point.
    //      2. It is too late (88/28/94) to change for NT3.5  This
    //      behaviour (ingnoring failure) has been around for a while
    //      (see reason #1).  It is possible that some apps are
    //      returning failure instead of S_FALSE to terminate.
    //      If we checked for failure and returned, we'd break those
    //      apps.
    //
    //if( hresult == ResultFromScode(S_FALSE) )
    //{
        // this is OK, means the enumerator terminated successfully
    //      hresult = NOERROR;
    //}

    pIEnum->Release();

    // now set up any OLE1 formats we might need to offer.

    // if the app offers ObjectLink itself, then we will have already
    // set it up for delayed rendering in the enumerator loop above

    if( fOfferObjectLink && !SSIsClipboardFormatAvailable(g_cfObjectLink) )
    {
        hresult = GetDataFromDescriptor(pDataObj, NULL,
                    g_cfLinkSrcDescriptor,
                    USE_NORMAL_CLSID, NULL, &dwStatus);

        // there are some kinds of links that can't be linked to
        // by OLE1 containers.  Non-filename links (e.g. a progid
        // moniker) and links to embeddings are common examples.

        // Clipboard source providers indicate this state by
        // setting the OLEMISC_CANLINKBYOLE1 bit in the status
        // field of LinkSourceDescriptor

        if( hresult == NOERROR && (dwStatus & OLEMISC_CANLINKBYOLE1) )
        {
            SSSetClipboardData(g_cfObjectLink, NULL);
            pFormatEtcDataArray->_dwMiscArrayFlags |= FETC_OFFER_OBJLINK;
        }
    }


    // even if the calls to GetDataFromDescriptor failed above, it only
    // means that we can't render OLE1 formats.  This is OK.

    hresult = NOERROR;

    // now keep a copy of the formats locally, ptds are set to be offsets from 
    // beginning of Structure so these don't need to be updated.
    _xmemcpy(pFormatEtcDataArrayCopy, pFormatEtcDataArray, dwSize);

    // now stuff the formatetc's on the clipboard and our private
    // clipboard window (for use by RenderFormat).

    SetWindowLongPtr(hClipWnd, 
                     WL_ClipPrivateData, 
                     (LONG_PTR) pFormatEtcDataArrayCopy);

    GlobalUnlock(hglobal);
    if( !SSSetClipboardData(g_cfOlePrivateData, hglobal) )
    {
        GlobalFree(hglobal);    // on success, the clipboard will
                    // take ownership of our hglobal.
        LEDebugOut((DEB_WARN, "WARNING: Unable to set clipboard "
            "formats!\n"));
    }

errRtn:
    LEDebugOut((DEB_ITRACE, "%p OUT SetClipboardFormats ( %lx )\n", NULL,
        hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   VerifyCallerIsClipboardOwner (internal)
//
//  Synopsis:   Checks to make sure the caller is the clipboard owner
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    HWND to the private clipboard window (the owner of the
//              clipboard) upon success
//              NULL on failure.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HWND VerifyCallerIsClipboardOwner( void )
{
    HWND            hClipWnd,
            hWndClipOwner;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN VerifyCallerIsClipboardOwner ( )\n",
        NULL ));

    // don't create a window if none exists
    hClipWnd = GetPrivateClipboardWindow( CLIP_QUERY );

    if( hClipWnd )
    {

        hWndClipOwner = SSGetClipboardOwner();

        if( hClipWnd != hWndClipOwner )
        {
            // caller is not owner, return NULL
            hClipWnd = NULL;
        }
    }

    LEDebugOut((DEB_ITRACE, "%p OUT VerifyCallerIsClipboardOwner "
        "( %lx )\n", NULL, hClipWnd));

    return hClipWnd;
}


void GetCopiedFormatEtcDataArraySize (FORMATETCDATAARRAY* pClipFormatEtcDataArray, size_t* pstSize)
{
    AssertSz(pstSize, "Bad argument to GetCopiedFormatEtcDataArraySize");

#ifdef _WIN64

    if (pClipFormatEtcDataArray->_fIs64BitArray)
    {
        *pstSize = pClipFormatEtcDataArray->_dwSize;
    }
    else
    {
        *pstSize = pClipFormatEtcDataArray->_dwSize + 
                   (sizeof (FORMATETCDATAARRAY) - sizeof (FORMATETCDATAARRAY32)) +
                   (pClipFormatEtcDataArray->_cFormats - 1) * (sizeof (FORMATETCDATA) - sizeof (FORMATETCDATA32));
    }

#else

    if (pClipFormatEtcDataArray->_fIs64BitArray)
    {
        // Just subtract
        *pstSize = pClipFormatEtcDataArray->_dwSize -
                   (sizeof (FORMATETCDATAARRAY64) - sizeof (FORMATETCDATAARRAY)) -
                   (pClipFormatEtcDataArray->_cFormats - 1) * (sizeof (FORMATETCDATA64) - sizeof (FORMATETCDATA));
    }
    else
    {
        *pstSize = pClipFormatEtcDataArray->_dwSize;
    }

#endif
}


#ifdef _WIN64

inline void TranslateFormatEtcData (FORMATETCDATA* pFormatEtcData, FORMATETCDATA32* pClipFormatEtcData)
{
    // Convert from 32 to 64 bit format
    pFormatEtcData->fSaveOnFlush = pClipFormatEtcData->fSaveOnFlush;
    pFormatEtcData->dwReserved1 = pClipFormatEtcData->dwReserved1;
    pFormatEtcData->dwReserved2 = pClipFormatEtcData->dwReserved2;

    pFormatEtcData->_FormatEtc.cfFormat = pClipFormatEtcData->_FormatEtc.cfFormat;
    pFormatEtcData->_FormatEtc.ptd = (DVTARGETDEVICE FAR*) UlongToPtr (pClipFormatEtcData->_FormatEtc.ptd);
    pFormatEtcData->_FormatEtc.dwAspect = pClipFormatEtcData->_FormatEtc.dwAspect;
    pFormatEtcData->_FormatEtc.lindex = pClipFormatEtcData->_FormatEtc.lindex;
    pFormatEtcData->_FormatEtc.tymed = pClipFormatEtcData->_FormatEtc.tymed;

    AssertSz(!pFormatEtcData->_FormatEtc.ptd, "This field should always be null");
}

#else

inline void TranslateFormatEtcData (FORMATETCDATA* pFormatEtcData, FORMATETCDATA64* pClipFormatEtcData)
{
    // Convert from 32 to 64 bit format
    pFormatEtcData->fSaveOnFlush = pClipFormatEtcData->fSaveOnFlush;
    pFormatEtcData->dwReserved1 = pClipFormatEtcData->dwReserved1;
    pFormatEtcData->dwReserved2 = pClipFormatEtcData->dwReserved2;

    pFormatEtcData->_FormatEtc.cfFormat = pClipFormatEtcData->_FormatEtc.cfFormat;
    pFormatEtcData->_FormatEtc.ptd = (DVTARGETDEVICE FAR*) pClipFormatEtcData->_FormatEtc.ptd;
    pFormatEtcData->_FormatEtc.dwAspect = pClipFormatEtcData->_FormatEtc.dwAspect;
    pFormatEtcData->_FormatEtc.lindex = pClipFormatEtcData->_FormatEtc.lindex;
    pFormatEtcData->_FormatEtc.tymed = pClipFormatEtcData->_FormatEtc.tymed;

    AssertSz(!pFormatEtcData->_FormatEtc.ptd, "This field should always be null");
}

#endif

void CopyFormatEtcDataArray (
    FORMATETCDATAARRAY* pFormatEtcDataArray, 
    FORMATETCDATAARRAY* pClipFormatEtcDataArray, 
    size_t stSize, 
    BOOL bCheckAvailable
    )
{
    DWORD i=0,k=0;

    AssertSz(pFormatEtcDataArray && pClipFormatEtcDataArray, "Bad argument to CopyFormatEtcDataArray");
 
    // copy header fields that are compatible on both types of structures
    pFormatEtcDataArray->_dwSig = pClipFormatEtcDataArray->_dwSig;
    pFormatEtcDataArray->_dwSize = pClipFormatEtcDataArray->_dwSize;
    pFormatEtcDataArray->_cRefs = pClipFormatEtcDataArray->_cRefs;
    pFormatEtcDataArray->_cFormats = pClipFormatEtcDataArray->_cFormats;
    pFormatEtcDataArray->_dwMiscArrayFlags = pClipFormatEtcDataArray->_dwMiscArrayFlags;

    // Check for compatible data array
    if (pClipFormatEtcDataArray->_fIs64BitArray == IS_WIN64)
    {
       // Format is compatible
       for(;i<pClipFormatEtcDataArray->_cFormats;i++)
        {
            if(!bCheckAvailable || SSIsClipboardFormatAvailable(pClipFormatEtcDataArray->_FormatEtcData[i]._FormatEtc.cfFormat))
            { 
                pFormatEtcDataArray->_FormatEtcData[k] = pClipFormatEtcDataArray->_FormatEtcData[i];
                k++;
            }
            else
            {
                pFormatEtcDataArray->_cFormats--;
            }
        }
    }
    else
    {

#ifdef _WIN64
        FORMATETCDATAARRAY32* pClipFormatEtcDataArray_ptr = (FORMATETCDATAARRAY32*) pClipFormatEtcDataArray;
#else
        FORMATETCDATAARRAY64* pClipFormatEtcDataArray_ptr = (FORMATETCDATAARRAY64*) pClipFormatEtcDataArray;
#endif
        for(;i<pClipFormatEtcDataArray_ptr->_cFormats;i++)
        {
            if(!bCheckAvailable || SSIsClipboardFormatAvailable(pClipFormatEtcDataArray_ptr->_FormatEtcData[i]._FormatEtc.cfFormat))
            {
                TranslateFormatEtcData (
                    pFormatEtcDataArray->_FormatEtcData + k,
                    pClipFormatEtcDataArray_ptr->_FormatEtcData + i
                    );

                k++;
            }
            else
            {
                pFormatEtcDataArray->_cFormats--;
            }
        }
    }

    // set size
    pFormatEtcDataArray->_dwSize = (DWORD) stSize;

    // adjust the size of the new structure
    pFormatEtcDataArray->_dwSize -= (i - k) * sizeof(FORMATETCDATA);

    // set the 64 bit flag
    pFormatEtcDataArray->_fIs64BitArray = IS_WIN64;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\cache\olecache.cpp ===
//+----------------------------------------------------------------------------
//
//      File:
//              olecache.cpp
//
//      Contents:
//              Ole default presentation cache implementation
//
//      Classes:
//              COleCache - ole multiple presentation cache
//              CCacheEnum - enumerator for COleCache
//
//      Functions:
//              CreateDataCache
//
//      History:
//              04-Sep-96 Gopalk    Completly rewritten to delay load cache using
//                                  Table of Contents written at the end of
//                                  Presentation steam 0
//              31-Jan-95 t-ScottH  add Dump methods to COleCache
//                                                      CCacheEnum
//                                                      CCacheEnumFormatEtc
//                                  add the following APIs: DumpCOleCache
//                                                          DumpCCacheEnum
//                                                          DumpCCacheEnumFormatEtc
//                                  moved CCacheEnumFormatEtc def'n to header file
//                                  added flag to COLECACHEFLAGS to indicate aggregation
//                                      (_DEBUG only)
//              01/09/95 - t-ScottH - change VDATETHREAD to accept a this
//                      pointer, and added VDATETHREAD to IViewObject:: methods
//                      (COleCache::CCacheViewImpl:: )
//              03/01/94 - AlexGo  - Added call tracing to AddRef/Release
//                      implementations
//              02/08/94 - ChrisWe - 7297: need implementation of
//                      FORMATETC enumerator
//              01/24/94 alexgo    first pass at converting to Cairo-style
//                                  memory allocation
//              01/11/94 - AlexGo  - added VDATEHEAP macros to every function
//                      and method.
//              12/10/93 - AlexT - header file clean up, include ole1cls.h
//              12/09/93 - ChrisWe - incremented pointer in COleCache::GetNext()
//              11/30/93 - alexgo  - fixed bugs with GETPPARENT usage
//              11/23/93 - ChrisWe - introduce use of CACHEID_NATIVE,
//                      CACHEID_GETNEXT_GETALL, CACHEID_GETNEXT_GETALLBUTNATIVE
//                      for documentary purposes
//              11/22/93 - ChrisWe - replace overloaded ==, != with
//                      IsEqualIID and IsEqualCLSID
//              07/04/93 - SriniK - Added the support for reading PBrush,
//                      MSDraw native objects, hence avoid creating
//                      presentation cache/stream. Also started writing static
//                      object data into "OLE_CONTENTS" stream in placeable
//                      metafile format for static metafile and DIB File
//                      format for static dibs. This enabled me to provide
//                      support for converting static objects. Also added code
//                      to support converting static metafile to MSDraw object
//                      and static DIB to PBrush object.
//              06/04/93 - SriniK - Added the support for demand loading and
//                      discarding the caches.
//              11/12/92 - SriniK - created
//
//-----------------------------------------------------------------------------
#include <le2int.h>
#include <olepres.h>
#include <ole1cls.h>
#include <olecache.h>
#include "enumtors.h"

#ifndef WIN32
#ifndef _MAC
const LONG lMaxSmallInt = 32767;
const LONG lMinSmallInt = -32768;
#else

#ifdef MAC_REVIEW
Review IS_SMALL_INT.
#endif
#include <limits.h>

#define lMaxSmallInt SHRT_MAX
#define lMinSmallInt SHRT_MIN
#endif

#define IS_SMALL_INT(lVal) \
((HIWORD(lVal) && ((lVal > lMaxSmallInt) || (lVal < lMinSmallInt))) \
    ? FALSE : TRUE)

#endif // WIN32

#define FREEZE_CONSTANT 143             // Used by Freeze() and Unfreeze()


// This was the original code...

/*
#define VERIFY_TYMED_SINGLE_VALID_FOR_CLIPFORMAT(pfetc) {\
    if ((pfetc->cfFormat==CF_METAFILEPICT && pfetc->tymed!=TYMED_MFPICT)\
        || ( (pfetc->cfFormat==CF_BITMAP || \
            pfetc->cfFormat == CF_DIB ) \
            && pfetc->tymed!=TYMED_GDI)\
        || (pfetc->cfFormat!=CF_METAFILEPICT && \
                pfetc->cfFormat!=CF_BITMAP && \
                pfetc->cfFormat!=CF_DIB && \
                pfetc->tymed!=TYMED_HGLOBAL)) \
        return ResultFromScode(DV_E_TYMED); \
}
*/

//+----------------------------------------------------------------------------
//
//	Function:
//		CheckTymedCFCombination (Internal)
//
//	Synopsis:
//		Verifies that the combination of clipformat and tymed is
//		valid to the cache.
//
//	Arguments:
//		[pfetc]	-- The candidate FORMATETC
//
//	Returns:
//		S_OK				For a valid combination
//		CACHE_S_FORMATETC_NOTSUPPORTED	For a combination which can be
//						cached, but not drawn by the cache
//		DV_E_TYMED			For all other combinations
//
//	Rules:
//		
//		1> (CMF && TMF) || (CEM && TEM) || (CB && TG) || (CD && TH) => S_OK
//		   (TH && ~CD) => CACHE_S_FORMATETC_NOTSUPPORTED
//		
//		2> (~S_OK && ~CACHE_S_FORMATETC_NOTSUPPORTED) => DV_E_TYMED
//
//		Where: 	CMF == CF_METAFILEPICT
//			CEM == CF_ENHMETAFILE
//			CB  == CF_BITMAP
//			CD  == CF_FIB
//			TMF == TYMED_MFPICT
//			TEM == TYMED_ENHMETAFILE
//			TG  == TYMED_GDI
//			TH  == TYMED_HGLOBAL
//		
//	Notes:
//		Since CACHE_S_FORMATETC_NOTSUPPORTED was never implemented in
//		16-bit, we return S_OK in its place if we are in the WOW.
//
//	History:
//		01/07/94   DavePl    Created
//
//-----------------------------------------------------------------------------

INTERNAL_(HRESULT) CheckTymedCFCombination(LPFORMATETC pfetc)
{

    HRESULT hr;

    // CF_METAFILEPICT on TYMED_MFPICT is a valid combination

    if (pfetc->cfFormat == CF_METAFILEPICT && pfetc->tymed == TYMED_MFPICT)
    {
        hr =  S_OK;
    }

    // CF_ENHMETAFILE on TYMED_ENHMF is a valid combination

    else if (pfetc->cfFormat == CF_ENHMETAFILE && pfetc->tymed == TYMED_ENHMF)
    {
        hr = S_OK;
    }

    // CF_BITMAP on TYMED_GDI is a valid combination

    else if (pfetc->cfFormat == CF_BITMAP && pfetc->tymed == TYMED_GDI)
    {
        hr = S_OK;
    }

    // CF_DIB on TYMED_HGLOBAL is a valid combination

    else if (pfetc->cfFormat == CF_DIB && pfetc->tymed == TYMED_HGLOBAL)
    {
        hr = S_OK;
    }

    // Anything else on TYMED_HGLOBAL is valid, but we cannot draw it

    else if (pfetc->tymed == TYMED_HGLOBAL)
    {
        hr = IsWOWThread() ? S_OK : CACHE_S_FORMATETC_NOTSUPPORTED;
    }

    // Any other combination is invalid

    else
    {
        hr = DV_E_TYMED;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//      Function:
//              IsSameAsObjectFormatEtc, internal
//
//      Synopsis:
//              REVIEW, checks to see if [lpforetc] is compatible with
//              [cfFormat].  If [lpforetc] doesn't have a format set,
//              sets it to cfFormat, which is then assumed to be
//              one of CF_METAFILEPICT, or CF_DIB.
//
//      Arguments:
//              [lpforetc] -- a pointer to a FORMATETC
//              [cfFormat] -- a clipboard format
//
//      Returns:
//              DV_E_ASPECT, if the aspect isn't DVASPECT_CONTENT
//              DV_E_LINDEX, DV_E_CLIPFORMAT if the lindex or clipboard
//                      formats don't match
//              S_OK
//
//      Notes:
//
//      History:
//              11/28/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
INTERNAL IsSameAsObjectFormatEtc(LPFORMATETC lpforetc, CLIPFORMAT cfFormat)
{
    VDATEHEAP();

    // this function only checks for DVASPECT_CONTENT
    if (lpforetc->dwAspect != DVASPECT_CONTENT)
        return ResultFromScode(DV_E_DVASPECT);

    // is the lindex right?
    if (lpforetc->lindex != DEF_LINDEX)
        return ResultFromScode(DV_E_LINDEX);

    // if there's no format, set it to CF_METAFILEPICT or CF_DIB
    if(lpforetc->cfFormat == NULL) {
        lpforetc->cfFormat =  cfFormat;
        if(lpforetc->cfFormat == CF_METAFILEPICT) {
            lpforetc->tymed = TYMED_MFPICT;
        }
#ifdef FULL_EMF_SUPPORT
        else if (lpforetc->cfFormat == CF_ENHMETAFILE) {
            lpforetc->tymed = TYMED_ENHMF;
        }
#endif
        else {
            lpforetc->tymed = TYMED_HGLOBAL;
        }
    }
    else
    {
        // if it's CF_BITMAP, change it to CF_DIB
        BITMAP_TO_DIB((*lpforetc));

        // compare the two formats
        if (lpforetc->cfFormat != cfFormat)
            return ResultFromScode(DV_E_CLIPFORMAT);
    }

    // if we got here, the two formats are [interchangeable?]
    return NOERROR;
}

//+----------------------------------------------------------------------------
//
//      Function:
//              CreateDataCache, public
//
//      Synopsis:
//              Creates an instance of the default presentation cache used by Ole.
//
//      Arguments:
//              [pUnkOuter] [in]  -- pointer to outer unknown, if this is being
//                                   aggregated
//              [rclsid]    [in]  -- the class that the cache should assume
//              [iid]       [in]  -- the interface the user would like returned
//              [ppv]       [out] -- pointer to return the requested interface
//
//      Returns:
//              E_OUTOFMEMORY, S_OK
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(CreateDataCache)
STDAPI CreateDataCache(IUnknown* pUnkOuter, REFCLSID rclsid, REFIID iid,
                       LPVOID* ppv)
{
    OLETRACEIN((API_CreateDataCache, 
                PARAMFMT("pUnkOuter= %p, rclsid= %I, iid= %I, ppv= %p"),
    		pUnkOuter, &rclsid, &iid, ppv));
    VDATEHEAP();

    // Local variables
    HRESULT error = NOERROR;
    COleCache* pOleCache = NULL;

    // Check if being aggregated
    if(pUnkOuter) {
        // Validate the interface and IID requested
        if(!IsValidInterface(pUnkOuter) || !IsEqualIID(iid, IID_IUnknown))
            error = ResultFromScode(E_INVALIDARG);
    }
    // Check that a valid out pointer has been passed
    if(!IsValidPtrOut(ppv, sizeof(LPVOID)))
        error = ResultFromScode(E_INVALIDARG);

    if(error == NOERROR) {
        // Create new cache
        pOleCache = (COleCache *) new COleCache(pUnkOuter, 
                                                rclsid, 
                                                COLECACHEF_APICREATE);
        if(pOleCache && !pOleCache->IsOutOfMemory()) {
            if(pUnkOuter) {
                // We're being aggregated, return private IUnknown
	        *ppv = (void *)(IUnknown *)&pOleCache->m_UnkPrivate;
            }
            else {
	        // Get requested interface on cache
	        error = pOleCache->QueryInterface(iid, ppv);
	        // Release the local pointer because the 
                // refcount is currently 2
	        if(error == NOERROR)
                    pOleCache->Release();
            }
        }
        else
            error = ResultFromScode(E_OUTOFMEMORY);
    }

    // If something has gone wrong, clean up
    if(error != NOERROR) {
        if(pOleCache)
            pOleCache->Release();
    }

    OLETRACEOUT((API_CreateDataCache, error));
    return error;
}

//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::COleCache, public
//
//      Synopsis:
//              Constructor
//
//      Arguments:
//              [pUnkOuter] [in] -- outer unknown, if being aggregated
//              [rclsid]    [in] -- the class id the cache should assume
//
//      Notes:
//              Constructs an instance of presentation cache
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_ctor)
COleCache::COleCache(IUnknown* pUnkOuter, REFCLSID rclsid, DWORD dwCreateFlag) :
    CRefExportCount(pUnkOuter)
{
    // Set reference count for return from constructor
    SafeAddRef();

    // Initialize flags
    Win4Assert(dwCreateFlag==0 || dwCreateFlag==COLECACHEF_APICREATE);
    m_ulFlags = COLECACHEF_LOADEDSTATE | dwCreateFlag;     //fresh cache!

    // Set m_pUnkOuter appropriately
    if(pUnkOuter) {
        m_pUnkOuter = pUnkOuter;

        // This is for the debugger extensions
        // (since we cannot compare m_pUnkOuter to m_pUnkPrivate with copied mem)
        // it is only used in the ::Dump method
        #ifdef _DEBUG
        m_ulFlags |= COLECACHEF_AGGREGATED;
        #endif // _DEBUG
    }
    else {
        m_pUnkOuter = &m_UnkPrivate;
    }

    // Create the CacheNode Array object
    m_pCacheArray = CArray<CCacheNode>::CreateArray(5,1);
    if(!m_pCacheArray) {
        m_ulFlags |= COLECACHEF_OUTOFMEMORY;
        return;
    }

    // Initialize storage
    m_pStg = NULL;

    // Initialize IViewObject advise sink
    m_pViewAdvSink = NULL;
    m_advfView = 0;
    m_aspectsView = 0;

    // Initialize frozen aspects
    m_dwFrozenAspects = NULL;

    // Initialize data object
    m_pDataObject = NULL;

    // Initialize CLSID and cfFormat
    m_clsid = rclsid;
    m_cfFormat = NULL;

    // Update flags based on the clsid
    if(IsEqualCLSID(m_clsid, CLSID_StaticMetafile)) {
        m_cfFormat = CF_METAFILEPICT;
        m_ulFlags |= COLECACHEF_STATIC | COLECACHEF_FORMATKNOWN;
    }
    else if(IsEqualCLSID(m_clsid, CLSID_StaticDib)) {
        m_cfFormat = CF_DIB;
        m_ulFlags |= COLECACHEF_STATIC | COLECACHEF_FORMATKNOWN;
    }
    else if(IsEqualCLSID(m_clsid, CLSID_PBrush)) {
        m_cfFormat = CF_DIB;
        m_ulFlags |= COLECACHEF_PBRUSHORMSDRAW | COLECACHEF_FORMATKNOWN;
    }
    else if(IsEqualCLSID(m_clsid, CLSID_MSDraw)) {
        m_cfFormat = CF_METAFILEPICT;
        m_ulFlags |= COLECACHEF_PBRUSHORMSDRAW | COLECACHEF_FORMATKNOWN;
    }
    else if(IsEqualCLSID(m_clsid, CLSID_Picture_EnhMetafile)) {
        m_cfFormat = CF_ENHMETAFILE;
        m_ulFlags |= COLECACHEF_STATIC | COLECACHEF_FORMATKNOWN;
    }
    else
        m_cfFormat = NULL;

    // If we can render native format of the cache, add native cache node
    if(m_cfFormat) {
     if (!UpdateCacheNodeForNative())
        m_ulFlags |= COLECACHEF_OUTOFMEMORY;
     else
        m_ulFlags &= ~COLECACHEF_LOADEDSTATE;   // Native node has been added.
    }
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::~COleCache, public
//
//      Synopsis:
//              Destructor
//
//      Notes:
//              Destroys the presentation cache
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_dtor)
COleCache::~COleCache(void)
{
    Win4Assert(m_ulFlags & COLECACHEF_CLEANEDUP);
}

//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CleanupFn, private
//
//      Synopsis:
//              Cleanup function called before destruction
//
//      Notes:
//              Performs necessary cleanup
//
//	History:
//               Gopalk            Creation        Jan 21, 97
//
//-----------------------------------------------------------------------------
void COleCache::CleanupFn(void)
{
    // Release the cache array object
    if(m_pCacheArray) {
        if(m_pDataObject) {
            ULONG index;
            LPCACHENODE lpCacheNode;

            // This indicates that cache client has bad release logic
            Win4Assert(!"Ole Cache released while the server is running");
            
            // Tear down existing advise connections
            m_pCacheArray->Reset(index);
            while(lpCacheNode = m_pCacheArray->GetNext(index))
                lpCacheNode->TearDownAdviseConnection(m_pDataObject);
        }
        m_pCacheArray->Release();
    }

    // Release storage
    if (m_pStg)
        m_pStg->Release();

    // Release IViewObject advise sink
    if (m_pViewAdvSink) {
        m_pViewAdvSink->Release();
        m_pViewAdvSink = NULL;
    }

    // Set COLECACHEF_CLEANEDUP flag
    m_ulFlags |= COLECACHEF_CLEANEDUP;

}

//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::QueryInterface, public
//
//      Synopsis:
//              implements IUnknown::QueryInterface
//
//      Arguments:
//              [iid] [in]  -- IID of the desired interface
//              [ppv] [out] -- pointer to return the requested interface
//
//      Returns:
//              E_NOINTERFACE if the requested interface is not available
//              otherwise S_OK
//
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_QueryInterface)
STDMETHODIMP COleCache::QueryInterface(REFIID iid, LPVOID* ppv)
{
    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);

    return(m_pUnkOuter->QueryInterface(iid, ppv));
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::AddRef, public
//
//      Synopsis:
//              implements IUnknown::AddRef
//
//      Arguments:
//              none
//
//      Returns:
//              the object's reference count
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_AddRef)
STDMETHODIMP_(ULONG) COleCache::AddRef(void)
{
    // Validation checks
    VDATEHEAP();
    if(!VerifyThreadId())
        return((ULONG) RPC_E_WRONG_THREAD);

    return(m_pUnkOuter->AddRef());
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::Release, public
//
//      Synopsis:
//              implements IUnknown::Release
//
//      Arguments:
//              none
//
//      Returns:
//              the object's reference count
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_Release)
STDMETHODIMP_(ULONG) COleCache::Release(void)
{
    // Validation checks
    VDATEHEAP();
    if(!VerifyThreadId())
        return((ULONG) RPC_E_WRONG_THREAD);

    return(m_pUnkOuter->Release());
}

//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::GetExtent, public
//
//      Synopsis:
//              Gets the size of the cached presentation for [dwAspect].  If
//              there are several, because of varied advise control flags,
//              such as ADVF_NODATA, ADVF_ONSTOP, ADVF_ONSAVE, etc., gets the
//              most up to date one
//
//      Arguments:
//              [dwAspect] [in]  -- the aspect for which the extents are needed
//              [lpsizel]  [out] -- pointer to return the width and height
//
//      Returns:
//              OLE_E_BLANK if the aspect is not found
//              otherwise S_OK
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_GetExtent)
INTERNAL COleCache::GetExtent(DWORD dwAspect, LPSIZEL lpsizel)
{
    // Validation check
    VDATEHEAP();

    // New data type
    typedef enum tagCacheType {
        // These values are defined in order of least to best preferred, so that
        // numeric comparisons are valid; DO NOT REORDER
        CACHETYPE_NONE   = 0,
        CACHETYPE_NODATA,
        CACHETYPE_ONSTOP,
        CACHETYPE_ONSAVE,
        CACHETYPE_NORMAL
    } CacheType;

    // local variables
    CCacheNode* pCacheNode;        // pointer to cache node being examined
    CacheType iCacheType;          // cache type of cache node being examined
    CacheType iCacheTypeSoFar;     // best cache type so far
    const FORMATETC* pforetc;      // format information for current node
    DWORD grfAdvf;                 // advise flags for current node
    SIZEL sizelTmp;                // temp Sizel struct
    unsigned long index;           // index used for enumerating m_pCacheArray

    // Initialize the sizel struct
    lpsizel->cx = 0;
    lpsizel->cy = 0;

    // Check to see if any cache nodes exist
    if (!m_pCacheArray->Length())
        return ResultFromScode(OLE_E_BLANK);

    // We want to return the extents of the cache node that has NORMAL
    // advise flags. If we don't find such a node then we will take the next
    // best available.
    m_pCacheArray->Reset(index);
    iCacheTypeSoFar = CACHETYPE_NONE;
    for(unsigned long i=0;i<m_pCacheArray->Length();i++) {
        // Get the next cache node
        pCacheNode = m_pCacheArray->GetNext(index);
        // pCacheNode cannot be null
        Win4Assert(pCacheNode);
        
        // Get the formatetc of the cache node
        pforetc = pCacheNode->GetFormatEtc();
        
        // Restrict cfFormat to those that cache can draw
        if((pforetc->cfFormat == CF_METAFILEPICT) ||
           (pforetc->cfFormat == CF_DIB) ||
           (pforetc->cfFormat == CF_ENHMETAFILE)) {
            // Obtain the advise flags
            grfAdvf = pCacheNode->GetAdvf();

            // Obtain the cachetype
            if(grfAdvf & ADVFCACHE_ONSAVE)
                iCacheType = CACHETYPE_ONSAVE;
            else if(grfAdvf & ADVF_NODATA)
                iCacheType = CACHETYPE_NODATA;
            else if(grfAdvf & ADVF_DATAONSTOP)
                iCacheType = CACHETYPE_ONSTOP;
            else
                iCacheType = CACHETYPE_NORMAL;
            
            if (iCacheType > iCacheTypeSoFar) {
                // Get the extents from the presentation object
                if((pCacheNode->GetExtent(dwAspect, &sizelTmp)) == NOERROR) {
                    if(!(sizelTmp.cx == 0 && sizelTmp.cy == 0)) {
                        // Update extents
                        *lpsizel = sizelTmp;
                        iCacheTypeSoFar = iCacheType;

                        // If we have normal cache, break
                        if(iCacheType == CACHETYPE_NORMAL)
                            break;
                    }
                }
            }
        }
    }
                    
    if(lpsizel->cx == 0 || lpsizel->cy == 0)
        return ResultFromScode(OLE_E_BLANK);

    return NOERROR;
}


// Private methods of COleCache
//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::UpdateCacheNodeForNative, private
//
//      Synopsis:
//              If a native cache node of different format already exists, 
//              changes that node to a normal cache node and adds a native 
//              cache node if cache can render the new native format
//
//      Arguments:
//              none
//
//      Returns:
//              pointer to the found, or newly created cache node. Will
//              return NULL if out of memory
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------

INTERNAL_(LPCACHENODE)COleCache::UpdateCacheNodeForNative(void)
{
    // Local variable
    ULONG index;
    LPCACHENODE lpCacheNode;
    FORMATETC foretc;

    // Check if a native cache has already been created
    lpCacheNode = m_pCacheArray->GetItem(1);
    if(lpCacheNode) {
        // Assert that we have storage now
        Win4Assert(m_pStg);
        Win4Assert(!lpCacheNode->GetStg());

        if(lpCacheNode->GetFormatEtc()->cfFormat != m_cfFormat) {
            // The native format has changed

            // Add the old native cache as a normal cache 
            index = m_pCacheArray->AddItem(*lpCacheNode);
            if(index) {
                // Clear the advise connection of the old native cache
                if(m_pDataObject)
                    lpCacheNode->ClearAdviseConnection();
                
                // Update the state on the new cache
                lpCacheNode = m_pCacheArray->GetItem(index);
                Win4Assert(lpCacheNode);
                lpCacheNode->MakeNormalCache();
                lpCacheNode->SetClsid(CLSID_NULL);
            }
            else {
                // We are out of memory
                if(m_pDataObject)
                    lpCacheNode->TearDownAdviseConnection(m_pDataObject);
            }
        
            // Delete the old native cache
            m_pCacheArray->DeleteItem(1);
            lpCacheNode = NULL;
        }
        else {
            // Set the storage on the native cache node
            lpCacheNode->SetStg(m_pStg);
        }
    }

    if(!lpCacheNode) {
        // Add a new native cache if we can render the format
        if(m_cfFormat==CF_METAFILEPICT || 
           m_cfFormat==CF_DIB || 
           m_cfFormat==CF_ENHMETAFILE) {
            // Initialize the FormatEtc
            INIT_FORETC(foretc);

            foretc.cfFormat = m_cfFormat;
            if (foretc.cfFormat == CF_METAFILEPICT)
                foretc.tymed = TYMED_MFPICT;
            else if (foretc.cfFormat == CF_ENHMETAFILE)
                foretc.tymed = TYMED_ENHMF;
            else
                foretc.tymed = TYMED_HGLOBAL;

            // Create the native cache node
            CCacheNode CacheNode(&foretc, 0, NULL);

            if(m_pCacheArray->AddReservedItem(CacheNode, 1)) {
                lpCacheNode = m_pCacheArray->GetItem(1);
            
                // Update state on the native cache node
                lpCacheNode->MakeNativeCache();
                lpCacheNode->SetClsid(m_clsid);
            }        
        }
    }

    return lpCacheNode;
}

//+----------------------------------------------------------------------------
//
//      Member:
//              COleObject::FindObjectFormat, private
//
//      Synopsis:
//              Determines the object's clipboard format from the storage
//              and updates native cache node
//
//      Arguments:
//              [pstg] [in] -- pointer to storage
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------

INTERNAL_(void) COleCache::FindObjectFormat(LPSTORAGE pstg)
{
    // Local variables
    CLIPFORMAT cfFormat;
    CLSID clsid;
    ULONG ulFlags;

    // Intialize CLSID, clipboard format and cache flags
    cfFormat = NULL;
    ulFlags = 0;
    clsid = CLSID_NULL;

    // Determine the CLSID of the object that owns the storage
    if(SUCCEEDED(ReadClassStg(pstg, &clsid))) {
        // Update clipboard format and cache flags based on the clsid
        if(IsEqualCLSID(clsid, CLSID_StaticMetafile)) {
            cfFormat = CF_METAFILEPICT;
            ulFlags |= (COLECACHEF_STATIC | COLECACHEF_FORMATKNOWN);
        }
        else if(IsEqualCLSID(clsid, CLSID_StaticDib)) {
            cfFormat = CF_DIB;
            ulFlags |= (COLECACHEF_STATIC | COLECACHEF_FORMATKNOWN);
        }
        else if(IsEqualCLSID(clsid, CLSID_PBrush)) {
            cfFormat = CF_DIB;
            ulFlags |= (COLECACHEF_PBRUSHORMSDRAW | COLECACHEF_FORMATKNOWN);
        }
        else if(IsEqualCLSID(clsid, CLSID_MSDraw)) {
            cfFormat = CF_METAFILEPICT;
            ulFlags |= (COLECACHEF_PBRUSHORMSDRAW | COLECACHEF_FORMATKNOWN);
        }
        else if(IsEqualCLSID(clsid, CLSID_Picture_EnhMetafile)) {
            cfFormat = CF_ENHMETAFILE;
            ulFlags |= (COLECACHEF_STATIC | COLECACHEF_FORMATKNOWN);
        }
    }

    // Though we do not know the CLSID of the object that owns the storage,
    // we might understand its native format
    if(!cfFormat) {
        if(SUCCEEDED(ReadFmtUserTypeStg(pstg, &cfFormat, NULL))) {
            if(cfFormat==CF_METAFILEPICT || cfFormat==CF_DIB || 
               cfFormat==CF_ENHMETAFILE)
                ulFlags |= COLECACHEF_FORMATKNOWN;
        }
        else
            cfFormat = NULL;
    }

    // Update the native cache node
    if(cfFormat || m_cfFormat) {
        m_cfFormat = cfFormat;
        m_clsid = clsid;
        m_ulFlags &= ~COLECACHEF_NATIVEFLAGS;
        m_ulFlags |= ulFlags;
        UpdateCacheNodeForNative();
    }

    return;
}


// IOleCacheControl implementation

//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::OnRun, public
//
//      Synopsis:
//              implements IOleCacheControl::OnRun
//
//              Sets up advisory connections with the running object for 
//              dynamically updating cached presentations
//
//      Arguments:
//              [pDataObj] [in] -- IDataObject interface on the running object
//
//      Returns:
//              S_OK or appropriate error code
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_OnRun)
STDMETHODIMP COleCache::OnRun(IDataObject* pDataObj)
{
    // Validatation checks
    VDATEHEAP();
    VDATETHREAD(this);
    VDATEIFACE(pDataObj);

    // Local variables
    HRESULT rerror, error;
    PCACHENODE pCacheNode;
    unsigned long index;

    // Static objects cannot have a server
    Win4Assert(!(m_ulFlags & COLECACHEF_STATIC));

    // OnRun should be called after Load or InitNew
    if(!m_pStg) {
        LEDebugOut((DEB_WARN, "OnRun called without storage\n"));
    }

    // If we already have the data object, nothing more to do
    if(m_pDataObject) {
        Win4Assert(m_pDataObject==pDataObj);
        return NOERROR;
    }

    // Save the data object without ref counting
    m_pDataObject = pDataObj;

    // Set up advise connections on the data object for each 
    // cached presentation including native cache. Gopalk
    m_pCacheArray->Reset(index);
    rerror = NOERROR;
    for(unsigned long i=0;i<m_pCacheArray->Length();i++) {
        // Get the next cache node
        pCacheNode = m_pCacheArray->GetNext(index);
        // pCacheNode cannot be null
        Win4Assert(pCacheNode);

        // Ask the cache node to set up the advise connection
        error = pCacheNode->SetupAdviseConnection(m_pDataObject,
                                                  (IAdviseSink *) &m_AdviseSink);
        if(error != NOERROR)
            rerror = error;
    }

    return rerror;
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::OnStop, public
//
//      Synopsis:
//              implements IOleCacheControl::OnStop
//
//              Tears down the advisory connections set up running object
//
//      Arguments:
//              none
//
//      Returns:
//              S_OK or appropriate error code
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_OnStop)
STDMETHODIMP COleCache::OnStop()
{
    // Validatation checks
    VDATEHEAP();
    VDATETHREAD(this);

    // Local variables
    HRESULT rerror, error;
    PCACHENODE pCacheNode;
    unsigned long index;

    // OnRun should have been called before OnStop
    if(!m_pDataObject)
        return E_UNEXPECTED;
    
    // Delete the advise connections on the data object for 
    // each cached presentation established earlier. Gopalk
    m_pCacheArray->Reset(index);
    rerror = NOERROR;
    for(unsigned long i=0;i<m_pCacheArray->Length();i++) {
        // Get the next cache node
        pCacheNode = m_pCacheArray->GetNext(index);
        // pCacheNode cannot be null
        Win4Assert(pCacheNode);

        // Ask the cache node to tear down the advise connection
        error = pCacheNode->TearDownAdviseConnection(m_pDataObject);
        if(error != NOERROR)
            rerror = error;
    }

    // Reset m_pDataObject
    m_pDataObject = NULL;

    // Assert that the advise sink ref count has gone to zero
    // Win4Assert(!GetExportCount());

    return rerror;
}

//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::OnCrash, public
//
//      Synopsis:
//              Called by the default handler when the local server crashes or
//              disconnects with remote objects
//
//      Arguments:
//              none
//
//      Returns:
//              S_OK or appropriate error code
//
//	History:
//               Gopalk            Created          Dec 07, 96
//
//-----------------------------------------------------------------------------
HRESULT COleCache::OnCrash()
{
    // Validatation checks
    VDATEHEAP();
    VDATETHREAD(this);

    // Local variables
    HRESULT rerror, error;
    PCACHENODE pCacheNode;
    unsigned long index;

    // OnRun should have been called before OnCrash
    if(!m_pDataObject)
        return E_UNEXPECTED;
    
    // Reset the advise connections on the data object for 
    // each cached presentation established earlier. Gopalk
    m_pCacheArray->Reset(index);
    rerror = NOERROR;
    for(unsigned long i=0;i<m_pCacheArray->Length();i++) {
        // Get the next cache node
        pCacheNode = m_pCacheArray->GetNext(index);
        // pCacheNode cannot be null
        Win4Assert(pCacheNode);

        // Ask the cache node to reset the advise connection
        error = pCacheNode->TearDownAdviseConnection(NULL);
        if(error != NOERROR)
            rerror = error;
    }

    // Reset m_pDataObject
    m_pDataObject = NULL;

    // Discard cache
    DiscardCache(DISCARDCACHE_NOSAVE);

    // Server crashed or disconnected. Recover the references 
    // placed by the server on the cache advise sink
    CoDisconnectObject((IUnknown *) &m_AdviseSink, 0);

    // Assert that the advise sink ref count has gone to zero
    // Win4Assert(!GetExportCount());

    return rerror;
}

// IOleCache implementation

//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::Cache, public
//
//      Synopsis:
//              implementation of IOleCache::Cache
//
//              The specified presentation is cached
//
//      Arguments:
//              [lpforetcIn]  [in]  -- the presentation format to cache
//              [advf]        [in]  -- the advise control flags
//              [lpdwCacheId] [out] -- pointer to return the cache node id
//
//      Returns:
//              HRESULT
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_Cache)
STDMETHODIMP COleCache::Cache(LPFORMATETC lpforetcIn, DWORD advf, 
                              LPDWORD lpdwCacheId)
{
    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);
    VDATEREADPTRIN(lpforetcIn, FORMATETC);
    if(lpdwCacheId)
        VDATEPTROUT(lpdwCacheId, DWORD);

    // Local variables
    HRESULT error = NOERROR;
    FORMATETC foretc;
    LPCACHENODE lpCacheNode = NULL;
    DWORD dwDummyCacheId;

    // Validate parameters
    if(!HasValidLINDEX(lpforetcIn))
      return(DV_E_LINDEX);
    VERIFY_ASPECT_SINGLE(lpforetcIn->dwAspect);
    if(lpforetcIn->cfFormat)
        if(FAILED(error = CheckTymedCFCombination(lpforetcIn)))
            return error;
    if(lpforetcIn->ptd) {
    	VDATEREADPTRIN(lpforetcIn->ptd, DVTARGETDEVICE);
        if(!IsValidReadPtrIn(lpforetcIn->ptd, lpforetcIn->ptd->tdSize))
            return ResultFromScode(E_INVALIDARG);
    }

    // Initialize cache id
    if(lpdwCacheId)
        *lpdwCacheId = 0;
    else
        lpdwCacheId = &dwDummyCacheId;


    // If this aspect is frozen, don't allow creation of the cache
    if (m_dwFrozenAspects & lpforetcIn->dwAspect)
        return ResultFromScode(E_FAIL);

    // Ensure that storage has been initialized
    if(!m_pStg) {
        LEDebugOut((DEB_WARN, "Presentation being cached without storage\n"));
    }

    // Copy the FORMATETC
    foretc = *lpforetcIn;
    lpCacheNode = NULL;
    if(foretc.dwAspect != DVASPECT_ICON) {
        HRESULT hresult;

        // Convert Bitmap to DIB
        BITMAP_TO_DIB(foretc);

        if(m_ulFlags & COLECACHEF_FORMATKNOWN) {
            // We can render the native format of the cache
            hresult = IsSameAsObjectFormatEtc(&foretc, m_cfFormat);
            if(hresult == NOERROR) {
                // New format is compatible with native format. Check Ptd
                if(foretc.ptd == NULL) {
                    // We can render this format from native format
                    // Locate the native cache node
                    lpCacheNode = Locate(&foretc, lpdwCacheId);

                    // Assert that we could locate the cache node
                    Win4Assert(lpCacheNode);
                }
                else if(m_ulFlags & COLECACHEF_STATIC) {
                    // Static objects cannot have NON-NULL target device
                    return ResultFromScode(DV_E_DVTARGETDEVICE);
                }
            }
            else if(m_ulFlags & COLECACHEF_STATIC) {
                // Static objects can only cache icon aspect
                return hresult;
            }
        }
     }

    if(!lpCacheNode) {
        // The CfFormat is different from native format or Ptd is NON-NULL
        // Check if the format has already been cached
        lpCacheNode = Locate(&foretc, lpdwCacheId);
    }

    // Check if we succeeded in locating an existing cache node
    if(lpCacheNode) {
        // Update advise control flags
        if(lpCacheNode->GetAdvf() != advf) {
            // Static objects cannot have a server
            Win4Assert(!(m_ulFlags & COLECACHEF_STATIC) || !m_pDataObject);

            // If the object is running, tear down advise connection
            if(m_pDataObject)
                lpCacheNode->TearDownAdviseConnection(m_pDataObject);

            // Set the new advise flags
            lpCacheNode->SetAdvf(advf);

            //If the object is running, set up advise connection
            if(m_pDataObject)
                lpCacheNode->SetupAdviseConnection(m_pDataObject,
                             (IAdviseSink *) &m_AdviseSink);
    
            // Cache is not in loaded state now
            m_ulFlags &= ~COLECACHEF_LOADEDSTATE;
        }

        return ResultFromScode(CACHE_S_SAMECACHE);
    }

    // The CfFormat is different from native format or Ptd is NON-NULL
    // and there is no existing cache node for the given formatetc

    // ICON aspect should specify CF_METAFILEPICT CfFormat
    if(foretc.dwAspect == DVASPECT_ICON) {
        // If the format is not set, set it
        if (foretc.cfFormat == NULL) {
            foretc.cfFormat = CF_METAFILEPICT;
            foretc.tymed = TYMED_MFPICT;
        }
        else if(foretc.cfFormat != CF_METAFILEPICT)
            return ResultFromScode(DV_E_FORMATETC);
    }

    // Add cache node for this formatetc
    CCacheNode CacheNode(&foretc, advf, m_pStg);
    
    *lpdwCacheId = m_pCacheArray->AddItem(CacheNode);
    if(!(*lpdwCacheId))
        return ResultFromScode(E_OUTOFMEMORY);
    
    lpCacheNode = m_pCacheArray->GetItem(*lpdwCacheId);
    Win4Assert(lpCacheNode);
    if(lpCacheNode->IsOutOfMemory())
        return ResultFromScode(E_OUTOFMEMORY);

    // Static objects cannot have a server
    Win4Assert(!(m_ulFlags & COLECACHEF_STATIC) || !m_pDataObject);

    // If the object is running, set up advise connection so that cache
    // gets updated. Note that we might have data in the cache at the end
    // of this remote call and call on OnDataChange might occur before the
    // call completes
    if(m_pDataObject)
        lpCacheNode->SetupAdviseConnection(m_pDataObject, 
                                           (IAdviseSink *) &m_AdviseSink);

    // Cache is not in loaded state now
    m_ulFlags &= ~COLECACHEF_LOADEDSTATE;

    // Do the special handling for icon here.
    // We prerender iconic aspect by getting icon data from registration
    // data base. Note that this is extra work that can be delayed till GetData
    // or GetDataHere or Draw or Save so that the running object is given a chance
    // to render icon through the advise sink. Gopalk
    if(foretc.dwAspect == DVASPECT_ICON && lpCacheNode->IsBlank() &&
       (!IsEqualCLSID(m_clsid, CLSID_NULL) || m_pDataObject)) {
        STGMEDIUM stgmed;
        BOOL fUpdated;
        
        // Get icon data
        if(UtGetIconData(m_pDataObject, m_clsid, &foretc, &stgmed) == NOERROR) {
            // Set the data on the cache
            if(lpCacheNode->SetData(&foretc, &stgmed, TRUE, fUpdated) == NOERROR) {
                // Check if aspect has been updated
                if(fUpdated)
                    AspectsUpdated(DVASPECT_ICON);
            }
            else {
                // Set data did not release the stgmedium. Release it
                ReleaseStgMedium(&stgmed);
            }
        }
    }

    return(error);
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::Uncache, public
//
//      Synopsis:
//              implements IOleCache::Uncache
//
//              The specified presenation is uncached
//
//      Arguments:
//              [dwCacheId] [in] -- the cache node id to be deleted
//
//      Returns:
//              OLE_E_NOCONNECTION, if dwCacheId is invalid
//              S_OK
//
//      Notes:
//              The native cache is never deleted
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_Uncache)
STDMETHODIMP COleCache::Uncache(DWORD dwCacheId)
{
    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);
    
    // Local variable
    LPCACHENODE lpCacheNode = NULL;

    // Delete the cache node
    if(dwCacheId) {
        lpCacheNode = m_pCacheArray->GetItem(dwCacheId);
        if(lpCacheNode && !(lpCacheNode->IsNativeCache())) {
            // If the object is running, tear down advise connection
            if(m_pDataObject)
                lpCacheNode->TearDownAdviseConnection(m_pDataObject);

            // Delete the cache node
            m_pCacheArray->DeleteItem(dwCacheId);

            // Cache is not in loaded state now
            m_ulFlags &= ~COLECACHEF_LOADEDSTATE;

            return NOERROR;
        }
    }

    // No cache node with dwCacheId or Native Cache 
    return ResultFromScode(OLE_E_NOCONNECTION);
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::EnumCache, public
//
//      Synopsis:
//              implements IOleCache::EnumCache
//
//              returns cache enumerator
//
//      Arguments:
//              [ppenum] [out] -- a pointer to return the pointer to the
//                                enumerator
//
//      Returns:
//              E_OUTOFMEMORY, S_OK
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_EnumCache)
STDMETHODIMP COleCache::EnumCache(LPENUMSTATDATA* ppenum)
{
    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);
    VDATEPTROUT(ppenum, LPENUMSTATDATA*);

    // Initialize
    *ppenum = NULL;
    
    // Check if the cache is empty
    //if(m_pCacheArray->Length()) {
        *ppenum = CEnumStatData::CreateEnumStatData(m_pCacheArray);
        if(!(*ppenum))
            return ResultFromScode(E_OUTOFMEMORY);
    //}

    return NOERROR;
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::InitCache, public
//
//      Synopsis:
//              implements IOleCache::InitCache
//
//              initializes all cache nodes with the given data object.
//              Calls IOleCache2::UpdateCache
//
//      Arguments:
//              [lpSrcDataObj] [in] -- pointer to the source data object
//
//      Returns:
//              E_INVALIDARG, if [lpSrcDataObj] is NULL
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_InitCache)
STDMETHODIMP COleCache::InitCache(LPDATAOBJECT lpSrcDataObj)
{
    // Validataion checks
    VDATEHEAP();
    VDATETHREAD(this);
    VDATEIFACE(lpSrcDataObj);

    // Initialize the cache by calling update cache
    return UpdateCache(lpSrcDataObj, UPDFCACHE_ALLBUTNODATACACHE, NULL);
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::SetData, public
//
//      Synopsis:
//              implements IOleCache::SetData
//
//              stores data into the cache node which matches the given
//              FORMATETC
//
//      Arguments:
//              [pformatetc] [in] -- the format the data is in
//              [pmedium]    [in] -- the storage medium for the new data
//              [fRelease]   [in] -- indicates whether to release the storage
//                                   after the data is examined
//
//      Returns:
//              HRESULT
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_SetData)
STDMETHODIMP COleCache::SetData(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium, 
                                BOOL fRelease)
{
    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);
    VDATEREADPTRIN(pformatetc, FORMATETC);
    VDATEREADPTRIN(pmedium, STGMEDIUM);
    VERIFY_TYMED_SINGLE_VALID_FOR_CLIPFORMAT(pformatetc);
    if(pformatetc->ptd) {
    	VDATEREADPTRIN(pformatetc->ptd, DVTARGETDEVICE);
        if(!IsValidReadPtrIn(pformatetc->ptd, pformatetc->ptd->tdSize))
            return ResultFromScode(E_INVALIDARG);
    }

    // Local variables
    LPCACHENODE lpCacheNode;
    CLIPFORMAT cfFormat;
    HRESULT error;
    FORMATETC foretc;
    BOOL fUpdated = FALSE;

    // Check if the object is static
    if((m_ulFlags & COLECACHEF_STATIC) && (pformatetc->dwAspect != DVASPECT_ICON)) {
        // Copy the FormatEtc
        foretc = *pformatetc;

        // The given format should be same as native format
        error = IsSameAsObjectFormatEtc(&foretc, m_cfFormat);
        if(error != NOERROR)
            return error;

        // The Ptd has to be null. This prevents client from storing the data
        // in the cache that has been created for NON-NULL Ptd in 
        // COleCache::Cache(). Gopalk
        if(foretc.ptd)
            return ResultFromScode(DV_E_DVTARGETDEVICE);

        // Obtain the native cache node.
        if(!(lpCacheNode = m_pCacheArray->GetItem(1)))
            return ResultFromScode(E_OUTOFMEMORY);

        // Set data on the cache node. The native stream gets saved in 
        // COleCache::Save(). Gopalk
        error = lpCacheNode->SetData(pformatetc, pmedium, fRelease, fUpdated);

        if(SUCCEEDED(error) && m_pStg)
            error = Save(m_pStg, TRUE);  // save changes
    }
    else {
        // The obejct is either not a static object or the aspect is ICON
        lpCacheNode = Locate(pformatetc);
        
        // Set data on the cache node
        if(lpCacheNode)
            error = lpCacheNode->SetData(pformatetc, pmedium, fRelease, fUpdated);
        else
            error = ResultFromScode(OLE_E_BLANK);
    }

    if(error==NOERROR) {
        // Cache is not in loaded state now
        m_ulFlags &= ~COLECACHEF_LOADEDSTATE;

        // Inform AspectsUpdated about the updated aspect
        if(fUpdated)
            AspectsUpdated(pformatetc->dwAspect);
    }

    return error;
}


// IOleCache2 implementation

//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::UpdateCache, public
//
//      Synopsis:
//              implements IOleCache2::UpdateCache
//
//              Updates cache entries that match the given criteria with the 
//              given data object. If no data object is given, it uses the 
//              existing running data object.
//
//      Arguments:
//              [pDataObjIn] [in] -- data object to get data from. Can be NULL
//              [grfUpdf]    [in] -- update control flags
//              [pReserved]  [in] -- must be NULL
//
//      Returns:
//              HRESULT
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_UpdateCache)
STDMETHODIMP COleCache::UpdateCache(LPDATAOBJECT pDataObjIn, DWORD grfUpdf,
                                    LPVOID pReserved)
{
    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);
    if(pDataObjIn) {
        VDATEIFACE(pDataObjIn);
    }
    else if(!m_pDataObject)
        return ResultFromScode(OLE_E_NOTRUNNING);
    Win4Assert(!pReserved);


    // Local variables
    LPDATAOBJECT pDataObject;
    ULONG cntUpdatedNodes, cntTotalNodes;
    ULONG index, i;
    BOOL fUpdated;
    DWORD dwUpdatedAspects, dwAspect;
    LPCACHENODE lpCacheNode;
    HRESULT error;

    // Set the data object for use in update
    if(pDataObjIn)     
        pDataObject = pDataObjIn;
    else
        pDataObject = m_pDataObject;

    // Check if the cache is empty
    cntTotalNodes = m_pCacheArray->Length();
    if(!cntTotalNodes)
        return NOERROR;

    // Update the cache nodes including native cache. Gopalk
    m_pCacheArray->Reset(index);
    cntUpdatedNodes = 0;
    dwUpdatedAspects = 0;
    for(i=0; i<cntTotalNodes; i++) {
        // Get the next cache node
        lpCacheNode = m_pCacheArray->GetNext(index);
        // lpCacheNode cannot be null
        Win4Assert(lpCacheNode);

        // Update the cache node
        error = lpCacheNode->Update(pDataObject, grfUpdf, fUpdated);
        if(error == NOERROR) {
            cntUpdatedNodes++;
        
            // Cache is not in loaded state now
            m_ulFlags &= ~COLECACHEF_LOADEDSTATE;
            
            // Check if a new aspect has been updated
            dwAspect = lpCacheNode->GetFormatEtc()->dwAspect;
            if(fUpdated && !(dwUpdatedAspects & dwAspect))
                dwUpdatedAspects |= dwAspect;
        }
        else if(error == ResultFromScode(CACHE_S_SAMECACHE))
            cntUpdatedNodes++;            
    }
    
    // Inform AspectsUpdated about the updated aspects
    if(dwUpdatedAspects)
        AspectsUpdated(dwUpdatedAspects);

    // It is OK to have zero nodes and zero updates 
    // Return appropriate error code
    if(!cntUpdatedNodes && cntTotalNodes)
        return ResultFromScode(CACHE_E_NOCACHE_UPDATED);
    else if(cntUpdatedNodes < cntTotalNodes)
//        return ResultFromScode(CACHE_S_SOMECACHES_NOTUPDATED);
        return(NOERROR);

    return NOERROR;
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::DiscardCache, public
//
//      Synopsis:
//              implements IOleCache2::DiscardCache
//
//              Instructs the cache that its contents should be discarded;
//              the contents are optionally saved to disk before discarding.
//
//      Arguments:
//              [dwDiscardOpt] -- discard option from DISCARDCACHE_*
//
//      Returns:
//              HRESULT
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

STDMETHODIMP COleCache::DiscardCache(DWORD dwDiscardOpt)
{
    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);
    if(dwDiscardOpt != DISCARDCACHE_SAVEIFDIRTY &&
       dwDiscardOpt != DISCARDCACHE_NOSAVE)
       return ResultFromScode(E_INVALIDARG);

    // Local variable
    HRESULT error;
    ULONG index;
    LPCACHENODE lpCacheNode;

    if(dwDiscardOpt == DISCARDCACHE_SAVEIFDIRTY) {
        // There has to be a storage for saving
        if(m_pStg == NULL)
            return ResultFromScode(OLE_E_NOSTORAGE);

        // Save the cache
        error = Save(m_pStg, TRUE /* fSameAsLoad */);
        if(FAILED(error))
            return error;

        // Call save completed
        SaveCompleted(NULL);
    }

    // Discard cache nodes including the native cache node
    // What about the uncached presentations. Should they
    // be loaded from the disk. Gopalk
    m_pCacheArray->Reset(index);
    for(unsigned long i=0; i<m_pCacheArray->Length(); i++) {
        // Get the next cache node
        lpCacheNode = m_pCacheArray->GetNext(index);
        // lpCacheNode cannot be null
        Win4Assert(lpCacheNode);

        // Discard the presentation of the cache node
        lpCacheNode->DiscardPresentation();
    }

    // We make a safe assumption that the cache is in loaded state
    m_ulFlags |= COLECACHEF_LOADEDSTATE;

    return NOERROR;
}


// private IUnknown implementation

//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CCacheUnkImpl::QueryInterface, public
//
//      Synopsis:
//              implements IUnknown::QueryInterface
//
//              This provides the private IUnknown implementation when
//              COleCache is aggregated
//
//      Arguments:
//              [iid] [in]  -- IID of the desired interface
//              [ppv] [out] -- pointer to where to return the requested interface
//
//      Returns:
//              E_NOINTERFACE, if the requested interface is not available
//              S_OK
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_CCacheUnkImpl_QueryInterface)
STDMETHODIMP COleCache::CCacheUnkImpl::QueryInterface(REFIID iid, LPVOID* ppv)
{
    // Validation checks
    VDATEHEAP();
    VDATEPTROUT(ppv, LPVOID);

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_UnkPrivate);
    VDATETHREAD(pOleCache);

    // Get the requested Interface
    if(IsEqualIID(iid, IID_IUnknown) || 
       IsEqualIID(iid, IID_IOleCache) || IsEqualIID(iid, IID_IOleCache2))
        *ppv = (void *)(IOleCache2 *) pOleCache;
    else if(IsEqualIID(iid, IID_IDataObject))
        *ppv = (void *)(IDataObject *) &pOleCache->m_Data;
    else if(IsEqualIID(iid, IID_IViewObject) || IsEqualIID(iid, IID_IViewObject2))
        *ppv = (void *)(IViewObject2 *) &pOleCache->m_ViewObject;
    else if(IsEqualIID(iid, IID_IPersist) || IsEqualIID(iid, IID_IPersistStorage))
        *ppv = (void *)(IPersistStorage *) pOleCache;
    else if(IsEqualIID(iid, IID_IOleCacheControl))
        *ppv = (void *)(IOleCacheControl *) pOleCache;
    else {
        *ppv = NULL;
        return ResultFromScode(E_NOINTERFACE);
    }

    // Call addref through the interface being returned
    ((IUnknown *) *ppv)->AddRef();
    return NOERROR;
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CCacheUnkImpl::AddRef, public
//
//      Synopsis:
//              implements IUnknown::AddRef
//
//              This is part of the private IUnknown implementation of
//              COleCache used when COleCache is aggregated
//
//      Arguments:
//              none
//
//      Returns:
//              the object's reference count
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_CCacheUnkImpl_AddRef)
STDMETHODIMP_(ULONG) COleCache::CCacheUnkImpl::AddRef(void)
{
    // Validation check
    VDATEHEAP();

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_UnkPrivate);
    ULONG cRefs;
    if(!pOleCache->VerifyThreadId())
        return((ULONG) RPC_E_WRONG_THREAD);

    // AddRef parent object
    cRefs = pOleCache->SafeAddRef();

    return cRefs;
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CCacheUnkImpl::Release, public
//
//      Synopsis:
//              implements IUnknown::Release
//
//              This is part of the private IUnknown implementation of
//              COleCache used when COleCache is aggregated
//
//      Arguments:
//              none
//
//      Returns:
//              the object's reference count
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_CCacheUnkImpl_Release)
STDMETHODIMP_(ULONG) COleCache::CCacheUnkImpl::Release(void)
{
    // Validation check
    VDATEHEAP();

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_UnkPrivate);
    ULONG cRefs;
    if(!pOleCache->VerifyThreadId())
        return((ULONG) RPC_E_WRONG_THREAD);

    // Release parent object
    cRefs = pOleCache->SafeRelease();
    
    return cRefs;
}

// IDataObject implementation

//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CCacheDataImpl::QueryInterface, public
//
//      Synopsis:
//              implements IUnknown::QueryInterface
//
//      Arguments:
//              [iid] [in]  -- IID of the desired interface
//              [ppv] [out] -- pointer to where to return the requested interface
//
//      Returns:
//              E_NOINTERFACE, if the requested interface is not available
//              S_OK
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_CCacheDataImpl_QueryInterface)
STDMETHODIMP COleCache::CCacheDataImpl::QueryInterface(REFIID riid, LPVOID* ppv)
{
    // Validation check
    VDATEHEAP();

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_Data);
    VDATETHREAD(pOleCache);

    // Delegate to the outer unknown
    return pOleCache->m_pUnkOuter->QueryInterface(riid, ppv);
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CCacheDataImpl::AddRef, public
//
//      Synopsis:
//              implements IUnknown::AddRef
//
//      Arguments:
//              none
//
//      Returns:
//              the object's reference count
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_CCacheDataImpl_AddRef)
STDMETHODIMP_(ULONG) COleCache::CCacheDataImpl::AddRef (void)
{
    // Validation check
    VDATEHEAP();

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_Data);
    if(!pOleCache->VerifyThreadId())
        return((ULONG) RPC_E_WRONG_THREAD);

    // Delegate to the outer unknown
    return pOleCache->m_pUnkOuter->AddRef();
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CCacheDataImpl::Release, public
//
//      Synopsis:
//              implements IUnknown::Release
//
//      Arguments:
//              none
//
//      Returns:
//              the object's reference count
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_CCacheDataImpl_Release)
STDMETHODIMP_(ULONG) COleCache::CCacheDataImpl::Release (void)
{
    // Validation check
    VDATEHEAP();

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_Data);
    if(!pOleCache->VerifyThreadId())
        return((ULONG) RPC_E_WRONG_THREAD);

    // Delegate to the outer unknown
    return pOleCache->m_pUnkOuter->Release();
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CCacheDataImpl::GetData, public
//
//      Synopsis:
//              implements IDataObject::GetData
//
//      Arguments:
//              [pforetc] [in]  -- the format the requestor would like the data in
//              [pmedium] [out] -- where to return the storage medium to the caller
//
//      Returns:
//              OLE_E_BLANK, if the cache is empty
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_CCacheDataImpl_GetData)
STDMETHODIMP COleCache::CCacheDataImpl::GetData(LPFORMATETC pforetc, 
                                                LPSTGMEDIUM pmedium)
{
    // Validation checks
    VDATEHEAP();
    VDATEREADPTRIN(pforetc, FORMATETC);
    VERIFY_ASPECT_SINGLE(pforetc->dwAspect);
    if(pforetc->ptd) {
        VDATEREADPTRIN(pforetc->ptd, DVTARGETDEVICE);
        if(!IsValidReadPtrIn(pforetc->ptd, pforetc->ptd->tdSize))
            return ResultFromScode(E_INVALIDARG);
    }
    VDATEPTROUT(pmedium, STGMEDIUM);

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_Data);
    VDATETHREAD(pOleCache);
    
    // Local variable
    LPCACHENODE lpCacheNode;

    // Check if cache is empty
    if(!pOleCache->m_pCacheArray->Length())
        return ResultFromScode(OLE_E_BLANK);

    // Initialize storage medium
    pmedium->tymed = TYMED_NULL;
    pmedium->pUnkForRelease = NULL;

    // Locate the cache node for the given formatetc
    lpCacheNode = pOleCache->Locate(pforetc);

    // If there is no cache node, we cannot furnish the data
    if(!lpCacheNode)
        return ResultFromScode(OLE_E_BLANK);

    // Get the data from the cache node
    return(lpCacheNode->GetData(pforetc, pmedium));
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CCacheDataImpl::GetDataHere, public
//
//      Synopsis:
//              implements IDataObject::GetDataHere
//
//      Arguments:
//              [pforetc] [in]     -- the format the requestor would like the data in
//              [pmedium] [in/out] -- where to return the storage medium to the caller
//
//      Returns:
//              OLE_E_BLANK, if the cache is empty
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_CCacheDataImpl_GetDataHere)
STDMETHODIMP COleCache::CCacheDataImpl::GetDataHere(LPFORMATETC pforetc,
                                                    LPSTGMEDIUM pmedium)
{
    // Validation checks
    VDATEHEAP();
    VDATEREADPTRIN(pforetc, FORMATETC);
    VERIFY_ASPECT_SINGLE(pforetc->dwAspect);
    VERIFY_TYMED_SINGLE(pforetc->tymed);
    if(pforetc->ptd) {
        VDATEREADPTRIN(pforetc->ptd, DVTARGETDEVICE);
        if(!IsValidReadPtrIn(pforetc->ptd, pforetc->ptd->tdSize))
            return ResultFromScode(E_INVALIDARG);
    }
    VDATEPTROUT(pmedium, STGMEDIUM);

    // TYMED_MFPICT, TYMED_GDI are not allowed
    if ((pforetc->tymed == TYMED_MFPICT) || (pforetc->tymed == TYMED_GDI)
        || (pmedium->tymed != pforetc->tymed))
        return ResultFromScode(DV_E_TYMED);

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_Data);
    VDATETHREAD(pOleCache);

    // Local variable
    LPCACHENODE lpCacheNode;

    // Check if cache is empty
    if(!pOleCache->m_pCacheArray->Length())
        return ResultFromScode(OLE_E_BLANK);

    // Locate the cache node for the given formatetc
    lpCacheNode = pOleCache->Locate(pforetc);

    // If there is no cache node, we cannot furnish the data
    if(!lpCacheNode)
        return ResultFromScode(OLE_E_BLANK);

    // Get the data from the cache node
    return(lpCacheNode->GetDataHere(pforetc, pmedium));
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CCacheDataImpl::QueryGetData, public
//
//      Synopsis:
//              implements IDataObject::QueryGetData
//
//      Arguments:
//              [pforetc] [in] -- the format to check for
//
//      Returns:
//              S_FALSE, if data is not available in the requested format
//              S_OK otherwise
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_CCacheDataImpl_QueryGetData)
STDMETHODIMP COleCache::CCacheDataImpl::QueryGetData(LPFORMATETC pforetc)
{
    // Validation checks
    VDATEHEAP();
    VDATEREADPTRIN(pforetc, FORMATETC);
    VERIFY_TYMED_VALID_FOR_CLIPFORMAT(pforetc);
    if(pforetc->ptd) {
        VDATEREADPTRIN(pforetc->ptd, DVTARGETDEVICE);
        if(!IsValidReadPtrIn(pforetc->ptd, pforetc->ptd->tdSize))
            return ResultFromScode(E_INVALIDARG);
    }

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_Data);
    VDATETHREAD(pOleCache);

    // Local variable
    LPCACHENODE lpCacheNode;

    // Check if cache is empty
    if(!pOleCache->m_pCacheArray->Length())
        return ResultFromScode(S_FALSE);

    // Locate the cache node for the given formatetc
    lpCacheNode = pOleCache->Locate(pforetc);

    // If there is no cache node or if it is blank, 
    // we cannot furnish the data
    if(!lpCacheNode || lpCacheNode->IsBlank())
        return ResultFromScode(S_FALSE);

    return NOERROR;
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CCacheDataImpl::GetCanonicalFormatEtc, public
//
//      Synopsis:
//              implements IDataObject::GetCanonicalFormatEtc
//
//      Arguments:
//              [pformatetc] --
//              [pformatetcOut] --
//
//      Returns:
//              E_NOTIMPL
//
//      History:
//              11/10/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_CCacheDataImpl_GetCanonicalFormatEtc)
STDMETHODIMP COleCache::CCacheDataImpl::GetCanonicalFormatEtc(LPFORMATETC pforetcIn,
                                                              LPFORMATETC pforetcOut)
{
    // Validation check
    VDATEHEAP();

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_Data);
    VDATETHREAD(pOleCache);

    // Not implemented
    return ResultFromScode(E_NOTIMPL);
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CCacheDataImpl::SetData, public
//
//      Synopsis:
//              implements IDataObject::SetData
//
//      Arguments:
//              [pformatetc] [in] -- the format the data is in
//              [pmedium]    [in] -- the storage medium the data is on
//              [fRelease]   [in] -- release storage medium after data is copied
//
//      Returns:
//              HRESULT
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_CCacheDataImpl_SetData)
STDMETHODIMP COleCache::CCacheDataImpl::SetData(LPFORMATETC pformatetc, 
                                                LPSTGMEDIUM pmedium,
                                                BOOL fRelease)
{
    // Validation check
    VDATEHEAP();

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_Data);
    VDATETHREAD(pOleCache);

    // Call COleCache::SetData. It validates the parameters
    return pOleCache->SetData(pformatetc, pmedium, fRelease);
}

//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CCacheDataImpl::EnumFormatEtc, public
//
//      Synopsis:
//              implements IDataObject::EnumFormatEtc
//
//      Arguments:
//              [dwDirection]     [in]  -- which way to run the enumerator
//              [ppenumFormatEtc] [out] -- pointer to where the enumerator
//                                          is returned
//
//      Returns:
//              E_OUTOFMEMORY, S_OK
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_CCacheDataImpl_EnumFormatEtc)
STDMETHODIMP COleCache::CCacheDataImpl::EnumFormatEtc(DWORD dwDirection,
                                                      LPENUMFORMATETC* ppenum)
{
    // Validation checks
    VDATEHEAP();
    VDATEPTROUT(ppenum, LPENUMFORMATETC);

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_Data);
    VDATETHREAD(pOleCache);

    // Enumeration for only DATADIR_GET is implemented
    if ((dwDirection | DATADIR_GET) != DATADIR_GET)
        return ResultFromScode(E_NOTIMPL);

    // Initialize
    //*ppenum = NULL;

    // Check if the cache is empty
    //if(pOleCache->m_pCacheArray->Length()) {
        *ppenum = CEnumFormatEtc::CreateEnumFormatEtc(pOleCache->m_pCacheArray);
        if(!(*ppenum))
            return ResultFromScode(E_OUTOFMEMORY);
    //}

    return NOERROR;
}

//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CCacheDataImpl::DAdvise, public
//
//      Synopsis:
//              implements IDataObject::DAdvise
//
//      Arguments:
//              [pforetc] -- the data format the advise sink is interested in
//              [advf] -- advise control flags from ADVF_*
//              [pAdvSink] -- the advise sink
//              [pdwConnection] -- pointer to where to return the connection id
//
//      Returns:
//              OLE_E_ADVISENOTSUPPORTED
//
//      Notes:
// Defhndlr and deflink never call the following three methods. Even for App
// handlers which make use our cache implementation this is not necessary. So,
// I am making it return error.
//
//      History:
//              11/10/93 - ChrisWe - set returned connection id to 0
//              11/10/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_CCacheDataImpl_DAdvise)
STDMETHODIMP COleCache::CCacheDataImpl::DAdvise(LPFORMATETC pforetc, DWORD advf,
                                                IAdviseSink* pAdvSink,
                                                DWORD* pdwConnection)
{
    // Validation Check
    VDATEHEAP();

    // Reset connection ID
    *pdwConnection = 0;
    
    // Not implemeted
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CCacheDataImpl::DUnadvise, public
//
//      Synopsis:
//              implements IDataObject::DUnadvise
//
//      Arguments:
//              [dwConnection] -- the connection id
//
//      Returns:
//              OLE_E_NOCONNECTION
//
//      Notes:
//              See COleCache::CCacheDataImpl::DAdvise
//
//      History:
//              11/10/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
#pragma SEG(COleCache_CCacheDataImpl_DUnadvise)
STDMETHODIMP COleCache::CCacheDataImpl::DUnadvise(DWORD dwConnection)
{
    // Validation check
    VDATEHEAP();

    // Not implemented
    return ResultFromScode(OLE_E_NOCONNECTION);
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CCacheDataImpl::EnumDAdvise, public
//
//      Synopsis:
//              implements IDataObject::EnumDAdvise
//
//      Arguments:
//              [ppenumDAdvise] -- pointer to where to return the enumerator
//
//      Returns:
//              OLE_E_ADVISENOTSUPPORTED
//
//      Notes:
//              See COleCache::CCacheDataImpl::DAdvise
//
//      History:
//              11/10/93 - ChrisWe - set returned enumerator pointer to 0
//              11/10/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_CCacheDataImpl_EnumDAdvise)
STDMETHODIMP COleCache::CCacheDataImpl::EnumDAdvise(LPENUMSTATDATA* ppenumDAdvise)
{
    // Validation check
    VDATEHEAP();

    // Reset the enumerator
    *ppenumDAdvise = NULL;

    // Not implemented
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}


// IViewObject implementation

//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CCacheViewImpl::QueryInterface, public
//
//      Synopsis:
//              implements IUnknown::QueryInterface
//
//      Arguments:
//              [iid] -- IID of the desired interface
//              [ppv] -- pointer where the requested interface is returned
//
//      Returns:
//              E_NOINTERFACE, if the requested interface is not available
//              S_OK, otherwise
//
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_CCacheViewImpl_QueryInterface)
STDMETHODIMP COleCache::CCacheViewImpl::QueryInterface(REFIID riid, LPVOID* ppv)
{
    // Validation check
    VDATEHEAP();

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_ViewObject);
    VDATETHREAD(pOleCache);

    // Delegate to contolling unknown
    return pOleCache->m_pUnkOuter->QueryInterface(riid, ppv);
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CCacheViewImpl::AddRef, public
//
//      Synopsis:
//              implements IUnknown::AddRef
//
//      Arguments:
//              none
//
//      Returns:
//              the object's reference count
//
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_CCacheViewImpl_AddRef)
STDMETHODIMP_(ULONG) COleCache::CCacheViewImpl::AddRef(void)
{
    // Validation check
    VDATEHEAP();

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_ViewObject);

    // VDATETHREAD contains a 'return HRESULT' but this procedure expects to
    // return a ULONG.  Disable the warning
#if ( _MSC_VER >= 800 )
#pragma warning( disable : 4245 )
#endif
    VDATETHREAD(pOleCache);
#if ( _MSC_VER >= 800 )
#pragma warning( default: 4245 )
#endif

    // Delegate to contolling unknown
    return pOleCache->m_pUnkOuter->AddRef();
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CCacheViewImpl::Release, public
//
//      Synopsis:
//              implements IUnknown::Release
//
//      Arguments:
//              none
//
//      Returns:
//              the object's reference count
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_CCacheViewImpl_Release)
STDMETHODIMP_(ULONG) COleCache::CCacheViewImpl::Release(void)
{
    // Validation check
    VDATEHEAP();

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_ViewObject);

    // VDATETHREAD contains a 'return HRESULT' but this procedure expects to
    // return a ULONG.  Disable the warning
#if ( _MSC_VER >= 800 )
#pragma warning( disable : 4245 )
#endif
    VDATETHREAD(pOleCache);
#if ( _MSC_VER >= 800 )
#pragma warning( default : 4245 )
#endif

    // Delegate to contolling unknown
    return pOleCache->m_pUnkOuter->Release();
}

//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CCacheViewImpl::Draw, public
//
//      Synopsis:
//              implements IViewObject::Draw
//
//      Arguments:
//              [dwDrawAspect] -- a value from the DVASPECT_* enumeration
//              [lindex] -- indicates what piece of the object is of
//                      interest; legal values vary with dwDrawAspect
//              [pvAspect] -- currently NULL
//              [ptd] -- the target device
//              [hicTargetDev] -- in information context for [ptd]
//              [hdcDraw] -- device context on which drawing is to be done
//              [lprcBounds] -- boundaries of drawing on [hdcDraw]
//              [lprcWBounds] -- if hdcDraw is a meta-file, it's boundaries
//              [pfnContinue] --a callback function that the drawer should call
//                      periodically to see if rendering should be aborted.
//              [dwContinue] -- passed on into [pfnContinue]
//
//      Returns:
//              OLE_E_BLANK, if no presentation object can be found
//              REVIEW, anything from IOlePresObj::Draw
//
//      Notes:
//              This finds the presentation object in the cache for
//              the requested format, if there is one, and then passes
//              on the call to its Draw method.
//
//              The use of a callback function as a parameter means that
//              this interface cannot be remoted, unless some custom
//              proxy is built, allowing the function to be called back in its
//              original context;  the interface is defined as
//              [local] in common\types
//
//      History:
//              01/12/95 - t-ScottH- added VDATETHREAD( GETPPARENT...)
//              11/11/93 - ChrisWe - file inspection and cleanup
//              11/30/93 - alexgo  - fixed bug with GETPPARENT usage
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_CCacheViewImpl_Draw)
STDMETHODIMP NC(COleCache,CCacheViewImpl)::Draw(
	DWORD dwDrawAspect,
        LONG lindex, void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,
        HDC hicTargetDev, HDC hdcDraw,
        LPCRECTL lprcBounds,
        LPCRECTL lprcWBounds,
        BOOL (CALLBACK * pfnContinue)(ULONG_PTR),
        ULONG_PTR dwContinue)
{
    // Validation check
    VDATEHEAP();

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_ViewObject);
    VDATETHREAD(pOleCache);

    // Local variables
    BOOL bMetaDC;
    LPCACHENODE lpCacheNode; 

    // Validate parameters
    if(ptd)
        VDATEPTRIN(ptd, DVTARGETDEVICE);
    if(lprcBounds) {
        VDATEPTRIN(lprcBounds, RECTL);
    }
    else
        return E_INVALIDARG;
    if(lprcWBounds)
        VDATEPTRIN(lprcWBounds, RECTL);
    if(!hdcDraw)
	return E_INVALIDARG;
    if(!IsValidLINDEX(dwDrawAspect, lindex))
      return(DV_E_LINDEX);

    // Locate the cache node for the given draw parameters
    lpCacheNode = pOleCache->Locate(dwDrawAspect, lindex, ptd);

    // If there is no cache node, we cannot draw
    if(!lpCacheNode)
        return ResultFromScode(OLE_E_BLANK);

    // If the DC is a metafile DC then window bounds must be valid
    if((bMetaDC = OleIsDcMeta(hdcDraw)) && (lprcWBounds == NULL))
        return ResultFromScode(E_INVALIDARG);

#ifdef MAC_REVIEW

A RECT value on the MAC contains members which are 'short's'. A RECTL
uses longs, and in the code below an assumption is explicitely made
that long member values is directly comp[atible on the MAC. Naturally, this is not
the case, and the compiler will barf on this.

#endif

#ifndef WIN32   // no need to do this on WIN 32 also

    // On Win 16 make sure that the coordinates are valid 16bit quantities.
    RECT    rcBounds;
    RECT    rcWBounds;

    if (!(IS_SMALL_INT(lprcBounds->left) &&
            IS_SMALL_INT(lprcBounds->right) &&
            IS_SMALL_INT(lprcBounds->top) &&
            IS_SMALL_INT(lprcBounds->bottom)))
    {
        AssertSz(FALSE, "Rect coordinate is not a small int");
        return ReportResult(0, OLE_E_INVALIDRECT, 0, 0);

    }
    else
    {
        rcBounds.left   = (int) lprcBounds->left;
        rcBounds.right  = (int) lprcBounds->right;
        rcBounds.top    = (int) lprcBounds->top;
        rcBounds.bottom = (int) lprcBounds->bottom;
    }


    if (bMetaDC)
    {
        if (!(IS_SMALL_INT(lprcWBounds->left) &&
                IS_SMALL_INT(lprcWBounds->right) &&
                IS_SMALL_INT(lprcWBounds->top) &&
                IS_SMALL_INT(lprcWBounds->bottom)))
        {
            AssertSz(FALSE, "Rect coordinate is not a small int");
            return ReportResult(0, OLE_E_INVALIDRECT, 0, 0);
        }
        else
        {
            rcWBounds.left          = (int) lprcWBounds->left;
            rcWBounds.right         = (int) lprcWBounds->right;
            rcWBounds.top           = (int) lprcWBounds->top;
            rcWBounds.bottom        = (int) lprcWBounds->bottom;
        }
    }

    return(lpCacheNode->Draw(pvAspect, hicTargetDev, hdcDraw,
                             &rcBounds, &rcWBounds, pfnContinue, 
                             dwContinue));
#else
    // on MAC as well as win 32 we can use the same pointer as it is,
    // 'cause rect fields are 32 bit quantities
    return(lpCacheNode->Draw(pvAspect, hicTargetDev, hdcDraw,
                             lprcBounds, lprcWBounds, pfnContinue,
                             dwContinue));
#endif
}

//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CCacheViewImpl::GetColorSet, public
//
//      Synopsis:
//              implements IViewObject::GetColorSet
//
//      Arguments:
//              [dwDrawAspect] -- a value from the DVASPECT_* enumeration
//              [lindex] -- indicates what piece of the object is of
//                      interest; legal values vary with dwDrawAspect
//              [pvAspect] -- currently NULL
//              [ptd] -- the target device
//              [hicTargetDev] -- in information context for [ptd]
//              [ppColorSet] -- the color set required for the requested
//                      rendering
//
//      Returns:
//              OLE_E_BLANK, if no presentation object can be found
//              REVIEW, anything from IOlePresObj::Draw
//
//      Notes:
//              Finds a presentation object in the cache that matches the
//              requested rendering, if there is one, and asks the
//              presentation object for the color set.
//
//      History:
//              09/04/96 - Gopalk  - Modifications needed for
//                                   supporting delay loading
//                                   of cache
//              01/12/95 - t-ScottH- added VDATETHREAD( GETPPARENT...)
//              11/11/93 - ChrisWe - file inspection and cleanup
//              11/30/93 - alexgo  - fixed bug with GETPPARENT usage
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_CCacheViewImpl_GetColorSet)
STDMETHODIMP COleCache::CCacheViewImpl::GetColorSet(DWORD dwDrawAspect,
                                                    LONG lindex, void* pvAspect,
                                                    DVTARGETDEVICE* ptd,
                                                    HDC hicTargetDev,
                                                    LPLOGPALETTE* ppColorSet)
{
    // Validation check
    VDATEHEAP();

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_ViewObject);
    VDATETHREAD(pOleCache);

    // Local variables
    LPCACHENODE lpCacheNode;

    // Initialize color set
    *ppColorSet = NULL;

    // Vaidate the parameters
    if(!IsValidLINDEX(dwDrawAspect, lindex))
      return(DV_E_LINDEX);

    // Locate the cache node for the given draw parameters
    lpCacheNode = pOleCache->Locate(dwDrawAspect, lindex, ptd);

    // If there is no cache node, we cannot draw
    if(!lpCacheNode)
        return ResultFromScode(OLE_E_BLANK);

    return(lpCacheNode->GetColorSet(pvAspect, hicTargetDev, ppColorSet));
}

//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CCacheViewImpl, public
//
//      Synopsis:
//              implements IViewObject::Freeze
//
//      Arguments:
//              [dwDrawAspect] -- a value from the DVASPECT_* enumeration
//              [lindex]       -- indicates what piece of the object is of
//                                interest; legal values vary with dwDrawAspect
//              [pvAspect]     -- currently NULL
//              [pdwFreeze]    -- a token that can later be used to unfreeze
//                                this aspects cached presentations
//
//      Returns:
//              OLE_E_BLANK, if no presentation is found that matches the
//                           requested characteristics
//
//      Notes:
//              The current implementation returns the ASPECT+FREEZE_CONSTANT
//              as the FreezeID.  At Unfreeze time we get the ASPECT by doing
//              FreezeID-FREEZE_CONSTANT.
//
//              REVIEW: In future where we allow lindexes other than DEF_LINDEX,
//              we will have to use some other scheme for generating the
//              FreezeID.
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_CCacheViewImpl_Freeze)
STDMETHODIMP COleCache::CCacheViewImpl::Freeze(DWORD dwAspect, LONG lindex,
                                               LPVOID pvAspect, DWORD* pdwFreeze)
{
    // Validation check
    VDATEHEAP();

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_ViewObject);
    VDATETHREAD(pOleCache);

    // Local variables
    ULONG index, cntFrozenNodes;
    LPCACHENODE lpCacheNode;
    const FORMATETC* pforetc;

    // Validate parameters
    if(pdwFreeze) {
        VDATEPTROUT(pdwFreeze, DWORD);
        *pdwFreeze = 0;
    }
    VERIFY_ASPECT_SINGLE(dwAspect);
    if(!IsValidLINDEX(dwAspect, lindex))
        return(DV_E_LINDEX);

    // Check if the aspect has already been frozen
    if(pOleCache->m_dwFrozenAspects & dwAspect) {
        // Set the freeze id
        if(pdwFreeze)
            *pdwFreeze = dwAspect + FREEZE_CONSTANT;
        return ResultFromScode(VIEW_S_ALREADY_FROZEN);
    }

    // Freeze the cache nodes including native cache node
    pOleCache->m_pCacheArray->Reset(index);
    cntFrozenNodes = 0;
    for(unsigned long i=0; i<pOleCache->m_pCacheArray->Length(); i++) {
        lpCacheNode = pOleCache->m_pCacheArray->GetNext(index);
        pforetc = lpCacheNode->GetFormatEtc();
        if(pforetc->dwAspect == dwAspect && pforetc->lindex == lindex)
            if(lpCacheNode->Freeze() == NOERROR)
                cntFrozenNodes++;
    }

    // Check if we froze any cache nodes
    if(cntFrozenNodes) {
        // Add this aspect to the frozen aspects.
        pOleCache->m_dwFrozenAspects |= dwAspect;

        // Set the freeze id
        if(pdwFreeze)
            *pdwFreeze = dwAspect + FREEZE_CONSTANT;

        return(NOERROR);
    }

    // No cache node matched the requested characteristics
    return ResultFromScode(OLE_E_BLANK);
}

//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CCacheViewImpl::Unfreeze, public
//
//      Synopsis:
//              implements IViewObject::Unfreeze
//
//      Arguments:
//              [dwFreezeId] -- the id returned by Freeze() when some aspect
//                              was frozen earlier
//
//      Returns:
//              OLE_E_NOCONNECTION, if dwFreezeId is invalid
//              S_OK, otherwise
//
//      Notes:
//              See notes for Freeze().
//
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_CCacheViewImpl_Unfreeze)
STDMETHODIMP COleCache::CCacheViewImpl::Unfreeze(DWORD dwFreezeId)
{
    // Validation check
    VDATEHEAP();

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_ViewObject);
    VDATETHREAD(pOleCache);

    // Local variables
    BOOL fAnyUpdated = FALSE, fUpdated;
    ULONG index, cntUnfrozenNodes;
    DWORD dwAspect = dwFreezeId - FREEZE_CONSTANT;
    LONG lindex = DEF_LINDEX;
    LPCACHENODE lpCacheNode;
    const FORMATETC* pforetc;

    // Atleast one and not more than one bit should be set in dwAspect
    if(!(dwAspect && !(dwAspect & (dwAspect-1)) && (dwAspect <= MAX_VALID_ASPECT)))
        return ResultFromScode(OLE_E_NOCONNECTION);

    // Make sure that this aspect is frozen
    if (!(pOleCache->m_dwFrozenAspects & dwAspect))
        return ResultFromScode(OLE_E_NOCONNECTION);

    // Unfreeze the cache nodes including native cache node
    pOleCache->m_pCacheArray->Reset(index);
    cntUnfrozenNodes = 0;
    for(unsigned long i=0; i<pOleCache->m_pCacheArray->Length(); i++) {
        // Get the next cache node
        lpCacheNode = pOleCache->m_pCacheArray->GetNext(index);
        // lpCacheNode cannot be null
        Win4Assert(lpCacheNode);

        // Get the formatetc of the cache node
        pforetc = lpCacheNode->GetFormatEtc();
        if(pforetc->dwAspect == dwAspect && pforetc->lindex == lindex)
            if(lpCacheNode->Unfreeze(fUpdated) == NOERROR) {
                if(fUpdated)    
                    fAnyUpdated = TRUE;
                cntUnfrozenNodes++;
            }
    }

    // Check if we unfroze any cache nodes
    if(cntUnfrozenNodes) {
        // Remove this aspect from frozen aspects
        pOleCache->m_dwFrozenAspects &= ~dwAspect;
    }

    // Check if the aspect has changed
    if(fAnyUpdated)
        pOleCache->AspectsUpdated(dwAspect);

    return NOERROR;
}

//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CCacheViewImpl::SetAdvise, public
//
//      Synopsis:
//              implements IViewObject::SetAdvise
//
//      Arguments:
//              [aspects]  -- the aspects the sink would like to be advised of
//                            changes to
//              [advf]     -- advise control flags from ADVF_*
//              [pAdvSink] -- the advise sink
//
//      Returns:
//              E_INVALIDARG
//              S_OK
//
//      Notes:
//              Only one advise sink is allowed at a time.  If a second one
//              is registered, the first one is released.
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_CCacheViewImpl_SetAdvise)
STDMETHODIMP COleCache::CCacheViewImpl::SetAdvise(DWORD aspects, DWORD advf,
                                                  IAdviseSink* pAdvSink)
{
    // Validation check
    VDATEHEAP();

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_ViewObject);
    VDATETHREAD(pOleCache);

    // Validate parameters
    if(pAdvSink)
        VDATEIFACE(pAdvSink);
    if(aspects & ~(DVASPECT_CONTENT | DVASPECT_THUMBNAIL |
                   DVASPECT_ICON|DVASPECT_DOCPRINT)) {
        Win4Assert(FALSE);
        return ResultFromScode(E_INVALIDARG);
    }

    // ADVF_NODATA is not valid because there is no way to send data
    // using IAdviseSink::OnViewChange
    if(advf & ADVF_NODATA)
        return ResultFromScode(E_INVALIDARG);

    // We allow only one view advise at any given time, 
    // so Release the old sink.
    if (pOleCache->m_pViewAdvSink)
        pOleCache->m_pViewAdvSink->Release();

    // Remember the new sink
    if((pOleCache->m_pViewAdvSink = pAdvSink)) {
        // Add ref the new advise sink
        pAdvSink->AddRef();

        // Save the advice flags and aspects
        pOleCache->m_advfView = advf;
        pOleCache->m_aspectsView = aspects;

        // If ADVF_PRIMEFIRST is set, send OnViewChange immediately
        if(advf & ADVF_PRIMEFIRST) {
            pOleCache->m_pViewAdvSink->OnViewChange(aspects, DEF_LINDEX);

            // If ADVF_ONLYONCE is set, free the advise sink
            if (pOleCache->m_advfView & ADVF_ONLYONCE) {
                pOleCache->m_pViewAdvSink->Release();
                pOleCache->m_pViewAdvSink = NULL;
                pOleCache->m_advfView = 0;
                pOleCache->m_aspectsView = 0;
            }
        }
    }

    return NOERROR;
}

//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CCacheViewImpl::GetAdvise, public
//
//      Synopsis:
//              implement IViewObject::GetAdvise
//
//      Arguments:
//              [pAspects]  -- a pointer to where to return the aspects the
//                             current advise sink is interested in
//              [pAdvf]     -- a pointer to where to return the advise control
//                             flags for the current advise sink
//              [ppAdvSink] -- a pointer to where to return a reference to
//                             the current advise sink
//
//      Returns:
//              S_OK
//
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_CCacheViewImpl_GetAdvise)
STDMETHODIMP COleCache::CCacheViewImpl::GetAdvise(DWORD* pAspects, DWORD* pAdvf,
                                                  IAdviseSink** ppAdvSink)
{
    // Validation check
    VDATEHEAP();

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_ViewObject);
    VDATETHREAD(pOleCache);

    // Validate parameters
    if(ppAdvSink) {
        VDATEPTROUT(ppAdvSink, IAdviseSink*);
        *ppAdvSink = NULL;
    }
    if(pAspects) {
        VDATEPTROUT(pAspects, DWORD);
        *pAspects = 0;
    }
    if(pAdvf) {
        VDATEPTROUT(pAdvf, DWORD);
        *pAdvf = 0;
    }

    // Check if an AdviseSink is registered
    if(pOleCache->m_pViewAdvSink) {
        if(pAspects)
            *pAspects = pOleCache->m_aspectsView;
        if(pAdvf)
            *pAdvf = pOleCache->m_advfView;
        if(ppAdvSink)
            (*ppAdvSink = pOleCache->m_pViewAdvSink)->AddRef();
    }

    return NOERROR;
}

//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CCacheViewImpl::GetExtent, public
//
//      Synopsis:
//              implements IViewObject::GetExtent
//
//      Arguments:
//              [dwDrawAspect] -- the aspect for which we'd like the extent
//              [lindex]       -- the lindex for which we'd like the extent
//              [ptd]          -- pointer to the target device descriptor
//              [lpsizel]      -- pointer to where to return the extent
//
//      Returns:
//              OLE_E_BLANK, if no presentation can be found that matches
//                           (dwDrawAspect, lindex)
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_CCacheViewImpl_GetExtent)
STDMETHODIMP COleCache::CCacheViewImpl::GetExtent(DWORD dwDrawAspect,
                                                  LONG lindex,
                                                  DVTARGETDEVICE* ptd,
                                                  LPSIZEL lpsizel)
{
    // Validation check
    VDATEHEAP();

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_ViewObject);
    VDATETHREAD(pOleCache);

    // Local variable
    LPCACHENODE lpCacheNode;

    // Validate parameters
    VDATEPTROUT(lpsizel, SIZEL);
    if(!IsValidLINDEX(dwDrawAspect, lindex))
      return(DV_E_LINDEX);
    if(ptd)
        VDATEPTRIN(ptd, DVTARGETDEVICE);

    // Locate the cache node for the given draw parameters
    lpCacheNode = pOleCache->Locate(dwDrawAspect, lindex, ptd);

    // If there is no cache node, we cannot draw
    if(!lpCacheNode)
        return ResultFromScode(OLE_E_BLANK);

    return(lpCacheNode->GetExtent(dwDrawAspect, lpsizel));
}


// IPersistStorage implementation

//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::GetClassID, public
//
//      Synopsis:
//              implements IPersist::GetClassID
//
//      Arguments:
//              [pClassID] -- pointer to where to return class id
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_GetClassID)
STDMETHODIMP COleCache::GetClassID(LPCLSID pClassID)
{
    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);
    VDATEPTROUT(pClassID, CLSID);

    *pClassID = m_clsid;
    return NOERROR;
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::IsDirty, public
//
//      Synopsis:
//              implements IPersistStorage::IsDirty
//
//      Arguments:
//              none
//
//      Returns:
//              S_FALSE, if the object does not need saving
//              S_OK otherwise
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_IsDirty)
STDMETHODIMP COleCache::IsDirty(void)
{
    // Validation check
    VDATEHEAP();
    VDATETHREAD(this);

    // Local variables
    ULONG index;
    LPCACHENODE lpCacheNode;

    // Check if the cache is in loaded state
    if(!(m_ulFlags & COLECACHEF_LOADEDSTATE))
        return(NOERROR);

    // Start the enumeration of the cache nodes at the right start point
    if(m_ulFlags & COLECACHEF_STATIC)
        m_pCacheArray->Reset(index, TRUE);
    else    
        m_pCacheArray->Reset(index, FALSE);
    
    // Enumerate the cache nodes
    while(lpCacheNode = m_pCacheArray->GetNext(index))
        if(!lpCacheNode->InLoadedState()) {
            m_ulFlags &= ~COLECACHEF_LOADEDSTATE;                   
            return NOERROR;
        }

    // Cache is not dirty
    return S_FALSE;
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::InitNew, public
//
//      Synopsis:
//              implements IPersistStorage::InitNew
//
//      Arguments:
//              [pstg] -- the storage the object can use until saved
//
//      Returns:
//              S_OK
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_InitNew)
STDMETHODIMP COleCache::InitNew(LPSTORAGE pstg)
{
    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);
    VDATEIFACE(pstg);
    
    // Local variable
    LPCACHENODE lpCacheNode;

    // Check if m_pStg is already set
    if(m_pStg)
        return ResultFromScode(CO_E_ALREADYINITIALIZED);

    // Save and add ref the storage
    (m_pStg = pstg)->AddRef();

    // Find the native object format to add native cache node
    FindObjectFormat(pstg);

    // Set the storage on the already cached nodes
    if((!m_pCacheArray->GetItem(1) && m_pCacheArray->Length()) || 
       (m_pCacheArray->GetItem(1) && m_pCacheArray->Length()>1)) {
        ULONG index;

        // Enumerate the cache nodes excluding native cache node
        m_pCacheArray->Reset(index, FALSE);
        while(lpCacheNode = m_pCacheArray->GetNext(index))
            lpCacheNode->SetStg(pstg);
    }

    // Check if the native object has been successfully created
    if(m_ulFlags & COLECACHEF_FORMATKNOWN) {
        // Obtain the native cache node.
        if(!(lpCacheNode = m_pCacheArray->GetItem(1)))
            return ResultFromScode(E_OUTOFMEMORY);

        // Static objects cannot have a server
        if(m_ulFlags & COLECACHEF_STATIC)
            Win4Assert(!m_pDataObject);

        // Check if native cache node has just been created 
        if(!lpCacheNode->GetStg()) {
            // Set the storage for the native cache node
            lpCacheNode->SetStg(pstg);
            
            // Set up the advise connection if the object is already running
            if(m_pDataObject)
                lpCacheNode->SetupAdviseConnection(m_pDataObject, 
                                             (IAdviseSink *) &m_AdviseSink);
        }
    }

    // The spec for InitNew requires that the object should be marked dirty
    // See Nt bug 284729.
    m_ulFlags &= ~COLECACHEF_LOADEDSTATE;   

    return NOERROR;
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::Load, public
//
//      Synopsis:
//              Called by DefHandler and DefLink when cache is empty
//
//      Arguments:
//              [pstg]        [in] -- the storage to load from
//              [fCacheEmpty] [in] -- Set to TRUE when cache is empty
//
//      Returns:
//              HRESULT
//
//	History:
//               Gopalk            Creation        Oct 24, 96
//
//-----------------------------------------------------------------------------
HRESULT COleCache::Load(LPSTORAGE pstg, BOOL fCacheEmpty)
{
    // Check if m_pStg is already set
    if(m_pStg)
        return ResultFromScode(CO_E_ALREADYINITIALIZED);

    // If Cache is not empty, follow normal load
    if(!fCacheEmpty)
        return Load(pstg);
    else {
        // Validation checks
        VDATEHEAP();
        VDATETHREAD(this);
        VDATEIFACE(pstg);

        // Save the storage
        (m_pStg = pstg)->AddRef();

        // Assert that there is no native cache node
        Win4Assert(!m_pCacheArray->GetItem(1));

        // Set the storage on the already cached nodes
        if(m_pCacheArray->Length()) {
            ULONG index;
            LPCACHENODE lpCacheNode;

            // Enumerate the cache nodes including native cache node
            m_pCacheArray->Reset(index);
            while(lpCacheNode = m_pCacheArray->GetNext(index))
                lpCacheNode->SetStg(pstg);
        }
        else  {
            // Cache is in loaded state
            m_ulFlags |= COLECACHEF_LOADEDSTATE;
        }
    }

#if DBG==1
    // Ensure that the storage is really empty in Debug builds
    HRESULT error;
    LPSTREAM lpstream;

    error = pstg->OpenStream(OLE_PRESENTATION_STREAM, NULL, 
                             (STGM_READ | STGM_SHARE_EXCLUSIVE),
                             0, &lpstream);
    Win4Assert(error==STG_E_FILENOTFOUND);
#endif // DBG==1

    return NOERROR;
}

//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::Load, public
//
//      Synopsis:
//              implements IPersistStorage::Load
//
//      Arguments:
//              [pstg] -- the storage to load from
//
//      Returns:
//              Various storage errors and S_OK
//
//      Notes:
//              Presentations are loaded from sequentially numbered
//              streams, stopping at the first one that cannot be found.
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_Load)
STDMETHODIMP COleCache::Load(LPSTORAGE pstg)
{
    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);
    VDATEIFACE(pstg);

    // Local variables
    CLSID clsid;
    HRESULT error = NOERROR;
    BOOL fCachedBefore = FALSE, fCachesLoaded = FALSE;
    ULONG ulLastIndex = 0;
    LPCACHENODE lpCacheNode;

    // Check if m_pStg is already set
    if(m_pStg)
        return ResultFromScode(CO_E_ALREADYINITIALIZED);

    // Save the storage
    m_pStg = pstg;

    // Find the native object format
    FindObjectFormat(pstg);

    // Set the storage on the already cached nodes
    if((!m_pCacheArray->GetItem(1) && m_pCacheArray->Length()) || 
       (m_pCacheArray->GetItem(1) && m_pCacheArray->Length()>1)) {
        // Presentations were cached before load
        Win4Assert(FALSE);
        fCachedBefore = TRUE;

        // Enumerate the cache nodes excluding native cache node
        m_pCacheArray->Reset(ulLastIndex, FALSE);
        while(lpCacheNode = m_pCacheArray->GetNext(ulLastIndex))
            lpCacheNode->SetStg(pstg);
    }

    // Check if the native object is a static object
    if(m_ulFlags & COLECACHEF_STATIC) {
        UINT uiStatus;

        // Static objects cannot have a server
        Win4Assert(!m_pDataObject);

        // Old static objects wrote data into the OLE_PRESENTATION_STREAM
        // rather than the CONTENTS stream.
        // If we have such a static object, we need to convert it
        error = UtOlePresStmToContentsStm(pstg, OLE_PRESENTATION_STREAM,
                                          TRUE, &uiStatus);
        Win4Assert(error==NOERROR);
        if(error != NOERROR)
            return error;
    }
    
    if(m_ulFlags & COLECACHEF_FORMATKNOWN) {
        // Obtain the native cache node.
        if(!(lpCacheNode = m_pCacheArray->GetItem(1)))
            return ResultFromScode(E_OUTOFMEMORY);

        // Check if native cache node has just been created 
        if(!lpCacheNode->GetStg()) {
            // Set the storage for the native cache node
            lpCacheNode->SetStg(pstg);
            
            // Set up the advise connection if the object is already running
            if(m_pDataObject)
                lpCacheNode->SetupAdviseConnection(m_pDataObject, 
                                             (IAdviseSink *) &m_AdviseSink);
        }

        // Ensure that native cache node is not blank before
        // delay loading the presentation from native stream
        if(lpCacheNode->IsBlank())
            lpCacheNode->Load(NULL, OLE_INVALID_STREAMNUM, TRUE);
    }

    if(error == NOERROR) {
        int iPresStreamNum=0;
        ULONG index;
        LPSTREAM lpstream;
        OLECHAR szName[sizeof(OLE_PRESENTATION_STREAM)/sizeof(OLECHAR)];
        CCacheNode BlankCache;

        // Start with presentation stream 0
        lstrcpyW(szName, OLE_PRESENTATION_STREAM);

        // Load the presentation streams
        while(TRUE) {
            // Open the presentation stream
            lpstream = NULL;
            error = pstg->OpenStream(szName, NULL, (STGM_READ | STGM_SHARE_EXCLUSIVE),
                                     0, &lpstream);
            if(error != NOERROR) {            
                if(GetScode(error) == STG_E_FILENOTFOUND) {
                    // Presentation stream does not exist. No error
                    error = NOERROR;
                }
                break;
            }

            // Presentation stream exists. Add a blank cache node 
            index = m_pCacheArray->AddItem(BlankCache);
            if(!index) {
                error = ResultFromScode(E_OUTOFMEMORY);
                break;
            }
            lpCacheNode = m_pCacheArray->GetItem(index);
            Win4Assert(lpCacheNode);

            // Load the presentation from the stream
            if(!iPresStreamNum) {
                // Do not delay load presentation
                error = lpCacheNode->Load(lpstream, iPresStreamNum, FALSE);
                if(error == NOERROR)
                    fCachesLoaded = TRUE;
            }
            else {
                // Delay load the presentation
                error = lpCacheNode->Load(lpstream, iPresStreamNum, TRUE);
            }
            if(error != NOERROR)
                break;

            // Set the storage on the cache node
            lpCacheNode->SetStg(pstg);

            // If the server is runinng, set the advise connection
            // We ignore the errors in setting up advise connection. Gopalk
            if(m_pDataObject)
                lpCacheNode->SetupAdviseConnection(m_pDataObject, 
                                                   (IAdviseSink *) &m_AdviseSink);
                    
            // Check if TOC exists at the end of presentation stream 0
            if(!iPresStreamNum)
                if(LoadTOC(lpstream, pstg) == NOERROR)
                    break;
               
            // Release the stream
            lpstream->Release();
            lpstream = NULL;

            // Get the next presentation stream name
            UtGetPresStreamName(szName, ++iPresStreamNum);
        }
        
        if(lpstream)
            lpstream->Release();
        lpstream = NULL;
    }

    if(error == NOERROR) {
        // Addref the storage
        m_pStg->AddRef();

        // For static object remove all the caches other than those with 
        // iconic aspect
        if(m_ulFlags & COLECACHEF_STATIC) {
            ULONG index, indexToUncache = 0;
            const FORMATETC* lpforetc;

            // Start the enumeration after native cache node
            m_pCacheArray->Reset(index, FALSE);
            while(lpCacheNode = m_pCacheArray->GetNext(index)) {
                lpforetc = lpCacheNode->GetFormatEtc();
                if(lpforetc->dwAspect != DVASPECT_ICON) {
                    // Uncache any previous index that needs to be uncached
                    if(indexToUncache)
                        Uncache(indexToUncache);
                    
                    // Remember the new index that needs to be uncached
                    indexToUncache = index;
                }
            }

            // Uncache any remaining index that needs to be uncached
            if(indexToUncache)
                Uncache(indexToUncache);
        }

        // Check if presentation were cached before load
        if(fCachedBefore) {            
            // Check if any presentation were loaded from disk
            if(fCachesLoaded) {
                // Shift the newly cached nodes to the end
                // This is needed to allow presentation
                // streams to be renamed during save 
                m_pCacheArray->ShiftToEnd(ulLastIndex);
            }
        }
        else {
            // Cache is in loaded state
            m_ulFlags |= COLECACHEF_LOADEDSTATE;
        }
    }
    else {
        if(m_pDataObject) {
            ULONG index;

            // Tear down the advise connection set up earlier
            m_pCacheArray->Reset(index);
            while(lpCacheNode = m_pCacheArray->GetNext(index))
                lpCacheNode->TearDownAdviseConnection(m_pDataObject);
        }

        // Delete all cache nodes
        m_pCacheArray->DeleteAllItems();

        // Reset the storage
        m_pStg = NULL;
    }

    return error;
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::Save, public
//
//      Synopsis:
//              implements IPersistStorage::Save
//
//      Arguments:
//              [pstgSave] -- the storage to use to save this
//              [fSameAsLoad] -- is this the same storage we loaded from?
//
//      Returns:
//              Various storage errors
//
//      Notes:
//              All the caches are saved to streams with sequential numeric
//              names.  Also TOC is saved at the end of presentation 0
//
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_Save)
STDMETHODIMP COleCache::Save(LPSTORAGE pstgSave, BOOL fSameAsLoad)
{
    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);
    VDATEIFACE(pstgSave);

    // Local variables    
    HRESULT error, rerror = NOERROR;
    ULONG index, cntCachesNotSaved;
    int iPresStreamNum;
    LPCACHENODE lpCacheNode;

    // Check if we are in no scribble mode
    // According to spec, SaveCompleted be should after Save to reset
    // NOSCRIBBLEMODE. Insisting on the spec is causing some apps
    // like ClipArt Gallery to break. Turn off the check. Gopalk
    //if(m_ulFlags & COLECACHEF_NOSCRIBBLEMODE)
    //    return E_UNEXPECTED;

    // If fSameAsLoad, assert that the current storage is same as given storage
    // Some apps will violate this assert because for SaveAs case, they copy the
    // existing storage to a new storage and call save on the new storage with
    // fSameAsLoad set to TRUE. They subsequently either call SaveCompleted with
    // the new storage or call SaveCompleted with NULL storage, HandsOffStorage,
    // and SaveCompleted with the new storage in sequence. Gopalk
    if(fSameAsLoad)
        Win4Assert(m_pStg==pstgSave);

    // Cache need not be saved if fSameAsLoad and not dirty
    if(!fSameAsLoad || IsDirty()==NOERROR) {
        // Reset the stream number
        iPresStreamNum = 0;

        // Check if the cache is empty
        if(m_pCacheArray->Length()) {
            // Cache is not empty

            // Save the native cache node only if it is a static object
            if(m_ulFlags & COLECACHEF_STATIC) {
                lpCacheNode = m_pCacheArray->GetItem(1);
                Win4Assert(lpCacheNode);
                lpCacheNode->Save(pstgSave, fSameAsLoad, OLE_INVALID_STREAMNUM);
            }

            // Enumerate the cache nodes excluding the native cache node
            m_pCacheArray->Reset(index, FALSE);
            while(lpCacheNode = m_pCacheArray->GetNext(index)) {
                // Save the cache node
                error = lpCacheNode->Save(pstgSave, fSameAsLoad, iPresStreamNum);

                // Update state information
                if(error == NOERROR)
                    ++iPresStreamNum;
                else
                    rerror = error;
            }

            // Save table of contents at the end of first pres stream
            if(rerror == NOERROR)
                SaveTOC(pstgSave, fSameAsLoad);

            if (m_ulFlags & COLECACHEF_APICREATE) {     // NT bug 281051
                DWORD dwFlags;
                if (S_OK == ReadOleStg(pstgSave,&dwFlags,NULL,NULL,NULL,NULL)){
                    WriteOleStgEx(pstgSave, NULL, NULL, 
                                (dwFlags & ~OBJFLAGS_CACHEEMPTY),
                                NULL ) ;
                }
            }
        }

        // Remove any extra presentation streams left
        // Due to streams getting renamed above, the streams left behind may not
        // be contiguous in XXXX where XXXX is \2OlePresXXXX. Consequently, we
        // may not get rid of all extra pres streams below. Gopalk
        UtRemoveExtraOlePresStreams(pstgSave, iPresStreamNum);
    }
    
    // Update flags
    if(rerror == NOERROR) {
        m_ulFlags |= COLECACHEF_NOSCRIBBLEMODE;
        if (fSameAsLoad)
            m_ulFlags |= COLECACHEF_SAMEASLOAD;
        else
            m_ulFlags &= ~COLECACHEF_SAMEASLOAD;
    }

    return rerror;
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::SaveCompleted, public
//
//      Synopsis:
//              implements IPersistStorage::SaveCompleted
//
//      Arguments:
//              [pstgNew] -- NULL, or a pointer to a new storage
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_SaveCompleted)
STDMETHODIMP COleCache::SaveCompleted(LPSTORAGE pStgNew)
{
    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);
    if(pStgNew)
        VDATEIFACE(pStgNew);
    if(!(m_ulFlags & (COLECACHEF_NOSCRIBBLEMODE | COLECACHEF_HANDSOFSTORAGE)))
        return E_UNEXPECTED;
    if(m_ulFlags & COLECACHEF_HANDSOFSTORAGE && !pStgNew)
        return E_INVALIDARG;
        
    // Local variables
    ULONG index;
    LPCACHENODE lpCacheNode;

    // Remember the new storage

    if (pStgNew || (m_ulFlags & COLECACHEF_SAMEASLOAD)) {
        m_ulFlags &= ~COLECACHEF_SAMEASLOAD;
        if (pStgNew) {
            if(m_pStg)
                m_pStg->Release();

            m_pStg = pStgNew;
            m_pStg->AddRef();
        }

        if (m_ulFlags & COLECACHEF_NOSCRIBBLEMODE) {
            // Enumerate the cache nodes starting with native cache node
            m_pCacheArray->Reset(index);

            for(unsigned long i=0;i<m_pCacheArray->Length();i++) {
                // Get the next cache node
                lpCacheNode = m_pCacheArray->GetNext(index);
                // pCacheNode cannot be null
                Win4Assert(lpCacheNode);
                // Call savecompleted method of the cache node
                lpCacheNode->SaveCompleted(pStgNew);
            }
            //The next line clears dirty flag effectively.
            //Had to move it here from Save to keep apps from breaking.
            m_ulFlags |= COLECACHEF_LOADEDSTATE;
        }
    }

    // Reset flags
    m_ulFlags &= ~COLECACHEF_NOSCRIBBLEMODE;
    m_ulFlags &= ~COLECACHEF_HANDSOFSTORAGE;

    return NOERROR;
}

//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::HandsOffStorage, public
//
//      Synopsis:
//              implements IPersistStorage::HandsOffStorage
//
//      Arguments:
//              none
//
//      Returns:
//              S_OK
//
//
//	History:
//               Gopalk            Rewritten        Sep 04, 96
//
//-----------------------------------------------------------------------------

#pragma SEG(COleCache_HandsOffStorage)
STDMETHODIMP COleCache::HandsOffStorage(void)
{
    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);
    if(!m_pStg) {
        // The following Win4Assert is getting fired in Liveness tests
        // Win4Assert(FALSE);
        return E_UNEXPECTED;
    }

    // Local variables
    ULONG index;
    LPCACHENODE lpCacheNode;

    // Enumerate the cache nodes starting with native cache node
    m_pCacheArray->Reset(index);
    for(unsigned long i=0;i<m_pCacheArray->Length();i++) {
        // Get the next cache node
        lpCacheNode = m_pCacheArray->GetNext(index);
        // lpCacheNode cannot be null
        Win4Assert(lpCacheNode);
        
        // Get the formatetc of the cache node
        lpCacheNode->HandsOffStorage();
    }

    // Release the current storage
    m_pStg->Release();
    m_pStg = NULL;

    // Set COLECACHEF_HANDSOFSTORAGE flag
    m_ulFlags |= COLECACHEF_HANDSOFSTORAGE;

    return NOERROR;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		COleCache::Locate, private
//
//	Synopsis:
//		Locates the cache node with the given FORMATETC
//
//	Arguments:
//		[foretc][in]       -- FormatEtc of the desired cache node
//              [lpdwCacheId][out] -- CacheId of the found cache node 
//                            
//
//	Returns:
//		Pointer to the found cache node on success
//              NULL otherwise
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
LPCACHENODE COleCache::Locate(LPFORMATETC lpGivenForEtc, DWORD* lpdwCacheId)
{
    // New data type
    typedef enum tagFormatType {
        // These values are defined in order of least to best preferred, so that
        // numeric comparisons are valid; DO NOT REORDER
        FORMATTYPE_NONE = 0,
        FORMATTYPE_ANY,
        FORMATTYPE_ENHMF,
        FORMATTYPE_DIB,
        FORMATTYPE_MFPICT,
        FORMATTYPE_USER
    } FormatType;

    // Local variables
    ULONG index, savedIndex;
    FormatType CurrFormatType;
    FormatType BestFormatType;
    LPFORMATETC lpCurrentForEtc;
    LPCACHENODE lpCacheNode;

    // Start the enumeration including the native cache
    m_pCacheArray->Reset(index);
    BestFormatType = FORMATTYPE_NONE;
    savedIndex = 0;
    for(unsigned long i=0;i<m_pCacheArray->Length();i++) {
        // Get the next cache node
        lpCacheNode = m_pCacheArray->GetNext(index);
        // pCacheNode cannot be null
        Win4Assert(lpCacheNode);
        
        // Get the formatetc of the cache node
        lpCurrentForEtc = (FORMATETC *) lpCacheNode->GetFormatEtc();
    
        // Obtain the Formattype of the current node
        if(lpCurrentForEtc->cfFormat == 0)
            CurrFormatType = FORMATTYPE_ANY;
        else if(lpCurrentForEtc->cfFormat == lpGivenForEtc->cfFormat)
            CurrFormatType = FORMATTYPE_USER;
        else if(lpCurrentForEtc->cfFormat == CF_DIB && 
                lpGivenForEtc->cfFormat == CF_BITMAP)
            CurrFormatType = FORMATTYPE_USER;
        else if(lpCurrentForEtc->cfFormat == CF_ENHMETAFILE)
            CurrFormatType = FORMATTYPE_ENHMF;
        else if(lpCurrentForEtc->cfFormat == CF_DIB)
            CurrFormatType = FORMATTYPE_DIB;
        else if(lpCurrentForEtc->cfFormat == CF_METAFILEPICT)
            CurrFormatType = FORMATTYPE_MFPICT;
        else
            CurrFormatType = FORMATTYPE_NONE;

        // Check if the cache node is better than any we have seen so far
        if(CurrFormatType > BestFormatType)
            if(lpCurrentForEtc->dwAspect == lpGivenForEtc->dwAspect)
                if(lpCurrentForEtc->lindex == lpGivenForEtc->lindex)
                    if(lpCurrentForEtc->ptd==lpGivenForEtc->ptd || 
                       UtCompareTargetDevice(lpCurrentForEtc->ptd, lpGivenForEtc->ptd)) {
                        BestFormatType = CurrFormatType;
                        savedIndex = index;
                        if(BestFormatType == FORMATTYPE_USER)
                            break;
                    }
    }
    
    // Handle the case when there is no matching cache node
    if((lpGivenForEtc->cfFormat && BestFormatType != FORMATTYPE_USER) ||
       (!lpGivenForEtc->cfFormat && BestFormatType == FORMATTYPE_NONE)) {
        if(lpdwCacheId)
            *lpdwCacheId = 0;
        return NULL;            
    }

    // There is a matching cache node
    lpCacheNode = m_pCacheArray->GetItem(savedIndex);
    Win4Assert(lpCacheNode);
    if(lpdwCacheId)
        *lpdwCacheId = savedIndex;

    return lpCacheNode;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		COleCache::Locate, private
//
//	Synopsis:
//		Locates the cache node with the given FORMATETC
//
//	Arguments:
//		[dwAspect][in] -- Aspect of the desired cache node
//              [lindex]  [in] -- Lindex of the desired cache node 
//              [ptd]     [in] -- Target device of the desired cache node
//
//	Returns:
//		Pointer to the found cache node on success
//              NULL otherwise
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
LPCACHENODE COleCache::Locate(DWORD dwAspect, LONG lindex, DVTARGETDEVICE* ptd)
{
    // New data type
    typedef enum tagFormatType {
        // These values are defined in order of least to best preferred, so that
        // numeric comparisons are valid; DO NOT REORDER
        FORMATTYPE_NONE = 0,
        FORMATTYPE_DIB,
        FORMATTYPE_MFPICT,
        FORMATTYPE_ENHMF
    } FormatType;

    // Local variables
    ULONG index, savedIndex;
    FormatType CurrFormatType;
    FormatType BestFormatType;
    LPFORMATETC lpCurrentForEtc;
    LPCACHENODE lpCacheNode;

    // Start the enumeration including the native cache
    m_pCacheArray->Reset(index);
    BestFormatType = FORMATTYPE_NONE;
    savedIndex = 0;
    for(unsigned long i=0;i<m_pCacheArray->Length();i++) {
        // Get the next cache node
        lpCacheNode = m_pCacheArray->GetNext(index);
        // pCacheNode cannot be null
        Win4Assert(lpCacheNode);
        
        // Get the formatetc of the cache node
        lpCurrentForEtc = (FORMATETC *) lpCacheNode->GetFormatEtc();
    
        // Obtain the Formattype of the current node
        if(lpCurrentForEtc->cfFormat == CF_ENHMETAFILE)
            CurrFormatType = FORMATTYPE_ENHMF;
        else if(lpCurrentForEtc->cfFormat == CF_METAFILEPICT)
            CurrFormatType = FORMATTYPE_MFPICT;
        else if(lpCurrentForEtc->cfFormat == CF_DIB)
            CurrFormatType = FORMATTYPE_DIB;
        else
            CurrFormatType = FORMATTYPE_NONE;

        // Check if the cache node is better than any we have seen so far
        if(CurrFormatType > BestFormatType)
            if(lpCurrentForEtc->dwAspect == dwAspect)
                if(lpCurrentForEtc->lindex == lindex)
                    if(lpCurrentForEtc->ptd==ptd ||
                       UtCompareTargetDevice(lpCurrentForEtc->ptd, ptd)) {
                        BestFormatType = CurrFormatType;
                        savedIndex = index;
                        if(BestFormatType == FORMATTYPE_ENHMF)
                            break;
                    }
    }
    
    // Handle the case when there is no matching cache node
    if(BestFormatType == FORMATTYPE_NONE)
        return NULL;

    // There is a matching cache node
    lpCacheNode = m_pCacheArray->GetItem(savedIndex);
    Win4Assert(lpCacheNode);

    return lpCacheNode;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		COleCache::CAdviseSinkImpl::QueryInterface private
//
//      Synopsis:
//              implements IUnknown::QueryInterface
//
//      Arguments:
//              [iid] [in]  -- IID of the desired interface
//              [ppv] [out] -- pointer to where to return the requested interface
//
//      Returns:
//              E_NOINTERFACE if the requested interface is not available
//              NOERROR otherwise
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
STDMETHODIMP COleCache::CAdviseSinkImpl::QueryInterface(REFIID riid, LPVOID* ppv)
{
    // Validation check
    VDATEHEAP();

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_AdviseSink);
    VDATETHREAD(pOleCache);
 
    // Get the requested Interface
    if(IsEqualIID(riid, IID_IUnknown))
        *ppv = (void *)(IUnknown *) this;
    else if(IsEqualIID(riid, IID_IAdviseSink))
        *ppv = (void *)(IAdviseSink *) this;
    else {
        *ppv = NULL;
        return ResultFromScode(E_NOINTERFACE);
    }

    // Call addref through the interface being returned
    ((IUnknown *) *ppv)->AddRef();
    return NOERROR;
}


//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CAdviseSinkImpl::AddRef, private
//
//      Synopsis:
//              implements IUnknown::AddRef
//
//      Arguments:
//              none
//
//      Returns:
//              the object's reference count
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COleCache::CAdviseSinkImpl::AddRef(void)
{
    // Validation check
    VDATEHEAP();

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_AdviseSink);
    ULONG cExportCount;
    if(!pOleCache->VerifyThreadId())
        return((ULONG) RPC_E_WRONG_THREAD);

    // Increment export count
    cExportCount = pOleCache->IncrementExportCount();

    // Addref the parent object
    return cExportCount;
}

//+----------------------------------------------------------------------------
//
//      Member:
//              COleCache::CAdviseSinkImpl::Release, private
//
//      Synopsis:
//              implements IUnknown::Release
//
//      Arguments:
//              none
//
//      Returns:
//              the object's reference count
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COleCache::CAdviseSinkImpl::Release(void)
{
    // Validation check
    VDATEHEAP();

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_AdviseSink);
    ULONG cExportCount;
    if(!pOleCache->VerifyThreadId())
        return((ULONG) RPC_E_WRONG_THREAD);

    // Decrement export count.
    cExportCount = pOleCache->DecrementExportCount();

    return cExportCount;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		COleCache::CAdviseSinkImpl::OnDataChange, private
//
//	Synopsis:
//		The methods looks up cache node representing the given formatetc
//              calls set data on it.
//
//	Arguments:
//		[lpForetc] [in] -- the format of the new data
//		[lpStgmed] [in] -- the storage medium of the new data
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(void) COleCache::CAdviseSinkImpl::OnDataChange(LPFORMATETC lpForetc, 
                                                             LPSTGMEDIUM lpStgmed)
{
    // Validation checks
    VDATEHEAP();
    if(!IsValidPtrIn(lpForetc, sizeof(FORMATETC)))
        return;
    if(!IsValidPtrIn(lpStgmed, sizeof(STGMEDIUM)))
        return;

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_AdviseSink);    
    if(!pOleCache->VerifyThreadId())
        return;
    if(pOleCache->IsZombie())
        return;

    // Local variables
    LPCACHENODE lpCacheNode;
    BOOL fUpdated;
    HRESULT error;

    // Locate the cache node representing the formatetc
    lpCacheNode = pOleCache->Locate(lpForetc);
    Win4Assert(lpCacheNode);
    if(lpCacheNode && lpStgmed->tymed!=TYMED_NULL) {
        error = lpCacheNode->SetData(lpForetc, lpStgmed, FALSE, fUpdated);

        if(error == NOERROR) {
            // Cache is not in loaded state now
            pOleCache->m_ulFlags &= ~COLECACHEF_LOADEDSTATE;

            // Inform AspectsUpdated about the updated aspect
            if(fUpdated)
                pOleCache->AspectsUpdated(lpForetc->dwAspect);
        }
    }

    return;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		COleCache::CAdviseSinkImpl::OnViewChange, private
//
//	Synopsis:
//              This function should not get called
//
//	Arguments:
//		[aspect] [in] -- Aspect whose view has changed
//		[lindex] [in] -- Lindex of the aspect that has changed
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(void) COleCache::CAdviseSinkImpl::OnViewChange(DWORD aspect, LONG lindex)
{
    // Validation check
    VDATEHEAP();

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_AdviseSink);
    if(!pOleCache->VerifyThreadId())
        return;

    // There function should not get called
    Win4Assert(FALSE);

    return;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		COleCache::CAdviseSinkImpl::OnRename, private
//
//	Synopsis:
//              This function should not get called
//
//	Arguments:
//		[pmk] [in] -- New moniker
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(void) COleCache::CAdviseSinkImpl::OnRename(IMoniker* pmk)
{
    // Validation check
    VDATEHEAP();
    if(!IsValidInterface(pmk))
        return;

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_AdviseSink);
    if(!pOleCache->VerifyThreadId())
        return;

    // There function should not get called
    Win4Assert(FALSE);

    return;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		COleCache::CAdviseSinkImpl::OnSave, private
//
//	Synopsis:
//              This function should not get called
//
//	Arguments:
//              NONE
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(void) COleCache::CAdviseSinkImpl::OnSave()
{
    // Validation check
    VDATEHEAP();

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_AdviseSink);
    if(!pOleCache->VerifyThreadId())
        return;

    // There function should not get called
    Win4Assert(FALSE);

    return;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		COleCache::CAdviseSinkImpl::OnClose, private
//
//	Synopsis:
//              This function should not get called
//
//	Arguments:
//              NONE
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(void) COleCache::CAdviseSinkImpl::OnClose()
{
    // Validation check
    VDATEHEAP();

    // Get the parent object
    COleCache* pOleCache = GETPPARENT(this, COleCache, m_AdviseSink);
    if(!pOleCache->VerifyThreadId())
        return;

    // There function should not get called
    Win4Assert(FALSE);

    return;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		COleCache::LoadTOC, private
//
//	Synopsis:
//              Loads the Table Of Contents from the given stream
//
//	Arguments:
//              lpStream    [in] - Stream from which TOC is to be loaded
//              lpZeroCache [in] - CacheNode representing presentation stream 0
//
//      Returns:
//              NOERROR if TOC was found and successfully loaded
//              else appropriate error
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
HRESULT COleCache::LoadTOC(LPSTREAM lpStream, LPSTORAGE pStg)
{
    // Local variables
    HRESULT error;
    int iPresStm=1;
    DWORD dwBuf[2];
    ULONG ulBytesRead, *TOCIndex, NumTOCAdded;
    LPCACHENODE lpNativeCache, lpCacheNode;
    CLIPFORMAT cfFormat;

    // Read TOC header
    error = lpStream->Read(dwBuf, sizeof(dwBuf), &ulBytesRead);
    if(ulBytesRead==sizeof(dwBuf) && dwBuf[0]==TOCSIGNATURE) {
        // TOC exists in presentation stream 0
        
        // Initialize
        error = NOERROR;
        NumTOCAdded = 0;
        if(dwBuf[1]) {
            CCacheNode BlankCache;

            TOCIndex = new unsigned long[dwBuf[1]];
            if(TOCIndex) {
                // Load TOC entries into new cache nodes
                while(NumTOCAdded < dwBuf[1]) {
                    // Add a blank cache node 
                    TOCIndex[NumTOCAdded] = m_pCacheArray->AddItem(BlankCache);
                    if(!TOCIndex[NumTOCAdded]) {
                        error = ResultFromScode(E_OUTOFMEMORY);
                        break;
                    }
                    lpCacheNode = m_pCacheArray->GetItem(TOCIndex[NumTOCAdded]);
                    Win4Assert(lpCacheNode);
                    ++NumTOCAdded;

                    // Load TOC entry from the stream
                    error = lpCacheNode->LoadTOCEntry(lpStream, iPresStm);
                    if(error != NOERROR)
                        break;

                    // Check if this is the first native TOC
                    if(NumTOCAdded == 1 && lpCacheNode->IsNativeCache()) {
                        cfFormat = lpCacheNode->GetFormatEtc()->cfFormat;
                        lpNativeCache = m_pCacheArray->GetItem(1);
                        if(lpNativeCache && (cfFormat==m_cfFormat)) {
                            // Both native cfFormats match. 
                            // Delete the new native cache node
                            m_pCacheArray->DeleteItem(TOCIndex[NumTOCAdded-1]);
                            continue;
                        }
                        else {
                            // Either native cache does not exist or cfFormats 
                            // do not match. This could be an auto convert case.
                            // Try to recover old native data
                            if(lpCacheNode->LoadNativeData()!=NOERROR) {
                                // Native data could not be loaded. May be the data has 
                                // already been converted
                                m_pCacheArray->DeleteItem(TOCIndex[NumTOCAdded-1]);
                                continue;
                            }

                            // Old Native data successfully loaded.
                            // Update state on the new cache
                            lpCacheNode->MakeNormalCache();
                            lpCacheNode->SetClsid(CLSID_NULL);
                        }
                    }

                    // Set the storage on the cache node
                    lpCacheNode->SetStg(pStg);

                    // If the server is runinng, set the advise connection
                    if(m_pDataObject)
                        lpCacheNode->SetupAdviseConnection(m_pDataObject, 
                                                          (IAdviseSink *) &m_AdviseSink);
                }

                // Check if TOC entries have been successfully loaded
                if(error != NOERROR) {
                    // Something has gone wrong while loading TOC. 
                    // Delete all newly added cache nodes
                    while(NumTOCAdded) {
                        lpCacheNode = m_pCacheArray->GetItem(TOCIndex[NumTOCAdded-1]);
                        Win4Assert(lpCacheNode);
                        if(m_pDataObject)
                            lpCacheNode->TearDownAdviseConnection(m_pDataObject);
                        m_pCacheArray->DeleteItem(TOCIndex[NumTOCAdded-1]);
                        --NumTOCAdded;
                    }
                }

                // Delete the TOCIndex array
                delete[] TOCIndex;
            }
            else
                error = ResultFromScode(E_OUTOFMEMORY);
        }
    }
    else
        error = ResultFromScode(E_FAIL);

    return error;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		COleCache::SaveTOC, private
//
//	Synopsis:
//              Saves the Table Of Contents in the given stream
//
//	Arguments:
//              pStg [in] - Storage in which TOC is to be saved
//
//      Returns:
//              NOERROR if TOC was successfully saved
//              else appropriate error
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
HRESULT COleCache::SaveTOC(LPSTORAGE pStg, BOOL fSameAsLoad)
{
    // Local variables
    HRESULT error;
    DWORD dwBuf[2];
    ULONG NumTOCEntries, index;
    LPSTREAM lpStream;
    LPCACHENODE lpCacheNode;
    LARGE_INTEGER largeInt;
    ULARGE_INTEGER ulargeInt;

    // There should be atleast one cached presentation for saving TOC
    if(!m_pCacheArray->Length() || 
       (m_pCacheArray->Length()==1 && (m_pCacheArray->GetItem(1))))
            return NOERROR;

    // Open presentation stream 0
    error = pStg->OpenStream(OLE_PRESENTATION_STREAM, NULL, 
                             (STGM_READWRITE | STGM_SHARE_EXCLUSIVE),
                             0, &lpStream);
    if(error == NOERROR) {            
        // Presentation stream exists. Seek to its end
	LISet32(largeInt, 0);	
	error = lpStream->Seek(largeInt, STREAM_SEEK_END, &ulargeInt);
        if(error == NOERROR) {
            // Save TOC header
            NumTOCEntries = m_pCacheArray->Length()-1;
            dwBuf[0] = TOCSIGNATURE;
            dwBuf[1] = NumTOCEntries;
            error = lpStream->Write(dwBuf, sizeof(dwBuf), NULL);
            if(error==NOERROR && NumTOCEntries) {
                // If native cache node exists, save its TOC entry first
                if(lpCacheNode = m_pCacheArray->GetItem(1)) {
                    error = lpCacheNode->SaveTOCEntry(lpStream, fSameAsLoad);
                    --NumTOCEntries;
                }

                if(error == NOERROR && NumTOCEntries) {
                    // Skip the first cached presentation
                    m_pCacheArray->Reset(index, FALSE);
                    lpCacheNode = m_pCacheArray->GetNext(index);
                    Win4Assert(lpCacheNode);

                    // Save the TOC entries of the remaining presentations
                    while(error==NOERROR && (lpCacheNode = m_pCacheArray->GetNext(index))) {
                        error = lpCacheNode->SaveTOCEntry(lpStream, fSameAsLoad);
                        --NumTOCEntries;
                    }
                }
            }

            // Check if the TOC has been successfully saved
            if(error == NOERROR)
                Win4Assert(!NumTOCEntries);
            else { 
                // Something has gone wrong while writting TOC.
                // Revert presentation stream to its original length
                lpStream->SetSize(ulargeInt);
            }
        }
    
        // Release the stream
        lpStream->Release();
    }

    return error;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		COleCache::AspectsUpdated, private
//
//	Synopsis:
//              Notifies the container advise sink of view change if the aspect
//              is one of those in which it expressed interest
//
//	Arguments:
//              dwAspect [in] - Aspect that changed
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
void COleCache::AspectsUpdated(DWORD dwAspects)
{
    DWORD dwKnownAspects;

    // Aspects known to us
    dwKnownAspects = DVASPECT_CONTENT | DVASPECT_THUMBNAIL |
                     DVASPECT_ICON | DVASPECT_DOCPRINT;

    // Ensure that we were given known aspects
    if(dwAspects & ~dwKnownAspects) {
        Win4Assert(FALSE);
        dwAspects &= dwKnownAspects;
    }

    // Check if the client registered advise on any of the changed aspects.
    if(m_pViewAdvSink) {
        // Ensure that container requested advise on valid aspects
        if(m_aspectsView & ~dwKnownAspects) {
            Win4Assert(FALSE);
            m_aspectsView &= dwKnownAspects;
        }

        // As cache is always loaded inproc, the advise to ViewAdvSink 
        // does not violate ASYNC call convention of not being allowed
        // to call outside the current apartment
        while(m_aspectsView & dwAspects) {
            if(dwAspects & DVASPECT_CONTENT) {
                dwAspects &= ~DVASPECT_CONTENT;
                if(!(m_aspectsView & DVASPECT_CONTENT))
                    continue;
                m_pViewAdvSink->OnViewChange(DVASPECT_CONTENT, DEF_LINDEX);
            }
            else if(dwAspects & DVASPECT_THUMBNAIL) {
                dwAspects &= ~DVASPECT_THUMBNAIL;
                if(!(m_aspectsView & DVASPECT_THUMBNAIL))
                    continue;
                m_pViewAdvSink->OnViewChange(DVASPECT_THUMBNAIL, DEF_LINDEX);
            }
            else if(dwAspects & DVASPECT_ICON) {
                dwAspects &= ~DVASPECT_ICON;
                if(!(m_aspectsView & DVASPECT_ICON))
                    continue;
                m_pViewAdvSink->OnViewChange(DVASPECT_ICON, DEF_LINDEX);
            }
            else if(dwAspects & DVASPECT_DOCPRINT) {
                dwAspects &= ~DVASPECT_DOCPRINT;
                if(!(m_aspectsView & DVASPECT_DOCPRINT))
                    continue;
                m_pViewAdvSink->OnViewChange(DVASPECT_DOCPRINT, DEF_LINDEX);
            }

            // If client only wanted notification once, free the advise sink
            if(m_advfView & ADVF_ONLYONCE) {
                m_pViewAdvSink->Release();
                m_pViewAdvSink = NULL;
                m_advfView = 0;
                m_aspectsView = 0;
            }
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\clipbrd\clipbrd.cpp ===
#define STATIC
//+----------------------------------------------------------------------------
//
//	File:
//		clipbrd.cpp
//
//	Contents:
//		OLE2 clipboard handling
//
//	Classes:
//
//	Functions:
//
//	History:
//		24-Jan-94 alexgo    first pass at converting to Cairo-style
//				    memory allocation
//		01/11/94 - alexgo  - added VDATEHEAP macro to every function
//		12/31/93 - ChrisWe - fixed string argument to Warn(); did some
//			additional cleanup and formatting
//		12/08/93 - ChrisWe - added necessary casts to GlobalLock() calls
//			resulting from removing bogus GlobalLock() macros in
//			le2int.h
//		12/08/93 - continuing cleanup
//		12/07/93 - ChrisWe - format some functions, free handle on
//			error condition (GlobalLock() failure) in MakeObjectLink
//		12/06/93 - ChrisWe - begin file cleanup; use new map_uhw.h to
//			avoid bogus unions in Clipboard functions
//		11/28/93 - ChrisWe - make default parameter explicit on
//			UtDupGlobal call
//		11/22/93 - ChrisWe - replace overloaded ==, != with
//			IsEqualIID and IsEqualCLSID
//
//-----------------------------------------------------------------------------

#include <le2int.h>
#pragma SEG(clipbrd)

#include <map_uhw.h>
#include <create.h>
#include <clipbrd.h>
#include <scode.h>
#include <objerror.h>
#include <reterr.h>
#include <ole1cls.h>
#include <ostm2stg.h>
// REVIEW #include "cmonimp.h"		// for CreateOle1FileMoniker()

#ifdef _MAC
# include <string.h>
# pragma segment ClipBrd

// On the Macintosh, the clipboard is always open.  We define a macro for
// OpenClipboard that returns TRUE.  When this is used for error checking,
// the compiler should optimize away any code that depends on testing this,
// since it is a constant.
# define OpenClipboard(x) TRUE

// On the Macintosh, the clipboard is not closed.  To make all code behave
// as if everything is OK, we define a macro for CloseClipboard that returns
// TRUE.  When this is used for error checking, the compiler should optimize
// away any code that depends on testing this, since it is a constant.
# define CloseClipboard() TRUE

#endif // _MAC

ASSERTDATA

#ifdef MAC_REVIEW
	All code is commented out for MAC currently. It is very Windows
	specific, and has to written for MAC.
#endif

// declarations of local functions

//+----------------------------------------------------------------------------
//
//	Function:
//		wNativeStreamToHandle, static
//
//	Synopsis:
//		Reads the contents of a length prefixed stream into a piece
//		of HGLOBAL memory.
//
//	Arguments:
//		[pstm] -- pointer to the IStream instance to read material
//			from; the stream should be positioned just before
//			the length prefix
//		[ph] -- pointer to where to return the handle to the allocated
//			HGLOBAL.
//
//	Returns:
//		HRESULT
//
//	Notes:
//		REVIEW, this looks like something that should be a Ut function
//
//	History:
//		12/13/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
STATIC INTERNAL	wNativeStreamToHandle(LPSTREAM pstm, LPHANDLE ph);


//+----------------------------------------------------------------------------
//
//	Function:
//		wStorageToHandle, static
//
//	Synopsis:
//		Copy an IStorage instance to a (new) handle.
//
//		The contents of the IStorage instance are duplicated in
//		a new HGLOBAL based IStorage instance, less any
//		STREAMTYPE_CACHE streams.
//
//	Arguments:
//		[pstg] -- pointer to the IStorage instance to copy
//		[ph] -- pointer to where to return the new handle.
//
//	Returns:
//		HRESULT
//
//	Notes:
//		REVIEW, this looks like something that should be a Ut function
//
//	History:
//		12/13/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
STATIC INTERNAL wStorageToHandle(LPSTORAGE pstg, LPHANDLE ph);


//+----------------------------------------------------------------------------
//
//	Function:
//		wProgIDFromCLSID, static
//
//	Synopsis:
//		Maps a CLSID to a string program/object name
//
//		Maps CLSID_StdOleLink, which is not listed in the registry.
//
//	Arguments:
//		[clsid] -- the class id to get the program id for
//		[psz] -- pointer to where to return the pointer to the newly
//			allocated string
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		12/13/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL wProgIDFromCLSID(REFCLSID clsid, LPOLESTR FAR* psz);


//+----------------------------------------------------------------------------
//
//	Function:
//		CreateObjectDescriptor, static
//
//	Synopsis:
//		Creates and initializes an OBJECTDESCRIPTOR from the given
//		parameters
//
//	Arguments:
//		[clsid] -- the class ID of the object being transferred
//		[dwAspect] -- the display aspect drawn by the source of the
//			transfer
//		[psizel] -- pointer to the size of the object
//		[ppointl] -- pointer to the mouse offset in the object that
//			initiated a drag-drop transfer
//		[dwStatus] -- the OLEMISC status flags for the object
//			being transferred
//		[lpszFullUserTypeName] -- the full user type name of the
//			object being transferred
//		[lpszSrcOfCopy] -- a human readable name for the object
//			being transferred
//
//	Returns:
//		If successful, A handle to the new OBJECTDESCRIPTOR; otherwise
//		NULL.
//
//	Notes:
//		REVIEW, this seems generally useful for anyone using the
//		clipboard, or drag-drop; perhaps it should be exported.
//
//	History:
//		12/07/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
STATIC INTERNAL_(HGLOBAL) CreateObjectDescriptor(CLSID clsid, DWORD dwAspect,
		const SIZEL FAR *psizel, const POINTL FAR *ppointl,
		DWORD dwStatus, LPOLESTR lpszFullUserTypeName,
		LPOLESTR lpszSrcOfCopy);

// $$$
STATIC INTERNAL_(void) RemoveClipDataObject(void);
// REVIEW, is this local, redeclaration, or what?

// Worker routine for CClipDataObject::GetData() below
// NOTE: may be called with pmedium of NULL (even though this is not legal).
// NOTE: also may be called with
//
// $$$
STATIC HRESULT GetOle2Format(LPFORMATETC pforetc, LPSTGMEDIUM pmedium);

// $$$
STATIC INTERNAL ObjectLinkToMonikerStream(LPOLESTR grszFileItem, DWORD cbFile,
		REFCLSID clsid, LPSTREAM pstm);


//+----------------------------------------------------------------------------
//
//	Function:
//		IsNetDDEObjectLink, static
//
//	Synopsis:
//		Determines if the cfObjectLink object on the clipboard
//		refers to a network file (one prefixed with \\server\share...)
//
//	Effects:
//
//	Arguments:
//		[fMustOpen] -- Indicates that the clipboard must be opened
//			before retrieving the cfObjectLink data format.  If
//			the clipboard is already open, it is left that way.
//
//	Returns:
//		TRUE, if the cfObjectLink data item is a network file,
//		FALSE otherwise
//
//	Notes:
//		REVIEW, what is this about:  This returns TRUE if it can't
//		open the clipboard, with a comment to the effect that this
//		will cause a failure.
//
//	History:
//		01/04/94 - ChrisWe - formatting
//
//-----------------------------------------------------------------------------
STATIC FARINTERNAL_(BOOL) IsNetDDEObjectLink(BOOL fMustOpen);


// $$$
STATIC INTERNAL_(BOOL) OrderingIs(const CLIPFORMAT cf1, const CLIPFORMAT cf2);


//+----------------------------------------------------------------------------
//
//	Function:
//		wOwnerLinkClassIsStdOleLink, static
//
//	Synopsis:
//		Checks to see that the clipboard format registered as
//		cfOwnerLink is actually the standard Ole Link.
//
//	Arguments:
//		[fOpenClipbrd] -- If true, signifies that the clipboard
//			is must be opened--it isn't already open.  If it is
//			already open, it is left open.
//
//	Returns:
//		TRUE if cfOwnerLink is actually the standard OLE link,
//		FALSE otherwise.
//
//	Notes:
//
//	History:
//		01/04/93 - ChrisWe - formatted
//
//-----------------------------------------------------------------------------
STATIC INTERNAL_(BOOL) wOwnerLinkClassIsStdOleLink(BOOL fOpenClipbrd);


STATIC INTERNAL_(BOOL) wEmptyClipboard(void);

STATIC const OLECHAR szStdOleLink[] = OLESTR("OLE2Link");

STATIC const OLECHAR szClipboardWndClass[] = OLESTR("CLIPBOARDWNDCLASS");

// DataObject 'posted' on clipboard
//
// pClipDataObj assumed to be valid in the context of the
// process that owns the clipboard.
//
// pClipDataObj == NULL => GetClipboardData(cfDataObject) == NULL
// 			=> hClipDataObj == NULL
//
// To enable delayed marshalling of ClipDataObj must keep the pointer
// in a global variable: initially SetClipboardData(cfDataObject, NULL);
// marshal ClipDataObj only when GetClipboardData(cfDataObject) is called
//
STATIC LPDATAOBJECT pClipDataObj = NULL; // Pointer to the object

// This always corresponds to what is on the clipboard as cfDataObject format
// May be NULL, indicating either that cfDataObject is on clipboard but not
// rendered. or cfDataObject is not on clipboard.
STATIC HANDLE hClipDataObj = NULL;


STATIC INTERNAL MakeObjectLink(LPDATAOBJECT pDataObj, LPSTREAM pStream,
		 LPHANDLE ph, BOOL fOwnerLink/*= FALSE*/);

STATIC INTERNAL GetClassFromDescriptor(LPDATAOBJECT pDataObj, LPCLSID pclsid,
		BOOL fLink, BOOL fUser, LPOLESTR FAR* pszSrcOfCopy);


//+----------------------------------------------------------------------------
//
//	Class:
//		CClipEnumFormatEtc
//
//	Purpose:
//		Provides an enumerator for the data object CClipDataObject
//
//	Interface:
//		IEnumFORMATETC
//		CClipEnumFormatEtc
//			constructor - this creates an instance that is
//			nearly ready to use; the created instance must still
//			be Init()ed before use, or have it's internal members
//			(except for the reference count) copied from an
//			existing enumerator, as in a clone operation.
//		Init
//			Initializes the enumerator to be at the beginning in
//			its scan state.
//
//	Notes:
//
//	History:
//		12/10/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
class FAR CClipEnumFormatEtc : public IEnumFORMATETC, public CPrivAlloc
{
public:
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPLPVOID ppvObj);
	STDMETHOD_(ULONG,AddRef)(THIS);
	STDMETHOD_(ULONG,Release)(THIS);

	// IEnumFORMATETC methods
	STDMETHOD(Next)(THIS_ ULONG celt, FORMATETC FAR * rgelt,
			ULONG FAR* pceltFetched);
	STDMETHOD(Skip)(THIS_ ULONG celt);
	STDMETHOD(Reset)(THIS);
	STDMETHOD(Clone)(THIS_ IEnumFORMATETC FAR* FAR* ppenum);

	// constructor
	CClipEnumFormatEtc();

	// initializer
	void Init(void);

private:
	INTERNAL NextOne(FORMATETC FAR* pforetc);

	ULONG m_refs; // reference count

	CLIPFORMAT m_cfCurrent; // the last returned format on the clipboard
	CLIPFORMAT m_cfForceNext; // if non-0, the next format to be enumerated
	unsigned m_uFlag;
#define CLIPENUMF_LINKSOURCEAVAILABLE	0x0001
			 /* is cfObjectLink somewhere on the clipboard? */
#define CLIPENUMF_DONE			0x0002 /* forces enumerator to stop */

	SET_A5;
};



// $$$
#pragma SEG(OleSetClipboard)
STDAPI OleSetClipboard(LPDATAOBJECT pDataObj)
{
	VDATEHEAP();

	if (pDataObj)
		VDATEIFACE(pDataObj);

	if (!OpenClipboard(GetClipboardWindow()))
		return(ReportResult(0, CLIPBRD_E_CANT_OPEN, 0, 0));

#ifndef _MAC
	if (!wEmptyClipboard())
	{
		// Also will clear pClipDaObj
		Verify(CloseClipboard());
		return(ReportResult(0, CLIPBRD_E_CANT_EMPTY, 0, 0));
	}
#endif // _MAC

	// Save both pointer to the object
	pClipDataObj = pDataObj;

	if (pDataObj != NULL)
	{
		pClipDataObj->AddRef();

		// Post required clipboard formats
		//
		// "..., which makes the passed IDataObject accessible
		// from the clipboard"
		//
		// Delay marshalling until needed by passing NULL handle
		SetClipboardData(cfDataObject, NULL);

		// REVIEW, what if this wasn't NULL before?  Did we just
		// drop a handle on the floor?
		hClipDataObj = NULL;

		SetOle1ClipboardFormats(pDataObj);
	}

	return(CloseClipboard() ? NOERROR :
			ResultFromScode(CLIPBRD_E_CANT_CLOSE));
}


#pragma SEG(OleGetClipboard)
STDAPI OleGetClipboard(LPDATAOBJECT FAR* ppDataObj)
{
	VDATEHEAP();

	HRESULT hresult;
	HANDLE hMem;
	BOOL fOpen;
	IStream FAR* pStm;

	// validate the output parameter
	VDATEPTROUT(ppDataObj, LPDATAOBJECT);

	// initialize this for error returns
	*ppDataObj = NULL;

	if (!(fOpen = OpenClipboard(GetClipboardWindow())))
	{
		// REVIEW - clipboard opened by caller
		// If clipboard opended by this task (thread)
		// it won't change during this call
		if (GetWindowThreadProcessId(GetOpenClipboardWindow(),NULL) !=
				GetCurrentThreadId())
		{
			// spec says return S_FALSE if someone else owns
			// clipboard
			return(ReportResult(0, S_FALSE, 0, 0));
		}
	}
	
	if (pClipDataObj == NULL)
		hresult = CreateClipboardDataObject(ppDataObj);
	else  // not the fake data object
	{
		// try to get a data object off the clipboard
		hMem = GetClipboardData(cfDataObject);
		if (hMem == NULL)
		{
			hresult = ReportResult(0, CLIPBRD_E_BAD_DATA, 0, 0);
			goto Exit;
		}

		// "..., which makes the passed IDataObject accessible
		// from the clipboard"
		//
		// Create shared memory stream on top of clipboard data.
		// UnMarshal object's interface
		pStm = CloneMemStm(hMem);
		if (pStm == NULL)
		{
			hresult = ReportResult(0, E_OUTOFMEMORY, 0, 0);
			goto Exit;
		}

		hresult = CoUnmarshalInterface(pStm, IID_IDataObject,
				(LPLPVOID)ppDataObj);
		pStm->Release();
		
		if (GetScode(hresult) == RPC_E_CANTPOST_INSENDCALL)
		{
			// This happens when inplace object gets WM_INITMENU,
			// and it is trying to Get the clipboard object, to
			// decide whether to enable Paste and PasteLink menus.
			// For this case we can create the fake data object
			// and return the pointer to it.
			hresult = CreateClipboardDataObject(ppDataObj);
		}	
	}

	if (hresult != NOERROR)
		*ppDataObj = NULL;

Exit:
#ifdef MAC_REVIEW
    Does mac have to trash the hMem handle, ericoe
#endif

	if (fOpen && !CloseClipboard())
		hresult = ResultFromScode(CLIPBRD_E_CANT_CLOSE);

	return(hresult);
}


// OleFlushClipboard
//
// Remove the DataObject from the clipboard, but leave hGlobal-based formats
// including OLE1 formats on the clipboard (for use after the server app
// exits).
//
#pragma SEG(OleFlushClipboard)
STDAPI OleFlushClipboard(void)
{
	VDATEHEAP();

	HWND hwnd;
	BOOL fOpen;
	CLIPFORMAT cf = 0;
	HRESULT hresult = NOERROR;

	hwnd = GetClipboardWindow();

	if (hwnd == GetClipboardOwner())  // Caller owns the clipboard
	{
		fOpen = OpenClipboard(hwnd);
		ErrZS(fOpen, CLIPBRD_E_CANT_OPEN);

		// Make sure all formats are rendered
		while (cf = EnumClipboardFormats(cf))  // not ==
		{
			if (cf != cfDataObject)
				GetClipboardData(cf);  // ignore return value
		}

		// this does OleSetClipboard(cfDataObject, NULL)
		RemoveClipDataObject();

	errRtn:
		if (fOpen && !CloseClipboard())
			hresult = ResultFromScode(CLIPBRD_E_CANT_CLOSE);
	}

	return(hresult);
}

#pragma SEG(OleIsCurrentClipboard)
STDAPI OleIsCurrentClipboard(LPDATAOBJECT pDataObj)
{
	VDATEHEAP();

	HWND hwnd;

	// validate parameters
	VDATEIFACE(pDataObj);

	hwnd = GetClipboardWindow();

	if (hwnd == GetClipboardOwner())
	{
		// Caller owns the clipboard, pClipDataObj valid in caller's
		// address space
		return(ReportResult(0, ((pClipDataObj == pDataObj) ? S_OK :
				S_FALSE), 0, 0));
	}

	// someone else owns the clipboard
	return(ResultFromScode(S_FALSE));
}


// Implementation of fake clipboard data object

//+----------------------------------------------------------------------------
//
//	Member:
//		CClipDataObject::QueryInterface, public
//
//	Synopsis:
//		implements IUnknown::QueryInterface
//
//	Arguments:
//		[riid] -- the IID of the desired interface
//		[ppv] -- pointer to where to return the requested interface
//			pointer
//
//	Returns:
//		E_NOINTERFACE, S_OK
//
//	History:
//		12/06/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
#pragma SEG(CClipDataObject_QueryInterface)
STDMETHODIMP CClipDataObject::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	VDATEHEAP();

	HRESULT hresult;
	
	M_PROLOG(this);

	// initialize this for error return
	*ppvObj = NULL;

	// validate parameters
	VDATEPTROUT(ppvObj, LPVOID);
	VDATEIID(riid);
	
	if (IsEqualIID(riid, IID_IDataObject) ||
			IsEqualIID(riid, IID_IUnknown))
	{

		AddRef();   // A pointer to this object is returned
		*ppvObj = (void FAR *)(IDataObject FAR *)this;
		hresult = NOERROR;
	}
	else
	{
	        // Not accessible or unsupported interface
		hresult = ReportResult(0, E_NOINTERFACE, 0, 0);
	}

	return hresult;
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CClipDataObject::AddRef, public
//
//	Synopsis:
//		implements IUnknown::AddRef
//
//	Arguments:
//		none
//
//	Returns:
//		The new reference count of the object
//
//	History:
//		12/06/93 - ChrisWe - file inspection
//
//-----------------------------------------------------------------------------
#pragma SEG(CClipDataObject_AddRef)
STDMETHODIMP_(ULONG) CClipDataObject::AddRef(void)
{
	VDATEHEAP();

	M_PROLOG(this);

	return(++m_refs);
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CClipDataObject::Release, internal
//
//	Synopsis:
//		Decrements the reference count of the object, freeing it
//		if the last reference has gone away
//
//	Arguments:
//		none
//
//	Returns:
//		The new reference count of the object.
//
//	History:
//		12/06/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
#pragma SEG(CClipDataObject_Release)
STDMETHODIMP_(ULONG) CClipDataObject::Release(void)
{
	VDATEHEAP();

	M_PROLOG(this);

	if (--m_refs != 0) // Still used by others
		return(m_refs);

	delete this; // Free storage
	return(0);
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CClipDataObject::GetData, public
//
//	Synopsis:
//		implements IDataObject::GetData
//
//		Retrieves data from the system clipboard, if data is available
//		in the requested format
//
//	Arguments:
//		[pformatetcIn] -- the desired format to retrieve the data in
//		[pmedium] -- the medium the data will be retrieved in
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		12/06/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
#pragma SEG(CClipDataObject_GetData)
STDMETHODIMP CClipDataObject::GetData(LPFORMATETC pformatetcIn,
		LPSTGMEDIUM pmedium)
{
	VDATEHEAP();

	M_PROLOG(this);

	// validate parameters
	VDATEPTRIN(pformatetcIn, FORMATETC);
	VDATEPTROUT(pmedium, STGMEDIUM);

	pmedium->tymed = TYMED_NULL;
	pmedium->pUnkForRelease = NULL;

	// REVIEW, what result does this have?
	return(GetDataHere(pformatetcIn, pmedium));
}


//+----------------------------------------------------------------------------
//
//	Function:
//		CClipDataObject::GetDataHere, internal
//
//	Synopsis:
//		implements IDataObject::GetDataHere
//
//		Retrieves the requested data from the clipboard, if possible.
//
//	Arguments:
//		[pformatetcIn] -- the format the requestor would like
//		[pmedium] -- the medium the requestor would like the
//			data returned on
//			REVIEW, this doesn't seem to be used in the expected
//			way here.
//
//	Returns:
//		HRESULT
//
//	Notes:
//		This is written to accept a NULL [pmedium] so that it can be
//		used to do the work for QueryGetData().  In that case
//		it just asks the clipboard with IsClipboardFormatAvailable().
//
//	History:
//		12/06/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
#pragma SEG(CClipDataObject_GetDataHere)
STDMETHODIMP CClipDataObject::GetDataHere(LPFORMATETC pformatetcIn,
		LPSTGMEDIUM pmedium)
{
	VDATEHEAP();

	HANDLE hData;
	CLIPFORMAT cf;
	DWORD tymed;

	M_PROLOG(this);

	// validate parameters
	if (pmedium)
		VDATEPTROUT(pmedium, STGMEDIUM);
	VDATEPTRIN(pformatetcIn, FORMATETC);
	VERIFY_LINDEX(pformatetcIn->lindex);

	if (pformatetcIn->ptd != NULL)
		return(ReportResult(0, DV_E_DVTARGETDEVICE, 0, 0));
			
	if (pformatetcIn->dwAspect
			&& !(pformatetcIn->dwAspect & DVASPECT_CONTENT))
		return(ReportResult(0, DV_E_DVASPECT, 0, 0));

	cf = pformatetcIn->cfFormat;
	tymed = pformatetcIn->tymed;

	if (cf == cfEmbeddedObject || cf == cfEmbedSource ||
			cf == cfLinkSource || (cf == cfLinkSrcDescriptor &&
			!IsClipboardFormatAvailable(cfLinkSrcDescriptor))
			|| (cf == cfObjectDescriptor &&
			!IsClipboardFormatAvailable(cfObjectDescriptor)))
	{
		return(GetOle2Format(pformatetcIn, pmedium));
	}

	//
	// REVIEW: probably should be able to return data in any of flat
	// mediums.  For now only return hglobal.
	//

	if (((cf == CF_BITMAP) || (cf == CF_PALETTE)) && (tymed & TYMED_GDI))
		tymed = TYMED_GDI;
	else if ((cf == CF_METAFILEPICT) && (tymed & TYMED_MFPICT))
		tymed = TYMED_MFPICT;
	else if (tymed & TYMED_HGLOBAL)
		tymed = TYMED_HGLOBAL;
	else
		return(ReportResult(0, DV_E_TYMED, 0, 0));

	if (pmedium == NULL)
		return(IsClipboardFormatAvailable(cf) ? NOERROR :
				ReportResult(0, DV_E_CLIPFORMAT, 0, 0));

	// initialize for error return case
	pmedium->pUnkForRelease = NULL;
	pmedium->hGlobal = NULL;

	// We just want to take the clipboard data and pass it on. We don't
	// want to get into the business of copying the data
	if (pmedium->tymed != TYMED_NULL)
		return(ReportResult(0, E_NOTIMPL, 0, 0));

	if (!OpenClipboard(GetClipboardWindow()))
		return(ReportResult(0, CLIPBRD_E_CANT_OPEN, 0, 0));

	hData = GetClipboardData(cf);
	if (hData == NULL)
	{
		Verify(CloseClipboard());
		return(ReportResult(0, DV_E_CLIPFORMAT, 0, 0));
	}

	pmedium->tymed = tymed;
	pmedium->hGlobal = OleDuplicateData(hData, cf, GMEM_MOVEABLE);
	return(CloseClipboard() ? NOERROR :
			ResultFromScode(CLIPBRD_E_CANT_CLOSE));
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CClipDataObject::QueryGetData, internal
//
//	Synopsis:
//		implements IDataObject::QueryGetData
//
//		determines if the requested data can be fetched
//
//	Arguments:
//		[pformatetcIn] -- checks to see if this format is available
//
//	Returns:
//
//	Notes:
//
//	History:
//		12/06/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
#pragma SEG(CClipDataObject_QueryGetData)
STDMETHODIMP CClipDataObject::QueryGetData(LPFORMATETC pformatetcIn)
{
	VDATEHEAP();

	M_PROLOG(this);

	return(NOERROR == GetDataHere(pformatetcIn, NULL) ? NOERROR :
			ResultFromScode(S_FALSE));
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CClipDataObject::GetCanonicalFormatEtc, public
//
//	Synopsis:
//		implements IDataObject::GetCanonicalFormatEtc
//
//	Arguments:
//		[pformatetc] -- the format for which we'd like a base
//			equivalence class
//		[pformatetcOut] -- the equivalence class
//
//	Returns:
//		S_OK
//
//	Notes:
//
//	History:
//		12/06/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
#pragma SEG(CClipDataObject_GetCanonicalFormatEtc)
STDMETHODIMP CClipDataObject::GetCanonicalFormatEtc(LPFORMATETC pformatetc,
		LPFORMATETC pformatetcOut)
{
	VDATEHEAP();

	M_PROLOG(this);

	// validate parameters
	VDATEPTRIN(pformatetc, FORMATETC);
	VDATEPTROUT(pformatetcOut, FORMATETC);
	VERIFY_LINDEX(pformatetc->lindex);

	// set return values
	INIT_FORETC(*pformatetcOut);
	pformatetcOut->cfFormat = pformatetc->cfFormat;

	// Handle cfEmbeddedObject, cfEmbedSource, cfLinkSource
	// REVIEW, this must be a reference to the fact that UtFormatToTymed
	// only currently (12/06/93) returns anything explicit for
	// CF_METAFILEPICT, CF_PALETTE, and CF_BITMAP.  For anything else
	// it returns TYMED_HGLOBAL.  I don't know what the correct
	// values should be for the above mentioned items....
	pformatetcOut->tymed = UtFormatToTymed(pformatetc->cfFormat);

	return(NOERROR);
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CClipDataObject::SetData, public
//
//	Synopsis:
//		implements IDataObject::SetData
//
//	Arguments:
//		[pformatetc] -- the format the data is in
//		[pmedium] -- the storage medium the data is in
//		[fRelease] -- indicates that the callee should release
//			the storage medium when it is done with it
//
//	Returns:
//		E_NOTIMPL
//
//	Notes:
//		It is not allowed to set things on the clipboard
//		with this.  Technically, it would be possible to do.  Would
//		it be useful to implement this so that it worked?  Would we
//		be able to release the storage medium correctly?
//		REVIEW, if we're not going to allow it, shouldn't we have
//		a better error message than E_NOTIMPL?  That seems to indicate
//		brokenness, rather than planned decision....
//
//	History:
//		12/06/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
#pragma SEG(CClipDataObject_SetData)
STDMETHODIMP CClipDataObject::SetData(LPFORMATETC pformatetc,
		STGMEDIUM FAR* pmedium, BOOL fRelease)
{
	VDATEHEAP();

	M_PROLOG(this);

	return(ReportResult(0, E_NOTIMPL, 0, 0));
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CClipDataObject::EnumFormatEtc, public
//
//	Synopsis:
//		implements IDataObject::EnumFormatEtc
//
//	Arguments:
//		[dwDirection] -- flags from DATADIR_*
//		[ppenumFormatEtc] -- pointer to where to return the enumerator
//
//	Returns:
//		E_OUTOFMEMORY, S_OK
//
//	Notes:
//
//	History:
//		12/08/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
#pragma SEG(CClipDataObject_EnumFormatEtc)
STDMETHODIMP CClipDataObject::EnumFormatEtc(DWORD dwDirection,
		LPENUMFORMATETC FAR* ppenumFormatEtc)
{
	VDATEHEAP();

	HRESULT hresult = NOERROR;
	CClipEnumFormatEtc *pCCEFE; // the newly created enumerator

	A5_PROLOG(this);

	// validate parameters
	VDATEPTROUT(ppenumFormatEtc, LPENUMFORMATETC);

	// initialize this for error returns
	*ppenumFormatEtc = NULL;

	// REVIEW, a user could potentially be very confused by this,
	// since DATADIR_SET is a valid argument.  Perhaps it would be
	// better to return an empty enumerator, OR, create a new error
	// code for this condition?
	if (dwDirection != DATADIR_GET)
		return(ResultFromScode(E_NOTIMPL));

	// open the clipboard, so we can enumerate the available formats
	// REVIEW, I believe the enumerator repeatedly does this, so
	// why Open and Close the clipboard here?
	if (!OpenClipboard(GetClipboardWindow()))
	{
		AssertSz(0,"EnumFormatEtc cannont OpenClipboard");
		return(ReportResult(0, CLIPBRD_E_CANT_OPEN, 0, 0));
	}

	// allocate the enumerator
	pCCEFE = new CClipEnumFormatEtc;
	if (pCCEFE == NULL)
		hresult = ResultFromScode(E_OUTOFMEMORY);

	// initialize the enumerator, and prepare to return it
	pCCEFE->Init();
	*ppenumFormatEtc = (IEnumFORMATETC FAR *)pCCEFE;

	if (!CloseClipboard())
		hresult = ResultFromScode(CLIPBRD_E_CANT_CLOSE);

	RESTORE_A5();
	return(hresult);
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CClipDataObject::DAdvise, public
//
//	Synopsis:
//		implements IDataObject::DAdvise
//
//	Arguments:
//		[pFormatetc] -- the format we are interested in being
//			advised of changes to
//		[advf] -- the advise control flags, from ADVF_*
//		[pAdvSink] -- pointer to the advise sink to use for
//			notifications
//		[pdwConnection] -- pointer to a DWORD where DAdvise() can
//			return a token that identifies this advise connection
//
//	Returns:
//		E_NOTIMPL
//
//	Notes:
//
//	History:
//		12/08/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
#pragma SEG(CClipDataObject_DAdvise)
STDMETHODIMP CClipDataObject::DAdvise(FORMATETC FAR* pFormatetc, DWORD advf,
		IAdviseSink FAR* pAdvSink, DWORD FAR* pdwConnection)

{
	VDATEHEAP();

	M_PROLOG(this);

	VDATEPTROUT(pdwConnection, DWORD);
	*pdwConnection = 0;
	return(ReportResult(0, E_NOTIMPL, 0, 0));
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CClipDataObject::DUnadvise, public
//
//	Synopsis:
//		implements IDataObject::Dunadvise
//
//	Arguments:
//		[dwConnection] -- a connection identification token, as
//			returned by DAdvise()
//
//	Returns:
//		E_NOTIMPL
//
//	Notes:
//
//	History:
//		12/08/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
#pragma SEG(CClipDataObject_DUnadvise)
STDMETHODIMP CClipDataObject::DUnadvise(DWORD dwConnection)
{
	VDATEHEAP();

 	M_PROLOG(this);

	return(ReportResult(0, E_NOTIMPL, 0, 0));
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CClipDataObject::EnumDAdvise, public
//
//	Synopsis:
//		implements IDataObject::EnumDAdvise
//
//	Arguments:
//		[ppenumAdvise] -- pointer to where to return the enumerator
//
//	Returns:
//		E_NOTIMPL
//
//	Notes:
//
//	History:
//		12/08/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
#pragma SEG(CClipDataObject_EnumDAdvise)
STDMETHODIMP CClipDataObject::EnumDAdvise(LPENUMSTATDATA FAR* ppenumAdvise)
{
	VDATEHEAP();

	M_PROLOG(this);

	VDATEPTROUT(ppenumAdvise, LPENUMSTATDATA FAR*);
	*ppenumAdvise = NULL;
	return(ReportResult(0, E_NOTIMPL, 0, 0));
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CClipDataObject::CClipDataObject, public
//
//	Synopsis:
//		constructor
//
//	Arguments:
//		none
//
//	Notes:
//		returns with reference count set to 1
//
//	History:
//		12/08/93 - ChrisWe - created
//
//-----------------------------------------------------------------------------
CClipDataObject::CClipDataObject()
{
	VDATEHEAP();

	m_refs = 1;
}


//+----------------------------------------------------------------------------
//
//	Function:
//		CreateClipboardDataObject, internal
//
//	Synopsis:
//		Creates an instance of CClipDataObject, manifested as
//		an IDataObject.
//
//	Arguments:
//		[ppDataObj] -- pointer to where to return the IDataObject
//			instance
//
//	Returns:
//		OLE_E_BLANK, if there are no registered clipboard formats
//			(and *ppDataObj will be NULL)
//		E_OUTOFMEMORY, S_OK
//
//	Notes:
//
//	History:
//		12/08/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
#pragma SEG(CreateClipboardDataObject)
INTERNAL CreateClipboardDataObject(LPDATAOBJECT FAR* ppDataObj)
{
	VDATEHEAP();

	// initialize this for error returns
	*ppDataObj = NULL;

	if (CountClipboardFormats() == 0)
		return(ReportResult(0, OLE_E_BLANK, 0, 0));
	
	*ppDataObj = new CClipDataObject;
	if (*ppDataObj == NULL)
		return(ReportResult(0, E_OUTOFMEMORY, 0, 0));

	return NOERROR;
}


// Implemetation of FORMATETC enumerator for the above fake clipboard data
// object

//+----------------------------------------------------------------------------
//
//	Member:
//		CClipEnumFormatEtc::QueryInterface, public
//
//	Synopsis:
//		implements IUnknown::QueryInterface
//
//	Arguments:
//		[riid] -- the IID of the desired interface
//		[ppv] -- pointer to where to return the requested interface
//			pointer
//
//	Returns:
//		E_NOINTERFACE, S_OK
//
//	History:
//		12/06/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
#pragma SEG(CClipEnumFormatEtc_QueryInterface)
STDMETHODIMP CClipEnumFormatEtc::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	VDATEHEAP();

	HRESULT hresult;

	M_PROLOG(this);

	// Two interfaces supported: IUnknown, IEnumFORMATETC
	if (IsEqualIID(riid, IID_IEnumFORMATETC) ||
			IsEqualIID(riid, IID_IUnknown))
	{
		AddRef();   // A pointer to this object is returned
		*ppvObj = (void FAR *)(IEnumFORMATETC FAR *)this;
		hresult = NOERROR;
	}
	else
	{
	        // Not accessible or unsupported interface
		*ppvObj = NULL;
		hresult = ReportResult(0, E_NOINTERFACE, 0, 0);
	}

	return hresult;
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CClipEnumFormatEtc::AddRef, public
//
//	Synopsis:
//		implements IUnknown::AddRef
//
//	Arguments:
//		none
//
//	Returns:
//		The new reference count of the object
//
//	History:
//		12/06/93 - ChrisWe - file inspection
//
//-----------------------------------------------------------------------------
#pragma SEG(CClipEnumFormatEtc_AddRef)
STDMETHODIMP_(ULONG) CClipEnumFormatEtc::AddRef(void)
{
	VDATEHEAP();

	M_PROLOG(this);

	return(++m_refs);
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CClipEnumFormatEtc::Release, internal
//
//	Synopsis:
//		Decrements the reference count of the object, freeing it
//		if the last reference has gone away
//
//	Arguments:
//		none
//
//	Returns:
//		The new reference count of the object.
//
//	History:
//		12/06/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
#pragma SEG(CClipEnumFormatEtc_Release)
STDMETHODIMP_(ULONG) CClipEnumFormatEtc::Release(void)
{
	VDATEHEAP();

	M_PROLOG(this);

	if (--m_refs != 0) // Still used by others
		return(m_refs);

	delete this; // Free storage
	return(0);
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CClipEnumFormatEtc::Next, public
//
//	Synopsis:
//		implements IEnumFORMATETC::Next
//
//	Arguments:
//		[celt] -- the number of elements the caller would like
//			returned
//		[rgelt] -- a pointer to space where the elements may be
//			returned
//		[pceltFetched] -- a pointer to where to return a count of
//			the number of elements fetched;  May be NULL.
//
//	Returns:
//		S_OK if the requested number of items is retrieved, or
//		S_FALSE, if fewer than the requested number is retrieved
//
//	Notes:
//
//	History:
//		12/06/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
#pragma SEG(CClipEnumFormatEtc_Next)
STDMETHODIMP CClipEnumFormatEtc::Next(ULONG celt, FORMATETC FAR * rgelt,
		ULONG FAR* pceltFetched)
{
	VDATEHEAP();

	ULONG celtSoFar; // count of elements fetched so far
	ULONG celtDummy; // used to avoid retesting pceltFetched

	// did the caller ask for the number of elements fetched?
	if (pceltFetched != NULL)
	{
		// validate the pointer
		VDATEPTROUT(pceltFetched, ULONG);

		// initialize for error return
		*pceltFetched = 0;
	}
	else
	{
		// point at the dummy so we can assign *pceltFetched w/o test
		pceltFetched = &celtDummy;

		// if pceltFetched == NULL, can only ask for 1 element
		if (celt != 1)
			return(ResultFromScode(E_INVALIDARG));
	}

	// validate parameters
	VDATEPTROUT(rgelt, FORMATETC);
	if (celt != 0)
		VDATEPTROUT(rgelt + celt - 1, FORMATETC);

	// fetch the items
	for(celtSoFar = 0; celtSoFar < celt; ++rgelt, ++celtSoFar)
	{
		if (NextOne(rgelt) != NOERROR)
			break;
	}

	*pceltFetched = celtSoFar;

	return(celtSoFar < celt ? ResultFromScode(S_FALSE) : NOERROR);
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CClipEnumFormatEtc::NextOne, private
//
//	Synopsis:
//		Workhorse function for CClipEnumFormatEtc::Next(); iterates
//		over the available formats on the clipboard using the
//		appropriate win32s APIs.
//
//	Arguments:
//		[pforetc] -- pointer to a FORMATETC to fill in with the
//			next format
//
//	Returns:
//		HRESULT
//
//	Notes:
//		This skips over cfDataObject, cfObjectLink, and cfOwnerLink.
//		cfObjectLink and cfOwnerLink are returned after all other
//		formats; cfDataObject is not returned at all.
//
//	History:
//		01/04/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
#pragma SEG(CClipEnumFormatEtc_NextOne)
INTERNAL CClipEnumFormatEtc::NextOne(FORMATETC FAR* pforetc)
{
	VDATEHEAP();

	CLIPFORMAT cfNext;
	HRESULT hresult;

	M_PROLOG(this);

	// Initialize the FORMATETC we're going to fetch into
	INIT_FORETC(*pforetc);

	// is there a CLIPFORMAT that we want to force to be next?
	if (m_cfForceNext != 0)
	{
		// return the format we're forcing to be next
		pforetc->cfFormat = m_cfForceNext;
		pforetc->tymed = UtFormatToTymed(m_cfForceNext);

		// there's no more format to force to be next
		m_cfForceNext = 0;
		return(NOERROR);
	}

	// if the enumerator is done, get out
	if (m_uFlag & CLIPENUMF_DONE)
		return(ResultFromScode(S_FALSE));

	// if we can't open the clipboard, we can't enumerate the formats on it
	if (!OpenClipboard(GetClipboardWindow()))
	{
		AssertSz(0, "CClipEnumFormatEtc::Next cannot OpenClipboard");
		return(ReportResult(0, CLIPBRD_E_CANT_OPEN, 0, 0));
	}

	// error state so far
	hresult = NOERROR;

	// get the next format to be returned by the enumerator
	cfNext = EnumClipboardFormats(m_cfCurrent);

TryAgain:
	// skip cfDataObject
	if (cfNext == cfDataObject)
		cfNext = EnumClipboardFormats(cfNext);

	if (cfNext == cfObjectLink)
	{
		if (!IsNetDDEObjectLink(FALSE))
		{
			// Hack to make sure CF_LINKSOURCE is last.
			m_uFlag |= CLIPENUMF_LINKSOURCEAVAILABLE;
		}

		// skip cfObjectlink for now
		cfNext = EnumClipboardFormats(cfNext);
		goto TryAgain;
	}

	if (cfNext == cfOwnerLink)
	{
		if (!IsClipboardFormatAvailable(cfNative)
				|| OrderingIs(cfOwnerLink, cfNative))
		{
			// This is the case of copying a link object from a
			// 1.0 container EmbeddedObject will need to be
			// generated on request in GetData.
			pforetc->cfFormat = cfEmbeddedObject;
			pforetc->tymed = TYMED_ISTORAGE;
			goto errRtn;
		}
		else
		{	
			// skip cfOwnerlink
			cfNext = EnumClipboardFormats(cfNext);
			goto TryAgain;
		}
	}

	// is there nothing more on the clipboard?
	if (cfNext == 0)
	{
		// mark the enumeration as done
		m_uFlag |= CLIPENUMF_DONE;

		if (m_uFlag & CLIPENUMF_LINKSOURCEAVAILABLE)
		{
		   	// Prevent infinite loop. Return S_FALSE next time.
			cfNext = cfObjectLink;
		}
		else
		{
			hresult = ResultFromScode(S_FALSE);
			goto errRtn;
		}
	}

	if (cfNext == cfNative)
	{
		if (IsClipboardFormatAvailable(cfOwnerLink) &&
				OrderingIs(cfNative, cfOwnerLink))
		{
			pforetc->cfFormat = wOwnerLinkClassIsStdOleLink(FALSE) ?
					cfEmbeddedObject : cfEmbedSource;
			pforetc->tymed = TYMED_ISTORAGE;

			if (!IsClipboardFormatAvailable(cfObjectDescriptor))
			{
				// cfObjectDescriptor may be directly on the
				// clipboard if it was flushed.
				m_cfForceNext = cfObjectDescriptor;
			}
		}
		else
		{
			// Native without ownerlink is useless
			cfNext = EnumClipboardFormats(cfNext);
			goto TryAgain;
		}
	}
	else if (cfNext == cfObjectLink)
	{
		pforetc->cfFormat = cfLinkSource;
		pforetc->tymed = TYMED_ISTREAM;

		if (!IsClipboardFormatAvailable(cfLinkSrcDescriptor))
		{
			// cfLinkSrcDescriptor may be directly on the clipboard
			// if it was flushed.
			m_cfForceNext = cfLinkSrcDescriptor;
		}
	}
	else
	{
		pforetc->cfFormat = cfNext;
		pforetc->tymed = UtFormatToTymed(cfNext);
	}

errRtn:
	m_cfCurrent = cfNext;

	if (!CloseClipboard())
		hresult = ResultFromScode(CLIPBRD_E_CANT_CLOSE);

	return(hresult);
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CClipEnumFormatEtc::Skip, public
//
//	Synopsis:
//		Implements IEnumFORMATETC::Skip
//
//	Arguments:
//		[celt] -- the number of elements to skip in the enumeration
//
//	Returns:
//		S_FALSE, if fewer elements were available than [celt]
//		S_TRUE, otherwise
//
//	Notes:
//
//	History:
//		12/10/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
#pragma SEG(CClipEnumFormatEtc_Skip)
STDMETHODIMP CClipEnumFormatEtc::Skip(ULONG celt)
{
	VDATEHEAP();

	ULONG celtSoFar; // a count of the elements we've skipped so far
	FORMATETC formatetc; // a dummy FORMATETC to fetch formats into

	M_PROLOG(this);

	// skip over as many formats as requested
	for(celtSoFar = 0; (celtSoFar < celt) &&
			(NextOne(&formatetc) == NOERROR); ++celtSoFar)
		;

	return((celtSoFar < celt) ? ResultFromScode(S_FALSE) : NOERROR);
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CClipEnumFormatEtc::Reset, public
//
//	Synopsis:
//		implements IEnumFORMATETC::Reset
//
//	Arguments:
//		none
//
//	Returns:
//		S_OK
//
//	Notes:
//
//	History:
//		12/10/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
#pragma SEG(CClipEnumFormatEtc_Reset)
STDMETHODIMP CClipEnumFormatEtc::Reset(void)
{
	VDATEHEAP();

	Init();

	return(NOERROR);
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CClipEnumFormatEtc::Clone, public
//
//	Synopsis:
//		implements IEnumFORMATETC::Clone
//
//	Arguments:
//		[ppenum] -- pointer to where to return the new enumerator
//
//	Returns:
//		E_OUTOFMEMORY, S_OK
//
//	Notes:
//
//	History:
//		12/10/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
#pragma SEG(CClipEnumFormatEtc_Clone)
STDMETHODIMP CClipEnumFormatEtc::Clone(IEnumFORMATETC FAR* FAR* ppenum)
{
	VDATEHEAP();

	CClipEnumFormatEtc FAR* pECB; // pointer to the new enumerator

	M_PROLOG(this);

	// validate parameters
	VDATEPTROUT(ppenum, LPENUMFORMATETC);

	// allocate the new enumerator
	*ppenum = pECB = new CClipEnumFormatEtc;
	if (pECB == NULL)
		return(ResultFromScode(E_OUTOFMEMORY));

	// set the clone enumerator to be in the same state as this one
	pECB->m_cfCurrent = m_cfCurrent;
	pECB->m_uFlag = m_uFlag;
	pECB->m_cfForceNext = m_cfForceNext;

	return(NOERROR);
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CClipEnumFormatEtc::CClipEnumFormatEtc, public
//
//	Synopsis:
//		constructor
//
//	Arguments:
//		none
//
//	Notes:
//		returns with reference count set to 1
//
//	History:
//		12/10/93 - ChrisWe - created
//
//-----------------------------------------------------------------------------
CClipEnumFormatEtc::CClipEnumFormatEtc()
{
	VDATEHEAP();

	m_refs = 1;
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CClipEnumFormatEtc::Init, public
//
//	Synopsis:
//		Initializes enumerator, preparing it for use.
//
//	Arguments:
//		none
//
//	Notes:
//
//	History:
//		12/10/93 - ChrisWe - created
//
//-----------------------------------------------------------------------------
void CClipEnumFormatEtc::Init(void)
{
	VDATEHEAP();

	M_PROLOG(this);

	// initialize enumerator to be at beginning of scan state
	m_cfCurrent = 0;
	m_uFlag = 0;
	m_cfForceNext = 0;
}


// $$$
// ObjectLinkToMonikerStream
//
// grszFileItem == szFileName\0szItemName\0\0
//   i.e. the tail end of an ObjectLink
// cbFile == strlen(szFileName)
//
// Create a moniker from the ObjectLink and serialize it to pstm
//

#pragma SEG(ObjectLinkToMonikerStream)
STATIC INTERNAL ObjectLinkToMonikerStream(LPOLESTR grszFileItem, DWORD cbFile,
		REFCLSID clsid, LPSTREAM pstm)
{
	VDATEHEAP();

	HRESULT hr = NOERROR;
	LPMONIKER pmk = NULL;
	LPMONIKER pmkFile = NULL;
	LPMONIKER pmkItem = NULL;
	LPPERSISTSTREAM ppersiststm = NULL;
	
#ifdef WIN32 // REVIEW, no 16 bit interop
        return(ReportResult(0, E_NOTIMPL, 0, 0));
// REVIEW, this seems to be used by GetOle2Format().
#else
	Assert(grszFileItem);
	Assert(cbFile == (DWORD)_xstrlen(grszFileItem) + 1);

	if (NOERROR != (hr = CreateOle1FileMoniker(grszFileItem, clsid,
			&pmkFile)))
	{
		AssertSz (0, "Cannot create file moniker");
		goto errRtn;
	}

	grszFileItem += cbFile;
	if (*grszFileItem)
	{
		if (NOERROR != (hr = CreateItemMoniker(OLESTR("!"),
				grszFileItem, &pmkItem)))
		{
			AssertSz(0, "Cannot create file moniker");	
			goto errRtn;
		}

		if (NOERROR != (hr = CreateGenericComposite(pmkFile,
				pmkItem, &pmk)))
		{
			AssertSz(0, "Cannot create composite moniker");	
			goto errRtn;
		}
	}
	else
	{
		// No item
		pmk = pmkFile;
		pmk->AddRef();
	}

	if (NOERROR != (hr = pmk->QueryInterface(IID_IPersistStream,
			(LPLPVOID)&ppersiststm)))
	{
		AssertSz(0, "Cannot get IPersistStream from moniker");
		goto errRtn;	
	}

	if (NOERROR != (hr = OleSaveToStream(ppersiststm, pstm)))
	{
		AssertSz(0, "Cannot save to Persist Stream");
		goto errRtn;
	}

  errRtn:
	if (pmk)
		pmk->Release();
	if (pmkFile)
		pmkFile->Release();
	if (pmkItem)
		pmkItem->Release();
	if (ppersiststm)
		ppersiststm->Release();
	return hr;
#endif // WIN32
}


//+----------------------------------------------------------------------------
//
//	Function:
//		wHandleToStorage, static
//
//	Synopsis:
//		Copies the contents of a handle to a native clipboard
//		format to an IStorage instance.
//
//	Arguments:
//		[pstg] -- the IStorage instance to copy the handle contents to
//		[hNative] -- a handle to a native clipboard format
//
//	Returns:
//		HRESULT
//
//	Notes:
//		REVIEW, this seems to assume that the handle was already
//		an IStorage instance disguised as an OLE1.0 object for the
//		sake of a containing OLE1.0 object, and creates a copy of
//		the underlying OLE2.0 stuff in the target storage.
//
//		The Cache streams are removed from the handle based storage
//		before copying to the target.
//		REVIEW, it's not clear if the caller would like this.  Perhaps
//		they should just not be copied....
//
//	History:
//		12/10/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
#pragma SEG(wHandleToStorage)
STATIC INTERNAL wHandleToStorage(LPSTORAGE pstg, HANDLE hNative)
{
	VDATEHEAP();

	LPLOCKBYTES plkbyt = NULL;
	LPSTORAGE pstgNative = NULL;
	HRESULT hresult;

	RetErr(CreateILockBytesOnHGlobal(hNative, FALSE, &plkbyt));
	if (NOERROR != (hresult = StgIsStorageILockBytes(plkbyt)))
	{
		AssertSz(0, "Native data is not an IStorage");
		goto errRtn;
	}

	// This is really a 2.0 object disguised as a 1.0 object
	// for the sake of its 1.0 container, so reconstitute
	// the original IStorage from the native data.
	if (NOERROR != (hresult = StgOpenStorageOnILockBytes(plkbyt, NULL,
			STGM_DFRALL, NULL, 0, &pstgNative)))
	{
		AssertSz(0, "Couldn't open storage on native data");
		goto errRtn;
	}

	ErrRtnH(UtDoStreamOperation(pstgNative, NULL, OPCODE_REMOVE,
			STREAMTYPE_CACHE));

	if (NOERROR != (hresult = pstgNative->CopyTo(0, NULL, NULL, pstg)))
	{
		AssertSz(0, "Couldn't copy storage");
		goto errRtn;
	}

  errRtn:
	if (pstgNative)
		pstgNative->Release();
	if (plkbyt)
		plkbyt->Release();

	return(hresult);
}


#ifndef WIN32 // REVIEW, can't find GetMetaFileBits() in win32
		// REVIEW, seems to be OLE1

#pragma SEG(MfToPres)
INTERNAL MfToPres(HANDLE hMfPict, PPRES ppres)
{
	VDATEHEAP();

	LPMETAFILEPICT pMfPict;

	Assert(ppres);
	pMfPict = (LPMETAFILEPICT)GlobalLock(hMfPict);
	RetZS(pMfPict, CLIPBRD_E_BAD_DATA);
	ppres->m_format.m_ftag = ftagClipFormat;
	ppres->m_format.m_cf = CF_METAFILEPICT;
	ppres->m_ulHeight = pMfPict->yExt;
	ppres->m_ulWidth  = pMfPict->xExt;

	// GetMetaFileBits() invalidates its parameter, therefore we must copy
	ppres->m_data.m_h = GetMetaFileBits(CopyMetaFile(pMfPict->hMF, NULL));
	ppres->m_data.m_cbSize = GlobalSize(ppres->m_data.m_h);
	ppres->m_data.m_pv = GlobalLock(ppres->m_data.m_h);
	GlobalUnlock(hMfPict);
	return(NOERROR);
}

#pragma SEG(DibToPres)
INTERNAL DibToPres(HANDLE hDib, PPRES ppres)
{
	VDATEHEAP();

	BITMAPINFOHEADER FAR* pbminfohdr;

	Assert(ppres);
	
	pbminfohdr = (BITMAPINFOHEADER FAR*)GlobalLock(hDib);
	RetZS(pbminfohdr, CLIPBRD_E_BAD_DATA);

	ppres->m_format.m_ftag = ftagClipFormat;
	ppres->m_format.m_cf = CF_DIB;
	ppres->m_ulHeight = pbminfohdr->biHeight;
	ppres->m_ulWidth  = pbminfohdr->biWidth;
	ppres->m_data.m_h = hDib;
	ppres->m_data.m_pv = pbminfohdr;
	ppres->m_data.m_cbSize = GlobalSize (hDib);

	// Don't free the hDib because it is on the clipboard.
	ppres->m_data.m_fNoFree = TRUE;

	// Do not unlock hDib
	return(NOERROR);
}


#pragma SEG(BmToPres)
INTERNAL BmToPres(HBITMAP hBM, PPRES ppres)
{
	VDATEHEAP();

	HANDLE	hDib;
	
	if (hDib = UtConvertBitmapToDib(hBM))
	{
		// this routine keeps hDib, it doesn't make a copy of it
		return DibToPres(hDib, ppres);
	}
	
	return(ResultFromScode(E_OUTOFMEMORY));
}

#endif // WIN32

//$$$
// OrderingIs
//
// Return whether the relative ordering of cf1 and cf2 on the clipboard
// is "cf1 then cf2".  Will return FALSE if cf1 is not on the clipboard,
// so OrderingIs (cf1, cf2) => IsClipboardFormatAvailable (cf1)
// Clipboard must be open.
//
INTERNAL_(BOOL) OrderingIs(const CLIPFORMAT cf1, const CLIPFORMAT cf2)
{
	VDATEHEAP();

	CLIPFORMAT cf = 0;

	while (cf = EnumClipboardFormats(cf))
	{
		if (cf == cf1)
			return(TRUE);
		if (cf == cf2)
		 	return(FALSE);
	}

	return(FALSE); // didn't find either format
}


// wMakeEmbedObjForLink
//
// Generate a storage (cfEmbedSource) for a link copied from a 1.0 container.
//

#pragma SEG(wMakeEmbedObjForLink)
INTERNAL wMakeEmbedObjForLink(LPSTORAGE pstg)
{
	VDATEHEAP();

#ifdef WIN32 // REVIEW, seems to be OLE1
	return(ReportResult(0, OLE_E_NOOLE1, 0, 0));
#else
	GENOBJ genobj;
	HANDLE hOwnerLink;
	LPOLESTR pch;
	HRESULT hresult;
		
	genobj.m_class.Set(CLSID_StdOleLink);
	genobj.m_ppres = new PRES;
	RetZS(genobj.m_ppres, E_OUTOFMEMORY);
	genobj.m_fLink = TRUE;
	genobj.m_lnkupdopt = UPDATE_ALWAYS;

	if (IsClipboardFormatAvailable(CF_METAFILEPICT))
	{
		RetErr(MfToPres(GetClipboardData(CF_METAFILEPICT),
				genobj.m_ppres));
	}
	else if (IsClipboardFormatAvailable(CF_DIB))
	{
		RetErr(DibToPres(GetClipboardData(CF_DIB),
				genobj.m_ppres));
	}
	else if (IsClipboardFormatAvailable(CF_BITMAP))
	{
		RetErr(BmToPres((HBITMAP)GetClipboardData(CF_BITMAP),
				genobj.m_ppres));
	}
	else
	{
		delete genobj.m_ppres;
		genobj.m_ppres = NULL;
		genobj.m_fNoBlankPres = TRUE;
	}

	if (NULL == (hOwnerLink = GetClipboardData(cfOwnerLink)))
	{
		Assert(0);
		return(ResultFromScode (DV_E_CLIPFORMAT));
	}

	if (NULL == (pch = GlobalLock(hOwnerLink)))
		return(ResultFromScode(CLIPBRD_E_BAD_DATA));


	genobj.m_classLast.Set(UtDupString(pch));
	pch += _xstrlen(pch)+1;
	genobj.m_szTopic = *pch ? UtDupString (pch) : NULL;
	pch += _xstrlen(pch)+1;
	genobj.m_szItem = *pch ? UtDupString (pch) : NULL;
	
	GlobalUnlock(hOwnerLink);
	hresult = GenericObjectToIStorage(genobj, pstg, NULL);
	if (SUCCEEDED(hresult))
		hresult = NOERROR;

	if (!OrderingIs(cfNative, cfOwnerLink))
		return(hresult);
	else
	{
		// Case of copying an OLE 2 link from a 1.0 container.
		// The first part of this function created a presentation
		// stream from the presentation on the clipboard.  The
		// presentation is NOT already inside the Native data (i.e.,
		// the cfEmbeddedObject) because we removed it to conserve
		// space.
		HGLOBAL h = GetClipboardData(cfNative);
		RetZS(h, CLIPBRD_E_BAD_DATA);
		return(wHandleToStorage(pstg, h));
	}
#endif // WIN32
}


#pragma SEG(CreateObjectDescriptor)
STATIC INTERNAL_(HGLOBAL) CreateObjectDescriptor(CLSID clsid, DWORD dwAspect,
		const SIZEL FAR *psizel, const POINTL FAR *ppointl,
		DWORD dwStatus, LPOLESTR lpszFullUserTypeName,
		LPOLESTR lpszSrcOfCopy)
{
	VDATEHEAP();

	DWORD dwFullUserTypeNameBLen; // length of lpszFullUserTypeName in BYTES
	DWORD dwSrcOfCopyBLen; // length of lpszSrcOfCopy in BYTES
	HGLOBAL hMem; // handle to the object descriptor
	LPOBJECTDESCRIPTOR lpOD; // the new object descriptor

	// Get the length of Full User Type Name; Add 1 for the null terminator
	if (!lpszFullUserTypeName)
		dwFullUserTypeNameBLen = 0;
	else
		dwFullUserTypeNameBLen = (_xstrlen(lpszFullUserTypeName) +
				1) * sizeof(OLECHAR);

	// Get the Source of Copy string and it's length; Add 1 for the null
	// terminator
	if (lpszSrcOfCopy)
		dwSrcOfCopyBLen = (_xstrlen(lpszSrcOfCopy) + 1) *
				sizeof(OLECHAR);
	else
	{
		// No src moniker so use user type name as source string.
		lpszSrcOfCopy =  lpszFullUserTypeName;
		dwSrcOfCopyBLen = dwFullUserTypeNameBLen;
	}

	// allocate the memory where we'll put the object descriptor
	hMem = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
			sizeof(OBJECTDESCRIPTOR) + dwFullUserTypeNameBLen +
			dwSrcOfCopyBLen);
	if (hMem == NULL)
		goto error;

	lpOD = (LPOBJECTDESCRIPTOR)GlobalLock(hMem);
	if (lpOD == NULL)
		goto error;

	// Set the FullUserTypeName offset and copy the string
	if (!lpszFullUserTypeName)
	{
		// zero offset indicates that string is not present
		lpOD->dwFullUserTypeName = 0;
	}
	else
	{
		lpOD->dwFullUserTypeName = sizeof(OBJECTDESCRIPTOR);
		_xmemcpy(((BYTE FAR *)lpOD)+lpOD->dwFullUserTypeName,
				(const void FAR *)lpszFullUserTypeName,
				dwFullUserTypeNameBLen);
	}

	// Set the SrcOfCopy offset and copy the string
	if (!lpszSrcOfCopy)
	{
		// zero offset indicates that string is not present
		lpOD->dwSrcOfCopy = 0;
	}
	else
	{
		lpOD->dwSrcOfCopy = sizeof(OBJECTDESCRIPTOR) +
				dwFullUserTypeNameBLen;
		_xmemcpy(((BYTE FAR *)lpOD)+lpOD->dwSrcOfCopy,
				(const void FAR *)lpszSrcOfCopy,
				dwSrcOfCopyBLen);
	}

	// Initialize the rest of the OBJECTDESCRIPTOR
	lpOD->cbSize = sizeof(OBJECTDESCRIPTOR) + dwFullUserTypeNameBLen +
			dwSrcOfCopyBLen;
	lpOD->clsid = clsid;
	lpOD->dwDrawAspect = dwAspect;
	lpOD->sizel = *psizel;
	lpOD->pointl = *ppointl;
	lpOD->dwStatus = dwStatus;

	GlobalUnlock(hMem);
	return(hMem);

error:
	if (hMem)
	{
		GlobalUnlock(hMem);
		GlobalFree(hMem);
	}

	return(NULL);
}


#pragma SEG(wOwnerLinkClassIsStdOleLink)
STATIC INTERNAL_(BOOL) wOwnerLinkClassIsStdOleLink(BOOL fOpenClipbrd)
{
	VDATEHEAP();
	
	BOOL f = FALSE;
	LPOLESTR sz = NULL;
	HANDLE h; // handle for clipboard data

	if (fOpenClipbrd && !OpenClipboard(GetClipboardWindow()))
		return(FALSE);
		
	h = GetClipboardData(cfOwnerLink);
	ErrZ(h);
	sz = (LPOLESTR)GlobalLock(h);
	ErrZ(sz);
		
	f = (0 == _xstrcmp(szStdOleLink, sz));
errRtn:
	if (sz)
		GlobalUnlock(h);
	if (fOpenClipbrd)
		Verify(CloseClipboard());

	return(f);
}


#pragma SEG(IsNetDDEObjectLink)
STATIC FARINTERNAL_(BOOL) IsNetDDEObjectLink(BOOL fMustOpen)
{
	VDATEHEAP();

	BOOL fAnswer;
	HANDLE hObjLink;
	LPOLESTR pObjLink;

	if (fMustOpen)
	{
		if (!OpenClipboard(GetClipboardWindow()))
			return(TRUE); // cause a failure
	}

	hObjLink = GetClipboardData(cfObjectLink);
	pObjLink = (LPOLESTR)GlobalLock(hObjLink);
	if (NULL==pObjLink)
	{
		fAnswer = TRUE;// cause a failure
		goto errRtn;
	}

	// Net DDE :"classnames" are of the form:
	// \\machinename\NDDE$\0$pagename.ole

	fAnswer = (OLESTR('\\')==pObjLink[0] && OLESTR('\\')==pObjLink[1]);
	GlobalUnlock(hObjLink);

errRtn:
	if (fMustOpen)
		CloseClipboard();

	return(fAnswer);
}
	


// $$$ Continue
// Handle cfEmbeddedObject, cfEmbedSource, cfLinkSource, cfObjectDescriptor,
// cfLinkDesciptor
//
#pragma SEG(GetOle2Format)
HRESULT GetOle2Format(LPFORMATETC pforetc, LPSTGMEDIUM pmedium)
{
	VDATEHEAP();

	CLIPFORMAT cf; // local copy of pforetc->cfFormat
	HRESULT hresult; // error state so far
	DWORD cbDoc, cbClass, cbItemName;
	HANDLE hOle1;
	HANDLE hNative;
	STGMEDIUM stgm;
	CLSID clsid;
	LPOLESTR szDoc;

	// the following variables are used in error cleanup situations, and
	// need to be initialized to NULL so the cleanup code does not try
	// to free things that haven't been used
	LPOLESTR szClass = NULL;
	LPOLESTR szItemName = NULL;
	IStream FAR* pstm = NULL;
	IStorage FAR* pstg = NULL;

	// validate parameters
	VERIFY_LINDEX(pforetc->lindex);
	
	cf = pforetc->cfFormat;

	Assert ((cf == cfEmbeddedObject) || (cf == cfEmbedSource)
			|| (cf == cfLinkSource) || (cf == cfLinkSrcDescriptor)
			|| (cf == cfObjectDescriptor));

	// Verify availability of format
	if ((cf == cfEmbedSource) && (!IsClipboardFormatAvailable(cfNative) ||
			!IsClipboardFormatAvailable(cfOwnerLink)))
	{
		return(ResultFromScode(DV_E_CLIPFORMAT));
  	}

	if ((cf == cfObjectDescriptor) &&
			!IsClipboardFormatAvailable(cfOwnerLink))
	{
		return(ResultFromScode(DV_E_CLIPFORMAT));
	}

	if (((cf == cfLinkSource) || (cf == cfLinkSrcDescriptor)) &&
			(!IsClipboardFormatAvailable(cfObjectLink) ||
			IsNetDDEObjectLink(TRUE)))
	{
		return(ResultFromScode(DV_E_CLIPFORMAT));
	}

	if (!OpenClipboard(GetClipboardWindow()))
		return(ReportResult(0, CLIPBRD_E_CANT_OPEN, 0, 0));

	// After this point, don't just return in case of error any more
	// as the clipboard is open.  From here on, either goto OK_Exit,
	// or errRtn, depending on the reason for quitting.

	if (cf == cfEmbeddedObject)
	{
		if (!IsClipboardFormatAvailable(cfOwnerLink) ||
				(OrderingIs(cfNative, cfOwnerLink) &&
				!wOwnerLinkClassIsStdOleLink(FALSE)))
#ifdef NEVER
/*
REVIEW
ChrisWe, 1/6/94.  I'm not at all sure about this.  The original code for the
condition above is as below, with the unary negation.  But it seems that
If we want embedded source we want to fail if the cfOwnerLink is for a link,
not if it isn't a link.  The below code seems to agree with that.

This agrees with what OleSetClipboard does when you try to put
cfEmbeddedObject on the clipboard.  All of the above are true, and everything
is alright.  I don't see how this negation can work on win16 unless there's
a compiler bug or something weird is going on.
*/
				//!wOwnerLinkClassIsStdOleLink(FALSE)))
#endif // NEVER
		{
			hresult = ResultFromScode (DV_E_CLIPFORMAT);
			goto OK_Exit; // Close clipboard and exit
		}
	}

	// Is it just a query?
	if (pmedium == NULL)
	{
		hresult = NOERROR;
		goto OK_Exit;  // Close clipboard and exit
	}

	//  Get all the data we need out of the OLE1 formats
	hOle1 = GetClipboardData(((cf == cfEmbedSource) ||
			(cf == cfEmbeddedObject) ||
			(cf == cfObjectDescriptor)) ?
			cfOwnerLink : cfObjectLink);
	if (hOle1 == NULL)
	{
		hresult = ReportResult(0, DV_E_CLIPFORMAT, 0, 0);
		goto errRtn;
	}

	szClass = (LPOLESTR)GlobalLock(hOle1);
	if (szClass  == NULL)
	{
		hresult = ReportResult(0, E_OUTOFMEMORY, 0, 0);
		goto errRtn;
	}

	if ((hresult = wCLSIDFromProgID(szClass, &clsid,
			/*fForceAssign*/ TRUE)) != NOERROR)
		goto errRtn;

	cbClass = _xstrlen(szClass) + 1;
	szDoc = szClass + cbClass;
	cbDoc = _xstrlen(szDoc) + 1;
	szItemName = szDoc + cbDoc;
	cbItemName = _xstrlen(szItemName) + 1;

	if (cf == cfEmbedSource)
	{
		if (NULL == (hNative = GetClipboardData(cfNative)))
		{
			hresult = ReportResult(0, DV_E_CLIPFORMAT, 0, 0);
			goto errRtn;
		}
	}

	stgm = *pmedium; // just an alias mechanism
		// REVIEW, NO, this makes a copy!!!

	// Choose and allocate medium
	if (pmedium->tymed == TYMED_NULL)
	{
		// none of our media need this
		stgm.pUnkForRelease = NULL;

		// GetData: Callee chooses medium
		if (((cf == cfEmbedSource) || (cf == cfEmbeddedObject)) &&
			(pforetc->tymed & TYMED_ISTORAGE))
		{
			// Choose Storage (Per spec)
			stgm.tymed = TYMED_ISTORAGE;
			hresult = StgCreateDocfile(NULL, STGM_CREATE |
					STGM_SALL | STGM_DELETEONRELEASE,
					0, &pstg);
			if (hresult != NOERROR)
				goto errRtn;
			stgm.pstg = pstg;
		}
		else if ((cf == cfLinkSource) &&
				(pforetc->tymed & TYMED_ISTREAM))
		{
			// Choose Stream (Per spec)
			stgm.tymed = TYMED_ISTREAM;
			pstm = CreateMemStm((cbClass + cbDoc)*sizeof(OLECHAR),
					NULL);
			if (pstm == NULL)
			{
				hresult = ReportResult(0, E_OUTOFMEMORY, 0, 0);
				goto errRtn;
			}
			stgm.pstm = pstm;
		}
		else if (((cf == cfLinkSrcDescriptor) ||
				(cf == cfObjectDescriptor)) &&
				(pforetc->tymed & TYMED_HGLOBAL))
		{
			// Do not need to allocate handle now,
			// will be allocated below.
			stgm.tymed = TYMED_HGLOBAL;
		}
		else
		{
			// don't understand any other media types
			hresult = ResultFromScode(DV_E_TYMED);
			goto errRtn;
		}
	}
	else // GetDataHere
	{
		if ((((cf == cfEmbedSource) || (cf == cfEmbeddedObject)) &&
				!(pmedium->tymed &= TYMED_ISTORAGE)) ||
				(cf==cfLinkSource &&
				!(pmedium->tymed &= TYMED_ISTREAM)) ||
				(cf == cfObjectDescriptor) ||
				(cf == cfLinkSrcDescriptor))
		{
			hresult = ResultFromScode(DV_E_TYMED);
			goto errRtn;
		}
	}


	// Write the data to the medium
	switch (stgm.tymed)
	{
        case TYMED_ISTORAGE:
		if (cf == cfEmbedSource)
		{
			if (!CoIsOle1Class(clsid))
			{
				hresult = wHandleToStorage(stgm.pstg, hNative);
				if (hresult != NOERROR)
				{
					hresult = ResultFromScode(
							DV_E_CLIPFORMAT);
					goto errRtn;
				}
			}
			else
			{
#ifdef WIN32 // REVIEW, no OLE1-2 interop
				return(ReportResult(0, OLE_E_NOOLE1, 0, 0));
#else
				// Create a storage for a 1.0 object
				ErrRtnH(WriteClassStg(stgm.pstg,clsid));
		
				// If we ever decide to write a Format and
				// User Type for link objects, we'll need to
				// remove this check
				if (clsid != CLSID_StdOleLink)
				{
					if (wWriteFmtUserType(stgm.pstg,clsid)
							 != NOERROR)
					{
						// This happens when the class
						// is not registered.  Use class
						// name as user Type
						WriteFmtUserTypeStg(stgm.pstg,
								RegisterClipboardFormat(szClass),
								szClass);
					}
				}
				hresult = StSave10NativeData(stgm.pstg,
						hNative, FALSE);
				if (hresult != NOERROR)
				{
					hresult = ResultFromScode(
							DV_E_CLIPFORMAT);
					goto errRtn;
				}
				if (IsValidReadPtrIn(szItemName, 1)
					&& (szItemName[0] != '\0'))
				{
					StSave10ItemName(stgm.pstg, szItemName);
				}
#endif // WIN32
			}
		}
		else if (cf == cfEmbeddedObject)
		{
			hresult = wMakeEmbedObjForLink(stgm.pstg);
			if (hresult != NOERROR)
			{
				hresult = ResultFromScode(DV_E_CLIPFORMAT);
				goto errRtn;
			}
		}
		else
		{
			Assert(0);
			hresult = ResultFromScode(DV_E_CLIPFORMAT);
			goto errRtn;
		}
		break;

        case TYMED_ISTREAM:

		if (NOERROR != (hresult = ObjectLinkToMonikerStream(szDoc,
				cbDoc, clsid, stgm.pstm)))
		{
			AssertSz(0, "Cannot make Serialized moniker");
			goto errRtn;
		}

		hresult = WriteClassStm(stgm.pstm, clsid);
		break;
		
	case TYMED_HGLOBAL:
	{
		LPOLESTR szSrcOfCopy;
		STATIC const SIZEL sizel = {0, 0};	
		STATIC const POINTL pointl = {0, 0};	
		LONG cb; // holds the sizeof(szFullName), and the query
				// return length
		OLECHAR szFullName[256];

		Assert((cf == cfObjectDescriptor) ||
				(cf == cfLinkSrcDescriptor));
		Assert(clsid != CLSID_NULL);

		// allocate a string to hold the source name.  Note that when
		// this is composed below, we don't need to add an extra
		// character for the '\\'; cbDob and cbItemName both already
		// include the terminating NULL for the string, so the
		// backslash simply occupies one of those
		szSrcOfCopy = (LPOLESTR)PubMemAlloc((size_t)(cbDoc +
			cbItemName)*sizeof(OLECHAR));
		ErrZS(szSrcOfCopy, E_OUTOFMEMORY);

		// construct the copy source name
		_xstrcpy(szSrcOfCopy, szDoc);
		_xstrcat(szSrcOfCopy, OLESTR("\\"));
		_xstrcat(szSrcOfCopy, szItemName);

		// NULL terminate the string in case it is left untouched
		szFullName[0] = OLECHAR('\0');

		// set the result buffer size, and query the registry
		cb = sizeof(szFullName);
		RegQueryValue(HKEY_CLASSES_ROOT, szClass, szFullName, &cb);

		// check to see that the buffer was big enough for the name
		// REVIEW, if asserts aren't in the retail code, then we should
		// test for this, and possibly allocate a buffer big enough
		Assert(cb <= sizeof(szFullName));

		stgm.hGlobal = CreateObjectDescriptor(clsid, DVASPECT_CONTENT,
				&sizel, &pointl,
				OLEMISC_CANTLINKINSIDE | OLEMISC_CANLINKBYOLE1,
				szFullName, szSrcOfCopy);

		PubMemFree(szSrcOfCopy);
		break;
	}
	default:
		// catch any cases we missed
		Assert(0);
	}
	
	// copy back the results
	*pmedium = stgm;
	goto OK_Exit;

errRtn:
	// free storage if we used it
	if (pstg != NULL)
		pstg->Release();

	// free stream if we used it
	if (pstm != NULL)
		pstm->Release();

OK_Exit:
	if (szClass != NULL)
		GlobalUnlock(hOle1);

	if (!CloseClipboard())
		hresult = ResultFromScode(CLIPBRD_E_CANT_CLOSE);

	return(hresult);
}


#pragma SEG(Is10CompatibleLinkSource)
STATIC INTERNAL Is10CompatibleLinkSource(LPDATAOBJECT pDataObj)
{
	VDATEHEAP();

	FORMATETC formatetc;
	STGMEDIUM medium;
	LPLINKSRCDESCRIPTOR pLinkDescriptor;
	BOOL fCompatible;

	INIT_FORETC(formatetc);
	formatetc.cfFormat = cfLinkSrcDescriptor;
	formatetc.tymed = TYMED_HGLOBAL;
	
	RetErr(pDataObj->GetData(&formatetc, &medium));
	pLinkDescriptor = (LPLINKSRCDESCRIPTOR)GlobalLock(medium.hGlobal);
	RetZS(pLinkDescriptor, E_HANDLE);
	fCompatible = (pLinkDescriptor->dwStatus & OLEMISC_CANLINKBYOLE1) != 0;
	GlobalUnlock(medium.hGlobal);
	ReleaseStgMedium(&medium);

	return(fCompatible ? NOERROR : ResultFromScode(S_FALSE));
}


// returns clsid based on [LinkSrc,Object]Desciptor; for persist class from
// ObjectDescriptor which is a link, returns CLSID_StdOleLink;
// NOTE: the OLEMISC_ISLINKOBJECT bit is ignored in the link src descriptor.
#pragma SEG(GetClassFromDescriptor)
STATIC INTERNAL GetClassFromDescriptor(LPDATAOBJECT pDataObj, LPCLSID pclsid,
		BOOL fLink, BOOL fUser, LPOLESTR FAR* pszSrcOfCopy)
{
	VDATEHEAP();

	FORMATETC formatetc;
	STGMEDIUM medium;
	LPOBJECTDESCRIPTOR pObjDescriptor;
	HRESULT hresult;

	INIT_FORETC(formatetc);
	formatetc.cfFormat = fLink ? cfLinkSrcDescriptor : cfObjectDescriptor;
	formatetc.tymed = TYMED_HGLOBAL;
	medium.tymed = TYMED_NULL;
	
	hresult = pDataObj->GetData(&formatetc, &medium);
	AssertOutStgmedium(hresult, &medium);
	if (hresult != NOERROR)
		return(hresult);

	pObjDescriptor = (LPOBJECTDESCRIPTOR)GlobalLock(medium.hGlobal);
	RetZS(pObjDescriptor, E_HANDLE);
	*pclsid = (!fLink && !fUser &&
			(pObjDescriptor->dwStatus & OLEMISC_ISLINKOBJECT)) ?
			CLSID_StdOleLink : pObjDescriptor->clsid;
	if (pszSrcOfCopy)
	{
		*pszSrcOfCopy = UtDupString((LPOLESTR)
				(((BYTE FAR *)pObjDescriptor) +
				pObjDescriptor->dwSrcOfCopy));
	}
	GlobalUnlock(medium.hGlobal);
	ReleaseStgMedium(&medium);

	return(NOERROR);
}


#pragma SEG(SetOle1ClipboardFormats)
FARINTERNAL SetOle1ClipboardFormats(LPDATAOBJECT pDataObj)
{
	VDATEHEAP();

	HRESULT hresult; // error state so far
	LPENUMFORMATETC penumFormatEtc; // the data object's FORMATETC enum
	FORMATETC foretc; // used to hold the results of the enumerator Next()
	BOOL fLinkSourceAvail = FALSE;
	BOOL fLinkSrcDescAvail = FALSE;
	BOOL fEmbedObjAvail = FALSE;
	CLSID clsid;
	
	// Enumerate all formats offered by data object, set clipboard
	// with formats retrievable onhGbal.
	hresult = pDataObj->EnumFormatEtc(DATADIR_GET, &penumFormatEtc);
	if (hresult != NOERROR)
		return(hresult);
	
	while((hresult = penumFormatEtc->Next(1, &foretc, NULL)) == NOERROR)
	{
		if ((foretc.cfFormat == cfEmbedSource) ||
				(foretc.cfFormat == cfEmbeddedObject))
		{
			if (foretc.cfFormat == cfEmbeddedObject)
				fEmbedObjAvail = TRUE;

			// get the clsid of the object; user .vs. persist
			// clsid ignored since we only test against the
			// clsids below.
			if (NOERROR == GetClassFromDescriptor(pDataObj, &clsid,
					FALSE, FALSE, NULL) &&
					!IsEqualCLSID(clsid,
					CLSID_StaticMetafile) &&
					!IsEqualCLSID(clsid, CLSID_StaticDib))
			{
				SetClipboardData(cfNative, NULL);
				SetClipboardData(cfOwnerLink, NULL);
			}
		}
		else if (foretc.cfFormat == cfLinkSource)
		{
			fLinkSourceAvail = TRUE;
		}
		else if (foretc.cfFormat == cfLinkSrcDescriptor)
		{
			fLinkSrcDescAvail = TRUE;
		}
		else
		{
			// use only those TYMEDs OLE1 supported
			// make sure it is available
			// use first (highest fidelity) one enumerated
			if ((NULL == foretc.ptd) &&
					(foretc.tymed & (TYMED_HGLOBAL |
					TYMED_GDI | TYMED_MFPICT)) &&
					(NOERROR == pDataObj->QueryGetData(
					&foretc)) &&
					!IsClipboardFormatAvailable(
					foretc.cfFormat))
			{
				SetClipboardData(foretc.cfFormat, NULL);
			}
		}
		
		PubMemFree(foretc.ptd);
	}

	// Do not allow 1.0 link to 2.0 embedded object.
	if (fLinkSourceAvail && !fEmbedObjAvail &&
			(NOERROR == Is10CompatibleLinkSource(pDataObj)))
	{
		// ObjectLink should be after any presentation formats
		SetClipboardData(cfObjectLink, NULL);
		if (fLinkSrcDescAvail)
		{
			// Only offer LinkSrcDesc if offering a link, ie,
			// ObjectLink.  If clipboard is flushed, we don't want
			// to offer LinkSrcDesc thru the DataObj if we are not
			// offering LinkSrc.
			SetClipboardData(cfLinkSrcDescriptor, NULL);
		}
	}

	// Were they all enumerated successfully?
	if (GetScode(hresult) == S_FALSE)
		hresult = NOERROR;

	// release the enumerator
	penumFormatEtc->Release();

	return(hresult);
}


// RemoveClipDataObject
//
// Called from: WM_RENDERALLFORMATS, WM_DESTROYCLIPBOARD therefore
// clipboard is already open.
// We use hClipDataObj instead of calling GetClipboardData(cfDataObj)
// because GetClipboardData returns NULL (without asking us to render
// cfDataObject)--Windows bug?
//

#pragma SEG(RemoveClipDataObject)
STATIC INTERNAL_(void) RemoveClipDataObject(void)
{
	VDATEHEAP();

	IStream FAR* pStm;

	if (pClipDataObj == NULL)
	{
		Assert(NULL == hClipDataObj);
		return;
	}

	if (hClipDataObj != NULL)
	{
		pStm = CloneMemStm(hClipDataObj);
		Assert(pStm != NULL);
		CoReleaseMarshalData(pStm);
		pStm->Release();

		ReleaseMemStm(&hClipDataObj, /*fInternalOnly*/TRUE);
		hClipDataObj = NULL;
		SetClipboardData(cfDataObject, NULL);
				// hClipDataObj freed by call !!
	}
	else
	{
		// The Clipboard Data Object was never rendered.
	}

   	CoDisconnectObject(pClipDataObj, 0);
	pClipDataObj->Release();
	pClipDataObj = NULL;
}


// $$$
// Windows specifics
//

// Worker routines for ClipboardWndProc()
//

STATIC LRESULT RenderDataObject(void);


//+----------------------------------------------------------------------------
//
//	Function:
//		RenderOle1Format, static
//
//	Synopsis:
//		Ask object for data in the clip format that corresponds to the
//		requested Ole1 clip format, which is one of cfOwnerLink,
//		cfObjectLink, or cfNative.
//
//		REVIEW, what does this mean?  Is this an internal comment?
//		Note that pDataObj should never point to a fake data object
//		because	it is either pClipDataObj or pointer to a proxy to an
//		object pointed by pClipDataObj.
//
//	Arguments:
//		[cf] -- the desired clipboard format
//		[pDataObj] -- pointer to the IDataObject instance to get the
//			required rendition from
//
//	Returns:
//		A handle to memory containing the format.  This memory handle
//		is allocated appropriately for being placed on the clipboard.
//		If the call is unsuccessful, the handle is NULL.
//
//	Notes:
//
//	History:
//		12/13/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
STATIC HANDLE RenderOle1Format(CLIPFORMAT cf, LPDATAOBJECT pDataObj);


//+----------------------------------------------------------------------------
//
//	Function:
//		RenderFormat, static
//
//	Synopsis:
//REVIEW
// Ask object for data in the requested clip format.
// Ole1, Ole2 clip formats are not (and shouldn't be) handled.
// This is for private clipformats.
//
//	Arguments:
//		[cf] -- the requested clipboard format
//		[pDataObj] -- the data object to get the rendition from
//
//	Requires:
//
//	Returns:
//
//	Notes:
//
//	History:
//		12/13/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
STATIC HANDLE RenderFormat(CLIPFORMAT cf, LPDATAOBJECT pDataObj);


//+----------------------------------------------------------------------------
//
//	Function:
//		RenderFormatAndAspect, static
//
//	Synopsis:
//		Allocate a new handle and render the requested data aspect
//		in the requested format into it.
//
//	Arguments:
//		[cf] -- the desired clipboard format
//		[pDataObj] -- the IDataObject to get the data from
//		[dwAspect] -- the desired aspect
//
//	Returns:
//		the newly allocated handle, or NULL.
//
//	Notes:
//
//	History:
//		12/13/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
STATIC HANDLE RenderFormatAndAspect(CLIPFORMAT cf, LPDATAOBJECT pDataObj,
		DWORD dwAspect);


#ifndef _MAC

STATIC HWND hwndClipboard = NULL; // Window used for Ole clipboard handling


// Process delayed rendering messages.

#pragma SEG(ClipboardWndProc)
extern "C" LRESULT CALLBACK __loadds ClipboardWndProc(HWND hwnd,
		UINT message, WPARAM wparam, LPARAM lparam)
{
	VDATEHEAP();

	HANDLE hMem;
	CLIPFORMAT cf;

	switch(message)
	{
        case WM_RENDERFORMAT:

		cf = wparam;

		if (cf == cfDataObject)
			return(RenderDataObject());

		// An app had opened the clipboard and tried to get
		// a format with a NULL handle.  Ask object to provide data.
		//
		// Note that that while the above if() is executed in the
		// context of the process owning the clipboard (that is
		// pClipDataObj is valid) the code below may or may not
		// that of the clipboard owner.
		if (pClipDataObj == NULL)
			return(0);

		if ((cf == cfOwnerLink) || (cf == cfObjectLink) ||
				(cf == cfNative))
			hMem = RenderOle1Format(cf, pClipDataObj);
		else
			hMem = RenderFormat(cf, pClipDataObj);

		if (hMem != NULL)
		{
			SetClipboardData(cf, hMem);
		}


		return(0);

	case WM_RENDERALLFORMATS:

		// Server app is going away.
		// Open the clipboard and render all intresting formats.
		if (!OpenClipboard(GetClipboardWindow()))
			return(0);

		if (pClipDataObj)
		{
			RemoveClipDataObject();
			wEmptyClipboard();
		}

		// else clipboard was flushed, so we don't want to empty it
		Verify(CloseClipboard());

		return(0);

        case WM_DESTROYCLIPBOARD:
		// Another app is empting the clipboard; remove
		// DataObject (if any).
		// Note that that app had opened the clipboard

		RemoveClipDataObject();

		return(0);
	}

	return(DefWindowProc(hwnd, message, wparam, lparam));
}
#endif // _MAC


// An app tries to get access to object on clipboard
// Marshall its interface.  Note that while that app
// may or may not be the process that owns the clipboard
// the code below is always executed by the clipboard owner.
//
// "..., which makes the passed IDataObject accessible
// from the clipboard"
//
#pragma SEG(RenderDataObject)
STATIC LRESULT RenderDataObject(void)
{
	VDATEHEAP();

	HRESULT hresult;
	HANDLE hMem;
	IStream FAR* pStm;

	if (pClipDataObj == NULL)
		return(0);

	// Create shared memory stream to Marshal object's interface
	pStm = CreateMemStm(MARSHALINTERFACE_MIN, &hMem);
	if (pStm == NULL)
		return(0);

	// REVIEW - If data object's server is not running
	// MarshalInterface will fail.  It is possible (per spec)
	// for an app to set the clipboard with a pointer to
	// an object whose server is a different process (i.e.
	// with a pointer to defhdnlr).
	hresult = CoMarshalInterface(pStm, IID_IDataObject,
			pClipDataObj, 0, NULL, MSHLFLAGS_TABLESTRONG);
	pStm->Release();
	if (hresult != NOERROR)
	{
		GlobalFree(hMem);
		return(0);
	}

	SetClipboardData(cfDataObject, hMem);
	hClipDataObj = hMem;
	OleSetEnumFormatEtc(pClipDataObj, TRUE /*fClip*/);
	return(0);
}


INTERNAL wSzFixNet(LPOLESTR FAR* pszIn)
{
	VDATEHEAP();

#ifdef REVIEW32
//this doesn't seem to link well...look at it later

	LPBC pbc = NULL;
	UINT dummy = 0xFFFF;
	LPOLESTR szOut = NULL;
	HRESULT hresult= NOERROR;

	RetErr(CreateBindCtx(0, &pbc));
	ErrRtnH(SzFixNet(pbc, *pszIn, &szOut, &dummy));
	if (szOut)
	{
		delete *pszIn;
		*pszIn = szOut;
	}

	// else leave *pszIn unchanged
errRtn:	
	if (pbc)
		pbc->Release();
	return(hresult);

#endif  //REVIEW32
	return(E_NOTIMPL);
}


// MakeObjectLink
//
// Take the stream returned by GetData(CF_LINKSOURCE), which should be
// positioned just before the moniker,
// and create a clipboard handle for format ObjectLink or OwnerLink.
// (They look the same.)
//
// On entry:
// 	*ph is an un-alloc'd (probably NULL) handle
//
// On exit:
// 		If successful:
//	 		*ph is the Owner/ObjectLink
//			return NOERROR
//		If cannot make ObjectLink: (because there are > 1 ItemMonikers)
//			*ph = NULL
//			return S_FALSE
//
//
// Stream 	  ::= FileMoniker [:: ItemMoniker]
// ObjectLink ::= szClsid\0szFile\0szItem\0\0
//
#pragma SEG(MakeObjectLink)
INTERNAL MakeObjectLink(LPDATAOBJECT pDataObj, LPSTREAM	pStream,
		LPHANDLE ph, BOOL fOwnerLink)
{
	VDATEHEAP();

	HRESULT hr;
	LPMONIKER pmk = NULL; // the moniker reconstituted from the stream
	LPOLESTR szFile	= NULL;
	size_t cbFile; // length of szFile, if not NULL
	LPOLESTR szItem	= NULL;
	size_t cbItem; // length of szItem, if not NULL
	CLSID clsid;
	LPOLESTR pszCid = NULL;
	size_t cbCid; // length of pszCid, if not NULL
#ifdef MAYBE_LATER	
	LPMONIKER pmkReduced= NULL;
	LPBC pbc = NULL;
#endif // MAYBE_LATER
	UINT cb; // length of string to allocate for object link
	LPOLESTR pch; // used to rove over the object link and fill it in
	LARGE_INTEGER large_integer; // sets the seek position in the stream

	// validate ph
	VDATEPTROUT(ph, HANDLE);

	// initialize this in case of error returns
	*ph = NULL;

	// validate remaining parameters
	VDATEIFACE(pDataObj);
	VDATEIFACE(pStream);

	// move to the beginning of the stream
	LISet32(large_integer, 0);
	if (NOERROR != (hr = pStream->Seek(large_integer, STREAM_SEEK_SET,
			NULL)))
	{
		AssertSz (0, "Cannot seek to beginning of stream\r\n");
		goto errRtn;
	}

	// get the link moniker in active form
	if (NOERROR != (hr = OleLoadFromStream(pStream, IID_IMoniker,
			(LPLPVOID)&pmk)))
	{
		AssertSz (0, "Cannot get moniker from stream");
		goto errRtn;
	}

#ifdef MAYBE_LATER	
	// Reduction
	if (NOERROR != (hr = CreateBindCtx(&pbc)))
	{
		AssertSz(0, "Cannot create bind ctx");
		goto errRtn;
	}

	if (NOERROR != (hr = pmk->Reduce(pbc, MKRREDUCE_ALL, NULL,
			&pmkReduced)))
	{
		AssertSz(0, "Cannot reduce moniker");
		goto errRtn;
	}

	if (pmkReduced != NULL)
	{
		pmk->Release();
		pmk = pmkReduced;
		pmkReduced = NULL; // for ref counting reasons
	}
	else
	{
		Assert (hr == MK_REDUCED_TO_SELF);
	}
#endif // MAYBE_LATER

	// We now have the moniker, pmk.
//REVIEW32  Ole10_ParseMoniker has been temporarily removed

	if (!fOwnerLink /* && (NOERROR != Ole10_ParseMoniker(pmk,
			&szFile, &szItem)) */)
	{
		// Not a File or File::Item moniker
		hr = ReportResult(0, S_FALSE, 0, 0);
		goto errRtn;
	}

	wSzFixNet(&szFile);

	// Determine class to put in first piece of ObjectLink
	if (NOERROR != ReadClassStm(pStream, &clsid))
	{
		// get the clsid if the link source for use in ObjectLink
		if (NOERROR != (hr = GetClassFromDescriptor(pDataObj, &clsid,
				TRUE, TRUE, NULL)))
		{
			AssertSz (0, "Cannot determine clsid for file");
			goto errRtn;
		}
	}

	if ((hr = ProgIDFromCLSID(clsid, &pszCid)) != NOERROR)
		goto errRtn;

	// Allocate the ObjectLink handle.
	cb = (cbCid = _xstrlen(pszCid)) + (cbFile = _xstrlen(szFile)) +
			(szItem ? (cbItem = _xstrlen(szItem)) : 0) +
			4; // for the \0's
	*ph = GlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE, cb*sizeof(OLECHAR));
	if (NULL == *ph)
	{
		hr= ReportResult(0, E_OUTOFMEMORY, 0, 0);
		goto errRtn;
	}

	pch = (LPOLESTR)GlobalLock(*ph);
	if (NULL == pch)
	{
		hr = ReportResult(0, E_OUTOFMEMORY, 0, 0);
		GlobalFree(*ph);
		*ph = NULL;
		goto errRtn;
	}

	// Fill in the ObjectLink handle.
	_xstrcpy(pch, pszCid);
	pch += cbCid + 1; // skip over string and its null terminator

	// add the filename, and skip over its null terminator
	if ((NULL == szFile) || fOwnerLink)
		*pch++ = '\0';
	else
	{
		_xstrcpy(pch, szFile);
		pch += cbFile + 1;	
	}

	// embedded 2.0 objs should have no item
	if ((NULL == szItem) || fOwnerLink)
		*pch++ = '\0';
	else
	{
		_xstrcpy(pch, szItem);
		pch += cbItem + 1;	
	}

	// add final null terminator
	*pch++ = '\0';

	GlobalUnlock(*ph);

errRtn:
	if (pmk)
		pmk->Release();
#ifdef MAYBE_LATER
	if (pbc)
		pbc->Release();
#endif // MAYBE_LATER
	if (pszCid)
		PubMemFree(pszCid);
	if (szFile)
		PubMemFree(szFile);
	if (szItem)
		PubMemFree(szItem);

  	return(hr);
}


#pragma SEG(wNativeStreamToHandle)
STATIC INTERNAL	wNativeStreamToHandle(LPSTREAM pstm, LPHANDLE ph)
{
	VDATEHEAP();

	HRESULT hresult = NOERROR;
	DWORD dwSize; // the size of the stream content, stored in the stream
	LPVOID pv;

   	ErrRtnH(StRead(pstm, &dwSize, sizeof(DWORD)));
	
	ErrZS(*ph = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, dwSize),
			E_OUTOFMEMORY);
	ErrZS(pv = GlobalLock(*ph), E_OUTOFMEMORY);	
   	ErrRtnH(StRead(pstm, pv, dwSize));

errRtn:
	if (pv)
		GlobalUnlock(*ph);

	return(hresult);
}
	

#pragma SEG(wStorageToHandle)
STATIC INTERNAL wStorageToHandle(LPSTORAGE pstg, LPHANDLE ph)
{
	VDATEHEAP();

	CLSID clsid;
	HRESULT hresult = NOERROR; // error state so far
	LPLOCKBYTES plbData = NULL; // lock bytes on HGlobal instance
	LPSTORAGE pstgLB = NULL; // IStorage on ILockBytes on HGlobal

	// validate parameters
	VDATEPTROUT(ph, HANDLE);

	RetErr(CreateILockBytesOnHGlobal(NULL, /*fDeleteOnRelease*/ FALSE,
			&plbData));

	ErrRtnH(StgCreateDocfileOnILockBytes(plbData, STGM_CREATE | STGM_SALL,
			0, &pstgLB));

	// We remove the cache streams first, then copy, for three reasons:
	// 1. We are free to modify pstg; it was the result of a GetData.
	// 2. The CopyTo will have less work.
	// 3. Presumably the ultimate docfile on memory will be less sparse
	//    (since we are not removing anything from it).

	// read the class id
	// REVIEW, why?  This is not ever used anywhere!!!  Can we remove it?
	ErrRtnH(ReadClassStg(pstg, &clsid));
	
	// remove the cache streams
   	ErrRtnH(UtDoStreamOperation(pstg, NULL, OPCODE_REMOVE,
			STREAMTYPE_CACHE));

	// Copy what was given to us into a storage we can convert to a handle
	ErrRtnH(pstg->CopyTo(0, NULL, NULL, pstgLB));

	ErrRtnH(GetHGlobalFromILockBytes(plbData, ph));

errRtn:
	if (plbData)
		plbData->Release();
	if (pstgLB)
		pstgLB->Release();

	return(hresult);
}


#pragma SEG(wProgIDFromCLSID)
FARINTERNAL wProgIDFromCLSID(REFCLSID clsid, LPOLESTR FAR* psz)
{
	VDATEHEAP();

	HRESULT hresult;

	if (NOERROR == (hresult = ProgIDFromCLSID(clsid, psz)))
		return(NOERROR);

	if (IsEqualCLSID(clsid, CLSID_StdOleLink))
	{
		*psz = UtDupString(szStdOleLink);
		return(NOERROR);
	}

	return(hresult);
}


#pragma SEG(wCLSIDFromProgID)
FARINTERNAL wCLSIDFromProgID(LPOLESTR szClass, LPCLSID pclsid,
		BOOL fForceAssign)
{
	VDATEHEAP();

	size_t len;
	LONG cbValue;
	OLECHAR sz[400];

	if (0 == _xstrcmp(szClass, szStdOleLink))
	{
		*pclsid = CLSID_StdOleLink;
		return NOERROR;
	}

#ifdef NEVER
//REVIEW32: taken out for the moment
	return(ResultFromScode(E_NOTIMPL));
#endif // NEVER
	// return(CLSIDFromOle1Class(szClass, pclsid, fForceAssign));
//REVIEW
	// This code is taken directly from the original 16 bit ole2 release
	// implementation of CLSIDFromOle1Class.  The Ole1 compatibility lookup
	// is omitted.  That implementation was in base\compapi.cpp
	len = _xstrlen(szClass);
	_xmemcpy((void *)sz, szClass, len*sizeof(OLECHAR));
	sz[len] = OLESTR('\\');
	_xstrcpy(sz+len+1, OLESTR("Clsid"));
	if (RegQueryValue(HKEY_CLASSES_ROOT, sz, sz, &cbValue) == 0)
		return(CLSIDFromString(sz, pclsid));

	return(ResultFromScode(REGDB_E_KEYMISSING));
}

#pragma SEG(wGetEmbeddedObjectOrSource)
FARINTERNAL wGetEmbeddedObjectOrSource (LPDATAOBJECT pDataObj,
		LPSTGMEDIUM pmedium)
{
	VDATEHEAP();

	HRESULT hresult;
	FORMATETC foretc;

	// Prepare formatetc
	INIT_FORETC(foretc);
	foretc.tymed = TYMED_ISTORAGE;

	// Prepare medium for GetDataHere calls
	pmedium->pUnkForRelease = NULL;
	pmedium->tymed = TYMED_ISTORAGE;
	RetErr(StgCreateDocfile(NULL,
			STGM_CREATE | STGM_SALL | STGM_DELETEONRELEASE,
			0, &(pmedium->pstg)));

	// Try cfEmbeddedObject Here
	foretc.cfFormat = cfEmbeddedObject;
	hresult = pDataObj->GetDataHere(&foretc,pmedium);
	if (NOERROR == hresult)
		return NOERROR;

	// Try cfEmbedSource Here
	foretc.cfFormat = cfEmbedSource;
	hresult = pDataObj->GetDataHere(&foretc,pmedium);
	if (NOERROR == hresult)
		return NOERROR;

	// Prepare medium for GetData calls, free temp stg
	ReleaseStgMedium(pmedium);

	// Try cfEmbeddedObject
	foretc.cfFormat = cfEmbeddedObject;
	hresult = pDataObj->GetData(&foretc,pmedium);
	AssertOutStgmedium(hresult, pmedium);
	if (NOERROR == hresult)
		return NOERROR;

	// Try cfEmbedSource
	foretc.cfFormat = cfEmbedSource;
	hresult = pDataObj->GetData(&foretc,pmedium);
	AssertOutStgmedium(hresult, pmedium);
	if (NOERROR == hresult)
		return NOERROR;

	// Failure
	return(ResultFromScode(DV_E_FORMATETC));
}


#pragma SEG(RenderOle1Format)
STATIC HANDLE RenderOle1Format(CLIPFORMAT cf, LPDATAOBJECT pDataObj)
{
	VDATEHEAP();

	HRESULT hresult; // errors state so far
	STGMEDIUM stgm; // dummy storage medium where returned handle may
			// be created

	// following variables are initialized so they can be used in error
	// condition cleanup at the end of the function
	LPSTREAM pstmNative = NULL; // native format stream that some formats
			// may use
	LPOLESTR pszCid = NULL; // a string that is the object class name
	HANDLE hMem = NULL; // return value

	// initialize the storage medium
	stgm.tymed = TYMED_NULL;
	stgm.pstg = NULL;
	stgm.pUnkForRelease = NULL;

	if (cf == cfOwnerLink)
	{
		LPOLESTR szSrcOfCopy; // text name of object being transferred
		LPOLESTR pMem; // access to locked hMem
		size_t uCidLen; // length of pszCid
		size_t uSrcOfCopyLen; // length of szSrcOfCopy
		CLSID clsid; // class id of the object being transferred

		// get the clsid from the object; we care about getting the link
		// clsid if the object is indeed a link.
		ErrRtnH(GetClassFromDescriptor(pDataObj, &clsid, FALSE,
				FALSE, &szSrcOfCopy));

		// cfObjectDescriptor -> OwnerLink szClassname\0\0\0\0

		// converts the link clsid specially
		ErrRtnH(wProgIDFromCLSID(clsid, &pszCid));

		uCidLen = _xstrlen(pszCid);
		uSrcOfCopyLen = szSrcOfCopy ? _xstrlen(szSrcOfCopy) : 0;
		hMem = GlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE,
				(uCidLen + uSrcOfCopyLen + 4)* sizeof(OLECHAR));
		ErrZS(hMem, E_OUTOFMEMORY);

		pMem = (LPOLESTR)GlobalLock(hMem);
		ErrZS(pMem, E_OUTOFMEMORY);
	
		// create the owner link format
		_xmemcpy((void FAR *)pMem, (const void FAR *)pszCid,
				uCidLen*sizeof(OLECHAR));
		pMem += uCidLen;
		*pMem = OLESTR('\0');
		_xmemcpy((void FAR *)++pMem, (const void FAR *)szSrcOfCopy,
				uSrcOfCopyLen*sizeof(OLECHAR));
		pMem += uSrcOfCopyLen;
		*pMem = OLESTR('\0');
		*++pMem = OLESTR('\0');
		
		PubMemFree(szSrcOfCopy);
		GlobalUnlock(hMem);
	}
	else if (cf == cfObjectLink)
	{
		FORMATETC foretc; // format descriptor for rendition request

		INIT_FORETC(foretc);

		// First check if cfObjectLink is offered by the DataObject
		// directly.  Servers do this when they want OLE1 containers
		// to link to something different from what OLE2 containers
		// link to.  For instance, they may provide a wrapper object
		// of their own class so OLE1 conatiners can link to the
		// outside of an embedded object.
		foretc.tymed = TYMED_HGLOBAL;
		foretc.cfFormat = cfObjectLink;
		hresult = pDataObj->GetData(&foretc, &stgm);
		AssertOutStgmedium(hresult, &stgm);
		if (NOERROR == hresult)
			hMem = UtDupGlobal(stgm.hGlobal, GMEM_MOVEABLE);
		else
		{
			// Otherwise generate the ObjectLink from cfLinkSource
			foretc.tymed = TYMED_ISTREAM;
			foretc.cfFormat = cfLinkSource;

			hresult = pDataObj->GetData(&foretc,&stgm);
			AssertOutStgmedium(hresult, &stgm);
			if (hresult != NOERROR)
			{
				Warn("Could not GetData(cfLinkSource, TYMED_ISTREAM)");
				return(NULL);
			}

			// cfLinkSource -> ObjectLink ==
			//			szClassName\0szFile\0szItem\0\0
			ErrRtnH(MakeObjectLink(pDataObj, stgm.pstm, &hMem,
					FALSE));
		}
	}
	else if (cf == cfNative)
	{
		ErrRtnH(wGetEmbeddedObjectOrSource(pDataObj, &stgm));

		if (NOERROR == stgm.pstg->OpenStream(OLE10_NATIVE_STREAM, NULL,
				STGM_SALL, 0, &pstmNative))
		{
			ErrRtnH(wNativeStreamToHandle(pstmNative, &hMem));
		}
		else
		{
			ErrRtnH(wStorageToHandle(stgm.pstg, &hMem));
		}
		Assert(hMem);
	}
	else
	{
		// unknown format
		return(NULL);
	}

errRtn:
	ReleaseStgMedium(&stgm);
	if (pstmNative)
		pstmNative->Release();
	if ((hresult != NOERROR) && (hMem != NULL))
	{
		GlobalFree(hMem);
		hMem = NULL;
	}
	PubMemFree(pszCid);
	return(hMem);
}


#pragma SEG(RenderFormatAndAspect)
STATIC HANDLE RenderFormatAndAspect(CLIPFORMAT cf, LPDATAOBJECT pDataObj,
		DWORD dwAspect)
{
	VDATEHEAP();

	HRESULT hresult;
	HANDLE hMem; // the return value
	FORMATETC foretc; // the format descriptor for data requests based on cf
	STGMEDIUM stgm; // the storage medium for data requests

	// REVIEW: if object can't return hglobal probably should try all
	// possible mediums, convert to hglobal.  For now only try hglobal.
	
	// initialize format descriptor
	INIT_FORETC(foretc);
	foretc.cfFormat = cf;
	foretc.tymed = UtFormatToTymed(cf);
	foretc.dwAspect = dwAspect;

	// initialize medium for fetching
	stgm.tymed = TYMED_NULL;
	stgm.hGlobal = NULL;

	hresult = pDataObj->GetData(&foretc, &stgm);
	AssertOutStgmedium(hresult, &stgm);
	if (hresult != NOERROR)
		goto ErrorExit;

	if (stgm.pUnkForRelease == NULL)
		hMem = stgm.hGlobal;
	else
	{
		hMem = OleDuplicateData(stgm.hGlobal, foretc.cfFormat,
				GMEM_DDESHARE | GMEM_MOVEABLE);
		
		ReleaseStgMedium(&stgm);
	}

	return(hMem);

ErrorExit:
	return(NULL);
}


#pragma SEG(RenderFormat)
STATIC HANDLE RenderFormat(CLIPFORMAT cf, LPDATAOBJECT pDataObj)
{
	VDATEHEAP();

	HANDLE h;

	if (h = RenderFormatAndAspect(cf, pDataObj, DVASPECT_CONTENT))
		return(h);

 	if (h = RenderFormatAndAspect(cf, pDataObj, DVASPECT_DOCPRINT))
		return(h);

 	if (h = RenderFormatAndAspect(cf, pDataObj, DVASPECT_THUMBNAIL))
		return(h);

 	return(RenderFormatAndAspect(cf, pDataObj, DVASPECT_ICON));
}  	



// Mapping of thread ID to a clipboard window handle.
// WIN32 : Only looks for thread IDs of the current process; resides in
// instance data.
// REVIEW, if the OLE compound document model is single-threaded, do we need
// this?  There should only be one thread ID => one window handle
STATIC CMapUintHwnd FAR * pTaskToClip = NULL;

#ifndef _MAC
// Get clipboard window handle of the current process.
//

#pragma SEG(GetClipboardWindow)
HWND GetClipboardWindow(void)
{
	VDATEHEAP();

	HWND hwnd;

	if ((NULL == pTaskToClip) &&
			(pTaskToClip = new CMapUintHwnd()) == NULL)
		return NULL;

	if (!pTaskToClip->Lookup(GetCurrentThreadId(), hwnd))
	{
		// Create an invisible window which will handle all of this
		// app's delay rendering messages.  Even though hInstance is
		// specified as being the DLL's rather than the app's, the
		// thread whose stack this function is called with is the one
		// whose msg queue will be associated with this window.
		hwnd = CreateWindow(szClipboardWndClass, OLESTR(""), WS_POPUP,
				CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
				CW_USEDEFAULT, NULL, NULL, hmodOLE2,
				NULL);

		if (hwnd != NULL)
			Verify(pTaskToClip->SetAt(GetCurrentThreadId(), hwnd));
	}

	return(hwnd);
}
#endif // _MAC


// this keeps track of the number of times the clipboard has been
// initialized; it is incremented for each initialization, and decremented
// for each uninitialization
// REVIEW, does this variable have to be per-thread, or per-process for the DLL?
STATIC ULONG cClipboardInit = 0;

#pragma SEG(ClipboardInitialize)
FARINTERNAL_(BOOL) ClipboardInitialize(void)
{
	VDATEHEAP();

#ifndef _MAC
    WNDCLASS wc;

	// One time initializtaion (when loaded for the first time)
	if (cClipboardInit++ == 0)
	{
		// The first process to load this DLL

		// Register Clipboard window class
		wc.style = 0;
		wc.lpfnWndProc = ClipboardWndProc;
		wc.cbClsExtra = 0;
		wc.cbWndExtra = 4; // REVIEW, what's this the sizeof()?
		wc.hInstance = hmodOLE2;
		wc.hIcon = NULL;
		wc.hCursor = NULL;
		wc.hbrBackground = NULL;
		wc.lpszMenuName =  NULL;
		wc.lpszClassName = szClipboardWndClass;

		// register this window class, returning if we fail
		if (!RegisterClass(&wc))
		{
			cClipboardInit--;
			return(FALSE);
		}
	}

	// Remove the current htask from the map; the only reason this
	// htask would be in the map is that it got reused
	// REVIEW, if CD model is single threaded, do we need this?
	if (pTaskToClip != NULL)
		pTaskToClip->RemoveKey(GetCurrentThreadId());

#endif // _MAC
	return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Function:   ClipboardUninitialize
//
//  Synopsis:
//
//  Effects:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    15-Feb-94 AlexT     Added delete call (and this comment block)
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(ClipboardUninitialize)
FARINTERNAL_(void) ClipboardUninitialize(void)
{
	VDATEHEAP();

#ifndef _MAC
	HWND hwnd;

	// REVIEW, do we need this pTaskToClip stuff?
	if (pTaskToClip != NULL &&
			pTaskToClip->Lookup(GetCurrentThreadId(), hwnd))
	{
		DestroyWindow(hwnd);

		pTaskToClip->RemoveKey(GetCurrentThreadId());
	}

	// Last process using this DLL?
	if (--cClipboardInit == 0)
	{
		// NULL out in case dll is not actually unloaded

                delete pTaskToClip;
		pTaskToClip = NULL;

		// since the last reference has gone away, unregister wnd class
		UnregisterClass(szClipboardWndClass, hmodOLE2);
	}
#endif // _MAC
}


STATIC INTERNAL_(BOOL) wEmptyClipboard(void)
{
	VDATEHEAP();

	OleRemoveEnumFormatEtc(TRUE /*fClip*/);
	return(EmptyClipboard());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\clipbrd\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   clipbrd
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\..\common\$(DEST_TREE);..\..\..\ih;..\..\inc

SOURCES=      \
              ..\clipapi.cpp \
              ..\clipdata.cpp

UMTYPE=       windows
!include ..\..\precomp2.inc
USE_IOSTREAM=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\clipbrd\clipdata.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: 	clipdata.cpp
//
//  Contents: 	implementation of CClipDataObject
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  added Dump method to CClipDataObject,
//                                  CEnumFormatEtcDataArray and added APIs
//                                  DumpCClipDataObject, DumpCEnumFormatEtcDataArray
//              09-Jan-95 t-scotth  changed VDATETHREAD to accept a pointer, and
//                                  ensured VDATETHREAD is before VDATEPTRIN and
//                                  VDATEPTROUT
//		21-Nov-94 alexgo    added thread validation
//		11-Aug-94 alexgo    added support for EmbeddedObject from
//				    OLE1 formats.
//		04-Jun-94 alexgo    now converts OLE1 formats into OLE2
//		30-May-94 alexgo    now supports enhanced metafiles
//		17-May-94 alexgo    now use OleOpenClipboard instead of
//				    OpenClipboard.
//		11-May-94 alexgo    eliminated allocations for 0
//				    bytes from the enumerator.
//    		02-Apr-94 alexgo    author
//
//  Notes:
//		This file is laid out as follows:
//			ClipboardDataObject private methods
//			ClipboardDataObject IDataObject methods
//			OLE1 support functions (in alphabetical order)
//			Formatetc Enumerator methods
//
//--------------------------------------------------------------------------

#include <le2int.h>
#include <getif.hxx>
#include "clipdata.h"
#include "clipbrd.h"
#include <ostm2stg.h>	//for wCLSIDFromProgID and GenericObjectToIStorage
#include <reghelp.hxx>

#ifdef _DEBUG
#include <dbgdump.h>
#endif // _DEBUG

// helper function used by the data object and formatetc enumerator
HRESULT BmToPres(HANDLE hBM, PPRES ppres);
BOOL 	CanRetrieveOle2FromOle1( UINT cf);
HRESULT DibToPres(HANDLE hDib, PPRES ppres);
BOOL 	IsOwnerLinkStdOleLink( void );
HRESULT	MfToPres( HANDLE hMFPict, PPRES ppres);
HRESULT NativeToStorage(IStorage *pstg, HANDLE hNative);

//+-------------------------------------------------------------------------
//
//  Member:  	CClipDataObject::CClipDataObject
//
//  Synopsis:	constructor
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns:	void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:	initializes reference count to 1

//
//  History:    dd-mmm-yy Author    Comment
//		02-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

CClipDataObject::CClipDataObject( )
{
    m_refs 		= 1;
    m_Internalrefs	= 0; // Up To Caller to Place InternalRef.
    m_pFormatEtcDataArray	= NULL;
    // OLE1 support stuff

    m_hOle1 	= NULL;
    m_pUnkOle1	= NULL;

    // Data object to use to get the data.
    m_pDataObject   = NULL;
    m_fTriedToGetDataObject = FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CClipDataObject::~CClipDataObject
//
//  Synopsis:	destructor
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns:	void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:	frees the formatetc array (if one exists)
//
//  History:    dd-mmm-yy Author    Comment
//		19-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

CClipDataObject::~CClipDataObject( )
{

    if (m_pDataObject != NULL) 
    {
	// Release our reference to the data object.
	m_pDataObject->Release();
    }


    if (m_pFormatEtcDataArray)
    {

	if (0 == --m_pFormatEtcDataArray->_cRefs) 
	{ 
	    PrivMemFree(m_pFormatEtcDataArray); 
	    m_pFormatEtcDataArray = NULL; 
	}

    }

}


//+-------------------------------------------------------------------------
//
//  Member:  	CClipDataObject::GetRealDataObjPtr (private)
//
//  Synopsis:   Get clip board data object from the clipboard
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns:	void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:	If we've tried this before, then return; otherwise:
//		Open the clipboard. Get the data object from the clipboard
//              if it is there. Close the clipboard and update our private
//              member.
//
//  History:    dd-mmm-yy Author    Comment
//		12-Aug-94 alexgo    handle identity better
//		17-Jun-94 alexgo    optimized
//		13-Jun-94 Ricksa    author
//
//  Notes: 	We must only try to get the real data object once in order
//		to preserve OLE identity.  Recall that we call this function
//		if somebody does a QI for IUnknown.  Now suppose that
//		GetInterfaceFromWindowProp fails for a 'benign' reason
//		(like we're in the middle of processing a send message).
//		Our QueryInterface will then return *our* IUnknown, thus
//		establishing the identity of this object to be CClipDataObject.
//
//		Now suppose another call to QI for IUnknown is made.  If
//		we simply noticed that m_pDataObject was NULL and called
//		GetInterfaceFromWindowProp again, it could succeed and we
//		would return a *different* IUnknown (thus violating OLE
//		object identity).
//
//		For this reason, we only allow one call to
//		GetInterfaceFromWindowProp.
//
//		Note that it is not strictly necessary to disable multiple
//		calls to GetInterfaceFromWindowProp for GetData and
//		GetDataHere methods.  Neither of these methods affect
//		object identity.  However, for the sake of consistency and
//		simplicity (!), we treat GetData and QI the same.
//		
//--------------------------------------------------------------------------    

LPDATAOBJECT CClipDataObject::GetRealDataObjPtr( )
{
    HGLOBAL		hDataObject;
    HWND *		phClipWnd;
    HWND            hClipWnd = NULL;
    HRESULT		hresult;

#if DBG == 1
    BOOL            fCloseClipSucceeded;
#endif // DBG

    LEDebugOut((DEB_ITRACE,
        "%p _IN CClipDataObject::GetRealDataObjPtr ( )\n", this));

    // if we already have a data object, or we've already tried and failed
    // to get one, then we don't need to do any work here.

    if( m_pDataObject || m_fTriedToGetDataObject == TRUE )
    {
        goto logRtn;
    }

    // if cfDataObject is not on the clipboard, don't bother opening it;
    // we know that we can't get a data object.

    if( !SSIsClipboardFormatAvailable(g_cfDataObject))
    {
        goto errRtn;
    }

    //
    //
    // BEGIN: OPEN CLIPBOARD
    //
    //

    // Open the clipboard in preparation  for the get
    hresult = OleOpenClipboard(NULL, NULL);

    if( hresult != NOERROR )
    {
        LEDebugOut((DEB_ERROR, "ERROR: OleOpenClipboard failed!\n"));
        goto errRtn;
    }

    hDataObject = SSGetClipboardData(g_cfDataObject);

    if( hDataObject )
    {
        phClipWnd = (HWND *)GlobalLock(hDataObject);

        LEERROR(phClipWnd == NULL, "GlobalLock failed!");

        if( phClipWnd )
        {
            hClipWnd = *phClipWnd;
            GlobalUnlock(hDataObject);
        }
    }


#if DBG == 1
    fCloseClipSucceeded =

#endif // DBG

    SSCloseClipboard();

#if DBG == 1
    // We only report this error in debug
    if (!fCloseClipSucceeded)
    {
        LEDebugOut((DEB_ERROR, "ERROR: CloseClipboard failed!\n"));
    }

#endif // DBG

    //
    //
    // END: CLOSE CLIPBOARD
    //
    //

    if( hClipWnd )
    {
        // See if we can get a data object
        hresult = GetInterfaceFromWindowProp( hClipWnd,
                IID_IDataObject,
                (IUnknown **) &m_pDataObject,
                CLIPBOARD_DATA_OBJECT_PROP );


#if DBG ==1
        if( hresult != NOERROR )
        {
            Assert(m_pDataObject == NULL);
        }
        else
        {
            Assert(m_pDataObject != NULL);
        }
#endif // DBG == 1

    }

errRtn:

logRtn:

    // if we didn't get a data object, then set a flag so we
    // don't try to do this again.
    m_fTriedToGetDataObject = TRUE;


    LEDebugOut((DEB_ITRACE,
        "%p OUT CClipDataObject::GetRealDataObjPtr ( ) "
            "[ %p ]\n", this, m_pDataObject));

    return m_pDataObject;
}


//+-------------------------------------------------------------------------
//
//  Member:  	CClipDataObject::GetFormatEtcDataArray (private)
//
//  Synopsis:   if don't already have shared formats creates.
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		13-Jun-94 Ricksa    author
//
//  Notes: 	
//		
//--------------------------------------------------------------------------

HRESULT CClipDataObject::GetFormatEtcDataArray()
{
    HRESULT			hresult = ResultFromScode(E_OUTOFMEMORY);
    UINT			cfFormat = NULL;
    ULONG			i;
    ULONG			cExtraFormats;
    FORMATETCDATA *		pFormatEtcData; 
    DWORD			cTotal; 
    DWORD			dwSize; 
    DWORD			flatmediums, structuredmediums;

#define MAX_OLE2FORMATS		4	// we can at most construct 4 OLE2
					// formats from OLE1 data

    if (m_pFormatEtcDataArray) // if already have the formats just return.
	return NOERROR;

    // 16bit apps do binary comparisons on the tymed instead
    // of bit-masking.  This is a hack to make them work.
    if( IsWOWThread() )
    {
        flatmediums = TYMED_HGLOBAL;
        structuredmediums = TYMED_ISTORAGE;
    }
    else
    {
        flatmediums = (TYMED_HGLOBAL | TYMED_ISTREAM);
        structuredmediums = (TYMED_ISTORAGE | TYMED_ISTREAM |
                    TYMED_HGLOBAL);
    }


    Assert(m_pFormatEtcDataArray == NULL);

    //
    // BEGIN: OPENCLIPBOARD
    //
    //

    hresult = OleOpenClipboard(NULL, NULL);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    // first count the number of formats on the clipboard

    cTotal = CountClipboardFormats();

    // don't include OLE's private clipboard formats in the count
    if (SSIsClipboardFormatAvailable(g_cfDataObject))
	cTotal--;
    if (SSIsClipboardFormatAvailable(g_cfOlePrivateData))
	cTotal--;

    // now allocate memory for the array
    // if there are zero formats, then don't bother allocating
    // the memory

    Assert((LONG) cTotal >= 0);

    // here we will allocate enough memory for the formats
    // we know about plus enough to cover any OLE2 formats
    // that we might be able to synthesize from OLE1 formats

    dwSize = ((cTotal + MAX_OLE2FORMATS) * sizeof(FORMATETCDATA)) 
		    + sizeof(FORMATETCDATAARRAY);

    m_pFormatEtcDataArray = (FORMATETCDATAARRAY *) PrivMemAlloc(dwSize);

    if( !m_pFormatEtcDataArray )
    {
        hresult = ResultFromScode(E_OUTOFMEMORY);
        if( !SSCloseClipboard() )
        {
            LEDebugOut((DEB_WARN, "WARNING: "
                "CloseClipboard failed!\n"));
            ;  // no-op to keep the compiler happy
        }

        //
        // END: CLOSECLIPBOARD
        //
        goto errRtn;
    }

    _xmemset(m_pFormatEtcDataArray, 0,dwSize); 
    m_pFormatEtcDataArray->_dwSig = 0;
    m_pFormatEtcDataArray->_dwSize = dwSize;
    m_pFormatEtcDataArray->_cRefs = 1;
    m_pFormatEtcDataArray->_fIs64BitArray = IS_WIN64;


    // first check to see if we can synthesize any OLE2 formats
    // from OLE1 data.

    cExtraFormats = 0;

    pFormatEtcData = &(m_pFormatEtcDataArray->_FormatEtcData[0]); // point to first value.

    // check for EmbedSource first
    if( CanRetrieveOle2FromOle1(g_cfEmbedSource) )
    {
        // set up a formatetc entry for EmbedSource
	
        INIT_FORETC(pFormatEtcData->_FormatEtc);
        pFormatEtcData->_FormatEtc.cfFormat =
                g_cfEmbedSource;
        pFormatEtcData->_FormatEtc.tymed =
                structuredmediums;

        cExtraFormats++;
	pFormatEtcData++;

        // we only want to support cfObjectDescriptor if we
        // can offer EmbedSource (which is why we're in this
        // if block)

        if( CanRetrieveOle2FromOle1(g_cfObjectDescriptor) )
        {
            INIT_FORETC(pFormatEtcData->_FormatEtc);
            pFormatEtcData->_FormatEtc.cfFormat =
                g_cfObjectDescriptor;
            pFormatEtcData->_FormatEtc.tymed =
                flatmediums;

            cExtraFormats++;
	    pFormatEtcData++;
        }
    }


    // check for EmbeddedObject
    if( CanRetrieveOle2FromOle1(g_cfEmbeddedObject) )
    {
        // set up a formatetc entry for EmbedSource

        INIT_FORETC(pFormatEtcData->_FormatEtc);
        pFormatEtcData->_FormatEtc.cfFormat =
                g_cfEmbeddedObject;
        pFormatEtcData->_FormatEtc.tymed =
                structuredmediums;

        cExtraFormats++;
	pFormatEtcData++;

        // we only want to support cfObjectDescriptor if we
        // can offer EmbedEmbedded (which is why we're in this
        // if block)

        if( CanRetrieveOle2FromOle1(g_cfObjectDescriptor) )
        {
            INIT_FORETC(pFormatEtcData->_FormatEtc);
            pFormatEtcData->_FormatEtc.cfFormat =
                g_cfObjectDescriptor;
            pFormatEtcData->_FormatEtc.tymed =
                flatmediums;

            cExtraFormats++;
	    pFormatEtcData++;

        }
    }
    // check for LinkSource

    if( CanRetrieveOle2FromOle1(g_cfLinkSource) )
    {
        INIT_FORETC(pFormatEtcData->_FormatEtc);
        pFormatEtcData->_FormatEtc.cfFormat =
                g_cfLinkSource;

        // for LinkSource in WOW, we want to explicitly offer
        // only ISTREAM tymed because that's what 16bit code
        // did.
        if( IsWOWThread() )
        {
            pFormatEtcData->_FormatEtc.tymed =
                TYMED_ISTREAM;
        }
        else
        {
            pFormatEtcData->_FormatEtc.tymed =
                    flatmediums;
        }

        cExtraFormats++;
	pFormatEtcData++;

        // we only want to support cfLinkSrcDescriptor if we
        // can offer LinkSource

        if( CanRetrieveOle2FromOle1(g_cfLinkSrcDescriptor) )
        {
            INIT_FORETC(pFormatEtcData->_FormatEtc);
            pFormatEtcData->_FormatEtc.cfFormat =
                g_cfLinkSrcDescriptor;
            pFormatEtcData->_FormatEtc.tymed =
                flatmediums;

            cExtraFormats++;
	    pFormatEtcData++;
        }
    }

    // Update Shared Format Header.

    Assert(cExtraFormats  <= MAX_OLE2FORMATS);

    cTotal += cExtraFormats;
    m_pFormatEtcDataArray->_cFormats = cTotal;


    // now we need to go through and initialize each formatetc array
    // for the remaining formats available directly on the clipboard
    // NB: this includes any ole1 formats from which constructed OLE2
    // formats above.  This will make it easier for apps, the interop
    // layer, and our api's to special case behaviour for backwards
    // compatibility with old apps.

    cfFormat = NULL;
    // we increment the loop counter at the bottom (so we can skip
    // private clipboard formats)

    // pFormatEtcData points to the proper starting position.

    for( i = cExtraFormats;  i < cTotal; i++ )
    {
        // lindex == DEF_LINDEX
        // aspect == DVASPECT_CONTENT
        // ptd == NULL

        INIT_FORETC(pFormatEtcData->_FormatEtc);

        cfFormat = SSEnumClipboardFormats(cfFormat);

        Assert(cfFormat);	// if it's NULL, something
                    // really weird is happening.

        pFormatEtcData->_FormatEtc.cfFormat = (CLIPFORMAT) cfFormat;

        // try to make some reasonable guesses as to what's
        // there.

        switch( cfFormat )
        {
        case CF_BITMAP:
        case CF_PALETTE:
            pFormatEtcData->_FormatEtc.tymed = TYMED_GDI;
            break;

        case CF_METAFILEPICT:
            pFormatEtcData->_FormatEtc.tymed = TYMED_MFPICT;
            break;

        case CF_ENHMETAFILE:
            pFormatEtcData->_FormatEtc.tymed = TYMED_ENHMF;
            break;

        default:
            // check for Storage-based OLE2 formats.
            if( cfFormat == g_cfEmbedSource ||
                cfFormat == g_cfEmbeddedObject )
            {
                // we can get these on any structured and flat
                // mediums
                pFormatEtcData->_FormatEtc.tymed =
                        structuredmediums;

                // In order to get here, the app must have
                // manually set these formats on the clipboard
                // (i.e. by not using OleSetClipboard()).

                // This is OK, but print out a warning.

                LEDebugOut((DEB_WARN, "WARNING: Ole2 formats "
                    "unexpected on clipboard\n"));
            }
            else
            {
                // we don't know, so be safe and just answer
                // with flat mediums
               pFormatEtcData->_FormatEtc.tymed =
                        flatmediums;
            }
            break;
        }

	++pFormatEtcData;
    }


    if( !SSCloseClipboard() )
    {
        LEDebugOut((DEB_WARN, "WARNING: CloseClipboard failed!\n"));
        ; 	// no-op to keep the compiler happy
    }

    //
    //
    // END: CLOSECLIPBOARD
    //
    //

    hresult = NOERROR;

errRtn:

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Member: 	CClipDataObject::MatchFormatetc
//
//  Synopsis:	checks the given formatetc against the array of formatetc's
//		that is on the Native Clipboard. 
//
//  Effects:
//
//  Arguments: 	[pformatetc]	-- the formatetc to check
//		[fNativeOnly]	--  If Set, return valid matches for only items that are on the Native clipboard.
//		[ptymed]	-- where to stuff the tymed of the *original*
//				   formatetc (may be NULL)
//
//  Requires:
//
//  Returns: 	FormatMatchFlag --
//			FORMAT_NOTFOUND - Format was not found in Enumerator or synthesized Data.
//			FORMAT_BADMATCH - Format or synthesized Found but doesn't match
//			FORMAT_GOODMATCH - Format Found in Enumerator or is valid synthesized data.
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		18-Aug-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

typedef struct SYNTHESIZED_MAP 
{
    CLIPFORMAT	cfSynthesized; // Synthesized Formats
    CLIPFORMAT	cfOrig; // Original Format.
} SYNTHESIZED_MAP;

#define CF_MAXSYNTHESIZED CF_ENHMETAFILE // CF_ENHMETAFILE == 14 and >> cfFormat value we check.

#define NumSynthesizedFormats 12  // Number of Synthesized formats in the Array.
const SYNTHESIZED_MAP pSynthesized[] = {
    CF_DIB,	    CF_BITMAP,
    CF_BITMAP,	    CF_DIB,
    CF_PALETTE,	    CF_DIB,
    CF_PALETTE,	    CF_BITMAP,
    CF_METAFILEPICT,CF_ENHMETAFILE,
    CF_ENHMETAFILE, CF_METAFILEPICT,
    CF_TEXT,	    CF_OEMTEXT,
    CF_TEXT,	    CF_UNICODETEXT,
    CF_OEMTEXT,	    CF_TEXT,
    CF_OEMTEXT,	    CF_UNICODETEXT,
    CF_UNICODETEXT, CF_OEMTEXT,
    CF_UNICODETEXT, CF_TEXT
};

FormatMatchFlag CClipDataObject::MatchFormatetc( FORMATETC *pformatetc,BOOL fNativeOnly,
        TYMED *ptymed )
{
FORMATETC formatetc;
ULONG	i;
FormatMatchFlag fFlag = FORMAT_NOTFOUND;
FORMATETCDATA  *    pFormatEtcData = NULL; 
DWORD dwNumFormats;
FORMATETC *pformatetcNative[CF_MAXSYNTHESIZED + 1]; 


    LEDebugOut((DEB_ITRACE, "%p _IN CClipDataObject::MatchFormatetc ("
        " %p , %p)\n", this, pformatetc, ptymed));


    formatetc = *pformatetc;

    // some applications as for an Aspect of 0 which maps to content.
    if (0 == formatetc.dwAspect)
	formatetc.dwAspect = DVASPECT_CONTENT;

    // make sure all pFormatEtcs in array are initially NULL.
    _xmemset(pformatetcNative, 0, sizeof(FORMATETC *) * (CF_MAXSYNTHESIZED + 1)); 

    GetFormatEtcDataArray(); // Create SharedFormats from Native Clipboard if Necessary.

    if( ptymed )
    {
        *ptymed = TYMED_NULL;
    }

    if( m_pFormatEtcDataArray )
    {
	dwNumFormats = m_pFormatEtcDataArray->_cFormats;
	pFormatEtcData = &(m_pFormatEtcDataArray->_FormatEtcData[0]);

        for( i = 0; i < dwNumFormats; i++ )
        {
	FORMATETC tempformatetc = pFormatEtcData->_FormatEtc;

            // if the clipboard format matchs AND
            // the aspect matches AND
            // the tymed matches
            // then, return success

            if( tempformatetc.cfFormat ==
                    formatetc.cfFormat)
            {

		// fix up the ptd if necessary
		if (tempformatetc.ptd)
		{
		    tempformatetc.ptd = (DVTARGETDEVICE *)
					((BYTE *) m_pFormatEtcDataArray + (ULONG_PTR) tempformatetc.ptd);
		}

                // we don't need to check TYMED because
                // this clipboard data object can satisfy
                // almost all valid TYMED's, and specfically,
                // more than will be contained in the
                // formatetc tymed field.

                if( ((tempformatetc.dwAspect & formatetc.dwAspect) == formatetc.dwAspect)
		    && (tempformatetc.lindex == formatetc.lindex)
                    && ( (tempformatetc.ptd == formatetc.ptd) 
			    || UtCompareTargetDevice(tempformatetc.ptd,formatetc.ptd))
		   )
                {
                    fFlag = FORMAT_GOODMATCH;

                    // keep track of the tymed
                    if( ptymed )
                    {
                        // this cast is a cute one;
                        // formatetc.tymed is
                        // actually declared to be
                        // a DWORD, since compiler
                        // type-checking is a bad
                        // thing in OLE16.
                        *ptymed = (TYMED)
                            tempformatetc.tymed;

                    }

		    break;
                }
                else
                {
                    fFlag = FORMAT_BADMATCH; 

		    if (fNativeOnly) // Only  check first cfFormat match if only looking at native Clipboard.
			break;
                }
            }

	    // if cfFormat is in predefined range and don't yet have a value for synthesized mapping, set it.
	    // to point to the Current pFormatEtcData arrays formatEtc.
	    if ( (tempformatetc.cfFormat <= CF_MAXSYNTHESIZED) && (NULL == pformatetcNative[tempformatetc.cfFormat]) )
	    {
		 pformatetcNative[tempformatetc.cfFormat] = &(pFormatEtcData->_FormatEtc);
	    }

	    ++pFormatEtcData;

        }

	// if no match was found in the Enumerator see if it can be synthesized from the 
	// native clipboard.
	
	// if have enumerator and couldn't find in either enumerator or synthesized 
	// aspect must be Content and should be one of our synthesized formats that was requested.

	if (FORMAT_NOTFOUND == fFlag && (formatetc.cfFormat <= CF_MAXSYNTHESIZED) )
	{
	    for( i = 0; i < NumSynthesizedFormats; i++ )
	    {
		// if format matches synthesized and the apspect has been set check the match
		// else it could have been set by another format that can be synthesized from.
		if ( (pSynthesized[i].cfSynthesized == formatetc.cfFormat) && 
			(pformatetcNative[(pSynthesized[i].cfOrig)] != NULL) )
		{
		FORMATETC tempformatetc = *(pformatetcNative[(pSynthesized[i].cfOrig)]);

		    Assert(pSynthesized[i].cfOrig <= CF_MAXSYNTHESIZED);

		    // fix up the ptd if necessary
		    if (tempformatetc.ptd)
		    {
			tempformatetc.ptd = (DVTARGETDEVICE *)
					    ((BYTE *) m_pFormatEtcDataArray + (ULONG_PTR) tempformatetc.ptd);
		    }


		    if ( ((tempformatetc.dwAspect & formatetc.dwAspect) == formatetc.dwAspect)
			    && (tempformatetc.lindex == formatetc.lindex)
			    && ( (tempformatetc.ptd == formatetc.ptd) 
				    || UtCompareTargetDevice(tempformatetc.ptd,formatetc.ptd) )
			)
		    {
			// leave tymed out param TYMED_NULL, GetData will figure this out as a not found case
			fFlag = FORMAT_GOODMATCH;
		    }
		    else
		    {
			// This is a Bad Match.
			fFlag = FORMAT_BADMATCH; 
		    }

		    break;
		}
	    }

	}

    }

    // if format not found we return not found 
    // This can happen if the format is not on the Clipboard or it is
    // one of the OLE synthesized formats, 

    // If Didn't find match, the aspect is enforced to be content
    if ( (FORMAT_NOTFOUND == fFlag) && (formatetc.dwAspect != DVASPECT_CONTENT) )
    {
	fFlag = FORMAT_BADMATCH;    
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CClipDataObject::MatchFormatetc ("
        "%lx )\n", this, fFlag));

    return fFlag;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CClipDataObject::Create (static)
//
//  Synopsis: 	Creates a new Clipboard data object
//
//  Effects:
//
//  Arguments:  [ppDataObj]	-- where to put the data object
//		[cFormats]	-- the count of formatetcs
//		[prgFormats]	-- the array of formatetcs (may be NULL)
//
//  Requires:	the clipboard must be open
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:	Creates a new data object, initializing an internal
//		formatetc array if g_cfOlePrivateData is available.
//
//  History:    dd-mmm-yy Author    Comment
// 		19-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT CClipDataObject::Create( IDataObject **ppDataObj, 
            FORMATETCDATAARRAY  *pFormatEtcDataArray)
{
    HRESULT hresult = NOERROR;
    CClipDataObject *	pClipData;


    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CClipDataObject::Create ( %p )\n",
        NULL, ppDataObj));

    pClipData = new CClipDataObject();

    if( pClipData  )
    {
        pClipData->m_pFormatEtcDataArray = pFormatEtcDataArray;
        *ppDataObj = pClipData;
    }
    else
    {
        hresult = ResultFromScode(E_OUTOFMEMORY);
    }

    Assert((NULL == pClipData->m_pFormatEtcDataArray) || (1 == pClipData->m_pFormatEtcDataArray->_cRefs));

    LEDebugOut((DEB_ITRACE, "%p OUT CClipDataObject::Create ( %lx ) "
        "[ %lx ]\n", NULL, hresult, *ppDataObj));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CClipDataObject::QueryInterface
//
//  Synopsis: 	returns requested interfaces
//
//  Effects:
//
//  Arguments: 	[riid]		-- the requested interface
//		[ppvObj]	-- where to put the interface pointer
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject
//
//  Algorithm:	Since we always create one of these data objects for
//		OleGetClipboard, we need to be careful about how we
//		handle QueryInterface since apps are free to QI for IFoo
//
//		Identity laws:  for each object with identity, QI for
//				IUnknown should always return the same
//				IUnknown.  However, IFoo-->IUnknown-->IFoo
//				does NOT have to give you back the same
//				IFoo.  We take advantage of this loophole.
//
//		QI for:
//		IDataObject:	always return a pointer to us (the fake
//				data object)
//		IFoo:		if we can get a pointer back to the
//				original data object, delegate to it.
//				Note that a QI back to IDataObject will
//				not get back to this fake data object
//		IUnknown:	as above, delegate to the real data object
//				if available.  If we're in the remote case,
//				we'll end up getting the standard identity
//				object's IUnknown (unless the data object
//				was custom-marshalled).
//
//  History:    dd-mmm-yy Author    Comment
// 		02-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CClipDataObject::QueryInterface( REFIID riid, LPVOID *ppvObj )
{
    HRESULT		hresult = NOERROR;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CClipDataObject::QueryInterface "
        "( %p , %p )\n", this, riid, ppvObj));

    // We always return our data object if IDataObject is requested.
    if(IsEqualIID(riid, IID_IDataObject) ||
       IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = this;
        AddRef();
        goto logRtn;
    }

    // try to get the remote data object;
    // GetRealDataObjPtr will set m_pDataObject.
    GetRealDataObjPtr();

    if (m_pDataObject != NULL)
    {
        // If we have a real data object, the we use that to give us
        // the new interface since they probably want something strange
        hresult = m_pDataObject->QueryInterface(riid, ppvObj);
    }
    else
    {
        *ppvObj = NULL;
        hresult = ResultFromScode(E_NOINTERFACE);
    }

logRtn:

    LEDebugOut((DEB_TRACE, "%p OUT CClipDataObject::QueryInterface "
        "( %lx ) [ %p ]\n", this, hresult, *ppvObj ));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CClipDataObject::AddRef
//
//  Synopsis:	increments the reference count
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns:	ULONG-- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//    		02-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CClipDataObject::AddRef( )
{
    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CClipDataObject::AddRef ( )\n", this));

    ++m_refs;

    LEDebugOut((DEB_TRACE, "%p OUT CClipDataObject::AddRef ( %lu )\n",
        this, m_refs));

    return m_refs;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CClipDataObject::InternalAddRef
//
//  Synopsis:	Internal Reference count to ensure object stays alive
//				as long as Clipboard Code needs it.
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns:	ULONG - Remaining Internal Reference Counts.
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:	
//
//  History:    dd-mmm-yy Author    Comment
//		11-Sep-96 rogerg    author
//
//  Notes:
//
//--------------------------------------------------------------------------


ULONG CClipDataObject::InternalAddRef(void)
{

    ++m_Internalrefs;

    Assert(m_Internalrefs == 1); // Should only have 1 InternalRef on Object.

    return m_Internalrefs;
}


//+-------------------------------------------------------------------------
//
//  Member:   	CClipDataObject::Release
//
//  Synopsis:	decrements the reference count on the object
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires:
//
//  Returns: 	ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		02-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CClipDataObject::Release( )
{
    ULONG cRefs;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CClipDataObject::Release ( )\n", this));

    Assert( (m_refs > 0) && (m_Internalrefs <= 1) ); 

    if( (cRefs = --m_refs ) == 0 )
    {

	// Release the Real DataObject even when still have internal since if 
	// if Clipboard Object Changes DataObject may not be valid but would still
	// be use.

	if (m_pDataObject != NULL) 
	{
	    // Release our reference to the data object.
	    m_pDataObject->Release();
	    m_pDataObject = NULL;
	}

	m_fTriedToGetDataObject = FALSE;

	Assert(m_hOle1 == NULL);
	Assert(m_pUnkOle1 == NULL);

	if (m_Internalrefs == 0)
	{
	    LEDebugOut((DEB_TRACE, "%p DELETED CClipDataObject\n", this));
	    delete this;
	}
    }

    // using "this" below is OK, since we only want its value
    LEDebugOut((DEB_TRACE, "%p OUT CClipDataObject::Release ( %lu )\n",
        this, cRefs));

    return cRefs;
}


//+-------------------------------------------------------------------------
//
//  Member:  	CClipDataObject::InternalRelease
//
//  Synopsis:	Internal Reference count to ensure object stays alive
//				as long as Clipboard Code needs it.
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns:	DWORD - Number of Internal Reference Counts on the Object.
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:	
//
//  History:    dd-mmm-yy Author    Comment
//		11-Sep-96 rogerg    author
//
//  Notes:
//
//--------------------------------------------------------------------------

ULONG CClipDataObject::InternalRelease(void)
{
ULONG cRefs;

    Assert(m_Internalrefs == 1);  // InternalRef should always either be 0 or 1.

    if( (cRefs = --m_Internalrefs ) == 0  && (m_refs == 0) )
    {
        LEDebugOut((DEB_TRACE, "%p DELETED CClipDataObject\n", this));
        delete this;
    }

    return cRefs;
}


//+-------------------------------------------------------------------------
//
//  Member:  	CClipDataObject::GetData
//
//  Synopsis:	retrieves data of the specified format
//
//  Effects:
//
//  Arguments:	[pformatetc]	-- the requested format
//		[pmedium]	-- where to put the data
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:  General algorithm: we *always* duplicate data from the
//		clipboard and offer it back to the caller in the desired
//		format.
//
//		GDI objects (BITMAPs, metafiles): these are duplicated
//			via OleDuplicateData and offered back only if
//			the requested tymed is correct (i.e. either
//			TYMED_GDI or TYMED_MFPICT).  We do not attempt
//			to extract the bits and write them into a file,
//			for example.  Note that DIBs are really memory
//			objects.
//
//		for all other formats (which are flat):
//
//		if asked for TYMED_FILE: create a temporary file and call
//			GetDataHere.
//		if asked for TYMED_ISTREAM: create a stream on an hglobal
//			and call GetDataHere.
//		if asked for TYMED_HGLOBAL: simply duplicate the data and
//			return.
//		if asked for TYMED_ISTORAGE, we will create a storage on
//			an hglobal and call GetDataHere.  GetDataHere
//			will call StgIsStorageILockBytes to verify that
//			the data in the HGlobal is really a flattened
//			storage.  This allows apps to pass app-defined
//			formats as storages.
//
//			Note that we do no checking on whether it is sensible
//			for data in a particular flat format to be passed on
//			a storage.  StgIsStorageILockBytes will detect that
//			we can't construct a storage on the flat data, so we
//			will catch all illegal attempts to get storage data.
//
//		Medium preferences:
//			GDI objects:  only one allowed (depends on format)
//			Others:	ISTORAGE, then HGLOBAL, then ISTREAM,
//				then FILE.  If we know the 'prefered' medium
//				of the data (from the original formatetc),
//				then we use the ordering above to find the
//				first match between what the caller wants
//				and the 'preferred' mediums of the data.
//				Otherwise, we use the first medium from the
//				above list that matches what the caller wants.
//			
//
//  OLE1 Compatibility:
//		The basic problem:	Ole1 objects only offer cfNative,
//			cfOwnerLink, and/or cfObjectLink on the	clipboard.
//			We need to translate these into cfEmbedSource,
//			cfLinkSource, etc.
//		Basic Algorithm:
//			First check to see if we can satisfy an OLE2 data
//			request directly, without medium translation.  If so,
//			then we simply return the data to the user.
//			Otherwise, we create the Ole2 data and then copy it
//			into whatever medium the caller desired.  Note that
//			this potentially means an extra allocation, but apps
//			are not likely to ask for ObjectDescriptor on a
//			memory stream ;-)
//			
//
//  History:    dd-mmm-yy Author    Comment
//		04-Jun-94 alexgo    added OLE1 support
//  		02-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CClipDataObject::GetData( LPFORMATETC pformatetc, LPSTGMEDIUM
        pmedium)
{
    HRESULT		hresult	= NOERROR;
    HANDLE		handle;
    TYMED		tymedOriginal = TYMED_NULL;
    BOOL		fMatchResult;

    VDATEHEAP();
    VDATETHREAD(this);

    VDATEPTRIN(pformatetc, FORMATETC);
    VDATEPTROUT(pmedium, STGMEDIUM);

    LEDebugOut((DEB_TRACE, "%p _IN CClipDataObject::GetData ( %p , %p )\n",
        this, pformatetc, pmedium));


    // zero the pmedium structure.

    _xmemset(pmedium, 0, sizeof(STGMEDIUM));

    // try to get the remote data object
    // GetRealDataObjPtr will set m_pDataObject.
    GetRealDataObjPtr();


    if (m_pDataObject != NULL)
    {
        // We have a data object, so just forward that call to the
        // real data object and then exit the routine since it did
        // all the work.
        hresult = m_pDataObject->GetData(pformatetc, pmedium);

        // WOW HACK alert!  Some Win16 apps, like Word6 and XL,
        // won't work if we continue and offer data in the requested
        // format anyway.  By failing here, we more closely mimic
        // 16bit OLE behaviour

        if (hresult == NOERROR || IsWOWThread() )
        {
            goto errRtn;
        }

        // If this GetData failed, we just fall through since the
        // generic code may be able to handle the request
    }

    // first, we are going through and verify that we can satisfy
    // the format and medium request.  We will fetch the data in
    // the subsequent switch statement.

    // we first need to check to see if the clipboard format is a
    // user-defined GDI format.  We do not know how to duplicate
    // these, so we can't satisfy the GetData request.

    if( pformatetc->cfFormat >= CF_GDIOBJFIRST &&
        pformatetc->cfFormat <= CF_GDIOBJLAST )
    {
        hresult = ResultFromScode(DV_E_FORMATETC);
        goto errRtn;
    }



    // There is no DataObject or request for DataObject Failed
    // then MatchFormat must return it found a match or the aspect
    // requested must be content.

    fMatchResult = MatchFormatetc(pformatetc,TRUE /*fNativeOnly */,  &tymedOriginal);

    if (FORMAT_BADMATCH == fMatchResult)
    {
	 hresult = ResultFromScode(DV_E_FORMATETC);
         goto errRtn;
    }
    // now check for "standard" formats

    switch( pformatetc->cfFormat )	
    {
    case CF_BITMAP:
    case CF_PALETTE:
        // TYMED_GDI is the only medium we support.
        if( (pformatetc->tymed & TYMED_GDI) )
        {
            pmedium->tymed = TYMED_GDI;
        }
        else
        {
            hresult = ResultFromScode(DV_E_TYMED);
            goto errRtn;
        }
        break;

    case CF_METAFILEPICT:
        // TYMED_MFPICT is the only medium we support
        if( (pformatetc->tymed & TYMED_MFPICT) )
        {
            pmedium->tymed = TYMED_MFPICT;
        }
        else
        {
            hresult = ResultFromScode(DV_E_TYMED);
            goto errRtn;
        }
        break;

    case CF_ENHMETAFILE:
        // TYMED_ENHMF is the only medium we support

        if( (pformatetc->tymed & TYMED_ENHMF) )
        {
            pmedium->tymed = TYMED_ENHMF;
        }
        else
        {
            hresult = ResultFromScode(DV_E_TYMED);
            goto errRtn;
        }
        break;


    // all other formats
    default:
        // we prefer TYMED_ISTORAGE, then TYMED_HGLOBAL, then
        // TYMED_ISTREAM

        // first check for matches with the 'preferred'
        // mediums of the data

        if( tymedOriginal != TYMED_NULL )
        {
            if( ((pformatetc->tymed & TYMED_ISTORAGE)
                & tymedOriginal) )
            {
                pmedium->tymed = TYMED_ISTORAGE;
                break;
            }
            else if( ((pformatetc->tymed & TYMED_HGLOBAL)
                & tymedOriginal))
            {
                pmedium->tymed = TYMED_HGLOBAL;
                break;
            }
            else if( ((pformatetc->tymed & TYMED_ISTREAM)
                & tymedOriginal))
            {
                pmedium->tymed = TYMED_ISTREAM;
                break;
            }
        }

        // if we didn't match above or if we don't know
        // the preferred formats, then make a best guess
        // and keep going.

        if( (pformatetc->tymed & TYMED_ISTORAGE) )
        {
            pmedium->tymed = TYMED_ISTORAGE;
        }		
        else if( (pformatetc->tymed & TYMED_HGLOBAL) )
        {
            pmedium->tymed = TYMED_HGLOBAL;
        }
        else if( (pformatetc->tymed & TYMED_ISTREAM) )
        {
            pmedium->tymed = TYMED_ISTREAM;
        }
        else
        {
            hresult = ResultFromScode(DV_E_TYMED);
            goto errRtn;
        }
        break;
    }

    // if we get this far, we've successfully picked the medium
    // on which we want to get our data.  For each medium, grab
    // the data.

    // If we need to construct OLE2 formats from OLE1 data,
    // then go ahead and try to fetch the data here.  If we can
    // fetch the data in the desired medium, then go ahead and return.
    // This optimization saves 1 extra allocation and copy when
    // retrieving OLE1 data.

    if( CanRetrieveOle2FromOle1(pformatetc->cfFormat) )
    {
        //
        //
        // BEGIN: OPENCLIPBOARD
        //
        //

        hresult = OleOpenClipboard(NULL, NULL);

        if( hresult != NOERROR )
        {
            goto errRtn;
        }

        // now fetch the data.  Since we're passing in the caller's
        // pmedium, this call *may* fail (since GetOle2FromOle1
        // *only* retrieves HGLOBAL or the native TYMED).  If so,
        // we'll fetch HGLOBAL from the OleGetClipboardData call
        // below and then do the appropriate conversion.

        hresult = GetOle2FromOle1(pformatetc->cfFormat, pmedium);

        // no matter what the result, we want to close the
        // clipboard

        if( !SSCloseClipboard() )
        {
            LEDebugOut((DEB_WARN, "WARNING: CloseClipboard "
                "failed!\n"));
            ; // no-op
        }

        //
        //
        // END: CLOSECLIPBOARD
        //
        //

        if( hresult == NOERROR )
        {
            // we successfully retrieved the Ole2 data the
            // caller wanted.  First reset our state
            // (*without* freeing the data we're returning
            // to the caller) and then go ahead and
            // return.

            FreeResources(JUST_RESET);
            goto errRtn;
        }

        // FALL-THROUGH.  If we weren't able
        // to retrieve data in the desired format, it probably
        // means the caller was asking for data on non-primary
        // medium.  The default processing below should take care of
        // this.

        // Recall that this code block is an optimization to
        // avoid multiple allocations and copies in the "normal"
        // case.

    }

    switch( pmedium->tymed )
    {
    case TYMED_HGLOBAL:
    case TYMED_MFPICT:
    case TYMED_ENHMF:
    case TYMED_GDI:
        // Mini-algorithm: Open the clipboard, fetch and
        // duplicate the data, then close the clipboard.

        // we only open the clipboard here because the
        // GetDataHere call will open the clipboard for
        // the other cases.  (Recall that OpenClipboard and
        // CloseClipboard are not balanced; only one CloseClipboard
        // is necessary to actually close the clipboard).

        //
        //
        // BEGIN: OPENCLIPBOARD
        //
        //

        hresult = OleOpenClipboard(NULL, NULL);

        if( hresult != NOERROR )
        {
            break;
        }

        hresult = OleGetClipboardData(pformatetc->cfFormat, &handle);

        if( hresult == NOERROR )
        {
            // since hGlobal is in a union, we don't need to
            // explicity assign for each medium type.

            pmedium->hGlobal = OleDuplicateData(handle,
                        pformatetc->cfFormat, NULL);
            if( !pmedium->hGlobal )
            {
                hresult = ResultFromScode(E_OUTOFMEMORY);
                // FALL-THROUGH!!: this is deliberate; we want
                //  to close the clipboard and get out (which is
                // what the code below does)
            }
        }

        if( !SSCloseClipboard() )
        {
            LEDebugOut((DEB_WARN, "WARNING: CloseClipboard failed!"
                "\n"));

            // don't overwrite the original error code
            if( hresult == NOERROR )
            {
                hresult =
                    ResultFromScode(CLIPBRD_E_CANT_CLOSE);
            }
            // FALL-THROUGH!! to the break below;
        }

        //
        //
        // END: CLOSECLIPBOARD
        //
        //

        break;

    case TYMED_ISTREAM:
        // create a memory stream.
        hresult = CreateStreamOnHGlobal(NULL,
                TRUE /*fDeleteOnRelease*/, &(pmedium->pstm));

        if( hresult != NOERROR )
        {
            break;
        }

        hresult = GetDataHere( pformatetc, pmedium );

        break;

    case TYMED_ISTORAGE:
        // create a memory storage (ILockBytes on top of a
        // a docfile).

        hresult = UtCreateStorageOnHGlobal(NULL,
                TRUE /*fDeleteOnRelease*/, &(pmedium->pstg),
                NULL);

        if( hresult != NOERROR )
        {
            break;
        }

        hresult = GetDataHere( pformatetc, pmedium );

        break;

    case TYMED_FILE:
        // create a temporary file
        pmedium->lpszFileName = (LPOLESTR)PubMemAlloc( MAX_PATH +1 );

        if( !pmedium->lpszFileName )
        {
            hresult = ResultFromScode(E_OUTOFMEMORY);
            break;
        }

        hresult = UtGetTempFileName( OLESTR("~OLE"),
                pmedium->lpszFileName);

        if( hresult == NOERROR )
        {
            hresult = GetDataHere( pformatetc, pmedium );
        }
        break;

    default:
        // should never get here
        AssertSz(0, "Unknown TYMED for get Data");
        hresult = ResultFromScode(E_UNEXPECTED);
        break;
    }

    // NB!!! Do not put any extra processing here without modifying the
    // error paths in the above switch (they just break, instead of
    // doing a goto errRtn.  This was done to avoid some duplicated
    // code.

    if( hresult != NOERROR )
    {
        // ReleaseStgMedium will correctly cleanup NULL and
        // partially NULL mediums, so we can rely on it for
        // general-purpose cleanup
        ReleaseStgMedium(pmedium);
    }

    // no matter what the error code, we should reset our state and
    // free any resources the OLE1 compatibility code may have allocated

    FreeResources(RESET_AND_FREE);

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT CClipDataObject::GetData ( %lx )\n",
        this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CClipDataObject::GetDataHere
//
//  Synopsis:	retrieves data of the specified format
//
//  Effects:
//
//  Arguments:	[pformatetc]	-- the requested format
//		[pmedium]	-- where to put the data, if NULL, then
//				   the call is treated as a Query.
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:  General algorithm: we *always* duplicate data from the
//		clipboard and offer it back to the caller in the desired
//		medium.  Since this is GetDataHere, we attempt to copy the
//		data into the medium provided by the caller.
//
//		GDI objects (BITMAPs, metafiles): *cannot* be retrieved
//			by GetDataHere, since we do not translate GDI
//			objects into byte arrays and we cannot copy a
//			metafile into a metafile (for example).
//
//		for all other formats (which are flat):
//
//		if asked for TYMED_FILE: open the file for create/append and
//			write the data into it.
//		if asked for TYMED_ISTREAM: write the data into the stream
//		if asked for TYMED_HGLOBAL: verify first that the given
//			hglobal is big enough; if so, then copy the clipboard
//			data into it.
//			
//		if asked for TYMED_ISTORAGE: call StgIsStorageILockBytes
//			to verify that the data in the HGlobal is really
//			a flattened storage.  This allows apps to pass
//			app-defined formats as storages.
//
//  OLE1 Compatibility:
//		OleGetClipboardData will manufacture OLE2 formats from
//		OLE1 data as necessary.  We simply take this handle and
//		copy it into the caller's medium (as with any other handle).
//
//  History:    dd-mmm-yy Author    Comment
//		04-Jun-94 alexgo    added OLE1 support
//  		02-Apr-94 alexgo    author
//
//  Notes: 	The spec does not say that a NULL pmedium should be treated
//		as a Query; however the 16bit code did that and it was fairly
//		easy for us to duplicate that behaviour.
//
//--------------------------------------------------------------------------

STDMETHODIMP CClipDataObject::GetDataHere( LPFORMATETC pformatetc, LPSTGMEDIUM
        pmedium)
{
    HRESULT		hresult	= NOERROR;
    HANDLE		handle;
    DWORD		cbClipData = 0;
    BOOL		fMatchResult;

    VDATEHEAP();
    VDATETHREAD(this);

    VDATEPTRIN(pformatetc, FORMATETC);

    if( pmedium )
    {
        VDATEPTRIN(pmedium, STGMEDIUM);
    }

    LEDebugOut((DEB_TRACE, "%p _IN CClipDataObject::GetDataHere ( %p , %p"
        " )\n", this, pformatetc, pmedium));

    // try to get the remote data object
    // GetRealDataObjPtr will set m_pDataObject.
    GetRealDataObjPtr();

    if (m_pDataObject != NULL)
    {
        // We have a data object, so just forward that call to the
        // real data object and then exit the routine since it did
        // all the work.
        hresult = m_pDataObject->GetDataHere(pformatetc, pmedium);

        // If this this failed, we just fall through since the
        // generic code may be able to handle the request

        // WOW HACK alert!  Some Win16 apps, like Word6 and XL,
        // won't work if we continue and offer data in the requested
        // format anyway.  By failing here, we more closely mimic
        // 16bit OLE behaviour

        if (hresult == NOERROR || IsWOWThread() )
        {
            goto logRtn;
        }

        // If this GetDataHere failed, we just fall through since the
        // generic code may be able to handle the request
    }

    // eliminate the GDI case immediately

    // we do not satisfy requests to GetDataHere for a GDI object
    // note that DIB's are really memory objects.

    if( (pformatetc->cfFormat ==  CF_BITMAP) ||
        (pformatetc->cfFormat == CF_PALETTE) ||
        (pformatetc->cfFormat == CF_METAFILEPICT) ||
        (pformatetc->cfFormat == CF_ENHMETAFILE) ||
        (pformatetc->cfFormat >= CF_GDIOBJFIRST &&
            pformatetc->cfFormat <= CF_GDIOBJLAST ))
    {
        hresult = ResultFromScode(DV_E_FORMATETC);
        goto logRtn;
    }

    // There is no DataObject or request for DataObject Failed
    // then MatchFormat must return it found a match or the aspect
    // requested must be content.

    fMatchResult = MatchFormatetc(pformatetc,TRUE /*fNativeOnly */, NULL);

    if (FORMAT_BADMATCH == fMatchResult)
    {
	 hresult = ResultFromScode(DV_E_FORMATETC);
         goto errRtn;
    }

    // If pmedium == NULL, then we will just
    // query and leave.  As noted above, this behavior is for 16bit
    // compatibility.

    if( !pmedium )
    {
        if( OleIsClipboardFormatAvailable(pformatetc->cfFormat) )
        {
            hresult = NOERROR;
        }
        else
        {
            hresult = ResultFromScode(DV_E_CLIPFORMAT);
        }

        goto logRtn;
    }

    //
    //
    // BEGIN: OPENCLIPBOARD
    //
    //

    // open the clipboard and retrieve the data.  Once we have it,
    // we'll do a switch and stuff it into the right spot.

    hresult = OleOpenClipboard(NULL, NULL);

    if( hresult != NOERROR )
    {
        goto logRtn;
    }

    // now actually get the data

    Assert(pmedium);

    hresult = OleGetClipboardData(pformatetc->cfFormat, &handle);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    // now copy the data into the given medium

    // for everything but storages, we need to know the size of the
    // data coming off the clipboard.

    // note that we have a general problem with comparing sizes--
    // GlobalSize returns the size of the *allocated* block, which
    // is not the same as the size of the real data (which, in
    // general, we have no way of determining).

    // When transfering from HGLOBAL to HGBOBAL, we therefore have
    // a boundary case where we actually have enough room to copy
    // the *real* data from the clipboard, but the global block
    // from the clipboard is bigger (causing a failure)

    // If an app really cares, GetData should be called instead.

    if( pmedium->tymed != TYMED_ISTORAGE )
    {
        cbClipData = (ULONG) GlobalSize(handle);

        if( cbClipData == 0 )
        {
            // got bad data from the clipboard
            hresult = ResultFromScode(CLIPBRD_E_BAD_DATA);
            goto errRtn;
        }
    }

    switch( pmedium->tymed )
    {
    case TYMED_HGLOBAL:
        // if there is enough room to stuff the data in the given
        // hglobal, then do so.

        hresult = UtHGLOBALtoHGLOBAL( handle, cbClipData,
                pmedium->hGlobal);
        break;

    case TYMED_ISTREAM:
        // copy the data into the medium's stream

        hresult = UtHGLOBALtoStm( handle, cbClipData, pmedium->pstm);
        break;

    case TYMED_ISTORAGE:
        // create a storage on top of the HGLOBAL and CopyTo to the
        // medium's storage.  Note that this will only work if
        // the HGLOBAL originally had a storage dumped on it

        hresult = UtHGLOBALtoStorage( handle, pmedium->pstg);
        break;

    case TYMED_FILE:
        // append the data into the file

        hresult = UtHGLOBALtoFile( handle, cbClipData,
                pmedium->lpszFileName);
        break;

    default:
        // we can't GetDataHere into GDI objects!!! (etc).

        hresult = ResultFromScode(DV_E_TYMED);
        break;
    }

    // NB!!: Be careful about adding extra code here; the above
    // switch does nothing special for error cases.

errRtn:

    if( !SSCloseClipboard() )
    {
        LEDebugOut((DEB_WARN, "WARNING: CloseClipboard failed!\n"));
        if( hresult == NOERROR )
        {
            hresult = ResultFromScode(CLIPBRD_E_CANT_CLOSE);
        }
    }

    //
    //
    // END: CLOSECLIPBOARD
    //
    //

    // now free any resources we may have used for OLE1 compatibility

    FreeResources(RESET_AND_FREE);

logRtn:

    LEDebugOut((DEB_TRACE, "%p OUT CClipDataObject::GetDataHere ( %lx )\n",
        this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CClipDataObject::QueryGetData
//
//  Synopsis:	queries whether a GetData call would succeed
//
//  Effects:
//
//  Arguments:	[pformatetc]	-- the requested format
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:	we simply see if the requested clipboard format is on the
//		clipboard.
//
//		If we have an array of formatetcs (m_rgFormats from the
//		g_cfOlePrivateData clipboard data), then we use that info
//		to check.  Otherwise, we will do as much checking as we can
//		without actually fetching the data.
//
//		Note that this is not 100% accurate (because
//		we may not be able to get the data in the requested medium
//		(such as TYMED_ISTORAGE)).  Without actually doing a GetData
//		call, however, this is the best we can do.
//
//  History:    dd-mmm-yy Author    Comment
//		04-Jun-94 alexgo    added OLE1 support
//		17-May-94 alexgo    removed call to OpenClipboard
//  		02-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CClipDataObject::QueryGetData( LPFORMATETC pformatetc )
{			
    HRESULT		hresult = NOERROR;
    FormatMatchFlag 	fFlag;

    VDATEHEAP();
    VDATETHREAD(this);

    VDATEPTRIN(pformatetc, FORMATETC);

    LEDebugOut((DEB_TRACE, "%p _IN CClipDataObject::QueryGetData ( %p )\n",
        this, pformatetc));


    // we check if the clipboard format is available *before*
    // checking the formatetc list as an optimization.  If a previous
    // attempt to render data had failed, then NT will remove that
    // clipboard format from the clipboard.

    if( OleIsClipboardFormatAvailable(pformatetc->cfFormat))
    {
        fFlag = MatchFormatetc(pformatetc,FALSE /*fNativeOnly */, NULL);

        if( fFlag == FORMAT_GOODMATCH )
        {
            hresult = NOERROR;
            goto errRtn;
        }
        else if( fFlag == FORMAT_BADMATCH )
        {
            hresult = ResultFromScode(DV_E_FORMATETC);
            goto errRtn;
        }		

        // even if we didn't match in the formatetc list,
        // continue to check below.  We can satisfy
        // many more GetData requests than the app may
        // have orginally.

        // do all the verification we can without actually
        // fetching the data


        switch( pformatetc->cfFormat )
        {
        case CF_BITMAP:
        case CF_PALETTE:
            // GDI objects must be requested on TYMED_GDI
            if( pformatetc->tymed != TYMED_GDI )
            {
                hresult = ResultFromScode(DV_E_TYMED);
            }
            break;

        case CF_METAFILEPICT:
            // metafiles must be on TYMED_MFPICT
            if( pformatetc->tymed != TYMED_MFPICT )
            {
                hresult = ResultFromScode(DV_E_TYMED);
            }
            break;

        case CF_ENHMETAFILE:
            // enhanced metafiles must be on TYMED_ENHMF;
            if( pformatetc->tymed != TYMED_ENHMF )
            {
                hresult = ResultFromScode(DV_E_TYMED);
            }
            break;

        default:
            // we cannot deal with special GDI objects
            if( pformatetc->cfFormat >= CF_GDIOBJFIRST &&
                pformatetc->cfFormat <= CF_GDIOBJLAST )
            {
                hresult = ResultFromScode(DV_E_FORMATETC);
                break;
            }

            // we cannot put other formats onto metafiles
            // or GDI objects

            // failure case: if somebody requests
            // TYMED_ISTORAGE but the actually hglobal on the
            // clipboard does not contain storage-formated data

            if( pformatetc->tymed == TYMED_GDI ||
                pformatetc->tymed == TYMED_MFPICT ||
                pformatetc->tymed == TYMED_ENHMF )
            {
                hresult = ResultFromScode(DV_E_TYMED);
            }
            break;
        }
    }
    else
    {
        hresult = ResultFromScode(DV_E_CLIPFORMAT);
    }

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT CClipDataObject::QueryGetData "
        "( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CClipDataObject::GetCanonicalFormatEtc
//
//  Synopsis:	retrieve the canonical format
//
//  Effects:
//
//  Arguments:	[pformatetc]	-- the requested format
//		[pformatetcOut]	-- the canonical format
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:	Since we always return the same data for each clipboard
//		format, this function is very simple (basically returns
//		the input formatetc, with a NULL target device).
//
//  History:    dd-mmm-yy Author    Comment
//  		02-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CClipDataObject::GetCanonicalFormatEtc( LPFORMATETC pformatetc,
    LPFORMATETC pformatetcOut)
{
    VDATEHEAP();
    VDATETHREAD(this);

    VDATEPTRIN(pformatetc, FORMATETC);
    VDATEPTROUT(pformatetcOut, FORMATETC);

    LEDebugOut((DEB_TRACE, "%p _IN CClipDataObject::GetCanonicalFormatEtc"
        " ( %p , %p )\n", this, pformatetc, pformatetcOut));

    // initialize the out param
    INIT_FORETC(*pformatetcOut);			

    pformatetcOut->cfFormat = pformatetc->cfFormat;
    pformatetcOut->tymed = pformatetc->tymed;

    LEDebugOut((DEB_TRACE, "%p OUT CClipDataObject::GetCanonicalFormatEtc"
        " ( %lx )\n", this, NOERROR ));

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CClipDataObject::SetData
//
//  Synopsis:	sets data of the specified format
//
//  Effects:
//
//  Arguments:	[pformatetc]	-- the format of the data
//		[pmedium]	-- the data
//
//  Requires:
//
//  Returns:	E_NOTIMPL
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		02-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CClipDataObject::SetData( LPFORMATETC pformatetc, LPSTGMEDIUM
        pmedium, BOOL fRelease)
{
HRESULT hr;

    VDATEHEAP();
    VDATETHREAD(this);

    VDATEREADPTRIN(pformatetc, FORMATETC);
    VDATEREADPTRIN(pmedium, STGMEDIUM);

    LEDebugOut((DEB_TRACE, "%p _IN CClipDataObject::SetData ( %p , %p )\n",
        this, pformatetc, pmedium));


    // try to get the remote data object
    // GetRealDataObjPtr will set m_pDataObject.
    GetRealDataObjPtr();

    if (NULL != m_pDataObject)
    {
	hr =  m_pDataObject->SetData(pformatetc,pmedium,fRelease); 
    }
    else
    {
	hr =  E_FAIL;
    }

    LEDebugOut((DEB_TRACE, "%p OUT CClipDataObject::SetData ( %lx )\n",
        this, hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CClipDataObject::EnumFormatEtc
//
//  Synopsis:	return an enumerator for the available data formats
//
//  Effects:
//
//  Arguments:	[dwDirection]	-- the direction (GET or SET)
//		[ppenum]	-- where to put the enumerator
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm: 	create a clipboard formatetc enumerator.  Upon creation,
//		we'll grab everything off clipboard we need (so that simple
//		enumeration doesn't block access to the clipboard).
//
//  History:    dd-mmm-yy Author    Comment
//  		02-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CClipDataObject::EnumFormatEtc( DWORD dwDirection,
    LPENUMFORMATETC * ppenum )
{
    HRESULT		hresult;

    VDATEHEAP();
    VDATETHREAD(this);

    VDATEPTROUT(ppenum, LPENUMFORMATETC);

    LEDebugOut((DEB_TRACE, "%p _IN CClipDataObject::EnumFormatEtc ( %lx "
        ", %p )\n", this, dwDirection, ppenum));

    // we can only enumerate in the GET direction

    *ppenum = NULL;

    if( dwDirection != DATADIR_GET )
    {
        hresult = ResultFromScode(E_NOTIMPL);
        goto errRtn;
    }

    GetFormatEtcDataArray(); // make sure dataArray is Set up.

    if (m_pFormatEtcDataArray)
    {
	*ppenum = new CEnumFormatEtcDataArray(m_pFormatEtcDataArray,0);
    }

    hresult = *ppenum ? NOERROR : E_OUTOFMEMORY;

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT CClipDataObject::EnumFormatEtc ( %lx )"
        "\n", this, hresult));

    return hresult;	
}

//+-------------------------------------------------------------------------
//
//  Member:  	CClipDataObject::DAdvise
//
//  Synopsis:	register a data advise
//
//  Effects:
//
//  Arguments:	[pformatetc]	-- the requested format
//		[dwAdvf]	-- advise flags
//		[pAdvSink]	-- the advise sink
//		[pdwConnection]	-- where to put the connection ID
//
//  Requires:
//
//  Returns: 	OLE_E_ADVISENOTSUPPORTED
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		02-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CClipDataObject::DAdvise( LPFORMATETC pformatetc, DWORD dwAdvf,
    IAdviseSink * pAdvSink, DWORD *pdwConnection )
{
    (void)pformatetc;
    (void)dwAdvf;
    (void)pAdvSink;
    (void)pdwConnection;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_WARN, "WARNING: DAdvise on the clipboard data"
        "object is not supported!\n"));

    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

//+-------------------------------------------------------------------------
//
//  Member:  	CClipDataObject::DUnadvise
//
//  Synopsis:	unadvises an advise connection
//
//  Effects:
//
//  Arguments:	[dwConnection]	-- the connection to remove
//
//  Requires:
//
//  Returns: 	OLE_E_ADVISENOTSUPPORTED
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		02-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CClipDataObject::DUnadvise(DWORD dwConnection)
{
    (void)dwConnection;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_WARN, "WARNING: DUnadvise on the clipboard data"
        "object is not supported!\n"));

    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

//+-------------------------------------------------------------------------
//
//  Member:  	CClipDataObject::EnumDAdvise
//
//  Synopsis:  	enumerates data advises
//
//  Effects:
//
//  Arguments:	[ppenum]	-- where to put the enumerator
//
//  Requires:
//
//  Returns: 	OLE_E_ADVISENOTSUPPORTED
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		02-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CClipDataObject::EnumDAdvise( LPENUMSTATDATA *ppenum)
{
    (void)ppenum;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_WARN, "WARNING: EnumDAdvise on the clipboard data"
        "object is not supported!\n"));

    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

//
// Private methods on CClipDataObject
//

//+-------------------------------------------------------------------------
//
//  Member:	CClipDataObject::FreeResources (private)
//
//  Synopsis:	frees any resources allocated by OLE1 compatibility
//		code and resets state
//
//  Effects:
//
//  Arguments:	[fFlags]	-- either JUST_RESET or RESET_AND_FREE
//
//  Requires:
//
//  Returns:  	void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		04-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void CClipDataObject::FreeResources( FreeResourcesFlags fFlags )
{
    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CClipDataObject::FreeResources "
        "( %lx )\n", this, fFlags));

    if( (fFlags & RESET_AND_FREE) )
    {
        if( m_hOle1 )
        {
            GlobalFree(m_hOle1);
        }

        if( m_pUnkOle1 )
        {
            m_pUnkOle1->Release();
        }
    }

    m_hOle1 = NULL;
    m_pUnkOle1 = NULL;

    LEDebugOut((DEB_ITRACE, "%p OUT CClipDataObject::FreeResources "
        "( )\n", this ));
}

//+-------------------------------------------------------------------------
//
//  Member: 	CClipDataObject::GetAndTranslateOle1 (private)
//
//  Synopsis:	Retrieves either cfOwnerLink or cfObjectLink from the
//		clipboard, reads the strings and converts to Unicode
//
//  Effects:	all strings will be allocated with the public allocator
//
//  Arguments:	[cf]		-- the clipboard format to retrieve
//				   must be either cfOwnerLink or cfObjectLink
//		[ppszClass]	-- where to put the class name (may be NULL)
//		[ppszFile]	-- where to put the file name (may be NULL)
//		[ppszItem]	-- where to put the item name (may be NULL)
//		[ppszItemA]	-- where to put the ANSI item name
//						(may be NULL)
//
//  Requires: 	the clipboard must be open
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:	cfOwnerLink and cfObjectLink are laid out as follows
//			classname\0filename\0\itemname\0\0
//		These strings are ANSI, so we must convert to unicode.
//
//  History:    dd-mmm-yy Author    Comment
//		04-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT CClipDataObject::GetAndTranslateOle1( UINT cf, LPOLESTR *ppszClass,
        LPOLESTR *ppszFile, LPOLESTR *ppszItem, LPSTR *ppszItemA )
{
    LPSTR		pszClassA 	= NULL,
            pszFileA 	= NULL,
            pszItemA 	= NULL;
    HGLOBAL		hOle1;
    HRESULT		hresult		= NOERROR;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CClipDataObject::GetAndTranslate"
        "Ole1 ( %d , %p , %p , %p )\n", this, cf, ppszClass, ppszFile,
        ppszItem));

    Assert( cf == g_cfOwnerLink || cf == g_cfObjectLink );

    // NULL out-params
    if( ppszClass )
    {
        *ppszClass = NULL;
    }
    if( ppszFile )
    {
        *ppszFile = NULL;
    }
    if( ppszItem )
    {
        *ppszItem = NULL;
    }

    hOle1 = SSGetClipboardData(cf);

    if( hOle1 == NULL )
    {
        LEDebugOut((DEB_WARN, "WARNING: GetClipboardData Failed!\n"));
        hresult = ResultFromScode(CLIPBRD_E_BAD_DATA);
        goto logRtn;
    }

    pszClassA = (LPSTR)GlobalLock(hOle1);

    if( pszClassA == NULL )
    {
        LEDebugOut((DEB_WARN, "WARNING: GlobalLock failed!\n"));
        hresult = ResultFromScode(E_OUTOFMEMORY);
        goto logRtn;
    }

    if( ppszClass )
    {
        hresult = UtGetUNICODEData((ULONG) strlen(pszClassA) + 1, pszClassA,
                    NULL, ppszClass);

        if( hresult != NOERROR )
        {
            goto errRtn;
        }
    }

    pszFileA = pszClassA + strlen(pszClassA) + 1;

    if( ppszFile )
    {
        hresult = UtGetUNICODEData((ULONG) strlen(pszFileA) + 1, pszFileA,
                    NULL, ppszFile );

        if( hresult != NOERROR )
        {
            goto errRtn;
        }
    }

    pszItemA = pszFileA + strlen(pszFileA) +1;

    if( ppszItem )
    {
        hresult = UtGetUNICODEData((ULONG) strlen(pszItemA) + 1, pszItemA,
                    NULL, ppszItem);

        if( hresult != NOERROR )
        {
            goto errRtn;
        }
    }

    if( ppszItemA )
    {
        *ppszItemA = UtDupStringA(pszItemA);

        if( !*ppszItemA )
        {
            hresult = ResultFromScode(E_OUTOFMEMORY);
            // FALL-THROUGH! no need to goto the error
            // handling code right below us
        }
    }

errRtn:

    GlobalUnlock(hOle1);

    if( hresult != NOERROR )
    {
        if( ppszClass && *ppszClass )
        {
            PubMemFree(*ppszClass);
            *ppszClass = NULL;
        }

        if( ppszFile && *ppszFile )
        {
            PubMemFree(*ppszFile);
            *ppszFile = NULL;
        }

        if( ppszItem && *ppszItem )
        {
            PubMemFree(*ppszItem);
            *ppszItem = NULL;
        }

#if DBG == 1
        // if this assert goes off, then we added more code
        // without modifying the error paths for ansi item strings

        if( ppszItemA )
        {
            Assert(*ppszItem == NULL );
        }
#endif // DBG ==1

    }

logRtn:

    LEDebugOut((DEB_ITRACE, "%p OUT CClipDataObject::GetAndTranslate"
        "Ole1 ( %lx ) [ %p , %p , %p ]\n", this, hresult,
        (ppszClass)? *ppszClass : 0,
        (ppszFile) ? *ppszFile  : 0,
        (ppszItem) ? *ppszItem  : 0 ));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CClipDataObject::GetEmbeddedObjectFromOle1
//
//  Synopsis:	synthesizes cfEmbeddedObject from available OLE1
//		data.
//
//  Effects:
//
//  Arguments:	[pmedium]	-- where to put the requested data		
//
//  Requires: 	The clipboard must be OPEN
//		we must have verified that the correct formats are
//		available before calling
//
//  Returns:  	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:	create a memory-based stroage and stuff the following
//		infomation in it:
//			clsid StdOleLink
//			an available presentation
//			the class from OwnerLink data as the user type
//			link information
//
//		Much of this work is done by the helper function
//		GenericObjectToIStorage
//
//  History:    dd-mmm-yy Author    Comment
//		11-Aug-94 alexgo    author
//
//  Notes: 	This code is largely based from 16bit OLE sources
//		REVIEW: we may want to rework portions of this code,
//		particularly if we rewrite the GENOBJ code (in
//		ostm2stg.cpp).
//
//--------------------------------------------------------------------------

HRESULT CClipDataObject::GetEmbeddedObjectFromOle1( STGMEDIUM *pmedium )
{
    HRESULT		hresult;
    IStorage *	pstg = NULL;
    LPOLESTR	pszClass = NULL;
    ILockBytes *	plockbytes = NULL;
    BOOL		fDeleteOnRelease = TRUE;
    GENOBJ		genobj;
    HGLOBAL		hglobal;


    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CClipDataObject::GetEmbeddedObject"
        "FromOle1 ( %p )\n", this, pmedium));


    // if we are asking for EmbeddedObject on an hglobal, then we
    // don't want to delete the hglobal when we release the storage

    if( pmedium->tymed == TYMED_HGLOBAL )
    {
        fDeleteOnRelease = FALSE;
    }

    genobj.m_class.Set(CLSID_StdOleLink, NULL);

    // the destructor for the generic object will free the
    // presentation.
    genobj.m_ppres = new PRES;

    if( genobj.m_ppres == NULL )
    {
        hresult = ResultFromScode(E_OUTOFMEMORY);
        goto errRtn;
    }

    genobj.m_fLink = TRUE;
    genobj.m_lnkupdopt = UPDATE_ALWAYS;

    if( SSIsClipboardFormatAvailable(CF_METAFILEPICT))
    {
        hglobal = SSGetClipboardData(CF_METAFILEPICT);

        if( hglobal )
        {
            if( (hresult = MfToPres(hglobal, genobj.m_ppres))
                != NOERROR)
            {
                goto errRtn;
            }
        }
        else
        {
            LEDebugOut((DEB_WARN, "WARNING: Unable to "
                "retrieve CF_METAFILEPICT\n"));
            hresult = ResultFromScode(E_OUTOFMEMORY);
            goto errRtn;
        }

    }
    else if( SSIsClipboardFormatAvailable(CF_DIB) )
    {
        hglobal = SSGetClipboardData(CF_DIB);

        if( hglobal )
        {
            // DibToPres will take ownership of the
            // hglobal
            HGLOBAL hTemp;

            hTemp = UtDupGlobal(hglobal, GMEM_DDESHARE |
                    GMEM_MOVEABLE);

            if( !hTemp )
            {
                hresult = ResultFromScode(E_OUTOFMEMORY);
                goto errRtn;
            }

            if( (hresult = DibToPres(hTemp, genobj.m_ppres))
                != NOERROR )
            {
                GlobalFree(hTemp);
                goto errRtn;
            }
        }
        else
        {
            LEDebugOut((DEB_WARN, "WARNING: Unable to "
                "retrieve CF_DIB\n"));
            hresult = ResultFromScode(E_OUTOFMEMORY);
            goto errRtn;
        }
    }
    else if (SSIsClipboardFormatAvailable(CF_BITMAP))
    {
        hglobal = SSGetClipboardData(CF_BITMAP);

        if( hglobal )
        {
            if( (hresult = BmToPres(hglobal, genobj.m_ppres))
                != NOERROR )
            {
                goto errRtn;
            }
        }
        else
        {
            LEDebugOut((DEB_WARN, "WARNING: Unable to "
                "retrieve CF_BITMAP\n"));
            hresult = ResultFromScode(E_OUTOFMEMORY);
            goto errRtn;
        }
    }
    else
    {
        delete genobj.m_ppres;
        genobj.m_ppres = NULL;
        genobj.m_fNoBlankPres = TRUE;
    }


    hresult = GetAndTranslateOle1(g_cfOwnerLink, &pszClass,
            &genobj.m_szTopic, &genobj.m_szItem, NULL);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    genobj.m_classLast.SetSz(pszClass);

    // now we need to create a storage to stuff the generic object
    // into.

    hresult = UtCreateStorageOnHGlobal(NULL, fDeleteOnRelease,
            &pstg, &plockbytes);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    hresult = GenericObjectToIStorage(genobj, pstg, NULL);

    if (SUCCEEDED(hresult))
    {
        hresult = NOERROR;
    }

    if( IsOwnerLinkStdOleLink() &&
            SSIsClipboardFormatAvailable( g_cfNative) )
    {
        // Case of copying an OLE 2 link from a 1.0 container.
        // The first part of this function created a presentation
        // stream from the presentation on the clipboard.  The
        // presentation is NOT already inside the Native data (i.e.,
        // the cfEmbeddedObject) because we removed it to conserve
        // space.
        hglobal = SSGetClipboardData(g_cfNative);

        if( hglobal == NULL )
        {
            LEDebugOut((DEB_WARN, "WARNING: GetClipboardData for "
                "cfNative failed!\n"));
            hresult = ResultFromScode(CLIPBRD_E_BAD_DATA);

            goto errRtn;		
        }

        // now stuff the native data into the storage, first
        // removing any presentation streams that may have
        // previously existed.

        hresult = NativeToStorage(pstg, hglobal);
    }

    // finished!!  now fill out the pmedium argument and return

    if( pmedium->tymed == TYMED_ISTORAGE )
    {
        // hang onto the storage, in case we need to release
        // it later

        m_pUnkOle1 = (IUnknown *)pstg;

        pmedium->pstg = pstg;
        // NO AddRef
    }
    else
    {
        Assert(pmedium->tymed == TYMED_HGLOBAL);

        hresult = GetHGlobalFromILockBytes(plockbytes,
                &pmedium->hGlobal);

        // GetHGLOBAL should never fail here because we
        // just created the ILockBytes!!
        Assert( hresult == NOERROR );

        // in this case, we want to release the storage
        // and save the hglobal for later delete

        m_hOle1 = pmedium->hGlobal;

        pstg->Release();
        pstg = NULL;
    }
errRtn:

    // if there was an error, we need to blow away any storage
    // that we may have created

    if( hresult != NOERROR )
    {
        if( pszClass )
        {
            PubMemFree(pszClass);
        }

        if( pstg )
        {
            pstg->Release();
            Assert(m_pUnkOle1 == NULL);
        }
    }

    // no matter what, we need to release our lockbytes

    if( plockbytes )
    {
        //  in case of failure we need to make sure the HGLOBAL
        //  used by plockbytes also gets freed - fDeleteOnRelease
        //  tells if plockbytes->Release will do that work for us

        if (FAILED(hresult) && !fDeleteOnRelease)
        {
            HRESULT hrCheck;    //  Preserve hresult

            //  GetHGlobal should never fail here because we just
            //  created the ILockBytes
            hrCheck = GetHGlobalFromILockBytes(plockbytes,
                    &hglobal);
            Assert(NOERROR == hrCheck);

            // GlobalFree returns NULL on success
            hglobal = GlobalFree(hglobal);
            Assert(hglobal == NULL);
        }

        plockbytes->Release();
    }


    LEDebugOut((DEB_ITRACE, "%p OUT CClipDataObject::GetEmbeddedObject"
        "FromOle1 ( %lx ) \n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CClipDataObject::GetEmbedSourceFromOle1 (private)
//
//  Synopsis:	synthesizes cfEmbedSource from available OLE1 data
//
//  Effects:
//
//  Arguments:	[pmedium]	-- where to put the resulting data
//
//  Requires: 	The clipboard must be OPEN
//		we must have verified that the correct formats are
//		available before calling and *while* the clipboard
//		is open (to avoid a race condition)
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:	create a memory-based storage and stuff the following
//		information in it:
//			the clsid of the embedding
//			the class name as the user type
//			the native data in the OLE10_NATIVE_STREAM
//			the item name in the OLE10_ITEMNAME_STREAM
//
//  History:    dd-mmm-yy Author    Comment
//		17-Aug-94 alexgo    fix the check for OLE2 data to handle
//				    OLE2 treat as from OLE1
//              03-Aug-94 AlexT     Check for OLE 2 data
//  		04-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT CClipDataObject::GetEmbedSourceFromOle1( STGMEDIUM *pmedium )
{
    HRESULT		hresult;
    IStorage *	pstg = NULL;
    HGLOBAL		hNative;
    HGLOBAL         hCopy = NULL;
    LPOLESTR	pszClass = NULL;
    LPSTR		pszItemA = NULL;
    CLSID		clsid;
    ILockBytes *	plockbytes = NULL;
    BOOL		fDeleteOnRelease = TRUE;
    BOOL		fIsOle1 = TRUE;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CClipDataObject::GetEmbedSourceFrom"
        "Ole1 ( %p )\n", this, pmedium));

    Assert(SSIsClipboardFormatAvailable(g_cfOwnerLink));
    Assert(SSIsClipboardFormatAvailable(g_cfNative));

    // first fetch the class name of the object

    hresult = GetAndTranslateOle1( g_cfOwnerLink, &pszClass, NULL, NULL,
            &pszItemA );

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    // now fetch the clsid for the embedding

    hresult = wCLSIDFromProgID(pszClass, &clsid, TRUE);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    // if we are asking for EmbedSource on an hglobal, then we
    // don't want to delete the hglobal when we release the storage

    if( pmedium->tymed == TYMED_HGLOBAL )
    {
        fDeleteOnRelease = FALSE;
    }

    // now fetch the native data

    hNative = SSGetClipboardData(g_cfNative);

    if( hNative == NULL )
    {
        hresult = ResultFromScode(CLIPBRD_E_BAD_DATA);
        goto errRtn;
    }

    if (!CoIsOle1Class(clsid))
    {
        // Just because the clsid is OLE2 does not mean that the
        // underlying data is OLE2.  For example, suppose a container
        // copies an old OLE1 object to the clipboard, but the OLE2
        // version of that object has been installed on the system.
        // CLSIDFromProgID will return the *OLE2* class ID in this case.
        // If we're in this case, then we should fall through and treat
        // the data as normal OLE1  (StgOpenStorageOnILockBytes would
        // fail in any event).

        hresult = CreateILockBytesOnHGlobal(hNative, FALSE,
                &plockbytes);

        if( hresult != NOERROR )
        {
            goto errRtn;
        }

        hresult = StgIsStorageILockBytes(plockbytes);

        plockbytes->Release();
        plockbytes = NULL;

        if( hresult == NOERROR )
        {
            // the hNative data really contains a serialized
            // IStorage.
            //
            // This will arise in two cases:
            //	1. Publisher 2.0, 16bit put data on the
            //	clipboard.  They do not call OLE api's but
            //      instead synthesize the same data that 16bit
            //      OleSetClipboard would.
            //
            //	2. An OLE1.0 container copies an OLE2 embedding
            //      to the clipboard.

            fIsOle1 = FALSE;

            hCopy = UtDupGlobal(hNative,
                    GMEM_DDESHARE | GMEM_MOVEABLE);

            if( NULL == hCopy )
            {
                hresult = E_OUTOFMEMORY;
                goto errRtn;
            }

            //  create plockbytes
            hresult = CreateILockBytesOnHGlobal(hCopy,
                        fDeleteOnRelease,
                        &plockbytes);

            if( hresult != NOERROR )
            {
                goto errRtn;
            }

            // the HGLOBAL in plockbytes can change, so we
            // can't do anything with hCopy;  we NULL it out
            // to make sure we don't try to free it

            hCopy = NULL;

            hresult = StgOpenStorageOnILockBytes(plockbytes, NULL,
                              STGM_SALL,
                              NULL, 0, &pstg);
            if (FAILED(hresult))
            {
                goto errRtn;
            }

            // We explicitly ignore any error returned by the
            // following
            UtDoStreamOperation(pstg, NULL, OPCODE_REMOVE,
                STREAMTYPE_CACHE);
        }
        // else the data is really OLE1 and is just being emulated by
        // an OLE2 object
        // Just fall through to the code below which will
        // stuff hNative into the OLE10_NATIVE_STREAM

    }

    // this will be TRUE if the clsid is OLE1 or if the clsid is OLE2
    // but the data in hNative is OLE1 anyway (see comments above)

    if( fIsOle1 == TRUE )
    {
        hresult = UtCreateStorageOnHGlobal( NULL, fDeleteOnRelease,
                          &pstg, &plockbytes);

        if( hresult != NOERROR )
        {
            goto errRtn;
        }

        // we need to stuff the class id of the embedding into the
        // storage

        // REVIEW: this clsid may be an OLE2 class id.  This could
        // cause us trouble in treat as scenarios.

        hresult = pstg->SetClass(clsid);

        if( hresult != NOERROR )
        {
            goto errRtn;
        }

        // store the user type information, etc in our private data
        // streams if RegisterClipboardFormat fails, it will return 0,
        // which is OK for us.

        hresult = WriteFmtUserTypeStg(pstg,
                       (CLIPFORMAT) RegisterClipboardFormat(pszClass),
                       pszClass);

        if( hresult != NOERROR )
        {
            goto errRtn;
        }

        // now stuff the native data into the OLE10_NATIVE_STREAM

        // this is a little worker function found in utstream.cpp
        // which will stuff the hglobal to the OLE1 data into the
        // right stream.
        // the OLE1 DDE stuff also uses this function.

        // REVIEW:
        // the FALSE flag is confusing here, it's supposed to be
        // fIsOle1Interop.  16bit clipboard sources passed FALSE when doing
        // their 1.0 interop stuff, so we'll do that here.  When we
        // overhaul the main 1.0 interop stuff, we should change this flag
        // to be something more intuitive.

        hresult = StSave10NativeData(pstg, hNative, FALSE);

        if( hresult != NOERROR )
        {
            goto errRtn;
        }

        // If we have an item name, then stuff that into
        // OLE10_ITEMNAME_STREAM

        if( pszItemA && pszItemA[0] != '\0' )
        {
            hresult = StSave10ItemName(pstg, pszItemA);
        }
    }

    // this Commit call in non-intuitive.  Basically, we may
    // try to get the underlying hglobal (see below) *before*
    // we release the storage.  The commit guarantees that all
    // the important state information gets flushed to the
    // hglobal (which is not otherwise guaranteed).

    hresult = pstg->Commit(STGC_DEFAULT);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    // FINIS!!
    // now fill out all of the arguments

    if( pmedium->tymed == TYMED_ISTORAGE )
    {
        // hang onto the storage, in case we need to release
        // it later

        m_pUnkOle1 = (IUnknown *)pstg;

        pmedium->pstg = pstg;
        // NO AddRef
    }
    else
    {
        Assert(pmedium->tymed == TYMED_HGLOBAL);

        hresult = GetHGlobalFromILockBytes(plockbytes,
                &pmedium->hGlobal);

        // GetHGLOBAL should never fail here because we
        // just created the ILockBytes!!
        Assert( hresult == NOERROR );

        // in this case, we want to release the storage
        // and save the hglobal for later delete

        m_hOle1 = pmedium->hGlobal;

        pstg->Release();
        pstg = NULL;
    }

errRtn:

    // we are done with our strings

    if( pszClass )
    {
        PubMemFree(pszClass);
    }

    if( pszItemA )
    {
        PubMemFree(pszItemA);
    }

    // if there was an error, we need to blow away any storage
    // that we may have created

    if( hresult != NOERROR )
    {
        if( pstg )
        {
            pstg->Release();
            m_pUnkOle1 = NULL;
        }
    }

    // no matter what, we need to release our lockbytes.

    if( plockbytes )
    {
        //  in case of failure we need to make sure the HGLOBAL
        //  used by plockbytes also gets freed - fDeleteOnRelease
        //  tells if plockbytes->Release will do that work for us

        if (FAILED(hresult) && !fDeleteOnRelease)
        {
            HRESULT hrCheck;    //  Preserve hresult

            //  GetHGlobal should never fail here because we just
            //  created the ILockBytes
            hrCheck = GetHGlobalFromILockBytes(plockbytes, &hCopy);
            Assert(NOERROR == hrCheck);

            //  hCopy will be freed below
        }

        plockbytes->Release();
    }

    if (NULL != hCopy)
    {
        //  GlobalFree returns NULL on success
        hCopy = GlobalFree(hCopy);
        Assert(NULL == hCopy);
    }


    LEDebugOut((DEB_ITRACE, "%p OUT CClipDataObject::GetEmbedSource"
        "FromOle1 ( %lx ) \n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CClipDataObject::GetLinkSourceFromOle1 (private)
//
//  Synopsis:	Synthesizes cfLinkSource format from OLE1 data
//
//  Effects:
//
//  Arguments:	[pmedium]	-- where to put the data
//
//  Requires:	the clipboard must be open
//		we must have verified that the correct formats are
//		available before calling and *while* the clipboard
//		is open (to avoid a race condition)
//
//  Returns: 	HRESULT	
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:	Gets the clsid, filename, and item name for the OLE1 object
//		and creates an OLE1 file moniker.  This moniker is then
//		saved into a memory stream
//
//  History:    dd-mmm-yy Author    Comment
// 		04-Jun-94 alexgo    author
//              05-Aug-94 AlexT     Link Source also needs class id
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT CClipDataObject::GetLinkSourceFromOle1( STGMEDIUM *pmedium )
{
    HRESULT		hresult;
    IStream *	pstm = NULL;
    LPMONIKER	pmkFile = NULL,
            pmkFinal = NULL,
            pmkItem = NULL;
    IPersistStream *pPersistStream = NULL;
    LPOLESTR	pszClass = NULL,
            pszFile = NULL,
            pszItem = NULL;
    CLSID		clsid;
    UINT		cf;
    BOOL		fDeleteOnRelease = TRUE;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CClipDataObject::GetLinkSourceFrom"
        "Ole1 ( %p , %p )\n", this, pmedium ));


    // fetch the info we need from cfOwnerLink or cfObjectLink
    // If this function is called, we should have already determined
    // that the formats were available in the correct order
    // for creating links.


    if( SSIsClipboardFormatAvailable(g_cfObjectLink) )
    {
        cf = g_cfObjectLink;
    }
    else
    {
        cf = g_cfOwnerLink;
        Assert(SSIsClipboardFormatAvailable(g_cfOwnerLink));
    }

    hresult = GetAndTranslateOle1(cf, &pszClass, &pszFile,
                &pszItem, NULL);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    // now fetch the clsid for the OLE1 server

    hresult = wCLSIDFromProgID(pszClass, &clsid, TRUE);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    // now build up our moniker

    hresult = CreateOle1FileMoniker(pszFile, clsid, &pmkFile);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    if( pszItem && pszItem[0] != OLESTR('\0') )
    {
        hresult = CreateItemMoniker(OLESTR("!"), pszItem,
                &pmkItem);

        if( hresult != NOERROR )
        {
            goto errRtn;
        }


        hresult = CreateGenericComposite(pmkFile, pmkItem,
                &pmkFinal);

        if( hresult != NOERROR )
        {
            goto errRtn;
        }
    }
    else
    {
        pmkFinal = pmkFile;

        // this addref is done so we can release all of our
        // monikers at once (i.e., the variables pmkFinal
        // and pmkFile will both be released)
        pmkFinal->AddRef();
    }

    // pmkFinal now contains the moniker we need.  Create a
    // memory stream and save the moniker into it.

    // if we are asking for LinkSource on an hglobal, then we
    // don't want to delete the hglobal when we release the stream

    if( pmedium->tymed == TYMED_HGLOBAL )
    {
        fDeleteOnRelease = FALSE;
    }

    hresult = CreateStreamOnHGlobal(NULL, fDeleteOnRelease, &pstm);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    hresult = pmkFinal->QueryInterface(IID_IPersistStream,
            (LPLPVOID)&pPersistStream);

    // we implemented this file moniker, it should support
    // IPersistStream

    Assert(hresult == NOERROR);

    hresult = OleSaveToStream(pPersistStream, pstm);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    hresult = WriteClassStm(pstm, clsid);

    if (hresult != NOERROR)
    {
        goto errRtn;
    }

    // no matter what, we should save the stream so we can clean
    // up and release our resources if needed



    if( pmedium->tymed == TYMED_ISTREAM )
    {
        // save the stream, in case we need to release it later
        m_pUnkOle1 = (IUnknown *)pstm;

        pmedium->pstm = pstm;
    }
    else
    {
        Assert(pmedium->tymed == TYMED_HGLOBAL);
        hresult = GetHGlobalFromStream(pstm, &(pmedium->hGlobal));

        // since we created the memory stream, the GetHGlobal
        // should never fail
        Assert(hresult == NOERROR);

        // in this case, we want to release the stream and hang
        // onto the hglobal

        m_hOle1 = pmedium->hGlobal;

        pstm->Release();
        pstm = NULL;
    }

errRtn:

    if( pPersistStream )
    {
        pPersistStream->Release();
    }

    if( pmkFile )
    {
        pmkFile->Release();
    }

    if( pmkItem )
    {
        pmkItem->Release();
    }

    if( pmkFinal )
    {
        pmkFinal->Release();
    }

    if( pszClass )
    {
        PubMemFree(pszClass);
    }

    if( pszFile )
    {
        PubMemFree(pszFile);
    }

    if( pszItem )
    {
        PubMemFree(pszItem);
    }

    if( hresult != NOERROR )
    {
        if( pstm )
        {
            HRESULT hrCheck;

            if (!fDeleteOnRelease)
            {
              //  pstm->Release will not free the underlying
              //  HGLOBAL, so we need to do so ourselves

              HGLOBAL hgFree;

              hrCheck = GetHGlobalFromStream(pstm, &hgFree);

              // since we created the memory stream, the GetHGlobal
              // should never fail
              Assert(hrCheck == NOERROR);

              //  GlobalFree returns NULL on success
              hgFree = GlobalFree(hgFree);
              Assert(NULL == hgFree);
            }

            pstm->Release();
            m_pUnkOle1 = NULL;
        }
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CClipDataObject::GetLinkSourceFrom"
        "Ole1 ( %lx ) [ %p , %p ]\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CClipDataObject::GetObjectDescriptorFromOle1 (private)
//
//  Synopsis:	retrieves a UNICODE object descriptor from OLE1 data
//
//  Effects:
//
//  Arguments: 	[cf]		-- the OLE1 clipboard format to use
//		[pmedium]	-- where to put the hglobal
//
//  Requires:  	the clipboard must be open
//		cf must be eith OwnerLink or ObjectLink
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:	Calls CreateObjectDesciptor
//
//  History:    dd-mmm-yy Author    Comment
//		04-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT CClipDataObject::GetObjectDescriptorFromOle1( UINT cf,
        STGMEDIUM *pmedium )
{
    HRESULT		hresult;
    HGLOBAL		hglobal;
    LPOLESTR	pszClass = NULL,
            pszFile = NULL,
            pszItem = NULL,
            pszSrcOfCopy = NULL;
    CLSID		clsid;
    const SIZEL	sizel = {0, 0};
    const POINTL	pointl = {0, 0};
    OLECHAR		szFullName[256];
    LONG		cb = sizeof(szFullName);  // RegQueryValue takes
                         // bytes!!

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CClipDataObject::GetObjectDescriptor"
        "FromOle1 ( %d , %p )\n", this, cf, pmedium));

    Assert(cf == g_cfOwnerLink || cf == g_cfObjectLink);

    // fetch the data we need

    hresult = GetAndTranslateOle1( cf, &pszClass, &pszFile, &pszItem,
                NULL);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    hresult = wCLSIDFromProgID(pszClass, &clsid, TRUE);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    // now fetch the full user name of the object.  This info
    // is found in the registry.

    if( QueryClassesRootValue(pszClass, szFullName, &cb) != 0 )
    {
        // uh-oh, it failed for some reason.  The class name
        // (potentially OLE2Link) was probably not registered, so
        // just use the class name.
        //
        // NB!! 16bit did no error checking for this case, so
        // szFullName in their equivalent code would be left as
        // a NULL string.  This had the effect of making a
        // blank entry in most paste-special dialogs.

        _xstrcpy(szFullName, pszClass);
    }

    // build up the SourceOfCopy string.  It will be a concatenation
    // of the Filename and Item name that we retrieved from the
    // Owner/ObjectLink OLE1 structures

    pszSrcOfCopy = (LPOLESTR)PrivMemAlloc( (_xstrlen(pszFile) +
                _xstrlen(pszItem) + 2) * sizeof(OLECHAR));

    if( pszSrcOfCopy == NULL )
    {
        hresult = ResultFromScode(E_OUTOFMEMORY);
        goto errRtn;
    }

    _xstrcpy(pszSrcOfCopy, pszFile);

    if( pszItem && *pszItem != OLESTR('\0') )
    {
        _xstrcat(pszSrcOfCopy, OLESTR("\\"));
        _xstrcat(pszSrcOfCopy, pszItem);
    }

    // create an object descriptor

    hglobal = CreateObjectDescriptor(clsid, DVASPECT_CONTENT, &sizel,
            &pointl,
            (OLEMISC_CANTLINKINSIDE | OLEMISC_CANLINKBYOLE1),
            szFullName, pszSrcOfCopy);

    if( hglobal == NULL )
    {
        hresult = ResultFromScode(E_OUTOFMEMORY);
        goto errRtn;
    }

    // now fill in out params

    Assert(pmedium->tymed == TYMED_HGLOBAL);

    pmedium->hGlobal = hglobal;

    // we need to save the hglobal so we can free it later if need
    // be

    m_hOle1 = hglobal;

errRtn:

    if( pszClass )
    {
        PubMemFree(pszClass);
    }

    if( pszFile )
    {
        PubMemFree(pszFile);
    }

    if( pszItem )
    {
        PubMemFree(pszItem);
    }

    if( pszSrcOfCopy )
    {
        // NB!! This was allocated with *private* memory
        PrivMemFree(pszSrcOfCopy);
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CClipDataObject::GetObjectDescriptor"
        "FromOle1 ( %lx )\n", this, hresult ));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CClipDataObject::GetOle2FromOle1 (private)
//
//  Synopsis:	synthesize the given ole2 format from available ole1 data
//
//  Effects:
//
//  Arguments: 	[cf]		-- the clipboard format to synthesize
//		[pmedium]	-- where to put the data
//
//  Requires: 	the clipboard must be open
//		CanRetrieveOle2FromOle1 should have succeeded before calling
//		this function
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		04-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT CClipDataObject::GetOle2FromOle1( UINT cf, STGMEDIUM *pmedium )
{
    HRESULT		hresult = ResultFromScode(DV_E_TYMED);

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CClipDataObject::GetOle2FromOle1 "
        "( %d , %p )\n", this, cf, pmedium));

    if( cf == g_cfEmbedSource )
    {
        // we can only fetch EmbedSource on an hglobal or storage

        if( pmedium->tymed == TYMED_HGLOBAL ||
            pmedium->tymed == TYMED_ISTORAGE )
        {
            hresult = GetEmbedSourceFromOle1(pmedium);
        }
    }
    else if( cf == g_cfEmbeddedObject )
    {
        // we can only fetch EmbeddedObject on an hglobal or storage

        if( pmedium->tymed == TYMED_HGLOBAL ||
            pmedium->tymed == TYMED_ISTORAGE )
        {
            hresult = GetEmbeddedObjectFromOle1(pmedium);
        }
    }
    else if( cf == g_cfLinkSource )
    {
        // we can only fetch LinkSource on an hglobal or stream

        if( pmedium->tymed == TYMED_HGLOBAL ||
            pmedium->tymed == TYMED_ISTREAM )
        {
            hresult = GetLinkSourceFromOle1(pmedium);
        }
    }
    else if( cf == g_cfObjectDescriptor )
    {
        // we can only fetch this on an hglobal

        if( pmedium->tymed == TYMED_HGLOBAL )
        {
            hresult = GetObjectDescriptorFromOle1(g_cfOwnerLink,
                    pmedium);
        }
    }
    else if( cf == g_cfLinkSrcDescriptor )
    {
        // we can only fetch this on an hglobal.  Note that
        // a link source descriptor is really an object descriptor

        // also, we can use either ObjectLink or OwnerLink as the
        // the data source, but the only time it is valid to use
        // OwnerLink is if ObjectLink is not available

        if( pmedium->tymed == TYMED_HGLOBAL )
        {
            UINT 	cfOle1;

            if( SSIsClipboardFormatAvailable(g_cfObjectLink) )
            {
                cfOle1 = g_cfObjectLink;
            }
            else
            {
                cfOle1 = g_cfOwnerLink;
            }

            hresult = GetObjectDescriptorFromOle1(cfOle1,
                    pmedium);
        }
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CClipDataObject::GetOle2FromOle1 "
        "( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:	CClipDataObject::OleGetClipboardData (private)
//
//  Synopsis:	private replacement for GetClipboardData that synthesizes
//		OLE2 formats from OLE1 data if necessary
//
//  Effects:
//
//  Arguments:	[cf]		-- the clipboard format to use
//		[phglobal]	-- where to put the fetched data
//
//  Requires:	the clipboard must be open
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:	Try to fetch the request format; if that fails then
//		try to synthesize the data from OLE1
//
//  History:    dd-mmm-yy Author    Comment
// 		04-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT CClipDataObject::OleGetClipboardData( UINT cf, HGLOBAL *phglobal )
{
    HRESULT		hresult = NOERROR;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CClipDataObject::OleGetClipboard"
        "Data ( %x , %p )\n", this, cf, phglobal ));

    Assert(phglobal);

    *phglobal = NULL;

    // fetch the real data, if available
    if( SSIsClipboardFormatAvailable(cf) )
    {
        *phglobal = SSGetClipboardData(cf);
    }
    else if( CanRetrieveOle2FromOle1(cf) )
    {
        STGMEDIUM	medium;

        medium.tymed = TYMED_HGLOBAL;

        hresult = GetOle2FromOle1(cf, &medium);

        if( hresult == NOERROR )
        {
            *phglobal = medium.hGlobal;
        }
    }
    else
    {
        hresult = ResultFromScode(DV_E_FORMATETC);
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CClipDataObject::OleGetClipboardData"
        " ( %lx ) [ %lx ]\n", this, hresult, *phglobal));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CClipDataObject::OleIsClipboardFormatAvailable (private)
//
//  Synopsis:	determines whether a clipboard format is available or
//		can be synthesized from available formats
//
//  Effects:
//
//  Arguments: 	[cf]	-- the clipboard format to check for
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		04-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CClipDataObject::OleIsClipboardFormatAvailable( UINT cf )
{
    BOOL		fRet;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CClipDataObject::OleIsClipboard"
        "FormatAvailable ( %d )\n", this, cf));

    if( !SSIsClipboardFormatAvailable(cf) )
    {
        // if the clipboard format is not normally available, see
        // if we can make it from available formats
        fRet = CanRetrieveOle2FromOle1(cf);
    }
    else
    {
        fRet = TRUE;
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CClipDataObject::OleIsClipboard"
        "FormatAvailable ( %lu )\n", this, fRet ));

    return fRet;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClipDataObject::Dump, public (_DEBUG only)
//
//  Synopsis:   return a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [ppszDump]      - an out pointer to a null terminated character array
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   [ppszDump]  - argument
//
//  Derivation:
//
//  Algorithm:  use dbgstream to create a string containing information on the
//              content of data structures
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

HRESULT CClipDataObject::Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel)
{
    int i;
    unsigned int ui;
    char *pszPrefix;
    char *pszCThreadCheck;
    char *pszFORMATETC;
    dbgstream dstrPrefix;
    dbgstream dstrDump(500);

    // determine prefix of newlines
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << this << " _VB ";
    }

    // determine indentation prefix for all newlines
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    pszCThreadCheck = DumpCThreadCheck((CThreadCheck *)this, ulFlag, nIndentLevel + 1);
    dstrDump << pszPrefix << "CThreadCheck:" << endl;
    dstrDump << pszCThreadCheck;
    CoTaskMemFree(pszCThreadCheck);

    dstrDump << pszPrefix << "No. of References         = " << m_refs       << endl;

    dstrDump << pszPrefix << "Handle OLE2 -> OLE1 data  = " << m_hOle1      << endl;

    dstrDump << pszPrefix << "pIUnknown to OLE1 data    = " << m_pUnkOle1   << endl;

    dstrDump << pszPrefix << "pIDataObject              = " << m_pDataObject << endl;

    dstrDump << pszPrefix << "TriedToGetDataObject?     = ";
    if (m_fTriedToGetDataObject == TRUE)
    {
        dstrDump << "TRUE" << endl;
    }
    else
    {
        dstrDump << "FALSE" << endl;
    }

    // cleanup and provide pointer to character array
    *ppszDump = dstrDump.str();

    if (*ppszDump == NULL)
    {
        *ppszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return NOERROR;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCClipDataObject, public (_DEBUG only)
//
//  Synopsis:   calls the CClipDataObject::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pCDO]          - pointer to CClipDataObject
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCClipDataObject(CClipDataObject *pCDO, ULONG ulFlag, int nIndentLevel)
{
    HRESULT hresult;
    char *pszDump;

    if (pCDO == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    hresult = pCDO->Dump(&pszDump, ulFlag, nIndentLevel);

    if (hresult != NOERROR)
    {
        CoTaskMemFree(pszDump);

        return DumpHRESULT(hresult);
    }

    return pszDump;
}

#endif // _DEBUG

//
// OLE1 support methods
//

//+-------------------------------------------------------------------------
//
//  Function: 	BmToPres
//
//  Synopsis: 	copies a bitmap into a presentation object
//
//  Effects:
//
//  Arguments:	[hBM]		-- handle to the bitmap
//		[ppres]		-- the presentation object
//
//  Requires:	
//
//  Returns:  	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm: 	converts the bitmap to a DIB and then calls DibToPres
//
//  History:    dd-mmm-yy Author    Comment
// 		11-Aug-94 alexgo    port from 16bit
//
//  Notes: 	This code is largely based from 16bit OLE sources
//		REVIEW: we may want to rework portions of this code,
//		particularly if we rewrite the PPRES/GENOBJ code (in
//		ostm2stg.cpp).
//
//--------------------------------------------------------------------------

HRESULT BmToPres(HANDLE hBM, PPRES ppres)
{
    HANDLE	hDib;
    HRESULT	hresult;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN BmToPres ( %lx , %p )\n", NULL,
        hBM, ppres));

    if( (hDib = UtConvertBitmapToDib((HBITMAP)hBM, NULL)) )
    {
        // this routine keeps hDib, it doesn't make a copy of it
        hresult = DibToPres(hDib, ppres);
    }
    else
    {
        hresult = ResultFromScode(E_OUTOFMEMORY);
    }

    LEDebugOut((DEB_ITRACE, "%p OUT BmToPres ( %lx )\n", NULL, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CanRetrieveOle2FromOle1 (private)
//
//  Synopsis:	Determines whether we can synthesize the asked for
//		ole2 format from the formats available on the clipboard.
//		Also checks to see if the *real* OLE2 format is available.
//
//  Effects: 	does not need to open the clipboard
//
//  Arguments: 	[cf]	-- the clipboard format to check for
//
//  Requires:
//
//  Returns: 	TRUE if we can synthesize the requested format AND the
//			real format is NOT available
//		FALSE otherwise
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:	for cfEmbedSource:
//			cfNative and cfOwnerLink must be present and
//			cfNative must precede cfOwnerLink and cfOwnerLink
//			must not represent a StdOleLink
//
//		for cfEmbeddedObject:
//			cfOwnerLink must be present and cfNative
//			must not be not present OR
//
//			cfNative must come after cfOwnerLink OR
//
//			cfNative precedes cfOwnerLink  and
//			cfOwnerLink represents a StdOleLink
//
//		for cfLinkSource:
//			cfObjectLink must be present OR
//
//			both cfNative and cfOwnerLink must be present
//			and cfOwnerLink must precede cfNative
//
//		for cfObjectDescriptor or cfLinkSrcDescriptor
//			either cfObjectLink or cfOwnerLink must be
//			available
//
//  History:    dd-mmm-yy Author    Comment
//		11-Aug-94 alexgo    added support for EmbeddedObject
//				    retrieval ala 16bit OLE
//		04-Jun-94 alexgo    author
//
//  Notes:	We don't want to synthesize OLE2 formats from OLE1
//		if the real OLE2 formats are available because the OLE2
//		formats probably contain more information.
//
//		We sometimes need to open the clipboard to accurately
//		fetch enough information to satisfy a query on
//		EmbedSource, EmbeddedObject or LinkSource.
//		Since the clipboard is a global resource, we
//		must only open it for brief periods of time.
//
//--------------------------------------------------------------------------

BOOL CanRetrieveOle2FromOle1( UINT cf )
{
    BOOL	fRet = FALSE,
        fOwnerLink = FALSE,
        fNative = FALSE,
        fOpenedClipboard = FALSE;
    UINT	cfFirst = 0,		// the first format available
        cfTemp;
    HRESULT	hresult;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CanRetrieveOle2From"
        "Ole1 ( %d )\n", NULL, cf ));


    if( SSIsClipboardFormatAvailable(g_cfOlePrivateData) )
    {
        // if we put the data on the clipboard, assume only OLE2
        // data transfers

        goto errRtn;
    }

    // first check for LinkSourceDescriptor or ObjectDescriptor, as
    // we do not need to open the clipboard for these.

    if( cf == g_cfObjectDescriptor )
    {
        // we must have either OwnerLink or ObjectLink
        if( !SSIsClipboardFormatAvailable(g_cfObjectDescriptor) &&
            (SSIsClipboardFormatAvailable(g_cfObjectLink) ||
            SSIsClipboardFormatAvailable(g_cfOwnerLink) ) )
        {
            fRet = TRUE;
        }

        goto errRtn;
    }

    if( cf == g_cfLinkSrcDescriptor )
    {
        // we must have either OwnerLink or ObjectLink
        if( !SSIsClipboardFormatAvailable(g_cfLinkSrcDescriptor) &&
            (SSIsClipboardFormatAvailable(g_cfObjectLink) ||
            SSIsClipboardFormatAvailable(g_cfOwnerLink) ) )
        {
            fRet = TRUE;
        }

        goto errRtn;
    }


    // now check for the remaining OLE2 formats EmbedSource,
    // EmbeddedObject, and LinkSource.


    if( (cf == g_cfEmbedSource) || (cf == g_cfEmbeddedObject) ||
        (cf == g_cfLinkSource) )
    {
        // we need to open the clipboard so our calls to
        // EnumClipboardFormats and GetClipboardData will work.

        // however, the caller of this function may have already
        // opened the clipboard, so we need to check for this.

        //
        //
        // BEGIN: OPENCLIPBOARD
        //
        //

        if( GetOpenClipboardWindow() !=
            GetPrivateClipboardWindow(CLIP_QUERY) )
        {
            hresult = OleOpenClipboard(NULL, NULL);

            if( hresult != NOERROR )
            {
                // if we can't open the clipboard,
                // then we can't accurately determine
                // if we can fetch the requested
                // data.  Assume that we can't
                // and return.
                fRet = FALSE;
                goto errRtn;

            }

            fOpenedClipboard = TRUE;
        }

        // we now need to determine the ordering of the clipboard
        // formats Native and OwnerLink.  OLE1 specifies different
        // behaviour based on the order in which these formats
        // appear (see the Algorithm section for details)

        fNative = SSIsClipboardFormatAvailable(g_cfNative);
        fOwnerLink = SSIsClipboardFormatAvailable(g_cfOwnerLink);


        if( fNative && fOwnerLink )
        {
            cfTemp = 0;
            while( (cfTemp = SSEnumClipboardFormats(cfTemp)) != 0 )
            {
                if( cfTemp == g_cfNative )
                {
                    cfFirst = g_cfNative;
                    break;
                }
                else if( cfTemp == g_cfOwnerLink )
                {
                    cfFirst = g_cfOwnerLink;
                    break;
                }
            }
        }


        if( cf == g_cfEmbeddedObject )
        {
            // cfOwnerLink must be present and cfNative
            // must not be not present OR
            // cfNative must come after cfOwnerLink OR
            // cfNative comes before cfOwnerLink and
            // cfOwnerLink represents a StdOleLink

            if( fOwnerLink && !fNative )
            {
                fRet = TRUE;
            }
            else if ( cfFirst == g_cfOwnerLink &&
                fNative )
            {
                fRet = TRUE;
            }
            else if( cfFirst == g_cfNative && fOwnerLink &&
                IsOwnerLinkStdOleLink() )
            {
                fRet = TRUE;
            }
        }
        else if( cf == g_cfEmbedSource )
        {
            // cfNative and cfOwnerLink must be present
            // cfNative must precede cfOwnerLink and
            // OwnerLink must not represent a StdOleLink

            if( cfFirst == g_cfNative && fOwnerLink &&
                !IsOwnerLinkStdOleLink())
            {
                fRet = TRUE;
            }
        }
        else
        {
            Assert(cf == g_cfLinkSource);

            // cfObjectLink must be present OR
            // both cfNative and cfOwnerLink must be present
            // and cfOwnerLink must precede cfNative

            if( SSIsClipboardFormatAvailable(g_cfObjectLink) )
            {
                fRet = TRUE;
            }
            else if( cfFirst == g_cfOwnerLink )
            {
                fRet = TRUE;
            }

        }

        if( fOpenedClipboard )
        {
            if( !SSCloseClipboard() )
            {
                LEDebugOut((DEB_ERROR, "ERROR!: "
                    "CloseClipboard failed in "
                    "CanRetrieveOle2FromOle1!\n"));

                // just keep going and hope for the best.
            }
        }

        //
        //
        // END: CLOSECLIPBOARD
        //
        //
    }

errRtn:

    LEDebugOut((DEB_ITRACE, "%p OUT CanRetrieveOle2From"
        "Ole1 ( %d )\n", NULL, fRet));

    return fRet;
}

//+-------------------------------------------------------------------------
//
//  Function:	DibToPres
//
//  Synopsis: 	stuffs a DIB into a presentation object
//
//  Effects:  	takes ownership of hDib.
//
//  Arguments: 	[hDib]		-- the DIB
//		[ppres]		-- the presentation object
//
//  Requires:	hDib *must* be a copy; this function will take ownership
//		of the hglobal.
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm: 	sets various fields in the presentation object
//
//  History:    dd-mmm-yy Author    Comment
//		11-Aug-94 alexgo    port from 16bit
//
//  Notes: 	This code is largely based from 16bit OLE sources
//		REVIEW: we may want to rework portions of this code,
//		particularly if we rewrite the PPRES/GENOBJ code (in
//		ostm2stg.cpp).
//
//		We take ownership of hDib because this function is
//		called by BmToPres, which allocates a DIB calls us.
//
//--------------------------------------------------------------------------

HRESULT DibToPres( HANDLE hDib, PPRES ppres)
{
    BITMAPINFOHEADER * 	pbminfohdr;
    HRESULT			hresult = NOERROR;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN DibToPres ( %lx , %p )\n", NULL,
        hDib, ppres));

    Assert (ppres);

    pbminfohdr = (BITMAPINFOHEADER FAR*) GlobalLock (hDib);

    if( pbminfohdr == NULL )
    {
        hresult = ResultFromScode(CLIPBRD_E_BAD_DATA);
        goto errRtn;
    }

    // ftagClipFormat is defined in ostm2stg.h

    ppres->m_format.m_ftag = ftagClipFormat;
    ppres->m_format.m_cf = CF_DIB;
    ppres->m_ulHeight = pbminfohdr->biHeight;
    ppres->m_ulWidth  = pbminfohdr->biWidth;

    // the destructor for m_data (in ostm2stg.cpp) will GlobalUnlock
    // m_pv and free m_h.  Cute, ehh??
    ppres->m_data.m_h = hDib;
    ppres->m_data.m_pv = pbminfohdr;
    ppres->m_data.m_cbSize = (ULONG) GlobalSize (hDib);

    // we must free hDib
    ppres->m_data.m_fNoFree = FALSE;

    // Do not unlock hDib (done by ~CData in ostm2stg.cpp)


errRtn:

    LEDebugOut((DEB_ITRACE, "%p OUT DibToPres ( %lx )\n", NULL, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function: 	IsOwnerLinkStdOleLink
//
//  Synopsis:	checks to see if the OwnerLink data on the clipboard
//		really represents a StdOleLink.
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires: 	The clipboard *must* be open.
//		cfOwnerLink must be on the clipboard.
//
//  Returns:	TRUE/FALSE
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	checks the class name in the OwnerLink data to see if it
//		matches	'OLE2Link'.
//
//  History:    dd-mmm-yy Author    Comment
// 		11-Aug-94 alexgo    author
//
//  Notes: 	OwnerLink data is laid out as follows
//		szClass\0szFile\0szItem\0\0
//
// 		where sz* are ANSI strings.
//
//--------------------------------------------------------------------------

BOOL IsOwnerLinkStdOleLink( void )
{
    HGLOBAL		hOwnerLink;
    LPSTR		pszClass;
    BOOL		fRet = FALSE;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN IsOwnerLinkStdOleLink ( )\n", NULL));

    Assert(SSIsClipboardFormatAvailable(g_cfOwnerLink));
    Assert(GetOpenClipboardWindow() ==
        GetPrivateClipboardWindow(CLIP_QUERY));

    hOwnerLink = SSGetClipboardData(g_cfOwnerLink);

    if( hOwnerLink )
    {
        pszClass = (LPSTR)GlobalLock(hOwnerLink);

        if( pszClass )
        {
            // NB!! These are intentionally ANSI strings.
            // OLE1 apps only understand ANSI

            if( _xmemcmp(pszClass, "OLE2Link",
                sizeof("OLE2Link")) == 0 )
            {
                fRet = TRUE;
            }

            GlobalUnlock(hOwnerLink);
        }
    }

    LEDebugOut((DEB_ITRACE, "%p OUT IsOwnerLinkStdOleLink ( %lu )\n",
        NULL, fRet));

    return fRet;
}

//+-------------------------------------------------------------------------
//
//  Function:	MfToPres
//
//  Synopsis:	copies the given metafile into the presentation object
//
//  Effects:
//
//  Arguments: 	[hMfPict]	-- the metafilepict handle
//		[ppres]		-- the presentation object
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	copies the metafile and fills out relevant fields in
//		the presentation object
//
//  History:    dd-mmm-yy Author    Comment
//		11-Aug-94 alexgo    port from 16bit
//
//  Notes: 	This code is largely based from 16bit OLE sources
//		REVIEW: we may want to rework portions of this code,
//		particularly if we rewrite the PPRES/GENOBJ code (in
//		ostm2stg.cpp).
//
//--------------------------------------------------------------------------

HRESULT MfToPres( HANDLE hMfPict, PPRES ppres )
{
    HRESULT 	hresult;
    LPMETAFILEPICT 	pMfPict = NULL;
    HANDLE		hglobal = NULL;
    DWORD		cbSize;
    LPVOID		pv = NULL;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN MfToPres ( %lx , %p )\n", NULL,
        hMfPict, ppres));

    Assert (ppres);

    pMfPict = (LPMETAFILEPICT) GlobalLock (hMfPict);


    if( !pMfPict )
    {
        hresult = ResultFromScode(CLIPBRD_E_BAD_DATA);
        goto errRtn;
    }

    ppres->m_format.m_ftag = ftagClipFormat;
    ppres->m_format.m_cf = CF_METAFILEPICT;
    ppres->m_ulHeight = pMfPict->yExt;
    ppres->m_ulWidth  = pMfPict->xExt;

    // in order for the presentation object stuff to work right,
    // we need to get the metafile bits in an HGLOBAL

    cbSize = GetMetaFileBitsEx(pMfPict->hMF, 0, NULL);

    if( cbSize == 0 )
    {
        hresult = ResultFromScode(CLIPBRD_E_BAD_DATA);
        goto errRtn;
    }

    hglobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, cbSize);

    if( hglobal == NULL )
    {
        hresult = ResultFromScode(E_OUTOFMEMORY);
        goto errRtn;
    }

    pv = GlobalLock(hglobal);

    if( pv == NULL )
    {
        hresult = ResultFromScode(E_OUTOFMEMORY);
        goto errRtn;
    }

    // now fetch the real bits

    if( GetMetaFileBitsEx(pMfPict->hMF, cbSize, pv) == 0 )
    {
        hresult = ResultFromScode(CLIPBRD_E_BAD_DATA);
        goto errRtn;
    }


    ppres->m_data.m_h = hglobal;
    ppres->m_data.m_cbSize = cbSize;
    ppres->m_data.m_pv = pv;

    hresult = NOERROR;

errRtn:

    if( pMfPict )
    {
        GlobalUnlock(hMfPict);
    }

    if( hresult != NOERROR )
    {
        if( pv )
        {
            GlobalUnlock(hglobal);
        }

        if( hglobal )
        {
            GlobalFree(hglobal);
        }
    }

    LEDebugOut((DEB_ITRACE, "%p OUT MftoPres ( %lx )\n", NULL, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function: 	NativeToStorage
//
//  Synopsis: 	takes the hglobal from cfNative and stuffs the data
//		onto the given storage.
//
//  Effects:
//
//  Arguments: 	[pstg]		-- the storage
//		[hNative]	-- the hglobal
//
//  Requires:	hNative must really have an IStorage in it
//
//  Returns:  	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	layers a storage on top of the HGLOBAL, removes any
//		presentation streams, and then copies into the given
//		storage.
//
//  History:    dd-mmm-yy Author    Comment
// 		11-Aug-94 alexgo    author
//
//  Notes: 	
//
//--------------------------------------------------------------------------

HRESULT NativeToStorage( LPSTORAGE pstg, HANDLE hNative )
{
    LPLOCKBYTES 	plockbyte = NULL;
    LPSTORAGE 	pstgNative= NULL;
    HRESULT 	hresult;
    HGLOBAL		hCopy = NULL;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN NativeToStorage ( %p , %lx )\n",
        NULL, pstg, hNative));

    hCopy = UtDupGlobal(hNative, GMEM_DDESHARE | GMEM_MOVEABLE);

    if( hCopy == NULL )
    {
        hresult = ResultFromScode(E_OUTOFMEMORY);
        goto errRtn;
    }

    hresult = CreateILockBytesOnHGlobal( hCopy, TRUE /*fDeleteOnRelease*/,
            &plockbyte);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

    // This is really a 2.0 object disguised as a 1.0 object
    // for the sake of its 1.0 container, so reconstitute
    // the original IStorage from the native data.

    hresult = StgIsStorageILockBytes(plockbyte);

    if( hresult != NOERROR )
    {
        LEDebugOut((DEB_ERROR, "ERROR!: Native data is not based on an"
            " IStorage!\n"));

        goto errRtn;
    }

    hresult = StgOpenStorageOnILockBytes(plockbyte, NULL, STGM_DFRALL,
            NULL, 0, &pstgNative);

    if( hresult != NOERROR )
    {
        LEDebugOut((DEB_ERROR, "ERROR!: OpenStorage on Native data"
            "failed!!\n"));
        goto errRtn;
    }

    // now remove the any presentation streams from the native IStorage.
    // we do this because the OLE1 container will just hang on to the
    // hglobal although it may change (i.e. resize) the presenation.
    // Any cached presentation streams may therefore be invalid.

    // the caller of this function should reconstruct new presentation
    // streams from data available on the clipboard.

    hresult = UtDoStreamOperation(pstgNative,/* pstgSrc */
            NULL,		   /* pstgDst */
            OPCODE_REMOVE,	   /* operation to performed */
            STREAMTYPE_CACHE); /* streams to be operated upon */

    if( hresult != NOERROR )
    {
        LEDebugOut((DEB_ERROR, "ERROR!: Cache stream removal "
            "failed for Native data-based IStorage!\n"));
        goto errRtn;
    }

    hresult = pstgNative->CopyTo(0, NULL, NULL, pstg);

    if( hresult != NOERROR )
    {
        goto errRtn;
    }

errRtn:
    if( pstgNative )
    {
        pstgNative->Release();
    }
    if( plockbyte )
    {
        plockbyte->Release();
    }

    LEDebugOut((DEB_ITRACE, "%p OUT NativeToStorage ( %lx )\n", NULL,
        hresult));

    return hresult;
}


//
// Enumerator implementation for enumerating a FromatEtcDataArray
//

//+-------------------------------------------------------------------------
//
//  Member: 	CEnumFormatEtcDataArray::QueryInterface
//
//  Synopsis: 	returns requested interfaces
//
//  Effects:
//
//  Arguments: 	[riid]		-- the requested interface
//		[ppvObj]	-- where to put the interface pointer
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		10-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CEnumFormatEtcDataArray::QueryInterface( REFIID riid, LPVOID *ppvObj )
{
    HRESULT		hresult = NOERROR;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CEnumFormatEtcDataArray::QueryInterface "
        "( %p , %p )\n", this, riid, ppvObj));

    if( IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IEnumFORMATETC) )
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
        *ppvObj = NULL;
        hresult = ResultFromScode(E_NOINTERFACE);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CEnumFormatEtcDataArray::QueryInterface "
        "( %lx ) [ %p ]\n", this, *ppvObj ));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CEnumFormatEtcDataArray::AddRef
//
//  Synopsis:	increments the reference count
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns:	ULONG-- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//    		10-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEnumFormatEtcDataArray::AddRef( )
{
    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CEnumFormatEtcDataArray::AddRef ( )\n",
        this));

    ++m_refs;

    LEDebugOut((DEB_TRACE, "%p OUT CEnumFormatEtcDataArray::AddRef ( %lu )\n",
        this, m_refs));

    return m_refs;
}

//+-------------------------------------------------------------------------
//
//  Member:   	CEnumFormatEtcDataArray::Release
//
//  Synopsis:	decrements the reference count on the object
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires:
//
//  Returns: 	ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		10-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEnumFormatEtcDataArray::Release( )
{
    ULONG cRefs;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CEnumFormatEtcDataArray::Release ( )\n",
        this));

    if( (cRefs = --m_refs ) == 0 )
    {
        LEDebugOut((DEB_TRACE, "%p DELETED CEnumFormatEtcDataArray\n",
            this));
        delete this;
    }

    // using "this" below is OK, since we only want its value
    LEDebugOut((DEB_TRACE, "%p OUT CEnumFormatEtcDataArray::Release ( %lu )\n",
        this, cRefs));

    return cRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:	CEnumFormatEtcDataArray::Next
//
//  Synopsis:	gets the next [celt] formats
//
//  Effects:
//
//  Arguments:	[celt]		-- the number of elements to fetch
//		[rgelt]		-- where to put them
//		[pceltFetched]	-- the number of formats actually fetched
//
//  Requires:
//
//  Returns:	NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		10-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CEnumFormatEtcDataArray::Next(    ULONG celt,
    FORMATETC *rgelt,
    ULONG *pceltFetched)
{
    if (celt == 0)
    {
        LEDebugOut((DEB_ERROR,
            "CDragEnum::Next requested entries returned is invalid\n"));
        return E_INVALIDARG;
    }

    if (!IsValidPtrOut(rgelt, sizeof(FORMATETC) * celt))
    {
        LEDebugOut((DEB_ERROR,
            "CDragEnum::Next array to return entries invalid\n"));
        return E_INVALIDARG;
    }

    if (pceltFetched)
    {
        if (!IsValidPtrOut(pceltFetched, sizeof(*pceltFetched)))
        {
            LEDebugOut((DEB_ERROR,
                "CDragEnum::Next count to return invalid\n"));
            return E_INVALIDARG;
        }
    }
    else if (celt != 1)
    {
        LEDebugOut((DEB_ERROR,
            "CDragEnum::count requested != 1 & count fetched is NULL\n"));
        return E_INVALIDARG;

    }

    // handle the case where we have no data
    if( m_pFormatEtcDataArray == NULL )
    {
	if( pceltFetched )
	{
	    *pceltFetched = 0;
	}
	return S_FALSE;
    }


    // Calculate the maximum number that we can return
    ULONG cToReturn = (m_cOffset < m_pFormatEtcDataArray->_cFormats)
        ? m_pFormatEtcDataArray->_cFormats - m_cOffset
        : 0;

    // Are we going to return any?
    if (cToReturn != 0)
    {
        // If the number requested is less that the maximum number
        // we can return, the we will return all requested/
        if (celt < cToReturn)
        {
            cToReturn = celt;
        }

        // Allocate and copy the DVTARGETDEVICE - a side effect of this
        // loop is that our offset pointer gets updated to its value at
        // the completion of the routine.
        for (DWORD i = 0; i < cToReturn; i++, m_cOffset++)
        {

	    memcpy(&rgelt[i], &(m_pFormatEtcDataArray->_FormatEtcData[m_cOffset]._FormatEtc),
		sizeof(FORMATETC));

            if (m_pFormatEtcDataArray->_FormatEtcData[m_cOffset]._FormatEtc.ptd != NULL)
            {
                // Create a pointer to the device target - Remember when
                // we created the shared memory block we overroad the ptd
                // field of the FORMATETC so that it is now the offset
                // from the beginning of the shared memory. We reverse
                // that here so we can copy the data for the consumer.
                DVTARGETDEVICE *pdvtarget = (DVTARGETDEVICE *)
                    ((BYTE *) m_pFormatEtcDataArray
                        + (ULONG_PTR) m_pFormatEtcDataArray->_FormatEtcData[m_cOffset]._FormatEtc.ptd);

                // Allocate a new DVTARGETDEVICE
                DVTARGETDEVICE *pdvtargetNew = (DVTARGETDEVICE *)
                    CoTaskMemAlloc(pdvtarget->tdSize);

                // Did the memory allocation succeed?
                if (pdvtargetNew == NULL)
                {
                    // NO! - so clean up. First we free any device targets
                    // that we might have allocated.
                    for (DWORD j = 0; j < i; j++)
                    {
                        if (rgelt[j].ptd != NULL)
                        {
                            CoTaskMemFree(rgelt[j].ptd);
                        }
                    }

                    // Then we restore the offset to its initial state
                    m_cOffset -= i;

                    return E_OUTOFMEMORY;
                }

                // Copy the old targetDevice to the new one
                memcpy(pdvtargetNew, pdvtarget, pdvtarget->tdSize);

                // Update output FORMATETC pointer
                rgelt[i].ptd = pdvtargetNew;
            }
        }
    }

    if (pceltFetched)
    {
        *pceltFetched = cToReturn;
    }

    return (cToReturn == celt) ? NOERROR : S_FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:	CEnumFormatEtcDataArray::Skip
//
//  Synopsis:	skips the next [celt] formats
//
//  Effects:
//
//  Arguments:	[celt]		-- the number of elements to skip
//
//  Requires:
//
//  Returns:	NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		10-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CEnumFormatEtcDataArray::Skip( ULONG celt )
{
    HRESULT		hresult = NOERROR;
    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CEnumFormatEtcDataArray::Skip ( %lu )\n",
        this, celt));

    m_cOffset += celt;

    if( m_cOffset > m_pFormatEtcDataArray->_cFormats )
    {
        // whoops, skipped to far ahead.  Set us to the max limit.
        m_cOffset = m_pFormatEtcDataArray->_cFormats ;
        hresult = ResultFromScode(S_FALSE);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CEnumFormatEtcDataArray::Skip ( %lx )\n",
        this, hresult ));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:	CEnumFormatEtcDataArray::Reset
//
//  Synopsis:	resets the seek pointer to zero
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns:	NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		10-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CEnumFormatEtcDataArray::Reset( void )
{
    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CEnumFormatEtcDataArray::Reset ( )\n",
        this));

    m_cOffset = 0;

    LEDebugOut((DEB_TRACE, "%p OUT CEnumFormatEtcDataArray::Reset ( %lx )\n",
        this, NOERROR ));

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:	CEnumFormatEtcDataArray::Clone
//
//  Synopsis:	clones the enumerator
//
//  Effects:
//
//  Arguments:	[ppIEnum]	-- where to put the cloned enumerator
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		10-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CEnumFormatEtcDataArray::Clone( IEnumFORMATETC **ppIEnum )
{
    HRESULT			hresult;
    CEnumFormatEtcDataArray *	pClipEnum;	

    VDATEHEAP();
    VDATETHREAD(this);

    VDATEPTROUT(ppIEnum, IEnumFORMATETC *);

    LEDebugOut((DEB_TRACE, "%p _IN CEnumFormatEtcDataArray::Clone ( %p )\n",
        this, ppIEnum));

    *ppIEnum = new CEnumFormatEtcDataArray(m_pFormatEtcDataArray,m_cOffset);

    hresult = *ppIEnum ? NOERROR : E_OUTOFMEMORY;

    LEDebugOut((DEB_TRACE, "%p OUT CEnumFormatEtcDataArray::Clone ( %p )\n",
        this, *ppIEnum));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CEnumFormatEtcDataArray::CEnumFormatEtcDataArray, private
//
//  Synopsis:	constructor
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//	 	10-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

CEnumFormatEtcDataArray::CEnumFormatEtcDataArray(FORMATETCDATAARRAY  *pFormatEtcDataArray,DWORD cOffset)
{

    Assert(pFormatEtcDataArray);

    m_refs		    = 1;	// give the intial reference
    m_pFormatEtcDataArray   = pFormatEtcDataArray;
    m_cOffset		    = cOffset;

    ++(m_pFormatEtcDataArray->_cRefs); // hold onto Shared formats.

}

//+-------------------------------------------------------------------------
//
//  Member:  	CEnumFormatEtcDataArray::~CEnumFormatEtcDataArray, private
//
//  Synopsis:	destructor
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//	 	10-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

CEnumFormatEtcDataArray::~CEnumFormatEtcDataArray( void )
{

    Assert(NULL != m_pFormatEtcDataArray);

    if( m_pFormatEtcDataArray )
    {
	if (0 == --m_pFormatEtcDataArray->_cRefs) 
	{ 
	    PrivMemFree(m_pFormatEtcDataArray); 
	     m_pFormatEtcDataArray = NULL; 
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\debug\debapi.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       DebAPI.CXX
//
//  Contents:   Debugging API's
//
//  Classes:
//
//  Functions:
//
//  History:    29-Nov-93 AlexT     Created
//
//--------------------------------------------------------------------------

#include <le2int.h>

#if DBG==1

#include <debnot.h>

DECLARE_INFOLEVEL(LE)

#endif  // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\debug\dbgdump.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       dbgdump.cpp
//
//  Contents:   contains APIs to dump structures (return a formatted string
//              of structure dumps in a coherent fashion)
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              23-Jan-95 t-ScottH  author
//
//--------------------------------------------------------------------------

#include <le2int.h>
#include <memstm.h>
#include <dbgdump.h>

#ifdef _DEBUG
    const char szDumpErrorMessage[]  = "Dump Error - Out of Memory   \n\0";
    const char szDumpBadPtr[]        = "Dump Error - NULL pointer    \n\0";
#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpADVFFlags, public (_DEBUG only)
//
//  Synopsis:   returns a char array with the set flags and hex value
//
//  Effects:
//
//  Arguments:  [dwADVF]  - flags
//
//  Requires:
//
//  Returns:    character arry of string value of flags
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpADVFFlags(DWORD dwAdvf)
{
    char *pszDump;
    dbgstream dstrDump(100);

    if (dwAdvf & ADVF_NODATA)
    {
        dstrDump << "ADVF_NODATA ";
    }
    if (dwAdvf & ADVF_PRIMEFIRST)
    {
        dstrDump << "ADVF_PRIMEFIRST ";
    }
    if (dwAdvf & ADVF_ONLYONCE)
    {
        dstrDump << "ADVF_ONLYONCE ";
    }
    if (dwAdvf & ADVF_DATAONSTOP)
    {
        dstrDump << "ADVF_DATAONSTOP ";
    }
    if (dwAdvf & ADVFCACHE_NOHANDLER)
    {
        dstrDump << "ADVFCACHE_NOHANDLER ";
    }
    if (dwAdvf & ADVFCACHE_FORCEBUILTIN)
    {
        dstrDump << "ADVFCACHE_FORCEBUILTIN ";
    }
    if (dwAdvf & ADVFCACHE_ONSAVE)
    {
        dstrDump << "ADVFCACHE_ONSAVE ";
    }
    // see if there are any flags set
    if ( ! (( dwAdvf & ADVF_NODATA )            |
            ( dwAdvf & ADVF_PRIMEFIRST )        |
            ( dwAdvf & ADVF_ONLYONCE )          |
            ( dwAdvf & ADVF_DATAONSTOP )        |
            ( dwAdvf & ADVFCACHE_NOHANDLER )    |
            ( dwAdvf & ADVFCACHE_FORCEBUILTIN ) |
            ( dwAdvf & ADVFCACHE_ONSAVE )))
    {
        dstrDump << "No FLAGS SET! ";
    }
    // cast as void * for formatting (0x????????) with sign-extension for Sundown.
    dstrDump << "(" << LongToPtr(dwAdvf) << ")";

    pszDump = dstrDump.str();

    if (pszDump == NULL)
    {
        return UtDupStringA(szDumpErrorMessage);
    }

    return pszDump;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpATOM, public (_DEBUG only)
//
//  Synopsis:   returns the ATOM name using GetAtomName
//
//  Effects:
//
//  Arguments:  [atm]   - the ATOM to get name of
//
//  Requires:   GetAtomNameA API
//
//  Returns:    a pointer to character array containing
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              27-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
#ifdef _DEBUG

#define MAX_ATOMNAME 256

char *DumpATOM(ATOM atm)
{
    UINT nResult;
    char *pszAtom = (char *)CoTaskMemAlloc(MAX_ATOMNAME);
    if (pszAtom == NULL)
    {
        return UtDupStringA(szDumpErrorMessage);        
    }

    nResult = GetAtomNameA( atm, pszAtom, MAX_ATOMNAME);

    if (nResult == 0)   // GetAtomName failed
    {
        // try get GlobalAtomNameA
        nResult = GlobalGetAtomNameA(atm, pszAtom, MAX_ATOMNAME);

        if (nResult == 0)
        {
            CoTaskMemFree(pszAtom);

            return DumpWIN32Error(GetLastError());
        }
    }

    return pszAtom;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCLIPFORMAT, public (_DEBUG only)
//
//  Synopsis:   returns the CLIPFORMAT name using GetClipboardFormatName
//
//  Effects:
//
//  Arguments:  [clipformat]   - the CLIPFORMAT to get name of
//
//  Requires:   GetClipboardFormatName API
//
//  Returns:    a pointer to character array containing
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              27-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
#ifdef _DEBUG

#define MAX_FORMATNAME 256

char *DumpCLIPFORMAT(CLIPFORMAT clipformat)
{
    int nResult;
    char *pszClipFormat;

    // we have to do predefined formats by name
    if ( clipformat > 0xC000 )
    {
        pszClipFormat = (char *)CoTaskMemAlloc(MAX_FORMATNAME);
        if (pszClipFormat == NULL)
        {
            return UtDupStringA(szDumpErrorMessage);        
        }

        nResult = SSGetClipboardFormatNameA( clipformat, pszClipFormat, MAX_FORMATNAME);

        if (nResult == 0)   // GetClipboardFormatName failed
        {
            CoTaskMemFree(pszClipFormat);

            return DumpWIN32Error(GetLastError());
        }
    }
    else
    {
        switch (clipformat)
        {
        case CF_METAFILEPICT:
            pszClipFormat = UtDupStringA("CF_METAFILEPICT\0");
            break;
        case CF_BITMAP:
            pszClipFormat = UtDupStringA("CF_BITMAP\0");
            break;
        case CF_DIB:
            pszClipFormat = UtDupStringA("CF_DIB\0");
            break;
        case CF_PALETTE:
            pszClipFormat = UtDupStringA("CF_PALETTE\0");
            break;
        case CF_TEXT:
            pszClipFormat = UtDupStringA("CF_TEXT\0");
            break;
        case CF_UNICODETEXT:
            pszClipFormat = UtDupStringA("CF_UNICODETEXT\0");
            break;
        case CF_ENHMETAFILE:
            pszClipFormat = UtDupStringA("CF_ENHMETAFILE\0");
            break;
        default:
            pszClipFormat = UtDupStringA("UNKNOWN Default Format\0");
            break;
        }
    }

    return pszClipFormat;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCMutexSem, public (_DEBUG only)
//
//  Synopsis:   not implemented
//
//  Effects:
//
//  Arguments:  [pMS]   - pointer to a CMutexSem
//
//  Requires:
//
//  Returns:    character array
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCMutexSem(CMutexSem2 *pMS)
{
    return UtDupStringA("Dump CMutexSem not implemented\0");
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCLSID, public (_DEBUG only)
//
//  Synopsis:   dump a CLSID into a string using StringFromCLSID and
//              ProgIDFromCLSID
//
//  Effects:
//
//  Arguments:  [clsid]    - pointer to a CLSID
//
//  Requires:   StringFromCLSID and ProgIDFromCLSID APIs
//
//  Returns:    character array of string (allocated by OLE)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              27-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCLSID(REFCLSID clsid)
{
    HRESULT     hresult;
    LPOLESTR    pszClsidString = NULL;
    LPOLESTR    pszClsidID = NULL;
    char        *pszDump;

    hresult = StringFromCLSID(clsid, &pszClsidString);

    if (hresult != S_OK)
    {
        CoTaskMemFree(pszClsidString);

        return DumpHRESULT(hresult);
    }

    hresult = ProgIDFromCLSID(clsid, &pszClsidID);

    if ((hresult != S_OK)&&(hresult != REGDB_E_CLASSNOTREG))
    {
        CoTaskMemFree(pszClsidString);
        CoTaskMemFree(pszClsidID);

        return DumpHRESULT(hresult);
    }

    pszDump = (char *)CoTaskMemAlloc(512);
    if (NULL == pszDump)
    {
        CoTaskMemFree(pszClsidString);
        CoTaskMemFree(pszClsidID);

        return UtDupStringA(szDumpErrorMessage);
    }

    if (hresult != REGDB_E_CLASSNOTREG)
    {
        _snprintf(pszDump, 512, "%ls %ls\0", pszClsidString, pszClsidID);
    }
    else
    {
        _snprintf(pszDump, 512, "%ls (CLSID not in registry)\0", pszClsidString);
    }
    pszDump[511] = '\0';

    CoTaskMemFree(pszClsidString);
    CoTaskMemFree(pszClsidID);

    return pszDump;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpDVAPECTFlags, public (_DEBUG only)
//
//  Synopsis:   returns a char array with the set flags and hex value
//
//  Effects:
//
//  Arguments:  [dwAspect]  - flags
//
//  Requires:
//
//  Returns:    character arry of string value of flags
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpDVASPECTFlags(DWORD dwAspect)
{
    char *pszDump;
    dbgstream dstrDump(100);

    if (dwAspect & DVASPECT_CONTENT)
    {
        dstrDump << "DVASPECT_CONTENT ";
    }
    if (dwAspect & DVASPECT_THUMBNAIL)
    {
        dstrDump << "DVASPECT_THUMBNAIL ";
    }
    if (dwAspect & DVASPECT_ICON)
    {
        dstrDump << "DVASPECT_ICON ";
    }
    if (dwAspect & DVASPECT_DOCPRINT)
    {
        dstrDump << "DVASPECT_DOCPRINT ";
    }
    if ( ! ((dwAspect & DVASPECT_CONTENT)   |
            (dwAspect & DVASPECT_THUMBNAIL) |
            (dwAspect & DVASPECT_ICON)      |
            (dwAspect & DVASPECT_DOCPRINT)))
    {
        dstrDump << "No FLAGS SET! ";
    }
    dstrDump << "(" << LongToPtr(dwAspect) << ")";

    pszDump = dstrDump.str();

    if (pszDump == NULL)
    {
        return UtDupStringA(szDumpErrorMessage);
    }

    return pszDump;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpFILETIME, public (_DEBUG only)
//
//  Synopsis:   Dumps a filetime structure
//
//  Effects:
//
//  Arguments:  [pFT]   - pointer to a FILETIME structure
//
//  Requires:
//
//  Returns:    character array of structure dump
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpFILETIME(FILETIME *pFT)
{
    char *pszDump;
    dbgstream dstrDump(100);

    if (pFT == NULL)
    {
        return UtDupStringA(szDumpBadPtr);;
    }

    dstrDump << "Low: "  << pFT->dwLowDateTime;
    dstrDump << "\tHigh: " << pFT->dwHighDateTime;

    pszDump = dstrDump.str();

    if (pszDump == NULL)
    {
        return UtDupStringA(szDumpErrorMessage);
    }

    return pszDump;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpHRESULT
//
//  Synopsis:   Takes an HRESULT and builds a character array with a
//              string version of the error and a hex version
//
//  Effects:
//
//  Arguments:  [hresult]   - the error which we are looking up
//
//  Requires:
//
//  Returns:    character array
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              27-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpHRESULT(HRESULT hresult)
{
    dbgstream dstrDump(100);
    char *pszDump;
    char *pszMessage = NULL;
    int  cMsgLen;

    cMsgLen = FormatMessageA(
                    FORMAT_MESSAGE_FROM_SYSTEM |
                    FORMAT_MESSAGE_ALLOCATE_BUFFER,
                    0,
                    hresult,
                    MAKELANGID(0, SUBLANG_ENGLISH_US),
                    (char *)pszMessage,
                    512,
                    0);

    if (cMsgLen == 0)   // FormatMessage failed
    {
        delete[] pszMessage;
        return UtDupStringA(szDumpErrorMessage);
    }

    dstrDump << "Error Code:  " << pszMessage;
    dstrDump << "(" << hresult << ")";

    pszDump = dstrDump.str();

    if (pszDump == NULL)
    {
        pszDump = UtDupStringA(szDumpErrorMessage);
    }

    delete[] pszMessage;

    return pszDump;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpMonikerDisplayName
//
//  Synopsis:   dumps a meaningful moniker name
//
//  Effects:
//
//  Arguments:  [pMoniker]  - pointer to IMoniker interface
//
//  Requires:
//
//  Returns:    character array of display name (ANSI)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              09-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpMonikerDisplayName(IMoniker *pMoniker)
{
    HRESULT         hresult;
    LPOLESTR        pszMoniker;
    char            *pszDump;
    LPBC            pBC;

    if (pMoniker == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    hresult = CreateBindCtx(0, &pBC);
    if (hresult != S_OK)
    {
        return DumpHRESULT(hresult);
    }

    hresult = pMoniker->GetDisplayName(pBC, NULL, &pszMoniker);

    if (hresult != S_OK)
    {
        CoTaskMemFree(pszMoniker);

        return DumpHRESULT(hresult);
    }

    pszDump = (char *)CoTaskMemAlloc(512);
    if (NULL == pszDump)
    {
        CoTaskMemFree(pszMoniker);

        return UtDupStringA(szDumpErrorMessage);
    }

    _snprintf(pszDump, 512, "%ls \0", pszMoniker);
    pszDump[511] = NULL;

    CoTaskMemFree(pszMoniker);

    return pszDump;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpWIN32Error
//
//  Synopsis:   Takes an WIN32 error and builds a character array with a
//              string version of the error and a hex version
//
//  Effects:
//
//  Arguments:  [dwError]   - the error which we are looking up
//
//  Requires:
//
//  Returns:    character array
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              27-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpWIN32Error(DWORD dwError)
{
    HRESULT hresult;

    hresult = HRESULT_FROM_WIN32(dwError);

    return DumpHRESULT(hresult);
}

#endif // _DEBUG


//+-------------------------------------------------------------------------
//
//  Function:   DumpCMapDwordDword, public (_DEBUG only)
//
//  Synopsis:   not implemented
//
//  Effects:
//
//  Arguments:  [pMDD]   - pointer to a CMapDwordDword
//
//  Requires:
//
//  Returns:    character array
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCMapDwordDword(CMapDwordDword *pMDD, ULONG ulFlag, int nIndentLevel)
{
    return UtDupStringA("   DumpCMapDwordDword is not implemented\n");
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpFORMATETC, public (_DEBUG only)
//
//  Synopsis:   returns a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [pFE]           - a pointer to a FORMATETC object
//              [ulFlag]        - a flag determining the prefix of all newlines of
//                                the out character array(default is 0 -no prefix)
//              [nIndentLevel]  - will add an indent prefix after the other prefix
//                                for all newlines(include those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              23-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpFORMATETC(FORMATETC *pFE, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    char *pszDump;
    char *pszClipFormat;
    char *pszDVASPECT;
    dbgstream dstrPrefix;
    dbgstream dstrDump;

    if (pFE == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    // determine prefix
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << pFE <<   " _VB ";
    }

    // determine indentation prefix
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    pszClipFormat = DumpCLIPFORMAT(pFE->cfFormat);
    dstrDump << pszPrefix << "CLIPFORMAT      = " << pszClipFormat  << endl;
    CoTaskMemFree(pszClipFormat);

    dstrDump << pszPrefix << "pDVTARGETDEVICE = " << pFE->ptd       << endl;

    pszDVASPECT   = DumpDVASPECTFlags(pFE->dwAspect);
    dstrDump << pszPrefix << "Aspect Flags    = " << pszDVASPECT    << endl;
    CoTaskMemFree(pszDVASPECT);

    dstrDump << pszPrefix << "Tymed Flags     = ";
    if (pFE->tymed & TYMED_HGLOBAL)
    {
        dstrDump << "TYMED_HGLOBAL ";
    }
    if (pFE->tymed & TYMED_FILE)
    {
        dstrDump << "TYMED_FILE ";
    }
    if (pFE->tymed & TYMED_ISTREAM)
    {
        dstrDump << "TYMED_ISTREAM ";
    }
    if (pFE->tymed & TYMED_ISTORAGE)
    {
        dstrDump << "TYMED_ISTORAGE ";
    }
    if (pFE->tymed & TYMED_GDI)
    {
        dstrDump << "TYMED_GDI ";
    }
    if (pFE->tymed & TYMED_MFPICT)
    {
        dstrDump << "TYMED_MFPICT ";
    }
    if (pFE->tymed & TYMED_ENHMF)
    {
        dstrDump << "TYMED_ENHMF ";
    }
    if (pFE->tymed == TYMED_NULL)
    {
        dstrDump << "TYMED_NULL ";
    }
    // if none of the flags are set there is an error
    if ( !( (pFE->tymed & TYMED_HGLOBAL )   |
            (pFE->tymed & TYMED_FILE )      |
            (pFE->tymed & TYMED_ISTREAM )   |
            (pFE->tymed & TYMED_ISTORAGE )  |
            (pFE->tymed & TYMED_GDI )       |
            (pFE->tymed & TYMED_MFPICT )    |
            (pFE->tymed & TYMED_ENHMF )     |
            (pFE->tymed == TYMED_NULL )))
    {
        dstrDump << "Error in FLAG!!!! ";
    }
    dstrDump << "(" << LongToPtr(pFE->tymed) << ")" << endl;

    // cleanup and provide pointer to character array
    pszDump = dstrDump.str();

    if (pszDump == NULL)
    {
        pszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return pszDump;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpIOlePresObj, public (_DEBUG only)
//
//  Synopsis:   calls the IOlePresObj::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pOPO]          - pointer to IOlePresObj
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              31-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpIOlePresObj(IOlePresObj *pOPO, ULONG ulFlag, int nIndentLevel)
{
    HRESULT hresult;
    char *pszDump;

    if (pOPO == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    // defers to CMfObject, CEMfObject, CGenObject
    hresult = pOPO->Dump(&pszDump, ulFlag, nIndentLevel);

    if (hresult != NOERROR)
    {
        CoTaskMemFree(pszDump);

        return DumpHRESULT(hresult);
    }

    return pszDump;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpMEMSTM, public (_DEBUG only)
//
//  Synopsis:   returns a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [pMS]           - a pointer to a MEMSTM object
//              [ulFlag]        - a flag determining the prefix of all newlines of
//                                the out character array(default is 0 -no prefix)
//              [nIndentLevel]  - will add an indent prefix after the other prefix
//                                for all newlines(include those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              23-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpMEMSTM(MEMSTM *pMS, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    char *pszDump;
    dbgstream dstrPrefix;
    dbgstream dstrDump;

    if (pMS == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    // determine prefix
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << pMS <<  " _VB ";
    }

    // determine indentation prefix
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    dstrDump << pszPrefix << "Size of Global Memory = " << pMS->cb      << endl;
    dstrDump << pszPrefix << "References            = " << pMS->cRef    << endl;
    dstrDump << pszPrefix << "hGlobal               = " << pMS->hGlobal << endl;
    dstrDump << pszPrefix << "DeleteOnRelease?      = ";
    if (pMS->fDeleteOnRelease == TRUE)
    {
        dstrDump << "TRUE" << endl;
    }
    else
    {
        dstrDump << "FALSE" << endl;
    }

    // cleanup and provide pointer to character array
    pszDump = dstrDump.str();

    if (pszDump == NULL)
    {
        pszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return pszDump;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpSTATDATA, public (_DEBUG only)
//
//  Synopsis:   returns a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [pSD]           - a pointer to a STATDATA object
//              [ulFlag]        - a flag determining the prefix of all newlines of
//                                the out character array(default is 0 -no prefix)
//              [nIndentLevel]  - will add an indent prefix after the other prefix
//                                for all newlines(include those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              23-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpSTATDATA(STATDATA *pSD, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    char *pszDump;
    char *pszFORMATETC;
    char *pszADVF;
    dbgstream dstrPrefix;
    dbgstream dstrDump(500);

    if (pSD == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    // determine prefix
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << pSD <<  " _VB ";
    }

    // determine indentation prefix
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    pszFORMATETC = DumpFORMATETC( &(pSD->formatetc), ulFlag, nIndentLevel + 1);
    dstrDump << pszPrefix << "FORMATETC:" << endl;
    dstrDump << pszFORMATETC;
    CoTaskMemFree(pszFORMATETC);

    pszADVF      = DumpADVFFlags( pSD->advf );
    dstrDump << pszPrefix << "Advise flag   = " << pszADVF << endl;
    CoTaskMemFree(pszADVF);

    dstrDump << pszPrefix << "pIAdviseSink  = " << pSD->pAdvSink << endl;

    dstrDump << pszPrefix << "Connection ID = " << pSD->dwConnection << endl;

    // cleanup and provide pointer to character array
    pszDump = dstrDump.str();

    if (pszDump == NULL)
    {
        pszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return pszDump;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpSTGMEDIUM, public (_DEBUG only)
//
//  Synopsis:   returns a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [pFE]           - a pointer to a STGMEDIUM object
//              [ulFlag]        - a flag determining the prefix of all newlines of
//                                the out character array(default is 0 -no prefix)
//              [nIndentLevel]  - will add an indent prefix after the other prefix
//                                for all newlines(include those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              23-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpSTGMEDIUM(STGMEDIUM *pSM, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    char *pszDump;
    dbgstream dstrPrefix;
    dbgstream dstrDump;

    if (pSM == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    // determine prefix
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << pSM <<   " _VB ";
    }

    // determine indentation prefix
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    dstrDump << pszPrefix << "Tymed Flags     = ";
    if (pSM->tymed & TYMED_HGLOBAL)
    {
        dstrDump << "TYMED_HGLOBAL ";
    }
    if (pSM->tymed & TYMED_FILE)
    {
        dstrDump << "TYMED_FILE ";
    }
    if (pSM->tymed & TYMED_ISTREAM)
    {
        dstrDump << "TYMED_ISTREAM ";
    }
    if (pSM->tymed & TYMED_ISTORAGE)
    {
        dstrDump << "TYMED_ISTORAGE ";
    }
    if (pSM->tymed & TYMED_GDI)
    {
        dstrDump << "TYMED_GDI ";
    }
    if (pSM->tymed & TYMED_MFPICT)
    {
        dstrDump << "TYMED_MFPICT ";
    }
    if (pSM->tymed & TYMED_ENHMF)
    {
        dstrDump << "TYMED_ENHMF ";
    }
    if (pSM->tymed == TYMED_NULL)
    {
        dstrDump << "TYMED_NULL ";
    }
    // if none of the flags are set there is an error
    if ( !( (pSM->tymed & TYMED_HGLOBAL )   |
            (pSM->tymed & TYMED_FILE )      |
            (pSM->tymed & TYMED_ISTREAM )   |
            (pSM->tymed & TYMED_ISTORAGE )  |
            (pSM->tymed & TYMED_GDI )       |
            (pSM->tymed & TYMED_MFPICT )    |
            (pSM->tymed & TYMED_ENHMF )     |
            (pSM->tymed == TYMED_NULL )))
    {
        dstrDump << "Error in FLAG!!!! ";
    }
    dstrDump << "(" << LongToPtr(pSM->tymed) << ")" << endl;

    dstrDump << pszPrefix << "Union (handle or pointer) = " << pSM->hBitmap       << endl;

    dstrDump << pszPrefix << "pIUnknown for Release     = " << pSM->pUnkForRelease  << endl;

    // cleanup and provide pointer to character array
    pszDump = dstrDump.str();

    if (pszDump == NULL)
    {
        pszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return pszDump;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\debug\cdebug.cpp ===
//+----------------------------------------------------------------------------
//
//	File:
//		cdebug.cpp
//
//	Contents:
//		Ole2 internal debugging support; implementation of debugstream
//		and IDebug for interface/class
//
//	Classes:
//
//	Functions:
//
//	History:
//		24-Jan-94 alexgo    first pass at converting to Cairo-style
//				    memory allocation
//		12/31/93 - ChrisWe - defined DbgWarn for use by reterr.h
//		12/31/93 - ChrisWe - make compile with _DEBUG defined
//              03-Jan-95  BruceMa  Use olewcstombs, etc.
//
//-----------------------------------------------------------------------------

#include <le2int.h>


#pragma SEG(cdebug)

#pragma SEG(cdebug)

#include <string.h>

//
//  Redefine UNICODE functions to ANSI for Chicago support.
//
#if !defined(UNICODE)
#define swprintf wsprintfA
#undef  _xstrcpy
#undef  _xstrlen
#define _xstrcpy strcpy
#define _xstrlen strlen
#endif

#ifdef _DEBUG
FARINTERNAL_(void) DbgWarn(LPSTR psz, LPSTR pszFileName, ULONG uLineno)
{
	static const char msg[] = "Unexpected result: ";
	const char *pszmsg;
	TCHAR buf[250];

	// pick a message
	pszmsg = psz ? psz : msg;

	// write this out to the debugger
	MultiByteToWideChar(CP_ACP, 
                        0, 
                        pszmsg, 
                        (int) strlen(pszmsg)+1,
                        buf, 
                        (sizeof(buf) / sizeof(buf[0])));
	OutputDebugString(buf);
	MultiByteToWideChar(CP_ACP, 
                        0, 
                        pszFileName, 
                        (int) strlen(pszFileName)+1,
                        buf, 
                        (sizeof(buf) / sizeof(buf[0])));
	OutputDebugString(buf);
    
    _snwprintf(buf, (sizeof(buf) / sizeof(buf[0])), L", line %lu\n", uLineno);
    buf[(sizeof(buf) / sizeof(buf[0])) - 1] = L'\0';

	OutputDebugString(buf);
}
#endif // _DEBUG


//some constants used only in this file
#define DBGMARGIN	45
#define DBGTABSIZE	4
#define HEADER		1
#define NOHEADER	0

ASSERTDATA

#define DBGLOGFILENAME	TEXT("debug.log")
static void GetCurDateTime(LPTSTR lpsz, DWORD cch);


#pragma SEG(DbgLogOpen)
STDAPI_(HFILE) DbgLogOpen(LPCTSTR lpszFile, LPCTSTR lpszMode)
{
#ifdef _DEBUG    
	HFILE fh = NULL;
	LPSTR lpsz;
	char buf[2 * MAX_PATH];

	AssertSz( lpszFile && lpszMode, "Invalid arguments to DbgLogOpen");
	
	switch (lpszMode[0]) {
        case TEXT('w'):
            WideCharToMultiByte (CP_ACP, 
                                 WC_COMPOSITECHECK, 
                                 lpszFile, 
                                 -1, 
                                 buf, 
                                 MAX_PATH, 
                                 NULL, 
                                 NULL);
            lpsz = buf;

            // Open for writing (overwrite if exists)
            fh = _lcreat(lpsz, 0);
            break;

        case TEXT('r'):
            // Open for reading
            WideCharToMultiByte (CP_ACP, 
                                 WC_COMPOSITECHECK, 
                                 lpszFile, 
                                 -1, 
                                 buf, 
                                 MAX_PATH, 
                                 NULL, 
                                 NULL);
            lpsz = buf;

            fh = _lopen(lpsz, OF_READ);
            break;

        case TEXT('a'):
            WideCharToMultiByte (CP_ACP, 
                                 WC_COMPOSITECHECK, 
                                 lpszFile, 
                                 -1, 
                                 buf, 
                                 MAX_PATH, 
                                 NULL, 
                                 NULL);
            lpsz = buf;

            // Open for appending
            // to append to log file seek to end before writing
            if ((fh = _lopen(lpsz, OF_READWRITE)) != -1) {
                _llseek(fh, 0L, FILE_END);
            } else {
                // file does not exist, create a new one.
                fh = _lcreat(lpsz, 0);
            }
            break;
	}
	return fh;
#else
 	(void) lpszFile;
	(void) lpszMode;
	return -1;
#endif	//_DEBUG
}


#pragma SEG(DbgLogClose)
STDAPI_(void) DbgLogClose(HFILE fh)
{
#ifdef _DEBUG
	if (fh != -1)
		_lclose(fh);
#else
	(void) fh;
#endif
}


#pragma SEG(DbgLogWrite)
STDAPI_(void) DbgLogWrite(HFILE fh, LPCTSTR lpszStr)
{
#ifdef _DEBUG
	LPSTR lpsz;
	char buf[2 * MAX_PATH];
	if (fh != -1 && lpszStr)
	{
            WideCharToMultiByte (CP_ACP, 
                                 WC_COMPOSITECHECK, 
                                 lpszStr, 
                                 -1, 
                                 buf, 
                                 MAX_PATH, 
                                 NULL, 
                                 NULL);
            lpsz = buf;

            _lwrite(fh, lpsz, (UINT) strlen(lpsz)); // NOTE NOT UNICODE
	}
#else
	(void) fh;
	(void) lpszStr;
#endif
}


#pragma SEG(DbgLogTimeStamp)
STDAPI_(void) DbgLogTimeStamp(HFILE fh, LPCTSTR lpsz)
{
#ifdef _DEBUG
	TCHAR buffer[80];

	GetCurDateTime(buffer, sizeof(buffer) / sizeof(buffer[0]));
	
	DbgLogOutputDebugString(fh, TEXT("\n***************************************\n"));
	if (lpsz) DbgLogOutputDebugString(fh, lpsz);
	DbgLogOutputDebugString(fh, TEXT(": "));
	DbgLogOutputDebugString(fh, buffer);
	DbgLogOutputDebugString(fh, TEXT("\n"));
	DbgLogOutputDebugString(fh, TEXT(".......................................\n\n"));
#else
	(void) fh;
	(void) lpsz;
#endif
}


#pragma SEG(DbgLogWriteBanner)
STDAPI_(void) DbgLogWriteBanner(HFILE fh, LPCTSTR lpsz)
{
#ifdef _DEBUG
	DbgLogOutputDebugString(fh, TEXT("\n***************************************\n"));
	if (lpsz) DbgLogOutputDebugString(fh, lpsz);
	DbgLogOutputDebugString(fh, TEXT("\n"));
	DbgLogOutputDebugString(fh, TEXT(".......................................\n\n"));
#else
	(void) fh;
	(void) lpsz;
#endif
}


#pragma SEG(DbgLogOutputDebugString)
STDAPI_(void) DbgLogOutputDebugString(HFILE fh, LPCTSTR lpsz)
{
#ifdef _DEBUG
#ifndef _MAC
	if (fh != -1)
		DbgLogWrite(fh, lpsz);
	OutputDebugString(lpsz);
#endif
#else
	(void)fh;
	(void)lpsz;
#endif
}


#ifdef _DEBUG

#pragma SEG(GetCurDateTime)
static void GetCurDateTime(LPTSTR lpsz, DWORD cch)
{
	unsigned year, month, day, dayOfweek, hours, min, sec;
	static const TCHAR FAR* const dayNames[7] =
		{ TEXT("Sun"), TEXT("Mon"), TEXT("Tue"), TEXT("Wed"),
			TEXT("Thu"), TEXT("Fri"), TEXT("Sat") };
	static const TCHAR FAR* const monthNames[12] =
        { TEXT("Jan"), TEXT("Feb"), TEXT("Mar"), TEXT("Apr"), TEXT("May"),
		TEXT("Jun"), TEXT("Jul"), TEXT("Aug"),
		TEXT("Sep"), TEXT("Oct"), TEXT("Nov"), TEXT("Dec") };

    SYSTEMTIME st;
    GetLocalTime(&st);
    year = st.wYear;
    month = st.wMonth - 1;
    dayOfweek = st.wDayOfWeek;
    day = st.wDay;
    hours = st.wHour;
    min = st.wMinute;
    sec = st.wSecond;

	// Format time as: Wed Jan 02 02:03:55 1990
	// Format time as: Wed 05/02/1992 02:03:55
    _snwprintf(lpsz, 
               cch,
               TEXT("%s %s %02d %02d:%02d:%02d %d"),
               dayNames[dayOfweek],
               monthNames[month], 
               day, 
               hours, 
               min, 
               sec, 
               year);
    lpsz[cch-1] = TEXT('\0');
}


class FAR CDebugLog
{
private:
	HFILE m_fhLog;

public:
	CDebugLog( ) { m_fhLog = -1; }
	CDebugLog( LPCTSTR lpszFileName );
	~CDebugLog() { DbgLogClose(m_fhLog); }
	HFILE Open(LPCTSTR lpszFileName, LPCTSTR lpszMode)
		{ return (m_fhLog = DbgLogOpen(lpszFileName, lpszMode)); }
	void Close(void) { DbgLogClose(m_fhLog); m_fhLog = -1; }
	void OutputDebugString(LPCTSTR lpsz) { DbgLogOutputDebugString(m_fhLog, lpsz); }
	void TimeStamp(LPCTSTR lpsz) { DbgLogTimeStamp(m_fhLog, lpsz); }
	void WriteBanner(LPCTSTR lpsz) { DbgLogWriteBanner(m_fhLog, lpsz); }

};


//-------------------------------------------------------------------------
// Thought for the decade:
// All these methods and all these functions and crud, for what?
// So we can avoid calling the shared, system-provided, *printf?
// Was it worth it?  Is Barney a genius?  He sure knows how to lead
// everyone down the garden path...
//-------------------------------------------------------------------------

class FAR CDebugStream : public CPrivAlloc
{

public:
	STDSTATIC_(IDebugStream FAR *) Create( // no aggregation
		int margin, int tabsize, BOOL fHeader);

private:
	CDebugStream( int margin, int tabsize, BOOL fHeader );
	~CDebugStream();
	void OutputDebugString( LPCTSTR lpsz ) {m_DbgLog.OutputDebugString(lpsz);}


implementations:
	implement CDSImpl :  IDebugStream
	{

	public:
		CDSImpl( CDebugStream FAR * pDebugStream )
			{ m_pDebugStream = pDebugStream; }
		~CDSImpl( void ) ; //{ if (m_pDebugStream->m_pendingReturn) ForceReturn(); }
		void PrintString( LPTSTR );
		void ForceReturn( void );
		void ReturnIfPending( void );
		STDMETHOD(QueryInterface)(REFIID iid, LPVOID FAR* ppvObj );
		STDMETHOD_(ULONG,AddRef)( void );
		STDMETHOD_(ULONG,Release)( void );

		STDMETHOD_(IDebugStream&, operator << ) ( IUnknown FAR * pDebug );
		STDMETHOD_(IDebugStream&, operator << ) ( REFCLSID rclsid );
		STDMETHOD_(IDebugStream&, operator << ) ( int n );
		STDMETHOD_(IDebugStream&, operator << ) ( long l );
		STDMETHOD_(IDebugStream&, operator << ) ( ULONG l );
		STDMETHOD_(IDebugStream&, operator << ) ( LPCTSTR sz );
		STDMETHOD_(IDebugStream&, operator << ) ( TCHAR ch );
		STDMETHOD_(IDebugStream&, operator << ) ( void FAR * pv );
		STDMETHOD_(IDebugStream&, operator << ) ( CBool b );
		STDMETHOD_(IDebugStream&, operator << ) ( CAtom atom );
		STDMETHOD_(IDebugStream&, operator << ) ( CHwnd hwnd );
		STDMETHOD_(IDebugStream&, Tab) ( void );
		STDMETHOD_(IDebugStream&, Indent) ( void );
		STDMETHOD_(IDebugStream&, UnIndent) ( void );
		STDMETHOD_(IDebugStream&, Return) ( void );
		STDMETHOD_(IDebugStream&, LF) ( void );
		CDebugStream FAR * m_pDebugStream;
	};
	DECLARE_NC(CDebugStream,CDSImpl)

	CDSImpl m_DebugStream;

shared_state:
	ULONG m_refs;
	int m_indent;
	int m_position;
	int m_margin;
	int m_tabsize;
	BOOL m_pendingReturn;
	CDebugLog m_DbgLog;
};

#endif // _DEBUG



/*
 *	The member variable m_pendingReturn is a hack to allow
 *	the sequence of operations Return, UnIndent put the character
 *	at the *beginning of the unindented line*  The debugwindow does
 *	not seem to support going to the beginning of the line or
 *	backspacing, so we do not actually do a Return until we know
 *	that the next operation is not UnIndent.
 *	
 */



/*
 *	Implementation of per process list heads
 */


//REVIEW:  maybe we should expose this later
STDAPI OleGetClassID( LPUNKNOWN pUnk, LPCLSID lpclsid )
{
	LPRUNNABLEOBJECT lpRunnableObject = NULL;
	LPPERSIST lpPersist = NULL;
	HRESULT hresult = NOERROR;
	
	VDATEIFACE(pUnk);
	VDATEPTROUT(lpclsid, LPCLSID);

	*lpclsid = CLSID_NULL;
				
	pUnk->QueryInterface(IID_IRunnableObject, (LPLPVOID)&lpRunnableObject);
	if( lpRunnableObject ){
		hresult = lpRunnableObject->GetRunningClass(lpclsid);
		lpRunnableObject->Release();
	} else {	
		pUnk->QueryInterface(IID_IPersist, (LPLPVOID)&lpPersist);
		if( lpPersist ){
			hresult = lpPersist->GetClassID( lpclsid );
			lpPersist->Release();
		}
	}
	return hresult;
}

#ifdef _DEBUG

CDebugStream::CDebugStream( int margin, int tabsize, BOOL fHeader) : m_DebugStream(this)
{
	static BOOL fAppendFile = FALSE;
	
	// Create the debug log file. Overwrite the existing file if it exists.
	m_DbgLog.Open(DBGLOGFILENAME, (fAppendFile ? TEXT("a") : TEXT("w")));

	if( fHeader )	
		// only add creation timestamp to top of file.
		if (! fAppendFile) {
			m_DbgLog.TimeStamp(TEXT("Created"));
			fAppendFile = TRUE;
		} else {
			m_DbgLog.WriteBanner(NULL);
		}

	m_indent = 0;
	m_position = m_indent;
	m_margin = margin;
	m_tabsize = tabsize;
	m_refs = 1;
	m_pendingReturn = FALSE;
}


CDebugStream::~CDebugStream()
{
	m_DbgLog.Close();
}


NC(CDebugStream,CDSImpl)::~CDSImpl(void)
{
	 if (m_pDebugStream->m_pendingReturn) ForceReturn();
}


STDMETHODIMP NC(CDebugStream,CDSImpl)::QueryInterface(REFIID iidInterface,
	void FAR* FAR* ppvObj )
{
	VDATEPTROUT(ppvObj, LPLPVOID);

	if (IsEqualGUID(iidInterface, IID_IUnknown) ||
            IsEqualGUID(iidInterface, IID_IDebugStream))
        {
		*ppvObj = (void FAR *)this;
		return NOERROR;
	} else
        {
		*ppvObj = NULL;
		return ReportResult(0, E_NOINTERFACE, 0, 0);
	}
}


STDMETHODIMP_(ULONG) NC(CDebugStream,CDSImpl)::AddRef( void )
{
	return ++m_pDebugStream->m_refs;
}


STDMETHODIMP_(ULONG) NC(CDebugStream,CDSImpl)::Release( void )
{
	if (--m_pDebugStream->m_refs == 0) {
		delete m_pDebugStream;
		return 0;
	}

	return m_pDebugStream->m_refs;
}


STDMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << (int n)
{
	TCHAR buffer[12] = {0};
	ReturnIfPending();

    _snwprintf(buffer, sizeof(buffer) / sizeof(buffer[0]), TEXT("%d"), n);
    buffer[(sizeof(buffer) / sizeof(buffer[0])) - 1] = TEXT('\0');

	PrintString(buffer);
	return *this;
}

STDMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << (long l)
{
	TCHAR buffer[16];
	ReturnIfPending();

    _snwprintf(buffer, sizeof(buffer) / sizeof(buffer[0]), TEXT("%ld"), l);
    buffer[(sizeof(buffer) / sizeof(buffer[0])) - 1] = TEXT('\0');

	PrintString(buffer);
	return *this;
}

STDMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << (ULONG l)
{
	TCHAR buffer[16];
	ReturnIfPending();

    _snwprintf(buffer, sizeof(buffer) / sizeof(buffer[0]), TEXT("%lu"), l);
    buffer[(sizeof(buffer) / sizeof(buffer[0])) - 1] = TEXT('\0');

    PrintString(buffer);
	return *this;
}

STDMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << (CAtom atom)
{
	TCHAR buffer[128];
	ReturnIfPending();
	
	if( (ATOM)atom )
    {
		if( !GetAtomName((ATOM)atom, buffer, (sizeof(buffer) / sizeof(buffer[0]))) )
			buffer[swprintf(buffer, TEXT("Invalid atom"))] = TEXT('\0');
	}
    else
    {
		buffer[swprintf(buffer, TEXT("NULL atom"))] = TEXT('\0');
    }
		
	PrintString(buffer);
	return *this;
}

STDMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << (CHwnd hwnd)
{
	TCHAR szBuf[128];
	
	ReturnIfPending();

	if( (HWND)hwnd )
    {
        _snwprintf(szBuf, sizeof(szBuf) / sizeof(szBuf[0]), TEXT("window handle: %x"), (HWND)hwnd);
        szBuf[(sizeof(szBuf) / sizeof(szBuf[0])) - 1] = TEXT('\0');
    }
	else
		szBuf[swprintf(szBuf, TEXT("NULL window handle"))] = TEXT('\0');

	PrintString(szBuf);		
	return *this;
}

LPTSTR FindBreak( LPTSTR sz, int currentPosition, int margin )
{
	LPTSTR szBreak = sz;
	LPTSTR szPtr = sz;

	if( !sz )
		return NULL;
	
	while (*szPtr)
	{
		while (*(szPtr) && *(szPtr++) <= TEXT(' '));
		while (*(szPtr) && *(szPtr++) > TEXT(' '));
		if (currentPosition+(szPtr-sz) < margin)
		{
			szBreak = szPtr;
		}
		else return szBreak;
	}
	return szPtr;
}

/*
 *	PrintString is an internal utility routine that can assume that
 *	everything in the string (other than the null at the end) is >=
 *	' '.  Thus it knows that when it prints a single character, the
 *	position on the debug terminal advances a single columm.  This
 *	would not be the case if the string could contain tabs,
 *	returns, etc.
 */

void NC(CDebugStream,CDSImpl)::PrintString(LPTSTR sz)
{
	//	assert sz != NULL
	LPTSTR szUnprinted = sz;
	LPTSTR szPtr = sz;
	TCHAR chSave;

	#ifdef _MAC
	Puts(sz);
	return;
	#endif
	
	if( !sz )
		return;
	
	while (*szUnprinted)
	{
		szPtr = FindBreak( szUnprinted, m_pDebugStream->m_position, m_pDebugStream->m_margin );
		if (szPtr == szUnprinted && m_pDebugStream->m_position > m_pDebugStream->m_indent)
		{
			Return();
			szPtr = FindBreak( szUnprinted, m_pDebugStream->m_position, m_pDebugStream->m_margin );
			if (szPtr == szUnprinted)	//	text won't fit even after word wrapping
			{
				m_pDebugStream->OutputDebugString(szUnprinted);
				m_pDebugStream->m_position += _xstrlen(szUnprinted);
				return;
			}
		}
		chSave = *szPtr;
		*szPtr = TEXT('\0');
		if (m_pDebugStream->m_position == m_pDebugStream->m_indent)		//	no text on line, skip blanks
		{
			while (*szUnprinted == TEXT(' ')) szUnprinted++;
		}
		m_pDebugStream->OutputDebugString(szUnprinted);
		*szPtr = chSave;
		m_pDebugStream->m_position += (ULONG) (szPtr - szUnprinted);
		szUnprinted = szPtr;
	}
}


STDMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << (TCHAR ch)
{
	TCHAR buffer[2] = TEXT("a");

	if (ch==TEXT('\n')) Return();
	else if (ch==TEXT('\t')) Tab();
	else if (ch >= TEXT(' '))
	{
		ReturnIfPending();
		if (m_pDebugStream->m_position >= m_pDebugStream->m_margin) Return();
		*buffer = ch;
		m_pDebugStream->OutputDebugString(buffer);
		m_pDebugStream->m_position++;
	}
	return *this;
}


STDMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << (LPCTSTR sz)
{
	LPTSTR szCopy;
	TCHAR chSave;
	LPTSTR szPtr;
	LPTSTR szPtrSave;

	ReturnIfPending();
	
	if (!sz)
		return *this;

	szCopy = (LPTSTR)PubMemAlloc(sizeof(TCHAR)*(2+_xstrlen(sz)));
	if (!szCopy)
	{
		Return();
		*this << TEXT("Memory allocation error in DebugStream");
		Return();
		return *this;
	}
	
	_xstrcpy( szCopy, sz );	
	for (szPtr = szCopy, szPtrSave = szCopy; *szPtr; szPtr++)
	{
		if ( *szPtr < TEXT(' '))// we hit a control character or the end
		{
			chSave = *szPtr;
			*szPtr = TEXT('\0');
			PrintString( szPtrSave );
			if (chSave != TEXT('\0'))
				*szPtr = chSave;
			szPtrSave = szPtr+1;
			switch (chSave)
			{
				case TEXT('\t'):  Tab();
							break;
				case TEXT('\n'):	Return();
							break;
				case TEXT('\r'):	m_pDebugStream->OutputDebugString(TEXT("\r"));
							break;
				default:
							break;
			}
		}
	}
	PrintString( szPtrSave );

	PubMemFree(szCopy);

	return *this;
}

STDMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << (CBool b)
{
	ReturnIfPending();
	if (b) *this << TEXT("TRUE");
	else *this << TEXT("FALSE");
	return *this;
}


STDMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << ( void FAR * pv )
{
	TCHAR buffer[12];

	ReturnIfPending();
	if (pv == NULL)
		*this << TEXT("NULL");
	else
	{
        _snwprintf(buffer, sizeof(buffer) / sizeof(buffer[0]), TEXT("%lX"), pv);
        buffer[(sizeof(buffer) / sizeof(buffer[0])) - 1] = TEXT('\0');

		PrintString(buffer);
	}

	return *this;
}


STDMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator <<
	( REFCLSID rclsid )
{
	TCHAR sz[256];
	
 	if (IsEqualGUID(rclsid, CLSID_NULL))
 		_xstrcpy(sz, TEXT("NULL CLSID"));
	else if (StringFromCLSID2(rclsid, sz, sizeof(sz)) == 0)
		_xstrcpy(sz, TEXT("Unknown CLSID"));

	*this << sz;

	return *this;
}


STDMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator <<
	( IUnknown FAR * pUnk )
{
	IDebug FAR * pDebug = NULL;
	CLSID	clsid = CLSID_NULL;

	ReturnIfPending();
	
	if (!pUnk) {
		*this << TEXT("NULL interface");
    } else if( IsValidInterface(pUnk) ) {
		pUnk->QueryInterface(IID_IDebug, (void FAR* FAR*)&pDebug);
		if (pDebug) {
			pDebug->Dump( this );
			if ( !pDebug->IsValid( 0 ) )
				*this << TEXT("Object is not valid") << TEXT('\n');
			/*
			 * NB: Debug interfaces are *not* ref counted (so as not to skew the
			 * counts of the objects they are debugging! :)
			 */
		} else {
		 	OleGetClassID(pUnk, (LPCLSID)&clsid);
			*this << clsid << TEXT(" @ ")<<(VOID FAR *)pUnk << TEXT(" doesn't support debug dumping");
        }
	} else {
		*this << TEXT("Invalid interface @ ") << (VOID FAR *)pUnk;
    }
		
	return *this;
}

STDMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::Tab( void )
{
	ReturnIfPending();
	int advance = m_pDebugStream->m_tabsize * ( 1 + m_pDebugStream->m_position/m_pDebugStream->m_tabsize) - m_pDebugStream->m_position;

	if (m_pDebugStream->m_position + advance < m_pDebugStream->m_margin)
	{
		for (int i = 0; i < advance; i++)
			m_pDebugStream->OutputDebugString(TEXT(" "));
		m_pDebugStream->m_position += advance;
	}
	return *this;
}

STDMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::Indent( void )
{
	if (m_pDebugStream->m_indent + m_pDebugStream->m_tabsize < m_pDebugStream->m_margin)
		m_pDebugStream->m_indent += m_pDebugStream->m_tabsize;
	if (!m_pDebugStream->m_pendingReturn)
		while (m_pDebugStream->m_position < m_pDebugStream->m_indent)
			operator<<(TEXT(' '));
		
	return *this;
}

STDMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::UnIndent( void )
{
	if (m_pDebugStream->m_indent > 0) m_pDebugStream->m_indent -= m_pDebugStream->m_tabsize;
	return *this;
}


void NC(CDebugStream,CDSImpl)::ForceReturn( void )
{
	m_pDebugStream->OutputDebugString(TEXT("\n"));
	for (int i = 0; i<m_pDebugStream->m_indent; i++)
		m_pDebugStream->OutputDebugString(TEXT(" "));
	m_pDebugStream->m_position = m_pDebugStream->m_indent;
	m_pDebugStream->m_pendingReturn = FALSE;
}

void NC(CDebugStream,CDSImpl)::ReturnIfPending( void )
{
	if (m_pDebugStream->m_pendingReturn) ForceReturn();
}



STDMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::Return( void )
{
	ReturnIfPending();
	m_pDebugStream->m_pendingReturn = TRUE;
    Yield();           // let dbwin get control
	return *this;
}

STDMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::LF( void )
{
	return Return();
}

STDSTATICIMP_(IDebugStream FAR *) CDebugStream::Create( // no aggregation
		int margin, int tabsize, BOOL fHeader )
{
	CDebugStream FAR * pcds = new CDebugStream( margin, tabsize, fHeader );
	if( !pcds ){
		AssertSz( pcds, "Out of Memory");
		return NULL;
	}
	return &(pcds->m_DebugStream);
}
#endif // _DEBUG


STDAPI_(IDebugStream FAR *) MakeDebugStream( short margin, short tabsize, BOOL fHeader)
{
#ifdef _DEBUG
	return CDebugStream::Create( margin, tabsize, fHeader );
#else
	(void) margin;
	(void) tabsize;
	(void) fHeader;
	return NULL;
#endif // _DEBUG
}



//
// IDebug helpers
//

STDAPI_(void) DbgDumpObject( IUnknown FAR * pUnk, DWORD dwReserved )
{
#ifdef _DEBUG
	IDebugStream FAR * pcds = MakeDebugStream( DBGMARGIN, DBGTABSIZE, NOHEADER );
 	(void)dwReserved;
 	
	if( pcds ) {	
		*pcds << pUnk;
		pcds->Return();
		pcds->Release();
	}
#else
	(void) pUnk;
	(void) dwReserved;
#endif	
}

STDAPI_(void) DbgDumpExternalObject( IUnknown FAR * pUnk, DWORD dwReserved )
{
//REVIEW32:  Compobj does not support RemLookupSHUnk yet (alexgo 11/8/93)

#ifdef WIN32
	(void)dwReserved;
	(void)pUnk;
	
#elif _DEBUG
	SHREG shreg;
	
	(void) dwReserved;

	if( IsValidInterface(pUnk) ){
		if( RemLookupSHUnk(pUnk, NULL, &shreg) == NOERROR ){
			DbgDumpObject(shreg.m_pSM, 0);
			shreg.m_pSM->Release();
		}
	}

#else
	(void) dwReserved;
	(void) pUnk;
#endif
}

STDAPI_(BOOL) DbgIsObjectValid( IUnknown FAR * pUnk )
{
#ifdef _DEBUG
	BOOL	fReturn = TRUE;	//	default value for objects that don't
							//	support IDebug
	IDebug FAR * pDebug = NULL;
	
	if( IsValidInterface(pUnk) ){
		pUnk->QueryInterface( IID_IDebug, (void FAR* FAR*)&pDebug);
		if (pDebug)
			fReturn = pDebug->IsValid();
		//IDebug is not addref'd
		return fReturn;
	}
	return FALSE;
#else
	(void) pUnk;
	return TRUE;
#endif
}


STDAPI_(void) DbgDumpClassName( IUnknown FAR * pUnk )
{
#ifdef _DEBUG
	CLSID clsid;

	IDebugStream FAR * pcds = MakeDebugStream( DBGMARGIN, DBGTABSIZE, NOHEADER );
	
	if( pcds ) {
        if( IsValidInterface(pUnk) ){
 			OleGetClassID( pUnk, (LPCLSID)&clsid);
			*pcds << clsid << TEXT(" @ ") << (void FAR* )pUnk << TEXT('\n');
		}else if (!pUnk)
			*pcds << TEXT("NULL interface") << TEXT('\n');
		else
			*pcds << (void FAR *)pUnk << TEXT(" is not a valid interface") << TEXT('\n');
		pcds->Release();
	}
#else
	(void)pUnk;
#endif
}

STDAPI_(void) DumpAllObjects( void )
{
//#ifdef _DEBUG
#ifdef NEVER
	IDebug FAR * pID = GetIDHead();
	IDebugStream FAR * pcds = MakeDebugStream( DBGMARGIN, DBGTABSIZE, NOHEADER );

	*pcds << TEXT("----TASK OBJECTS-------\n");
	while (pID)
	{
		pID->Dump( pcds );
		pID = pID->pIDNext;
	}
	*pcds << TEXT("----SHARED OBJECTS-------\n");
	pID = pIDHeadShared;
	while (pID)
	{
		pID->Dump( pcds );
		pID = pID->pIDNext;
	}

	pcds->Release();
#endif
}


STDAPI_(BOOL) ValidateAllObjects( BOOL fSuspicious )
{
//#ifdef _DEBUG
#ifdef NEVER
	IDebug FAR * pID = GetIDHead();
	int pass = 0;
	IDebugStream FAR * pcds = MakeDebugStream( DBGMARGIN, DBGTABSIZE, NOHEADER);
	BOOL fReturn = TRUE;

	while (pID)
	{
		if (!(pID->IsValid(fSuspicious)))
		{
			fReturn = FALSE;
			if (pass == 0)
				*pcds <<
					TEXT("\n****INVALID OBJECT*****\n");
			else
				*pcds << TEXT("\n****INVALID SHARED MEMORY OBJECT*****\n");
			pID->Dump( pcds );
			pcds->Return();
		}
		pID = pID->pIDNext;
		if ((pID == NULL) && (pass++ == 0))
			pID = pIDHeadShared;
	}
	pcds->Release();
	return fReturn;
#endif 	//NEVER
	(void) fSuspicious;
    return TRUE;
}


#ifdef _DEBUG


extern "C"
BOOL CALLBACK __loadds DebCallBack(WORD wID, DWORD dwData)
{
//    TCHAR rgchBuf[50];
////    BOOL    fTraceStack = FALSE;
////    STACKTRACEENTRY ste;
////    WORD wSS, wCS, wIP, wBP;
//    NFYLOADSEG FAR* pNFY = (NFYLOADSEG FAR *)dwData;
//
//    if (wID == NFY_LOADSEG)
//    {
//        if (0 == _xstrcmp(pNFY->lpstrModuleName, TEXT("OLE2")))
//        {
//            swprintf(rgchBuf, TEXT("Load seg %02x(%#04x), module %s"), pNFY->wSegNum,
//                pNFY->wSelector, pNFY->lpstrModuleName);
//            OutputDebugString(rgchBuf);
//            _asm int 3
////            if (fTraceStack)
////            {
////                _asm mov wSS, SS
////                _asm mov wCS, CS
////                _asm mov wIP, IP
////                _asm mov wBP, BP
////                ste.dwSize = sizeof(STACKTRACEENTRY);
////                if (StackTraceCSIPFirst(&ste, wSS, wCS, wIP, wBP))
////                {
////                    while (fTraceStack && StackTraceNext(&ste));
////                }
////
////            }
//        }
//    }
//    else if (wID == NFY_FREESEG)
//    {
//    }
	(void) wID;
	(void) dwData;
    return FALSE;
}

BOOL InstallHooks(void)
{
//    return NotifyRegister(NULL, (LPFNNOTIFYCALLBACK)DebCallBack, NF_NORMAL);
return TRUE;
}

BOOL UnInstallHooks()
{
//    return NotifyUnRegister(NULL);
return TRUE;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\debug\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   debug
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\..\common\$(DEST_TREE);..\..\..\ih;..\..\inc

SOURCES=      \
              ..\cdebug.cpp   \
              ..\debapi.cxx   \
              ..\dstream.cpp  \
              ..\dbgdump.cpp

UMTYPE=       windows
USE_IOSTREAM=1
!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\drag\dmsgfltr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	dmsgfltr.cpp
//
//  Contents:	This tiny message filter implementation exists to prevent
//		the eating of mouse messages by applications during drag and
//		drop. The default behavior of the call control is to eat these
//		messages. And application can specify whatever behavior they
//		want with messages.
//
//  Classes:	CDragMessageFilter
//
//  History:    dd-mmm-yy Author    Comment
//		03-Apr-94 Ricksa    Created
//
//--------------------------------------------------------------------------
#ifndef _DMSGFLTR_H_
#define _DMSGFLTR_H_




//+-------------------------------------------------------------------------
//
//  Class:	CDragMessageFilter
//
//  Purpose:	Handles special message filter processing req'd by Drag
//		and Drop.
//
//  Interface:	QueryInterface - get new interface
//		AddRef - bump reference count
//		Release - dec reference count
//		HandleInComingCall - handle new RPC
//		RetryRejectedCall - whether to retry rejected
//		MessagePending - handle message during RPC
//
//  History:	dd-mmm-yy Author    Comment
//		03-Apr-94 Ricksa    Created
//
//--------------------------------------------------------------------------
class CDragMessageFilter : public CPrivAlloc, public IMessageFilter
{
public:

			CDragMessageFilter(void);

			~CDragMessageFilter(void);

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);

    ULONG STDMETHODCALLTYPE AddRef(void);

    ULONG STDMETHODCALLTYPE Release(void);

    DWORD STDMETHODCALLTYPE HandleInComingCall(
	DWORD dwCallType,
	HTASK htaskCaller,
	DWORD dwTickCount,
	LPINTERFACEINFO lpInterfaceInfo);
    
    DWORD STDMETHODCALLTYPE RetryRejectedCall(
	HTASK htaskCallee,
	DWORD dwTickCount,
	DWORD dwRejectType);
    
    DWORD STDMETHODCALLTYPE MessagePending(
	HTASK htaskCallee,
	DWORD dwTickCount,
	DWORD dwPendingType);

    static HRESULT	Create(IMessageFilter **pMF);

private:

			// Previous message filter
    LPMESSAGEFILTER	_lpMessageFilterPrev;

			// Reference count on our object
    LONG		_crefs;
};




#endif // _DMSGFLTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\drag\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   drag
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..;..\..\..\common\$(DEST_TREE);..\..\..\ih;..\..\inc

SOURCES=      \
              ..\ido.cpp \
              ..\drag.cpp

UMTYPE=       windows

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\drag\drag.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	drag.cpp
//
//  Contents:	Api's for doing drag'n'drop
//
//  Classes:	CPoint
//		        CDragOperation
//              CDropTarget
//
//  History:	dd-mmm-yy Author    Comment
//		08-Nov-94 alexgo    converted to PrivDragDrop rpc
//				    for Drag Drop protocol
//		20-Oct-94 alexgo    added Win3.1 style drag drop
//				    for Chicago/NT shell
//              30-Sep-94 ricksa    Drag/Drop optimization.
//              18-Jul-94 ricksa    made cursors work in shared WOW
//              21-Apr-94 ricksa    made drag/drop handle WM_CANCELMODE
//		04-Apr-94 ricksa    rewrote DoDragDrop loop
//		11-Jan-94 alexgo    added VDATEHEAP to every function
//		29-Dec-93 alexgo    converted to RPC alogirithm for
//				    getting IDropTarget, etc.
//		06-Dec-93 alexgo    commented, formatted
//		93/94 Johann Posch (JohannP) created Drag/Drop for Ole 16 bit
//
//  Notes:
//
//	RPC Drag Drop algorithm:
//
//	During a drag drop operation, the user is moving the mouse around
//	the screen, passing over many windows.  For each window the mouse
//	is over, we need to determine if the window is a drop target.
//	If it is, then we remote the IDropTarget interface to the DropSource
//	so that the correct visual feedbacks can be given.
//
//	To accomplish this, RegisterDragDrop adds two properties to the
//	drop target window: a public property, EndPoint ID (provided to
//	us by compobj), and a private property (available only to the calling
//	process), the IDropTarget pointer.
//
//	During the DoDragDrop loop, we ask compobj to test each window for
//	the EndpointID property.  If it is there, compobj (via
//	GetInterfaceFromWindowProp), then we will rpc to the drop target
//	process, get the IDropTarget pointer and marshal it back to the
//	drop source process. We also install a custom message filter to
//	ensure that messages (particularly mouse move messages) are handled
//	correctly.
//
//	RevokeDragDrop simply removes the above mentioned properties from
//	the window handle.
//
//      Because in Win32, you can always switch windows and mouse capture
//      depends on having the mouse button down, drag/drop processing
//      is changed slightly. Whenever, the user does an operation that
//      would switch windows, the clipboard window that we use for capture
//      will get a WM_CANCELMODE. It will notify the drag operation and
//      the drag operation will proceed as if the user aborted the operation.
//
//
//	Win 3.1 DragDrop algorithm:
//
//	Win3.1 apps can register a window as a drop target via DragAcceptFiles.
//	This API sets the WS_EX_ACCEPTFILES bit in the window style.
//
//	In Win3.1, these apps would get a WM_DROPFILES message when
//	files where dropped on them.  An hglobal with the filenames is
//	sent in the wparam of WM_DROPFILES.
//
//	In Chicago and NT3.5, CF_HDROP is a new clipboard format that is
//	identical to the data sent in WM_DROPFILES.  If we see this format
//	available in a data object passed to DoDragDrop, then we enter
//	into our Win31 compatibility mode (which affects finding a drop
//	target).
//
//	When finding a drop target for a given window, we check to
//	see if a window in the hierarchy is registered as a Win31 drop
//	target.  If so, then we create a wrapper drop target.  This wrapper
//	drop target will forward calls to the real drop target (if available).
//
//	With Win3.1 drag drop, we can do a COPY. If the OLE target indicates
//	that no OLE drop can be performed (by returning DROPEFFECT_NONE),
//	then we substitute in DROPEFFECT_COPY.
//
//	On Drop, if the OLE target chooses not to accept the drop, then
//	we will post the window a WM_DROPFILES message with the hglobal
//	obtained from IDataObject::GetData(CF_HDROP).
//
//--------------------------------------------------------------------------

#include <le2int.h>
#pragma SEG(drag)

#include <getif.hxx>
#include <dragopt.h>
#include <resource.h>
#include "enumgen.h"
#include "clipbrd.h"
#include "drag.h"


NAME_SEG(Drag)
ASSERTDATA

ATOM g_aEndPointAtom;

// DROPFILES is the structure of data contained in the CF_HDROP format.
// However, this is private to the shell, so it is not declared in any
// header files.

typedef struct _DROPFILES {
   DWORD  pFiles;                       // offset of file list
   POINTL pt;                           // drop point (client coords)
   DWORD  fNC;                           // is it on NonClient area
                       // and pt is in screen coords
   DWORD  fWide;                         // WIDE character switch
} DROPFILES, FAR * LPDROPFILES;


#define WM_NCMOUSEFIRST	0x00A0
#define WM_NCMOUSELAST	0x00A9


// From ido.cpp to create shared memory formats
HANDLE CreateSharedDragFormats(IDataObject *pIDataObject);


#define VK_ALT VK_MENU

static const struct {
        int     keyCode;
        WPARAM  keyFlag;
    } vKeyMap [] = {
        { VK_LBUTTON, MK_LBUTTON },
        { VK_RBUTTON, MK_RBUTTON },
        { VK_MBUTTON, MK_MBUTTON },
        { VK_ALT    , MK_ALT     },
        { VK_SHIFT  , MK_SHIFT   },
        { VK_CONTROL, MK_CONTROL }
	};

// This is the default cursor object for 32 bit apps. Only one such object
// is needed for 32 bit apps. 16 bit apps need one per shared WOW application
// that is running.
CDragDefaultCursors *cddcDefault32 = NULL;

extern ATOM g_aDropTarget;
extern ATOM g_aDropTargetMarshalHwnd;


//+-------------------------------------------------------------------------
//
//  Member:     DragDropProcessUninitialize
//
//  Synopsis:   Does any Unitialization necessary at OleUninitialize time.
//		for the last Unitialize for the Process
//
//  Returns:    none
//
//  Algorithm:

//  History:	dd-mmm-yy Author    Comment
//		18-Jul-94 rogerg    Created
//
//  Note:       We need a per thread default cursor object in WOW because
//              of the clean up that WOW does. For 32 bit apps, we just use
//              one for the entire process.
//
//--------------------------------------------------------------------------


void DragDropProcessUninitialize(void)
{

    if (NULL != cddcDefault32)
    {
	delete cddcDefault32;
	cddcDefault32 = NULL;
    }

}

//+-------------------------------------------------------------------------
//
//  Member:     CDragDefaultCursors::GetDefaultCursorObject, static
//
//  Synopsis:   Get appropriate pointer to default cursor object
//
//  Returns:    NULL - error occurred
//              ~NULL - pointer to appropriate default cursor table
//
//  Algorithm:  If we are in a 32 bit app, just get a pointer to the
//              single cursor table. In 16 bit, get the per thread cursor
//              table. If there is none, then allocate and initialize it.
//
//  History:	dd-mmm-yy Author    Comment
//		18-Jul-94 Ricksa    Created
//
//  Note:       We need a per thread default cursor object in WOW because
//              of the clean up that WOW does. For 32 bit apps, we just use
//              one for the entire process.
//
//--------------------------------------------------------------------------
CDragDefaultCursors *CDragDefaultCursors::GetDefaultCursorObject(void)
{
    if (!IsWOWThread())
    {
        // If we aren't in WOW, we can use the single common default cursor
        // object. We make sure that it is initialized before we use it.
		
	if (NULL == cddcDefault32)
	{
	    cddcDefault32 = new CDragDefaultCursors;
	    if (cddcDefault32)
	    {
		if (!cddcDefault32->Init())
		{
		    delete cddcDefault32;
		    cddcDefault32 = NULL;
		}

	    }
	}

        return cddcDefault32;
    }

    COleTls tls;

    // We are in WOW. Get the cursor object if it has already been allocated
    CDragDefaultCursors *pccdc16 = (CDragDefaultCursors *) tls->pDragCursors;

    if (pccdc16 == NULL)
    {
        // No cursor table so allocate it -- Please note that we take advantage
        // of the fact that this object has only the default constructor by
        // simply allocating it rather than "newing" it. The point is that
        // we need to free the memory at thread release time and this happens
        // in code that doesn't know about the the object.
        pccdc16 = (CDragDefaultCursors *)
            PrivMemAlloc(sizeof(CDragDefaultCursors));

        if (pccdc16 != NULL)
        {
            // Successfully allocated so initialize it
            if (!pccdc16->Init())
			{
				PrivMemFree(pccdc16);
				return NULL;
			}

	    tls->pDragCursors = pccdc16;
	}
    }

    return pccdc16;
}




//+-------------------------------------------------------------------------
//
//  Function:   CDragDefaultCursors::Init
//
//  Synopsis:   Initialize object by loading all the default cursors.
//
//  History:	dd-mmm-yy Author    Comment
//		19-Apr-94 Ricksa    Created
//
//  Note:       We continue the Win16 practice of ignoring possible failure
//              cases when loading the cursors although we do put in a
//              debug verification that they all loaded.
//
//--------------------------------------------------------------------------
BOOL CDragDefaultCursors::Init(void)
{
    // Make sure table is set to NULLs.
    memset(&ahcursorDefaults[0][0], 0, sizeof(ahcursorDefaults));

    // Load cursors for operation
    if ( !(ahcursorDefaults[NO_SCROLL] [NO_DROP]
        = LoadCursor (g_hmodOLE2, MAKEINTRESOURCE(CURNONE))) )
			return FALSE;

    if (!(ahcursorDefaults[NO_SCROLL] [MOVE_DROP] =
        LoadCursor (g_hmodOLE2, MAKEINTRESOURCE(CURMOVE))) )
			return FALSE;

    if (!(ahcursorDefaults[NO_SCROLL] [COPY_DROP] =
        LoadCursor (g_hmodOLE2, MAKEINTRESOURCE(CURCOPY))) )
			return FALSE;

    if (!(ahcursorDefaults[NO_SCROLL] [LINK_DROP] =
        LoadCursor(g_hmodOLE2, MAKEINTRESOURCE(CURLINK))) )
			return FALSE;


    // Load cursors for operation
    ahcursorDefaults[SCROLL] [NO_DROP] =
        ahcursorDefaults[NO_SCROLL] [NO_DROP];

    ahcursorDefaults[SCROLL] [MOVE_DROP] =
         ahcursorDefaults[NO_SCROLL] [MOVE_DROP];

    ahcursorDefaults[SCROLL] [COPY_DROP] =
         ahcursorDefaults[NO_SCROLL] [COPY_DROP];

    ahcursorDefaults[SCROLL] [LINK_DROP] =
         ahcursorDefaults[NO_SCROLL] [LINK_DROP];


#if DBG == 1
    // For debug, verify that cursors were loaded correctly
    for (int i = 0; i < 2; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            AssertSz((ahcursorDefaults[i] [j] != NULL),
                "Drag/Drop cursor initialization failed!");
        }
    }
#endif // DBG == 1

	return TRUE;
}




//+-------------------------------------------------------------------------
//
//  Function:   CDragDefaultCursors::SetCursor
//
//  Synopsis:   Set cursor to appropriate value
//
//  Algorithm:  We use the input effect to calculate the appropriate offset
//              into the table for the cursor to use.
//
//  History:	dd-mmm-yy Author    Comment
//		19-Apr-94 Ricksa    Created
//
//  Note:       We use the table approach so we to make consistent behavior
//              between scroll and non-scroll cursors.
//
//--------------------------------------------------------------------------
void CDragDefaultCursors::SetCursor(DWORD dwEffect)
{
    // Get Scroll index
    int iScroll = (dwEffect & DROPEFFECT_SCROLL) ? SCROLL : NO_SCROLL;

    int iCursorType = NO_DROP;

    if (dwEffect & DROPEFFECT_LINK)
    {
        iCursorType = LINK_DROP;
    }
    else if (dwEffect & DROPEFFECT_COPY)
    {
        iCursorType = COPY_DROP;
    }
    else if (dwEffect & DROPEFFECT_MOVE)
    {
        iCursorType = MOVE_DROP;
    }

    ::SetCursor(ahcursorDefaults[iScroll] [iCursorType]);
}



//
// Drag/Drop Operation Statics
//
LONG CDragOperation::s_wScrollInt = -1;




//+-------------------------------------------------------------------------
//
//  Function: 	GetControlKeysState
//
//  Synopsis:   queries the current status of the control keys
//
//  Arguments:  [fAll]	-- if true, the just query the keys, not mouse
//			   buttons too
//
//  Returns:    the MK flags for each key pressed
//
//  Algorithm:	Get key state either for all keys and mouse buttons in
//		the vKeyMap table or simply for the key portion of the table
//		and translate it to the WPARAM form as returned in mouse
//		messages.
//
//  History:    dd-mmm-yy Author    Comment
//		06-Dec-93 alexgo    32bit port
//
//--------------------------------------------------------------------------

WORD GetControlKeysState(BOOL fAll)
{
    WORD grfKeyState = 0;

    int i = (fAll) ? 0 : 3;
	
    for (; i < sizeof(vKeyMap) / sizeof(vKeyMap[0]); i++)
    {
	if (GetKeyState(vKeyMap[i].keyCode) < 0) // Key down
	{
	    grfKeyState |= vKeyMap[i].keyFlag;
	}
    }

    return grfKeyState;
}

//+-------------------------------------------------------------------------
//
//  Function:	GetControlKeysStateOfParam
//
//  Synopsis:   gets the key/button state of wparam (used with mouse messages)
//
//  Arguments:  [wParam]	-- the wParam to parse apart
//
//  Returns:    the key's set in wParam
//
//  Algorithm:	First determine if keys we are interested in are set
//		in the wParam message. Then go check the state of the
//		ALT key and record that in the key state. We then return
//		that to the caller.
//
//  History:    dd-mmm-yy Author    Comment
//		06-Dec-93 alexgo    32bit port
//
//--------------------------------------------------------------------------

WORD GetControlKeysStateOfParam(WPARAM wParam)
{
    // Check all the buttons we are interested in at once.
    WORD grfKeyState = (WORD) wParam
	& (MK_LBUTTON | MK_RBUTTON | MK_MBUTTON | MK_SHIFT | MK_CONTROL);

    // get the alt key
    if (GetKeyState(VK_ALT) < 0) // Key down
    {
	grfKeyState |= MK_ALT;
    }

    return grfKeyState;
}

//+-------------------------------------------------------------------------
//
//  Function: 	IsWin31DropTarget
//
//  Synopsis: 	determines whether the given hwnd is a valid drop target
//		for Win31 style drag drop
//
//  Effects:
//
//  Arguments: 	[hwnd]	-- the window to check
//
//  Requires:
//
//  Returns:    TRUE/
//              FALSE
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	checks the WS_EX_ACCEPTFILES style bit.  If this bit is
//		set and the window is not disabled, then it is a valid
//		Win3.1 drop target.
//
//  History:    dd-mmm-yy Author    Comment
//		25-Jan-95 alexgo    added check for WS_DISABLED
//		20-Oct-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL IsWin31DropTarget( HWND hwnd )
{
    LONG exstyle;

    exstyle = GetWindowLong(hwnd, GWL_EXSTYLE);


    if( (exstyle & WS_EX_ACCEPTFILES) )
    {
	LONG style;
	style = GetWindowLong(hwnd, GWL_STYLE);

	if( !(style & WS_DISABLED) )
	{
	    return TRUE;
	}
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function: 	UseWin31DragDrop
//
//  Synopsis:	tests the given data object to see if enough data is offered
//		to perform Win3.1 style drag drop
//
//  Effects:
//
//  Arguments: 	[pDataObject]	-- pointer to the data object
//
//  Requires: 	pdataobj must not be NULL
//
//  Returns:	TRUE/FALSE
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	does an IDataObject::QueryGetData for CF_HDROP
//
//  History:    dd-mmm-yy Author    Comment
//		30-Oct-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL UseWin31DragDrop(IDataObject *pDataObject)
{
    FORMATETC formatetc;

    INIT_FORETC(formatetc);
    formatetc.cfFormat = CF_HDROP;
    formatetc.tymed = TYMED_HGLOBAL;

    if( pDataObject->QueryGetData(&formatetc) == NOERROR )
    {
	return TRUE;
    }
    else
    {
	return FALSE;
    }
}

//+-------------------------------------------------------------------------
//
//  Function: 	IsNCDrop
//
//  Synopsis: 	are we dropping into the non-client area of the window or
//		on an iconic window?
//
//  Effects: 	*DOES A SEND MESSAGE*!!!
//
//  Arguments:	[hwnd]	-- the window to ask
//		[pt]	-- the point in screen coords
//
//  Requires:
//
//  Returns: 	TRUE/FALSE  (TRUE if in non-client area)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//   		25-Jan-95 alexgo    borrowed from Win95 shell sources
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL IsNCDrop(HWND hwnd, POINT pt)
{
    return (!IsIconic(hwnd) &&
    HTCLIENT!=SendMessage(hwnd, WM_NCHITTEST, 0, MAKELPARAM(pt.x, pt.y)));
}

//+-------------------------------------------------------------------------
//
//  Member: 	GetDropTarget
//
//  Synopsis:   Gets the IDropTarget * from the closest window in the
//		hierachy up from the given window (if available, of
//		course ;-)
//
//  Arguments:  [hwndCur]	    -- the window to the cursor is currently over
//		[hwndDropTarget]    -- the window that contains a valid DropTarget
//
//  Returns:    Result of drag enter operation at Target
//
//  Algorithm:  Loop calling PrivDragDrop until we get a drop target or
//              we run out of windows that are parent to the window that
//              the mouse is currently on.
//
//		If a window in the hierarchy has registered itself for
//		Win3.1 drag drop, then we create a drop target wrapper
//		(CDropTarget) to handle the Win3.1 protocol.  Note
//		that a window hierarchy may be both OLE *and* Win3.1
//		targets.
//
//  History:	dd-mmm-yy Author    Comment
//		08-Nov-94 alexgo    converted to use PrivDragDrop
//		20-Oct-94 alexgo    added Win31 drop target support
//              30-Sep-94 ricksa    Drag/Drop optimization.
//		21-Jul-94 alexgo    removed GetDropTargetFromWindow
//				    optimization and put that functionality
//				    in GetInterfaceFromWindowProp (to
//				    help make clipboard faster).
//		06-Apr-94 Ricksa    Modified to call GetDropTargetFromWindow
//				    to optimize local calls
//		11-Jan-94 alexgo    changed name from GetTopStm to
//				    GetDropTarget, converted to the RPC-style
//				    drag drop, added a VDATEHEAP macro
//		06-Dec-93 alexgo    commented
//
//--------------------------------------------------------------------------

HRESULT CDragOperation::GetDropTarget(HWND hwnd31,HWND hwndDropTarget)
{
IDropTarget *ptarget = NULL;
DDInfo hDDInfo = NULL;

    VDATEHEAP();

    DDDebugOut((DEB_ITRACE, "%p _IN GetDropTarget ( %x,%x)\n", this, hwnd31,hwndDropTarget));

    _pDropTarget = NULL;

    HRESULT hr = E_FAIL;


    if (hwndDropTarget)
    {
    HWND hwndClipWindow;

	Assert(GetProp(hwndDropTarget, (LPCWSTR)g_aDropTarget));

        // If the DropTarget hasn't been marshaled, Marshal it now.
        if (hwndClipWindow = (HWND) GetProp(hwndDropTarget,(LPCWSTR) g_aDropTargetMarshalHwnd))
        {
            SSSendMessage(hwndClipWindow,WM_OLE_CLIPBRD_MARSHALDROPTARGET,0,(LPARAM) hwndDropTarget);
        }
    
	hr = PrivDragDrop(hwndDropTarget,
		DRAGOP_ENTER,
		_DOBuffer,
		_pDataObject,
		_grfKeyState,
		_cpt.GetPOINTL(),
		_pdwEffect,
		NULL,
		&hDDInfo);

	if (hr != NOERROR)
	{
	    hwndDropTarget = NULL;
	}

    }

    Assert( (NULL == hwnd31) || IsWin31DropTarget(hwnd31));

    if( hwndDropTarget || hwnd31 )
    {
	ptarget = new CDropTarget(hwnd31, hwndDropTarget, *_pdwEffect, this, hDDInfo);

	if( ptarget == NULL )
	{
	    hr = E_OUTOFMEMORY;
	}
	else
	{
	    hr = NOERROR;
	}

	// if we have a Win31 drop target AND the OLE drop target returned
	// DROPEFFECT_NONE, then we should return DROPEFFECT_COPY

	if( hr == NOERROR && *_pdwEffect == DROPEFFECT_NONE && hwnd31 )
	{
	    *_pdwEffect = DROPEFFECT_COPY;
	}

	_pDropTarget = ptarget;

    }
		
    DDDebugOut((DEB_ITRACE, "%p OUT GetDropTarget ( %lx ) [ %p ]\n",
	this, hr, _pDropTarget));


    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:	CDragOperation::CDragOperation
//
//  Synopsis:	Initialize the object to start the operation
//
//  Arguments:	[pDataObject] - pointer to data object to drop
//		[pDropSource] - pointer to source for drop operation
//		[dwOKEffects] - effects allowed in drag operation
//		[pdwEffect] - how operation affected source data
//		[hr] - whether constructor succeeded
//
//  Algorithm:	Initialize data in object. Make sure that static data
//		is initialized. Wait for first mouse message to begin.
//
//  History:	dd-mmm-yy Author    Comment
//		20-Oct-94 alexgo    added support for Win31 drag drop
//		04-Apr-94 Ricksa    Created
//
//--------------------------------------------------------------------------
CDragOperation::CDragOperation(
    LPDATAOBJECT pDataObject,
    LPDROPSOURCE pDropSource,
    DWORD dwOKEffects,
    DWORD FAR *pdwEffect,
    HRESULT& hr)
	:
	    _pDataObject(pDataObject),
            _DOBuffer(NULL),
	    _pDropSource(pDropSource),
	    _pDropTarget(NULL),
	    _pRealDropTarget(NULL),
	    _hFormats(NULL),
	    _dwOKEffects(dwOKEffects),
	    _pdwEffect(pdwEffect),
	    _fEscapePressed(FALSE),
	    _curOld(GetCursor()),
	    _hwndLast((HWND) -1),
	    _grfKeyState(0),
	    _hrDragResult(S_OK),
            _fReleasedCapture(FALSE),
            _pcddcDefault(NULL),
            _fUseWin31(FALSE)
{
    VDATEHEAP();

    // Set the default scroll interval
    if (s_wScrollInt < 0)
    {
	InitScrollInt();
    }

    hr = GetMarshalledInterfaceBuffer(IID_IDataObject, pDataObject,
		&_DOBuffer);

    if( hr != NOERROR )
    {
	Assert(NULL == _DOBuffer);
	return;
    }

    // Get appropriate default cursor table object
    if ((_pcddcDefault = CDragDefaultCursors::GetDefaultCursorObject()) == NULL)
    {
        // Some error occurred while we were trying to initialize the
        // so return an error. This should be highly unusual.
        DDDebugOut((DEB_ERROR,
            "CDragDefaultCursors::GetDefaultCursorObject Failed!\n"));
        hr = E_FAIL;
        return;
    }

    // We will use the clipboard window to capture the mouse but we
    // must have a clipboard window so we make sure it is created
    // if it is not already there.
    hr = ClipSetCaptureForDrag(this);

    if (FAILED(hr))
    {
        return;
    }

    _hFormats = CreateSharedDragFormats(pDataObject);

    // it's OK for _hFormats to be NULL (indicates an empty or non-existant
    // formatetc enumertor

    // For following peek
    MSG msg;

    // Busy wait until a mouse or escape message is in the queue
    while (!PeekMessage(&msg, 0, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE))
    {
	// Note: all keyboard messages except escape are tossed. This is
	// fairly reasonable since the user has to be holding the left
	// mouse button down at this point. They can't really be doing
	// too much data input one handed.
	if ((PeekMessage(&msg, 0, WM_KEYDOWN, WM_KEYDOWN, PM_REMOVE)
	    || PeekMessage(&msg, 0, WM_SYSKEYDOWN, WM_SYSKEYDOWN, PM_REMOVE))
	    && msg.wParam == VK_ESCAPE)
	{
		_fEscapePressed = TRUE;
		break;
	}
    }

    // get mouse pos and key state
    if (!_fEscapePressed)
    {
	_cpt.Set(msg.pt.x, msg.pt.y);
	_grfKeyState = GetControlKeysStateOfParam(msg.wParam);
    }
    else
    {
	// We ask the cursor for its position since we didn't get a
	// position from the mouse.
	GetCursorPos(_cpt.GetAddressOfPOINT());
	_grfKeyState = GetControlKeysState(TRUE);
    }

    // Check to see if we need to do Win3.1 style drag drop.
    // If we do, then set a flag so we can construct a fake drop target as
    // needed

    if( UseWin31DragDrop(pDataObject) )
    {
	_fUseWin31 = TRUE;
    }

}

//+-------------------------------------------------------------------------
//
//  Function:	~CDragOperation
//
//  Synopsis:	Clean up object
//
//  Algorithm:	Release mouse capture. Restore ole cursor. Remove enum
//		formats.
//
//  History:	dd-mmm-yy Author    Comment
//		04-Apr-94 Ricksa    Created
//
//--------------------------------------------------------------------------
CDragOperation::~CDragOperation(void)
{
    VDATEHEAP();

    AssertSz((_pDropTarget == NULL), "CDragOperation::~CDragOperation");

    // Stop the mouse capture
    ReleaseCapture();

    // Restore the cursor if it got changed
    SetCursor(_curOld);

    // Close the handle to the shared memory
    if (_hFormats)
    {
        CloseHandle(_hFormats);
	_hFormats = NULL;
    }

    if( _DOBuffer )
    {
	ReleaseMarshalledInterfaceBuffer(_DOBuffer);
    }
}




//+-------------------------------------------------------------------------
//
//  Function:	CDragOperation::InitScrollInt
//
//  Synopsis:	Initialize the scroll interval
//
//  Algorithm:	Look in profile for defined interval. If none set, then
//		default to zero.
//
//  History:	dd-mmm-yy Author    Comment
//		04-Apr-94 Ricksa    Created
//
//--------------------------------------------------------------------------
void CDragOperation::InitScrollInt(void)
{
    DWORD	dw;
    OLECHAR	szBuffer[20];

    s_wScrollInt = DD_DEFSCROLLDELAY;

    dw = sizeof(szBuffer);
    if (ERROR_SUCCESS == RegQueryValueEx(HKEY_CURRENT_USER,
					 OLESTR("Control Panel\\Mouse\\DragScrollDelay"),
					 NULL,
					 NULL,
					 (LPBYTE)szBuffer,
					 &dw))
    {
	s_wScrollInt = wcstol(szBuffer, NULL, 0);
    }
}



//+-------------------------------------------------------------------------
//
//  Function:	CDragOperation::UpdateTarget
//
//  Synopsis:	Update the target window based on mouse location
//
//  Returns:	TRUE - continue drag operation
//		FALSE - error or time to drop
//
//  Algorithm:	First, we query the source to see if it wants to continue
//		with the drop. If so, we get current window for mouse. If
//		it is different than the previous window check to see whether
//		the targets are different. If they are different, then notify
//		the current target that we are leaving and then notify the
//		new target that we have arrived.
//
//  History:	dd-mmm-yy Author    Comment
//		04-Apr-94 Ricksa    Created
//              10-Jul-94 AlexT     Allow same IDropTarget on different HWNDs
//
//--------------------------------------------------------------------------
BOOL CDragOperation::UpdateTarget(void)
{
    VDATEHEAP();

    DDDebugOut((DEB_ITRACE, "%p _IN CDragOperation::UpdateTarget ( )\n", this));

    // Assume this operation will continue the drag drop
    BOOL fResult = TRUE;
    HRESULT hr;
    LPDROPTARGET lpCurDropTarget = NULL,
                 lpOldDropTarget = NULL;
    HWND hWndTemp = NULL;

    HWND hwndCur = WindowFromPoint(_cpt.GetPOINT());

    // Query continue can return telling us one of four things:
    // (1) Keep going (S_OK), (2) Drop operation should occur
    // (DRAGDROP_S_DROP), (3) Drop operation is canceled
    // (DRAGDROP_S_CANCEL) or (4) An unexpected error has occurred.

    HRESULT hrQuery = _pDropSource->QueryContinueDrag(_fEscapePressed,
	_grfKeyState);

    if (FAILED(hrQuery) || (hrQuery == ResultFromScode(DRAGDROP_S_CANCEL)))
    {
	// Unexpected error or the operation has been cancelled so give up.
	_hrDragResult = hrQuery;
	fResult = FALSE;
	goto UpdateTarget_exit;
    }

    // walk up the window list to find the actual pointer values for the current
    // and old IDropTarget interfaces
    if (hwndCur != _hwndLast)
    {
        hWndTemp = _hwndLast;

	BOOL fChangedWin31 = FALSE;

	HWND hWndOldDrop = NULL;
	HWND hWndNewDrop = NULL;
	HWND hWndWin31Drop = NULL;

	LPDROPTARGET lpRealDropTarget = NULL;
	HANDLE hTemp = NULL;

	DWORD dwCurrentProcessId = 0;

	if (hWndTemp != (HWND)-1)
	    GetWindowThreadProcessId(hWndTemp, &dwCurrentProcessId);

	DWORD dwTempProcessID = dwCurrentProcessId;

	while (hWndTemp && !lpRealDropTarget && hWndTemp != (HWND)-1 && dwTempProcessID == dwCurrentProcessId)
	{
	    if (lpRealDropTarget = (IDropTarget *)GetProp(hWndTemp, (LPCWSTR)g_aDropTarget))
	    {
	        hWndOldDrop = hWndTemp;
	    }

	    hWndTemp = GetParent(hWndTemp);

	    if (hWndTemp)
	    {
	        GetWindowThreadProcessId(hWndTemp, &dwTempProcessID);
	    }
	}

        hWndTemp = hwndCur;

	if (hWndTemp != (HWND)-1)
	    GetWindowThreadProcessId(hWndTemp, &dwCurrentProcessId);

	dwTempProcessID = dwCurrentProcessId;

	while (hWndTemp && dwTempProcessID == dwCurrentProcessId)
        {
	    // If we haven't found the DropTarget yet, check this window.
	    if (!lpCurDropTarget)
	    {
                if (lpCurDropTarget = (IDropTarget *)GetProp(hWndTemp, (LPCWSTR)g_aDropTarget))
		{
		    hWndNewDrop = hWndTemp;
		}
	    }

            // if the current window is a win31 drop target, update the win31 window
	    // handle in our DropTarget Class.  NOTE: Beware, this code relies on the
            // fact that we can party on the CDropTarget Class directly, knowing that
	    // the class is reconstructed below as a result of the GetDropTarget()
	    // when the real IDropTarget ptrs change.

	    if (!fChangedWin31 &&
	        IsWin31DropTarget(hWndTemp) &&
	        _fUseWin31)
	    {
	        fChangedWin31 = TRUE;

		hWndWin31Drop = hWndTemp;

		if (_pDropTarget)
		{
		    ((CDropTarget*)_pDropTarget)->_hwnd31 = hWndTemp;
		}
	    }


	    // if have a droptarget, and handle Win31 break.
	    if (lpCurDropTarget && (!_fUseWin31 || fChangedWin31))
	    {
		break;
	    }

	    hWndTemp = GetParent(hWndTemp);

	    if (hWndTemp)
	    {
    	        GetWindowThreadProcessId(hWndTemp, &dwTempProcessID);
	    }
        }

        // only update the drop target if the target has actually changed.

	// HACK ALERT:  We must explicitly check _hwndLast for -1 because Excel does not
	// use OLE drag drop internally.  When the cursor is moved outside the Overlapped
	// Excel window, DoDragDrop is called.  At this point _pRealDropTarget == NULL
	// and lpCurDropTarget == NULL, and the no-smoking cursor does not appear.

	// the _pRealDropTarget==NULL relies on the fact that lpCurDropTarget==NULL.  This
	// is true because the first case would short-circuit the rest of the condition
	// otherwise
        if ( (lpCurDropTarget != _pRealDropTarget) ||
             (_hwndLast == (HWND)-1) ||
             (hWndNewDrop != hWndOldDrop) ||
             (_pRealDropTarget == NULL))
        {
            DDDebugOut((DEB_ITRACE, "%p lpCurDropTarget != lpOldDropTarget\n", this));
	
	    // The window that we are working on has changed
	    _hwndLast = hwndCur;
            _pRealDropTarget = lpCurDropTarget;

            //Allow the owner of the window to take foreground if it tries to.
            if (dwCurrentProcessId)
                AllowSetForegroundWindow(dwCurrentProcessId);

            // Assume that neither current or previous window are drop aware
            BOOL fCurAndLastNotDropAware = TRUE;

            if (_pDropTarget != NULL)
            {
                // There was a previous drop target

                // Last window was drag/drop aware
                fCurAndLastNotDropAware = FALSE;

                // Tell the drop target we are leaving & release it
                _pDropTarget->DragLeave();
                _pDropTarget->Release();
	        _pDropTarget = NULL;
            }

            // Set up effects for query of target
            *_pdwEffect = _dwOKEffects;

            hr = GetDropTarget(hWndWin31Drop,hWndNewDrop);

            if (_pDropTarget != NULL)
            {
                // This window is drop awarre
                fCurAndLastNotDropAware = FALSE;

                // Errors from this call are ignored. We interpret them
                // as the drop being disallowed. Since we don't really
                // use this information here but in the DragOver call
                // we make shortly, we just use this call to notify
                // the application that we are beginning a drag operation.

                if (!HandleFeedBack(hr))
                {
                    goto UpdateTarget_exit;
                }
            }
	    else
	    {
                // Tell the source that nothing happened

	        // only use DROPEFFECT_NONE if there is no new drop target.
                hr = _pDropSource->GiveFeedback(*_pdwEffect = DROPEFFECT_NONE);

                if (hr != NOERROR)
                {
                    if (DRAGDROP_S_USEDEFAULTCURSORS == GetScode(hr))
                    {
                        _pcddcDefault->SetCursorNone();
                    }
                    else
                    {
                        // Unexpected error -- we will give up drag/drop.
                        DDDebugOut((DEB_ERROR,
                            "CDragOperation::UpdateTarget 1st GiveFeedback FAILED %x\n",
                                hr));
                        _hrDragResult = hr;
                        fResult = FALSE;
                        goto UpdateTarget_exit;
                    }
                }
	    }

            if (fCurAndLastNotDropAware)
            {
                // Neither new or old window know about drag/drop so set
                // cursor accordingly.
                _pcddcDefault->SetCursorNone();
            }
        }
	else
	{
	// The window that we are working on has changed
	    _hwndLast = hwndCur;
	}
    }


    if (hrQuery != NOERROR)
    {
	// Query asked for a drop
	fResult = FALSE;
	_hrDragResult = hrQuery;
    }

UpdateTarget_exit:

    DDDebugOut((DEB_ITRACE, "%p OUT CDragOperation::UpdateTarget ( %lx )\n",
	this, fResult));

    return fResult;
}



//+-------------------------------------------------------------------------
//
//  Function:	CDragOperation::HandleFeedBack
//
//  Synopsis:   Handle feedback and update of cursor
//
//  Arguments:  [hr] - hresult from previous operation on drop target.
//
//  Returns:	TRUE - continue drag operation
//		FALSE - error
//
//  Algorithm:  If previous operation on the target failed, map this to a
//              disallowed drop. Then ask the source for feedback. If it
//              so requests, then update the cursor. If an unexpected
//              error occurs, let caller know that loop should break.
//
//  History:	dd-mmm-yy Author    Comment
//		19-Apr-94 Ricksa    Created
//
//--------------------------------------------------------------------------
BOOL CDragOperation::HandleFeedBack(HRESULT hr)
{
    VDATEHEAP();

    DDDebugOut((DEB_ITRACE, "%p _IN CDragOperation::HandleFeedBack ( %x )\n",
        this, hr));

    BOOL fResult = TRUE;

    if (hr != NOERROR)
    {

	// target not responding for some reason; treat
	// as if drop not possible, but don't preserve
	// the reason why.
	*_pdwEffect = DROPEFFECT_NONE;
    }

    // If bogus return from drag over, then make sure results are appropriate.
    // However, if we are in a WOW we need to do things a little differently
    // to maintain complete compatability with Win 3.1.  In 16-bit OLE 2.0,
    // the *_pdwEffect value is not changed when displaying feedback (i.e.,
    // the result of the & is not stored back into *_pdwEffect in Win 3.1...
    // in straight NT we do).  Not storing the results back into *_pdwEffect
    // when InWow() is a hack specifically for Visio, and even more
    // specifically, for dragging from Visio's palette of "items" to an
    // Excel spreadsheet.

    if (IsWOWThread())
    {
	hr = _pDropSource->GiveFeedback( *_pdwEffect & (_dwOKEffects | DROPEFFECT_SCROLL));
    }
    else
    {
        *_pdwEffect &= (_dwOKEffects | DROPEFFECT_SCROLL);

        hr = _pDropSource->GiveFeedback(*_pdwEffect);
    }

    if(hr != NOERROR)
    {
        // Either we want to change the cursor or some unexpected
	// error has occurred.

	if (DRAGDROP_S_USEDEFAULTCURSORS == GetScode(hr))
	{
            _pcddcDefault->SetCursor(*_pdwEffect);
	}
	else
	{
	    DDDebugOut((DEB_ERROR,
	        "CDragOperation::HandleFeedBack Feedback FAILED %x\n", hr));

	    fResult = FALSE;

	    _hrDragResult = hr;
	}
    }

    DDDebugOut((DEB_ITRACE, "%p OUT CDragOperation::HandleFeedBack ( %lx )\n",
	this, fResult));

    return fResult;
}




//+-------------------------------------------------------------------------
//
//  Function:	CDragOperation::DragOver
//
//  Synopsis:	Tell the target we are dragging over and process the result
//
//  Returns:	TRUE - continue drag operation
//		FALSE - error or time to drop
//
//  Algorithm:	Call the target's drag over if there is one and then
//		get the sources feedback to update the cursor accordingly.
//
//  History:	dd-mmm-yy Author    Comment
//		04-Apr-94 Ricksa    Created
//
//--------------------------------------------------------------------------
BOOL CDragOperation::DragOver(void)
{
    VDATEHEAP();

    DDDebugOut((DEB_ITRACE, "%p _IN CDragOperation::DragOver ( )\n", this));

    // Default the result of the function to continue the loop for
    // drag and drop.
    BOOL fResult = TRUE;

    // Local holder for errors.
    HRESULT hr;

    if (_pDropTarget != NULL)
    {
	// Keep effect in a local variable to save indirections
	// in this routine.
	*_pdwEffect = _dwOKEffects;

        hr = _pDropTarget->DragOver(_grfKeyState, _cpt.GetPOINTL(), _pdwEffect);

        // Get feedback from source & update cursor if necessary
        fResult = HandleFeedBack(hr);
    }

    DDDebugOut((DEB_ITRACE, "%p OUT CDragOperation::DragOver ( %lx )\n",
	this, fResult));

    return fResult;
}


//+-------------------------------------------------------------------------
//
//  Function:	CDragOperation::HandleMessages
//
//  Synopsis:	Handle windows messages
//
//  Returns:	TRUE - continue drag operation
//		FALSE - error or time to drop
//
//  Algorithm:	Check for any windows message. If the message is a mouse
//		message then record the new position of the mouse. If it
//		is a key message, the record whether escape has been pushed.
//		If this is any other message, then dispatch it. Repeat this
//		process until the scroll interval has been exceeded.
//
//  History:	dd-mmm-yy Author    Comment
//		04-Apr-94 Ricksa    Created
//
//--------------------------------------------------------------------------
BOOL CDragOperation::HandleMessages(void)
{
    VDATEHEAP();

    DDDebugOut((DEB_ITRACE, "%p _IN CDragOperation::HandleMessages ( )\n",
	this));


    // Message buffer
    MSG msg;

    // Default result of function to continue
    BOOL fResult = TRUE;

    // Capture all messages (i.e. modal loop).
    // Process all input messages, dispatch other messages
    //
    // Note:we must NOT loop here until a hardware message comes in
    //	 scrolling will not work.
    //	* yielding is important since other apps need to run
    //	* look for mouse messages first since these are the most
    //	  impotant

    // Flag for whether we peeked a message
    BOOL fMsg;

//
// Sundown - The SetTimer return value can be truncated.
//           We are passing NULL as HWND and Win32 will returned 
//           a value not greater than 4GB...
//           If a check is required we could consider a temporary 
//           UINT_PTR value and do an ASSERT on its value...
//

    UINT uTimer = (UINT)SetTimer(NULL, 0, s_wScrollInt, NULL);

    do
    {
	fMsg = FALSE;

	// Note: the order of peek is important - further messages can show up
	// in the last peek

        // If we looked for mouse messages first, we might never pick up
        // WM_QUIT or keyboard messages (because by the time we finished
        // processing the mouse message another might be on the queue).
        // So, we check for WM_QUIT and keyboard messages first.

	if (PeekMessage(&msg, 0, WM_QUIT, WM_QUIT, PM_REMOVE | PM_NOYIELD) ||
            PeekMessage(&msg, 0, WM_KEYFIRST, WM_KEYLAST,
                        PM_REMOVE | PM_NOYIELD) ||
	    PeekMessage(&msg, 0, WM_SYSKEYDOWN, WM_SYSKEYUP,
                        PM_REMOVE | PM_NOYIELD) ||
            PeekMessage(&msg, 0, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE) ||
	    PeekMessage(&msg, 0, WM_NCMOUSEFIRST, WM_NCMOUSELAST,
		        PM_REMOVE | PM_NOYIELD) ||
	    PeekMessage(&msg, 0, 0, 0, PM_REMOVE | PM_NOYIELD))
	{
	    fMsg = TRUE;



	    if (msg.message == WM_QUIT)
	    {
		// Quit message so we are done.
		PostQuitMessage((int) msg.wParam);

		// We are going exiting so the error doesn't matter too much
		_hrDragResult = ResultFromScode(E_UNSPEC);

		// Make sure we break out of the loop
		fResult = FALSE;
	    }
            else if ((msg.message >= WM_KEYFIRST &&
                      msg.message <= WM_KEYLAST) ||
                     (msg.message >= WM_SYSKEYDOWN &&
                      msg.message <= WM_SYSKEYUP))
            {
                //  Pull all keyboard messages from the queue - this keeps
                //  the keyboard state in sync with the user's actions

                //  We use a do/while so that we process the message we've
                //  already peeked.

                do
                {
        	    // We only really pay attention to the escape key and dump
	            // any other key board messages.
	            if ((msg.message == WM_KEYDOWN
	                || msg.message == WM_SYSKEYDOWN)
	                && msg.wParam == VK_ESCAPE)
	            {
	                // Esc pressed: Cancel
	                _fEscapePressed = TRUE;
	            }
                }
                while (PeekMessage(&msg, 0, WM_KEYFIRST, WM_KEYLAST,
                                   PM_REMOVE | PM_NOYIELD) ||
	               PeekMessage(&msg, 0, WM_SYSKEYDOWN, WM_SYSKEYUP,
                                   PM_REMOVE | PM_NOYIELD));

                DWORD grfKeyState;  // temp variable for key state

                // get the key state don't change the button states!!
	        grfKeyState = GetControlKeysState(FALSE) |
		              (_grfKeyState &
                               (MK_LBUTTON | MK_RBUTTON | MK_MBUTTON));

	        // if the keyboard state is unchanged, then don't exit
	        // this loop (as that will result in DragOver being called).
	        // If we call DragOver for each keyboard message, then
	        // performance is unacceptably slow.

	        if ((grfKeyState == _grfKeyState) && !_fEscapePressed)
                {
                    fMsg = FALSE;
                }
                else
                {
	            DDDebugOut((DEB_ITRACE, "Updating key state\n"));
	            _grfKeyState = grfKeyState;
	        }
	    }
            else if (msg.message >= WM_MOUSEFIRST &&
                     msg.message <= WM_MOUSELAST)
	    {
		// we may not have the focus (e.g. if we are the Chicago
		// shell).  Therefore, we won't ever get any WM_KEYDOWN
		// messages.  Double check the esc key status here

		if( GetKeyState(VK_ESCAPE) < 0 )
		{
		    _fEscapePressed = TRUE;
		}

		// We got a mouse move message - we skip all the mouse messages
                // till we get to the last one. The point here is that
                // because of the length of DragOver calls, we can get behind
                // in processing messages which causes odd things to happen
                // on the screen.
		if (WM_MOUSEMOVE == msg.message)
		{
		MSG msg2;

		    // Keep processing mouse move messages till there
		    // aren't any more.
			// if PeekMessage returns true update the original msg.
		    while(PeekMessage(&msg2, 0, WM_MOUSEMOVE, WM_MOUSEMOVE,
			PM_REMOVE))
		    {
			  msg = msg2;
		    }

		}


		// Record position of the mouse
		_cpt.Set(msg.pt.x, msg.pt.y);

		// set mouse button state here
		_grfKeyState = GetControlKeysStateOfParam(msg.wParam);

	    }
            else if (msg.message >= WM_NCMOUSEFIRST &&
                     msg.message <= WM_NCMOUSELAST)
            {
                //  Nothing we need to do for these NC mouse actions
                NULL;
            }
            else if ( (msg.message == WM_TIMER) && (msg.wParam == uTimer) )
            {
                //  Our timer was triggered.  We need to recheck the keyboard
		//  state just in case it has changed.  This is important for
		//  the Chicago shell--if it doesn't have focus, then we won't
		//  get any WM_KEYDOWN message (just mouse moves).

		_grfKeyState = GetControlKeysState(FALSE) | (_grfKeyState &
				(MK_LBUTTON | MK_RBUTTON | MK_MBUTTON));

		if( GetKeyState(VK_ESCAPE) < 0 )
		{
		    _fEscapePressed = TRUE;
		}

		//  go ahead and fall out of the loop so we call DragOver
		//  (our timeout expired).
            }
            else
            {
		// Dispatch all other messages
		DispatchMessage(&msg);
		fMsg = FALSE;
	    }
	}
        else
        {
            WaitMessage();
        }

    // we have to leave the loop periodicially since apps
    // might rely on on it the DragOver is called freqeuntly.
    } while (!fMsg);

    // Get rid of the timer we created for the loop
    KillTimer(NULL, uTimer);

    DDDebugOut((DEB_ITRACE, "%p OUT CDragOperation::HandleMessages ( %lx )\n",
	this, fResult));


    return fResult;
}


//+-------------------------------------------------------------------------
//
//  Function:	CDragOperation::CompleteDrop
//
//  Synopsis:	Complete the drag/drop operation
//
//  Returns:	Result of operation
//
//  Algorithm:	If there is a target and we have decided to drop, then
//		drop. Otherwise, release the target and return whatever
//		the other result of the operation was.
//
//  History:	dd-mmm-yy Author    Comment
//		04-Apr-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CDragOperation::CompleteDrop(void)
{
    VDATEHEAP();

    DDDebugOut((DEB_ITRACE, "%p _IN CDragOperation::CompleteDrop ( )\n",
	this));

    // Stop the mouse capture in case a dialog box is thrown up.
    ReleaseCapture();

    if (_pDropTarget != NULL)
    {
	// Caller is Drag/Drop aware
	// and indicated it might accept drop

        // The drop source replies DRAG_S_DROP if the user has
        // released the left mouse button.  However, we may be over
        // a drop target which has refused a drop (via the feedback
        // DROPEFFECT_NONE).  Thus, both the drop source and drop
        // target need to agree before we commit the drop.

	if ((DRAGDROP_S_DROP == GetScode(_hrDragResult))
            && (*_pdwEffect != DROPEFFECT_NONE))
	{
            // We are going to try to drop
	    *_pdwEffect = _dwOKEffects;

	    HRESULT hr = _pDropTarget->Drop(_pDataObject, _grfKeyState,
		_cpt.GetPOINTL(), _pdwEffect);

	    if (FAILED(hr))
	    {
		// If drop actually failed in the last stage, let the
		// caller know that this happened.
		_hrDragResult = hr;
	    }


	}
	else
	{
            *_pdwEffect = DROPEFFECT_NONE;
	    _pDropTarget->DragLeave();

	}

	_pDropTarget->Release();
	_pDropTarget = NULL;
    }
    else
    {
        *_pdwEffect = DROPEFFECT_NONE;
    }

    DDDebugOut((DEB_ITRACE, "%p OUT CDragOperation::CompleteDrop ( %lx )\n",
	this, _hrDragResult));

    return _hrDragResult;
}




//+-------------------------------------------------------------------------
//
//  Function:	RegisterDragDrop
//
//  Synopsis:   Registers a drop target
//
//  Arguments:  [hwnd]		-- a handle to the drop target window
//		[pDropTarget]	-- the IDropTarget interface for the window	
//
//  Returns:    HRESULT
//
//  Algorithm:	We ask compobj (via AssignEndpoinProperty) to put an
//		endpoint ID publicly available on the window handle.  Then
//		we put the IDropTarget pointer on the window as a private
//		property (see the notes at the beginning of this file).
//
//  History:	dd-mmm-yy Author    Comment
//		06-Apr-94 ricksa    Added tracing
//		16-Jan-94 alexgo    pDropTarget is now AddRef'ed
//		11-Jan-94 alexgo    added VDATEHEAP, converted to RPC-style
//				    drag drop.
//		06-Dec-93 alexgo    commented
//
//  Notes:  	By AddRef'ing the pDropTarget pointer, we are changing
//		the semantics of the 16bit code (which did not do an
//		AddRef).
//
//--------------------------------------------------------------------------
#pragma SEG(RegisterDragDrop)
STDAPI RegisterDragDrop(HWND hwnd, LPDROPTARGET pDropTarget)
{
HRESULT	hresult = NOERROR;
BOOL    fDelayDrop = FALSE;

    VDATEHEAP();

    OLETRACEIN((API_RegisterDragDrop, PARAMFMT("hwnd= %h, pDropTarget= %p"),
    			hwnd, pDropTarget));

    DDDebugOut((DEB_ITRACE, "%p _IN RegisterDragDrop ( %lx %p )\n",
	NULL, hwnd, pDropTarget));


    if (!IsValidInterface(pDropTarget))
    {
	hresult = E_INVALIDARG;
    } 
    else if (!IsWindow(hwnd))
    {
	hresult = DRAGDROP_E_INVALIDHWND;
    }
    else
    {
        CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IDropTarget,(IUnknown **)&pDropTarget);

        if (GetProp(hwnd, (LPCWSTR)g_aDropTarget))
        {
	    hresult = DRAGDROP_E_ALREADYREGISTERED;
        }
        else if (!SetProp(hwnd, (LPCWSTR)g_aDropTarget, (HANDLE)pDropTarget))
        {
            hresult = E_OUTOFMEMORY;
        }   
        else
        {
        DWORD dwAssignAptID;

            Win4Assert(NOERROR == hresult);

            // HACK:  We need to add this atom every time RegisterDragDrop
            // is called because 16-bit Word does not call RevokeDragDrop
            // and user will automatically clean-up this atom if Word is the
            // first app run, and then exited before another app calls
            // RegisterDragDrop.
            g_aEndPointAtom = GlobalAddAtom(ENDPOINT_PROP_NAME);


            // See if Delayed Drop can be set up.
            fDelayDrop = FALSE;

            if (g_aDropTargetMarshalHwnd && IsApartmentInitialized())
            {
            HWND hwndClipboard = GetPrivateClipboardWindow(CLIP_CREATEIFNOTTHERE);

                if (hwndClipboard)
                {
                    fDelayDrop = SetProp(hwnd,(LPCWSTR) g_aDropTargetMarshalHwnd,hwndClipboard); 
                }
            }

            // if can't delay marshal then marshal immediately.
            if (!fDelayDrop)
            {
                hresult = AssignEndpointProperty(hwnd);
            }

            if (NOERROR == hresult)
            {
                pDropTarget->AddRef();
            }
            else
            {
				// We don't free h. It's not a handle at all.
                HANDLE h = RemoveProp(hwnd, (LPCWSTR)g_aDropTarget);
            }
        }
    }

    DDDebugOut((DEB_ITRACE, "%p OUT RegisterDragDrop ( %lx )\n",
	NULL, hresult));

    OLETRACEOUT((API_RegisterDragDrop, hresult));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Function: 	RevokeDragDrop
//
//  Synopsis:   Unregisters a window as a drop target
//
//  Arguments:  [hwnd]		-- the window to unregister
//
//  Returns:    HRESULT
//
//  Algorithm:	Removes the two window properties set by
//		RegisterDragDrop
//
//  History:	dd-mmm-yy Author    Comment
//		06-Apr-94 ricksa    added tracing
//		16-Jan-94 alexgo    added a Release to the drag drop
//				    pointer to match the AddRef in
//				    RegisterDragDrop.
//		11-Jan-94 alexgo    converted to RPC-style drag drop,
//				    added VDATEHEAP macro
//		06-Dec-93 alexgo    commented
//
//  Notes:	the DropTarget->Release call changes the semantics of
//		this function from the 16bit version (see Notes: for
//		RegisterDragDrop).
//
//--------------------------------------------------------------------------
#pragma SEG(RevokeDragDrop)
STDAPI RevokeDragDrop(HWND hwnd)
{
HRESULT hr = NOERROR;
LPDROPTARGET pDropTarget;
BOOL fReleaseDropTarget = TRUE;

    VDATEHEAP();


    OLETRACEIN((API_RevokeDragDrop, PARAMFMT("hwnd= %h"), hwnd));

    DDDebugOut((DEB_ITRACE, "%p _IN RevokeDragDrop ( %lx )\n", NULL, hwnd));

    if (!IsWindow(hwnd))
    {
	hr = DRAGDROP_E_INVALIDHWND;
    }
    else if ((pDropTarget = (LPDROPTARGET)RemoveProp(hwnd, (LPCWSTR)g_aDropTarget)) == NULL)
    {
	hr = DRAGDROP_E_NOTREGISTERED;
    }
    else
    {
        fReleaseDropTarget = TRUE;

        if (GetProp(hwnd, (LPCWSTR) g_aEndPointAtom)) // see if there is an endpoint.
        {
        DWORD dwAssignAptID;

              // Ask compobj to remove the endpoint ID it placed on the window.
            if(SUCCEEDED(UnAssignEndpointProperty(hwnd,&dwAssignAptID)))
            {
                 // Note: AptID == ThreadID in Apartment model.
               if( (dwAssignAptID != GetCurrentThreadId()) && (IsApartmentInitialized()) )
               {
                    fReleaseDropTarget = FALSE;
               }
            }

            Win4Assert(NULL == GetProp(hwnd,(LPCWSTR) g_aDropTargetMarshalHwnd));
        }
        else
        {
        HWND hwndClipbrd;

            hwndClipbrd = (HWND) RemoveProp(hwnd,(LPCWSTR) g_aDropTargetMarshalHwnd);
            Win4Assert(hwndClipbrd);

            fReleaseDropTarget = (IsApartmentInitialized()  && (hwndClipbrd != GetPrivateClipboardWindow(CLIP_QUERY )) ) 
                                 ? FALSE : TRUE;
        }

        // Release our reference to the object since we are no longer using it.
        // NOTE: AddRef came from RegisterDragDrop

        // Warning: Only call Release if we are in the same thread that Registered the DropTarget
        //  Or we are FreeThreading.

        // This mirrors the atom added in RegisterDragDrop
         GlobalDeleteAtom(g_aEndPointAtom);

        if (fReleaseDropTarget)
        {
            pDropTarget->Release(); 
            hr = NOERROR; // Always return NOERROR even if UnAssignEndPoint Failed
        }
        else
        {
	    LEDebugOut((DEB_WARN, "WARNING:Revoke Called on Different Thread than Register!!\n"));	    
	    hr = RPC_E_WRONG_THREAD;
        }
    }

    DDDebugOut((DEB_ITRACE, "%p OUT RegisterDragDrop ( %lx )\n", NULL, hr));

    OLETRACEOUT((API_RevokeDragDrop, hr));

    return hr;
}




//+-------------------------------------------------------------------------
//
//  Function: 	DoDragDrop
//
//  Synopsis:   The main drag'n'drop loop
//
//  Effects:
//
//  Arguments:  [pDataObject]		-- the object to drag
//		[pDropSource]		-- the drop source
//		[dwOKEffects]		-- effects flags (stuff to draw)
//		[pdwEffect]		-- what actually happened in
//					   the drag drop attempt
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	See the notes at the beginning of the file
//
//  History:    dd-mmm-yy Author    Comment
//              25-Nov-96 gopalk    Fail the call if OleInitialize has not
//                                  been called
//		05-Dec-94 JohannP   added stack switching for WIN95		
//		11-Jan-94 alexgo    added VDATEHEAP macro, converted to
//                                  the RPC-style drag drop.
//      	31-Dec-93 erikgav   chicago port
//		06-Dec-93 alexgo    formatted
//
//  Notes:	Under Win95 SSAPI(DoDragDrop) gets expanded to SSDoDragDrop.
//		This function is called by DoDragDrop (in stkswtch.cxx)
//		which switches to the 16 bit stack first.
//	       	IMPORTANT: this function has to be executed on the 16 bit
//		since call back via USER might occur.
//--------------------------------------------------------------------------
#pragma SEG(DoDragDrop)
STDAPI SSAPI(DoDragDrop)(LPDATAOBJECT pDataObject, LPDROPSOURCE pDropSource,
                         DWORD dwOKEffects, DWORD *pdwEffect)
{
    OLETRACEIN((API_DoDragDrop,
                PARAMFMT("pDataObject=%p, pDropSource=%p, dwOKEffects=%x, pdwEffect=%p"),
                pDataObject, pDropSource, dwOKEffects, pdwEffect));
    DDDebugOut((DEB_ITRACE, "%p _IN DoDragDrop (%p %p %lx %p )\n", 
                NULL, pDataObject, pDropSource, dwOKEffects, pdwEffect));

    HRESULT hr = NOERROR;

#ifndef _MAC
    // Validation checks
    VDATEHEAP();
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IDataObject,(IUnknown **)&pDataObject);
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IDropSource,(IUnknown **)&pDropSource);
    if(!IsValidPtrOut(pdwEffect, sizeof(DWORD)) ||
       !IsValidInterface(pDropSource) ||
       !IsValidInterface(pDataObject))
        hr = E_INVALIDARG;

    // Check if the thread has called oleinitialize
    if(!IsOleInitialized())
        hr = CO_E_NOTINITIALIZED;

    if(hr == NOERROR) {
        // Create the object that does all the work.
        CDragOperation drgop(pDataObject, pDropSource, dwOKEffects, pdwEffect, hr);

        // Did the constructor succeeded?
        if(SUCCEEDED(hr)) {
            // Loop till worker object tells us to stop
            for(;;) {
                // Update target based on new window position
                if(!drgop.UpdateTarget()) {
                    // Error so we are done
                    break;
                }

                // Notify
                if(!drgop.DragOver()) {
                    break;
                }

                // Handle any messages we get in the mean time
                if(!drgop.HandleMessages())  {
                    break;
                }

            } // end for loop

            hr = drgop.CompleteDrop();
        }
    }
#endif // !_MAC

    DDDebugOut((DEB_ITRACE, "%p OUT DoDragDrop ( %lx )\n", NULL, hr));
    OLETRACEOUT((API_DoDragDrop, hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDropTarget::CDropTarget
//
//  Synopsis:   constructor for the CDropTarget class
//
//  Effects:
//
//  Arguments:  [hwnd31] 	-- the hwnd of the Win3.1 drop target
//				   may be NULL
//		[hwndOLE]	-- the hwnd of the OLE drop target
//		[dwEffectLast]	-- the last effect given the the current
//				   drop target that we are to emulate
//		[pdo]		-- a pointer to the main drag drop class
//		[hDDInfo]	-- handle to cached drag drag info
//		
//
//  Requires:   hwnd31 *must* be a handle to a valid Win3.1 drop source
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:  initializes variables
//
//  History:    dd-mmm-yy Author    Comment
//              20-Oct-94 alexgo    author
//		08-Jan-95
//
//  Notes:      there are two ways of determining if a given hwnd is
//              a valid Win3.1 drop target:
//                  1. send a WM_QUERYDROPOBJECT message for a TRUE/FALSE
//                     reply
//                  2. check the extended style bits for WS_EX_ACCEPTFILES
//
//		if ptarget is non-NULL, then the specific window to which
//		it belongs is *not* guaranteed to be the same window as
//		hwndtarget.  hwndtarget is the window that is registered as
//		a Win3.1 target.  All that is guaranteed is that the ole
//		target and hwndtarget are in the same window hierarchy.
//
//--------------------------------------------------------------------------

CDropTarget::CDropTarget( HWND hwnd31, HWND hwndOLE, DWORD dwEffectLast,
    CDragOperation *pdo, DDInfo hDDInfo )
{
    _crefs = 1;

    _hwndOLE = hwndOLE;
    _hwnd31 = hwnd31;
    _hDDInfo = hDDInfo;

    _dwEffectLast = dwEffectLast;

    _pdo = pdo;		// pointer to the current drag operation class

#if DBG ==1

    // now do some checking (see Notes above)

    if( hwnd31 )
    {
	LONG exstyle;

	exstyle = GetWindowLong(hwnd31, GWL_EXSTYLE);

	// strictly speaking, an app could process the WM_QUERYDROPOBJECT
	// message itself (and thus, not set the extended style bits).
	// However, this should be considered an application bug; the
	// documentation states that apps should call DragAcceptFiles,
	// which will set the WS_EX_ACCEPTFILES bit

	Assert( (exstyle & WS_EX_ACCEPTFILES) );
    }

#endif // DBG ==1

}

//+-------------------------------------------------------------------------
//
//  Member:   	CDropTarget::~CDropTarget
//
//  Synopsis: 	frees the cached drag drop info handle
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires:
//
//  Returns:  	void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		08-Jan-95 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

CDropTarget::~CDropTarget()
{
    if( _hDDInfo )
    {
	FreeDragDropInfo(_hDDInfo);
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CDropTarget::QueryInterface
//
//  Synopsis:   returns available interfaces on this object
//
//  Effects:
//
//  Arguments:  [riid]      -- the requested interface
//              [ppv]       -- where to put the interface
//
//  Requires:
//
//  Returns:    E_UNEXPECTED
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IDropTarget
//
//  Algorithm:  CDropTarget is only used internally by OLE's drag drop code.
//              It should never do a QI.
//
//  History:    dd-mmm-yy Author    Comment
//              20-Oct-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDropTarget::QueryInterface( REFIID riid, LPVOID * ppv )
{
    (void)riid;	// unused;
    (void)ppv;	// unused;

    AssertSz(0, "Unexpected QI to CDropTarget");

    return E_UNEXPECTED;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDropTarget::AddRef
//
//  Synopsis:   increments the reference count
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG, the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IDropTarget
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              20-Oct-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CDropTarget::AddRef( void )
{
    VDATEHEAP();

    DDDebugOut((DEB_ITRACE, "%p _IN CDropTarget::AddRef ( )\n", this));

    _crefs++;

    DDDebugOut((DEB_ITRACE, "%p OUT CDropTarget::AddRef ( %ld )\n", this,
        _crefs));

    return _crefs;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDropTarget::Release
//
//  Synopsis:   decrements the reference count
//
//  Effects:    may delete 'this' object
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG, the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IDropTarget
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              20-Oct-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CDropTarget::Release( void )
{
    ULONG crefs;

    VDATEHEAP();

    DDDebugOut((DEB_ITRACE, "%p _IN CDropTarget::Release ( )\n", this));

    crefs = --_crefs;

    if( crefs == 0)
    {
        DDDebugOut((DEB_ITRACE, "DELETING CDropTarget %p\n", this));
        delete this;
    }

    DDDebugOut((DEB_ITRACE, "%p OUT CDropTarget::Release ( %ld )\n",
        this, crefs));

    return crefs;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDropTarget::DragEnter
//
//  Synopsis:   sets the window up for drag drop
//
//  Effects:
//
//  Arguments:  [pDataObject]   -- the data object to drop
//              [grfKeyState]   -- the current keyboard state
//              [pt]            -- the cursor point
//              [pdwEffect]     -- where to return the drag drop effect
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IDropTarget
//
//  Algorithm:	should never be called.  DragEnter is always called
//		via GetDropTarget
//
//  History:    dd-mmm-yy Author    Comment
//		08-Nov-93 alexgo    eliminated
//              20-Oct-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDropTarget::DragEnter( IDataObject * pDataObject,
    DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect )
{
    AssertSz(0, "DragEnter unexpectedly called!");

    return E_UNEXPECTED;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDropTarget::DragOver
//
//  Synopsis:   called while the mouse is over a given window
//
//  Effects:
//
//  Arguments:  [grfKeyState]   -- the state of the keyboard
//		[ptl]		-- the position of the cursor
//		[pdwEffect]	-- the drag drop effect
//
//  Requires:
//
//  Returns: 	NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDropTarget
//
//  Algorithm: 	If an OLE target is available, then we forward the call.
//		If the target says DROPEFFECT_NONE, then we go ahead
//		and return DROPEFFECT_COPY if a Win31 target window is
//		available.
//
//		If there is no OLE target and we have a Win3.1 target,
//		then we go ahead and return DROPEFFECT_COPY.
//
//  History:    dd-mmm-yy Author    Comment
//		08-Nov-94 alexgo    converted to PrivDragDrop protocol
//		20-Oct-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDropTarget::DragOver( DWORD grfKeyState, POINTL ptl,
    DWORD *pdwEffect)
{
    HRESULT	hresult = NOERROR;

    VDATEHEAP();


    DDDebugOut((DEB_ITRACE, "%p _IN CDropTarget::DragOver ( %lx , %lx "
	", %lx )\n", this, grfKeyState, &ptl, *pdwEffect));

    if( _hwndOLE )
    {
	hresult = PrivDragDrop(_hwndOLE, DRAGOP_OVER, NULL, NULL, grfKeyState,
			ptl, pdwEffect, NULL, &_hDDInfo);

	_dwEffectLast = *pdwEffect;

	if( _hwnd31 )
	{
	    // we only want to stomp on the effect if the DragOver call
	    // succeeded.  If the call failed, then just assume that a
	    // Win3.1 drop would fail as well.

	    if( hresult == NOERROR && *pdwEffect == DROPEFFECT_NONE )
	    {
		*pdwEffect = DROPEFFECT_COPY;
	    }
	}
    }
    else if ( _hwnd31 )
    {
	*pdwEffect = DROPEFFECT_COPY;
    }


    DDDebugOut((DEB_ITRACE, "%p OUT CDropTarget::DragOver ( %lx ) [ "
	"%lx ]\n", this, hresult, *pdwEffect));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:   	CDropTarget::DragLeave
//
//  Synopsis: 	called when the cursor leaves the current target window
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires:
//
//  Returns: 	NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDropTarget
//
//  Algorithm:	Forwards the DragLeave call to the OLE-drop target
//		(if it exists).
//
//  History:    dd-mmm-yy Author    Comment
//		08-Nov-94 alexgo    converted to PrivDragDrop protocol
// 		20-Oct-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDropTarget::DragLeave()
{
    HRESULT hresult = NOERROR;
    static POINTL ptl = {0, 0};

    VDATEHEAP();

    DDDebugOut((DEB_ITRACE, "%p _IN CDropTarget::DragLeave ( )\n",
	this));

    if( _hwndOLE )
    {
	hresult = PrivDragDrop(_hwndOLE, DRAGOP_LEAVE, NULL, NULL, NULL,
		    ptl, NULL, NULL, &_hDDInfo);
    }

    DDDebugOut((DEB_ITRACE, "%p OUT CDropTarget::DragLeave ( %lx )\n",
	this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CDropTarget::Drop
//
//  Synopsis: 	called if the user lets go of the mouse button while
//		over a drop target
//
//  Effects:
//
//  Arguments: 	[pDataObject]	-- the data object to use
//		[grfKeyState]	-- the keyboard state
//		[ptl]		-- the current mouse position
//		[pdwEffect]	-- where to return cursor effect feedback
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDropTarget
//
//  Algorithm: 	If there is an OLE-target available, then we first forward
//		the drop request to it.  If the call fails
//		(or DROPEFFECT_NONE is returned), then we try the Win31
//		drop by posting a WM_DROPFILES message to the Win31 target
//		window (ifit exists).
//
//  History:    dd-mmm-yy Author    Comment
//		08-Nov-94 alexgo    converted to PrivDragDrop protocol
// 		20-Oct-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDropTarget::Drop( IDataObject *pDataObject,
    DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect )
{
    STGMEDIUM	medium;
    FORMATETC	formatetc;
    HRESULT	hresult = E_FAIL;
    IFBuffer 	DOBuffer = _pdo->GetDOBuffer();


    VDATEHEAP();

    DDDebugOut((DEB_ITRACE, "%p _IN CDropTarget::Drop ( %p , %lx , ",
	"%p , %lx )\n", this, pDataObject, grfKeyState, &ptl, *pdwEffect));


    // we don't forward Drop calls to the target if the last effect
    // is DROPEFFECT_NONE.  It is important that we check for this because
    // to DoDragDrop 'normally' would not call Drop if the last effect
    // was DROPEFFECT_NONE.  However, this target wrapper will stomp
    // pdwEffect and return DROPEFFECT_COPY instead of DROPEFFECT_NONE.

    if( _hwndOLE && _dwEffectLast != DROPEFFECT_NONE )
    {
	hresult = PrivDragDrop(_hwndOLE, DRAGOP_DROP, DOBuffer,	pDataObject,
			grfKeyState, ptl, pdwEffect,
			GetPrivateClipboardWindow(CLIP_QUERY), &_hDDInfo);
    }
    else if( _hwndOLE )
    {
	// if the 'real' drop effect is NONE, then we need to call
	// DragLeave here before going on to post the WM_DROPFILES
	// message.  Otherwise, the app that is both an OLE and Win31
	// and has been returning DROPEFFECT_NONE will never get a
	// Drop or DragLeave call (which is necessary to terminate
	// the OLE2 drag protocol).  Capone in particular is sensitive
	// to this.

	*pdwEffect = DROPEFFECT_NONE;
	hresult = DragLeave();
    }
	

    if( (hresult != NOERROR || *pdwEffect == DROPEFFECT_NONE) &&
        (hresult != S_FALSE) &&
        (_hwnd31) )
    {
	medium.tymed = TYMED_NULL;
	INIT_FORETC(formatetc);
	formatetc.cfFormat = CF_HDROP;
	formatetc.tymed = TYMED_HGLOBAL;

	hresult = pDataObject->GetData(&formatetc, &medium);

	if( hresult == NOERROR )
	{
	    // we need to fixup the mouse point coordinates in the CF_HDROP
	    // data.  The point point should be in client coordinates
	    // (whereas IDropTarget::Drop takes screen coordinates)

	    DROPFILES *pdf = (DROPFILES *)GlobalLock(medium.hGlobal);
	    POINT pt;

	    pt.x = ptl.x;
	    pt.y = ptl.y;

	    if( pdf )
	    {

		// we also need to set the non-client (NC) flag of the
		// dropfile data.  This lets the app do different behaviour
		// depending on whether the drop point is in the client or
		// non-client area (Word6, for example, opens the file if on
		// non-client area, otherwise makes a package object).

		pdf->fNC = IsNCDrop(_hwnd31, pt);

		if( ScreenToClient(_hwnd31, &pt) )
		{
		    pdf->pt.x = pt.x;
		    pdf->pt.y = pt.y;
		}
		else
		{
		    LEDebugOut((DEB_WARN, "WARNING: CF_HDROP pt coords"
			"not updated!!\n"));
		    ; // don't do anything
		}


		GlobalUnlock(medium.hGlobal);
	    }
	    else
	    {
		LEDebugOut((DEB_WARN, "WARNING: OUT OF MEMORY!\n"));
		; // don't do anything
	    }


	    if( PostMessage(_hwnd31, WM_DROPFILES,
		    (WPARAM)medium.hGlobal, 0) )
	    {
		*pdwEffect = DROPEFFECT_COPY;
	    }
	    else
	    {
		// PostMessage failed, so free the data
		ReleaseStgMedium(&medium);
		*pdwEffect = DROPEFFECT_NONE;
	    }
	}
    }

    DDDebugOut((DEB_ITRACE, "%p OUT CDropTarget::Drop ( %lx ) [ %lx ]\n",
	this, hresult, *pdwEffect));

    return hresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\drag\ido.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	ido.cpp
//
//  Contents:   Special data object implementation to optimize drag/drop
//
//  Classes:   CDragDataObject
//
//  Functions:  CreateDragDataObject
//
//  History:	dd-mmm-yy Author    Comment
//              30-Sep-94 ricksa    Created
//
//  Notes:
//
//--------------------------------------------------------------------------

#include <le2int.h>
#include <utils.h>
#include <dragopt.h>
#include <clipdata.h>

// Format for name of shared memory
OLECHAR szSharedMemoryTemplate[] = OLESTR("DragDrop%lx");

// Maximum size of string for name of shared memory. This is the size of the
// template plus the maximum number of hex digits in a long.
const int DRAG_SM_NAME_MAX = sizeof(szSharedMemoryTemplate)
    + sizeof(DWORD) * 2;

// Useful function for getting an enumerator
HRESULT wGetEnumFormatEtc(
    IDataObject *pDataObj,
    DWORD dwDirection,
    IEnumFORMATETC **ppIEnum);




//+-------------------------------------------------------------------------
//
//  Class:      CDragDataObject
//
//  Purpose:    Server side data object for drag that creates enumerator
//              for shared formats.
//
//  Interface:	QueryInterface
//              AddRef
//              Release
//              GetData
//              GetDataHere
//              QueryGetData
//              GetCanonicalFormatEtc
//              SetData
//              EnumFormatEtc
//              DAdvise
//              DUnadvise
//              EnumDAdvise
//
//  History:	dd-mmm-yy Author    Comment
//		30-Sep-94 Ricksa    Created
//
//  Notes:      This class only exists for return the enumerator. For
//              all other operations it will simply pass the operation on
//              to the real data object.
//
//--------------------------------------------------------------------------
class CDragDataObject : public IDataObject, public CPrivAlloc
{
public:
    CDragDataObject(
        void *pvMarshaledDataObject,
        DWORD dwSmId);

    ~CDragDataObject(void);

    //
    //  IUnknown
    //
    STDMETHODIMP        QueryInterface(
                            REFIID riid,
                            void **ppvObject);

    STDMETHODIMP_(ULONG) AddRef(void);

    STDMETHODIMP_(ULONG) Release(void);

    //
    //  IDataObject
    //
    STDMETHODIMP        GetData(
                            FORMATETC *pformatetcIn,
                            STGMEDIUM *pmedium);

    STDMETHODIMP        GetDataHere(
                            FORMATETC *pformatetc,
                            STGMEDIUM *pmedium);

    STDMETHODIMP        QueryGetData(
                            FORMATETC *pformatetc);

    STDMETHODIMP        GetCanonicalFormatEtc(
                            FORMATETC *pformatectIn,
                            FORMATETC *pformatetcOut);

    STDMETHODIMP        SetData(
                            FORMATETC *pformatetc,
                            STGMEDIUM *pmedium,
                            BOOL fRelease);

    STDMETHODIMP        EnumFormatEtc(
                            DWORD dwDirection,
                            IEnumFORMATETC **ppenumFormatEtc);

    STDMETHODIMP        DAdvise(
                            FORMATETC *pformatetc,
                            DWORD advf,
                            IAdviseSink *pAdvSink,
                            DWORD *pdwConnection);

    STDMETHODIMP        DUnadvise(DWORD dwConnection);

    STDMETHODIMP        EnumDAdvise(IEnumSTATDATA **ppenumAdvise);

private:

    IDataObject *       GetRealDataObjPtr(void);
    HRESULT		GetFormatEtcDataArray(void);

    ULONG               _cRefs;

    void *              _pvMarshaledDataObject;

    IDataObject *       _pIDataObject;
    FORMATETCDATAARRAY  *m_pFormatEtcDataArray;

    DWORD               _dwSmId;
};


//+-------------------------------------------------------------------------
//
//  Member:     CDragDataObject::CDragDataObject
//
//  Synopsis:   Create server side object for drag
//
//  History:	dd-mmm-yy Author    Comment
//		30-Sep-94 Ricksa    Created
//
//--------------------------------------------------------------------------
CDragDataObject::CDragDataObject(void *pvMarshaledDataObject, DWORD dwSmId)
 : _cRefs(1), _pvMarshaledDataObject(pvMarshaledDataObject), _dwSmId(dwSmId),
    _pIDataObject(NULL), m_pFormatEtcDataArray(NULL)
{
    // Header does all the work
}





//+-------------------------------------------------------------------------
//
//  Member:     CDragDataObject::~CDragDataObject
//
//  Synopsis:   Free any resources connected with this object
//
//  History:	dd-mmm-yy Author    Comment
//		30-Sep-94 Ricksa    Created
//
//  Note:
//
//--------------------------------------------------------------------------
CDragDataObject::~CDragDataObject(void)
{
    // Release held pointer since we no longer need it.
    if (_pIDataObject)
    {
        _pIDataObject->Release();
    }

    // this memory was allocated in RemPrivDragDrop, getif.cxx
    if( _pvMarshaledDataObject )
    {
	PrivMemFree(_pvMarshaledDataObject);
    }

    if (m_pFormatEtcDataArray)
    {

	if (0 == --m_pFormatEtcDataArray->_cRefs)
	{
	    PrivMemFree(m_pFormatEtcDataArray);
	    m_pFormatEtcDataArray = NULL;
	}

    }


}





//+-------------------------------------------------------------------------
//
//  Member:     CDragDataObject::GetRealDataObjPtr
//
//  Synopsis:   Get the pointer to the real data object from the client
//
//  Returns:    NULL - could not unmarshal drag source's data object
//              ~NULL - pointer to drag source's data object
//
//  History:	dd-mmm-yy Author    Comment
//		30-Sep-94 Ricksa    Created
//
//--------------------------------------------------------------------------
IDataObject *CDragDataObject::GetRealDataObjPtr(void)
{
    if (_pIDataObject == NULL)
    {
        _pIDataObject = UnmarshalDragDataObject(_pvMarshaledDataObject);

	LEERROR(!_pIDataObject, "Unable to unmarshal dnd data object");
    }

    return _pIDataObject;
}


//+-------------------------------------------------------------------------
//
//  Member:  	CDragDataObject::GetFormatEtcDataArray (private)
//
//  Synopsis:   if don't already have shared formats for enumeraor.
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		13-Jun-94 Ricksa    author
//
//  Notes: 	
//		
//--------------------------------------------------------------------------


HRESULT CDragDataObject::GetFormatEtcDataArray(void)
{
OLECHAR szSharedMemoryName[DRAG_SM_NAME_MAX];
HANDLE hSharedMemory;
FORMATETCDATAARRAY *pFormatEtcDataArray = NULL;


    if (m_pFormatEtcDataArray)
	return NOERROR;

    wsprintf(szSharedMemoryName, szSharedMemoryTemplate, _dwSmId);

     // Create the shared memory object
    hSharedMemory = OpenFileMapping(FILE_MAP_READ, FALSE, szSharedMemoryName);
    if (hSharedMemory != NULL)
    {
    	// Map in the shared memory
    	pFormatEtcDataArray = (FORMATETCDATAARRAY *) MapViewOfFile(hSharedMemory,
    	    FILE_MAP_READ, 0, 0, 0);

    	if (NULL == pFormatEtcDataArray)
    	{
    	    CloseHandle(hSharedMemory);
    	    hSharedMemory = NULL;
    	}
    }

    if (pFormatEtcDataArray)
    {

        size_t stSize;
        GetCopiedFormatEtcDataArraySize (pFormatEtcDataArray, &stSize);

    	m_pFormatEtcDataArray = (FORMATETCDATAARRAY *) PrivMemAlloc(stSize);
    	if (m_pFormatEtcDataArray)
    	{
    	    CopyFormatEtcDataArray (m_pFormatEtcDataArray, pFormatEtcDataArray, stSize, FALSE);
    	    Assert(1 == m_pFormatEtcDataArray->_cRefs);
    	}

    	UnmapViewOfFile(pFormatEtcDataArray);
    	CloseHandle(hSharedMemory);
    }

    return m_pFormatEtcDataArray ? NOERROR : E_OUTOFMEMORY;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDragDataObject::QueryInterface
//
//  Synopsis:   Get new interface
//
//  Arguments:  [riid] - interface id of requested interface
//              [ppvObject] - where to put the new interface pointer
//
//  Returns:    NOERROR - interface was instantiated
//              E_FAIL - could not unmarshal source's data object
//              other - some error occurred.
//
//  History:	dd-mmm-yy Author    Comment
//		30-Sep-94 Ricksa    Created
//
//  Note:
//
//--------------------------------------------------------------------------
STDMETHODIMP CDragDataObject::QueryInterface(
    REFIID riid,
    void **ppvObject)
{
    if(IsEqualIID(riid, IID_IDataObject) ||
       IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObject = this;
        AddRef();
        return NOERROR;
    }

    return (GetRealDataObjPtr() != NULL)
        ?  _pIDataObject->QueryInterface(riid, ppvObject)
        : E_FAIL;
}





//+-------------------------------------------------------------------------
//
//  Member:     CDragDataObject::AddRef
//
//  Synopsis:   Create server side object for drag
//
//  Returns:    Current reference count
//
//  History:	dd-mmm-yy Author    Comment
//		30-Sep-94 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDragDataObject::AddRef(void)
{
    DDDebugOut((DEB_ITRACE, "ADDREF == %d\n", _cRefs + 1));
    return ++_cRefs;
}





//+-------------------------------------------------------------------------
//
//  Member:     CDragDataObject::Release
//
//  Synopsis:   Decrement reference count to the object
//
//  Returns:    Current reference count to the object
//
//  History:	dd-mmm-yy Author    Comment
//		30-Sep-94 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDragDataObject::Release(void)
{
    ULONG cRefs = --_cRefs;

    DDDebugOut((DEB_ITRACE, "RELEASE == %d\n", cRefs));

    if (cRefs == 0)
    {
        delete this;
    }

    return cRefs;
}





//+-------------------------------------------------------------------------
//
//  Member:     CDragDataObject::GetData
//
//  Synopsis:   Create server side object for drag
//
//  Arguments:  [pformatetcIn] - format for requested data
//              [pmedium] - storage medium
//
//  Returns:    NOERROR - operation was successful
//              Other - operation failed
//
//  History:	dd-mmm-yy Author    Comment
//		30-Sep-94 Ricksa    Created
//
//  Note:       This just forwards the operation to the source data object
//              if possible.
//
//--------------------------------------------------------------------------
STDMETHODIMP CDragDataObject::GetData(
    FORMATETC *pformatetcIn,
    STGMEDIUM *pmedium)
{
    return (GetRealDataObjPtr() != NULL)
        ? _pIDataObject->GetData(pformatetcIn, pmedium)
        : E_FAIL;
}





//+-------------------------------------------------------------------------
//
//  Member:     CDragDataObject::GetDataHere
//
//  Synopsis:   Create server side object for drag
//
//  Arguments:  [pformatetc] - format for requested data
//              [pmedium] - storage medium
//
//  Returns:    NOERROR - operation was successful
//              Other - operation failed
//
//  History:	dd-mmm-yy Author    Comment
//		30-Sep-94 Ricksa    Created
//
//  Note:       This just forwards the operation to the source data object
//              if possible.
//
//--------------------------------------------------------------------------
STDMETHODIMP CDragDataObject::GetDataHere(
    FORMATETC *pformatetc,
    STGMEDIUM *pmedium)
{
    return (GetRealDataObjPtr() != NULL)
        ? _pIDataObject->GetDataHere(pformatetc, pmedium)
        : E_FAIL;
}





//+-------------------------------------------------------------------------
//
//  Member:     CDragDataObject::QueryGetData
//
//  Synopsis:   Create server side object for drag
//
//  Arguments:  [pformatetc] - format to verify
//
//  Returns:    NOERROR - operation was successful
//              Other - operation failed
//
//  History:	dd-mmm-yy Author    Comment
//		30-Sep-94 Ricksa    Created
//
//  Note:       This just forwards the operation to the source data object
//              if possible.
//
//--------------------------------------------------------------------------
STDMETHODIMP CDragDataObject::QueryGetData(FORMATETC *pformatetc)
{
    return (GetRealDataObjPtr() != NULL)
        ? _pIDataObject->QueryGetData(pformatetc)
        : E_FAIL;
}





//+-------------------------------------------------------------------------
//
//  Member:     CDragDataObject::GetCanonicalFormatEtc
//
//  Synopsis:   Create server side object for drag
//
//  Arguments:  [pformatetcIn] - input format
//              [pformatetcOut] - output format
//
//  Returns:    NOERROR - operation was successful
//              Other - operation failed
//
//  History:	dd-mmm-yy Author    Comment
//		30-Sep-94 Ricksa    Created
//
//  Note:       This just forwards the operation to the source data object
//              if possible.
//
//--------------------------------------------------------------------------
STDMETHODIMP CDragDataObject::GetCanonicalFormatEtc(
    FORMATETC *pformatetcIn,
    FORMATETC *pformatetcOut)
{
    return (GetRealDataObjPtr() != NULL)
        ? _pIDataObject->GetCanonicalFormatEtc(pformatetcIn, pformatetcOut)
        : E_FAIL;
}





//+-------------------------------------------------------------------------
//
//  Member:     CDragDataObject::SetData
//
//  Synopsis:   Create server side object for drag
//
//  Arguments:  [pformatetc] - format for set
//              [pmedium] - medium to use
//              [fRelease] - who releases
//
//  Returns:    NOERROR - operation was successful
//              Other - operation failed
//
//  History:	dd-mmm-yy Author    Comment
//		30-Sep-94 Ricksa    Created
//
//  Note:       This just forwards the operation to the source data object
//              if possible.
//
//--------------------------------------------------------------------------
STDMETHODIMP CDragDataObject::SetData(
    FORMATETC *pformatetc,
    STGMEDIUM *pmedium,
    BOOL fRelease)
{
    return (GetRealDataObjPtr() != NULL)
        ? _pIDataObject->SetData(pformatetc, pmedium, fRelease)
        : E_FAIL;
}





//+-------------------------------------------------------------------------
//
//  Member:     CDragDataObject::EnumFormatEtc
//
//  Synopsis:   Create server side object for drag
//
//  Arguments:  [dwDirection] - direction of formats either set or get
//              [ppenumFormatEtc]  - where to put enumerator
//
//  Returns:    NOERROR - operation succeeded.
//
//  Algorithm:  If format enumerator requested is for a data get, the
//              create our private enumerator object otherwise pass
//              the request to the real data object.
//
//  History:	dd-mmm-yy Author    Comment
//		30-Sep-94 Ricksa    Created
//
//  Note:       For the data set direction, we just use the data object of
//              the drop source.
//
//--------------------------------------------------------------------------
STDMETHODIMP CDragDataObject::EnumFormatEtc(
    DWORD dwDirection,
    IEnumFORMATETC **ppenumFormatEtc)
{
    HRESULT hr;

    // Create our enumerator
    if (dwDirection == DATADIR_GET)
    {
        // In the data get case we use our overridden enumerator.
        // This s/b the typical case with Drag and Drop.

	*ppenumFormatEtc = NULL;
	GetFormatEtcDataArray();

	if (m_pFormatEtcDataArray)
	{
	    // enumerator implementation in Clipdata.cpp
	    *ppenumFormatEtc = new CEnumFormatEtcDataArray(m_pFormatEtcDataArray,0);
	}

	hr = *ppenumFormatEtc ? NOERROR : E_OUTOFMEMORY;
    }
    else
    {
        // Call through to the real data object because this is the
        // set case. In general, this won't happen during Drag and Drop.
        hr = (GetRealDataObjPtr() != NULL)
            ? _pIDataObject->EnumFormatEtc(dwDirection, ppenumFormatEtc)
            : E_FAIL;
    }

    return hr;
}





//+-------------------------------------------------------------------------
//
//  Member:     CDragDataObject::DAdvise
//
//  Synopsis:   Create server side object for drag
//
//  Arguments:  [pformatetc] - format to be advised on
//              [advf] - type of advise
//              [pAdvSink] - advise to notify
//              [pdwConnection] - connection id for advise
//
//  Returns:    NOERROR - operation was successful
//              Other - operation failed
//
//  History:	dd-mmm-yy Author    Comment
//		30-Sep-94 Ricksa    Created
//
//  Note:       This just forwards the operation to the source data object
//              if possible.
//
//--------------------------------------------------------------------------
STDMETHODIMP CDragDataObject::DAdvise(
    FORMATETC *pformatetc,
    DWORD advf,
    IAdviseSink *pAdvSink,
    DWORD *pdwConnection)
{
    return (GetRealDataObjPtr() != NULL)
        ? _pIDataObject->DAdvise(pformatetc, advf, pAdvSink, pdwConnection)
        : E_FAIL;
}





//+-------------------------------------------------------------------------
//
//  Member:     CDragDataObject::DUnadvise
//
//  Synopsis:   Create server side object for drag
//
//  Arguments:  [dwConnection] - connection id for advise
//
//  Returns:    NOERROR - operation was successful
//              Other - operation failed
//
//  History:	dd-mmm-yy Author    Comment
//		30-Sep-94 Ricksa    Created
//
//  Note:       This just forwards the operation to the source data object
//              if possible.
//
//--------------------------------------------------------------------------
STDMETHODIMP CDragDataObject::DUnadvise(DWORD dwConnection)
{
    return (GetRealDataObjPtr() != NULL)
        ? _pIDataObject->DUnadvise(dwConnection)
        : E_FAIL;
}





//+-------------------------------------------------------------------------
//
//  Member:     CDragDataObject::EnumDAdvise
//
//  Synopsis:   Create server side object for drag
//
//  Arguments:  [ppenumAdvise] - where to put the enumerator
//
//  Returns:    NOERROR - operation was successful
//              Other - operation failed
//
//  History:	dd-mmm-yy Author    Comment
//		30-Sep-94 Ricksa    Created
//
//  Note:       This just forwards the operation to the source data object
//              if possible.
//
//--------------------------------------------------------------------------
STDMETHODIMP CDragDataObject::EnumDAdvise(IEnumSTATDATA **ppenumAdvise)
{
    return (GetRealDataObjPtr() != NULL)
        ? _pIDataObject->EnumDAdvise(ppenumAdvise)
        : E_FAIL;
}




//+-------------------------------------------------------------------------
//
//  Member:     CreateDragDataObject
//
//  Synopsis:   Create the server side data object for format enumeration
//
//  Arguments:  [pvMarshaledDataObject] - marshaled real data object buffer
//              [dwSmId] - id for the shared memory
//              [ppIDataObject] - output data object.
//
//  Returns:    NOERROR - could create the object
//              E_OUTOFMEMORY - could not create the object
//
//
//  History:	dd-mmm-yy Author    Comment
//		30-Sep-94 Ricksa    Created
//
//  Note:
//
//--------------------------------------------------------------------------
HRESULT CreateDragDataObject(
    void *pvMarshaledDataObject,
    DWORD dwSmId,
    IDataObject **ppIDataObject)
{
    CDragDataObject *pDragDataObject =
        new CDragDataObject(pvMarshaledDataObject, dwSmId);

    if (pDragDataObject != NULL)
    {
        *ppIDataObject = pDragDataObject;
    }

    // The only thing that can fail here is the memory allocation of
    // CDragDataObject thus there are only two error returns.
    return (pDragDataObject != NULL) ? NOERROR : E_OUTOFMEMORY;
}




//+-------------------------------------------------------------------------
//
//  Member:     CreateSharedDragFormats
//
//  Synopsis:   Put the data formats for the data object in shared memory.
//
//  Arguments:  [pIDataObject] - data object to use for formats.
//
//  Returns:    NULL - could not create enumerator
//              ~NULL - handle to shared memory
//
//  Algorithm:  First calculate the size of the required memory by enumerating
//              the formats. Then allocate the memory and map it into the
//              process. Then enumerate the formats again placing them in
//              the shared memory. Finally, map the memory out of the
//              process and return the handle the file mapping to the
//              caller.
//
//  History:	dd-mmm-yy Author    Comment
//		30-Sep-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HANDLE CreateSharedDragFormats(IDataObject *pIDataObject)
{

    // Handle to the shared memory for formats
    HANDLE hSharedMemory = NULL;

    // Pointer to share memory
    FORMATETCDATAARRAY *pFormatEtcDataArray = NULL;

    // Size required for the shared memory
    DWORD dwSize = 0;

    // Count of FORMATETCs contained in the enumerator
    DWORD cFormatEtc = 0;

    // Buffer for name of shared memory for enumerator
    OLECHAR szSharedMemoryName[DRAG_SM_NAME_MAX];

    // Work pointer to shared memory for storing FORMATETCs from the enumerator.
    FORMATETCDATA *pFormatEtcData;

    // Work ptr to shared memory for storing DVTARGETDEVICEs from enumerator.
    BYTE *pbDvTarget = NULL;

    //
    // Calculate the size of the formats
    //

    // Get the format enumerator
    IEnumFORMATETC *penum = NULL;
    HRESULT hr = wGetEnumFormatEtc(pIDataObject, DATADIR_GET, &penum);
    FORMATETC FormatEtc;

    if( hr != NOERROR )
    {
	// not all apps support enumerators (yahoo).  Also, we may
	// have run out of memory or encountered some other error.

	DDDebugOut((DEB_WARN, "WARNING: Failed to get formatetc enumerator"
	    ", error code (%lx)", hr));
	goto exitRtn;
    }

    // Enumerate the data one at a time because this is a local operation
    // and it make the code simpler.
    while ((hr = penum->Next(1, &FormatEtc, NULL)) == S_OK)
    {
	// Bump the entry count
	cFormatEtc++;

	// Bump the size by the size of another FORMATETC.
	dwSize += sizeof(FORMATETCDATA);

	// Is there a device target associated with the FORMATETC?
	if (FormatEtc.ptd != NULL)
	{
	    // Bump the size required by the size of the target device
	    dwSize += FormatEtc.ptd->tdSize;

	    // Free the target device
	    CoTaskMemFree(FormatEtc.ptd);
	}
    }

    // HRESULT s/b S_FALSE at the end of the enumeration.
    if (hr != S_FALSE)
    {
	goto errRtn;
    }

    // the enumerator may have been empty

    if( dwSize == 0 )
    {
	DDDebugOut((DEB_WARN, "WARNING: Empty formatetc enumerator"));
	goto exitRtn;
    }


    dwSize += sizeof(FORMATETCDATAARRAY); // add space for _cFormats and one extra FORMATETC for FALSE in enumerator.

    //
    // Create shared memory for the type enumeration
    //

    // Build name of shared memory - make it unique by using the thread id.
    wsprintf(szSharedMemoryName, szSharedMemoryTemplate, GetCurrentThreadId());

    // Create the shared memory object
    hSharedMemory = CreateFileMapping(INVALID_HANDLE_VALUE, NULL,
        PAGE_READWRITE, 0, dwSize, szSharedMemoryName);

    // Did the file mapping get created?
    if (hSharedMemory == NULL)
    {
        goto errRtn;
    }

    // Map in the memory
    pFormatEtcDataArray = (FORMATETCDATAARRAY *) MapViewOfFile(
        hSharedMemory,
        FILE_MAP_WRITE,
        0,              // High-order 32 bits of file offset
        0,              // Low-order 32 bits of file offset
        0);             // Number of bytes to map; 0 means all.

    // Could we map the memory?
    if (pFormatEtcDataArray == NULL)
    {
        goto errRtn;
    }

    // We can initialize the size of the array now.
    pFormatEtcDataArray->_dwSig = 0;
    pFormatEtcDataArray->_dwSize = dwSize;
    pFormatEtcDataArray->_cFormats = cFormatEtc;
    pFormatEtcDataArray->_cRefs = 1;
    pFormatEtcDataArray->_fIs64BitArray = IS_WIN64;

    //
    // Copy the formats into the shared memory
    //

    // Get back to the start of the enumeration
    penum->Reset();

    // This is the pointer to where we will copy the data from the
    // enumeration.
    pFormatEtcData = &pFormatEtcDataArray->_FormatEtcData[0];

    // put DvTarget past last valid FormatEtc + 1 to handle S_FALSE enumerator case.

    pbDvTarget = (BYTE *) (&pFormatEtcDataArray->_FormatEtcData[cFormatEtc + 1]);

    // Loop loading the formats into the shared memory.
    while (penum->Next(1,&(pFormatEtcData->_FormatEtc), NULL) != S_FALSE)
    {
        // Is there a DVTARGETDEVICE?
        if (pFormatEtcData->_FormatEtc.ptd != NULL)
        {

            // Copy the device target data
          memcpy(pbDvTarget,pFormatEtcData->_FormatEtc.ptd,(pFormatEtcData->_FormatEtc.ptd)->tdSize);

 	    // Free the target device data
            CoTaskMemFree(pFormatEtcData->_FormatEtc.ptd);

            // NOTE: For this shared memory structure, we override the
            // FORMATETC field so that it is that offset to the DVTARGETDEVICE
            // from the beginning of the shared memory rather than a direct
            // pointer to the structure. This is because we can't guarantee
            // the base of shared memory in different processes.

            pFormatEtcData->_FormatEtc.ptd = (DVTARGETDEVICE *)
                (pbDvTarget - (BYTE *) pFormatEtcDataArray);

            // Bump pointer of where to copy target to next available
            // byte for copy.
            pbDvTarget += ((DVTARGETDEVICE *) pbDvTarget)->tdSize;
	
	    Assert(dwSize >= (DWORD) (pbDvTarget - (BYTE *) pFormatEtcDataArray));

        }

	// Bug#18669 - if dwAspect was set to NULL the 16 bit dlls would
	// set it to content.
	if ( (NULL == pFormatEtcData->_FormatEtc.dwAspect) &&  IsWOWThread() )
	{
	    pFormatEtcData->_FormatEtc.dwAspect = DVASPECT_CONTENT;
	    pFormatEtcData->_FormatEtc.lindex = -1; // CorelDraw also puts up a lindex of 0
	}

        // Bump the pointer in the table of FORMATETCs to the next slot
        pFormatEtcData++;
    }

    Assert( dwSize >= (DWORD) ( (BYTE *) pFormatEtcData - (BYTE *) pFormatEtcDataArray));
    Assert( dwSize >= (DWORD) ( (BYTE *) pbDvTarget - (BYTE *) pFormatEtcDataArray));


    // Successful enumeration always ends with S_FALSE.
    if (hr == S_FALSE)
    {
        goto exitRtn;
    }

errRtn:

    if (hSharedMemory != NULL)
    {
        CloseHandle(hSharedMemory);
        hSharedMemory = NULL;
    }

exitRtn:

    if( penum )
    {
        // HACK ALERT:  Do not release the enumerator if the calling application
	// was Interleaf 6.0, otherwise they will fault in the release call.
        if (!IsTaskName(L"ILEAF6.EXE"))
	{
    	    penum->Release();
        }
    }

    if (pFormatEtcDataArray != NULL)
    {
        // Only remote clients will use this memory so we unmap it
        // out of our address space.
        UnmapViewOfFile(pFormatEtcDataArray);
    }

    return hSharedMemory;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\debug\dstream.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dstream.cpp
//
//  Contents:   internal debugging support (debug stream which builds a string)
//
//  Classes:    dbgstream implementation
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              09-Feb-95 t-ScottH  author
//
//--------------------------------------------------------------------------

#include <le2int.h>
#include <stdio.h>
#include "dstream.h"

//+-------------------------------------------------------------------------
//
//  Member:     dbgstream, public (_DEBUG only)
//
//  Synopsis:   constructor
//
//  Effects:    initializes and allocates buffer
//
//  Arguments:  [dwSize]    - size of initial buffer to allocate
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

dbgstream::dbgstream(SIZE_T stSize)
{
    init();
    allocate(stSize);
    if (m_stBufSize)
    {
        m_pszBuf[0] = '\0';
    }
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Member:     dbgstream, public (_DEBUG only)
//
//  Synopsis:   constructor
//
//  Effects:    initializes and allocates buffer
//
//  Arguments:
//
//  Requires:   DEFAULT_INITAL_ALLOC
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Feb-95 t-ScottH  author
//
//  Notes:
//      allocate the buffer with the default initial size
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

dbgstream::dbgstream()
{
    init();
    allocate(DEFAULT_INITIAL_ALLOC);
    if (m_stBufSize)
    {
        m_pszBuf[0] = '\0';
    }
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Member:     ~dbgstream, public (_DEBUG only)
//
//  Synopsis:   destructor
//
//  Effects:    frees the string if m_fFrozen == FALSE
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:   frees the character array
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Feb-95 t-ScottH  author
//
//  Notes:
//      we only want to free the string if it has not been passed off externally
//      using the str() method
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

dbgstream::~dbgstream()
{
    if (m_fFrozen == FALSE)
    {
        free();
    }
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Member:     init, private (_DEBUG only)
//
//  Synopsis:   initializes the data members
//
//  Effects:    initializes radix to DEFAULT_RADIX,
//              precision to DEFAULT_PRECISION decimal places
//
//  Arguments:
//
//  Requires:   DEFAULT_RADIX, DEFAULT_PRECISION
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

void dbgstream::init()
{
    m_stIndex   = 0;
    m_stBufSize = 0;
    m_fFrozen   = FALSE;
    m_radix     = DEFAULT_RADIX;
    m_precision = DEFAULT_PRECISION;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Member:     allocate, private (_DEBUG only)
//
//  Synopsis:   allocate the buffer
//
//  Effects:    if allocates fail, freeze the buffer
//
//  Arguments:  [dwSize]    - size of buffer to allocate (in bytes)
//
//  Requires:   CoTaskMemRealloc
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

void dbgstream::allocate(SIZE_T stSize)
{
    m_pszBuf = (char *)CoTaskMemAlloc(stSize);

    if (m_pszBuf == NULL)
    {
        m_fFrozen = TRUE;
    }
    else
    {
        m_stBufSize = stSize;
    }

    return;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Member:     free, private (_DEBUG only)
//
//  Synopsis:   frees the buffer (resets index and max size)
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:   CoTaskMemFree
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

void dbgstream::free()
{
    CoTaskMemFree(m_pszBuf);
    m_stIndex       = 0;
    m_stBufSize     = 0;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Member:     reallocate, private (_DEBUG only)
//
//  Synopsis:   reallocates the buffer (keeps data intact), depending on
//              current size this method will choose a growby size
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:   CoTaskMemRealloc, DEFAULT_GROWBY, DEFAULT_INITIAL_ALLOC
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Feb-95 t-ScottH  author
//
//  Notes:
//      tried to make reallocation more efficient based upon current size
//      (I don't know any of the mathematical theory :-)
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

void dbgstream::reallocate()
{
    if (m_stBufSize < (DEFAULT_INITIAL_ALLOC * 2))
    {
        reallocate(DEFAULT_GROWBY);
    }
    else
    {
        reallocate(m_stBufSize/2);
    }
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Member:     reallocate, private (_DEBUG only)
//
//  Synopsis:   reallocate the buffer (keep data intact)
//
//  Effects:    if reallocation fails, freeze the buffer
//
//  Arguments:  [dwSize]    - amount to grow buffer by
//
//  Requires:   CoTaskMemRealloc
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Feb-95 t-ScottH  author
//
//  Notes:
//      new buffer size = m_stBufSize + stSize
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

void dbgstream::reallocate(SIZE_T stSize)
{
    char *pszBuf;

    pszBuf = (char *)CoTaskMemRealloc(m_pszBuf, m_stBufSize + stSize);

    if (pszBuf != NULL)
    {
        m_pszBuf     = pszBuf;
        m_stBufSize += stSize;
    }
    else
    {
        m_fFrozen = TRUE;
    }

    return;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Member:     freeze, public (_DEBUG only)
//
//  Synopsis:   freeze the buffer by throwing the flag
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    BOOL - whether buffer was frozen (we are alway successful)
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

BOOL dbgstream::freeze()
{
    m_fFrozen = TRUE;
    return TRUE;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Member:     unfreeze, public (_DEBUG only)
//
//  Synopsis:   unfreeze the buffer
//
//  Effects:    if buffer size = 0, allocate the buffer
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    BOOL - whether successful
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Feb-95 t-ScottH  author
//
//  Notes:
//      buffer may be frozen if no memory, so try to allocate buffer if NULL
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

BOOL dbgstream::unfreeze()
{
    if (m_pszBuf == NULL)
    {
        allocate(DEFAULT_INITIAL_ALLOC);
        if (m_pszBuf == NULL)
        {
            return FALSE;
        }
    }
    m_fFrozen = FALSE;

    return TRUE;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Member:     str, public (_DEBUG only)
//
//  Synopsis:   passes the string externally
//
//  Effects:    freezes buffer until unfreeze method is called
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    char * - buffer
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char * dbgstream::str()
{
    m_fFrozen = TRUE;
    return m_pszBuf;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Member:     overloaded operator<<(int), public (_DEBUG only)
//
//  Synopsis:   put int into stream (store in character buffer)
//
//  Effects:
//
//  Arguments:  [i] - integer to put in stream
//
//  Requires:   _itoa
//
//  Returns:    reference to dbgstream (current object)
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

dbgstream& dbgstream::operator<<(int i)
{
    // _itoa - fills up to 17 bytes
    char szBuffer[20];
    const int cch = sizeof(szBuffer) / sizeof(szBuffer[0]);

    if (m_fFrozen == FALSE)
    {
        switch(m_radix)
        {
        case 16: _snprintf(szBuffer, cch, "%x", i); break;
        case 8:  _snprintf(szBuffer, cch, "%o", i); break;
        default: _snprintf(szBuffer, cch, "%d", i); break;
        }
        szBuffer[cch - 1] = '\0';

        return (operator<<(szBuffer));
    }
    return *this;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Member:     overloaded operator<<(long), public (_DEBUG only)
//
//  Synopsis:   put long into stream (store in character buffer)
//
//  Effects:
//
//  Arguments:  [l] - long to put in stream
//
//  Requires:   _ltoa
//
//  Returns:    reference to dbgstream (current object)
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

dbgstream& dbgstream::operator<<(long l)
{
    // _ltoa - up to 33 bytes
    char szBuffer[35];

    if (m_fFrozen == FALSE)
    {
        _ltoa(l, szBuffer, m_radix);
        return (operator<<(szBuffer));
    }
    return *this;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Member:     overloaded operator<<(unsigned long), public (_DEBUG only)
//
//  Synopsis:   put unsigned long into stream (store in character buffer)
//
//  Effects:
//
//  Arguments:  [ul] - long to put in stream
//
//  Requires:   _ultoa
//
//  Returns:    reference to dbgstream (current object)
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

dbgstream& dbgstream::operator<<(unsigned long ul)
{
    // _ltoa - up to 33 bytes
    char szBuffer[35];

    if (m_fFrozen == FALSE)
    {
        _ultoa(ul, szBuffer, m_radix);
        return (operator<<(szBuffer));
    }
    return *this;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Member:     overloaded operator<<(const void *), public (_DEBUG only)
//
//  Synopsis:   put const void* into stream (store in character buffer)
//
//  Effects:    all pointers are inherently void*
//
//  Arguments:  [p] - void * to put in stream
//
//  Requires:   wsprintf
//
//  Returns:    reference to dbgstream (current object)
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Feb-95 t-ScottH  author
//
//  Notes:
//     wsprintf not most efficient, but easy for formatting
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

dbgstream& dbgstream::operator<<(const void *p)
{
    char szBuffer[19];
    const int cch = (sizeof(szBuffer) / sizeof(szBuffer[0])) - 1;

    if (m_fFrozen == FALSE)
    {
        _snprintf(szBuffer, cch, "0x%p", p);
        szBuffer[cch-1] = '\0';

        return (operator<<(szBuffer));
    }
    return *this;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Member:     overloaded operator<<(const char *), public (_DEBUG only)
//
//  Synopsis:   put const char* into stream (store in character buffer)
//
//  Effects:
//
//  Arguments:  [psz] - const char * to put in stream
//
//  Requires:
//
//  Returns:    reference to dbgstream (current object)
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

dbgstream& dbgstream::operator<<(const char *psz)
{
    int i;

    // only if string is not frozen
    if (m_fFrozen == FALSE)
    {
        for (i = 0; psz[i] != '\0'; i++)
        {
            if ((m_stIndex + i) >= (m_stBufSize - 2))
            {
                // if reallocate fails m_fFrozen is TRUE
                reallocate();
                if (m_fFrozen == TRUE)
                {
                    return *this;
                }
            }
            m_pszBuf[m_stIndex + i] = psz[i];
        }
        // ensure that always null terminated string
        m_pszBuf[m_stIndex + i] = '\0';
        m_stIndex += i;
    }
    return *this;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\cachenod.h ===
//+----------------------------------------------------------------------------
//
//	File:
//		cachenode.h
//
//	Classes:
//		CCacheNode
//
//	Functions:
//
//	History:
//              Gopalk         Creation        Aug 23, 1996
//-----------------------------------------------------------------------------

#ifndef _CACHENODE_H_
#define _CACHENODE_H_

#include <olepres.h>

#define CNFLAG_FROZENSTATE  0x00000001 /* In Frozen State */
#define CNFLAG_LOADEDSTATE  0x00000002 /* In Loaded State */
#define CNFLAG_DATAPRESENT  0x00000004 /* Data Present */
#define CNFLAG_NATIVECACHE  0x00000008 /* Native Cache Node */
#define CNFLAG_LOADEDCACHE  0x00000010 /* Loaded Cache Node */
#define CNFLAG_OUTOFMEMORY  0x00000020 /* Out of Memory */

#ifdef _DEBUG
#define CN_PRESOBJ_GEN 0x00000001
#define CN_PRESOBJ_EMF 0x00000010
#define CN_PRESOBJ_MF  0x00000100
#endif // _DEBUG

class CCacheNode
{
public:
    CCacheNode(void);
    CCacheNode(LPFORMATETC lpFormatEtc, DWORD advf, LPSTORAGE pStg);
    CCacheNode(LPFORMATETC lpFormatEtc) {
        CCacheNode(lpFormatEtc, 0, NULL);
    }
    ~CCacheNode();
    void SetClsid(const CLSID& clsid) {
        m_clsid = clsid;
        return;
    }
    CLSID GetClsid(void) {
        return m_clsid;
    }
    LPOLEPRESOBJECT GetPresObj(void) {
        return(m_pPresObj);
    }
    const FORMATETC* GetFormatEtc(void) {
        return(&m_foretc);
    }
    HRESULT SetAdvf(DWORD dwAdvf) {
        m_advf = dwAdvf;
        ClearLoadedStateFlag();
        return NOERROR;
    }
    DWORD GetAdvf(void) {
        return(m_advf);
    }
    HRESULT SetStg(LPSTORAGE pStg);
    void ResetStg(void) {
        m_pStg = NULL;
    }
    LPSTORAGE GetStg(void) {
        return(m_pStg);
    }
    void HandsOffStorage(void) {
        m_pStg = NULL;
        return;
    }
    void SaveCompleted(LPSTORAGE pStgNew) {
        if(pStgNew)
            m_pStg = pStgNew;
        return;
    }
    BOOL InFrozenState() {
        return(m_dwFlags & CNFLAG_FROZENSTATE);
    }
    BOOL InLoadedState() {
        return(m_dwFlags & CNFLAG_LOADEDSTATE);
    }
    BOOL IsBlank() {
        return(!(m_dwFlags & CNFLAG_DATAPRESENT));
    }
    BOOL IsNativeCache() {
        return(m_dwFlags & CNFLAG_NATIVECACHE);
    }
    BOOL IsNormalCache() {
        return(!(m_dwFlags & CNFLAG_NATIVECACHE));
    }
    BOOL IsOutOfMemory() {
        return(m_dwFlags & CNFLAG_OUTOFMEMORY);
    }
    void MakeNativeCache() {
        m_dwFlags |= CNFLAG_NATIVECACHE;
        return;
    }
    void MakeNormalCache() {
        m_dwFlags &= ~CNFLAG_NATIVECACHE;
        return;
    }
    BOOL IsLoadedCache() {
        Win4Assert(IsNormalCache());
        return(m_dwFlags & CNFLAG_LOADEDCACHE);
    }
    void ClearAdviseConnection(void) {
        m_pDataObject = NULL;
        m_dwAdvConnId = 0;
    }
    HRESULT LoadNativeData(void) {
        Win4Assert(IsNativeCache());
        return CreateAndLoadPresObj(FALSE);
    }
    HRESULT LoadPresentation(void) {
        Win4Assert(IsNormalCache());
        return CreateAndLoadPresObj(FALSE);
    }
    HRESULT Load(LPSTREAM lpstream, int iStreamNum, BOOL fDelayLoad);
    HRESULT Save(LPSTORAGE pstgSave, BOOL fSameAsLoad, int iStreamNum);
    HRESULT Update(LPDATAOBJECT pDataObj, DWORD grfUpdf, BOOL& fUpdated);
    HRESULT SetDataWDO(LPFORMATETC lpForetc, LPSTGMEDIUM lpStgmed,
                       BOOL fRelease, BOOL& fUpdated, IDataObject* pdo);
    HRESULT SetData(LPFORMATETC lpForetc, LPSTGMEDIUM lpStgmed, 
                    BOOL fRelease, BOOL& fUpdated) {
        return SetDataWDO(lpForetc, lpStgmed, fRelease, fUpdated, NULL);
    }        
    HRESULT GetExtent(DWORD dwAspect, SIZEL* psize);
    HRESULT CCacheNode::GetData(LPFORMATETC pforetc, LPSTGMEDIUM pmedium);
    HRESULT CCacheNode::GetDataHere(LPFORMATETC pforetc, LPSTGMEDIUM pmedium);
    HRESULT CCacheNode::Draw(void* pvAspect, HDC hicTargetDev, HDC hdcDraw,
                             LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
                             BOOL (CALLBACK *pfnContinue)(ULONG_PTR), ULONG_PTR dwContinue);
    HRESULT CCacheNode::GetColorSet(void* pvAspect, HDC hicTargetDev, 
                                    LPLOGPALETTE* ppColorSet);
    HRESULT Freeze (void);
    HRESULT Unfreeze (BOOL& fUpdated);
    LPSTREAM GetStm(BOOL fSeekToPresBits, DWORD dwStgAccess);
    HRESULT SetupAdviseConnection(LPDATAOBJECT pDataObj, IAdviseSink* pAdviseSink);
    HRESULT TearDownAdviseConnection(LPDATAOBJECT pDataObj);
    HRESULT DiscardPresentation(LPSTREAM pGivenStream=NULL);
    HRESULT SaveTOCEntry(LPSTREAM pStream, BOOL fSameAsLoad);
    HRESULT LoadTOCEntry(LPSTREAM pStream, int& iStreamNum);

    const CCacheNode& operator=(const CCacheNode& rCN);

private:
    CLSID m_clsid;                         // set to clsid of the native object for
                                           // native cache node
    FORMATETC m_foretc;                    // the formatetc for this cache node
    DWORD m_advf;                          // the advise control flags requested
                                           // for this cache node
    long m_lWidth;                         // width of the presentation
    long m_lHeight;                        // height of the presentation
    DWORD m_dwFlags;                       // flags for the cache node
    LPSTORAGE m_pStg;                      // storage containing this presentation
    int m_iStreamNum;                      // presentation stream number
    DWORD m_dwPresBitsPos;                 // byte offset to presentation bits in stream
    DWORD m_dwSavedPresBitsPos;            // byte offset to presentation bits in stream
                                           // saved with fSameAsLoad set to FALSE
    BOOL m_fConvert;                       // set if the presentation is in MAC CfFormat
    LPOLEPRESOBJECT m_pPresObj;            // pres object
    LPOLEPRESOBJECT m_pPresObjAfterFreeze; // pres object that holds changes
                                           // when the main pres object is frozen
    LPDATAOBJECT m_pDataObject;            // data object on which DAdvise is set up
    DWORD m_dwAdvConnId;                   // the connection ID of the above DAdvise
#ifdef _DEBUG
    DWORD m_dwPresFlag;                    // type of pres object
#endif // _DEBUG

    // Private methods
    void Initialize(DWORD advf, LPSTORAGE pStg);
    BOOL QueryFormatSupport(LPDATAOBJECT lpDataObj);
    HRESULT CreateOlePresObj(LPOLEPRESOBJECT* ppPresObj, BOOL fMacPict);
    HRESULT CreateAndLoadPresObj(BOOL fHeaderOnly);
    void SetPresBitsPos(LPSTREAM lpStream,DWORD& dwPresBitsPos);
    void SetFrozenStateFlag() {
        m_dwFlags |= CNFLAG_FROZENSTATE;
        return;
    }
    void ClearFrozenStateFlag() {
        m_dwFlags &= ~CNFLAG_FROZENSTATE;
        return;
    }
    void SetLoadedStateFlag() {
        m_dwFlags |= CNFLAG_LOADEDSTATE;
        return;
    }
    void ClearLoadedStateFlag() {
        m_dwFlags &= ~CNFLAG_LOADEDSTATE;
        return;
    }
    void SetDataPresentFlag() {
        m_dwFlags |= CNFLAG_DATAPRESENT;
        return;
    }
    void ClearDataPresentFlag() {
        m_dwFlags &= ~CNFLAG_DATAPRESENT;
        return;
    }
    void SetOutOfMemoryFlag() {
        m_dwFlags |= CNFLAG_OUTOFMEMORY;
    }
    void SetLoadedCacheFlag() {
        m_dwFlags |= CNFLAG_LOADEDCACHE;
    }
    void ClearLoadedCacheFlag() {
        m_dwFlags &= ~CNFLAG_LOADEDCACHE;
    }
};
typedef CCacheNode *PCACHENODE;
typedef CCacheNode *LPCACHENODE;

#endif // _CACHENODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\clipbrd.h ===
//+----------------------------------------------------------------------------
//
//	File:
//		clipbrd.h
//
//	Contents:
//
//	Classes:
//		CClipDataObject
//
//	Functions:
//
//	History:
//		17/05/94 - AlexGo  - added OleOpenClipboard
//      	16/03/94 - AlexGo  - modified for the rewritten clipboard code.
//		12/08/93 - ChrisWe - continue with file cleanup
//		12/06/93 - ChrisWe - began file cleanup
//
//-----------------------------------------------------------------------------

#ifndef _CLIPBRD_H_
#define _CLIPBRD_H_


// WindowMessage for Delayed DropTarget Marshaling.

const UINT WM_OLE_CLIPBRD_MARSHALDROPTARGET  = (WM_USER + 0);



//+----------------------------------------------------------------------------
//
//	Function:
//		ClipboardInitialize, internal
//
//	Synopsis:
//		Initialize the use of the clipboard.
//
//	Effects:
//		Registers a window class CLIPBRDWNDCLASS.
//
//	Arguments:
//		none
//
//	Returns:
//		TRUE for success; FALSE other wise
//
//	Notes:
//
//	History:
//		12/06/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
BOOL ClipboardInitialize(void);


//+----------------------------------------------------------------------------
//
//	Function:
//		ClipboardUninitialize, internal
//
//	Synopsis:
//		Terminates use of the clipboard by OLE, freeing associated
//		resources.
//
//	Effects:
//		If this is the last reference, unregisters the clipboard
//		window class.
//
//	Arguments:
//		none
//
//	Notes:
//
//	History:
//		12/06/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
void ClipboardUninitialize(void);


// flags used for GetPrivateClipboardWindow

typedef enum tagCLIPWINDOWFLAGS
{
	CLIP_QUERY		= 0,
	CLIP_CREATEIFNOTTHERE	= 1
} CLIPWINDOWFLAGS;

//+-------------------------------------------------------------------------
//
//  Function: 	GetPrivateClipboardWindow
//
//  Synopsis: 	Retrieves (creates if necessary) the private clipboard
//		window associated with the current apartment (thread)
//
//  Effects:
//
//  Arguments:	fCreate		-- if TRUE and no window currently exists,
//				   create one
//
//  Requires:
//
//  Returns:  	HWND
//
//  Signals:
//
//  Modifies:
//
//  Algorithm: 	see description in the code (clipapi.cpp)
//
//  History:    dd-mmm-yy Author    Comment
//		16-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HWND GetPrivateClipboardWindow( CLIPWINDOWFLAGS fFlags );

//+-------------------------------------------------------------------------
//
//  Function:	OleOpenClipboard (internal)
//
//  Synopsis:	Opens the clipboard
//
//  Effects:
//
//  Arguments:	[hClipWnd]	-- open the clipboard with this window
//				   may be NULL.
//		[phClipWnd]	-- where to put the clipboard owner
//				   may be NULL
//
//  Requires:	
//
//  Returns:	NOERROR: the clipboard was opened successfully
//     		CLIPBRD_E_CANT_OPEN: could not open the clipboard
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		17-May-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT OleOpenClipboard( HWND hClipWnd, HWND *phClipWnd );


//+-------------------------------------------------------------------------
//
//  Function:   ClipSetCaptureForDrag
//
//  Synopsis:   Sets mouse capture mode for a drag operation
//
//  Arguments:	[pdrgop] - pointer to object that handles drag operation
//
//  Returns:    S_OK            -- it worked
//              E_FAIL          -- unexpected failure occurred.
//
//  Algorithm:  see description in the code (clipapi.cpp)
//
//  History:    dd-mmm-yy Author    Comment
//		21-Apr-94 ricksa    created
//
//--------------------------------------------------------------------------
class CDragOperation;   // Forward declaration for circular dependencies
HRESULT ClipSetCaptureForDrag(CDragOperation *pdrgop);

//+-------------------------------------------------------------------------
//
//  Function:   ClipReleaseCaptureForDrag
//
//  Synopsis:   Clean up drag mouse capture
//
//  Algorithm:  see description in the code (clipapi.cpp)
//
//  History:    dd-mmm-yy Author    Comment
//		21-Apr-94 ricksa    created
//
//--------------------------------------------------------------------------
void ClipReleaseCaptureForDrag(void);

#endif // _CLIPBRD_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\clipdata.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	clipdata.h
//
//  Contents: 	Declaration of the clipboard data object.
//
//  Classes:	CClipDataObject
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  added Dump methods to CClipDataObject
//                                  and CClipEnumFormatEtc
// 		31-Mar-94 alexgo    author
//
//--------------------------------------------------------------------------

#ifdef _DEBUG
#include <dbgexts.h>
#endif // _DEBUG

#ifndef _CLIPDATA_H
#define _CLIPDATA_H

typedef enum
{
    RESET_AND_FREE = 1,
    JUST_RESET = 2
} FreeResourcesFlags;

typedef enum
{
    FORMAT_NOTFOUND = 1,
    FORMAT_BADMATCH = 2,
    FORMAT_GOODMATCH = 4
} FormatMatchFlag;


// format for an array for FormatEtcs in memory. 

struct FORMATETCDATA
{
    FORMATETC _FormatEtc;
    BOOL fSaveOnFlush; // set to true in Clipboard case if format is valid after OleFlushClipboard.
    DWORD dwReserved1;
    DWORD dwReserved2;
};

#define FETC_OFFER_OLE1                 1
#define FETC_OFFER_OBJLINK              2
#define FETC_PERSIST_DATAOBJ_ON_FLUSH   4

struct FORMATETCDATAARRAY
{
    DWORD	    _dwSig;  // must be zero.	
    DWORD	    _dwSize; // total size of structure.
    ULONG	    _cRefs; // Number of references held on Data.
    DWORD	    _cFormats; // number of formats in the enumerator.
    DWORD	    _dwMiscArrayFlags;
    BOOL	    _fIs64BitArray;
    FORMATETCDATA   _FormatEtcData[1];
};


//
// Methods and types used for 32/64 bit FORMATETC interop
//

#ifdef _WIN64
#define IS_WIN64 TRUE
#else
#define IS_WIN64 FALSE
#endif

void GetCopiedFormatEtcDataArraySize (
	FORMATETCDATAARRAY* pClipFormatEtcDataArray, 
	size_t* pstSize
	);

void CopyFormatEtcDataArray (
	FORMATETCDATAARRAY* pClipFormatEtcDataArray, 
	FORMATETCDATAARRAY* pFormatEtcDataArray, 
	size_t stSize, 
	BOOL bCheckAvailable
	);

typedef struct FARSTRUCT tagFORMATETC32
{
    CLIPFORMAT          cfFormat;
    ULONG				ptd;
    DWORD               dwAspect;
    LONG                lindex;
    DWORD               tymed;
} FORMATETC32, FAR* LPFORMATETC32;

typedef struct FARSTRUCT tagFORMATETC64
{
    CLIPFORMAT          cfFormat;
    ULONG64				ptd;
    DWORD               dwAspect;
    LONG                lindex;
    DWORD               tymed;
} FORMATETC64, FAR* LPFORMATETC64;

struct FORMATETCDATA32
{
    FORMATETC32 _FormatEtc;
    BOOL fSaveOnFlush; // set to true in Clipboard case if format is valid after OleFlushClipboard.
    DWORD dwReserved1;
    DWORD dwReserved2;
};

struct FORMATETCDATA64
{
    FORMATETC64 _FormatEtc;
    BOOL fSaveOnFlush; // set to true in Clipboard case if format is valid after OleFlushClipboard.
    DWORD dwReserved1;
    DWORD dwReserved2;
};

struct FORMATETCDATAARRAY32
{
    DWORD	    _dwSig;  // must be zero.	
    DWORD	    _dwSize; // total size of structure.
    ULONG	    _cRefs; // Number of references held on Data.
    DWORD	    _cFormats; // number of formats in the enumerator.
    DWORD	    _dwMiscArrayFlags;
    BOOL	    _fIs64BitArray;
    FORMATETCDATA32   _FormatEtcData[1];
};

struct FORMATETCDATAARRAY64
{
    DWORD	    _dwSig;  // must be zero.	
    DWORD	    _dwSize; // total size of structure.
    ULONG	    _cRefs; // Number of references held on Data.
    DWORD	    _cFormats; // number of formats in the enumerator.
    DWORD	    _dwMiscArrayFlags;
    BOOL	    _fIs64BitArray;
    FORMATETCDATA64   _FormatEtcData[1];
};


//+-------------------------------------------------------------------------
//
//  Class:	CClipDataObject
//
//  Purpose: 	clipboard data object
//
//  Interface: 	IDataObject
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  added Dump method (_DEBUG only)
//		04-Jun-94 alexgo    added OLE1 support
// 		31-Mar-94 alexgo    author
//
//  Notes:	See clipdata.cpp for a description of OLE1 support
//
//--------------------------------------------------------------------------

class CClipDataObject : public IDataObject, public CPrivAlloc,
    public CThreadCheck
{
    friend void ClipboardUninitialize(void);
    friend void SetClipDataObjectInTLS(IDataObject *pDataObj, 
                    DWORD dwClipSeqNum, BOOL fIsClipWrapper);
    friend void GetClipDataObjectFromTLS(IDataObject **ppDataObj);


   // HACK ALERT!!!  
   // MFC was being slimy, so we have to special case testing against clipboard data
   // objects in OleQueryCreateFromData.  See create.cpp,
   // wQueryEmbedFormats for more details.

    friend WORD wQueryEmbedFormats( LPDATAOBJECT lpSrcDataObj,CLIPFORMAT FAR* lpcfFormat);

public:
    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);

    // IDataObject methods
    STDMETHOD(GetData) (LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium);
    STDMETHOD(GetDataHere) (LPFORMATETC pformatetc,
            LPSTGMEDIUM pmedium);
    STDMETHOD(QueryGetData) (LPFORMATETC pformatetc);
    STDMETHOD(GetCanonicalFormatEtc) (LPFORMATETC pformatetc,
            LPFORMATETC pformatetcOut);
    STDMETHOD(SetData) (LPFORMATETC pformatetc,
            STGMEDIUM FAR* pmedium, BOOL fRelease);
    STDMETHOD(EnumFormatEtc) (DWORD dwDirection,
            LPENUMFORMATETC FAR* ppenumFormatEtc);
    STDMETHOD(DAdvise) (FORMATETC FAR* pFormatetc, DWORD advf,
            IAdviseSink FAR* pAdvSink, DWORD FAR* pdwConnection);
    STDMETHOD(DUnadvise) (DWORD dwConnection);
    STDMETHOD(EnumDAdvise) (LPENUMSTATDATA FAR* ppenumAdvise);

    static HRESULT CClipDataObject::Create(IDataObject **ppDataObj,
                FORMATETCDATAARRAY  *pClipFormatEtcDataArray);

#ifdef _DEBUG

    HRESULT Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel);

    // need to be able to access CClipDataObject private data members in the
    // following debugger extension APIs
    // this allows the debugger extension APIs to copy memory from the
    // debuggee process memory to the debugger's process memory
    // this is required since the Dump method follows pointers to other
    // structures and classes
    friend DEBUG_EXTENSION_API(dump_clipdataobject);

#endif // _DEBUG


private:

    CClipDataObject();		// constructor
    ~CClipDataObject();		// destructor

    ULONG InternalAddRef(); 	// ensure object stays around as long as OLE thinks it should.
    ULONG InternalRelease(); 

    IDataObject * GetRealDataObjPtr();    // Get real data object for clipboard
    HRESULT GetFormatEtcDataArray();    //checks is have a FormatEtcDataArray, if not creates one from the Native Clipboard.
    FormatMatchFlag MatchFormatetc( FORMATETC *pformatetc,BOOL fNativeOnly, TYMED *ptymed );
                    // checks the given formatetc against
                    // the formatetc we know about.

    // the following methods and data items are used for OLE1
    // support
    void		FreeResources( FreeResourcesFlags fFlags );
    HRESULT 		GetAndTranslateOle1( UINT cf, LPOLESTR *ppszClass,
			    LPOLESTR *ppszFile, LPOLESTR *ppszItem,
			    LPSTR *ppszItemA );
    HRESULT		GetEmbeddedObjectFromOle1( STGMEDIUM *pmedium );
    HRESULT		GetEmbedSourceFromOle1( STGMEDIUM *pmedium );
    HRESULT		GetLinkSourceFromOle1( STGMEDIUM *pmedium );
    HRESULT		GetObjectDescriptorFromOle1( UINT cf,
			    STGMEDIUM *pmedium );
    HRESULT		GetOle2FromOle1( UINT cf, STGMEDIUM *pmedium );
    HRESULT		OleGetClipboardData( UINT cf, HANDLE *pHandle );
    BOOL		OleIsClipboardFormatAvailable( UINT cf );

    HGLOBAL		m_hOle1;	// hGlobal to OLE2 data constructed
					// from OLE1 data
    IUnknown *		m_pUnkOle1;	// IUnknown to either a storage or
					// a stream of OLE1 data

    // end of OLE1 support

    ULONG 		m_refs; 	// reference count
    ULONG		m_Internalrefs; // Internal Reference Count

    FORMATETCDATAARRAY  *m_pFormatEtcDataArray;	// Enumerator Data.
    IDataObject *   	m_pDataObject;  // Actual data object for data.
    BOOL		m_fTriedToGetDataObject;
					// indicates whether or not we've
					// tried to get the real IDataObject
					// from the clipboard source
					// (see GetDataObjectForClip)
};


//+-------------------------------------------------------------------------
//
//  Class: 	CEnumFormatEtcDataArray
//
//  Purpose:	Enumerator for the formats available on the clipboard
//		and in DragDrop.
//
//  Interface: 	IEnumFORMATETC
//
//  History:    dd-mmm-yy Author    Comment
// 		30-Sep-96 rogerg    created base on CClipEnumFormatEtc
//
//  Notes:
//
//--------------------------------------------------------------------------

class CEnumFormatEtcDataArray :public IEnumFORMATETC, public CPrivAlloc,
	public CThreadCheck
{
public:
    STDMETHOD(QueryInterface)(REFIID riid, LPLPVOID ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    STDMETHOD(Next) (ULONG celt, FORMATETC *rgelt,
            ULONG *pceltFetched);
    STDMETHOD(Skip) (ULONG celt);
    STDMETHOD(Reset) (void);
    STDMETHOD(Clone) (IEnumFORMATETC **ppenum);

     CEnumFormatEtcDataArray(FORMATETCDATAARRAY *pFormatEtcDataArray,DWORD cOffset);

private:
    ~CEnumFormatEtcDataArray();	// destructor

    ULONG		m_refs;		// reference count
    ULONG		m_cOffset;	// current clipboard format 
    FORMATETCDATAARRAY * m_pFormatEtcDataArray; 
};

#endif // !_CLIPDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\create.h ===
#if !defined( _CREATE_H_ )
#define _CREATE_H_


INTERNAL    wCreateFromData(IDataObject FAR* lpSrcDataObj, REFIID iid, DWORD renderopt, LPFORMATETC lpFormatEtc, IOleClientSite FAR* lpClientSite, IStorage FAR* lpStg, void FAR* FAR* lplpObj);

INTERNAL    wCreateFromDataEx(IDataObject FAR* lpSrcDataObj, REFIID iid, DWORD dwFlags, DWORD renderopt, ULONG cFormats, DWORD FAR* rgAdvf, LPFORMATETC rgFormatEtc, IAdviseSink FAR* lpAdviseSink, DWORD FAR* rgdwConnection, IOleClientSite FAR* lpClientSite, IStorage FAR* lpStg, void FAR* FAR* lplpObj);

INTERNAL    wCreateLink(IMoniker FAR* lpmkSrc, REFCLSID clsidLast, IDataObject FAR* lpSrcDataObj,   REFIID iid, DWORD renderopt, LPFORMATETC lpFormatEtc, IOleClientSite FAR* lpClientSite, IStorage FAR* lpStg, void FAR* FAR* lplpObj);

INTERNAL    wCreateLinkEx(IMoniker FAR* lpmkSrc, REFCLSID clsidLast, IDataObject FAR* lpSrcDataObj, REFIID iid, DWORD dwFlags, DWORD renderopt, ULONG cFormats, DWORD FAR* rgAdvf, LPFORMATETC rgFormatEtc, IAdviseSink FAR* lpAdviseSink, DWORD FAR* rgdwConnection, IOleClientSite FAR* lpClientSite, IStorage FAR* lpStg, void FAR* FAR* lplpObj);

INTERNAL    wCreateObject(CLSID rclsid, BOOL fPermitCodeDownload, REFIID iid, IOleClientSite FAR* lpClientSite,  IStorage FAR* lpstg, WORD wfStorage, void FAR* FAR* ppv);

INTERNAL    wCreateFromFile(LPMONIKER lpmkFile, REFIID iid, DWORD renderopt, LPFORMATETC lpFormatEtc, LPOLECLIENTSITE lpClientSite, LPSTORAGE lpStg, LPLPVOID lplpObj);

INTERNAL    wCreateFromFileEx(LPMONIKER lpmkFile,LPDATAOBJECT lpDataObject, REFIID iid, DWORD dwFlags, DWORD renderopt, ULONG cFormats, DWORD FAR* rgAdvf, LPFORMATETC rgFormatEtc, IAdviseSink FAR* lpAdviseSink, DWORD FAR* rgdwConnection, LPOLECLIENTSITE lpClientSite, LPSTORAGE lpStg, LPLPVOID lplpObj);


INTERNAL    wInitializeCache(IDataObject FAR* lpSrcDataObj, REFCLSID rclsId, DWORD  renderopt, LPFORMATETC lpFormatEtc, void FAR* lpNewObj, BOOL FAR* pfCacheNodeCreated = NULL);

INTERNAL    wInitializeCacheEx(IDataObject FAR* lpSrcDataObj, REFCLSID rclsid, DWORD renderopt, ULONG cFormats, DWORD FAR* rgAdvf, LPFORMATETC rgFormatEtc, IAdviseSink FAR* lpAdviseSink, DWORD FAR* rgdwConnection, void FAR* lpNewObj, BOOL FAR* pfCacheNodeCreated = NULL);

INTERNAL    wGetMonikerAndClassFromFile(LPCOLESTR   lpszFileName, BOOL fLink, LPMONIKER FAR* lplpMoniker, BOOL FAR* lpfPackagerMoniker, CLSID FAR* lpClsid,LPDATAOBJECT* lplpDataObject);

INTERNAL    wCreatePackage(LPDATAOBJECT lpSrcDataObj, REFIID iid, DWORD renderopt, LPFORMATETC lpFormatEtc, LPOLECLIENTSITE lpClientSite, LPSTORAGE lpStg, BOOL fLink, LPLPVOID lplpObj);

INTERNAL    wCreatePackageEx(LPDATAOBJECT lpSrcDataObj, REFIID iid, DWORD dwFlags, DWORD renderopt, ULONG cFormats, DWORD FAR* rgAdvf, LPFORMATETC rgFormatEtc, IAdviseSink FAR* lpAdviseSink, DWORD FAR* rgdwConnection, LPOLECLIENTSITE lpClientSite, LPSTORAGE lpStg, BOOL fLink, LPLPVOID lplpObj);


INTERNAL    wValidateCreateParams(DWORD dwFlags, DWORD renderopt, ULONG cFormats, DWORD FAR* rgAdvf, LPFORMATETC rgFormatEtc, IAdviseSink FAR* lpAdviseSink, DWORD FAR* rgdwConnection, IOleClientSite FAR* lpClientSite, IStorage FAR* lpStg);

INTERNAL    wValidateAdvfEx(ULONG cFormats, DWORD FAR* rgAdvf);

INTERNAL    wValidateFormatEtc(DWORD renderopt, LPFORMATETC lpFormatEtc, LPFORMATETC lpMyFormatEtc);

INTERNAL    wValidateFormatEtcEx(DWORD renderopt, ULONG FAR* lpcFormats, LPFORMATETC rgFormatEtc, LPFORMATETC lpFormatEtc, LPFORMATETC FAR* lplpFormatEtc, LPBOOL lpfAlloced);

INTERNAL    wQueryFormatSupport(LPVOID lpObj, DWORD optrender, LPFORMATETC lpFormatEtc);

INTERNAL    wLoadAndInitObject(IDataObject FAR* lpSrcDataObj, REFIID iid, DWORD renderopt, LPFORMATETC lpFormatEtc, IOleClientSite FAR* lpClientSite, IStorage FAR* lpStg, void FAR* FAR* lplpObj);

INTERNAL    wLoadAndInitObjectEx(IDataObject FAR* lpSrcDataObj, REFIID iid, DWORD renderopt, ULONG cFormats, DWORD FAR* rgAdvf, LPFORMATETC rgFormatEtc, IAdviseSink FAR* lpAdviseSink, DWORD FAR* rgdwConnection, IOleClientSite FAR* lpClientSite, IStorage FAR* lpStg, void FAR* FAR* lplpObj);

INTERNAL    wGetMonikerAndClassFromObject(LPDATAOBJECT lpSrcDataObj, LPMONIKER FAR* lplpmkSrc, CLSID FAR* lpclsid);

INTERNAL    wGetEmbeddedDataObject(LPDATAOBJECT FAR* lplpSrcDataObj, BOOL FAR* lpfRelease, DWORD renderopt, LPSTORAGE lpstgDst);

INTERNAL    wSaveObjectWithoutCommit(LPUNKNOWN lpUnk, LPSTORAGE lpStg, BOOL fSameAsLoad);

INTERNAL    wStuffIconOfFile(LPCOLESTR lpszFile, BOOL fAddLabel, DWORD renderopt, LPFORMATETC lpforetc, LPUNKNOWN lpUnk);

INTERNAL    wStuffIconOfFileEx(LPCOLESTR lpszFile, BOOL fAddLabel, DWORD renderopt, ULONG cFormats, LPFORMATETC rgFormatEtc, LPUNKNOWN lpUnk);


void        wDoLockUnlock(IUnknown FAR* lpUnknown);

STDAPI      CreatePackagerMoniker (LPCOLESTR lpszPathName, LPMONIKER FAR* ppmk,BOOL fLink);
STDAPI      CreatePackagerMonikerEx (LPCOLESTR lpszPathName,LPMONIKER lpFileMoniker,BOOL fLink,LPMONIKER FAR* ppmk);

INTERNAL    wReturnCreationError(HRESULT hresult);
INTERNAL_(BOOL) wNeedToPackage(REFCLSID rclsid);
INTERNAL_(WORD) wQueryEmbedFormats(LPDATAOBJECT lpSrcDataObj,
                        CLIPFORMAT FAR* lpcfFormat);
INTERNAL_(CLIPFORMAT) wQueryLinkFormats(LPDATAOBJECT lpSrcDataObj);

INTERNAL_(void) wBindIfRunning(LPUNKNOWN lpUnk);
INTERNAL        OleLoadWithoutBinding(LPSTORAGE lpStg, BOOL fPermitCodeDownload, REFIID iid, LPOLECLIENTSITE lpClientSite, LPLPVOID lplpObj);


INTERNAL_(BOOL) wQueryUseCustomLink(REFCLSID clsid);

WINOLEAPI CoCreateErrorInfo(ICreateErrorInfo **ppCreateErrorInfo);

#endif // _CREATE_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\dacache.h ===
//+----------------------------------------------------------------------------
//
//	File:
//		dacache.h
//
//	Classes:
//		CDataAdviseCache
//
//	Functions:
//
//	History:
//              31-Jan-95 t-ScottH  add Dump method to CDataAdviseCache class
//		24-Jan-94 alexgo    first pass at converting to Cairo-style
//				    memory allocation
//		11/02/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#ifndef _DACACHE_H_
#define _DACACHE_H_

#ifdef _DEBUG
#include <dbgexts.h>
#endif // _DEBUG

#include <map_dwdw.h>

//+----------------------------------------------------------------------------
//
//	Class:
//		CDataAdviseCache
//
//	Purpose:
//		A CDataAdviseCache is used to remember data advises across
//		loaded<-->running transitions.  The data advise cache holds
//		on to advise sinks that are interested in data, even if there
//		is no data object, because the server is not activated.
//		These advise sinks can be registered with a running data object
//		later on, when it is activated, or they can be Unadvised()
//		if the object is to go inactive.
//
//	Interface:
//		Advise - add a new advise sink for the indicated data object,
//			if there is one; if no data object, record the
//			advise sink for future use
//
//		Unadvise - remove an advise sink from the advise sink cache,
//			and from the data object, if there is one
//
//		EnumAdvise - enumerate all the registered advise sinks
//
//		ClientToDelegate - Maps a client connection number to a
//			delegate connection number.  Client connection numbers
//			are those returned by Advise(), while the delegate
//			connection numbers are those used by the data object
//			itself.
//
//		EnumAndAdvise - A data object has become newly active (or
//			has just been deactivated.)  This will enumerate all
//			the registered advise sinks, and call Advise() (or
//			Unadvise()) on the data object.
//
//		CreateDataAdviseCache - creates an instance of the
//			CDataAdviseCache; there is no public constructor,
//			because internal data structures must be allocated,
//			and these allocations could fail.  There is no way
//			to indicate such a failure when using "new," so
//			clients are required to use this function instead.
//
//		~CDataAdviseCache
//
//	Notes:
//		This is an internal helper class, and does not support any
//		interfaces.
//
//		Because a connection number must be returned even in the loaded
//		state, there must be two sets of connection numbers: client
//		numbers are "fake" connection numbers returned to the caller;
//		delegate numbers are those returned by the "real" running
//		object.  We maintain a map from client numbers to delegate
//		numbers.  If not running, our client numbers map to zero.
//		Client numbers also map to zero if the delegate refused the
//		Advise when it began to run.  We use a DWORD->DWORD map.
//
//	History:
//              31-Jan-95 t-ScottH  add Dump method (_DEBUG only)
//		11/02/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

class FAR CDataAdviseCache : public CPrivAlloc
{
public:
	HRESULT Advise(LPDATAOBJECT pDataObject, FORMATETC FAR* pFetc,
		DWORD advf, LPADVISESINK pAdvise,
		DWORD FAR* pdwClient);
	// first 4 parms are as in DataObject::Advise
	HRESULT Unadvise(IDataObject FAR* pDataObject, DWORD dwClient);
	HRESULT EnumAdvise(LPENUMSTATDATA FAR* ppenumAdvise);
	HRESULT EnumAndAdvise(LPDATAOBJECT pDataObject, BOOL fAdvise);
	// Advise or Unadvise

	static FARINTERNAL CreateDataAdviseCache(
			class CDataAdviseCache FAR* FAR* ppDataAdvCache);
	~CDataAdviseCache();
	
    #ifdef _DEBUG
        HRESULT Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel);

        // need to be able to access CDataAdviseCache private data members
        // in the following debugger extension APIs
        // this allows the debugger extension APIs to copy memory from the
        // debuggee process memory to the debugger's process memory
        // this is required since the Dump method follows pointers to other
        // structures and classes
        friend DEBUG_EXTENSION_API(dump_defobject);
        friend DEBUG_EXTENSION_API(dump_deflink);
        friend DEBUG_EXTENSION_API(dump_dataadvisecache);
    #endif // _DEBUG

private:
	CDataAdviseCache();
	HRESULT ClientToDelegate(DWORD dwClient, DWORD FAR* pdwDelegate);

	LPDATAADVISEHOLDER m_pDAH; // a data advise holder
	CMapDwordDword m_mapClientToDelegate; // the map of clients to delegates

};

typedef class CDataAdviseCache DATAADVCACHE;
typedef DATAADVCACHE FAR* LPDATAADVCACHE;

#endif // _DACACHE_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\dbgdump.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//
//--------------------------------------------------------------------------

#ifndef _DBGDUMP_H
#define _DBGDUMP_H

#include <le2int.h>
#include <olecache.h>
#include <olepres.h>
#include <oaholder.h>
#include <dacache.h>
#include <memstm.h>
#include <dstream.h>

#define DEB_VERBOSE 0x10000000
#define NO_PREFIX   0x00000000

#define DUMPTAB "    "


extern const char szDumpErrorMessage[];
extern const char szDumpBadPtr[];

class CEnumSTATDATA;
class CCacheEnumFormatEtc;
class CClipDataObject;
class CClipEnumFormatEtc;
class CDefClassFactory;
class CDefObject;
class CDefLink;
class CEMfObject;
class CMfObject;
class CGenObject;
class CEnumFmt;
class CEnumFmt10;
class CEnumVerb;

// Dump structures which fit on one line and prefix not required
// NOTE: there is no newline character a the end of these char arrays
extern char *DumpADVFFlags(DWORD dwAdvf);

extern char *DumpATOM(ATOM atom);

extern char *DumpCLSID(REFCLSID clsid);

extern char *DumpCLIPFORMAT(CLIPFORMAT clipformat);

extern char *DumpCMutexSem(CMutexSem2 *pCMS);

extern char *DumpDVASPECTFlags(DWORD dwAspect);

extern char *DumpFILETIME(FILETIME *pFT);

extern char *DumpHRESULT(HRESULT hresult);

extern char *DumpMonikerDisplayName(IMoniker *pMoniker);

extern char *DumpWIN32Error(DWORD dwError);

// Dump structures which may be multiple lines - take care of prefixes
// NOTE: the following dumps have newline characters throughout and at the end
//extern char *DumpCACHELIST_ITEM(CACHELIST_ITEM *pCLI, ULONG ulFlag, int nIndentLevel);

//extern char *DumpCCacheEnum(CCacheEnum *pCE, ULONG ulFlag, int nIndentLevel);

//extern char *DumpCCacheEnumFormatEtc(CCacheEnumFormatEtc *pCEFE, ULONG ulFlag, int nIndentLevel);

//extern char *DumpCCacheNode(CCacheNode *pCN, ULONG ulFlag, int nIndentLevel);

extern char *DumpCClipDataObject(CClipDataObject *pCDO, ULONG ulFLag, int nIndentLevel);

extern char *DumpCClipEnumFormatEtc(CClipEnumFormatEtc *pCEFE, ULONG ulFlag, int nIndentLevel);

extern char *DumpCDAHolder(IDataAdviseHolder *pIDAH, ULONG ulFlag, int nIndentLevel);

extern char *DumpCDataAdviseCache(CDataAdviseCache *pDAC, ULONG ulFlag, int nIndentLevel);

extern char *DumpCDefClassFactory(CDefClassFactory *pDCF, ULONG ulFlag, int nIndentLevel);

extern char *DumpCDefLink(CDefLink *pDL, ULONG ulFlag, int nIndentLevel);

extern char *DumpCDefObject(CDefObject *pDO, ULONG ulFlag, int nIndentLevel);

extern char *DumpCEMfObject(CEMfObject *pEMFO, ULONG ulFlag, int nIndentLevel);

extern char *DumpCEnumFmt(CEnumFmt *pEF, ULONG ulFlag, int nIndentLevel);

extern char *DumpCEnumFmt10(CEnumFmt10 *pEF, ULONG ulFlag, int nIndentLevel);

extern char *DumpCEnumSTATDATA(CEnumSTATDATA *pESD, ULONG ulFlag, int nIndentLevel);

extern char *DumpCEnumVerb(CEnumVerb *pEV, ULONG ulFlag, int nIndentLevel);

extern char *DumpCGenObject(CGenObject *pGO, ULONG ulFlag, int nIndentLevel);

extern char *DumpCMapDwordDword(CMapDwordDword *pMDD, ULONG ulFlag, int nIndentLevel);

extern char *DumpCMemBytes(CMemBytes *pMB, ULONG ulFlag, int nIndentLevel);

extern char *DumpCMemStm(CMemStm *pMS, ULONG ulFlag, int nIndentLevel);

extern char *DumpCMfObject(CMfObject *pMFO, ULONG ulFlag, int nIndentLevel);

extern char *DumpCOAHolder(COAHolder *pOAH, ULONG ulFlag, int nIndentLevel);

extern char *DumpCOleCache(COleCache *pOC, ULONG ulFlag, int nIndentLevel);

extern char *DumpCSafeRefCount(CSafeRefCount *pSRC, ULONG ulFlag, int nIndentLevel);

extern char *DumpCThreadCheck(CThreadCheck *pTC, ULONG ulFlag, int nIndentLevel);

extern char *DumpFORMATETC(FORMATETC *pFE, ULONG ulFlag, int nIndentLevel);

extern char *DumpIOlePresObj(IOlePresObj *pIPO, ULONG ulFlag, int nIndentLevel);

extern char *DumpMEMSTM(MEMSTM *pMS, ULONG ulFlag, int nIndentLevel);

extern char *DumpSTATDATA(STATDATA *pSD, ULONG ulFlag, int nIndentLevel);

extern char *DumpSTGMEDIUM(STGMEDIUM *pSM, ULONG ulFlag, int nIndentLevel);

#endif // _DBGDUMP_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\dbgexts.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dbgexts.h
//
//  Contents:   macro for declaration of debugger extensions for friend
//              to each class
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              03-Feb-95 t-ScottH  author
//
//--------------------------------------------------------------------------

#ifndef _DBGEXTS_H_
#define _DBGEXTS_H_

#include <ntsdexts.h>

#define DEBUG_EXTENSION_API(s)                      \
        void                                        \
        s(                                          \
            HANDLE               hCurrentProcess,   \
            HANDLE               hCurrentThread,    \
            DWORD                dwCurrentPc,       \
            PNTSD_EXTENSION_APIS lpExtensionApis,   \
            LPSTR                args               \
            )

#endif // _DBGEXTS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\daholder.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       daholder.h
//
//  Contents:   CDAHolder, concrete version of IDataAdviseHolder
//
//  Classes:    CDAHolder
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-95 t-ScottH  created - split class definition from
//                                  cpp file (for debug purposes)
//                                  - added Dump method to CDAHolder
//
//--------------------------------------------------------------------------

#ifndef _DAHOLDER_H_
#define _DAHOLDER_H_

#ifdef _DEBUG
#include <dbgexts.h>
#endif // _DEBUG

//+----------------------------------------------------------------------------
//
//	Class:
//		CDAHolder
//
//	Purpose:
//		provides concrete implementation of IDataAdviseHolder
//
//	Interface:
//		IDataAdviseHolder
//
//	Notes:
//		REVIEW, not thread safe, under assumption that docs cant be MT
//
//		Connections are numbered from [1..infinity).  We don't use
//		zero to avoid getting caught on someone else's zero init'ed
//		memory.  Zero is checked for as a connection number on entry
//		to routines, and rejected.  This allows us to use zero as
//		a way to mark unused STATDATA entries in our array.
//
//	History:
//              06-Feb-95 t-Scotth  added Dump method (_DEBUG only)
//		01/24/94 - AlexGo  - now inherit from CPrivAlloc
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

// NOTE:    CDAHolder MUST inherit from IDataAdviseHolder first in order for the
//          DumpCDAHolder function to work since we cast the IDataAdviseHolder as a
//          CDAHolder (if it inherits from IDataAdviseHolder first, then the pointers
//          are the same)

class FAR CDAHolder : public IDataAdviseHolder, public CSafeRefCount
{
public:
	CDAHolder();

	// *** IUnknown methods ***
	STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppv);
	STDMETHOD_(ULONG,AddRef) () ;
	STDMETHOD_(ULONG,Release) ();
	
	// *** IDataAdviseHolder methods ***
	STDMETHOD(Advise)(LPDATAOBJECT pDataObj, FORMATETC FAR* pFetc,
			DWORD advf, IAdviseSink FAR* pAdvSink,
			DWORD FAR* pdwConnection);
	STDMETHOD(Unadvise)(DWORD dwConnection);
	STDMETHOD(EnumAdvise)(IEnumSTATDATA FAR* FAR* ppenumAdvise);

	STDMETHOD(SendOnDataChange)(IDataObject FAR* pDataObject,
			DWORD dwReserved, DWORD advf);

        // *** debug and dump methods ***
    #ifdef _DEBUG

        HRESULT Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel);

        // need to be able to access CDAHolder private data members in the
        // following debugger extension APIs
        // this allows the debugger extension APIs to copy memory from the
        // debuggee process memory to the debugger's process memory
        // this is required since the Dump method follows pointers to other
        // structures and classes
        friend DEBUG_EXTENSION_API(dump_daholder);
        friend DEBUG_EXTENSION_API(dump_enumstatdata);
        friend DEBUG_EXTENSION_API(dump_dataadvisecache);
        friend DEBUG_EXTENSION_API(dump_defobject);
        friend DEBUG_EXTENSION_API(dump_deflink);

    #endif // _DEBUG

private:
	~CDAHolder();


	DWORD m_dwConnection; // next connection number to use
	int m_iSize; // number of stat data elements in array
	STATDATA FAR *m_pSD; // array of STATDATA elements
#define CDAHOLDER_GROWBY 5 /* number of entries to grow array by each time */

	SET_A5;

	// the enumerator returned by the EnumAdvise method
	friend class CEnumSTATDATA;
};

//+----------------------------------------------------------------------------
//
//	Class:
//		CEnumSTATDATA
//
//	Purpose:
//		is the enumerator returned by CDAHolder::Enum
//
//	Interface:
//		IEnumSTATDATA
//
//	Notes:
//		Keeps the underlying CDAHolder alive for the lifetime of
//		the enumerator.
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

class CEnumSTATDATA : public IEnumSTATDATA, public CPrivAlloc
{
public:
	CEnumSTATDATA(CDAHolder FAR* pHolder, int iDataStart);

	// *** IUnknown methods ***
	STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppv);
	STDMETHOD_(ULONG,AddRef)() ;
	STDMETHOD_(ULONG,Release)();

	// *** IEnumSTATDATA methods ***
	STDMETHOD(Next)(ULONG celt, STATDATA FAR * rgelt,
			ULONG FAR* pceltFetched);
	STDMETHOD(Skip)(ULONG celt);
	STDMETHOD(Reset)();
	STDMETHOD(Clone)(LPENUMSTATDATA FAR* ppenum);

    #ifdef _DEBUG

        HRESULT Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel);


        // need to be able to access CEnumSTATDATA private data members in the
        // following debugger extension APIs
        // this allows the debugger extension APIs to copy memory from the
        // debuggee process memory to the debugger's process memory
        // this is required since the Dump method follows pointers to other
        // structures and classes
        friend DEBUG_EXTENSION_API(dump_enumstatdata);

    #endif // _DEBUG

private:
	~CEnumSTATDATA();

	ULONG m_refs; // reference count
	int m_iDataEnum; // index of the next element to return

	CDAHolder FAR* m_pHolder; // pointer to holder; is ref counted

	SET_A5;
};



#endif // _DAHOLDER_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\dstream.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dstream.h
//
//  Contents:   internal debugging support (debug stream which builds a string)
//
//  Classes:    dbgstream
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              09-Feb-95 t-ScottH  author
//
//--------------------------------------------------------------------------

#ifndef _STREAM_H_
#define _STREAM_H_

//+-------------------------------------------------------------------------
//
//  Class:      dbgstream (_DEBUG only)
//
//  Purpose:    a stream which builds a string for debugging purposes
//              (used to build a string in Dump methods of LE objects such
//              that the character array can be passed off in debugger extensions
//              or used by call tracing)
//
//  Interface:  private:
//                  allocate(DWORD)
//                  free()
//                  reallocate()
//                  reallocate(DWORD)
//                  init()
//              public:
//                  dbgstream(DWORD)
//                  dbgstream()
//                  ~dbgstream()
//                  hex()
//                  oct()
//                  dec()
//                  precision()
//                  freeze()
//                  unfreeze()
//                  str()
//                  operator<<(const void *)
//                  operator<<(const char *)
//                  operator<<(const unsigned char *)
//                  operator<<(const signed char *)
//                  operator<<(int)
//                  operator<<(unsigned int)
//                  operator<<(long)
//                  operator<<(unsigned long)
//                  operator<<(float)
//
//  History:    dd-mmm-yy Author    Comment
//              11-Feb-95 t-ScottH  author
//
//  Notes:
//      This is simple, efficient implementation of the CRT ostrstream. The
//      ostrstream was found to have too much overhead and thus performance
//      was terrible (in the debugger extensions almost a 5-10x slower) than
//      this implementation
//
//      this implementation differs from the ostrstream class
//      - no need to append a null character to the string (the string ALWAYS
//        maintains a null character at the end of the string)
//      - implementation uses CoTaskMem[Alloc, Free, Realloc] for memory
//        management. Therefore, all strings passes out externally must also
//        use CoTaskMem[Alloc, Free, Realloc] for memory management
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

#define DEFAULT_INITIAL_ALLOC   300
#define DEFAULT_GROWBY          100

#define DEFAULT_RADIX           10
#define DEFAULT_PRECISION       6

#define endl "\n"
#define ends "\0"

class dbgstream
{
    private:
        // *** data members ***

        // pointer to last character in buffer
        SIZE_T  m_stIndex;

        // maximum size of current buffer
        SIZE_T  m_stBufSize;

        // if TRUE -> cannot change buffer
        BOOL    m_fFrozen;

        // buffer
        char    *m_pszBuf;

        // hex, dec, or oct for storing ints or longs
        int     m_radix;

        // precision for doubles and floats
        int     m_precision;


        // *** private methods ***
        void    allocate(SIZE_T stSize);
        void    reallocate(SIZE_T stSize);
        void    reallocate();
        void    free();

        void    init();

    public:
        // *** constructors and destructor ***
        dbgstream(SIZE_T stSize);
        dbgstream();

        ~dbgstream();

        // *** public interface ***
        char    *str();

        BOOL    freeze();
        BOOL    unfreeze();

        void    hex() {m_radix = 16;}
        void    dec() {m_radix = 10;}
        void    oct() {m_radix = 8; }

        void    precision(int p) {m_precision = p;}

        dbgstream& dbgstream::operator<<(int i);
        dbgstream& dbgstream::operator<<(unsigned int ui)
            {
                return (operator<<((unsigned long)ui));
            }
        dbgstream& dbgstream::operator<<(long l);
        dbgstream& dbgstream::operator<<(unsigned long ul);

        dbgstream& dbgstream::operator<<(const void *p);

        dbgstream& dbgstream::operator<<(const char *psz);
        dbgstream& dbgstream::operator<<(const unsigned char *psz)
            {
                return (operator<<((const char *)psz));
            }
        dbgstream& dbgstream::operator<<(const signed char *psz)
            {
                return (operator<<((const char *)psz));
            }

};

#endif // _DEBUG

#endif // _STREAM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\empty.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       empty.cxx
//
//  Contents:   This file is used as a target for building the precompiled
//		header. It is not linked into the product.
//  Classes:
//
//  Functions:
//
//  History:    6-22-94   kevinro   Created
//
//----------------------------------------------------------------------------

#include <le2int.h>

#pragma hdrstop

void VoidFunc()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\enumgen.h ===
/****************************** Module Header ******************************\
* Module Name: ENUMGEN.H
*
* This module contains structure definitions for the enumerator class.
*
* Created: 8-July-1992
*
* Copyright (c) 1985 - 1992  Microsoft Corporation
*
* History:
*   Created by TonyKit
*
\***************************************************************************/

#ifndef __ENUMGEN_H__
#define __ENUMGEN_H__


/****** Generic Enumerator Interface ****************************************/

#define LPENUMGENERIC     IEnumGeneric FAR*

#undef  INTERFACE
#define INTERFACE   IEnumGeneric

DECLARE_INTERFACE_(IEnumGeneric, IUnknown)
{
    //*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    //*** IEnumerator methods ***/
    STDMETHOD(Next) (THIS_ ULONG celt,
                     LPVOID pArrayObjs, 
                     ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ LPENUMGENERIC FAR* ppenm) PURE;

    //*** helper methods ***/
    STDMETHOD(UpdateEnumerator)(THIS_ REFIID riid, DWORD dwCurrent,
                                DWORD dwNew) PURE;
    STDMETHOD(SetCurrent) (THIS_ DWORD dwCurrent) PURE;
    STDMETHOD(SetNext) (THIS_ LPENUMGENERIC pEnumGenNext) PURE;
    STDMETHOD(GetNext) (THIS_ LPENUMGENERIC FAR* ppEnumGenNext) PURE;
    STDMETHOD(SetPrev) (THIS_ LPENUMGENERIC pEnumGenPrev) PURE;
    STDMETHOD(GetPrev) (THIS_ LPENUMGENERIC FAR* ppEnumGenPrev) PURE;
};


/****** Generic Enumerator Callback Interface *****************************/

#define LPENUMCALLBACK     IEnumCallback FAR*

#undef  INTERFACE
#define INTERFACE   IEnumCallback

DECLARE_INTERFACE_(IEnumCallback, IUnknown)
{
    //*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    //*** IEnumCallback methods ***/
    STDMETHOD(Next) (THIS_ DWORD FAR* pdwCurrent,DWORD dwInfo,
                     LPVOID FAR* ppNext) PURE;
    STDMETHOD(Skip) (THIS_ DWORD FAR* pdwCurrent,DWORD dwInfo) PURE;
    STDMETHOD(Reset) (THIS_ DWORD FAR* pdwCurrent) PURE;
    STDMETHOD(Clone) (THIS_ DWORD FAR* pdwCurrent) PURE;
    STDMETHOD(Destroy) (THIS_ DWORD dwCurrent) PURE;
};


/****** Generic Enumerator Holder Interface ******************************/

#define LPENUMHOLDER     IEnumHolder FAR*

#undef  INTERFACE
#define INTERFACE   IEnumHolder

DECLARE_INTERFACE_(IEnumHolder, IUnknown)
{
    //*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    //*** IEnumHolder methods ***/

    STDMETHOD(CreateEnumerator)(THIS_ REFIID riid, DWORD dwInfo,
                                LPENUMCALLBACK pEnumCallback,
                                LPVOID FAR* ppGenericEnumerator) PURE;
    STDMETHOD(UpdateEnumerators)(THIS_ REFIID riid, DWORD dwCurrent,
                                 DWORD dwNew) PURE;
    STDMETHOD(RemoveEnumerator)(THIS_ LPENUMGENERIC pEnumGeneric) PURE;
    STDMETHOD(EnumeratorCount)(THIS_ WORD FAR* pwCount) PURE;
};


STDAPI CreateEnumHolder(LPENUMHOLDER FAR* ppEnumHolder);


/****** CEnumList class *************************************/

class FAR CEnumHolder : public IEnumHolder, public CPrivAlloc  {
public:
    //*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (REFIID riid, LPLPVOID ppvObj);
    STDMETHOD_(ULONG,AddRef) ();
    STDMETHOD_(ULONG,Release) ();

    //*** IEnumHolder methods ***/
    STDMETHOD(CreateEnumerator)(REFIID riid, DWORD dwInfo,
                                LPENUMCALLBACK pEnumCallback,
                                LPLPVOID ppGenericEnumerator);
    STDMETHOD(UpdateEnumerators)(REFIID riid, DWORD dwCurrent,
                                 DWORD dwNew);
    STDMETHOD(RemoveEnumerator)(LPENUMGENERIC pEnumGeneric);
    STDMETHOD(EnumeratorCount)(WORD FAR* pwCount); 

    STDSTATIC_(CEnumHolder FAR*) Create(void);

ctor_dtor:
    CEnumHolder() { GET_A5(); m_nCount = 0; m_refs = 0; m_pFirst = NULL; m_pLast  = NULL; }
    ~CEnumHolder() {}

private:
    ULONG m_refs;
    WORD m_nCount;
    LPENUMGENERIC m_pFirst;
    LPENUMGENERIC m_pLast;
	SET_A5;
};


/****** CEnumGeneric class *************************************/

class FAR CEnumGeneric : public IEnumGeneric  {
public:
    //*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (REFIID riid, LPLPVOID ppvObj);
    STDMETHOD_(ULONG,AddRef) ();
    STDMETHOD_(ULONG,Release) ();

    //*** IEnumGeneric methods ***/
    STDMETHOD(Next) (ULONG celt, LPVOID pArrayObjs, ULONG FAR* pceltFetched);
    STDMETHOD(Skip) (ULONG celt);
    STDMETHOD(Reset) ();
    STDMETHOD(Clone) (LPENUMGENERIC FAR* ppenm);

    //*** helper methods ***/
    STDMETHOD(UpdateEnumerator)(REFIID riid, DWORD dwCurrent, DWORD dwNew);
    STDMETHOD(SetCurrent) (DWORD dwCurrent);
    STDMETHOD(SetNext)(LPENUMGENERIC pNext);
    STDMETHOD(GetNext)(LPENUMGENERIC FAR* ppNext);
    STDMETHOD(SetPrev)(LPENUMGENERIC pPrev);
    STDMETHOD(GetPrev)(LPENUMGENERIC FAR* ppPrev);

    STDSTATIC_(CEnumGeneric FAR*) Create(LPENUMHOLDER pEnumHolder, REFIID riid,
                                   DWORD dwInfo, LPENUMCALLBACK pEnumCallback);
ctor_dtor:
    CEnumGeneric() { GET_A5(); m_refs = 0; m_dwCurrent = 0; m_pNext = m_pPrev = NULL; }
    ~CEnumGeneric() {}

private:
    IID m_iid;
    ULONG m_refs; // referance count, when 0 this object goes away
    DWORD m_dwCurrent; 
    DWORD m_dwDirection; // extra information for enumerator
    LPENUMCALLBACK m_pEnumCallback; // callback proc to get the next element
    LPENUMHOLDER m_pParent;  // pointer to the list which owns this object
    LPENUMGENERIC m_pNext; // pointer to the next guy in the list
    LPENUMGENERIC m_pPrev; // pointer to the prev guy in the list
	SET_A5;
};  


#endif // __ENUMGEN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\emf.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       emf.h
//
//  Contents:   Declaration of CEMfObject
//
//  Classes:    CEMfObject
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  add Dump method to CEMfObject
//              12-May-94 DavePl    created
//
//--------------------------------------------------------------------------

#include "olepres.h"
#include "olecache.h"
#include "cachenod.h"

// The following number adjusts the count of records processed by
// our EMF enumeration function before the user's callback function
// is run.

#define EMF_RECORD_COUNT 20

// Enumeration to indicate which format a hEMF is to be serialized as.
// Values are not indicative of anything, just non-zero and non-one to
// make it easier to catch bogus values while debugging

typedef enum tagEMFWRITETYPE
{
	WRITE_AS_WMF = 13,
	WRITE_AS_EMF = 17
} EMFWRITETYPE;


//+-------------------------------------------------------------------------
//
//  Class:      CEMfObject
//
//  Purpose:    Enhanced Metafile presentation object
//
//  Interface:  IOlePresObj
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  add Dump method (_DEBUG only) (this method
//                                  is also a method in IOlePresObj
//              12-May-94 DavePl    Created
//
//--------------------------------------------------------------------------

class FAR CEMfObject : public IOlePresObj, public CPrivAlloc
{
public:
	CEMfObject(LPCACHENODE pCacheNode, DWORD dwAspect);
	~CEMfObject();

	STDMETHOD (QueryInterface)      (THIS_ REFIID riid,
					 void ** ppvObj);

	STDMETHOD_(ULONG,AddRef)        (THIS);

	STDMETHOD_(ULONG,Release)       (THIS);

	STDMETHOD (GetData)             (THIS_ LPFORMATETC pformatetcIn,
					 LPSTGMEDIUM pmedium );

	STDMETHOD (GetDataHere)         (THIS_ LPFORMATETC pformatetcIn,
					 LPSTGMEDIUM pmedium );
	
	STDMETHOD (SetDataWDO)          (THIS_ LPFORMATETC pformatetc,
					 STGMEDIUM FAR * pmedium,
					 BOOL fRelease, IDataObject * pdo);
	
	STDMETHOD (Draw)                (THIS_ void * pvAspect,
					 HDC hicTargetDev,
					 HDC hdcDraw,
					 LPCRECTL lprcBounds,
					 LPCRECTL lprcWBounds,
					 int (CALLBACK * pfnContinue)(ULONG_PTR),
					 ULONG_PTR dwContinue);
			
	
	STDMETHOD (Load)                (THIS_ LPSTREAM pstm,
					 BOOL fReadHeaderOnly);

	STDMETHOD (Save)                (THIS_ LPSTREAM pstm);

	STDMETHOD (GetExtent)           (THIS_ DWORD dwAspect,
					 LPSIZEL lpsizel);
		
	STDMETHOD (GetColorSet)         (void * pvAspect,
					 HDC hicTargetDev,
					 LPLOGPALETTE * ppColorSet);

	STDMETHOD_(BOOL, IsBlank) (void);

	STDMETHOD_(void, DiscardHPRES) (void);

	int CALLBACK CallbackFuncForDraw (HDC hdc,
					 HANDLETABLE * lpHTable,
					 const ENHMETARECORD * lpEMFR,
					 int nObj,
					 LPARAM lpobj);
	
    #ifdef _DEBUG
        STDMETHOD(Dump) (THIS_ char **ppszDump, ULONG ulFlag, int nIndentLevel);
    #endif // _DEBUG
	
private:

	INTERNAL                ChangeData      (HENHMETAFILE hEMfp, BOOL fDelete);
	INTERNAL_(HENHMETAFILE) LoadHPRES       (void);
	INTERNAL_(HENHMETAFILE) GetCopyOfHPRES  (void);
	inline HENHMETAFILE     M_HPRES(void);
	
	ULONG                   m_ulRefs;
	HENHMETAFILE            m_hPres;

	BOOL                    m_fMetaDC;
	int                     m_nRecord;
	HRESULT                 m_error;
	LPLOGPALETTE            m_pColorSet;
	

	int (CALLBACK * m_pfnContinue)(ULONG_PTR);
	
	ULONG_PTR               m_dwContinue;
	DWORD                   m_dwAspect;
	DWORD                   m_dwSize;
	LONG                    m_lWidth;
	LONG                    m_lHeight;
	LPCACHENODE             m_pCacheNode;
};
	
// This is the prototype for the callback function which
// will enumerate over the enhanced metafile records.

int CALLBACK EMfCallbackFuncForDraw     (HDC hdc,
					 HANDLETABLE * pHTable,
					 const ENHMETARECORD * pMFR,
					 int  nObj,
					 LPARAM lpobj);

// Utility function to de-serialize an enhanced metafile from
// a stream, and create a usable handle to it

FARINTERNAL UtGetHEMFFromEMFStm(LPSTREAM lpstream,
				DWORD * dwSize,
				HENHMETAFILE * lphPres);

// Utility function which takes a handle to an enhanced metafile
// and serializes the associated metafile to a stream

FARINTERNAL UtHEMFToEMFStm(HENHMETAFILE hEMF,
			   DWORD dwSize,
			   LPSTREAM lpstream,
			   EMFWRITETYPE type);

// A utility function to check whether or not a DC in question
// is a standard DC or a metafile DC.

STDAPI_(BOOL) OleIsDcMeta (HDC hdc);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\drag.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	drag.h
//
//  Contents:   Classes used in drag operation
//
//  Classes:    CPoint
//              CDragDefaultCursors
//		CDragOperation
//		CWin31DropTarget
//
//  History:	dd-mmm-yy Author    Comment
//		20-Oct-94 alexgo    added CWin31DropTarget to handle Win3.1
//				    style drag drop
//		21-Apr-94 ricksa    split out from drag.cpp
//
//  Notes:      This exists as a separate file to facilitate the special
//              processing required for WM_CANCELMODE during drag/drop.
//
//--------------------------------------------------------------------------

#ifndef _DRAG_H
#define _DRAG_H

void DragDropProcessUninitialize(void);

//+-------------------------------------------------------------------------
//
//  Class:	CPoint
//
//  Purpose:	Handles strangness of the POINTL & POINT structures.
//
//  Interface:	Set - set value of data
//		GetPOINT - return a reference to a POINT structure
//		GetPOINTL - return a reference to a POINTL structure
//		GetAddressOfPOINT - return address of point structure
//
//  History:	dd-mmm-yy Author    Comment
//		04-Apr-94 Ricksa    Created
//
//  Notes:	This class is created because we have two structures
//		that are exactly the same in Win32 but have different
//		types. This class will have to be modified for use
//		in Win16 if we ever do that again.
//
//--------------------------------------------------------------------------
class CPoint
{
public:

			CPoint(void);

    void		Set(LONG x, LONG y);

    POINT&		GetPOINT(void);

    POINTL&		GetPOINTL(void);

    POINT *		GetAddressOfPOINT(void);

private:

    POINT		_pt;

};


//+-------------------------------------------------------------------------
//
//  Function:	CPoint::CPoint
//
//  Synopsis:	Initialize object to zero
//
//  History:	dd-mmm-yy Author    Comment
//		04-Apr-94 Ricksa    Created
//
//--------------------------------------------------------------------------
inline CPoint::CPoint(void)
{
    _pt.x = 0;
    _pt.y = 0;
}




//+-------------------------------------------------------------------------
//
//  Function:	CPoint::Set
//
//  Synopsis:	Set value of structure
//
//  History:	dd-mmm-yy Author    Comment
//		04-Apr-94 Ricksa    Created
//
//--------------------------------------------------------------------------
inline void CPoint::Set(LONG x, LONG y)
{
    _pt.x = x;
    _pt.y = y;
}




//+-------------------------------------------------------------------------
//
//  Function:	CPoint::GetPOINT
//
//  Synopsis:	Return a reference to a POINT type for function calls
//
//  History:	dd-mmm-yy Author    Comment
//		04-Apr-94 Ricksa    Created
//
//--------------------------------------------------------------------------
inline POINT& CPoint::GetPOINT(void)
{
    return _pt;
}



//+-------------------------------------------------------------------------
//
//  Function:	CPoint::GetPOINTL
//
//  Synopsis:	Return a reference to a POINTL type for function calls
//
//  History:	dd-mmm-yy Author    Comment
//		04-Apr-94 Ricksa    Created
//
//--------------------------------------------------------------------------
inline POINTL& CPoint::GetPOINTL(void)
{
    return *((POINTL *) &_pt);
}



//+-------------------------------------------------------------------------
//
//  Function:	CPoint::GetAddressOfPOINT
//
//  Synopsis:	Return address of POINT type for function calls
//
//  History:	dd-mmm-yy Author    Comment
//		04-Apr-94 Ricksa    Created
//
//--------------------------------------------------------------------------
inline POINT *CPoint::GetAddressOfPOINT(void)
{
    return &_pt;
}





//+-------------------------------------------------------------------------
//
//  Class:      CDragDefaultCursors
//
//  Purpose:    Handles init/setting default drag cursors
//
//  Interface:  NeedInit - whether object needs to be initialized
//              Init - does initialization
//              SetCursor - sets cursor to appropriate default
//
//  History:	dd-mmm-yy Author    Comment
//		19-Apr-94 Ricksa    Created
//
//  Notes:	This class specifically avoids a constructor and depends
//              on the behavior of of static data being initialized to
//              NULL. The reason for this is two fold: (1) it makes start
//              up faster by avoiding a page fault when the constructor
//              would be called and (2) it allows this ole32 to be loaded
//              at boot time before cursors exist.
//
//--------------------------------------------------------------------------
class CDragDefaultCursors : public CPrivAlloc
{
public:

    BOOL                Init(void);

    void                SetCursor(DWORD dwEffect);

    void                SetCursorNone(void);

    static CDragDefaultCursors *GetDefaultCursorObject(void);

private:

    enum SCROLL_TYPE    {NO_SCROLL, SCROLL};

    enum CURSOR_ID      {NO_DROP, MOVE_DROP, COPY_DROP, LINK_DROP};

    HCURSOR             ahcursorDefaults[2][4];
};



//+-------------------------------------------------------------------------
//
//  Function:	CDragDefaultCursors::SetCursorNone
//
//  Synopsis:   Set the cursor to none
//
//  History:	dd-mmm-yy Author    Comment
//		19-Apr-94 Ricksa    Created
//
//--------------------------------------------------------------------------
inline void CDragDefaultCursors::SetCursorNone(void)
{
    ::SetCursor(ahcursorDefaults[NO_SCROLL][NO_DROP]);
}


//+-------------------------------------------------------------------------
//
//  Class:	CDragOperation
//
//  Purpose:	Handles breaking down drag operation into managable pieces
//
//  Interface:	UpdateTarget - update where we are trying to drop
//              HandleFeedBack - handle cursor feedback
//		DragOver - handle dragging object over target
//		HandleMessages - Handle windows messages
//		CompleteDrop - Do drop or clean up
//              CancelDrag - notify operation that drag is canceled.
//              ReleaseCapture - release capture on the mouse
//              GetDropTarget - get target for drop
//
//  History:	dd-mmm-yy Author    Comment
//		04-Apr-94 Ricksa    Created
//
//--------------------------------------------------------------------------
class CDragOperation
{
public:
			CDragOperation(
			    LPDATAOBJECT pDataObject,
			    LPDROPSOURCE pDropSource,
			    DWORD dwOKEffects,
			    DWORD FAR *pdwEffect,
			    HRESULT& hr);

			~CDragOperation(void);

    BOOL		UpdateTarget(void);

    BOOL                HandleFeedBack(HRESULT hr);

    BOOL		DragOver(void);

    BOOL		HandleMessages(void);

    HRESULT		CompleteDrop(void);

    void                CancelDrag(void);

    void                ReleaseCapture(void);

    IFBuffer 		GetDOBuffer(void);

private:

    void		InitCursors(void);

    void		InitScrollInt(void);

    HRESULT             GetDropTarget(HWND hwnd31,HWND hwndDropTarget);

    LPDATAOBJECT	_pDataObject;

    IFBuffer           	_DOBuffer;     	// a buffer for the marshalled
					// data object

    LPDROPSOURCE	_pDropSource;

    LPDROPTARGET	_pDropTarget;

    LPDROPTARGET	_pRealDropTarget;

    HANDLE              _hFormats;

    CPoint		_cpt;

    DWORD		_dwOKEffects;

    DWORD FAR * 	_pdwEffect;

    BOOL		_fEscapePressed;

    HCURSOR		_curOld;

    HWND		_hwndLast;

    DWORD		_grfKeyState;

    HRESULT		_hrDragResult;

    BOOL                _fReleasedCapture;

    CDragDefaultCursors* _pcddcDefault;

    BOOL		_fUseWin31;

    static LONG 	s_wScrollInt;

};


//+-------------------------------------------------------------------------
//
//  Function:   CDragOperation::ReleaseCapture
//
//  Synopsis:   Tell clipboard window to turn off mouse capture if we haven't
//              already done so.
//
//  History:	dd-mmm-yy Author    Comment
//		07-Jul-94 Ricksa    Created
//
//--------------------------------------------------------------------------
inline void CDragOperation::ReleaseCapture(void)
{
    if (!_fReleasedCapture)
    {
        _fReleasedCapture = TRUE;
        ClipReleaseCaptureForDrag();
    }
}

//+-------------------------------------------------------------------------
//
//  Member:   	CDragOperation::GetDOBuffer
//
//  Synopsis:  	returns the interface buffer for the marshalled
//		data object interface
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns: 	IFBuffer *
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		02-Dec-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

inline IFBuffer CDragOperation::GetDOBuffer(void)
{
    return _DOBuffer;
}

//+-------------------------------------------------------------------------
//
//  Class:   	CDropTarget
//
//  Purpose:  	Implements IDropTarget for the DoDragLoop.  This class
//		will either delegate to a real drop target (registered
//		with RegisterDragDrop) or translate IDropTarget methods
//		into the Win3.1 drag drop protocol.
//
//  Interface:	IDropTarget
//
//  History:    dd-mmm-yy Author    Comment
//		20-Oct-94 alexgo    author
//
//  Notes:   	This class is NOT thread safe, nor is it safe to pass
//		outside of the CDragOperation class (which is why
//		QueryInterface is not implemented).  As long as
//		DoDropDrag works by a modal loop on the calling thread,
//		this should not have to change.
//
//--------------------------------------------------------------------------

class CDropTarget : public IDropTarget, public CPrivAlloc
{
public:
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID *ppv);
    STDMETHOD_(ULONG, AddRef) (void);
    STDMETHOD_(ULONG, Release) (void);
    STDMETHOD(DragEnter) (IDataObject *pDataObject, DWORD grfKeyState,
        POINTL ptl, DWORD *pdwEffect);
    STDMETHOD(DragOver) (DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect);
    STDMETHOD(DragLeave) (void);
    STDMETHOD(Drop) (IDataObject *pDataObject, DWORD grfKeyState, POINTL pt,
        DWORD *pdwEffect);

private:

    CDropTarget(HWND hwnd31, HWND hwndOLE, DWORD _dwEffectLast,
	CDragOperation *pdo, DDInfo hDDInfo);

    ~CDropTarget();

    HWND            	_hwndOLE;
    HWND		_hwnd31;
    DWORD		_dwEffectLast;
    ULONG           	_crefs;
    CDragOperation *	_pdo;
    DDInfo		_hDDInfo;

    // make CDragOperation a friend so it can create an instance of our
    // class (the constructor is private)

    friend class CDragOperation;

};

#endif // _DRAG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\fetcenum.h ===
#if !defined( _FETCENUM_H_ )
#define _FETCENUM_H_

#include <olerem.h>
STDAPI OleSetEnumFormatEtc(LPDATAOBJECT pDataObj, BOOL fClip);
STDAPI OleGetEnumFormatEtc(OID oid,	LPENUMFORMATETC FAR* ppenumfortec);
STDAPI OleRemoveEnumFormatEtc(BOOL fClip);

#endif // _FETCENUM_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\gen.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	gen.h
//
//  Contents:	Declaration of CGenObject
//
//  Classes:	CGenObject
//
//  Functions:	
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  add Dump method to CGenObject
//		24-Jan-94 alexgo    first pass converting to Cairo style
//				    memory allocation
//		23-Nov-93 alexgo    32bit port
//		23-Nov-93 alexgo    removed internal function declarations
//				    (only used in gen.cpp, so put them there)
//
//--------------------------------------------------------------------------


#include "olepres.h"
#include "olecache.h"
#include "cachenod.h"

//+-------------------------------------------------------------------------
//
//  Class:  	CGenObject::IOlePresObj
//
//  Purpose:    Implementation of IOlePresObj for device independent bitmaps
//
//  Interface:  IOlePresObj (internal OLE interface)
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  add Dump method (_DEBUG only) (this method
//                                  is also a method in IOlePresObj
//		23-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

class FAR CGenObject : public IOlePresObj, public CPrivAlloc
{
public:
	CGenObject (LPCACHENODE pCacheNode, CLIPFORMAT cfFormat,
			DWORD dwAspect);
	~CGenObject( void );

    	STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    	STDMETHOD_(ULONG,AddRef) (THIS) ;
    	STDMETHOD_(ULONG,Release) (THIS);

    	STDMETHOD(GetData) (THIS_ LPFORMATETC pformatetcIn,
			LPSTGMEDIUM pmedium );
    	STDMETHOD(GetDataHere) (THIS_ LPFORMATETC pformatetcIn,
			LPSTGMEDIUM pmedium );
	
	STDMETHOD(SetDataWDO) (THIS_ LPFORMATETC pformatetc, LPSTGMEDIUM pmedium,
			BOOL fRelease, IDataObject * pdo);
								
    	STDMETHOD(Draw) (THIS_ void FAR* pvAspect, HDC hicTargetDev,
    			HDC hdcDraw, LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
			BOOL (CALLBACK * pfnContinue)(ULONG_PTR),
			ULONG_PTR dwContinue);
	STDMETHOD(GetExtent) (THIS_ DWORD dwAspect, LPSIZEL lpsizel);
	STDMETHOD(Load) (THIS_ LPSTREAM pstm, BOOL fReadHeaderOnly = FALSE);
	STDMETHOD(Save) (THIS_ LPSTREAM pstm);
	STDMETHOD(GetColorSet) (void FAR* pvAspect, HDC hicTargetDev,
			LPLOGPALETTE FAR* ppColorSet);
	STDMETHOD_(BOOL, IsBlank) (THIS);	
	STDMETHOD_(void, DiscardHPRES)(THIS);

    #ifdef _DEBUG
        STDMETHOD(Dump) (THIS_ char **ppszDump, ULONG ulFlag, int nIndentLevel);
    #endif // _DEBUG
	
private:

#ifndef _MAC
    	INTERNAL GetBitmapData(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium);
							
	INTERNAL SetBitmapData(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium,
			BOOL fRelease, IDataObject *pDataObject);
#endif

	INTERNAL ChangeData(HANDLE hData, BOOL fDelete);
	INTERNAL_(HANDLE) LoadHPRES(void);
	INTERNAL_(HANDLE) GetCopyOfHPRES(void);	
	
shared_state:
	ULONG					m_ulRefs;
	DWORD					m_dwAspect;
    	DWORD					m_dwSize;
	LONG					m_lWidth;
	LONG					m_lHeight;
	HANDLE					m_hPres;
	CLIPFORMAT				m_cfFormat;
	LPCACHENODE				m_pCacheNode;
};


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\le2int.h ===
//+----------------------------------------------------------------------------
//
//      File:
//              ole2int.h
//
//      Contents:
//              This is the internal compound document header file that all
//              implementations in the linking and embedding code include.
//
//      Classes:
//
//      Functions:
//
//      History:
//              20-Jan-95 t-ScottH  add CThreadCheck::Dump method (_DEBUG only)
//              09-Jan-95 t-scotth  changed macro VDATETHREAD to accept a
//                                  pointer
//              19-Apr-94 alexgo    renamed global clipboard formats to
//                                  Cairo conventions
//              24-Jan-94 alexgo    first pass converting to Cairo style
//                                  memory allocation
//              01/13/93 - alexgo  - temporarily disabled _DEBUG for Chicago
//              12/30/93 - ChrisWe - define _DEBUG #if DBG==1 so that asserts
//                      are included; got rid of some previously #ifdef NEVER
//                      code;  added proper file prolog
//              12/27/93 - ErikGav - changed lstr* to wcs* on Win32
//              12/17/93 - ChrisWe - added first pass at GlobalAlloc debugging
//                      macros
//              12/08/93 - ChrisWe - made error assert message strings constant;
//                      formatting changes
//              12/07/93 - ChrisWe - removed obsolete names for memory arenas;
//                      did some minor formatting; removed obsolete DBCS stuff
//
//-----------------------------------------------------------------------------

/*
 *  This is the internal ole2 header, which means it contains those
 *  interfaces which might eventually be exposed to the outside
 *  and which will be exposed to our implementations. We don't want
 *  to expose these now, so I have put them in a separate file.
 */

#ifndef _LE2INT_H_
#define _LE2INT_H_

// For TLS on Nt, we use a reserved DWORD in the TEB directly. We need to
// include these files in order to get the macro NtCurrentTeb. These must
// be included before windows.h
extern "C"
{
#include <nt.h> 	// NT_PRODUCT_TYPE
#include <ntdef.h>      // NT_PRODUCT_TYPE
#include <ntrtl.h>      // NT_PRODUCT_TYPE
#include <nturtl.h>     // NT_PRODUCT_TYPE
#include <windef.h>     // NT_PRODUCT_TYPE
#include <winbase.h>    // NT_PRODUCT_TYPE
}


// ------------------------------------
// system includes
#include <string.h>
#include <stdlib.h>
#include <stddef.h>

#ifdef WIN32
# include <wchar.h>
#else
# include <ctype.h>
#endif

// we need to turn on the validation code in the ole library for
// Cairo/Daytona/Chicago debug builds, which was keyed off _DEBUG
// in the win16 code.  It appears we need this before any other files
// are included so that debug only declarations in ole2.h/compobj.h
// get processed.
#if DBG==1
# ifndef _DEBUG
#  define _DEBUG
# endif
#endif

#ifndef _MAC
# include <windows.h>
# include <malloc.h>
# include <shellapi.h>
#else
//#include <mac.h>
#endif // _MAC

//
//  Debug support
//

# include <debnot.h>

DECLARE_DEBUG(LE)
DECLARE_DEBUG(Ref)
DECLARE_DEBUG(DD)

#if DBG==1

#define LEDebugOut(x)   LEInlineDebugOut x
#define RefDebugOut(x)	RefInlineDebugOut x
#define DDDebugOut(x)   DDInlineDebugOut x

#else

#define LEDebugOut(x)   NULL
#define RefDebugOut(x)	NULL
#define DDDebugOut(x)   NULL

#endif // DBG

#include <tls.h>

//+-------------------------------------------------------------------------
//
//  Function:   LEERROR (macro)
//
//  Synopsis:   prints out an error message if [cond] is TRUE, along with
//              the file and line information
//
//  Effects:
//
//  Arguments:  [cond]          -- condition to test against
//              [szError]       -- string to print out
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              18-Apr-94 alexgo    author
//
//  Notes:      Only present in DEBUG builds
//
//--------------------------------------------------------------------------
#if DBG==1

#define LEERROR( cond, szError )        if( cond ) {\
	LEDebugOut((DEB_ERROR, "ERROR!: %s (%s %d)\n", szError, __FILE__, \
		__LINE__)); }

#else

#define LEERROR( cond, szError )

#endif  //!DBG

//+-------------------------------------------------------------------------
//
//  Function:   LEWARN  (macro)
//
//  Synopsis:   prints out a warning message if [cond] is TRUE, along with
//              the file and line information
//
//  Effects:
//
//  Arguments:  [cond]          -- condition to test against
//              [szWarn]        -- string to print out
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              18-Apr-94 alexgo    author
//
//  Notes:      Only present in DEBUG builds
//
//--------------------------------------------------------------------------
#if DBG==1

#define LEWARN( cond, szWarn )  if( cond ) {\
	LEDebugOut((DEB_WARN, "WARNING!: %s (%s %d)\n", szWarn, __FILE__, \
		__LINE__)); }

#else

#define LEWARN( cond, szWarn )

#endif  //!DBG

//+-------------------------------------------------------------------------
//
//  Function:   LEVERIFY  (macro)
//
//  Synopsis:   prints out a warning message if [cond] is FALSE, along with
//              the file and line information.  In non-debug builds, the
//              condition IS still evaluated/executed.
//
//  Effects:
//
//  Arguments:  [cond]      -- condition to test for (intended to be true)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Aug-94 davepl    author
//
//  Notes:      Warns only in DEBUG builds, executes in all builds
//
//--------------------------------------------------------------------------

#if DBG==1

#define LEVERIFY( cond ) ( (cond)  ?             \
            (void)  NULL  :       \
            LEDebugOut((DEB_WARN, "VERIFY FAILED: %s (%s %d)\n", #cond, __FILE__, __LINE__)) \
          )

#else

#define LEVERIFY( cond ) (void) (cond)

#endif  //!DBG


#ifdef WIN32

# define __loadds            // Not used
# define UnlockData(ds)      // Not used

# define _fmalloc  malloc
# define _frealloc realloc
# define _ffree    free

#endif // WIN32

#ifdef WIN32

# define _xmemset memset
# define _xmemcpy memcpy
# define _xmemcmp memcmp
# define _xmemmove memmove

#else

# define _xmemset _fmemset
# define _xmemcpy _fmemcpy
# define _xmemcmp _fmemcmp
# define _xmemmove _fmemmove

#endif // WIN32


#ifdef WIN32

# define EXPORT

#else

# define EXPORT __export

#endif


// ------------------------------------
// public includes
#include <ole2.h>
#include <ole2sp.h>
#include <ole2com.h>
// ------------------------------------
// internal includes
#include <utils.h>
#include <olecoll.h>
#include <valid.h>
#include <map_kv.h>
#include <privguid.h>
#include <memapi.hxx>

/* Exported CLSIDs.. */
// REVIEW, why not just change these to be correct?
#define CLSID_StaticMetafile CLSID_Picture_Metafile
#define CLSID_StaticDib CLSID_Picture_Dib



#ifdef _MAC
#define BITMAP_TO_DIB(foretc)
#else
#define BITMAP_TO_DIB(foretc) \
	if (foretc.cfFormat == CF_BITMAP) {\
		foretc.cfFormat = CF_DIB;\
		foretc.tymed = TYMED_HGLOBAL;\
	}
#endif // _MAC


// NOTE!!!
//
// If a member is added to the aspect, tymed, or advf enumerations,
// these values MUST be updated accordingly!!

#define MAX_VALID_ASPECT DVASPECT_DOCPRINT
#define MAX_VALID_TYMED  TYMED_ENHMF
#define MAX_VALID_ADVF   ADVF_DATAONSTOP

// This creates a mask of the valid ADVF bits:
#define MASK_VALID_ADVF  ((MAX_VALID_ADVF << 1) - 1)

// #include "pres.h"

#define VERIFY_ASPECT_SINGLE(dwAsp) {\
	if (!(dwAsp && !(dwAsp & (dwAsp-1)) && (dwAsp <= MAX_VALID_ASPECT))) {\
		LEDebugOut((DEB_WARN, "More than 1 aspect is specified"));\
		return ResultFromScode(DV_E_DVASPECT);\
	}\
}


#define VERIFY_TYMED_SINGLE(tymed) {\
	if (!(tymed && !(tymed & (tymed-1)) && (tymed <= MAX_VALID_TYMED))) \
		return ResultFromScode(DV_E_TYMED); \
}

//      Legal formats for clipformat (and thus, cache nodes)
//      CF_METAFILEPICT && TYMED_MFPICT
//      CF_BITMAP && TYMED_GDI
//      CF_DIB && TYMED_HGLOBAL
//      CF_other && TYMED_HGLOBAL

#define VERIFY_TYMED_VALID_FOR_CLIPFORMAT(pfetc) {\
	if ((pfetc->cfFormat==CF_METAFILEPICT && !(pfetc->tymed & TYMED_MFPICT))\
			|| (pfetc->cfFormat==CF_ENHMETAFILE && !(pfetc->tymed & TYMED_ENHMF))\
			|| (pfetc->cfFormat==CF_BITMAP && !(pfetc->tymed & TYMED_GDI))\
			|| (pfetc->cfFormat==CF_DIB && !(pfetc->tymed & TYMED_HGLOBAL))\
			|| (pfetc->cfFormat!=CF_METAFILEPICT && \
				pfetc->cfFormat!=CF_BITMAP && \
				pfetc->cfFormat!=CF_DIB && \
				pfetc->cfFormat!=CF_ENHMETAFILE && \
				!(pfetc->tymed & TYMED_HGLOBAL)))\
		return ResultFromScode(DV_E_TYMED); \
}

#define VERIFY_TYMED_SINGLE_VALID_FOR_CLIPFORMAT(pfetc)                                 \
{                                                                                       \
	if (pfetc->cfFormat==CF_METAFILEPICT && pfetc->tymed != TYMED_MFPICT)           \
		return ResultFromScode(DV_E_TYMED);                                     \
											\
	if (pfetc->cfFormat==CF_ENHMETAFILE  && pfetc->tymed != TYMED_ENHMF)            \
		return ResultFromScode(DV_E_TYMED);					\
											\
	if (pfetc->cfFormat==CF_BITMAP && pfetc->tymed != TYMED_GDI)                    \
		return ResultFromScode(DV_E_TYMED);                                     \
											\
	if (pfetc->cfFormat==CF_DIB && pfetc->tymed != TYMED_HGLOBAL)                   \
		return ResultFromScode(DV_E_TYMED);                                     \
											\
	if (pfetc->cfFormat != CF_METAFILEPICT)                                         \
	   if (pfetc->cfFormat != CF_BITMAP)                                            \
	      if (pfetc->cfFormat != CF_DIB)                                            \
	      	 if (pfetc->cfFormat != CF_ENHMETAFILE)					\
		    if (pfetc->tymed != TYMED_HGLOBAL)                                  \
			return ResultFromScode(DV_E_TYMED);                             \
}

// This was the original code...

/*
#define VERIFY_TYMED_SINGLE_VALID_FOR_CLIPFORMAT(pfetc) {\
	if ((pfetc->cfFormat==CF_METAFILEPICT && pfetc->tymed!=TYMED_MFPICT)\
		|| ( (pfetc->cfFormat==CF_BITMAP || \
			pfetc->cfFormat == CF_DIB ) \
			 && pfetc->tymed!=TYMED_GDI)\
		|| (pfetc->cfFormat!=CF_METAFILEPICT && \
				pfetc->cfFormat!=CF_BITMAP && \
				pfetc->cfFormat!=CF_DIB && \
				pfetc->tymed!=TYMED_HGLOBAL)) \
		return ResultFromScode(DV_E_TYMED); \
}
*/

//+----------------------------------------------------------------------------
//
//	Function:
//		CreateObjectDescriptor, static
//
//	Synopsis:
//		Creates and initializes an OBJECTDESCRIPTOR from the given
//		parameters
//
//	Arguments:
//		[clsid] -- the class ID of the object being transferred
//		[dwAspect] -- the display aspect drawn by the source of the
//			transfer
//		[psizel] -- pointer to the size of the object
//		[ppointl] -- pointer to the mouse offset in the object that
//			initiated a drag-drop transfer
//		[dwStatus] -- the OLEMISC status flags for the object
//			being transferred
//		[lpszFullUserTypeName] -- the full user type name of the
//			object being transferred
//		[lpszSrcOfCopy] -- a human readable name for the object
//			being transferred
//
//	Returns:
//		If successful, A handle to the new OBJECTDESCRIPTOR; otherwise
//		NULL.
//
//	Notes:
//		REVIEW, this seems generally useful for anyone using the
//		clipboard, or drag-drop; perhaps it should be exported.
//
//	History:
//		12/07/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
INTERNAL_(HGLOBAL) CreateObjectDescriptor(CLSID clsid, DWORD dwAspect,
		const SIZEL FAR *psizel, const POINTL FAR *ppointl,
		DWORD dwStatus, LPOLESTR lpszFullUserTypeName,
		LPOLESTR lpszSrcOfCopy);


INTERNAL_(HRESULT) CheckTymedCFCombination(LPFORMATETC pfetc);

/*
#define VERIFY_ASPECT_SINGLE(dwAsp) {\
	if (!(dwAsp && !(dwAsp & (dwAsp-1)) && (dwAsp <= MAX_VALID_ASPECT))) {\
		AssertSz(FALSE, "More than 1 aspect is specified");\
		return ResultFromScode(DV_E_DVASPECT);\
	}\
}
*/

//+----------------------------------------------------------------------------
//
//	Function:
//		VerifyAspectSingle (Internal Inline)
//
//	Synopsis:
//		Verifies that exactly one bit is set in the aspect, and that
//		it is one of the known aspect bits.
//
//	Returns:
//		S_OK				For a valid aspect
//		DV_E_ASPECT			For an invalid aspect
//
//	Notes:
//		The (0 == (dwAsp & (dwAsp - 1))) test is an efficient means
//		for testing that exactly at most bit is set in dwAsp, once it
//		is known that dwAsp is nonzero.
//
//	History:
//		01/07/94   DavePl    Created
//
//-----------------------------------------------------------------------------

inline HRESULT VerifyAspectSingle(DWORD dwAsp)
{
	// Ensure at least one bit is set

	if (dwAsp)
	{
		// Ensure at most one bit is set

		if (0 == (dwAsp & (dwAsp-1)))
		{
			// Ensure that one bit is valid

			if (MAX_VALID_ASPECT >= dwAsp)
			{
				return S_OK;
			}
		}
	}
	
	LEDebugOut((DEB_WARN,"WARNING: Invalid Aspect DWORD -> %0X\n", dwAsp));
							
	return DV_E_DVASPECT;
}


/*
#define VERIFY_TYMED_SINGLE(tymed) {\
	if (!(tymed && !(tymed & (tymed-1)) && (tymed <= MAX_VALID_TYMED))) \
		return ResultFromScode(DV_E_TYMED); \
}
*/

//+----------------------------------------------------------------------------
//
//	Function:
//		VerifyTymedSingle (Internal Inline)
//
//	Synopsis:
//		Verifies that exactly one bit is set in the tymed, and that
//		it is one of the known tymed bits.
//
//	Returns:
//		S_OK				For a valid aspect
//		DV_E_ASPECT			For an invalid aspect
//
//	Notes:
//		The (0 == (dwAsp & (dwAsp - 1))) test is an efficient means
//		for testing that exactly at most bit is set in dwTymed, once it
//		is known that dwTymed is nonzero.
//
//	History:
//		01/07/94   DavePl    Created
//
//-----------------------------------------------------------------------------

inline HRESULT VerifyTymedSingle(DWORD dwTymed)
{
	// Ensure that at least one bit is set

	if (dwTymed)
	{
		// Ensure that at most one bit is set

		if (0 == (dwTymed & (dwTymed - 1)))
		{
			// Ensure that the one set bit is a valid one

			if (MAX_VALID_TYMED >= dwTymed)
			{
				return S_OK;
			}
		}
	}
	
	LEDebugOut((DEB_WARN,"WARNING: Invalid Tymed DWORD -> %0X\n", dwTymed));

	return DV_E_TYMED;
}

//+-------------------------------------------------------------------------
//
//  Class:      CSafeRefCount
//
//  Purpose:    A class that implements reference counting rules for objects.
//              It keeps track of reference count and zombie state.
//              It helps object manage their liveness properly.
//
//  History:    dd-mmm-yy   Author    Comment
//              16-Jan-97   Gopalk    Simplified and Rewritten to handle 
//                                    aggregation
//
//--------------------------------------------------------------------------
class CSafeRefCount : public CPrivAlloc
{
public:
    // Constructor
    CSafeRefCount(IUnknown *pUnkOuter) {
	m_cRefs = 0;
        m_fInDelete = FALSE;
        m_pUnkOuter = pUnkOuter;
#if DBG==1
        m_cNestCount = 0;
#endif
    }
    
    // Destructor. It has to be virtual so that delete this will
    // despatched to the right object
    virtual ~CSafeRefCount() {
        Win4Assert(!m_cRefs && !m_cNestCount && m_fInDelete);
    }

    // Reference count methods
    ULONG SafeAddRef() {
        return InterlockedIncrement((LONG *)& m_cRefs);
    }
    ULONG SafeRelease();

    // Nest count methods
    void IncrementNestCount() {
#if DBG==1
        InterlockedIncrement((LONG *) &m_cNestCount);
#endif
        if(m_pUnkOuter)
            m_pUnkOuter->AddRef();
        else
             SafeAddRef();

        return;
    }
    void DecrementNestCount() {
#if DBG==1
        InterlockedDecrement((LONG *) &m_cNestCount);
        Win4Assert((LONG) m_cNestCount >= 0);
#endif
        if(m_pUnkOuter)
            m_pUnkOuter->Release();
        else
            SafeRelease();

        return;
    }
    
    // State methods
    BOOL IsZombie() {
        return m_fInDelete;
    }

    // Other useful methods
    IUnknown *GetPUnkOuter() {
        return m_pUnkOuter;
    }
    ULONG GetRefCount(void) {
        return m_cRefs;
    }
#if DBG==1
    ULONG GetNestCount(void) {
        return m_cNestCount;
    }
#endif

private:
    ULONG m_cRefs;
    BOOL m_fInDelete;
    IUnknown *m_pUnkOuter;
#if DBG==1
    ULONG m_cNestCount;
#endif
};

//+-------------------------------------------------------------------------
//
//  Class:      CRefExportCount
//
//  Purpose:    A class that implements reference counting rules for server
//              objects that export their nested objects on behalf of their
//              clients like DEFHANDLER abd CACHE. It keeps track of 
//              reference count, export count, zombie state, etc.
//              It helps object manage their shutdown logic properly.
//
//  History:    dd-mmm-yy   Author    Comment
//              16-Jan-97   Gopalk    Creation
//
//--------------------------------------------------------------------------
class CRefExportCount : public CPrivAlloc
{
public:
    // Constructor
    CRefExportCount(IUnknown *pUnkOuter) {
	m_cRefs = 0;
        m_cExportCount = 0;
        m_IsZombie = FALSE;
	m_Status = ALIVE;
        m_pUnkOuter = pUnkOuter;
#if DBG==1
        m_cNestCount = 0;
#endif
    }
    
    // Destructor. It has to be virtual so that delete this will
    // despatched to the right object
    virtual ~CRefExportCount() {
        Win4Assert(!m_cRefs && !m_cNestCount && !m_cExportCount &&
                   m_IsZombie && m_Status==DEAD);
    }

    // Reference count methods
    ULONG SafeAddRef() {
        return InterlockedIncrement((LONG *)& m_cRefs);
    }
    ULONG SafeRelease();

    // Nest count methods
    void IncrementNestCount() {
#if DBG==1
        InterlockedIncrement((LONG *) &m_cNestCount);
#endif
        if(m_pUnkOuter)
            m_pUnkOuter->AddRef();
        else
             SafeAddRef();

        return;
    }
    void DecrementNestCount() {
#if DBG==1
        InterlockedDecrement((LONG *) &m_cNestCount);
        Win4Assert((LONG) m_cNestCount >= 0);
#endif
        if(m_pUnkOuter)
            m_pUnkOuter->Release();
        else
            SafeRelease();

        return;
    }
    
    // Methods used by exported nested objects
    ULONG IncrementExportCount() {
        return InterlockedIncrement((LONG *) &m_cExportCount);
    }
    ULONG DecrementExportCount();

    // State methods
    BOOL IsZombie() {
        return m_IsZombie;
    }
    BOOL IsExported() {
        return m_cExportCount>0;
    }

    // Other useful methods
    IUnknown *GetPUnkOuter() {
        return m_pUnkOuter;
    }
    ULONG GetRefCount(void) {
        return m_cRefs;
    }
    ULONG GetExportCount(void) {
        return m_cExportCount;
    }
#if DBG==1
    ULONG GetNestCount(void) {
        return m_cNestCount;
    }
#endif

private:
    // Cleanup function which is invoked when the object transistions
    // into zombie state. It is virtual so that the correct cleanup
    // function is invoked
    virtual void CleanupFn(void) {
        return;
    }

    // Tokens used 
    enum tagTokens {
        ALIVE = 0,
        KILL = 1,
        DEAD = 2
    };

    // Member variables
    ULONG m_cRefs;
    ULONG m_cExportCount;
    ULONG m_IsZombie;
    ULONG m_Status;
    IUnknown *m_pUnkOuter;
#if DBG==1
    ULONG m_cNestCount;
#endif
};

//+-------------------------------------------------------------------------
//
//  Class:      CStabilize
//
//  Purpose:    An instance of this class should be allocated on the
//              stack of every object method that makes an outgoing call.
//
//  History:    dd-mmm-yy   Author    Comment
//              16-Jan-97   Gopalk    Simplified and Rewritten to handle 
//                                    aggregation
//
//--------------------------------------------------------------------------
class CStabilize
{
public:
    // Constructor    
    CStabilize(CSafeRefCount *pSafeRefCount) {
        m_pSafeRefCount = pSafeRefCount;
        pSafeRefCount->IncrementNestCount();
    }
    // Destructor
    ~CStabilize() {
        m_pSafeRefCount->DecrementNestCount();
    }

private:
    CSafeRefCount *m_pSafeRefCount;
};

//+-------------------------------------------------------------------------
//
//  Class:      CRefStabilize
//
//  Purpose:    An instance of this class should be allocated on the
//              stack of every object method that makes an outgoing call.
//
//  History:    dd-mmm-yy   Author    Comment
//              16-Jan-97   Gopalk    Simplified and Rewritten to handle 
//                                    aggregation
//
//--------------------------------------------------------------------------
class CRefStabilize
{
public:
    // Constructor    
    CRefStabilize(CRefExportCount *pRefExportCount) {
        m_pRefExportCount = pRefExportCount;
        pRefExportCount->IncrementNestCount();
    }
    // Destructor
    ~CRefStabilize() {
        m_pRefExportCount->DecrementNestCount();
    }

private:
    CRefExportCount *m_pRefExportCount;
};
//+-------------------------------------------------------------------------
//
//  Class:  	CThreadCheck
//
//  Purpose:  	ensures that an object is called on the correct thread
//
//  Interface:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Jan-95 t-ScottH  add Dump method to CThreadCheck class
//                                  (_DEBUG only)
// 		21-Nov-94 alexgo    author
//
//  Notes:	To use this class, an object should simply publicly
//		inherit CThreadCheck.  The VDATETHREAD macro can then be
//		used to check the thread id at each entry point.
//
//--------------------------------------------------------------------------

class CThreadCheck
{
public:
    inline CThreadCheck();
    BOOL VerifyThreadId(); 	// in utils.cpp
    #ifdef _DEBUG
    HRESULT Dump(char **ppszDumpOA, ULONG ulFlag, int nIndentLevel); // utils.cpp
    #endif //_DEBUG

private:
    DWORD	m_tid;
};

//+-------------------------------------------------------------------------
//
//  Member:   	CThreadCheck::CThreadCheck
//
//  Synopsis:	stores the current thread id 	
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns: 	void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		21-Nov-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

inline CThreadCheck::CThreadCheck( void )
{
    m_tid = GetCurrentThreadId();

    LEWARN(!m_tid, "GetCurrentThreadId failed!!");
}

//+-------------------------------------------------------------------------
//
//  Function:  	VDATETHREAD (macro)
//
//  Synopsis:  	makes sure the correct thread is called
//
//  Effects:
//
//  Arguments:
//
//  Requires:  	the calling class must inherit from CThreadCheck
//
//  Returns: 	RPC_E_WRONG_THREAD if called on the wrong thread
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              09-Jan-95 t-ScottH  give VDATETHREAD an argument
// 		21-Nov-94 alexgo    author
//
//  Notes:	THIS MACRO FUNCTIONS IN RETAIL BUILDS TOO!!!
//
//--------------------------------------------------------------------------


#define VDATETHREAD(pObject) if( !( pObject->VerifyThreadId() ) ) { return RPC_E_WRONG_THREAD; }

// utility macros.

#define LONG_ABS(x)     ((x) < 0 ? -(x) : (x))


#endif  //      _LE2INT_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\memstm.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	memstm.h
//
//  Contents:	class declarations and API's for memory streams
//
//  Classes:	MEMSTM (struct)
//		CMemStm
//		CMemBytes
//		CMarshalMemStm
//		CMarshalMemBytes
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              31-Jan-95 t-ScottH  added Dump methods to CMemStm and CMemBytes
//                                  (_DEBUG only)
//		24-Jan-94 alexgo    first pass converting to Cairo style
//				    memory allocation
//		09-Nov-93 alexgo    32bit port, added API declarations
//		02-Dec-93 alexgo    finished commenting and converting
//				    to cairo standards
//--------------------------------------------------------------------------
#if !defined( _MEMSTM_H_ )
#define _MEMSTM_H_

#include    <sem.hxx>	    // CMutexSem
#include    <olesem.hxx>

#ifdef _DEBUG
#include "dbgexts.h"
#endif // _DEBUG

/*
 * MemStm APIs
 */

STDAPI_(LPSTREAM) 	CreateMemStm(DWORD cb, LPHANDLE phMem);
STDAPI_(LPSTREAM) 	CloneMemStm(HANDLE hMem);
STDAPI_(void) 		ReleaseMemStm(LPHANDLE phMem, BOOL fInternalOnly);
STDAPI 			CreateStreamOnHGlobal(HANDLE hGlobal,
				BOOL fDeleteOnRelease, LPSTREAM FAR * ppstm);
STDAPI 			GetHGlobalFromStream(LPSTREAM pstm,
				HGLOBAL FAR *phglobal);
STDAPI_(IUnknown FAR*) 	CMemStmUnMarshal(void);
STDAPI_(IUnknown FAR*) 	CMemBytesUnMarshal(void);

class FAR CMarshalMemStm;
class FAR CMarshalMemBytes;

//+-------------------------------------------------------------------------
//
//  Class:  	MEMSTM
//
//  Purpose:    A structure to describe the global memroy
//
//  Interface:
//
//  History:    dd-mmm-yy Author    Comment
//		09-Nov-93 alexgo    32bit port
//
//  Notes:
//
// cRef counts all CMemStm pointers to this MEMSTM plus the number of times
// a hMem handle to MEMSTM had been returned
//
//--------------------------------------------------------------------------

struct MEMSTM
{   // Data in shared memory
    DWORD  cb;              // Size of hGlobal
    DWORD  cRef;            // See below
#ifdef NOTSHARED
    HANDLE hGlobal;         // The data
#else
	BYTE * m_pBuf;
	HANDLE hGlobal;
#endif
	
    BOOL   fDeleteOnRelease;
};


#define STREAM_SIG (0x4d525453L)

//+-------------------------------------------------------------------------
//
//  Class:  	CRefMutexSem
//
//  Purpose:    A class that provides a refcounted CMutexSem object
//
//  Interface:
//
//  History:    dd-mmm-yy Author    Comment
//		20-Sep-2000 mfeingol Created
//
//  Notes:
//
class CRefMutexSem 
{
protected:
    LONG m_lRefs;
    CMutexSem2 m_mxs;
    
    CRefMutexSem();
    BOOL FInit();
    
public:

    static CRefMutexSem* CreateInstance();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    void RequestCS();
    void ReleaseCS();
    
    const CMutexSem2* GetMutexSem();
};

// Autolock class for CRefMutexSem
class CRefMutexAutoLock INHERIT_UNWIND_IF_CAIRO
{
    EXPORTDEF DECLARE_UNWIND

protected:

    CRefMutexSem* m_pmxs;

public:

    CRefMutexAutoLock (CRefMutexSem* pmxs);
    ~CRefMutexAutoLock();
};

//+-------------------------------------------------------------------------
//
//  Class: 	CMemStm
//
//  Purpose:    IStream on memory (shared mem for win16)
//
//  Interface:  IStream
//
//  History:    dd-mmm-yy Author    Comment
//		02-Dec-93 alexgo    32bit port
//
//  Notes:
//
// CMemStm is a stream implementation on top of global shared memory MEMSTM
//
// CMemStm
// +---------+
// + pvtf    +    Shared  memory
// +---------+   +--------------+
// + m_pMem  +-->|cb            |
// +---------+   |cRef          |
//               |hGlobal       |--->+--------------+
//               +--------------+	 | Actual Data	|
// CMemStm             MEMSTM		 +--------------+
//--------------------------------------------------------------------------
class FAR CMemStm : public IStream, public CPrivAlloc
{
public:
	STDMETHOD(QueryInterface) (REFIID iidInterface, void **ppvObj);
    	STDMETHOD_(ULONG,AddRef) (void);
    	STDMETHOD_(ULONG,Release) (void);
    	STDMETHOD(Read) (VOID HUGEP* pv, ULONG cb, ULONG FAR* pcbRead);
	STDMETHOD(Write) (VOID const HUGEP* pv, ULONG cb, ULONG *pcbWritten);
    	STDMETHOD(Seek) (LARGE_INTEGER dlibMove, DWORD dwOrigin,
			 ULARGE_INTEGER *plibNewPosition);
    	STDMETHOD(SetSize) (ULARGE_INTEGER cb);
	STDMETHOD(CopyTo) (IStream *pstm, ULARGE_INTEGER cb,
			ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    	STDMETHOD(Commit) (DWORD grfCommitFlags);
    	STDMETHOD(Revert) (void);
    	STDMETHOD(LockRegion) (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
    			DWORD dwLockType);
    	STDMETHOD(UnlockRegion) (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
    			DWORD dwLockType);
	STDMETHOD(Stat) (STATSTG *pstatstg, DWORD statflag);
	STDMETHOD(Clone)(IStream **ppstm);

    	STDSTATIC_(CMemStm FAR*) Create(HANDLE hMem, CRefMutexSem* pmxs);

    #ifdef _DEBUG

        HRESULT Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel);

        friend DEBUG_EXTENSION_API(dump_cmemstm);

    #endif // _DEBUG

	~CMemStm();

private:

    CMemStm();
    
    DWORD 		m_dwSig;	// Signature indicating this is our
					// implementation of
					// IStream: STREAM_SIG
    ULONG 		m_refs;  	// Number of references to this CmemStm
    ULONG 		m_pos;   	// Seek pointer for Read/Write
    HANDLE 		m_hMem; 	// Memory Handle passed on creation
    MEMSTM 		FAR* m_pData;   // Pointer to that memroy
    CRefMutexSem*	m_pmxs;		// mutex for MultiThread protection

    friend HRESULT STDAPICALLTYPE GetHGlobalFromStream(LPSTREAM, HGLOBAL *);
    friend LPSTREAM STDAPICALLTYPE 	CreateMemStm(DWORD, LPHANDLE);
    friend class CMarshalMemStm;
};

#define LOCKBYTE_SIG (0x0046574A)

//+-------------------------------------------------------------------------
//
//  Class: 	CMemBytes
//
//  Purpose:    an ILockBytes implementation atop (global shared in win16)
//		memory MEMSTM
//
//  Interface:  ILockBytes
//
//  History:    dd-mmm-yy Author    Comment
//		02-Dec-93 alexgo    32bit port
//
//  Notes:
//
// CMemBytes
// +---------+
// + pvtf    +    Shared  memory
// +---------+   +--------------+
// + m_pData +-->| cb           |	
// +---------+   | cRef         |	
//               | hGlobal      |--->+-------------+
//               +--------------+	 | Actual data |
// CMemBytes         MEMSTM  	  	 +-------------+
//
// cRef counts all CMemBytes pointers to this MEMSTM.
// It and fDeleteOnRelease control the GlobalFree'ing of the hGlobal.
//
//--------------------------------------------------------------------------

class FAR CMemBytes : public ILockBytes, public CPrivAlloc
{
public:
    	STDMETHOD(QueryInterface) (REFIID iidInterface,
    			void FAR* FAR* ppvObj);
    	STDMETHOD_(ULONG,AddRef) (void);
    	STDMETHOD_(ULONG,Release) (void);
    	STDMETHOD(ReadAt) (ULARGE_INTEGER ulOffset, VOID HUGEP *pv, ULONG cb,
   			ULONG FAR *pcbRead);
    	STDMETHOD(WriteAt) (ULARGE_INTEGER ulOffset, VOID const HUGEP *pv,
    			ULONG cb, ULONG FAR *pcbWritten);
    	STDMETHOD(Flush) (void);
    	STDMETHOD(SetSize) (ULARGE_INTEGER cb);
    	STDMETHOD(LockRegion) (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
    			DWORD dwLockType);
    	STDMETHOD(UnlockRegion) (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
    			DWORD dwLockType);
    	STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD statflag);

    	STDSTATIC_(CMemBytes FAR*) Create(HANDLE hMem);

    #ifdef _DEBUG

        HRESULT Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel);

        friend DEBUG_EXTENSION_API(dump_membytes);

    #endif // _DEBUG

ctor_dtor:
    	CMemBytes()
    	{
    		GET_A5();
    		m_hMem = NULL;
    		m_pData = NULL;
    		m_refs = 0;
    	}
    	~CMemBytes()
    	{
    		// empty body
    	}

private:
	DWORD 			m_dwSig;  	// Signature indicating this
						// is our implementation of
						// ILockBytes: LOCKBYTE_SIG
    	ULONG 			m_refs;  	// Normal reference count
    	HANDLE 			m_hMem;    	// Handle for bookeeping info
    						// (MEMSTM)
    	MEMSTM FAR* m_pData;	        	// Pointer to that memory

 	friend HRESULT STDAPICALLTYPE GetHGlobalFromILockBytes(LPLOCKBYTES,
 					HGLOBAL FAR*);
    	friend class CMarshalMemBytes;
	SET_A5;
};

#ifndef WIN32
//
// THE MARSHALLING CLASSES BELOW ARE ONLY IN 16BIT OLE!!!!
//

//+-------------------------------------------------------------------------
//
//  Class: 	CMarshalMemStm
//
//  Purpose:    provides marshalling for CMemStm's
//
//  Interface:  IMarshal
//
//  History:    dd-mmm-yy Author    Comment
//		02-Dec-93 alexgo    32bit port
//		05-Dec-93 alexgo    removed m_clsid
//
//  Notes:
//
// CMarshalMemStm can Marshal, Unmarshal CMemStm.  It is impletented as
// a seperate object accessible from CMemStm, CMemBytes: QueryIntreface of
// IMarshal on CMemStm's IStream will return an IMarshal pointer to
// CMarshalMemStm, but QueryInterface of IStream on that IMarshal will
// fail.
// Also QueryInterface of IUnknown on IMarshal will not return the same value
// As QueryInterface of IUnkown on the original IStream.
//
//--------------------------------------------------------------------------

class FAR CMarshalMemStm : public IMarshal
{
public:
    	STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);
    	STDMETHOD_(ULONG,AddRef) (void);
    	STDMETHOD_(ULONG,Release) (void);

    	STDMETHOD(GetUnmarshalClass)(THIS_ REFIID riid, LPVOID pv,
			DWORD dwDestContext, LPVOID pvDestContext,
			DWORD mshlflags, LPCLSID pCid);
    	STDMETHOD(GetMarshalSizeMax)(THIS_ REFIID riid, LPVOID pv,		
			DWORD dwDestContext, LPVOID pvDestContext,
			DWORD mshlflags, LPDWORD pSize);
    	STDMETHOD(MarshalInterface)(THIS_ IStream FAR* pStm, REFIID riid,
			LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
			DWORD mshlflags);
    	STDMETHOD(UnmarshalInterface)(THIS_ IStream FAR* pStm, REFIID riid,
                        LPVOID FAR* ppv);
    	STDMETHOD(ReleaseMarshalData)(THIS_ IStream FAR* pStm);
    	STDMETHOD(DisconnectObject)(THIS_ DWORD dwReserved);

    	STDSTATIC_(CMarshalMemStm FAR*) Create(CMemStm FAR* pMemStm);

ctor_dtor:
   	CMarshalMemStm()
   	{
   		GET_A5();
   		m_pMemStm = NULL;
   		m_refs = 0;
   	}
    	~CMarshalMemStm()
    	{
    		// empty body
    	}

private:
    	ULONG 		m_refs;		// Number of references to this CmemStm
    	CMemStm FAR* 	m_pMemStm; 	// Pointer to object [Un]Marshalled
	SET_A5;
};

//+-------------------------------------------------------------------------
//
//  Class: 	CMarshalMemBytes
//
//  Purpose:    provides marshalling for CMemBytes
//
//  Interface:  IMarshal
//
//  History:    dd-mmm-yy Author    Comment
//		02-Dec-93 alexgo    32bit port
//		05-Dec-93 alexgo    removed m_clsid
//
//  Notes:
//
// CMarshalMemBytes can Marshal, Unmarshal CMemBytes.  It is impletented as
// a seperate object accessible from CMemBytes, CMemBytes: QueryIntreface of
// IMarshal on CMemBytes's ILocBytes will return an IMarshal pointer to
// CMarshalMemBytes, but QueryInterface of ILockBytes on that IMarshal will
// fail.
// Also QueryInterface of IUnknown on IMarshal will not return the same value
// As QueryInterface of IUnkown on the original ILockBytes.
//
//--------------------------------------------------------------------------

class FAR CMarshalMemBytes : public IMarshal
{
public:
    	STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);
    	STDMETHOD_(ULONG,AddRef) (void);
    	STDMETHOD_(ULONG,Release) (void);

    	STDMETHOD(GetUnmarshalClass)(THIS_ REFIID riid, LPVOID pv,
			DWORD dwDestContext, LPVOID pvDestContext,
			DWORD mshlflags, LPCLSID pCid);
    	STDMETHOD(GetMarshalSizeMax)(THIS_ REFIID riid, LPVOID pv,
			DWORD dwDestContext, LPVOID pvDestContext,
			DWORD mshlflags, LPDWORD pSize);
    	STDMETHOD(MarshalInterface)(THIS_ IStream FAR* pStm, REFIID riid,
			LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
			DWORD mshlflags);
    	STDMETHOD(UnmarshalInterface)(THIS_ IStream FAR* pStm, REFIID riid,
                        LPVOID FAR* ppv);
    	STDMETHOD(ReleaseMarshalData)(THIS_ IStream FAR* pStm);
    	STDMETHOD(DisconnectObject)(THIS_ DWORD dwReserved);

    	STDSTATIC_(CMarshalMemBytes FAR*) Create(CMemBytes FAR* pMemBytes);

ctor_dtor:
    	CMarshalMemBytes()
    	{
    		GET_A5();
    		m_pMemBytes = NULL;
    		m_refs = 0;
    	}
    	~CMarshalMemBytes()
    	{
    		// empty body
    	}

private:
    	ULONG 			m_refs;		// Number of references to
    						// this CMemBytes
    	CMemBytes FAR* 		m_pMemBytes;	// Pointer to object
    						// [Un]Marshalled
	SET_A5;
};

#endif // !WIN32

#endif // _MemBytes_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\map_lp.h ===
////////////////////////////////////////////////////////////////////////////



class FAR CMapLongPtr : public CPrivAlloc
{
public:
	// Construction
	CMapLongPtr(DWORD memctx, UINT nBlockSize=10) 
		: m_mkv(memctx, sizeof(void FAR*), sizeof(LONG), nBlockSize) { }
	CMapLongPtr(DWORD memctx, UINT nBlockSize, UINT nHashTableSize) 
		: m_mkv(memctx, sizeof(void FAR*), sizeof(LONG), nBlockSize,
			&MKVDefaultHashKey, nHashTableSize) { }

	// Attributes
	// number of elements
	int     GetCount() const
				{ return m_mkv.GetCount(); }
	BOOL    IsEmpty() const
				{ return GetCount() == 0; }

	// Lookup
	BOOL    Lookup(LONG key, void FAR* FAR& value) const
				{ return m_mkv.Lookup((LPVOID)&key, sizeof(LONG), (LPVOID)&value); }

	BOOL    LookupHKey(HMAPKEY hKey, void FAR* FAR& value) const
				{ return m_mkv.LookupHKey(hKey, (LPVOID)&value); }

	BOOL    LookupAdd(LONG key, void FAR* FAR& value) const
				{ return m_mkv.LookupAdd((LPVOID)&key, sizeof(LONG), (LPVOID)&value); }

	// Add/Delete
	// add a new (key, value) pair
	BOOL    SetAt(LONG key, void FAR* value)
				{ return m_mkv.SetAt((LPVOID)&key, sizeof(LONG), (LPVOID)&value); }
	BOOL    SetAtHKey(HMAPKEY hKey, void FAR* value)
				{ return m_mkv.SetAtHKey(hKey, (LPVOID)&value); }

	// removing existing (key, ?) pair
	BOOL    RemoveKey(LONG key)
				{ return m_mkv.RemoveKey((LPVOID)&key, sizeof(LONG)); }

	BOOL    RemoveHKey(HMAPKEY hKey)
				{ return m_mkv.RemoveHKey(hKey); }

	void    RemoveAll()
				{ m_mkv.RemoveAll(); }


	// iterating all (key, value) pairs
	POSITION GetStartPosition() const
				{ return m_mkv.GetStartPosition(); }

	void    GetNextAssoc(POSITION FAR& rNextPosition, LONG FAR& rKey, void FAR* FAR& rValue) const
				{ m_mkv.GetNextAssoc(&rNextPosition, (LPVOID)&rKey, NULL, (LPVOID)&rValue); }

	HMAPKEY GetHKey(LONG key) const
				{ return m_mkv.GetHKey((LPVOID)&key, sizeof(LONG)); }

#ifdef _DEBUG
	void    AssertValid() const
				{ m_mkv.AssertValid(); }
#endif

private:
	CMapKeyToValue m_mkv;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\olecache.h ===
//+----------------------------------------------------------------------------
//
//	File:
//		olecache.h
//
//	Contents:
//		Better implementation of Ole presentation cache
//
//	Classes:
//		COleCache - ole presentation cache
//		CCacheEnum - enumerator for COleCache
//
//	Functions:
//
//	History:
//              Gopalk       Creation         Aug 23, 1996
//-----------------------------------------------------------------------------

#ifndef _OLECACHE_H_
#define _OLECACHE_H_

#include <cachenod.h>
#include <array.hxx>

//+----------------------------------------------------------------------------
//
//	Class:
//		COleCache
//
//	Purpose:
//		Ole presentation cache maintains the presentations for
//		one embedding.
//
//		For every unique FORMATETC, a cache node is created; cache
//		nodes encapsulate a presentation object and advise sink.
//
//		COleCache handles persistence of cache nodes, saving (loading)
//		their presentation objects, format descriptions, and advise
//		options.
//
//	Interface:
//		IUnknown (public IUnknown for aggregation purposes)
//		IOleCacheControl
//		IOleCache2
//		IPersistStorage
//		IViewObject2
//		IDataObject
//		m_UnkPrivate
//			the private IUnknown for aggregation purposes
//
//		INTERNAL GetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel);
//			returns the size of the aspect indicated
//
//	Private Interface used by friend classes:
//		INTERNAL_(void) OnChange(DWORD dwAspect, LONG lindex,
//				 BOOL fDirty);
//			CCacheNode instances use this to alert the cache to
//			changes to themselves so that the cache can be
//			marked dirty, if that is necessary
//		INTERNAL_(LPSTORAGE) GetStg(void);
//			CCacheNode uses this to obtain storage when cache
//			nodes are being saved
//
//		INTERNAL_(void) DetachCacheEnum(CCacheEnum FAR* pCacheEnum);
//			When about to be destroyed, CCacheEnum instances
//			use this to request to be taken off
//			the list of cache enumerators that COleCache
//			maintains.
//
//	Notes:
//		The constructor returns a pointer to the public IUnknown
//		of the object.  The private one is available at m_UnkPrivate.
//
//		The cache maintains its contents in an array.  Ids of the
//		cache nodes, such as those returned from Cache(), start out
//		being the index of the node in the array.  To detect
//		reuse of an array element, each id is incremented by the maximum
//		size of the array each time it is reused.  To find an element by
//		id simply take (id % max_array_size).  (id / max_array_size)
//		gives the number of times the array element has been used to
//		cache data.  (We do not allocate all the array members at once,
//		but instead grow the array on demand, up to the maximum
//		compile-time array size, MAX_CACHELIST_ITEMS.)
//		If id's do not match
//		exactly, before taking the modulo value, we know that a
//		request has been made for an earlier generation of data that
//		no longer exists.
//
//		The cache automatically maintains a "native format" node.
//		This node cannot be deleted by the user, and is always kept
//		up to date on disk.  This node attempts to keep either a
//		CF_METAFILEPICT, or CF_DIB rendering, with preference in
//		this order.
//		REVIEW, it's not clear how this node ever gets loaded.
//
//	History:
//              31-Jan-95 t-ScottH  add Dump method (_DEBUG only)
//		11/15/93 - ChrisWe - file inspection and cleanup;
//			removed use of nested classes where possible;
//			got rid of obsolete declaration of GetOlePresStream;
//			moved presentation stream limits to ole2int.h;
//			coalesced many BOOL flags into a single unsigned
//			quantity
//
//-----------------------------------------------------------------------------

// declare the array of cache node pointers
// COleCache will maintain an array of these

#define COLECACHEF_LOADEDSTATE          0x00000001
#define COLECACHEF_NOSCRIBBLEMODE       0x00000002
#define COLECACHEF_PBRUSHORMSDRAW       0x00000004
#define COLECACHEF_STATIC               0x00000008
#define COLECACHEF_FORMATKNOWN          0x00000010
#define COLECACHEF_OUTOFMEMORY          0x00000020
#define COLECACHEF_HANDSOFSTORAGE       0x00000040
#define COLECACHEF_CLEANEDUP            0x00000080
#define COLECACHEF_SAMEASLOAD           0x00000100
#define COLECACHEF_APICREATE            0x00000200
#ifdef _DEBUG
// In debug builds, this flag is set if aggregated
#define COLECACHEF_AGGREGATED           0x00001000
#endif // _DEBUG

// The following flag is used for clearing out native COLECACHE FLAGS.
// Remember to update the following when native formats are either 
// added or removed
#define COLECACHEF_NATIVEFLAGS            (COLECACHEF_STATIC | \
                                           COLECACHEF_FORMATKNOWN | \
                                           COLECACHEF_PBRUSHORMSDRAW)

// TOC signature
#define TOCSIGNATURE 1229865294

class COleCache : public IOleCacheControl, public IOleCache2, 
                  public IPersistStorage, public CRefExportCount,
                  public CThreadCheck
{
public:
    COleCache(IUnknown* pUnkOuter, REFCLSID rclsid, DWORD dwCreateFlags=0);
    ~COleCache();

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppv);
    STDMETHOD_(ULONG,AddRef)(void) ;
    STDMETHOD_(ULONG,Release)(void);

    // *** IOleCacheControl methods ***
    STDMETHOD(OnRun)(LPDATAOBJECT pDataObject);
    STDMETHOD(OnStop)(void);	

    // *** IOleCache methods ***
    STDMETHOD(Cache)(LPFORMATETC lpFormatetc, DWORD advf, LPDWORD lpdwCacheId);
    STDMETHOD(Uncache)(DWORD dwCacheId);
    STDMETHOD(EnumCache)(LPENUMSTATDATA* ppenumStatData);
    STDMETHOD(InitCache)(LPDATAOBJECT pDataObject);
    STDMETHOD(SetData)(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium, BOOL fRelease);

    // *** IOleCache2 methods ***		
    STDMETHOD(UpdateCache)(LPDATAOBJECT pDataObject, DWORD grfUpdf, LPVOID pReserved);
    STDMETHOD(DiscardCache)(DWORD dwDiscardOptions);

    // IPersist methods
    STDMETHOD(GetClassID)(LPCLSID pClassID);

    // IPersistStorage methods
    STDMETHOD(IsDirty)(void);
    STDMETHOD(InitNew)(LPSTORAGE pstg);
    STDMETHOD(Load)(LPSTORAGE pstg);
    STDMETHOD(Save)(LPSTORAGE pstgSave, BOOL fSameAsLoad);
    STDMETHOD(SaveCompleted)(LPSTORAGE pstgNew);
    STDMETHOD(HandsOffStorage)(void);		

    // Other public methods, called by defhndlr and deflink
    HRESULT GetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel);
    HRESULT Load(LPSTORAGE pstg, BOOL fCacheEmpty);
    HRESULT OnCrash();
    BOOL IsEmpty() {
        return(!m_pCacheArray->Length());
    }

    // Private IUnknown used in aggregation.
    // This has been implemented as a nested class because of
    // the member name collisions with the outer IUnknown.
    class CCacheUnkImpl : public IUnknown
    {
    public:
        // *** IUnknown methods ***
        STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppv);
        STDMETHOD_(ULONG,AddRef)(void) ;
        STDMETHOD_(ULONG,Release)(void);
    };
    friend class CCacheUnkImpl;
    CCacheUnkImpl m_UnkPrivate; // vtable for private IUnknown

    // IDataObject implementation of the cache.
    // This has been implemented as a nested class because
    // IDataObject::SetData collides with IOleCache::SetData
    class CCacheDataImpl : public IDataObject
    {
    public:
        // IUnknown methods
        STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppv);
        STDMETHOD_(ULONG,AddRef)(void);
        STDMETHOD_(ULONG,Release)(void);

        // IDataObject methods
        STDMETHOD(GetData)(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium);
        STDMETHOD(GetDataHere)(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium);
        STDMETHOD(QueryGetData)(LPFORMATETC pformatetc);
        STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC pformatetc,
                                         LPFORMATETC pformatetcOut);
        STDMETHOD(SetData)(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium, BOOL fRelease);
        STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppenumFormatEtc);
        STDMETHOD(DAdvise)(FORMATETC* pFormatetc, DWORD advf, IAdviseSink* pAdvSink,
                           DWORD* pdwConnection);
        STDMETHOD(DUnadvise)(DWORD dwConnection);
        STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppenumAdvise);
    };
    friend class CCacheDataImpl;
    CCacheDataImpl m_Data; // vtable for IDataObject

    // Other public methods
    BOOL IsOutOfMemory() {
        return(m_ulFlags & COLECACHEF_OUTOFMEMORY);
    }

private:
    // Private methods
    LPCACHENODE Locate(LPFORMATETC lpGivenForEtc, DWORD* lpdwCacheId=NULL);
    LPCACHENODE Locate(DWORD dwAspect, LONG lindex, DVTARGETDEVICE* ptd);
    LPCACHENODE UpdateCacheNodeForNative(void);
    void FindObjectFormat(LPSTORAGE pstg);
    HRESULT LoadTOC(LPSTREAM lpstream, LPSTORAGE pStg);
    HRESULT SaveTOC(LPSTORAGE pStg, BOOL fSameAsLoad);
    void AspectsUpdated(DWORD dwAspect);
    void CleanupFn(void);

    // IViewObject2 implementation of cache.
    // This has been implemented as a nested class because GetExtent
    // collides with the method on COleCache
    class CCacheViewImpl : public IViewObject2
    {
    public:
        // IUnknown methods
        STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppv);
        STDMETHOD_(ULONG,AddRef)(void);
        STDMETHOD_(ULONG,Release)(void);

        // IViewObject methods
        STDMETHOD(Draw)(DWORD dwDrawAspect, LONG lindex,
                        void FAR* pvAspect, DVTARGETDEVICE FAR* ptd,
                        HDC hicTargetDev, HDC hdcDraw,
                        LPCRECTL lprcBounds,
                        LPCRECTL lprcWBounds,
                        BOOL(CALLBACK *pfnContinue)(ULONG_PTR),
                        ULONG_PTR dwContinue);

        STDMETHOD(GetColorSet)(DWORD dwDrawAspect, LONG lindex, void* pvAspect,
                               DVTARGETDEVICE* ptd, HDC hicTargetDev,
                               LPLOGPALETTE* ppColorSet);

        STDMETHOD(Freeze)(DWORD dwDrawAspect, LONG lindex, void* pvAspect,
                          DWORD* pdwFreeze);
        STDMETHOD(Unfreeze)(DWORD dwFreeze);
        STDMETHOD(SetAdvise)(DWORD aspects, DWORD advf, LPADVISESINK pAdvSink);
        STDMETHOD(GetAdvise)(DWORD* pAspects, DWORD* pAdvf, LPADVISESINK* ppAdvSink);

        // IViewObject2 methods
        STDMETHOD(GetExtent)(DWORD dwDrawAspect, LONG lindex, DVTARGETDEVICE* ptd,
                             LPSIZEL lpsizel);

    };
    friend class CCacheViewImpl;
    CCacheViewImpl m_ViewObject; // vtable for IViewObject2

    // IAdviseSink implementation
    // This has been implemented as a nested class because of the need that 
    // the QueryInterface method on the Advise Sink should not return 
    // cache interfaces
    class CAdviseSinkImpl : public IAdviseSink
    {
    public:
        // IUnknown methods
        STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppv);
        STDMETHOD_(ULONG,AddRef)(void);
        STDMETHOD_(ULONG,Release)(void);

        // IAdviseSink methods
	STDMETHOD_(void,OnDataChange)(FORMATETC* pFormatetc, STGMEDIUM* pStgmed);
	STDMETHOD_(void,OnViewChange)(DWORD aspect, LONG lindex);
	STDMETHOD_(void,OnRename)(IMoniker* pmk);
	STDMETHOD_(void,OnSave)(void);
	STDMETHOD_(void,OnClose)(void);
    };
    friend class CAdviseSinkImpl;
    CAdviseSinkImpl m_AdviseSink;

    // Private member variables
    IUnknown* m_pUnkOuter;             // Aggregating IUnknown
    LPSTORAGE m_pStg;                  // Storage for cache
    CLSID m_clsid;                     // CLSID of object
    CLIPFORMAT m_cfFormat;             // Native clipformat of the object
    unsigned long m_ulFlags;           // Cache flags
    CArray<CCacheNode>* m_pCacheArray; // Cache array
    IAdviseSink* m_pViewAdvSink;       // IViewObject Advise Sink
    DWORD m_advfView;                  // IViewObject Advise control flags
    DWORD m_aspectsView;               // Aspects notified for view changes
    DWORD m_dwFrozenAspects;           // Frozen Aspects
    IDataObject* m_pDataObject;        // non-NULL if running; not ref counted
};

#endif  //_OLECACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\map_dwdw.h ===
////////////////////////////////////////////////////////////////////////////



class FAR CMapDwordDword : public CPrivAlloc
{
public:
	// Construction
	CMapDwordDword(UINT nBlockSize=10) 
		: m_mkv(sizeof(DWORD), sizeof(DWORD), nBlockSize) { }
	CMapDwordDword(UINT nBlockSize, UINT nHashTableSize) 
		: m_mkv(sizeof(DWORD), sizeof(DWORD), nBlockSize,
			&MKVDefaultHashKey, nHashTableSize) { }

	// Attributes
	// number of elements
	int     GetCount() const
				{ return m_mkv.GetCount(); }
	BOOL    IsEmpty() const
				{ return GetCount() == 0; }

	// Lookup
	BOOL    Lookup(DWORD key, DWORD FAR& value) const
				{ return m_mkv.Lookup((LPVOID)&key, sizeof(DWORD), (LPVOID)&value); }

	BOOL    LookupHKey(HMAPKEY hKey, DWORD FAR& value) const
				{ return m_mkv.LookupHKey(hKey, (LPVOID)&value); }

	BOOL    LookupAdd(DWORD key, DWORD FAR& value) const
				{ return m_mkv.LookupAdd((LPVOID)&key, sizeof(DWORD), (LPVOID)&value); }

	// Add/Delete
	// add a new (key, value) pair
	BOOL    SetAt(DWORD key, DWORD value)
				{ return m_mkv.SetAt((LPVOID)&key, sizeof(DWORD), (LPVOID)&value); }
	BOOL    SetAtHKey(HMAPKEY hKey, DWORD value)
				{ return m_mkv.SetAtHKey(hKey, (LPVOID)&value); }

	// removing existing (key, ?) pair
	BOOL    RemoveKey(DWORD key)
				{ return m_mkv.RemoveKey((LPVOID)&key, sizeof(DWORD)); }

	BOOL    RemoveHKey(HMAPKEY hKey)
				{ return m_mkv.RemoveHKey(hKey); }

	void    RemoveAll()
				{ m_mkv.RemoveAll(); }


	// iterating all (key, value) pairs
	POSITION GetStartPosition() const
				{ return m_mkv.GetStartPosition(); }

	void    GetNextAssoc(POSITION FAR& rNextPosition, DWORD FAR& rKey, DWORD FAR& rValue) const
				{ m_mkv.GetNextAssoc(&rNextPosition, (LPVOID)&rKey, NULL, (LPVOID)&rValue); }

	HMAPKEY GetHKey(DWORD key) const
				{ return m_mkv.GetHKey((LPVOID)&key, sizeof(DWORD)); }

#ifdef _DEBUG
	void    AssertValid() const
				{ m_mkv.AssertValid(); }
#endif

private:
	CMapKeyToValue m_mkv;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\map_uhw.h ===
////////////////////////////////////////////////////////////////////////////



class FAR CMapUintHwnd : public CPrivAlloc
{
public:
	// Construction
	CMapUintHwnd(UINT nBlockSize=10) 
		: m_mkv(sizeof(HWND), sizeof(UINT), nBlockSize) { }
	CMapUintHwnd(UINT nBlockSize, UINT nHashTableSize) 
		: m_mkv(sizeof(HWND), sizeof(UINT), nBlockSize,
			&MKVDefaultHashKey, nHashTableSize) { }

	// Attributes
	// number of elements
	int     GetCount() const
				{ return m_mkv.GetCount(); }
	BOOL    IsEmpty() const
				{ return GetCount() == 0; }

	// Lookup
	BOOL    Lookup(UINT key, HWND FAR& value) const
				{ return m_mkv.Lookup((LPVOID)&key, sizeof(UINT), (LPVOID)&value); }

	BOOL    LookupHKey(HMAPKEY hKey, HWND FAR& value) const
				{ return m_mkv.LookupHKey(hKey, (LPVOID)&value); }

	BOOL    LookupAdd(UINT key, HWND FAR& value) const
				{ return m_mkv.LookupAdd((LPVOID)&key, sizeof(UINT), (LPVOID)&value); }

	// Add/Delete
	// add a new (key, value) pair
	BOOL    SetAt(UINT key, HWND value)
				{ return m_mkv.SetAt((LPVOID)&key, sizeof(UINT), (LPVOID)&value); }
	BOOL    SetAtHKey(HMAPKEY hKey, HWND value)
				{ return m_mkv.SetAtHKey(hKey, (LPVOID)&value); }

	// removing existing (key, ?) pair
	BOOL    RemoveKey(UINT key)
				{ return m_mkv.RemoveKey((LPVOID)&key, sizeof(UINT)); }

	BOOL    RemoveHKey(HMAPKEY hKey)
				{ return m_mkv.RemoveHKey(hKey); }

	void    RemoveAll()
				{ m_mkv.RemoveAll(); }


	// iterating all (key, value) pairs
	POSITION GetStartPosition() const
				{ return m_mkv.GetStartPosition(); }

	void    GetNextAssoc(POSITION FAR& rNextPosition, UINT FAR& rKey, HWND FAR& rValue) const
				{ m_mkv.GetNextAssoc(&rNextPosition, (LPVOID)&rKey, NULL, (LPVOID)&rValue); }

	HMAPKEY GetHKey(UINT key) const
				{ return m_mkv.GetHKey((LPVOID)&key, sizeof(UINT)); }

#ifdef _DEBUG
	void    AssertValid() const
				{ m_mkv.AssertValid(); }
#endif

private:
	CMapKeyToValue m_mkv;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\mf.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	mf.h
//
//  Contents:	Declaration of CMfObject (metafile presentation object)
//
//  Classes:	CMfObject
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  add Dump method to CMfObject
//		24-Jan-94 alexgo    first pass converting to Cairo style
//				    memory allocation
//		29-Nov-93 alexgo    32bit port
//
//--------------------------------------------------------------------------

#include "olepres.h"
#include "olecache.h"
#include "cachenod.h"

#define RECORD_COUNT	16

#ifndef _MAC

typedef struct _METADC
{
    	int 	xMwo;
    	int     yMwo;
    	int     xMwe;
    	int     yMwe;
    	int     xre;
    	int     yre;
    	struct _METADC FAR* pNext;
} METADC, *PMETADC, FAR* LPMETADC;

typedef struct _METAINFO
{
    	METADC	headDc;
    	int	xwo;
    	int	ywo;
    	int	xwe;
    	int	ywe;
    	int	xro;
    	int	yro;
} METAINFO, *PMETAINFO, FAR* LPMETAINFO;

#endif


//+-------------------------------------------------------------------------
//
//  Class:  	CMfObject
//
//  Purpose:    Metafile presentation object
//
//  Interface:  IOlePresObj
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  add Dump method (_DEBUG only) (this method
//                                  is also a method in IOlePresObj
//		29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

class FAR CMfObject : public IOlePresObj, public CPrivAlloc
{
public:
  	 CMfObject(LPCACHENODE pCacheNode, DWORD dwAspect,
  	 	BOOL fConvert = FALSE);
  	 ~CMfObject(void);

    	STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    	STDMETHOD_(ULONG,AddRef) (THIS) ;
    	STDMETHOD_(ULONG,Release) (THIS);

    	STDMETHOD(GetData) (THIS_ LPFORMATETC pformatetcIn,
				LPSTGMEDIUM pmedium );
    	STDMETHOD(GetDataHere) (THIS_ LPFORMATETC pformatetcIn,
				LPSTGMEDIUM pmedium );							
    	
	STDMETHOD(SetDataWDO)    (THIS_ LPFORMATETC pformatetc,
    				STGMEDIUM FAR * pmedium,
				BOOL fRelease, IDataObject * pdo);
	
    	STDMETHOD(Draw) (THIS_ void FAR* pvAspect, HDC hicTargetDev,
    				HDC hdcDraw,
                    		LPCRECTL lprcBounds,
                    		LPCRECTL lprcWBounds,
				BOOL (CALLBACK * pfnContinue)(ULONG_PTR),
				ULONG_PTR dwContinue);
	STDMETHOD(GetExtent) (THIS_ DWORD dwAspect, LPSIZEL lpsizel);
	STDMETHOD(Load) (THIS_ LPSTREAM pstm, BOOL fReadHeaderOnly = FALSE);
	STDMETHOD(Save) (THIS_ LPSTREAM pstm);
	STDMETHOD(GetColorSet) (void FAR* pvAspect, HDC hicTargetDev,
				LPLOGPALETTE FAR* ppColorSet);
	STDMETHOD_(BOOL, IsBlank) (THIS);	
	STDMETHOD_(void, DiscardHPRES)(THIS);

#ifndef _MAC
	inline int CallbackFuncForDraw(HDC hdc, LPHANDLETABLE lpHTable,
				LPMETARECORD lpMFR, int nObj);

	inline int CallbackFuncForGetColorSet(HDC hdc, LPHANDLETABLE lpHTable,
				LPMETARECORD lpMFR, int nObj);
#endif
	
    #ifdef _DEBUG
        STDMETHOD(Dump) (THIS_ char **ppszDump, ULONG ulFlag, int nIndentLevel);
    #endif // _DEBUG
	
private:

#ifndef _MAC
	INTERNAL_(HANDLE)	GetHmfp (void);
	INTERNAL_(BOOL)		PopDc (void);
	INTERNAL_(BOOL)		PushDc (void);
	INTERNAL_(void)		CleanStack(void);
#endif

	INTERNAL		ChangeData (HANDLE hMfp, BOOL fDelete);
	INTERNAL_(HANDLE)	LoadHPRES(void);
	INTERNAL_(HANDLE)	GetCopyOfHPRES(void);

	INTERNAL_(void)		SetPictOrg (HDC, int, int, BOOL);
	INTERNAL_(void)		SetPictExt (HDC, int, int);
	INTERNAL_(void)		ScalePictExt (HDC, int, int, int, int);
	INTERNAL_(void)		ScaleRectExt (HDC, int, int, int, int);
	
shared_state:
	ULONG			m_ulRefs;
#ifdef _MAC
	PicHandle		m_hPres;
#else
    	HMETAFILE		m_hPres;

	// these are used only during draw
    	LPMETAINFO		m_pMetaInfo;
    	LPMETADC		m_pCurMdc;
    	BOOL			m_fMetaDC;
    	int			m_nRecord;
    	HRESULT			m_error;
	LPLOGPALETTE		m_pColorSet;
	BOOL			m_fConvert;
#endif	
	BOOL (CALLBACK * m_pfnContinue)(ULONG_PTR);
	ULONG_PTR      	        m_dwContinue;
	DWORD			m_dwAspect;
	DWORD			m_dwSize;
	LONG			m_lWidth;
	LONG			m_lHeight;
	LPCACHENODE		m_pCacheNode;	
        HPALETTE		m_hPalDCOriginal;
        HPALETTE		m_hPalLast;

};
	

INTERNAL_(DWORD) MfGetSize (LPHANDLE lphmf);

#ifndef _MAC
FARINTERNAL_(HMETAFILE)  QD2GDI(HANDLE);

int CALLBACK __loadds MfCallbackFuncForDraw(HDC hdc, HANDLETABLE FAR* lpHTable,
			METARECORD FAR* lpMFR, int  nObj, LPARAM lpobj);

int CALLBACK __loadds MfCallbackFuncForGetColorSet(HDC hdc,
			HANDLETABLE FAR* lpHTable,
			METARECORD FAR* lpMFR, int  nObj, LPARAM lpobj);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\oaholder.h ===
//+----------------------------------------------------------------------------
//
//	File:
//		oaholder.h
//
//	Contents:
//		concrete IOleAdviseHolder declaration
//
//	Classes:
//		COAHolder, concrete version of IOleAdviseHolder
//
//	Functions:
//
//	History:
//              31-Jan-95 t-ScottH  added Dump method to COAHolder class
//		24-Jan-94 alexgo    first pass converting to Cairo style
//				    memory allocation
//		11/01/93 - ChrisWe - created
//
//-----------------------------------------------------------------------------

#ifndef _OAHOLDER_H_
#define _OAHOLDER_H_

#ifdef _DEBUG
#include <dbgexts.h>
#endif // _DEBUG

//+----------------------------------------------------------------------------
//
//	Class:
//		COAHolder
//
//	Purpose:
//		Provides concrete implementation of IOleAdviseHolder; a helper
//		class that OLE implementors can use
//
//	Interface:
//		IOleAdviseHolder
//		SendOnLinkSrcChange() - multicasts the OnLinkSrcChange
//			notification to any registered advise sinks that support
//			IAdviseSink2
//
//	Notes:
//		Is hard coded to always be allocated from Task memory
//			(MEMCTX_TASK).
//
//		Connection numbers run from [1..n], and while the implementation
//		uses an array, indexed from [0..n-1], the returned value is
//		one more than the array index of the sink; Advise() and
//		Unadvise() do the adjustment arithmetic;  all of this means
//		that elements can't be shifted around, or they won't be found
//		again.
//
//		REVIEW -- IS NOT THREAD SAFE under assumption that documents
//		will always be single threaded
//
//
//	History:
//              31-Jan-95  t-ScottH  added _DEBUG only Dump method
//		11/01/93 - ChrisWe - moved declaration to oaholder.h
//		10/28/93 - ChrisWe - removed use of CPtrArray
//		10/28/93 - ChrisWe - file cleanup and inspection for Cairo
//
//-----------------------------------------------------------------------------

class FAR COAHolder : public IOleAdviseHolder, public CSafeRefCount
{
public:
	COAHolder();

	// *** IUnknown methods ***
	STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppv);
	STDMETHOD_(ULONG,AddRef) () ;
	STDMETHOD_(ULONG,Release) ();
	
	// *** IOleAdviseHolder methods ***
	STDMETHOD(Advise)(IAdviseSink FAR* pAdvSink, DWORD FAR* pdwConnection);
	STDMETHOD(Unadvise)(DWORD dwConnection);
	STDMETHOD(EnumAdvise)(IEnumSTATDATA FAR* FAR* ppenumAdvise);

	STDMETHOD(SendOnRename)(IMoniker FAR* pMk);
	STDMETHOD(SendOnSave)();
	STDMETHOD(SendOnClose)();

	// non-interface methods
	HRESULT SendOnLinkSrcChange(IMoniker FAR* pmk);

    #ifdef _DEBUG

        HRESULT Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel);

        // need to be able to access COAHolder private data members in the
        // following debugger extension APIs
        // this allows the debugger extension APIs to copy memory from the
        // debuggee process memory to the debugger's process memory
        // this is required since the Dump method follows pointers to other
        // structures and classes
        friend DEBUG_EXTENSION_API(dump_oaholder);
        friend DEBUG_EXTENSION_API(dump_deflink);
        friend DEBUG_EXTENSION_API(dump_defobject);

    #endif // _DEBUG

private:
	~COAHolder();

#define COAHOLDER_GROWBY 5 /* number of array elements to add each realloc */
	IAdviseSink FAR *FAR *m_ppIAS; // array of advise sinks
	int m_iSize; // size of array of advise sinks
	SET_A5;
};

#endif // _OAHOLDER_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\olepres.h ===
//+----------------------------------------------------------------------------
//
//	File:
//		olepres.h
//
//	Contents:
//		IOlePresObj declaration
//
//	Classes:
//
//	Functions:
//
//	History:
//              01-Jan-95 t-ScottH  add Dump method to the interface (_DEBUG only)
//		11/11/93 - ChrisWe - fix type qualifier problems on
//			IOlePresObj::Draw; replace define of LPOLEPRESOBJECT
//			with a typedef
//		11/10/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#ifndef _OLEPRES_H_
#define _OLEPRES_H_


#undef  INTERFACE
#define INTERFACE   IOlePresObj

#ifdef MAC_REVIEW
Does this need to be made A5 aware?
#endif

DECLARE_INTERFACE_(IOlePresObj, IUnknown)
{
	// *** IUnknown methods ***
	STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
	STDMETHOD_(ULONG,Release) (THIS) PURE;

	// *** IOlePresObj methods ***
	// NOTE: these methods match similarly named methods in IDataObject,
	// IViewObject and IOleObject
	STDMETHOD(GetData)(THIS_ LPFORMATETC pformatetcIn,
			LPSTGMEDIUM pmedium ) PURE;
	STDMETHOD(GetDataHere)(THIS_ LPFORMATETC pformatetcIn,
			LPSTGMEDIUM pmedium ) PURE;
	STDMETHOD(SetDataWDO)(THIS_ LPFORMATETC pformatetc,
			STGMEDIUM FAR * pmedium, BOOL fRelease, IDataObject * pdo) PURE;
	STDMETHOD(Draw)(THIS_ void FAR* pvAspect, HDC hicTargetDev,
			HDC hdcDraw, LPCRECTL lprcBounds,
			LPCRECTL lprcWBounds,
			BOOL (CALLBACK * pfnContinue)(ULONG_PTR),
			ULONG_PTR dwContinue) PURE;
	STDMETHOD(GetExtent)(THIS_ DWORD dwAspect, LPSIZEL lpsizel) PURE;

	STDMETHOD(Load)(THIS_ LPSTREAM pstm, BOOL fReadHeaderOnly) PURE;
	STDMETHOD(Save)(THIS_ LPSTREAM pstm) PURE;
	STDMETHOD(GetColorSet)(THIS_ void FAR* pvAspect,
			HDC hicTargetDev,
			LPLOGPALETTE FAR* ppColorSet) PURE;		
	STDMETHOD_(BOOL, IsBlank)(THIS) PURE;
	STDMETHOD_(void, DiscardHPRES)(THIS) PURE;

        #ifdef _DEBUG
        STDMETHOD(Dump)(THIS_ char **ppszDumpOA, ULONG ulFlag, int nIndentLevel) PURE;
        #endif // _DEBUG
};

typedef IOlePresObj FAR *LPOLEPRESOBJECT;

#endif  //_OLEPRES_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\qd2gdi.h ===
/****************************************************************************

                   QuickDraw PICT Import Filter

*****************************************************************************

   This file contains the interface for the QuickDraw import filter 
   that reads Mac pictures from disk and/or memory.  In addition to the
   Aldus filter interface, it also supports a parameterized interface
   for Microsoft applications to control some conversion results.

****************************************************************************/

/*--- Possible Aldus-defined error code returns ---*/

#define NOERR              0     // Conversion succeeded

#define IE_NOT_MY_FILE     5301  // Invalid version (not version 1 or 2 PICT)
                                 // Invalid QD2GDI structure version (greater than 2)
                                 // Ill-formed PICT header record sequence

#define	IE_TOO_BIG        5302  // Image extents exceed 32K

#define IE_BAD_FILE_DATA   5309  // Image bounding box is empty
                                 // Attempt to read past end of picture
                                 // Corrupted input file
                                 // Zero-length record

#define	IE_IMPORT_ABORT   5310  // Opening of source image failed
                                 // Read failure (network failure, floppy popped)
                                 // Most I/O errors

#define IE_MEM_FULL        5311  // CreateMetaFile() failure
                                 // CloseMetaFile() failure
                                 // Unable to allocate memory (out of memory)

#define IE_MEM_FAIL	      5315  // Handle lock failure

#define IE_NOPICTURES      5317  // Empty bounding rectangle or nothing drawn

#define IE_UNSUPP_VERSION  5342  // User-defined abort performed


/*--- Aldus-defined file access block ---*/

typedef DWORD FILETYPE;

typedef struct 
{
	unsigned	slippery : 1;	/* TRUE if file may disappear. */
	unsigned	write : 1;		/* TRUE if open for write. */
	unsigned	unnamed : 1;	/* TRUE if unnamed. */
	unsigned	linked : 1;		/* Linked to an FS FCB. */
	unsigned	mark : 1;		/* Generic mark bit. */
	FILETYPE	fType;			/* The file type. */
#define IBMFNSIZE 124
	short		handle;			/* MS-DOS open file handle. */
	char		fullName[IBMFNSIZE];	/* Device, path, file names. */
	DWORD		filePos;		/* Our current file posn. */
} FILESPEC, FAR *LPFILESPEC;


/*--- Preferences memory block ---*/

typedef struct                   // "old" version 1 USERPREFS
{
   char     signature[6];
   WORD     version;
   LPSTR    sourceFilename;
   HANDLE   sourceHandle;
   LPSTR    destinationFilename;
   BYTE     penPatternAction;
   BYTE     nonSquarePenAction;
   BYTE     penModeAction;
   BYTE     textModeAction;
   BYTE     charLock;
   BYTE     nonRectRegionAction;
   BOOL     PICTinComment;
   BOOL     optimizePP;
   WORD     lineClipWidthThreshold;
   WORD     reserved[6];   
} USERPREFS_V1, FAR *LPUSERPREFS_V1;


typedef struct                   // current version 2 USERPREFS
{
   char     signature[6];
   WORD     version;
   WORD     size;
   LPSTR    sourceFilename;
   HANDLE   sourceHandle;
   LPSTR    destinationFilename;
   BYTE     penPatternAction;
   BYTE     nonSquarePenAction;
   BYTE     penModeAction;
   BYTE     textModeAction;
   BYTE     nonRectRegionAction;
   BOOL     optimizePP;
   WORD     reserved[6];

} USERPREFS, FAR * LPUSERPREFS;

typedef struct {
	HANDLE hmf;		//handle to resulting
	RECT   bbox;	//bounding box
	WORD   inch;	//metafile units/inch (for image size)
}PICTINFO;


/*********************** Exported Function Definitions **********************/

int FAR PASCAL GetFilterInfo( short PM_Version, LPSTR lpIni, 
                              HANDLE FAR * lphPrefMem, 
                              HANDLE FAR * lphFileTypes );
/* Returns information about this filter. 
   Input parameters are PM_Version which is the filter interface version#
         and lpIni which is a copy of the win.ini entry
   Output parameters are lphPrefMem which is a handle to moveable global
         memory which will be allocated and initialized.
         lphFileTypes is a structure that contains the file types
         that this filter can import. (For MAC only)
   This routine should be called once, just before the filter is to be used
   the first time. */


void FAR PASCAL GetFilterPref( HANDLE hInst, HANDLE hWnd, HANDLE hPrefMem, WORD wFlags );
/* Input parameters are hInst (in order to access resources), hWnd (to
   allow the DLL to display a dialog box), and hPrefMem (memory allocated
   in the GetFilterInfo() entry point).  WFlags is currently unused, but
   should be set to 1 for Aldus' compatability */


short FAR PASCAL ImportGR( HDC hdcPrint, LPFILESPEC lpFileSpec, 
                           PICTINFO FAR * lpPict, HANDLE hPrefMem );
/* Import the metafile in the file indicated by the lpFileSpec. The 
   metafile generated will be returned in lpPict. */


short FAR PASCAL ImportEmbeddedGr( HDC hdcPrint, LPFILESPEC lpFileSpec, 
                                   PICTINFO FAR * lpPict, HANDLE hPrefMem,
                                   DWORD dwSize, LPSTR lpMetafileName );
/* Import the metafile in using the previously opened file handle in
   the structure field lpFileSpec->handle. Reading begins at offset
   lpFileSpect->filePos, and the convertor will NOT expect to find the
   512 byte PICT header.  The metafile generated will be returned in
   lpPict and can be specified via lpMetafileName (NIL = memory metafile,
   otherwise, fully qualified filename. */

short FAR PASCAL QD2GDI( LPUSERPREFS lpPrefMem, PICTINFO FAR * lpPict );
/* Import the metafile as specified using the parameters supplied in the
   lpPrefMem.  The metafile will be returned in lpPict. */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\ostm2stg.h ===
/* ostm2stg.h

    Used by ostm2stg.cpp only

    Defines a generic object structure which stores all the data necessary
    to construct either a 2.0 IStorage or a 1.0 OLESTREAM
*/



#define OLE_PRESENTATION_STREAM_1 OLESTR("\2OlePres001")

// We will need to do conversions to and from WIN16 and WIN32 bitmaps, so
// define what a BITMAP used to be under WIN16 (Same for METAFILEPICT).

#pragma pack(1)					   // Ensure the structure is not expanded
								   // for alignment reasons
typedef struct tagWIN16BITMAP
{
    short   bmType;
    short   bmWidth;
    short   bmHeight;
    short   bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    void FAR* bmBits;
} WIN16BITMAP, * LPWIN16BITMAP;

typedef struct tagWIN16METAFILEPICT
{
    short   mm;
    short   xExt;
    short   yExt;
    WORD    hMF;
} WIN16METAFILEPICT, * LPWIN16METAFILEPICT;


#pragma pack()      				// Resume normal packing 

// Version number written to stream, From OLE 1.0 ole.h
const DWORD dwVerToFile = 0x0501;

typedef enum { ctagNone, ctagCLSID, ctagString } CLASSTAG;
typedef enum { ftagNone, ftagClipFormat, ftagString } FORMATTAG;

class CClass : public CPrivAlloc
{
public:
    CLSID m_clsid;    // These two should always represent
    LPOLESTR m_szClsid;  // the same CLSID

    INTERNAL Set   (REFCLSID clsid, LPSTORAGE pstg);
    INTERNAL SetSz (LPOLESTR pcsz);
    INTERNAL Reset (REFCLSID clsid);
    CClass (void);
    ~CClass (void);

};
typedef CClass CLASS;


class CData : public CPrivAlloc
{
public:
    ULONG  m_cbSize;
    LPVOID m_pv;      // the same memory
    HANDLE m_h;
    BOOL   m_fNoFree; // Free memory in destructor?

    CData (void);
    ~CData (void);
};
typedef CData DATA;
typedef CData *PDATA;


class CFormat : public CPrivAlloc
{
public:
    FORMATTAG m_ftag;
    struct
    {
        CLIPFORMAT m_cf;
        DATA         m_dataFormatString;
    };

    CFormat (void);
    inline BOOL operator== (const CFormat FAR&) 
    { 
        Win4Assert(0 && "Format == Used"); 
        return FALSE;
    };
};
typedef CFormat FORMAT;
typedef CFormat *PFORMAT;


class CPres : public CPrivAlloc
{
public:
    FORMAT m_format;
    ULONG  m_ulHeight;
    ULONG  m_ulWidth;
    DATA   m_data;

    CPres (void);
};
typedef CPres PRES;
typedef CPres *PPRES;


// OLE 1.0 values.  Used in m_lnkupdopt
#define UPDATE_ALWAYS  0L
#define UPDATE_ONSAVE  1L
#define UPDATE_ONCALL  2L
#define UPDATE_ONCLOSE 3L

// OLE 1.0 format id's
// These never change.
#define FMTID_LINK   1L
#define FMTID_EMBED  2L
#define FMTID_STATIC 3L
#define FMTID_PRES   5L

class CGenericObject : CPrivAlloc
{
public:
    CLASS       m_class;
    CLASS       m_classLast;
    PPRES       m_ppres;            
    DATA        m_dataNative;
    BOOL        m_fLink;
    BOOL        m_fStatic;
    BOOL        m_fNoBlankPres;
    LPOLESTR    m_szTopic;
    LPOLESTR    m_szItem;
    ULONG       m_lnkupdopt;

    CGenericObject (void);
    ~CGenericObject (void);
};
typedef CGenericObject GENOBJ;
typedef CGenericObject FAR* PGENOBJ;
typedef const GENOBJ FAR * PCGENOBJ;



static INTERNAL OLESTREAMToGenericObject
    (LPOLESTREAM pos,
    PGENOBJ      pgenobj)
;

static INTERNAL GetStaticObject
    (LPOLESTREAM pos,
    PGENOBJ      pgenobj)
;

static INTERNAL GetPresentationObject
    (LPOLESTREAM pos,
    PGENOBJ      pgenobj,   
    BOOL         fStatic = FALSE)
;       

static INTERNAL GetStandardPresentation
    (LPOLESTREAM pos,
    PGENOBJ      pgenobj,
    CLIPFORMAT   cf)
;

static INTERNAL GetGenericPresentation
    (LPOLESTREAM pos,
    PGENOBJ      pgenobj)
;

static INTERNAL GetSizedDataOLE1Stm
    (LPOLESTREAM pos,
    PDATA        pdata)
;

static INTERNAL OLE1StreamToUL
    (LPOLESTREAM pos,
     ULONG FAR* pul)
;

static INTERNAL GenericObjectToOLESTREAM
    (const GENOBJ FAR&  genobj,
    LPOLESTREAM           pos)
;

static INTERNAL OLE1StmToString
    (LPOLESTREAM pos,
    LPOLESTR FAR*   psz)
;

static INTERNAL PutPresentationObject
    (LPOLESTREAM     pos,
    const PRES FAR*  pres,
    const CLASS FAR& cls,
    BOOL                  fStatic = FALSE)
;

static INTERNAL PutStandardPresentation
    (LPOLESTREAM     pos,
    const PRES FAR*  pres)
;

static INTERNAL PutGenericPresentation
    (LPOLESTREAM     pos,
    const PRES FAR*  pres,
    LPCOLESTR            szClass)
;


static INTERNAL StringToOLE1Stm
    (LPOLESTREAM pos,
     LPCOLESTR       sz)
;

static INTERNAL SizedDataToOLE1Stm
    (LPOLESTREAM    pos,
    const DATA FAR& data)
;

static INTERNAL PutNetworkInfo
    (LPOLESTREAM pos,
    LPOLESTR         szTopic)
;

static INTERNAL Read20OleStream
    (LPSTORAGE  pstg,
    PGENOBJ pgenobj)
;

static INTERNAL Read20PresStream
    (LPSTORAGE  pstg,
    PGENOBJ pgenobj,
    BOOL fObjFmtKnown)
;

static INTERNAL StorageToGenericObject
    (LPSTORAGE pstg,
    PGENOBJ   pgenobj)
;

static INTERNAL MonikerIntoGenObj
    (PGENOBJ  pgenobj,
    REFCLSID  clsidLast,
    LPMONIKER pmk)
;

static INTERNAL OLE2StmToSizedData
    (LPSTREAM pstm,
    PDATA    pdata,
    ULONG    cbSizeDelta=0,
    ULONG    cbSizeKnown=0)
;

static INTERNAL Read20NativeStreams
    (LPSTORAGE  pstg,
    PDATA       pdata)
;

static INTERNAL GenObjToOLE2Stm
    (LPSTORAGE pstg, 
     const GENOBJ FAR&   genobj)
;

FARINTERNAL GenericObjectToIStorage
    (const GENOBJ FAR&  genobj,
    LPSTORAGE                   pstg,
    const DVTARGETDEVICE FAR*   ptd)
;

static INTERNAL PresToNewOLE2Stm
    (LPSTORAGE                  pstg,
    BOOL                        fLink,
    const PRES FAR&             pres,
    const DVTARGETDEVICE FAR*   ptd,
    LPOLESTR                        szStream,
    BOOL                        fPBrushNative = FALSE);
;

static INTERNAL PresToIStorage
    (LPSTORAGE                  pstg,
    const GENOBJ FAR&           genobj,
    const DVTARGETDEVICE FAR*   ptd)
;

static INTERNAL Write20NativeStreams
    (LPSTORAGE              pstg,
    const GENOBJ FAR&   genobj)
;

static INTERNAL WriteFormat
    (LPSTREAM           pstm,
    const FORMAT FAR&   format)
;

static INTERNAL ReadFormat
    (LPSTREAM pstm,
    PFORMAT   pformat)
;

static INTERNAL DataObjToOLE2Stm
    (LPSTREAM  pstm,
    const DATA FAR& data)
;


static INTERNAL OLE2StmToUL
    (LPSTREAM   pstm,
     ULONG FAR* pul)
;


inline static INTERNAL ULToOLE2Stm
    (LPSTREAM pstm,
    ULONG     ul)
;

inline static INTERNAL FTToOle2Stm (LPSTREAM pstm);

static INTERNAL FindPresStream
    (LPSTORAGE          pstg,
    LPSTREAM FAR*       ppstm,
    BOOL                fObjFmtKnown)
;

static INTERNAL MonikerToOLE2Stm
    (LPSTREAM pstm,
    LPOLESTR      szFile,
    LPOLESTR      szItem,
    CLSID     clsid)
;

static INTERNAL OLE2StmToMoniker
    (LPSTREAM       pstm,
    LPMONIKER FAR*  ppmk)
;

static INTERNAL ReadRealClassStg
    (LPSTORAGE pstg,
    LPCLSID pclsid)
;


INTERNAL wCLSIDFromProgID(LPOLESTR szClass, LPCLSID pclsid,
        BOOL fForceAssign);

INTERNAL wProgIDFromCLSID
    (REFCLSID clsid,
    LPOLESTR FAR* pszClass)
;

INTERNAL wWriteFmtUserType 
    (LPSTORAGE, 
    REFCLSID)
;

INTERNAL_(BOOL) wIsValidHandle 
    (HANDLE h, 
    CLIPFORMAT cf)  
;      

inline INTERNAL_(VOID) ConvertBM32to16(LPBITMAP lpsrc, LPWIN16BITMAP lpdest);
inline INTERNAL_(VOID) ConvertBM16to32(LPWIN16BITMAP lpsrc, LPBITMAP lpdest);
inline INTERNAL_(VOID) ConvertMF16to32(
								LPWIN16METAFILEPICT lpsrc,
    							LPMETAFILEPICT      lpdest );
inline INTERNAL_(VOID) ConvertMF32to16(
   								LPMETAFILEPICT      lpsrc,
   								LPWIN16METAFILEPICT lpdest );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\reterr.h ===
//+----------------------------------------------------------------------------
//
//	File:
//		reterr.h
//
//	Contents:
//		Macros that perform an (argument) operation, and on failure,
//		give a warning, and branch to error returns
//
//	Classes:
//
//	Functions:
//
//	History:
//		12/30/93 - ChrisWe - redefined Warn macro; added DbgWarn
//
//-----------------------------------------------------------------------------

/* Jason's error handling macros */

#ifndef RETERR_H
#define RETERR_H

#ifdef _DEBUG
#ifdef NEVER
FARINTERNAL_(void) wWarn(LPOLESTR sz, LPOLESTR szFile, int iLine);
#define Warn(sz) wWarn(sz, __FILE__, __LINE__)
#endif // NEVER
FARINTERNAL_(void) DbgWarn(LPSTR psz, LPSTR pszFileName, ULONG uLineno);
#define Warn(sz) DbgWarn(sz, __FILE__, __LINE__)
#else
#define Warn(sz)
#endif // _DEBUG

// Call x.  If hresult is not NOERROR, goto errRtn.
#define ErrRtn(x) do {if (NOERROR != (x)) {Warn(NULL); goto errRtn;}} while(0)

// Call x.  If hresult is not NOERROR, store it in hresult and goto errRtn.
#define ErrRtnH(x) do {if (NOERROR != (hresult=(x))) {Warn(NULL); goto errRtn;}} while (0)

// If x, goto errRtn.
#define ErrNz(x) do {if (x) {Warn(NULL); goto errRtn;}} while (0)

// If x==0, goto errRtn.
#define ErrZ(x) do {if (!(x)) {Warn(NULL); goto errRtn;}} while (0)

// If x==0, goto errRtn with a specific scode
#define ErrZS(x, scode) do {if (!(x)) {Warn(NULL); hresult=ResultFromScode(scode); goto errRtn;}} while (0)

// Call x.  If hresult is not NOERROR, return that hresult.
#define RetErr(x) do {HRESULT hresult; if (NOERROR != (hresult=(x))) {Warn(NULL); return hresult;}} while (0)

// Return unexpected error if x is non-zero
#define RetNz(x)  do {if (x) {Warn(NULL); return ReportResult(0, E_UNEXPECTED, 0, 0);}} while (0)

// Return specific scode if x is non-zero
#define RetNzS(x, scode)  do {if (x) {Warn(NULL); return ResultFromScode (scode);}} while (0)

// Return unexpected error if x is zero
#define RetZ(x)   do {if (!(x)) {Warn(NULL); return ReportResult(0, E_UNEXPECTED, 0, 0);}} while (0)

// Return specific scode if x is zero
#define RetZS(x, scode) do {if (!(x)) {Warn(NULL); return ResultFromScode (scode);}} while (0)

#endif // RETERR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inc\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   empty
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\..\common\$(DEST_TREE);..\..\..\ih;..\..\inc

C_DEFINES=  \
            $(C_DEFINES)

SOURCES = ..\empty.cxx

!include ..\..\precomp2.inc

SYNCHRONIZE_BLOCK=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inplace\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   inplace
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\..\common\$(DEST_TREE);..\..\..\ih;..\..\inc

SOURCES=      \
              ..\inplace.cpp

UMTYPE=       windows

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inplace\inplace.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       inplace.cpp
//
//  Contents:   Implementation of OLE inplace editing API's
//
//  Classes:    CFrame implementation, used to store per-window info
//
//  Functions:  OleCreateMenuDescriptor
//      OleSetMenuDescriptor
//      OleDestroyMenuDescriptor
//      OleTranslateAccelerator
//      IsAccelerator
//      FrameWndFilterProc
//      MessageFilterProc
//
//
//  History:    dd-mmm-yy Author    Comment
//      31-Mar-94 ricksa    Fixed menu merge bug & added some comments
//      23-Feb-94 alexgo    added call tracing
//      11-Jan-94 alexgo    added VDATEHEAP macros to every function
//      31-Dec-93 ChrisWe   fixed casts in OutputDebugStrings
//      07-Dec-93 alexgo    merged changes with shipped 16bit 2.01a
//                          (RC9).  Also removed lots of bad inlining.
//      01-Dec-93 alexgo    32bit port, made globals static
//      07-Dec-92 srinik    Converted frame filter implementatio
//                          into a C++ class implementation.
//                          So, most of the code is rewritten.
//      09-Jul-92 srinik    author
//
//  Notes:      REVIEW32:  we need to do something about the new
//      focus management policy for NT (re TonyWi's mail)
//
//--------------------------------------------------------------------------

#include <le2int.h>
#pragma SEG(inplace)

#include "inplace.h"

NAME_SEG(InPlace)
  ASSERTDATA

// to keep the code bases common
// REVIEW32:  we may want to clean this up a bit
#define FARPROC  WNDPROC


// we'd be faster if we used an atom instead of a string!
static const OLECHAR    szPropFrameFilter[] = OLESTR("pFrameFilter");

static WORD             wSignature; //    =  (WORD) { 'S', 'K' }

static HHOOK            hMsgHook = NULL;
static PCFRAMEFILTER    pFrameFilter = NULL;

// the values for these globals are set in ole2.cpp
UINT            uOmPostWmCommand;
UINT            uOleMessage;

#define OM_CLEAR_MENU_STATE             0       // lParam is NULL
#define OM_COMMAND_ID                   1       // LOWORD(lParam) contains
// the command ID



//+-------------------------------------------------------------------------
//
//  Function:   IsHmenuEqual
//
//  Synopsis:   Test whether two menu handles are equal taking into
//              account whether one might be a Win16 handle.
//
//  History:    dd-mmm-yy Author    Comment
//      31-May-94 Ricksa    Created
//
//--------------------------------------------------------------------------
inline BOOL IsHmenuEqual(HMENU hmenu1, HMENU hmenu2)
{

#ifdef _WIN64

    //
    // Sundown v-thief ( in accordance with Jerry Shea's feedback ):
    //
    //  At this time - 07/98 - all the bits of the HMENUs have to be equal
    //

    return hmenu1 == hmenu2;

#else  // !_WIN64

    if (HIWORD(hmenu1) == 0 || HIWORD(hmenu2) == 0)
    {

        return LOWORD(hmenu1) == LOWORD(hmenu2);
    }
    else
    {

        return hmenu1 == hmenu2;
    }

#endif // !_WIN64

}




//+-------------------------------------------------------------------------
//
//  Class:      CPaccel
//
//  Purpose:    Handles enumeration of ACCEL table for IsAccelerator
//
//  Interface:  InitLPACCEL - Initialize object
//      operator-> Get pointer to current ACCEL in enumeration
//      Next - bump current pointer
//
//  History:    dd-mmm-yy Author    Comment
//      14-Apr-94 Ricksa    Created
//
//  Notes:      This class also guarantees clean up of the
//      allocated accelerator table & to localize the differences
//      between Win16 & Win32 within this class.
//
//--------------------------------------------------------------------------
class CPaccelEnum : public CPrivAlloc
{
public:
    CPaccelEnum(void);

    inline     ~CPaccelEnum(void);

    BOOL                InitLPACCEL(HACCEL haccel, int cAccel);

    LPACCEL             operator->(void);

    void                Next(void);

private:

    LPACCEL             _lpaccel;

    LPACCEL             _lpaccelBase;
};





//+-------------------------------------------------------------------------
//
//  Function:   CPaccelEnum::CPaccelEnum
//
//  Synopsis:   Initialize object to zero
//
//  History:    dd-mmm-yy Author    Comment
//      14-Apr-94 Ricksa    Created
//
//--------------------------------------------------------------------------
inline CPaccelEnum::CPaccelEnum(void) : _lpaccel(NULL)
{
    // In Win32, we allocate the memory so we need to keep track of the
    // base of the memory that we allocated.
    _lpaccelBase = NULL;
}




//+-------------------------------------------------------------------------
//
//  Function:   CPaccelEnum::~CPaccelEnum
//
//  Synopsis:   Free resources connected with resource table
//
//  History:    dd-mmm-yy Author    Comment
//      14-Apr-94 Ricksa    Created
//
//--------------------------------------------------------------------------
inline CPaccelEnum::~CPaccelEnum(void)
{
    PrivMemFree(_lpaccelBase);
}




//+-------------------------------------------------------------------------
//
//  Function:   CPaccelEnum::InitLPACCEL
//
//  Synopsis:   Initialize Accelerator table pointer
//
//  Arguments:  [haccel] - handle to accelerator table
//      [cAccel] - count of entries in the table
//
//  Returns:    TRUE - table was allocated successfully
//      FALSE - table could not be allocated
//
//  History:    dd-mmm-yy Author    Comment
//      14-Apr-94 Ricksa    Created
//
//--------------------------------------------------------------------------
inline BOOL CPaccelEnum::InitLPACCEL(HACCEL haccel, int cAccel)
{
    // Allocate the memory for the table. If that succeeds, then copy
    // the accelerator table. Note that if _lpaccelBase gets allocated,
    // but CopyAcceleratorTable fails, the memory will be cleaned up
    // in the destructor.
    if (((_lpaccelBase
          = (LPACCEL) PrivMemAlloc(cAccel * sizeof(ACCEL))) != NULL)
        && (CopyAcceleratorTable(haccel, _lpaccelBase, cAccel) == cAccel))
    {
        _lpaccel = _lpaccelBase;
        return TRUE;
    }

    return FALSE;
}



//+-------------------------------------------------------------------------
//
//  Function:   CPaccelEnum::operator->
//
//  Synopsis:   Return pointer to accelerator table
//
//  History:    dd-mmm-yy Author    Comment
//      14-Apr-94 Ricksa    Created
//
//--------------------------------------------------------------------------
inline LPACCEL CPaccelEnum::operator->(void)
{
    AssertSz((_lpaccel != NULL), "CPaccelEnum::operator-> _lpaccel NULL!");
    return _lpaccel;
}




//+-------------------------------------------------------------------------
//
//  Function:   CPaccelEnum::Next
//
//  Synopsis:   Bump enumeration pointer
//
//  History:    dd-mmm-yy Author    Comment
//      14-Apr-94 Ricksa    Created
//
//--------------------------------------------------------------------------
inline void CPaccelEnum::Next(void)
{
    AssertSz((_lpaccel != NULL), "CPaccelEnum::Next _lpaccel NULL!");
    _lpaccel++;
}




//+-------------------------------------------------------------------------
//
//  Function:   OleCreateMenuDescriptor
//
//  Synopsis:   creates a descriptor from a combined menu (for use in
//      dispatching menu messages)
//
//  Effects:
//
//  Arguments:  [hmenuCombined]         -- handle the combined menu
//      [lpMenuWidths]          -- an array of 6 longs with the
//                                 the number of menus in each
//                                 group
//
//  Requires:
//
//  Returns:    handle to an OLEMENU
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Allocates space for enough ole menu items (total of all the
//      combined menues) and then fills in each ole menu item from
//      the combined menu
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:      if hmenuCombined is NULL, we still allocate the ole menu
//      descriptor handle
//
//--------------------------------------------------------------------------

#pragma SEG(OleCreateMenuDescriptor)
STDAPI_(HOLEMENU) OleCreateMenuDescriptor (HMENU hmenuCombined,
                                           LPOLEMENUGROUPWIDTHS lplMenuWidths)
{
    OLETRACEIN((API_OleCreateMenuDescriptor, PARAMFMT("hmenuCombined= %h, lplMenuWidths= %tw"),
                hmenuCombined, lplMenuWidths));
    VDATEHEAP();

    int                      iGroupCnt, n;
    int                      iMenuCnt = 0;
    HGLOBAL                  hOleMenu;
    LPOLEMENU                lpOleMenu;
    LPOLEMENUITEM            lpMenuList;
    DWORD                    dwOleMenuItemsSize = 0;

    LEDebugOut((DEB_TRACE, "%p _IN OleCreateMenuDescriptor ( %lx , "
                "%p )\n", NULL, hmenuCombined, lplMenuWidths));

    if (hmenuCombined)
    {
        GEN_VDATEPTRIN_LABEL( lplMenuWidths, OLEMENUGROUPWIDTHS,
                              (HOLEMENU)NULL, errRtn, hOleMenu );

        iMenuCnt = 0;
        for (iGroupCnt = 0; iGroupCnt < 6; iGroupCnt++)
        {
            iMenuCnt += (int) lplMenuWidths->width[iGroupCnt];
        }

        if (iMenuCnt == 0)
        {
            hOleMenu = NULL;
            goto errRtn;
        }

        dwOleMenuItemsSize = (iMenuCnt-1) * sizeof(OLEMENUITEM);
    }

    hOleMenu = GlobalAlloc(GMEM_SHARE | GMEM_ZEROINIT,
                           sizeof(OLEMENU) + dwOleMenuItemsSize);

    if (!hOleMenu)
    {
        goto errRtn;
    }

    if (! (lpOleMenu = (LPOLEMENU) GlobalLock(hOleMenu)))
    {
        GlobalFree(hOleMenu);
        hOleMenu = NULL;
        goto errRtn;
    }

    lpOleMenu->wSignature            = wSignature;
    lpOleMenu->hmenuCombined         = PtrToUlong(hmenuCombined);
    lpOleMenu->lMenuCnt              = (LONG) iMenuCnt;

    if (! hmenuCombined)
    {
        goto Exit;
    }

    lpMenuList = lpOleMenu->menuitem;

    for (iMenuCnt = 0, iGroupCnt = 0; iGroupCnt < 6; iGroupCnt++)
    {
        lpOleMenu->MenuWidths.width[iGroupCnt] =
          lplMenuWidths->width[iGroupCnt];
        for (n = 0; n < lplMenuWidths->width[iGroupCnt]; n++)
        {
            lpMenuList->fObjectMenu = (iGroupCnt % 2);
            if (GetSubMenu(hmenuCombined, iMenuCnt) != NULL)
            {
                lpMenuList->fwPopup = MF_POPUP;
                lpMenuList->item = PtrToUlong(GetSubMenu(
                    hmenuCombined, iMenuCnt));
            }
            else
            {
                lpMenuList->fwPopup = NULL;
                lpMenuList->item = GetMenuItemID (
                    hmenuCombined, iMenuCnt);
            }

            lpMenuList++;
            iMenuCnt++;
        }
    }

Exit:
    GlobalUnlock(hOleMenu);

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT OleCreateMenuDescriptor ( %lx )\n",
                NULL, hOleMenu));

    OLETRACEOUTEX((API_OleCreateMenuDescriptor, RETURNFMT("%h"), hOleMenu));

    return (HOLEMENU) hOleMenu;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleSetMenuDescriptor
//
//  Synopsis:   Called by the SetMenu method on the IOleInPlace frame
//      interface.  This API adds(removes) the FrameWndFilterProc
//      to the Frame window of the container. And then sets and
//      removes the main(frame) menu bar
//
//  Effects:
//
//  Arguments:  [holemenu]      -- a handle to the composite menu descriptor
//      [hwndFrame]     -- a handle to the container's frame window
//      [hwndActiveObject]      -- a handle to the object's in-place
//                                 window
//      [lpFrame]       -- pointer to the container's
//                         IOleInPlaceFrame implementation
//      [lpActiveObj]   -- pointer to in-place object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  check arguments, then create a new frame filter object
//      and attach it to the frame (replacing any that might
//      already be there).
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OleSetMenuDescriptor)
STDAPI OleSetMenuDescriptor
(
    HOLEMENU                 holemenu,
    HWND                     hwndFrame,
    HWND                     hwndObject,
    LPOLEINPLACEFRAME        lpFrame,
    LPOLEINPLACEACTIVEOBJECT lpObject
)
{
    OLETRACEIN((API_OleSetMenuDescriptor,
                PARAMFMT("holemenu= %h, hwndFrame= %h, hwndObject= %h, lpFrame= %p, lpObject= %p"),
                holemenu, hwndFrame, hwndObject, lpFrame, lpObject));

    VDATEHEAP();

    PCFRAMEFILTER                    pFrameFilter;
    LPOLEMENU                        lpOleMenu = NULL;
    LPOLEMENU                        lpOleMenuCopy = NULL;
    HRESULT                          error = NOERROR;

    LEDebugOut((DEB_TRACE, "%p _IN OleSetMenuDescriptor ( %lx , %lx ,"
                "%lx , %p , %p )\n", NULL, holemenu, hwndFrame, hwndObject,
                lpFrame, lpObject));

    // The Frame window parameter always needs to be valid since
    // we use it for both hook and unhook of menus
    if (hwndFrame == NULL || !IsWindow(hwndFrame))
    {
        LEDebugOut((DEB_ERROR,
                    "ERROR in OleSetMenuDesciptor: bad hwndFrame\n"));
        error =  ResultFromScode(OLE_E_INVALIDHWND);
        goto errRtn;
    }

    if (holemenu != NULL)
    {
        if (hwndObject == NULL || !IsWindow(hwndObject))
        {
            LEDebugOut((DEB_ERROR,
                        "ERROR in OleSetMenuDesciptor: bad hwndFrame\n"));
            error =  ResultFromScode(OLE_E_INVALIDHWND);
            goto errRtn;
        }

        if (lpFrame && lpObject)
        {
            // the caller wants us to provide the support for
            // context sensitive help, let's validat the pointers
            VDATEIFACE_LABEL(lpFrame, errRtn, error);
            VDATEIFACE_LABEL(lpObject, errRtn, error);
            CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IOleInPlaceFrame,
                           (IUnknown **)&lpFrame);
            CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IOleInPlaceActiveObject,
                           (IUnknown **)&lpObject);
        }

        if (!(lpOleMenu = wGetOleMenuPtr(holemenu)))
        {
            error = ResultFromScode(E_HANDLE);
            goto errRtn;
        }


        // OleMenuPtr gets released down below by wReleaseOleMenuPtr

        // Allocate memory for the copy
        DWORD dwSize = (DWORD) GlobalSize(holemenu);

        lpOleMenuCopy = (LPOLEMENU) PrivMemAlloc(dwSize);

        if (lpOleMenuCopy == NULL)
        {
            wReleaseOleMenuPtr(holemenu);
            error = E_OUTOFMEMORY;
            goto errRtn;
        }

        memcpy(lpOleMenuCopy, lpOleMenu, dwSize);
    }

    // if there is a frame filter get rid off it.
    if (pFrameFilter =  (PCFRAMEFILTER) wGetFrameFilterPtr(hwndFrame))
    {
        // be sure to remove our window proc hook

        pFrameFilter->RemoveWndProc();

        pFrameFilter->SafeRelease();
    }

    // Add a new frame filter
    if (holemenu)
    {
        error = CFrameFilter::Create (lpOleMenuCopy,
                                      (HMENU)UlongToPtr(lpOleMenu->hmenuCombined),
                                      hwndFrame, 
                                      hwndObject,  
                                      lpFrame,
                                      lpObject);

        if (FAILED(error))
        {
            PrivMemFree(lpOleMenuCopy);
        }

        wReleaseOleMenuPtr(holemenu);
    }

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT OleSetMenuDescriptor ( %lx )\n",
                NULL, error ));

    OLETRACEOUT((API_OleSetMenuDescriptor, error));

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleDestroyMenuDescriptor
//
//  Synopsis:   Releases the menu descriptor allocated by
//      OleCreateMenuDescriptor
//
//  Effects:
//
//  Arguments:  [holemenu]      -- the menu descriptor
//
//  Requires:
//
//  Returns:    NOERROR, E_HANDLE
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  does a global lock and verifies that holemenu is
//      really a menu descriptor handle (via wGetOleMenuPtr),
//      then unlock's and free's.
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleDestroyMenuDescriptor)
STDAPI OleDestroyMenuDescriptor (HOLEMENU holemenu)
{
    OLETRACEIN((API_OleDestroyMenuDescriptor, PARAMFMT("holemenu= %h"), holemenu));

    VDATEHEAP();

    LPOLEMENU        lpOleMenu;
    HRESULT          error;

    LEDebugOut((DEB_TRACE, "%p _IN OleDestroyMenuDescriptor ( %lx )\n",
                NULL, holemenu));

    // make sure that it is a valid handle
    if (! (lpOleMenu = wGetOleMenuPtr(holemenu)))
    {
        error = ResultFromScode(E_HANDLE);
    }
    else
    {
        wReleaseOleMenuPtr(holemenu);
        GlobalFree((HGLOBAL) holemenu);
        error = NOERROR;
    }

    LEDebugOut((DEB_TRACE, "%p OUT OleDestroyMenuDescriptor ( %lx )\n",
                NULL, error));

    OLETRACEOUT((API_OleDestroyMenuDescriptor, error));

    return error;
}

//+-------------------------------------------------------------------------
//
//  Function:   wSysKeyToKey (internal)
//
//  Synopsis:   Converts a message from a WM_SYSKEY to a WM_KEY message
//      if the alt key was not held down
//
//  Effects:
//
//  Arguments:  [lpMsg]         -- the message to convert
//
//  Requires:
//
//  Returns:    UINT -- the new message
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//      07-Dec-93 alexgo    removed inlining
//
//  Notes:      original notes:
//
// if the ALT key is down when a key is pressed, then the 29th bit of the
// LPARAM will be set
//
// If the message was not made with the ALT key down, convert the message
// from a WM_SYSKEY* to a WM_KEY* message.
//
//--------------------------------------------------------------------------

static UINT wSysKeyToKey(LPMSG lpMsg)
{
    VDATEHEAP();

    UINT     message = lpMsg->message;

    if (!(HIWORD(lpMsg->lParam) & 0x2000)
        && (message >= WM_SYSKEYDOWN && message <= WM_SYSDEADCHAR))
    {
        message -= (WM_SYSKEYDOWN - WM_KEYDOWN);
    }

    return message;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleTranslateAccelerator
//
//  Synopsis:   Called by an inplace object to allow a container to attempt
//      to handle an accelerator
//
//  Effects:
//
//  Arguments:  [lpFrame]       -- pointer to IOleInPlaceFrame where the
//                         keystroke might be sent
//      [lpFrameInfo]   -- pointer to and OLEINPLACEFRAMEINFO
//                         from the container with it's accelerator
//                         table
//      [lpmsg]         -- the keystroke
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  We call SendMessage to store the accelerator cmd
//      (to handle degenerate lookups on the container) and
//      then ask the container to handle
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleTranslateAccelerator)
STDAPI OleTranslateAccelerator(LPOLEINPLACEFRAME lpFrame,
                               LPOLEINPLACEFRAMEINFO lpFrameInfo, LPMSG lpMsg)
{
    OLETRACEIN((API_OleTranslateAccelerator,
                PARAMFMT("lpFrame= %p, lpFrameInfo= %to, lpMsg= %tm"),
                lpFrame, lpFrameInfo, lpMsg));

    VDATEHEAP();

    WORD             cmd;
    BOOL             fFound;
    HRESULT          error;

    LEDebugOut((DEB_TRACE, "%p _IN OleTranslateAccelerator ( %p , %p "
                ", %p )\n", NULL, lpFrame, lpFrameInfo, lpMsg));
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IOleInPlaceFrame,
                   (IUnknown **)&lpFrame);

    // Validate parameters -- the best that we can!
    // Note: the macro's VDATEPTR* were not used because they return
    // immediately & break the tracing semantics
    if (!IsValidInterface(lpFrame)
        || !IsValidPtrIn(lpFrameInfo, sizeof(OLEINPLACEFRAMEINFO))
        || !IsValidPtrIn(lpMsg, sizeof(MSG)))
    {
        error = ResultFromScode(E_INVALIDARG);
        goto exitRtn;
    }


    // Search the (container) frame's table of accelerators. Remember that
    // the container may be (actually most likely) is in a separate
    // process.
    fFound = IsAccelerator(lpFrameInfo->haccel,
                           lpFrameInfo->cAccelEntries, lpMsg, &cmd);

    if (!fFound && lpFrameInfo->fMDIApp)
    {
        // If no accelerator was found and the app is a MDI app,
        // then we see if there is a mdi accelerator found.
        fFound = IsMDIAccelerator(lpMsg, &cmd);
    }

    if (fFound)
    {
        // Found some kind of for the container accelerator.

        // uOleMessage is set in ole2.cpp -- it is a private message
        // between OLE applications.

        // This SendMessage tells the message filter that is on the
        // frame window what the command translated to. This will
        // be used in menu collision processing.
        SSSendMessage(lpFrameInfo->hwndFrame, uOleMessage,
                      OM_COMMAND_ID, MAKELONG(cmd, 0));

        // Send the command and the message to the container. The
        // result tells the caller whether the container really
        // used the command.

        error = lpFrame->TranslateAccelerator(lpMsg, cmd);

    }
    else if (wSysKeyToKey(lpMsg) == WM_SYSCHAR)
    {
        // Eat the message if it is "Alt -". This is supposed
        // to bring the MDI system menu down. But we can not
        // support it. And we also don't want the message to
        // be Translated by the object application either.
        // So, we return as if it has been accepted by the
        // container as an accelerator.

        // If the container wants to support this it can
        // have an accelerator for this. This is not an
        // issue for SDI apps, because it will be thrown
        // away by USER anyway.

        // This is the original support as it appeared in
        // the 16-bit version of OLE and the first 32-bit
        // release.  To fix the problem, remove the comment
        // tags from the else case below and comment the
        // code out in the _DEBUG #ifdef below.  This new
        // code will walk back up through the objects
        // parent windows until a window is found that
        // contains a system menu, at which point the
        // message is sent.

        if (lpMsg->wParam != OLESTR('-'))
        {
            SSSendMessage(lpFrameInfo->hwndFrame,
                          lpMsg->message,
                          lpMsg->wParam, lpMsg->lParam);
        }
        //      else
        //  {
        //      HWND hWndCurrent = lpMsg->hwnd;
        //
        //      while ( hWndCurrent &&
        //              !(GetWindowLong(hWndCurrent, GWL_STYLE) & WS_SYSMENU))
        //      {
        //          hWndCurrent = GetParent(hWndCurrent);
        //      }
        //
        //      if (hWndCurrent)
        //          {
        //              SSSendMessage(hWndCurrent,
        //                      lpMsg->message,
        //                      lpMsg->wParam, lpMsg->lParam);
        //          }
        //  }

#ifdef _DEBUG
        else
        {
            OutputDebugString(
                TEXT("OleTranslateAccelerator: Alt+ - key is discarded\r\n"));
        }
#endif
        error = NOERROR;
    }
    else
    {
        error = ResultFromScode(S_FALSE);
    }

exitRtn:

    LEDebugOut((DEB_TRACE, "%p OUT OleTranslateAccelerator ( %lx )\n",
                NULL, error));

    OLETRACEOUT((API_OleTranslateAccelerator, error));

    return error;
}

//+-------------------------------------------------------------------------
//
//  Function:   IsAccelerator
//
//  Synopsis:   determines whether [lpMsg] is an accelerator in the [hAccel]
//
//  Effects:
//
//  Arguments:  [hAccel]        -- the accelerator table
//      [cAccelEntries] -- the number of entries in the accelerator
//                         table
//      [lpMsg]         -- the keystroke message that we should
//                         see if it's an accelerator
//      [lpCmd]         -- where to return the corresponding command
//                         ID if an accelerator is found (may be NULL)
//
//  Requires:
//
//  Returns:    TRUE if accelerator is found, FALSE otherwise or on error
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDAPI_(BOOL) IsAccelerator
(HACCEL hAccel, int cAccelEntries, LPMSG lpMsg, WORD FAR* lpwCmd)
{
    OLETRACEIN((API_IsAccelerator,
                PARAMFMT("hAccel= %h, cAccelEntries= %d, lpMsg= %tm, lpwCmd= %p"),
                hAccel, cAccelEntries, lpMsg, lpwCmd));

    VDATEHEAP();

    WORD             cmd = NULL;
    WORD             flags;
    BOOL             fFound = FALSE;
    BOOL             fVirt;
    UINT             message;

    // Safe place for pointer to accelerator table
    CPaccelEnum      cpaccelenum;

    LEDebugOut((DEB_TRACE, "%p _IN IsAccelerator ( %lx , %d , %p , %p )\n",
                NULL, hAccel, cAccelEntries, lpMsg, lpwCmd));

    if (! cAccelEntries)
    {
        // no accelerators so we can stop here.
        goto errRtn;
    }

    // Change message type from WM_SYS type to WM_KEY type if the ALT
    // key is not pressed.
    message = wSysKeyToKey(lpMsg);

    // Figure out whether this message is one that can possibly contain
    // an accelerator.
    switch (message)
    {
    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
        // wParam in this message is virtual key code
        fVirt = TRUE;
        break;

    case WM_CHAR:
    case WM_SYSCHAR:
        // wParam is the character
        fVirt = FALSE;
        break;

    default:
        goto errRtn;
    }

    // Get a pointer to the accerator table
    if ((hAccel == NULL)
        || !cpaccelenum.InitLPACCEL(hAccel, cAccelEntries))
    {
        // Handle is NULL or we could not lock the resource so exit.
        goto errRtn;
    }

    do
    {
        // Get the flags from the accelerator table entry to save
        // a pointer dereference.
        flags = cpaccelenum->fVirt;

        // if the key in the message and the table aren't the same,
        // or if the key is virtual and the accel table entry is not or
        // vice versa (if key is not virtual & accel table entry is
        // not), we can skip checking the accel entry immediately.
        if ((cpaccelenum->key != (WORD) lpMsg->wParam) ||
            ((fVirt != 0) != ((flags & FVIRTKEY) != 0)))
        {
            goto Next;
        }

        if (fVirt)
        {
            // If shift down & shift not requested in accelerator
            // table or if shift not down and shift not set,
            // we skip this table entry.
            if ((GetKeyState(VK_SHIFT) < 0) != ((flags & FSHIFT)
                                                != 0))
            {
                goto Next;
            }

            // Likewise if control key down & control key not
            // set in accelerator table or if control not down
            // and it was set in the accelerator table, we skip
            // skip this entry in the table.
            if ((GetKeyState(VK_CONTROL) < 0) !=
                ((flags & FCONTROL) != 0))
            {
                goto Next;
            }
        }

        // If the ALT key is down and the accel table flags do not
        // request the ALT flags or if the alt key is not down and
        // the ALT is requested, this item does not match.
        if ((GetKeyState(VK_MENU) < 0) != ((flags & FALT) != 0))
        {
            goto Next;
        }

        // We have gotten a match in the table. 
        // we get the command out of the table and record that we found
        // something.
        cmd = cpaccelenum->cmd;
        fFound = TRUE;

        goto errRtn;

    Next:
        cpaccelenum.Next();

    } while (--cAccelEntries);


errRtn:
    // Common exit

    if (lpwCmd)
    {
        // If caller wants to get back the command that they
        // requested, we assign it at this point.
        *lpwCmd = cmd;
    }


    LEDebugOut((DEB_TRACE, "%p OUT IsAccelerator ( %lu )\n", NULL,
                fFound));

    OLETRACEOUTEX((API_IsAccelerator, RETURNFMT("%B"), fFound));

    // Return the result of the search.
    return fFound;
}


//+-------------------------------------------------------------------------
//
//  Function:   IsMDIAccelerator
//
//  Synopsis:   determines wither [lpMsg] is an accelerator for MDI window
//      commands
//
//  Effects:
//
//  Arguments:  [lpMsg]         -- the keystroke to look at
//      [lpCmd]         -- where to put the command ID
//
//  Requires:
//
//  Returns:    BOOL
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Make sure message is a key down message. Then make sure
//      that the control key is up or toggled and the ALT key is
//      down. Then if F4 is pressed set the system command to
//      close or if the F6 or tab keys are pressed send the
//      appropriate window switch message.
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port, fixed fall-through bug
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(IsMDIAccelerator)
BOOL IsMDIAccelerator(LPMSG lpMsg, WORD FAR* lpCmd)
{
    VDATEHEAP();

    BOOL fResult = FALSE;

    LEDebugOut((DEB_TRACE, "%p _IN IsMDIAccelerator ( %p , %p )\n",
                NULL, lpMsg, lpCmd));

    // This can be an accelerator only if this is some kind of key down.
    if (lpMsg->message != WM_KEYDOWN && lpMsg->message != WM_SYSKEYDOWN)
    {
        goto IsMDIAccelerator_exit;
    }

    if (GetKeyState(VK_CONTROL) >= 0)
    {
        // All MIDI accelerators have the control key up (or toggled),
        // so we can exit here if it isn't down.
        goto IsMDIAccelerator_exit;
    }

    switch ((WORD)lpMsg->wParam)
    {
    case VK_F4:
        *lpCmd = SC_CLOSE;
        fResult = TRUE;
        break;          // this break was not in the 16bit code, but
        // it looks like it must be there (otherwise
        // this info is lost)
    case VK_F6:
    case VK_TAB:
        fResult = TRUE;

        *lpCmd = (WORD) (GetKeyState(VK_SHIFT) < 0
                         ? SC_PREVWINDOW : SC_NEXTWINDOW);

        break;
    }

IsMDIAccelerator_exit:

    LEDebugOut((DEB_TRACE, "%p OUT IsMDIAccelerator ( %lu ) [ %lu ] \n",
                NULL, fResult, *lpCmd));

    return fResult;
}

//+-------------------------------------------------------------------------
//
//  Function:   FrameWndFilterProc
//
//  Synopsis:   The callback proc for the container's frame window
//
//  Effects:
//
//  Arguments:  [hwnd]          -- the window handle
//      [msg]           -- the msg causing the notification
//      [uParam]        -- first param
//      [lParam]        -- second param
//
//  Requires:
//
//  Returns:    LRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Gets the CFrame object (if available) and asks it
//      to deal with the window message
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(FrameWndFilterProc)
STDAPI_(LRESULT) FrameWndFilterProc(HWND hwnd, UINT msg, WPARAM uParam, LPARAM lParam)
{
    VDATEHEAP();

    PCFRAMEFILTER    pFrameFilter;
    LRESULT          lresult;

    LEDebugOut((DEB_TRACE, "%p _IN FrameWndFilterProc ( 0x%p , %u ,"
                " %u , %ld )\n", NULL, hwnd, msg, PtrToUlong((void*)uParam), PtrToLong((void*)lParam)));

    if (!(pFrameFilter = (PCFRAMEFILTER) wGetFrameFilterPtr(hwnd)))
    {
        lresult = SSDefWindowProc(hwnd, msg, uParam, lParam);
    }
    else
    {
        // stabilize the frame filter
        CStabilize FFstabilize((CSafeRefCount *)pFrameFilter);

        if (msg == WM_SYSCOMMAND)
        {
            lresult = pFrameFilter->OnSysCommand(uParam,
                                                 lParam);
        }
        else
        {
            lresult = pFrameFilter->OnMessage(msg, uParam,
                                              lParam);
        }
    }

    LEDebugOut((DEB_TRACE, "%p OUT FrameWndFilterProc ( %lu )\n",
                NULL, PtrToUlong((void*)lresult)));

    return lresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   CFrameFilter::Create
//
//  Synopsis:   Allocates and initializes a CFrame object (which handles
//      all of the real processing work for event callbacks)
//
//  Effects:
//
//  Arguments:  [lpOleMenu]     -- pointer to the ole menu descriptor
//      [hmenuCombined] -- the combined menu handle
//      [hwndFrame]     -- handle to the container's frame
//                         (where the CFrame should be installed)
//      [hwndActiveObj] -- handle to the in-place object's window
//      [lpFrame]       -- pointer to the container's
//                         IOleInPlaceFrame implementation
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Allocates the object and installs a pointer to it as
//      a property on the window
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CFrameFilter_Create)
HRESULT CFrameFilter::Create(LPOLEMENU lpOleMenu, HMENU hmenuCombined,
                             HWND hwndFrame,  HWND hwndActiveObj,
                             LPOLEINPLACEFRAME lpFrame, LPOLEINPLACEACTIVEOBJECT lpActiveObj)
{
    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CFrameFilter::Create ( %lx , %p ,"
                " %lx , %lx , %p , %p )\n", NULL, lpOleMenu,
                hmenuCombined, hwndFrame, hwndActiveObj,
                lpFrame, lpActiveObj));

    CFrameFilter * pFF = new CFrameFilter(hwndFrame, hwndActiveObj);

    if (!pFF)
    {
        goto errRtn;
    }

    pFF->SafeAddRef();

    pFF->m_lpOleMenu = lpOleMenu;
    pFF->m_hmenuCombined = hmenuCombined;

    // If the following pointers are NON-NULL, it means that the container
    // wants us to use our message filter to deal with the F1 key. So,
    // remember the pointers.

    if (lpFrame && lpActiveObj)
    {
        // these addref's should not be outgoing calls, so
        // no need to stabilize around them.  (unless, of
        // course, the container made an outgoing call for
        // frame->AddRef, but that would be really weird).

        (pFF->m_lpFrame  = lpFrame)->AddRef();
        (pFF->m_lpObject = lpActiveObj)->AddRef();
    }

    // Hook the frame wnd proc
    if (!(pFF->m_lpfnPrevWndProc = (WNDPROC) SetWindowLongPtr (hwndFrame,
                                                               GWLP_WNDPROC, (LONG_PTR) FrameWndFilterProc)))
    {
        goto errRtn;
    }

    if (!SetProp (hwndFrame, szPropFrameFilter, (HANDLE) pFF))
    {
        goto errRtn;
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CFrameFilter::Create ( %lx )\n",
                NULL, NOERROR ));
    return NOERROR;

errRtn:
    if (pFF)
    {
        pFF->SafeRelease();
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CFrameFilter::Create ( %lx )\n",
                NULL, ResultFromScode(E_OUTOFMEMORY)));

    return ResultFromScode(E_OUTOFMEMORY);
}


//+-------------------------------------------------------------------------
//
//  Member:     CFrameFilter::CFrameFilter
//
//  Synopsis:   Constructor for the frame filter object
//
//  Effects:
//
//  Arguments:  [hwndFrame]     -- the container's frame
//      [hwndActiveObj] -- the inplace object's window
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CFrameFilter_ctor)
CFrameFilter::CFrameFilter (HWND hwndFrame, HWND hwndActiveObj) : 
  CSafeRefCount(NULL)
{
    VDATEHEAP();

    m_hwndFrame              = hwndFrame;
    m_hwndObject             = hwndActiveObj;
    m_lpFrame                = NULL;
    m_lpObject               = NULL;
    m_lpfnPrevWndProc        = NULL;
    m_fObjectMenu            = FALSE;
    m_fCurItemPopup          = FALSE;
    m_fInMenuMode            = FALSE;
    m_fGotMenuCloseEvent     = FALSE;
    m_uCurItemID             = NULL;
    m_cAltTab                = NULL;
    m_hwndFocusOnEnter       = NULL;
    m_fDiscardWmCommand      = FALSE;
    m_cmdId                  = NULL;
    m_fRemovedWndProc        = FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFrameFileter::~CFrameFilter
//
//  Synopsis:   destroys the object
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CFrameFilter_dtor)
CFrameFilter::~CFrameFilter(void)
{
    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CFrameFilter::~CFrameFilter ( )\n",
                this));

    PrivMemFree(m_lpOleMenu);

    // remove the FrameWndFilterProc hook.  We do this *before*
    // the Releases since those releases may make outgoing calls
    // (we'd like to be in a 'safe' state).

    // REVIEW32:  We may want to check to see if we're the current
    // window proc before blowing it away.  Some apps (like Word)
    // go ahead and blow away the wndproc by theselves without calling
    // OleSetMenuDescriptor(NULL);

    RemoveWndProc();

    if (m_lpFrame != NULL)
    {
        // OleUnInitialize could have been called.
        // In such case we do not want to call releas
        // on OLeObject.
        COleTls tls;
        if(tls->cOleInits > 0)
        {
            SafeReleaseAndNULL((IUnknown **)&m_lpFrame);
            SafeReleaseAndNULL((IUnknown **)&m_lpObject);
        }
        else
        {
            m_lpObject = NULL;
            m_lpFrame = NULL;
        }
    }



    LEDebugOut((DEB_ITRACE, "%p OUT CFrameFilter::~CFrameFilter ( )\n",
                this));
}

//+-------------------------------------------------------------------------
//
//  Member:     CFrameFilter::RemoveWndProc
//
//  Synopsis:   un-installs our window proc for inplace-processing
//
//  Effects:
//
//  Arguments:
//
//  Requires:   none
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      04-Aug-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void CFrameFilter::RemoveWndProc()
{
    LEDebugOut((DEB_ITRACE, "%p _IN CFrameFilter::RemoveWndProc ( )\n",
                this));

    if( m_fRemovedWndProc == FALSE)
    {
        m_fRemovedWndProc = TRUE;

        if (m_lpfnPrevWndProc)
        {
            // If the sub-classing has already been removed, then
            // don't bother to remove it again.  This happens
            // to be the case with Word 6 and inplace embeddings.
            // and Word95 with SnapGraphics.

            // if somebody comes along later (after us) and
            // sub-classes the window, we won't be able to remove
            // ourselves so we just avoid it. 

            if (GetWindowLongPtr(m_hwndFrame, GWLP_WNDPROC) ==
                (LONG_PTR)FrameWndFilterProc)
            {

                SetWindowLongPtr (m_hwndFrame, GWLP_WNDPROC,
                                  (LONG_PTR) m_lpfnPrevWndProc);

            }

            // We remove the window property at the
            // same time as the sub-classing since
            // the window property is the flag as to
            // whether we are doing sub-classing. The
            // problem this solves is that what if
            // OleSetMenuDescriptor is called while we
            // have the menu subclassed? We won't remove
            // this property until the outer most sub
            // classing is exited which if we are setting
            // a new sub-class will remove the new
            // sub-class' window property. Therefore, it
            // will look like the window is not sub-classed
            // at all.
            HANDLE h = RemoveProp (m_hwndFrame, szPropFrameFilter);
            // We must not free 'h'. It's not a real handle.
        }
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CFrameFilter::RemoveWndProc ( )\n",
                this));

}


//+-------------------------------------------------------------------------
//
//  Member:     CFrameFilter::OnSysCommand
//
//  Synopsis:   Process system messages
//
//  Effects:
//
//  Arguments:  [uParam]        -- the first message argument
//      [lParam]        -- the second message argument
//
//  Requires:   the 'this' pointer must have been stabilized before
//      calling this function.
//
//  Returns:    LRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:  big switch to deal with the different types of messages
//      see comments below
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//      07-Dec-93 alexgo    removed inlining
//
//  Notes:      FrameWndFilterProc currently does the work of stabilizing
//      the framefilter's 'this' pointer.
//
//--------------------------------------------------------------------------

#pragma SEG(CFrameFilter_OnSysCommand)
LRESULT CFrameFilter::OnSysCommand(WPARAM uParam, LPARAM lParam)
{
    VDATEHEAP();

    UINT     uParamTmp = ((UINT)uParam & 0xFFF0);
    LRESULT  lresult;


    LEDebugOut((DEB_ITRACE, "%p _IN CFrameFilter::OnSysCommand ( %lu ,"
                " %ld )\n", this, PtrToUlong((void*)uParam), PtrToLong((void*)lParam)));

    // this lets the sending app continue processing
    if (SSInSendMessage())
    {

        SSReplyMessage(NULL);
    }

    switch (uParamTmp)
    {
    case SC_KEYMENU:
    case SC_MOUSEMENU:
        OnEnterMenuMode();
        SSCallWindowProc((WNDPROC) m_lpfnPrevWndProc, m_hwndFrame,
                         WM_SYSCOMMAND, uParam, lParam);

        // By this time menu processing would've been completed.

        if (! m_fGotMenuCloseEvent)
        {
            // Can happen if user cancelled menu mode when MDI
            // window's system menu is down. Hence generate
            // the message here

            SSSendMessage(m_hwndFrame, WM_MENUSELECT, 0,
                          MAKELONG(-1,0));
        }

        // We can not set m_fObjectMenu to FALSE yet, 'cause we
        // could be recieving the WM_COMMAND (if a menu item is
        // selected), which gets posted by the windows' menu
        // processing code.
        // We will clear the flag when we get OM_CLEAR_MENU_STATE
        // message. Even if WM_COMMAND got generated, this message
        // will come after that
        PostMessage (m_hwndFrame, uOleMessage, OM_CLEAR_MENU_STATE,
                     0L);
        OnExitMenuMode();
        lresult = 0L;
        goto errRtn;

    case SC_NEXTWINDOW:
    case SC_PREVWINDOW:

        OnEnterAltTabMode();
        lresult = SSCallWindowProc((WNDPROC)m_lpfnPrevWndProc,
                                   m_hwndFrame, WM_SYSCOMMAND, uParam, lParam);
        OnExitAltTabMode();

        goto errRtn;

    default:
        break;
    }

    lresult = SSCallWindowProc((WNDPROC)m_lpfnPrevWndProc, m_hwndFrame,
                               WM_SYSCOMMAND, uParam, lParam);

errRtn:

    LEDebugOut((DEB_ITRACE, "%p OUT CFrameFilter::OnSysCommand ( %lx )\n",
                this, PtrToLong((void*)lresult)));

    return lresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFrameFilter::OnEnterMenuMode
//
//  Synopsis:   called by the SysCommand processing, puts us into in
//      InMenuMode, sets the focus and installs our message filter
//      hook.
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      23-Feb-94 alexgo    restored OLE32 in GetModuleHandle
//      31-Dec-93 erikgav   removed hardcoded "OLE2" in GetModuleHandle
//      07-Dec-93 alexgo    removed inlining
//      01-Dec-93 alexgo    32bit port
//
//  Notes:      REVIEW32:  We may need to update this to reflect new
//      focus management policies.
//
//--------------------------------------------------------------------------

#pragma SEG(CFrameFilter_OnEnterMenuMode)
void CFrameFilter::OnEnterMenuMode()
{
    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CFrameFilter::OnEnterMenuMode ( )\n",
                this ));

    if (m_fInMenuMode)
    {
        goto errRtn;
    }

    m_fInMenuMode = TRUE;
    m_fGotMenuCloseEvent = FALSE;
    m_hwndFocusOnEnter = SetFocus(m_hwndFrame);

    if (!m_lpFrame)
    {
        goto errRtn;
    }

    // REVIEW32:  hMsgHook is a static (formerly global) variable for
    // the whole dll.  This may cause problems on NT (with threads, etc)
    // (what happens if we haven't yet unhooked a previous call and
    // we get here again????)

    if (hMsgHook = (HHOOK) SetWindowsHookEx (WH_MSGFILTER,
                                             (HOOKPROC) MessageFilterProc,
                                             //GetModuleHandle(NULL),
                                             GetModuleHandle(TEXT("OLE32")),
                                             GetCurrentThreadId()))
    {
        pFrameFilter = this;
    }

errRtn:

    LEDebugOut((DEB_ITRACE, "%p OUT CFrameFilter::OnEnterMenuMode ( )\n",
                this ));

}

//+-------------------------------------------------------------------------
//
//  Member:     CFrameFilter::OnExitMenuMode
//
//  Synopsis:   takes us out of InMenuMode
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:  Resets the focus and unhooks our callback function
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//      07-Dec-93 alexgo    removed inlining
//
//  Notes:      REVIEW32:: see OnEnterMenuMode
//
//--------------------------------------------------------------------------

#pragma SEG(CFrameFilter_OnExitMenuMode)
void CFrameFilter::OnExitMenuMode()
{
    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CFrameFilter::OnExitMenuMode ( )\n",
                this));

    if (m_fInMenuMode)
    {

        m_fInMenuMode = FALSE;
        m_fGotMenuCloseEvent = TRUE;
        m_uCurItemID = NULL;

        if (hMsgHook)
        {
            UnhookWindowsHookEx(hMsgHook);
            hMsgHook = NULL;
            pFrameFilter = NULL;
        }

        SetFocus(m_hwndFocusOnEnter);
        m_hwndFocusOnEnter = NULL;
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CFrameFilter::OnExitMenuMode ( )\n",
                this));
}

//+-------------------------------------------------------------------------
//
//  Member:     CFrameFileter::OnEnterAltTabMode
//
//  Synopsis:   enters AltTab mode and sets the focus
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//      07-Dec-93 alexgo    removed inlining
//
//  Notes:      REVIEW32:  we may need to modify to implement new
//      focus management policy
//
//--------------------------------------------------------------------------

void CFrameFilter::OnEnterAltTabMode(void)
{
    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CFrameFilter::OnEnterAltTabMode ( )\n",
                this ));

    if (m_cAltTab == NULL)
    {

        m_fInMenuMode = TRUE;
        // this will prevent SetFocus from getting
        // delegated to the object
        m_hwndFocusOnEnter = SetFocus(m_hwndFrame);
        m_fInMenuMode = FALSE;
    }

    m_cAltTab++;

    LEDebugOut((DEB_ITRACE, "%p OUT CFrameFilter::OnEnterAltTabMode ( )\n",
                this ));
}

//+-------------------------------------------------------------------------
//
//  Member:     CFrameFilter::OnExitAltTabMode
//
//  Synopsis:   exits alt-tab mode and sets the focus
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//      07-Dec-93 alexgo    removed inlining
//
//  Notes:
//
//--------------------------------------------------------------------------

void CFrameFilter::OnExitAltTabMode()
{
    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CFrameFilter::OnExitAltTabMode ( )\n",
                this ));

    Assert(m_cAltTab != NULL);

    if (--m_cAltTab == 0)
    {
        // The m_hwndFocusOnEnter would've been set to NULL if we are
        // going to ALT-TAB out into some other process. In that case
        // we would have got WM_ACTIVATEAPP and/or WM_KILLFOCUS.
        if (m_hwndFocusOnEnter)
        {
            SetFocus(m_hwndFocusOnEnter);
            m_hwndFocusOnEnter = NULL;
        }
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CFrameFilter::OnExitAltTabMode ( )\n",
                this ));
}

//+-------------------------------------------------------------------------
//
//  Member:     CFrameFilter::OnMessage
//
//  Synopsis:   Handles window message processing
//
//  Effects:
//
//  Arguments:  [msg]           -- the window message
//      [uParam]        -- the first argument
//      [lParam]        -- the second argument
//
//  Requires:
//
//  Returns:    LRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:  a big switch to deal with the different commands
//      see comments below
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//      07-Dec-93 alexgo    removed inlining
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CFrameFilter_OnMessage)
LRESULT CFrameFilter::OnMessage(UINT msg, WPARAM uParam, LPARAM lParam)
{
    VDATEHEAP();
    LRESULT          lresult;

    LEDebugOut((DEB_ITRACE, "%p _IN CFrameFilter::OnMessage ( %u , %u ,"
                " %ld )\n", this, msg, PtrToUlong((void*)uParam), 
                PtrToLong((void*)lParam)));

    // We come to this routine only if the message is not WM_SYSCOMMAND

    switch (msg)
    {
    case WM_SETFOCUS:
        if (m_fInMenuMode)
        {
            lresult = SSDefWindowProc (m_hwndFrame, msg, uParam, lParam);
            goto errRtn;
        }
        break;

    case WM_MENUSELECT:
        if (m_fInMenuMode)
        {
            HMENU   hmenu = (HMENU) lParam;
            UINT    fwMenu = HIWORD(uParam);
            UINT    uItem = 0;

            // There is a subtle difference in the message between
            // Win16 & Win32 here. In Win16, the item is either
            // an item id or a menu handle for a pop up menu.
            // In Win32, the item is an item id or an offset
            // in a menu if it is a popup menu handle. To minimize
            // changes, we map this field as was appropriate for
            // Win16.

            if ( (fwMenu & MF_POPUP)  &&
                 (hmenu != 0) )
            {
                uItem = (UINT) PtrToUlong(GetSubMenu(hmenu, (int) LOWORD(uParam)));
            }
            else {
                uItem = LOWORD(uParam);
            }

            m_uCurItemID = uItem;
            m_fCurItemPopup = fwMenu & MF_POPUP;

            if (hmenu == 0 && fwMenu == 0xFFFF)
            {
                // end of menu processing

                // We can not set m_fObjectMenu to FALSE yet,
                // because we could be recieving the
                // WM_COMMAND (if a menu item is selected),
                // which is posted by the windows' menu
                // processing code, and will be recieved at
                // a later time.

                // There is no way to figure whether the user
                // has selected a menu (which implies that
                // WM_COMMAND is posted), or ESCaped out of
                // menu selection.

                // This problem is handled by posting a
                // message to ourselves to clear the flag.
                // See CFrameFilter::OnSysCommand() for
                // more details...

                m_fGotMenuCloseEvent = TRUE;
                SSSendMessage(m_hwndObject, msg, uParam, lParam);
            }
            else
            {
                if (fwMenu & MF_SYSMENU)
                {
                    m_fObjectMenu = FALSE;
                    // if it is top level menu, see whose
                    // menu it is

                }
                else if (IsHmenuEqual(hmenu, m_hmenuCombined))
                {
                    // set m_fObjectMenu
                    IsObjectMenu (uItem, fwMenu);

                    // this flag must not be modified
                    // when nested menus are selected.
                }

                if (m_fObjectMenu)
                {
                    lresult = SSSendMessage(m_hwndObject, msg, uParam, lParam);
                    goto errRtn;
                }
            } // else
        } // if (m_fInMenuMode)
        break; // WM_MENUSELECT

    case WM_MEASUREITEM:
    case WM_DRAWITEM:
        if (m_fInMenuMode && m_fObjectMenu)
        {
            lresult = SSSendMessage(m_hwndObject, msg, uParam, lParam);
            goto errRtn;
        }
        break;

    case WM_ENTERIDLE:
    {
        WCHAR wstr[10];

        // We need to post this message if the server is
        // SnapGraphics. See bug #18576.
        GetClassName(m_hwndObject, wstr, 10);
        if (0 == lstrcmpW(OLESTR("MGX:SNAP2"), wstr))
        {
            PostMessage(m_hwndObject, msg, uParam, lParam);
        }
        else
        {
            SSSendMessage(m_hwndObject, msg, uParam, lParam);
        }
    }
    break;

    case WM_INITMENU:
        m_fObjectMenu = FALSE;
        if (m_fInMenuMode && IsHmenuEqual(m_hmenuCombined, (HMENU)uParam))
        {
            SSSendMessage(m_hwndObject, msg, uParam, lParam);
        }
        break;

    case WM_INITMENUPOPUP:
        if (!m_fInMenuMode)
        {
            // Accelarator translation....

            if (! ((BOOL) HIWORD(lParam)))
            {
                // if not a system menu, see whether windows
                // generated WM_INITMENUPOPUP for object's
                // menu because of menu collision. If so
                // fix it and route it to container

                // menu collisions can occur with combined
                // menus (from object and container)
                if (IsMenuCollision(uParam, lParam))
                {
                    lresult = 0L;
                    goto errRtn;
                }
            }
        }

        if (m_fObjectMenu)
        {
            lresult = SSSendMessage(m_hwndObject, msg, uParam, lParam);
            goto errRtn;
        }
        break;

    case WM_SYSCHAR:
        if (SSInSendMessage())
        {
            SSReplyMessage(NULL);
        }
        break;

    case WM_COMMAND:
        // End of menu processing or accelartor translation.
        // Check whether we should give the message to the object
        // or not.

        // If the LOWORD of lParam is NON-NULL, then the message
        // must be from a control, and the control must belong to
        // the container app.

        // REVIEW32:  what about app-specific commands with NULL
        // lParams???

        if (LOWORD(lParam) == 0)
        {
            m_cmdId = 0;

            if (m_fDiscardWmCommand)
            {
                m_fDiscardWmCommand = FALSE;
                lresult = 0L;
                goto errRtn;
            }

            if (m_fObjectMenu)
            {
                m_fObjectMenu = FALSE;
                lresult = PostMessage(m_hwndObject, msg, uParam,lParam);
                goto errRtn;
            }
        }
        break;

    case WM_ACTIVATEAPP:
    case WM_KILLFOCUS:
        // If in ALT-TAB mode, we get these messages only if we are
        // going to ALT-TAB out in to some other task. In this case,
        // on exit from ALT-TAB mode we wouldn't want to set
        // focus back to the window that had the focus on
        // entering the ALT-TAB mode.

        if (m_cAltTab)
        {
            m_hwndFocusOnEnter = NULL;
        }
        break;

    default:
        if (msg == uOleMessage)
        {
            switch(uParam)
            {
            case OM_CLEAR_MENU_STATE:
                m_fObjectMenu = FALSE;
                break;

            case OM_COMMAND_ID:
                // this message is sent by
                // OleTranslateAccelerator, before it actually
                // calls the lpFrame->TranslateAccelerator
                // method.
                // We remember the command id here, later it
                // gets used if the container's calling of
                // TranslateAccelerator results in a
                // WM_INITMENUPOPUP for the object because
                // of command id collision. In that case we
                // scan the menu list to see whether there is
                // any container menu which has the same
                // command id, if so we generate
                // WM_INITMENUPOPUP for that menu.
                m_cmdId = LOWORD(lParam);
                break;

            default:
                AssertSz(FALSE, "Unexpected OLE private message");
                break;
            } // switch

            lresult = 0L;
            goto errRtn;
        } // if (msg == uOleMessage)
        else if (m_fInMenuMode && (msg == uOmPostWmCommand))
        {
            // if the current selection is a popup menu then
            // return its menu handle else post the command
            // and return NULL.

            if (m_fCurItemPopup)
            {
                lresult = m_uCurItemID;
                goto errRtn;
            }

            HWND hwnd;

            hwnd = m_hwndFrame;
            if (m_fObjectMenu)
            {
                hwnd = m_hwndObject;
            }
            PostMessage (hwnd, WM_COMMAND, m_uCurItemID, 0L);

            m_fObjectMenu = FALSE;
            lresult = 0L;
            goto errRtn;
        } // else if

        break; // default

    } // switch

    lresult = SSCallWindowProc ((WNDPROC) m_lpfnPrevWndProc, m_hwndFrame,
                                msg, uParam, lParam);

errRtn:
    LEDebugOut((DEB_ITRACE, "%p OUT CFrameFilter::OnMessage ( %lu )\n",
                this, lresult));

    return lresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFrameFilter::IsObjectMenu
//
//  Synopsis:   This gets called when WM_MENUSELECT is sent for a
//      top level (either POPUP or normal) menu item.  Figures
//      out whether [uMenuItem] really belongs to the in-place object
//
//  Effects:
//
//  Arguments:  [uMenuItem]     -- the menu in question
//      [fwMenu]        -- the menu type
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:  Searchs through our ole menu descriptor to find a match
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//      07-Dec-93 alexgo    removed inlining
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CFrameFilter_IsObjectMenu)
void CFrameFilter::IsObjectMenu(UINT uMenuItem, UINT fwMenu)
{
    VDATEHEAP();
    int              i,
      iMenuCnt;
    LPOLEMENUITEM    lpMenuList;

    LEDebugOut((DEB_ITRACE, "%p _IN CFrameFilter::IsObjectMenu ( %u , "
                "%u )\n", this, uMenuItem, fwMenu));

    if (m_hmenuCombined == NULL)
    {
        goto errRtn;
    }


    m_fObjectMenu = FALSE;

    lpMenuList = m_lpOleMenu->menuitem;
    iMenuCnt = (int) m_lpOleMenu->lMenuCnt;

    for (i = 0; i < iMenuCnt; i++)
    {
        // Are the types of the menus the same?
        if ((fwMenu & MF_POPUP) == lpMenuList[i].fwPopup)
        {
            HMENU hmenuMenuListItem = (HMENU)UlongToPtr(lpMenuList[i].item);
            
            // Are we dealing with a menu handle?
            if (fwMenu & MF_POPUP)
            {
                // See if windows handles are equal
                if (IsHmenuEqual((HMENU)IntToPtr(uMenuItem),
                                 hmenuMenuListItem))
                {
                    m_fObjectMenu = lpMenuList[i].fObjectMenu;
                    break;
                }
            }
            // Are item handles equal?
            else if (uMenuItem == lpMenuList[i].item)
            {
                m_fObjectMenu = lpMenuList[i].fObjectMenu;
                
                // If the menu isn't hilited, another menu with a duplicate
                // menu ID must have been selected. The duplicate menu was
                // probably created by the other application.
                if (!(GetMenuState(m_hmenuCombined, uMenuItem, MF_BYCOMMAND)
                      & MF_HILITE))
                {
                    m_fObjectMenu = !m_fObjectMenu;
                }
                break;
            }
        }
    }

errRtn:
    LEDebugOut((DEB_ITRACE, "%p OUT CFrameFilter::IsObjectMenu ( )\n",
                this ));
}

//+-------------------------------------------------------------------------
//
//  Member:     CFrameFilter::IsMenuCollision
//
//  Synopsis:   Determines if we've had a menu collission. This gets called
//      as a result of WM_INITMENUPOPUP during accelerator translation
//
//  Effects:
//
//  Arguments:  [uParam]        -- the first window message argument
//      [lParam]        -- the second argument
//
//  Requires:
//
//  Returns:    BOOL
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//      07-Dec-93 alexgo    changed Assert(hmenuPopup) to an if
//                          in merging with 16bit RC9 sources
//      07-Dec-93 alexgo    removed inlining
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CFrameFilter::IsMenuCollision(WPARAM uParam, LPARAM lParam)
{
    BOOL             fRet;
    int              iCntrMenu, iObjMenu, iMenuCnt;
    BOOL             fGenerateWmCommand;
    HMENU            hmenuPopup;
    LPOLEMENUITEM    lpMenuList;
    
    VDATEHEAP();
    
    LEDebugOut((DEB_ITRACE, "%p _IN CFrameFilter::IsMenuCollision ( %u ,"
                " %ld )\n", this, uParam, lParam ));
    
    if (m_hmenuCombined == NULL)
    {
        fRet = FALSE;
        goto errRtn;
    }
    
    if (m_lpOleMenu == NULL)
    {
        fRet = FALSE;
        goto errRtn;
    }
    
    hmenuPopup = (HMENU) uParam;
    iObjMenu = (int) LOWORD(lParam);
    
    lpMenuList = m_lpOleMenu->menuitem;
    iMenuCnt = (int) m_lpOleMenu->lMenuCnt;
    
    if (iObjMenu >= iMenuCnt)
    {
        fRet = FALSE;
        goto errRtn;
    }
    
    if( hmenuPopup != (HMENU)UlongToPtr(lpMenuList[iObjMenu].item) )
    {
        // this could be the container's popmenu, not associated
        // with the frame
        fRet = FALSE;
        goto errRtn;
    }
    
    Assert(lpMenuList[iObjMenu].fwPopup);
    
    if (! lpMenuList[iObjMenu].fObjectMenu)
    {
        fRet = FALSE; // container's pop-up menu
        goto errRtn;
    }
    
    // Otherwise the popup menu belongs to the object. This can only
    // happen because of id collision. Start scanning the menus starting
    // from the next top level menu item to look for a match in
    // container's menus (while scanning skip object's menus)
    
    
    // It is possible that the colliding command id may not be associated
    // with any of the container's menus. In that case we must send
    // WM_COMMAND to  the container.
    
    fGenerateWmCommand = TRUE;
    m_fDiscardWmCommand = FALSE;
    iCntrMenu = iObjMenu + 1;
    
    
    while (iCntrMenu < iMenuCnt)
    {
        if (! lpMenuList[iCntrMenu].fObjectMenu)
        {               
            if (lpMenuList[iCntrMenu].fwPopup & MF_POPUP)
            {
                HMENU hmenuListItem = (HMENU)UlongToPtr(lpMenuList[iCntrMenu].item);
                if (GetMenuState(hmenuListItem, m_cmdId, MF_BYCOMMAND) != -1)
                {
                    // We found match in the container's
                    // menu list Generate WM_INITMENUPOPUP
                    // for the corresponding popup
                    SSCallWindowProc ((WNDPROC) m_lpfnPrevWndProc,
                                      m_hwndFrame, 
                                      WM_INITMENUPOPUP,
                                      lpMenuList[iCntrMenu].item /*uParam*/,
                                      MAKELONG(iCntrMenu, HIWORD(lParam)));
                    
                    // We have sent WM_INITMENUPOPUP to
                    // the container.
                    // Now rechek the menu state. If
                    // disabled or grayed then
                    // don't generate WM_COMMAND                       
                    if (GetMenuState(hmenuListItem, m_cmdId, MF_BYCOMMAND) &
                        (MF_DISABLED | MF_GRAYED))
                    {
                        fGenerateWmCommand = FALSE;
                    }
                    
                    break;
                }                   
            }
            else
            {
                // top-level, non-popup container menu
                HMENU hmenuCombined = (HMENU)UlongToPtr(m_lpOleMenu->hmenuCombined);
                if (GetMenuItemID(hmenuCombined, iCntrMenu) == m_cmdId)
                {
                    // No need to generate
                    // WM_INITMENUPOPUP
                    
                    // Chek the menu state. If disabled or
                    // grayed then don't generate
                    // WM_COMMAND
                    if (GetMenuState(hmenuCombined, m_cmdId, MF_BYCOMMAND) &
                        (MF_DISABLED | MF_GRAYED))
                    {
                        fGenerateWmCommand = FALSE;
                    }                       
                    break;
                }
            }
        }
        
        iCntrMenu++;
    }
    
    // Check the object's colliding menu's status
    if (GetMenuState((HMENU)UlongToPtr(lpMenuList[iObjMenu].item), m_cmdId,
                     MF_BYCOMMAND) & (MF_DISABLED | MF_GRAYED))
    {
        // Then windows is not going to genearte WM_COMMAND for the
        // object's  menu, so we will generate
        // the command and send it to the container
        
        if (fGenerateWmCommand)
        {
            SSCallWindowProc ((WNDPROC) m_lpfnPrevWndProc,
                              m_hwndFrame, WM_COMMAND, m_cmdId,
                              MAKELONG(0, 1)); /* not from control */
            // & and as result of
            // accelerator
            m_cmdId = NULL;
        }
    }
    else
    {
        
        // Wait for WM_COMMAND generated by windows to come to our
        // frame filter wndproc which would have been sent to the
        // container anyway because we have not set the m_fObjectMenu
        // flag.
        //
        // But we need to throw it away if the container's menu
        // associated with the command is disabled or grayed
        
        if (! fGenerateWmCommand)
        {
            m_fDiscardWmCommand = TRUE;
        }
    }
    
    fRet = TRUE;
    
errRtn:
    
    LEDebugOut((DEB_ITRACE, "%p OUT CFrameFilter::IsMenuCollision "
                "( %lu )\n", this, fRet));
    
    return fRet;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFrameFilter::DoContextSensitiveHelp
//
//  Synopsis:   Calls IOIPF->ContextSensitive help on both the container
//      and the object.
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    FALSE if we're in popup menu mode, TRUE otherwise
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//      07-Dec-93 alexgo    removed inlining
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CFrameFilter_DoContextSensitiveHelp)
BOOL CFrameFilter::DoContextSensitiveHelp(void)
{
    VDATEHEAP();
    BOOL             fRet;

    LEDebugOut((DEB_ITRACE, "%p _IN CFrameFilter::DoContextSensitiveHelp"
                " ( )\n", this ));

    if (m_fCurItemPopup)
    {
        fRet = FALSE;
    }
    else
    {
        m_lpFrame->ContextSensitiveHelp(TRUE);
        m_lpObject->ContextSensitiveHelp (TRUE);

        PostMessage (m_hwndFrame, WM_COMMAND, m_uCurItemID, 0L);
        fRet = TRUE;
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CFrameFilter::DoContextSensitiveHelp"
                " ( %lu )\n", this, fRet));

    return fRet;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFrameFilter::GetActiveObject
//
//  Synopsis:   Returns the IOleInplaceActiveObject interface pointer
//
//  Effects:
//
//  Arguments:  lplpOIAO
//
//  Requires:
//
//  Returns:    NOERROR or E_INVALIDARG
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      28-Jul-94 bobday    created for WinWord hack
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CFrameFilter_GetActiveObject)
STDMETHODIMP CFrameFilter::GetActiveObject( LPOLEINPLACEACTIVEOBJECT *lplpOIAO)
{
    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CFrameFilter::GetActiveObject"
                " ( %p )\n", this, lplpOIAO ));

    VDATEPTROUT( lplpOIAO, LPOLEINPLACEACTIVEOBJECT);

    *lplpOIAO = m_lpObject;

    if ( m_lpObject )
    {
        m_lpObject->AddRef();
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CFrameFilter::GetActiveObject"
                " ( %lx ) [ %p ]\n", this, NOERROR , *lplpOIAO ));

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function:   wGetFrameFilterPtr
//
//  Synopsis:   Gets the CFrame object from the window
//
//  Effects:
//
//  Arguments:  [hwndFrame]     -- the window to get the CFrame object from
//
//  Requires:
//
//  Returns:    pointer to the frame filter
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


inline PCFRAMEFILTER wGetFrameFilterPtr(HWND hwndFrame)
{
    VDATEHEAP();

    return (PCFRAMEFILTER) GetProp (hwndFrame, szPropFrameFilter);
}

//+-------------------------------------------------------------------------
//
//  Function:   wGetOleMenuPtr
//
//  Synopsis:   Locks a handle to an ole menu and returns the pointer
//      (after some error checking)
//
//  Effects:
//
//  Arguments:  [holemenu]
//
//  Requires:
//
//  Returns:    pointer to the ole menu
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

LPOLEMENU wGetOleMenuPtr(HOLEMENU holemenu)
{
    VDATEHEAP();

    LPOLEMENU        lpOleMenu;

    if (! (holemenu &&
           (lpOleMenu = (LPOLEMENU) GlobalLock((HGLOBAL) holemenu))))
    {
        return NULL;
    }

    if (lpOleMenu->wSignature != wSignature)
    {
        AssertSz(FALSE, "Error - handle is not a HOLEMENU");
        GlobalUnlock((HGLOBAL) holemenu);
        return NULL;
    }

    return lpOleMenu;
}

//+-------------------------------------------------------------------------
//
//  Function:   wReleaseOleMenuPtr
//
//  Synopsis:   calls GlobalUnlock
//
//  Effects:
//
//  Arguments:  [holemenu]      -- handle to the ole menu
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

inline void     wReleaseOleMenuPtr(HOLEMENU holemenu)
{
    VDATEHEAP();

    GlobalUnlock((HGLOBAL) holemenu);
}

//+-------------------------------------------------------------------------
//
//  Function:   MessageFilterProc
//
//  Synopsis:   The message filter installed when entering menu mode;
//      handles context sensitive help
//
//  Effects:
//
//  Arguments:  [nCode]         -- hook code
//      [wParam]        -- first arg
//      [lParam]        -- second arg
//
//  Requires:
//
//  Returns:    LRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(MessageFilterProc)
STDAPI_(LRESULT) MessageFilterProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    VDATEHEAP();
    LRESULT          lresult;
    LPMSG            lpMsg = (LPMSG) lParam;


    LEDebugOut((DEB_TRACE, "%p _IN MessageFilterProc ( %d , %ld , %lu )\n",
                NULL, nCode, (LONG)wParam, lParam));

    // If it is not the F1 key then let the message (wihtout modification)
    // go to the next proc in the hook/filter chain.

    if (lpMsg && lpMsg->message == WM_KEYDOWN
        && lpMsg->wParam == VK_F1 && pFrameFilter)
    {
        if (pFrameFilter->DoContextSensitiveHelp())
        {
            // Change message value to be WM_CANCELMODE and then
            // call the next hook. When the windows USER.EXE's
            // menu processing code sees this message it will
            // bring down menu state and come out of its
            // menu processing loop.

            lpMsg->message = WM_CANCELMODE;
            lpMsg->wParam  = NULL;
            lpMsg->lParam  = NULL;
        }
        else
        {
            lresult = TRUE;  // otherwise throw away this message.
            goto errRtn;
        }
    }

    lresult = CallNextHookEx (hMsgHook, nCode, wParam, lParam);

errRtn:
    LEDebugOut((DEB_TRACE, "%p OUT MessageFilterProc ( %ld )\n", NULL,
                lresult));

    return lresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\inplace\inplace.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       inplace.h
//
//  Contents:   Private API's and classes for the inplace OLE API's
//
//  Classes:    CFrameFilter
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              24-Jan-94 alexgo    first pass converting to Cairo style
//                                  memory allocation
//              07-Dec-93 alexgo    removed inlining
//              01-Dec-93 alexgo    32bit port
//
//--------------------------------------------------------------------------

#if !defined( _INPLACE_H_ )
#define _INPLACE_H_

// This ACCEL structure and the related constants definitions come with WIN32.
// Win31 also uses the same stuff internally but it's not exposed in the
// header files.

#ifndef FVIRTKEY

#define FVIRTKEY  TRUE          // Assumed to be == TRUE
#define FLASTKEY  0x80          // Indicates last key in the table
#define FNOINVERT 0x02
#define FSHIFT    0x04
#define FCONTROL  0x08
#define FALT      0x10

#pragma pack(1)
typedef struct tagACCEL {       // Accelerator Table structure
        BYTE    fVirt;
        WORD    key;
        WORD    cmd;
} ACCEL, FAR* LPACCEL;
#pragma pack()

#endif // FVIRTKEY

// private structures

typedef struct tagOLEMENUITEM
{
    UINT                    item;        // index or hwnd
    WORD                    fwPopup;
    BOOL                    fObjectMenu;
} OLEMENUITEM;
typedef OLEMENUITEM FAR* LPOLEMENUITEM;

typedef struct tagOLEMENU
{
    WORD                    wSignature;
    DWORD                   hwndFrame;     // Really a hwnd
    DWORD                   hmenuCombined; // Really a hmenu
    OLEMENUGROUPWIDTHS      MenuWidths;
    LONG                    lMenuCnt;
    OLEMENUITEM             menuitem[1];
} OLEMENU;
typedef OLEMENU FAR* LPOLEMENU;


//+-------------------------------------------------------------------------
//
//  Class:      CFrameFilter
//
//  Purpose:    Gets attached to an apps window so we can store various
//              bits of relevant info
//
//  Interface:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Dec-93 alexgo    32bit port
//
//  Notes:      CSafeRefCount inherits CPrivAlloc
//
//--------------------------------------------------------------------------

class FAR CFrameFilter : public CSafeRefCount
{
public:
        static HRESULT Create(LPOLEMENU lpOleMenu, HMENU hmenuCombined,
                                HWND hwndFrame, HWND hwndActiveObj,     
                                LPOLEINPLACEFRAME lpFrame,
                                LPOLEINPLACEACTIVEOBJECT lpActiveObj);
                
        CFrameFilter (HWND hwndFrame, HWND hwndActiveObj);              
        ~CFrameFilter(void);
        
        LRESULT         OnSysCommand(WPARAM uParam, LPARAM lParam);
        void            OnEnterMenuMode(void);
        void            OnExitMenuMode(void);
        void            OnEnterAltTabMode(void);
        void            OnExitAltTabMode(void); 
        LRESULT         OnMessage(UINT msg, WPARAM uParam, LPARAM lParam);  
        void            IsObjectMenu (UINT uMenuItem, UINT fwMenu);
        BOOL            IsMenuCollision(WPARAM uParam, LPARAM lParam);      
        BOOL            DoContextSensitiveHelp();
        STDMETHOD(GetActiveObject) (
                               LPOLEINPLACEACTIVEOBJECT *lplpActiveObj);

        void            RemoveWndProc();

private:
        HWND                            m_hwndObject;
        HWND                            m_hwndFrame;
        LPOLEINPLACEFRAME               m_lpFrame;
        LPOLEINPLACEACTIVEOBJECT        m_lpObject;
        WNDPROC                         m_lpfnPrevWndProc;
        BOOL                            m_fObjectMenu;
        BOOL                            m_fCurItemPopup;
        BOOL                            m_fInMenuMode;
        BOOL                            m_fDiscardWmCommand;
        BOOL                            m_fGotMenuCloseEvent;
        BOOL                            m_fRemovedWndProc;
        UINT                            m_cmdId;
        UINT_PTR                        m_uCurItemID;
        LPOLEMENU                       m_lpOleMenu;
        HMENU                           m_hmenuCombined;
        HWND                            m_hwndFocusOnEnter;
        int                             m_cAltTab;
};

typedef CFrameFilter FAR* PCFRAMEFILTER;


STDAPI_(LRESULT)        FrameWndFilterProc (HWND hwnd, UINT msg, WPARAM uParam,
                                        LPARAM lParam);
STDAPI_(LRESULT)        MessageFilterProc(int nCode, WPARAM wParam,
                                        LPARAM lParam);

BOOL                    IsMDIAccelerator(LPMSG lpMsg, WORD FAR* cmd);

inline PCFRAMEFILTER    wGetFrameFilterPtr(HWND hwndFrame);

LPOLEMENU               wGetOleMenuPtr(HOLEMENU holemenu);
inline void             wReleaseOleMenuPtr(HOLEMENU holemenu);

#endif // _INPLACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\ole1\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   ole1
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\..\common\$(DEST_TREE);..\..\..\ih;..\..\inc

SOURCES=      \
              ..\ddecnvrt.cpp \
              ..\ostm2stg.cpp

UMTYPE=       windows

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\ole1\ostm2stg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       ostm2stg.cpp
//
//  Contents:   OLE 1 - OLE 2 Stream/IStorage Interoperatbility
//
//  Functions:  Implements API functions:
//              OleConvertOLESTREAMToIStorage
//              OleConvertIStorageToOLESTREAM
//              OleConvertOLESTREAMToIStorageEx
//              OleConvertIStorageToOLESTREAMEx
//
//
//  History:    dd-mmm-yy Author    Comment
//              03-Feb-92 jasonful  original version
//              08-Aug-93 srinik    added Ex functions
//              12-Feb-94 davepl    32-bit port
//
//--------------------------------------------------------------------------

#include <le2int.h>
#include "ostm2stg.h"
#include <ctype.h>
#include <limits.h>
#include <string.h>
#include <ole1cls.h>

ASSERTDATA

// We need a ptr value which will indicate that the associated handle
// is a metafile handle, and therefore cannot be cleaned up as if
// it were a normal global memory handle

#define METADATAPTR ((void *) -1)

// This fn is not prototyped in any include file, since it was static
// to its file.  Need to add the prototype to a common include file.

HRESULT STDAPICALLTYPE CreateOle1FileMoniker(LPWSTR,REFCLSID,LPMONIKER FAR*);

// This is defined in the new privstm.cpp; must be added to an include file.

STDAPI      ReadFmtProgIdStg ( IStorage   * pstg, LPOLESTR   * pszProgID );
FARINTERNAL wWriteFmtUserType (LPSTORAGE, REFCLSID);



//+-------------------------------------------------------------------------
//
//  Member:     CGenericObject::CGenericObject
//
//  Synopsis:   Constructor for CGenericObject class
//
//  Effects:    Initializes all child pointers to NULL and sets
//              flags to FALSE
//
//  History:    dd-mmm-yy Author    Comment
//              14-Feb-94 davepl    Cleanup and document
//
//  Notes:
//
//--------------------------------------------------------------------------
CGenericObject::CGenericObject(void)
{
    m_ppres         = NULL;     // Presentation data
    m_fLink         = FALSE;    // Flag: Linked (T) or Embedded (F)
    m_fStatic       = FALSE;    // Flag: Static object
    m_fNoBlankPres  = FALSE;    // Flag: do not want a blank presentation
    m_szTopic       = NULL;     // Topic string for this object
    m_szItem        = NULL;     // Item (file) string for this object
}


//+-------------------------------------------------------------------------
//
//  Member:     CGenericObject::~CGenericObject
//
//  Synopsis:   Desctuctor for CGenericObject class
//
//  Effects:    Removes children then self
//
//  History:    dd-mmm-yy Author    Comment
//              12-Aug-94 alexgo    check for NULL before delete
//              14-Feb-94 davepl    Cleanup and document
//
//  Notes:      As much as I hated to do it, some of these strings
//                              have to be freed with PubMemFree because they are
//                              allocated by UtDupString, which allocates public memory.
//
//--------------------------------------------------------------------------

CGenericObject::~CGenericObject (void)
{
    if( m_ppres )
    {
	delete m_ppres;         // Presentation data
    }

    if( m_szTopic )
    {
	PubMemFree(m_szTopic);  // Topic string
    }

    if( m_szItem )
    {
	PubMemFree(m_szItem);   // Item string
    }
}

 
//+-------------------------------------------------------------------------
//
//  Member:     CData::CData
//
//  Synopsis:   Constructor for a simple class which holds a piece of
//              memory.
//
//  Effects:    Clears size, flags, and pointer
//
//  History:    dd-mmm-yy Author    Comment
//
//  Notes:      14-Feb-94 davepl    Cleanup and document
//
//--------------------------------------------------------------------------

CData::CData (void)
{
    m_cbSize = 0;           // Count, in bytes, of data size
    m_h = NULL;             // Memory handke
    m_pv= NULL;             // Memory pointer
    m_fNoFree = FALSE;      // Flag: Should memory be freed in destructor
}


//+-------------------------------------------------------------------------
//
//  Member:     CData::~CData
//
//  Synopsis:   Destructor for simple data class
//
//  Effects:    Unlocks and frees memory if m_fNoFree is not set
//
//  History:    dd-mmm-yy Author    Comment
//              14-Feb-94 davepl    Cleanup and document
//
//  Notes:      If a metafile handle is stored in the handle, the
//              pointer will be marked with a special value, indicating
//              that we must DeleteMetafile, not GlobalFree the handle.
//
//--------------------------------------------------------------------------

CData::~CData (void)
{
    if (m_h)                                // Do we have a handle?
    {
	if (m_pv == METADATAPTR)
	{
		LEVERIFY(DeleteMetaFile((HMETAFILE) m_h));
	}
	else
	{
		GlobalUnlock (m_h);                 // Dec lock count
		if (!m_fNoFree)                     // Free this memory if we
		{                                   // have been flagged to do so
			LEVERIFY(0==GlobalFree (m_h));
		}
	}
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CFormat::CFormat
//
//  Synopsis:   CFormat class constructor
//
//  Effects:    Initializes format tag and clipboard format
//
//  History:    dd-mmm-yy Author    Comment
//
//  Notes:      14-Feb-94 davepl    Cleanup and document
//
//--------------------------------------------------------------------------

CFormat::CFormat (void)
{
    m_ftag = ftagNone;      // Format tag (string, clipformat, or none)
    m_cf = 0;               // Clipboard format
}

//+-------------------------------------------------------------------------
//
//  Member:     CClass::CClass
//
//  Synopsis:   CClass constructor
//
//  Effects:    sets class ID and class ID string to NULL
//
//  History:    dd-mmm-yy Author    Comment
//
//  Notes:
//
//--------------------------------------------------------------------------

CClass::CClass (void)
{
    m_szClsid = NULL;
    m_clsid   = CLSID_NULL;
}

//+-------------------------------------------------------------------------
//
//  Member:     CPres::CPres
//
//  Synopsis:   CPres constructor
//
//  Effects:    Initializes height & width of presentation data to zero.
//
//  History:    dd-mmm-yy Author    Comment
//
//  Notes:
//
//--------------------------------------------------------------------------


CPres::CPres (void)
{
    m_ulHeight = 0L;
    m_ulWidth  = 0L;
}


//+-------------------------------------------------------------------------
//
//  Member:     CClass::Set, INTERNAL
//
//  Synopsis:   Sets the m_szClsid based on clsid
//
//  Effects:    Sets m_szClsid in the following order of preference:
//              - ProgID obtained from ProgIDFromCLSID()
//              - If it is a static type, m_szClsid is left blank
//              - Tries to read it from [pstg]
//              - Tries to obtain it from registry based on CLSID
//
//
//  Arguments:  [clsid]     - class id object is to be set to
//              [pstg]      - storage which may contain info on the
//                            clipboard format as a last resort
//
//  Returns:    NOERROR                 on success
//              REGDB_E_CLASSNOTREG     unknown class
//
//  History:    dd-mmm-yy Author    Comment
//              16-Feb-94 davepl    Cleaned up and documented
//
//  Notes:      Hard-coded maximum of 256 character clip format name.
//              On failure, m_clsid has still been set to clsid.
//
//--------------------------------------------------------------------------

INTERNAL CClass::Set (REFCLSID clsid, LPSTORAGE pstg)
{
    CLIPFORMAT cf;
    unsigned short const ccBufSize = 256;
    LPOLESTR szProgId = NULL;

    Assert (m_clsid == CLSID_NULL && m_szClsid == NULL);

    // set the m_clsid member in the object
    m_clsid = clsid;

    // If we can get it using ProgIDFromCLSID, that's the simplest case
    if (NOERROR == wProgIDFromCLSID (clsid, &m_szClsid))
    {
	return NOERROR;
    }

    // If not, maybe the object is static, in which case we leave the
    // class string NULL

    if (IsEqualCLSID(CLSID_StaticMetafile, clsid) ||
	IsEqualCLSID(CLSID_StaticDib, clsid))
    {
	return NOERROR;
    }

    // If still no luck, try to read the clipboard format from the storage
    // and then look that up.

    if (pstg &&
	SUCCEEDED(ReadFmtUserTypeStg(pstg, &cf, NULL)) &&
	SUCCEEDED(ReadFmtProgIdStg  (pstg, &szProgId)))
    {
	// Last-ditch effort.  If the class is an unregistered OLE1 class,
	// the ProgID should still be obtainable from the format tag.
	// If the class is an unregistered OLE2 class, the ProgId should be
	// at the end of the CompObj stream.

	if (CoIsOle1Class(clsid))
	{
	    Verify (GetClipboardFormatName (cf, szProgId, ccBufSize));
	}
	else
	{
	    // If its an OLE 2 object and we couldn't get the program ID from
	    // the storage, we're out of luck

	    if (szProgId == NULL || szProgId[0] == L'\0')
	    {
		if (szProgId)
		{
		    PubMemFree(szProgId);
		}
	    return ResultFromScode (REGDB_E_CLASSNOTREG);
	    }
	}

	// At this point we know we have a program ID and that this is an
	// OLE 2 object, so we use the program ID as the class name.

	m_szClsid = szProgId;
	return NOERROR;
    }
    else
    {
	// If we hit this path, we couldn't read from the storage

	return ResultFromScode (REGDB_E_CLASSNOTREG);
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CClass:SetSz, INTERNAL
//
//  Synopsis:   Sets CGenericObject's CLASS member ID based on the class
//              name passed in.
//
//  History:    dd-mmm-yy Author    Comment
//              15-Feb-94 davepl    Cleaned up and documented
//
//--------------------------------------------------------------------------


INTERNAL CClass::SetSz (LPOLESTR sz)
{
    HRESULT hr;

    // The class info should be completely unset at this point
    Assert (m_clsid==CLSID_NULL && m_szClsid==NULL);

    m_szClsid = sz;

    if (FAILED(hr = wCLSIDFromProgID (sz, &m_clsid, TRUE)))
    {
	return hr;
    }

    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Member:     CClass::Reset
//
//  Synopsis:   Frees the Class ID string for CClass and resets the pointer,
//              then sets the class ID and string bassed on the CLSID
//              passed in.
//
//  History:    dd-mmm-yy Author    Comment
//              16-Feb-94 davepl    Cleaned up and documented
//
//  Notes:      Class ID must already be set before calling RESET
//
//--------------------------------------------------------------------------

INTERNAL CClass::Reset (REFCLSID clsid)
{
    m_clsid = clsid;

    // We should already have a class ID string if we are _re_setting it
    Assert(m_szClsid);

    PubMemFree(m_szClsid);

    HRESULT hr;
    m_szClsid = NULL;

    if (FAILED(hr = wProgIDFromCLSID (clsid, &m_szClsid)))
    {
	return hr;
    }

    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Member:     CClass::~CClass
//
//  Synopsis:   CClass destructor
//
//  History:    dd-mmm-yy Author    Comment
//              12-Aug-94 alexgo    check for NULL before free'ing memory
//  Notes:
//
//--------------------------------------------------------------------------

CClass::~CClass (void)
{
    // The string is created by UtDupString, so its public memory

    if( m_szClsid )
    {
	PubMemFree(m_szClsid);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   wConvertOLESTREAMToIStorage, INTERNAL
//
//  Synopsis:   Worker function.  Ensures the OLESTREAM is correctly
//              set up then calls OLESTREAMToGenericObject.
//
//  History:    dd-mmm-yy Author    Comment
//              15-Feb-94 davepl    Cleaned up and documented
//  Notes:
//
//--------------------------------------------------------------------------


INTERNAL wConvertOLESTREAMToIStorage(
    LPOLESTREAM polestream,
    LPSTORAGE   pstg,
    PGENOBJ     pgenobj)
{
    VDATEIFACE (pstg);

#if DBG==1
    if (!IsValidReadPtrIn (polestream, sizeof(OLESTREAM)) ||
	!IsValidReadPtrIn (polestream->lpstbl, sizeof(OLESTREAMVTBL)) ||
	!IsValidCodePtr ((FARPROC)polestream->lpstbl->Get))
    {
	AssertSz (0, "Bad OLESTREAM");
	return ResultFromScode (E_INVALIDARG);
    }
#endif

    return OLESTREAMToGenericObject (polestream, pgenobj);
}

//+-------------------------------------------------------------------------
//
//  Function:   OleConvertOLESTREAMToIStorage, STDAPI
//
//  Synopsis:   Given an OLE 1 stream and an OLE 2 storage, reads an object
//              from the OLE 1 stream into a CGenericObject.  Once read in,
//              the object is written from generic format back into the OLE 2
//              storage object.
//
//  Arguments:  [polestream]    -- OLE 1 stream to read object from
//              [pstg]          -- OLE 2 storage to write object to
//              [ptd]           -- Target device
//
//  Requires:   Streams should be set up, and OLE 1 stream should be
//              positioned at the beginning of the next OLE 1 object
//              to be read.
//
//  Returns:    [DV_E_DVTARGETDEVICE]       Invalid write ptr to target device
//              CONVERT10_E_OLESTREAM_FMT   On unknown OLE 1 format
//              CONVERT10_E_OLESTREAM_GET   On stream read failue
//              E_OUTOFMEMORY               On stream I/O memory failure
//
//  History:    dd-mmm-yy Author    Comment
//              14-Feb-94 davepl    Cleanup and documentation
//
//  Notes:
//
//--------------------------------------------------------------------------

STDAPI OleConvertOLESTREAMToIStorage(
    LPOLESTREAM                 polestream,
    LPSTORAGE                   pstg,
    const DVTARGETDEVICE FAR*   ptd)
{

    OLETRACEIN((API_OleConvertOLESTREAMToIStorage,
				PARAMFMT("polestream= %p, pstg= %p, ptd= %td"),
				polestream, pstg, ptd));

    LEDebugOut((DEB_TRACE, "%p _IN OleConvertOLESTREAMToIStorage ("
	" %p , %p , %p)\n", 0 /*function*/,
	polestream, pstg, ptd
    ));
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IStorage,(IUnknown **)&pstg);

    HRESULT hresult;

    // This is the generic object we will use as intermediate storage to
    // hold the contents of the OLESTREAM

    CGenericObject genobj;

    if (ptd)
    {
	// The side of the td is the first DWORD.  Ensure that much is
	// valid and then we can use it to check the whole structure.
	if (!IsValidReadPtrIn (ptd, sizeof(DWORD)))
	{
	    hresult = ResultFromScode (DV_E_DVTARGETDEVICE);
	    goto errRtn;
	}
	if (!IsValidReadPtrIn (ptd, (UINT) ptd->tdSize))
	{
	    hresult = ResultFromScode (DV_E_DVTARGETDEVICE_SIZE);
	    goto errRtn;
	}
    }

    if (FAILED(hresult=wConvertOLESTREAMToIStorage(polestream,pstg,&genobj)))
    {
	goto errRtn;
    }

    // If we were able to read the object out of the stream, we can now try
    // to write it back out to the storage

    hresult = GenericObjectToIStorage (genobj, pstg, ptd);

errRtn:
    LEDebugOut((DEB_TRACE, "%p OUT OleConvertOLESTREAMToIStorage ( %lx ) "
    "\n", 0 /*function*/, hresult));

    OLETRACEOUT((API_OleConvertOLESTREAMToIStorage, hresult));
    return hresult;

}

//+-------------------------------------------------------------------------
//
//  Function:   PrependUNCName
//
//  Synopsis:   Convert *pszFile to use szUNC=="\\server\share" instead
//              of drive letter
//
//  Effects:    Deletes the UNC name and returns *ppszFile as a NEW string
//              with the full UNC filename.  The string originally held at
//              *ppszFile is deleted by this function.
//
//  Arguments:  [ppszFile]      Pointer to incoming filename string pointer
//
//  History:    dd-mmm-yy Author    Comment
//              16-Feb-94 davepl    Cleanup, documentation, allocation fixes
//
//  Notes:      This function does some frightening things by changing the
//              caller's pointer and deleting various reference parameters.
//              Be sure you know what's going on before turning this function
//              loose on one of your own pointers.
//
//--------------------------------------------------------------------------

static INTERNAL PrependUNCName (LPOLESTR FAR* ppszFile, LPOLESTR szUNC)
{
    HRESULT hresult = NOERROR;
    LPOLESTR szNew;

    // No place to put result, so nothing to do...
    if (NULL==szUNC)
    {
	return hresult;
    }

    // Ensure the caller's pointer is valid
    if (NULL == *ppszFile)
    {
	return ResultFromScode(CONVERT10_E_OLESTREAM_FMT);
    }

    // Ensure the second letter of path is a colon (ie; X:\file)
    if((*ppszFile)[1] != L':')
    {
	return ResultFromScode(CONVERT10_E_OLESTREAM_FMT);
    }

    // Allocate enough space for new filename (we will be
    // omitting the X: portion of the filename, so this calculation
    // is _not_ short by 2 as it may appear)

    szNew = (LPOLESTR)
    PubMemAlloc((_xstrlen(*ppszFile)+_xstrlen (szUNC)) * sizeof(OLECHAR));

    if (NULL == szNew)
    {
	return ResultFromScode(E_OUTOFMEMORY);
    }

    // Copy over the UNC name
    _xstrcpy (szNew, szUNC);

    // Add the original name, except for the X:
    _xstrcat (szNew, (*ppszFile) + 2);

    // Free the original name
    PubMemFree(*ppszFile);
    *ppszFile = szNew;

    // Delete the UNC name
    PubMemFree(szUNC);
    return hresult;
}



//+-------------------------------------------------------------------------
//
//  Function:   OLESTREAMToGenericObject, INTERNAL
//
//  Synopsis:   Reads and OLE 1.0 version of an object from an OLE 1 stream
//              and stores it internally, including presentation and native
//              data, in a GenericObject.
//
//  Effects:    Creates a GenericObject that can be written back in OLE 1
//              or OLE 2 format
//
//  Arguments:  [pos]       -- pointer to OLE 1 stream to read object from
//              [pgenobj]   -- pointer to generic object to read into
//
//  Requires:   Input stream setup and GenObj created
//
//  Returns:    NOERROR                     On success
//              CONVERT10_E_OLESTREAM_FMT   On unknown OLE 1 format
//              CONVERT10_E_OLESTREAM_GET   On stream read failue
//              E_OUTOFMEMORY               On stream I/O memory failure
//
//  Signals:    (none)
//
//  Modifies:   Stream position, GenObj
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              14-Feb-94 davepl    Added Trace code
//                        davepl    Cleaned up and documented
//                        davepl    Rerouted errors through central return
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OLESTREAMToGenericObject)
static INTERNAL OLESTREAMToGenericObject
(
    LPOLESTREAM pos,
    PGENOBJ     pgenobj
)
{
    HRESULT error   = NOERROR;
    ULONG   ulFmtId;
    LPOLESTR szClass = NULL;

    // Read OLE Version # from the stream and discard it
    if (FAILED(error = OLE1StreamToUL(pos, NULL)))
    {
	LEDebugOut(( DEB_ERROR,
	    "Unable to read OLE ver# from stream at line %d in %s\n",
	    __LINE__, __FILE__));
	goto errRtn;
    }

    // Get Format ID from the stream
    if (FAILED(error = OLE1StreamToUL(pos, &ulFmtId)))
    {
	LEDebugOut(( DEB_ERROR,
	    "Unable to read format ID from stream at line %d in %s\n",
	    __LINE__, __FILE__));
	goto errRtn;
    }

    // If this is a static object, read it into the generic object and return
    if (ulFmtId == FMTID_STATIC)
    {
	if (FAILED(error = GetStaticObject (pos, pgenobj)))
	{
	    LEDebugOut(( DEB_ERROR,
	    "Unable to read static object at line %d in %s\n",
	    __LINE__, __FILE__));
	}
	goto errRtn;
    }

    // If this is neither a linked nor an embedded object, something
    // is wrong
    if (ulFmtId != FMTID_LINK && ulFmtId != FMTID_EMBED)
    {
	LEDebugOut(( DEB_ERROR,
	    "Object is neither linked nor embedded at line %d in %s\n",
	    __LINE__, __FILE__));

	error = ResultFromScode(CONVERT10_E_OLESTREAM_FMT);
	goto errRtn;
    }

    // If this is a linked object, set our flag in GenericObject
    if (FMTID_LINK == ulFmtId)
    {
	pgenobj->m_fLink = TRUE;
    }

    // Read the class name from the stream

    if (FAILED(error = OLE1StmToString(pos, &szClass)))
    {
	LEDebugOut(( DEB_ERROR,
	    "Unable to read the class name from stream at line %d in %s\n",
	    __LINE__, __FILE__));

	goto errRtn;
    }
    if (NULL == szClass)
    {
	LEDebugOut(( DEB_ERROR,
	    "Class name was returned NULL at line %d in %s\n",
	    __LINE__, __FILE__));

	error = CONVERT10_E_OLESTREAM_FMT;
	goto errRtn;
    }

    // If this is an embedded object, set the class ID and class string
    // If it is a linked object, set the class name but set the class ID
    // to CLSID_StdOleLink

    if (FMTID_EMBED == ulFmtId)
    {
	pgenobj->m_class.SetSz (szClass);
    }
    else
    {
	Assert (ulFmtId == FMTID_LINK);
	pgenobj->m_classLast.SetSz (szClass);
	pgenobj->m_class.Set (CLSID_StdOleLink, NULL);
    }

    // Read the Topic string from the stream
    if (FAILED(error = OLE1StmToString(pos, &(pgenobj->m_szTopic))))
    {
	LEDebugOut(( DEB_ERROR,
	    "Unable to read topic string from stream at line %d in %s\n",
	    __LINE__, __FILE__));

	goto errRtn;
    }

    // Read the Item string from the stream
    if (FAILED(error = OLE1StmToString(pos, &(pgenobj->m_szItem))))
    {
	LEDebugOut(( DEB_ERROR,
	    "Unable to get item string from stream at line %d in %s\n",
	    __LINE__, __FILE__));

	goto errRtn;
    }

    // If this is a linked object, set up the filename etc.
    if (FMTID_LINK == ulFmtId)
    {
	LPOLESTR szUNCName = NULL;

	// Read the network name from the stream

	if (FAILED(error = OLE1StmToString(pos, &szUNCName)))
	{
	    LEDebugOut(( DEB_ERROR,
		"Unable to get network name from stream at line %d in %s\n",
		__LINE__, __FILE__));

	    goto errRtn;
	}

	// Convert a drive-letter based name to \\srv\share name
	if (FAILED(error = PrependUNCName (&(pgenobj->m_szTopic), szUNCName)))
	{
	    LEDebugOut(( DEB_ERROR,
		"Unable to convert drv ltr to UNC name at line %d in %s\n",
		__LINE__, __FILE__));

	    goto errRtn;
	}

	// Read network type and network driver version # from stream
	// (They are both shorts and we discarding them, so read a LONG)
	if (FAILED(error = OLE1StreamToUL (pos, NULL)))
	{
	    LEDebugOut(( DEB_ERROR,
		"Unable to get net type/ver from stream at line %d in %s\n",
		__LINE__, __FILE__));

	    goto errRtn;
	}

	// Read the link-updating options from the stream.  This field
	// use OLE 1.0 enumeration values for the link update options
	if (FAILED(error = OLE1StreamToUL(pos, &(pgenobj->m_lnkupdopt))))
	{
	    LEDebugOut(( DEB_ERROR,
		"Unable to read link update opts at line %d in %s\n",
		__LINE__, __FILE__));

	    goto errRtn;
	}

	// OLE 1.0 duplicates the link update options in the highword
	// of the LONG, and we don't want that, so clear the highword.

	pgenobj->m_lnkupdopt &= 0x0000FFFF;
    }
    else // This path is taken to read in embedded objects
    {
	Assert (ulFmtId == FMTID_EMBED);

	// Read and store the native data from the stream
	if (FAILED(error = GetSizedDataOLE1Stm (pos, &(pgenobj->m_dataNative))))
	{
	    LEDebugOut(( DEB_ERROR,
		"Unable to get native data from stream at line %d in %s\n",
		__LINE__, __FILE__));

	    goto errRtn;
	}
    }

    // For both linked and embedded objects, we need to read in any
    // presentation data that may be present.  Note that certain formats
    // such as MS-Paint will not provide presentation data; this is OK
    // since they can be rendered by native data alone (space saving measure)

    if (FAILED(error = GetPresentationObject (pos, pgenobj)))
    {
	LEDebugOut(( DEB_ERROR,
	    "Unable to get presentation data from stream at line %d in %s\n",
	    __LINE__, __FILE__));

	goto errRtn;
    }

errRtn:

    LEDebugOut((DEB_ITRACE, "%p OUT OLESTREAMToGenericObject ( %lx ) \n",
	NULL /*function*/, error));

    return error;
}



//+-------------------------------------------------------------------------
//
//  Function:   GetStaticObject, INTERNAL
//
//  Synopsis:   Reads the presentation data for a static object into the
//              PPRES member of GenericObject, and sets format and class
//              flags accordingly
//
//  Effects:
//
//  Arguments:  [pos]           -- stream we are reading OLE 1 object from
//              [pgenobj]       -- GenericObject we are reading into
//  Requires:
//
//  Returns:    NOERROR                     On success
//              CONVERT10_E_OLESTREAM_FMT   On unknown OLE 1 format
//              CONVERT10_E_OLESTREAM_GET   On stream read failue
//              E_OUTOFMEMORY               On stream I/O memory failure
//
//  Signals:    (none)
//
//  Modifies:   Stream position, GenericObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              14-Feb-94 davepl    Cleanup and documentation
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL GetStaticObject (LPOLESTREAM pos, PGENOBJ pgenobj)
{
    HRESULT error;

    // Read the presentation data, standard or generic, into the
    // PPRES member of the GenericObject
    if (FAILED(error = GetPresentationObject(pos, pgenobj, TRUE)))
    {
	return ResultFromScode(error);
    }

    // Ensure that the format tag is a clipboard format
    if (ftagClipFormat != pgenobj->m_ppres->m_format.m_ftag)
    {
	return ResultFromScode(CONVERT10_E_OLESTREAM_FMT);
    }

    // If the clipboard format is a METAFILEPIC, set the CLASS
    // member of GenericObject to CLSID_StaticMetafile
    if (CF_METAFILEPICT == pgenobj->m_ppres->m_format.m_cf)
    {
	pgenobj->m_class.Set (CLSID_StaticMetafile, NULL);
    }

    // Otherwise, check to see if it is a DIB, and set the CLASS
    // member accordingly

    else if (CF_DIB == pgenobj->m_ppres->m_format.m_cf)
    {
	pgenobj->m_class.Set (CLSID_StaticDib, NULL);
    }

    // If it is neither a METAFILEPIC nor a DIB, we have a problem

    else
    {
	AssertSz (0, "1.0 static object not in one of 3 standard formats");
	return ResultFromScode (CONVERT10_E_OLESTREAM_FMT);
    }

    // Flag the GenericObject as Static
    pgenobj->m_fStatic = TRUE;
    return NOERROR;
}



//+-------------------------------------------------------------------------
//
//  Function:   CreateBlankPres, INTERNAL
//
//  Synopsis:   Sets up the format in the PPRES struct as ClipFormat 0
//
//  History:    dd-mmm-yy Author    Comment
//              16-Feb-94 davepl    Cleaned up
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL CreateBlankPres(PPRES ppres)
{
    Assert (ppres);
    ppres->m_format.m_ftag = ftagClipFormat;
    ppres->m_format.m_cf   = 0;
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetPresentationObject, INTERNAL
//
//  Synopsis:   Reads the presentation data into the CGenericObject object
//
//  Arguments:  [pos]           -- OLE 1 stream we are reading from
//              [pgenobj]       -- Generic object we are reading to
//              [fStatic]       -- Flag: getting a static pres object?
//
//  Requires:   stream open, object allocated
//
//  Returns:    CONVERT10_E_OLESTREAM_FMT       unknown format id in stream
//
//
//  History:    dd-mmm-yy Author    Comment
//              16-Feb-94 davepl    Cleaned up and documented
//
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL GetPresentationObject(
    LPOLESTREAM  pos,
    PGENOBJ      pgenobj,
    BOOL         fStatic)
{
    LPOLESTR szClass = NULL;
    HRESULT hresult  = NOERROR;

    Assert (pgenobj->m_ppres==NULL);

    if (TRUE != fStatic)    //FALSE!
    {
	// Pull the OLE version number out of the stream, we don't want it

	if (FAILED(hresult = OLE1StreamToUL(pos, NULL)))
	{
	    return hresult;
	}

	// Pull the OLE 1 format identifier out of the stream

	ULONG ulFmtId;
	if (FAILED(hresult = OLE1StreamToUL (pos, &ulFmtId)))
	{
	    return hresult;
	}

	// If the format identifier is not FMTID_PRES, we've got a
	// problem... unless it's 0 in which case it simply means
	// that there _is no_ presentation data, ie: PBrush, Excel

	if (ulFmtId != FMTID_PRES)
	{
	    if (0==ulFmtId)
	    {
		return NOERROR;
	    }
	    else
	    {
		return ResultFromScode(CONVERT10_E_OLESTREAM_FMT);
	    }
	}
    }

    // Pull in the type name for the OLE1 data

    if (FAILED(hresult = OLE1StmToString (pos, &szClass)))
    {
	return hresult;
    }

    if (0==_xstrcmp (szClass, OLESTR("METAFILEPICT")))
    {
	hresult = GetStandardPresentation (pos, pgenobj, CF_METAFILEPICT);
    }
    else if (0==_xstrcmp (szClass, OLESTR("BITMAP")))
    {
	hresult = GetStandardPresentation (pos, pgenobj, CF_BITMAP);
    }
    else if (0==_xstrcmp (szClass, OLESTR("DIB")))
    {
	hresult = GetStandardPresentation (pos, pgenobj, CF_DIB);
    }
    else if (0==_xstrcmp (szClass, OLESTR("ENHMETAFILE")))
    {
	Assert (0 && "Encountered an unsupported format: ENHMETAFILE");
    }
    else
    {
	// This is a Generic Presentation stream

#if DBG==1
	Assert (!fStatic);
	if (_xstrcmp (pgenobj->m_fLink
		? pgenobj->m_classLast.m_szClsid
		: pgenobj->m_class.m_szClsid, szClass))
	{
	    Assert (0 && "Class name in embedded object stream does\n"
		 "not match class name in pres object stream");
	}
#endif
	hresult = GetGenericPresentation (pos, pgenobj);
    }

    if (szClass)
    {
	PubMemFree(szClass);
    }

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetBitmapAsDib, INTERNAL
//
//  Synopsis:   Reads a bitmap from the OLE1 stream, converts it to a DIB,
//              and stores it in the DATA member of CGenericObject
//
//  Arguments:  [pos]           -- The OLE 1 stream to read from
//              [pdata]         -- The DATA object to read into
//
//  Requires:
//
//  Returns:    NOERROR                             success
//              CONVERT10_E_OLESTREAM_GET           I/O error
//              CONVERT10_E_OLESTREAM_BITMAP_TO_DIB conversion error
//
//  History:    dd-mmm-yy Author    Comment
//              16-Feb-94 davepl    Cleaned up and documented
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL GetBitmapAsDib(LPOLESTREAM pos, PDATA pdata)
{
    HRESULT   hresult= NOERROR;
    HGLOBAL   hBits  = NULL;
    HGLOBAL   hDib   = NULL;
    LPVOID    pBits  = NULL;
    WIN16BITMAP bm;
    HBITMAP   hBitmap = NULL;
    ULONG     cbBits;
    ULONG     ul;


    Assert (pdata->m_h==NULL && pdata->m_pv==NULL && pdata->m_cbSize==0);

    // Get size of all bitmap data, including the bitmap header struct

    if (FAILED(hresult = OLE1StreamToUL(pos, &ul)))
    {
	return hresult;
    }

    // Read the bitmap header structure.  Since this was stored as Win16
	// BITMAP, we have to pull a structure of that size from the stream
	// (A Win32 BITMAP uses LONGs and hence is larger).

    if (pos->lpstbl->Get (pos, &bm, sizeof(WIN16BITMAP)) < sizeof(WIN16BITMAP))
    {
	return ResultFromScode (CONVERT10_E_OLESTREAM_GET);
    }

    // The bitmap data is total size - header size
    // Allocate enough memory to hold the bitmap data

    cbBits = ul - sizeof(WIN16BITMAP);
    hBits  = GlobalAlloc (GMEM_MOVEABLE, cbBits);
    if (NULL == hBits)
    {
	hresult = ResultFromScode(E_OUTOFMEMORY);
	goto errRtn;
    }

    pBits = (void FAR*) GlobalLock (hBits);
    if (pBits == NULL)
    {
	hresult = ResultFromScode(E_OUTOFMEMORY);
	goto errRtn;
    }

    // Read the header data into our allocated buffer
    if (pos->lpstbl->Get (pos, pBits, cbBits) < cbBits)
    {
	hresult = ResultFromScode (CONVERT10_E_OLESTREAM_GET);
	goto errRtn;
    }

    // Turn that raw data into a bitmap
    hBitmap = CreateBitmap (bm.bmWidth, bm.bmHeight, bm.bmPlanes,
		bm.bmBitsPixel, pBits);

    if (NULL == hBitmap)
    {
	hresult = ResultFromScode(CONVERT10_E_OLESTREAM_BITMAP_TO_DIB);
	goto errRtn;
    }

    // NOTE:    The following call gave only the first parameter in the
    // (davepl) original source; The second is the palette handle, which
    //          I've passed as NULL to indicate the default stock palette.

    hDib = UtConvertBitmapToDib (hBitmap, NULL);
    if (NULL == hDib)
    {
	hresult = ResultFromScode(CONVERT10_E_OLESTREAM_BITMAP_TO_DIB);
	goto errRtn;
    }

    // Set the presentation data pointers to point to this new DIB

    pdata->m_pv = GlobalLock (hDib);
    if (NULL == pdata->m_pv)
    {
	hresult = ResultFromScode(E_OUTOFMEMORY);
	goto errRtn;
    }

    pdata->m_cbSize = (ULONG) GlobalSize (hDib);
    pdata->m_h = hDib;

    // Free up allocations and resources, return result

errRtn:

    if (pBits)
    {
	Verify (0==GlobalUnlock (hBits));
    }
    if (hBits)
    {
	Verify (0==GlobalFree (hBits));
    }
    if (hBitmap)
    {
	Verify (DeleteObject (hBitmap));
    }
    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Function:   GetMfBits, INTERNAL
//
//  Synopsis:   Strips the METAFILE header from the stream and then reads
//              the metafile bits into an allocated memory area; the
//              presentation data member of [pos] is then set to point
//              to this memory.
//
//  Arguments:  [pos]       -- the OLE 1 stream to read from
//              [pdata]     -- the presentation data member of generic object
//
//  Returns:    NOERROR                         success
//              CONVERT10_E_OLESTREAM_GET       stream error
//              E_OUTOFMEMORY                   allocation failure
//
//  History:    dd-mmm-yy Author    Comment
//              16-Feb-94 davepl    Cleaned up and documented
//
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL GetMfBits(LPOLESTREAM pos, PDATA pdata)
{
    ULONG cbSize;
    WIN16METAFILEPICT mfpictDummy;
    HRESULT hresult = NOERROR;

    Assert (0==pdata->m_cbSize && pdata->m_h==NULL && NULL==pdata->m_pv);

    // Read the data size from the stream

    if (FAILED(hresult = (OLE1StreamToUL (pos, &cbSize))))
    {
	return hresult;
    }

    // Now read the actual data

    if (cbSize <= sizeof(WIN16METAFILEPICT))
    {
	return ResultFromScode(CONVERT10_E_OLESTREAM_FMT);
    }

    // An OLESTREAM contains a METAFILEPICT structure (with a meaningless
    // handle) followed by the metafile bits.  So consume the METAFILEPICT.

    if (pos->lpstbl->Get (pos, &mfpictDummy, sizeof(WIN16METAFILEPICT))
				    < sizeof(WIN16METAFILEPICT))
    {
	return ResultFromScode(CONVERT10_E_OLESTREAM_GET);
    }

    // Deduct from our count of bytes to read the size of the header which
    // we just consumed.  Set the presentation data size to be this new size.

    cbSize -= sizeof(WIN16METAFILEPICT);
    pdata->m_cbSize = cbSize;

    // Grad some memory to store the metafile bits

    pdata->m_h  = GlobalAlloc (GMEM_MOVEABLE, cbSize);
    if (NULL==pdata->m_h)
    {
	return ResultFromScode(E_OUTOFMEMORY);
    }

    pdata->m_pv = GlobalLock (pdata->m_h);
    if (NULL==pdata->m_pv)
    {
	return ResultFromScode(E_OUTOFMEMORY);
    }
    // Get the actual metafile bits

    if (pos->lpstbl->Get (pos, pdata->m_pv, cbSize) < cbSize)
    {
	return ResultFromScode(CONVERT10_E_OLESTREAM_GET);
    }

    return hresult;
}



//+-------------------------------------------------------------------------
//
//  Function:   GetStandardPresentation, INTERNAL
//
//  Synopsis:   Allocates a PRES member for generic object, then reads
//              whatever presentation may be found in the stream into
//              that PRES.
//
//  Arguments:  [pos]       -- the OLE 1 stream to read from
//              [pgenobj]   -- the generic object we are going to set
//                             up with the presentation data
//              [cf]        -- the clipboad format we are to read
//
//  Returns:    NOERROR                         success
//              E_OUTOFMEMORY                   allocation failure
//
//  Modifies:   [pgenobj] - sets up the m_ppres member
//
//  History:    dd-mmm-yy Author    Comment
//              16-Feb-94 davepl    Cleaned up and documented
//
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL GetStandardPresentation(
    LPOLESTREAM  pos,
    PGENOBJ      pgenobj,
    CLIPFORMAT   cf)
{
    HRESULT hresult = NOERROR;

    // Allocate enough memory for the PRES object
    pgenobj->m_ppres = new PRES;
    if (NULL == pgenobj->m_ppres)
    {
	return ResultFromScode(E_OUTOFMEMORY);
    }

    // Set up the format tag and clipboard format
    pgenobj->m_ppres->m_format.m_ftag = ftagClipFormat;
    pgenobj->m_ppres->m_format.m_cf   = cf;

    // Get the width of the data from the stream
    if (FAILED(hresult = OLE1StreamToUL(pos, &(pgenobj->m_ppres->m_ulWidth))))
    {
	return hresult;
    }
    // Get the height of the data from the stream
    if (FAILED(hresult=OLE1StreamToUL(pos, &(pgenobj->m_ppres->m_ulHeight))))
    {
	return hresult;
    }

    // The height saved by OLE 1.0 objects into the stream is always a
    // negative value (Y-increase in pixel is negative upward?) so we
    // have to correct that value.

    pgenobj->m_ppres->m_ulHeight
		    = (ULONG) -((LONG) pgenobj->m_ppres->m_ulHeight);

    // Read the appropriate presentation data based on the clipboard
    // format ID

    switch(cf)
    {
    case CF_METAFILEPICT:
    {
	hresult = GetMfBits (pos, &(pgenobj->m_ppres->m_data));
	break;
    }

    case CF_BITMAP:
    {
	// When reading a bitmap, we will convert from Bitmap to
	// DIB in the process, so update the PRES clipboard format ID

	pgenobj->m_ppres->m_format.m_cf = CF_DIB;
	hresult = GetBitmapAsDib (pos, &(pgenobj->m_ppres->m_data));
	break;
    }

    case CF_DIB:
    {
	Assert (CF_DIB==cf);
	hresult = GetSizedDataOLE1Stm (pos, &(pgenobj->m_ppres->m_data));
	break;
    }

    default:
    {
	Assert(0 && "Unexpected clipboard format reading PRES");
    }
    }

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Function:   GetGenericPresentation, INTERNAL
//
//  Synopsis:   Allocated the PRES member of the generic object and reads
//              the generic presentation data into it.
//
//  Effects:    If the format is a known clipboard format, we set the
//              format tag to indicate this, and set the format type
//              to indicate the clipboard format type.  If it is unknown,
//              we set the format tag to string and read the description
//              of the format.
//
//  Arguments:  [pos]           -- the OLE 1 stream we are reading from
//              [pgenobj]       -- the generic object we are reading to
//
//  Returns:    NOERROR         on success
//              E_OUTOFMEMORY   on allocation failure
//
//  History:    dd-mmm-yy Author    Comment
//              16-Feb-94 davepl    Code cleanup and document
//
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL GetGenericPresentation(
    LPOLESTREAM  pos,
    PGENOBJ      pgenobj)
{
    ULONG ulClipFormat;
    HRESULT hresult = NOERROR;

    // The PRES member should not exist at this point
    Assert (NULL==pgenobj->m_ppres);

    // Allocate the PRES member of the generic object

    pgenobj->m_ppres = new PRES;
    if (NULL == pgenobj->m_ppres)
    {
	return ResultFromScode(E_OUTOFMEMORY);
    }

    // Read the clipboard format ID

    if (FAILED(hresult = OLE1StreamToUL (pos, &ulClipFormat)))
    {
	delete (pgenobj->m_ppres);
	return hresult;
    }

    // If the clipboard format is not 0, we have a known clipboard
    // format and we should set the tag type and ID accordingly

    if (ulClipFormat)
    {
	pgenobj->m_ppres->m_format.m_ftag = ftagClipFormat;
	pgenobj->m_ppres->m_format.m_cf   = (CLIPFORMAT) ulClipFormat;
    }
    else
    {
	// Otherwise, we have a custom format so we need to set the
	// tag type to string and read in the data format string

	pgenobj->m_ppres->m_format.m_ftag = ftagString;
	if (FAILED(hresult = (GetSizedDataOLE1Stm
	    (pos, &(pgenobj->m_ppres->m_format.m_dataFormatString)))))
	{
	    delete (pgenobj->m_ppres);
	    return hresult;
	}
    }

    // We don't know the size, so reset to 0

    pgenobj->m_ppres->m_ulHeight = 0;
    pgenobj->m_ppres->m_ulWidth = 0;

    // Read the raw generic presentation data into the PRES member

    if (FAILED(hresult=GetSizedDataOLE1Stm(pos,&(pgenobj->m_ppres->m_data))))
    {
	delete (pgenobj->m_ppres);
	return hresult;
    }

    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Function:   GetSizedDataOLE1Stm, INTERNAL
//
//  Synopsis:   Reads bytes from an OLE 1 stream into a CData object.
//              Obtains the number of bytes to read from the first
//              ULONG in the stream
//
//  Arguments:  [pos]       -- the stream to read from
//              [pdata]     -- the CData object to read to
//
//  Requires:
//
//  Returns:    NOERROR                     on success
//              CONVERT10_E_OLESTREAM_GET   on stream read problem
//              E_OUTOFMEMORY               on allocation failure
//
//  History:    dd-mmm-yy Author    Comment
//              16-Feb-94 davepl    Cleaned up and documented
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL GetSizedDataOLE1Stm(LPOLESTREAM pos, PDATA pdata)
{
    ULONG cbSize;
    HRESULT hr;
    Assert (0==pdata->m_cbSize && pdata->m_h==NULL && NULL==pdata->m_pv);

    // Read size of data
    if (FAILED(hr = OLE1StreamToUL(pos, &cbSize)))
    {
	return hr;
    }

    if (cbSize==0)
    {
	return NOERROR;
    }

    // Allocate memory for data
    pdata->m_cbSize = cbSize;

    pdata->m_h  = GlobalAlloc (GMEM_MOVEABLE, cbSize);
    if (NULL==pdata->m_h)
    {
	return ResultFromScode(E_OUTOFMEMORY);
    }
    pdata->m_pv = GlobalLock (pdata->m_h);

    if (NULL==pdata->m_pv)
    {
	return ResultFromScode(E_OUTOFMEMORY);
    }

    // Read data into allocated buffer

    if (pos->lpstbl->Get (pos, pdata->m_pv, cbSize) < cbSize)
    {
	return ResultFromScode(CONVERT10_E_OLESTREAM_GET);
    }

    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Function:   OLE1StreamToUL, INTERNAL
//
//  Synopsis:   Reads a ULONG from an OLE1 stream
//
//  Arguments:  [pos]       -- the OLE 1 stream to read from
//              [pul]       -- the ULONG to read into
//
//  Returns:    NOERROR                     on success
//              CONVERT10_E_OLESTREAM_GET   on stream read failure
//
//  History:    dd-mmm-yy Author    Comment
//              16-Feb-94 davepl    Cleaned up and documented
//
//  Notes:      on failure [pul] is preserved
//
//--------------------------------------------------------------------------

static INTERNAL OLE1StreamToUL(LPOLESTREAM pos, ULONG FAR* pul)
{
    ULONG ul;

    // Read the data from the stream into the local ULONG

    if (pos->lpstbl->Get (pos, &ul, sizeof(ULONG)) < sizeof(ULONG))
    {
	return ResultFromScode(CONVERT10_E_OLESTREAM_GET);
    }

    // If all went well, store the data into [pul]

    if (pul != NULL)
    {
	Assert (IsValidPtrOut (pul, sizeof(ULONG)));
	*pul = ul;
    }
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function:   DataToOLE1Stm, INTERNAL INLINE
//
//  Synopsis:   Writes raw data out to an OLE 1 stream
//
//  Arguments:  [pos]       -- the stream to write to
//              [pvBuf]     -- the buffer to write from
//              [ulSize]    -- the number of bytes to write
//
//  Returns:    NOERROR                     on success
//              CONVERT10_E_OLESTREAM_PUT   on stream write failure
//
//  History:    dd-mmm-yy Author    Comment
//              16-Feb-94 davepl    Cleaned up and documented
//  Notes:
//
//--------------------------------------------------------------------------

inline static INTERNAL DataToOLE1Stm(LPOLESTREAM pos, LPVOID pvBuf, ULONG ulSize)
{
    // Write the data out to the stream

    if (pos->lpstbl->Put(pos, pvBuf, ulSize) < ulSize)
    {
	return ResultFromScode(CONVERT10_E_OLESTREAM_PUT);
    }
    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Function:   ULToOLE1Stream, INTERNAL INLINE
//
//  Synopsis:   Write a ULONG to the specified OLESTREAM via the Put()
//              member of the stream's VTBL
//
//  Effects:    Advances stream position by sizeof(ULONG) on success.
//
//  Arguments:  [pos]       -- The stream into which the ULONG is written
//              [ul]        -- The ULONG, passed by value
//
//  Requires:
//
//  Returns:    NOERROR on success
//              CONVERT10_E_OLESTREAM_PUT on failure
//
//  Signals:    (none)
//
//  Modifies:   Stream position
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-93 davepl    Cleaned up and documented
//
//  Notes:      On failure 0-3 bytes may have been written
//
//--------------------------------------------------------------------------

inline static INTERNAL ULToOLE1Stream(LPOLESTREAM pos, ULONG ul)
{
    if (pos->lpstbl->Put (pos, &ul, sizeof(ULONG)) < sizeof(ULONG))
    {
	return ResultFromScode(CONVERT10_E_OLESTREAM_PUT);
    }
    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Function:   StringToOLE1Stm, INTERNAL
//
//  Synopsis:   Converts the input OLESTR to ANSI and writes it to an
//              OLE 1 stream, preceded by a ULONG indicating the number
//              of bytes in the ANSI representation (terminator included).
//
//  Arguments:  [pos]       -- The stream into which the ULONG is written
//              [szOleStr]  -- The STR to be written
//
//  Returns:    NOERROR                     on success
//              CONVERT10_E_OLESTREAM_PUT   on stream write failure
//              E_NOMEMORY                  on allocation failure
//
//  Modifies:   Stream position
//
//  History:    dd-mmm-yy Author    Comment
//              11-Feb-94 davepl    Cleaned up and documented
//              15-Feb-94 davepl    Re-write for ANSI/WCHAR handling
//              17-Feb-94 davepl    Restructured error handling
//
//  Notes:      On failure, 0 to (cbSize-1) bytes may have been written
//
//--------------------------------------------------------------------------

static INTERNAL StringToOLE1Stm(LPOLESTREAM pos, LPCOLESTR pszOleStr)
{
    HRESULT hr    = NOERROR;
    LPSTR pszAnsi = NULL;           // Ansi version of OLE input string

    if (pszOleStr)
    {
    // This handy function will calculate the size of the buffer we
    // need to represent the OLESTR in ANSI format for us.

	ULONG cbSize = WideCharToMultiByte(CP_ACP, // Code Page ANSI
					0, // No flags
				pszOleStr, // Input OLESTR
				       -1, // Input len (auto detect)
				     NULL, // Output buffer
					0, // Output len (check only)
				 NULL, // Default char
				 NULL);// Flag: Default char used

	if (cbSize == FALSE)
	{
	    return ResultFromScode(E_UNSPEC);
	}

    // Now that we know the actual needed length, allocate a buffer

	pszAnsi = (LPSTR) PrivMemAlloc(cbSize);
    if (NULL == pszAnsi)
    {
	return ResultFromScode(E_OUTOFMEMORY);
    }

    // We've got out buffer and our length, so do the conversion now
	// We don't need to check for cbSize == FALSE since that was
	// already done during the length test, but we need to check
	// for substitution.  Iff this call sets the fDefChar even when
	// only doing a length check, these two tests could be merged,
	// but I don't believe this is the case.

	BOOL fDefUsed = 0;
	cbSize = WideCharToMultiByte(CP_ACP,  // Code Page ANSI
					  0,  // No flags
				  pszOleStr,  // Input OLESTR
					 -1,  // Input len (auto detect)
				    pszAnsi,  // Output buffer
				     cbSize,  // Output len
				       NULL,  // Default char (use system's)
				  &fDefUsed); // Flag: Default char used

    // If number of bytes converted was 0, we failed

    if (fDefUsed)
    {
	hr = ResultFromScode(E_UNSPEC);
    }

    // Write the size of the string (including null terminator) to stream

    else if (FAILED(hr = ULToOLE1Stream(pos, cbSize)))
    {
	NULL;
    }

    // Write the Ansi version of the string into the stream

    else if (pos->lpstbl->Put(pos, pszAnsi, cbSize) < cbSize)
    {
	hr = ResultFromScode(CONVERT10_E_OLESTREAM_PUT);
    }

	if (pszAnsi)
	{
	    PrivMemFree(pszAnsi);
	}
    }

    // If the pointer is not valid, we write a length of zero into
    // the stream

    else
    {
	hr = ULToOLE1Stream(pos, 0);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   OLE2StmToUL, INTERNAL
//
//  Synopsis:   Reads a ULONG from the specified ISTREAM and stores it at
//              the ULONG deferenced by pul
//
//  Effects:    Writes the value read into memory at pul
//
//  Arguments:  [pstm]      -- The stream from which the ULONG is read
//              [pul]       -- ULONG to hold the value read
//
//  Requires:
//
//  Returns:    NOERROR on success
//              CONVERT10_E_OLESTREAM_PUT on failure
//
//  Signals:    (none)
//
//  Modifies:   Stream position
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Feb-93 davepl    Cleaned up and documented
//
//  Notes:      On failure, *pul is not disturbed regardless of how
//              many bytes were actually read from the stream
//
//--------------------------------------------------------------------------

static INTERNAL OLE2StmToUL(LPSTREAM pstm, ULONG FAR* pul)
{
    ULONG ul;
    ULONG cbRead;
    HRESULT hr = NOERROR;

    // Attempt to read 4 bytes from the stream to form a ULONG.

    if (FAILED(hr = pstm->Read (&ul, sizeof(ULONG), &cbRead)))
    {
	return hr;
    }

    if (cbRead != sizeof(ULONG))
    {
	hr = STG_E_READFAULT;
    }
    // Ensure that the [pul] pointer is valid and that we have write
    // access to all 4 bytes (assertion only).  If OK, transfer the
    // ULONG to [*pul]
    else if (pul != NULL)
    {
	Assert (FALSE == !IsValidPtrOut(pul, sizeof(ULONG)));
	*pul = ul;
    }
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   OLE1StmToString, INTERNAL
//
//  Synopsis:   Reads a cstr from the specified STREAM and stores it in
//              a dynamically allocated buffer as an OLESTR; sets the
//              user's pointer to point to this new buffer.
//
//  Effects:    Allocates memory on the input pointer, advances stream pos'n
//
//  Arguments:  [pos ]      -- The stream from which the STR is read
//              [ppsz]      -- OLESTR ** which allows this fn to modify the
//                             caller's pointer to point to memory allocated
//                             by this fn to hold the OLESTR
//
//  Requires:   Stream must be set up.  Caller's responsibilty to free memory.
//
//  Returns:    NOERROR on success
//              CONVERT10_E_OLESTREAM_GET on failure
//              E_OUTOFMEMORY if buffers couldn't be allocated
//
//  Signals:    (none)
//
//  Modifies:   Stream position, caller's string pointer
//
//  Algorithm:  if ppsz == NULL, string is read from stream and discarded
//              if ppsz != NULL, string is read and converted into a
//                               dynamically allocated buffer.  *ppsz is set
//                               to point to this buffer, which must be later
//                               freed by the caller
//
//  History:    dd-mmm-yy Author    Comment
//              12-Jan-93 davepl    Cleaned up and documented
//              14-Jan-93 davepl    Changed to return LPOLESTR
//
//  Notes:      [ppsz] may be NULL on entry; string is read and discarded
//              with no cleanup required by the caller
//
//
//--------------------------------------------------------------------------

static INTERNAL OLE1StmToString(LPOLESTREAM pos, LPOLESTR FAR* ppsz)
{
    ULONG    cbSize;                // Size in bytes of cstr
    LPOLESTR pszOleStr  = NULL;
    LPSTR    pszAnsiStr = NULL;
    HRESULT  error      = NOERROR;

    // if ppsz is valid, NULL out *ppsz as default out parameter

    if (NULL != ppsz)
    {
	*ppsz = NULL;
    }

    // Retrieve the incoming string size from the stream

    if (FAILED(error = OLE1StreamToUL (pos, &cbSize)))
    {
	goto errRtn;
    }

    // If there are chars to be read, allocate memory for the
    // ANSI and OLESTR versions.  Read the string into the
    // ANSI version and convert it to OLESTR

    if (0 < cbSize)
    {
	// Allocate the ANSI buffer
	pszAnsiStr = (LPSTR) PrivMemAlloc((size_t)cbSize);
	if (NULL == pszAnsiStr)
	{
	    error = ResultFromScode(E_OUTOFMEMORY);
	    goto errRtn;
	}

	// Read the string into the ANSI buffer
	if (pos->lpstbl->Get (pos, pszAnsiStr, cbSize) < cbSize)
	{
	    error = ResultFromScode(CONVERT10_E_OLESTREAM_GET);
	    goto errRtn;
	}

	// We only need to perform the ANSI->OLESTR conversion in those
	// cases where the caller needs an out parameter

	if (NULL != ppsz)
	{
	    // Allocate the OLESTR buffer
	    pszOleStr = (LPOLESTR) PubMemAlloc((size_t)cbSize * 2);
	    if (NULL == pszOleStr)
	    {
		error = ResultFromScode(E_OUTOFMEMORY);
		goto errRtn;
	    }

	    // Convert from ANSI buffer to OLESTR buffer
	    if (FALSE==MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pszAnsiStr,
		     cbSize, pszOleStr, cbSize *2))
	    {
		error = HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION);
		PubMemFree(pszOleStr);
		goto errRtn;
	    }
	    *ppsz = pszOleStr;
	}
    }

errRtn:

    if (pszAnsiStr)
    {
	PrivMemFree(pszAnsiStr);
    }

    return error;

}

//+-------------------------------------------------------------------------
//
//  Function:   GenericObjectToIStorage
//
//  Synopsis:   Write the generic object in memory out to an OLE 2 IStorage
//              This invovles writing the class, native data, and
//              presentation data out where applicable.
//
//  Arguments:  [genobj]        -- the generic object holding the info
//              [pstg]          -- the IStorage object to write to
//              [ptd]           -- target device
//
//  Returns:    NOERROR                     on success
//              CONVERT10_S_NO_PRESENTATION in cases where the object did
//                                          not have needed presentation data
//
//  History:    dd-mmm-yy Author    Comment
//              17-Feb-94 davepl    Cleanup and document
//
//  Notes:
//
//--------------------------------------------------------------------------

FARINTERNAL GenericObjectToIStorage(
    const GENOBJ FAR&           genobj,
    LPSTORAGE                   pstg,
    const DVTARGETDEVICE FAR*   ptd)
{
    HRESULT hr = NOERROR;

    // Assert (genobj.m_class.m_clsid != CLSID_NULL);

    // Write the class ID out to the storage
    if (FAILED(hr = WriteClassStg (pstg, genobj.m_class.m_clsid)))
    {
	LEDebugOut(( DEB_ERROR,
	    "Unable to WriteClassStg at line %d in %s\n",
	    __LINE__, __FILE__));

	return hr;
    }

    if (!genobj.m_fLink)
    {
	if (genobj.m_fStatic)
	{
	    // If we are a static embedded object, get the format name from
	    // the registration database and write it out to the IStorage

	    LPOLESTR pszUserType = NULL;

	    OleRegGetUserType(genobj.m_class.m_clsid, USERCLASSTYPE_FULL,
		&pszUserType);

	    WriteFmtUserTypeStg (pstg, genobj.m_ppres->m_format.m_cf,
				    pszUserType);

	    if (pszUserType)
	    {
		PubMemFree(pszUserType);
	    }
	}
	else if (wWriteFmtUserType (pstg, genobj.m_class.m_clsid) != NOERROR)
	{
	    // This happens when the class is not registered.
	    // Use ProgId as UserType.

	    WriteFmtUserTypeStg (pstg,
		(CLIPFORMAT) RegisterClipboardFormat (genobj.m_class.m_szClsid),
		genobj.m_class.m_szClsid);
	}
    }

    if (FAILED(hr = GenObjToOLE2Stm (pstg, genobj)))
    {
	LEDebugOut(( DEB_ERROR,
	    "Unable to write gen obj to stream at line %d in %s\n",
	    __LINE__, __FILE__));

	return hr;
    }

    // If it's not a link and not a static object, dump its native
    // data out to the storage

    if (!genobj.m_fLink && !genobj.m_fStatic)
    {
	if (FAILED(hr=Write20NativeStreams (pstg, genobj)))
	{
	    LEDebugOut(( DEB_ERROR,
		"Unable to write native stream at line %d in %s\n",
		__LINE__, __FILE__));

	    return hr;
	}
    }

    if (! genobj.m_fLink)
    {
	if (genobj.m_class.m_clsid == CLSID_PBrush)
	{
	    if (! genobj.m_ppres || (genobj.m_ppres->m_format.m_cf == CF_DIB))
	    {
		// If the object is not a link, and it is a PBrush object with
		// either a DIB presentation or no presentation at all, we
		// don't need to do anything.

		return NOERROR;
	    }
	}

	if (genobj.m_class.m_clsid == CLSID_MSDraw)
	{
	    if (! genobj.m_ppres ||
		(genobj.m_ppres->m_format.m_cf == CF_METAFILEPICT))
	    {
		// Similarly, if it is not a link, and it is an MSDraw object
		// with no presentation or a METAFILEPICT presentation, we
		// don't need to do anything.

		return NOERROR;
	    }
	}
    }

    // In all other cases, we have to dump the presenation data out to
    // the storage.

    if (FAILED(hr = PresToIStorage (pstg, genobj, ptd)))
    {
	LEDebugOut(( DEB_ERROR,
	    "Unable to write pres to IStorage at line %d in %s\n",
	    __LINE__, __FILE__));

	return hr;
    }

    // If we are a static object, copy the contents of the presentation
    // stream over to the contents stream.

    if (genobj.m_fStatic)
    {
	UINT uiStatus;
	return UtOlePresStmToContentsStm(pstg, OLE_PRESENTATION_STREAM,
		TRUE, &uiStatus);
    }

    // If we don't have a presentation (but weren't one of the special
    // cases handled above), we have a problem

    //
    // We don't care if genobj.m_pres is NULL if a blank presentation is
    // permited as the routine PresToIStorage will generate a blank pres.
    //
    if ((NULL == genobj.m_ppres) && genobj.m_fNoBlankPres)
    {
	LEDebugOut(( DEB_ERROR,
	    "We have no presentation at line %d in %s\n",
	    __LINE__, __FILE__));

	return ResultFromScode(CONVERT10_S_NO_PRESENTATION);
    }

    return NOERROR;

}


//+-------------------------------------------------------------------------
//
//  Function:   GenObjToOLE2Stm, INTERNAL
//
//  Synopsis:   Write the generic object out to the OLE 2 stream
//
//  Effects:    Write the whole object, including presentation data, etc.
//
//  Arguments:  [pstg]      -- the IStorage to write to
//              [genobj]    -- the generic object to write
//
//  Returns:    NOERROR on success
//              This is an upper level function, so there are numerous
//              error that could be propagated up through it
//
//  History:    dd-mmm-yy Author    Comment
//              14-Feb-94 davepl    Code cleanup and document
//
//  Notes:      The code is enclosed in a do{}while(FALSE) block so that
//              we can break out of it on any error and fall through to
//              the cleanup and error return code.
//
//--------------------------------------------------------------------------

static INTERNAL GenObjToOLE2Stm(LPSTORAGE pstg, const GENOBJ FAR&   genobj)
{
    HRESULT  hr = NOERROR;
    LPSTREAM pstm=NULL;

    do {            // The do{}while(FALSE) allows us to break out on error

	// Create a stream in the current IStorage
	if (FAILED(hr = OpenOrCreateStream (pstg, OLE_STREAM, &pstm)))
	{
	    LEDebugOut(( DEB_ERROR,
		"Can't create streamat line %d in %s\n",
		__LINE__, __FILE__));

	    break;
	}

	// Write the Ole version out to that new stream
	if (FAILED(hr = ULToOLE2Stm (pstm, gdwOleVersion)))
	{
	    break;
	}
	
	// Write the object flags (for links only, otherwise 0) to the stream
	if (FAILED(hr = ULToOLE2Stm
	    (pstm, genobj.m_fLink ? OBJFLAGS_LINK : 0L)))
	{
	    break;
	}

	// Write the update options out to the stream
	if (genobj.m_fLink || genobj.m_class.m_clsid == CLSID_StdOleLink)
	{
	    // If our object's link update options are UPDATE_ONCALL, we
	    // write out the corresponding OLE 2 flags, otherwise, we
	    // write out OLEUPDATE_ALWAYS

	    if (genobj.m_lnkupdopt==UPDATE_ONCALL)
	    {
		if (FAILED(hr = ULToOLE2Stm (pstm, OLEUPDATE_ONCALL)))
		{
		    break;
		}
	    }
	    else
	    {
		if (FAILED(hr = ULToOLE2Stm (pstm, OLEUPDATE_ALWAYS)))
		{
		    break;
		}
	    }

	}
	else
	{
	    // We are neither a link nor a StdOleLink, so we have no
	    // update options.. just write out a 0.
	    if (FAILED(hr = ULToOLE2Stm (pstm, 0L)))
	    {
		break;
	    }
	}

	// This is a reserved filed (was View Format), just write a 0
	if (FAILED(hr = ULToOLE2Stm (pstm, 0L)))
	{
	    break;
	}

	// We have no relative moniker, write out NULL
	if (FAILED(hr = WriteMonikerStm (pstm, (LPMONIKER)NULL)))
	{
	    LEDebugOut(( DEB_ERROR,
		"Unable to write moniker to stream at line %d in %s\n",
		__LINE__, __FILE__));

	    break;
	}

	// If we are a link, we have to write out all of that information...

	if (genobj.m_fLink || genobj.m_class.m_clsid == CLSID_StdOleLink)
	{
	    // relative source moniker
	    if (FAILED(hr = WriteMonikerStm (pstm, (LPMONIKER)NULL)))
	    {
		LEDebugOut(( DEB_ERROR,
		    "Unable to write moniker to stream at line %d in %s\n",
		    __LINE__, __FILE__));
	    break;
	    }

	    // absolute source moniker
	    if (FAILED(hr = MonikerToOLE2Stm (pstm, genobj.m_szTopic,
		   genobj.m_szItem, genobj.m_classLast.m_clsid)))
	    {
	    LEDebugOut(( DEB_ERROR,
		"Unable to write moniker to stream at line %d in %s\n",
		__LINE__, __FILE__));
	    break;
	    }

	    // write the classLast field to the stream

	    CLSID clsid;

	    // If we have the classLast already, use that clsid
	    if (genobj.m_classLast.m_szClsid)
	    {
		clsid = genobj.m_classLast.m_clsid;
	    }
	    else
	    {
		// Otherwise, if it's a StdOleLink, class id is NULL
		if (genobj.m_class.m_clsid == CLSID_StdOleLink)
		{
		    clsid = CLSID_NULL;
		}
		else
		{
		    // If we don't have last class and not a link, use the
		    // class id of the generic object
		    clsid = genobj.m_class.m_clsid;
		}
	    }

	    if (FAILED(hr = WriteM1ClassStm(pstm, clsid)))
	    {
		LEDebugOut(( DEB_ERROR,
		    "Unable to write M1 to stream at line %d in %s\n",
		    __LINE__, __FILE__));
		break;
	    }

	    // last display == NULL string
	    if (FAILED(hr = ULToOLE2Stm (pstm, 0L)))
	    {
		break;
	    }

	    // Last Change time
	    if (FAILED(hr = FTToOle2Stm (pstm)))
	    {
	        break;
	    }

	    // Last known up to date
	    if (FAILED(hr = FTToOle2Stm (pstm)))
	    {
	        break;
	    }

	    // rtUpdate
	    if (FAILED(hr = FTToOle2Stm (pstm)))
	    {
	        break;
	    }

	    // end marker
	    if (FAILED(hr = ULToOLE2Stm(pstm, (ULONG) -1L)))
	    {
		break;
	    }
	}

    } while (FALSE);    // This do{}while(FALSE) is a once-through "loop"
	    // that we can break out of on error and fall
	    // through to the return.

    if (pstm)
    {
	pstm->Release();
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   MonikerToOLE2Stm, INTERNAL
//
//  Synopsis:   Write the file and item moniker as a composite to the stream
//
//  Effects:    Builds a composite of the file and item monikers, and then
//              writes them out.  If there is no file, a NULL moniker is
//              written in its place
//
//  Arguments:  [pstm]          -- The OLE2 storage we are writing to
//              [pszFile]       -- The file associated with the object
//              [spzItem]       -- The item
//              [clsid]         -- The class ID of the object
//
//  Returns:    NOERROR on success
//
//  History:    dd-mmm-yy Author    Comment
//              18-Feb-94 davepl    Reworked, cleaned up and documented
//
//  Notes:
//
//--------------------------------------------------------------------------



#pragma SEG(MonikerToOLE2Stm)
static INTERNAL MonikerToOLE2Stm(
    LPSTREAM pstm,
    LPOLESTR szFile,
    LPOLESTR szItem,
    CLSID    clsid)             // CLSID of the link source file, szFile

{
    HRESULT   hr = NOERROR;
    LPMONIKER pmkFile = NULL;       // File moniker
    LPMONIKER pmkItem = NULL;       // Item moniker
    LPMONIKER pmkComp = NULL;       // Composite of file + item monikers


    // If we don't have a file, write a NULL moniker
    if (NULL == szFile)
    {
	if (FAILED(hr = WriteMonikerStm (pstm, NULL)))
	{
	    goto errRtn;
	}
    }
    else
    {
	// Otherwise, create a file moniker (OLE1 or OLE2 as appplicable)

	if (CoIsOle1Class (clsid))
	{
	    if (FAILED(hr = CreateOle1FileMoniker (szFile, clsid, &pmkFile)))
	    {
		LEDebugOut(( DEB_ERROR,
		    "Can't create OLE 1 moniker at line %d in %s\n",
		    __LINE__, __FILE__));
		goto errRtn;
	    }
	}
	else
	{
	    if (FAILED(hr = CreateFileMoniker (szFile, &pmkFile)))
	    {
	    LEDebugOut(( DEB_ERROR,
		"Can't create file moniker at line %d in %s\n",
		__LINE__, __FILE__));
	    goto errRtn;
	    }
	}

	// If we don't have an Item, write just the file moniker

	if (NULL==szItem)
	{
	    if (FAILED(hr = WriteMonikerStm (pstm, pmkFile)))
	    {
		LEDebugOut(( DEB_ERROR,
		    "Unable to write moniker to stream at line %d in %s\n",
		    __LINE__, __FILE__));
		goto errRtn;
	    }

	}

	// Otherwise, create a composite of the file + item monikers
	// and write it out

	else
	{
	    if (FAILED(hr=CreateItemMoniker(OLESTR("!"), szItem, &pmkItem)))
	    {
		LEDebugOut(( DEB_ERROR,
		    "Unable to create item moniker at line %d in %s\n",
		    __LINE__, __FILE__));
		goto errRtn;
	    }

	    if (FAILED(hr=CreateGenericComposite(pmkFile, pmkItem, &pmkComp)))
	    {
	    LEDebugOut(( DEB_ERROR,
		"Unable to create generic pres at line %d in %s\n",
		__LINE__, __FILE__));
	    goto errRtn;
	    }

	    if (FAILED(hr = WriteMonikerStm (pstm, pmkComp)))
	    {
		LEDebugOut(( DEB_ERROR,
		    "Unable to write moniker to stream at line %d in %s\n",
		    __LINE__, __FILE__));
	    goto errRtn;
	    }
	}
    }


  errRtn:
    if (pmkFile)
    {
	pmkFile->Release();
    }
    if (pmkItem)
    {
	pmkItem->Release();
    }
    if (pmkComp)
    {
	pmkComp->Release();
    }
    return hr;
}



//+-------------------------------------------------------------------------
//
//  Function:   IsStandardFormat, INTERNAL
//
//  Synopsis:   Returns TRUE if object is in clipboard format and is one
//              one of the three standard formats (METAFILE, DIB, BITMAP)
//
//  Arguments:  [format]    -- the format object which contains the
//                             format tag and clipboard format type
//
//  Returns:    TRUE if METAFILE, DIB, or BITMAP
//              FALSE if other format or not clipboard format at all
//
//  History:    dd-mmm-yy Author    Comment
//              16-Feb-94 davepl    documented and chaged from big
//                                  conditional to a switch()
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL_(BOOL) IsStandardFormat(const FORMAT FAR& format)
{
    // First we must ensure that the format tag indicates that this
    // object is in clipboard format at all...

    if (format.m_ftag == ftagClipFormat)
    {
	// If so, there is a limited set of clipboard formats which
	// we consider "standard".  If it is not among these,
	// we return FALSE.

	switch(format.m_cf)
	{
	    case CF_METAFILEPICT:
	    case CF_BITMAP:
	    case CF_DIB:

		return TRUE;


	    default:

		return FALSE;

	}
    }
    return FALSE;
}



//+-------------------------------------------------------------------------
//
//  Function:   PresToIStorage, INTERNAL
//
//  Synopsis:   Given an generic object and an IStorage, write genobj's
//              presentation data out to the storage
//
//  Effects:    Will call PresToNewOLE2Stm to create a stream in this
//              storage to hold the presentation data
//
//  Arguments:  [pstg]      -- the storage to save to
//              [genobj]    -- the generic object holding the presenation
//              [ptd]       -- the target device for the presentation
//
//  Returns:    NOERROR     on success
//              Various other errors may propagate back up from I/O funcs
//
//  History:    dd-mmm-yy Author    Comment
//              18-Feb-94 davepl    ARRGR! Cleanup and document
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL PresToIStorage(
    LPSTORAGE                  pstg,
    const GENOBJ FAR&          genobj,
    const DVTARGETDEVICE FAR*  ptd)
{
    HRESULT hr = NOERROR;

    if (genobj.m_fNoBlankPres)
    {
	return NOERROR;
    }

    PRES pres;

    if (NULL==genobj.m_ppres)
    {
	// If we're not a link, and we don't have a presentation, we will
	// create a blank presentation and write it out.  If we are a link,
	// we will do nothing, and just fall through to the return.

	if (!genobj.m_fLink)
	{
	    if (FAILED(hr = CreateBlankPres (&pres)))
	    {
		LEDebugOut(( DEB_ERROR,
		    "Unable to create blank pres at line %d in %s\n",
		    __LINE__, __FILE__));
		return hr;
	    }

	    if (FAILED(hr = PresToNewOLE2Stm
		(pstg, genobj.m_fLink, pres, ptd, OLE_PRESENTATION_STREAM)))
	    {
		LEDebugOut(( DEB_ERROR,
		    "Unable to write pres to new stream at line %d in %s\n",
		    __LINE__, __FILE__));
		return hr;
	    }
	}
    }
    else
    {
	// If the object did indeed have a presentation, we write it
	// out to a new stream

	if (IsStandardFormat (genobj.m_ppres->m_format))
	{
	    // If the presentation is a standard clipboard
	    // format, we can write it out with no other work

	    if (FAILED(hr = PresToNewOLE2Stm (       pstg,
					   genobj.m_fLink,
					*(genobj.m_ppres),
						      ptd,
				  OLE_PRESENTATION_STREAM)))
	    {
		LEDebugOut(( DEB_ERROR,
		    "Unable to write pres to new stream at line %d in %s\n",
		    __LINE__, __FILE__));

	    return hr;
	    }

	}
	else
	{
	    // If the presentation is not a standard format,
	    // it may be a PBrush object (handled below), or if
	    // not, we write it as a generic presentation stream

	    if (genobj.m_classLast.m_clsid != CLSID_PBrush)
	    {
		if(FAILED(hr = PresToNewOLE2Stm ( pstg,
					genobj.m_fLink,
				     *(genobj.m_ppres),
						   ptd,
			       OLE_PRESENTATION_STREAM)))
		{
		    LEDebugOut(( DEB_ERROR,
		     "Unable to write pres to new stream at line %d in %s\n",
		     __LINE__, __FILE__));

		    return hr;
		}
	    }
	    else // PBrush
	    {
		BOOL fPBrushNative = FALSE;

		// We know this is a PBrush object.  If the
		// format tag is a format string, check to see
		// if that string is "Native", in which case
		// we set the flag to indicate that this is
		// native pbrush data.

		if (genobj.m_ppres->m_format.m_ftag == ftagString)
		{
		    if (!strcmp( (LPCSTR) genobj.m_ppres->
			m_format.m_dataFormatString.m_pv,
			"Native"
			    )
		    )
		    {
			fPBrushNative = TRUE;
		    }
		}

		if (FAILED(hr = PresToNewOLE2Stm(      pstg,
					     genobj.m_fLink,
					  *(genobj.m_ppres),
							ptd,
				    OLE_PRESENTATION_STREAM,
					      fPBrushNative)))
		{
		    LEDebugOut(( DEB_ERROR,
		    "Unable to write pres to new stream at line %d in %s\n",
		    __LINE__, __FILE__));

		    return hr;
		}


	    }

	}
    }
    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Function:   PresToNewOLE2Stm, INTERNAL
//
//  Synopsis:   Creates a new stream within a storage and writes the
//              generic object's presentation data out to it.
//
//  Arguments:  [pstg]          -- the storage in which to create the stream
//              [fLink]         -- flag: is this object a link?
//              [pres]          -- the presentation data to be saved
//              [ptd]           -- the target render device
//              [szStream]      -- the name of the new stream
//              [fPBrushNative] -- flag: is this native PBrush pres data?
//
//  Returns:    NOERROR             on success
//              STG_E_WRITEFAULT    on stream write failure
//
//  History:    dd-mmm-yy Author    Comment
//              21-Feb-94 davepl    Code cleanup and documentation
//
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL PresToNewOLE2Stm(
    LPSTORAGE                   pstg,
    BOOL                        fLink,
    const PRES FAR&             pres,
    const DVTARGETDEVICE FAR*   ptd,
    LPOLESTR                    szStream,
    BOOL                        fPBrushNative
)
{
HRESULT  hr = NOERROR;
LPSTREAM pstm=NULL;
FORMATETC foretc;



    // Create the new stream to hold the presentation data
    if (FAILED(hr = OpenOrCreateStream (pstg, szStream, &pstm)))
    {
		goto errRtn;
    }

	// Fill in the FormatEtc structure
	if (fPBrushNative)
	{
		foretc.cfFormat = CF_DIB;
	}
	else
	{
		switch( pres.m_format.m_ftag)
		{
			case ftagClipFormat:
				foretc.cfFormat = pres.m_format.m_cf;
				break;
			case ftagString:
				// m_dataFormatString is an ASCII string.
				foretc.cfFormat = (CLIPFORMAT) SSRegisterClipboardFormatA( (LPCSTR) pres.m_format.m_dataFormatString.m_pv);
				Assert(0 != foretc.cfFormat);
				break;
			default:
				AssertSz(0,"Error in Format");
				hr = E_UNEXPECTED;
				goto errRtn;
				break;
		}
	}


	foretc.ptd = (DVTARGETDEVICE *) ptd;
	foretc.dwAspect = DVASPECT_CONTENT;
	foretc.lindex = -1;
	foretc.tymed = TYMED_NULL; // tymed field is ignored by utWriteOlePresStmHeader.

	if (FAILED(hr = UtWriteOlePresStmHeader(pstm,&foretc,(fLink) ? (ADVF_PRIMEFIRST) : (0L))))
	{
		goto errRtn;
	}

    if (fPBrushNative)
    {
		if (FAILED(hr = UtHDIBFileToOlePresStm(pres.m_data.m_h, pstm)))
		{
			LEDebugOut(( DEB_ERROR,
			"Unable to write DIB to stream at line %d in %s\n",
			 __LINE__, __FILE__));

			goto errRtn;
		}
    }
    else
    {
	// Compression
		if (FAILED(hr = ULToOLE2Stm (pstm, 0L)))
		{
			goto errRtn;
		}

		// Width / Height
		if (FAILED(hr = ULToOLE2Stm (pstm, pres.m_ulWidth)))
		{
			goto errRtn;
		}
		if (FAILED(hr = ULToOLE2Stm (pstm, pres.m_ulHeight)))
		{
			goto errRtn;
		}

		// Presentation data
		if (FAILED(hr = DataObjToOLE2Stm (pstm, pres.m_data)))
		{
			goto errRtn;
		}
    }

  errRtn:
    if (pstm)
    {
		pstm->Release();
    }
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   ULToOLE2Stm, INTERNAL
//
//  Synopsis:   Writes a ULONG out to an OLE2 stream
//
//  Arguments:  [pstm]      -- the stream to write to
//              [ul]        -- the ULONG to write to that stream
//
//  Returns:    NOERROR             on success
//              STG_E_WRITEFAULT    on write failure
//
//  History:    dd-mmm-yy Author    Comment
//              18-Feb-94 davepl    Cleaned up and documented
//
//--------------------------------------------------------------------------

inline static INTERNAL ULToOLE2Stm(LPSTREAM pstm, ULONG ul)
{
    // Write the ULONG out
    return pstm->Write (&ul, sizeof(ULONG), NULL);

}

//+-------------------------------------------------------------------------
//
//  Function:   FTToOLE2Stm, INTERNAL
//
//  Synopsis:   Writes a dummy filetime out to an OLE2 stream
//
//  Arguments:  [pstm]      -- the stream to write to
//
//  Returns:    NOERROR             on success
//              STG_E_WRITEFAULT    on write failure
//
//  History:    dd-mmm-yy Author    Comment
//              31-Mar-95 scottsk   Created
//
//--------------------------------------------------------------------------

inline static INTERNAL FTToOle2Stm(LPSTREAM pstm)
{
    FILETIME ft = { 0, 0 };

    return pstm->Write (&ft, sizeof(FILETIME), NULL);

}


//+-------------------------------------------------------------------------
//
//  Function:   DataObjToOLE2Stm
//
//  Synopsis:   Writes a fixed-size data buffer to an OLE2 stream preceded
//              by a ULONG indicating the number of bytes to follow.
//
//  Returns:    NOERROR             on success
//              STG_E_WRITEFAULT    on write failure
//
//  History:    dd-mmm-yy Author    Comment
//              18-Feb-94 davepl    Code cleanup
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL DataObjToOLE2Stm(LPSTREAM pstm, const DATA FAR& data)
{
    HRESULT hr;


    // Write a ULONG indicating the number of bytes to follow
    if (FAILED(hr = ULToOLE2Stm (pstm, data.m_cbSize)))
    {
	return hr;
    }

    // If there are any bytes to follow...
    if (data.m_cbSize)
    {
	if (FAILED(hr = pstm->Write (data.m_pv, data.m_cbSize, NULL)))
	{
	    return hr;
	}
    }
    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Function:   SizedDataToOLE1Stm
//
//  Synopsis:   Writes a fixed-size data buffer to an OLE1 stream preceded
//              by a ULONG indicating the number of bytes to follow.
//
//  Parameters: [pos]       -- The stream to write to
//              [data]      -- The data object to write out
//
//  Returns:    NOERROR             on success
//              STG_E_WRITEFAULT    on write failure
//
//  History:    dd-mmm-yy Author    Comment
//              18-Feb-94 davepl    Code cleanup
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL SizedDataToOLE1Stm(LPOLESTREAM  pos, const DATA FAR& data)
{
    HRESULT hr = NOERROR;

    // Ensure the memory we are going to write out is valid
    Assert (data.m_pv);

    // Write the ULONG representing the byte count of the sized data

    if (FAILED(hr = ULToOLE1Stream (pos, data.m_cbSize)))
    {
	Assert (0 && "Can't write UL to ole1 stream");
	return hr;
    }

    if (pos->lpstbl->Put (pos, data.m_pv, data.m_cbSize) < data.m_cbSize)
    {
	Assert (0 && "Cant write sized data to ole1 stream");
	return ResultFromScode(CONVERT10_E_OLESTREAM_PUT);
    }
    return NOERROR;
}



//+-------------------------------------------------------------------------
//
//  Function:   Write20NativeStreams, INTERNAL
//
//  Synopsis:   Writes the generic object's native data out to an OLE 2 stream
//
//  Effects:    Creates an ILockBytes on the handle to the native data, and
//              then attempts to create a storage on it.  If it can, it uses
//              the CopyTo interface to write that storage into our OLE 2
//              stream.  Otherwise, it manually creates a stream in the OLE 2
//              storage and dumps the native data into it.
//
//  Arguments:  [pstg]   -- the OLE 2 storage we are saving genobj to
//              [genobj] -- the generic object we are writing
//
//  Returns:    NOERROR                     on success
//              E_OUTOFMEMORY               on allocation failure
//              STG_E_WRITEFAULT            on storage write failure
//
//  History:    dd-mmm-yy Author    Comment
//              18-Feb-94 davepl    Removed 14 goto's (for better or worse)
//                                    See "Notes" for new control flow
//              24-Mar-94 alext     Fix OLE 1 native case (there was an
//                                  extra stream open)
//
//  Notes:      There are two possible major codepaths based on the creation
//              of the Stg on ILockBytes.  The outcome is handled by a
//              switch statement, and both the TRUE and FALSE cases are
//              loaded with break statements that will bail out to the
//              bottom of the function on any failure.  This gives us a
//              single entry and exit point, without all the gotos
//
//--------------------------------------------------------------------------

static INTERNAL Write20NativeStreams(LPSTORAGE pstg, const GENOBJ FAR& genobj)
{
    LPLOCKBYTES plkbyt     = NULL;
    LPSTORAGE   pstgNative = NULL;
    LPSTREAM    pstmNative = NULL;
    HRESULT     hr         = NOERROR;

    // Create an ILockBytes instance on our generic object's native data

    if (SUCCEEDED(hr = CreateILockBytesOnHGlobal
	    (genobj.m_dataNative.m_h, FALSE, &plkbyt)))
    {
	// If the ILockBytes appears to contain an IStorage, then this was
	// an OLE 2 object "hiding" within the OLE 1 stream as native data

	switch ((DWORD)(S_OK == StgIsStorageILockBytes (plkbyt)))
	{
	case (TRUE):

	    // Open the IStorage contained in the ILockBytes

	    if (FAILED(hr =          StgOpenStorageOnILockBytes (plkbyt,
							(LPSTORAGE)NULL,
		    STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT,
							      (SNB)NULL,
								      0,
							    &pstgNative)))
	    {
		LEDebugOut(( DEB_ERROR,
		 "Can't open storage on ILBytes at line %d in %s\n",
		 __LINE__, __FILE__));

		break;   // on failure fall through to error return
	    }

	    // Remove the stream from the native data

	    if (FAILED(hr = UtDoStreamOperation(pstgNative,
			      NULL,   // pstgDst
			 OPCODE_REMOVE,   // operation
			  STREAMTYPE_CACHE))) // stream
	    {
		LEDebugOut(( DEB_ERROR,
		"OPCODE REMOVE stream op failed at line %d in %s\n",
		__LINE__, __FILE__));

		break;   // on failure fall through to error return
	    }

	    // Copy the "hidden" IStorage to our destination storage

	    if (FAILED(hr = pstgNative->CopyTo (0, NULL,(SNB)NULL, pstg)))
	    {
		LEDebugOut(( DEB_ERROR,
		    "CopyTo member fn failed at line %d in %s\n",
		    __LINE__, __FILE__));

		break;   // on failure fall through to error return
	    }

	    break;       // end case TRUE


	case FALSE:

	    // This is the typical case, where the OLE 1 stream had just
	    // plain old native data, so write it to a stream inside our
	    // output IStorage and call it OLE10_NATIVE_STREAM

	    ULONG cb;
	    LPVOID pv = genobj.m_dataNative.m_pv;

	    if (NULL == pv)
	    {
		hr = ResultFromScode(E_OUTOFMEMORY);
		break;
	    }

	    // Create the new stream to hold the native data

	    if (FAILED(hr = OpenOrCreateStream
		(pstg, OLE10_NATIVE_STREAM, &pstmNative)))
	    {
		break;   // on failure fall through to error return
	    }

	    // Write the length of the native data to the stream

	    if (FAILED(hr = pstmNative->Write
		(&genobj.m_dataNative.m_cbSize, sizeof(ULONG), &cb)))
	    {
		break;   // on failure fall through to error return
	    }

	    // Now write the actual native data

	    if (FAILED(hr = pstmNative->Write
		(pv, genobj.m_dataNative.m_cbSize, &cb)))
	    {
		break;   // on failure fall through to error return
	    }

	    // Write out the item name

	    if (genobj.m_szItem)
	    {
		ULONG cchItem;
		LPSTR pszAnsiItem;
		int cbWritten;

		//  We need to convert m_szItem from Wide to Ansi

		//  The ANSI string is bounded by the byte length of the
		//  Unicode string (one Unicode character maximally translates
		//  to one double-byte char, so we just use that length
		cchItem = lstrlenW(genobj.m_szItem) + 1;

		pszAnsiItem = (LPSTR) PrivMemAlloc(cchItem * sizeof(OLECHAR));
		if (NULL == pszAnsiItem)
		{
		    hr = E_OUTOFMEMORY;
		    break;
		}

		// We've got out buffer and our length, so do the conversion now
		// We don't need to check for cbSize == FALSE since that was
		// already done during the length test, but we need to check
		// for substitution.  Iff this call sets the fDefChar even when
		// only doing a length check, these two tests could be merged,
		// but I don't believe this is the case.

		BOOL fDefUsed = 0;
		cbWritten = WideCharToMultiByte(CP_ACP,  // Code Page ANSI
						0,  // No flags
						genobj.m_szItem,  // Input OLESTR
						cchItem,  // Input len (auto detect)
						pszAnsiItem,  // Output buffer
						cchItem * sizeof(OLECHAR),  // Output len
						NULL,  // Default char (use system's)
						&fDefUsed); // Flag: Default char used

		// If number of bytes converted was 0, we failed

		if ((FALSE == cbWritten) || fDefUsed)
		{
		    hr = ResultFromScode(E_UNSPEC);
		}
		else
		{
		    // Write the size of the string (including null terminator) to stream
		    hr = StSave10ItemName(pstg, pszAnsiItem);
		}

		PrivMemFree(pszAnsiItem);

		if (FAILED(hr))
		{
		    break; // on failure  fall through to error return
		}
	    }
	    break;

	} // end switch
    } // end if

    // Free up any resources that may have been allocated in any of the
    // code paths above

    if (NULL != plkbyt)
    {
	plkbyt->Release();
    }

    if (NULL != pstgNative)
    {
	pstgNative->Release();
    }

    if (NULL != pstmNative)
    {
	pstmNative->Release();
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   wConvertIStorageToOLESTREAM, INTERNAL
//
//  Synopsis:   Worker function; brings object from the IStorage into
//              the internal generic object representation
//
//  Arguments:  [pstg]      -- the IStorage the object resides in
//              [polestream]-- the OLE 1 stream it will be going to
//              [pgenobj]   -- the generic object to hold the internal rep
//
//  Returns:    NOERROR                       on success
//              STG_E_FILENOTFOUND            bad IStorage
//              CONVERT10_E_STG_NO_STD_STREAM the IStorage was missing one
//                                            of the required standard streams
//
//  History:    dd-mmm-yy Author    Comment
//              21-Feb-94 davepl    Code cleanup and documentation
//
//  Notes:
//
//--------------------------------------------------------------------------


INTERNAL wConvertIStorageToOLESTREAM (
    LPSTORAGE       pstg,
    LPOLESTREAM     polestream,
    PGENOBJ         pgenobj
)
{
    SCODE scode = S_OK;

    VDATEIFACE (pstg);

    // Ensure that all of the pointers are valid

#if DBG==1
    if (!IsValidReadPtrIn (polestream, sizeof(OLESTREAM)) ||
	!IsValidReadPtrIn (polestream->lpstbl, sizeof(OLESTREAMVTBL)) ||
	!IsValidCodePtr ((FARPROC)polestream->lpstbl->Put))
    {
	LEDebugOut(( DEB_ERROR,
	    "Bad OLESTREAM at line %d in %s\n",
	    __LINE__, __FILE__));

	return ResultFromScode (E_INVALIDARG);
    }
#endif

    scode = GetScode (StorageToGenericObject (pstg, pgenobj));

    // If the storage was not there, modify the return code to
    // make it specific to the conversion process, otherwise just
    // return whatever error code came back.

    if (scode != S_OK)
    {
	if (scode == STG_E_FILENOTFOUND)
	{
	    return ResultFromScode(CONVERT10_E_STG_NO_STD_STREAM);
	}
	else
	{
	    return ResultFromScode(scode);
	}
    }

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleConvertIStorageToOLESTREAM, STDAPI
//
//  Synopsis:   Reads an object from an IStorage into a generic internal
//              representation, then writes it back out to an OLE 1 stream
//
//  Arguments:  [pstg]          -- the IStorage to read from
//              [polestream]    -- the OLESTREAM to write to
//
//  Returns:    NOERROR                       on success
//              CONVERT10_E_STG_NO_STD_STREAM when one of the needed streams
//                                            inside the IStorage was not
//                                            present
//              E_INVALIDARG                  bad input argument
//
//  History:    dd-mmm-yy Author    Comment
//              21-Feb-94 davepl    Cleanup and documentation
//
//  Notes:
//
//--------------------------------------------------------------------------

STDAPI OleConvertIStorageToOLESTREAM(LPSTORAGE pstg, LPOLESTREAM polestream)
{
    OLETRACEIN((API_OleConvertIStorageToOLESTREAM, 
    		PARAMFMT("pstg= %p, polestream= %p"), pstg, polestream));

    LEDebugOut((DEB_TRACE, "%p _IN OleConvertIStorageToOLESTREAM ("
		" %p , %p )\n", 0 /*function*/,
		pstg, polestream
		));
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IStorage,(IUnknown **)&pstg);

    HRESULT hr;
    CGenericObject genobj;

    // Read from the IStorage into the generic object
    hr = wConvertIStorageToOLESTREAM(pstg, polestream, &genobj);
    if (FAILED(hr))
    {
	goto errRtn;
    }

    // Write from the generic object out to the OLE 1 stream
    hr = GenericObjectToOLESTREAM (genobj, polestream);

errRtn:
    LEDebugOut((DEB_TRACE,"%p OUT OleConvertIStorageToOLESTREAM ( %lx ) "
    "\n", 0 /*function*/, hr));

    OLETRACEOUT((API_OleConvertIStorageToOLESTREAM, hr));

    return hr;

}

//+-------------------------------------------------------------------------
//
//  Function:   wFillPpres, INTERNAL
//
//  Synopsis:   Fills in the generic object's presentation data by
//              building a presentation out of the native data
//
//  Arguments:  [pstg]      -- the IStorage we are reading from
//              [pgenobj]   -- the generic object
//              [cfFormat]  -- what clipboard format is being used
//              [fOle10Native] -- flag: is this OLE 1 native data?
//
//  Returns:    NOERROR        on success
//              E_OUTOFMEMORY  can't allocate mem for PRES member
//
//  History:    dd-mmm-yy Author    Comment
//              21-Feb-94 davepl    Code cleanup, documentation
//              19-Jul-94 davepl    Fixed HMETAFILE cases
//
//  Notes:      Since most of this code treats HMETAFILE handles and
//              HGLOBALS indentically, we need to special case the
//              the HMETAFILE case by marking the pointer with a
//              special value
//
//--------------------------------------------------------------------------


static INTERNAL wFillPpres(
    LPSTORAGE   pstg,
    PGENOBJ     pgenobj,
    CLIPFORMAT  cfFormat,
    BOOL        fOle10Native)
{
    pgenobj->m_ppres = new PRES;

    if (pgenobj->m_ppres == NULL)
    {
	return ResultFromScode(E_OUTOFMEMORY);
    }

    // Set the format tag and clipboard format in the PRES member
    pgenobj->m_ppres->m_format.m_cf   = cfFormat;
    pgenobj->m_ppres->m_format.m_ftag = ftagClipFormat;

    // Build the presentation based on the object's native data
    HANDLE hpres = UtGetHPRESFromNative(pstg, NULL, pgenobj->m_ppres->m_format.m_cf,
	    fOle10Native);

    void * lppres = NULL;

    if (hpres == NULL)
    {
	return NOERROR;
    }

    // Lock the DIB or the METAFILEPICT structure

    lppres = GlobalLock(hpres);
    if (NULL == lppres)
    {
	goto errRtn;
    }

    if (cfFormat == CF_DIB)
    {
	// If it's a DIB, fill in the extents
	LPBITMAPINFOHEADER lpbmi = (LPBITMAPINFOHEADER) lppres;
	UtGetDibExtents(lpbmi, (LPLONG) &(pgenobj->m_ppres->m_ulWidth),
	    (LPLONG) &(pgenobj->m_ppres->m_ulHeight));

	GlobalUnlock(hpres);
	pgenobj->m_ppres->m_data.m_h = hpres;
	
	pgenobj->m_ppres->m_data.m_cbSize
		= (ULONG) GlobalSize(pgenobj->m_ppres->m_data.m_h);
	pgenobj->m_ppres->m_data.m_pv
		= GlobalLock(pgenobj->m_ppres->m_data.m_h);

	
    }
    else if (cfFormat == CF_METAFILEPICT)
    {
	LPMETAFILEPICT lpmfp = (LPMETAFILEPICT) lppres;

	// If it's a METAFILE, fill in the width, height
	pgenobj->m_ppres->m_ulWidth = (ULONG) lpmfp->xExt;
	pgenobj->m_ppres->m_ulHeight = (ULONG) lpmfp->yExt;
	pgenobj->m_ppres->m_data.m_h = lpmfp->hMF;
	GlobalFree(hpres);
	hpres = NULL;

	// We place a special known value in the pointer field
	// to indicate that the associated handle is a metafile
	// handle (as opposed to a global memory handle), which
	// signals us to special case its cleanup.

	pgenobj->m_ppres->m_data.m_pv = METADATAPTR;

	// We cannot merely GlobalSize() the HMETAFILE, so we
	// ask the GDI how many bytes we will need to store the
	// data.

	pgenobj->m_ppres->m_data.m_cbSize =
		GetMetaFileBitsEx((HMETAFILE) pgenobj->m_ppres->m_data.m_h, 0, NULL);
	
	if (0 == pgenobj->m_ppres->m_data.m_cbSize)
	{
		pgenobj->m_ppres->m_data.m_h = NULL;
		goto errRtn;
	}
    }
    else
    {
	goto errRtn;
    }

    return NOERROR;


errRtn:
    if (hpres)
    {
	Verify(GlobalUnlock(hpres));
	GlobalFree(hpres);
    }

    delete pgenobj->m_ppres;
    pgenobj->m_ppres = NULL;
    return ResultFromScode(E_OUTOFMEMORY);
}


//+-------------------------------------------------------------------------
//
//  Function:   StorageToGenericObject, INTERNAL
//
//  Synopsis:   Read an object from an IStorage into the generic object,
//              and set up the format type, native and pres data.
//
//  Arguments:  [pstg]      -- the IStorage we are reading from
//              [pgenobj]   -- the generic object we are reading into
//
//  Returns:    NOERROR on success
//              various possible errors from lower-level fns
//
//  History:    dd-mmm-yy Author    Comment
//              21-Feb-94 davepl    Code cleanup and documentation
//
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL StorageToGenericObject(LPSTORAGE pstg, PGENOBJ   pgenobj)
{
    CLSID clsid;
    CLIPFORMAT cf = NULL;
    BOOL fObjFmtKnown = FALSE;
    HRESULT hr;

    // Get the class ID from the IStorage
    if (FAILED(hr = ReadRealClassStg (pstg, &clsid)))
    {
	return hr;
    }

    // Set the class ID in our generic object
    if (CLSID_StaticMetafile == clsid || CLSID_StaticDib  == clsid)
    {
	if (CLSID_StaticMetafile == clsid)
	{
	    cf = CF_METAFILEPICT;
	}
	else
	{
	    cf = CF_DIB;
	}
	fObjFmtKnown = TRUE;

	pgenobj->m_class.Set(clsid, NULL);
	pgenobj->m_fStatic = TRUE;
    }
    else
    {
	if (FAILED(hr = pgenobj->m_class.Set (clsid, pstg)))
	{
	    return hr;
	}
    }

    // Get the OLE version, flags, update opts, and moniker

    SCODE sc = GetScode (Read20OleStream (pstg, pgenobj));

    // It is okay for the Ole Stream to be missing.
    if (sc != S_OK)
    {
	if (sc != STG_E_FILENOTFOUND)
	{
	    return ResultFromScode (sc);
	}
    }

    // Read the native data into the generic object
    if (FAILED(hr = Read20NativeStreams (pstg, &(pgenobj->m_dataNative))))
    {
	return hr;
    }

    // Try to ascertain the clipboard format
    if (cf == 0)
    {
	if (clsid == CLSID_PBrush)
	{
	    cf = CF_DIB;
	}
	else if (clsid == CLSID_MSDraw)
	{
	    cf = CF_METAFILEPICT;
	}
	else
	{
	    ReadFmtUserTypeStg (pstg, &cf, NULL);
	}

	fObjFmtKnown = (cf == CF_METAFILEPICT || cf == CF_DIB);
    }

    // Read the presentation data if possible
    if (FAILED(hr = Read20PresStream (pstg, pgenobj, fObjFmtKnown)))
    {
	return hr;
    }

    // If we don't have a presentation, it might be a PBrush object,
    // which is OK because OLE 1 DLLs know how to draw them based on
    // the native data.  Otherwise, we will try and create a presentation
    // based on the native data.

    if (pgenobj->m_ppres == NULL)
    {
	if (clsid == CLSID_PBrush)
	{
	    return NOERROR;
	}
	if (cf == CF_METAFILEPICT || cf == CF_DIB)
	{
	    if (FAILED(hr=wFillPpres(pstg,pgenobj,cf,clsid == CLSID_MSDraw)))
	    {
	    return hr;
	    }
	}
    }

    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Function:   GenericObjectToOLESTREAM, INTERNAL
//
//  Synopsis:   Writes the interal object representation out to an OLE1
//                              stream.
//
//  Arguments:  [genobj]                -- the object to write out
//                              [pos]                   -- the OLE 1 stream to write to
//
//  Returns:    NOERROR                 on success
//
//  History:    dd-mmm-yy Author    Comment
//                              22-Feb-94 davepl        32-bit port
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL GenericObjectToOLESTREAM(
    const GENOBJ FAR&   genobj,
    LPOLESTREAM         pos)
{
    HRESULT hr;

    if (genobj.m_fStatic)
    {
	return PutPresentationObject (pos, genobj.m_ppres, genobj.m_class,
		      TRUE /* fStatic*/ );
    }

    // OLE version
    if (FAILED(hr = ULToOLE1Stream (pos, dwVerToFile)))
    {
	return hr;
    }

    // Format ID for embedded or linked object
    if (FAILED(hr = ULToOLE1Stream
	    (pos, genobj.m_fLink ? FMTID_LINK : FMTID_EMBED)))
    {
	return hr;
    }

    // We must have the class id string by this point
    Assert (genobj.m_class.m_szClsid);

    // Write out the class ID string
    if (FAILED(hr = StringToOLE1Stm (pos, genobj.m_class.m_szClsid)))
    {
	return hr;
    }

    // Write out the topic string
    if (FAILED(hr = StringToOLE1Stm (pos, genobj.m_szTopic)))
    {
	return hr;
    }

    // Write out the item string
    if (FAILED(hr = StringToOLE1Stm (pos, genobj.m_szItem)))
    {
	return hr;
    }

    // Write out the update options, network info for a link,
    // or the native data for an embedded object
    if (genobj.m_fLink)
    {
	// Network information
	if (FAILED(hr = PutNetworkInfo (pos, genobj.m_szTopic)))
	{
	    return hr;
	}
	// Link update options
	if (FAILED(hr = ULToOLE1Stream (pos, genobj.m_lnkupdopt)))
	{
	    return hr;
	}
    }
    else
    {
	if (FAILED(hr = SizedDataToOLE1Stm (pos, genobj.m_dataNative)))
	{
	    return hr;
	}
    }

    // Write out the presentation data
    return PutPresentationObject (pos, genobj.m_ppres, genobj.m_class);
}



//+-------------------------------------------------------------------------
//
//  Function:   PutNetworkInfo, INTERNAL
//
//  Synopsis:   If needed, converts a DOS-style path to a proper network
//              path.  In any case, writes network path to OLE 1 stream
//
//  Arguments:  [pos]       -- the OLE 1 stream we are writing to
//              [szTopic]   -- the topic string for this object
//
//  Returns:    NOERROR on success
//              Various possible I/O errors on write
//
//  History:    dd-mmm-yy Author    Comment
//              21-Feb-94 davepl    Code cleanup and documentation
//
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL PutNetworkInfo(LPOLESTREAM pos, LPOLESTR szTopic)
{
    LPOLESTR szNetName = NULL;
    HRESULT hr = NOERROR;

    // If we have an X:\ style path, we want to convert that
    // to a proper network name

    if (szTopic && IsCharAlphaW(szTopic[0]) && szTopic[1]==':')
    {
	OLECHAR szBuf[80];
	DWORD u;
	OLECHAR szDrive[3];

	szDrive[0] = (OLECHAR)CharUpperW((LPWSTR)szTopic[0]);
	szDrive[1] = ':' ;
	szDrive[2] = '\0';

	if (GetDriveType (szDrive) == DRIVE_REMOTE
	    && WNetGetConnection (szDrive, szBuf, &u) == WN_SUCCESS)
	{
	    szNetName =szBuf;
	}
    }

    // We now have the network name, so write it out to OLE 1 stream
    if (FAILED(hr = StringToOLE1Stm (pos, szNetName)))
    {
	return hr;
    }

    // Network type, driver version number, but we have to pad for
    // the space anyway

    if (FAILED(hr = ULToOLE1Stream (pos, 0L)))
    {
	return hr;
    }

    Assert (hr == NOERROR);
    return hr;
}



//+-------------------------------------------------------------------------
//
//  Function:   OpenStream, INTERNAL
//
//  Synopsis:   Opens a stream in SHARE_EXCLUSIVE, READ mode
//
//  Arguments:  [pstg]          -- the storage the stream resides in
//              [szName]        -- the name of the stream
//              [ppstm]         -- out parameter for stream
//
//  History:    dd-mmm-yy Author    Comment
//              21-Feb-94 davepl    Code cleanup and document
//
//  Notes:
//
//--------------------------------------------------------------------------

static inline INTERNAL OpenStream(
    LPSTORAGE      pstg,
    LPOLESTR       szName,
    LPSTREAM FAR*  ppstm)
{
    return pstg->OpenStream
	(szName, NULL, STGM_SHARE_EXCLUSIVE| STGM_READ, 0, ppstm);
}


//+-------------------------------------------------------------------------
//
//  Function:   ReadRealClassStg, INTERNAL
//
//  Synopsis:   Reads the _real_ class of the object.  ie: if the class is
//                              StdOleLink, we need to find out the class of the object
//                              to which this is linked
//
//  Arguments:  pstg                    -- the storage to read from
//                              pclsid                  -- caller's CLSID holder
//
//  Returns:    NOERROR                 on success
//
//  History:    dd-mmm-yy Author    Comment
//                              04-Mar-04 davepl        32-bit port
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL ReadRealClassStg(LPSTORAGE pstg, LPCLSID pclsid)
{
    LPSTREAM pstm   = NULL;
    HRESULT  hr = NOERROR;

    // Get the class ID from the IStorage
    if (FAILED(hr = ReadClassStg (pstg, pclsid)))
    {
	return hr;
    }

    // If it's a link, we have to figure out what class its a link _to_
    if (CLSID_StdOleLink == *pclsid)
    {
	LPMONIKER pmk = NULL;

	if (FAILED(hr = ReadOleStg (pstg, NULL, NULL, NULL, NULL, &pstm)))
	{
	    return hr;
	}

	if (FAILED(hr = ReadMonikerStm (pstm, &pmk)))
	{
	    goto errRtn;
	}

	if (pmk)
	{
	    pmk->Release();
	}

	if (FAILED(hr = ReadMonikerStm (pstm, &pmk)))
	{
	    goto errRtn;
	}

	if (pmk)
	{
	    pmk->Release();
	}

	// Read "last class"
	if (FAILED(hr = ReadM1ClassStm (pstm, pclsid)))
	{
	    goto errRtn;
	}
    }

  errRtn:

    if (pstm)
    {
	pstm->Release();
    }
    return hr;
}



//+-------------------------------------------------------------------------
//
//  Function:   Read20OleStream, INTERNAL
//
//  Synopsis:   Reads the update options and absolute source class from
//              an OLE 2 object
//
//  Arguments:  pstg                    -- the IStorage to read from
//                              pgenobj                 -- the genobj we are reading into
//
//  Returns:    NOERROR                 on success
//
//  History:    dd-mmm-yy Author    Comment
//                              06-Mar-94 davepl        32-bit port
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL Read20OleStream(LPSTORAGE  pstg, PGENOBJ pgenobj)
{
    LPMONIKER pmk     = NULL;
    HRESULT   hr      = NOERROR;
    LPSTREAM  pstm    = NULL;
    ULONG     ul      = (ULONG) -1L;
    CLSID     clsidLast;

    if (SUCCEEDED(hr = OpenStream (pstg, OLE_STREAM, &pstm)))
    {
	// OLE version
	if (SUCCEEDED(hr = OLE2StmToUL (pstm, NULL)))
	{
	    // Object flags
	    if (SUCCEEDED(hr = OLE2StmToUL (pstm, &ul)))
	    {
		if (ul & OBJFLAGS_LINK)
		{
		    pgenobj->m_fLink = TRUE;
		}

		// Update options
		hr = OLE2StmToUL (pstm, &ul);
	    }
	}
    }

    // If no errors so far...

    // If this is a link, get the update options

    if (SUCCEEDED(hr) && pgenobj->m_fLink)
    {
	switch (ul)
	{
	    case OLEUPDATE_ALWAYS:
		pgenobj->m_lnkupdopt = UPDATE_ALWAYS;
		break;

	    case OLEUPDATE_ONCALL:
		pgenobj->m_lnkupdopt = UPDATE_ONCALL;
		break;

	    default:
		AssertSz (0, "Warning: Invalid update options in Storage");
		hr = ResultFromScode(CONVERT10_E_STG_FMT);
	}
    }

    if (SUCCEEDED(hr))               // Only continue if no failures so far
    {
	// Reserved (was view format)
	if (SUCCEEDED(hr = OLE2StmToUL (pstm, NULL)))
	{
	    if (pgenobj->m_fLink)
	    {

		// All 4 of these calls must succeed or we simply fall
		// through to the cleanup code

		    // ignore relative moniker
		if (SUCCEEDED(hr = OLE2StmToMoniker (pstm, NULL))          &&
		    // ignore relative source moniker
		    SUCCEEDED(hr = OLE2StmToMoniker (pstm, NULL))          &&
		    // get absolute source moniker
		    SUCCEEDED(hr = OLE2StmToMoniker (pstm, &pmk))          &&
		    // get class from abs moniker
		    SUCCEEDED(hr = ReadM1ClassStm (pstm, &clsidLast))   )
		{
		    hr = MonikerIntoGenObj (pgenobj, clsidLast, pmk);
		}
	    }
	}
    }

    // Clean up any resources and return status to caller

    if (pstm)
    {
	pstm->Release();
    }
    if (pmk)
    {
	pmk->Release();
    }
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   OLE2StmToMoniker, INTERNAL
//
//  Synopsis:   Calls ReadMonikerStm to get a moniker from a stream,
//              and if the ppmk parameter was NULL, it does a Release()
//              on the moniker object immediately, otherwise sets the
//              caller's pointer to point to the moniker that was read.
//
//  Arguments:  [pstm]      -- the stream to read the moniker from
//              [ppmk]      -- points to caller's moniker ptr
//
//  History:    dd-mmm-yy Author    Comment
//              21-Feb-94 davepl    Code cleanup and documentation
//
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL OLE2StmToMoniker(LPSTREAM pstm, LPMONIKER FAR* ppmk)
{
    LPMONIKER pmk = NULL;
    HRESULT   hr  = NOERROR;

    if (FAILED(hr = ReadMonikerStm (pstm, &pmk)))
    {
	return hr;
    }

    if (ppmk)               // If the callers wanted a result, return the
    {                       // moniker as an out parameter
	*ppmk = pmk;
    }
    else                    // Otherwise, release it immediately and
    {                       // return to caller
	if (pmk)
	{
	    pmk->Release();
	}
    }

    return NOERROR;
}



//+-------------------------------------------------------------------------
//
//  Function:   ReadFormat, INTERNAL
//
//  Synopsis:   Reads the format ID type from the stream, and based on that,
//              reads the format ID from the stream.
//
//  Arguments:  [pstm]      -- the stream to read from
//              [pformat]   -- caller's format member object
//
//  History:    dd-mmm-yy Author    Comment
//              21-Feb-94 davepl    Code cleanup and documentation
//
//  Notes:      The first ULONG indicates the type (standard clipboard,
//              Mac, NULL, or string) of the identifier
//
//--------------------------------------------------------------------------

static INTERNAL ReadFormat(LPSTREAM pstm, PFORMAT pformat)
{
    ULONG ul;
    HRESULT hr = NOERROR;

    // Get the format ID type indicator

    if (FAILED(hr = OLE2StmToUL (pstm, &ul)))
    {
	return hr;
    }

    // The first ULONG indicates what kind of format ID will
    // found in the stream:
    //
    // -1   =>    A standard clipboard format ID
    // -2   =>    A Macintosh format
    //  0   =>    NULL format
    // >0   =>    The number of bytes of the text string
    //            identifier to follow

    switch ((signed long)ul)
    {
    case -1L:   // Standard clipboard format

	ULONG ulClipFormat;
	pformat->m_ftag = ftagClipFormat;
	if (FAILED(hr = OLE2StmToUL (pstm, &ulClipFormat)))
	{
	return hr;
	}
	pformat->m_cf = (CLIPFORMAT) ulClipFormat;
	break;


    case -2L:   // Macintosh format

	return ResultFromScode(CONVERT10_E_STG_FMT);


    case 0:     // NULL format

	pformat->m_ftag = ftagNone;
	pformat->m_cf   = 0;
	return NOERROR;


    default:    // ul == size of string (format name)


	pformat->m_ftag = ftagString;
	if (FAILED(hr = OLE2StmToSizedData
	    (pstm, &(pformat->m_dataFormatString), 0, ul)))
	{
	    return hr;
	}
	break;

    }
    return NOERROR;
}


#ifdef _OBSOLETE

//+-------------------------------------------------------------------------
//
//  Function:   WriteFormat, INTERNAL
//
//  Synopsis:   Depending on what kind of format (standard cf, string, etc)
//              the format object holds, this fn writes out the appropriate
//              information to the stream
//
//  Arguments:  [pstm]      -- the stream to write to
//              [format]    -- the format object to get info from
//
//  Returns:    NOERROR             on success
//              E_UNEXPECTED        for a NULL format tag
//
//  History:    dd-mmm-yy Author    Comment
//              21-Feb-94 davepl    Code cleanup and documentation
//  Notes:
//--------------------------------------------------------------------------

static INTERNAL WriteFormat(LPSTREAM pstm, const FORMAT FAR& format)
{
    HRESULT hr;

    switch (format.m_ftag)
    {
    case ftagNone:
	Assert (0 && "Cant write a NULL format tag");
	return ResultFromScode (E_UNEXPECTED);

    case ftagClipFormat:
	if (FAILED(hr = ULToOLE2Stm (pstm, (ULONG) -1L)))
	{
	    return hr;
	}
	if (FAILED(hr = ULToOLE2Stm (pstm, format.m_cf)))
	{
	    return hr;
	}
	break;

    case ftagString:
	if (FAILED(hr=DataObjToOLE2Stm(pstm,format.m_dataFormatString)))
	{
	    return hr;
	}
	break;

    default:
	AssertSz (0, "invalid m_ftag value");
	return ResultFromScode (E_UNEXPECTED);
    }
    return NOERROR;
}

#endif // _OBSOLETE


//+-------------------------------------------------------------------------
//
//  Function:   ReadDibAsBitmap, INTERNAL
//
//  Synopsis:   Reads a DIB from an OLE 2 stream and stores it as a
//              Bitmap in a DATA structure
//
//  Arguments:  [pstm]          -- the OLE 2 stream to read from
//              [pdata]         -- the data object to hold the bitmap
//
//  Returns:    NOERROR                         on success
//              CONVERT10_E_STG_DIB_TO_BITMAP   conversion failure
//              E_OUTOFMEMORY                   allocation failure
//
//  History:    dd-mmm-yy Author    Comment
//              21-Feb-94 davepl    Code cleanup and documentation
//
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL ReadDibAsBitmap(LPSTREAM pstm, PDATA pdata)
{
    DATA    dataDib;
    ULONG   cb;
    ULONG   cbBits;
    ULONG   cbBitsFake;
    BITMAP  bm;

    HBITMAP hBitmap = NULL;
    HRESULT hr      = NOERROR;
    HGLOBAL hBits   = NULL;
    LPBYTE  pBits   = NULL;

    Assert (pdata&&pdata->m_cbSize==0&&pdata->m_h==NULL&&pdata->m_pv==NULL);

    // Read the DIB into our local DATA object
    if (FAILED(hr = OLE2StmToSizedData (pstm, &dataDib)))
    {
	return hr;
    }

    // Convert the DIB to a Bitmap
    hBitmap = UtConvertDibToBitmap (dataDib.m_h);
    if (NULL == hBitmap )
    {
	return ResultFromScode(CONVERT10_E_STG_DIB_TO_BITMAP);
    }

    if (0 == GetObject (hBitmap, sizeof(BITMAP), &bm))
    {
	return ResultFromScode(CONVERT10_E_STG_DIB_TO_BITMAP);
    }

    cbBits = (DWORD) bm.bmHeight * (DWORD) bm.bmWidthBytes
		     * (DWORD) bm.bmPlanes;

    // There was a bug in OLE 1.0.  It calculated the size of a bitmap
    // as Height * WidthBytes * Planes * BitsPixel.
    // So we need to put that many bytes here even if most of the end of that
    // data block is garbage.  Otherwise OLE 1.0 will try to read too many
    // bytes of the OLESTREAM as bitmap bits.

    cbBitsFake = cbBits * (DWORD) bm.bmBitsPixel;

    // Allocate enough memory for our resultant BITMAP & header
    hBits = GlobalAlloc (GMEM_MOVEABLE, cbBitsFake + sizeof (BITMAP));
    if (NULL == hBits)
    {
	if (hBitmap)
	{
	    Verify (DeleteObject (hBitmap));
	}
	return ResultFromScode(E_OUTOFMEMORY);
    }

    // Get a pointer to the memory
    pBits = (LPBYTE) GlobalLock (hBits);
    if (NULL == pBits)
    {
	if (hBitmap)
	{
	    Verify (DeleteObject (hBitmap));
	}
	GlobalFree(hBits);
	return ResultFromScode(E_OUTOFMEMORY);
    }

    // Copy the raw bitmap data
    cb = GetBitmapBits (hBitmap, cbBits, pBits + sizeof(BITMAP));
    if (cb != cbBits)
    {
	if (hBitmap)
	{
	    Verify (DeleteObject (hBitmap));
	}
	GlobalFree(hBits);
	return ResultFromScode(CONVERT10_E_STG_DIB_TO_BITMAP);
    }

    // Set the caller's pointer to point to the bitmap

    *((BITMAP FAR*)pBits) = bm;

    pdata->m_h = hBits;
    pdata->m_pv = pBits;
    pdata->m_cbSize = cbBitsFake + sizeof(BITMAP);

    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Function:   Read20PresStream, INTERNAL
//
//  Synopsis:   Reads presentation data from an IStorage into a
//              generic object
//
//  Arguments:  [pstg]          -- the IStorage holding the pres stream
//              [pgenobj]       -- the generic object to read to
//              [fObjFmtKnown]  -- flag: Do we know the object format?
//
//  Returns:    NOEROR          on success
//              E_OUTOFMEMORY   on allocation failure
//
//  History:    dd-mmm-yy Author    Comment
//              22-Feb-94 davepl    Code cleanup and documentation
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL Read20PresStream(
    LPSTORAGE pstg,
    PGENOBJ   pgenobj,
    BOOL      fObjFmtKnown)
{
    HRESULT hr = NOERROR;
    LPSTREAM pstm = NULL;

    // Find the best presentation stream in this IStorage

    if (FAILED(hr = FindPresStream (pstg, &pstm, fObjFmtKnown)))
    {
	return hr;
    }

    if (pstm)
    {
	// Allocate a generic presentation object
	Assert (NULL==pgenobj->m_ppres);
	pgenobj->m_ppres = new PRES;
	if (NULL == pgenobj->m_ppres)
	{
	    pstm->Release();
	    return ResultFromScode(E_OUTOFMEMORY);
	}
    }
    else
    {
	// No presentation stream
	Assert (NULL == pgenobj->m_ppres);
	return NOERROR;
    }

    // read the format
    if (FAILED(hr = ReadFormat (pstm, &(pgenobj->m_ppres->m_format))))
    {
	pstm->Release();
	return hr;
    }

    // This is the fix for Bug 4020, highly requested by Access
    if (pgenobj->m_ppres->m_format.m_ftag == ftagNone)
    {
	// NULL format
	delete pgenobj->m_ppres;
	pgenobj->m_ppres = NULL;
	Assert (hr == NOERROR);
	pstm->Release();
	return hr;
    }

    // Each of the following calls must succeed in order for the following
    // one to be executed; if any fails, the if( .. && ..) will be false
    // and hr will be set to the error that caused the failure

    // target device
    if (SUCCEEDED(hr = OLE2StmToSizedData (pstm, NULL, 4))                  &&
    // aspect
    SUCCEEDED(hr = OLE2StmToUL (pstm, NULL))                            &&
    // lIndex
    SUCCEEDED(hr = OLE2StmToUL (pstm, NULL))                            &&
    // cache flags
    SUCCEEDED(hr = OLE2StmToUL (pstm, NULL))                            &&
    // compression
    SUCCEEDED(hr = OLE2StmToUL (pstm, NULL))                            &&
    // width
    SUCCEEDED(hr = OLE2StmToUL (pstm, &(pgenobj->m_ppres->m_ulWidth))))
    {   // height
	hr = OLE2StmToUL (pstm, &(pgenobj->m_ppres->m_ulHeight));
    }

    // We only proceed if everything so far has suceeded

    if (SUCCEEDED(hr))
    {
	if (pgenobj->m_ppres->m_format.m_ftag == ftagClipFormat &&
	     pgenobj->m_ppres->m_format.m_cf == CF_DIB &&
	    !pgenobj->m_fStatic)
	{
	    pgenobj->m_ppres->m_format.m_cf = CF_BITMAP;
	    hr = ReadDibAsBitmap (pstm, &(pgenobj->m_ppres->m_data));
	}
	else
	{
	    // In most cases, we look for a sized block of data in the
	    // stream.

	    hr = OLE2StmToSizedData (pstm, &(pgenobj->m_ppres->m_data));
	}
    }

    // Free up the stream and return status to caller

    if (pstm)
    {
	pstm->Release();
    }
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   OLE2StmToSizedData, INTERNAL
//
//  Synopsis:   Reads a set amount of data from an OLE 2 stream into a
//              DATA structure.  If the number of bytes are not known
//              ahead of time, the data length is pulled as the first
//              ULONG at the current stream position.
//
//  Arguments:  [pstm]          -- the stream to read from
//              [pdata]         -- the DATA structure to read to
//              [cbSizeDelta]   -- amount to be subtracted from
//                                 length; used to read target devices
//                                 where the length of data includes
//                                 prefixed length
//              [cbSizeKnown]   -- number of bytes to read if known
//                                 ahead of time
//
//  History:    dd-mmm-yy Author    Comment
//              21-Feb-94 davepl    Code cleanup and documentation
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL OLE2StmToSizedData(
    LPSTREAM  pstm,
    PDATA     pdata,
    ULONG     cbSizeDelta,  // default 0
    ULONG     cbSizeKnown)  // default 0
{
    ULONG cbSize;
    ULONG cbRead;
    LARGE_INTEGER large_integer;
    HRESULT hr = NOERROR;

    // If we don't know the data size ahead of time, read it from the stream;
    // it will be the first ULONG at the current position

    if (cbSizeKnown)
    {
	cbSize = cbSizeKnown;
    }
    else
    {
	if (FAILED(hr = (OLE2StmToUL (pstm, &cbSize))))
	{
	    return hr;
	}
    }

    cbSize -= cbSizeDelta;

    // If pdata is set, it means we actually do want to read the
    // data to a buffer, rather than just skip over it (the NULL case)

    if (pdata)
    {
	Assert (pdata->m_cbSize==0 && pdata->m_h==NULL && pdata->m_pv==NULL);

	// Set the number of bytes in the DATA structure

	pdata->m_cbSize = cbSize;

	// If there are any, allocate a buffer and read them.

	if (cbSize)
	{
	    // Allocate memory on the DATA handle
	    pdata->m_h = GlobalAlloc (GMEM_MOVEABLE, cbSize);
	    if (NULL == pdata->m_h)
	    {
		return ResultFromScode(E_OUTOFMEMORY);
	    }

	    // Lock memory in for the read
	    pdata->m_pv = GlobalLock (pdata->m_h);
	    if (NULL == pdata->m_pv)
	    {
		GlobalFree(pdata->m_h);
		return ResultFromScode(E_OUTOFMEMORY);
	    }

	    // Read the data to the buffer
	    if (FAILED(hr = pstm->Read (pdata->m_pv, cbSize, &cbRead)))
	    {
		GlobalUnlock(pdata->m_h);
		GlobalFree(pdata->m_h);
		return hr;
	    }

	    // If we didn't get enough bytes, bail now
	    if (cbRead != cbSize)
	    {
		GlobalUnlock(pdata->m_h);
		GlobalFree(pdata->m_h);
		return ResultFromScode(STG_E_READFAULT);
	    }
	}
	else
	{
	    // We have 0 bytes to read, so mark the
	    // memory handle and ptr as NULL
	    pdata->m_h = NULL;
	    pdata->m_pv = NULL;
	}
    }
    else
    {
	// we don't care what the data is, so just skip it
	LISet32( large_integer, cbSize );
	if (FAILED(hr = pstm->Seek (large_integer, STREAM_SEEK_CUR, NULL)))
	{
	    return hr;
	}
    }
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function:   RankOfPres, INTERNAL
//
//  Synopsis:   Returns a ULONG indicating the relative "goodness" of a
//              presentation. The preference is, in descending order:
//
//              Type            Rank
//              ----------      ----------
//              METAFILE        x30000
//              DIB             x20000
//              none            x10000
//
//              Add x200 for fScreenTargDev being set
//              Add x4   for Content aspect
//              Add x3   for Thumbnail aspect
//              Add x2   for Icon aspect
//              Add x1   for Docprint aspect
//
//              Eg: Metafile in Content aspect, with ScreenTargDev: 30204
//
//              The whole point of this is that there may be many
//              presentation streams available in the IStorage.  This fn
//              is used to select the best one.
//
//  Arguments:  [format]        -- the format tag & type structure
//              [fScreenTargDev]-- do we have a handle to the target dev
//              [dwAspect]      -- the aspect type
//
//  History:    dd-mmm-yy Author    Comment
//              21-Feb-94 davepl    Code cleanup and documentation
//
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL_(ULONG) RankOfPres(
     const FORMAT FAR& format,
     const BOOL  fScreenTargDev,
     const DWORD dwAspect)
{
    ULONG ul = 0L;

    if (format.m_cf==CF_METAFILEPICT)
    {
	ul += 0x030000;
    }
    else if (format.m_cf==CF_DIB)
    {
	ul += 0x020000;
    }
    else if (format.m_ftag != ftagNone)
    {
	ul += 0x010000;
    }

    ul += (fScreenTargDev + 1) * 0x0100;

    switch (dwAspect)
    {
    case DVASPECT_CONTENT:
	ul += 0x04;
	break;

    case DVASPECT_THUMBNAIL:
	ul += 0x03;
	break;

    case DVASPECT_ICON:
	ul += 0x02;
	break;

    case DVASPECT_DOCPRINT:
	ul += 0x01;
	break;
    }

    return ul;
}

//+-------------------------------------------------------------------------
//
//  Function:   IsBetter, INTERNAL INLINE
//
//  Synopsis:   Calls RankOfPres to determine if one presentation is
//              better than another
//
//  Effects:
//
//  Arguments:  [format]        -- the format tag and type
//              [fScreenTargDev]-- do we have a handle to target device
//              [dwAspect]      -- the aspect of the presentation
//              [formatBest]    -- the best format seen so far
//              [fScreenTargDevBest] -- flag for best format seen so far
//              [dwAspectBest]  -- the aspect of best format seen so far
//
//  History:    dd-mmm-yy Author    Comment
///             21-Feb-94 davepl    Code cleanup and documentation
//
//  Notes:
//
//--------------------------------------------------------------------------

inline static INTERNAL_(BOOL) IsBetter(
     const FORMAT FAR& format,
     const BOOL        fScreenTargDev,
     const DWORD       dwAspect,
     const FORMAT FAR& formatBest,
     const BOOL        fScreenTargDevBest,
     const DWORD       dwAspectBest)
{
    return RankOfPres (format, fScreenTargDev, dwAspect) >
       RankOfPres (formatBest, fScreenTargDevBest, dwAspectBest);
}


//+-------------------------------------------------------------------------
//
//  Function:   FindPresStream, INTERNAL
//
//  Synopsis:   Enumerates over the streams in an IStorage, looking for
//              presentation streams.  Selects the best stream among
//              these based on the comparison fn, IsBetter(), which uses
//              for comparison the criteria established in RankOfPres().
//
//  Arguments:  [pstg]      -- the IStorage to look in
//              [ppstmBest] -- out param for best pres stream
//              [fObjFmtKnown] is the object format known
//
//  Returns:    NOERROR on success
//              If no presentation is found, it is not an error but
//              *ppstm is set to NULL.
//
//  History:    dd-mmm-yy Author    Comment
//              21-Feb-94 davepl    Code cleanup and documentation
//
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL FindPresStream(
    LPSTORAGE           pstg,
    LPSTREAM FAR*       ppstmBest,
    BOOL                fObjFmtKnown)
{
    HRESULT             hr           = NOERROR;
    LPSTREAM            pstm         = NULL;
    IEnumSTATSTG FAR*   penumStg     = NULL;
    DWORD               dwAspectBest = 0;
    BOOL                fTargDevBest = -1;
    STATSTG             statstg;
    FORMAT              formatBest;

    Assert (ppstmBest);

    *ppstmBest = NULL;

    // Set up the enumeration on the available IStreams in the storage
    if (FAILED(hr = pstg->EnumElements (NULL, NULL, NULL, &penumStg)))
    {
	return hr;
    }

    // Enumerate through them and search for the best among all
    // presentation streams

    while (penumStg->Next (1, &statstg, NULL) == NOERROR)
    {
	// Check to see if this a presentation stream

	if (lstrlenW(statstg.pwcsName) >= 8 &&
            0==memcmp(statstg.pwcsName, OLESTR("\2OlePres"), 8*sizeof(WCHAR)))
	{
	    FORMAT format;
	    DATA   dataTargDev;
	    DWORD  dwAspect;

	    // Open the presentation stream
	    if (FAILED(hr = OpenStream (pstg, statstg.pwcsName, &pstm)))
	    {
		goto errRtn;
	    }

	    // Read the format from the pres stream
	    if (FAILED(hr = ReadFormat (pstm, &format)))
	    {
		goto errRtn;
	    }

	    // Read the target device from the pres stream
	    if (FAILED(hr = OLE2StmToSizedData (pstm, &dataTargDev, 4)))
	    {
		goto errRtn;
	    }

	    // Get the aspect from the pres stream
	    if (FAILED(hr = OLE2StmToUL (pstm, &dwAspect)))
	    {
		goto errRtn;
	    }

	    // Check to see if this presentation stream is better
	    // than the best seen so far

	    if (IsBetter (format,     dataTargDev.m_h==NULL, dwAspect,
		  formatBest, fTargDevBest,          dwAspectBest))
	    {
		// If it is, we can release the "best"
		if (*ppstmBest)
		{
		    (*ppstmBest)->Release();
		}

		// The king is dead, long live the king
		*ppstmBest = pstm;
		pstm->AddRef();

		formatBest  = format;
		fTargDevBest = (dataTargDev.m_h==NULL);
		dwAspectBest = dwAspect;
	    }
	    pstm->Release();
	    pstm = NULL;
	}
	PubMemFree(statstg.pwcsName);
	statstg.pwcsName = NULL;
    }

    // On Windows For Workgroups machines, statstg.pwcsName!=NULL when
    // Next() returns S_FALSE. Bug 3370.
    statstg.pwcsName = NULL;

  errRtn:

    if (statstg.pwcsName)
    {
	PubMemFree(statstg.pwcsName);
    }

    if (*ppstmBest)
    {
	if (dwAspectBest != DVASPECT_CONTENT && fObjFmtKnown)
	{
	    // then don't use this stream, we will get the presentaion
	    // from the CONTENTS stream
	    (*ppstmBest)->Release();
	    *ppstmBest = NULL;
	}
	else
	{
	    LARGE_INTEGER large_integer;
	    LISet32( large_integer, 0);
	    hr = (*ppstmBest)->Seek(large_integer, STREAM_SEEK_SET,NULL);
	}
    }

    if (penumStg)
    {
	penumStg->Release();
    }
    if (pstm)
    {
	pstm->Release();
    }

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Function:   Reads native data from an OLE 2 stream
//
//  Synopsis:   If the fn can find OLE 1 native data in the stream, it is
//              read out; otherwise, it attempts to create an IStorage
//              in memory on the data in the stream, and then uses the
//              CopyTo interface to extract the data.
//
//  Arguments:  [pstg]      -- The OLE 2 IStorage to look in
//              [pdata]     -- The DATA object to read native data to
//
//  Returns:    NOERROR                 on success
//              STG_E_READFAULT         on read failure
//              E_OUTOFMEMORY           on allocation failure
//
//  History:    dd-mmm-yy Author    Comment
//              21-feb-94 davepl    Cleaned up and documented code
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL Read20NativeStreams(LPSTORAGE  pstg, PDATA pdata)
{
    LPSTREAM    pstm      = NULL;
    LPLOCKBYTES plkbyt    = NULL;
    LPSTORAGE   pstgNative= NULL;

    HRESULT hr = NOERROR;

    // There are two possible codepaths based on the success of
    // OpenStream.  If it is true, it is because we were able to
    // open the OLE 1 presentation stream in the OLE 2 object.
    // Thus, it must have been an OLE 1 object "hidden" in
    // an OLE 2 IStream.
    //
    // If that fails, we create an in-memory IStorage based on
    // the native data and use the CopyTo member to extract the
    // natice data.
    //
    // If we experience a failure at any point, a "break" statement
    // bails us out past everything to the error cleanup and return
    // code following the closure of the switch() statement.

    switch ((DWORD)(NOERROR==OpenStream (pstg, OLE10_NATIVE_STREAM, &pstm)))
    {
    case TRUE:
    {
	// This was a 1.0 object "hidden" inside a 2.0 IStorage
	ULONG cbRead;

	Assert (pdata->m_cbSize==0 && NULL==pdata->m_h && NULL==pdata->m_pv);

	// read size
	if (FAILED(hr = pstm->Read(&(pdata->m_cbSize),sizeof(DWORD),&cbRead)))
	{
	    break;
	}

	if (sizeof(DWORD) != cbRead)
	{
	    hr = ResultFromScode (STG_E_READFAULT);
	    break;
	}

	// allocate memory to store copy of stream
	pdata->m_h = GlobalAlloc (GMEM_MOVEABLE, pdata->m_cbSize);
	if (NULL == pdata->m_h)
	{
	    hr = ResultFromScode(E_OUTOFMEMORY);
	    break;
	}

	pdata->m_pv = GlobalLock (pdata->m_h);
	if (NULL == pdata->m_pv)
	{
	    hr = ResultFromScode(E_OUTOFMEMORY);
	    break;
	}

	// read stream
	if (FAILED(hr = pstm->Read(pdata->m_pv,pdata->m_cbSize,&cbRead)))
	{
	    break;
	}

	if (pdata->m_cbSize != cbRead)
	{
	    hr= ResultFromScode (STG_E_READFAULT);
	    break;
	}
	break;
    }

    case FALSE:
    {
	const DWORD grfCreateStg = STGM_READWRITE | STGM_SHARE_EXCLUSIVE
				    | STGM_DIRECT | STGM_CREATE ;

	// Copy pstg into pstgNative, thereby removing slack and
	// giving us access to the bits via an ILockBytes
	if (FAILED(hr = CreateILockBytesOnHGlobal (NULL, FALSE, &plkbyt)))
	{
	    break;
	}
	if (FAILED(hr = StgCreateDocfileOnILockBytes
		    (plkbyt, grfCreateStg, 0, &pstgNative)))
	{
	    break;
	}
	if (FAILED(hr = pstg->CopyTo (0, NULL, 0, pstgNative)))
	{
	    break;
	}


	// Set pdata->m_cbSize
	STATSTG statstg;
	if (FAILED(hr = plkbyt->Stat (&statstg, 0)))
	{
	    break;
	}
	pdata->m_cbSize = statstg.cbSize.LowPart;

	// Set pdata->m_h
	if (FAILED(hr = GetHGlobalFromILockBytes (plkbyt, &(pdata->m_h))))
	{
	    break;
	}
	Assert (GlobalSize (pdata->m_h) >= pdata->m_cbSize);

	// Set pdata->m_pv
	pdata->m_pv = GlobalLock (pdata->m_h);
	if (NULL == pdata->m_pv)
	{
	    hr = ResultFromScode(E_OUTOFMEMORY);
	    break;
	}
    }   // end case
    }   // end switch

    // Cleanup and return status to caller
    if (pstm)
    {
	pstm->Release();
    }
    if (plkbyt)
    {
	plkbyt->Release();
    }
    if (pstgNative)
    {
	pstgNative->Release();
    }
    return hr;
}



//+-------------------------------------------------------------------------
//
//  Function:   PutPresentationObject, INTERNAL
//
//  Synopsis:   Writes a presentation to an OLE 1 stream.
//
//  Arguments:  [pos]           -- the OLE 1 stream to write to
//              [ppres]         -- the presentation object
//              [cls]           -- the class object
//              [fStatic]       -- flag: is this a static object
//
//  Returns:    NOERROR                 on success
//              various possible I/O errors on failure
//
//  History:    dd-mmm-yy Author    Comment
//              21-Feb-94 davepl    Code cleaned up and documented
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL PutPresentationObject(
    LPOLESTREAM      pos,
    const PRES FAR*  ppres,
    const CLASS FAR& cls,
    BOOL             fStatic) // optional
{
    HRESULT hr;

    // Is there a real presentation?

    BOOL fIsPres = FALSE;
    if (ppres)
    {
	if (ppres->m_format.m_ftag != ftagClipFormat ||
	    ppres->m_format.m_cf   != 0 )
	{
	    fIsPres = TRUE;
	}
    }

    // write the OLE version to the stream
    if (FAILED(hr = ULToOLE1Stream (pos, dwVerToFile)))
    {
	return hr;
    }

    // Calc format ID for presentation object, use 0 for no presentation

    ULONG id = 0L;

    if (fIsPres)
    {
	if (fStatic)
	{
	    id = FMTID_STATIC;
	}
	else
	{
	    id = FMTID_PRES;
	}
    }
    if (FAILED(hr = ULToOLE1Stream(pos, id)))
    {
	return hr;
    }

    if (!fIsPres)
    {
	// No presentation
	return NOERROR;
    }

    if (IsStandardFormat (ppres->m_format))
    {
	return PutStandardPresentation (pos, ppres);
    }
    else
    {
	Assert (!fStatic);
	return PutGenericPresentation (pos, ppres, cls.m_szClsid);
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   PutStandardPresentation, INTERNAL
//
//  Synopsis:   Writes a standard presentation (META, DIB, or BITMAP) out
//              to an OLE 1 stream.  Creates the METAFILEPICT header
//              as required.
//
//  Arguments:  [pos]           -- the OLE 1 stream to write to
//              [ppres]         -- the presentation to write
//
//  Returns:    NOERROR on success
//              Various other errors are possible from I/O routines
//
//  History:    dd-mmm-yy Author    Comment
//              21-Feb-94 davepl    Cleaned up and documented
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL PutStandardPresentation(
    LPOLESTREAM      pos,
    const PRES FAR*  ppres)
{
    HRESULT hr = NOERROR;

    Assert (ppres->m_format.m_ftag == ftagClipFormat);

    // Write the clipboard format string to the OLE 1 stream
    // (Will be written in ANSI, not OLESTR format)

    switch (ppres->m_format.m_cf)
    {
    case CF_METAFILEPICT:
	if (FAILED(hr = StringToOLE1Stm (pos, OLESTR("METAFILEPICT"))))
	{
	    return hr;
	}
	break;

    case CF_DIB:
	if (FAILED(hr = StringToOLE1Stm (pos, OLESTR("DIB"))))
	{
	    return hr;
	}
	break;

    case CF_BITMAP:
	if (FAILED(hr = StringToOLE1Stm (pos, OLESTR("BITMAP"))))
	{
	    return hr;
	}
	break;

    default:
	Assert (0 && "Don't know how to write pres format");
    }

    // Write width

    if (FAILED(hr = ULToOLE1Stream(pos, ppres->m_ulWidth)))
    {
	return hr;
    }
    // OLE 1.0 file format expects height to be  saved as a negative value
    if (FAILED(hr = ULToOLE1Stream(pos, - ((LONG)ppres->m_ulHeight))))
    {
	return hr;
    }

    // Do special handling for CF_METAFILEPICT
    if (ppres->m_format.m_cf == CF_METAFILEPICT)
    {
	// Need a header to write, crete one here

	WIN16METAFILEPICT mfpict =
	{
	    MM_ANISOTROPIC,
	    (short) ppres->m_ulWidth,
	    (short) ppres->m_ulHeight,
	    0
	};

	// put size ater adjusting it for metafilepict

	if (FAILED(hr = ULToOLE1Stream
	    (pos, (ppres->m_data.m_cbSize + sizeof(WIN16METAFILEPICT)))))
	{
	    return hr;
	}

	// put metafilepict

	if (FAILED(hr = DataToOLE1Stm(pos, &mfpict, sizeof(mfpict))))
	{
	    return hr;
	}

	// put metafile bits

	// There are two possible means by which we got these metafile
	// bits:  either we have an in-memory metafile, or raw bits
	// which we read from disk.  If it is an in-memory metafile,
	// the m_pv ptr will have been set to METADATAPTR, and we need
	// to extract the bits to our own buffer before saving them.
	// If they came from disk, we can just re-write the buffer
	// into which we read them.

	if (METADATAPTR == ppres->m_data.m_pv)
	{
	    BYTE *pb = (BYTE *) PrivMemAlloc(ppres->m_data.m_cbSize);
	    if (NULL == pb)
	    {
		return E_OUTOFMEMORY;
	    }

	    if (0 == GetMetaFileBitsEx((HMETAFILE) ppres->m_data.m_h,
					ppres->m_data.m_cbSize, pb))
	    {
		PrivMemFree(pb);
		return HRESULT_FROM_WIN32(GetLastError());
	    }

	    if (FAILED(hr = DataToOLE1Stm(pos, pb, ppres->m_data.m_cbSize)))
	    {
		PrivMemFree(pb);
		return hr;
	    }
	    PrivMemFree(pb);
	}
	else    // Bits were originally read into our buffer from disk
	{
	    if (FAILED(hr = DataToOLE1Stm(pos, ppres->m_data.m_pv,
				ppres->m_data.m_cbSize)))
	    {
		return hr;
	    }
	}
    }
    else
    {
	// Not a METAFILE, just write the data

	if (FAILED(hr = SizedDataToOLE1Stm (pos, ppres->m_data)))
	{
	    return hr;
	}
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   PutGenericPresentation, INTERNAL
//
//  Synopsis:   Writes a generic presentation to the stream based on
//              the clipboard format.  (Dumps raw pres data to stm)
//
//  Arguments:  [pos]       -- the stream to write to
//              [ppres]     -- the presentation
//              [szClass]   -- class name
//
//  History:    dd-mmm-yy Author    Comment
//              16-Feb-94 davepl    32-bit port'n'doc
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL PutGenericPresentation(
    LPOLESTREAM         pos,
    const PRES FAR*     ppres,
    LPCOLESTR           szClass)
{
    Assert (szClass);
    HRESULT hr = NOERROR;

    // Write the format class name out to the stream

    if (FAILED(hr = StringToOLE1Stm(pos, szClass)))
    {
	return hr;
    }

    // This semi-mythical 0xC000 occurs in
    // other code I've seen in this project also; if there's
    // a constant defined, someone ought to fix this

    if (ppres->m_format.m_ftag == ftagClipFormat)
    {
	if (ppres->m_format.m_cf < 0xc000)
	{
	    if (FAILED(hr = ULToOLE1Stream (pos, ppres->m_format.m_cf)))
	    {
	    return hr;
	    }
	}
	else
	{
	    if (FAILED(hr = ULToOLE1Stream (pos, 0L)))
	    {
	    return hr;
	    }

	    OLECHAR buf[256];

	    if (!GetClipboardFormatName(ppres->m_format.m_cf, buf,
		    sizeof(buf)/sizeof(OLECHAR)))
	    {
		return ResultFromScode(DV_E_CLIPFORMAT);
	    }

	    if (FAILED(hr = StringToOLE1Stm (pos, buf)))
	    {
		return hr;
	    }
	}
    }
    else if (ppres->m_format.m_ftag == ftagString)
    {
	// Write the format string to the stream

	if (FAILED(hr = ULToOLE1Stream (pos, 0L)))
	{
	    return hr;
	}
	if (FAILED(hr = SizedDataToOLE1Stm
	    (pos, ppres->m_format.m_dataFormatString)))
	{
	    return hr;
	}

    }
    else
    {
	AssertSz (0, "Bad format");
    }

    Assert (ppres->m_data.m_cbSize && ppres->m_data.m_h);

    // Write the raw presentation data out

    if (FAILED(hr = SizedDataToOLE1Stm (pos, ppres->m_data)))
    {
	return hr;
    }

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function:   wClassesMatchW, INTERNAL INLINE
//
//  Synopsis:   Worker function to compare classes.  Special case for
//              handling when the class of the file cannot be determined
//              because it is not a real file; this returns NOERROR
//
//  History:    dd-mmm-yy Author    Comment
//              21-Feb-94 davepl    Cleaned up and documented
//
//  Notes:
//
//--------------------------------------------------------------------------

inline INTERNAL wClassesMatchW(REFCLSID clsidIn, LPOLESTR szFile)
{
    CLSID clsid;

    // If we can get the CLSID for the code that works with this file,
    // compare it to the CLSID passed in, and return the result of
    // that comparison

    if (NOERROR==GetClassFile (szFile, &clsid))
    {
	if (IsEqualCLSID(clsid, clsidIn))
	{
	    return NOERROR;
	}
	else
	{
	    return ResultFromScode(S_FALSE);
	}
    }
    else
    {
	// If we can't determine the class of the file (because it's
	// not a real file) then OK.
	// Bug 3937.

	return NOERROR;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   MonikerIntoGenObj, INTERNAL
//
//  Synopsis:   Merges an OLE 2.0 moniker into a generic object
//
//  Effects:    Sets ths Topic, Item, and class members
//
//  Arguments:  [pgenobj]       -- the generic object to receive moniker
//              [clsidLast]     -- if a link, what its a link to
//              [pmk]           -- the moniker to merge in
//
//  History:    dd-mmm-yy Author    Comment
//              21-Feb-94 davepl    Code cleanup
//
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL MonikerIntoGenObj(
    PGENOBJ   pgenobj,
    REFCLSID  clsidLast,
    LPMONIKER pmk )
{
    LPOLESTR szFile=NULL;
    LPOLESTR szItem=NULL;
    BOOL     fClassesMatch = FALSE;

    // If the classes match, that implies this is a link to a pseudo-object
    // not to an embedded object.  If GetClassFile fails because the file
    // does not exist or is unsaved then we give the link the benefit
    // of the doubt and let it stay a link.  Only if we know the
    // classes do NOT match do we change the link into an Ole2Link
    // embedded object.

	// Ole10_PareMoniker returns S_FALSE in the FileMoniker - ItemMoniker - ItemMoniker... case
	// so check for NOERROR explicitly.
    if (NOERROR == Ole10_ParseMoniker (pmk, &szFile, &szItem))
    {
       if (szFile) 
       {
	  SCODE sc = GetScode(wClassesMatchW(clsidLast, szFile));
	  if (sc == S_OK || sc == MK_E_CANTOPENFILE)
	  {
		pgenobj->m_szTopic = szFile;
		pgenobj->m_szItem  = szItem;
		fClassesMatch = TRUE;
	  }
       }
    }
    if (FALSE == fClassesMatch)
    {
	// This moniker is either not a File or File::Item moniker,
	// or is a link to an embedded object, so the only
	// way we can convert it to OLE 1.0 is to make it an opaque Ole2Link

	pgenobj->m_fLink = FALSE;
	pgenobj->m_class.Reset (CLSID_StdOleLink);
    }

    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleConvertIStorageToOLESTREAMEx, STDAPI
//
//  Synopsis:   Similar to OleConvertIStorageToOLESTREAM, except that the
//              presentation data that needs to be written into OLESTREAM
//              is passed in. pmedium->tymed can only be TYMED_HGLOBAL
//              or TYMED_ISTREAM and the medium will not be released by the
//              api.  cfFormat can be NULL, If it is NULL then the other
//              parameters (lWidth, lHeight, dwSize, pmedium) will be ignored.
//
//  Arguments:  [pstg]          -- the storage object to convert from
//              [cfFormat]      -- clipboard format
//              [lWidth]        -- width
//              [lHeight]       -- height
//              [dwSize]        -- size in bytes
//              [pmedium]       -- serialized bytes
//              [polestm]       -- the OLE 1 stream to write to
//
//  Returns:    NOERROR                 on success
//              DV_E_TYMED              invalid clipboard format
//              E_INVALIDARG            invalid arg, normally stg or stm
//              DV_E_STGMEDIUM          bad medium ptr
//              E_OUTOFMEMORY           allocation failure
//
//  History:    dd-mmm-yy Author    Comment
//              21-Feb-94 davepl    Cleaned up and documented
//
//  Notes:
//
//--------------------------------------------------------------------------


STDAPI OleConvertIStorageToOLESTREAMEx
(
    LPSTORAGE       pstg,
    CLIPFORMAT      cfFormat,
    LONG            lWidth,
    LONG            lHeight,
    DWORD           dwSize,
    LPSTGMEDIUM     pmedium,
    LPOLESTREAM     polestm
)
{

    OLETRACEIN((API_OleConvertIStorageToOLESTREAMEx, 
    	PARAMFMT("pstg= %p, cfFormat= %x, lWidth= %d, lHeight= %d, dwSize= %ud, pmedium= %ts, polestm= %p"),
		pstg, cfFormat, lWidth, lHeight, dwSize, pmedium, polestm));

    LEDebugOut((DEB_ITRACE, "%p _IN OleConvertIStorageToOLESTREAMEx ("
	    " %p, %x , %lx , %lx , %x , %p , %p )\n", 0 /*function*/,
	    pstg, cfFormat, lWidth, lHeight, dwSize, pmedium, polestm
	));
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IStorage,(IUnknown **)&pstg);

    HGLOBAL         hGlobal = NULL;
    HRESULT         hr = NOERROR;
    BOOL            fFree = FALSE;
    CGenericObject  genobj;

    // If we are given a clipboard format...

    if (cfFormat) {

	VDATEPTRIN_LABEL(pmedium, STGMEDIUM, errRtn, hr);

	// Check that the medium ptr is valid
	if (pmedium->hGlobal == NULL)
	{
	    hr = ResultFromScode(DV_E_STGMEDIUM);
	    goto errRtn;
	}

	// Cannot have a 0 sized clipboard representation
	if (dwSize == 0)
	{
	    hr = ResultFromScode(E_INVALIDARG);
	    goto errRtn;
	}

	switch (pmedium->tymed)
	{
	case TYMED_HGLOBAL:
	    hGlobal = pmedium->hGlobal;
	    break;

	case TYMED_ISTREAM:
	    VDATEIFACE_LABEL(pmedium->pstm, errRtn, hr);
	    if ((hr = UtGetHGLOBALFromStm(pmedium->pstm, dwSize,
		&hGlobal)) != NOERROR)
	    {
		goto errRtn;
	    }
	    fFree = TRUE;
	    break;

	default:
	    hr = ResultFromScode(DV_E_TYMED);
	    goto errRtn;
	}
    }

    if (FAILED(hr = wConvertIStorageToOLESTREAM(pstg, polestm, &genobj)))
    {
	goto errRtn;
    }

    // Clean m_ppres
    if (genobj.m_ppres)
    {
	delete genobj.m_ppres;
	genobj.m_ppres = NULL;
    }

    if (cfFormat)
    {
	// fill genobj.m_ppres

	PPRES ppres;

	if ((genobj.m_ppres = ppres = new PRES) == NULL)
	{
	    hr = ResultFromScode(E_OUTOFMEMORY);
	    goto errRtn;
	}

	ppres->m_ulWidth        = (ULONG) lWidth;
	ppres->m_ulHeight       = (ULONG) lHeight;
	ppres->m_data.m_cbSize  = dwSize;
	ppres->m_data.m_fNoFree = !fFree;
	ppres->m_data.m_h       = hGlobal;
	ppres->m_data.m_pv      = GlobalLock(hGlobal);
	ppres->m_format.m_ftag  = ftagClipFormat;
	ppres->m_format.m_cf    = cfFormat;

    }
    else
    {
	genobj.m_fNoBlankPres = TRUE;
    }

    // REVIEW: We may not want to allow NULL cfFormat with static object
    
    hr = GenericObjectToOLESTREAM (genobj, polestm);

    LEDebugOut((DEB_ITRACE, "%p OUT OleConvertIStorageToOLESTREAMEx ( %lx ) "
    "\n", 0 /*function*/, hr));

    OLETRACEOUT((API_OleConvertIStorageToOLESTREAMEx, hr));

    return hr;

errRtn:

    if (fFree && hGlobal != NULL)
    {
	GlobalFree(hGlobal);
    }

    LEDebugOut((DEB_ITRACE, "%p OUT OleConvertIStorageToOLESTREAMEx ( %lx ) "
    "\n", 0 /*function*/, hr));

    OLETRACEOUT((API_OleConvertIStorageToOLESTREAMEx, hr));

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleConvertOLESTREAMToIStorageEx, STDAPI
//
//  Synopsis:   Similar to OleConvertOLESTREAMToIStorage, except that the
//              presentation data that is read from OLESTREAM is passed out.
//              And no presentation stream will written in to the storage.
//              pmedium->tymed can be TYMED_ISTREAM ot TYMED_NULL. If
//              TYMED_NULL, then the bits will be returned in a global
//              handle through pmedium->hGlobal. Otherwise data will be
//              written into pmedium->pstm. NULL will be returned through
//              *pcfFormat, if there is no presentation in the OLESTREAM.
//
//  Arguments:  [pstg]          -- the storage object to convert to
//              [cfFormat]      -- clipboard format
//              [lWidth]        -- width
//              [lHeight]       -- height
//              [dwSize]        -- size in bytes
//              [pmedium]       -- serialized bytes
//              [polestm]       -- the OLE 1 stream to write from
//
//  Returns:    DV_E_TYMED              invalid clipboard format
//
//  History:    dd-mmm-yy Author    Comment
//              21-Feb-94 davepl    Cleaned up and documented
//  Notes:
//
//--------------------------------------------------------------------------


STDAPI OleConvertOLESTREAMToIStorageEx
(
    LPOLESTREAM     polestm,
    LPSTORAGE       pstg,
    CLIPFORMAT FAR* pcfFormat,
    LONG FAR*       plWidth,
    LONG FAR*       plHeight,
    DWORD FAR*      pdwSize,
    LPSTGMEDIUM     pmedium
)
{
    OLETRACEIN((API_OleConvertOLESTREAMToIStorageEx,
    	PARAMFMT("polestm= %p, pstg= %p, pcfFormat= %p, plWidth= %p, plHeight= %p, pdwSize= %p, pmedium= %p"),
		polestm, pstg, pcfFormat, plWidth, plHeight, pdwSize, pmedium));

    LEDebugOut((DEB_ITRACE, "%p _IN OleConvertOLESTREAMToIStorageEx ("
    " %p , %p , %p , %p , %p , %p , %p )\n", 0 /*function*/,
    polestm, pstg, pcfFormat,plWidth,plHeight,pdwSize,pmedium
    ));

    HRESULT hr;
    PPRES ppres = NULL;
    GENOBJ genobj;

    VDATEPTROUT_LABEL(pcfFormat, CLIPFORMAT, errRtn, hr);
    VDATEPTROUT_LABEL(plWidth, LONG, errRtn, hr);
    VDATEPTROUT_LABEL(plHeight, LONG, errRtn, hr);
    VDATEPTROUT_LABEL(pdwSize, DWORD, errRtn, hr);
    VDATEPTROUT_LABEL(pmedium, STGMEDIUM, errRtn, hr);

    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IStorage,(IUnknown **)&pstg);

    if (pmedium->tymed == TYMED_ISTREAM)
    {
	VDATEIFACE_LABEL(pmedium->pstm, errRtn, hr);
    }
    else if (pmedium->tymed != TYMED_NULL)
    {
	hr = ResultFromScode(DV_E_TYMED);
	goto errRtn;
    }

    // Bring the object into genobj

    if (FAILED((hr = wConvertOLESTREAMToIStorage(polestm, pstg, &genobj))))
    {
	goto errRtn;
    }

    ppres = genobj.m_ppres;
    genobj.m_ppres = NULL;

    if (FAILED(hr = GenericObjectToIStorage (genobj, pstg, NULL)))
    {
	goto errRtn;
    }

    // If no presentation is available, clear our all the pres
    // dimensions and format

    if (ppres == NULL)
    {
	*pcfFormat = 0;
	*plWidth = 0L;
	*plHeight = 0L;
	*pdwSize = 0L;

	// Don't worry about the pmedium, it is already in the proper state

	hr = NOERROR;
	goto errRtn;
    }

    // If we reach here, we have a presentation, so set the OUT
    // parameters accordingly

    *plWidth = (LONG) ppres->m_ulWidth;
    *plHeight = (LONG) ppres->m_ulHeight;
    *pdwSize = ppres->m_data.m_cbSize;

    Assert(ppres->m_format.m_ftag != ftagNone);

    // If we have a clipboard format ID, return that in the OUT paramter,
    // otherwise return whatever we get back from an attempt to register
    // the format string

    if (ppres->m_format.m_ftag == ftagClipFormat)
    {
		*pcfFormat = ppres->m_format.m_cf;
    }
    else
    {
		// m_dataFormatString is an ASCII string.
		*pcfFormat = (CLIPFORMAT) SSRegisterClipboardFormatA( (LPCSTR) ppres->m_format.m_dataFormatString.m_pv);
		Assert(0 != *pcfFormat);
    }

    if (pmedium->tymed == TYMED_NULL)
    {
	if (ppres->m_data.m_h)
	{
	    Assert(ppres->m_data.m_pv != NULL);
	    GlobalUnlock(ppres->m_data.m_h);
	}

	// transfer the ownership
	pmedium->tymed = TYMED_HGLOBAL;
	pmedium->hGlobal = ppres->m_data.m_h;

	// Null out the handle and pointer so that destructor of PRES will not
	// free it.
	ppres->m_data.m_h = NULL;
	ppres->m_data.m_pv = NULL;

    }
    else
    {
	hr = pmedium->pstm->Write(ppres->m_data.m_pv, *pdwSize, NULL);
    }

errRtn:

    if (ppres)
    {
	delete ppres;
    }

    LEDebugOut((DEB_ITRACE, "%p OUT OleConvertOLESTREAMToIStorageEx ( %lx ) "
    "\n", 0 /*function*/, hr));

    OLETRACEOUT((API_OleConvertOLESTREAMToIStorageEx, hr));

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   wWriteFmtUserType, INTERNAL
//
//  Synopsis:   Gets the user type for a class ID and writes it to
//              an IStorage
//
//
//  Arguments:  [pstg]          -- the storage to write to
//              [clsid]         -- the class ID
//
//
//  Returns:    NOERROR on success
//
//  History:    dd-mmm-yy Author    Comment
//              21-Feb-94 davepl    Cleaned up and documented
//  Notes:
//
//--------------------------------------------------------------------------

FARINTERNAL wWriteFmtUserType(LPSTORAGE pstg, REFCLSID   clsid)
{
    HRESULT    hr         = NOERROR;
    LPOLESTR   szProgID   = NULL;
    LPOLESTR   szUserType = NULL;

    // Get the program ID
    if (FAILED(hr = ProgIDFromCLSID (clsid, &szProgID)))
    {
	goto errRtn;
    }

    // Get the user type
    if (FAILED(hr = OleRegGetUserType(clsid,USERCLASSTYPE_FULL,&szUserType)))
    {
	goto errRtn;
    }

    // Write the user type out to the storage
    if (FAILED(hr = WriteFmtUserTypeStg
	(pstg, (CLIPFORMAT) RegisterClipboardFormat (szProgID), szUserType)))
    {
	goto errRtn;
    }

    // Clean up and return status

  errRtn:

    if (szProgID)
    {
	PubMemFree(szProgID);
    }
    if (szUserType)
    {
	PubMemFree(szUserType);
    }
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   wCLSIDFromProgID
//
//  Synopsis:   Looks for the key HKEY_CLASSES_ROOT\{ProgID}\Clsid\ to get
//              the string version of the class ID, then returns the CLSID
//              value of whatever it found.
//
//  History:    dd-mmm-yy Author    Comment
//              25-Jun-94 alexgo    fixed Ole1 CLSID creation
//              15-Apr-94 davepl    Rewrite
//
//  Notes:      Used to be in clipboard code, but used in this file
//
//--------------------------------------------------------------------------

INTERNAL wCLSIDFromProgID(LPOLESTR szProgID, LPCLSID pclsid, BOOL fForceAssign)
{
    VDATEHEAP();

    // Apparently some optimization.  If the class name is "OLE2Link", we can
    // return CLSID_StdOleLInk without even bothering to check the registry.

    if (0 == _xstrcmp(szProgID, OLESTR("OLE2Link")))
    {
	*pclsid = CLSID_StdOleLink;
	return NOERROR;
    }
    else
    {
	// this function will look for a CLSID under the ProgID entry in
	// the registry or manufacture one if none present.

	return CLSIDFromOle1Class(szProgID, pclsid, fForceAssign);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   wProgIDFromCLSID
//
//  Synopsis:   A wrapper for ProgIDFromCLSID.  The only change in
//              functionality is to check and see if this is a
//              CLSID_StdOleLink, and if so, return a prog ID of
//              "OLE2Link" rather than failing.
//
//
//  History:    dd-mmm-yy Author    Comment
//              15-Feb-94 davepl    Rewrite
//
//--------------------------------------------------------------------------

FARINTERNAL wProgIDFromCLSID(REFCLSID clsid, LPOLESTR FAR* psz)
{
    VDATEHEAP();

    HRESULT hresult;

    // If we can get the ProgID by conventional methods, great, just
    // return it.

    if (NOERROR == (hresult = ProgIDFromCLSID(clsid, psz)))
    {
        return hresult;
    }

    // If we failed, it might be because this is a standard OLE link, which
    // will not have a ProgID entry in the registry, so we fake it out by
    // returning the ProgID manually.

    if (IsEqualCLSID(clsid, CLSID_StdOleLink))
    {
        *psz = UtDupString(OLESTR("OLE2Link"));

        if (*psz == NULL)
        {
            hresult = E_OUTOFMEMORY;
        }
        else
        {
            hresult = NOERROR;
        }
    }

    // Must not have been able to resolve for ProgID, so return the error.
    return(hresult);
}


#if 0


// We don't need these conversion fns yet, but we likely will soon.

inline INTERNAL_(VOID) ConvertBM32to16(LPBITMAP lpsrc, LPWIN16BITMAP lpdest)
{
    lpdest->bmType       = (short)lpsrc->bmType;
    lpdest->bmWidth      = (short)lpsrc->bmWidth;
    lpdest->bmHeight     = (short)lpsrc->bmHeight;
    lpdest->bmWidthBytes = (short)lpsrc->bmWidthBytes;
    lpdest->bmPlanes     = (BYTE)lpsrc->bmPlanes;
    lpdest->bmBitsPixel  = (BYTE)lpsrc->bmBitsPixel;
}

inline INTERNAL_(VOID) ConvertBM16to32(LPWIN16BITMAP lpsrc, LPBITMAP lpdest)
{
    lpdest->bmType       = MAKELONG(lpsrc->bmType,NULL_WORD);
    lpdest->bmWidth      = MAKELONG(lpsrc->bmWidth,NULL_WORD);
    lpdest->bmHeight     = MAKELONG(lpsrc->bmHeight,NULL_WORD);
    lpdest->bmWidthBytes = MAKELONG(lpsrc->bmWidthBytes,NULL_WORD);
    lpdest->bmPlanes     = (WORD)lpsrc->bmPlanes;
    lpdest->bmBitsPixel  = (WORD)lpsrc->bmBitsPixel;
}

inline INTERNAL_(VOID) ConvertMF16to32(
	LPWIN16METAFILEPICT lpsrc,
    LPMETAFILEPICT      lpdest )
{
   lpdest->mm     = (DWORD)lpsrc->mm;
   lpdest->xExt   = (DWORD)MAKELONG(lpsrc->xExt,NULL_WORD);
   lpdest->yExt   = (DWORD)MAKELONG(lpsrc->yExt,NULL_WORD);
}

inline INTERNAL_(VOID) ConvertMF32to16(
   LPMETAFILEPICT      lpsrc,
   LPWIN16METAFILEPICT lpdest )
{
   lpdest->mm     = (short)lpsrc->mm;
   lpdest->xExt   = (short)lpsrc->xExt;
   lpdest->yExt   = (short)lpsrc->yExt;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\stdimpl\clthndlr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       clnthndlr.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-10-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

#ifndef _CLTHNDLR_H_DEFINED_
#define _CLTHNDLR_H_DEFINED_

//+---------------------------------------------------------------------------
//
//  Class:      CClientSiteHandler ()
//
//  Purpose:    Implement ClientSide of IOleClientSite handler
//
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
class CClientSiteHandler : public IClientSiteHandler
{
public:

    CClientSiteHandler(IOleClientSite *pOCS);
    ~CClientSiteHandler();

    STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);

    // IOleClientSite methods
    STDMETHOD (GetContainer)(IOleContainer **ppContainer);
    STDMETHOD (OnShowWindow)(BOOL fShow);
    STDMETHOD (GetMoniker)(DWORD dwAssign,DWORD dwWhichMoniker,IMoniker  **ppmk);
    STDMETHOD (RequestNewObjectLayout)();
    STDMETHOD (SaveObject)();
    STDMETHOD (ShowObject)();

    // IOleWindow methods
    STDMETHOD (GetWindow)(HWND *phwnd);
    STDMETHOD (ContextSensitiveHelp)(BOOL fEnterMode);

    // IOleInPlaceSite methods
    STDMETHOD (CanInPlaceActivate)(void);
    STDMETHOD (OnInPlaceActivate)(void);
    STDMETHOD (OnUIActivate)(void);
    STDMETHOD (GetWindowContext)(IOleInPlaceFrame **ppFrame,IOleInPlaceUIWindow **ppDoc,
                   LPRECT lprcPosRect,LPRECT lprcClipRect,LPOLEINPLACEFRAMEINFO lpFrameInfo);
    STDMETHOD (Scroll)(SIZE scrollExtant);
    STDMETHOD (OnUIDeactivate)(BOOL fUndoable);
    STDMETHOD (OnInPlaceDeactivate)(void);
    STDMETHOD (DiscardUndoState)(void);
    STDMETHOD (DeactivateAndUndo)(void);
    STDMETHOD (OnPosRectChange)(LPCRECT lprcPosRect);

    // IClientSiteHandler methods
    STDMETHOD (GoInPlaceActivate)(HWND *phwndOIPS);
    
public:
    IOleClientSite      *m_pOCS;
    IOleInPlaceSite     *m_pOIPS;

private:
    ULONG               m_cRefs;

};

// IOleClientSite Replacement implementation
// Implements ServerSide of ClientSiteHandler.

class CEmbServerClientSite : public IOleClientSite, public IOleInPlaceSite
{
public:

    CEmbServerClientSite(IUnknown *pUnkOuter);
    ~CEmbServerClientSite();

    STDMETHOD(Initialize) (OBJREF  objref,BOOL fHasIPSite);
    STDMETHOD(SetDoVerbState) (BOOL fDoVerbState);

    // Controlling Unknown.
    class CPrivUnknown : public IUnknown
    {
    public:
        STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj);
        STDMETHOD_(ULONG,AddRef) (void);
        STDMETHOD_(ULONG,Release) (void);
        
        CEmbServerClientSite *m_EmbServerClientSite;
    };

    friend class CPrivUnknown;
    CPrivUnknown m_Unknown;

    // IUnknown Methods
    STDMETHOD(QueryInterface) ( REFIID iid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);

    // IOleClientSite Methods
    STDMETHOD (SaveObject)( void);
    STDMETHOD (GetMoniker)( DWORD dwAssign,DWORD dwWhichMoniker,IMoniker **ppmk);
    STDMETHOD (GetContainer)(IOleContainer **ppContainer);
    STDMETHOD (ShowObject)( void);
    STDMETHOD (OnShowWindow)(BOOL fShow);
    STDMETHOD (RequestNewObjectLayout)( void);
    
    // IOleInPlaceSiteMethods.
    STDMETHOD (GetWindow)(HWND *phwnd);
    STDMETHOD (ContextSensitiveHelp)( BOOL fEnterMode);
    STDMETHOD (CanInPlaceActivate)(void);
    STDMETHOD (OnInPlaceActivate)( void);
    STDMETHOD (OnUIActivate)( void);
    STDMETHOD (GetWindowContext)(IOleInPlaceFrame **ppFrame,IOleInPlaceUIWindow **ppDoc,
                           LPRECT lprcPosRect,LPRECT lprcClipRect,LPOLEINPLACEFRAMEINFO lpFrameInfo);
    STDMETHOD (Scroll)(SIZE scrollExtant);
    STDMETHOD (OnUIDeactivate)(BOOL fUndoable);
    STDMETHOD (OnInPlaceDeactivate)( void);
    STDMETHOD (DiscardUndoState)( void);
    STDMETHOD (DeactivateAndUndo)( void);
    STDMETHOD (OnPosRectChange)(LPCRECT lprcPosRect);

private:
    IClientSiteHandler *m_pClientSiteHandler;   // Pointer to Real Containers ClientSite.
    IUnknown *m_pUnkOuter; // Controlling Unknown
    ULONG m_cRefs;
    IUnknown *m_pUnkInternal; // used for QI on object.
    BOOL    m_fInDelete;   // Set to True if RefCount has gone to Zero.
    
    BOOL m_fInDoVerb;
    BOOL m_fHasIPSite;
    
    // Cache data while in doVerbState
    HWND m_hwndOIPS;
};

HRESULT CreateClientSiteHandler(IOleClientSite *pOCS, CClientSiteHandler **ppClntHdlr,BOOL *pfHasIPSite);

#endif //  _CLTHNDLR_H_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\ole1\ddecnvrt.cpp ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ddecnvrt.cpp

Abstract:

    This module contains the code to read/write PBrush, MSDraw native data
	formats. This module also contains PBrush native format <->DIbFile stream,
	and MSDraw native format <-> placeable metafile stream conversion routines.

Author:

    Srini Koppolu (srinik)	06/29/1993

Revision History:

--*/

#include <le2int.h>
#include <ole1cls.h>
#ifndef _MAC




/************************   FILE FORMATS   **********************************


Normal Metafile (memory or disk based):

	 ------------ ---------------
	| METAHEADER | Metafile bits |
	 ------------ ---------------
	
Placeable Metafile:

	 --------------------- -----------------
	| PLACEABLEMETAHEADER | Normal metafile |
	 --------------------- -----------------

Memory Based DIB:

	 ------------------ --------------- ----------
	| BITMAPINFOHEADER | RGBQUAD array | DIB bits |
	 ------------------ --------------- ----------
	
DIB file format:

	 ------------------ ------------------
	| BITMAPFILEHEADER | Memory based DIB |
	 ------------------ ------------------
	
Ole10NativeStream Format:	
	
	 -------- ----------------------
	| dwSize | Object's Native data |
	 -------- ----------------------
	
PBrush Native data format:

	 -----------------
	| Dib File format |
	 -----------------
	
MSDraw Native data format:

	 --------------------- ------------- ------------- -----------------
	| mapping mode (WORD) | xExt (WORD) | yExt (WORD) | Normal metafile |
	 --------------------- ------------- ------------- -----------------
	
	
*****************************************************************************/




FARINTERNAL	UtGetHMFPICTFromMSDrawNativeStm
	(LPSTREAM pstm,	DWORD dwSize, HANDLE FAR* lphdata)
{
	HRESULT		error;
	WORD		mfp[3]; // mm, xExt, yExt
	HMETAFILE	hMF = NULL;
	
	*lphdata = NULL;
	
	if (error = pstm->Read(mfp, sizeof(mfp), NULL))
		return error;
	
	dwSize -= sizeof(mfp);

	if (error = UtGetHMFFromMFStm(pstm, dwSize, FALSE, (void **)&hMF))
		return error;
		
	AssertSz(mfp[0] == MM_ANISOTROPIC, "invalid map mode in MsDraw native data");
	
	if (*lphdata = UtGetHMFPICT(hMF, TRUE, (int) mfp[1], (int) mfp[2]))
		return NOERROR;

	return ResultFromScode(E_OUTOFMEMORY);	
}


FARINTERNAL UtPlaceableMFStmToMSDrawNativeStm
	(LPSTREAM pstmPMF, LPSTREAM pstmMSDraw)
{
	DWORD	dwSize;	// size of metafile bits excluding the placeable MF header
	LONG	xExt;
	LONG	yExt;
	WORD	wBuf[5]; // dwSize(DWORD), mm(int), xExt(int), yExt(int)
	HRESULT error;
	
	if (error = UtGetSizeAndExtentsFromPlaceableMFStm(pstmPMF, &dwSize,
			&xExt, &yExt))
		return error;		

	*((DWORD FAR*) wBuf) = dwSize + 3*sizeof(WORD);
	wBuf[2] = MM_ANISOTROPIC;
	wBuf[3] = (WORD) xExt;
	wBuf[4] = (WORD) yExt;
	
	if (error = pstmMSDraw->Write(wBuf, sizeof(wBuf), 0))
		return error;

	ULARGE_INTEGER ularge_int;
	ULISet32(ularge_int, dwSize);
	if ((error = pstmPMF->CopyTo(pstmMSDraw, ularge_int,
			NULL, NULL)) == NOERROR)
		StSetSize(pstmMSDraw, 0, TRUE);
	
	return error;
				
}


FARINTERNAL UtDIBFileStmToPBrushNativeStm
	(LPSTREAM pstmDIBFile, LPSTREAM pstmPBrush)
{
	BITMAPFILEHEADER bfh;
	HRESULT	error;
	
	if (error = pstmDIBFile->Read(&bfh, sizeof(bfh), 0))
		return error;
	
	// seek to the begining of the stream
	LARGE_INTEGER large_int;
	LISet32( large_int, 0);
	if (error = pstmDIBFile->Seek(large_int, STREAM_SEEK_SET, 0))
		return error;
	
	if (error = pstmPBrush->Write(&(bfh.bfSize), sizeof(DWORD), 0))
		return error;
	
	ULARGE_INTEGER ularge_int;
	ULISet32(ularge_int, bfh.bfSize);
	
	if ((error = pstmDIBFile->CopyTo(pstmPBrush, ularge_int,
			NULL, NULL)) == NOERROR)
		StSetSize(pstmPBrush, 0, TRUE);
	
	return error;
}
	
	
	
FARINTERNAL UtContentsStmTo10NativeStm
	(LPSTORAGE pstg, REFCLSID rclsid, BOOL fDeleteSrcStm, UINT FAR* puiStatus)
{
	CLIPFORMAT	cf;
	LPOLESTR	lpszUserType = NULL;
	HRESULT		error;
	LPSTREAM	pstmSrc = NULL;
	LPSTREAM	pstmDst = NULL;
			
	*puiStatus = NULL;
	
	if (error = ReadFmtUserTypeStg(pstg, &cf, &lpszUserType))
		return error;
		
	
	if (! ((cf == CF_DIB  && rclsid == CLSID_PBrush)
			|| (cf == CF_METAFILEPICT && rclsid == CLSID_MSDraw))) {
		error = ResultFromScode(DV_E_CLIPFORMAT);
		goto errRtn;
	}
			
	if (error = pstg->OpenStream(OLE_CONTENTS_STREAM, NULL,
						(STGM_READ|STGM_SHARE_EXCLUSIVE),
						0, &pstmSrc)) {
		*puiStatus |= CONVERT_NOSOURCE;	

		// check whether OLE10_NATIVE_STREAM exists
		if (pstg->OpenStream(OLE10_NATIVE_STREAM, NULL,
				(STGM_READ|STGM_SHARE_EXCLUSIVE), 0, &pstmDst))
			*puiStatus |= CONVERT_NODESTINATION;
		else {
			pstmDst->Release();
			pstmDst = NULL;
		}
		
		goto errRtn;
	}
	
	if (error = OpenOrCreateStream(pstg, OLE10_NATIVE_STREAM, &pstmDst)) {
		*puiStatus |= CONVERT_NODESTINATION;						
		goto errRtn;
	}
	
	if (cf == CF_METAFILEPICT)
		error = UtPlaceableMFStmToMSDrawNativeStm(pstmSrc, pstmDst);
	else
		error = UtDIBFileStmToPBrushNativeStm(pstmSrc, pstmDst);
	
errRtn:
	if (pstmDst)
		pstmDst->Release();
			
	if (pstmSrc)
		pstmSrc->Release();
	
	if (error == NOERROR) {
		LPOLESTR lpszProgId = NULL;
		ProgIDFromCLSID(rclsid, &lpszProgId);
		
		error = WriteFmtUserTypeStg(pstg,
						(CLIPFORMAT) RegisterClipboardFormat(lpszProgId),
						lpszUserType);

		if (lpszProgId)
			delete lpszProgId;
	}
	
	if (error == NOERROR) {
		if (fDeleteSrcStm)				
			pstg->DestroyElement(OLE_CONTENTS_STREAM);
	} else {
		pstg->DestroyElement(OLE10_NATIVE_STREAM);	
	}	
	
	if (lpszUserType)
		delete lpszUserType;
	
	return error;
}


	
FARINTERNAL Ut10NativeStmToContentsStm
	(LPSTORAGE pstg, REFCLSID rclsid, BOOL fDeleteSrcStm)
{

	CLIPFORMAT	cfOld;
	CLIPFORMAT	cfNew;	
	LPOLESTR	lpszUserType = NULL;
	HRESULT		error;
	LPSTREAM	pstmSrc = NULL;
	LPSTREAM	pstmDst = NULL;

	
	if (error = ReadFmtUserTypeStg(pstg, &cfOld, &lpszUserType))
		return error;

	if (rclsid == CLSID_StaticDib)
		cfNew = CF_DIB;
	else if (rclsid == CLSID_StaticMetafile)
		cfNew = CF_METAFILEPICT;
	else {
		AssertSz(FALSE, "Internal Error: this routine shouldn't have been called for this class");
		return ResultFromScode(E_FAIL);
	}
	
	if (cfOld == g_cfPBrush) {
		if (cfNew != CF_DIB) {
			error = ResultFromScode(DV_E_CLIPFORMAT);			
			goto errRtn;
		}
	} else if (cfOld == g_cfMSDraw) {
		if (cfNew != CF_METAFILEPICT) {
			error = ResultFromScode(DV_E_CLIPFORMAT);			
			goto errRtn;
		}
	} else {
		// Converted to static object from some class other than PBrush or
		// MSDraw. The data must be in a proper format in the CONTENTS
		// stream.
		return NOERROR;
	}
	
	if (error = pstg->OpenStream(OLE10_NATIVE_STREAM, NULL,
						(STGM_READ|STGM_SHARE_EXCLUSIVE),
						0, &pstmSrc))
		goto errRtn;
	
	if (error = OpenOrCreateStream(pstg, OLE_CONTENTS_STREAM, &pstmDst))
		goto errRtn;
	
	DWORD dwSize;
	if (error = pstmSrc->Read(&dwSize, sizeof(DWORD), NULL))
		goto errRtn;
			
	if (cfOld == g_cfMSDraw) {
		WORD mfp[3]; // mm, xExt, yExt
	
		if (error = pstmSrc->Read(mfp, sizeof(mfp), NULL))
			goto errRtn;
		
		dwSize -= sizeof(mfp);
		
		error = UtMFStmToPlaceableMFStm(pstmSrc, dwSize,
					(LONG) mfp[1], (LONG) mfp[2], pstmDst);
		
	} else {
		// The PBrush native data format is DIB File format. So all we got to
		// do is CopyTo.
		
		ULARGE_INTEGER ularge_int;
		ULISet32(ularge_int, dwSize);
		if ((error = pstmSrc->CopyTo(pstmDst, ularge_int, NULL,
				NULL)) == NOERROR)
			StSetSize(pstmDst, 0, TRUE);		
	}
	
errRtn:
	if (pstmDst)
		pstmDst->Release();
			
	if (pstmSrc)
		pstmSrc->Release();
	
	if (error == NOERROR) {
 		error = WriteFmtUserTypeStg(pstg, cfNew, lpszUserType);

		if (fDeleteSrcStm)				
			pstg->DestroyElement(OLE10_NATIVE_STREAM);

	} else {
		pstg->DestroyElement(OLE_CONTENTS_STREAM);	
	}	
	
	if (lpszUserType)
		PubMemFree(lpszUserType);
	
	return error;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\stdimpl\clthndlr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       clnthndlr.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-10-95   JohannP (Johann Posch)   Created
//              12-03-96    rogerg      Changed to New Embed ServerHandler Model.
//
//----------------------------------------------------------------------------


#include <le2int.h>
#include <ole2int.h>

#include <stdid.hxx>        // CStdIdentity
#include "srvhdl.h"
#include "clthndlr.h"


ASSERTDATA

//+---------------------------------------------------------------------------
//
//  Function:   CreateClientSiteHandler
//
//  Synopsis:
//
//  Arguments:  [pOCS] --
//              [ppClntHdlr] --
//
//  Returns:
//
//  History:    11-10-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CreateClientSiteHandler(IOleClientSite *pOCS, CClientSiteHandler **ppClntHdlr, BOOL *pfHasIPSite)
{
HRESULT hr = NOERROR;

    LEDebugOut((DEB_TRACE, "IN CreateClientSiteHandler(pOCS:%p)\n",pOCS));

    *ppClntHdlr = new CClientSiteHandler(pOCS);

    if (*ppClntHdlr)
    {
        *pfHasIPSite = (*ppClntHdlr)->m_pOIPS ? TRUE: FALSE;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    LEDebugOut((DEB_TRACE, "OUT CreateClientSiteHandler(ppSrvHdlr:%p) return %lx\n",*ppClntHdlr,hr));

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClientSiteHandler::CClientSiteHandler
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    9-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CClientSiteHandler::CClientSiteHandler(IOleClientSite *pOCS)
{

    Win4Assert(pOCS);

    m_cRefs = 1;
    m_pOIPS = NULL;
    m_pOCS = pOCS;

    if (m_pOCS)
    {
        m_pOCS->AddRef();

        // see if Supports InPlaceSite and if so hold onto it.
        if (FAILED(m_pOCS->QueryInterface(IID_IOleInPlaceSite,(void **) &m_pOIPS)))
        {
                m_pOIPS = NULL;
        }

    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CClientSiteHandler::~CClientSiteHandler
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    9-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CClientSiteHandler::~CClientSiteHandler()
{
    Win4Assert(m_pOIPS == NULL);
    Win4Assert(m_pOCS == NULL);
}

//+---------------------------------------------------------------------------
//
//  Method:     CClientSiteHandler::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppv] --
//
//  Returns:
//
//  History:    8-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientSiteHandler::QueryInterface( REFIID riid, void **ppv)
{
HRESULT hresult = NOERROR;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CClientSiteHandler::QueryInterface (%lx, %p)\n", this, riid, ppv));

    if (IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IClientSiteHandler) )
    {
        *ppv = (void FAR *)(IClientSiteHandler *)this;
        InterlockedIncrement((long *)&m_cRefs);
    }
    else
    {
        hresult = m_pOCS->QueryInterface(riid,ppv);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CClientSiteHandler::QueryInterface (%lx)[%p]\n", this, hresult, *ppv));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClientSiteHandler::AddRef
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    8-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClientSiteHandler::AddRef( void )
{
    VDATEHEAP();
    LEDebugOut((DEB_TRACE, "%p _IN CClientSiteHandler::AddRef\n", this));

    InterlockedIncrement((long *)&m_cRefs);

    LEDebugOut((DEB_TRACE, "%p OUT CClientSiteHandler::AddRef (%ld)\n", this, m_cRefs));
    return m_cRefs;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClientSiteHandler::Release
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    8-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClientSiteHandler::Release( void )
{
ULONG  cRefs = 0;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CClientSiteHandler::Release\n", this));

    cRefs = InterlockedDecrement((long *)&m_cRefs);

    if (cRefs == 0)
    {
    LPUNKNOWN punk; // local var for safe release

        if (m_pOIPS)
        {
            punk = (LPUNKNOWN) m_pOIPS;
            m_pOIPS = NULL;
            punk->Release();
        }

        if (m_pOCS)
        {
            punk = (LPUNKNOWN) m_pOCS;
            m_pOCS = NULL;
            punk->Release();
        }

        delete this;
    }

    LEDebugOut((DEB_TRACE, "%p OUT CClientSiteHandler::Release (%ld)\n", this, cRefs));
    return cRefs;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClientSiteHandler::GetContainer
//
//  Synopsis:   delegates call on to appropriate OleClientSite
//
//  Arguments:  [dwId] -- id of the OleClientSite the call should be delegate too
//              [ppContainer] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientSiteHandler::GetContainer(IOleContainer  * *ppContainer)
{
HRESULT hresult = E_FAIL;

    VDATEHEAP();
    LEDebugOut((DEB_TRACE, "%p _IN CClientSiteHandler::GetContainer\n", this));

    Win4Assert(m_pOCS);

    if (m_pOCS)
    {
        hresult = m_pOCS->GetContainer(ppContainer);
    }


    LEDebugOut((DEB_TRACE, "%p OUT CClientSiteHandler::GetContainer hr=%lx\n", this,  hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClientSiteHandler::OnShowWindow
//
//  Synopsis:   delegates call on to appropriate OleClientSite
//
//  Arguments:  [dwId] -- id of the OleClientSite the call should be delegate too
//              [fShow] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientSiteHandler::OnShowWindow(BOOL fShow)
{
HRESULT hresult = E_FAIL;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CClientSiteHandler::OnShowWindow\n", this));

    Win4Assert(m_pOCS);

    if (m_pOCS)
    {
        hresult = m_pOCS->OnShowWindow(fShow);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CClientSiteHandler::OnShowWindow hr=%lx\n", this,  hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClientSiteHandler::RequestNewObjectLayout
//
//  Synopsis:   delegates call on to appropriate OleClientSite
//
//  Arguments:  [dwId] -- id of the OleClientSite the call should be delegate too
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientSiteHandler::RequestNewObjectLayout()
{
HRESULT hresult = E_FAIL;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CClientSiteHandler::RequestNewObjectLayout\n", this));

    Win4Assert(m_pOCS);

    if (m_pOCS)
    {
        hresult = m_pOCS->RequestNewObjectLayout();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CClientSiteHandler::RequestNewObjectLayout hr=%lx\n", this,  hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClientSiteHandler::GetMoniker
//
//  Synopsis:   delegates call on to appropriate OleClientSite
//
//  Arguments:  [dwId] -- id of the OleClientSite the call should be delegate too
//              [DWORD] --
//              [IMoniker] --
//              [ppmk] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientSiteHandler::GetMoniker(DWORD dwAssign,DWORD dwWhichMoniker,IMoniker  * *ppmk)
{
HRESULT hresult = E_FAIL;

    VDATEHEAP();
    LEDebugOut((DEB_TRACE, "%p _IN CClientSiteHandler::GetMoniker\n", this));

    Win4Assert(m_pOCS);

    if (m_pOCS)
    {
        hresult = m_pOCS->GetMoniker(dwAssign, dwWhichMoniker,ppmk);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CClientSiteHandler::GetMoniker hr=%lx\n", this,  hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClientSiteHandler::SaveObject
//
//  Synopsis:   delegates call on to appropriate OleClientSite
//
//  Arguments:  [dwId] -- id of the OleClientSite the call should be delegate too
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientSiteHandler::SaveObject( )
{
HRESULT hresult = E_FAIL;

    VDATEHEAP();
    LEDebugOut((DEB_TRACE, "%p _IN CClientSiteHandler::SaveObject\n", this));

    Win4Assert(m_pOCS);

    if (m_pOCS)
    {
        hresult = m_pOCS->SaveObject();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CClientSiteHandler::SaveObject hr=%lx\n", this,  hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClientSiteHandler::ShowObject
//
//  Synopsis:   delegates call on to appropriate OleClientSite
//
//  Arguments:  [dwId] -- id of the OleClientSite the call should be delegate too
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientSiteHandler::ShowObject()
{
HRESULT hresult = E_FAIL;

    VDATEHEAP();
    LEDebugOut((DEB_TRACE, "%p _IN CClientSiteHandler::ShowObject\n", this));

    Win4Assert(m_pOCS);

    if (m_pOCS)
    {
        hresult = m_pOCS->ShowObject();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CClientSiteHandler::ShowObject hr=%lx\n", this,  hresult));
    return hresult;
}


//
// IOleInPlaceSite methods
//

//+---------------------------------------------------------------------------
//
//  Method:     CClientSiteHandler::GetWindow
//
//  Synopsis:   delegates call on to OleInPlaceSite
//
//  Arguments:  [phwnd] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientSiteHandler::GetWindow( HWND *phwnd)
{
HRESULT hresult = E_FAIL;

    VDATEHEAP();
    LEDebugOut((DEB_TRACE, "%p _IN CClientSiteHandler::GetWindow\n", this));

    Win4Assert(m_pOIPS);

    if (m_pOIPS)
    {
        hresult = m_pOIPS->GetWindow(phwnd);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CClientSiteHandler::GetWindow hr=%lx\n", this,  hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClientSiteHandler::ContextSensitiveHelp
//
//  Synopsis:   delegates call on to OleInPlaceSite
//
//  Arguments:  [fEnterMode] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientSiteHandler::ContextSensitiveHelp(BOOL fEnterMode)
{
HRESULT hresult = E_FAIL;

    VDATEHEAP();
    LEDebugOut((DEB_TRACE, "%p _IN CClientSiteHandler::ContextSensitiveHelp\n", this));

    Win4Assert(m_pOIPS);

    if (m_pOIPS)
    {
        hresult = m_pOIPS->ContextSensitiveHelp(fEnterMode);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CClientSiteHandler::ContextSensitiveHelp hr=%lx\n", this,  hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClientSiteHandler::CanInPlaceActivate
//
//  Synopsis:   delegates call on to OleInPlaceSite
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientSiteHandler::CanInPlaceActivate(void)
{
HRESULT hresult = E_FAIL;

    VDATEHEAP();
    LEDebugOut((DEB_TRACE, "%p _IN CClientSiteHandler::CanInPlaceActivate\n", this));

    Win4Assert(m_pOIPS);

    if (m_pOIPS)
    {
        hresult = m_pOIPS->CanInPlaceActivate();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CClientSiteHandler::CanInPlaceActivate hr=%lx\n", this,  hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClientSiteHandler::OnInPlaceActivate
//
//  Synopsis:   delegates call on to OleInPlaceSite
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientSiteHandler::OnInPlaceActivate(void)
{
HRESULT hresult = E_FAIL;

    VDATEHEAP();
    LEDebugOut((DEB_TRACE, "%p _IN CClientSiteHandler::OnInPlaceActivate\n", this));

    Win4Assert(m_pOIPS);

    if (m_pOIPS)
    {
        hresult = m_pOIPS->OnInPlaceActivate();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CClientSiteHandler::OnInPlaceActivate hr=%lx\n", this,  hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClientSiteHandler::OnUIActivate
//
//  Synopsis:   delegates call on to OleInPlaceSite
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientSiteHandler::OnUIActivate(void)
{
HRESULT hresult = E_FAIL;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CClientSiteHandler::OnUIActivate\n", this));
    Win4Assert(m_pOIPS);

    if (m_pOIPS)
    {
        hresult = m_pOIPS->OnUIActivate();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CClientSiteHandler::OnUIActivate hr=%lx\n", this,  hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClientSiteHandler::GetWindowContext
//
//  Synopsis:   delegates call on to OleInPlaceSite
//
//  Arguments:  [ppFrame] --
//              [ppDoc] --
//              [lprcPosRect] --
//              [lprcClipRect] --
//              [lpFrameInfo] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientSiteHandler::GetWindowContext(IOleInPlaceFrame **ppFrame,
                                                        IOleInPlaceUIWindow  * *ppDoc, LPRECT lprcPosRect,
                                                        LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
HRESULT hresult = E_FAIL;

    VDATEHEAP();
    LEDebugOut((DEB_TRACE, "%p _IN CClientSiteHandler::GetWindowContext\n", this));

    Win4Assert(m_pOIPS);

    if (m_pOIPS)
    {
       hresult = m_pOIPS->GetWindowContext(ppFrame, ppDoc, lprcPosRect, lprcClipRect, lpFrameInfo);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CClientSiteHandler::GetWindowContext hr=%lx\n", this,  hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClientSiteHandler::Scroll
//
//  Synopsis:   delegates call on to OleInPlaceSite
//
//  Arguments:  [scrollExtant] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientSiteHandler::Scroll(SIZE scrollExtant)
{
HRESULT hresult = E_FAIL;

    VDATEHEAP();
    LEDebugOut((DEB_TRACE, "%p _IN CClientSiteHandler::Scroll\n", this));

    Win4Assert(m_pOIPS);

    if (m_pOIPS)
    {
        hresult = m_pOIPS->Scroll(scrollExtant);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CClientSiteHandler::Scroll hr=%lx\n", this,  hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClientSiteHandler::OnUIDeactivate
//
//  Synopsis:   delegates call on to OleInPlaceSite
//
//  Arguments:  [fUndoable] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientSiteHandler::OnUIDeactivate(BOOL fUndoable)
{
HRESULT hresult = E_FAIL;

    VDATEHEAP();
    LEDebugOut((DEB_TRACE, "%p _IN CClientSiteHandler::OnUIDeactivate\n", this));

    Win4Assert(m_pOIPS);

    if (m_pOIPS)
    {
        hresult = m_pOIPS->OnUIDeactivate(fUndoable);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CClientSiteHandler::OnUIDeactivate hr=%lx\n", this,  hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClientSiteHandler::OnInPlaceDeactivate
//
//  Synopsis:   delegates call on to OleInPlaceSite
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientSiteHandler::OnInPlaceDeactivate( void)
{
HRESULT hresult = E_FAIL;

    VDATEHEAP();
    LEDebugOut((DEB_TRACE, "%p _IN CClientSiteHandler::OnInPlaceDeactivate\n", this));

    Win4Assert(m_pOIPS);

    if (m_pOIPS)
    {
        hresult = m_pOIPS->OnInPlaceDeactivate();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CClientSiteHandler::OnInPlaceDeactivate hr=%lx\n", this,  hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClientSiteHandler::DiscardUndoState
//
//  Synopsis:   delegates call on to OleInPlaceSite
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientSiteHandler::DiscardUndoState(void)
{
HRESULT hresult = E_FAIL;

    VDATEHEAP();
    LEDebugOut((DEB_TRACE, "%p _IN CClientSiteHandler::DiscardUndoState\n", this));

    Win4Assert(m_pOIPS);

    if (m_pOIPS)
    {
        hresult = m_pOIPS->DiscardUndoState();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CClientSiteHandler::DiscardUndoState hr=%lx\n", this,  hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClientSiteHandler::DeactivateAndUndo
//
//  Synopsis:   delegates call on to OleInPlaceSite
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientSiteHandler::DeactivateAndUndo(void)
{
HRESULT hresult = E_FAIL;

    VDATEHEAP();
    LEDebugOut((DEB_TRACE, "%p _IN CClientSiteHandler::DeactivateAndUndo\n", this));

    Win4Assert(m_pOIPS);

    if (m_pOIPS)
    {
        hresult = m_pOIPS->DeactivateAndUndo();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CClientSiteHandler::DeactivateAndUndo hr=%lx\n", this,  hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClientSiteHandler::OnPosRectChange
//
//  Synopsis:   delegates call on to OleInPlaceSite
//
//  Arguments:  [lprcPosRect] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientSiteHandler::OnPosRectChange(LPCRECT lprcPosRect)
{
HRESULT hresult = E_FAIL;

    VDATEHEAP();
    LEDebugOut((DEB_TRACE, "%p _IN CClientSiteHandler::OnPosRectChange\n", this));

    Win4Assert(m_pOIPS);

    if (m_pOIPS)
    {
        hresult = m_pOIPS->OnPosRectChange(lprcPosRect);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CClientSiteHandler::OnPosRectChange hr=%lx\n", this,  hresult));
    return hresult;
}

//
// ClientSiteHandler methods
//
//+---------------------------------------------------------------------------
//
//  Method:     CClientSiteHandler::GoInPlaceActivate
//
//  Synopsis:   called by the serverhandler when going inplace
//
//  Arguments:  [phwndOIPS] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientSiteHandler::GoInPlaceActivate(HWND *phwndOIPS)
{
HRESULT hresult = E_FAIL;

    VDATEHEAP();
    LEDebugOut((DEB_TRACE, "%p _IN CClientSiteHandler::GoInPlaceActivate\n", this));

    Win4Assert(m_pOIPS);

        *phwndOIPS = NULL;

        if (m_pOIPS)
        {
            // 1. OnInPlaceActivate
            hresult = m_pOIPS->OnInPlaceActivate();

            // 2. Get the Site Window, not an error if this fails
            if (SUCCEEDED(hresult))
            {
                if (NOERROR != m_pOIPS->GetWindow(phwndOIPS))
                {
                        *phwndOIPS = NULL;
                }
            }
         }

    LEDebugOut((DEB_TRACE, "%p OUT CClientSiteHandler::GoInPlaceActivate\n", this));
    return hresult;
}


// ClientSiteHandler on ServerSide

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::CEmbServerClientSite
//
//  Synopsis:   Constructor
//
//  Arguments:
//              pStdId - Pointer to StandardIdentity for Object
//
//  Returns:
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CEmbServerClientSite::CEmbServerClientSite (IUnknown *pUnkOuter)
{
    VDATEHEAP();

    if (!pUnkOuter)
    {
        pUnkOuter = &m_Unknown;
    }

    m_pUnkOuter  = pUnkOuter;

    m_pClientSiteHandler = NULL;
    m_cRefs = 1;
    m_pUnkInternal = NULL;
    m_hwndOIPS = NULL;

    m_Unknown.m_EmbServerClientSite = this;
    m_fInDelete = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::Initialize
//
//  Synopsis:   Initialize the ClientSiteHandler
//
//  Arguments:
//              objref - objref to be unmarshaled
//              fHasIPSite - Indicates if ClientSite should support IOleInPlaceSite
//
//  Returns:
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CEmbServerClientSite::Initialize(OBJREF objref,BOOL fHasIPSite)
{
HRESULT hr = E_OUTOFMEMORY;
CStdIdentity *pStdId;
BOOL fSuccess = FALSE;

    // Need to create a Standard Identity Handler
    // as the controlling Unknown, then unmarshal pIRDClientsite
    // into it.

    // This code relies on the premise that this is the first time the
    // interface has been unmarshaled which is checked for on the Container Side

    m_fHasIPSite = fHasIPSite;

    pStdId = new CStdIdentity(STDID_CLIENT,
                              GetCurrentApartmentId(),
                              m_pUnkOuter,
                              NULL, &m_pUnkInternal, &fSuccess);

    if (pStdId && fSuccess == FALSE)
    {
    	delete pStdId;
    	pStdId = NULL;
    }
    
    if (pStdId)
    {
        LPUNKNOWN pObjRefInterface = NULL;

        Win4Assert(IsEqualIID(objref.iid, IID_IClientSiteHandler));

        hr = pStdId->UnmarshalObjRef(objref, (void **)&m_pClientSiteHandler);
        if (NOERROR == hr)
        {
            m_pUnkOuter->Release(); // Release ref from UnMarshal
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::SetDoVerbState
//
//  Synopsis:   Informs ClientSiteHandler if a DoVerb is in progress
//
//  Arguments:
//
//  Returns:
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CEmbServerClientSite::SetDoVerbState(BOOL fDoVerbState)
{
    m_fInDoVerb = fDoVerbState ? TRUE: FALSE;

    if (!m_fInDoVerb)
    {
        // reset any data the is Cached while in a DoVerb.
        m_hwndOIPS = NULL;
    }

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::~CEmbServerClientSite
//
//  Synopsis:   Destructor
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CEmbServerClientSite::~CEmbServerClientSite()
{
    Win4Assert(NULL == m_pClientSiteHandler);
    Win4Assert(NULL == m_pUnkInternal);
    Win4Assert(TRUE == m_fInDelete);
}


//
// Controlling Uknown
//
//

//+-------------------------------------------------------------------------
//
//  Member:     CEmbServerClientSite::CPrivUnknown::QueryInterface
//
//  Synopsis:   Returns a pointer to one of the supported interfaces.
//
//  Effects:
//
//  Arguments:  [iid]           -- the requested interface ID
//              [ppv]           -- where to put the iface pointer
//
//  Requires:
//
//  Returns:    HRESULT
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CEmbServerClientSite::CPrivUnknown::QueryInterface(REFIID iid,
    LPLPVOID ppv)
{
HRESULT         hresult;

    VDATEHEAP();

    Win4Assert(m_EmbServerClientSite);

    LEDebugOut((DEB_TRACE,
        "%p _IN CDefObject::CUnknownImpl::QueryInterface "
        "( %p , %p )\n", m_EmbServerClientSite, iid, ppv));

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (void FAR *)this;
    }
    else if (IsEqualIID(iid, IID_IOleClientSite))
    {
        *ppv = (void FAR *)(IOleClientSite *) m_EmbServerClientSite;
    }
    else if (IsEqualIID(iid, IID_IOleInPlaceSite) && (m_EmbServerClientSite->m_fHasIPSite))
    {
        *ppv = (void FAR *)(IOleInPlaceSite *) m_EmbServerClientSite;
    }
    else if(m_EmbServerClientSite->m_pUnkInternal)
    {

        hresult = m_EmbServerClientSite->m_pUnkInternal->QueryInterface(iid,(void **) ppv);


        LEDebugOut((DEB_TRACE,
            "%p OUT CDefObject::CUnknownImpl::QueryInterface "
            "( %lx ) [ %p ]\n", m_EmbServerClientSite, hresult,
            (ppv) ? *ppv : 0 ));

        return hresult;
    }
    else
    {
        // Don't have a ClientSite.
        *ppv = NULL;

        LEDebugOut((DEB_TRACE,
            "%p OUT CDefObject::CUnkownImpl::QueryInterface "
            "( %lx ) [ %p ]\n", m_EmbServerClientSite, CO_E_OBJNOTCONNECTED,
            0 ));

        return E_NOINTERFACE;
    }

    // this indirection is important since there are different
    // implementationsof AddRef (this unk and the others).
    ((IUnknown FAR*) *ppv)->AddRef();

    LEDebugOut((DEB_TRACE,
        "%p OUT CDefObject::CUnknownImpl::QueryInterface "
        "( %lx ) [ %p ]\n", m_EmbServerClientSite, NOERROR, *ppv));

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEmbServerClientSite::CPrivUnknown::AddRef
//
//  Synopsis:   Increments the reference count.
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG (the new reference count)
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEmbServerClientSite::CPrivUnknown::AddRef( void )
{
ULONG cRefs;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::CPrivUnknown::AddRef "
        "( )\n", m_EmbServerClientSite));


    Win4Assert(m_EmbServerClientSite);

    cRefs = InterlockedIncrement((long *) &(m_EmbServerClientSite->m_cRefs));

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::CPrivUnknown::AddRef "
        "( %lu )\n", m_EmbServerClientSite, m_EmbServerClientSite->m_cRefs));

    return cRefs;

}

//+-------------------------------------------------------------------------
//
//  Member:     CEmbServerClientSite::CPrivUnknown::Release
//
//  Synopsis:   Decrements the ref count, cleaning up and deleting the
//              object if necessary
//
//  Effects:    May delete the object (and potentially objects to which the
//              handler has pointer)
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG--the new ref count
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEmbServerClientSite::CPrivUnknown::Release(void)
{
ULONG refcount;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::CPrivUnknown::Release "
        "( )\n", m_EmbServerClientSite));

    Win4Assert(m_EmbServerClientSite);

    refcount = InterlockedDecrement((long *) &(m_EmbServerClientSite->m_cRefs));

    // TODO: not thread safe.
    if (0 == refcount && !(m_EmbServerClientSite->m_fInDelete))
    {
        m_EmbServerClientSite->m_fInDelete = TRUE;

        if (m_EmbServerClientSite->m_pClientSiteHandler)
        {
        LPUNKNOWN lpUnkForSafeRelease = m_EmbServerClientSite->m_pClientSiteHandler;

            m_EmbServerClientSite->m_pClientSiteHandler = NULL;
            m_EmbServerClientSite->m_pUnkOuter->AddRef();
            lpUnkForSafeRelease->Release();

        }

        if (m_EmbServerClientSite->m_pUnkInternal)
        {
        LPUNKNOWN pUnkSafeRelease;

            pUnkSafeRelease = m_EmbServerClientSite->m_pUnkInternal;
            m_EmbServerClientSite->m_pUnkInternal = NULL;
            pUnkSafeRelease->Release();
        }

        delete m_EmbServerClientSite;

    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::CPrivUnknown::Release "
        "( %lu )\n", m_EmbServerClientSite, refcount));

    return refcount;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppv] --
//
//  Returns:
//
//  History:    9-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP  CEmbServerClientSite::QueryInterface( REFIID riid, void **ppv )
{
HRESULT hresult = E_NOINTERFACE;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::QueryInterface ( %lx , "
        "%p )\n", this, riid, ppv));

    Win4Assert(m_pUnkOuter);

    hresult = m_pUnkOuter->QueryInterface(riid, ppv);

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::QueryInterface ( %lx ) "
        "[ %p ]\n", this, hresult, *ppv));

    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::AddRef
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    9-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEmbServerClientSite::AddRef( void )
{
    ULONG       crefs;;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::AddRef ( )\n", this));

    Assert(m_pUnkOuter);

    crefs = m_pUnkOuter->AddRef();

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::AddRef ( %ld ) ", this,
        crefs));

    return crefs;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::Release
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    9-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEmbServerClientSite::Release( void )
{
ULONG crefs;;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::Release ( )\n", this));

    Assert(m_pUnkOuter);

    crefs = m_pUnkOuter->Release();

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::Release ( %ld ) ", this,
        crefs));

    return crefs;
}


//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::GetContainer
//
//  Synopsis:
//
//  Arguments:  [ppContainer] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEmbServerClientSite::GetContainer(IOleContainer **ppContainer)
{
HRESULT hresult = E_FAIL;

    LEDebugOut((DEB_TRACE, "%p _IN CEmbServerClientSite::COleClientSiteImplGetContainer\n", this));
    Win4Assert(m_pClientSiteHandler);

    if (m_pClientSiteHandler)
    {
        hresult = m_pClientSiteHandler->GetContainer(ppContainer);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CEmbServerClientSite::COleClientSiteImplGetContainer  return %lx\n", this, hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::ShowObject
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEmbServerClientSite::ShowObject( void)
{
HRESULT hresult = E_FAIL;

    LEDebugOut((DEB_TRACE, "%p _IN CEmbServerClientSite::COleClientSiteImplShowObject\n", this));
    Win4Assert(m_pClientSiteHandler);

    if (m_pClientSiteHandler)
    {
        hresult = m_pClientSiteHandler->ShowObject();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CEmbServerClientSite::COleClientSiteImplShowObject  return %lx\n", this, hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::COleClientSiteImplOnShowWindow
//
//  Synopsis:
//
//  Arguments:  [fShow] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEmbServerClientSite::OnShowWindow(BOOL fShow)
{
HRESULT hresult = E_FAIL;

    LEDebugOut((DEB_TRACE, "%p _IN CEmbServerClientSite::COleClientSiteImplOnShowWindow\n", this));
    Win4Assert(m_pClientSiteHandler);

    if (m_pClientSiteHandler)
    {
        hresult = m_pClientSiteHandler->OnShowWindow(fShow);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CEmbServerClientSite::COleClientSiteImplOnShowWindow  return %lx\n", this, hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::COleClientSiteImplRequestNewObjectLayout
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEmbServerClientSite::RequestNewObjectLayout(void)
{
HRESULT hresult = E_FAIL;

    LEDebugOut((DEB_TRACE, "%p _IN CEmbServerClientSite::COleClientSiteImplRequestNewObjectLayout\n", this));
    Win4Assert(m_pClientSiteHandler);

    if (m_pClientSiteHandler)
    {
        hresult = m_pClientSiteHandler->RequestNewObjectLayout();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CEmbServerClientSite::COleClientSiteImplRequestNewObjectLayout return %lx\n", this, hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::COleClientSiteImplSaveObject
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEmbServerClientSite::SaveObject(void)
{
HRESULT hresult = E_FAIL;

    LEDebugOut((DEB_TRACE, "%p _IN CEmbServerClientSite::COleClientSiteImplSaveObject\n", this));
    Win4Assert(m_pClientSiteHandler);

    if (m_pClientSiteHandler)
    {
        hresult = m_pClientSiteHandler->SaveObject();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CEmbServerClientSite::COleClientSiteImplSaveObject return %lx\n", this, hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::COleClientSiteImplGetMoniker
//
//  Synopsis:
//
//  Arguments:  [dwAssign] --
//              [dwWhichMoniker] --
//              [ppmk] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEmbServerClientSite::GetMoniker(DWORD dwAssign,DWORD dwWhichMoniker,IMoniker **ppmk)
{
HRESULT hresult = E_FAIL;

    LEDebugOut((DEB_TRACE, "%p _IN CEmbServerClientSite::COleClientSiteImplGetMoniker\n", this));
    Win4Assert(m_pClientSiteHandler);

    if (m_pClientSiteHandler)
    {
        hresult = m_pClientSiteHandler->GetMoniker(dwAssign, dwWhichMoniker, ppmk);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CEmbServerClientSite::COleClientSiteImplGetMoniker  return %lx\n", this, hresult));
    return hresult;
}


// IOleWindow Methods
//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::GetWindow
//
//  Synopsis:
//
//  Arguments:  [phwnd] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CEmbServerClientSite::GetWindow(HWND *phwnd)
{
HRESULT hresult = NOERROR;

    LEDebugOut((DEB_TRACE, "%p _IN CEmbServerClientSite::GetWindow\n", this));

    *phwnd = NULL;

    if ( m_fInDoVerb && m_hwndOIPS )
    {
        *phwnd = m_hwndOIPS;
    }
    else
    {
        Win4Assert(m_pClientSiteHandler);

        if (m_pClientSiteHandler)
        {
            hresult = m_pClientSiteHandler->GetWindow(phwnd);
        }
        else
        {
            hresult = E_FAIL;
        }

        if (NOERROR == hresult)
        {
            m_hwndOIPS = *phwnd;
        }

    }

    LEDebugOut((DEB_TRACE, "%p OUT CEmbServerClientSite::COleCInPlaceSiteImpl::GetWindow  return %lx\n", this, hresult));
    return hresult;
}

//
// IOleInPlaceSite Methods
//

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::ContextSensitiveHelp
//
//  Synopsis:
//
//  Arguments:  [fEnterMode] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEmbServerClientSite::ContextSensitiveHelp(BOOL fEnterMode)
{
HRESULT hresult = E_FAIL;

    LEDebugOut((DEB_TRACE, "%p _IN CEmbServerClientSite::COleCInPlaceSiteImpl::ContextSensitiveHelp\n", this));
    Win4Assert(m_pClientSiteHandler);

    if (m_pClientSiteHandler)
    {
        hresult = m_pClientSiteHandler->ContextSensitiveHelp(fEnterMode);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CEmbServerClientSite::COleCInPlaceSiteImpl::ContextSensitiveHelp  return %lx\n", this, hresult));
    return hresult;
}


//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::CanInPlaceActivate
//
//  Synopsis:
//
//  Arguments:  [] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CEmbServerClientSite::CanInPlaceActivate( void)
{
HRESULT hresult = E_FAIL;

    LEDebugOut((DEB_TRACE, "%p _IN CEmbServerClientSite::CanInPlaceActivate\n", this));
        Win4Assert(m_pClientSiteHandler);

    if (m_pClientSiteHandler)
    {
        hresult = m_pClientSiteHandler->CanInPlaceActivate();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CEmbServerClientSite::CanInPlaceActivate  return %lx\n", this, hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::OnInPlaceActivate
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEmbServerClientSite::OnInPlaceActivate( void)
{
HRESULT hresult = E_FAIL;

    LEDebugOut((DEB_TRACE, "%p _IN CEmbServerClientSite::OnInPlaceActivate\n", this));
    Win4Assert(m_pClientSiteHandler);

    if (m_pClientSiteHandler)
    {
        if (m_fInDoVerb )
        {
            // call back to client site
            hresult = m_pClientSiteHandler->GoInPlaceActivate(&m_hwndOIPS);

            if (FAILED(hresult))
            {
                // on failure make sure out params for caching are NULL;
                m_hwndOIPS = NULL;
            }

        }
        else
        {
            hresult = m_pClientSiteHandler->OnInPlaceActivate();
        }
    }

    LEDebugOut((DEB_TRACE, "%p OUT CEmbServerClientSite::OnInPlaceActivate  return %lx\n", this, hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::OnUIActivate
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEmbServerClientSite::OnUIActivate( void)
{
HRESULT hresult = E_FAIL;

    LEDebugOut((DEB_TRACE, "%p _IN CEmbServerClientSite::OnUIActivate\n", this));
    Win4Assert(m_pClientSiteHandler);

    if (m_pClientSiteHandler)
    {
        hresult = m_pClientSiteHandler->OnUIActivate();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CEmbServerClientSite::OnUIActivate  return %lx\n", this, hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::GetWindowContext
//
//  Synopsis:
//
//  Arguments:  [ppFrame] --
//              [ppDoc] --
//              [lprcPosRect] --
//              [lprcClipRect] --
//              [lpFrameInfo] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEmbServerClientSite::GetWindowContext(IOleInPlaceFrame **ppFrame,
                              IOleInPlaceUIWindow **ppDoc,LPRECT lprcPosRect,LPRECT lprcClipRect,
                              LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
HRESULT hresult = E_FAIL;

    LEDebugOut((DEB_TRACE, "%p _IN CEmbServerClientSite::GetWindowContext\n", this));
    Win4Assert(m_pClientSiteHandler);

    if (m_pClientSiteHandler)
    {
        hresult = m_pClientSiteHandler->GetWindowContext(ppFrame, ppDoc,lprcPosRect, lprcClipRect, lpFrameInfo);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CEmbServerClientSite::GetWindowContext  return %lx\n", this, hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::Scroll
//
//  Synopsis:
//
//  Arguments:  [scrollExtant] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEmbServerClientSite::Scroll(SIZE scrollExtant)
{
HRESULT hresult = E_FAIL;

    LEDebugOut((DEB_TRACE, "%p _IN CEmbServerClientSite::Scroll\n", this));
    Win4Assert(m_pClientSiteHandler);

    if (m_pClientSiteHandler)
    {
        hresult = m_pClientSiteHandler->Scroll(scrollExtant);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CEmbServerClientSite::Scroll  return %lx\n", this, hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::OnUIDeactivate
//
//  Synopsis:
//
//  Arguments:  [fUndoable] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEmbServerClientSite::OnUIDeactivate(BOOL fUndoable)
{
HRESULT hresult = E_FAIL;

    LEDebugOut((DEB_TRACE, "%p _IN CEmbServerClientSite::OnUIDeactivate\n", this));
    Win4Assert(m_pClientSiteHandler);

    if (m_pClientSiteHandler)
    {
        hresult = m_pClientSiteHandler->OnUIDeactivate(fUndoable);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CEmbServerClientSite::OnUIDeactivate  return %lx\n", this, hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::OnInPlaceDeactivate
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEmbServerClientSite::OnInPlaceDeactivate(void)
{
HRESULT hresult = E_FAIL;

    LEDebugOut((DEB_TRACE, "%p _IN CEmbServerClientSite::OnInPlaceDeactivate\n", this));
    Win4Assert(m_pClientSiteHandler);

    if (m_pClientSiteHandler)
    {
        hresult = m_pClientSiteHandler->OnInPlaceDeactivate();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CEmbServerClientSite::OnInPlaceDeactivate  return %lx\n", this, hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::DiscardUndoState
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEmbServerClientSite::DiscardUndoState(void)
{
HRESULT hresult = E_FAIL;

    LEDebugOut((DEB_TRACE, "%p _IN CEmbServerClientSite::DiscardUndoState\n", this));
    Win4Assert(m_pClientSiteHandler);

    if (m_pClientSiteHandler)
    {
        hresult = m_pClientSiteHandler->DiscardUndoState();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CEmbServerClientSite::DiscardUndoState  return %lx\n", this, hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::DeactivateAndUndo
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEmbServerClientSite::DeactivateAndUndo(void)
{
HRESULT hresult = E_FAIL;

    LEDebugOut((DEB_TRACE, "%p _IN CEmbServerClientSite::DeactivateAndUndo\n", this));
    Win4Assert(m_pClientSiteHandler);

    if (m_pClientSiteHandler)
    {
        hresult = m_pClientSiteHandler->DeactivateAndUndo();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CEmbServerClientSite::DeactivateAndUndo  return %lx\n", this, hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::OnPosRectChange
//
//  Synopsis:
//
//  Arguments:  [lprcPosRect] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEmbServerClientSite::OnPosRectChange(LPCRECT lprcPosRect)
{
HRESULT hresult = E_FAIL;

    LEDebugOut((DEB_TRACE, "%p _IN CEmbServerClientSite::OnPosRectChange\n", this));
    Win4Assert(m_pClientSiteHandler);

    if (m_pClientSiteHandler)
    {
        hresult = m_pClientSiteHandler->OnPosRectChange(lprcPosRect);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CEmbServerClientSite::OnPosRectChange  return %lx\n", this, hresult));
    return hresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\stdimpl\defcf.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       defcf.h
//
//  Contents:   class factory for def handler and def link
//
//  Classes:    CDefClassFactory
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-95 t-ScottH  created - transfer CDefClassFactory
//                                  definition into header file from cpp file
//
//--------------------------------------------------------------------------
#ifndef _DEFCF_H_
#define _DEFCF_H_

#include <stdcf.hxx>

#ifdef _DEBUG
#include <dbgexts.h>
#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Class:      CDefClassFactory
//
//  Purpose:    The class factory for the default handler and default link
//
//  Interface:  IClassFactory
//
//  History:    dd-mmm-yy Author    Comment
//              09-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------
class FAR CDefClassFactory : public CStdClassFactory, public CPrivAlloc
{
public:
        CDefClassFactory (REFCLSID clsidClass);
        STDMETHOD(CreateInstance) (LPUNKNOWN pUnkOuter, REFIID iid,
                                   LPVOID FAR* ppv);

    #ifdef _DEBUG
        HRESULT Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel);
    #endif // _DEBUG

private:
        CLSID           m_clsid;
        SET_A5;
};

#endif // _DEFCF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\stdimpl\defcf.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       defcf.cpp
//
//  Contents:   The class factory implementations for the default handler
//              and default link
//
//  Classes:    CDefClassFactory
//
//  Functions:  DllGetClassObject
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  added Dump method to CDefClassFactory
//                                  and DumpCDefClassFactory API
//              24-Jan-94 alexgo    first pass converting to Cairo style
//                                  memory allocation
//              11-Jan-94 alexgo    made custom memory stream unmarshalling
//                                  for 16bit only.
//              11-Jan-94 alexgo    added VDATEHEAP macro to every function
//                                  and method
//              22-Nov-93 alexgo    removed overload GUID ==
//              09-Nov-93 alexgo    32bit port
//              04-Mar-92 SriniK    author
//
//--------------------------------------------------------------------------

#include <le2int.h>
#pragma SEG(deflink)

#include <create.h>
#include "defcf.h"

#ifdef _DEBUG
#include <dbgdump.h>
#endif // _DEBUG

NAME_SEG(DefLink)
ASSERTDATA

#ifdef _MAC
// These global class decl's are necessary for CFront because both
// defhndlr.h and deflink.h have nested class's of the same name.
// These decl's allow this.

class CDataObjectImpl  {
        VDATEHEAP();
};
class COleObjectImpl  {};
class CManagerImpl  {};
class CAdvSinkImpl  {};
class CPersistStgImpl  {};

#endif

#include "olerem.h"
#include "defhndlr.h"
#include "deflink.h"


//+-------------------------------------------------------------------------
//
//  Function:   Ole32DllGetClassObject
//
//  Synopsis:   Returns a pointer to the class factory
//
//  Effects:
//
//  Arguments:  [clsid] -- the class id desired
//              [iid]   -- the requested interface
//              [ppv]   -- where to put the pointer to the new object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              09-Nov-93 alexgo    32bit port
//              22-Nov-93 alexgo    removed overloaded GUID ==
//
//  Notes:
//
//--------------------------------------------------------------------------
#pragma SEG(DllGetClassObject)
#ifdef WIN32
HRESULT Ole232DllGetClassObject(REFCLSID clsid, REFIID iid, void FAR* FAR* ppv)
#else
STDAPI  DllGetClassObject(REFCLSID clsid, REFIID iid, void FAR* FAR* ppv)
#endif // WIN32
{
        VDATEHEAP();
        VDATEIID( iid );
        VDATEPTROUT(ppv, LPVOID);
        *ppv = NULL;

        if ( !IsEqualIID(iid,IID_IUnknown) && !IsEqualIID(iid,
                IID_IClassFactory))
        {
                return ResultFromScode(E_NOINTERFACE);
        }

        if ((*ppv = new CDefClassFactory (clsid)) == NULL)
        {
                return ResultFromScode(E_OUTOFMEMORY);
        }

        return NOERROR;
}

/*
 *      IMPLEMENTATION of CDefClassFactory
 *
 */

//+-------------------------------------------------------------------------
//
//  Member:     CDefClassFactory::CDefClassFactory
//
//  Synopsis:   constructor for the class factory
//
//  Effects:
//
//  Arguments:  [clsidClass]    -- the class id for the the factory
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              09-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------
#pragma SEG(CDefClassFactory_ctor)
CDefClassFactory::CDefClassFactory (REFCLSID clsidClass)
    : CStdClassFactory(1), m_clsid(clsidClass)
{
        VDATEHEAP();
        GET_A5();
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefClassFactory::CreateInstance
//
//  Synopsis:   Creates an instance of the class that the class factory
//              was created for (by Ole32DllGetClassObject)
//
//  Effects:
//
//  Arguments:  [pUnkOuter]     -- the controlling unknown (for aggregation)
//              [iid]           -- the requested interface ID
//              [ppv]           -- where to put the pointer to the new object
//
//  Requires:
//
//  Returns:    HRESULT.  E_INVALIDARG is returned if an non-null pUnkOuter
//              is passed when asked to create a moniker.
//
//  Derivation: IClassFactory
//
//  Algorithm:  Tests the classid against a number of predefined ones, doing
//              appropriate tests and actions for each (see comments below).
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-94 alexgo    ifdef'ed out code to deal with
//                                  custom marshalling of memory streams
//                                  and lockbytes (it's 16bit only)
//              12-Nov-93 alexgo    removed  IID check's for monikers
//                                  (see notes below)
//              12-Nov-93 alexgo    removed a goto and more redundant code
//                                  changed overloaded == to IsEqualCLSID
//              11-Nov-93 alexgo    32bit port
//
//--------------------------------------------------------------------------
#pragma SEG(CDefClassFactory_CreateInstance)
STDMETHODIMP CDefClassFactory::CreateInstance
        (IUnknown FAR* pUnkOuter, REFIID iid, void FAR* FAR* ppv)
{
        VDATEHEAP();
        M_PROLOG(this);
        VDATEIID( iid );
        VDATEPTROUT( ppv, LPVOID );
        *ppv = NULL;

        if ( pUnkOuter )
        {
            VDATEIFACE( pUnkOuter );
        }

        HRESULT  hresult = E_OUTOFMEMORY;
        IUnknown *pUnk;

        if (IsEqualCLSID(m_clsid, CLSID_StdOleLink))
        {
            pUnk = CDefLink::Create(pUnkOuter);
        }
        else
        {
            pUnk = CDefObject::Create(pUnkOuter, m_clsid,
                        EMBDHLP_INPROC_HANDLER | EMBDHLP_CREATENOW, NULL);
        }

        if ( pUnk != NULL )
        {
            //if we get this far, then everything is OK; we have successfully
            //created default handler or default link. now QueryInterface and return

            hresult = pUnk->QueryInterface(iid, ppv);
            //The QI will add a ref, plus the ref from Create, so
            //we need to release one.
            pUnk->Release();
        }

        return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefClassFactory::Dump, public (_DEBUG only)
//
//  Synopsis:   return a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [ppszDump]      - an out pointer to a null terminated character array
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   [ppszDump]  - argument
//
//  Derivation:
//
//  Algorithm:  use dbgstream to create a string containing information on the
//              content of data structures
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

HRESULT CDefClassFactory::Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    char *pszCLSID;
    dbgstream dstrPrefix;
    dbgstream dstrDump;

    // determine prefix of newlines
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << this << " _VB ";
    }

    // determine indentation prefix for all newlines
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    pszCLSID = DumpCLSID(m_clsid);
    dstrDump << pszPrefix << "CLSID                 = " << pszCLSID << endl;
    CoTaskMemFree(pszCLSID);

    // cleanup and provide pointer to character array
    *ppszDump = dstrDump.str();

    if (*ppszDump == NULL)
    {
        *ppszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return NOERROR;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCDefClassFactory, public (_DEBUG only)
//
//  Synopsis:   calls the CDefClassFactory::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pCDF]          - pointer to CDefClassFactory
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCDefClassFactory(CDefClassFactory *pCDF, ULONG ulFlag, int nIndentLevel)
{
    HRESULT hresult;
    char *pszDump;

    if (pCDF == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    hresult = pCDF->Dump(&pszDump, ulFlag, nIndentLevel);

    if (hresult != NOERROR)
    {
        CoTaskMemFree(pszDump);

        return DumpHRESULT(hresult);
    }

    return pszDump;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\stdimpl\defhndlr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       defhndlr.cpp
//
//  Contents:   Implementation of the default handler
//
//  Classes:    CDefObject (see defhndlr.h)
//
//  Functions:  OleCreateDefaultHandler
//              OleCreateEmbeddingHelper
//
//
//  History:    dd-mmm-yy Author    Comment
//
//              11-17-95  JohannP   (Johann Posch)  Architectural change:
//                                  Default handler will talk to a handler object
//                                  on the server site (ServerHandler). The serverhandler
//                                  communicates with the default handler via the
//                                  clientsitehandler. See document: "The Ole Server Handler".
//
//              06-Sep-95 davidwor  modified SetHostNames to avoid atoms
//              01-Feb-95 t-ScottH  add Dump method to CDefObject
//                                  add DumpCDefObject API
//                                  add DHFlag to indicate aggregation
//                                  initialize m_cConnections in constructor
//              09-Jan-95 t-scotth  changed VDATETHREAD to accept a pointer
//              15-Nov-94 alexgo    optimized, removed excess BOOLS and
//                                  now use multiple inheritance
//              01-Aug-94 alexgo    added object stabilization
//              16-Jan-94 alexgo    fixed bug in control flow for
//                                  advises
//              11-Jan-94 alexgo    added VDATEHEAP macro to every function
//                                  and method.
//              10-Dec-93 alexgo    added call tracing, ran through
//                                  tab filter program to eliminate
//                                  whitespace
//              30-Nov-93 alexgo    fixed bug with cache aggregation
//              22-Nov-93 alexgo    removed overloaded == for GUIDs
//              09-Nov-93 ChrisWe   changed COleCache::Update to
//                      COleCache::UpdateCache, and COleCache::Discard to
//                      COleCache::DiscardCache, which do the same as the
//                      originals, but without the indirect function call
//              02-Nov-93 alexgo    32bit port
//      srinik  09/15/92  Removed code for giving cfOwnerLink data through
//                        GetData() method
//      srinik  09/11/92  Removed IOleCache implementation, as a result of
//                        removing voncache.cpp, and moving IViewObject
//                        implementation into olecache.cpp.
//      SriniK  06/04/92  Fixed problems in IPersistStorage methods
//              04-Mar-92 srinik    created
//
//--------------------------------------------------------------------------

#include <le2int.h>

#include <scode.h>
#include <objerror.h>

#include <olerem.h>

#include "defhndlr.h"
#include "defutil.h"
#include "ole1cls.h"


#ifdef _DEBUG
#include <dbgdump.h>
#endif // _DEBUG

#include <ole2int.h>

#include <stdid.hxx>        // CStdIdentity
#include <ipidtbl.hxx>      // IpidTable.
#include <aggid.hxx>        // COM outer object
#include "xmit.hxx"

#ifdef SERVER_HANDLER
#include "srvhndlr.h"
#include "clthndlr.h"
#endif // SERVER_HANDLER

ASSERTDATA

/*
*      IMPLEMENTATION of CDefObject
*
*/

FARINTERNAL_(LPUNKNOWN) CreateDdeProxy(IUnknown FAR* pUnkOuter,
        REFCLSID rclsid);

//+-------------------------------------------------------------------------
//
//  Function:   CreateRemoteHandler
//
//  Arguments:  [rclsid]     -- clsid of the remote object
//              [pUnkOuter]  -- the controlling unknown
//              [iid]        -- requested interface ID
//              [ppv]        -- pointer to hold the returned interface
//
//  Returns:    HRESULT
//
//  History:    dd-mmm-yy Author    Comment
//              10-Jan-96 Gopalk    Rewritten
//--------------------------------------------------------------------------

static INTERNAL CreateRemoteHandler(REFCLSID rclsid, IUnknown *pUnkOuter, REFIID iid,
                                    void **ppv, DWORD flags, BOOL *fComOuterObject, BOOL *fOle1Server)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CreateRemoteHandler (%p, %p, %p, %p, %p)\n",
                0 /* this */, rclsid, pUnkOuter, iid, ppv, fComOuterObject));

    // Validation checks
    VDATEHEAP();

    // Local variables
    HRESULT hresult = NOERROR;

    // Initialize fComOuterObject and fOle1Server
    *fComOuterObject = FALSE;
    *fOle1Server = FALSE;

    // Check if the server is a OLE 1.0 object
    if(CoIsOle1Class(rclsid)) {
        IUnknown*  pUnk;
        COleTls Tls;

        // Set fComOuterObject to TRUE
        *fOle1Server = TRUE;

        // Check if the container disabled OLE1 functinality
        if(Tls->dwFlags & OLETLS_DISABLE_OLE1DDE) {
            // Container is not interested in talking to OLE1 servers.
            // Fail the call
            hresult = CO_E_OLE1DDE_DISABLED;
        }

        else {
            LEDebugOut((DEB_ITRACE,
                        "%p CreateRemoteHandler calling CreateDdeProxy(%p, %p)\n",
                        0 /* this */, pUnkOuter, rclsid));

            pUnk = CreateDdeProxy(pUnkOuter, rclsid);

            if(pUnk) {
                hresult = pUnk->QueryInterface(iid, ppv);
                pUnk->Release();
            }
            else {
                hresult = E_OUTOFMEMORY;
            }
        }

    }
    else {
        // Check for COM outer object
        CStdIdentity *pStdId;

        Win4Assert(pUnkOuter);
        // We do not want to QI a generic pUnkOuter for IID_IStdIdentity. Hence
        // we QI only if we put the pUnkOuter, either during OleCreateEmbeddingHelper
        // or during unmarshaling (CDefClassFactory::CreateInstance).
        // The DH_APICREATE flag is used to distinguish between the two cases.
        if ( flags & DH_COM_OUTEROBJECT ||
                ( !(flags & DH_COM_OUTEROBJECT)&&!(flags & DH_APICREATE) )) {
            
            hresult = pUnkOuter->QueryInterface(IID_IStdIdentity, (void **)&pStdId);
            if(SUCCEEDED(hresult)) {
                // Obtain the inner IUnknown on the COM outer object
                *ppv = pStdId->GetInternalUnk();
                ((IUnknown *) *ppv)->AddRef();

                // Inform the COM outer object that it is dealing with Default
                // Handler so that it enables access to IProxyManager methods
                pStdId->UpdateFlags(STDID_CLIENT_DEFHANDLER);

                // Release the StdId
                pStdId->Release();

                // Set fComOuterObject to TRUE
                *fComOuterObject = TRUE;
            }
        }
        else {
            // Create StdIdentity
            hresult = CreateIdentityHandler(pUnkOuter, STDID_CLIENT_DEFHANDLER,
                                            NULL, GetCurrentApartmentId(),
                                            iid, ppv);
        }
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CreateRemoteHandler(%lx)\n",
                0 /* this */, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleCreateDefaultHandler
//
//  Synopsis:   API to create the default handler.  Simply calls
//              OleCreateEmbeddingHelper with more arguments
//
//  Arguments:  [clsid]         -- the clsid of the remote exe
//              [pUnkOuter]     -- the controlling unknown (so we can
//                                 be aggregated)
//              [iid]           -- the requested interface
//              [ppv]           -- where to put a pointer to the default
//                                 handler
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              10-Dec-93 alexgo    added call tracing
//              02-Nov-93 alexgo    32bit port
//              10-Jan-97 Gopalk    Simplified
//--------------------------------------------------------------------------

#pragma SEG(OleCreateDefaultHandler)
STDAPI OleCreateDefaultHandler(REFCLSID clsid, IUnknown *pUnkOuter,
                               REFIID iid, void **ppv)
{
    OLETRACEIN((API_OleCreateDefaultHandler,
                PARAMFMT("clsid=%I, pUnkOuter=%p, iid=%I, ppv=%p"),
                &clsid, pUnkOuter, &iid, ppv));
    LEDebugOut((DEB_TRACE, "%p _IN OleCreateDefaultHandler(%p, %p, %p, %p)\n",
                0 /* this */, clsid, pUnkOuter, iid, ppv));


    // validation checks
    VDATEHEAP();

    // Local variable
    HRESULT hresult;

    // Call OleCreateEmbeddingHelper with the right parameters
    hresult = OleCreateEmbeddingHelper(clsid, pUnkOuter,
                                       EMBDHLP_INPROC_HANDLER | EMBDHLP_CREATENOW,
                                       NULL, iid, ppv);

    LEDebugOut((DEB_TRACE, "%p OUT OleCreateDefaultHandler(%lx)\n",
                0 /* this */, hresult));

    OLETRACEOUT((API_OleCreateDefaultHandler, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleCreateEmbeddingHelper
//
//  Synopsis:   Creates an instance of CDefObject (the default handler)
//              Called by OleCreateDefaultHandler
//
//  Arguments:  [clsid]     -- Server class id
//              [pUnkOuter] -- Controlling unkown for aggregation
//              [flags]     -- Indiacte an inproc handler or
//                             helper for an inproc server. The inproc
//                             server case is useful for self embedding
//              [pCF]       -- Server's class factory for inproc server
//              [iid]       -- Requested interface
//              [ppv]       -- pointer to hold the returned interface
//
//  Returns:    HRESULT
//
//  History:    dd-mmm-yy Author    Comment
//              10-Jan-96 Gopalk    Rewritten
//--------------------------------------------------------------------------

#pragma SEG(OleCreateEmbeddingHelper)
STDAPI OleCreateEmbeddingHelper(REFCLSID clsid, IUnknown *pUnkOuter,
                                DWORD flags, IClassFactory  *pCF,
                                REFIID iid, void **ppv)
{
    OLETRACEIN((API_OleCreateEmbeddingHelper,
                PARAMFMT("clsid=%I, pUnkOuter=%p, flags=%x, pCF=%p, iid=%I, ppv=%p"),
                &clsid, pUnkOuter, flags, pCF, &iid, ppv));
    LEDebugOut((DEB_TRACE, "%p _IN OleCreateEmbeddingHelper(%p, %p, %lu, %p, %p, %p)\n",
                0 /* this */, clsid, pUnkOuter, flags, pCF, iid, ppv));

    // Local variables
    HRESULT hresult = NOERROR;
    IUnknown *pUnk;

    // Validation checks
    VDATEHEAP();

    // Initialize the out parameter
    if(IsValidPtrOut(ppv, sizeof(void *)))
        *ppv = NULL;
    else
        hresult = E_INVALIDARG;

    if(hresult == NOERROR) {
        // Check that only allowed flags are set
        if(flags & ~(EMBDHLP_INPROC_SERVER|EMBDHLP_DELAYCREATE)) {
            hresult = E_INVALIDARG;
        } // Ensure that aggregation rules are being followed
        else if(pUnkOuter && (iid!=IID_IUnknown || !IsValidInterface(pUnkOuter))) {
            hresult = E_INVALIDARG;
        }
        else {
            // Check whether Inproc Server or Inproc Handler is requested
            if(flags & EMBDHLP_INPROC_SERVER) {
                // InProc server requested
                if(!pCF || !IsValidInterface(pCF)) {
                    // Inproc Server should be given a class factory
                    hresult = E_INVALIDARG;
                }
            }
            else {
                // InProc Handler requested
                if(pCF || (flags & EMBDHLP_DELAYCREATE)) {
                    // InProc Handler should not be given a class factory
                    hresult = E_INVALIDARG;
                }
            }
        }
    }

    // Create the Default object
    if(hresult == NOERROR) {
        // We add the DH_APICREATE flag so that during CreateRemoteHandler we can
        // distinguish between creation through APIs v/s creation through unmarshaling.
        // Warning: Be careful! Do not use bits used by the EMBDHLP_xxx flags (ole2.h)
        pUnk = CDefObject::Create(pUnkOuter, clsid, flags|DH_APICREATE, pCF);
        if(pUnk) {
            // Check if IUnknown was requested
            if(IsEqualIID(iid, IID_IUnknown)) {
                *ppv = pUnk;
            }
            else {
                // QI for the desired interface
                hresult = pUnk->QueryInterface(iid, ppv);
                // Fixup the reference count
                pUnk->Release();
            }
        }
        else {
            hresult = E_OUTOFMEMORY;
        }
    }

    LEDebugOut((DEB_TRACE, "%p OUT OleCreateEmbeddingHelper(%lx)\n",
                0 /* this */, hresult));
    OLETRACEOUT((API_OleCreateEmbeddingHelper, hresult));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::Create, static
//
//  Synopsis:   Static function used internally to create CDefObject
//
//  Arguments:  [pUnkOuter] -- Controlling unkown
//              [clsid]     -- Server clsid
//              [flags]     -- creation flags
//              [pCF]       -- pointer to server object class factory for
//                             inproc server
//
//  Returns:    pointer to the CDefObject's IUnkown interface
//
//  History:    dd-mmm-yy Author    Comment
//              10-Jan-96 Gopalk    Rewritten
//              07-Oct-98 SteveSw   Fix bug in "new CAggID" failure case
//--------------------------------------------------------------------------

IUnknown *CDefObject::Create(IUnknown *pUnkOuter, REFCLSID clsid,
                             DWORD flags, IClassFactory *pCF)
{
    // Validation checks
    VDATEHEAP();

    // Local variables
    CDefObject *pDefObj = NULL;
    CAggId *pAID = NULL;
    HRESULT error = S_OK;

    // If the outer object is absent, create the standard
    // COM outer object to take care of race conditions
    // during unmarshaling. If the outer object is present,
    // we can only hope that either it handles the race
    // conditions (Unmarshaled handler case) or that
    // they are not encountered
    if(!(flags & EMBDHLP_INPROC_SERVER) && !pUnkOuter && !CoIsOle1Class(clsid)) {
        IUnknown *pUnkInternal = NULL;

        // Create the COM outer object
        pAID = new CAggId(clsid, error);
        if(SUCCEEDED(error) && pAID != NULL) {
            pUnkOuter = (IUnknown *) pAID;
            flags |= DH_COM_OUTEROBJECT;
        }
        else
        {
            // Release aggid if it was created
            if(pAID)
                pAID->Release();
            return NULL;
        }
    }

    // Create the Default Handler
    pDefObj = new CDefObject(pUnkOuter);
    if(!pDefObj) {
        // If COM outer object was created earlier, release it now
        if(flags & DH_COM_OUTEROBJECT)
            pAID->Release();

        return NULL;
    }

    // Make our ref count equal to 1
    pDefObj->m_Unknown.AddRef();

    // Check if COM outer object was created earlier
    if(flags & DH_COM_OUTEROBJECT) {
        // Set handler on the COM outer object
        error = pAID->SetHandler(&pDefObj->m_Unknown);
        // As OID has not yet been assigned to StdIdentity
        // of AggId, no other thread can get a pointer to it
        // and consequently, the above call should never fail
        Win4Assert(error == NOERROR);

        // Fix the reference count
        pDefObj->m_Unknown.Release();

        // Return if something has gone wrong
        if(error != NOERROR) {
            pAID->Release();
            return NULL;
        }
    }

    // Initialize member variables
    pDefObj->m_clsidServer = clsid;
    pDefObj->m_clsidBits = CLSID_NULL;

#ifdef SERVER_HANDLER
    pDefObj->m_clsidUser = CLSID_NULL;
    pDefObj->m_ContentMiscStatusUser = 0;
#endif // SERVER_HANDLER

    if(pCF) {
        pDefObj->m_pCFDelegate = pCF;
        pCF->AddRef();
    }

    // Update flags
    if(!(flags & EMBDHLP_INPROC_SERVER))
        pDefObj->m_flags |= DH_INPROC_HANDLER;
    if(flags & DH_COM_OUTEROBJECT)
        pDefObj->m_flags |= DH_COM_OUTEROBJECT;
    if (flags & DH_APICREATE)
        pDefObj->m_flags |= DH_APICREATE;

    if(IsEqualCLSID(clsid, CLSID_StaticMetafile) ||
       IsEqualCLSID(clsid, CLSID_StaticDib) ||
       IsEqualCLSID(clsid, CLSID_Picture_EnhMetafile))
        pDefObj->m_flags |= DH_STATIC;

    // Create sub objects starting with Ole Cache
    pDefObj->m_pCOleCache = new COleCache(pDefObj->m_pUnkOuter, clsid);
    if(pDefObj->m_pCOleCache) {
        // Create DataAdvise Cache
        error = CDataAdviseCache::CreateDataAdviseCache(&pDefObj->m_pDataAdvCache);
        if(error == NOERROR) {
            // Check flags and create the inner object if requested
            if(flags & EMBDHLP_DELAYCREATE) {
                Win4Assert(pCF);
                Win4Assert(flags & EMBDHLP_INPROC_SERVER);
                Win4Assert(pDefObj->m_pUnkDelegate == NULL);
                Win4Assert(pDefObj->m_pProxyMgr == NULL);
                Win4Assert(pDefObj->GetRefCount() == 1);
                pDefObj->m_flags |= DH_DELAY_CREATE;
                return &pDefObj->m_Unknown;
            }
            else {
                error = pDefObj->CreateDelegate();
                if(error == NOERROR) {
                    Win4Assert(pDefObj->GetRefCount() == 1);
                    if(flags & DH_COM_OUTEROBJECT)
                        return (IUnknown *)pAID;
                    else
                        return &pDefObj->m_Unknown;
                }
            }
        }
    }

    // Something has gone wrong. Release the outer object
    // which will in turn release sub objects
    Win4Assert(pDefObj->GetRefCount() == 1);
    if(flags & DH_COM_OUTEROBJECT)
        pAID->Release();
    else
        pDefObj->m_Unknown.Release();

    return NULL;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::CDefObject
//
//  Synopsis:   constructor, sets member variables to NULL
//
//  Effects:
//
//  Arguments:  [pUnkOuter]     -- the controlling unkown
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: none
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Nov-93 alexgo    32bit port
//              10-Jan-97 Gopalk    Intialize CRefExportCount
//--------------------------------------------------------------------------

CDefObject::CDefObject (IUnknown *pUnkOuter) :
    CRefExportCount(pUnkOuter)
{
    VDATEHEAP();

    if (!pUnkOuter)
    {
        pUnkOuter = &m_Unknown;
    }

    //m_clsidServer
    //m_clsidBits are set in ::Create

    m_cConnections      = 0;
    m_pCFDelegate       = NULL;
    m_pUnkDelegate      = NULL;
    m_pUnkOuter         = pUnkOuter;
    m_pProxyMgr         = NULL;

    m_pCOleCache        = NULL;
    m_pOAHolder         = NULL;
    m_dwConnOle         = 0L;

    m_pAppClientSite    = NULL;
    m_pStg              = NULL;

    m_pDataAdvCache     = NULL;
    m_flags             = DH_INIT_NEW;
    m_dwObjFlags        = 0;

    m_pHostNames        = NULL;
    m_ibCntrObj         = 0;
    m_pOleDelegate      = NULL;
    m_pDataDelegate     = NULL;
    m_pPSDelegate       = NULL;

#ifdef SERVER_HANDLER
    m_pEmbSrvHndlrWrapper = NULL;
    m_pRunClientSite = NULL;
#endif // SERVER_HANDLER

    // Initialize member variables used for caching MiscStatus bits
    m_ContentSRVMSHResult = 0xFFFFFFFF;
    m_ContentSRVMSBits = 0;
    m_ContentREGMSHResult = 0xFFFFFFFF;
    m_ContentREGMSBits = 0;

    // Initialize member variables used for caching MiscStatus bits
    m_ContentSRVMSHResult = 0xFFFFFFFF;
    m_ContentSRVMSBits = 0;
    m_ContentREGMSHResult = 0xFFFFFFFF;
    m_ContentREGMSBits = 0;

#if DBG==1
    if (pUnkOuter != &m_Unknown)
    {
        m_flags |= DH_AGGREGATED;
    }
#endif
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::CleanupFn, private, virtual
//
//  Synopsis:   This function is called by CRefExportCount when the object
//              enters zombie state
//
//  Arguments:  None
//
//  History:    dd-mmm-yy Author    Comment
//              10-Jan-07 Gopalk    Creation
//--------------------------------------------------------------------------

void CDefObject::CleanupFn(void)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CDefObject::CleanupFn()\n", this));

    // Validation check
    VDATEHEAP();

    // Ensure that the server is stopped thereby releasing all references on
    // it
    Stop();

    // Release all cached pointers following aggregation rules. For local
    // server case, the following calls simply release proxies maintained
    // by the proxy manager as they have already been disconnected above
    if(m_pProxyMgr) {
        m_pUnkOuter->AddRef();
        SafeReleaseAndNULL((IUnknown **)&m_pProxyMgr);
    }
    if(m_pDataDelegate) {
        m_pUnkOuter->AddRef();
        SafeReleaseAndNULL((IUnknown **)&m_pDataDelegate);
    }
    if(m_pOleDelegate) {
        m_pUnkOuter->AddRef();
        SafeReleaseAndNULL((IUnknown **)&m_pOleDelegate);
    }
    if(m_pPSDelegate) {
        m_pUnkOuter->AddRef();
        SafeReleaseAndNULL((IUnknown **)&m_pPSDelegate);
    }

    // Release server handler
#ifdef SERVER_HANDLER
    if (m_pEmbSrvHndlrWrapper){
        CEmbServerWrapper* pWrapper = m_pEmbSrvHndlrWrapper;
        m_pEmbSrvHndlrWrapper = NULL;
        pWrapper->m_Unknown.Release();
    }
#endif // SERVER_HANDLER

    // Release the inner objects
    if(m_pUnkDelegate) {
        SafeReleaseAndNULL((IUnknown **)&m_pUnkDelegate);
    }
    if(m_pCFDelegate) {
        SafeReleaseAndNULL((IUnknown **)&m_pCFDelegate);
    }
    if(m_pCOleCache) {
        COleCache *pcache = m_pCOleCache;
        m_pCOleCache = NULL;
        pcache->m_UnkPrivate.Release();
    }
    if(m_pOAHolder) {
        SafeReleaseAndNULL((IUnknown **)&m_pOAHolder);
    }
    if (m_pDataAdvCache) {
        LPDATAADVCACHE pcacheTemp = m_pDataAdvCache;
        m_pDataAdvCache = NULL;
        delete pcacheTemp;
    }

    // Release container side objects
    if(m_pAppClientSite) {
        SafeReleaseAndNULL((IUnknown **)&m_pAppClientSite);
    }
    if(m_pStg) {
        SafeReleaseAndNULL((IUnknown **)&m_pStg);
    }
    if(m_pHostNames) {
        PrivMemFree(m_pHostNames);
        m_pHostNames = NULL;
    }

    // Set DH_CLEANEDUP flag
    m_flags |= DH_CLEANEDUP;

    LEDebugOut((DEB_ITRACE, "%p OUT CDefObject::CleanupFn()\n", this));

    return;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::~CDefObject
//
//  Synopsis:   Destructor
//
//  Arguments:  None
//
//  History:    dd-mmm-yy Author    Comment
//              10-Jan-07 Gopalk    Rewritten
//--------------------------------------------------------------------------

#pragma SEG(CDefObject_dtor)
CDefObject::~CDefObject(void)
{
    VDATEHEAP();

    Win4Assert(m_flags & DH_CLEANEDUP);
    Win4Assert(m_pUnkDelegate == NULL);
    Win4Assert(m_pCFDelegate == NULL);
    Win4Assert(m_pProxyMgr == NULL);
    Win4Assert(m_pCOleCache == NULL);
    Win4Assert(m_pOAHolder == NULL);
    Win4Assert(m_pAppClientSite == NULL);
    Win4Assert(m_pHostNames == NULL);
    Win4Assert(m_pStg == NULL);
    Win4Assert(m_pDataAdvCache == NULL);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::CreateDelegate, private
//
//  Synopsis:   Creates either a remote handler or a user supplied delegate
//              The remote handler must support IProxyManager
//
//  Returns:    HRESULT
//
//  History:    dd-mmm-yy Author    Comment
//              10-Jan-07 Gopalk    Rewritten
//--------------------------------------------------------------------------
INTERNAL CDefObject::CreateDelegate(void)
{
    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::CreateDelegate()\n", this));

    // Validation checks
    VDATEHEAP();

    // Local variables
    HRESULT hresult = NOERROR;
    BOOL fComOuterObject, fOle1Server;

    // Check if inner object has not yet been created
    if(!m_pUnkDelegate) {
        // Check for the class factory for the inner object
        if(m_pCFDelegate) {
            // Create the inner object using its class factory
            Win4Assert(!(m_flags & DH_INPROC_HANDLER));
            Win4Assert(!(m_flags & DH_COM_OUTEROBJECT));
            hresult = m_pCFDelegate->CreateInstance(m_pUnkOuter, IID_IUnknown,
                                                    (void **) &m_pUnkDelegate);

            // Assert that COM rules have been followed for out parameters
            AssertOutPtrIface(hresult, m_pUnkDelegate);

            // Release class factory if inner object has been
            // successfully created
            if(hresult == NOERROR) {
                m_pCFDelegate->Release();
                m_pCFDelegate = NULL;
            }
            else {
               // Win4Assert(!"CreateInstance failed"); // LeSuite Covers this case.
            }

        }
        else {
            // Create the COM/DDE Proxy Manager
            // Note that the proxy manager is intialized to obtain strong
            // references when the server is run. The conatiner can
            // modify this behavior by calling either
            // OleSetConatinedObject or IRunnableObject::LockRunning
            Win4Assert(m_flags & DH_INPROC_HANDLER);
            hresult = CreateRemoteHandler(m_clsidServer, m_pUnkOuter,
                                          IID_IUnknown, (void **) &m_pUnkDelegate,
                                          m_flags, &fComOuterObject, &fOle1Server);

            // Assert that COM rules have been followed for out parameters
            AssertOutPtrIface(hresult, m_pUnkDelegate);
            if(hresult == NOERROR) {
                // Determine if the Default Handler is being created due to
                // unmarshaling and update flags
                if(m_flags & DH_COM_OUTEROBJECT) {
                    Win4Assert(fComOuterObject);
                }
                else if(fComOuterObject) {
                    // DEFHANDLER obtained by unmarshaling.
                    // This happens on the linking container side
                    m_flags |= DH_UNMARSHALED;

                    // Output a debug warning.
                    LEDebugOut((DEB_WARN, "DEFHANDLER obtained by unmarshaling\n"));
                }
                if(fOle1Server) {
                    // OLE 1.0 Server
                    m_flags |= DH_OLE1SERVER;

                    // Output a debug warning.
                    LEDebugOut((DEB_WARN, "OLE 1.0 Server\n"));
                }

                // Obtain the IProxyManager interface
                hresult = m_pUnkDelegate->QueryInterface(IID_IProxyManager,
                                                         (void **) &m_pProxyMgr);
                // Follow aggregation rules for caching interface
                // pointers on inner objects
                if(hresult == NOERROR) {
                    Win4Assert(m_pProxyMgr);
                    m_pUnkOuter->Release();
                }
                else {
                    Win4Assert(!"Default handler failed to obtain Proxy Manager");
                    Win4Assert(!m_pProxyMgr);
                    m_pProxyMgr = NULL;
                }
            }
            else {
                Win4Assert(!"CreateRemoteHandler Failed");
            }
        }

        // Cleanup if something has gone wrong
        if(hresult != NOERROR) {
            if(m_pUnkDelegate)
                m_pUnkDelegate->Release();
            m_pUnkDelegate = NULL;
        }

    }

    // DEFHANDLER either has proxy manager as the inner object
    // for out of proc server objects or actual server as the
    // inner object for inproc server objects.
    // Assert that this is TRUE
    Win4Assert((m_pProxyMgr != NULL) == !!(m_flags & DH_INPROC_HANDLER));

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::CreateDelegate(%lx)\n",
                this , hresult));

    return hresult;
}

//+----------------------------------------------------------------------------
//
//      Member:
//              CDefObject::CPrivUnknown::AddRef, private
//
//      Synopsis:
//              implements IUnknown::AddRef
//
//      Arguments:
//              none
//
//      Returns:
//              the parent object's reference count
//
//      History:
//               Gopalk    Rewritten        Jan 20, 97
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDefObject::CPrivUnknown::AddRef( void )
{
    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::CPrivUnknown::AddRef()\n",
                this));

    // Validation check
    VDATEHEAP();

    // Local variables
    CDefObject *pDefObject = GETPPARENT(this, CDefObject, m_Unknown);
    ULONG cRefs;

    // Addref the parent object
    cRefs = pDefObject->SafeAddRef();

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::CPrivUnknown::AddRef(%lu)\n",
                this, cRefs));

    return cRefs;
}

//+----------------------------------------------------------------------------
//
//      Member:
//              CDefObject::CPrivUnknown::Release, private
//
//      Synopsis:
//              implements IUnknown::Release
//
//      Arguments:
//              none
//
//      Returns:
//              the parent object's reference count
//
//      History:
//               Gopalk    Rewritten        Jan 20, 97
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDefObject::CPrivUnknown::Release( void )
{
    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::CPrivUnknown::Release()\n",
                this));

    // Validation check
    VDATEHEAP();

    // Local variables
    CDefObject *pDefObject = GETPPARENT(this, CDefObject, m_Unknown);
    ULONG cRefs;

    // Release parent object
    cRefs = pDefObject->SafeRelease();

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::CPrivUnknown::Release(%lu)\n",
                this, cRefs));

    return cRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::CPrivUnknown::QueryInterface
//
//  Synopsis:   Returns a pointer to one of the supported interfaces.
//
//  Effects:
//
//  Arguments:  [iid]           -- the requested interface ID
//              [ppv]           -- where to put the iface pointer
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              03-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::CPrivUnknown::QueryInterface(REFIID iid,
    LPLPVOID ppv)
{
    CDefObject * pDefObject = GETPPARENT(this, CDefObject, m_Unknown);
    HRESULT         hresult;

    VDATEHEAP();


    LEDebugOut((DEB_TRACE,
        "%p _IN CDefObject::CUnknownImpl::QueryInterface "
        "( %p , %p )\n", pDefObject, iid, ppv));

    CRefStabilize stabilize(pDefObject);

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (void FAR *)this;
    }
    else if (IsEqualIID(iid, IID_IOleObject))
    {
        *ppv = (void FAR *)(IOleObject *)pDefObject;
    }
    else if (IsEqualIID(iid, IID_IDataObject))
    {
        *ppv = (void FAR *)(IDataObject *)pDefObject;
    }
    else if (IsEqualIID(iid, IID_IRunnableObject))
    {
        *ppv = (void FAR *)(IRunnableObject *)pDefObject;
    }
    else if (IsEqualIID(iid, IID_IPersist) ||
        IsEqualIID(iid, IID_IPersistStorage))
    {
        *ppv = (void FAR *)(IPersistStorage *)pDefObject;
    }
    else if( IsEqualIID(iid, IID_IViewObject) ||
        IsEqualIID(iid, IID_IViewObject2) ||
        IsEqualIID(iid, IID_IOleCache) ||
        IsEqualIID(iid, IID_IOleCache2) )
    {
        // m_pCOleCache is a pointer to the *public* IUnknown
        // (we want the private one)
        hresult =
        pDefObject->m_pCOleCache->m_UnkPrivate.QueryInterface(
                iid, ppv);

        LEDebugOut((DEB_TRACE,
            "%p OUT CDefObject::CUnknownImpl::QueryInterface "
            "( %lx ) [ %p ]\n", pDefObject, hresult,
            (ppv) ? *ppv : 0 ));

        return hresult;
    }
    else if( !(pDefObject->m_flags & DH_INPROC_HANDLER) &&
        IsEqualIID(iid, IID_IExternalConnection) )
    {
        // only allow IExternalConnection if inproc server.  We
        // know we are an inproc server if we are *not* an inproc
        // handler (cute, huh? ;-)

        *ppv = (void FAR *)(IExternalConnection *)pDefObject;
    }
    else if( IsEqualIID(iid, IID_IOleLink) )
    {
        // this prevents a remote call for
        // a query which will almost always fail; the remote call
        // interfered with server notification messages.
        *ppv = NULL;

        LEDebugOut((DEB_TRACE,
            "%p OUT CDefObject::CUnknownImpl::QueryInterface "
            "( %lx ) [ %p ]\n", pDefObject, E_NOINTERFACE, 0));

        return E_NOINTERFACE;
    }
    else if( IsEqualIID(iid, IID_IInternalUnknown) )
    {
        // this interface is private between the handler and the
        // remoting layer and is never exposed by handlers.
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    else if( pDefObject->CreateDelegate() == NOERROR)
    {

        hresult = pDefObject->m_pUnkDelegate->QueryInterface( iid,
            ppv);

        LEDebugOut((DEB_TRACE,
            "%p OUT CDefObject::CUnknownImpl::QueryInterface "
            "( %lx ) [ %p ]\n", pDefObject, hresult,
            (ppv) ? *ppv : 0 ));

        return hresult;
    }
    else
    {
        // no delegate and couldn't create one
        *ppv = NULL;

        LEDebugOut((DEB_TRACE,
            "%p OUT CDefObject::CUnkownImpl::QueryInterface "
            "( %lx ) [ %p ]\n", pDefObject, CO_E_OBJNOTCONNECTED,
            0 ));

        return CO_E_OBJNOTCONNECTED;
    }

    // this indirection is important since there are different
    // implementationsof AddRef (this unk and the others).
    ((IUnknown FAR*) *ppv)->AddRef();

    LEDebugOut((DEB_TRACE,
        "%p OUT CDefObject::CUnknownImpl::QueryInterface "
        "( %lx ) [ %p ]\n", pDefObject, NOERROR, *ppv));

    return NOERROR;
}

/*
 * IMPLEMENTATION of IUnknown methods
 */

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::QueryInterface
//
//  Synopsis:   QI's to the controlling IUnknown
//
//  Effects:
//
//  Arguments:  [riid]  -- the interface ID
//              [ppv]   -- where to put it
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IUnknown
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              15-Nov-94 alexgo    author
//
//  Notes:      We do *not* need to stabilize this method as only
//              one outgoing call is made and we do not use the
//              'this' pointer afterwards
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::QueryInterface( REFIID riid, void **ppv )
{
    HRESULT     hresult;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::QueryInterface ( %lx , "
        "%p )\n", this, riid, ppv));

    Assert(m_pUnkOuter);

    hresult = m_pUnkOuter->QueryInterface(riid, ppv);

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::QueryInterface ( %lx ) "
        "[ %p ]\n", this, hresult, *ppv));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::AddRef
//
//  Synopsis:   delegates AddRef to the controlling IUnknown
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IUnknown
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              15-Nov-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CDefObject::AddRef( void )
{
    ULONG       crefs;;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::AddRef ( )\n", this));

    Assert(m_pUnkOuter);

    crefs = m_pUnkOuter->AddRef();

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::AddRef ( %ld ) ", this,
        crefs));

    return crefs;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::Release
//
//  Synopsis:   delegates Release to the controlling IUnknown
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IUnknown
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              15-Nov-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CDefObject::Release( void )
{
    ULONG       crefs;;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::Release ( )\n", this));

    Assert(m_pUnkOuter);

    crefs = m_pUnkOuter->Release();

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::Release ( %ld ) ", this,
        crefs));

    return crefs;
}

/*
 *      IMPLEMENTATION of CDataObjectImpl methods
 */

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::GetDataDelegate
//
//  Synopsis:   Calls DuCacheDelegate (a glorified QueryInterface)
//              for the IDataObject interface on the def handler's
//              delegate
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    IDataObject *
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              04-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

INTERNAL_(IDataObject FAR*) CDefObject::GetDataDelegate(void)
{
    VDATEHEAP();

    if( IsZombie() )
    {
        return NULL;
    }


    if (m_pDataDelegate) {
        return m_pDataDelegate;
    }

    return (IDataObject FAR*)DuCacheDelegate(
                &m_pUnkDelegate,
                IID_IDataObject, (LPLPVOID) &m_pDataDelegate,
                m_pUnkOuter);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::GetData
//
//  Synopsis:   calls IDO->GetData on the cache, if that fails, then the
//              call is delegated
//
//  Effects:    Space for the data is allocated; caller is responsible for
//              freeing.
//
//  Arguments:  [pformatetcIn]          -- format of the data to get
//              [pmedium]               -- the medium to transmit the data
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IDataObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::GetData( LPFORMATETC pformatetcIn,
                                LPSTGMEDIUM pmedium )
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT         hresult;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::GetData ( %p , %p )\n",
        this, pformatetcIn, pmedium));

    VDATEPTROUT( pmedium, STGMEDIUM );
    VDATEREADPTRIN( pformatetcIn, FORMATETC );

    CRefStabilize stabilize(this);


    if (!HasValidLINDEX(pformatetcIn))
    {
        return DV_E_LINDEX;
    }

    pmedium->tymed = TYMED_NULL;
    pmedium->pUnkForRelease = NULL;

    Assert(m_pCOleCache != NULL);

    hresult = m_pCOleCache->m_Data.GetData(pformatetcIn, pmedium);

    if( hresult != NOERROR )
    {
        if( IsRunning() && GetDataDelegate() )
        {
            hresult = m_pDataDelegate->GetData(pformatetcIn,
                            pmedium);
            AssertOutStgmedium(hresult, pmedium);
        }
        else
        {
            hresult = OLE_E_NOTRUNNING;
        }
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::GetData ( %lx )\n",
        this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::GetDataHere
//
//  Synopsis:   Gets data and puts it into the medium specified in pmedium
//
//  Effects:
//
//  Arguments:  [pformatetcIn]          -- the format of the data
//              [pmedium]               -- the medium to put the data in
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IDataObject
//
//  Algorithm:  Tries the cache first, if that fails, calls GetDataHere
//              on the delegate.
//
//  History:    dd-mmm-yy Author    Comment
//              05-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::GetDataHere( LPFORMATETC pformatetcIn,
                            LPSTGMEDIUM pmedium )
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT         hresult;

    LEDebugOut((DEB_TRACE,
        "%p _IN CDefObject::GetDataHere "
        "( %p , %p )\n", this, pformatetcIn, pmedium));

    VDATEREADPTRIN( pformatetcIn, FORMATETC );
    VDATEREADPTRIN( pmedium, STGMEDIUM );

    CRefStabilize stabilize(this);

    if (!HasValidLINDEX(pformatetcIn))
    {
        return DV_E_LINDEX;
    }

    Assert((m_pCOleCache) != NULL);

    hresult = m_pCOleCache->m_Data.GetDataHere(pformatetcIn,
                pmedium);

    if( hresult != NOERROR)
    {
        if( IsRunning() && GetDataDelegate() )
        {
            hresult = m_pDataDelegate->GetDataHere(pformatetcIn,
                pmedium);
        }
        else
        {
            hresult = OLE_E_NOTRUNNING;
        }
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::GetDataHere "
        "( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::QueryGetData
//
//  Synopsis:   Determines whether or not a GetData call with [pformatetcIn]
//              would succeed.
//
//  Effects:
//
//  Arguments:  [pformatetcIn]          -- the format of the data
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IDataObject
//
//  Algorithm:  Tries the cache first, then the delegate.
//
//  History:    dd-mmm-yy Author    Comment
//              05-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::QueryGetData( LPFORMATETC pformatetcIn )
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT         hresult;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::QueryGetData "
        "( %p )\n", this, pformatetcIn));

    VDATEREADPTRIN( pformatetcIn, FORMATETC );

    CRefStabilize stabilize(this);

    if (!HasValidLINDEX(pformatetcIn))
    {
        return DV_E_LINDEX;
    }

    Assert((m_pCOleCache) != NULL);

    hresult = m_pCOleCache->m_Data.QueryGetData(pformatetcIn);

    if( hresult != NOERROR )
    {
        if( IsRunning() && GetDataDelegate() )
        {
            hresult = m_pDataDelegate->QueryGetData(pformatetcIn);
        }
        else
        {
            hresult = OLE_E_NOTRUNNING;
        }
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::QueryGetData "
        "( %lx )\n", this, hresult));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::GetCanonicalFormatEtc
//
//  Synopsis:   Calls IDO->GetCanonicalFormatEtc on the delegate
//
//  Effects:
//
//  Arguments:  [pformatetc]    -- the reqested format
//              [pformatetcOut] -- the canonical format
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IDataObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::GetCanonicalFormatEtc( LPFORMATETC pformatetc,
                        LPFORMATETC pformatetcOut)
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT         hresult;

    LEDebugOut((DEB_TRACE,
        "%p _IN CDefObject::GetCanonicalFormatEtc "
        "( %p , %p )\n", this, pformatetc, pformatetcOut));


    VDATEPTROUT( pformatetcOut, FORMATETC );
    VDATEREADPTRIN( pformatetc, FORMATETC );

    CRefStabilize stabilize(this);

    pformatetcOut->ptd = NULL;
    pformatetcOut->tymed = TYMED_NULL;

    if (!HasValidLINDEX(pformatetc))
    {
        return DV_E_LINDEX;
    }

    if( IsRunning() && GetDataDelegate() )
    {
        hresult = m_pDataDelegate->GetCanonicalFormatEtc( pformatetc,
                pformatetcOut);
    }
    else
    {
        hresult = OLE_E_NOTRUNNING;
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::GetCanonicalFormatEtc "
        "( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::SetData
//
//  Synopsis:   Calls IDO->SetData on the handler's delegate
//
//  Effects:
//
//  Arguments:  [pformatetc]            -- the format of the data
//              [pmedium]               -- the data's transmision medium
//              [fRelease]              -- if the delegate should release
//                                         the data
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IDataObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::SetData( LPFORMATETC pformatetc,
                    LPSTGMEDIUM pmedium, BOOL fRelease)
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT hresult;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::SetData "
        "( %p , %p , %ld )\n", this, pformatetc, pmedium,
        fRelease));

    VDATEREADPTRIN( pformatetc, FORMATETC );
    VDATEREADPTRIN( pmedium, STGMEDIUM );

    CRefStabilize stabilize(this);

    if (!HasValidLINDEX(pformatetc))
    {
        return DV_E_LINDEX;
    }

    if( IsRunning() && GetDataDelegate() )
    {
        hresult = m_pDataDelegate->SetData(pformatetc, pmedium,
                fRelease);
    }
    else
    {
        hresult = OLE_E_NOTRUNNING;
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::SetData "
        "( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::EnumFormatEtc
//
//  Synopsis:   Enumerates the formats available from an object
//
//  Effects:
//
//  Arguments:  [dwDirection]   -- indicates which set of formats are
//                                 desired (i.e. those that can be set or
//                                 those that can be retrieved via GetData)
//              [ppenumFormatEtc]       -- where to put the pointer to the
//                                         enumerator
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:  Tries the delegate (if available).  If the delegate is
//              is not currently connected (or if it returns OLE_E_USEREG),
//              then we attempt to build the enumerator from the reg database
//
//  History:    dd-mmm-yy Author    Comment
//              05-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::EnumFormatEtc( DWORD dwDirection,
                    LPENUMFORMATETC FAR* ppenumFormatEtc)
{
    VDATEHEAP();
    VDATETHREAD(this);


    HRESULT         hresult;

    LEDebugOut((DEB_TRACE,
        "%p _IN CDefObject::EnumFormatEtc ( %lu , %p )\n", this,
        dwDirection, ppenumFormatEtc));

    VDATEPTROUT(ppenumFormatEtc, LPVOID);

    CRefStabilize stabilize(this);

    *ppenumFormatEtc = NULL;

    if( IsRunning() && GetDataDelegate() )
    {
        hresult = m_pDataDelegate->EnumFormatEtc (dwDirection,
                    ppenumFormatEtc);

        if (!GET_FROM_REGDB(hresult))
        {
            LEDebugOut((DEB_TRACE,
               "%p OUT CDefObject::CDataObject::EnumFormatEtc "
                "( %lx ) [ %p ]\n", this,
                hresult, ppenumFormatEtc));

            return hresult;
        }
    }
    // Not running, or object wants to use reg db anyway
    hresult = OleRegEnumFormatEtc (m_clsidServer, dwDirection,
                    ppenumFormatEtc);

    LEDebugOut((DEB_TRACE,
        "%p OUT CDefObject::EnumFormatEtc "
        "( %lx ) [ %p ]\n", this, hresult, ppenumFormatEtc));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::DAdvise
//
//  Synopsis:   Sets up a data advise connection
//
//  Effects:
//
//  Arguments:  [pFormatetc]    -- format to be advise'd on
//              [advf]          -- advise flags
//              [pAdvSink]      -- advise sink (whom to notify)
//              [pdwConnection] -- where to put the connection ID
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IDataObject
//
//  Algorithm:  calls Advise on the DataAdvise cache
//
//  History:    dd-mmm-yy Author    Comment
//              05-Nov-93 alexgo    32bit port
//
//  Notes:
//          We should set up an data advise holder and add the entries to
//          it. We should also create a new data advise sink and register
//          it with server when it is run. On receiving OnDataChange
//          notifications, the advise sink would turn around and send
//          OnDataChange notifications to registered client advise sinks
//          This should improve run time performance and also facilitates
//          better cleanup when server crashes through CoDisconnectObject
//          on the advise sink registered with the server. Gopalk
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::DAdvise(FORMATETC *pFormatetc, DWORD advf,
                        IAdviseSink * pAdvSink, DWORD * pdwConnection)
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT         hresult;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::DAdvise "
        "( %p , %lu , %p , %p )\n", this, pFormatetc, advf,
        pAdvSink, pdwConnection));

    VDATEREADPTRIN( pFormatetc, FORMATETC );
    VDATEIFACE( pAdvSink );

    CRefStabilize stabilize(this);

    IDataObject * pDataDelegate = NULL;

    if( pdwConnection )
    {
        VDATEPTROUT( pdwConnection, DWORD );
        *pdwConnection = NULL;
    }

    if( !HasValidLINDEX(pFormatetc) )
    {
        return DV_E_LINDEX;
    }

    if( IsRunning() )
    {
        pDataDelegate = GetDataDelegate();
    }

    // setting up advises' changes state.  Don't do this if we
    // are in a zombie state

    if( IsZombie() == FALSE )
    {
        hresult = m_pDataAdvCache->Advise(pDataDelegate, pFormatetc, advf,
                        pAdvSink, pdwConnection);
    }
    else
    {
        hresult = CO_E_RELEASED;
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::DAdvise "
        "( %lx ) [ %lu ]\n", this, hresult,
        (pdwConnection) ? *pdwConnection : 0));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::DUnadvise
//
//  Synopsis:   Tears down a data advise connection
//
//  Effects:
//
//  Arguments:  [dwConnection]  -- the advise connection to remove
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IDataObject
//
//  Algorithm:  delegates to the DataAdvise cache
//
//  History:    dd-mmm-yy Author    Comment
//              05-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::DUnadvise(DWORD dwConnection)
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT                 hresult;

    LEDebugOut((DEB_TRACE,
        "%p _IN CDefObject::DUnadvise ( %lu )\n", this, dwConnection));

    CRefStabilize stabilize(this);

    IDataObject *       pDataDelegate = NULL;

    if( IsRunning() )
    {
        pDataDelegate = GetDataDelegate();
    }

    hresult = m_pDataAdvCache->Unadvise(pDataDelegate, dwConnection);

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::DUnadvise "
        "( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::EnumDAdvise
//
//  Synopsis:   Enumerates advise connection (delegates to data advise cache)
//
//  Effects:
//
//  Arguments:  [ppenumAdvise]  -- where to put a pointer to the enumerator
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IDataObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Nov-93 alexgo    32bit port
//
//  Notes:      We do NOT need to stabilize this method, as we make
//              no outgoing calls (EnumAdvise on the data advise cache
//              just allocates an advise enumerator which we implement)
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::EnumDAdvise( LPENUMSTATDATA * ppenumAdvise )
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT                 hresult;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::EnumDAdvise "
        "( %p )\n", this, ppenumAdvise));

    VDATEPTROUT( ppenumAdvise, LPENUMSTATDATA );
    *ppenumAdvise = NULL;

    hresult = m_pDataAdvCache->EnumAdvise (ppenumAdvise);

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::EnumDAdvise "
        "( %lx ) [ %p ]\n", this, hresult, *ppenumAdvise));

    return hresult;
}

/*
*      IMPLEMENTATION of COleObjectImpl methods
*
*/

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::COleObjectImpl::GetOleDelegate
//
//  Synopsis:   Gets the IID_IOleObject interface from the delegate
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    IOleObject *
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

INTERNAL_(IOleObject FAR*) CDefObject::GetOleDelegate(void)
{
    VDATEHEAP();

    if( IsZombie() )
    {
        return NULL;
    }

    return (IOleObject FAR*)DuCacheDelegate(&m_pUnkDelegate,
                IID_IOleObject, (LPLPVOID) &m_pOleDelegate, m_pUnkOuter);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::COleObjectImpl::SetClientSite
//
//  Synopsis:   Sets the client site for the object
//
//  Effects:
//
//  Arguments:  [pClientSite]   -- pointer to the client site
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  If running, set the client site in the server, if not
//              running (or successfully set the server client site),
//              save it in the handler as well
//
//  History:    dd-mmm-yy Author    Comment
//              05-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::SetClientSite(IOleClientSite * pClientSite)
{
    VDATEHEAP();
    VDATETHREAD(this);
    HRESULT             hresult = S_OK;
    IOleObject *        pOleDelegate;
    BOOL                fIsRunning;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::SetClientSite "
        "( %p )\n", this, pClientSite));

    CRefStabilize stabilize(this);

#if DBG==1
    // In Debug builds, assert that the clientsite is in the same
    // apartment. This assert is harmless but shows the deficiency
    // of the current design in loading INPROC servers
    CStdIdentity* pStdId = NULL;

    // QI for IStdIdentity
    if(pClientSite &&
       pClientSite->QueryInterface(IID_IStdIdentity, (void **)&pStdId) ==
       NOERROR) {
        // Assert that DefHandler and ClientSite not in the same apartment
        LEDebugOut((DEB_WARN,"Performance Alert: Default Handler and "
                             "ClientSite not in the same apartment. "
                             "You can avoid this performance problem "
                             "by making the Server Dll apartment aware"));

        // Release the StdIdentity as it succeded
        pStdId->Release();
    }
#endif

    fIsRunning=IsRunning();

    if( (fIsRunning) && (pOleDelegate = GetOleDelegate()) != NULL)
    {
#ifdef SERVER_HANDLER
        if (m_pEmbSrvHndlrWrapper)
        {
            // Todo: Need to handle case ClientSite is the Wrapped one like DoVerb.
            // Win4Assert(0 && "SetClientSite while running");
            hresult = m_pEmbSrvHndlrWrapper->SetClientSite(pClientSite);
        }
        else
#endif // SERVER_HANDLER
        {
            hresult = pOleDelegate->SetClientSite(pClientSite);
        }

        if( hresult != NOERROR )
        {
            goto errRtn;
        }
    }

    // we shouldn't set the client site if we are in a zombie state;
    // it's possible that we're zombied and have already gotten
    // to the point in our destructor where we release the client
    // site.  Resetting it here would cause an unbalanced addref.

    if( IsZombie() == FALSE )
    {
        BOOL    fLockedContainer = m_flags & DH_LOCKED_CONTAINER;

        fIsRunning=IsRunning(); // I am chicken, maybe running state has changed!

        hresult = DuSetClientSite(fIsRunning, pClientSite,
                    &m_pAppClientSite, &fLockedContainer);

        if(fLockedContainer)
            m_flags |= DH_LOCKED_CONTAINER;
        else
            m_flags &= ~DH_LOCKED_CONTAINER;

#if DBG==1
        // In debug builds, update DH_LOCKFAILED flag
        if(fIsRunning) {
            if(fLockedContainer)
                m_flags &= ~DH_LOCKFAILED;
            else
                m_flags |= DH_LOCKFAILED;
        }
#endif
    }

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::SetClientSite "
        "( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::GetClientSite
//
//  Synopsis:   returns the client site of the object
//
//  Effects:
//
//  Arguments:  [ppClientSite]  -- where to put the client site pointer
//
//  Requires:
//
//  Returns:    NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Nov-93 alexgo    32bit port
//
//  Notes:      We do NOT need to stabilize this call.  The client
//              site addref should simply addref the client site on this
//              thread.
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::GetClientSite( IOleClientSite ** ppClientSite)
{
    VDATEHEAP();
    VDATETHREAD(this);


    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::GetClientSite "
        "( %p )\n", this, ppClientSite));

    VDATEPTROUT(ppClientSite, IOleClientSite *);

    *ppClientSite = m_pAppClientSite;
    if( *ppClientSite )
    {
        (*ppClientSite)->AddRef();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::GetClientSite "
        "( %lx ) [ %p ]\n", this, NOERROR, *ppClientSite));

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::SetHostNames
//
//  Synopsis:   Sets the name that may appear in an object's window
//
//  Effects:    Turns the strings into atoms
//
//  Arguments:  [szContainerApp]        -- name of the container
//              [szContainerObj]        -- name of the object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  turns the strings into atoms, calls IOO->SetHostNames
//              on the delegate
//
//  History:    dd-mmm-yy Author    Comment
//              05-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::SetHostNames( LPCOLESTR szContainerApp,
                    LPCOLESTR szContainerObj)
{
    VDATEHEAP();
    VDATETHREAD(this);


    HRESULT         hresult = NOERROR;
    OLECHAR         szNull[] = OLESTR("");
    DWORD           cbApp, cbObj;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::SetHostNames "
        "( \"%ws\" , \"%ws\" )\n", this, szContainerApp,
        szContainerObj));

    VDATEPTRIN( (LPVOID)szContainerApp, char );

    CRefStabilize stabilize(this);

    if( (m_flags & DH_STATIC) )
    {
        hresult = OLE_E_STATIC;
        goto errRtn;
    }

    // Make sure both arguments point to a valid string; this
    // simplifies the code that follows.
    if (!szContainerApp)
    {
        szContainerApp = szNull;
    }
    if (!szContainerObj)
    {
        szContainerObj = szNull;
    }

    cbApp = (_xstrlen(szContainerApp) + 1) * sizeof(OLECHAR);
    cbObj = (_xstrlen(szContainerObj) + 1) * sizeof(OLECHAR);
    m_ibCntrObj = cbApp;

    if (m_pHostNames)
    {
        PrivMemFree(m_pHostNames);
    }

    m_pHostNames = (char *)PrivMemAlloc(cbApp+cbObj);

    // Store the two strings in the m_pHostNames pointer.
    if (m_pHostNames)
    {
        memcpy(m_pHostNames, szContainerApp, cbApp);
        memcpy(m_pHostNames + cbApp, szContainerObj, cbObj);
    }

    if( IsRunning() && GetOleDelegate() )
    {
        hresult = m_pOleDelegate->SetHostNames(szContainerApp,
            szContainerObj);
    }

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::SetHostNames "
        "( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::Close
//
//  Synopsis:   calls Close on the delegate and does cleanup
//
//  Arguments:  [dwFlags]  -- close flags
//
//  Returns:    HRESULT
//
//  History:    dd-mmm-yy Author    Comment
//              10-Jan-96 Gopalk    Rewritten
//--------------------------------------------------------------------------
STDMETHODIMP CDefObject::Close(DWORD dwFlags)
{
    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::Close(%lu)\n", this, dwFlags));

    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);

    // Local variables
    HRESULT hresult = NOERROR;
    CRefStabilize stabilize(this);

    // Check if the server is running
    if(IsRunning()) {
        // Call IOleObject::Close on the server
        if(m_pOleDelegate || GetOleDelegate()) {
            hresult = m_pOleDelegate->Close(dwFlags);
            if(SUCCEEDED(hresult)) {
                // Discard cache if requested
                if(dwFlags == OLECLOSE_NOSAVE)
                    m_pCOleCache->DiscardCache(DISCARDCACHE_NOSAVE);
            }
        }

        // Do not rely on server calling IAdviseSink::OnClose and
        // stop the running server
        Stop();
    }
    else {
        // Check the save flags
        if (dwFlags != OLECLOSE_NOSAVE) {
            Win4Assert(dwFlags == OLECLOSE_SAVEIFDIRTY);

            // Call IOleClientSite::SaveObject if dirty
            if(IsDirty()==NOERROR && m_pAppClientSite)
                hresult = m_pAppClientSite->SaveObject();
        }
    }

    // Assert that the container is not locked
    Win4Assert(!(m_flags & DH_LOCKED_CONTAINER) && !(m_flags & DH_LOCKFAILED));

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::Close(%lx)\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::SetMoniker
//
//  Synopsis:   Gives a moniker to the embedding (usually called by the
//              container)
//
//  Effects:
//
//  Arguments:  [dwWhichMoniker]        -- flags to indicate the type of
//                                         moniker
//              [pmk]                   -- the moniker
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  delegates to the server object
//
//  History:    dd-mmm-yy Author    Comment
//              07-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::SetMoniker( DWORD dwWhichMoniker, LPMONIKER pmk )
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT         hresult = NOERROR;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::SetMoniker "
        "( %lu , %p )\n", this, dwWhichMoniker, pmk));

    VDATEIFACE( pmk );

    CRefStabilize stabilize(this);


    if( IsRunning() && GetOleDelegate() )
    {
        hresult = m_pOleDelegate->SetMoniker(dwWhichMoniker, pmk);
    }
    // else case: return NOERROR
    // this is not an error since we will call SetMoniker in Run().

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::COleObjectImpl::SetMoniker "
        "( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::COleObjectImpl::GetMoniker
//
//  Synopsis:   Calls the client site to get the object's moniker
//
//  Effects:
//
//  Arguments:  [dwAssign]      -- controls whether a moniker should be
//                                 assigned if not already present
//              [dwWhichMoniker]        -- the moniker type to get
//              [ppmk]          -- where to put a pointer to the moniker
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              07-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::GetMoniker( DWORD dwAssign, DWORD dwWhichMoniker,
                    LPMONIKER FAR* ppmk)
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT         hresult;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::GetMoniker "
        "( %lu , %lu , %p )\n", this, dwAssign,
        dwWhichMoniker, ppmk));

    VDATEPTROUT( ppmk, LPMONIKER );

    CRefStabilize stabilize(this);

    *ppmk = NULL;

    // the moniker is always accessible via the client site
    if( m_pAppClientSite)
    {
        hresult = m_pAppClientSite->GetMoniker(dwAssign,
                dwWhichMoniker, ppmk);
    }
    else
    {
        // not running and no client site
        hresult = E_UNSPEC;
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::GetMoniker "
        "( %lx ) [ %p ]\n", this, hresult, *ppmk));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::InitFromData
//
//  Synopsis:   Initializes the object from the data in [pDataObject]
//
//  Effects:
//
//  Arguments:  [pDataObject]   -- the data
//              [fCreation]     -- TRUE on creation, FALSE for data transfer
//              [dwReserved]    -- unused
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  delegates to the server
//
//  History:    dd-mmm-yy Author    Comment
//              07-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::InitFromData(LPDATAOBJECT pDataObject,
                    BOOL fCreation, DWORD dwReserved)
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT         hresult;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::InitFromData "
        "( %p , %ld , %lu )\n", this, pDataObject,
        fCreation, dwReserved ));

    if( pDataObject )
    {
        VDATEIFACE(pDataObject);
    }

    CRefStabilize stabilize(this);

    if( IsRunning() && GetOleDelegate() )
    {
        hresult = m_pOleDelegate->InitFromData(pDataObject,
                fCreation, dwReserved);
    }
    else
    {
        hresult = OLE_E_NOTRUNNING;
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::InitFromData "
        "( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::GetClipboardData
//
//  Synopsis:   Retrieves a data object that could be passed to the clipboard
//
//  Effects:
//
//  Arguments:  [dwReserverd]   -- unused
//              [ppDataObject]  -- where to put the pointer to the data object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  delegates to the server
//
//  History:    dd-mmm-yy Author    Comment
//              07-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::GetClipboardData( DWORD dwReserved,
                    LPDATAOBJECT * ppDataObject)
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT         hresult;

    LEDebugOut((DEB_TRACE,
        "%p _IN CDefObject::GetClipboardData "
        "( %lu , %p )\n", this, dwReserved, ppDataObject));

    VDATEPTROUT( ppDataObject, LPDATAOBJECT );

    CRefStabilize stabilize(this);

    *ppDataObject = NULL;

    if( IsRunning() && GetOleDelegate() )
    {
        hresult = m_pOleDelegate->GetClipboardData (dwReserved,
            ppDataObject);
    }
    else
    {
        hresult = OLE_E_NOTRUNNING;
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::GetClipboardData "
        "( %lx ) [ %p ]\n", this, hresult, *ppDataObject));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::DoVerb
//
//  Synopsis:   Calls a verb on the object (such as Edit)
//
//  Effects:    The object may launch its app, go in place, etc
//
//  Arguments:  [iVerb]         -- the verb number
//              [lpmsg]         -- the windows message that caused the verb
//                                 to be invoked
//              [pActiveSite]   -- the client site in which the verb was
//                                 invoked
//              [lindex]        -- reserved
//              [hwndParent]    -- the document window (containing the object)
//              [lprcPosRect]   -- the object's bounding rectangle
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  delegates to the server (launching it if necessary)
//
//  History:    dd-mmm-yy Author    Comment
//              07-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


STDMETHODIMP CDefObject::DoVerb( LONG iVerb, LPMSG lpmsg,
                    LPOLECLIENTSITE pActiveSite, LONG lindex,
                    HWND hwndParent, const RECT * lprcPosRect)
{
    VDATEHEAP();
    VDATETHREAD(this);

    BOOL            bStartedNow = FALSE;
    HRESULT         hresult;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::DoVerb "
        "( %ld , %p , %p , %ld , %lx , %p )\n", this,
        iVerb, lpmsg, pActiveSite, lindex, hwndParent, lprcPosRect));


    if( lpmsg )
    {
        VDATEPTRIN( lpmsg, MSG );
    }

    if (pActiveSite)
    {
        VDATEIFACE( pActiveSite );
    }

    if( lprcPosRect )
    {
        VDATEPTRIN(lprcPosRect, RECT);
    }

    CRefStabilize stabilize(this);

    if (lindex != 0 && lindex != -1)
    {
        hresult = DV_E_LINDEX;
        goto errRtn;
    }

    if (!IsRunning())
    {
        if( FAILED(hresult = Run(NULL)) )
        {
            goto errRtn;
        }
        bStartedNow = TRUE;
    }

#ifdef SERVER_HANDLER
    if (m_pEmbSrvHndlrWrapper)
    {
        LPOLECLIENTSITE pOleClientSite = NULL;
        BOOL fUseRunClientSite = FALSE;

        // Marshal the ClientSite based on if same ClientSite passed in Run
        if ( m_pRunClientSite && (m_pRunClientSite == pActiveSite))
        {
            pOleClientSite = NULL;
            fUseRunClientSite = TRUE;

        }
        else
        {
            pOleClientSite = pActiveSite;
            fUseRunClientSite = FALSE;

        }

        // Todo: Can prefetch information to pass along to ClientSiteHandler.
        hresult = m_pEmbSrvHndlrWrapper->DoVerb(iVerb, lpmsg,
                                                fUseRunClientSite, pOleClientSite, lindex, hwndParent, lprcPosRect);
    }
    else
#endif // SERVER_HANDLER
    {
        if( !GetOleDelegate() )
        {
            hresult = E_NOINTERFACE;
        }
        else
        {
            hresult = m_pOleDelegate->DoVerb(iVerb, lpmsg, pActiveSite,
                    lindex, hwndParent, lprcPosRect);
        }
    }

    if (FAILED(hresult) && bStartedNow)
    {
        Close(OLECLOSE_NOSAVE);
    }


errRtn:
    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::DoVerb "
        "( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::EnumVerbs
//
//  Synopsis:   Enumerates the verbs that an object supports
//
//  Effects:
//
//  Arguments:  [ppenumOleVerb] -- where to put the verb enumerator
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  delegates to the cache (if running), otherwise looks it up
//              in the registration database
//
//  History:    dd-mmm-yy Author    Comment
//              07-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::EnumVerbs( IEnumOLEVERB ** ppenumOleVerb)
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT         hresult;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::EnumVerbs "
        "( %p )\n", this, ppenumOleVerb));

    VDATEPTROUT( ppenumOleVerb, IEnumOLEVERB FAR );

    CRefStabilize stabilize(this);

    *ppenumOleVerb = NULL;

    if( IsRunning() && GetOleDelegate() )
    {

        hresult = m_pOleDelegate->EnumVerbs (ppenumOleVerb);

        if (!GET_FROM_REGDB(hresult))
        {
            goto errRtn;
        }
    }
    // Not running, or object deferred to us, so interrogate reg db
    hresult = OleRegEnumVerbs( m_clsidServer, ppenumOleVerb);

errRtn:
    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::EnumVerbs "
        "( %lx ) [ %p ]\n", this, hresult, *ppenumOleVerb));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::Update
//
//  Synopsis:   Brings any caches or views up-to-date
//
//  Effects:    may launch the server (if not already running)
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  delegates to the server, launching it if it is not
//              already running
//
//  History:    dd-mmm-yy Author    Comment
//              07-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::Update( void )
{
    VDATEHEAP();
    VDATETHREAD(this);

    BOOL            bStartedNow = FALSE;
    HRESULT         hresult = NOERROR;
    HRESULT         hrLock;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::Update ( )\n", this ));

    CRefStabilize stabilize(this);

    if( (m_flags & DH_STATIC) )
    {
        hresult = OLE_E_STATIC;
        goto errRtn;
    }

    if (!IsRunning())
    {
        if( FAILED(hresult = Run(NULL)))
        {
            goto errRtn;
        }
        bStartedNow = TRUE;
    }

    // as a convenience to the server, we make the connection strong
    // for the duration of the update; thus, if lock container (of
    // embedings of this server) is done with co lock obj external,
    // nothing special need be done.
    hrLock = LockRunning(TRUE, FALSE);

    if( GetOleDelegate() )
    {
        hresult = m_pOleDelegate->Update();
    }

    if (hresult == NOERROR)
    {
        m_flags &= ~DH_INIT_NEW;

        if (bStartedNow)
        {
            hresult = m_pCOleCache->UpdateCache(
                    GetDataDelegate(),
                    UPDFCACHE_ALLBUTNODATACACHE,
                    NULL);
        }
        else
        {
            // already running...
            // normal caches would have got updated as a result
            // of SendOnDataChange of the object.
            hresult = m_pCOleCache->UpdateCache(
                    GetDataDelegate(),
                    UPDFCACHE_IFBLANKORONSAVECACHE,
                    NULL);
        }
    }

    // balance lock above; do not release on last unlock; i.e., siliently
    // restore to the state before this routine was called.
    if( hrLock == NOERROR )
    {
        LockRunning(FALSE, FALSE);
    }

    if( bStartedNow )
    {
        Close(OLECLOSE_SAVEIFDIRTY);
    }

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::Update "
        "( %lx )\n", this, hresult ));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::IsUpToDate
//
//  Synopsis:   returns whether or not the embedding is up-to-date
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    HRESULT (NOERROR == is up to date)
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  delegates to the server if it is running
//
//  History:    dd-mmm-yy Author    Comment
//              07-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::IsUpToDate(void)
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT         hresult;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::IsUpToDate ( )\n", this));

    CRefStabilize stabilize(this);

    if( (m_flags & DH_STATIC) )
    {
        hresult = NOERROR;
    }
    else if( IsRunning() && GetOleDelegate() )
    {
        // if running currently, propogate call; else fail
        hresult =  m_pOleDelegate->IsUpToDate();
    }
    else
    {
        hresult = OLE_E_NOTRUNNING;
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::IsUpToDate "
        "( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::SetExtent
//
//  Synopsis:   Set's the size boundaries on an object
//
//  Effects:
//
//  Arguments:  [dwDrawAspect]  -- the drawing aspect (such as ICON, etc)
//              [lpsizel]       -- the new size (in HIMETRIC)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  delegates to the server if running
//
//  History:    dd-mmm-yy Author    Comment
//              07-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::SetExtent( DWORD dwDrawAspect, LPSIZEL lpsizel )
{
    VDATEHEAP();
    VDATETHREAD(this);


    HRESULT         hresult;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::SetExtent "
        "( %lu , %p )\n", this, dwDrawAspect, lpsizel));

    VDATEPTRIN( lpsizel, SIZEL );

    CRefStabilize stabilize(this);


    if( (m_flags & DH_STATIC) )
    {
        hresult = OLE_E_STATIC;
    }
    else if( IsRunning() && GetOleDelegate() )
    {
        hresult = m_pOleDelegate->SetExtent(dwDrawAspect, lpsizel);
    }
    else
    {
        hresult = OLE_E_NOTRUNNING;
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::SetExtent "
        "( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::GetExtent
//
//  Synopsis:   Retrieve the size of the object
//
//  Effects:
//
//  Arguments:  [dwDrawAspect]  -- the drawing aspect (such as icon)
//              [lpsizel]       -- where to put the size
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  Tries the server first, the the cache if that fails
//
//  History:    dd-mmm-yy Author    Comment
//              07-Nov-93 alexgo    32bit port
//
//  Notes:      Hacks for bogus WordArt2.0 app.
//              REVIEW32:  We may want to take them out for 32bit
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::GetExtent( DWORD dwDrawAspect, LPSIZEL lpsizel )
{
    VDATEHEAP();
    VDATETHREAD(this);

    VDATEPTROUT(lpsizel, SIZEL);

    HRESULT     hresult = NOERROR;
    BOOL        fNoDelegate = TRUE;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::GetExtent "
        "( %lu , %p )\n", this, dwDrawAspect, lpsizel));

    CRefStabilize stabilize(this);

    lpsizel->cx = 0;
    lpsizel->cy = 0;

    // if server is running try to get extents from the server
    if( IsRunning() && GetOleDelegate() )
    {
        fNoDelegate = FALSE;
        hresult = m_pOleDelegate->GetExtent(dwDrawAspect, lpsizel);
    }

    // if there is error or object is not running or WordArt2 returns zero
    // extents, then get extents from Cache
    if (hresult != NOERROR || fNoDelegate || (0==lpsizel->cx &&
        0==lpsizel->cy))
    {
        // Otherwise try to get extents from cache
        Assert(m_pCOleCache != NULL);
        hresult = m_pCOleCache->GetExtent(dwDrawAspect,
            lpsizel);
    }

    // WordArt2.0 is giving negative extents!!
    if (SUCCEEDED(hresult)) {
        lpsizel->cx = LONG_ABS(lpsizel->cx);
        lpsizel->cy = LONG_ABS(lpsizel->cy);
    }


    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::GetExtent "
        "( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::Advise
//
//  Synopsis:   Sets up an advise connection for things like close, save,
//              rename, etc.
//
//  Effects:    Creates an OleAdviseHolder
//
//  Arguments:  [pAdvSink]      -- whom to advise
//              [pdwConnection] -- where to put the connection ID
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  delegates to the server and creates a an OleAdviseHolder
//              if one doesn't already exist
//
//  History:    dd-mmm-yy Author    Comment
//              07-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT         hresult;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::Advise "
        "( %p , %p )\n", this, pAdvSink, pdwConnection));

    VDATEIFACE( pAdvSink );
    VDATEPTROUT( pdwConnection, DWORD );

    CRefStabilize stabilize(this);

    *pdwConnection = NULL;

    if( (m_flags & DH_STATIC) )
    {
        hresult = OLE_E_STATIC;
        goto errRtn;
    }


    // if defhndlr got running without going through run, setup advise.
    // The call to run (via ProxyMgr::Connect) always comes before any
    // other method call in the default handler.  Thus it is safe to
    // assume that there is no earlier point by which this advise (or any
    // other of the calls) should have been done.
    if( IsRunning() && m_dwConnOle == 0L && GetOleDelegate() )
    {
        if( IsZombie() )
        {
            hresult = CO_E_RELEASED;
            goto errRtn;
        }

        // delegate to the server
        hresult = m_pOleDelegate->Advise((IAdviseSink *)&m_AdviseSink,
                            &m_dwConnOle);

        if( hresult != NOERROR )
        {
            goto errRtn;
        }
    }

    // if we are in a zombie state, we shouldn't go allocate more
    // memory.

    if( IsZombie() )
    {
        hresult = CO_E_RELEASED;
    }

    if( m_pOAHolder == NULL )
    {
        hresult = CreateOleAdviseHolder((IOleAdviseHolder **)&m_pOAHolder);
        if( hresult != NOERROR )
        {
            goto errRtn;
        }
    }

    // stuff the advise notification in our advise holder
    hresult = m_pOAHolder->Advise(pAdvSink, pdwConnection);

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::Advise "
        "( %lx ) [ %lu ]\n", this, hresult,
        (pdwConnection)? *pdwConnection : 0));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::COleObjectImpl::Unadvise
//
//  Synopsis:   Tears down an advise connection
//
//  Effects:
//
//  Arguments:  [dwConnection]  -- the connection to destroy
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              07-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::Unadvise(DWORD dwConnection)
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT         hresult;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::Unadvise "
        "( %lu )\n", this, dwConnection));

    CRefStabilize stabilize(this);

    if( m_pOAHolder == NULL )
    {
        // no one registered
        hresult = OLE_E_NOCONNECTION;
    }
    else
    {
        hresult = m_pOAHolder->Unadvise(dwConnection);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::Unadvise "
        "( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::EnumAdvise
//
//  Synopsis:   Enumerate the advises currently established
//
//  Effects:
//
//  Arguments:  [ppenumAdvise]  -- where to put the advise enumerator
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              07-Nov-93 alexgo    32bit port
//
//  Notes:      We do NOT need to stabilize because EnumAdvise only
//      allocates some memory for an enumerator and returns.
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::EnumAdvise( LPENUMSTATDATA *ppenumAdvise )
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT         hresult;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::EnumAdvise "
        "( *p )\n", this, ppenumAdvise));

    VDATEPTROUT( ppenumAdvise, LPENUMSTATDATA );
    *ppenumAdvise = NULL;

    if( m_pOAHolder == NULL )
    {
        // no one registered
        hresult = E_UNSPEC;
    }
    else
    {
        hresult = m_pOAHolder->EnumAdvise(ppenumAdvise);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::EnumAdvise "
        "( %lx ) [ %p ]\n", this, hresult, *ppenumAdvise));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::GetMiscStatus
//
//  Synopsis:   Get misc status bits, such as OLEMISC_ONLYICONIC
//
//  Effects:
//
//  Arguments:  [dwAspect]      -- the drawing aspect we're concerned about
//              [pdwStatus]     -- where to put the status bits
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  Delegates to the server.  If not there, or if it returns
//              OLE_E_USEREG, then lookup in the registration database
//
//  History:    dd-mmm-yy Author    Comment
//              07-Nov-93 alexgo    32bit port
//              20-Nov-96 Gopalk    Cache MiscStatus bits
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::GetMiscStatus( DWORD dwAspect, DWORD *pdwStatus)
{
    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::GetMiscStatus(%lu, %p)\n",
                this, dwAspect, pdwStatus));

    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);
    VDATEPTROUT(pdwStatus, DWORD);

    // Local variables
    HRESULT hresult;

    // Stabilize
    CRefStabilize stabilize(this);

    // Initialize
    *pdwStatus = 0;
    hresult = OLE_S_USEREG;

    if(IsRunning()) {
#ifdef SERVER_HANDLER
        if(m_pEmbSrvHndlrWrapper && (DVASPECT_CONTENT == dwAspect)) {
            *pdwStatus = m_ContentMiscStatusUser;
            hresult = m_hresultContentMiscStatus;
        }
        else
#endif // SERVER_HANDLER
        if(GetOleDelegate()) {
            // Check if MiscStatus bits have been cached for this instance
            // of server for DVASPECT_CONTENT
            if(m_ContentSRVMSHResult != 0xFFFFFFFF &&
               dwAspect == DVASPECT_CONTENT) {
                *pdwStatus = m_ContentSRVMSBits;
                hresult = m_ContentSRVMSHResult;
            }
            else {
                // Ask the running server
                hresult = m_pOleDelegate->GetMiscStatus(dwAspect, pdwStatus);

                // Cache the server MiscStatus bits for DVASPECT_CONTENT
                if(dwAspect == DVASPECT_CONTENT) {
                    m_ContentSRVMSBits = *pdwStatus;
                    m_ContentSRVMSHResult = hresult;
                }
            }
        }
    }

    // Check if we have to obtain MiscStatus bits from the registry
    if (GET_FROM_REGDB(hresult)) {
        // Check if registry MiscStatus bits have been cached for DVASPECT_CONTENT
        if(m_ContentREGMSHResult != 0xFFFFFFFF && dwAspect == DVASPECT_CONTENT) {
            *pdwStatus = m_ContentREGMSBits;
            hresult = m_ContentREGMSHResult;
        }
        else {
            // Hit the registry
            hresult = OleRegGetMiscStatus (m_clsidServer, dwAspect, pdwStatus);
            if(hresult == NOERROR) {
                // Update the MiscStatus flags
                if((m_flags & DH_STATIC))
                    (*pdwStatus) |= (OLEMISC_STATIC | OLEMISC_CANTLINKINSIDE);
                else if(CoIsOle1Class(m_clsidServer))
                    (*pdwStatus) |=  OLEMISC_CANTLINKINSIDE;

                // Cache the registry MiscStatus bits for DVASPECT_CONTENT
                if(dwAspect == DVASPECT_CONTENT) {
                    m_ContentREGMSBits = *pdwStatus;
                    m_ContentREGMSHResult = hresult;
                }
            }
        }
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::GetMiscStatus(%lx) [%lx]\n",
                this, hresult, *pdwStatus));
    return hresult;
}
//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::SetColorScheme
//
//  Synopsis:   Sets the palette for an object
//
//  Effects:
//
//  Arguments:  [lpLogpal]      -- the palette
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  Delegates to the server
//
//  History:    dd-mmm-yy Author    Comment
//              07-Nov-93 alexgo    32bit
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::SetColorScheme( LPLOGPALETTE lpLogpal )
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT         hresult;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::SetColorScheme "
        "( %p )\n", this, lpLogpal));

    CRefStabilize stabilize(this);

    if( (m_flags & DH_STATIC) )
    {
        hresult = OLE_E_STATIC;
    }
    else if( lpLogpal == NULL || lpLogpal->palNumEntries == NULL)
    {
        hresult = E_INVALIDARG;
    }
    else if( IsRunning() && GetOleDelegate() )
    {
        hresult = m_pOleDelegate->SetColorScheme (lpLogpal);
    }
    else
    {
        hresult = OLE_E_NOTRUNNING;
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::SetColorScheme "
        "( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::GetUserClassID
//
//  Synopsis:   Retrieves the class ID for the object
//
//  Effects:
//
//  Arguments:  [pClassID]      -- where to put the class ID
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  Delegates to the server, or if not running (or if it
//              fails the delegated call), then we attempt
//              to get the class id from the storage.
//
//  History:    dd-mmm-yy Author    Comment
//              07-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::GetUserClassID( CLSID *pClassID )
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT         hresult;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::GetUserClassID "
        "( %p )\n", this, pClassID));

    VDATEPTROUT(pClassID, CLSID);

    CRefStabilize stabilize(this);

    if( IsRunning() )
    {
#ifdef SERVER_HANDLER
        if (m_pEmbSrvHndlrWrapper )
        {
            *pClassID = m_clsidUser;
            hresult = m_hresultClsidUser;
            goto errRtn;

        }
        else
#endif // SERVER_HANDLER
    if ( GetOleDelegate() )
        {
            hresult = m_pOleDelegate->GetUserClassID(pClassID);
            // success!  We don't have to figure it out ourselves, so
            // skip to the end and exit
            if (hresult == NOERROR )
            {
                goto errRtn;
            }
        }
    }

    if( !IsEqualCLSID(m_clsidServer, CLSID_NULL) )
    {
        *pClassID = m_clsidServer;
        hresult = NOERROR;
    }
    else
    {
        hresult = GetClassBits(pClassID);
    }

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::GetUserClassID "
        "( %lx ) [ %p ]\n", this, hresult, pClassID));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::GetUserType
//
//  Synopsis:   Gets a descriptive string about the object for the user
//
//  Effects:
//
//  Arguments:  [dwFromOfType]  -- whether to get a short/long/etc version
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  Delegates to the server, failing that, trys the registration
//              database, failing that, tries to read from the storage
//
//  History:    dd-mmm-yy Author    Comment
//              07-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::GetUserType( DWORD dwFormOfType,
                    LPOLESTR *ppszUserType)
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT hresult;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::GetUserType "
        "( %lu , %p )\n", this, dwFormOfType, ppszUserType));

    VDATEPTROUT(ppszUserType, LPOLESTR);

    CRefStabilize stabilize(this);

    *ppszUserType = NULL;

    if( IsRunning() && GetOleDelegate() )
    {
        hresult = m_pOleDelegate->GetUserType (dwFormOfType,
            ppszUserType);

        if (!GET_FROM_REGDB(hresult))
        {
            goto errRtn;
        }
    }

    if( (hresult = OleRegGetUserType( m_clsidServer, dwFormOfType,
                ppszUserType)) == NOERROR)
    {
        goto errRtn;
    }


    // Try reading from storage
    // This really ugly bit of 16bit code tries to read the user type
    // from the storage. If that fails, then we look in the registry

    if( NULL == m_pStg ||
        NOERROR != (hresult = ReadFmtUserTypeStg(m_pStg, NULL, ppszUserType)) ||
        NULL == *ppszUserType )
    {
        OLECHAR sz[256];
        long    cb = sizeof(sz);// ReqQueryValue expects
                                // a *byte* count
        *ppszUserType = UtDupString (
            (ERROR_SUCCESS ==
            QueryClassesRootValue (OLESTR("Software\\Microsoft\\OLE2\\UnknownUserType"),
                sz, &cb))
            ? (LPCOLESTR)sz : OLESTR("Unknown"));

        if (NULL != *ppszUserType)
        {
            hresult =  NOERROR;
        }
        else
        {
            hresult = E_OUTOFMEMORY;
        }
    }

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::GetUserType "
        "( %lx ) [ %p ]\n", this, hresult, *ppszUserType));


    return hresult;
}

/*
*      IMPLEMENTATION of CROImpl methods
*
*      We never delegate to the server. This is by design.
*/


//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::GetRunningClass
//
//  Synopsis:   Get the class id of the server
//
//  Effects:
//
//  Arguments:  [lpClsid]       -- where to put the class id
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IRunnableObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              07-Nov-93 alexgo    32bit port
//
//  Notes:      We do not need to stabilize this call as no outgoing
//              calls are made.
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::GetRunningClass(LPCLSID lpClsid)
{
    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::GetRunningClass "
        "( %p )\n", this, lpClsid));

    VDATEPTROUT(lpClsid, CLSID);

    *lpClsid = m_clsidServer;

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::GetRunningClass "
        "( %lx ) [ %p ]\n", this, NOERROR, lpClsid));

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::Run
//
//  Synopsis:   Sets the object running (if it isn't already)
//
//  Effects:    may launch the server
//
//  Arguments:  [pbc]   -- the bind context (unused)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IRunnableObject
//
//  Algorithm:  If already running, return.  Otherwise, get the proxy
//              manager to create the server.  Initialize the storage
//              and caches, and set the host name for the server's window.
//
//  History:    dd-mmm-yy Author    Comment
//              07-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


STDMETHODIMP CDefObject::Run(LPBINDCTX pbc)
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT                         hresult;
    IDataObject FAR*                pDataDelegate = NULL;
    IOleObject FAR*                 pOleDelegate = NULL;
    IPersistStorage FAR*            pPStgDelegate = NULL;
    IMoniker FAR*                   pmk = NULL;
    BOOL                            fLockedContainer;
    DWORD                           dwMiscStatus = 0;

    // NOTE: ignore pbc for now

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::Run ( %p )\n", this, pbc));

    CRefStabilize stabilize(this);

    if( IsRunning() )
    {
        hresult = S_OK;
        // just return the error code
        goto errRtn2;
    }

    if( (m_flags & DH_STATIC) )
    {
        hresult = OLE_E_STATIC;
        goto errRtn2;
    }


    if( IsZombie() )
    {
        hresult = CO_E_RELEASED;
        goto errRtn2;
    }

    if( FAILED(hresult = CreateDelegate()) )
    {
        // just return the error code
        goto errRtn2;
    }

    if (m_pProxyMgr != NULL)
    {

#ifdef  SERVER_HANDLER
        IServerHandler *pSrvHndl = NULL;

        hresult = m_pProxyMgr->CreateServerWithEmbHandler(m_clsidServer,
                                        CLSCTX_LOCAL_SERVER   | CLSCTX_ESERVER_HANDLER ,
                                        IID_IServerHandler,(void **) &pSrvHndl,NULL);
    if(FAILED(hresult))
        Win4Assert(NULL == pSrvHndl);
#else
        hresult = m_pProxyMgr->CreateServer(m_clsidServer,
                                            CLSCTX_LOCAL_SERVER,
                                            NULL);
#endif // SERVER_HANDLER

        if (FAILED(hresult))
        {
            goto errRtn;
        }

        // if there is a serverHandler, create a wrapper object for handling standard interfaces
#ifdef  SERVER_HANDLER
        if (pSrvHndl)
        {
            m_pEmbSrvHndlrWrapper = CreateEmbServerWrapper(m_pUnkOuter,pSrvHndl);
            pSrvHndl->Release();
        }
        else
        {
            m_pEmbSrvHndlrWrapper = NULL;
        }
#endif // SERVER_HANDLER
    }


    // NOTE: the lock state of the proxy mgr is not changed; it remembers
    // the state and sets up the connection correctly.

    // server is running; normally this coincides with locking the
    // container, but we keep a separate flag since locking the container
    // may fail.

    m_flags |= DH_FORCED_RUNNING;


    // Lock the container

    fLockedContainer = m_flags & DH_LOCKED_CONTAINER;

    DuLockContainer(m_pAppClientSite, TRUE, &fLockedContainer );

    if( fLockedContainer )
    {
        m_flags |= DH_LOCKED_CONTAINER;
    }
    else
    {
        m_flags &= ~DH_LOCKED_CONTAINER;
    }

#if DBG==1
    // In debug builds, update DH_LOCKFAILED flag
    if(fLockedContainer)
        m_flags &= ~DH_LOCKFAILED;
    else
        m_flags |= DH_LOCKFAILED;
#endif

#ifdef SERVER_HANDLER
    if (m_pEmbSrvHndlrWrapper)
    {
        MInterfacePointer *pIRDClientSite = NULL;
        CStdIdentity *pStdid = NULL;
        CClientSiteHandler *pClientSiteHandler = NULL;
        GUID riid = IID_IOleClientSite; //Reference to the identifier of the interface
        BOOL fHasIPSite = FALSE;
        IUnknown *pUnk = NULL; //Pointer to the interface to be marshaled
        CXmitRpcStream Stm;

        if (m_pAppClientSite)
        {

           // Only wrap ClientSite if there is not an existing Identity.
           if (NOERROR != LookupIDFromUnk(m_pAppClientSite, GetCurrentApartmentId(),0,&pStdid))
           {
                Assert(NULL == pClientSiteHandler);

                hresult = CreateClientSiteHandler(m_pAppClientSite,&pClientSiteHandler,&fHasIPSite);

                riid = IID_IClientSiteHandler;
                pUnk = (IUnknown *) (IClientSiteHandler *) pClientSiteHandler;
           }
           else
           {
                riid = IID_IOleClientSite;
                pUnk = (IUnknown *) (IOleClientSite*)  m_pAppClientSite;
                pUnk->AddRef();
           }

           hresult = CoMarshalInterface(&Stm,riid,
                                         pUnk,
                                         MSHCTX_DIFFERENTMACHINE,
                                         NULL, MSHLFLAGS_NORMAL);

            if (SUCCEEDED(hresult))
            {
                 Stm.AssignSerializedInterface((InterfaceData **) &pIRDClientSite);
            }

            m_pRunClientSite = m_pAppClientSite; // Remember ClientSite on Run.

        }

        Assert(m_dwConnOle == 0L);

        hresult = m_pEmbSrvHndlrWrapper->Run(m_flags,
                            riid,
                            pIRDClientSite,
                            fHasIPSite,
                            (LPOLESTR)m_pHostNames,
                            (LPOLESTR)(m_pHostNames + m_ibCntrObj),
                            (IStorage *) m_pStg,
                            (IAdviseSink *) &m_AdviseSink,
                            &m_dwConnOle,
                            &m_hresultClsidUser,
                            &m_clsidUser,
                            &m_hresultContentMiscStatus,
                            &m_ContentMiscStatusUser
                        );

        if (pIRDClientSite)
            CoTaskMemFree(pIRDClientSite);

        if (pStdid)
            pStdid->Release();

        if (pUnk)
            pUnk->Release();


        // !!! Make sure on error don't set up Cache.
        if (NOERROR != hresult)
        {
            goto errRtn;
        }

        // set up any cached interfaces
        // !!!!!TODO: Not All LeSuite Linking Tests Pass when Cache DataObject through ServerHandler.
        if (!m_pDataDelegate)
        {
            if (NOERROR == m_pEmbSrvHndlrWrapper->m_Unknown.QueryInterface(IID_IDataObject,(void **) &m_pDataDelegate))
            {
                m_pUnkOuter->Release();
            }
        }

    }
    else
#endif // SERVER_HANDLER
    {
        // Check if we have client site
        if(m_pAppClientSite) {
            // Clear the cached MiscStatus bits
            m_ContentSRVMSBits = 0;
            m_ContentSRVMSHResult = 0xFFFFFFFF;

            // Get MiscStatus bits from the running server
            hresult = GetMiscStatus(DVASPECT_CONTENT, &dwMiscStatus);

            // Set the client site first if OLEMISC_SETCLIENTSITEFIRST bit is set
            if(hresult == NOERROR && (dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST) &&
               (pOleDelegate = GetOleDelegate()))
                hresult = pOleDelegate->SetClientSite(m_pAppClientSite);
            else if(hresult != NOERROR) {
                hresult = NOERROR;
                dwMiscStatus = 0;
            }
        }
        if(hresult != NOERROR)
            goto errRtn;

        if( pPStgDelegate = GetPSDelegate() )
        {
            if( m_pStg)
            {
                if( (m_flags & DH_INIT_NEW) )
                {
                    hresult = pPStgDelegate->InitNew(m_pStg);
                }
                else
                {
                    hresult = pPStgDelegate->Load(m_pStg);
                }
                if (hresult != NOERROR)
                {
                    // this will cause us to stop the
                    // the server we just launced
                    goto errRtn;
                }
            }
        }


        if(pOleDelegate || (pOleDelegate = GetOleDelegate()))
        {
            // REVIEW MM1: what are we supposed to do in case of failure
            if(m_pAppClientSite && !(dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST))
            {
                pOleDelegate->SetClientSite(m_pAppClientSite);
            }

            if (m_pHostNames)
            {
                if (hresult = pOleDelegate->SetHostNames((LPOLESTR)m_pHostNames,
                        (LPOLESTR)(m_pHostNames + m_ibCntrObj))
                        != NOERROR)
                {
                    goto errRtn;
                }
            }

            // set single ole advise (we multiplex)
            Assert(m_dwConnOle == 0L);

            if ((hresult = pOleDelegate->Advise((IAdviseSink *)&m_AdviseSink,
                &m_dwConnOle)) != NOERROR)
            {
                goto errRtn;
            }

            if(m_pAppClientSite != NULL &&
                m_pAppClientSite->GetMoniker
                    (OLEGETMONIKER_ONLYIFTHERE,
                    OLEWHICHMK_OBJREL, &pmk) == NOERROR)
            {
                AssertOutPtrIface(NOERROR, pmk);
                pOleDelegate->SetMoniker(OLEWHICHMK_OBJREL, pmk);
                pmk->Release();
            }

        }

    }

    Win4Assert(NOERROR == hresult);

    if( pDataDelegate = GetDataDelegate() )
    {
        // inform cache that we are running
        Assert(m_pCOleCache != NULL);

        m_pCOleCache->OnRun(pDataDelegate);

        // Enumerate all the advises we stored while we were either not
        // running or running the previous time, and send them to the
        // now-running object.
        m_pDataAdvCache->EnumAndAdvise(pDataDelegate, TRUE);
    }



errRtn:
    if(hresult == NOERROR) {
        // Clear the cached MiscStatus bits if not cleared before
#ifdef SERVER_HANDLER
        if(m_pEmbSrvHndlrWrapper) {
            m_ContentSRVMSBits = 0;
            m_ContentSRVMSHResult = 0xFFFFFFFF;
        }
        else
#endif // SERVER_HANDLER
        if(!m_pAppClientSite) {
            m_ContentSRVMSBits = 0;
            m_ContentSRVMSHResult = 0xFFFFFFFF;
        }
    }
    else {
        // Stop the running object
        Stop();

        // Assert that the container is not locked
        Win4Assert(!(m_flags & DH_LOCKED_CONTAINER) && !(m_flags & DH_LOCKFAILED));
    }

errRtn2:

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::Run "
        "( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::Stop
//
//  Synopsis:   Undoes some of Run() (stops the server)...internal function
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:  unadvise connections (if any), stop the cache, disconnect
//              from the proxy manager and unlock the container
//
//  History:    dd-mmm-yy Author    Comment
//              07-Nov-93 alexgo    32bit port
//
//  Notes:
//
// undo effects of Run(); some of this work is done also in IsRunning
// when we detect we are not running (in case the server crashed).
//--------------------------------------------------------------------------

INTERNAL CDefObject::Stop (void)
{
    BOOL fLockedContainer;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CDefObject::CROImpl::Stop "
        "( )\n", this));

    CRefStabilize stabilize(this);

    if( !IsRunning() )
    {
        // NOTE: ISRUNNING below does some of this cleanup
        goto errRtn;    // return NOERROR
    }

    // NOTE: we cleanup connections which point directly back to us;
    // connections which point back to the app (e.g, the clientsite and
    // data advise) are left alone; an app must know how to use
    // CoDisconnectObject if deterministic shutdown is desired.
    if( m_dwConnOle != 0L && GetOleDelegate() )
    {
        m_pOleDelegate->Unadvise(m_dwConnOle);
        m_dwConnOle = 0L;
    }

    if( m_pDataDelegate )
    {
        m_pDataAdvCache->EnumAndAdvise(m_pDataDelegate, FALSE);
    }

    // inform cache that we are not running (Undoes advise)
    Assert(m_pCOleCache != NULL);
    m_pCOleCache->OnStop();

#ifdef SERVER_HANDLER
    if (m_pEmbSrvHndlrWrapper)
    {
        CEmbServerWrapper *pSrvHndlr = m_pEmbSrvHndlrWrapper;

        m_pEmbSrvHndlrWrapper = NULL;
        m_pRunClientSite = NULL;

        // need to release any interfaces the Handler Wraps
        if(m_pDataDelegate)
        {
            m_pUnkOuter->AddRef();
            SafeReleaseAndNULL((IUnknown **)&m_pDataDelegate);
        }

        // NULL out m_pSrvHndl before Release since out call could case re-entrance.
        pSrvHndlr->m_Unknown.Release();
    }
#endif // SERVER_HANDLER

#if DBG==1
    // In debug builds, set DH_WILLUNLOCK flag
    m_flags |= DH_WILLUNLOCK;
#endif

    // Reset DH_FORCED_RUNNING flag and disconnect proxy manager
    m_flags &= ~DH_FORCED_RUNNING;
    if(m_pProxyMgr)
        m_pProxyMgr->Disconnect();

    // Unlock the container site
    fLockedContainer = (m_flags & DH_LOCKED_CONTAINER);
    if(fLockedContainer) {
        m_flags &= ~DH_LOCKED_CONTAINER;
        DuLockContainer(m_pAppClientSite, FALSE, &fLockedContainer);
    }
    Win4Assert(!fLockedContainer);
#if DBG==1
    // In debug builds, reset the DH_LOCKFAILED and DH_WILLUNLOCK flags
    m_flags &= ~DH_LOCKFAILED;
    m_flags &= ~DH_WILLUNLOCK;
#endif

errRtn:
    LEDebugOut((DEB_ITRACE, "%p OUT CDefObject::Stop "
        "( %lx )\n", this, NOERROR ));

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::IsRunning
//
//  Arguments:  None
//
//  Returns:    BOOL
//
//  Derivation: IRunnableObject
//
//  Notes:      Detects if the local server has crashed and does cleanup
//              so that the user can activate the embedding in the same
//              session.
//
//  History:    dd-mmm-yy Author    Comment
//              06-Dec-96 Gopalk    Rewritten
//--------------------------------------------------------------------------

STDMETHODIMP_(BOOL) CDefObject::IsRunning(void)
{
    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::IsRunning()\n", this));

    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);

    // Local variable
    BOOL fReturn = FALSE;
    HRESULT hStatus;

    CRefStabilize stabilize(this);

    // Check if the inner object has been created
    if(m_pUnkDelegate) {
        // DEFHANDLER either has proxy manager as the inner object
        // for out of proc server objects or actual server as the
        // inner object for inproc server objects.
        // Assert that this is TRUE
        Win4Assert((m_pProxyMgr != NULL) == !!(m_flags & DH_INPROC_HANDLER));
        if(m_pProxyMgr) {
            // Out of proc server object.
            // Check with the proxy manager whether it is connected to the
            // server object. We cannot rely on the DH_FORCED_RUNNING flag
            // to indicate run status because the DEFHANDLER could have been
            // marshaled from the embedding conatiner and unmarshaled in the
            // link container. The DEFHANDLER created by unmarshaling in the
            // link container is always in the running state due to the
            // requirement that IOleItemContainer::GetObject is required to
            // put the embedding in running state when its bind speed
            // parameter permits, else it is supposed to return
            // MK_E_EXCEEDEDDEADLINE. Further, CoMarshalInterface fails
            // if the the proxy manager is not connected
            fReturn = m_pProxyMgr->IsConnected();
            if(fReturn) {
                // The proxymanager is connected to the server object
                // Check the status of connection with the server object
                hStatus = m_pProxyMgr->GetConnectionStatus();
                if(hStatus != S_OK) {
                    // Either Server object called CoDisconnectObject or
                    // its apartment crashed or unitialized breaking the
                    // external connection to the objects in that apartment
                    // Clean up the state
                    Win4Assert(!"Local Server crashed or disconnected");

                    // Reset flags
                    m_flags &= ~DH_FORCED_RUNNING;

                    // Reset advise connection and recover the references
                    // placed by the server on the handler advise sink
                    m_dwConnOle = 0L;
                    CoDisconnectObject((IUnknown *) &m_AdviseSink, 0);

                    // Inform cache that the local server crashed
                    if(m_pCOleCache)
                        m_pCOleCache->OnCrash();

                    // Inform and cleanup data advice cache
                    m_pDataAdvCache->EnumAndAdvise(NULL, FALSE);

                    // Unlock the container if it is was locked
                    BOOL fCurLock = !!(m_flags & DH_LOCKED_CONTAINER);

                    if(fCurLock) {
                        DuLockContainer(m_pAppClientSite, FALSE, &fCurLock);
                        m_flags &= ~DH_LOCKED_CONTAINER;
                    }
                    Win4Assert(!fCurLock);
#if DBG==1
                    // In debug builds, reset DH_LOCKFAILED flag
                    m_flags &= ~DH_LOCKFAILED;
#endif

                    // Inform ProxyManager to disconnect
                    m_pProxyMgr->Disconnect();

                    // Reset fReturn
                    fReturn = FALSE;
                }
            }
        }
        else {
            // Inproc server object.
            // COM supports self embedding by allowing separate class
            // objects to be registered for instatiating INPROC_SERVER
            // and LOCAL_SERVER objects. Apps typically ask the Default
            // handler to aggregate their INPROC_SERVER objects by
            // using OleCreateEmbeddingHelper api so that embedding
            // interfaces like IViewObject are supported. But this
            // creates problem for self linking because link moniker
            // binds to inproc servers in preference to local servers.
            // As the inproc server object obtained from the INPROC_SERVER
            // class factory is the default handler, it will not delegate
            // method calls to the actual server object unless it thinks that
            // the local object is running. Below we check if we are dealing
            // with an embedded object using the assumption that embedded objects
            // are initialized through IStorage. The above assumption is
            // questionable but we are helpless.
            if (!(m_flags & DH_EMBEDDING) || (m_flags & DH_FORCED_RUNNING))
                fReturn = TRUE;
        }
    }
    else
        Win4Assert((m_flags & DH_DELAY_CREATE) && m_pCFDelegate != NULL);

    // Sanity checks
    if(fReturn) {
        if(m_flags & DH_FORCED_RUNNING) {
            Win4Assert((m_flags & DH_LOCKED_CONTAINER) || (m_flags & DH_LOCKFAILED));
            Win4Assert(!(m_flags & DH_UNMARSHALED));
        }
        else if(m_pProxyMgr) {
            Win4Assert(!m_pAppClientSite);
            Win4Assert(!m_pStg);
            Win4Assert(!(m_flags & DH_LOCKED_CONTAINER));
            Win4Assert(!(m_flags & DH_LOCKFAILED));
            Win4Assert(m_flags & DH_UNMARSHALED);
            Win4Assert(!(m_flags & DH_EMBEDDING));
        }
    }
    else {
        if(!(m_flags & DH_OLE1SERVER)) {
            // DDE IProxyManager::IsConnected returns FLASE until
            // either IPersistStorage::Load or IPersistStorage::InitNew
            // is called on it
            Win4Assert(!(m_flags & DH_FORCED_RUNNING));
            Win4Assert((m_flags & DH_WILLUNLOCK) || !(m_flags & DH_LOCKED_CONTAINER));
            Win4Assert((m_flags & DH_WILLUNLOCK) || !(m_flags & DH_LOCKFAILED));
        }
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::IsRunning(%lu)\n", this, fReturn));

    return fReturn;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::SetContainedObject
//
//  Synopsis:   sets the embedding status of an object
//
//  Effects:
//
//  Arguments:  [fContained]    --  TRUE indicates we are an embedding/
//                                  FALSE otherwise
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IRunnableObject
//
//  Algorithm:  Sets flags, if we are an improc handler, we will call
//              IRunnableObject->LockRunning(FALSE) to unlock ourselves
//
//  History:    dd-mmm-yy Author    Comment
//              08-Nov-93 alexgo    32bit port
//
//  Notes:
//              note that this is a contained object; this unlocks
//              connection to the server
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::SetContainedObject(BOOL fContained)
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT hresult = NOERROR;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::SetContainedObject "
        "( %lu )\n", this, fContained));

    CRefStabilize stabilize(this);

    if( !!(m_flags & DH_CONTAINED_OBJECT) != !!fContained)
    {
        // not contained in the same way as desired;
        // for inproc handler, [un]lock connection
        // for inproc server, just remember flag

        if( (m_flags & DH_INPROC_HANDLER) )
        {
            hresult = LockRunning(!fContained, FALSE);
        }

        if (hresult == NOERROR)
        {
            // the !! ensure exactly 0 or 1 will be stored in
            // m_fContainedObject

            if( fContained )
            {
                m_flags |= DH_CONTAINED_OBJECT;
            }
            else
            {
                m_flags &= ~DH_CONTAINED_OBJECT;
            }
        }
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::SetContainedObject "
        "( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::LockRunning
//
//  Synopsis:   Locks or unlocks the object
//
//  Effects:
//
//  Arguments:  [fLock]                 -- TRUE, then lock, unlock if FALSE
//              [fLastUnlockCloses]     -- shut down if unlocking the last
//                                         lock
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IRunnableObject
//
//  Algorithm:  If we are an improc server, call CoLockObjectExternal,
//              otherwise have the proxy manager lock us down.
//
//  History:    dd-mmm-yy Author    Comment
//              08-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::LockRunning(BOOL fLock, BOOL fLastUnlockCloses)
{
    VDATEHEAP();
    VDATETHREAD(this);


    HRESULT         hresult;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::LockRunning "
        "( %lu , %lu )\n", this, fLock, fLastUnlockCloses ));

    CRefStabilize stabilize(this);

    // else map to lock connection
    if( !(m_flags & DH_INPROC_HANDLER) )
    {
        // inproc server: use CoLockObjExternal; will close down
        // if invisible via new IExternalConnection interface.

        Assert(m_pProxyMgr == NULL);
        hresult = CoLockObjectExternal((IUnknown *)(IOleObject *)this, fLock,
                    fLastUnlockCloses); }
    else if( m_pUnkDelegate == NULL )
    {
        // NOTE: this really shouldn't happen at present
        // since we currently disallow delay create with
        // inproc handler.  In fact, the LockConnection below
        // is one of the reasons why we must have the
        // proxymgr upfront.  In the future we could force
        // the creation of the delegate here.
        Assert( (m_flags & DH_DELAY_CREATE) && m_pCFDelegate != NULL);
        hresult = NOERROR;
    }
    else
    {
        Assert(m_pProxyMgr != NULL);

        hresult = m_pProxyMgr->LockConnection(fLock, fLastUnlockCloses);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::LockRunning "
        "( %lx )\n", this, hresult));

    return hresult;
}


/*
*      IMPLEMENTATION of CECImpl methods
*
*/


//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::AddConnection
//
//  Synopsis:   Adds an external connection
//
//  Effects:
//
//  Arguments:  [extconn]       -- the type of connection (such as
//                                 EXTCONN_STRONG)
//              [reserved]      -- unused
//
//  Requires:
//
//  Returns:    DWORD -- the number of strong connections
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IExternalConnection
//
//  Algorithm:  keeps track of strong connections
//
//  History:    dd-mmm-yy Author    Comment
//              08-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(DWORD) CDefObject::AddConnection(DWORD extconn, DWORD reserved)
{
    VDATEHEAP();

    //
    // VDATETHREAD contains a 'return HRESULT' but this procedure expects to
    // return a DWORD.  Avoid the warning.
#if ( _MSC_VER >= 800 )
#pragma warning( disable : 4245 )
#endif
    VDATETHREAD(this);
#if ( _MSC_VER >= 800 )
#pragma warning( default : 4245 )
#endif

    DWORD   dwConn;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::AddConnection "
        "( %lu , %lu )\n", this, extconn, reserved));

    Assert( !(m_flags & DH_INPROC_HANDLER) );

    dwConn = extconn&EXTCONN_STRONG ? ++m_cConnections : 0;

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::AddConnection "
        "( %lu )\n", this, dwConn));

    return dwConn;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::ReleaseConnection
//
//  Synopsis:   Releases external connection, potentially calling IOO->Close
//
//  Effects:
//
//  Arguments:  [extconn]               -- the type of connection
//              [reserved]              -- unused
//              [fLastReleaseCloses]    -- call IOO->Close if its the last
//                                         release
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              08-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(DWORD) CDefObject::ReleaseConnection(DWORD extconn,
    DWORD reserved, BOOL fLastReleaseCloses)
{
    VDATEHEAP();

    //
    // VDATETHREAD contains a 'return HRESULT' but this procedure expects to
    // return a DWORD.  Avoid the warning.
#if ( _MSC_VER >= 800 )
#pragma warning( disable : 4245 )
#endif
    VDATETHREAD(this);
#if ( _MSC_VER >= 800 )
#pragma warning( default : 4245 )
#endif

    DWORD           dwConn;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::ReleaseConnection "
        "( %lu , %lu , %lu )\n", this, extconn, reserved,
        fLastReleaseCloses));

    CRefStabilize stabilize(this);

    // must be an embedding helper

    Assert( !(m_flags & DH_INPROC_HANDLER) );

    if( (extconn & EXTCONN_STRONG) && --m_cConnections == 0 &&
        fLastReleaseCloses)
    {
        // REVIEW: might want this to be close save if dirty.
        Close(OLECLOSE_NOSAVE);
    }

    dwConn = (extconn & EXTCONN_STRONG) ? m_cConnections : 0;

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::ReleaseConnection "
        "( %lu )\n", this, dwConn));

    return dwConn;
}


/*
*
*      IMPLEMENTATION of CAdvSinkImpl methods
*
*/

//
// NOTE: Advise Sink is a nested object of Default Handler that is exported
//       for achieving some of its functionality. This introduces some lifetime
//       complications. Can its lifetime be controlled by the server object to
//       which it exported its Advise Sink? Ideally, only its client should
//       control its lifetime alone, but it should also honor the ref counts
//       placed on it by the server object by entering into a zombie state
//       to prevent AV's on the incoming calls to the Advise Sink. All needed
//       logic is coded into the new class "CRefExportCount" which manages
//       the ref and export counts in a thread safe manner and invokes
//       appropriate methods during the object's lifetime. Any server objects
//       that export nested objects to other server objects should derive from
//       "CRefExportCount" class and call its methods to manage their lifetime
//       as exemplified in this Default Handler implementation.
//
//                Gopalk  Jan 10, 97
//

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::CAdvSinkImpl::QueryInterface
//
//  Synopsis:   Only supports IUnknown and IAdviseSink
//
//  Arguments:  [iid]     -- Interface requested
//              [ppvObj]  -- pointer to hold returned interface
//
//  Returns:    HRESULT
//
//  History:    dd-mmm-yy Author    Comment
//              10-Jan-96 Gopalk    Rewritten
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::CAdvSinkImpl::QueryInterface(REFIID iid, void **ppv)
{
    LEDebugOut((DEB_TRACE,"%p _IN CDefObject::CAdvSinkImpl::QueryInterface()\n",
                this));

    // Validation check
    VDATEHEAP();

    // Local variables
    HRESULT hresult = NOERROR;

    if(IsValidPtrOut(ppv, sizeof(void *))) {
        if(IsEqualIID(iid, IID_IUnknown)) {
            *ppv = (void *)(IUnknown *) this;
        }
        else if(IsEqualIID(iid, IID_IAdviseSink)) {
            *ppv = (void *)(IAdviseSink *) this;
        }
        else {
            *ppv = NULL;
            hresult = E_NOINTERFACE;
        }
    }
    else
        hresult = E_INVALIDARG;

    if(hresult == NOERROR)
        ((IUnknown *) *ppv)->AddRef();

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::CAdvSinkImpl::QueryInterface(%lx)\n",
                this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::CAdvSinkImpl::AddRef
//
//  Synopsis:   Increments export count
//
//  Returns:    ULONG; New export count
//
//  History:    dd-mmm-yy Author    Comment
//              10-Jan-96 Gopalk    Rewritten
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CDefObject::CAdvSinkImpl::AddRef( void )
{
    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::CAdvSinkImpl::AddRef()\n",
                this));

    // Validation check
    VDATEHEAP();

    // Local variables
    CDefObject *pDefObject = GETPPARENT(this, CDefObject, m_AdviseSink);
    ULONG cExportCount;

    // Increment export count
    cExportCount = pDefObject->IncrementExportCount();

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::CAdvSinkImpl::AddRef(%ld)\n",
                this, cExportCount));

    return cExportCount;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::CAdvSinkImpl::Release
//
//  Synopsis:   Decerement export count and potentially destroy the object
//
//  Returns:    ULONG; New export count
//
//  History:    dd-mmm-yy Author    Comment
//              10-Jan-96 Gopalk    Rewritten
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CDefObject::CAdvSinkImpl::Release ( void )
{
    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::CAdvSinkImpl::Release()\n",
                this));

    // Validation check
    VDATEHEAP();

    // Local variables
    CDefObject *pDefObject = GETPPARENT(this, CDefObject, m_AdviseSink);
    ULONG cExportCount;

    // Decrement export count.
    cExportCount = pDefObject->DecrementExportCount();

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::CAdvSinkImpl::Release(%ld)\n",
                this, cExportCount));

    return cExportCount;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::CAdvSinkImpl::OnDataChange
//
//  Synopsis:   Function to notify on data change
//
//  Effects:    Never called
//
//  Arguments:  [pFormatetc]    -- format of the data
//              [pStgmed]       -- data medium
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IAdviseSink
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              08-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(void) CDefObject::CAdvSinkImpl::OnDataChange(
    FORMATETC *pFormatetc, STGMEDIUM *pStgmed)
{
    VDATEHEAP();

    VOID_VDATEPTRIN( pFormatetc, FORMATETC );
    VOID_VDATEPTRIN( pStgmed, STGMEDIUM );

    Assert(FALSE);          // never received
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::CAdvSinkImpl::OnViewChange
//
//  Synopsis:   notification of view changes
//
//  Effects:    never called
//
//  Arguments:  [aspects]
//              [lindex]
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IAdviseSink
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              08-Nov-93 alexgo    32bit port
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(void) CDefObject::CAdvSinkImpl::OnViewChange
    (DWORD aspects, LONG lindex)
{
    VDATEHEAP();

    Assert(FALSE);          // never received
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::CAdvSinkImpl::OnRename
//
//  Synopsis:   Notification of name change. Turns around and informs its
//              advise sinks
//
//  Arguments:  [pmk]  -- New name (moniker)
//
//  History:    dd-mmm-yy Author    Comment
//              10-Jan-96 Gopalk    Rewritten
//--------------------------------------------------------------------------

STDMETHODIMP_(void) CDefObject::CAdvSinkImpl::OnRename(IMoniker *pmk)
{
    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::CAdvSinkImpl::OnRename(%p)\n",
                this, pmk));

    // Validation check
    VDATEHEAP();

    // Local variable
    CDefObject *pDefObject = GETPPARENT(this, CDefObject, m_AdviseSink);

    if(IsValidInterface(pmk)) {
        if(!pDefObject->IsZombie()) {
            // Stabilize
            CRefStabilize stabilize(pDefObject);

            if(pDefObject->m_pOAHolder != NULL)
                pDefObject->m_pOAHolder->SendOnRename(pmk);
        }
        else
            LEDebugOut((DEB_WARN, "OnRename() method invoked on zombied "
                                  "Default Handler"));
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::CAdvSinkImpl::OnRename()\n",
                this));
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::CAdvSinkImpl::OnSave
//
//  Synopsis:   Notification of save. Turns around and informs its
//              advise sinks
//
//  Arguments:  None
//
//  History:    dd-mmm-yy Author    Comment
//              10-Jan-96 Gopalk    Rewritten
//--------------------------------------------------------------------------

STDMETHODIMP_(void) CDefObject::CAdvSinkImpl::OnSave(void)
{
    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::CAdvSinkImpl::OnSave()\n",
                this));

    // Validation check
    VDATEHEAP();

    // Local variable
    CDefObject *pDefObject = GETPPARENT(this, CDefObject, m_AdviseSink);

    if(!pDefObject->IsZombie()) {
        // Stabilize
        CRefStabilize stabilize(pDefObject);

        if(pDefObject->m_pOAHolder != NULL)
            pDefObject->m_pOAHolder->SendOnSave();
    }
    else
        LEDebugOut((DEB_WARN,"OnSave() method invoked on zombied Default Handler"));

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::CAdvSinkImpl::OnSave()\n",
                this));
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::CAdvSinkImpl::OnClose
//
//  Synopsis:   notification of the object close. Turns around and informs its
//              advise sinks
//
//  Arguments:  None
//
//  History:    dd-mmm-yy Author    Comment
//              10-Jan-96 Gopalk    Rewritten
//--------------------------------------------------------------------------

STDMETHODIMP_(void) CDefObject::CAdvSinkImpl::OnClose( void )
{
    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::CAdvSinkImpl::OnClose()\n",
                this));

    // Validation check
    VDATEHEAP();

    // Local variables
    CDefObject *pDefObject = GETPPARENT(this, CDefObject, m_AdviseSink);

    if(!pDefObject->IsZombie()) {
        // Stabilize
        CRefStabilize stabilize(pDefObject);

        // Check if container has registered any of its own advise sinks
        if(pDefObject->m_pOAHolder) {
            // Inform the container advise sinks. Note that this can result
            // in additional outgoing calls and consequently, OnClose()
            // method is designed to be not asyncronous
            pDefObject->m_pOAHolder->SendOnClose();
        }

        // Do not rely on container calling close. Stop the running server
        pDefObject->Stop();
    }
    else
        LEDebugOut((DEB_WARN,"OnClose() method invoked on zombied Default Handler"));

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::CAdvSinkImpl::OnClose()\n",
                pDefObject));

    return;
}


/*
*      IMPLEMENTATION of CPersistStgImpl methods
*
*/


//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::GetPSDelegate
//
//  Synopsis:   retrieves the IPersistStorage interface from the delegate
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    IPersistStorage *
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              08-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

INTERNAL_(IPersistStorage *) CDefObject::GetPSDelegate(void)
{
    VDATEHEAP();

    if( IsZombie() )
    {
        return NULL;
    }

    return (IPersistStorage FAR*)DuCacheDelegate(
                &m_pUnkDelegate,
                IID_IPersistStorage,
                (LPLPVOID) &m_pPSDelegate,
                m_pUnkOuter);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::GetClassID
//
//  Synopsis:   Retrieves the class ID of the object
//
//  Effects:
//
//  Arguments:  [pClassID]      -- where to put the class ID
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IPersistStorage
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              08-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::GetClassID (CLSID *pClassID)
{
    VDATEHEAP();
    VDATETHREAD(this);


    HRESULT         hresult;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::GetClassID "
        "( %p )\n", this, pClassID));

    VDATEPTROUT(pClassID, CLSID );

    hresult = GetClassBits(pClassID);

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::GetClassID "
        "( %lx ) [ %p ]\n", this, hresult, pClassID));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::IsDirty
//
//  Synopsis:   Returns whether or not the object needs to be saved
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    HRESULT -- NOERROR means the object *is* dirty
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IPersistStorage
//
//  Algorithm:  if the server is running, delegate.  If the server is
//              clean (or not present), ask the cache
//
//  History:    dd-mmm-yy Author    Comment
//              08-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::IsDirty( void )
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT         hresult = S_FALSE;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::IsDirty ( )\n", this));

    CRefStabilize stabilize(this);

    // if server is running, it holds definitive dirty flag
    if( IsRunning() && GetPSDelegate() )
    {
        if ( FAILED(hresult = m_pPSDelegate->IsDirty()) )
        {
            goto errRtn;
        }
    }

    if (hresult == S_FALSE) {
	Assert(m_pCOleCache != NULL);
	hresult =  m_pCOleCache->IsDirty();
    }

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::IsDirty "
        "( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::InitNew
//
//  Synopsis:   Create a new object with the given storage
//
//  Effects:
//
//  Arguments:  [pstg]          -- the storage for the new object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IPersistStorage
//
//  Algorithm:  Delegates to the server and to the cache.  Writes
//              Ole private data to the storage.
//
//  History:    dd-mmm-yy Author    Comment
//              08-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::InitNew( IStorage *pstg )
{
    VDATEHEAP();
    VDATETHREAD(this);

    VDATEIFACE( pstg );

    HRESULT hresult;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::InitNew ( %p )\n",
        this, pstg));

    CRefStabilize stabilize(this);

    if( m_pStg )
    {
        hresult = CO_E_ALREADYINITIALIZED;
        goto errRtn;
    }

    m_flags |= DH_EMBEDDING;


    if( IsRunning() && GetPSDelegate()
        && (hresult = m_pPSDelegate->InitNew(pstg)) != NOERROR)
    {
        goto errRtn;
    }

    m_flags |= DH_INIT_NEW;


    // if we're in a zombie state, don't change the storage!

    if( IsZombie() )
    {
        hresult = CO_E_RELEASED;
        goto errRtn;
    }

    Assert(m_pCOleCache != NULL);
    if ((hresult = m_pCOleCache->InitNew(pstg)) != NOERROR)
    {
        goto errRtn;
    }

     // remember the storage pointer
    (m_pStg = pstg)->AddRef();

    // go ahead and write the Ole stream now
    WriteOleStg(pstg, (IOleObject *)this, NULL, NULL);

errRtn:
    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::InitNew "
        "( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::Load
//
//  Synopsis:   Loads object data from the given storage
//
//  Effects:
//
//  Arguments:  [pstg]  -- the storage for the object's data
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IPeristStorage
//
//  Algorithm:  Reads ole-private data (or creates if not there), delegates
//              to the server and the cache.
//
//  History:    dd-mmm-yy Author    Comment
//              08-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::Load (IStorage *pstg)
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT         hresult;
    DWORD           dwOptUpdate;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::Load ( %p )\n",
        this, pstg));

    VDATEIFACE( pstg );

    CRefStabilize stabilize(this);


    if( m_pStg )
    {
        hresult = CO_E_ALREADYINITIALIZED;
        goto errRtn;
    }

    m_flags |= DH_EMBEDDING;


    // NOTE: we can get the moniker from container, so no need to get
    // it here

    hresult = ReadOleStg (pstg, &m_dwObjFlags, &dwOptUpdate, NULL, NULL, NULL);

    if (hresult == NOERROR)
    {
        if (m_dwObjFlags & OBJFLAGS_CONVERT)
        {
            if( DoConversionIfSpecialClass(pstg) != NOERROR )
            {
                hresult = OLE_E_CANTCONVERT;
                goto errRtn;
            }
        }

        Assert (dwOptUpdate == NULL);

    }
    else if (hresult == STG_E_FILENOTFOUND)
    {
        // it is OK if the Ole stream doesn't exist.
        hresult = NOERROR;

        // go ahead and write the Ole stream now
        WriteOleStg(pstg, (IOleObject *)this, NULL, NULL);
    }
    else
    {
        goto errRtn;
    }


    // if running, tell server to load from pstg
    if( IsRunning() && GetPSDelegate()
        && (hresult = m_pPSDelegate->Load(pstg)) != NOERROR)
    {
        goto errRtn;
    }

    // if we're in a zombie state, don't addref' the storage!

    if( IsZombie() )
    {
        hresult = CO_E_RELEASED;
        goto errRtn;
    }

    // now load cache from pstg
    Assert(m_pCOleCache != NULL);
    if(m_dwObjFlags & OBJFLAGS_CACHEEMPTY) {
        hresult = m_pCOleCache->Load(pstg, TRUE);
        if(hresult != NOERROR)
            goto errRtn;
    }
    else {
        hresult = m_pCOleCache->Load(pstg);
        if(hresult != NOERROR)
            goto errRtn;
    }

    m_flags &= ~DH_INIT_NEW; // clear init new flag

    // remember the storage pointer
    (m_pStg = pstg)->AddRef();

errRtn:
    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::Load "
        "( %lx )\n", this, hresult));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::Save
//
//  Synopsis:   Saves the object to the given storage
//
//  Effects:
//
//  Arguments:  [pstgSave]      -- storage in which to save
//              [fSameAsLoad]   -- FALSE indicates a SaveAs operation
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IPersistStorage
//
//  Algorithm:  Saves ole-private data, delegates to the server and then
//              to the cache
//
//  History:    dd-mmm-yy Author    Comment
//              08-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::Save( IStorage *pstgSave, BOOL fSameAsLoad)
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT         hresult = NOERROR;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::Save "
        "( %p , %lu )\n", this, pstgSave, fSameAsLoad ));

    VDATEIFACE( pstgSave );

    CRefStabilize stabilize(this);

    Assert(m_pCOleCache != NULL);

    if( IsRunning() && GetPSDelegate() )
    {

        DWORD grfUpdf = UPDFCACHE_IFBLANK;
        DWORD ObjFlags = 0;
        HRESULT error;

#ifdef NEVER
        // We would have liked to have done this check as an
        // optimization, but WordArt2 does not give the right answer
        // (bug 3504) so we can't.
        if (m_pPStgDelegate->IsDirty() == NOERROR)
#endif
            grfUpdf |= UPDFCACHE_ONSAVECACHE;

        // next save server data
        if (hresult = m_pPSDelegate->Save(pstgSave, fSameAsLoad))
        {
            goto errRtn;
        }

        // Update any blank cached presentations
        m_pCOleCache->UpdateCache(GetDataDelegate(), grfUpdf, NULL);

        // Save cache
        hresult = m_pCOleCache->Save(pstgSave, fSameAsLoad);

        // Write the Ole stream after obtaining cache status
        if(m_pCOleCache->IsEmpty())
            ObjFlags |= OBJFLAGS_CACHEEMPTY;
        error = WriteOleStgEx(pstgSave, (IOleObject *)this, NULL, ObjFlags, NULL);

        // Remember the cache status if Ole stream was successfully written and
        // fSameAsLoad is TRUE
        if(error==NOERROR && fSameAsLoad)
            m_dwObjFlags |= ObjFlags;
    }
    else
    {
        // Save the cache
        if ((hresult = m_pCOleCache->Save(m_pStg,TRUE))
                != NOERROR)
        {
            goto errRtn;
        }

        // Check to see if Ole Stream needs to be written
        if((!!(m_dwObjFlags & OBJFLAGS_CACHEEMPTY)) != m_pCOleCache->IsEmpty()) {
            DWORD ObjFlags = 0;
            HRESULT error;

            // Write the Ole stream after obtaining cache status
            if(m_pCOleCache->IsEmpty())
                ObjFlags |= OBJFLAGS_CACHEEMPTY;
            error = WriteOleStgEx(m_pStg, (IOleObject *)this, NULL, ObjFlags, NULL);

            // Remember the cache status if Ole stream was successfully written
            if(error==NOERROR)
                m_dwObjFlags |= ObjFlags;
        }


        // By now we are sure that object's current state has got
        // saved into its storage.

        AssertSz(m_pStg, "Object doesn't have storage");

        // Is saving the existing storage when fSameAsLoad is FLASE correct?
        // To me it seems wrong. Gopalk
        // It is not being fixed fearing some regression in apps
        if (!fSameAsLoad)
        {
            hresult = m_pStg->CopyTo(NULL, NULL, NULL, pstgSave);
        }
    }

errRtn:
    if (hresult == NOERROR)
    {
        if( fSameAsLoad )
        {
            m_flags |= DH_SAME_AS_LOAD;
            // gets used in SaveCompleted
            m_flags &= ~DH_INIT_NEW;
        }
        else
        {
            m_flags &= ~DH_SAME_AS_LOAD;
        }
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::Save "
        "( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::SaveCompleted
//
//  Synopsis:   called when the save is completed
//
//  Effects:
//
//  Arguments:  [pstgNew]       -- the new storage for the object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IPersistStorage
//
//  Algorithm:  delegates to the server and the cache.
//
//  History:    dd-mmm-yy Author    Comment
//              08-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::SaveCompleted( IStorage *pstgNew )
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT hresult = NOERROR;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::SaveCompleted "
        "( %p )\n", this, pstgNew));


    if( pstgNew )
    {
        VDATEIFACE(pstgNew);
    }

    CRefStabilize stabilize(this);

    if( IsRunning() && GetPSDelegate() )
    {
        hresult = m_pPSDelegate->SaveCompleted(pstgNew);
    }

    // we don't save the new storage if we're in a zombie state!

    if( hresult == NOERROR && pstgNew && !IsZombie() )
    {
        if( m_pStg )
        {
            m_pStg->Release();
        }

        m_pStg = pstgNew;
        pstgNew->AddRef();
    }

    // let the cache know that the save is completed, so that it can
    // clear its dirty flag in Save or SaveAs situation, as well as
    // remember the new storage pointer if a new one is  given

    Assert(m_pCOleCache != NULL);

    if( (m_flags & DH_SAME_AS_LOAD) || pstgNew)
    {
        // clear init-new and same-as-load flags
        m_flags &= ~(DH_SAME_AS_LOAD | DH_INIT_NEW);
    }

    m_pCOleCache->SaveCompleted(pstgNew);

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::SaveCompleted ( %lx )\n",
        this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::HandsOffStorage
//
//  Synopsis:   Forces the server to release a storage (for low-mem reasons,
//              etc).
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IPersistStorage
//
//  Algorithm:  Delegates to the server and the cache
//
//  History:    dd-mmm-yy Author    Comment
//              08-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefObject::HandsOffStorage(void)
{
    VDATEHEAP();
    VDATETHREAD(this);

    HRESULT hresult = NOERROR;

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::HandsOffStorage ( )\n",
        this));

    CRefStabilize stabilize(this);

    if( IsRunning() && GetPSDelegate() )
    {
        hresult = m_pPSDelegate->HandsOffStorage();
    }

    if (hresult == NOERROR)
    {
        if( m_pStg )
        {
            m_pStg->Release();
            m_pStg = NULL;
        }

        Assert(m_pCOleCache != NULL);
        m_pCOleCache->HandsOffStorage();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::HandsOffStorage ( %lx )\n",
        this, hresult));

    return hresult;
}

/*
 * Default handler private functions
 */

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::GetClassBits
//
//  Synopsis:   Gets a class id for the object
//
//  Effects:
//
//  Arguments:  [pClsidBits]    -- where to put the class id
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:  Tries the server, then the storage, and finally the
//              clsid we were created with
//
//  History:    dd-mmm-yy Author    Comment
//              08-Nov-93 alexgo    32bit port
//
//  Notes:
//
// always gets a clsid and returns NOERROR; the clsid may be m_clsidServer
// under certain conditions (e.g., no compobj stream).
//
//--------------------------------------------------------------------------

INTERNAL CDefObject::GetClassBits(CLSID FAR* pClsidBits)
{
    VDATEHEAP();

    // alway try server first; this allows the server to respond
    if( IsRunning() && GetPSDelegate() )
    {
        if( m_pPSDelegate->GetClassID(pClsidBits) == NOERROR )
        {
            m_clsidBits = *pClsidBits;
            return NOERROR;
        }
    }

    // not running, no ps or error: use previously cached value
    if( !IsEqualCLSID(m_clsidBits, CLSID_NULL) )
    {
        *pClsidBits = m_clsidBits;
        return NOERROR;
    }

    // not running, no ps or error and no clsidBits yet: read from stg
    // if not static object.
    if( !(m_flags & DH_STATIC) )
    {
        if (m_pStg && ReadClassStg(m_pStg, pClsidBits) == NOERROR)
        {
            m_clsidBits = *pClsidBits;
            return NOERROR;
        }
    }

    // no contact with server and can't get from storage; don't set
    // m_clsidBits so if we get a storage or the serve becomes running,
    // we get the right one

    *pClsidBits = m_clsidServer;
    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::DoConversionIfSpecialClass
//
//  Synopsis:   Convert old data formats.
//
//  Effects:
//
//  Arguments:  [pstg]          -- the storage with the data
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:  see notes...
//
//  History:    dd-mmm-yy Author    Comment
//              08-Nov-93 alexgo    32bit port
//
//  Notes:      this is not yet functional for 32bit OLE
//
// If the class is CLSID_StaticDib/CLSID_StaticMetafile and the old
// format is "PBrush"/"MSDraw" the data must be in the OLE10_NATIVESTREAM.
// Move the data into the CONTENTS stream
//
// If the class is CLSID_PBrush/CLSID_MSDraw and the old format is
// metafile/DIB then data must be in the CONTENTS stream. Move the data
// from the CONTENTS stream to the OLE10_NATIVESTREAM"
//
//--------------------------------------------------------------------------

INTERNAL CDefObject::DoConversionIfSpecialClass(LPSTORAGE pstg)
{
    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CDefObject::DoConversionIfSpecialClass ("
        " %p )\n", this, pstg));

    HRESULT hresult;
    UINT    uiStatus;

    /*** Handle the static object case ***/

    if( (m_flags & DH_STATIC) ) {
        if ((hresult = Ut10NativeStmToContentsStm(pstg, m_clsidServer,
            TRUE /* fDeleteContentStm*/)) == NOERROR)
#ifdef OLD
            UtRemoveExtraOlePresStreams(pstg, 0 /*iStart*/);
#endif
        goto errRtn;

    }


    /*** Handle the PBrush & MSDraw case ***/

    // Conversion is not a frequent operation. So, it is better to do the
    // CLSID comparison here when it is necessary than doing comparison
    // upfront and remember a flag

    // if the class is not one of the following two then the object server
    // will do the necessary conversion.

    {
        CLSID clsid = CLSID_NULL;

        // Get the real CLSID from the storage.  This is necessary because we
        // may be a PBrush object being "treated as".
        ReadClassStg(pstg, &clsid);

        // if the real CLSID is not PaintBrush or the known CLSID is not MSDRAW
        // head out.
        if( clsid != CLSID_PBrush && m_clsidServer != CLSID_MSDraw )
        {
          hresult = NOERROR;
          goto exitRtn;
        }

        // if the real CLSID is not paintbrush, then set clsid to the clsid to
        // the known clsid.
        if (clsid != CLSID_PBrush)
        {
            clsid = m_clsidServer;
        }

        //
        hresult = UtContentsStmTo10NativeStm(pstg, clsid,
                            TRUE /* fDeleteContentStm*/,
                            &uiStatus);
    }
    // if OLE10_NATIVE_STREAM exists then assume success
    if (!(uiStatus & CONVERT_NODESTINATION))
        hresult = NOERROR;

    if (hresult != NOERROR) {
        // May be the static object data is in OlePres stream. If so,
        // first convert that to contents stream and then try again
        // In OLE2.0 first release static object were written to
        // OlePres000 stream.
        hresult = UtOlePresStmToContentsStm(pstg,
            OLE_PRESENTATION_STREAM,
            TRUE /*fDeletePresStm*/, &uiStatus);

        if (hresult == NOERROR)
            hresult = UtContentsStmTo10NativeStm(pstg,
                    m_clsidServer,
                    TRUE /* fDeleteContentStm*/,
                    &uiStatus);
    }

errRtn:
    if (hresult == NOERROR)
        // conversion is successful, turn the bit off
        SetConvertStg(pstg, FALSE);

exitRtn:
    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::DoConversionIfSpecialClass "
        "( %lx ) \n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::Dump, public (_DEBUG only)
//
//  Synopsis:   return a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [ppszDump]      - an out pointer to a null terminated character array
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   [ppszDump]  - argument
//
//  Derivation:
//
//  Algorithm:  use dbgstream to create a string containing information on the
//              content of data structures
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

HRESULT CDefObject::Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    char *pszCSafeRefCount;
    char *pszCThreadCheck;
    char *pszOAHolder;
    char *pszCLSID;
    char *pszCOleCache;
    char *pszDAC;
    LPOLESTR pszName;
    dbgstream dstrPrefix;
    dbgstream dstrDump(5000);

    // determine prefix of newlines
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << this << " _VB ";
    }

    // determine indentation prefix for all newlines
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    pszCThreadCheck = DumpCThreadCheck((CThreadCheck *)this, ulFlag, nIndentLevel + 1);
    dstrDump << pszPrefix << "CThreadCheck:" << endl;
    dstrDump << pszCThreadCheck;
    CoTaskMemFree(pszCThreadCheck);

    // only vtable pointers (plus we don't get the right address in debugger extensions)
    // dstrDump << pszPrefix << "&IUnknown                 = " << &m_Unknown       << endl;
    // dstrDump << pszPrefix << "&IAdviseSink              = " << &m_AdviseSink    << endl;

    dstrDump << pszPrefix << "pIOleObject Delegate      = " << m_pOleDelegate   << endl;

    dstrDump << pszPrefix << "pIDataObject Delegate     = " << m_pDataDelegate  << endl;

    dstrDump << pszPrefix << "pIPersistStorage Delegate = " << m_pPSDelegate    << endl;

    dstrDump << pszPrefix << "Count of Strong Connection= " << m_cConnections   << endl;

    dstrDump << pszPrefix << "pIUnknown pUnkOuter       = ";
    if (m_flags & DH_AGGREGATED)
    {
        dstrDump << "AGGREGATED (" << m_pUnkOuter << ")" << endl;
    }
    else
    {
        dstrDump << "NO AGGREGATION (" << m_pUnkOuter << ")" << endl;
    }

    pszCLSID = DumpCLSID(m_clsidServer);
    dstrDump << pszPrefix << "Server CLSID              = " << pszCLSID         << endl;
    CoTaskMemFree(pszCLSID);

    pszCLSID = DumpCLSID(m_clsidBits);
    dstrDump << pszPrefix << "Persistent CLSID          = " << pszCLSID         << endl;
    CoTaskMemFree(pszCLSID);

    dstrDump << pszPrefix << "Handler flags             = ";
    if (m_flags & DH_SAME_AS_LOAD)
    {
        dstrDump << "DH_SAME_AS_LOAD ";
    }
    if (m_flags & DH_CONTAINED_OBJECT)
    {
        dstrDump << "DH_CONTAINED_OBJECT ";
    }
    if (m_flags & DH_LOCKED_CONTAINER)
    {
        dstrDump << "DH_LOCKED_CONTAINER ";
    }
    if (m_flags & DH_FORCED_RUNNING)
    {
        dstrDump << "DH_FORCED_RUNNING ";
    }
    if (m_flags & DH_EMBEDDING)
    {
        dstrDump << "DH_EMBEDDING ";
    }
    if (m_flags & DH_INIT_NEW)
    {
        dstrDump << "DH_INIT_NEW ";
    }
    if (m_flags & DH_STATIC)
    {
        dstrDump << "DH_STATIC ";
    }
    if (m_flags & DH_INPROC_HANDLER)
    {
        dstrDump << "DH_INPROC_HANDLER ";
    }
    if (m_flags & DH_DELAY_CREATE)
    {
        dstrDump << "DH_DELAY_CREATE ";
    }
    if (m_flags & DH_AGGREGATED)
    {
        dstrDump << "DH_AGGREGATED ";
    }
    // if none of the flags are set...
    if ( !( (m_flags & DH_SAME_AS_LOAD)     |
            (m_flags & DH_CONTAINED_OBJECT) |
            (m_flags & DH_LOCKED_CONTAINER) |
            (m_flags & DH_FORCED_RUNNING)   |
            (m_flags & DH_EMBEDDING)        |
            (m_flags & DH_INIT_NEW)         |
            (m_flags & DH_STATIC)           |
            (m_flags & DH_INPROC_HANDLER)   |
            (m_flags & DH_DELAY_CREATE)     |
            (m_flags & DH_AGGREGATED)))
    {
        dstrDump << "No FLAGS SET!";
    }
    dstrDump << "(" << LongToPtr(m_flags) << ")" << endl;

    dstrDump << pszPrefix << "pIClassFactory Delegate   = " << m_pCFDelegate    << endl;

    dstrDump << pszPrefix << "pIUnknown Delegate        = " << m_pUnkDelegate   << endl;

    dstrDump << pszPrefix << "pIProxyManager            = " << m_pProxyMgr      << endl;

    if (m_pCOleCache != NULL)
    {
//        pszCOleCache = DumpCOleCache(m_pCOleCache, ulFlag, nIndentLevel + 1);
        dstrDump << pszPrefix << "COleCache: " << endl;
//        dstrDump << pszCOleCache;
//        CoTaskMemFree(pszCOleCache);
    }
    else
    {
    dstrDump << pszPrefix << "pCOleCache                = " << m_pCOleCache     << endl;
    }

    if (m_pOAHolder != NULL)
    {
        pszOAHolder = DumpCOAHolder(m_pOAHolder, ulFlag, nIndentLevel + 1);
        dstrDump << pszPrefix << "COAHolder: " << endl;
        dstrDump << pszOAHolder;
        CoTaskMemFree(pszOAHolder);
    }
    else
    {
    dstrDump << pszPrefix << "pIOleAdviseHolder         = " << m_pOAHolder      << endl;
    }

    dstrDump << pszPrefix << "OLE Connection Advise ID  = " << m_dwConnOle      << endl;

    dstrDump << pszPrefix << "pIOleClientSite           = " << m_pAppClientSite << endl;

    dstrDump << pszPrefix << "pIStorage                 = " << m_pStg           << endl;

    pszName = (LPOLESTR)m_pHostNames;
    dstrDump << pszPrefix << "Application Name          = " << pszName          << endl;

    pszName = (LPOLESTR)(m_pHostNames + m_ibCntrObj);
    dstrDump << pszPrefix << "Document Name             = " << pszName          << endl;

    if (m_pDataAdvCache != NULL)
    {
        pszDAC = DumpCDataAdviseCache(m_pDataAdvCache, ulFlag, nIndentLevel + 1);
        dstrDump << pszPrefix << "CDataAdviseCache: " << endl;
        dstrDump << pszDAC;
        CoTaskMemFree(pszDAC);
    }
    else
    {
    dstrDump << pszPrefix << "pCDataAdviseCache         = " << m_pDataAdvCache  << endl;
    }

    // cleanup and provide pointer to character array
    *ppszDump = dstrDump.str();

    if (*ppszDump == NULL)
    {
        *ppszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return NOERROR;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCDefObject, public (_DEBUG only)
//
//  Synopsis:   calls the CDefObject::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pDO]           - pointer to CDefObject
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCDefObject(CDefObject *pDO, ULONG ulFlag, int nIndentLevel)
{
    HRESULT hresult;
    char *pszDump;

    if (pDO == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    hresult = pDO->Dump(&pszDump, ulFlag, nIndentLevel);

    if (hresult != NOERROR)
    {
        CoTaskMemFree(pszDump);

        return DumpHRESULT(hresult);
    }

    return pszDump;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\stdimpl\defutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       defutil.cpp
//
//  Contents:   Implementations of utility functions for the default
//              handler and default link objects
//
//  Classes:    none
//
//  Functions:  DuLockContainer
//              DuSetClientSite
//              DuGetClientSite
//              DuCacheDelegate
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-94 alexgo    added VDATEHEAP macros to every function
//              20-Nov-93 alexgo    32bit port
//
//--------------------------------------------------------------------------

#include <le2int.h>
#pragma SEG(defutil)

#include <olerem.h>
#include <ole2dbg.h>

ASSERTDATA
NAME_SEG(defutil)


//+-------------------------------------------------------------------------
//
//  Function:   DuLockContainer
//
//  Synopsis:   Calls IOleContainer->LockContainer from the given client site
//
//  Effects:    Unlocking the container may release the calling object.
//
//  Arguments:  [pCS]           -- the client site from which to get
//                                 the IOleContainer pointer
//              [fLockNew]      -- TRUE == lock, FALSE == unlock
//              [pfLockCur]     -- pointer to a flag with the current lock
//                                 state
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              20-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(DuLockContainer)
INTERNAL_(void) DuLockContainer(IOleClientSite FAR* pCS, BOOL fLockNew,
        BOOL FAR*pfLockCur)
{
    VDATEHEAP();

#ifdef _DEBUG
    BOOL fLocked = FALSE;   // used only for debugging so don't waste
                            // the code space in the retail version
#endif // _DEBUG

    IOleContainer FAR* pContainer;

    //the double bang turns each into a true boolean
    if (!!fLockNew == !!*pfLockCur)
    {
        // already locked as needed
        return;
    }

    // set flag to false first since unlocking container may release obj;
    // we can just set to false since it is either already false or going
    // to become false (don't set to true until we know the lock completed).
    *pfLockCur = FALSE;

    if (pCS == NULL)
    {
        pContainer = NULL;
    }
    else
    {
        HRESULT hresult = pCS->GetContainer(&pContainer);

        // Excel 5 can return S_FALSE, pContainer == NULL
        // so we can't use AssertOutPtrIface here since it
        // expects all successful returns to provide a
        // valid interface

        if (hresult != NOERROR)
        {
            pContainer = NULL; // just in case
        }
    }
    if (pContainer != NULL)
    {
        // we assume that LockContainer will succeed first and
        // and set the locked flag that was passed into us.  This
        // way, if LockContainer succeeeds, we won't access memory
        // that could have potentially been blown away.
        // If it *fails*, then we handle reset the flag (as our
        // memory would not have been free'd)

        BOOL fLockOld = *pfLockCur;
        *pfLockCur = fLockNew;

        if( pContainer->LockContainer(fLockNew) != NOERROR )
        {
            //failure case, we were not deleted
            *pfLockCur = fLockOld;
            //fLocked is FALSE
        }
#ifdef _DEBUG
        else
        {
            fLocked = TRUE;
        }
#endif // _DEBUG

        pContainer->Release();
    }

}


//+-------------------------------------------------------------------------
//
//  Function:   DuSetClientSite
//
//  Synopsis:   Called by the default handler and deflink SetClientSite
//              implemenations; Releases the old client site (and unlocks
//              its container), stores the client site (locking its
//              container).
//
//  Effects:
//
//  Arguments:  [fRunning]      -- whether or not the delegate is running
//              [pCSNew]        -- the new client site
//              [ppCSCur]       -- a pointer to the original client site
//                                 pointer.  [*ppCSCur] will be reset
//                                 to the new client site pointer.
//              [pfLockCur]     -- pointer to the fLocked flag, used by
//                                 DuLockContainer.
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              22-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(DuSetClientSite)
INTERNAL DuSetClientSite(BOOL fRunning, IOleClientSite FAR* pCSNew,
        IOleClientSite FAR* FAR* ppCSCur, BOOL FAR*pfLockCur)
{

    VDATEHEAP();

    if (pCSNew)
    {
        VDATEIFACE( pCSNew );
    }

    IOleClientSite FAR* pCSOldClientSite = *ppCSCur;
    BOOL fLockOldClientSite = *pfLockCur;

    *pfLockCur = FALSE; // New ClientSite is not Locked.

    if ((*ppCSCur = pCSNew) != NULL)
    {

	// we've decided to keep the pointer that's been passed to us. So we
	// must AddRef() and Lock if in Running state.

        pCSNew->AddRef();

        // Lock the newcontainer
        if (fRunning)
        {
            DuLockContainer(pCSNew, TRUE, pfLockCur);
        }
    }

    // If Already Had a ClientSite, Unlock and Free
    if (pCSOldClientSite != NULL)
    {
        // Unlock the old container
        if (fRunning)
        {
            DuLockContainer(pCSOldClientSite, FALSE, &fLockOldClientSite);
        }

        pCSOldClientSite->Release();
    }

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function:   DuCacheDelegate
//
//  Synopsis:   Retrieves the requested interface from [pUnk].  If [fAgg] is
//              true, we release the pointer (so ref counts to not get
//              obfuscated ;-)
//
//  Effects:
//
//  Arguments:  [ppUnk]  -- the object to QueryInterface on
//              [iid]   -- the requested interface
//              [ppv]   -- where to put the pointer to the interface
//              [pUnkOuter]     -- controlling unknown, if non-NULL indicates
//                                 aggregation and release is called on it
//
//
//
//  Requires:
//
//  Returns:    void *, the requested interface pointer
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		29-Jun-94 alexgo    better handle re-entrancy
//              20-Jun-94 alexgo    updated to May '94 aggregation rules
//              22-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(DuCacheDelegate)
INTERNAL_(void FAR*) DuCacheDelegate(IUnknown FAR** ppUnk,
        REFIID iid, LPVOID FAR* ppv, IUnknown *pUnkOuter)
{
    VDATEHEAP();

    if (*ppUnk != NULL && *ppv == NULL)
    {
        if ((*ppUnk)->QueryInterface (iid, ppv) == NOERROR)
        {
            // the QI may actually be an outgoing call so it
            // is possible that ppUnk was released and set to
            // NULL during our call.  To make the default link
            // and handler simpler, we check for that case and
            // release any pointer we may have obtained
            // from the QI

            if( *ppUnk == NULL )
            {
                LEDebugOut((DEB_WARN, "WARNING: Delegate "
                        "released during QI, should be OK\n"));
                if( *ppv )
                {
                    // this should never be a final
                    // release on the default handler
                    // since we are calling it from
                    // within a method in the default
                    // link object. Therefore,
                    // we do not need to guard this
                    // release
                    //
                    // in the case of the link object,
                    // this may be the final release
                    // on the proxies, but since they are
                    // not aggregated into the link
                    // object, that's OK.

                    (*(IUnknown **)ppv)->Release();
                    *ppv = NULL;
                }
            }
            if( pUnkOuter && *ppv)
            {
                // we will keep the pointer but we don't want
                // to bump the ref count of the aggregate,
                // so we gotta do Release() on the controlling
                // unknown.
                pUnkOuter->Release();
            }
        }
    }

    return *ppv;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\stdimpl\defsrv.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       defsrv.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-19-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------


#include <le2int.h>

#ifdef SERVER_HANDLER

#include <scode.h>
#include <objerror.h>

#include <olerem.h>

#include "defhndlr.h"
#include "defutil.h"
#include "ole1cls.h"

#ifdef _DEBUG
#include <dbgdump.h>
#endif // _DEBUG


ASSERTDATA

//+---------------------------------------------------------------------------
//
//  Method:     CDefObject::SrvInitialize
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    10-19-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CDefObject::SrvInitialize(void)
{
    HRESULT     hresult = NOERROR;
    VDATEHEAP();
    HdlDebugOut((DEB_SERVERHANDLER, "%p _IN CDefObject::Initialize\n", this));

    CLSID clsidsrv = CLSID_ServerHandler;
    Assert (( CanUseServerHandler() ));
    Assert((m_pProxyMgr != NULL));

    if (CanUseClientSiteHandler())
    {
        hresult = CreateClientSiteHandler(m_pAppClientSite, &_pClientSiteHandler);
        if (FAILED(hresult))
        {
            _pClientSiteHandler = NULL;
        }
        Assert((_pClientSiteHandler != NULL));

    }

    hresult = m_pProxyMgr->CreateServerWithHandler(m_clsidServer,
                CLSCTX_LOCAL_SERVER, NULL,clsidsrv,
                IID_IServerHandler, (void **) &_pSrvHndlr,
                IID_IClientSiteHandler, _pClientSiteHandler);

    if (SUCCEEDED(hresult))
    {
        // set up the server handler and call InitializeAndRun on it
        Assert((_pSrvHndlr != NULL));
    }
    else
    {
        // try to get server without server handler object

        _dwClientSiteHandler = 0;
        _dwServerHandler = 0;

        // release the client handler
        if (_pClientSiteHandler)
        {
            _pClientSiteHandler->Release();
            _pClientSiteHandler = NULL;
        }
        // Note: do not try to launch the server without handler here
        //       this will be done by the default handler
    }

    HdlDebugOut((DEB_SERVERHANDLER, "%p OUT CDefObject::SrvInitialize\n", this));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDefObject::SrvRun
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    10-19-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CDefObject::SrvRun(void)
{
    HRESULT     hresult = NOERROR;
    VDATEHEAP();
    HdlDebugOut((DEB_SERVERHANDLER, "%p _IN CDefObject::SrvRun\n", this));
    INSRVRUN InSrvRun;
    OUTSRVRUN *pOutSrvRun = NULL;
    BOOL fLockedContainer;
    IMoniker *pmk;

    memset((void*)&InSrvRun, 0, sizeof(InSrvRun));
    Assert((_pSrvHndlr));

    // get the Container and lock it

    // NOTE: the lock state of the proxy mgr is not changed; it remembers
    // the state and sets up the connection correctly.

    // server is running; normally this coincides with locking the
    // container, but we keep a separate flag since locking the container
    // may fail.

    m_flags |= DH_FORCED_RUNNING;
    // Lock the container
    fLockedContainer = m_flags & DH_LOCKED_CONTAINER;
    DuLockContainer(m_pAppClientSite, TRUE, &fLockedContainer );
    if( fLockedContainer )
    {
        m_flags |= DH_LOCKED_CONTAINER;
    }
    else
    {
        m_flags &= ~DH_LOCKED_CONTAINER;
    }

    // PStgDelegate Load or InitNew
    InSrvRun.dwInFlags = m_flags;
    InSrvRun.pStg = m_pStg;

    if (NULL == m_pPSDelegate)
    {
        InSrvRun.dwOperation |= OP_NeedPersistStorage;
    }
    if (NULL == m_pDataDelegate)
    {
        InSrvRun.dwOperation |= OP_NeedDataObject;
    }
    if (NULL == m_pOleDelegate)
    {
        InSrvRun.dwOperation |= OP_NeedOleObject;
        InSrvRun.dwOperation |= OP_NeedUserClassID;
    }

    // Set the clientsite
    if (m_pAppClientSite)
    {
        InSrvRun.dwOperation |= OP_GotClientSite;
    }

    // set the hostname
    InSrvRun.pszContainerApp = (LPOLESTR)m_pHostNames;
    InSrvRun.pszContainerObj = (LPOLESTR)(m_pHostNames + m_ibCntrObj);


    // adivse sink
    Assert((m_dwConnOle == 0L));
    InSrvRun.pAS = (IAdviseSink *) &m_AdviseSink;
    InSrvRun.dwConnOle = m_dwConnOle;

    // Get the Moniker and call
    if(m_pAppClientSite != NULL)
    {
	if (m_pAppClientSite->GetMoniker
            (OLEGETMONIKER_ONLYIFTHERE,OLEWHICHMK_OBJREL, &pmk) == NOERROR)
	{
	    AssertOutPtrIface(NOERROR, pmk);
	    InSrvRun.pMnk = pmk;
	}
	else
	{
	    InSrvRun.pMnk = NULL;
	}

	// QI for IMsoDocumentSite
	IUnknown *pMsoDS = NULL;

	hresult = m_pAppClientSite->QueryInterface(
                                        IID_IMsoDocumentSite,
                                        (void **)&pMsoDS);
	if (hresult == NOERROR)
	{
	    // indicate we have MsoDocumentSite
	    InSrvRun.dwOperation |= OP_HaveMsoDocumentSite;
	    pMsoDS->Release();
	}
    }


    // MAKE CALL TO SERVERHANDLER
    hresult = _pSrvHndlr->RunAndInitialize(&InSrvRun, &pOutSrvRun);

    if (SUCCEEDED(hresult))
    {
        if (InSrvRun.dwOperation & OP_NeedPersistStorage)
        {
            Assert(NULL != pOutSrvRun->pPStg);
            m_pPSDelegate = pOutSrvRun->pPStg;
        }
        if (InSrvRun.dwOperation & OP_NeedDataObject)
        {
            Assert(NULL != pOutSrvRun->pDO);
            m_pDataDelegate = pOutSrvRun->pDO;

            // inform cache that we are running
            Assert(NULL != m_pCOleCache);
            m_pCOleCache->OnRun(m_pDataDelegate);

            // Enumerate all the advises we stored while we were either not
            // running or running the previous time, and send them to the
            // now-running object.
            Assert(NULL != m_pDataAdvCache);
            m_pDataAdvCache->EnumAndAdvise(m_pDataDelegate, TRUE);
        }
        if (InSrvRun.dwOperation & OP_NeedOleObject)
        {
            Assert(NULL != pOutSrvRun->pOO);
            m_pOleDelegate = pOutSrvRun->pOO;
        }
        if (InSrvRun.dwOperation & OP_NeedUserClassID)
        {
            Assert(NULL != pOutSrvRun->pUserClassID);
            m_clsidUser = *(pOutSrvRun->pUserClassID);
        }

        m_dwConnOle = pOutSrvRun->dwOutFlag;

        if (InSrvRun.pMnk != NULL)
        {
            InSrvRun.pMnk->Release();
        }

        // release the pUnkOuter for all marshald pointers
        if (m_pPSDelegate && m_pUnkOuter)
        {
            m_pUnkOuter->Release();
        }
        if (m_pOleDelegate && m_pUnkOuter)
        {
            m_pUnkOuter->Release();
        }
        if (m_pDataDelegate && m_pUnkOuter)
        {
            m_pUnkOuter->Release();
        }
    }
    else    // Server Handler RunAndInitialize has failed... now clean up.
    {
        Stop();

        // if for some reason we did not unlock the container by now,
        // do it (e.g., app crashed or failed during InitNew).

        fLockedContainer = (m_flags & DH_LOCKED_CONTAINER);

        DuLockContainer(m_pAppClientSite, FALSE, &fLockedContainer );

        if( fLockedContainer )
        {
            m_flags |= DH_LOCKED_CONTAINER;
        }
        else
        {
            m_flags &= ~DH_LOCKED_CONTAINER;
        }

        if (InSrvRun.pMnk != NULL)
        {
            InSrvRun.pMnk->Release();
        }
    }

    if (pOutSrvRun != NULL)
    {
	PubMemFree(pOutSrvRun->pUserClassID);   // OK to free NULL;
	PubMemFree(pOutSrvRun);
    }

    HdlDebugOut((DEB_SERVERHANDLER, "%p OUT CDefObject::SrvRun( %lx )\n", this, hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDefObject::SrvRunAndDoVerb
//
//  Synopsis:
//
//  Arguments:  [iVerb] --
//              [lpmsg] --
//              [pActiveSite] --
//              [lindex] --
//              [hwndParent] --
//              [lprcPosRect] --
//
//  Returns:
//
//  History:    10-19-95   JohannP (Johann Posch)   Created
//
//  Notes:      This is not implemented yet.
//
//----------------------------------------------------------------------------
HRESULT CDefObject::SrvRunAndDoVerb( LONG iVerb, LPMSG lpmsg,
                    LPOLECLIENTSITE pActiveSite, LONG lindex,
                    HWND hwndParent, const RECT * lprcPosRect)
{
    HRESULT     hresult = NOERROR;
    VDATEHEAP();
    HdlDebugOut((DEB_SERVERHANDLER, "%p _IN CDefObject::SrvRunAndDoVerb\n", this));

    HdlDebugOut((DEB_SERVERHANDLER, "%p OUT CDefObject::SrvRunAndDoVerb\n", this));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDefObject::SrvDoVerb
//
//  Synopsis:   1. gathers information on the client site
//              2. calls the serverhandler with SrvDoverb with collected information
//                  3. serverhandler sets up connections and calls
//                     OleObject::DoVerb on reall object
//              4. release objects which did not get used
//
//  Arguments:  [iVerb] --  OleObject DoVerb parameter
//              [lpmsg] --          detto
//              [pActiveSite] --    detto
//              [lindex] --         detto
//              [hwndParent] --     detto
//              [lprcPosRect] --    detto
//
//  Returns:
//
//  History:    10-19-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CDefObject::SrvDoVerb( LONG iVerb, LPMSG lpmsg,
                    LPOLECLIENTSITE pActiveSite, LONG lindex,
                    HWND hwndParent, const RECT * lprcPosRect)
{
    HRESULT     hresult = NOERROR;
    VDATEHEAP();
    HdlDebugOut((DEB_SERVERHANDLER, "%p _IN CDefObject::SrvDoVerb\n", this));
    CInSrvRun InSrvRun;
    OUTSRVRUN *pOutSrvRun = NULL;
    IOleContainer *pOCont = NULL;
    IOleObject *pOOCont = NULL;
    IOleClientSite *pOContCS;
    IOleInPlaceSite *pOIPS;

    // set up the DoVerb parametes
    InSrvRun.dwOperation = 0;
    InSrvRun.iVerb = iVerb;
    InSrvRun.lpmsg = lpmsg;
    InSrvRun.lindex = lindex;
    InSrvRun.hwndParent = hwndParent;
    InSrvRun.lprcPosRect = (RECT *)lprcPosRect;

    // Step 1: set up OleClientSiteActive
    if (pActiveSite)
    {
        // Currently this Assert goes off with LE test = deflink-1854 (bchapman Mar'96)
        Assert(NULL != _pClientSiteHandler);

        _pClientSiteHandler->SetClientSiteDelegate(ID_ClientSiteActive, pActiveSite);
        InSrvRun.dwOperation |= OP_GotClientSiteActive;
    }

    // Step 2: IOleClientSite::GetContainer
    // Note: this call might cause a GetUserClassID call
    // to the server
    hresult = m_pAppClientSite->GetContainer(&pOCont);
    if (hresult == NOERROR)
    {
        HdlAssert((_pClientSiteHandler->_pOCont == NULL));

        _pClientSiteHandler->_pOCont = pOCont;
        InSrvRun.dwOperation |= OP_GotContainer;

        // Step 3: QI on OleContainer for the OleObject
        hresult = pOCont->QueryInterface(IID_IOleObject, (void **)&pOOCont);
        if (hresult == NOERROR)
        {
            InSrvRun.dwOperation |= OP_GotOleObjectOfContainer;

            // release OleObject of container
            pOOCont->Release();
        }
    }

    // Step 6: OI for IOleInPlaceSite
    hresult = m_pAppClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&pOIPS);
    if (hresult == NOERROR)
    {
        // set up OleInPlaceSite on the clientsitehandler
        HdlAssert((_pClientSiteHandler != NULL));

        // release the old OleInPlaceSite
        if (_pClientSiteHandler->_pOIPS)
        {
            _pClientSiteHandler->_pOIPS->Release();
        }

        _pClientSiteHandler->_pOIPS = pOIPS;

        // Step 7: IOleInPlaceSite::CanInPlaceActivate
        InSrvRun.dwInPlace = pOIPS->CanInPlaceActivate();

        // indicate we have OleInPlaceSite
        InSrvRun.dwOperation |= OP_GotInPlaceSite;
    }


    // call the ServerHandler
    HdlDebugOut((DEB_SERVERHANDLER, "%p In CDefObject::SrvDoVerb calling DoVerb on ServerHandler!\n",this));
    hresult = _pSrvHndlr->DoVerb(&InSrvRun, &pOutSrvRun);
    HdlDebugOut((DEB_SERVERHANDLER, "%p In CDefObject::SrvDoVerb return from DoVerb on ServerHandler!\n",this));

    Assert(NULL != _pClientSiteHandler);

    if (FAILED(hresult))
    {
	HdlDebugOut((DEB_ERROR, "OO::DoVerb failed !"));
        goto errRtn;
    }
    // Release the active OleClientSite if not used by server
    if (   (InSrvRun.dwOperation & OP_GotClientSiteActive)
        && !(pOutSrvRun->dwOperation & OP_GotClientSiteActive) )
    {
        // release the active clientsite if not used by the server app.
        Assert(NULL != _pClientSiteHandler);

        _pClientSiteHandler->SetClientSiteDelegate(ID_ClientSiteActive, NULL);
    }

    // Release OleInPlaceSite if not used by server
    if (   (InSrvRun.dwOperation & OP_GotInPlaceSite)
        && !(pOutSrvRun->dwOperation & OP_GotInPlaceSite) )
    {
        _pClientSiteHandler->SetClientSiteDelegate(ID_InPlaceSite,NULL);
    }

    // Release the container if not used by server
    if (   (InSrvRun.dwOperation & OP_GotContainer)
        && !(pOutSrvRun->dwOperation & OP_GotContainer) )
    {
        _pClientSiteHandler->SetClientSiteDelegate(ID_Container,NULL);
    }

errRtn:

    // delete the out parameter
    if (pOutSrvRun)
    {
        PubMemFree(pOutSrvRun);
    }

    HdlDebugOut((DEB_SERVERHANDLER, "%p OUT CDefObject::SrvDoVerb\n",this));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDefObject::SrvRelease
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    10-19-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CDefObject::SrvRelease(void)
{
    VDATEHEAP();
    HdlDebugOut((DEB_SERVERHANDLER, "%p _IN CDefObject::SrvRelease\n", this));
    Assert((_pSrvHndlr != NULL));

    DWORD dwRet = _pSrvHndlr->Release();
#if DBG==1
    if (dwRet)
    {
        HdlDebugOut((DEB_ERROR, "Last IServerHandler::Release() return %ld\n", dwRet));
    }
#endif

    _pSrvHndlr = NULL;

    HdlDebugOut((DEB_SERVERHANDLER, "%p OUT CDefObject::SrvRelease\n", this));
    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDefObject::SrvCloseAndRelease
//
//  Synopsis:
//
//  Arguments:  [dwFlag] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CDefObject::SrvCloseAndRelease(DWORD dwFlag)
{
    HRESULT hresult;
    VDATEHEAP();
    HdlDebugOut((DEB_SERVERHANDLER, "%p _IN CDefObject::SrvCloseAndRelease\n", this));
    HdlAssert((_pSrvHndlr != NULL));

    hresult = _pSrvHndlr->CloseAndRelease(dwFlag);

    HdlDebugOut((DEB_SERVERHANDLER, "%p OUT CDefObject::SrvSrvCloseAndRelease hr:%lx\n",this,hresult));
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDefObject::InitializeServerHandlerOptions
//
//  Synopsis:
//
//  Arguments:  [clsidSrv] --
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:      determines server application specifics which can be used
//              to make serverhandler operations more efficient
//  Review:     (JohannP) we would need a flag in the registery or so
//
//----------------------------------------------------------------------------
void CDefObject::InitializeServerHandlerOptions(REFCLSID clsidSrv)
{
    VDATEHEAP();
    HdlDebugOut((DEB_SERVERHANDLER, "%p _IN CDefObject::InitializeServerHandlerOptions\n",this));

    //
    // this method should retrieve server application specific informantion
    //

    HdlDebugOut((DEB_SERVERHANDLER, "%p OUT CDefObject::InitializeServerHandlerOptions\n",this));
}

#endif // SERVER_HANDLER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\stdimpl\deflink.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       deflink.h
//
//  Contents:   Implementation of the standard link object
//
//  Classes:    CDefLink
//
//  Functions:
//
//  Author:
//              Craig Wittenberg (craigwi)    8/12/92
//
//  History:    dd-mmm-yy Author    Comment
//              20-Feb-95 KentCe    Buffered stream i/o.
//              01-Feb-95 t-ScottH  added Dump method to CDefLink
//                                  added DumpCDefLink API
//                                  added DLFlag to indicate if aggregated
//                                  (_DEBUG only)
//              09-Jan-95 t-scotth  changed VDATETHREAD to accept a pointer
//		09-Jan-95 alexgo    fixed a ton of link tracking bugs from
//				    16bit OLE.
//		21-Nov-94 alexgo    memory optimization
//		28-Aug-94 alexgo    added IsReallyRunning
//		02-Aug-94 alexgo    added object stabilization
//		30-Jun-94 alexgo    handles re-entrant shutdowns better
//              31-May-94 alexgo    now recovers from crashed servers
//              06-May-94 alexgo    made IsRunning work properly
//              07-Mar-94 alexgo    added call tracing
//              03-Feb-94 alexgo    fixed errors with SendOnLinkSrcChange
//              11-Jan-94 alexgo    added VDATEHEAP macros to every function
//                                  and method.  Also fixed an aggregation bug,
//                                  allowing linking to work.
//              22-Nov-93 alexgo    removed overloaded GUID ==
//              15-Nov-93 alexgo    32bit port
//
//      ChrisWe 11/09/93  Changed COleCache::Update to COleCache::UpdateCache,
//              which does the same thing without an indirect fuction call
//      srinik  09/11/92  Removed IOleCache implementation, as a result of
//                        removing voncache.cpp, and moving IViewObject
//                        implementation into olecache.cpp.
//
//      SriniK  06/04/92  Fixed problems in IPersistStorage methods
//--------------------------------------------------------------------------

#include <le2int.h>


#include <scode.h>
#include <objerror.h>

#include "deflink.h"
#include "defutil.h"

#ifdef _DEBUG
#include <dbgdump.h>
#endif // _DEBUG

#ifdef _TRACKLINK_
#include <itrkmnk.hxx>
#endif

ASSERTDATA


/*
*      IMPLEMENTATION of CDefLink
*/

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::Create
//
//  Synopsis:   Static function to create an instance of a link object
//
//  Arguments:  [pUnkOuter]  -- Controlling unknown
//
//  Returns:    Pointer to IUnkown interface on DefLink
//
//  History:    dd-mmm-yy   Author    Comment
//              28-Jan-96   Gopalk    Rewritten
//--------------------------------------------------------------------------

IUnknown *CDefLink::Create(IUnknown *pUnkOuter)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CDefLink::Create(%p)\n",
                NULL /* this */, pUnkOuter));

    // Validation check 
    VDATEHEAP();

    // Local variable
    CDefLink *pDefLink = NULL;
    IUnknown *pUnk = NULL;
    
    // Create DefLink
    pDefLink = new CDefLink(pUnkOuter);
    
    if(pDefLink) {
        // Make the ref count equal to 1
        pDefLink->m_Unknown.AddRef();

        // Create Ole Cache
        pDefLink->m_pCOleCache = new COleCache(pDefLink->m_pUnkOuter, CLSID_NULL);
        if(pDefLink->m_pCOleCache) {
            // Create Data Advise Cache
            if(CDataAdviseCache::CreateDataAdviseCache(&pDefLink->m_pDataAdvCache)
               == NOERROR) {
                pUnk = &pDefLink->m_Unknown;
            }
        }
    }

    if(pUnk == NULL) {
        // Something has gone wrong. Cleanup
        if(pDefLink)
            pDefLink->m_Unknown.Release();
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CDefLink::Create(%p)\n",
                NULL /* this */, pUnk ));    
    
    return pUnk;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::CDefLink
//
//  Synopsis:   Constructor
//
//  Arguments:  [pUnkOuter] -- Controlling IUnknown
//
//  History:    dd-mmm-yy   Author    Comment
//              28-Jan-96   Gopalk    Rewritten to use CRefExportCount
//--------------------------------------------------------------------------
CDefLink::CDefLink(IUnknown *pUnkOuter) : 
CRefExportCount(pUnkOuter)
{
    // Validation check    
    VDATEHEAP();

    // Initialize the controlling unknown
    if(!pUnkOuter)
        pUnkOuter = &m_Unknown;

    // Initialize member variables
    m_pUnkOuter = pUnkOuter;
    m_clsid = CLSID_NULL;
    m_dwUpdateOpt = OLEUPDATE_ALWAYS;
    m_pStg = NULL;
    m_flags = 0;
    m_dwObjFlags = 0;

    // Initialize sub objects
    m_pCOleCache = NULL;
    m_pCOAHolder = NULL;
    m_dwConnOle = 0;
    m_pDataAdvCache = NULL;
    m_dwConnTime = 0;

    // Initialize client site
    m_pAppClientSite = NULL;

    // Intialize delegates
    m_pUnkDelegate = NULL;
    m_pDataDelegate = NULL;
    m_pOleDelegate = NULL;
    m_pRODelegate = NULL;
    m_pOleItemContainerDelegate = NULL;

    // Initialize monikers
    m_pMonikerAbs = NULL;
    m_pMonikerRel = NULL;

    // zero out times
    memset(&m_ltChangeOfUpdate, 0, sizeof(m_ltChangeOfUpdate));
    memset(&m_ltKnownUpToDate, 0, sizeof(m_ltKnownUpToDate));
    memset(&m_rtUpdate, 0, sizeof(m_rtUpdate));

    // Initialize member variables used for caching MiscStatus bits
    m_ContentSRVMSHResult = 0xFFFFFFFF;
    m_ContentSRVMSBits = 0;
    m_ContentREGMSHResult = 0xFFFFFFFF;
    m_ContentREGMSBits = 0;

#ifdef _DEBUG
    if(pUnkOuter != &m_Unknown)
        m_flags |= DL_AGGREGATED;
#endif // _DEBUG
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefObject::CleanupFn, private, virtual
//
//  Synopsis:   This function is called by CRefExportCount when the object
//              enters zombie state
//
//  Arguments:  None
//
//  History:    dd-mmm-yy   Author    Comment
//              28-Jan-07   Gopalk    Creation
//--------------------------------------------------------------------------

void CDefLink::CleanupFn(void)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CDefLink::CleanupFn()\n", this));
    
    // Validation check
    VDATEHEAP();

    // Unbind source if neccessary
    UnbindSource();

    // Release monikers
    if(m_pMonikerAbs) {
        m_pMonikerAbs->Release();
        m_pMonikerAbs = NULL;
    }
    if(m_pMonikerRel) {
        m_pMonikerRel->Release();
        m_pMonikerRel = NULL;
    }

    // Release sub objects
    if(m_pCOleCache) {
        m_pCOleCache->m_UnkPrivate.Release();
        m_pCOleCache = NULL;
    }
    if(m_pCOAHolder) {
        m_pCOAHolder->Release();
        m_pCOAHolder = NULL;
    }
    if(m_pDataAdvCache) {
        delete m_pDataAdvCache;
        m_pDataAdvCache = NULL;
    }

    // Release container side objects
    Win4Assert(!(m_flags & DL_LOCKED_CONTAINER));
    if(m_pAppClientSite) {
        m_pAppClientSite->Release();
        m_pAppClientSite = NULL;
    }
    if(m_pStg) {
        m_pStg->Release();
        m_pStg = NULL;
    }

    // Update flags
    m_flags &= ~(DL_DIRTY_LINK);
    m_flags |= DL_CLEANEDUP;


    LEDebugOut((DEB_ITRACE, "%p OUT CDefLink::CleanupFn()\n", this ));

}


//+-------------------------------------------------------------------------
//
//  Function:   DumpSzTime
//
//  Synopsis:   Prints the time in the FILETIME strucutre
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//
//  Notes:      NYI for 32bit
//
//--------------------------------------------------------------------------

#ifdef LINK_DEBUG
INTERNAL_(void) DumpSzTime( LPOLESTR szMsg, FILETIME ft )
{
    VDATEHEAP();

  WORD wDate, wTime;
  XCHAR szBuffer[24];

  CoFileTimeToDosDateTime(&ft, &wDate, &wTime);

  int Day = ( wDate & 0x001F);
  int Month = ( (wDate>>5) & 0x000F);
  int Year = 1980 + ((wDate>>9) & 0x007F);

  int Sec = ( wTime & 0x001F);
  int Min = ( (wTime>>5) & 0x003F);
  int Hour = ( (wTime>>11) & 0x001F);

  wsprintf((LPOLESTR)szBuffer, "  %02d:%02d:%02d on %02d/%02d/%04d\n",
    Hour, Min, Sec, Month, Day, Year);
  OutputDebugString(szMsg);
  OutputDebugString(szBuffer);
}
#else
#define DumpSzTime(a,b)
#endif


//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::SetUpdateTimes
//
//  Synopsis:   Internal function to save local and remote times for
//              link->IsUpToDate calculations
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:  See notes below
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//              18-Nov-93 alexgo    32bit port
//
//  Notes:
//              The basic problem in calculating link IsUpToDate is that
//              the local clock may be different than the remote clock.
//              The solution is to keep track of both times on *both*
//              clocks (i.e. time now and time of change on both the local
//              and remote clocks).  IsUpToDate is calculated by comparing
//              the differences between the times on the two clocks.  This,
//              of course, assumes that both clocks equivalently measure
//              a second.
//
//--------------------------------------------------------------------------

INTERNAL CDefLink::SetUpdateTimes( void )
{
    VDATEHEAP();

    FILETIME                rtNewUpdate;
    LPMONIKER               pmkAbs = NULL;
    HRESULT                 hresult;
    LPBINDCTX               pbc = NULL;


    LEDebugOut((DEB_ITRACE, "%p _IN CDefLink::SetUpdateTimes ( )\n",
        this ));

    //use the relative moniker if it exists and if the container has a
    //moniker
    if (NOERROR != GetAbsMkFromRel(&pmkAbs, NULL))
    {
        //otherwise use the absolute moniker
        pmkAbs = m_pMonikerAbs;
        if (pmkAbs)
        {
            pmkAbs->AddRef();
        }
    }
    if (pmkAbs == NULL)
    {
       hresult = E_UNSPEC;
       goto errRet;
    }

    hresult = CreateBindCtx( 0, &pbc );
    if (hresult != NOERROR)
    {
        goto errRet;
    }

    //debugging aids
    DumpSzTime("SetUpdateTimes (going in): rtUpdate = ",m_rtUpdate);
    DumpSzTime("SetUpdateTimes (going in): ltKnownUpToDate = ",
        m_ltKnownUpToDate);
    DumpSzTime("SetUpdateTimes (going in): ltChangeOfUpdate = ",
        m_ltChangeOfUpdate);

    //get the current local time.
    CoFileTimeNow(&m_ltKnownUpToDate);

    //debugging aids
    DumpSzTime("SetUpdateTimes: time now is ",m_ltKnownUpToDate);

    //get the time of last change on the remote machine
    hresult = pmkAbs->GetTimeOfLastChange(pbc, NULL, &rtNewUpdate);
    if (hresult == NOERROR)
    {
        //if the remote time of last change is different than
        //what we previously stored as the remote time of last change,
        //then we update the remote time of last change and update
        //our local time of last change.
        //Since the IsUpToDate algorithm relies on taking the
        //differences between times on the same clock and comparing
        //those differences between machines, it is important that
        //the two times (local and remote) are *set* simulataneously.

        if ((rtNewUpdate.dwLowDateTime != m_rtUpdate.dwLowDateTime)||
            (rtNewUpdate.dwHighDateTime !=
            m_rtUpdate.dwHighDateTime))

        {
            // rtUpdate value is changing
            m_rtUpdate = rtNewUpdate;

            //debugging aid
            DumpSzTime("rtUpdate changing to ", m_rtUpdate);
            m_ltChangeOfUpdate = m_ltKnownUpToDate;

            //debugging aid
            DumpSzTime("ltChangeOfUpdate changing to ",
                m_ltChangeOfUpdate);
	    m_flags |= DL_DIRTY_LINK;
        }
    }
errRet:
    //debugging aids
    DumpSzTime("SetUpdateTimes (going out): rtUpdate = ",m_rtUpdate);
    DumpSzTime("SetUpdateTimes (going out): ltKnownUpToDate = ",
        m_ltKnownUpToDate);
    DumpSzTime("SetUpdateTimes (going out): ltChangeOfUpdate = ",
        m_ltChangeOfUpdate);

    if (pmkAbs)
    {
        pmkAbs->Release();
    }

    if (pbc)
    {
        pbc->Release();
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CDefLink::SetUpdateTimes ( %lx )\n",
        this, hresult));

    return(hresult);
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::UpdateUserClassID
//
//  Synopsis:   Grabs the class ID from the remote server (our delegate)
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//              18-Nov-93 alexgo    32bit port
//
//  Notes:
//
// update clsid from server if running; necessary because link source in
// treatas case may decide to change the clsid (e.g., if features are used
// which aren't supported by the old clsid).
//--------------------------------------------------------------------------

INTERNAL_(void) CDefLink::UpdateUserClassID(void)
{
    VDATEHEAP();

    CLSID clsid;
    IOleObject *pOleDelegate;

    LEDebugOut((DEB_ITRACE, "%p _IN CDefLink::UpdateUserClass ( )\n",
        this));

    if( (pOleDelegate = GetOleDelegate()) != NULL &&
        pOleDelegate->GetUserClassID(&clsid) == NOERROR)
    {
        m_clsid = clsid;
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CDefLink::UpdateUserClass ( )\n",
        this ));
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::~CDefLink
//
//  Synopsis:   Destructor
//
//  Arguments:  None
//
//  History:    dd-mmm-yy Author    Comment
//              10-Jan-07 Gopalk    Rewritten
//--------------------------------------------------------------------------

CDefLink::~CDefLink (void)
{
    VDATEHEAP();

    Win4Assert(m_flags & DL_CLEANEDUP);
    Win4Assert(!(m_flags & DL_LOCKED_CONTAINER) );
    Win4Assert(!(m_flags & DL_DIRTY_LINK));
    Win4Assert(m_pMonikerAbs == NULL);
    Win4Assert(m_pMonikerRel == NULL);
    Win4Assert(m_pUnkDelegate == NULL);
    Win4Assert(m_pStg == NULL);
    Win4Assert(m_pCOleCache == NULL);
    Win4Assert(m_pCOAHolder == NULL);
    Win4Assert(m_pAppClientSite == NULL);
}

//+----------------------------------------------------------------------------
//
//      Member:
//              CDefLink::CPrivUnknown::AddRef, private
//
//      Synopsis:
//              implements IUnknown::AddRef
//
//      Arguments:
//              none
//
//      Returns:
//              the parent object's reference count
//
//	History:
//               Gopalk    Rewritten        Jan 28, 97
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDefLink::CPrivUnknown::AddRef( void )
{
    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::CPrivUnknown::AddRef()\n",
                this));

    // Validation check
    VDATEHEAP();

    // Local variables
    CDefLink *pDefLink = GETPPARENT(this, CDefLink, m_Unknown);
    ULONG cRefs;

    // Addref the parent object
    cRefs = pDefLink->SafeAddRef();

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::CPrivUnknown::AddRef(%lu)\n",
                this, cRefs));

    return cRefs;
}

//+----------------------------------------------------------------------------
//
//      Member:
//              CDefLink::CPrivUnknown::Release, private
//
//      Synopsis:
//              implements IUnknown::Release
//
//      Arguments:
//              none
//
//      Returns:
//              the parent object's reference count
//
//	History:
//               Gopalk    Rewritten        Jan 28, 97
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDefLink::CPrivUnknown::Release( void )
{
    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::CPrivUnknown::Release()\n",
                this));

    // Validation check
    VDATEHEAP();

    // Local variables
    CDefLink *pDefLink = GETPPARENT(this, CDefLink, m_Unknown);
    ULONG cRefs;

    // Release parent object
    cRefs = pDefLink->SafeRelease();

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::CPrivUnknown::Release(%lu)\n",
                this, cRefs));

    return cRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::CPrivUnknown::QueryInterface
//
//  Synopsis:   The link's private QI implementation
//
//  Effects:
//
//  Arguments:  [iid]           -- the requested interface ID
//              [ppv]           -- where to put the pointer to the interface
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IUnknown
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//              11-Jan-94 alexgo    QI to the cache now queries to the cache's
//                                  private IUnknown implementation
//              22-Nov-93 alexgo    removed overloaded GUID ==
//              18-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::CPrivUnknown::QueryInterface(REFIID iid,
    LPLPVOID ppv)
{
    HRESULT hresult = NOERROR;
    CDefLink *pDefLink = GETPPARENT(this, CDefLink, m_Unknown);

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::CPrivUnknown::QueryInterface"
        " ( %p , %p )\n", pDefLink, iid, ppv));

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (void FAR *)&pDefLink->m_Unknown;
        //AddRef this object (not the aggregate)
        AddRef();
        // hresult already set to NOERROR;
        goto errRtn;
    }
    else if (IsEqualIID(iid, IID_IOleObject))
    {
        *ppv = (void FAR *) (IOleObject *)pDefLink;
    }
    else if (IsEqualIID(iid, IID_IDataObject))
    {
        *ppv = (void FAR *) (IDataObject *)pDefLink;
    }
    else if (IsEqualIID(iid, IID_IOleLink))
    {
        *ppv = (void FAR *) (IOleLink *)pDefLink;
    }
    else if (IsEqualIID(iid, IID_IRunnableObject))
    {
        *ppv = (void FAR *) (IRunnableObject *)pDefLink;
    }
    else if (IsEqualIID(iid, IID_IViewObject) ||
        IsEqualIID(iid, IID_IOleCache) ||
        IsEqualIID(iid, IID_IViewObject2) ||
        IsEqualIID(iid, IID_IOleCache2) )
    {
        hresult =
	    pDefLink->m_pCOleCache->m_UnkPrivate.QueryInterface(iid,ppv);
        goto errRtn;
    }
    else if (IsEqualIID(iid, IID_IPersistStorage) ||
        IsEqualIID(iid, IID_IPersist))
    {
        *ppv = (void FAR *) (IPersistStorage *)pDefLink;
    }
    else
    {
        *ppv = NULL;
        hresult = E_NOINTERFACE;
        goto errRtn;
    }

    pDefLink->m_pUnkOuter->AddRef();

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::CPrivUnknown::QueryInterface"
        " ( %lx ) [ %p ]\n", pDefLink, hresult, *ppv));

    return(hresult);
}


/*
 * IMPLEMENTATION of IUnknown methods
 */

//+-------------------------------------------------------------------------
//
//  Member: 	CDefLink::QueryInterface
//
//  Synopsis:	QI's to the controlling IUnknown 	
//
//  Effects:
//
//  Arguments: 	[riid]	-- the interface ID
//		[ppv]	-- where to put it
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IUnknown
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		15-Nov-94 alexgo    author
//
//  Notes: 	We do *not* need to stabilize this method as only
//		one outgoing call is made and we do not use the
//		'this' pointer afterwards
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::QueryInterface( REFIID riid, void **ppv )
{
    HRESULT	hresult;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::QueryInterface ( %lx , "
	"%p )\n", this, riid, ppv));

    Assert(m_pUnkOuter);

    hresult = m_pUnkOuter->QueryInterface(riid, ppv);

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::QueryInterface ( %lx ) "
	"[ %p ]\n", this, hresult, *ppv));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CDefLink::AddRef
//
//  Synopsis: 	delegates AddRef to the controlling IUnknown
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns: 	ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IUnknown
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		15-Nov-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CDefLink::AddRef( void )
{
    ULONG	crefs;;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::AddRef ( )\n", this));

    Assert(m_pUnkOuter);

    crefs = m_pUnkOuter->AddRef();

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::AddRef ( %ld ) ", this,
	crefs));

    return crefs;
}


//+-------------------------------------------------------------------------
//
//  Member: 	CDefLink::Release
//
//  Synopsis: 	delegates Release to the controlling IUnknown
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns: 	ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IUnknown
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		15-Nov-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CDefLink::Release( void )
{
    ULONG	crefs;;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::Release ( )\n", this));

    Assert(m_pUnkOuter);

    crefs = m_pUnkOuter->Release();

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::Release ( %ld )\n", this,
	crefs));

    return crefs;
}

/*
 *      IMPLEMENTATION of CDataObjectImpl methods
 */


//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::GetDataDelegate
//
//  Synopsis:   Private method to get the IDataObject interface on
//              the server delegate for the link
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    IDataObject *
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//              18-Nov-93 alexgo    32bit port
//
//  Notes:
//              This function may return misleading information if the
//              server has died (i.e., you'll return a pointer to a cached
//              interface proxy).  It is the responsibility of the caller
//              to handler server crashes.
//
//--------------------------------------------------------------------------

INTERNAL_(IDataObject *) CDefLink::GetDataDelegate(void)
{
    VDATEHEAP();

    IDataObject *pDataDelegate;

    LEDebugOut((DEB_ITRACE, "%p _IN CDefLink::GetDataDelegate ( )\n",
	this ));

    if( !IsZombie() )
    {
        DuCacheDelegate(&m_pUnkDelegate,
            IID_IDataObject, (LPLPVOID)&m_pDataDelegate, NULL);
        pDataDelegate = m_pDataDelegate;
#if DBG == 1
        if( m_pDataDelegate )
        {
            Assert(m_pUnkDelegate);
        }
#endif  // DBG == 1

    }
    else
    {
        pDataDelegate = NULL;
    }


    LEDebugOut((DEB_ITRACE, "%p OUT CDefLink::GetData"
        "Delegate ( %p )\n", this, pDataDelegate));

    return pDataDelegate;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::ReleaseDataDelegate
//
//  Synopsis:   Private method to release the IDataObject pointer on the
//              server to which we are linked
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//              18-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

INTERNAL_(void) CDefLink::ReleaseDataDelegate(void)
{
    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CDefLink::ReleaseDataDelegate ( )\n",
	this));

    if (m_pDataDelegate)
    {
        SafeReleaseAndNULL((IUnknown **)&m_pDataDelegate);
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CDefLink::ReleaseData"
        "Delegate ( )\n", this ));
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::GetData
//
//  Synopsis:   Gets data from the server
//
//  Effects:
//
//  Arguments:  [pfromatetcIn]  -- the requested data format
//              [pmedium]       -- where to put the data
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IDataObject
//
//  Algorithm:  Tries the cache first, then asks the server
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              18-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::GetData(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium )
{
    HRESULT         hresult = NOERROR;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::GetData"
        " ( %p , %p )\n", this, pformatetcIn, pmedium));

    VDATEPTROUT( pmedium, STGMEDIUM );
    VDATEREADPTRIN( pformatetcIn, FORMATETC );


    CRefStabilize stabilize(this);

    if( !HasValidLINDEX(pformatetcIn) )
    {
      return DV_E_LINDEX;
    }

    pmedium->tymed = TYMED_NULL;
    pmedium->pUnkForRelease = NULL;


    Assert(m_pCOleCache != NULL);
    if( m_pCOleCache->m_Data.GetData(pformatetcIn, pmedium) != NOERROR)
    {
        if( GetDataDelegate() )
        {
            hresult = m_pDataDelegate->GetData(pformatetcIn,
                    pmedium);
            AssertOutStgmedium(hresult, pmedium);
        }
        else
        {
            hresult = OLE_E_NOTRUNNING;
        }
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::GetData"
        " ( %lx )\n", this, hresult));

    return(hresult);

}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::GetDataHere
//
//  Synopsis:   Retrieves data into the specified pmedium
//
//  Effects:
//
//  Arguments:  [pformatetcIn]          -- the requested format
//              [pmedium]               -- where to put the data
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IDataObject
//
//  Algorithm:  Asks the cache first, then the server delegate
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              18-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::GetDataHere( LPFORMATETC pformatetcIn,
		LPSTGMEDIUM pmedium )
{
    HRESULT         hresult = NOERROR;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::GetDataHere"
        " ( %p , %p )\n", this, pformatetcIn, pmedium));

    VDATEREADPTRIN( pformatetcIn, FORMATETC );
    VDATEREADPTRIN( pmedium, STGMEDIUM );

    CRefStabilize stabilize(this);

    if( !HasValidLINDEX(pformatetcIn) )
    {
      return DV_E_LINDEX;
    }

    Assert(m_pCOleCache != NULL);
    if( m_pCOleCache->m_Data.GetDataHere(pformatetcIn, pmedium) != NOERROR )
    {
        if ( GetDataDelegate() )
        {
            hresult = m_pDataDelegate->GetDataHere(pformatetcIn,
                    pmedium);
        }
        else
        {
            hresult = OLE_E_NOTRUNNING;
        }
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::GetDataHere"
        " ( %lx )\n", this, hresult));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::QueryGetData
//
//  Synopsis:   Returns whether or not a GetData call for the requested
//              format would succeed.
//
//  Effects:
//
//  Arguments:  [pformatetcIn]  -- the requested data format
//
//  Requires:
//
//  Returns:    HRESULT (NOERROR == GetData would succeed)
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IDataObject
//
//  Algorithm:  Asks the cache first, then the server delegate (if the
//              cache call fails)
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              18-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::QueryGetData(LPFORMATETC pformatetcIn )
{
    HRESULT         hresult = NOERROR;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::QueryGetData"
        " ( %p )\n", this, pformatetcIn));

    VDATEREADPTRIN( pformatetcIn, FORMATETC );

    CRefStabilize stabilize(this);

    if( !HasValidLINDEX(pformatetcIn) )
    {
        hresult = DV_E_LINDEX;
        goto errRtn;
    }

    Assert(m_pCOleCache != NULL);
    if( m_pCOleCache->m_Data.QueryGetData(pformatetcIn) != NOERROR )
    {
        if ( GetDataDelegate() )
        {
            hresult = m_pDataDelegate->QueryGetData(pformatetcIn);
        }
        else
        {
            hresult = OLE_E_NOTRUNNING;
        }
    }

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::QueryGetData"
        " ( %lx )\n", this, hresult));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::GetCanonicalFormatEtc
//
//  Synopsis:   Gets the cannonical (or preferred) data format for the
//              object (choosing from the given formats)
//
//  Effects:
//
//  Arguments:  [pformatetc]    -- the requested formats
//              [pformatetcOut] -- where to to put the canonical format
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IDataObject
//
//  Algorithm:  Delegates to the server (if running)
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              18-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::GetCanonicalFormatEtc( LPFORMATETC pformatetc,
		LPFORMATETC pformatetcOut)
{
    HRESULT         hresult;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::Get"
        "CanonicalFormatetc ( %p , %p )\n", this, pformatetc,
        pformatetcOut));

    VDATEPTROUT( pformatetcOut, FORMATETC );
    VDATEREADPTRIN( pformatetc, FORMATETC );

    CRefStabilize stabilize(this);

    pformatetcOut->ptd = NULL;
    pformatetcOut->tymed = TYMED_NULL;

    if (!HasValidLINDEX(pformatetc))
    {
    	return DV_E_LINDEX;
    }

    if( GetDataDelegate() )
    {
        hresult = m_pDataDelegate->GetCanonicalFormatEtc(pformatetc,
                pformatetcOut);
    }
    else
    {
        hresult = OLE_E_NOTRUNNING;
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::Get"
        "CanonicalFormatetc ( %lx )\n", this, hresult));

    return hresult;
}



//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::SetData
//
//  Synopsis:   Stuffs data into an object (such as an icon)
//
//  Effects:
//
//  Arguments:  [pformatetc]    -- the format of the data
//              [pmedium]       -- the data
//              [fRelease]      -- if TRUE, then the data should be free'd
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IDataObject
//
//  Algorithm:  Delegates to the server
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              18-Nov-93 alexgo    32bit port
//
//  Notes:      The cache gets updated via a OnDataChange advise
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::SetData( LPFORMATETC pformatetc,
		LPSTGMEDIUM pmedium, BOOL fRelease)
{
    HRESULT         hresult;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE,  "%p _IN CDefLink::SetData"
        " ( %p , %p , %lu )\n", this, pformatetc, pmedium,
        fRelease));

    VDATEREADPTRIN( pformatetc, FORMATETC );
    VDATEREADPTRIN( pmedium, STGMEDIUM );

    CRefStabilize stabilize(this);

    if( !HasValidLINDEX(pformatetc) )
    {
        hresult = DV_E_LINDEX;
        goto errRtn;

    }

    if( GetDataDelegate() )
    {
        hresult = m_pDataDelegate->SetData(pformatetc, pmedium,
                fRelease);
    }
    else
    {
        hresult = OLE_E_NOTRUNNING;
    }

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::SetData "
        "( %lx )\n", this, hresult));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::EnumFormatEtc
//
//  Synopsis:   Enumerates the formats accepted for either GetData or SetData
//
//  Effects:
//
//  Arguments:  [dwDirection]           -- which formats (1 == GetData or
//                                              2 == SetData)
//              [ppenumFormatEtc]       -- where to put the enumerator
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IDataObject
//
//  Algorithm:  Delegates to the server, if not available or the server
//              returns OLE_E_USEREG
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              30-May-94 alexgo    now handles crashed servers
//              18-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::EnumFormatEtc( DWORD dwDirection,
		LPENUMFORMATETC *ppenumFormatEtc)
{
    HRESULT hresult;

    VDATEHEAP();
    VDATETHREAD(this);

    VDATEPTROUT(ppenumFormatEtc, LPENUMFORMATETC);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::EnumFormat"
        "Etc ( %lu , %p )\n", this, dwDirection,
        ppenumFormatEtc));

    CRefStabilize stabilize(this);

    if( GetDataDelegate() )
    {
        hresult=m_pDataDelegate->EnumFormatEtc (dwDirection,
                ppenumFormatEtc);

        if( !GET_FROM_REGDB(hresult) )
        {
            if( SUCCEEDED(hresult) || IsReallyRunning() )
            {
                // if we failed, but the server is still
                // running, then go ahead and propogate the
                // error to the caller.
                // Note that IsReallyRunning will clean up our
                // state if the server had crashed.
                goto errRtn;
            }

            // FALL-THROUGH!!  This is deliberate.  If
            // the call failed and the server is no longer
            // running, then we assume the server has crashed.
            // We want to go ahead and fetch the information
            // from the registry.
        }
    }

    // Not running or object wants to use reg db anyway
    hresult = OleRegEnumFormatEtc(m_clsid, dwDirection,
            ppenumFormatEtc);

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::EnumFormat"
        "Etc ( %lx ) [ %p ]\n", this, hresult,
        *ppenumFormatEtc));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::DAdvise
//
//  Synopsis:   Sets up a data advise connection
//
//  Effects:
//
//  Arguments:  [pFormatetc]    -- the data format to advise on
//              [advf]          -- advise flags
//              [pAdvSink]      -- whom to notify
//              [pdwConnection] -- where to put the advise connection ID
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IDataObject
//
//  Algorithm:  Delegates to the advise cache
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              18-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::DAdvise(FORMATETC *pFormatetc, DWORD advf,
		IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
    HRESULT                 hresult;
    IDataObject *	    pDataDelegate;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::DAdvise "
        "( %p , %lu , %p , %p )\n", this, pFormatetc, advf,
        pAdvSink, pdwConnection ));

    VDATEREADPTRIN( pFormatetc, FORMATETC );
    VDATEIFACE( pAdvSink );

    if (pdwConnection)
    {
        VDATEPTROUT( pdwConnection, DWORD );
        *pdwConnection = NULL;
    }

    CRefStabilize stabilize(this);

    if (!HasValidLINDEX(pFormatetc))
    {
        hresult = DV_E_LINDEX;
        goto errRtn;
    }

    pDataDelegate = GetDataDelegate(); // NULL if not running

    hresult = m_pDataAdvCache->Advise(pDataDelegate,
            pFormatetc, advf, pAdvSink, pdwConnection);

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::DAdvise "
        "( %lx ) [ %p ]\n", this, hresult, (pdwConnection) ?
        *pdwConnection : 0 ));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::DUnadvise
//
//  Synopsis:   Destroys a data advise connection
//
//  Effects:
//
//  Arguments:  [dwConnection]  -- the connection to dismantle
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IDataObject
//
//  Algorithm:  delegates to the data advise cache
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              18-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::DUnadvise(DWORD dwConnection)
{
    HRESULT                 hresult;
    IDataObject FAR*        pDataDelegate;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::DUnadvise"
        " ( %lu )\n", this, dwConnection ));

    CRefStabilize stabilize(this);

    pDataDelegate = GetDataDelegate();// NULL if not running

    hresult = m_pDataAdvCache->Unadvise(pDataDelegate, dwConnection);

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::DUnadvise ( %lx )\n",
	this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::EnumDAdvise
//
//  Synopsis:   Enumerates the data advise connections to the object
//
//  Effects:
//
//  Arguments:  [ppenumAdvise]  -- where to put the enumerator
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IDataObject
//
//  Algorithm:  delegates to the data advise cache
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//              18-Nov-93 alexgo    32bit port
//
//  Notes:	This method does NOT have to be stabilized as we are
//		only going to be allocating memory for the enumerator
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::EnumDAdvise( LPENUMSTATDATA *ppenumAdvise )
{
    HRESULT         hresult;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::EnumDAdvise"
        " ( %p )\n", this, ppenumAdvise));

    hresult = m_pDataAdvCache->EnumAdvise (ppenumAdvise);

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::EnumDAdvise"
        " ( %lx ) [ %p ]\n", this, hresult, *ppenumAdvise));

    return hresult;
}



/*
*      IMPLEMENTATION of COleObjectImpl methods
*
*/

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::GetOleDelegate
//
//  Synopsis:   Gets the IOleObject interface from the server, private method
//
//  Effects:
//
//  Arguments:  [void]
//
//  Requires:
//
//  Returns:    IOleObject *
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized and handled the zombie state
//              18-Nov-93 alexgo    32bit port
//
//  Notes:
//              This function may return misleading information if the
//              server has died (i.e., you'll return a pointer to a cached
//              interface proxy).  It is the responsibility of the caller
//              to handler server crashes.
//
//
//--------------------------------------------------------------------------

INTERNAL_(IOleObject *) CDefLink::GetOleDelegate(void)
{
    IOleObject *pOleDelegate;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CDefLink::GetOle"
        "Delegate ( )\n", this ));

    if( !IsZombie() )
    {
        DuCacheDelegate(&m_pUnkDelegate,
            IID_IOleObject, (LPLPVOID)&m_pOleDelegate, NULL);

        pOleDelegate = m_pOleDelegate;

#if DBG == 1
        if( m_pOleDelegate )
        {
            Assert(m_pUnkDelegate);
        }
#endif  // DBG == 1
    }
    else
    {
        pOleDelegate = NULL;
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CDefLink::GetOle"
        "Delegate ( %p )\n", this, pOleDelegate));

    return pOleDelegate;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::ReleaseOleDelegate (private)
//
//  Synopsis:   Releases the IOleObject pointer from the server
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//              18-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

INTERNAL_(void) CDefLink::ReleaseOleDelegate(void)
{
    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CDefLink::ReleaseOle"
        "Delegate ( )\n", this ));

    if (m_pOleDelegate)
    {
        SafeReleaseAndNULL((IUnknown **)&m_pOleDelegate);
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CDefLink::ReleaseOle"
        "Delegate ( )\n", this ));
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::SetClientSite
//
//  Synopsis:   Sets the client site for the object
//
//  Effects:
//
//  Arguments:  [pClientSite]   -- the client site
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  Stores the pointer; if the link is running, then
//              the LockContainer is called via the client site by
//              the DuSetClientSite helper function
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized and handled zombie state
//              18-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::SetClientSite( IOleClientSite *pClientSite )
{
    HRESULT         hresult;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::SetClientSite"
        " ( %p )\n", this, pClientSite));

    CRefStabilize stabilize(this);

    if( IsZombie() )
    {
        // we don't want to change our state (i.e. reset the
        // the client site) if we're zombied, because it's possible
        // that we'd never be able to release the client site again
        // resulting in memory leaks or faults.

        hresult = CO_E_RELEASED;
    }
    else
    {
	BOOL fLockedContainer = (m_flags & DL_LOCKED_CONTAINER);

        // here we use whether or not we've been bound to the server
        // as the test for whether or not we're running (even though
        // the server may have crashed since we last bound).  We do
        // this because DuSetClientSite will Unlock the old container
        // and lock the new if we're running.  Thus, if we've ever been
        // running, we need to unlock the old container (even though
        // we may not currently be running).

	hresult = DuSetClientSite(
                m_pUnkDelegate ? TRUE : FALSE,
                pClientSite,
                &m_pAppClientSite,
                &fLockedContainer);

	if(fLockedContainer)
	{
	    m_flags |= DL_LOCKED_CONTAINER;
	}
	else
	{
	    m_flags &= ~(DL_LOCKED_CONTAINER);
	}
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::SetClientSite"
        " ( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::GetClientSite
//
//  Synopsis:   Retrieves the stored client site pointer
//
//  Effects:
//
//  Arguments:  [ppClientSite]  -- where to put the client site pointer
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              22-Nov-93 alexgo    inlined DuGetClientSite
//              18-Nov-93 alexgo    32bit port
//
//  Notes: 	
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::GetClientSite( IOleClientSite **ppClientSite )
{
    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::GetClientSite ( %p )\n",
	this, ppClientSite));

    VDATEPTROUT(ppClientSite, IOleClientSite *);

    CRefStabilize stabilize(this);

    *ppClientSite = m_pAppClientSite;

    if( *ppClientSite )
    {
        (*ppClientSite)->AddRef();
    }


    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::GetClientSite"
        " ( %lx ) [ %p ] \n", this, NOERROR, *ppClientSite));

    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::SetHostNames
//
//  Synopsis:   In principal, should set the names to be drawn for
//              the server object.  Not relevant for links (link servers
//              are not a part of the document being edited).
//
//  Effects:
//
//  Arguments:  [szContainerApp]        -- the name of the container
//              [szContainerObj]        -- the container's name for the object
//
//  Requires:
//
//  Returns:    HRESULT (NOERROR currently)
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//              18-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::SetHostNames
    (LPCOLESTR szContainerApp, LPCOLESTR szContainerObj)
{
    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::SetHostNames"
        " ( %p , %p )\n", this, szContainerApp, szContainerObj));

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::SetHostNames"
        " ( %lx )\n", this, NOERROR));

    return NOERROR; // makes the embedded/link case more the same
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::Close
//
//  Synopsis:   Closes the object (in this case, just saves and unbinds the
//              link)
//
//  Effects:
//
//  Arguments:  [dwFlags]       -- clising flags (such as SAVEIFDIRTY)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              18-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


STDMETHODIMP CDefLink::Close( DWORD dwFlags )
{
    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::Close "
        "( %lu )\n", this, dwFlags));

    CRefStabilize stabilize(this);

    if (dwFlags != OLECLOSE_NOSAVE)
    {
        AssertSz(dwFlags == OLECLOSE_SAVEIFDIRTY,
                "OLECLOSE_PROMPTSAVE is inappropriate\n");
        if( IsDirty() == NOERROR )
	{
            if( m_pAppClientSite )
	    {
                m_pAppClientSite->SaveObject();
	    }
        }

    }

    // just unbind.
    UnbindSource();


    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::Close "
        "( %lx )\n", this, NOERROR));

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::SetMoniker
//
//  Synopsis:   Sets the moniker to the link object
//
//  Effects:
//
//  Arguments:  [dwWhichMoniker]        -- which moniker
//              [pmk]                   -- the new moniker
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  calls utility method UpdateRelMkFromAbsMk
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              18-Nov-93 alexgo    32bit port
//
//  Notes:
//
//  The moniker of the container is changing.
//  The next time we bind, we will try using the container moniker
//  composed with the relative moniker, and then, if that fails,
//  the absolute moniker, so there is no real need for us to
//  change these monikers.
//
//  However, there are two cases when we know the absolute moniker
//  is the correct one, and we can take this opportunity to
//  recompute the relative moniker (which is changing because
//  the container moniker is changing).  The advantage of this is
//  that GetDisplayName can return a better result in the interim
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::SetMoniker( DWORD dwWhichMoniker, LPMONIKER pmk )
{
    HRESULT	hresult = NOERROR;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::SetMoniker "
        "( %lx , %p )\n", this, dwWhichMoniker, pmk));

    CRefStabilize stabilize(this);

    if( IsZombie() )
    {
        hresult = CO_E_RELEASED;
    }
    else if (dwWhichMoniker == OLEWHICHMK_CONTAINER
        || dwWhichMoniker == OLEWHICHMK_OBJFULL)
    {
        if( m_pMonikerRel == NULL || m_pUnkDelegate)
        {
            UpdateRelMkFromAbsMk(pmk);
        }
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::SetMoniker"
        " ( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::GetMoniker
//
//  Synopsis:   Retrieves the moniker for the object
//
//  Effects:
//
//  Arguments:  [dwAssign]      -- flags (such as wether a moniker should
//                                 be assigned to the object if none currently
//                                 exits)
//              [dwWhichMoniker]-- which moniker to get (relative/absolute/etc)
//              [ppmk]          -- where to put a pointer to the moniker
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  asks the client site for the moniker
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              18-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::GetMoniker( DWORD dwAssign, DWORD dwWhichMoniker,
		    LPMONIKER *ppmk)
{
    HRESULT         hresult;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::GetMoniker "
        "( %lx , %lx , %p )\n", this, dwAssign, dwWhichMoniker,
        ppmk));

    CRefStabilize stabilize(this);

    if( m_pAppClientSite )
    {	
        hresult = m_pAppClientSite->GetMoniker(dwAssign, dwWhichMoniker,
		    ppmk);
    }
    else
    {
        // no client site
        *ppmk = NULL;
        hresult = E_UNSPEC;
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::GetMoniker "
        "( %lx ) [ %p ]\n", this, hresult, *ppmk ));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::InitFromData
//
//  Synopsis:   Initializes the object from the given data
//
//  Effects:
//
//  Arguments:  [pDataObject]   -- the data object to initialize from
//              [fCreation]     -- TRUE indicates the object is being
//                                 created, FALSE a data transfer
//              [dwReserved]    -- unused
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  Delegates to the server
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              18-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::InitFromData( LPDATAOBJECT pDataObject, BOOL fCreation,
		    DWORD dwReserved)
{
    HRESULT         hresult;
    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::InitFromData "
        "( %p , %lu , %lx )\n", this, pDataObject, fCreation,
        dwReserved));

    CRefStabilize stabilize(this);

    if( GetOleDelegate() )
    {
        hresult = m_pOleDelegate->InitFromData(pDataObject,
                fCreation, dwReserved);
    }
    else
    {
        hresult = OLE_E_NOTRUNNING;
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::InitFromData "
        "( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::GetClipboardData
//
//  Synopsis:   Retrieves a data object that could be put on the clipboard
//
//  Effects:
//
//  Arguments:  [dwReserved]    -- unused
//              [ppDataObject]  -- where to put the pointer to the data
//                                 object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  Delegates to the server object
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              18-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::GetClipboardData( DWORD dwReserved,
		    LPDATAOBJECT *ppDataObject)
{
    HRESULT         hresult;
    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::GetClipboard"
        "Data ( %lx , %p )\n", this, dwReserved, ppDataObject));

    CRefStabilize stabilize(this);

    if ( GetOleDelegate() )
    {
        hresult = m_pOleDelegate->GetClipboardData (dwReserved,
            ppDataObject);
    }
    else
    {
        hresult = OLE_E_NOTRUNNING;
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::GetClipboard"
        "Data ( %lx ) [ %p ]\n", this, hresult, *ppDataObject));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::DoVerb
//
//  Synopsis:   Sends a verb to the object (such as Open)
//
//  Effects:
//
//  Arguments:  [iVerb]         -- the verb
//              [lpmsg]         -- the window's message that caused the verb
//              [pActiveSite]   -- the site where the object was activated
//              [lindex]        -- unused currently
//              [hwndParent]    -- the parent window of the container
//              [lprcPosRect]   -- the rectange bounding the object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  Binds to the server and then delegates the DoVerb call
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              18-Nov-93 alexgo    32bit port
//
//  Notes:      If we had bound to the server and it crashed, we pretend it
//              was still running anyway for DoVerb (our call to BindToSource
//              will re-run it).  Essentially, this algorithm "fixes" the
//              crash and restores the link's state.
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::DoVerb
    (LONG iVerb, LPMSG lpmsg, LPOLECLIENTSITE pActiveSite, LONG lindex,
    HWND hwndParent, LPCRECT lprcPosRect)
{
    HRESULT         hresult;
    BOOL            bStartedNow = !m_pUnkDelegate;


    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::DoVerb "
        "( %ld , %ld , %p , %ld , %lx , %p )\n", this, iVerb,
        lpmsg, pActiveSite, lindex, hwndParent, lprcPosRect));

    if( lpmsg )
    {
        VDATEPTRIN( lpmsg, MSG );
    }

    if( pActiveSite )
    {
        VDATEIFACE( pActiveSite );
    }


    if( lprcPosRect )
    {
        VDATEPTRIN(lprcPosRect, RECT);
    }

    CRefStabilize stabilize(this);

    if( lindex != 0 && lindex != -1 )
    {
        hresult = DV_E_LINDEX;
        goto errRtn;
    }

    // if we had crashed, BindToSource will reconnect us

    if ( FAILED(hresult = BindToSource(0, NULL)) )
    {
        goto errRtn;
    }

    // we don't propogate hide to server; this (and other behavior)
    // favors the link object as serving an OLE container rather than
    // a general programmability client.  This leave the link running,
    // possibly invisible.

    if (iVerb == OLEIVERB_HIDE)
    {
        hresult = NOERROR;
        goto errRtn;
    }

    if( GetOleDelegate() )
    {
        hresult = m_pOleDelegate->DoVerb(iVerb, lpmsg, pActiveSite,
            lindex, hwndParent, lprcPosRect);
    }
    else
    {
        hresult = E_NOINTERFACE;
    }

    if (bStartedNow && FAILED(hresult))
    {
        UnbindSource();
    }

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::DoVerb "
        "( %lx )\n", this, hresult));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::EnumVerbs
//
//  Synopsis:   Enumerate the verbs accepted by this object
//
//  Effects:
//
//  Arguments:  [ppenumOleVerb] -- where to put the pointer to the enumerator
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  askes the server delegate.  If not there or it returns
//              OLE_E_USEREG, then we get the info from the registration
//              database
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              30-May-94 alexgo    now handles crashed servers
//              18-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::EnumVerbs( IEnumOLEVERB **ppenumOleVerb )
{
    HRESULT hresult;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::EnumVerbs "
        "( %p )\n", this, ppenumOleVerb));

    CRefStabilize stabilize(this);

    if( GetOleDelegate() )
    {
        hresult = m_pOleDelegate->EnumVerbs(ppenumOleVerb);

        if( !GET_FROM_REGDB(hresult) )
        {
            if( SUCCEEDED(hresult) ||  IsReallyRunning() )
            {
                // if we failed, but the server is still
                // running, then go ahead and propogate the
                // error to the caller.
                // Note that IsReallyRunning will clean up our
                // state if the server had crashed.
                goto errRtn;
            }
            // FALL-THROUGH!!  This is deliberate.  If
            // the call failed and the server is no longer
            // running, then we assume the server has crashed.
            // We want to go ahead and fetch the information
            // from the registry.
        }
    }

    // Not running or object wants to use reg db anyway
    hresult = OleRegEnumVerbs(m_clsid, ppenumOleVerb);

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::EnumVerbs "
        "( %lx ) [ %p ]\n", this, hresult, *ppenumOleVerb));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::GetUserClassID
//
//  Synopsis:   Retrieves the class id of the linked object
//
//  Effects:
//
//  Arguments:  [pClassID]      -- where to put the class ID
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//              18-Nov-93 alexgo    32bit port
//
//  Notes: 	No need to stabilize as we make no outgoing calls
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::GetUserClassID(CLSID *pClassID)
{
    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::GetUserClass"
        "ID ( %p )\n", this, pClassID));

    VDATEPTROUT(pClassID, CLSID);

    *pClassID = m_clsid;

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::GetUserClass"
        "ID ( %lx )\n", this, NOERROR ));

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::GetUserType
//
//  Synopsis:   Retrieves a descriptive string about the server type
//
//  Effects:
//
//  Arguments:  [dwFormOfType]  -- indicates whether a short or long string
//                                 description is desired
//              [pszUserType]   -- where to put the string
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  Asks the server delegate, if that fails or the server
//              returns OLE_E_USEREG, then get the info from the registration
//              database
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              30-May-94 alexgo    now handles crashed servers
//              18-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::GetUserType(DWORD dwFormOfType,
		    LPOLESTR *ppszUserType)
{
    HRESULT         hresult;

    VDATEHEAP();
    VDATETHREAD(this);


    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::GetUserType "
        "( %lu , %p )\n", this, dwFormOfType, ppszUserType));

    VDATEPTROUT(ppszUserType, LPOLESTR);
    *ppszUserType = NULL;

    CRefStabilize stabilize(this);


    if( GetOleDelegate() )
    {
        hresult = m_pOleDelegate->GetUserType (dwFormOfType,
            ppszUserType);

        if( !GET_FROM_REGDB(hresult) )
        {
            if( SUCCEEDED(hresult) || IsReallyRunning() )
            {
                // if we failed, but the server is still
                // running, then go ahead and propogate the
                // error to the caller.
                // Note that IsReallyRunning will clean up our
                // state if the server had crashed.
                goto errRtn;
            }
            // FALL-THROUGH!!  This is deliberate.  If
            // the call failed and the server is no longer
            // running, then we assume the server has crashed.
            // We want to go ahead and fetch the information
            // from the registry.

        }
    }

    // Not running, or object wants to use reg db anyway

    // Consult reg db
    hresult = OleRegGetUserType(m_clsid, dwFormOfType,
        ppszUserType);

    // it is not appropriate to read from the stg since the storage is
    // owned by the link, not the link source (thus, the link source
    // never has the opportunity to call WriteFmtUserTypeStg on the
    // link object's storage).

    // We also do not need to bother storing the last known user
    // type because if we can get it for one particular clsid, we
    // should always be able to get it.  If we can't get the user type,
    // then either we have never gotten a user type (and thus don't
    // have a "last known") or we've changed clsid's (in which case,
    // the last known user type would be wrong).

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::GetUserType "
        "( %lx ) [ %p ]\n", this, hresult, *ppszUserType));

    return hresult;
}



//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::Update
//
//  Synopsis:   Updates the link (by calling IOleLink->Update)
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              18-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::Update(void)
{
    HRESULT         hresult;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::Update ( )\n",
        this ));

    CRefStabilize stabilize(this);

    hresult = Update(NULL);

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::Update ( "
        "%lx )\n", this, hresult));

    return hresult;
}

//fudge value
#define TwoSeconds 0x01312D00

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::IsUpToDate
//
//  Synopsis:   Determines whether or not a link is up-to-date
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    HRESULT  -- NOERROR == IsUpToDate, S_FALSE == out of date
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  The current time is compared with the last time known
//              up-to-date on *both* machines (the process of the container
//              and the process of the link).  These time differences are
//              compared to determine whether the link is out-of-date.
//              See the UpdateTimes method.
//
//  History:    dd-mmm-yy Author    Comment
//		09-Jan-95 alexgo    correctly answer IsUpToDate now; also
//				    fixup monikers if needed.
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              19-Nov-93 alexgo    32bit port
//
//  Notes:      The arithmetic calculations in this method assume
//              two's complement arithmetic and a high order sign bit
//              (true for most current machines)
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::IsUpToDate(void)
{
    FILETIME        rtTimeOfLastChange;
    LPMONIKER       pmkAbs = NULL;
    IMoniker *	    pmkContainer = NULL;
    HRESULT         hresult = NOERROR;
    LPBINDCTX       pbc = NULL;
    FILETIME        rtDiff;
    FILETIME        ltDiff;
    FILETIME        ftTemp;
    FILETIME        ftNow;
    BOOL            fHighBitSet;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::IsUpToDate "
        "( )\n", this ));

    CRefStabilize stabilize(this);

    if (m_dwUpdateOpt == OLEUPDATE_ALWAYS &&
        IsRunning())
    {
        // hresult == NOERROR from default initializer
        goto errRet;
    }


    // use the relative moniker if it exists and if the container
    // has a moniker
    if (NOERROR != GetAbsMkFromRel(&pmkAbs, &pmkContainer))
    {
        //      otherwise use the absolute moniker
        if (pmkAbs = m_pMonikerAbs)
        {
            pmkAbs->AddRef();
        }
    }

    if (pmkAbs == NULL)
    {
        hresult = MK_E_UNAVAILABLE;
        goto errRet;
    }

    hresult = CreateBindCtx( 0, &pbc );
    if (hresult != NOERROR)
    {
        goto errRet;
    }

    //get the remote time of last change
    hresult = pmkAbs->GetTimeOfLastChange(pbc, NULL, &rtTimeOfLastChange);
    if (hresult != NOERROR)
    {
	// if GetTimeOfLastChange failed, it's possible that the moniker
	// we constructed is bogus.  Try again using the *real* absolute
	// moniker.  We do this to mimic bind behaviour.  The moniker
	// we use above is constructed from the relative moniker.  In binding,
	// if the relative moniker fails, then we fall back to the last
	// known real absolute moniker.
        BOOL fSuccess = FALSE;

	if( m_pMonikerAbs )
        {
            if (pmkAbs != m_pMonikerAbs)
            {
                // do this if we did the bind on the relative one.above
                hresult = m_pMonikerAbs->GetTimeOfLastChange(pbc, NULL,
        		&rtTimeOfLastChange);

                if( hresult == NOERROR )
                {
                    fSuccess = TRUE;
        	        // hang onto the better absolute moniker
        	    pmkAbs->Release();	// releases the one we contructed
        				// in GetAbsMkFromRel
        	    pmkAbs = m_pMonikerAbs;
        	    pmkAbs->AddRef();	// so the Release() down below
                }                      // doesn't hose us.
            }

#ifdef _TRACKLINK_
            if (!fSuccess)
            {
                // at this point we have tried either: relative then absolute OR
                // just absolute.  We now should try the reduced absolute one.

                IMoniker *pmkReduced;
                EnableTracking(m_pMonikerAbs, OT_ENABLEREDUCE);
                hresult = m_pMonikerAbs->Reduce(pbc, MKRREDUCE_ALL, NULL, &pmkReduced);
                EnableTracking(m_pMonikerAbs, OT_DISABLEREDUCE);
                if (hresult == NOERROR)
                {
                    hresult = pmkReduced->GetTimeOfLastChange(pbc, NULL,
        	        	&rtTimeOfLastChange);
                    if (hresult != NOERROR)
                    {
                        pmkReduced->Release();
                    }
                    else
                    {
                        fSuccess = TRUE;
                        pmkAbs->Release();
                        pmkAbs = pmkReduced;
                    }
                }
            }
#endif
        }
	
	if (!fSuccess)
	{
	    hresult = MK_E_UNAVAILABLE;
	    goto errRet;
	}
    }

    // once we get this far, we know that either 1. the relative moniker
    // is good, or 2. the absolute moniker is good.  In any event, pmkAbs
    // now points to a (semi)-reasonable spot.  (I say 'semi', because
    // even though GetTimeOfLastChange succeeded, we aren't guaranteed that
    // a Bind would be successful.
    //
    // check to see if we need to update the relative moniker (if we don't
    // already have one, don't bother.)  It is also possible that the
    // absolute moniker is now bad.  Use the known 'good' one and update
    // both monikers

    // we ignore the return code here; if this call fails, it is not
    // serious.

    // pmkContainer may be NULL if our container doesn't offer us one.
    if( pmkContainer )
    {
	UpdateMksFromAbs(pmkContainer, pmkAbs);

	pmkContainer->Release();
    }

    // compute  rtDiff = max(0, rtTimeOfLastChange - rtUpdate)
    // possibly optimize with _fmemcopy

    // debugging aid
    DumpSzTime("IsUpToDate: rtTimeOfLastChange = ", rtTimeOfLastChange);

    // start rtDiff calculation
    rtDiff = rtTimeOfLastChange;

    // debugging aid
    DumpSzTime("IsUpToDate: rtUpdate = ", m_rtUpdate);

    // the following subtractions rely on two's complement
    if (m_rtUpdate.dwLowDateTime > rtDiff.dwLowDateTime)
    {
        //handle the carry
        rtDiff.dwHighDateTime =
            (DWORD)((LONG)rtDiff.dwHighDateTime - 1);
    }

    rtDiff.dwLowDateTime = (DWORD)((LONG)rtDiff.dwLowDateTime -
        (LONG)m_rtUpdate.dwLowDateTime);
    rtDiff.dwHighDateTime = (DWORD)((LONG)rtDiff.dwHighDateTime -
        (LONG)m_rtUpdate.dwHighDateTime);


    //  if rtDiff < 0, say we are out of date.
    if ((LONG)rtDiff.dwHighDateTime < 0)
    {
        hresult = S_FALSE;
        goto errRet;
    }

    if (rtDiff.dwHighDateTime == 0 && rtDiff.dwLowDateTime == 0)
    {
        // no time difference.  could be due to large clock ticks,
        // so we say we are up to date only if several seconds have
        // elapsed since last known update time.

        CoFileTimeNow( &ftNow );
        ftTemp = m_ltKnownUpToDate;

        // This bit of logic may seem strange.  All we want is
        // is to test the high bit in a portable fashion
        // between 32/64bit machines (so a constant isn't good)
        // As long as the sign bit is the high order bit, then
        // this trick will do

        fHighBitSet = ((LONG)ftTemp.dwLowDateTime < 0);

        ftTemp.dwLowDateTime += TwoSeconds;

        // if the high bit was set, and now it's zero, then we
        // had a carry

        if (fHighBitSet && ((LONG)ftTemp.dwLowDateTime >= 0))
        {
            ftTemp.dwHighDateTime++;        // handle the carry.
        }

        // compare times
        if ((ftNow.dwHighDateTime > ftTemp.dwHighDateTime) ||
            ((ftNow.dwHighDateTime == ftTemp.dwHighDateTime) &&
            (ftNow.dwLowDateTime > ftTemp.dwLowDateTime)))
        {
            hresult = NOERROR;
        }
        else
        {
            hresult = S_FALSE;
        }
    }
    else
    {
        // there was a time difference

        // compute ltDiff = max(0, m_ltKnownUpToDate -
        //                      m_ltChangeOfUpdate);
        // Actually, by this time we know rtDiff >= 0, so we can
        // simply compare ltDiff with rtDiff -- no need to compute
        // the max.

        ltDiff = m_ltKnownUpToDate;

        // debugging aid
        DumpSzTime("IsUpToDate: ltKnownUpToDate = ",ltDiff);
        DumpSzTime("IsUpToDate: ltChangeOfUpdate = ",
            m_ltChangeOfUpdate);

        // these calc's rely on two's complement.

        if (m_ltChangeOfUpdate.dwLowDateTime >
            ltDiff.dwLowDateTime)
        {
            // handle carry
            ltDiff.dwHighDateTime =
                (DWORD)((LONG)ltDiff.dwHighDateTime - 1);
        }

        ltDiff.dwLowDateTime = (DWORD)((LONG)ltDiff.dwLowDateTime -
            (LONG)m_ltChangeOfUpdate.dwLowDateTime);
        ltDiff.dwHighDateTime = (DWORD)((LONG)ltDiff.dwHighDateTime -
            (LONG)m_ltChangeOfUpdate.dwHighDateTime);

        // Now determine if rtDiff < ltDiff
        if (ltDiff.dwHighDateTime > rtDiff.dwHighDateTime)
        {
            hresult = NOERROR;
        }
        else if (ltDiff.dwHighDateTime == rtDiff.dwHighDateTime)
        {
            if (ltDiff.dwLowDateTime > rtDiff.dwLowDateTime)
            {
                hresult = NOERROR;
            }
            else
            {
                hresult = S_FALSE;
            }
        }
        else
        {
            hresult = S_FALSE;
        }
    }

    // all cases should have been handled by this point.  Release
    // any resources grabbed.

errRet:
    if (pmkAbs)
    {
        pmkAbs->Release();
    }
    if (pbc)
    {
        pbc->Release();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::IsUpToDate "
        "( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::SetExtent
//
//  Synopsis:   Sets the drawing extents, not allowed for links
//
//  Effects:
//
//  Arguments:  [dwDrawAspect]  -- the drawing aspect
//              [lpsizel]       -- the new extents
//
//  Requires:
//
//  Returns:    E_UNSPEC  (not allowed)
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//              19-Nov-93 alexgo    32 bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::SetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::SetExtent "
        "( %lx , %p )\n", this, dwDrawAspect, lpsizel));

    LEDebugOut((DEB_WARN, "Set Extent called for links, E_UNSPEC \n"));

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::SetExtent "
        "( %lx )\n", this, E_UNSPEC));

    return E_UNSPEC; // can't call this for a link
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::GetExtent
//
//  Synopsis:   Get's the size (extents) of the object
//
//  Effects:
//
//  Arguments:  [dwDrawAspect]  -- the drawing aspect
//              [lpsizel]       -- where to put the extents
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  Asks the server first, if not running or an error
//              then delegate to the cache
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::GetExtent( DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    HRESULT         error = E_FAIL;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::GetExtent "
        "( %lx , %p )\n", this, dwDrawAspect, lpsizel));

    VDATEPTROUT(lpsizel, SIZEL);

    CRefStabilize stabilize(this);

    lpsizel->cx = 0;
    lpsizel->cy = 0;

    // if server is running try to get extents from the server
    if( GetOleDelegate() )
    {
        error = m_pOleDelegate->GetExtent(dwDrawAspect, lpsizel);
    }

    // if there is error or object is not running get extents from Cache
    if( error != NOERROR )
    {
        Assert(m_pCOleCache != NULL);
        error = m_pCOleCache->GetExtent(dwDrawAspect,
            lpsizel);
    }

    // WordArt2.0 is giving negative extents!!
    if (SUCCEEDED(error))
    {
        lpsizel->cx = LONG_ABS(lpsizel->cx);
        lpsizel->cy = LONG_ABS(lpsizel->cy);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::GetExtent "
        "( %lx )\n", this, error ));

    return error;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::Advise
//
//  Synopsis:   Sets up an advise connection to the object for things like
//              Close, Save, etc.
//
//  Effects:
//
//  Arguments:  [pAdvSink]      -- whom to notify
//              [pdwConnection] -- where to put the connection ID
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  Creates an OleAdvise holder (if one not already present
//              and then delegates to it)
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized and handle zombie case
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::Advise(IAdviseSink *pAdvSink,
        DWORD *pdwConnection)
{
    HRESULT         hresult;
    VDATEHEAP();
    VDATETHREAD(this);


    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::Advise "
        "( %p , %p )\n", this, pAdvSink, pdwConnection));

    CRefStabilize stabilize(this);

    if( IsZombie() )
    {
        hresult = CO_E_RELEASED;
        goto errRtn;
    }

    // if we haven't got an advise holder yet, allocate one
    if (m_pCOAHolder == NULL)
    {
        // allocate the advise holder
        m_pCOAHolder = new FAR COAHolder;

        // check to make sure we got one
        if (m_pCOAHolder == NULL)
        {
            hresult = E_OUTOFMEMORY;
            goto errRtn;
        }
    }

    // delegate the call to the advise holder
    hresult = m_pCOAHolder->Advise(pAdvSink, pdwConnection);

errRtn:
    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::Advise "
        "( %lx ) [ %lu ]\n", this, hresult,
        (pdwConnection) ? *pdwConnection : 0 ));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::Unadvise
//
//  Synopsis:   Removes an advise connection to the object
//
//  Effects:
//
//  Arguments:  [dwConnection]  -- the connection ID to remove
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  Delegates to the OleAdvise holder (which was created
//              during the Advise--if it wasn't, then we are in a strange
//              state).
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::Unadvise(DWORD dwConnection)
{
    HRESULT         hresult;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::Unadvise "
        "( %lu )\n", this, dwConnection ));

    CRefStabilize stabilize(this);

    if (m_pCOAHolder == NULL)
    {
        // no one registered
        hresult = E_UNEXPECTED;
    }
    else
    {
        hresult = m_pCOAHolder->Unadvise(dwConnection);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::Unadvise "
        "( %lx )\n", this, hresult ));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::EnumAdvise
//
//  Synopsis:   Enumerates the advise connections on the object
//
//  Effects:
//
//  Arguments:  [ppenumAdvise]  -- where to put the pointer to the advise
//                                 enumerator
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  Delegates to the advise holder
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//              19-Nov-93 alexgo    32bit port
//
//  Notes: 	We do not need to stabilize this method as we only allocate
//		memory for hte advise enumerator
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::EnumAdvise( LPENUMSTATDATA *ppenumAdvise )
{
    HRESULT         hresult;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::EnumAdvise "
        "( %p )\n", this, ppenumAdvise ));

    if (m_pCOAHolder == NULL)
    {
        // no one registered
        hresult = E_UNSPEC;
    }
    else
    {
        hresult = m_pCOAHolder->EnumAdvise(ppenumAdvise);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::EnumAdvise "
        "( %lx ) [ %p ]\n", this, hresult, *ppenumAdvise ));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::GetMiscStatus
//
//  Synopsis:   Gets the miscellaneous status bits (such as
//              OLEMISC_ONLYICONIC)
//
//  Effects:
//
//  Arguments:  [dwAspect]      -- the drawing aspect
//              [pdwStatus]     -- where to put the status bits
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:  Asks the server first, if not running or if it returns
//              OLE_E_USEREG, then get the info from the registration
//              database.  We always add link-specific bits regardless
//              of error conditions or what the server or regdb says.
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              30-May-94 alexgo    now handles crashed servers
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::GetMiscStatus( DWORD dwAspect, DWORD *pdwStatus)
{
    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::GetMiscStatus(%lx, %p)\n", 
                this, dwAspect, pdwStatus ));

    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);
    VDATEPTROUT(pdwStatus, DWORD);

    // Local variables
    HRESULT hresult;

    // Stabilize
    CRefStabilize stabilize(this);

    // Initialize
    *pdwStatus = 0;
    hresult = OLE_S_USEREG;

    if(GetOleDelegate()) {
        // Check if MiscStatus bits have been cached for this instance 
        // of server for DVASPECT_CONTENT
        if(m_ContentSRVMSHResult != 0xFFFFFFFF && dwAspect == DVASPECT_CONTENT) {
            *pdwStatus = m_ContentSRVMSBits;
            hresult = m_ContentSRVMSHResult;
        }
        else {
            // Ask the running server
            hresult = m_pOleDelegate->GetMiscStatus (dwAspect, pdwStatus);

            // Cache the server MiscStatus bits for DVASPECT_CONTENT
            if(dwAspect == DVASPECT_CONTENT) {
                m_ContentSRVMSBits = *pdwStatus;
                m_ContentSRVMSHResult = hresult;
            }
        }

        if(FAILED(hresult) && !GET_FROM_REGDB(hresult)) {
            // Check if server is really running
            BOOL fRunning = FALSE;

            // Note that IsReallyRunning will cleanup if the 
            // server had crashed
            fRunning = IsReallyRunning();
            Win4Assert(fRunning);
            
            // Hit the registry if the server crashed
            if(!fRunning)
                hresult = OLE_S_USEREG;
        }
    }

    // Check if we have to obtain MiscStatus bits from the registry
    if (GET_FROM_REGDB(hresult)) {
        // Check if registry MiscStatus bits have been cached for DVASPECT_CONTENT
        if(m_ContentREGMSHResult != 0xFFFFFFFF && dwAspect == DVASPECT_CONTENT) {
            *pdwStatus = m_ContentREGMSBits;
            hresult = m_ContentREGMSHResult;
        }
        else {
            // Hit the registry
            hresult = OleRegGetMiscStatus (m_clsid, dwAspect, pdwStatus);
            // Cache the registry MiscStatus bits for DVASPECT_CONTENT
            if(hresult == NOERROR && dwAspect == DVASPECT_CONTENT) {            
                m_ContentREGMSBits = *pdwStatus;
                m_ContentREGMSHResult = hresult;
            }
        }
    }

    // Add link-specific bits (even if error) and return.
    // we add them even if an error because in order to get here, we
    // have to have instantiated this link object; thus, it is always
    // valid to say OLEMISC_ISLINKOBJECT, etc.
    (*pdwStatus) |= OLEMISC_CANTLINKINSIDE | OLEMISC_ISLINKOBJECT;


    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::GetMiscStatus (%lx)[%lx]\n",
                this, hresult, *pdwStatus ));
    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::SetColorScheme
//
//  Synopsis:   Sets the palette for the object; unused for links
//
//  Effects:
//
//  Arguments:  [lpLogpal]      -- the palette
//
//  Requires:
//
//  Returns:    NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::SetColorScheme(LPLOGPALETTE lpLogpal)
{
    VDATEHEAP();
    VDATETHREAD(this);
    // we ignore this always

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::SetColor"
        "Scheme ( %p )\n", this, lpLogpal));

    LEDebugOut((DEB_WARN, "Link IOO:SetColorScheme called on a link\n"));

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::SetColor"
        "Scheme ( %lx )\n", this, NOERROR));

    return NOERROR;
}


/*
*      IMPLEMENTATION of CLinkImpl methods
*
*/


//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::BeginUpdates
//
//  Synopsis:   Private method to update the caches and then set the update
//              times
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

INTERNAL_(void) CDefLink::BeginUpdates(void)
{
    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CDefLink::BeginUpdates ( )\n", this));

    IDataObject FAR*        pDataDelegate;

    if( pDataDelegate = GetDataDelegate() )
    {
        // inform cache that we are running
        Assert(m_pCOleCache != NULL);
        m_pCOleCache->OnRun(pDataDelegate);

        // update only the automatic local caches from the newly
        // running src
        m_pCOleCache->UpdateCache(pDataDelegate, UPDFCACHE_NORMALCACHE,
                NULL);

        // we are an automatic link which is now up to date
        SetUpdateTimes();
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CDefLink::BeginUpdates ( )\n", this ));

}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::EndUpdates
//
//  Synopsis:   Calls OnStop on the cache
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

INTERNAL_(void) CDefLink::EndUpdates(void)
{
    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CDefLink::EndUpdates ( )\n", this));

    Assert(m_pCOleCache != NULL);
    m_pCOleCache->OnStop();

    LEDebugOut((DEB_ITRACE, "%p OUT CDefLink::EndUpdates ( )\n", this));
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::UpdateAutoOnSave
//
//  Synopsis:   Updates caches that have been set with ADVFCACHE_ONSAVE
//              and sets the update times.  Private method
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

INTERNAL_(void) CDefLink::UpdateAutoOnSave(void)
{
    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CDefLink::UpdateAutoOnSave ( )\n",
        this));

    // if m_pUnkDelegate is non-NULL, assume we are running
    // (we only want to take the hit of the rpc-call IsRunning
    // on external entry points.

    if (m_pUnkDelegate && m_dwUpdateOpt == OLEUPDATE_ALWAYS)
    {
        // update any cache which has ADVFCACHE_ONSAVE
        Assert(m_pCOleCache != NULL);

        //REVIEW32:  I think SetUpdateTimes ought to be called
        //*after* the cache has been updated (that's what
        //BeginUpdates does as well)
        SetUpdateTimes();
        m_pCOleCache->UpdateCache(GetDataDelegate(),
                UPDFCACHE_IFBLANKORONSAVECACHE, NULL);
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CDefLink::UpdateAutoOnSaves ( )\n",
        this));

}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::UpdateRelMkFromAbsMk  (private)
//
//  Synopsis:   Creates a new relative moniker from the absolute moniker
//
//  Effects:
//
//  Arguments: 	[pmkContainer]	-- the moniker to the container (may be NULL)
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//              03-Feb-94 alexgo    check for NULL before SendOnLinkSrcChange
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//  update relative moniker from abs; always release relative moniker;
//  may leave relative moniker NULL; doesn't return an error (because
//  no caller wanted it); dirties the link when we get rid of an
//  existing relative moniker or get a new one.
//
//--------------------------------------------------------------------------

INTERNAL_(void) CDefLink::UpdateRelMkFromAbsMk(IMoniker *pmkContainer)
{
    LPMONIKER	pmkTemp = NULL;
    BOOL        fNeedToAdvise = FALSE;
    HRESULT     hresult;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CDefLink::UpdateRelMkFromAbsMk ( %p )\n",
        this, pmkContainer ));

    if (m_pMonikerRel)
    {
        m_pMonikerRel->Release();
        m_pMonikerRel = NULL;

	m_flags |= DL_DIRTY_LINK; // got rid on an existing moniker, now dirty
        fNeedToAdvise = TRUE;
    }

    // NOTE: m_pMonikerRel is now NULL and only set when if we get a
    // new one

    if (m_pMonikerAbs == NULL)
    {
        // no abs mk thus no relative one
        goto errRtn;
    }

    if (pmkContainer)
    {
	pmkTemp = pmkContainer;
    }
    else
    {
	hresult = GetMoniker( OLEGETMONIKER_ONLYIFTHERE, // it will be
	    OLEWHICHMK_CONTAINER, &pmkTemp );

	AssertOutPtrIface(hresult, pmkTemp);
	if (hresult != NOERROR)
	{
	    // no container moniker, thus no relative one to it
	    goto errRtn;
	}

	Assert(pmkTemp != NULL);
    }

    hresult = pmkTemp->RelativePathTo(m_pMonikerAbs, &m_pMonikerRel);
    AssertOutPtrIface(hresult, m_pMonikerRel);

    if (hresult != NOERROR)
    {
        // no relationship between container and absolute, thus no
        // relative
        if (m_pMonikerRel)
        {
            m_pMonikerRel->Release();
            m_pMonikerRel = NULL;
        }
    }

    if (pmkContainer == NULL)
    {
	// new moniker was allocated and needs to be released
	pmkTemp->Release();
    }

    if (m_pMonikerRel != NULL)
    {
        m_flags |= DL_DIRTY_LINK;    // have new relative moniker; dirty
        fNeedToAdvise = TRUE;
    }

    // if there's an advise holder and we need to advise, send out
    // the change notification.
    if (fNeedToAdvise && m_pCOAHolder)
    {
        m_pCOAHolder->SendOnLinkSrcChange(m_pMonikerAbs);
    }

errRtn:

    LEDebugOut((DEB_ITRACE, "%p OUT CDefLink::UpdateRelMkFromAbsMk ( %p )\n",
        this, pmkContainer ));
}

//+-------------------------------------------------------------------------
//
//  Member: 	CDefLink::UpdateMksFromAbs
//
//  Synopsis: 	make a reasonable attempt to get valid rel && absolute
//		monikers
//
//  Effects:
//
//  Arguments: 	[pmkContainer]	-- the moniker to the container
//		[pmkAbs]	-- 'good' absolute moniker
//
//  Requires:
//
//  Returns: 	S_OK
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		09-Jan-95 alexgo    author
//
//  Notes: 	This function should only be used when we aren't 100% sure
//		of the validity of the moniker (i.e. after an IMoniker::
//		TimeOfLastChange call).  We do not do any error
//		recovery.  Basically, the idea is 'try' to put us in a
//		more consistent state, but it that fails, it's OK (because
//		we'd basically have OLE 16bit behaviour).
//
//--------------------------------------------------------------------------

INTERNAL CDefLink::UpdateMksFromAbs( IMoniker *pmkContainer, IMoniker *pmkAbs )
{
    HRESULT hresult;
    IMoniker *pmktempRel;
    BOOL fNeedToUpdate = FALSE;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CDefLink::UpdateMksFromAbs ( %p , %p )\n",
	this, pmkContainer, pmkAbs));

    // try updating the relative moniker (if one exists).  Basically, we
    // see if the relative moniker between pmkContainer and pmkAbs is
    // any different than the moniker we currently have.

    if( m_pMonikerRel )
    {
	hresult = pmkContainer->RelativePathTo(pmkAbs, &pmktempRel);

	if( hresult == NOERROR )
	{
	    if( pmktempRel->IsEqual(m_pMonikerRel) == S_FALSE )
	    {
		// need to update the relative moniker.

		m_pMonikerRel->Release();
		m_pMonikerRel = pmktempRel;
		m_pMonikerRel->AddRef();

		// updated relative moniker, now dirty
		m_flags |= DL_DIRTY_LINK;
		fNeedToUpdate = TRUE;
	    }
	}
    }

    // it is also possible that the absolute moniker is now bad.  Use the
    // known 'good' one.

    if( m_pMonikerAbs && m_pMonikerAbs->IsEqual(pmkAbs) == S_FALSE )
    {
	m_pMonikerAbs->Release();
	m_pMonikerAbs = pmkAbs;
	m_pMonikerAbs->AddRef();

#ifdef _TRACKLINK_
        EnableTracking(m_pMonikerAbs, OT_READTRACKINGINFO);
#endif

	m_flags |= DL_DIRTY_LINK;

	fNeedToUpdate = TRUE;
    }

    // send out an advise to any interested parties if we changed our
    // monikers.  Note that we do this even if just the relative moniker
    // changed because the moniker we give apps via GetSourceMoniker is
    // computed from the relative.

    if( fNeedToUpdate && m_pCOAHolder )
    {
	m_pCOAHolder->SendOnLinkSrcChange(m_pMonikerAbs);
    }

    hresult = NOERROR;

    LEDebugOut((DEB_ITRACE, "%p OUT CDefLink::UpdateMksFromAbs ( %lx )\n",
	this, hresult));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::GetAbsMkFromRel (private)
//
//  Synopsis:   Gets the absolute moniker from the relative moniker
//              stored in the link
//
//  Effects:
//
//  Arguments:  [ppmkAbs]       -- where to put the pointer to the moniker
//		[ppmkCont]	-- where to put the container moniker
//				   (may be NULL)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:  calls IMoniker->ComposeWith on the moniker to the container
//
//  History:    dd-mmm-yy Author    Comment
//		09-Jan-95 alexgo    added ppmkCont parameter
//		21-Nov-94 alexgo    memory optimization
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

INTERNAL CDefLink::GetAbsMkFromRel(IMoniker **ppmkAbs, IMoniker **ppmkCont )
{
    LPMONIKER       pmkContainer = NULL;
    HRESULT         hresult;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_ITRACE, "%p _IN CDefLink::GetAbsMkFromRel ( %p , %p )\n",
        this, ppmkAbs, ppmkCont));

    *ppmkAbs = NULL;
    if (m_pMonikerRel == NULL)
    {
        hresult = E_FAIL;
        goto errRtn;
    }

    hresult = GetMoniker( OLEGETMONIKER_ONLYIFTHERE,
        OLEWHICHMK_CONTAINER, &pmkContainer );
    AssertOutPtrIface(hresult, pmkContainer);
    if (hresult != NOERROR)
    {
        goto errRtn;
    }

    Assert(pmkContainer != NULL);

    hresult = pmkContainer->ComposeWith( m_pMonikerRel, FALSE, ppmkAbs );

    if (pmkContainer)
    {
	if( ppmkCont )
	{
	    *ppmkCont = pmkContainer;  // no need to AddRef, just implicitly
				       // transfer ownership from pmkContainer
	}
	else
	{
	    pmkContainer->Release();
	}
    }

errRtn:

    LEDebugOut((DEB_ITRACE, "%p OUT CDefLink::GetAbsMkFromRel ( %lx ) "
        "[ %p ]\n", this, hresult, *ppmkAbs));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::SetUpdateOptions
//
//  Synopsis:   Sets the update options for the link (such as always or
//              manual)
//
//  Effects:
//
//  Arguments:  [dwUpdateOpt]   -- update options
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleLink
//
//  Algorithm:  If UPDATE_ALWAYS, then update the caches, otherwise
//              call OnStop  (via EndUpdates)
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized and handle zombie case
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::SetUpdateOptions(DWORD dwUpdateOpt)
{
    HRESULT         hresult;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::SetUpdateOptions "
        "( %lx )\n", this, dwUpdateOpt));

    CRefStabilize stabilize(this);

    if( IsZombie() )
    {
        hresult = CO_E_RELEASED;
        goto errRtn;
    }

    switch (dwUpdateOpt)
    {
        case OLEUPDATE_ALWAYS:
            // make sure we are connected if running
            BindIfRunning();

            // if we've already are in UPDATE_ALWAYS mode,
            // we don't need to reenter
            if (m_pUnkDelegate &&
                m_dwUpdateOpt != OLEUPDATE_ALWAYS)
            {
                BeginUpdates();
            }
            break;

        case OLEUPDATE_ONCALL:
            // if we aren't already in UPDATE_ONCALL mode, then
            // enter it.
            if (m_dwUpdateOpt != OLEUPDATE_ONCALL)
            {
                // inform cache that we are not running
                // (even if not running)
                EndUpdates();
            }
            break;
        default:
            hresult = E_INVALIDARG;
            goto errRtn;
    }

    m_dwUpdateOpt = dwUpdateOpt;

    m_flags |= DL_DIRTY_LINK;

    hresult = NOERROR;

errRtn:
    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::SetUpdateOptions "
        "( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::GetUpdateOptions
//
//  Synopsis:   Retrieves the current update mode for the link
//
//  Effects:
//
//  Arguments:  [pdwUpdateOpt]  -- wehre to put the update options
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleLink
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::GetUpdateOptions(LPDWORD pdwUpdateOpt)
{
    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::GetUpdateOptions "
        "( %p )\n", this, pdwUpdateOpt));

    *pdwUpdateOpt = m_dwUpdateOpt;

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::GetUpdateOptions "
        "( %lx ) [ %lx ]\n", this, NOERROR, *pdwUpdateOpt));

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::SetSourceMoniker
//
//  Synopsis:   Sets the link source moniker
//
//  Effects:
//
//  Arguments:  [pmk]           -- moniker to the new source  (NULL used
//                                 for CancelLink operations)
//              [rclsid]        -- the clsid of the source
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleLink
//
//  Algorithm:  Stores the new absolute moniker and creates a new relative
//              moniker from the absolute moniker
//
//  History:    dd-mmm-yy Author    Comment
//		09-Jan-95 alexgo    added call to SetUpdateTimes to keep
//				    internal state consistent
//		21-Nov-94 alexgo    memory optimization
///		03-Aug-94 alexgo    stabilized and handle zombie case
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::SetSourceMoniker( LPMONIKER pmk, REFCLSID clsid )
{
    HRESULT		hresult = NOERROR;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::SetSourceMoniker "
        "( %p , %p )\n", this, pmk, clsid));

    CRefStabilize stabilize(this);

    if( IsZombie() )
    {
        hresult = CO_E_RELEASED;
        goto errRtn;
    }

    if (pmk)
    {
        VDATEIFACE(pmk);
    }


    UnbindSource();

    // REVIEW: the following code appears in several places and should
    // be put in a separate routine:
    // SetBothMk(pmkSrcAbs, <calculated from abs>,
    // TRUE/*fBind*/);

    if (m_pMonikerAbs)
    {
        m_pMonikerAbs->Release();
    }

    if ((m_pMonikerAbs = pmk) != NULL)
    {
        pmk->AddRef();

        //
        // TRACKLINK
        //
        // -- use ITrackingMoniker to convert file moniker to
        //    be tracking.
        //
#ifdef _TRACKLINK_
        EnableTracking(pmk, OT_READTRACKINGINFO);
#endif
    }

    UpdateRelMkFromAbsMk(NULL);

    // to prevent error in BindToSource when clsid is different; i.e., we
    // shouldn't fail to connect (or require OLELINKBIND_EVENIFCLASSDIFF)
    // when the moniker is changed; i.e., we expect the class to change
    // so don't bother the programmer.
    m_clsid = CLSID_NULL;

    if (BindIfRunning() != NOERROR)
    {
        // server not running -> use clsid given (even if CLSID_NULL
        // and even
        // if no moniker)
        m_clsid = clsid;
    }

errRtn:

	
    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::SetSourceMoniker "
        "( %lx )\n", this, hresult ));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::GetSourceMoniker
//
//  Synopsis:   Gets the moniker to the source
//
//  Effects:
//
//  Arguments:  [ppmk]          -- where to put the moniker
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleLink
//
//  Algorithm:  We first try to build a new absolute moniker from the
//              relative one, if that fails then we return the currently
//              stored absolute moniker.
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::GetSourceMoniker(LPMONIKER *ppmk)
{
    LPMONIKER       pmkAbs = NULL;
    //  the absolute moniker constructed from the rel
    HRESULT         hresult = NOERROR;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::GetSourceMoniker "
        "( %p )\n", this, ppmk));

    CRefStabilize stabilize(this);

    GetAbsMkFromRel(&pmkAbs, NULL);
    if (pmkAbs)
    {
        *ppmk = pmkAbs;     // no addref
    }
    else if (*ppmk = m_pMonikerAbs)
    {
        // we've been asked to give the pointer so we should AddRef()
        m_pMonikerAbs->AddRef();
    }
    else
    {
        hresult = MK_E_UNAVAILABLE;
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::GetSourceMoniker "
        "( %lx ) [ %p ]\n", this, hresult, *ppmk));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::SetSourceDisplayName
//
//  Synopsis:   Creates a moniker from the display name and calls
//              SetSourceMoniker, thus setting the moniker to the source
//
//  Effects:
//
//  Arguments:  [lpszStatusText]        -- the display name
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleLink
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized and handle the zombie case
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::SetSourceDisplayName(
    LPCOLESTR lpszStatusText)
{
    HRESULT                 error;
    IBindCtx FAR*           pbc;
    ULONG                   cchEaten;
    IMoniker FAR*           pmk;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::SetSourceDisplay"
        "Name ( %p )\n", this, lpszStatusText));

    CRefStabilize stabilize(this);

    if( IsZombie() )
    {
        error = CO_E_RELEASED;
        goto errRtn;
    }

    if (error = CreateBindCtx(0,&pbc))
    {
        goto errRtn;
    }

    error = MkParseDisplayName(pbc, (LPOLESTR)lpszStatusText, &cchEaten,
            &pmk);


    // In Daytona, we release the hidden server
    // must release this now so the (possibly) hidden server goes away.
    Verify(pbc->Release() == 0);

    if (error != NOERROR)
    {
        goto errRtn;
    }


    error = SetSourceMoniker(pmk, CLSID_NULL);

    pmk->Release();

    // NOTE: we don't bind to the link source now since that would leave
    // the server running, but hidden.  If the caller want to not start
    // the server twice it should parse the moniker itself, call
    // SetSourceMoniker and then BindToSource with the bind context of
    // the parse.

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::SetSourceDisplay"
        "Name ( %lx )\n", this, error ));

    return error;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::GetSourceDisplayName
//
//  Synopsis:   Retrieves the source display name (such as that set with
//              SetSourceDisplayName)
//
//  Effects:
//
//  Arguments:  [lplpszDisplayName]     -- where to put a pointer to the
//                                         display name
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleLink
//
//  Algorithm:  Gets the absolute moniker and asks it for the display name
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::GetSourceDisplayName( LPOLESTR *lplpszDisplayName )
{
    HRESULT                 hresult;
    IBindCtx FAR*           pbc;
    LPMONIKER               pmk = NULL;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::GetSourceDisplay"
        "Name ( %p )\n", this, lplpszDisplayName));

    CRefStabilize stabilize(this);

    *lplpszDisplayName = NULL;

    GetSourceMoniker(&pmk);

    if (pmk == NULL)
    {
        hresult = E_FAIL;
        goto errRtn;
    }

    if (hresult = CreateBindCtx(0,&pbc))
    {
        goto errRtn;
    }

    hresult = pmk->GetDisplayName(pbc, NULL,lplpszDisplayName);
    AssertOutPtrParam(hresult, *lplpszDisplayName);

    Verify(pbc->Release() == 0);
errRtn:
    if (pmk)
    {
        pmk->Release();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::GetSourceDisplay"
        "Name ( %lx ) [ %p ]\n", this, hresult,
        *lplpszDisplayName));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::BindToSource
//
//  Synopsis:   Binds to the link source
//
//  Effects:
//
//  Arguments:  [bindflags]     -- controls the binding (such as binding
//                                 even if the class ID is different)
//              [pbc]           -- the bind context
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleLink
//
//  Algorithm:  First try binding with the relative moniker, failing that
//              then try the absolute moniker.  Once bound, we set up
//              the advises and cache.
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilize and check for zombie case
//              03-Feb-94 alexgo    check for NULL before SendOnLinkSrcChange
//              11-Jan-94 alexgo    cast -1's to DWORD to fix compile
//                                  warning
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::BindToSource(DWORD bindflags, LPBINDCTX pbc)
{
    HRESULT                         error = S_OK;
    IOleObject FAR*                 pOleDelegate;
    IDataObject FAR*                pDataDelegate;
    IBindCtx FAR*                   pBcUse;
    CLSID                           clsid;
    LPMONIKER                       pmkAbs = NULL;
    LPMONIKER                       pmkHold = NULL;
    LPRUNNABLEOBJECT		        pRODelegate;
    LPOLEITEMCONTAINER		        pOleCont;
    BOOL		                    fLockedContainer;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::BindToSource "
        "( %lx , %p )\n", this, bindflags, pbc));

    CRefStabilize stabilize(this);

    // if we're zombied (e.g. in the middle of our destructor), we
    // don't really want to bind the source again ;-)

    if( IsZombie() )
    {
        error = CO_E_RELEASED;
        goto logRtn;
    }

    // if we're running, then we're already bound
    if (IsReallyRunning())
    {
        error = NOERROR;
        goto logRtn;
    }

    // nobody to bind to
    if (m_pMonikerAbs == NULL)
    {
        error = E_UNSPEC;
        goto logRtn;
    }

    if ((pBcUse = pbc) == NULL && (error = CreateBindCtx(0,&pBcUse))
        != NOERROR)
    {
        goto errRtn;
    }

    {
        //
        // Rewritten BillMo 30 Jan 1995.
        //
        // Enumeration which is used to keep track of what stage of resolution
        // we were successful in.
        //
        enum
        {
            None, Relative, Ids, Absolute
        } ResolveSuccess = { None };
   
        if (m_pMonikerRel != NULL)
        {
            error = GetAbsMkFromRel(&pmkAbs, NULL);
            if (error == NOERROR)
            {
                error = pmkAbs->BindToObject(pBcUse,
                                 NULL,
                                 IID_IUnknown,
                                 (LPVOID FAR *) &m_pUnkDelegate);
                if (error == NOERROR)
                {
                     ResolveSuccess = Relative;
                }
                else
                {
                     pmkAbs->Release();
                     pmkAbs = NULL;
                }
            }
        }

        if (ResolveSuccess == None && error != RPC_E_CALL_REJECTED)
        {
            error = m_pMonikerAbs->BindToObject(pBcUse,
                 NULL,
                 IID_IUnknown,
                 (LPVOID FAR *)&m_pUnkDelegate);
            if (error == NOERROR)
            {
                ResolveSuccess = Absolute;
                (pmkAbs = m_pMonikerAbs)->AddRef();
            }
        }

#ifdef _TRACKLINK_
        if (ResolveSuccess == None && error != RPC_E_CALL_REJECTED)
        {
            HRESULT error2;
            Assert(pmkAbs == NULL);
            EnableTracking(m_pMonikerAbs, OT_ENABLEREDUCE);
            error2 = m_pMonikerAbs->Reduce(pBcUse,
                MKRREDUCE_ALL,
                NULL,
                &pmkAbs);
            EnableTracking(m_pMonikerAbs, OT_DISABLEREDUCE);
            if (error2 == NOERROR)
            {
                if (pmkAbs != NULL)
                {
                    error2 = pmkAbs->BindToObject(pBcUse,
                         NULL,
                         IID_IUnknown,
                         (LPVOID FAR *)&m_pUnkDelegate);
                    if (error2 == NOERROR)
                    {
                        ResolveSuccess = Ids;
                        error = NOERROR;
                    }
                    else
                    {
                        pmkAbs->Release();
                        pmkAbs=NULL;
                    }
                }
                // else error contains error from m_pMonikerAbs->BindToObject
            }
            else
            if (error2 == MK_S_REDUCED_TO_SELF)
            {
                if (pmkAbs != NULL)
                {
                    pmkAbs->Release();
                    pmkAbs=NULL;
                }
            }
            // else error contains error from m_pMonikerAbs->BindToObject
        }
#endif
        //
        // Update the link state
        //
  
        if (ResolveSuccess == None)
            goto errRtn;

        // Update the absolute moniker and send OnLinkSrcChange
        // (may update relative if this was an Ids resolve)
        if (ResolveSuccess == Relative || ResolveSuccess == Ids)
        {
            // binding succeeded with relative moniker or ids
            // Update the absolute one.
    
            // hold on to old absolute one
            pmkHold = m_pMonikerAbs;
            if (pmkHold)
            {
                pmkHold->AddRef();
            }
    
            if (m_pMonikerAbs)
            {
                m_pMonikerAbs->Release();
                m_pMonikerAbs = NULL;
            }
    
            if (ResolveSuccess == Relative)
            {
                GetAbsMkFromRel(&m_pMonikerAbs, NULL);
            }
            else
            {
                // Ids
                m_pMonikerAbs = pmkAbs;
                pmkAbs = NULL;
                UpdateRelMkFromAbsMk(NULL);
            }
    
            //
            // test to see if we had no abs moniker before OR the
            // one we had is different to the new one.
            //
    
            if (pmkHold == NULL ||
                pmkHold->IsEqual(m_pMonikerAbs)
                != NOERROR )
            {
                m_flags |= DL_DIRTY_LINK;
    
                // send change notification if the advise
                // holder present.
                if( m_pCOAHolder)
                {
                  m_pCOAHolder->SendOnLinkSrcChange(
                    m_pMonikerAbs);
                }
            }
    
            // have new absolute moniker; dirty
            if (pmkHold)
            {
                pmkHold->Release();
            }
        }
   
        // Update the relative
        if (ResolveSuccess == Absolute)
        {
           UpdateRelMkFromAbsMk(NULL);
        }
    }

#ifdef _TRACKLINK_
    EnableTracking(m_pMonikerAbs, OT_READTRACKINGINFO);

    if (m_pMonikerAbs->IsDirty())
        m_flags |= DL_DIRTY_LINK;
#endif

    // NOTE: don't need to update the relative moniker when there isn't
    // one because we will do that at save time.

    // Successfully bound, Lock the Object.
    if ((pRODelegate = GetRODelegate()) != NULL)
    {
 	// lock  so invisible link source does not goes away.

	Assert(0 == (m_flags  & DL_LOCKED_RUNNABLEOBJECT));

        if (NOERROR == pRODelegate->LockRunning(TRUE, FALSE))
        {
	    m_flags |= DL_LOCKED_RUNNABLEOBJECT;
        }
    }
    else if( (pOleCont = GetOleItemContainerDelegate()) != NULL)
    {
		
	// have container in same process or handler which doesn't
	// support IRunnableObject. 

	Assert(0 == (m_flags  & DL_LOCKED_OLEITEMCONTAINER));

	if (NOERROR == pOleCont->LockContainer(TRUE))
	{
	    m_flags |= DL_LOCKED_OLEITEMCONTAINER;
	}

    }


     // Lock the container
    fLockedContainer = m_flags & DL_LOCKED_CONTAINER;

    DuLockContainer(m_pAppClientSite, TRUE, &fLockedContainer );

    if(fLockedContainer)
    {
        m_flags |= DL_LOCKED_CONTAINER;
    }
    else
    {
        m_flags &= ~DL_LOCKED_CONTAINER;
    }

    // By this point, we have successfully bound to the server.  Now
    // we take care of misc administrative tasks.

    Assert(m_pUnkDelegate != NULL &&
       "CDefLink::BindToSource expected valid m_pUnkDelegate");

    // get class of link source; use NULL if it doesn't support IOleObject
    // or IOleObject::GetUserClassID returns an error.
    if ((pOleDelegate = GetOleDelegate()) == NULL ||
        pOleDelegate->GetUserClassID(&clsid) != NOERROR)
    {
        clsid = CLSID_NULL;
    }

    // if different and no flag, release and return error.
    if ( IsEqualCLSID(m_clsid,CLSID_NULL))
    {
        // m_clsid now NULL; link becomes dirty
	m_flags |= DL_DIRTY_LINK;
    }
    else if ( !IsEqualCLSID(clsid, m_clsid) )
    {
        if ((bindflags & OLELINKBIND_EVENIFCLASSDIFF) == 0)
        {
            CLSID TreatAsCLSID;

            // Initialize error
            error = OLE_E_CLASSDIFF;
            
            // Check for TreatAs case
            if(CoGetTreatAsClass(m_clsid, &TreatAsCLSID) == S_OK) {
                // Check if the server clsid is same as TreatAs clsid
                if(IsEqualCLSID(clsid, TreatAsCLSID))
                    error = NOERROR;
            }

            if(error == OLE_E_CLASSDIFF)
                goto errRtn;
        }

        // clsid's do no match; link becomes dirty
	m_flags |= DL_DIRTY_LINK;
    }

    // use new class (even if null); dirty flag set above
    m_clsid = clsid;

    // it is possible that a re-entrant call unbound our source
    // thus making pOleDelegate invalid (since it's a local on
    // the stack

    LEWARN(pOleDelegate != m_pOleDelegate,
            "Unbind during IOL::BindToSource");

    // we fetched m_pOleDelegate in the call to GetOleDelegate above.
    if( m_pOleDelegate != NULL)
    {
        // set single ole advise (we multiplex)
        if ((error =  m_pOleDelegate->Advise(
                    &m_AdviseSink,
                    &m_dwConnOle)) != NOERROR)
        {
            goto errRtn;
        }
    }

    // Set up advise connections for data changes
    if( pDataDelegate = GetDataDelegate() )
    {
        // setup wild card advise to get time change
        FORMATETC       fetc;

        fetc.cfFormat   = NULL;
        fetc.ptd        = NULL;
        fetc.dwAspect   = (DWORD)-1L;
        fetc.lindex     = -1;
        fetc.tymed      = (DWORD)-1L;

        if ((error = pDataDelegate->DAdvise(&fetc, ADVF_NODATA,
            &m_AdviseSink,
            &m_dwConnTime)) != NOERROR)
        {
            LEDebugOut((DEB_WARN, "WARNING: server does not "
                "support wild card advises\n"));
            goto errRtn;
        }


        // it is possible that a re-entrant call unbound our
        // link server, so we need to fetch the data object
        // pointer again

        LEWARN(pDataDelegate != m_pDataDelegate,
            "Unbind during IOL::BindToSource");

        // this will set up data advise connections with
        // everybody in our data advise holder
        // (see dacache.cpp)

        error = m_pDataAdvCache->EnumAndAdvise(
                m_pDataDelegate, TRUE);

        if( error != NOERROR )
        {
            goto errRtn;
        }
    }

    if (m_dwUpdateOpt == OLEUPDATE_ALWAYS)
    {
        // we inform the cache that we are running only if auto
        // update; otherwise, we are a manual link and will call
        // Update directly (which doesn't require OnRun to be called).

        BeginUpdates();
    }

    //  Our m_pUnkDelegate may have been released by an
    //  OnClose advise that came in while we were setting up Advise
    //  sinks.

    if (NULL == m_pUnkDelegate)
    {
        LEDebugOut((DEB_WARN,
              "CDefLink::BindToSource - "
              "m_pUnkDelegate was released "
              "(probably due to OnClose)"));

        error = MK_E_NOOBJECT;
    }

errRtn:
    // free used resources
    if (pmkAbs)
    {
        pmkAbs->Release();
    }
    if (error == NOERROR) {
        m_ContentSRVMSBits = 0;
        m_ContentSRVMSHResult = 0xFFFFFFFF;
    }
    else {
        UnbindSource(); // ClientSite will be unlocked in UnBindSource
    }

    if (pbc == NULL && pBcUse != NULL)
    {
        // created bind ctx locally
        Verify(pBcUse->Release() == 0);
    }

#if DBG == 1
    if( m_pUnkDelegate )
    {
        Assert(error == NOERROR );
    }
    else
    {
        Assert(error != NOERROR );
    }
#endif
    AssertOutPtrIface(error, m_pUnkDelegate);

logRtn:

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::BindToSource "
        "( %lx )\n", this, error ));

    return error;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::BindIfRunning
//
//  Synopsis:   Binds to the source server only if it is currently running
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    HRESULT (NOERROR if connected)
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleLink
//
//  Algorithm:  Gets a good moniker to the source (first tries relative,
//              then tries absolute), ask it if the server is running, if
//              yes, then bind to it.
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilize and handle the zombie case
//              19-Nov-93 alexgo    32bit port
//
//  Notes:      We may return NOERROR (connected) even if the server has
//              crashed unexpectedly
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::BindIfRunning(void)
{
    HRESULT                 error;
    LPBC                    pbc;
    LPMONIKER               pmkAbs = NULL;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::BindIfRunning "
        "( )\n", this ));

    CRefStabilize stabilize(this);

    // if we're zombied (e.g. in our destructor), then we don't want
    // to bind to the server!

  
    if( IsZombie() )
    {
        error = CO_E_RELEASED;
        goto errRtn;
    }

    if (IsReallyRunning())
    {
        error = NOERROR;
        goto errRtn;
    }

    // try getting an absolute moniker from the relative moniker first
    if (GetAbsMkFromRel(&pmkAbs, NULL) != NOERROR)
    {
        // can't get relative moniker; use abs if available
        if ((pmkAbs = m_pMonikerAbs) == NULL)
        {
            error = E_FAIL;
            goto errRtn;
        }

        pmkAbs->AddRef();
    }

    // NOTE: we used to try both monikers, but this caused problems if
    // both would bind and the absolute one was running: we would bind
    // to the wrong one or force the relative one to be running.  Now,
    // if we have a relative moniker, we try that one only; if we only
    // have an absolute moniker, we try that one; otherwise we fail.

    error = CreateBindCtx( 0, &pbc );
    if (error != NOERROR)
    {
        goto errRtn;
    }

    if ((error = pmkAbs->IsRunning(pbc, NULL, NULL)) == NOERROR)
    {
        // abs is running, but rel is not; force BindToSource to use
        // the absolute moniker
        error = BindToSource(0, pbc);
    }

    // else return last error (from pmkAbs->IsRunning)

    pbc->Release();

errRtn:
    if (pmkAbs)
    {
        pmkAbs->Release();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::BindIfRunning "
        "( %lx )\n", this, error ));

    return error;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::GetBoundSource
//
//  Synopsis:   Returns a pointer to the server delegate
//
//  Effects:
//
//  Arguments:  [ppUnk]         -- where to put the pointer to the server
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleLink
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::GetBoundSource(LPUNKNOWN *ppUnk)
{
    HRESULT         hresult;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::GetBoundSource "
        "( %p )\n", this, ppUnk));

    CRefStabilize stabilize(this);

    if (!IsReallyRunning())
    {
        *ppUnk = NULL;
        hresult = E_FAIL;
    }
    else
    {
        (*ppUnk = m_pUnkDelegate)->AddRef();
        hresult = NOERROR;
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::GetBoundSource "
        "( %lx ) [ %p ]\n", this, hresult, *ppUnk));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::UnbindSource
//
//  Synopsis:   Unbinds the connection to the link source server
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleLink
//
//  Algorithm:  First unadvise all advise connections and then tickle
//              the container by lock/unlocking (to handle the silent
//              update case).  Finally, we release all pointers to the
//              server.  If we were the only folks connected, the server
//              will go away
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::UnbindSource(void)
{
    LPDATAOBJECT            pDataDelegate;
    LPOLEOBJECT             pOleDelegate;
    LPRUNNABLEOBJECT        pRODelegate;
    LPOLEITEMCONTAINER      pOleCont;
    HRESULT                 hresult = NOERROR;
    IUnknown *              pUnkDelegate;
    BOOL                    fLockedContainer;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::UnbindSource "
        "( )\n", this ));

    CRefStabilize stabilize(this);

    if (!m_pUnkDelegate)
    {
        // hresult == NOERROR
        goto errRtn;
    }

    // unadvise so if delegate stays around, we get the correct results
    if ((pOleDelegate = GetOleDelegate()) != NULL &&
        m_dwConnOle != 0)
    {
 	pOleDelegate->Unadvise(m_dwConnOle);
 	m_dwConnOle = 0;
   }

    if( pDataDelegate = GetDataDelegate() )
    {
        if (m_dwConnTime)
        {
            pDataDelegate->DUnadvise(m_dwConnTime);
	    m_dwConnTime = 0;
        }

        // we can actually be re-entered here, so refetch the
        // IDO pointer from the server (if it's still around)

        LEWARN(pDataDelegate != m_pDataDelegate,
            "Unbind called within IOL::UnbindSource!");

        // pDataDelegate should still be good, since we still have
        // an AddRef on it.  Go through and do the unadvises again
        // anyway.

        // this will unadvise everybody registered in the data
        // advise holder
        m_pDataAdvCache->EnumAndAdvise(
            pDataDelegate, FALSE);
    }

    // inform cache that we are not running (even if OnRun was not called)
    EndUpdates();

	
    if ( (m_flags & DL_LOCKED_RUNNABLEOBJECT) && 
	    ((pRODelegate = GetRODelegate()) != NULL) )
    {
        // unlock so invisible link source goes away.
        // do it just before release delegates so above unadvises go

	m_flags &= ~DL_LOCKED_RUNNABLEOBJECT;
	pRODelegate->LockRunning(FALSE, TRUE);
    }
    
	
    if(  (m_flags & DL_LOCKED_OLEITEMCONTAINER)  && 
	    ((pOleCont = GetOleItemContainerDelegate()) != NULL) )
    {
        // have container in same process or handler
        // Unlock to shutdown.

	m_flags &= ~DL_LOCKED_OLEITEMCONTAINER;
	pOleCont->LockContainer(FALSE);
    }

    Assert(0 == (m_flags & (DL_LOCKED_OLEITEMCONTAINER | DL_LOCKED_RUNNABLEOBJECT)));

    // release all of our pointers.

    ReleaseOleDelegate();
    ReleaseDataDelegate();
    ReleaseRODelegate();
    ReleaseOleItemContainerDelegate();

    // if we are the only consumer of this data, the following will stop
    // the server; set member to NULL first since release may cause this
    // object to be accessed again.

    pUnkDelegate = m_pUnkDelegate;

    LEWARN(pUnkDelegate == NULL, "Unbind called within IOL::UnbindSource");

    m_pUnkDelegate = NULL;

    if( pUnkDelegate )
    {
        pUnkDelegate->Release();
    }

    // make sure unlocked if we locked it
    fLockedContainer = m_flags & DL_LOCKED_CONTAINER;
    m_flags &= ~DL_LOCKED_CONTAINER;
    DuLockContainer(m_pAppClientSite, FALSE, &fLockedContainer);


    AssertSz( hresult == NOERROR, "Bogus code modification, check error "
        "paths");

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::UnbindSource "
        "( %lx )\n", this, hresult));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::Update
//
//  Synopsis:   Updates the link (fills cache, etc).
//
//  Effects:
//
//  Arguments:  [pbc]           -- the bind context
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOleLink
//
//  Algorithm:  Bind to the server, then update the caches
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//              As in IOO::DoVerb, we try to "fix" crashed servers by
//              staying bound to them if we rebind due to a crash.  See
//              the Notes in IOO::DoVerb for more info.
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::Update(LPBINDCTX pbc)
{
    HRESULT         error = NOERROR;
    BOOL            bStartedNow = !m_pUnkDelegate;
    LPBINDCTX	    pBcUse;			

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::Update ( %p )\n",
        this, pbc));

    CRefStabilize stabilize(this);

    if (pbc)
    {
	pBcUse = pbc;
    }
    else
    {
	if (FAILED(error = CreateBindCtx( 0, &pBcUse )))
	    goto errBndCtx;
    }


    if (FAILED(error = BindToSource(0,pBcUse)))
    {
        goto errRtn;
    }

    // store the pUnk there to allow for
    // better optimization (if we didn't, file based link sources would
    // be launched multiple times since the moniker code does not put
    // them in the bind ctx (and probably shouldn't)).
    pBcUse->RegisterObjectBound(m_pUnkDelegate);

    SetUpdateTimes();       //  ignore error.

    if (bStartedNow && (m_dwUpdateOpt == OLEUPDATE_ALWAYS))
    {
        // if this is an auto-link and we ran it now, then all the
        // automatic caches would have been updated during the
        // running process.  So, here we have to update only the
        // ADVFCACHE_ONSAVE caches.
        error= m_pCOleCache->UpdateCache(
                GetDataDelegate(),
                UPDFCACHE_IFBLANKORONSAVECACHE, NULL);
    }
    else
    {
        // This is a manual-link or it is an auto-link then it is
        // already running. In all these cases, all the caches need
        // to be updated.
        // (See bug 1616, to find out why we also have to update
        // the autmatic caches of auto-links).

        error= m_pCOleCache->UpdateCache(
                GetDataDelegate(),
                UPDFCACHE_ALLBUTNODATACACHE, NULL);
    }

    if (bStartedNow)
    {
        UnbindSource();
    }



errRtn:

    // if we created a bind context release it.
    if ( (NULL == pbc) && pBcUse)
    {
	pBcUse->Release();
    }

errBndCtx:

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::Update ( %lx )\n",
        this, error ));

    return error;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::EnableTracking
//
//  Synopsis:   Calls ITrackingMoniker::EnableTracking on the passed moniker.
//
//  Arguments:  [pmk]           -- moniker 
//
//              [ulFlags]
//              OT_READTRACKINGINFO -- read tracking info from source
//              OT_ENABLESAVE -- enable save of tracking info
//              OT_DISABLESAVE -- disable save of tracking info
//
//  Algorithm:  QI to ITrackingMoniker and call EnableTracking
//
//
//--------------------------------------------------------------------------
#ifdef _TRACKLINK_
INTERNAL CDefLink::EnableTracking(IMoniker *pmk, ULONG ulFlags)
{
    ITrackingMoniker *ptm = NULL;
    HRESULT hr = E_FAIL;

    if (pmk != NULL)
    {
        hr = pmk->QueryInterface(IID_ITrackingMoniker, (void**)&ptm);
        if (hr == S_OK)
        {
            hr = ptm->EnableTracking(NULL, ulFlags);
            LEDebugOut((DEB_TRACK,
                "CDefLink(%08X)::EnableTracking -- ptm->EnableTracking() = %08X\n",
                this, hr));
            ptm->Release();
        }
        else
        {
            LEDebugOut((DEB_TRACK,
                "CDefLink(%08X)::EnableTracking -- pmk->QI failed (%08X)\n",
                this, hr));
        }
    }
    else
    {
        LEDebugOut((DEB_TRACK,
            "CDefLink(%08X)::EnableTracking -- pmk is NULL\n",
            this));
    }
    return(hr);
}
#endif


/*
 *      IMPLEMENTATION of CROImpl methods
 */


//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::GetRODelegate  (private)
//
//  Synopsis:   gets the IRunnableObject from the interface
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    IRunnableObject *
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized and handle the zombie case
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//              This function may return misleading information if the
//              server has died (i.e., you'll return a pointer to a cached
//              interface proxy).  It is the responsibility of the caller
//              to handler server crashes.
//
//--------------------------------------------------------------------------

INTERNAL_(IRunnableObject *) CDefLink::GetRODelegate(void)
{
    IRunnableObject *pRODelegate;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CDefLink::GetRODelegate "
        "( )\n", this ));

    // if we're zombied, then we don't want to QI for a new interface!!

    if( !IsZombie() )
    {
        DuCacheDelegate(&(m_pUnkDelegate),
            IID_IRunnableObject, (LPLPVOID)&m_pRODelegate, NULL);

        pRODelegate = m_pRODelegate;

#if DBG == 1
        if( m_pRODelegate )
        {
            Assert(m_pUnkDelegate);
        }
#endif  // DBG == 1
    }
    else
    {
        pRODelegate = NULL;
    }


    LEDebugOut((DEB_ITRACE, "%p OUT CDefLink::GetRODelegate "
        "( %p )\n", this, pRODelegate));

    return pRODelegate;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::ReleaseRODelegate (private)
//
//  Synopsis:   Releases the IRO pointer to the server
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

INTERNAL_(void) CDefLink::ReleaseRODelegate(void)
{
    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CDefLink::ReleaseRODelegate "
        "( )\n", this ));

    if (m_pRODelegate)
    {
        SafeReleaseAndNULL((IUnknown **)&m_pRODelegate);
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CDefLink::ReleaseRODelegate "
        "( )\n", this ));
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::GetRunningClass
//
//  Synopsis:   retrieves the class of the the default link
//
//  Effects:
//
//  Arguments:  [lpClsid]       -- where to put the class id
//
//  Requires:
//
//  Returns:    NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IRunnableObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::GetRunningClass(LPCLSID lpClsid)
{
    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::GetRunningClass "
        "( %p )\n", this, lpClsid));

    VDATEPTROUT(lpClsid, CLSID);

    *lpClsid = CLSID_StdOleLink;

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::GetRunningClass "
        "( %lx )\n", this, NOERROR));

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::Run
//
//  Synopsis:   Runs the object (binds to the server)
//
//  Effects:
//
//  Arguments:  [pbc]   -- the bind context
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IRunnableObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::Run (LPBINDCTX pbc)
{
    HRESULT         hresult;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::Run ( %p )\n",
        this, pbc ));

    CRefStabilize stabilize(this);

    hresult = BindToSource(0, pbc);

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::Run ( %lx )\n",
        this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CDefLink::IsRunning
//
//  Synopsis: 	returns whether or not we've bound to the link server
//
//  Effects:
//
//  Arguments: 	none
//
//  Requires:
//
//  Returns:  	TRUE/FALSE
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IRunnableObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//   		27-Aug-94 alexgo    author
//
//  Notes:	16bit OLE only ever implemented this function.  We
//		implement IsReallyRunning to allow links to recover
//		from a crashed server.
//		Unfortunately, we can't just move the IsReallyRunning
//		implementation into IsRunning.  Many apps (like Project)
//		sit and spin calling OleIsRunning.  IsReallyRunning also
//		will sometimes make outgoing RPC calls; with Project,
//		this causes a really cool infinite feedback loop.  (the
//		outgoing call resets some state in Project and they decide
//		to call OleIsRunning again ;-)
//
//--------------------------------------------------------------------------

STDMETHODIMP_(BOOL) CDefLink::IsRunning (void)
{
    BOOL fRet;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::IsRunning ( )\n",
        this ));

    if( m_pUnkDelegate )
    {
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::IsRunning ( %d )\n",
        this, fRet));

    return fRet;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::IsReallyRunning
//
//  Synopsis:   Returns whether or not the link server is running
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    BOOL -- TRUE == is running
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:  If we have not yet bound to the link server, then we
//              are not running.  If we have, we would like to verify
//              that the server is still running (i.e. it hasn't crashed).
//              Thus, we ask the absolute  moniker if we are still running.
//              (it will ping the rot, which will ping the server).
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              06-May-94 alexgo    now calls IMoniker::IsRunning
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//
//--------------------------------------------------------------------------

STDMETHODIMP_(BOOL) CDefLink::IsReallyRunning (void)
{
    BOOL    fRet = FALSE;
    LPBC    pbc;
    HRESULT hresult;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_ITRACE, "%p _IN CDefLink::IsReallyRunning "
        "( )\n", this));

    CRefStabilize stabilize(this);

    if( m_pUnkDelegate != NULL )
    {
        if( CreateBindCtx( 0, &pbc ) != NOERROR )
        {
            // this is a bit counter-intuitive.  Basically,
            // the only error we'll get is OutOfMemory, but
            // we have no way of returning that error.

            // In order to mimimize the amount of work we need
            // to do (since we are in a low-mem state), just
            // return the current Running state (in this,
            // TRUE, since m_pUnkDelegate is not NULL

            fRet = TRUE;
            goto errRtn;
        }

        if( m_pMonikerAbs )
        {
            hresult = m_pMonikerAbs->IsRunning(pbc,
                NULL, NULL);

            if( hresult != NOERROR )
            {
                LEDebugOut((DEB_WARN, "WARNING: link server "
                    "crashed or exited inappropriately "
                    "( %lx ).  Recovering...\n", hresult));

                // wowsers, the server has crashed or gone
                // away even though we were bound to it.
                // let's go ahead and unbind.

                // don't worry about errors here; we're
                // just trying to cleanup as best we can

                UnbindSource();
            }
            if( hresult == NOERROR )
            {
                fRet = TRUE;
            }
#if DBG == 1
            else
            {
                Assert(fRet == FALSE);
            }
#endif // DBG == 1

        }

#if DBG == 1
        else
        {
            // we cannot have a pointer to the link server
            // if we don't have a moniker to it.  If we get
            // to this state, something is hosed.

            AssertSz(0,
                "Pointer to link server without a moniker");
        }
#endif // DBG == 1

        pbc->Release();
    }

errRtn:

    // do some checking here.  If we say we're running, then
    // we should have a valid pUnkDelegate.  Otherwise, it should
    // be NULL.  Note, however, that is *is* possible for us
    // to unbind during this call even if we think we're running
    //
    // This occurs if during the call to IMoniker::IsRunning, we
    // get another call in which does an UnbindSource; thus
    // we'll think we're really running (from IMoniker::IsRunning),
    // but we've really unbound.
    //
    // We'll check for that condition here


    if( fRet == TRUE )
    {
        if( m_pUnkDelegate == NULL )
        {
            fRet = FALSE;
            LEDebugOut((DEB_WARN, "WARNING: Re-entrant Unbind"
                " during IsReallyRunning, should be OK\n"));
        }
    }
#if DBG == 1
    if( fRet == TRUE )
    {
        Assert(m_pUnkDelegate != NULL);
    }
    else
    {
        Assert(m_pUnkDelegate == NULL);
    }
#endif // DBG == 1


    LEDebugOut((DEB_ITRACE, "%p OUT CDefLink::IsReallyRunning"
        "( %lu )\n", this, fRet));

    return fRet;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::SetContainedObject
//
//  Synopsis:   Sets the object as an embedding, not relevant for links
//
//  Effects:
//
//  Arguments:  [fContained]    -- flag to toggle embedding status
//
//  Requires:
//
//  Returns:    HRESULT (NOERROR)
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IRunnableObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
// 		note contained object; links don't care at present
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::SetContainedObject(BOOL fContained)
{
    VDATEHEAP();
    VDATETHREAD(this);

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::LockRunning
//
//  Synopsis:   Lock/Unlock the connection to the server.  Does nothing
//              for links.
//
//  Effects:
//
//  Arguments:  [fLock]                 -- flag to lock/unlock
//              [fLastUnlockCloses]     -- close if its the last unlock
//
//  Requires:
//
//  Returns:    NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IRunnableObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//              Links have different liveness characteristics than embeddings.
//              We do not need to do anything for LockRunning for links.
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::LockRunning(BOOL fLock, BOOL fLastUnlockCloses)
{
    VDATEHEAP();
    VDATETHREAD(this);

    return NOERROR;
}

/*
 *      IMPLEMENTATION of CPersistStgImpl methods
 */

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::GetClassID
//
//  Synopsis:   Retrieves the class id of the default link
//
//  Effects:
//
//  Arguments:  [pClassID]      -- where to put the class ID
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IPersistStorage
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::GetClassID (CLSID *pClassID)
{
    VDATEHEAP();
    VDATETHREAD(this);

    *pClassID = CLSID_StdOleLink;
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::IsDirty
//
//  Synopsis:   Returns TRUE if the linked object has changed
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    NOERROR if dirty
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IPersistStorage
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::IsDirty(void)
{
    HRESULT         hresult;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::IsDirty"
        " ( )\n", this));

    if( (m_flags & DL_DIRTY_LINK) )
    {
        hresult = NOERROR;
    }
    else
    {
        Assert(m_pCOleCache != NULL);
        hresult = m_pCOleCache->IsDirty();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::IsDirty "
        "( %lx )\n", this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::InitNew
//
//  Synopsis:   Initialize a new link object from the given storage
//
//  Effects:
//
//  Arguments:  [pstg]  -- the new storage for the link
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IPersistStorage
//
//  Algorithm:  Delegates to the cache
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized and handle the zombie case
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::InitNew( IStorage *pstg)
{
    HRESULT                 error;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::InitNew "
        "( %p )\n", this, pstg));

    VDATEIFACE(pstg);

    CRefStabilize stabilize(this);

    if( IsZombie() )
    {
        error = CO_E_RELEASED;
    }
    else if (m_pStg == NULL)
    {
        Assert(m_pCOleCache != NULL);
        if ((error = m_pCOleCache->InitNew(pstg)) == NOERROR)
        {
	    m_flags |= DL_DIRTY_LINK;
            (m_pStg = pstg)->AddRef();
        }
    }
    else
    {
        error = CO_E_ALREADYINITIALIZED;
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::InitNew "
        "( %lx )\n", this, error ));

    return error;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::Load
//
//  Synopsis:   Initializes a link from data stored in the storage
//
//  Effects:
//
//  Arguments:  [pstg]  -- the storage with link data
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IPersistStorage
//
//  Algorithm:  Read ole private data and set internal link information.
//              Then delegate to the cache to load presentation data, etc.
//
//  History:    dd-mmm-yy Author    Comment
//              20-Feb-94 KentCe    Buffer internal stream i/o.
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized and handle zombie case
//              19-Nov-93 alexgo    32bit port
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::Load(IStorage *pstg)
{
    HRESULT                 error;
    LPMONIKER               pmk = NULL;
    LPMONIKER               pmkSrcAbs = NULL;
    LPMONIKER               pmkSrcRel = NULL;
    CLSID                   clsid;
    DWORD                   dwOptUpdate;
    LPSTREAM                pstm = NULL;
    DWORD                   dummy;
    ULONG                   cbRead;
    CStmBufRead             StmRead;


    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::CPeristStgImpl::Load "
        "( %p )\n", this, pstg ));

    VDATEIFACE(pstg);

    CRefStabilize stabilize(this);

    // if we're in a zombie state, we don't want to be reloading
    // our object!!

    if( IsZombie() )
    {
        error = CO_E_RELEASED;
        goto logRtn;
    }

    if (m_pStg)
    {
        error = CO_E_ALREADYINITIALIZED;
        goto logRtn;
    }

    //read link data from the storage
    error = ReadOleStg (pstg, &m_dwObjFlags, &dwOptUpdate, NULL, &pmk, &pstm);

    if (error == NOERROR)
    {
        // set the update options.
        SetUpdateOptions (dwOptUpdate);

        // we can get the moniker from container, so no need to
        // remeber this
        if (pmk)
        {
            pmk->Release();
        }

        Assert (pstm != NULL);

        // Read relative source moniker. Write NULL for the time being
        if ((error = ReadMonikerStm (pstm, &pmkSrcRel)) != NOERROR)
        {
            goto errRtn;
        }

        // Read absolute source moniker; stored in link below
        if ((error = ReadMonikerStm (pstm, &pmkSrcAbs)) != NOERROR)
        {
            goto errRtn;
        }

        //
        //  Buffer the read i/o from the stream.
        //
        StmRead.Init(pstm);


        // Read -1 followed by the last class name
        if ((error = ReadM1ClassStmBuf(StmRead, &clsid)) != NOERROR)
        {
            goto errRtn;
        }

        // Read the last display name

        // Right now, this is always an empty string
        LPOLESTR        pstr = NULL;
        if ((error = ReadStringStream (StmRead, &pstr)) != NOERROR)
        {
            goto errRtn;
        }

        if (pstr)
        {
            LEDebugOut((DEB_ERROR, "ERROR!: Link user type "
                "string found, unexpected\n"));
            PubMemFree(pstr);
        }

        if ((error = StmRead.Read(&dummy, sizeof(DWORD)))
            != NOERROR)
        {
            goto errRtn;
        }

        if ((error = StmRead.Read(&(m_ltChangeOfUpdate),
            sizeof(FILETIME))) != NOERROR)
        {
            goto errRtn;
        }

        if ((error = StmRead.Read(&(m_ltKnownUpToDate),
            sizeof(FILETIME))) != NOERROR)
        {
            goto errRtn;
        }

        if ((error = StmRead.Read(&(m_rtUpdate),
            sizeof(FILETIME))) != NOERROR)
        {
            goto errRtn;
        }

        //
        // TRACKLINK
        //
        //  - tell the absolute moniker to convert itself
        //    into a tracking moniker using ITrackingMoniker::
        //    EnableTracking.  (The composite
        //    moniker should pass this on to each of
        //    its contained monikers.)
        //  - if the moniker is already a tracking file moniker
        //    ignore the request.
        //
#ifdef _TRACKLINK_
        EnableTracking(pmkSrcAbs, OT_READTRACKINGINFO);
#endif

        m_pMonikerRel = pmkSrcRel;
        if (pmkSrcRel)
        {
            pmkSrcRel->AddRef();
        }

        m_pMonikerAbs = pmkSrcAbs;
        if (pmkSrcAbs)
        {
            pmkSrcAbs->AddRef();
        }

        m_clsid = clsid;
        // just loaded; thus not dirty

	m_flags &= ~(DL_DIRTY_LINK);

    }
    else if( error == STG_E_FILENOTFOUND)
    {
        // It's OK if the Ole stream doesn't exist.
        error = NOERROR;

    }
    else
    {
        return error;
    }

    // now load cache from pstg
    Assert(m_pCOleCache != NULL);

    if(m_dwObjFlags & OBJFLAGS_CACHEEMPTY) {
        error = m_pCOleCache->Load(pstg, TRUE);
        if(error != NOERROR)
            goto errRtn;
    }
    else {
        error = m_pCOleCache->Load(pstg);
        if(error != NOERROR)
            goto errRtn;
    }
    (m_pStg = pstg)->AddRef();

errRtn:
    StmRead.Release();

    if (pmkSrcAbs)
    {
        pmkSrcAbs->Release();
    }

    if (pmkSrcRel)
    {
        pmkSrcRel->Release();
    }

    if (pstm)
    {
        pstm->Release();
    }

#ifdef REVIEW
    if (error == NOERROR && m_pAppClientSite)
    {
        BindIfRunning();
    }
#endif

logRtn:

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::Load "
        "( %lx )\n", this, error ));

    return error;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::Save
//
//  Synopsis:   Saves the link the given storage
//
//  Effects:
//
//  Arguments:  [pstgSave]      -- the storage to save into
//              [fSameAsLoad]   -- FALSE indicates SaveAs operation
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IPersistStorage
//
//  Algorithm:  Writes private ole data (such as the clsid, monikers,
//              and update times) and the presentations stored in the
//              cache to the given storage
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized
//              19-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::Save( IStorage *pstgSave, BOOL fSameAsLoad)
{
    HRESULT                 error = NOERROR;
    LPSTREAM                pstm = NULL;
    DWORD                   cbWritten;
    CStmBufWrite            StmWrite;
    DWORD                   ObjFlags = 0;

    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::CPeristStgImpl::Save "
        "( %p , %lu )\n", this, pstgSave, fSameAsLoad ));

    VDATEIFACE(pstgSave);

    CRefStabilize stabilize(this);

    // update any cache which has ADVFCACHE_ONSAVE
    UpdateAutoOnSave();

    if(fSameAsLoad && !(m_flags & DL_DIRTY_LINK) && 
       (!!(m_dwObjFlags & OBJFLAGS_CACHEEMPTY)==m_pCOleCache->IsEmpty())) {
        // The storage is not a new one (so we don't need to
        // initialize our private data) and the link is not
        // dirty, so we just need to delegate to the cache
        goto LSaveCache;
    }

    // Obtain cache status
    if(m_pCOleCache->IsEmpty())
        ObjFlags |= OBJFLAGS_CACHEEMPTY;

    // assign object moniker (used by WriteOleStg); we don't save this
    // moniker since WriteOleStg gets it again; we also don't care if
    // this failes as we don't want a failure here to prevent the link
    // from being saved; the assignment might fail if some container has
    // yet to be saved to a file. REIVEW PERF: we could pass this mk to
    // WriteOleStg.  We don't get the moniker for !fSameAsLoad since the
    // relative moniker is not correct for the new stg and it causes the
    // container to do work in a case for which it might not be prepared.

    IMoniker * pMkObjRel;

    if (fSameAsLoad && GetMoniker(
        OLEGETMONIKER_FORCEASSIGN,
        OLEWHICHMK_OBJREL, &pMkObjRel) == NOERROR)
    {
        pMkObjRel->Release();
    }

    if ((error = WriteOleStgEx(pstgSave,(IOleObject *)this, NULL, ObjFlags,
        &pstm)) != NOERROR)
    {
        goto logRtn;
    }

    Assert(pstm != NULL);

    // Write relative source moniker.
    // if it is NULL, try to compute it now.  We may be saving a file for
    // the first time, so the container now has a moniker for the first
    // time.

    if (m_pMonikerRel == NULL || m_pUnkDelegate)
    {
        // if the link is connected, we know that the absolute
        // moniker is correct -- it was updated at bind time if
        // necessary.  If the link container moniker has changed
        // (file/saveas) then we can exploit this opportunity to
        // straighten things out and improve our link tracking
        // since we know which of the two monikers is correct.
        UpdateRelMkFromAbsMk(NULL);
    }

    if ((error = WriteMonikerStm (pstm, m_pMonikerRel))
        != NOERROR)
    {
        goto errRtn;
    }

#ifdef _TRACKLINK_
    EnableTracking(m_pMonikerAbs, OT_ENABLESAVE);
#endif

    // Write absolute source moniker.
    error = WriteMonikerStm (pstm, m_pMonikerAbs);

#ifdef _TRACKLINK_
    EnableTracking(m_pMonikerAbs, OT_DISABLESAVE);
#endif

    if (error != NOERROR)
        goto errRtn;
    //
    //
    //
    StmWrite.Init(pstm);


    // write last class name
    UpdateUserClassID();
    if ((error = WriteM1ClassStmBuf(StmWrite, m_clsid)) != NOERROR)
    {
        goto errRtn;
    }


    // write last display name, should be NULL if the moniker's are
    // non-NULL.  For the time being this is always NULL.
    if ((error = StmWrite.WriteLong(0))
        != NOERROR)
    {
        goto errRtn;
    }


    // write -1 as the end marker, so that if we want to extend
    // the file formats (ex: adding network name) it will be easier.
    if ((error = StmWrite.WriteLong(-1))
        != NOERROR)
    {
        goto errRtn;
    }

    if ((error = StmWrite.Write(&(m_ltChangeOfUpdate),
        sizeof(FILETIME))) != NOERROR)
    {
        goto errRtn;
    }

    if ((error = StmWrite.Write(&(m_ltKnownUpToDate),
        sizeof(FILETIME))) != NOERROR)
    {
        goto errRtn;
    }

    if ((error = StmWrite.Write(&(m_rtUpdate),
        sizeof(FILETIME))) != NOERROR)
    {
        goto errRtn;
    }

    if ((error = StmWrite.Flush()) != NOERROR)
    {
        goto errRtn;
    }

    if (!fSameAsLoad)
    {
        // Copy link tracking info
        static const LPOLESTR lpszLinkTracker = OLESTR("\1OleLink");

        pstgSave->DestroyElement(lpszLinkTracker);

        if (m_pStg)
        {
            // copy link tracking info, if one existed,
            // ignore error
            m_pStg->MoveElementTo(lpszLinkTracker,
                    pstgSave, lpszLinkTracker,
                    STGMOVE_COPY);
        }
    }

LSaveCache:
    // last, save cache
    Assert(m_pCOleCache != NULL);
    error = m_pCOleCache->Save(pstgSave, fSameAsLoad);

errRtn:
    StmWrite.Release();

    if (pstm)
    {
        pstm->Release();
    }

    if (error == NOERROR)
    {
	m_flags |= DL_NO_SCRIBBLE_MODE;
	if( fSameAsLoad )
	{
	    m_flags |= DL_SAME_AS_LOAD;
            m_dwObjFlags |= ObjFlags;
	}
	else
	{
	    m_flags &= ~(DL_SAME_AS_LOAD);
	}
    }

logRtn:

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::Save "
        "( %lx )\n", this, error ));

    return error;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::SaveCompleted
//
//  Synopsis:   Called once the save is completed (for all objects in the
//              container).  Clear the dirty flag and update the storage
//              that we hand onto.
//
//  Effects:
//
//  Arguments:  [pstgNew]       -- the new default storage for the object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IPersistStorage
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//		03-Aug-94 alexgo    stabilized and handle zombie case
//              20-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::SaveCompleted( IStorage *pstgNew)
{
    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::Save"
        "Completed ( %p )\n", this, pstgNew ));

    if (pstgNew)
    {
        VDATEIFACE(pstgNew);
    }

    // don't hang on to the new storage if we're in a zombie state!

    if (pstgNew && !IsZombie() )
    {
        if (m_pStg)
        {
            m_pStg->Release();
        }

        m_pStg = pstgNew;
        pstgNew->AddRef();
    }

    // REVIEW: do we send on save???

    if( (m_flags & DL_SAME_AS_LOAD) || pstgNew)
    {
        if( (m_flags & DL_NO_SCRIBBLE_MODE) )
        {
	    m_flags &= ~(DL_DIRTY_LINK);
        }

	m_flags &= ~(DL_SAME_AS_LOAD);
    }

    // let the cache know that the save is completed, so that it can clear
    // its dirty flag in Save or SaveAs situation, as well as remember the
    // new storage pointer if a new one is  given

    Assert(m_pCOleCache != NULL);
    m_pCOleCache->SaveCompleted(pstgNew);

    m_flags &= ~(DL_NO_SCRIBBLE_MODE);

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::Save"
        "Completed ( %lx )\n", this, NOERROR ));

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::HandsOffStorage
//
//  Synopsis:   Releases all pointers to the storage (useful for low-mem
//              situations)
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    HRESULT  (NOERROR)
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IPersistStorage
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//              20-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::HandsOffStorage(void)
{
    VDATEHEAP();
    VDATETHREAD(this);

    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::HandsOff"
        "Storage ( )\n", this ));

    if (m_pStg)
    {
        m_pStg->Release();
        m_pStg = NULL;
    }

    Assert(m_pCOleCache != NULL);
    m_pCOleCache->HandsOffStorage();

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::HandsOff"
        "Storage ( %lx )\n", this, NOERROR));

    return NOERROR;
}


/*
*
*      IMPLEMENTATION of CAdvSinkImpl methods
*
*/

//
// NOTE: Advise Sink is a nested object of Default Link that is exported
//       for achieving some of its functionality. This introduces some lifetime
//       complications. Can its lifetime be controlled by the server object to
//       which it exported its Advise Sink? Ideally, only its client should 
//       control its lifetime alone, but it should also honor the ref counts
//       placed on it by the server object by entering into a zombie state 
//       to prevent AV's on the incoming calls to the Advise Sink. All needed
//       logic is coded into the new class "CRefExportCount" which manages
//       the ref and export counts in a thread safe manner and invokes 
//       appropriate methods during the object's lifetime. Any server objects 
//       that export nested objects to other server objects should derive from
//       "CRefExportCount" class and call its methods to manage their lifetime
//       as exemplified in this Default Link implementation.
//
//                Gopalk  Jan 28, 97
//

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::CAdvSinkImpl::QueryInterface
//
//  Synopsis:   Only supports IUnknown and IAdviseSink
//
//  Arguments:  [iid]     -- Interface requested 
//              [ppvObj]  -- pointer to hold returned interface 
//
//  Returns:    HRESULT
//
//  History:    dd-mmm-yy Author    Comment
//              10-Jan-96 Gopalk    Rewritten
//--------------------------------------------------------------------------

STDMETHODIMP CDefLink::CAdvSinkImpl::QueryInterface(REFIID iid, void **ppv)
{
    LEDebugOut((DEB_TRACE,"%p _IN CDefLink::CAdvSinkImpl::QueryInterface()\n",
                this));

    // Validation check
    VDATEHEAP();
    
    // Local variables
    HRESULT hresult = NOERROR;

    if(IsValidPtrOut(ppv, sizeof(void *))) {
        if(IsEqualIID(iid, IID_IUnknown)) {
            *ppv = (void *)(IUnknown *) this;
        }
        else if(IsEqualIID(iid, IID_IAdviseSink)) {
            *ppv = (void *)(IAdviseSink *) this;
        }
        else {
            *ppv = NULL;
            hresult = E_NOINTERFACE;
        }
    }
    else
        hresult = E_INVALIDARG;

    if(hresult == NOERROR)
        ((IUnknown *) *ppv)->AddRef();

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::CAdvSinkImpl::QueryInterface(%lx)\n",
                this, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::CAdvSinkImpl::AddRef
//
//  Synopsis:   Increments export count
//
//  Returns:    ULONG; New export count
//
//  History:    dd-mmm-yy Author    Comment
//              10-Jan-96 Gopalk    Rewritten
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CDefLink::CAdvSinkImpl::AddRef( void )
{
    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::CAdvSinkImpl::AddRef()\n",
                this));

    // Validation check
    VDATEHEAP();

    // Local variables
    CDefLink *pDefLink = GETPPARENT(this, CDefLink, m_AdviseSink);
    ULONG cExportCount;

    // Increment export count
    cExportCount = pDefLink->IncrementExportCount();

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::CAdvSinkImpl::AddRef(%ld)\n",
                this, cExportCount));

    return cExportCount;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::CAdvSinkImpl::Release
//
//  Synopsis:   Decerement export count and potentially destroy the Link
//
//  Returns:    ULONG; New export count
//
//  History:    dd-mmm-yy Author    Comment
//              10-Jan-96 Gopalk    Rewritten
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CDefLink::CAdvSinkImpl::Release ( void )
{
    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::CAdvSinkImpl::Release()\n",
                this));
    
    // Validation check
    VDATEHEAP();

    // Local variables
    CDefLink *pDefLink = GETPPARENT(this, CDefLink, m_AdviseSink);
    ULONG cExportCount;

    // Decrement export count.
    cExportCount = pDefLink->DecrementExportCount();

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::CAdvSinkImpl::Release(%ld)\n",
                this, cExportCount));

    return cExportCount;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::CAdvSinkImpl::OnDataChange
//
//  Synopsis:   Updates time of change
//
//  Arguments:  [pFormatetc]  -- Data format that changed
//              [pStgmed]     -- New data
//
//  Returns:    void
//
//  History:    dd-mmm-yy   Author    Comment
//              28-Jan-96   Gopalk    Rewritten
//--------------------------------------------------------------------------

STDMETHODIMP_(void) CDefLink::CAdvSinkImpl::OnDataChange(FORMATETC *pFormatetc, 
                                                         STGMEDIUM *pStgmed)
{
    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::CAdvSinkImpl::OnDataChange(%p, %p)\n",
                this, pFormatetc, pStgmed));

    // Validation checks
    VDATEHEAP();

    // Local variable
    CDefLink *pDefLink = GETPPARENT(this, CDefLink, m_AdviseSink);

    // Assert that the wild card advise prompted this notification
    Win4Assert(pFormatetc->cfFormat == NULL && pFormatetc->ptd == NULL &&
               pFormatetc->dwAspect == -1 && pFormatetc->tymed == -1);
    Win4Assert(pStgmed->tymed == TYMED_NULL);

    // Update time of change for automatic links
    if(!pDefLink->IsZombie() && pDefLink->m_dwUpdateOpt==OLEUPDATE_ALWAYS) {
        // Stabilize
        CRefStabilize stabilize(pDefLink);
        
        pDefLink->SetUpdateTimes();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::CAdvSinkImpl::OnDataChange()\n",
                this));
    return;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::CAdvSinkImpl::OnViewChange
//
//  Synopsis:   Called when the view changes; should never be called for
//              links
//
//  Effects:
//
//  Arguments:  [aspects]       -- drawing aspect
//              [lindex]        -- unused
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IAdviseSink
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		21-Nov-94 alexgo    memory optimization
//              20-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(void) CDefLink::CAdvSinkImpl::OnViewChange
    (DWORD aspects, LONG lindex)
{
    VDATEHEAP();

    Assert(FALSE);          // never received
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::CAdvSinkImpl::OnRename
//
//  Synopsis:   Updates internal monikers to the source object. Turns around
//              and informs its advise sinks
//
//  Arguments:  [pmk] -- New moniker name
//
//  Returns:    void
//
//  History:    dd-mmm-yy   Author    Comment
//              28-Jan-96   Gopalk    Rewritten
//--------------------------------------------------------------------------

STDMETHODIMP_(void) CDefLink::CAdvSinkImpl::OnRename(IMoniker *pmk)
{
    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::CAdvSinkImpl::OnRename(%p)\n",
                this, pmk));

    // Validation check
    VDATEHEAP();

    // Local variable
    CDefLink *pDefLink = GETPPARENT(this, CDefLink, m_AdviseSink);

    if(!pDefLink->IsZombie()) {
        CRefStabilize stabilize(pDefLink);

        // Release old absolute moniker
        if(pDefLink->m_pMonikerAbs)
            pDefLink->m_pMonikerAbs->Release();
        
        // Remember the new moniker
        pDefLink->m_pMonikerAbs = pmk;
        if(pmk) {
            // AddRef the new moniker
            pmk->AddRef();

            //
            //  Enable tracking on the new moniker
            //  (this will get a new shellink if neccessary.)
            //
#ifdef _TRACKLINK_
            pDefLink->EnableTracking(pmk, OT_READTRACKINGINFO);
#endif
        }

        // Update relative moniker from the new absolute moniker
        pDefLink->UpdateRelMkFromAbsMk(NULL);

        // Name of the link source changed. This has no bearing on the
        // name of the link object itself.
        if(pDefLink->m_pCOAHolder)
            pDefLink->m_pCOAHolder->SendOnLinkSrcChange(pmk);
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::CAdvSinkImpl::OnRename()\n",
                this));
    return;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::CAdvSinkImpl::OnSave
//
//  Synopsis:   Updates cache and turns around and informs its advise sinks
//
//  Arguments:  None
//
//  Returns:    void
//
//  History:    dd-mmm-yy   Author    Comment
//              28-Jan-96   Gopalk    Rewritten
//--------------------------------------------------------------------------

STDMETHODIMP_(void) CDefLink::CAdvSinkImpl::OnSave()
{
    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::CAdvSinkImpl::OnSave()\n",
                this));
    
    // Validation check
    VDATEHEAP();

    // Local variable
    CDefLink *pDefLink = GETPPARENT(this, CDefLink, m_AdviseSink);

    if(!pDefLink->IsZombie()) {
        // Stabilize
        CRefStabilize stabilize(pDefLink);

        // Turn around and send notification
        if(pDefLink->m_pCOAHolder)
            pDefLink->m_pCOAHolder->SendOnSave();

        // Update presentations cached with ADVFCACHE_ONSAVE
        pDefLink->UpdateAutoOnSave();

        // Update clsid
        pDefLink->UpdateUserClassID();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::CAdvSinkImpl::OnSave()\n",
                this));
    return;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::CAdvSinkImpl::OnClose
//
//  Synopsis:   Updates time of change and turns around and informs its 
//              advise sinks.
//
//  Arguments:  void
//
//  Returns:    void
//
//  History:    dd-mmm-yy   Author    Comment
//              28-Jan-96   Gopalk    Rewritten
//--------------------------------------------------------------------------

STDMETHODIMP_(void) CDefLink::CAdvSinkImpl::OnClose(void)
{
    LEDebugOut((DEB_TRACE, "%p _IN CDefLink::CAdvSinkImpl::OnClose()\n",
                this));

    // Validation check
    VDATEHEAP();

    // Local variable
    CDefLink *pDefLink = GETPPARENT(this, CDefLink, m_AdviseSink);

    if(!pDefLink->IsZombie()) {
        // Stabilize
        CRefStabilize stabilize(pDefLink);

        // Update time of change
        if(pDefLink->m_dwUpdateOpt == OLEUPDATE_ALWAYS )
            pDefLink->SetUpdateTimes();

        // Turn around and send notification
        if(pDefLink->m_pCOAHolder)
            pDefLink->m_pCOAHolder->SendOnClose();

        // To be safe, unbind source
        pDefLink->UnbindSource();
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefLink::CAdvSinkImpl::OnClose()\n",
                this));
    return;
}


/*
 *      IMPLEMENTATION of  OleItemContainer methods
 */



//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::GetOleItemContainerDelegate  (private)
//
//  Synopsis:   gets the IOleItemContainer from the interface
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    IOleItemContainer *
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//
//  Notes:
//              This function may return misleading information if the
//              server has died (i.e., you'll return a pointer to a cached
//              interface proxy).  It is the responsibility of the caller
//              to handler server crashes.
//
//--------------------------------------------------------------------------

INTERNAL_(IOleItemContainer *) CDefLink::GetOleItemContainerDelegate(void)
{
    IOleItemContainer *pOleItemContainerDelegate = NULL;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CDefLink::GetOleItemContainerDelegate "
        "( )\n", this ));

    // if we're zombied, then we don't want to QI for a new interface!!

    if(!IsZombie())
    {
        DuCacheDelegate(&(m_pUnkDelegate),
            IID_IOleItemContainer, (LPLPVOID)&m_pOleItemContainerDelegate, NULL);

        pOleItemContainerDelegate = m_pOleItemContainerDelegate;

#if DBG == 1
        if( m_pOleItemContainerDelegate )
        {
            Assert(m_pUnkDelegate);
        }
#endif  // DBG == 1
    }
    else
    {
        m_pOleItemContainerDelegate = NULL;
    }


    LEDebugOut((DEB_ITRACE, "%p OUT CDefLink::GetOleItemContainerDelegate "
        "( %p )\n", this, pOleItemContainerDelegate));

    return m_pOleItemContainerDelegate;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::ReleaseOleItemContainerDelegate (private)
//
//  Synopsis:   Releases the OleItemContainer pointer to the server
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//
//  Notes:
//
//--------------------------------------------------------------------------

INTERNAL_(void) CDefLink::ReleaseOleItemContainerDelegate(void)
{
    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN CDefLink::ReleaseOleItemContainerDelegate "
        "( )\n", this ));

    if (m_pOleItemContainerDelegate)
    {
        SafeReleaseAndNULL((IUnknown **)&m_pOleItemContainerDelegate);
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CDefLink::ReleaseOleItemContainerDelegate "
        "( )\n", this ));
}


//+-------------------------------------------------------------------------
//
//  Member:     CDefLink::Dump, public (_DEBUG only)
//
//  Synopsis:   return a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [ppszDump]      - an out pointer to a null terminated character array
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   [ppszDump]  - argument
//
//  Derivation:
//
//  Algorithm:  use dbgstream to create a string containing information on the
//              content of data structures
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

HRESULT CDefLink::Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    char *pszCSafeRefCount;
    char *pszCThreadCheck;
    char *pszCLSID;
    char *pszCOleCache;
    char *pszCOAHolder;
    char *pszDAC;
    char *pszFILETIME;
    char *pszMonikerDisplayName;
    dbgstream dstrPrefix;
    dbgstream dstrDump(5000);

    // determine prefix of newlines
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << this << " _VB ";
    }

    // determine indentation prefix for all newlines
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    pszCThreadCheck = DumpCThreadCheck((CThreadCheck *)this, ulFlag, nIndentLevel + 1);
    dstrDump << pszPrefix << "CThreadCheck:" << endl;
    dstrDump << pszCThreadCheck;
    CoTaskMemFree(pszCThreadCheck);

    // only vtable pointers (plus we don't get the right address in debugger extensions)
    // dstrDump << pszPrefix << "&IUnknown                 = " << &m_Unknown       << endl;
    // dstrDump << pszPrefix << "&IAdviseSink              = " << &m_AdviseSink    << endl;

    dstrDump << pszPrefix << "Link flags                = ";
    if (m_flags & DL_SAME_AS_LOAD)
    {
        dstrDump << "DL_SAME_AS_LOAD ";
    }
    if (m_flags & DL_NO_SCRIBBLE_MODE)
    {
        dstrDump << "DL_NO_SCRIBBLE_MODE ";
    }
    if (m_flags & DL_DIRTY_LINK)
    {
        dstrDump << "DL_DIRTY_LINK ";
    }
    if (m_flags & DL_LOCKED_CONTAINER)
    {
        dstrDump << "DL_LOCKED_CONTAINER ";
    }
    // if none of the flags are set...
    if ( !( (m_flags & DL_SAME_AS_LOAD)     |
            (m_flags & DL_LOCKED_CONTAINER) |
            (m_flags & DL_NO_SCRIBBLE_MODE) |
            (m_flags & DL_DIRTY_LINK)))
    {
        dstrDump << "No FLAGS SET!";
    }
    dstrDump << "(" << LongToPtr(m_flags) << ")" << endl;

    dstrDump << pszPrefix << "pIOleObject Delegate      = " << m_pOleDelegate   << endl;

    dstrDump << pszPrefix << "pIDataObject Delegate     = " << m_pDataDelegate  << endl;

    dstrDump << pszPrefix << "pIRunnableObject Delegate = " << m_pRODelegate    << endl;

    dstrDump << pszPrefix << "No. of Refs. on Link      = " << m_cRefsOnLink    << endl;

    dstrDump << pszPrefix << "pIUnknown pUnkOuter       = ";
    if (m_flags & DL_AGGREGATED)
    {
        dstrDump << "AGGREGATED (" << m_pUnkOuter << ")" << endl;
    }
    else
    {
        dstrDump << "NO AGGREGATION (" << m_pUnkOuter << ")" << endl;
    }

    dstrDump << pszPrefix << "pIMoniker Absolute        = " << m_pMonikerAbs    << endl;

    if (m_pMonikerAbs != NULL)
    {
        pszMonikerDisplayName = DumpMonikerDisplayName(m_pMonikerAbs);
        dstrDump << pszPrefix << "pIMoniker Absolute        = ";
        dstrDump << pszMonikerDisplayName;
        dstrDump << "( " << m_pMonikerAbs << " )" << endl;
        CoTaskMemFree(pszMonikerDisplayName);
    }
    else
    {
    dstrDump << pszPrefix << "pIMoniker Absolute        = NULL or unable to resolve" << endl;
    }

    if (m_pMonikerRel != NULL)
    {
        pszMonikerDisplayName = DumpMonikerDisplayName(m_pMonikerRel);
        dstrDump << pszPrefix << "pIMoniker Relative        = ";
        dstrDump << pszMonikerDisplayName;
        dstrDump << "( " << m_pMonikerRel << " )" << endl;
        CoTaskMemFree(pszMonikerDisplayName);
    }
    else
    {
    dstrDump << pszPrefix << "pIMoniker Absolute        = NULL or unable to resolve" << endl;
    }

    dstrDump << pszPrefix << "pIUnknown Delegate        = " << m_pUnkDelegate   << endl;

    dstrDump << pszPrefix << "OLEUPDATE flags           = ";
    if (m_dwUpdateOpt & OLEUPDATE_ALWAYS)
    {
        dstrDump << "OLEUPDATE_ALWAYS ";
    }
    else if (m_dwUpdateOpt & OLEUPDATE_ONCALL)
    {
        dstrDump << "OLEUPDATE_ONCALL ";
    }
    else
    {
        dstrDump << "No FLAGS SET!";
    }
    dstrDump << "(" << LongToPtr(m_flags) << ")" << endl;

    pszCLSID = DumpCLSID(m_clsid);
    dstrDump << pszPrefix << "Last known CLSID of link  = " << pszCLSID         << endl;
    CoTaskMemFree(pszCLSID);

    dstrDump << pszPrefix << "pIStorage                 = " << m_pStg           << endl;

    if (m_pCOleCache != NULL)
    {
//        pszCOleCache = DumpCOleCache(m_pCOleCache, ulFlag, nIndentLevel + 1);
        dstrDump << pszPrefix << "COleCache: " << endl;
//        dstrDump << pszCOleCache;
//        CoTaskMemFree(pszCOleCache);
    }
    else
    {
    dstrDump << pszPrefix << "pCOleCache                = " << m_pCOleCache     << endl;
    }

    if (m_pCOAHolder != NULL)
    {
        pszCOAHolder = DumpCOAHolder(m_pCOAHolder, ulFlag, nIndentLevel + 1);
        dstrDump << pszPrefix << "COAHolder: " << endl;
        dstrDump << pszCOAHolder;
        CoTaskMemFree(pszCOAHolder);
    }
    else
    {
    dstrDump << pszPrefix << "pCOAHolder                = " << m_pCOAHolder     << endl;
    }

    dstrDump << pszPrefix << "OLE Connection Advise ID  = " << m_dwConnOle      << endl;

    if (m_pDataAdvCache != NULL)
    {
        pszDAC = DumpCDataAdviseCache(m_pDataAdvCache, ulFlag, nIndentLevel + 1);
        dstrDump << pszPrefix << "CDataAdviseCache: " << endl;
        dstrDump << pszDAC;
        CoTaskMemFree(pszDAC);
    }
    else
    {
    dstrDump << pszPrefix << "pCDataAdviseCache         = " << m_pDataAdvCache  << endl;
    }

    dstrDump << pszPrefix << "pIOleClientSite           = " << m_pAppClientSite << endl;

    dstrDump << pszPrefix << "Connection for time       = " << m_dwConnTime     << endl;

    pszFILETIME = DumpFILETIME(&m_ltChangeOfUpdate);
    dstrDump << pszPrefix << "Change of update filetime = " << pszFILETIME      << endl;
    CoTaskMemFree(pszFILETIME);

    pszFILETIME = DumpFILETIME(&m_ltKnownUpToDate);
    dstrDump << pszPrefix << "Known up to date filetime = " << pszFILETIME      << endl;
    CoTaskMemFree(pszFILETIME);

    pszFILETIME = DumpFILETIME(&m_rtUpdate);
    dstrDump << pszPrefix << "Update filetime           = " << pszFILETIME      << endl;
    CoTaskMemFree(pszFILETIME);

    // cleanup and provide pointer to character array
    *ppszDump = dstrDump.str();

    if (*ppszDump == NULL)
    {
        *ppszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return NOERROR;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCDefLink, public (_DEBUG only)
//
//  Synopsis:   calls the CDefLink::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pDL]           - pointer to CDefLink
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCDefLink(CDefLink *pDL, ULONG ulFlag, int nIndentLevel)
{
    HRESULT hresult;
    char *pszDump;

    if (pDL == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    hresult = pDL->Dump(&pszDump, ulFlag, nIndentLevel);

    if (hresult != NOERROR)
    {
        CoTaskMemFree(pszDump);

        return DumpHRESULT(hresult);
    }

    return pszDump;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\stdimpl\emf.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       emf.cpp
//
//  Contents:   Implentation of the enhanced metafile picture object
//
//  Classes:    CEMfObject
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  added Dump method to EMfObject
//                                  added DumpEMfObject API
//                                  initialize m_pfnContinue in constructor
//              12-May-94 DavePl    Created
//
//--------------------------------------------------------------------------

#include <le2int.h>
#include <limits.h>
#include "emf.h"

#ifdef _DEBUG
#include <dbgdump.h>
#endif // _DEBUG

ASSERTDATA

//+-------------------------------------------------------------------------
//
//  Function:   CEMfObject::M_HPRES
//
//  Synopsis:   Returns handle to EMF, possibly after demand-loading it
//
//  History:    dd-mmm-yy Author    Comment
//              12-May-94 DavePl    Created
//
//  Notes:
//              The following macro allows for demand loading of the
//              presentation bits for enhanced metafiles.  If the handle to
//              the EMF (m_hPres) is already set, it is returned.  If it is
//              not, LoadHPRES() is called which loads the presentation and
//              returns the handle to it.
//
//--------------------------------------------------------------------------

inline HENHMETAFILE CEMfObject::M_HPRES(void)
{
	return (m_hPres ? m_hPres : LoadHPRES());
}

//+-------------------------------------------------------------------------
//
//  Member:     CEMfObject::CEMfObject
//
//  Synopsis:   constructor for the enhanced metafile object
//
//  Effects:
//
//  Arguments:  [pCacheNode]    -- pointer to the cache node for this object
//              [dwAspect]      -- drawing aspect for the object
//
//  History:    dd-mmm-yy Author    Comment
//              13-Feb-95 t-ScottH  initialize m_pfnContinue
//              12-May-94 DavePl    Created
//
//  Notes:
//
//--------------------------------------------------------------------------

CEMfObject::CEMfObject(LPCACHENODE pCacheNode, DWORD dwAspect)
{
	VDATEHEAP();

	m_ulRefs        = 1;
	m_hPres         = NULL;
	m_dwSize        = 0;
	m_dwAspect      = dwAspect;
	m_pCacheNode    = pCacheNode;
	m_dwContinue    = 0;
        m_pfnContinue   = NULL;
	m_lWidth        = 0;
	m_lHeight       = 0;
	m_fMetaDC       = FALSE;
	m_nRecord       = 0;
	m_error         = NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEMfObject::~CEMfObject
//
//  Synopsis:   Destroys an enahnced metafile presentation object
//
//  History:    dd-mmm-yy Author    Comment
//              12-May-94 DavePl    Created
//
//--------------------------------------------------------------------------

CEMfObject::~CEMfObject (void)
{
	VDATEHEAP();

	CEMfObject::DiscardHPRES();
}

//+-------------------------------------------------------------------------
//
//  Member:     CEMfObject::QueryInterface
//
//  Synopsis:   returns supported interfaces
//
//  Arguments:  [iid]           -- the requested interface ID
//              [ppvObj]        -- where to put the interface pointer
//
//  Requires:
//
//  Returns:    NOERROR, E_NOINTERFACE
//
//  Derivation: IOlePresObj
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              12-May-94 DavePl    Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CEMfObject::QueryInterface (REFIID iid, void ** ppvObj)
{
	VDATEHEAP();

	if (IsEqualIID(iid, IID_IUnknown) || IsEqualIID(iid, IID_IOlePresObj))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	else
	{
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}
}

//+-------------------------------------------------------------------------
//
//  Member:     CEMfObject::AddRef
//
//  Synopsis:   Increments the reference count
//
//  Returns:    ULONG  -- the new reference count
//
//  Derivation: IOlePresObj
//
//  History:    dd-mmm-yy Author    Comment
//              12-May-94 DavePl    Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEMfObject::AddRef(void)
{
	VDATEHEAP();
	
	return (ULONG) InterlockedIncrement((LONG *) &m_ulRefs);
}
			
//+-------------------------------------------------------------------------
//
//  Member:     CEMfObject::Release
//
//  Synopsis:   decrements the reference count
//
//  Effects:    deletes the object once the ref count goes to zero
//
//  Returns:    ULONG -- the new reference count
//
//  Derivation: IOlePresObj
//
//  History:    dd-mmm-yy Author    Comment
//              12-May-94 DavePl    Created
//
//  Notes:      Not multi-threaded safe
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEMfObject::Release(void)
{
	VDATEHEAP();

	ULONG cTmp = (ULONG) InterlockedDecrement((LONG *) &m_ulRefs);
	if (0 == cTmp)
	{
		delete this;
	}

	return cTmp;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEMfObject::GetData
//
//  Synopsis:   Retrieves data in the specified format from the object
//
//  Arguments:  [pformatetcIn]  -- the requested data format
//              [pmedium]       -- where to put the data
//
//  Returns:    HRESULT
//
//  Derivation: IOlePresObject
//
//  History:    dd-mmm-yy Author    Comment
//              12-May-94 DavePl    Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CEMfObject::GetData(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
	VDATEHEAP();

	HRESULT hr = NOERROR;
	pmedium->tymed = (DWORD) TYMED_NULL;
	pmedium->pUnkForRelease = NULL;

	// We can only support enhanced metafile TYMED
	if (!(pformatetcIn->tymed & (DWORD) TYMED_ENHMF))
	{
		hr = DV_E_TYMED;
	}
	// We can only support enhanced metafile clipformat
	else if (pformatetcIn->cfFormat != CF_ENHMETAFILE)
	{
		hr = DV_E_CLIPFORMAT;
	}

	// Check to ensure we are not blank
	else if (IsBlank())
	{
		hr = OLE_E_BLANK;
	}
	
	// Go ahead and try to get the data
	
	else
	{
		HENHMETAFILE hEMF = M_HPRES();
		if (NULL == hEMF)
		{
			hr = OLE_E_BLANK;
		}

		else if (NULL == (pmedium->hEnhMetaFile = CopyEnhMetaFile(hEMF, NULL)))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
		else
		{
			pmedium->tymed = (DWORD) TYMED_ENHMF;
		}
	}
		
	return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEMfObject::GetDataHere
//
//  Synopsis:   Retrieves data of the specified format into the specified
//              medium
//
//  Arguments:  [pformatetcIn]  -- the requested data format
//              [pmedium]       -- where to put the data
//
//  Derivation: IOlePresObj
//
//  Algorithm:  Does error checking and then copies the EMF into a
//              stream.
//
//  History:    dd-mmm-yy Author    Comment
//              14-May-94 DavePl    Created
//
//  Notes:      Although I'm only handling TYMED_ISTREAM here, since that's
//              all standard metafiles provide, there's no compelling reason
//              we couldn't support other formats.  In fact, supporting
//              raw bits on TYMED_HGLOBAL might be a nice addition, and
//              TYMED_MFPICT would make for an easy way to do enhanced to
//              standard conversions.  NTIssue #2802.
//
//
//               _______
//              | DWORD |       One DWORD indicating the size of the header
//              |-------|
//              |       |
//              |  HDR  |       The ENHMETAHEADER structure
//              |       |
//              |-------|
//              |       |
//              | DATA  |       Raw EMF bits
//              |_______|
//
//--------------------------------------------------------------------------

STDMETHODIMP CEMfObject::GetDataHere
			   (LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
	VDATEHEAP();

	HRESULT hr = NOERROR;
	
	// We can only handle EMF format
	if (pformatetcIn->cfFormat != CF_ENHMETAFILE)
	{
		hr = DV_E_CLIPFORMAT;
	}
	// We can only support returns to ISTREAM
	else if (pmedium->tymed != (DWORD) TYMED_ISTREAM)
	{
		hr = DV_E_TYMED;
	}
	// The stream ptr must be valid
	else if (pmedium->pstm == NULL)
	{
		hr = E_INVALIDARG;
	}
	// The presentation must not be blank
	else if (IsBlank())
	{
		hr = OLE_E_BLANK;
	}
	else
	{
		// Get the metaheader size
		
		HENHMETAFILE hEMF = M_HPRES();
		DWORD dwMetaHdrSize = GetEnhMetaFileHeader(hEMF, 0, NULL);
		if (dwMetaHdrSize == 0)
		{
			return HRESULT_FROM_WIN32(GetLastError());
		}

		// Allocate the meta header

		void * pvHeader = PrivMemAlloc(dwMetaHdrSize);
		if (NULL == pvHeader)
		{
			return E_OUTOFMEMORY;
		}

		// Retrieve the ENHMETAHEADER

		if (0 == GetEnhMetaFileHeader(hEMF, dwMetaHdrSize, (ENHMETAHEADER *) pvHeader))
		{
			PrivMemFree(pvHeader);
			return HRESULT_FROM_WIN32(GetLastError());
		}
		
		// Write the byte count to disk.

		hr = StWrite(pmedium->pstm, &dwMetaHdrSize, sizeof(DWORD));
		if (FAILED(hr))
		{
			return hr;
		}

		// Write the enhmetaheader to disk
		
		hr = StWrite(pmedium->pstm, pvHeader, dwMetaHdrSize);
		
		PrivMemFree(pvHeader);
		
		if (FAILED(hr))
		{
			return hr;
		}
									
		DWORD dwSize = GetEnhMetaFileBits(hEMF, 0, NULL);
		if (0 == dwSize)
		{
			return HRESULT_FROM_WIN32(GetLastError());
		}
		
		// Write the EMF bits to the stream

		hr = UtHEMFToEMFStm(hEMF,
				    m_dwSize,
				    pmedium->pstm,
				    WRITE_AS_EMF);
	
	}
	return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CEMfObject::SetDataWDO
//
//  Synopsis:   Stores an ehanced metafile in this object
//
//  Effects:
//
//  Arguments:  [pformatetc]    -- format of the data coming in
//              [pmedium]       -- the new metafile (data)
//              [fRelease]      -- if true, then we'll release the [pmedium]
//		[IDataObject]	-- unused for EMF objects
//
//  Derivation: IOlePresObj
//
//  History:    dd-mmm-yy Author    Comment
//              14-May-94 Davepl    Created
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CEMfObject::SetDataWDO
	(LPFORMATETC pformatetc, STGMEDIUM * pmedium, BOOL fRelease, IDataObject * )
{
	VDATEHEAP();

	HRESULT         hr;
	BOOL            fTakeData = FALSE;
	
	// If someone is trying to SetData on our EMF object with a standard
	// metafile, we must convert it to EMF format
	
	if (pformatetc->cfFormat == CF_METAFILEPICT)
	{
		// If its a standard metafile, it must be TYMED_MFPICT
		if (pmedium->tymed != (DWORD) TYMED_MFPICT)
		{
			return DV_E_TYMED;
		}

		// We need to know the size of the metafile in bytes,
		// so we have to lock the structure and grab the handle
		// for a call to GetMetaFileBitsEx

		METAFILEPICT * pMF = (METAFILEPICT *) GlobalLock(pmedium->hMetaFilePict);
		if (NULL == pMF)
		{
			return E_OUTOFMEMORY;
		}

		// Determine the no. of bytes needed to hold the
		// metafile

		DWORD dwSize = GetMetaFileBitsEx(pMF->hMF, NULL, 0);
		if (0 == dwSize)
		{
			GlobalUnlock(pmedium->hMetaFilePict);
			return E_FAIL;
		}

		// Allocate space for the metafile bits

		void *pvBuffer = PrivMemAlloc(dwSize);
		if (NULL == pvBuffer)
		{
			GlobalUnlock(pmedium->hMetaFilePict);
			return E_OUTOFMEMORY;
		}
		
		// Retrieve the bits to our buffer

		if (0 == GetMetaFileBitsEx(pMF->hMF, dwSize, pvBuffer))
		{
			GlobalUnlock(pmedium->hMetaFilePict);
			PrivMemFree(pvBuffer);
			return E_FAIL;
		}
		
		HENHMETAFILE hEMF = SetWinMetaFileBits(dwSize,
			(const BYTE *) pvBuffer, NULL, pMF);
		if (NULL == hEMF)
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			GlobalUnlock(pmedium->hMetaFilePict);
			PrivMemFree(pvBuffer);
			return hr;
		}

		GlobalUnlock(pmedium->hMetaFilePict);
		PrivMemFree(pvBuffer);

		// Update the cache node.  To avoid a copy operation, let the cache
		// node keep our EMF.  It will take the data even in the event of
		// an error

		hr = ChangeData (hEMF, TRUE /* fTakeData */ );

		if (fRelease)
		{
			ReleaseStgMedium(pmedium);
		}
	
		return hr;
	}
							
		
	
	// Other than standard metafile ,we can only accept enhanced metafile format

	if (pformatetc->cfFormat != CF_ENHMETAFILE)
	{
		return DV_E_CLIPFORMAT;
	}
	
	// The medium must be enhanced metafile
	if (pmedium->tymed != (DWORD) TYMED_ENHMF)
	{
		return DV_E_TYMED;
	}

	// If no controlling unkown, and the release flag is set,
	// it is up to us to take control of the data

	if ((pmedium->pUnkForRelease == NULL) && fRelease)
	{
		fTakeData = TRUE;
	}
	
	// ChangeData will keep the data if fRelease is TRUE, else it copies

	hr = ChangeData (pmedium->hEnhMetaFile, fTakeData);

	// If we've taken the data, clear the TYMED
	if (fTakeData)
	{
		pmedium->tymed = (DWORD) TYMED_NULL;
		pmedium->hEnhMetaFile = NULL;
	}

	// If we are supposed to release the data, do it now

	else if (fRelease)
	{
		ReleaseStgMedium(pmedium);
	}
	
	return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CEMfObject::ChangeData (internal)
//
//  Synopsis:   Swaps the stored enhanced metafile presentation into the
//              cache node
//
//  Arguments:  [hEMF]          -- the new enhanced metafile
//              [fTakeData]     -- if TRUE, then delete [hEMF]
//
//  History:    dd-mmm-yy Author    Comment
//              14-May-94 DavePl    Created
//
//  Notes:      If the routine fails then the object will be left with it's
//              old data. We are supposed to delete the incoming EMF when
//              fTakeData is set, even in the event of an error.
//
//--------------------------------------------------------------------------

INTERNAL CEMfObject::ChangeData (HENHMETAFILE hEMF, BOOL fTakeData)
{
	VDATEHEAP();

	HENHMETAFILE            hNewEMF;
	DWORD                   dwSize;
	HRESULT                 hr = NOERROR;

	// If we're not supposed to delete the metafile when we're
	// done, we need to make a copy.  Otherwise, we can just
	// use the handle that came in.

	if (!fTakeData)
	{
		hNewEMF = CopyEnhMetaFile(hEMF, NULL);
		if (NULL == hNewEMF)
		{
			return HRESULT_FROM_WIN32(GetLastError());
			
		}
	}
	else
	{
		hNewEMF = hEMF;
	}
	
	// We get the size of the EMF by calling GetEnhMetaFileBits with
	// a NULL buffer
								
	dwSize =  GetEnhMetaFileBits(hNewEMF, 0, NULL);
	if (0 == dwSize)
	{
		hr = OLE_E_BLANK;
	}
	else
	{
		// We need the dimensions of the metafile, so
		// we have to get the header.

		ENHMETAHEADER emfHeader;
		UINT result = GetEnhMetaFileHeader(hNewEMF,
						   sizeof(emfHeader),
						   &emfHeader);
		if (0 == result)
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
		else
		{
			// If there already is an EMF presentation, kill it
			// so we can replace it

			DiscardHPRES();
				
			// Set up our new EMF as the presentation
		
			m_hPres         = hNewEMF;
			m_dwSize        = dwSize;

			m_lWidth        = emfHeader.rclFrame.right -
					  emfHeader.rclFrame.left;
			m_lHeight       = emfHeader.rclFrame.bottom -
					  emfHeader.rclFrame.top;

                        // EMF extents are returned in physical himets,
                        // but all of the other formats are in logical
                        // himets, so we need to convert.

                        LONG  HorzSize,
                              HorzRes,
                              VertSize,
                              VertRes,
                              LogXPels,
                              LogYPels;

                        HDC hdcTmp = GetDC(NULL);
                        if (hdcTmp)
                        {
                            const LONG HIMET_PER_MM = 100;
                            const LONG HIMET_PER_LINCH = 2540;

                            HorzSize = GetDeviceCaps(hdcTmp, HORZSIZE);
                            HorzRes  = GetDeviceCaps(hdcTmp, HORZRES);
                            VertSize = GetDeviceCaps(hdcTmp, VERTSIZE);
                            VertRes  = GetDeviceCaps(hdcTmp, VERTRES);
                            LogXPels = GetDeviceCaps(hdcTmp, LOGPIXELSX);
                            LogYPels = GetDeviceCaps(hdcTmp, LOGPIXELSY);

                            LEVERIFY( ReleaseDC(NULL, hdcTmp) );

                            // The GDI cannot fail the above calls, but
                            // it's a possibility that some broken driver
                            // returns a zero.  Unlikely, but a division
                            // by zero is severe, so check for it...

                            if ( !HorzSize || !HorzRes  || !VertSize ||
                                 !VertRes  || !LogXPels || !LogYPels)
                            {
                                Assert(0 && " A Devicecap is zero! ");
                                hr = E_FAIL;
                            }

                            if (SUCCEEDED(hr))
                            {
                                // Convert physical himetrics to pixels

                                m_lWidth   = MulDiv(m_lWidth,  HorzRes, HorzSize);
                                m_lHeight  = MulDiv(m_lHeight, VertRes, VertSize);
                                m_lWidth   = m_lWidth  / HIMET_PER_MM;
                                m_lHeight  = m_lHeight / HIMET_PER_MM;

                                // Convert pixels to logical himetrics

                                m_lWidth   =
                                    MulDiv(m_lWidth,  HIMET_PER_LINCH, LogXPels);
                                m_lHeight  =
                                    MulDiv(m_lHeight, HIMET_PER_LINCH, LogYPels);
                            }

                        }
                        else
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                        }
		}
	}

	if (FAILED(hr))
	{
		LEVERIFY( DeleteEnhMetaFile(hNewEMF) );
	}
		
	return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CEMfObject::Draw
//
//  Synopsis:   Draws the stored presentation
//
//  Arguments:  [pvAspect]      -- (UNUSED) the drawing aspect
//              [hicTargetDev]  -- (UNUSED) the target device
//              [hdcDraw]       -- hdc to draw into
//              [lprcBounds]    -- bounding rectangle to draw into
//              [lprcWBounds]   -- (UNUSED) bounding rectangle for the metafile
//              [pfnContinue]   -- function to call while drawing
//              [dwContinue]    -- parameter to [pfnContinue]
//
//  Returns:    HRESULT
//
//  Derivation: IOlePresObj
//
//  Algorithm:  Sets the viewport and metafile boundaries, then plays
//              the metafile
//
//  History:    dd-mmm-yy Author    Comment
//              14-May-94 DavePl    Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CEMfObject::Draw(THIS_ void * /* UNUSED pvAspect     */,
			      HDC          /* UNUSED hicTargetDev */,
			      HDC          hdcDraw,
			      LPCRECTL     lprcBounds,
			      LPCRECTL     /* UNUSED lprcWBounds  */,
			      int (CALLBACK * pfnContinue)(ULONG_PTR),
			      ULONG_PTR       dwContinue)
{
	VDATEHEAP();

	m_error = NOERROR;
	
	int     iOldDc;
	RECT    rlBounds;

	// We receive a RECTL, and must pass in a RECT.  16-bit used to
	// manually copy the fields over, but we know that in Win32 they
	// really are the same structure.  Assert to be sure.
		
	Assert(sizeof(RECT) == sizeof(RECTL));

	Assert(lprcBounds);

	// We must have an EMF handle before we can even begin

	if (!M_HPRES())
	{
		return OLE_E_BLANK;
	}
	
	// Make a copy of the incoming bounding rectangle
	memcpy(&rlBounds, lprcBounds, sizeof(RECT));

	m_nRecord = EMF_RECORD_COUNT;

	// Determine whether or not we are drawing into another
	// metafile

	m_fMetaDC = OleIsDcMeta (hdcDraw);

	// Save the current state of the DC

	if (0 == (iOldDc = SaveDC (hdcDraw)))
	{
		return E_OUTOFMEMORY;
	}

	m_pfnContinue = pfnContinue;
	m_dwContinue  = dwContinue;

	LEVERIFY( EnumEnhMetaFile(hdcDraw, m_hPres, EMfCallbackFuncForDraw, this, (RECT *) lprcBounds) );
	
	LEVERIFY( RestoreDC (hdcDraw, iOldDc) );
	return m_error;
}


//+-------------------------------------------------------------------------
//
//  Function:   EMfCallBackFuncForDraw
//
//  Synopsis:   callback function for drawing metafiles -- call's the caller's
//              draw method (via a passed in this pointer)
//
//  Effects:
//
//  Arguments:  [hdc]           -- the device context
//              [lpHTable]      -- pointer to the MF handle table
//              [lpEMFR]        -- pointer to metafile record
//              [nObj]          -- number of objects
//
//  Requires:
//
//  Returns:    non-zero to continue, zero stops the drawing
//
//  History:    dd-mmm-yy Author    Comment
//              12-May-94 DavePl    Created
//
//--------------------------------------------------------------------------


int CALLBACK EMfCallbackFuncForDraw(HDC hdc,
				    HANDLETABLE FAR* lpHTable,
				    const ENHMETARECORD FAR* lpEMFR,
				    int nObj,
				    LPARAM lpobj)
{
	VDATEHEAP();

        // Warning: this casts an LPARAM (a long) to a pointer, but
        // it's the "approved" way of doing this...

	return ((CEMfObject *)    lpobj)->CallbackFuncForDraw(hdc,
							      lpHTable,
							      lpEMFR,
							      nObj,
							      lpobj);
}
//+-------------------------------------------------------------------------
//
//  Member:     CEMfObject::CallbackFuncForDraw
//
//  Synopsis:   Draws the metafile
//
//  Effects:
//
//  Arguments:  [hdc]           -- the device context
//              [lpHTable]      -- pointer to the MF handle table
//              [lpEMFR]        -- pointer to metafile record
//              [nObj]          -- number of objects
//
//  Requires:
//
//  Returns:    non-zero to continue, zero stops the drawing
//
//  History:    dd-mmm-yy Author    Comment
//              12-May-94 DavePl    Created
//
//--------------------------------------------------------------------------

int CALLBACK CEMfObject::CallbackFuncForDraw(HDC                   hdc,
					     LPHANDLETABLE         lpHTable,
					     const ENHMETARECORD * lpEMFR,
					     int                   nObj,
					     LPARAM      /* UNUSED lpobj*/)
{
	// Count down the record count.  When the count reaches zero,
	// it is time to call the "continue" function
		
	if (0 == --m_nRecord)
	{
		m_nRecord = EMF_RECORD_COUNT;
		
		if (m_pfnContinue && !((*(m_pfnContinue))(m_dwContinue)))
		{
			m_error = E_ABORT;
			return FALSE;
		}
	}

	LEVERIFY( PlayEnhMetaFileRecord (hdc, lpHTable, lpEMFR, (unsigned) nObj) );
	return TRUE;
}




//+-------------------------------------------------------------------------
//
//  Member:     CEMfObject::Load
//
//  Synopsis:   Loads an enhanced metafile object from the given stream
//
//  Arguments:  [lpstream]              -- the stream from which to load
//              [fReadHeaderOnly]       -- if TRUE, then only the header is
//                                         read
//  Returns:    HRESULT
//
//  Derivation: IOlePresObj
//
//  History:    dd-mmm-yy Author    Comment
//              12-May-94 DavePl    Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CEMfObject::Load(LPSTREAM lpstream, BOOL fReadHeaderOnly)
{
	VDATEHEAP();

	DWORD           dwBuf[4];
	HRESULT         hr;
	
	/* read dwCompression, width, height, size of data */
	hr = StRead(lpstream, dwBuf, 4*sizeof(DWORD));
	if (FAILED(hr))
	{
		return hr;
	}
	
	m_lWidth  = (LONG) dwBuf[1];
	m_lHeight = (LONG) dwBuf[2];
	m_dwSize  = dwBuf[3];

	if (!m_dwSize || fReadHeaderOnly)
	{
		return NOERROR;
	}
	
	// Read the EMF from the stream and create a handle to it.  Note
	// that the size will be adjusted to reflect the size of the
	// in-memory EMF, which may well differ from the the persistent
	// form (which is a MF with an EMF embedded as a comment).

	return UtGetHEMFFromEMFStm(lpstream, &m_dwSize, &m_hPres);
}


//+-------------------------------------------------------------------------
//
//  Member:     CEMfObjectn
//
//  Synopsis:   Saves the metafile to the given stream
//
//  Arguments:  [lpstream]      -- the stream to save to
//
//  Returns:    HRESULT
//
//  Derivation: IOlePresObj
//
//  History:    dd-mmm-yy Author    Comment
//              12-May-94 DavePl    Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CEMfObject::Save(LPSTREAM lpstream)
{
	VDATEHEAP();

	HRESULT         hr;
	DWORD           dwBuf[4];

	DWORD dwPersistSize;

	// The EMF could have been provided during this session, which would imply
	// that the resultant size of the converted EMF has no bearing on the size
	// of the original EMF we have been using.  Thus, we must update the size
	// for the persistent form.

	// If we are a blank presentation, there's no need to calculate
	// anything: our size is just 0

	if (IsBlank() || m_hPres == NULL)
	{
		dwPersistSize = 0;
	}
	else
	{
		HDC hdcTemp = CreateCompatibleDC(NULL);
		if (NULL == hdcTemp)
		{
			return HRESULT_FROM_WIN32(GetLastError());
		}

		dwPersistSize = GetWinMetaFileBits(m_hPres, 0, NULL, MM_ANISOTROPIC, hdcTemp);
		if (0 == dwPersistSize)
		{
			LEVERIFY( DeleteDC(hdcTemp) );
			return HRESULT_FROM_WIN32(GetLastError());
		}
		Verify(DeleteDC(hdcTemp));
	}
	
	/* write dwCompression, width, height, size of data */

	dwBuf[0]  = 0L;
	dwBuf[1]  = (DWORD) m_lWidth;
	dwBuf[2]  = (DWORD) m_lHeight;
	dwBuf[3]  = dwPersistSize;

	hr = StWrite(lpstream, dwBuf, sizeof(dwBuf));
	if (FAILED(hr))
	{
		return hr;
	}

	// if blank object, don't write any more; no error.
	if (IsBlank() || m_hPres == NULL)
	{
		StSetSize(lpstream, 0, TRUE);
		return NOERROR;
	}
	
	return UtHEMFToEMFStm(m_hPres,
			      dwPersistSize,
			      lpstream,
			      WRITE_AS_WMF);
}


//+-------------------------------------------------------------------------
//
//  Member:     CEMfObject::IsBlank
//
//  Synopsis:   Returns whether or not the enhanced metafile is blank
//
//  Arguments:  void
//
//  Returns:    TRUE/FALSE
//
//  Derivation: IOlePresObj
//
//  History:    dd-mmm-yy Author    Comment
//              12-May-94 DavePl    Created
//
//--------------------------------------------------------------------------

BOOL CEMfObject::IsBlank(void)
{
	VDATEHEAP();

	return (m_dwSize ? FALSE : TRUE);
}

//+-------------------------------------------------------------------------
//
//  Member:     CEMfObject::LoadHPRES (private)
//
//  Synopsis:   Loads the presentation from the cache's stream and returns
//              a handle to it
//
//  Returns:    HANDLE to the metafile
//
//  History:    dd-mmm-yy Author    Comment
//              12-May-94 DavePl    Created
//
//--------------------------------------------------------------------------

INTERNAL_(HENHMETAFILE) CEMfObject::LoadHPRES(void)
{
	VDATEHEAP();

	LPSTREAM pstm  = m_pCacheNode->GetStm(TRUE /*fSeekToPresBits*/,
		 			      STGM_READ);
	
	if (pstm)
	{
                // In case ::Load() fails, NULL the handle first

                m_hPres = NULL;
		LEVERIFY( SUCCEEDED(Load(pstm, FALSE /* fHeaderOnly*/)) );
		pstm->Release();
	}
	
	return m_hPres;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEMfObject::DiscardHPRES
//
//  Synopsis:   deletes the stored metafile
//
//  Derivation: IOlePresObj
//
//  History:    dd-mmm-yy Author    Comment
//              12-May-94 DavePl    Created
//
//--------------------------------------------------------------------------

void CEMfObject::DiscardHPRES(void)
{
	VDATEHEAP();

	if (m_hPres)
	{
		LEVERIFY( DeleteEnhMetaFile(m_hPres) );
		m_hPres = NULL;
	}
}
	

//+-------------------------------------------------------------------------
//
//  Member:     CEMfObject::GetCopyOfHPRES (private)
//
//  Synopsis:   makes a copy of the enhanced metafile (if one is present),
//              otherwise just loads it from the stream (but doesn't store
//              it in [this] object)
//
//  Arguments:  void
//
//  Returns:    HENHMETAFILE to the enhanced metafile
//
//  History:    dd-mmm-yy Author    Comment
//              12-May-94 DavePl    Created
//
//--------------------------------------------------------------------------

INTERNAL_(HENHMETAFILE) CEMfObject::GetCopyOfHPRES(void)
{
	VDATEHEAP();

	HENHMETAFILE hPres;
	
	// Make a copy if the presentation data is already loaded
	if (m_hPres)
	{
		return CopyEnhMetaFile(m_hPres, NULL);
	}
	
	// Load the presentation data now and return the same handle.
	// No need to copy the data. If the caller wants the m_hPres to be
	// set s/he would call LoadHPRES() directly.

	LEVERIFY( LoadHPRES() );
	hPres = m_hPres;        // Grab the handle from the member var
	m_hPres = NULL;         // (re-) Clear out the member var
	return hPres;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEMfObject::GetColorSet
//
//  Synopsis:   Retrieves the logical palette associated with the EMF
//
//  Effects:
//
//  Arguments:  [pvAspect]      -- the drawing aspect
//              [hicTargetDev]  -- target device
//              [ppColorSet]    -- where to put the logical palette pointer
//
//  Returns:    HRESULT
//
//  Derivation: IOlePresObj
//
//  History:    dd-mmm-yy Author    Comment
//              18-May-94 DavePl    Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CEMfObject::GetColorSet(LPVOID         /* UNUSED pvAspect     */,
                                     HDC            /* UNUSED hicTargetDev */,
                                     LPLOGPALETTE * ppColorSet)
{
	VDATEHEAP();
	VDATEPTROUT(ppColorSet, LPLOGPALETTE);

	m_pColorSet = *ppColorSet = NULL;

	if (IsBlank() || !M_HPRES())
	{
		return OLE_E_BLANK;
	}

	HENHMETAFILE hEMF = M_HPRES();

	// Get the count of palette entries
		
	UINT cColors = GetEnhMetaFilePaletteEntries(hEMF, 0, NULL);

	// If no palette entries, return a NULL LOGPALETTE

	if (0 == cColors)
	{
		return S_FALSE;
	}

        // REVIEW (davepl) A quick fix until we figure out what happens, or if
        // it is possible, for a EMF to have more than 32767 colors

        LEWARN( cColors > USHRT_MAX, "EMF has more colors than LOGPALETTE allows" );

        if (cColors > USHRT_MAX)
        {
            cColors = USHRT_MAX;
        }

	// Calculate the size of the variably-sized LOGPALLETE structure
	
	UINT uPalSize = cColors * sizeof(PALETTEENTRY) + 2 * sizeof(WORD);

	// Allocate the LOGPALETTE structure

	m_pColorSet = (LPLOGPALETTE) PubMemAlloc(uPalSize);
		
	if( NULL == m_pColorSet)
	{
		m_error = E_OUTOFMEMORY;
		return FALSE;
	}

	// Get the actual color entries

	m_pColorSet->palVersion = 0x300;
	m_pColorSet->palNumEntries = (WORD) cColors;
	UINT result = GetEnhMetaFilePaletteEntries(
				hEMF,
				cColors,
				&(m_pColorSet->palPalEntry[0]));

	// If it failed, clean up and bail

	if (cColors != result)
	{
		PubMemFree(m_pColorSet);
		m_pColorSet = NULL;
		return HRESULT_FROM_WIN32(GDI_ERROR);
	}
	
	// We succeeded, so set the OUT ptr and return
	
	*ppColorSet = m_pColorSet;

	return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEMfObject::GetExtent
//
//  Synopsis:   Retrieves the extents of the enhanced metafile
//
//  Arguments:  [dwDrawAspect]  -- the drawing aspect we're interested in
//              [lpsizel]       -- where to put the extent info
//
//  Returns:    NOERROR, DV_E_DVASPECT, OLE_E_BLANK
//
//  Derivation: IOlePresObj
//
//  History:    dd-mmm-yy Author    Comment
//              18-May-94 DavePl    Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CEMfObject::GetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
	VDATEHEAP();

	if (!(dwDrawAspect & m_dwAspect))
	{
		return DV_E_DVASPECT;
	}
	
	if (IsBlank())
	{
		return OLE_E_BLANK;
	}

	lpsizel->cx = m_lWidth;
	lpsizel->cy = m_lHeight;
	return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEMfObject::Dump, public (_DEBUG only)
//
//  Synopsis:   return a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [ppszDump]      - an out pointer to a null terminated character array
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   [ppszDump]  - argument
//
//  Derivation:
//
//  Algorithm:  use dbgstream to create a string containing information on the
//              content of data structures
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

HRESULT CEMfObject::Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    char *pszHRESULT;
    char *pszDVASPECT;
    dbgstream dstrPrefix;
    dbgstream dstrDump(500);

    // determine prefix of newlines
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << this << " _VB ";
    }

    // determine indentation prefix for all newlines
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    dstrDump << pszPrefix << "No. of References                 = " << m_ulRefs     << endl;

    dstrDump << pszPrefix << "Handle Enhanced Metafile          = " << m_hPres      << endl;

    dstrDump << pszPrefix << "IsMetaDeviceContext?              = ";
    if (m_fMetaDC == TRUE)
    {
        dstrDump << "TRUE" << endl;
    }
    else
    {
        dstrDump << "FALSE" << endl;
    }

    dstrDump << pszPrefix << "No. of Records in Metafile        = " << m_nRecord    << endl;

    pszHRESULT = DumpHRESULT(m_error);
    dstrDump << pszPrefix << "Error code                        = " << pszHRESULT   << endl;
    CoTaskMemFree(pszHRESULT);

    dstrDump << pszPrefix << "pLOGPALETTE (Color set palette)   = " << m_pColorSet  << endl;

    dstrDump << pszPrefix << "Continue                          = " << ((ULONG) m_dwContinue) << endl;

    dstrDump << pszPrefix << "fp Continue                       = " << m_pfnContinue<< endl;

    pszDVASPECT = DumpDVASPECTFlags(m_dwAspect);
    dstrDump << pszPrefix << "Aspect flags                      = " << pszDVASPECT  << endl;
    CoTaskMemFree(pszDVASPECT);

    dstrDump << pszPrefix << "Size                              = " << m_dwSize     << endl;

    dstrDump << pszPrefix << "Width                             = " << m_lWidth     << endl;

    dstrDump << pszPrefix << "Height                            = " << m_lHeight    << endl;

    dstrDump << pszPrefix << "pCacheNode                        = " << m_pCacheNode << endl;

    // cleanup and provide pointer to character array
    *ppszDump = dstrDump.str();

    if (*ppszDump == NULL)
    {
        *ppszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return NOERROR;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCEMfObject, public (_DEBUG only)
//
//  Synopsis:   calls the CEMfObject::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pEMFO]         - pointer to CEMfObject
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCEMfObject(CEMfObject *pEMFO, ULONG ulFlag, int nIndentLevel)
{
    HRESULT hresult;
    char *pszDump;

    if (pEMFO == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    hresult = pEMFO->Dump(&pszDump, ulFlag, nIndentLevel);

    if (hresult != NOERROR)
    {
        CoTaskMemFree(pszDump);

        return DumpHRESULT(hresult);
    }

    return pszDump;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   UtGetHEMFFromEMFStm
//
//  Synopsis:   Reads an enhanced metafile from a stream into memory,
//              creates the enhanced metafile from the raw data, and
//              returns a handle to it.
//
//  Arguments:  [lpstream] -- stream containing the EMF
//              [dwSize] -- data size within stream
//              [fConvert] -- FALSE for metafile, TRUE for PICT
//
//  Requires:   lpstream positioned at start of data
//
//  Returns:    HRESULT
//
//  History:    15-May-94   DavePl    Created
//
//--------------------------------------------------------------------------

FARINTERNAL UtGetHEMFFromEMFStm(LPSTREAM lpstream,
				DWORD * pdwSize,
				HENHMETAFILE * lphPres)
{
	VDATEHEAP();

	BYTE *pbEMFData = NULL;
	HRESULT hr      = NOERROR;
	
	// initialize this in case of error return

	*lphPres = NULL;

	// allocate a global handle for the data

	pbEMFData = (BYTE *) GlobalAlloc(GMEM_FIXED, *pdwSize);
	if (NULL == pbEMFData)
	{
	    return E_OUTOFMEMORY;
	}

	// read the stream into the bit storage

	hr = StRead(lpstream, pbEMFData, *pdwSize);

	if (FAILED(hr))
	{
	    LEVERIFY( NULL == GlobalFree((HGLOBAL) pbEMFData) );
	    return hr;
	}

	// Create an in-memory EMF based on the raw bits

	HDC hdcTemp = CreateCompatibleDC(NULL);
	if (NULL == hdcTemp)
	{
	    LEVERIFY( NULL == GlobalFree((HGLOBAL) pbEMFData) );
	    return E_FAIL;
	}
	
	*lphPres = SetWinMetaFileBits(*pdwSize, pbEMFData, hdcTemp, NULL);
	
	LEVERIFY( DeleteDC(hdcTemp) );

	// In any case, we can free the bit buffer

	LEVERIFY( NULL == GlobalFree((HGLOBAL) pbEMFData) );

	// If the SetEnhM... failed, set the error code
	
	if (*lphPres == NULL)
	{
	    hr = HRESULT_FROM_WIN32(GetLastError());
	}

	// We need to update the size of the in-memory EMF, as it
	// could differ from out persistent MF form.

	*pdwSize = GetEnhMetaFileBits(*lphPres, NULL, NULL);
	if (0 == *pdwSize)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
	}

	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   UtHEMFToEMFStm
//
//  Synopsis:   Takes a handle to an enhanced metafile and serializes it
//              to the supplied stream.  It can be serialized as either
//              a standard or enhanced metafile.
//
//  Arguments:  [lphEMF]        -- ptr to the EMF handle
//              [dwSize]        -- size of the EMF bits
//              [lpstream]      -- the stream to write to
//              [fWriteAsWMF]   -- write as WMF, not EMF
//
//  Returns:    HRESULT
//
//  History:    15-May-94   DavePl    Created
//
//  Notes:      This fn is used to serialize EMFs as MFs in the cache node
//              save case, which will allow 16-bit DLLs to read them back.
//              A EMF converted to MF contains the original EMF as an
//              embedded comment record, so no loss is taken in the
//              EMF -> MF -> EMF conversion case.
//
//              The incoming dwSize must be large enough to accomodate the
//              WMF (w/embedded EMF) in the standard metafile save case.
//
//--------------------------------------------------------------------------


FARINTERNAL UtHEMFToEMFStm(HENHMETAFILE hEMF,
			  DWORD dwSize,
			  LPSTREAM lpstream,
			  EMFWRITETYPE emfwType
			  )
{
	VDATEHEAP();

	HRESULT hr;

	Assert(emfwType == WRITE_AS_EMF || emfwType == WRITE_AS_WMF);
		
	// If we don't have a handle, there's nothing to do.

	if (hEMF == NULL)
	{
		return OLE_E_BLANK;
	}

	void *lpBits;
	
	lpBits = PrivMemAlloc(dwSize);
	if (NULL == lpBits)
	{
		return E_OUTOFMEMORY;
	}
	
	if (emfwType == WRITE_AS_WMF)
	{
		// WMF WRITE CASE

		// Get the raw bits of the metafile that we are going to
		// write out

		HDC hdcTemp = CreateCompatibleDC(NULL);
		if (NULL == hdcTemp)
		{
			hr = E_FAIL;
			goto errRtn;
		}

		if (0 == GetWinMetaFileBits(hEMF, dwSize, (BYTE *) lpBits, MM_ANISOTROPIC, hdcTemp))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			LEVERIFY( DeleteDC(hdcTemp) );
			goto errRtn;
		}
		LEVERIFY( DeleteDC(hdcTemp) );
	
		// write the metafile bits out to the stream

	}
	else
	{
		// EMF WRITE CASE

		if (0 == GetEnhMetaFileBits(hEMF, dwSize, (BYTE *) lpBits))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto errRtn;
		}
	}

	hr = StWrite(lpstream, lpBits, dwSize);
	
errRtn:
	
	// free the metafile bits
	
	PrivMemFree(lpBits);

	// set the stream size
	if (SUCCEEDED(hr))
	{
		hr = StSetSize(lpstream, 0, TRUE);
	}

	return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   UtGetHEMFFromContentsStm
//
//  Synopsis:   Pulls EMF data from a stream and creates a handle to
//              the resultant in-memory EMF
//
//  Arguments:  [pstm]          -- the stream to read from
//              [phdata]        -- the handle to create on
//
//  Returns:    (void)
//
//  History:    10-Jul-94   DavePl    Created
//
//
//--------------------------------------------------------------------------

void UtGetHEMFFromContentsStm(LPSTREAM pstm, HANDLE * phdata)
{
	*phdata = NULL;
	
	DWORD   dwSize;
	ENHMETAHEADER * pHdr;
		
	// Pull the size of the metafile header from the stream

	if (FAILED(StRead(pstm, &dwSize, sizeof(DWORD))))
	{
		return;
	}

	// The header must be at least as large as the byte
	// offset to the nBytes member of the ENHMETAHEADER struct.
	
	if (dwSize < offsetof(ENHMETAHEADER, nBytes))
	{
		return;
	}

	// Allocate enough memory for the header struct

	pHdr = (ENHMETAHEADER *) PrivMemAlloc(dwSize);
	if (NULL == pHdr)
	{
		return;
	}

	// Read the header structure into our buffer
	
	if (FAILED(StRead(pstm, pHdr, dwSize)))
	{
		PrivMemFree(pHdr);
		return;
	}
	
	// All we care about in the header is the size of the
	// metafile bits, so cache that and free the header buffer
	
	dwSize = pHdr->nBytes;
	PrivMemFree(pHdr);
		
	// Allocate memory to read the raw EMF bits into
		
	BYTE * lpBytes = (BYTE *) PrivMemAlloc(dwSize);
	if (NULL == lpBytes)
	{
		return;
	}

	// Read the raw bits into the buffer...

	if (FAILED(StRead(pstm, lpBytes, dwSize)))
	{
		PrivMemFree(lpBytes);
		return;
	}

	// Create an in-memory EMF based on those bits

	HENHMETAFILE hEmf = SetEnhMetaFileBits(dwSize, lpBytes);
	PrivMemFree(lpBytes);
	
	if (NULL == hEmf)
	{
		return;
	}

	*phdata = hEmf;

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\stdimpl\defhndlr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       defhndlr.h
//
//  Contents:   class declaration for the default handler
//
//  Classes:    CDefObject
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//
//              11-17-95  JohannP   (Johann Posch)  Architectural change:
//                                  Default handler will talk to a handler object
//                                  on the server site (ServerHandler). The serverhandler
//                                  communicates with the default handler via the
//                                  clientsitehandler. See document: "The Ole Server Handler".
//
//              06-Sep-95 davidwor  removed SetHostNames atoms and replaced with
//                                  m_pHostNames and m_ibCntrObj members
//              01-Feb-95 t-ScottH  added Dump method to CDefObject
//                                  added DHFlag to indicate aggregation
//                                  (_DEBUG only)
//                                  changed private member from IOleAdviseHolder *
//                                  to COAHolder * (it is what we instantiate)
//              15-Nov-94 alexgo    optimized, removed 16bit burfiness
//                                  (nested classes and multiple BOOLs)
//              25-Jan-94 alexgo    first pass at converting to Cairo-style
//                                  memory allocations.
//              02-Nov-93 alexgo    32bit port
//
//--------------------------------------------------------------------------

#include <utils.h>
#include "olepres.h"
#include "olecache.h"
#include "dacache.h"
#include "oaholder.h"

#ifdef SERVER_HANDLER
#include <srvhdl.h> 
class CEmbServerWrapper;
#endif SERVER_HANDLER

// default handler flags
typedef enum tagDHFlags
{
    DH_SAME_AS_LOAD     = 0x0001,
    DH_CONTAINED_OBJECT = 0x0002,    // indicates an embedding
    DH_LOCKED_CONTAINER = 0x0004,
    DH_FORCED_RUNNING   = 0x0008,
    DH_EMBEDDING        = 0x0010,   // link or an embedding?
    DH_INIT_NEW         = 0x0020,
    DH_STATIC           = 0x0040,
    DH_INPROC_HANDLER   = 0x0080,
    DH_DELAY_CREATE     = 0x0100,
    DH_COM_OUTEROBJECT  = 0x0200,
    DH_UNMARSHALED      = 0x0400,
    DH_CLEANEDUP        = 0x0800,
    DH_OLE1SERVER       = 0x1000,
    DH_APICREATE        = 0x2000,
#ifdef _DEBUG
    DH_AGGREGATED       = 0x00010000,
    DH_LOCKFAILED       = 0x00020000,
    DH_WILLUNLOCK       = 0x00040000
#endif // _DEBUG
} DHFlags;


//+-------------------------------------------------------------------------
//
//  Class:      CDefObject
//
//  Purpose:    The default handler class.  The object acts as a surrogate,
//              or handler for an out-of-process server exe.
//
//  Interface:  The default handler implements
//              IDataObject
//              IOleObject
//              IPersistStorage
//              IRunnableObject
//              IExternalConnection
//              IAdviseSink
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  added Dump method (_DEBUG only)
//              15-Nov-94 alexgo    memory optimization
//              02-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


class CDefObject : public CRefExportCount, public IDataObject,
        public IOleObject, public IPersistStorage, public IRunnableObject,
        public IExternalConnection, public CThreadCheck
{
public:

    static IUnknown *Create (IUnknown *pUnkOuter,
            REFCLSID clsidClass, DWORD flags, IClassFactory *pCF);

    class CPrivUnknown : public IUnknown
    {
    public:
        STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj);
        STDMETHOD_(ULONG,AddRef) (void);
        STDMETHOD_(ULONG,Release) (void);
    };

    friend class CPrivUnknown;

    CPrivUnknown m_Unknown;

    // IUnknown methods

    STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);

    // IDataObject methods

    INTERNAL_(IDataObject *) GetDataDelegate(void);

    STDMETHOD(GetData) ( LPFORMATETC pformatetcIn,
            LPSTGMEDIUM pmedium );
    STDMETHOD(GetDataHere) ( LPFORMATETC pformatetc,
            LPSTGMEDIUM pmedium );
    STDMETHOD(QueryGetData) ( LPFORMATETC pformatetc );
    STDMETHOD(GetCanonicalFormatEtc) ( LPFORMATETC pformatetc,
            LPFORMATETC pformatetcOut);
    STDMETHOD(SetData) ( LPFORMATETC pformatetc,
            LPSTGMEDIUM pmedium, BOOL fRelease);
    STDMETHOD(EnumFormatEtc) ( DWORD dwDirection,
            LPENUMFORMATETC FAR* ppenumFormatEtc);
    STDMETHOD(DAdvise) ( FORMATETC FAR* pFormatetc, DWORD advf,
            IAdviseSink FAR* pAdvSink,
            DWORD FAR* pdwConnection);
    STDMETHOD(DUnadvise) ( DWORD dwConnection);
    STDMETHOD(EnumDAdvise) ( LPENUMSTATDATA FAR* ppenumAdvise);

    // IOleObject methods

    INTERNAL_(IOleObject *)GetOleDelegate();

    STDMETHOD(SetClientSite) ( LPOLECLIENTSITE pClientSite);
    STDMETHOD(GetClientSite) ( LPOLECLIENTSITE FAR* ppClientSite);
    STDMETHOD(SetHostNames) ( LPCOLESTR szContainerApp,
                LPCOLESTR szContainerObj);
    STDMETHOD(Close) ( DWORD reserved);
    STDMETHOD(SetMoniker) ( DWORD dwWhichMoniker, LPMONIKER pmk);
    STDMETHOD(GetMoniker) ( DWORD dwAssign, DWORD dwWhichMoniker,
                LPMONIKER FAR* ppmk);
    STDMETHOD(InitFromData) ( LPDATAOBJECT pDataObject,
                BOOL fCreation,
                DWORD dwReserved);
    STDMETHOD(GetClipboardData) ( DWORD dwReserved,
                LPDATAOBJECT FAR* ppDataObject);
    STDMETHOD(DoVerb) ( LONG iVerb,
                LPMSG lpmsg,
                LPOLECLIENTSITE pActiveSite,
                LONG lindex,
                HWND hwndParent,
                const RECT FAR* lprcPosRect);
    STDMETHOD(EnumVerbs) ( IEnumOLEVERB FAR* FAR* ppenumOleVerb);
    STDMETHOD(Update) (void);
    STDMETHOD(IsUpToDate) (void);
    STDMETHOD(GetUserClassID) ( CLSID FAR* pClsid);
    STDMETHOD(GetUserType) ( DWORD dwFormOfType,
                LPOLESTR FAR* pszUserType);
    STDMETHOD(SetExtent) ( DWORD dwDrawAspect, LPSIZEL lpsizel);
    STDMETHOD(GetExtent) ( DWORD dwDrawAspect, LPSIZEL lpsizel);
    STDMETHOD(Advise)(IAdviseSink FAR* pAdvSink,
                DWORD FAR* pdwConnection);
    STDMETHOD(Unadvise)( DWORD dwConnection);
    STDMETHOD(EnumAdvise) ( LPENUMSTATDATA FAR* ppenumAdvise);
    STDMETHOD(GetMiscStatus) ( DWORD dwAspect,
                DWORD FAR* pdwStatus);
    STDMETHOD(SetColorScheme) ( LPLOGPALETTE lpLogpal);

    // IPeristStorage methods

    INTERNAL_(IPersistStorage *) GetPSDelegate(void);

    STDMETHOD(GetClassID) ( LPCLSID pClassID);
    STDMETHOD(IsDirty) (void);
    STDMETHOD(InitNew) ( LPSTORAGE pstg);
    STDMETHOD(Load) ( LPSTORAGE pstg);
    STDMETHOD(Save) ( LPSTORAGE pstgSave, BOOL fSameAsLoad);
    STDMETHOD(SaveCompleted) ( LPSTORAGE pstgNew);
    STDMETHOD(HandsOffStorage) ( void);

    // IRunnable Object methods

    STDMETHOD(GetRunningClass) (LPCLSID lpClsid);
    STDMETHOD(Run) (LPBINDCTX pbc);
    STDMETHOD_(BOOL, IsRunning) (void);
    STDMETHOD(LockRunning)(BOOL fLock, BOOL fLastUnlockCloses);
    STDMETHOD(SetContainedObject)(BOOL fContained);

    INTERNAL Stop(void);

    // IExternalConnection methods

    STDMETHOD_(DWORD, AddConnection) (THIS_ DWORD extconn,
            DWORD reserved);
    STDMETHOD_(DWORD, ReleaseConnection) (THIS_ DWORD extconn,
            DWORD reserved, BOOL fLastReleaseCloses);


    // NOTE: the advise sink has a separate controlling unknown from the
    // other interfaces; the lifetime of the memory for this implementation
    // is still the same as the default handler.   The ramifications of
    // this are that when the default handler goes away it must make sure
    // that all pointers back to the sink are released; see the special
    // code in the dtor of the default handler.
    class CAdvSinkImpl : public IAdviseSink
    {
    public:
        // IUnknown methods
        STDMETHOD(QueryInterface) ( REFIID iid, LPVOID FAR* ppvObj);
        STDMETHOD_(ULONG,AddRef) (void);
        STDMETHOD_(ULONG,Release) (void);

        // *** IAdviseSink methods ***
        STDMETHOD_(void,OnDataChange)( FORMATETC FAR* pFormatetc,
            STGMEDIUM FAR* pStgmed);
        STDMETHOD_(void,OnViewChange)( DWORD aspects, LONG lindex);
        STDMETHOD_(void,OnRename)( IMoniker FAR* pmk);
        STDMETHOD_(void,OnSave)(void);
        STDMETHOD_(void,OnClose)(void);
    };

    friend class CAdvSinkImpl;

    CAdvSinkImpl m_AdviseSink;

#ifdef _DEBUG

    HRESULT Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel);

    // need to be able to access CDefObject private data members in the
    // following debugger extension APIs
    // this allows the debugger extension APIs to copy memory from the
    // debuggee process memory to the debugger's process memory
    // this is required since the Dump method follows pointers to other
    // structures and classes
    friend DEBUG_EXTENSION_API(dump_defobject);

#endif // _DEBUG

private:

    CDefObject (IUnknown *pUnkOuter);
    virtual ~CDefObject (void);
    virtual void CleanupFn(void);
    INTERNAL_(ULONG) CheckDelete(ULONG ulRet);
    INTERNAL GetClassBits(CLSID FAR* pClsidBits);
    INTERNAL CreateDelegate(void);
    INTERNAL DoConversionIfSpecialClass(LPSTORAGE pstg);


    // Member Variables for Server Handler.
#ifdef SERVER_HANDLER
    CEmbServerWrapper*          m_pEmbSrvHndlrWrapper;      // Pointer to local wrapping interface.
    HRESULT                     m_hresultClsidUser;         // hresult from call to GetUserClassID
    HRESULT                     m_hresultContentMiscStatus; // hresult from Call to GetMiscStatus for DVASPECT_CONTENT
    CLSID                       m_clsidUser;                // clsid returned by GetUserClassID
    DWORD                       m_ContentMiscStatusUser;    // MiscStatus returned be GetMiscStatus for DVASPECT_CONTENT

    // Todo: Move to EmbServerWrapper
    IOleClientSite *            m_pRunClientSite;           // ClientSite used when Run was Called.
#endif // SERVER_HANDLER
	
    // Member variables for caching MiscStatus bits
    HRESULT                     m_ContentSRVMSHResult;
    DWORD                       m_ContentSRVMSBits;
    HRESULT                     m_ContentREGMSHResult;
    DWORD                       m_ContentREGMSBits;

    IOleObject *                m_pOleDelegate;
    IDataObject *               m_pDataDelegate;
    IPersistStorage *           m_pPSDelegate;

    DWORD                       m_cConnections;
    IUnknown *                  m_pUnkOuter;
    CLSID                       m_clsidServer;  // clsid of app we will run
    CLSID                       m_clsidBits;    // clsid of bits on disk;
                                                // NULL init

    DWORD                       m_flags;        // handler flags
    DWORD                       m_dwObjFlags;   // OBJFLAGS of OLESTREAM
    IClassFactory *             m_pCFDelegate;  // only set if delayed create
    IUnknown *                  m_pUnkDelegate;
    IProxyManager *             m_pProxyMgr;

    // m_fForcedRunning indicates that the container forced the object
    // running via ::Run or DoVerb.  Handlers (EMBDHLP_INPROC_HANDLER) can
    // can go running implicitly via marshaling (usually via moniker bind)
    // and thus we actually use pProxyMgr->IsConnected to answer IsRunning.

    // Distinguishes between embeddings and links.  We cannot use
    // m_pStg because it gets set to NULL in HandsOffStorage.

    // data cache
    COleCache *                 m_pCOleCache;   // pointer to COleCache

    // ole advise info
    COAHolder *                 m_pOAHolder;
    DWORD                       m_dwConnOle;    // if not 0L, ole advise conn.

    // info passed to server on run
    IOleClientSite *            m_pAppClientSite;
    IStorage *                  m_pStg;         // may be NULL
    char *                      m_pHostNames;   // store both host name strings
    DWORD                       m_ibCntrObj;    // offset into m_pHostNames
    LPDATAADVCACHE              m_pDataAdvCache;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\stdimpl\deflink.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	deflink.h
//
//  Contents:	Declares the default link object
//
//  Classes:	CDefLink
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  added Dump method to CDefLink
//                                  added DLFlag to indicate if aggregated
//                                  (in _DEBUG only)
//		21-Nov-94 alexgo    memory optimization
//		25-Jan-94 alexgo    first pass at converting to Cairo-style
//				    memory allocations.
//		13-Nov-93 alexgo    32bit port
//
//--------------------------------------------------------------------------

#include "olepres.h"
#include "olecache.h"
#include "dacache.h"
#include <oaholder.h>

typedef enum tagDLFlags
{
    DL_SAME_AS_LOAD	       = 0x0001,
    DL_NO_SCRIBBLE_MODE        = 0x0002,
    DL_DIRTY_LINK	       = 0x0004,
    DL_LOCKED_CONTAINER        = 0x0008,
    DL_LOCKED_RUNNABLEOBJECT   = 0x0010,
    DL_LOCKED_OLEITEMCONTAINER = 0x0020,
    DL_CLEANEDUP               = 0x0040,
#ifdef _DEBUG
    DL_AGGREGATED              = 0x10000
#endif // _DEBUG
} DLFlags;

//+-------------------------------------------------------------------------
//
//  Class:  	CDefLink
//
//  Purpose:    The "embedding" for a link; the default object that implements
//		a link connection
//
//  Interface:	IUnknown
//		IDataObject
//		IOleObject
//		IOleLink
//		IRunnableObject
//		IAdviseSink
//		IPersistStorage	
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  add Dump method (_DEBUG only)
//		21-Nov-94 alexgo    memory optimization
//		13-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

class FAR CDefLink : public CRefExportCount, public IDataObject,
    public IOleObject, public IOleLink, public IRunnableObject,
    public IPersistStorage, public CThreadCheck
{
public:

    static IUnknown FAR* Create(IUnknown FAR* pUnkOuter);

    class CPrivUnknown : public IUnknown
    {
    public:
        STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj);
        STDMETHOD_(ULONG,AddRef) (void);
        STDMETHOD_(ULONG,Release) (void);
    };

    friend class CPrivUnknown;
    CPrivUnknown 	m_Unknown;

    // IUnknown methods

    STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);

    // IDataObject methods

    INTERNAL_(IDataObject *) GetDataDelegate(void);
    INTERNAL_(void) ReleaseDataDelegate(void);

    STDMETHOD(GetData) ( LPFORMATETC pformatetcIn,
	    LPSTGMEDIUM pmedium );
    STDMETHOD(GetDataHere) ( LPFORMATETC pformatetc,
	    LPSTGMEDIUM pmedium );
    STDMETHOD(QueryGetData) ( LPFORMATETC pformatetc );
    STDMETHOD(GetCanonicalFormatEtc) ( LPFORMATETC pformatetc,
	    LPFORMATETC pformatetcOut);
    STDMETHOD(SetData) ( LPFORMATETC pformatetc,
	    LPSTGMEDIUM pmedium,
	    BOOL fRelease);
    STDMETHOD(EnumFormatEtc) ( DWORD dwDirection,
	  LPENUMFORMATETC *ppenumFormatEtc);
    STDMETHOD(DAdvise) ( FORMATETC *pFormatetc, DWORD advf,
	    IAdviseSink *pAdvSink,
	    DWORD *pdwConnection);
    STDMETHOD(DUnadvise) ( DWORD dwConnection);
    STDMETHOD(EnumDAdvise) ( LPENUMSTATDATA *ppenumAdvise);

    // IOleObject methods

    INTERNAL_(IOleObject FAR*) GetOleDelegate(void);
    INTERNAL_(void) ReleaseOleDelegate(void);

    // *** IOleObject methods ***
    STDMETHOD(SetClientSite)(LPOLECLIENTSITE pClientSite);
    STDMETHOD(GetClientSite)(LPOLECLIENTSITE *ppClientSite);
    STDMETHOD(SetHostNames)(LPCOLESTR szContainerApp,
	    LPCOLESTR szContainerObj);
    STDMETHOD(Close) ( DWORD reserved);
    STDMETHOD(SetMoniker) ( DWORD dwWhichMoniker, LPMONIKER pmk);
    STDMETHOD(GetMoniker) ( DWORD dwAssign, DWORD dwWhichMoniker,
	    LPMONIKER *ppmk);
    STDMETHOD(InitFromData) ( LPDATAOBJECT pDataObject,
	    BOOL fCreation,
	    DWORD dwReserved);
    STDMETHOD(GetClipboardData) ( DWORD dwReserved,
		LPDATAOBJECT *ppDataObject);
    STDMETHOD(DoVerb) ( LONG iVerb,
	    LPMSG lpmsg,
	    LPOLECLIENTSITE pActiveSite,
	    LONG lindex,
	    HWND hwndParent,
	    const RECT *lprcPosRect);					
    STDMETHOD(EnumVerbs) ( IEnumOLEVERB **ppenumOleVerb);
    STDMETHOD(Update) (void);
    STDMETHOD(IsUpToDate) (void);
    STDMETHOD(GetUserClassID) ( CLSID *pClsid);
    STDMETHOD(GetUserType) ( DWORD dwFormOfType,
	    LPOLESTR *pszUserType);
    STDMETHOD(SetExtent) ( DWORD dwDrawAspect, LPSIZEL lpsizel);
    STDMETHOD(GetExtent) ( DWORD dwDrawAspect, LPSIZEL lpsizel);
    STDMETHOD(Advise)(IAdviseSink FAR* pAdvSink,
	    DWORD *pdwConnection);
    STDMETHOD(Unadvise)( DWORD dwConnection);
    STDMETHOD(EnumAdvise) ( LPENUMSTATDATA *ppenumAdvise);
    STDMETHOD(GetMiscStatus) ( DWORD dwAspect,
	    DWORD *pdwStatus);
    STDMETHOD(SetColorScheme) ( LPLOGPALETTE lpLogpal);

    // IOleLink methods

    STDMETHOD(SetUpdateOptions) ( DWORD dwUpdateOpt);
    STDMETHOD(GetUpdateOptions) ( LPDWORD pdwUpdateOpt);
    STDMETHOD(SetSourceMoniker) ( LPMONIKER pmk, REFCLSID rclsid);
    STDMETHOD(GetSourceMoniker) ( LPMONIKER *ppmk);
    STDMETHOD(SetSourceDisplayName) ( LPCOLESTR lpszStatusText);
    STDMETHOD(GetSourceDisplayName) (
	    LPOLESTR *lplpszDisplayName);
    STDMETHOD(BindToSource) ( DWORD bindflags, LPBINDCTX pbc);
    STDMETHOD(BindIfRunning) (void);
    STDMETHOD(GetBoundSource) ( LPUNKNOWN *pUnk);
    STDMETHOD(UnbindSource) (void);
    STDMETHOD(Update) ( LPBINDCTX pbc);

    // IRunnableObject methods

    INTERNAL_(IRunnableObject FAR*) GetRODelegate(void);
    INTERNAL_(void) ReleaseRODelegate(void);

    STDMETHOD(GetRunningClass) (LPCLSID lpClsid);
    STDMETHOD(Run) (LPBINDCTX pbc);
    STDMETHOD_(BOOL,IsRunning) (void);
    STDMETHOD(LockRunning)(BOOL fLock, BOOL fLastUnlockCloses);
    STDMETHOD(SetContainedObject)(BOOL fContained);

    // IPersistStorage methods

    STDMETHOD(GetClassID) ( LPCLSID pClassID);
    STDMETHOD(IsDirty) (void);
    STDMETHOD(InitNew) ( LPSTORAGE pstg);
    STDMETHOD(Load) ( LPSTORAGE pstg);
    STDMETHOD(Save) ( LPSTORAGE pstgSave, BOOL fSameAsLoad);
    STDMETHOD(SaveCompleted) ( LPSTORAGE pstgNew);
    STDMETHOD(HandsOffStorage) ( void);

    // will really check to see if the server is still
    // running and do appropriate cleanups if we have
    // crashed

    STDMETHOD_(BOOL, IsReallyRunning)(void);


    // NOTE: the advise sink has a separate controlling unknown from the
    // other interfaces; the lifetime of the memory for this implementation
    // is still the same as the default handler.   The ramifications of
    // this are that when the default handler goes away it must make sure
    // that all pointers back to the sink are released; see the special
    // code in the dtor of the default handler.
    class CAdvSinkImpl : public IAdviseSink
    {
    public:    	

        STDMETHOD(QueryInterface) ( REFIID iid, LPVOID *ppvObj);
        STDMETHOD_(ULONG,AddRef) (void);
        STDMETHOD_(ULONG,Release) (void);

        // *** IAdviseSink methods ***
        STDMETHOD_(void,OnDataChange)( FORMATETC *pFormatetc,
            STGMEDIUM *pStgmed);
        STDMETHOD_(void,OnViewChange)( DWORD aspects, LONG lindex);
        STDMETHOD_(void,OnRename)( IMoniker *pmk);
        STDMETHOD_(void,OnSave)(void);
        STDMETHOD_(void,OnClose)(void);
    };

    friend class CAdvSinkImpl;
    CAdvSinkImpl m_AdviseSink;

#ifdef _DEBUG

    HRESULT Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel);

    // need to be able to access CDefLink private data members in the
    // following debugger extension APIs
    // this allows the debugger extension APIs to copy memory from the
    // debuggee process memory to the debugger's process memory
    // this is required since the Dump method follows pointers to other
    // structures and classes
    friend DEBUG_EXTENSION_API(dump_deflink);

#endif // _DEBUG

private:

    CDefLink( IUnknown *pUnkOuter);
    virtual void CleanupFn(void);
    ~CDefLink (void);

    INTERNAL_(void) UpdateUserClassID();
    INTERNAL_(void) BeginUpdates(void);
    INTERNAL_(void) EndUpdates(void);
    INTERNAL_(void) UpdateAutoOnSave(void);
    INTERNAL_(void) UpdateRelMkFromAbsMk(IMoniker *pmkContainer);
    INTERNAL UpdateMksFromAbs(IMoniker *pmkContainer, IMoniker *pmkAbs);
    INTERNAL GetAbsMkFromRel(LPMONIKER *ppmkAbs, IMoniker **ppmkContainer );
    INTERNAL SetUpdateTimes( void );
#ifdef _TRACKLINK_
    INTERNAL EnableTracking( IMoniker * pmk, ULONG ulFlags );
#endif

    INTERNAL_(IOleItemContainer FAR*) GetOleItemContainerDelegate(void);
    INTERNAL_(void) ReleaseOleItemContainerDelegate(void);

    INTERNAL_(void) CheckDelete(void);

    DWORD			m_flags; 	// DLFlags enumeration
    DWORD                       m_dwObjFlags;   // OBJFLAGS of the OLESTREAM
    IDataObject *		m_pDataDelegate;
    IOleObject *		m_pOleDelegate;
    IRunnableObject *		m_pRODelegate;
    IOleItemContainer *		m_pOleItemContainerDelegate;

    // Member variables for caching MiscStatus bits
    HRESULT                     m_ContentSRVMSHResult;
    DWORD                       m_ContentSRVMSBits;
    HRESULT                     m_ContentREGMSHResult;
    DWORD                       m_ContentREGMSBits;

    ULONG			m_cRefsOnLink;
    IUnknown *			m_pUnkOuter;			
    IMoniker *			m_pMonikerAbs;	// THE absolute moniker
						// of the link source				
    IMoniker *			m_pMonikerRel;	// THE relative moniker
						// of the link source			
    IUnknown *			m_pUnkDelegate;	// from mk bind; non-null
						// if running	
    DWORD			m_dwUpdateOpt;
    CLSID			m_clsid; 	// last known clsid of
						// link source;
						// NOTE: may be NULL
    IStorage *			m_pStg;			

    // data cache
    COleCache * 		m_pCOleCache;	// cache (always non-NULL)

    // ole advise info
    COAHolder *			m_pCOAHolder; 	// OleAdviseHolder

    DWORD			m_dwConnOle;	// if running, ole advise conn.

    LPDATAADVCACHE		m_pDataAdvCache;// data advise cache

    IOleClientSite *		m_pAppClientSite;// not passed to server!

    DWORD			m_dwConnTime;	// dwConnection for time
						// changes
    FILETIME			m_ltChangeOfUpdate;
    FILETIME			m_ltKnownUpToDate;
    FILETIME			m_rtUpdate;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\stdimpl\gen.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       gen.cpp
//
//  Contents:   Implementation of the generic picture object (CGenObject)
//              and dib routines.
//
//  Classes:    CGenObject implementation
//
//  Functions:  DibDraw (internal)
//              DibMakeLogPalette (internal)
//              DibFillPaletteEntries (internal)
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  add Dump method and DumpCGenObject API
//              25-Jan-94 alexog    first pass at converting to Cairo-style
//                                  memory allocations.
//              11-Jan-94 alexgo    added VDATEHEAP macros to every function
//                                  and method
//              07-Dec-93 ChrisWe   make default params to StSetSize explicit
//              07-Dec-93 alexgo    merged 16bit RC9 changes
//              29-Nov-93 ChrisWe   make default arguments to UtDupGlobal,
//                                      UtConvertBitmapToDib explicit
//              23-Nov-93 alexgo    32bit port
//      srinik  06/04/93        Added the support for demand loading and
//                              discarding the caches.
//      SriniK  03/19/1993      Deleted dib.cpp and moved DIB drawing routines
//                              into this file.
//      SriniK  01/07/1993      Merged dib.cpp into gen.cpp
//
//--------------------------------------------------------------------------

/*
REVIEW32::: WARNING WARNING
There are many potentially bogus pointer to Palette, etc handle conversions
put in to make the code compile.  :(
(Gee, thanks for marking them as you went)
*/

#include <le2int.h>
#pragma SEG(gen)

#include "gen.h"

#ifdef _DEBUG
#include <dbgdump.h>
#endif // _DEBUG

ASSERTDATA

#define M_HPRES()               (m_hPres ? m_hPres : LoadHPRES())

//local functions
INTERNAL                DibDraw(HANDLE hDib, HDC hdc, LPCRECTL lprc);
INTERNAL_(HANDLE)       DibMakeLogPalette (BYTE FAR *lpColorData,
				WORD wDataSize,
				LPLOGPALETTE FAR* lplpLogPalette);
INTERNAL_(void)         DibFillPaletteEntries(BYTE FAR *lpColorData,
				WORD wDataSize, LPLOGPALETTE lpLogPalette);



/*
 *      IMPLEMENTATION of CGenObject
 *
 */

NAME_SEG(Gen)


//+-------------------------------------------------------------------------
//
//  Member:     CGenObject::CGenObject
//
//  Synopsis:   Constructor
//
//  Effects:
//
//  Arguments:  [pCacheNode]    -- cache for the object
//              [cfFormat]      -- clipboard format of the object
//              [dwAspect]      -- drawing aspect of the object
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:  just initializes member variables
//
//  History:    dd-mmm-yy Author    Comment
//              23-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CGenObject_ctor)
CGenObject::CGenObject(LPCACHENODE pCacheNode, CLIPFORMAT cfFormat,
	DWORD dwAspect)
{
	VDATEHEAP();

	m_ulRefs        = 1;
	m_dwSize        = NULL;
	m_lWidth        = NULL;
	m_lHeight       = NULL;
	m_hPres         = NULL;
	m_cfFormat      = cfFormat;
	m_dwAspect      = dwAspect;
	m_pCacheNode    = pCacheNode;
}


//+-------------------------------------------------------------------------
//
//  Member:     CGenObject::~CGenObject
//
//  Synopsis:   Destructor
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              23-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CGenObject_dtor)
CGenObject::~CGenObject(void)
{
	VDATEHEAP();

	if (m_hPres)
	{
		LEVERIFY( NULL == GlobalFree (m_hPres));
	}
}

//+-------------------------------------------------------------------------
//
//  Member:     CGenObject::QueryInterface
//
//  Synopsis:   returns interfaces on the generic picture object
//
//  Effects:
//
//  Arguments:  [iid]           -- the requested interface ID
//              [ppvObj]        -- where to put the interface pointer
//
//  Requires:
//
//  Returns:    NOERROR, E_NOINTERFACE
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IUnkown
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              23-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CGenObject_QueryInterface)
STDMETHODIMP CGenObject::QueryInterface (REFIID iid, void FAR* FAR* ppvObj)
{
	VDATEHEAP();

	if (IsEqualIID(iid, IID_IUnknown) || IsEqualIID(iid, IID_IOlePresObj))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	else
	{
		*ppvObj = NULL;
		return ResultFromScode(E_NOINTERFACE);
	}
}

//+-------------------------------------------------------------------------
//
//  Member:     CGenObject::AddRef
//
//  Synopsis:   increments the reference count
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IUnknown
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              23-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CGenObject_AddRef)
STDMETHODIMP_(ULONG) CGenObject::AddRef(void)
{
	VDATEHEAP();
	
	return ++m_ulRefs;
}
			
//+-------------------------------------------------------------------------
//
//  Member:     CGenObject::Release
//
//  Synopsis:   Decrements the reference count
//
//  Effects:    may delete [this] object
//
//  Arguments:
//
//  Requires:
//
//  Returns:    ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IUnknown
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              23-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CGenObject_Release)
STDMETHODIMP_(ULONG) CGenObject::Release(void)
{
	VDATEHEAP();

	if (--m_ulRefs == 0)
	{
		delete this;
		return 0;
	}

	return m_ulRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:     CGenObject::GetData
//
//  Synopsis:   retrieves data of the specified format
//
//  Effects:
//
//  Arguments:  [pformatetcIn]  -- the requested data format
//              [pmedium]       -- where to put the data
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObject
//
//  Algorithm:  If available, copies the presentation to pmedium
//
//  History:    dd-mmm-yy Author    Comment
//              23-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(CGenObject_GetData)
STDMETHODIMP CGenObject::GetData
	(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
	VDATEHEAP();

	SCODE sc;
	
	if (IsBlank())
	{
		sc = OLE_E_BLANK;
	}
	else if (pformatetcIn->cfFormat != m_cfFormat)
	{

		if (m_cfFormat == CF_DIB &&
			pformatetcIn->cfFormat == CF_BITMAP)
		{
			return GetBitmapData(pformatetcIn, pmedium);
		}
		else
		{
			sc = DV_E_CLIPFORMAT;
		}
	}
	else if (0 == (pformatetcIn->tymed & TYMED_HGLOBAL))
	{
		sc = DV_E_TYMED;
	}
	else
	{
		if (NULL == (pmedium->hGlobal = GetCopyOfHPRES()))
		{
			sc = E_OUTOFMEMORY;
			goto errRtn;
		}
		
		pmedium->tymed = TYMED_HGLOBAL;
		return NOERROR;
	}
	
errRtn:
	// null out in case of error
	pmedium->tymed = TYMED_NULL;
	pmedium->pUnkForRelease = NULL;
	return ResultFromScode(sc);
}


//+-------------------------------------------------------------------------
//
//  Member:     CGenObject::GetDataHere
//
//  Synopsis:   retrieves presentation data into the given pmedium
//
//  Effects:
//
//  Arguments:  [pformatetcIn]  -- the requested data format
//              [pmedium]       -- where to put the data
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:  copies presentation data into the given storage medium
//              after error checking on the arguments
//
//  History:    dd-mmm-yy Author    Comment
//              23-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CGenObject_GetDataHere)
STDMETHODIMP CGenObject::GetDataHere
	(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
	VDATEHEAP();

	SCODE scode = S_OK;

	if (pformatetcIn->cfFormat != m_cfFormat)
	{
		scode = DV_E_CLIPFORMAT;
	}
	else if (pmedium->tymed != TYMED_HGLOBAL
		&& pmedium->tymed != TYMED_ISTREAM)
	{
		scode = DV_E_TYMED;
	}
	else if (pmedium->hGlobal == NULL)
	{
		scode = E_INVALIDARG;
	}
	else if (IsBlank())
	{
		scode = OLE_E_BLANK;
	}
	else    // actually get the data now
	{
		if (pmedium->tymed == TYMED_HGLOBAL)
		{
			// check the size of the given pmedium and then
			// copy the data into it
			LPVOID  lpsrc = NULL;
			LPVOID  lpdst = NULL;
			DWORD   dwSizeDst;

			scode = E_OUTOFMEMORY;

			if (0 == (dwSizeDst = (DWORD) GlobalSize(pmedium->hGlobal)))
			{
				goto errRtn;
			}

			// not enough room to copy
			if (dwSizeDst  < m_dwSize)
			{
				goto errRtn;
			}
	
			if (NULL == (lpdst = (LPVOID) GlobalLock(pmedium->hGlobal)))
			{
				goto errRtn;
			}
	
			if (NULL == (lpsrc = (LPVOID) GlobalLock(M_HPRES())))
			{
				goto errMem;
			}
		
			_xmemcpy(lpdst, lpsrc, m_dwSize);
			scode = S_OK;
		
		errMem:
			if (lpdst)
			{
				GlobalUnlock(pmedium->hGlobal);
			}
			if (lpsrc)
			{
				GlobalUnlock(m_hPres);
			}
			
		}
		else
		{
			Assert(pmedium->tymed == TYMED_ISTREAM);
			if (m_cfFormat == CF_DIB)
			{
				return UtHDIBToDIBFileStm(M_HPRES(),
						m_dwSize,pmedium->pstm);
			}
			else
			{
				return UtHGLOBALtoStm(M_HPRES(),
						m_dwSize, pmedium->pstm);
			}
		}
	}
	
errRtn:
	return ResultFromScode(scode);
}


//+-------------------------------------------------------------------------
//
//  Member:     CGenObject::SetDataWDO
//
//  Synopsis:   Takes the given presentation data and stores it
//
//  Effects:
//
//  Arguments:  [pformatetc]    -- the format of the data
//              [pmedium]       -- the new presentation data
//              [fRelease]      -- if TRUE, then we keep the data, else
//                                 we keep a copy
//              [pDataObj]      -- pointer to the IDataObject, may be NULL
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              23-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenObject::SetDataWDO
	(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium, BOOL fRelease, IDataObject * pDataObj)
{
	VDATEHEAP();

	HRESULT         error;
	BOOL            fTakeData = FALSE;
	
	if (pformatetc->cfFormat != m_cfFormat)
	{
		if (m_cfFormat == CF_DIB && pformatetc->cfFormat == CF_BITMAP)
		{
			return SetBitmapData(pformatetc, pmedium, fRelease, pDataObj);
		}
		else
		{
			return ResultFromScode(DV_E_CLIPFORMAT);
		}
	}

	
	if (pmedium->tymed != TYMED_HGLOBAL)
	{
		return ResultFromScode(DV_E_TYMED);
	}

	if ((pmedium->pUnkForRelease == NULL) && fRelease)
	{
		// we can take the ownership of the data
		fTakeData = TRUE;
	}

	// ChangeData will keep the data if fRelease is TRUE, else it copies
	error = ChangeData (pmedium->hGlobal, fTakeData);

	if (fTakeData)
	{
		pmedium->tymed = TYMED_NULL;
	}
	else if (fRelease)
	{
		ReleaseStgMedium(pmedium);
	}

	return error;
}

//+-------------------------------------------------------------------------
//
//  Member:     CGenObject::ChangeData   (private)
//
//  Synopsis:   Replaces the stored presentation
//
//  Effects:
//
//  Arguments:  [hNewData]      -- the new presentation
//              [fDelete]       -- if TRUE, then free hNewData
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              23-Nov-93 alexgo    32bit port
//  Notes:
//
// If the routine fails then the object will be left with it's old data.
// In case of failure if fDelete is TRUE, then hNewData will be freed.
//
//--------------------------------------------------------------------------

#pragma SEG(CGenObject_ChangeData)
INTERNAL CGenObject::ChangeData (HANDLE hNewData, BOOL fDelete)
{
	VDATEHEAP();

	HRESULT         hresult = ResultFromScode(E_OUTOFMEMORY);
	
	if (!hNewData)
	{
		return ResultFromScode(OLE_E_BLANK);
	}

	if (!fDelete)
	{
		if (NULL == (hNewData = UtDupGlobal(hNewData, GMEM_MOVEABLE)))
		{
			return hresult;
		}
	}
	else
	{
		HANDLE          hTmp;
		
		// change the ownership to yourself

                hTmp = GlobalReAlloc (hNewData, 0L, GMEM_MODIFY|GMEM_SHARE);
		if (NULL == hTmp)
		{
			if (NULL == (hTmp = UtDupGlobal(hNewData, GMEM_MOVEABLE)))
			{
				goto errRtn;
			}
			
			// Realloc failed but copying succeeded. Since this is fDelete
			// case, free the source global handle.
			LEVERIFY( NULL == GlobalFree(hNewData));
		}
		
		hNewData = hTmp;
	}

#ifndef _MAC

	// CF_DIB format specific code.  Get the it's extents
	if (m_cfFormat == CF_DIB)
	{
		LPBITMAPINFOHEADER      lpBi;

		if (NULL == (lpBi = (LPBITMAPINFOHEADER) GlobalLock (hNewData)))
		{
			goto errRtn;
		}
	
		UtGetDibExtents (lpBi, &m_lWidth, &m_lHeight);
		GlobalUnlock (hNewData);
	}
	
#endif

	// free the old presentation
	if (m_hPres)
	{
		LEVERIFY( NULL == GlobalFree (m_hPres));
	}

	// store the new presentation in m_hPres
	m_dwSize  = (DWORD) GlobalSize (m_hPres = hNewData);
	
	return NOERROR;
	
errRtn:
	if (hNewData && fDelete)
	{
		LEVERIFY( NULL == GlobalFree (hNewData));
	}

	return hresult;
}



//+-------------------------------------------------------------------------
//
//  Member:     CGenObject::Draw
//
//  Synopsis:   Calls DibDraw to draw the stored bitmap presentation
//
//  Effects:
//
//  Arguments:  [pvAspect]      -- drawing aspect
//              [hicTargetDev]  -- the target device
//              [hdcDraw]       -- the device context
//              [lprcBounds]    -- drawing boundary
//              [lprcWBounds]   -- boundary rectangle for metafiles
//              [pfnContinue]   -- callback function to periodically call
//                                 for long drawing operations
//              [dwContinue]    -- argument to be passed to pfnContinue
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              23-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CGenObject_Draw)
STDMETHODIMP CGenObject::Draw(void *    /* UNUSED pvAspect      */,
			      HDC       /* UNUSED hicTargetDev  */,
			      HDC       hdcDraw,
			      LPCRECTL  lprcBounds,
			      LPCRECTL  /* UNUSED lprcWBounds   */,
			      BOOL (CALLBACK * /*UNUSED pfcCont*/)(ULONG_PTR),
			      ULONG_PTR     /* UNUSED dwContinue    */)
{
	VDATEHEAP();

#ifndef _MAC
	if (m_cfFormat == CF_DIB)
	{
		return DibDraw (M_HPRES(), hdcDraw,lprcBounds);
	}
#endif

	return ResultFromScode(E_NOTIMPL);
}

//+-------------------------------------------------------------------------
//
//  Member:     CGenObject::Load
//
//  Synopsis:   Loads a stored presentation object from the given stream
//
//  Effects:
//
//  Arguments:  [lpstream]              -- the stream from which to load
//              [fReadHeaderOnly]       -- if TRUE, only get header info
//                                         (such as size, width, height, etc)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              23-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenObject::Load(LPSTREAM lpstream, BOOL fReadHeaderOnly)
{
	VDATEHEAP();

	DWORD           dwBuf[4];
	HRESULT         error;
	
	/* read dwCompression, width, height, size of data */
	error = StRead(lpstream, dwBuf, 4 * sizeof(DWORD));
	if (error)
	{
		return error;
	}

	// we don't allow for compression yet
	AssertSz (dwBuf[0] == 0, "Picture compression factor is non-zero");
	
	m_lWidth  = (LONG) dwBuf[1];
	m_lHeight = (LONG) dwBuf[2];
	m_dwSize  = dwBuf[3];


	if (!m_dwSize || fReadHeaderOnly)
	{
		return NOERROR;
	}

	return UtGetHGLOBALFromStm(lpstream, m_dwSize, &m_hPres);
}


//+-------------------------------------------------------------------------
//
//  Member:     CGenObject::Save
//
//  Synopsis:   Stores presentation data to the given stream
//
//  Effects:
//
//  Arguments:  [lpstream]      -- where to store the data
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              23-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenObject::Save(LPSTREAM lpstream)
{
	VDATEHEAP();

	HRESULT         error;
	DWORD           dwBuf[4];

	/* write dwCompression, width, height, size of data */

	dwBuf[0]  = 0L;
	dwBuf[1]  = (DWORD) m_lWidth;
	dwBuf[2]  = (DWORD) m_lHeight;
	dwBuf[3]  = m_dwSize;

        error = StWrite(lpstream, dwBuf, 4*sizeof(DWORD));
	if (error)
	{
		return error;
	}

	// if we're blank or don't have any presentation data, then
	// nothing to else to save.
	if (IsBlank() || m_hPres == NULL)
	{
		StSetSize(lpstream, 0, TRUE);
		return NOERROR;
	}

	return UtHGLOBALtoStm(m_hPres, m_dwSize, lpstream);
}


//+-------------------------------------------------------------------------
//
//  Member:     CGenObject::GetExtent
//
//  Synopsis:   retrieves the size (width/height) of the presentation bitmap
//
//  Effects:
//
//  Arguments:  [dwDrawAspect]  -- the drawing aspect the caller is
//                                 interested in
//              [lpsizel]       -- where to put the size extents
//
//  Requires:
//
//  Returns:    HRESULT  (NOERROR, DV_E_DVASPECT, OLE_E_BLANK)
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:  retrieves the stored dimensions
//
//  History:    dd-mmm-yy Author    Comment
//              23-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CGenObject_GetExtent)
STDMETHODIMP CGenObject::GetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
	VDATEHEAP();

	// aspects must match
	if (!(dwDrawAspect & m_dwAspect))
	{
		return ResultFromScode(DV_E_DVASPECT);
	}

	if (IsBlank())
	{
		return ResultFromScode(OLE_E_BLANK);
	}
	
	lpsizel->cx = m_lWidth;
	lpsizel->cy = m_lHeight;
	
	if (lpsizel->cx || lpsizel->cy)
	{
		return NOERROR;
	}
	else
	{
		return ResultFromScode(OLE_E_BLANK);
	}
}


//+-------------------------------------------------------------------------
//
//  Member:     CGenObject::GetColorSet
//
//  Synopsis:   Retrieves the pallette associated with the bitmap
//
//  Effects:
//
//  Arguments:  [pvAspect]      -- the drawing aspect  (unused)
//              [hicTargetDev]  -- the target device (unused)
//              [ppColorSet]    -- where to put the new palette
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:  Allocates a new pallette and copies the bitmap
//              palette into it.
//
//  History:    dd-mmm-yy Author    Comment
//              23-Nov-93 alexgo    32bit port, fixed bad memory bugs
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenObject::GetColorSet(LPVOID         /* UNUSED pvAspect     */,
                                     HDC            /* UNUSED hicTargetDev */,
                                     LPLOGPALETTE * ppColorSet)
{
    VDATEHEAP();

    HRESULT hresult = ResultFromScode(S_FALSE);

    if (m_cfFormat == CF_DIB)
    {
	if (IsBlank())
	{
	    return ResultFromScode(OLE_E_BLANK);
	}

	LPBITMAPINFOHEADER      lpbmih;
	LPLOGPALETTE            lpLogpal;
	WORD                    wPalSize;
		
	if (NULL == (lpbmih = (LPBITMAPINFOHEADER) GlobalLock (M_HPRES())))
	{
	    return ResultFromScode(E_OUTOFMEMORY);
	}

	// A bitmap with more than 8 bpp cannot have a palette at all,
	// so we just return S_FALSE

	if (lpbmih->biBitCount > 8)
	{
	    goto errRtn;
	}

	// Note: the return from UtPaletteSize can overflow the WORD
	// wPalSize, but utPaletteSize asserts against this
                			
	if (0 == (wPalSize = (WORD) UtPaletteSize(lpbmih)))
	{
	    goto errRtn;
	}
	
	lpLogpal = (LPLOGPALETTE)PubMemAlloc(wPalSize +
				2*sizeof(WORD));
	if (lpLogpal == NULL)
	{
	    hresult = ResultFromScode(E_OUTOFMEMORY);
	    goto errRtn;
	}
	
	DibFillPaletteEntries((BYTE FAR *)++lpbmih, wPalSize, lpLogpal);
	*ppColorSet = lpLogpal;
	hresult = NOERROR;

    errRtn:
	GlobalUnlock(m_hPres);
	return hresult;
    }

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Member:     CGenObject::IsBlank
//
//  Synopsis:   returns TRUE if the presentation is blank
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    TRUE/FALSE
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              23-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CGenObject_IsBlank)
STDMETHODIMP_(BOOL) CGenObject::IsBlank(void)
{
	VDATEHEAP();

    return (m_dwSize ? FALSE : TRUE);
}

//+-------------------------------------------------------------------------
//
//  Member:     CGenObject::LoadHPRES  (private)
//
//  Synopsis:   Loads the presentation from the internal cache's stream
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    HANDLE (to the presentation)
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              23-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

INTERNAL_(HANDLE) CGenObject::LoadHPRES()
{
	VDATEHEAP();

	LPSTREAM pstm;

        pstm = m_pCacheNode->GetStm(TRUE /*fSeekToPresBits*/, STGM_READ);
	if (pstm)
	{
		LEVERIFY( SUCCEEDED(Load(pstm)));
		pstm->Release();
	}
	
	return m_hPres;
}

//+-------------------------------------------------------------------------
//
//  Member:     CGenObject::DiscardHPRES
//
//  Synopsis:   Deletes the object's presentation
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              23-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(void) CGenObject::DiscardHPRES(void)
{
	VDATEHEAP();

	if (m_hPres)
	{
		LEVERIFY( NULL == GlobalFree(m_hPres));
		m_hPres = NULL;
	}
}

//+-------------------------------------------------------------------------
//
//  Member:     CGenObject::GetCopyOfHPRES (private)
//
//  Synopsis:   Returns a handle to a copy of the presentation data
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    HANDLE
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:  makes a copy of m_hPres if not NULL, otherwise loads it
//              from the stream (without setting m_hPres)
//
//  History:    dd-mmm-yy Author    Comment
//              23-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

INTERNAL_(HANDLE) CGenObject::GetCopyOfHPRES()
{
	VDATEHEAP();

	HANDLE  hPres;
	
	// Make a copy if the presentation data is already loaded
	if (m_hPres)
	{
		return(UtDupGlobal(m_hPres, GMEM_MOVEABLE));
	}

	// Load the presentation data now and return the same handle.
	// No need to copy the data. If the caller wants the m_hPres to be
	// set he would call LoadHPRES() directly.

	hPres = LoadHPRES();
	m_hPres = NULL;
	return hPres;
}

//+-------------------------------------------------------------------------
//
//  Member:     CGenObject::GetBitmapData (private)
//
//  Synopsis:   Gets bitmap data from a dib
//
//  Effects:
//
//  Arguments:  [pformatetcIn]  -- the requested format
//              [pmedium]       -- where to put the data
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:  checks the parameters, then calls UtConvertDibtoBitmap
//              to get raw bitmap data from the device-independent bitmap
//
//  History:    dd-mmm-yy Author    Comment
//              23-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------
#ifndef _MAC

#pragma SEG(CGenObject_GetBitmapData)
INTERNAL CGenObject::GetBitmapData
	(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
	VDATEHEAP();

	SCODE sc = E_OUTOFMEMORY;
	
	if (0 == (pformatetcIn->tymed & TYMED_GDI))
	{
		sc = DV_E_TYMED;
	}

	pmedium->pUnkForRelease = NULL;

        pmedium->hGlobal = UtConvertDibToBitmap(M_HPRES());

        // if pmedium->hGlobal is not NULL, then UtConvertDibToBitmap succeeded
        // so the tymed needs to be set appropriately, and the return value
        // changed to S_OK.
        if (NULL != pmedium->hGlobal)
	{
		pmedium->tymed = TYMED_GDI;
		sc = S_OK;
	}
	else
	{
		pmedium->tymed = TYMED_NULL;
	}
	
	return ResultFromScode(sc);
}


//+-------------------------------------------------------------------------
//
//  Member:     CGenObject::SetBitmapData (private)
//
//  Synopsis:   Converts bitmap data to a dib and stores it in [this]
//              presenatation object
//
//  Effects:
//
//  Arguments:  [pformatetc]    -- the format of the data
//              [pmedium]       -- the data
//              [fRelease]      -- if TRUE, then pmedium will be free'd
//
//  Returns:    HRESULT
//
//  Algorithm:  calls UtConvertBitmapToDib and stores the result
//
//  History:    dd-mmm-yy Author    Comment
//              07-Jul-94 DavePl    Added CF_PALETTE support
//
//  Notes:      if [fRelease] == TRUE, then [pmedium] is released, even
//              if a dib could not be built
//
//--------------------------------------------------------------------------

INTERNAL CGenObject::SetBitmapData(LPFORMATETC   pformatetc,
				   STGMEDIUM   * pmedium,
				   BOOL          fRelease,
				   IDataObject * pDataObject)
{
	VDATEHEAP();

	HGLOBAL         hDib;
		
	if (pmedium->tymed != TYMED_GDI)
	{
		return ResultFromScode(DV_E_TYMED);
	}

	// If we have a data object and if we can get the palette from it,
	// use that to do the bitmap -> dib conversion.  Otherwise, just
	// pass a NULL palette along and the default one will be used

	STGMEDIUM   stgmPalette;
	FORMATETC   fetcPalette = {
				    CF_PALETTE,
				    NULL,
				    pformatetc->dwAspect,
				    DEF_LINDEX,
				    TYMED_GDI
				  };
	

	if (pDataObject && SUCCEEDED(pDataObject->GetData(&fetcPalette, &stgmPalette)))
	{
	    hDib = UtConvertBitmapToDib((HBITMAP)pmedium->hGlobal,
					(HPALETTE) stgmPalette.hGlobal);
	    ReleaseStgMedium(&stgmPalette);
	}
	else
	{
	    hDib = UtConvertBitmapToDib((HBITMAP)pmedium->hGlobal, NULL);
	}

	if (fRelease)
	{
		ReleaseStgMedium(pmedium);
	}

	if (!hDib)
	{
		return ResultFromScode(E_OUTOFMEMORY);
	}
	
	FORMATETC foretcTmp = *pformatetc;
	STGMEDIUM pmedTmp = *pmedium;
	
	foretcTmp.cfFormat = CF_DIB;
	foretcTmp.tymed = TYMED_HGLOBAL;
	
	pmedTmp.pUnkForRelease = NULL;
	pmedTmp.tymed = TYMED_HGLOBAL;
	pmedTmp.hGlobal = hDib;

	// Now that we have converted the bitmap data to DIB,
	// SetData _back_ on ourselves again with the DIB info
		
	return SetDataWDO(&foretcTmp, &pmedTmp, TRUE, NULL);
}

//+-------------------------------------------------------------------------
//
//  Member:     CGenObject::Dump, public (_DEBUG only)
//
//  Synopsis:   return a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [ppszDump]      - an out pointer to a null terminated character array
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   [ppszDump]  - argument
//
//  Derivation:
//
//  Algorithm:  use dbgstream to create a string containing information on the
//              content of data structures
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

HRESULT CGenObject::Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    char *pszDVASPECT;
    char *pszCLIPFORMAT;
    dbgstream dstrPrefix;
    dbgstream dstrDump(500);

    // determine prefix of newlines
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << this << " _VB ";
    }

    // determine indentation prefix for all newlines
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    dstrDump << pszPrefix << "No. of References     = " << m_ulRefs         << endl;

    pszDVASPECT = DumpDVASPECTFlags(m_dwAspect);
    dstrDump << pszPrefix << "Aspect flags          = " << pszDVASPECT      << endl;
    CoTaskMemFree(pszDVASPECT);

    dstrDump << pszPrefix << "Size                  = " << m_dwSize         << endl;

    dstrDump << pszPrefix << "Width                 = " << m_lWidth         << endl;

    dstrDump << pszPrefix << "Height                = " << m_lHeight        << endl;

    dstrDump << pszPrefix << "Presentation Handle   = " << m_hPres          << endl;

    pszCLIPFORMAT = DumpCLIPFORMAT(m_cfFormat);
    dstrDump << pszPrefix << "Clip Format           = " << pszCLIPFORMAT    << endl;
    CoTaskMemFree(pszCLIPFORMAT);

    dstrDump << pszPrefix << "pCacheNode            = " << m_pCacheNode     << endl;

    // cleanup and provide pointer to character array
    *ppszDump = dstrDump.str();

    if (*ppszDump == NULL)
    {
        *ppszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return NOERROR;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCGenObject, public (_DEBUG only)
//
//  Synopsis:   calls the CGenObject::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pGO]           - pointer to CGenObject
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCGenObject(CGenObject *pGO, ULONG ulFlag, int nIndentLevel)
{
    HRESULT hresult;
    char *pszDump;

    if (pGO == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    hresult = pGO->Dump(&pszDump, ulFlag, nIndentLevel);

    if (hresult != NOERROR)
    {
        CoTaskMemFree(pszDump);

        return DumpHRESULT(hresult);
    }

    return pszDump;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DibDraw
//
//  Synopsis:   Draws a device independent bitmap
//
//  Effects:
//
//  Arguments:  [hDib]          -- the bitmap
//              [hdc]           -- the device context
//              [lprc]          -- the bounding rectangle
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Sets the palette to the palette in the dib, sizes and draws
//              the dib to the bounding rectangle.  The original palette
//              is then restored
//
//  History:    dd-mmm-yy Author    Comment
//              23-Nov-93 alexgo    32bit port
//              07-Dec-93 alexgo    merged RC9 16bit changes.  The
//                                  error-handling code used to reset the
//                                  old palette and then RealizePalette.
//                                  The call to RealizePalette was removed
//              11-May-94 davepl    Added support for BITMAPCOREINFO dibs
//              17-Jul-94 davepl    Added 12, 32 bpp support
//
//  Notes:
//
//--------------------------------------------------------------------------

INTERNAL DibDraw (HANDLE hDib, HDC hdc, LPCRECTL lprc)
{
	VDATEHEAP();

	HRESULT                 error       = ResultFromScode(E_DRAW);
	BYTE FAR *              lpDib;
	HANDLE                  hPalette    = NULL;
	HPALETTE                hLogPalette = NULL,
				hOldPalette = NULL;
	LPLOGPALETTE            lpLogPalette;
	WORD                    wPalSize;
	DWORD                   cbHeaderSize;
	BOOL                    fNeedPalette = FALSE;
	WORD                    iHeight;
	WORD                    iWidth;
	int                     iOffBits;
	BITMAPINFO *            pbi         = NULL;
	BOOL                    fWeAllocd   = FALSE;

	if (NULL == hDib)
	{
		return ResultFromScode(OLE_E_BLANK);
	}

	Assert(lprc);

	if (NULL == (lpDib = (BYTE FAR *) GlobalLock (hDib)))
	{
		return  ResultFromScode(E_OUTOFMEMORY);
	}

	// The bitmap header could be BITMAPINFOHEADER or
	// BITMAPCOREHEADER.  Set our cbHeaderSize flag
	// based on the header type.  We can then calculate the
	// palette size and the offset to the raw data bits.  If
	// we don't recognize either one of the structures here,
	// we bail; the data is likely corrupt.

	// Just a thought here: could be dangerous if the struct
	// is not LONG aligned and this is run on an Alpha.  As far
	// as I've been able to find out, they always are long
	// aligned

        cbHeaderSize = *((ULONG *) lpDib);
        LEWARN( cbHeaderSize > 500, "Struct size > 500, likely invalid!");
	
	if (cbHeaderSize == sizeof(BITMAPINFOHEADER))
	{
                // Note: this assignment can overflow the WORD wPalSize,
                // but the UtPaletteSize function asserts against this

		wPalSize = (WORD) UtPaletteSize((LPBITMAPINFOHEADER)lpDib);

		iWidth   = (WORD) ((LPBITMAPINFOHEADER)lpDib)->biWidth;
		iHeight  = (WORD) ((LPBITMAPINFOHEADER)lpDib)->biHeight;
		pbi      = (LPBITMAPINFO) lpDib;
		iOffBits = wPalSize + sizeof(BITMAPINFOHEADER);
	}
	else if (cbHeaderSize == sizeof(BITMAPCOREHEADER))
	{

// Since the clipboard itself does not support COREINFO
// bitmaps, we will not support them in the presentation
// cache.  When (if) windows adds complete support for
// these, the code is here and ready.

#ifndef CACHE_SUPPORT_COREINFO
		error = DV_E_TYMED;
		goto errRtn;
#else

		// Special case 32 bpp bitmaps

		// If we have a palette, we need to calculate its size and
		// allocate enough memory for the palette entries (remember
		// we get one entry for free with the BITMAPINFO struct, so
		// less one).  If we don't have a palette, we only need to
		// allocate enough for the BITMAPINFO struct itself.

		// Bitmaps with more than 64K colors lack a palette; they
		// use direct RGB entries in the pixels

		if ((((LPBITMAPCOREHEADER)lpDib)->bcBitCount) > 16)
		{
			wPalSize = 0;
			pbi = (BITMAPINFO *) PrivMemAlloc(sizeof(BITMAPINFO));
		}
		else
		{
			wPalSize = sizeof(RGBQUAD) *
				   (1 << (((LPBITMAPCOREHEADER)lpDib)->bcBitCount));
			pbi = (BITMAPINFO *) PrivMemAlloc(sizeof(BITMAPINFO)
				    + wPalSize - sizeof(RGBQUAD));
		}
		
		if (NULL == pbi)
		{
			return ResultFromScode(E_OUTOFMEMORY);
		}
		else
		{
			fWeAllocd = TRUE;
		}

			
		// Grab the width and height
		iWidth   = ((LPBITMAPCOREHEADER)lpDib)->bcWidth;
		iHeight  = ((LPBITMAPCOREHEADER)lpDib)->bcHeight;
		
		// Clear all the fields.  Don't worry about color table, as if
		// it exists we will set the entries explicitly.

		memset(pbi, 0, sizeof(BITMAPINFOHEADER));

		// Transfer what fields we do have from the COREINFO

		pbi->bmiHeader.biSize     = sizeof(BITMAPINFOHEADER);
		pbi->bmiHeader.biWidth    = iWidth;
		pbi->bmiHeader.biHeight   = iHeight;
		pbi->bmiHeader.biPlanes   = 1;
		pbi->bmiHeader.biBitCount = ((LPBITMAPCOREHEADER)lpDib)->bcBitCount;

		// Set up the color palette, if required.
		// Note that we must translate from RGBTRIPLE entries to
		// RGBQUAD.

		for (WORD c = 0; c < wPalSize / sizeof(RGBQUAD); c++)
		{
			pbi->bmiColors[c].rgbRed   = ((BITMAPCOREINFO *)lpDib)->bmciColors[c].rgbtRed;
			pbi->bmiColors[c].rgbBlue  = ((BITMAPCOREINFO *)lpDib)->bmciColors[c].rgbtBlue;
			pbi->bmiColors[c].rgbGreen = ((BITMAPCOREINFO *)lpDib)->bmciColors[c].rgbtGreen;
			pbi->bmiColors[c].rgbReserved = 0;
		}
	
		iOffBits = wPalSize + sizeof(BITMAPCOREHEADER);
#endif
	}
	else
	{
		error = E_FAIL;
		goto errRtn;
	}
		
	// if color info exists, create a palette from the data and select it
	// images with < 16 bpp do not have a palette from which we can create
	// a logical palette

	fNeedPalette = ((LPBITMAPINFOHEADER)lpDib)->biBitCount < 16;
	if (wPalSize && fNeedPalette)
	{
                hLogPalette = (HPALETTE)DibMakeLogPalette(lpDib + cbHeaderSize,
					                  wPalSize,
					                  &lpLogPalette);		
		if (NULL == hLogPalette)
		{
			error = ResultFromScode(E_OUTOFMEMORY);
			goto errRtn;
		}


		if (NULL == (hPalette = CreatePalette (lpLogPalette)))
		{
			goto errRtn;
		}

		// we're done with lpLogPalette now, so unlock it
		// (DibMakeLogPalette got the pointer via a GlobalLock)

		GlobalUnlock(hLogPalette);
		
		// select as a background palette
		hOldPalette = SelectPalette (hdc, (HPALETTE)hPalette, TRUE);
		if (NULL == hOldPalette)
		{
			goto errRtn;
		}

		LEVERIFY( 0 < RealizePalette(hdc) );
	}

	
	// size the dib to fit our drawing rectangle and draw it

	if (!StretchDIBits( hdc,                        // HDC
			    lprc->left,                 // XDest
			    lprc->top,                  // YDest
			    lprc->right - lprc->left,   // nDestWidth
			    lprc->bottom - lprc->top,   // nDestHeight
			    0,                          // XSrc
			    0,                          // YSrc
			    iWidth,                     // nSrcWidth
			    iHeight,                    // nSrcHeight
			    lpDib + iOffBits,           // lpBits
			    pbi,                        // lpBitsInfo
			    DIB_RGB_COLORS,             // iUsage
			    SRCCOPY                     // dwRop
			   )
	   )
	{
		error = ResultFromScode(E_DRAW);
	}
	else
	{
		error = NOERROR;
	}

errRtn:

	// We only want to free the header if it is was one which we allocated,
	// which can only happen when we were give a core header type in the
	// first place
		
	if (fWeAllocd)
	{
		PrivMemFree(pbi);
	}

	if (lpDib)
	{
		GlobalUnlock (hDib);
	}
	
	// if color palette exists do the following
	if (fNeedPalette)
	{
		hOldPalette = (HPALETTE)(OleIsDcMeta (hdc) ?
				GetStockObject(DEFAULT_PALETTE)
				: (HPALETTE)hOldPalette);
				
		if (hOldPalette)
		{
			LEVERIFY( SelectPalette (hdc, hOldPalette, TRUE) );
			// Do we need to realize the palette? [Probably not]
		}

		if (hPalette)
		{
			LEVERIFY( DeleteObject (hPalette) );
		}

		if (hLogPalette)
		{
			LEVERIFY( NULL == GlobalFree (hLogPalette) );
		}
	}

	return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   DibMakeLogPalette
//
//  Synopsis:   Makes a logical palette from a byte array of color info
//
//  Effects:
//
//  Arguments:  [lpColorData]           -- the color data
//              [wDataSize]             -- size of the data
//              [lplpLogPalette]        -- where to put a pointer to the
//
//  Requires:
//
//  Returns:    HANDLE to the logical palette (must be global unlock'ed
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              23-Nov-93 alexgo    32bit port
//
//  Notes:      The caller MUST call GlobalUnlock on the returned handle
//              to avoid a memory leak  (*lplpLogPalette is the result
//              of a global lock on the handle)
//
//--------------------------------------------------------------------------

#pragma SEG(DibMakeLogPalette)
INTERNAL_(HANDLE) DibMakeLogPalette(
	BYTE FAR * lpColorData, WORD wDataSize,
	LPLOGPALETTE FAR *lplpLogPalette)
{
	VDATEHEAP();

	HANDLE          hLogPalette=NULL;
	LPLOGPALETTE    lpLogPalette;
	DWORD           dwLogPalSize = wDataSize +  2 * sizeof(WORD);

	if (NULL == (hLogPalette = GlobalAlloc(GMEM_MOVEABLE, dwLogPalSize)))
	{
		return NULL;
	}

	if (NULL == (lpLogPalette = (LPLOGPALETTE) GlobalLock (hLogPalette)))
	{
		LEVERIFY( NULL == GlobalFree (hLogPalette));
		return NULL;
	}

	*lplpLogPalette = lpLogPalette;
	DibFillPaletteEntries(lpColorData, wDataSize, lpLogPalette);
	return hLogPalette;
}

//+-------------------------------------------------------------------------
//
//  Function:   DibFillPaletteEntries
//
//  Synopsis:   Fills the logical palette with the color info in [lpColorData]
//
//  Effects:
//
//  Arguments:  [lpColorData]   -- the color info
//              [wDataSize]     -- the size of the color info
//              [lpLogPalette]  -- the logical palette
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              23-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

INTERNAL_(void) DibFillPaletteEntries(
	BYTE FAR * lpColorData, WORD wDataSize, LPLOGPALETTE lpLogPalette)
{
	VDATEHEAP();

	LPPALETTEENTRY  lpPE;
	RGBQUAD FAR *   lpQuad;

	lpLogPalette->palVersion = 0x300;
	lpLogPalette->palNumEntries = wDataSize / sizeof(PALETTEENTRY);

	/* now convert RGBQUAD to PALETTEENTRY as we copy color info */
	for (lpQuad = (RGBQUAD far *)lpColorData,
		lpPE   = (LPPALETTEENTRY)lpLogPalette->palPalEntry,
		wDataSize /= sizeof(RGBQUAD);
		wDataSize--;
		++lpQuad,++lpPE)
	{
		lpPE->peFlags           = NULL;
		lpPE->peRed             = lpQuad->rgbRed;
		lpPE->peBlue            = lpQuad->rgbBlue;
		lpPE->peGreen           = lpQuad->rgbGreen;
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\stdimpl\defutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       defutil.h
//
//  Contents:   Declarations for utility functions used in the default
//              handler and default link
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              20-Nov-93 alexgo    32bit port
//
//--------------------------------------------------------------------------

#if !defined( _DEFUTIL_H_ )
#define _DEFUTIL_H_

INTERNAL_(void)         DuLockContainer(IOleClientSite FAR* pCS,
                                        BOOL fLockNew,
                                        BOOL FAR*pfLockCur);
INTERNAL                DuSetClientSite(BOOL fRunning,
                                        IOleClientSite FAR* pCSNew,
                                        IOleClientSite FAR* FAR* ppCSCur,
                                        BOOL FAR*pfLockCur);
INTERNAL_(void FAR*)    DuCacheDelegate(IUnknown FAR** ppUnk,
                                        REFIID iid,
                                        LPVOID FAR* ppv,
                                        IUnknown *pUnkOuter);


#define  GET_FROM_REGDB(scode)  \
        (((scode == OLE_S_USEREG) || (scode == RPC_E_CANTPOST_INSENDCALL) || \
	  (scode == RPC_E_CANTCALLOUT_INASYNCCALL) || \
	  (scode == RPC_E_CANTCALLOUT_INEXTERNALCALL) || \
	  (scode == RPC_E_CANTCALLOUT_ININPUTSYNCCALL) || \
          (scode == RPC_E_CALL_CANCELED) || (scode == RPC_E_CALL_REJECTED)) \
                 ?      TRUE : FALSE)


#endif // _DEFUTIL_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\stdimpl\icon.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	icon.h
//
//  Contents:	function declarations for manipulating icons (see icon.cpp)
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//		24-Nov-93 alexgo    32bit port
//
//--------------------------------------------------------------------------

#if !defined( _ICON_H )
#define _ICON_H_

#if !defined( IDS_DEFICONLABEL )
#define IDS_DEFICONLABEL    310
#endif

STDAPI_(int)        	XformWidthInHimetricToPixels(HDC, int);
STDAPI_(int)        	XformWidthInPixelsToHimetric(HDC, int);
STDAPI_(int)        	XformHeightInHimetricToPixels(HDC, int);
STDAPI_(int)        	XformHeightInPixelsToHimetric(HDC, int);

HICON FAR PASCAL    	HIconAndSourceFromClass(REFCLSID, LPOLESTR, 
				UINT FAR *);

BOOL FAR PASCAL		FIconFileFromClass(REFCLSID, LPOLESTR, UINT, 
				UINT FAR *);

LPOLESTR FAR PASCAL    	PointerToNthField(LPOLESTR, int, OLECHAR);

BOOL FAR PASCAL		GetAssociatedExecutable(LPOLESTR, LPOLESTR);

STDAPI_(UINT)		OleStdGetAuxUserType(REFCLSID 	rclsid,
                           		WORD   		wAuxUserType,
                                      	LPOLESTR  	lpszAuxUserType,
                                      	int    		cch,
                                      	HKEY   		hKey);

STDAPI_(UINT)		OleStdGetUserTypeOfClass(REFCLSID rclsid,
                                 	LPOLESTR 	lpszUserType,
                                    	UINT 		cch,
                                        HKEY 		hKey);

STDAPI_(UINT)		OleStdIconLabelTextOut(HDC     	hDC,
                                 	HFONT      	hFont,
                                 	int        	nXStart,
                                  	int        	nYStart,
                                   	UINT       	fuOptions,
                                  	RECT FAR * 	lpRect,
                                  	LPOLESTR      	lpszString,
                                   	UINT       	cchString,
                                  	int FAR *  	lpDX);

#endif // _ICON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\stdimpl\oregfmt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:   oregfmt.cpp
//
//  Contents:   Enumerator implementation for the regdb formatetc's
//
//  Classes:    CEnumFmt
//      CEnumFmt10
//
//  Functions:  OleRegEnumFormatEtc
//      
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  add Dump methods to CEnumFmt, CEnumFmt10
//                                  and add APIs DumpCEnumFmt, DumpCEnumFmt10
//                                  DumpFMT, DumpFMTCache
//      25-Jan-94 alexgo    first pass at converting to Cairo-style
//                  memory allocations.
//      11-Jan-94 alexgo    added VDATEHEAP macros to every function
//          31-Dec-93 erikgav   chicago port
//      01-Dec-93 alexgo    32bit port
//      12-Nov-92 jasonful  author
//
//--------------------------------------------------------------------------

#include <le2int.h>
#pragma SEG(oregfmt)

#include <reterr.h>
#include "oleregpv.h"
#include <ctype.h>
#include <string.h>

#ifdef _DEBUG
#include <dbgdump.h>
#endif // _DEBUG

ASSERTDATA

#define MAX_STR 256

#define UtRemoveRightmostBit(x) ((x)&((x)-1))
#define UtRightmostBit(x)   ((x)^UtRemoveRightmostBit(x))
#define UtIsSingleBit(x)    ((x) && (0==UtRemoveRightmostBit(x)))

// reg db key
static const LPCOLESTR DATA_FORMATS = OLESTR("DataFormats\\GetSet");

static INTERNAL CreateEnumFormatEtc10
    (REFCLSID clsid,
    DWORD dwDirection,
    LPENUMFORMATETC FAR* ppenum);


typedef struct FARSTRUCT
{
    FORMATETC   fmt;
    DWORD       dwAspects; // aspects not yet returned
    BOOL        fUseMe;  // is the cache valid?
} FMTCACHE;


//+-------------------------------------------------------------------------
//
//  Class:  CEnumFmt
//
//  Purpose:    FORMATETC enumerator for regdb formats
//
//  Interface:  IEnumFORMATETC
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

class FAR CEnumFmt : public IEnumFORMATETC, public CPrivAlloc
{
public:
        // *** IUnknown methods ***
        STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
        STDMETHOD_(ULONG,AddRef) (THIS);
        STDMETHOD_(ULONG,Release) (THIS);

        // *** IEnumFORMATETC methods ***
        STDMETHOD(Next) (THIS_ ULONG celt, FORMATETC FAR * rgelt,
            ULONG FAR* pceltFetched) ;
        STDMETHOD(Skip) (THIS_ ULONG celt) ;
        STDMETHOD(Reset) (THIS) ;
        STDMETHOD(Clone) (THIS_ LPENUMFORMATETC FAR* ppenum) ;

    CEnumFmt (LPOLESTR szClsid, DWORD dwDirection, DWORD iKey=0);
    STDMETHOD(OpenHKey) (HKEY FAR*);

    #ifdef _DEBUG
        HRESULT Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel);
    #endif // _DEBUG

    ULONG       m_cRef;
    LPOLESTR    m_szClsid;
    DWORD       m_dwDirection;
    DWORD       m_iKey ; // index of current key in reg db
    
    // We cannot keep an hkey open because Clone (or trying to use any 2
    // independent enumerators) would fail.
    FMTCACHE    m_cache;
};

// For OLE 1.0
typedef struct
{
    CLIPFORMAT cf;
    DWORD      dw;   // DATADIR_GET/SET
} FMT;

#ifdef _DEBUG
// for use in CEnumFmt[10] Dump methods
char *DumpFMT(FMT *pFMT, ULONG ulFlag, int nIndentLevel);
char *DumpFMTCACHE(FMTCACHE *pFMTC, ULONG ulFlag, int nIndentLevel);
#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Class:  CEnumFmt10 : CEnumFmt
//
//  Purpose:    Enumerates OLE1.0 formats
//
//  Interface:  IEnumFORMATETC
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

class FAR CEnumFmt10 : public CEnumFmt
{
public:
        STDMETHOD(Next) (THIS_ ULONG celt, FORMATETC FAR * rgelt,
            ULONG FAR* pceltFetched) ;
        STDMETHOD(Skip) (THIS_ ULONG celt) ;
        STDMETHOD(Clone) (THIS_ LPENUMFORMATETC FAR* ppenum) ;
        STDMETHOD_(ULONG,Release) (THIS) ;
    CEnumFmt10 (LPOLESTR szClsid, DWORD dwDirection, DWORD iKey=0);

    STDMETHOD(InitFromRegDb) (HKEY);
    STDMETHOD(InitFromScratch) (void);

    #ifdef _DEBUG
        HRESULT Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel);
    #endif // _DEBUG

    FMT FAR*    m_rgFmt;
    size_t      m_cFmt;     // number of Fmts in m_rgFmt
};


//+-------------------------------------------------------------------------
//
//  Member: CEnumFmt::CEnumFmt
//
//  Synopsis:   Constructor for the formatetc enumerator
//
//  Effects:
//
//  Arguments:  [szClsid]   -- the class id to look for
//      [dwDirection]   -- (either SET or GET)
//      [iKey]      -- index into the regdb (which formatetc)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumFmt_ctor)
CEnumFmt::CEnumFmt
    (LPOLESTR szClsid,
    DWORD  dwDirection,
    DWORD  iKey)
{
    VDATEHEAP();

    m_cRef      = 1;
    m_szClsid   = szClsid;
    m_iKey      = iKey;
    m_dwDirection   = dwDirection;
    m_cache.fUseMe  = FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumFmt10::CEnumFmt10
//
//  Synopsis:   Constructor for the 1.0 formatetc enumerator
//
//  Effects:
//
//  Arguments:  [szClsid]   -- the class id to look for
//      [dwDirection]   -- (either SET or GET)
//      [iKey]      -- index into the regdb (which formatetc)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumFmt10_ctor)
CEnumFmt10::CEnumFmt10
    (LPOLESTR szClsid,
    DWORD  dwDirection,
    DWORD  iKey)
    : CEnumFmt (szClsid, dwDirection, iKey)
{
    VDATEHEAP();

    m_rgFmt = NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   CreateEnumFormatEtc (static)
//
//  Synopsis:   Creates a 2.0 formatetc enumerator object
//
//  Effects:
//
//  Arguments:  [clsid]     -- the class ID to look for
//      [dwDirection]   -- the formatetc direction (SET or GET)
//      [ppenum]    -- where to put the enumerator
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Checks to make sure that the data exists in the reg db
//      and then allocates an enumerator object
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CreateEnumFormatEtc)
static INTERNAL CreateEnumFormatEtc
    (REFCLSID clsid,
    DWORD dwDirection,
    LPENUMFORMATETC FAR* ppenum)
{
    VDATEHEAP();

    OLECHAR     szKey[MAX_STR];
    LPOLESTR    szClsid = NULL;
    HKEY        hkey = NULL;
    HKEY        hkeyFmts = NULL;

    RetErr (StringFromCLSID (clsid, &szClsid));
    _xstrcpy (szKey, szClsidRoot);
    _xstrcat (szKey, szClsid);
    if (ERROR_SUCCESS != OpenClassesRootKey (szKey, &hkey))
    {           
        PubMemFree(szClsid);
        return ReportResult(0, REGDB_E_CLASSNOTREG, 0, 0);
    }

    if (ERROR_SUCCESS != RegOpenKeyEx (hkey, (LPOLESTR) DATA_FORMATS, 0, KEY_READ, &hkeyFmts))
    {
        CLOSE (hkey);
        PubMemFree(szClsid);
        return ReportResult(0, REGDB_E_KEYMISSING, 0, 0);
    }
    CLOSE (hkeyFmts);
    CLOSE (hkey);
    *ppenum = new FAR CEnumFmt (szClsid, dwDirection);
        // hook the new interface
        CALLHOOKOBJECTCREATE(S_OK,CLSID_NULL,IID_IEnumFORMATETC,
                             (IUnknown **)ppenum);
    // do not delete szClsid.  Will be deleted on Release
    return *ppenum ? NOERROR : ResultFromScode (E_OUTOFMEMORY);
}


//+-------------------------------------------------------------------------
//
//  Function:   OleRegEnumFormatEtc
//
//  Synopsis:   Creates a reg db formatetc enumerator
//
//  Effects:
//
//  Arguments:  [clsid]     -- the class ID we're interested in
//      [dwDirection]   -- either GET or SET (for the formatetc and
//                 IDataObject->[Get|Set]Data)
//      [ppenum]    -- where to put the enumerator  
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Creates either an OLE2 enumerator or an OLE1 enumerator
//
//  History:    dd-mmm-yy Author    Comment
//      29-Nov-93 ChrisWe   allow more than one DATADIR_* flag at a
//                  time
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleRegEnumFormatEtc)
STDAPI OleRegEnumFormatEtc
    (REFCLSID       clsid,
    DWORD           dwDirection,
    LPENUMFORMATETC FAR*    ppenum)
{
    OLETRACEIN((API_OleRegEnumFormatEtc, PARAMFMT("clsid= %I, dwDirection= %x, ppenum= %p"),
            &clsid, dwDirection, ppenum));

    VDATEHEAP();

    HRESULT hr;

    VDATEPTROUT_LABEL(ppenum, LPENUMFORMATETC, errRtn, hr);
    *ppenum = NULL;

    // check that dwDirection only has valid values
    if (dwDirection & ~(DATADIR_GET | DATADIR_SET))
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto errRtn;
    }

    if (CoIsOle1Class (clsid))
    {
        hr = CreateEnumFormatEtc10 (clsid, dwDirection, ppenum);
    }
    else
    {
        hr = CreateEnumFormatEtc (clsid, dwDirection, ppenum);
    }

errRtn:
    OLETRACEOUT((API_OleRegEnumFormatEtc, hr));

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CEnumFmt::OpenHKey
//
//  Synopsis:   Opens a the regdb and returns a handle to the formatetc's
//
//  Effects:
//
//  Arguments:  [phkey]     -- where to put the regdb handle
//
//  Requires:
//
//  Returns:    NOERROR, REGDB_E_KEYMISSING
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumFmt_OpenHKey)
STDMETHODIMP CEnumFmt::OpenHKey
    (HKEY FAR* phkey)
{
    VDATEHEAP();

    VDATEPTRIN (phkey, HKEY);
    OLECHAR     szBuf [MAX_STR];

    _xstrcpy (szBuf, szClsidRoot);
    _xstrcat (szBuf, m_szClsid);
    _xstrcat (szBuf, OLESTR("\\"));
    _xstrcat (szBuf, DATA_FORMATS);
    return ERROR_SUCCESS==OpenClassesRootKey (szBuf, phkey)
            ? NOERROR
            : ResultFromScode(REGDB_E_KEYMISSING);
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumFmt::Reset
//
//  Synopsis:   Resets the enumerator
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IEnumFormatEtc
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumFmt_Reset)
STDMETHODIMP CEnumFmt::Reset (void)
{
    VDATEHEAP();

    m_iKey = 0;
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumFmt::Skip
//
//  Synopsis:   Skips the next [c] formatetc's
//
//  Effects:
//
//  Arguments:  [c] -- number of formatetc's to skip
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IEnumFormatEtc
//
//  Algorithm:  just calls Next [c] times :)
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumFmt_Skip)
STDMETHODIMP CEnumFmt::Skip
    (ULONG c)
{
    VDATEHEAP();

    ULONG       i=0;
    FORMATETC   formatetc;
    HRESULT     hresult = NOERROR;

    while (i++ < c)
    {
        // There will not be a target device to free
        ErrRtnH (Next (1, &formatetc, NULL));
    }

  errRtn:
    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumFmt::Next
//
//  Synopsis:   Gets the next formatetc from teh regdb
//
//  Effects:
//
//  Arguments:  [cfmt]      -- the number of formatetc's to return
//      [rgfmt]     -- where to put the formatetc's
//      [pcfmtFetched]  -- where to put how many formatetc's were
//                 actually fetched
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IEnumFORMATETC
//
//  Algorithm:  In the reg db, apps may compactly specify that a formatetc
//      applies to multiple aspects by simply using the numeric
//      value of the aspects or'ed together.  Since our enumerator
//      should give one formatetc *per* aspect, if multiple aspects
//      are specified, then we cache the formatetc and use it the
//      next time a formatetc is requested (via next or [cfmt] > 1)
//      That's what the m_cache stuff is all about.
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:  
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumFmt_Next)
STDMETHODIMP CEnumFmt::Next
    (ULONG          cfmt,
    FORMATETC FAR   * rgfmt,
    ULONG FAR*      pcfmtFetched)
{
    VDATEHEAP();

    OLECHAR     szBuf [MAX_STR];
    OLECHAR     szKey [80];
    DWORD       dwAspects;
    LPOLESTR    psz;
        LONG        cb              = 0;
    HKEY        hkey        = NULL;
    ULONG       ifmt        = 0;    // number successfully fetched so far
    LPOLESTR    szFmt       = NULL;
    LPOLESTR    szAspects   = NULL;
    LPOLESTR    szMedia     = NULL;
    LPOLESTR    szDirection     = NULL;
    HRESULT     hresult     = NOERROR;

    RetErr (OpenHKey (&hkey));

    while (ifmt < cfmt)
    {
        // use the cached value (multiple aspects specified for the
        // formatetc.
        if (m_cache.fUseMe)
        {
            rgfmt[ifmt] = m_cache.fmt;
            rgfmt[ifmt].dwAspect = UtRightmostBit (
                m_cache.dwAspects);
            m_cache.dwAspects = UtRemoveRightmostBit (
                m_cache.dwAspects);
            if (0==m_cache.dwAspects)
                m_cache.fUseMe = FALSE;
            ifmt++;
        }
        else
        {
            wsprintf (szKey, OLESTR("%d"), m_iKey++);
            cb = MAX_STR;
            if (ERROR_SUCCESS == RegQueryValue (hkey, szKey,
                szBuf, &cb))
            {
                rgfmt[ifmt].ptd = NULL;
                rgfmt[ifmt].lindex = DEF_LINDEX;

                psz = szBuf;
                ErrZS(*psz, REGDB_E_INVALIDVALUE);

                szFmt = psz;

                while (*psz && *psz != DELIM[0])
                    psz++;
                ErrZS(*psz, REGDB_E_INVALIDVALUE);
                *psz++ = OLESTR('\0');

                szAspects = psz;

                while (*psz && *psz != DELIM[0])
                    psz++;
                ErrZS(*psz, REGDB_E_INVALIDVALUE);
                *psz++ = OLESTR('\0');

                szMedia = psz;

                while (*psz && *psz != DELIM[0])
                    psz++;
                ErrZS(*psz, REGDB_E_INVALIDVALUE);
                *psz++ = OLESTR('\0');

                szDirection = psz;

                // Format
                rgfmt [ifmt].cfFormat = _xisdigit (szFmt[0])
                    ? (CLIPFORMAT) Atol (szFmt)
                    : (CLIPFORMAT) RegisterClipboardFormat (szFmt);
                
                // Aspect
                dwAspects = Atol (szAspects);
                ErrZS (dwAspects, REGDB_E_INVALIDVALUE);
                if (UtIsSingleBit (dwAspects))
                {
                    rgfmt[ifmt].dwAspect = Atol(szAspects);
                }
                else
                {
                    rgfmt[ifmt].dwAspect =
                        UtRightmostBit(dwAspects);
                    m_cache.fmt = rgfmt[ifmt];
                    m_cache.dwAspects =
                        UtRemoveRightmostBit(
                            dwAspects) & 0xf;
                    if (m_cache.dwAspects != 0)
                    {
                        m_cache.fUseMe = TRUE;
                    }
                }
    
                // Media
                rgfmt[ifmt].tymed = Atol (szMedia);
                if (m_cache.fUseMe)
                {
                    m_cache.fmt.tymed = rgfmt[ifmt].tymed;
                }
            
                // Direction
                if ( (Atol (szDirection) & m_dwDirection) ==
                    m_dwDirection)
                {
                    // This format supports the direction
                    // we are interested in
                    ifmt++;
                }
                else
                {
                    m_cache.fUseMe = FALSE;
                }
            }
            else
            {
                break; // no more entries
            }
        }// else
    }// while
        
    if (pcfmtFetched)
    {
        *pcfmtFetched = ifmt;
    }
        
  errRtn:
    CLOSE (hkey);

    if (NOERROR==hresult)
    {
        return ifmt==cfmt ? NOERROR : ResultFromScode (S_FALSE);
    }
    else
    {
                if (pcfmtFetched)
                {
                    *pcfmtFetched = 0;
                }

        m_cache.fUseMe = FALSE;
        return hresult;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumFmt::Clone
//
//  Synopsis:   clones the enumerator
//
//  Effects:
//
//  Arguments:  [ppenum]    -- where to put the cloned enumerator
//
//  Requires:
//
//  Returns:    NOERROR, E_OUTOFMEMORY
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumFmt_Clone)
STDMETHODIMP CEnumFmt::Clone
    (LPENUMFORMATETC FAR* ppenum)
{
    VDATEHEAP();

    VDATEPTRIN (ppenum, LPENUMFORMATETC);
    *ppenum = new FAR CEnumFmt (UtDupString(m_szClsid), m_dwDirection,
        m_iKey);
    return *ppenum ? NOERROR : ResultFromScode (E_OUTOFMEMORY);
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumFmt::QueryInterface
//
//  Synopsis:   returns supported interfaces
//
//  Effects:
//
//  Arguments:  [iid]       -- the requested interface ID
//      [ppv]       -- where to put the interface pointer
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IEnumFormatEtc
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumFmt_QueryInterface)
STDMETHODIMP CEnumFmt::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    VDATEHEAP();

    M_PROLOG(this);
    if (IsEqualIID(iid, IID_IUnknown) ||
        IsEqualIID(iid, IID_IEnumFORMATETC))
    {
        *ppv = this;
        AddRef();
        return NOERROR;
    }
    else
    {
        *ppv = NULL;
        return ResultFromScode (E_NOINTERFACE);
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumFmt::AddRef
//
//  Synopsis:   Increments the reference count
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumFmt_AddRef)
STDMETHODIMP_(ULONG) CEnumFmt::AddRef(void)
{
    VDATEHEAP();

    M_PROLOG(this);
    return ++m_cRef;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumFmt::Release
//
//  Synopsis:   decrements the reference count
//
//  Effects:    may delete this object
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG -- the new reference count    
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumFmt_Release)
STDMETHODIMP_(ULONG) CEnumFmt::Release(void)
{
    VDATEHEAP();

    M_PROLOG(this);
    if (--m_cRef == 0)
    {
        PubMemFree(m_szClsid);
        delete this;
        return 0;
    }
    return m_cRef;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumFmt::Dump, public (_DEBUG only)
//
//  Synopsis:   return a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [ppszDump]      - an out pointer to a null terminated character array
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   [ppszDump]  - argument
//
//  Derivation:
//
//  Algorithm:  use dbgstream to create a string containing information on the
//              content of data structures
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

HRESULT CEnumFmt::Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    char *pszFMTCACHE;
    dbgstream dstrPrefix;
    dbgstream dstrDump;

    // determine prefix of newlines
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << this << " _VB ";
    }

    // determine indentation prefix for all newlines
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    dstrDump << pszPrefix << "No. of References = " << m_cRef       << endl;

    dstrDump << pszPrefix << "CLSID string      = " << m_szClsid    << endl;

    dstrDump << pszPrefix << "Direction         = " << m_dwDirection<< endl;

    dstrDump << pszPrefix << "Current Key Index = " << m_iKey       << endl;

    pszFMTCACHE = DumpFMTCACHE(&m_cache, ulFlag, nIndentLevel + 1);
    dstrDump << pszPrefix << "FMTCACHE: " << endl;
    dstrDump << pszFMTCACHE;
    CoTaskMemFree(pszFMTCACHE);

    // cleanup and provide pointer to character array
    *ppszDump = dstrDump.str();

    if (*ppszDump == NULL)
    {
        *ppszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return NOERROR;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCEnumFmt, public (_DEBUG only)
//
//  Synopsis:   calls the CEnumFmt::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pEF]           - pointer to CEnumFmt
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCEnumFmt(CEnumFmt *pEF, ULONG ulFlag, int nIndentLevel)
{
    HRESULT hresult;
    char *pszDump;

    if (pEF == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    hresult = pEF->Dump(&pszDump, ulFlag, nIndentLevel);

    if (hresult != NOERROR)
    {
        CoTaskMemFree(pszDump);

        return DumpHRESULT(hresult);
    }

    return pszDump;
}

#endif // _DEBUG

/////////////////////////////////////////
// OLE 1.0 stuff

//+-------------------------------------------------------------------------
//
//  Function:   CreateEnumFormatEtc10
//
//  Synopsis:   Creates a 1.0 format enumerator
//
//  Effects:
//
//  Arguments:  [clsid]     -- the class id we're interested in
//      [dwDirection]   -- either GET or SET
//      [ppenum]    -- where to put the enumerator
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  checks to see if the info's in the reg db, then creates
//      and initializes a 1.0 enumerator object.  (note that there
//      does not *have* to be any info in the regdb, we can
//      InitFromScratch)
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CreateEnumFormatEtc10)
static INTERNAL CreateEnumFormatEtc10
    (REFCLSID clsid,
    DWORD dwDirection,
    LPENUMFORMATETC FAR* ppenum)
{
    VDATEHEAP();

    LPOLESTR    szClsid = NULL;
    HKEY        hkey = NULL;
    HKEY        hkeyFmts = NULL;
    HRESULT     hresult = NOERROR;
    BOOL        fInReg;
    CEnumFmt10 FAR* penum;
    
    VDATEPTROUT (ppenum, LPENUMFORMATETC);
    *ppenum = NULL;

    RetErr (ProgIDFromCLSID (clsid, &szClsid));
    if (ERROR_SUCCESS != OpenClassesRootKey (szClsid, &hkey))
    {           
        PubMemFree(szClsid);
        return ReportResult(0, REGDB_E_CLASSNOTREG, 0, 0);
    }

    // Does this server have "Request/SetDataFormats" keys?
    fInReg = (ERROR_SUCCESS == RegOpenKeyEx (hkey,
        OLESTR("Protocol\\StdFileEditing\\RequestDataFormats"),
        0, KEY_READ,
        &hkeyFmts));
    CLOSE(hkeyFmts);

    penum = new FAR CEnumFmt10 (szClsid, dwDirection);
    if (NULL==penum)
    {
        ErrRtnH (ResultFromScode (E_OUTOFMEMORY));
    }

    if (fInReg)
    {
        penum->InitFromRegDb (hkey);
    }
    else
    {
        penum->InitFromScratch ();
    }
        

  errRtn:
    CLOSE (hkey);
    if (hresult == NOERROR)
    {
        *ppenum = penum;
                CALLHOOKOBJECTCREATE(S_OK,CLSID_NULL,IID_IEnumFORMATETC,
                                     (IUnknown **)ppenum);
    }
    else
    {
        PubMemFree(szClsid);
        // If no error, szClsid will be deleted on Release
    }
    return hresult;
}



//+-------------------------------------------------------------------------
//
//  Member:     CEnumFmt10::Next
//
//  Synopsis:   Gets the next 1.0 format
//
//  Effects:
//
//  Arguments:  [cfmt]      -- the number of formatetc's to get
//      [rgfmt]     -- where to put the formatetc's
//      [pcfmtFetched]  -- where to put the num of formatetc's fetched
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IEnumFORMATETC
//
//  Algorithm:  Ole1.0 formats are retrieved when the enumerator object
//      is created, so we just return ones from our internal array
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumFmt10_Next)
STDMETHODIMP CEnumFmt10::Next
    (ULONG          cfmt,
    FORMATETC FAR   *   rgfmt,
    ULONG FAR*      pcfmtFetched)
{
    VDATEHEAP();

    ULONG       ifmt = 0;  // number successfully fetched so far

    while (ifmt < cfmt
           && m_rgFmt != NULL
           && m_rgFmt[m_iKey].cf != 0)
    {
        if ( (m_rgFmt[m_iKey].dw & m_dwDirection) == m_dwDirection)
        {
            // This format supports the direction we are
            // interested in
            rgfmt [ifmt].cfFormat = m_rgFmt[m_iKey].cf;
            rgfmt [ifmt].ptd = NULL;
            rgfmt [ifmt].lindex = DEF_LINDEX;
            rgfmt [ifmt].tymed =
                UtFormatToTymed(m_rgFmt[m_iKey].cf);
            rgfmt [ifmt].dwAspect = DVASPECT_CONTENT;
            ifmt++;
        }
        m_iKey++;
    }
        
    if (pcfmtFetched)
        *pcfmtFetched = ifmt;
        
    return ifmt==cfmt ? NOERROR : ResultFromScode (S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Function:   Index (static)
//
//  Synopsis:   finds the index of the given clipformat in the format
//      array
//
//  Effects:
//
//  Arguments:  [rgFmt]     -- the clipformat array
//      [cf]        -- the clipformat to look for
//      [iMax]      -- size of the array
//      [pi]        -- where to put the index
//
//  Requires:
//
//  Returns:    TRUE if found, FALSE otherwise
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(Index)
static INTERNAL_(BOOL) Index
    (FMT FAR *  rgFmt,
        CLIPFORMAT  cf, // format to search for
    size_t      iMax,   // size of array
    size_t FAR*     pi) // out parm,  index of found format
{
    VDATEHEAP();

    for (size_t i=0; i< iMax; i++)
    {
        if (rgFmt[i].cf==cf)
        {
            *pi = i;
            return TRUE;
        }
    }
    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   String2Clipformat (static)
//
//  Synopsis:   Converts a string to a clipboard format number (and then
//      registers the format)
//
//  Effects:
//
//  Arguments:  [sz]    -- the string to convert
//
//  Requires:
//
//  Returns:    CLIPFORMAT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(String2Clipformat)
static INTERNAL_(CLIPFORMAT) String2Clipformat
    (LPOLESTR sz)
{
    VDATEHEAP();

    if (_xstrlen(sz) >= 3 &&
            0==memcmp (sz, OLESTR("CF_"), 3*sizeof(sz[0])))
    {
        #define macro(cf) if (0==_xstricmp (sz, OLESTR(#cf))) return cf
        macro (CF_TEXT);
        macro (CF_BITMAP);
        macro (CF_METAFILEPICT);
        macro (CF_SYLK);
        macro (CF_DIF);
        macro (CF_TIFF);
        macro (CF_OEMTEXT);
        macro (CF_DIB);
        macro (CF_PALETTE);
        macro (CF_PENDATA);
        macro (CF_RIFF);
        macro (CF_WAVE);
        macro (CF_OWNERDISPLAY);
        macro (CF_DSPTEXT);
        macro (CF_DSPBITMAP);
        macro (CF_DSPMETAFILEPICT);
        #undef macro
    }
    return (CLIPFORMAT) RegisterClipboardFormat (sz);
}


//+-------------------------------------------------------------------------
//
//  Member:     CEnumFmt10::InitFromRegDb (internal)
//
//  Synopsis:   Initializes the 1.0 enumerator from the reg db (loads
//      all the available formats)
//
//  Effects:
//
//  Arguments:  [hkey]  -- handle to the regdb
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//      Original comment:
//
//      Fill m_rgFmt with FMTs which map clipformats to Get/Set flags
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumFmt10_InitFromRegDb)
STDMETHODIMP CEnumFmt10::InitFromRegDb
    (HKEY hkey)                             // CLSID key
{
    VDATEHEAP();

    LPOLESTR    pch;
    LPOLESTR    szReq = (LPOLESTR)PubMemAlloc(512 * sizeof(OLECHAR));
    LPOLESTR    szSet = (LPOLESTR)PubMemAlloc(512 * sizeof(OLECHAR));
    LPOLESTR    szFmt;
    BOOL        bMore;
    size_t      cFmts = 0;
    size_t      iFmt  = 0;
    size_t      iFmtPrev;
    CLIPFORMAT  cf;
        LONG        cb;
    HRESULT     hresult = NOERROR;

    if( !szReq )
    {
        // assumes delete 0 works (if szSet == 0)
        PubMemFree(szSet);
        return ResultFromScode (E_OUTOFMEMORY);
    }
    if( !szSet )
    {
        PubMemFree(szReq);
        return ResultFromScode (E_OUTOFMEMORY);
    }
        
    cb = 512;
    if (ERROR_SUCCESS == RegQueryValue (hkey,
        OLESTR("Protocol\\StdFileEditing\\RequestDataFormats"),
        szReq, &cb))
    {
        cFmts = 1;          // no commas means one format
        for (pch = szReq; *pch; pch++)
        {
            if (*pch==OLESTR(','))
                cFmts++;
        }
    }

    // the size of szSet
    cb = 512;
    if (ERROR_SUCCESS == RegQueryValue (hkey,
        OLESTR("Protocol\\StdFileEditing\\SetDataFormats"),
        szSet, &cb))
    {
        cFmts++;            // no commas means one format
        for (pch = szSet; *pch; pch++)
        {
            if (*pch==OLESTR(','))
                cFmts++;
        }
    }

    if (cFmts==0)
    {
        Assert(0);
        ErrRtnH (ReportResult(0, REGDB_E_KEYMISSING, 0, 0));
    }

    m_rgFmt = (FMT FAR *)PrivMemAlloc(sizeof(FMT)*(cFmts+1));
    if (m_rgFmt==NULL)
    {
        ErrRtnH (ResultFromScode (E_OUTOFMEMORY));
    }

    pch = szReq;
    bMore = (*pch != 0);
    while (bMore)
    {
        while (*pch == OLESTR(' '))
        pch++;
        szFmt = pch;
        while (*pch && *pch != DELIM[0])
        pch++;
        if (*pch == 0)
        bMore = FALSE;
        *pch++ = OLESTR('\0');
        m_rgFmt[iFmt].cf = String2Clipformat(szFmt);
        m_rgFmt[iFmt++].dw = DATADIR_GET;
    }

    pch = szSet;
    bMore = (*pch != 0);
    while (bMore)
    {
        while (*pch == OLESTR(' '))
        pch++;
        szFmt = pch;
        while (*pch && *pch != DELIM[0])
        pch++;
        if (*pch == 0)
        bMore = FALSE;
        *pch++ = OLESTR('\0');
        cf = String2Clipformat(szFmt);
        if (Index (m_rgFmt, cf, iFmt, &iFmtPrev))
        {
        // This format can also be gotten
        m_rgFmt[iFmtPrev].dw |= DATADIR_SET;
        }
        else
        {
        m_rgFmt[iFmt].cf = cf;
        m_rgFmt[iFmt++].dw = DATADIR_SET;
        }
    }

    // Terminator
    m_rgFmt[iFmt].cf = 0;
    m_cFmt = iFmt;

  errRtn:
    PubMemFree(szReq);
    PubMemFree(szSet);
    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Member: CEnumFmt10::InitFromScratch
//
//  Synopsis:   Initialize the enumerated formats for a 1.0 server that
//      does not specify any Request/SetData formats.
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    HRESULT  (NOERROR, E_OUTOFMEMORY)
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:  sets up Metafiles and "Native" formats
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:  
//      The spec says that what EnumFormatEtc returns is not a
//      guarantee of support.
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumFmt10_InitFromScratch)

STDMETHODIMP CEnumFmt10::InitFromScratch
    (void)
{
    VDATEHEAP();

    m_rgFmt = (FMT FAR *)PrivMemAlloc(10 * sizeof(FMT));
    if( !m_rgFmt )
    {
        return ResultFromScode (E_OUTOFMEMORY);
    }
    m_rgFmt[0].cf = CF_METAFILEPICT;
    m_rgFmt[0].dw = DATADIR_GET;
        m_rgFmt[1].cf = (CLIPFORMAT) RegisterClipboardFormat (OLESTR("Native"));
        m_rgFmt[1].dw = DATADIR_GET | DATADIR_SET;
    m_rgFmt[2].cf = 0; // Terminator
    m_cFmt = 2;
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumFmt10::Skip
//
//  Synopsis:   skips to over [c] formats
//
//  Effects:
//
//  Arguments:  [c] -- the number of formats to skip
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:  This is re-implemented so we get the right implementation
//      of Next (because C++ is evil OOP).
//      REVIEW32: we can probably get rid of this by clever use
//      of virtual (but must make sure the vtables don't get hosed).
//
//--------------------------------------------------------------------------


#pragma SEG(CEnumFmt10_Skip)
STDMETHODIMP CEnumFmt10::Skip
    (ULONG c)
{
    VDATEHEAP();

    ULONG i=0;
    FORMATETC formatetc;
    HRESULT hresult = NOERROR;

    while (i++ < c)
    {
        // There will not be a target device to free
        ErrRtnH (Next (1, &formatetc, NULL));
    }

  errRtn:
    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumFmt10::Clone
//
//  Synopsis:   duplicates the 1.0 format enumerator
//
//  Effects:
//
//  Arguments:  [ppenum]    -- where to put the cloned enumerator
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port, fixed memory leak
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumFmt10_Clone)
STDMETHODIMP CEnumFmt10::Clone
    (LPENUMFORMATETC FAR* ppenum)
{
    VDATEHEAP();

    VDATEPTROUT (ppenum, LPENUMFORMATETC);
    CEnumFmt10 FAR* penum;
    penum = new FAR CEnumFmt10 (UtDupString(m_szClsid), m_dwDirection,
        m_iKey);
    if (NULL==penum)
    {
        return ResultFromScode (E_OUTOFMEMORY);
    }
    penum->m_cFmt = m_cFmt;
    penum->m_rgFmt = (FMT FAR *)PrivMemAlloc((m_cFmt+1) * sizeof(FMT));
    if (NULL==penum->m_rgFmt)
    {
        delete penum;
        return ResultFromScode (E_OUTOFMEMORY);
    }
    _xmemcpy (penum->m_rgFmt, m_rgFmt, (m_cFmt+1)*sizeof(FMT));
    Assert (penum->m_rgFmt[penum->m_cFmt].cf==0);
    *ppenum = penum;
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumFmt10::Release
//
//  Synopsis:   decrements the reference count
//
//  Effects:    may delete the object
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumFmt10_Release)
STDMETHODIMP_(ULONG) CEnumFmt10::Release(void)
{
    VDATEHEAP();

    M_PROLOG(this);
    if (--m_cRef == 0)
    {
        PubMemFree(m_szClsid);
        PrivMemFree(m_rgFmt);
        delete this;
        return 0;
    }
    return m_cRef;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumFmt10::Dump, public (_DEBUG only)
//
//  Synopsis:   return a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [ppszDump]      - an out pointer to a null terminated character array
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   [ppszDump]  - argument
//
//  Derivation:
//
//  Algorithm:  use dbgstream to create a string containing information on the
//              content of data structures
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

HRESULT CEnumFmt10::Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel)
{
    int i;
    unsigned int ui;
    char *pszPrefix;
    char *pszCEnumFmt;
    char *pszFMT;
    dbgstream dstrPrefix;
    dbgstream dstrDump;

    // determine prefix of newlines
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << this << " _VB ";
    }

    // determine indentation prefix for all newlines
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    pszCEnumFmt = DumpCEnumFmt((CEnumFmt *)this, ulFlag, nIndentLevel + 1);
    dstrDump << pszPrefix << "CEnumFmt: " << endl;
    dstrDump << pszCEnumFmt;
    CoTaskMemFree(pszCEnumFmt);

    dstrDump << pszPrefix << "No. in FMT array  = " << (UINT) m_cFmt << endl;

    for (ui = 0; ui < m_cFmt; ui++)
    {
        pszFMT = DumpFMT(&m_rgFmt[ui], ulFlag, nIndentLevel + 1);
        dstrDump << pszPrefix << "FMT [" << ui << "]: " << endl;
        dstrDump << pszFMT;
        CoTaskMemFree(pszFMT);
    }

    // cleanup and provide pointer to character array
    *ppszDump = dstrDump.str();

    if (*ppszDump == NULL)
    {
        *ppszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return NOERROR;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCEnumFmt10, public (_DEBUG only)
//
//  Synopsis:   calls the CEnunFmt10::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pEF]           - pointer to CEnumFmt10
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCEnumFmt10(CEnumFmt10 *pEF, ULONG ulFlag, int nIndentLevel)
{
    HRESULT hresult;
    char *pszDump;

    if (pEF == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    hresult = pEF->Dump(&pszDump, ulFlag, nIndentLevel);

    if (hresult != NOERROR)
    {
        CoTaskMemFree(pszDump);

        return DumpHRESULT(hresult);
    }

    return pszDump;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpFMT, public (_DEBUG only)
//
//  Synopsis:   returns a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [pFMT]          - a pointer to a FMT object
//              [ulFlag]        - a flag determining the prefix of all newlines of
//                                the out character array(default is 0 -no prefix)
//              [nIndentLevel]  - will add an indent prefix after the other prefix
//                                for all newlines(include those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              23-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpFMT(FMT *pFMT, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    char *pszDump;
    char *pszCLIPFORMAT;
    dbgstream dstrPrefix;
    dbgstream dstrDump;

    if (pFMT == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    // determine prefix
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << pFMT <<  " _VB ";
    }

    // determine indentation prefix
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    pszCLIPFORMAT = DumpCLIPFORMAT(pFMT->cf);
    dstrDump << pszPrefix << "Clip format   = " << pszCLIPFORMAT << endl;
    CoTaskMemFree(pszCLIPFORMAT);

    dstrDump << pszPrefix << "Dword         = " << pFMT->dw      << endl;

    // cleanup and provide pointer to character array
    pszDump = dstrDump.str();

    if (pszDump == NULL)
    {
        pszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return pszDump;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpFMTCACHE, public (_DEBUG only)
//
//  Synopsis:   returns a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [pFMT]          - a pointer to a FMTCACHE object
//              [ulFlag]        - a flag determining the prefix of all newlines of
//                                the out character array(default is 0 -no prefix)
//              [nIndentLevel]  - will add an indent prefix after the other prefix
//                                for all newlines(include those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              23-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpFMTCACHE(FMTCACHE *pFMT, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    char *pszDump;
    char *pszFORMATETC;
    char *pszDVASPECT;
    dbgstream dstrPrefix;
    dbgstream dstrDump;

    if (pFMT == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    // determine prefix
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << pFMT <<  " _VB ";
    }

    // determine indentation prefix
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    pszFORMATETC = DumpFORMATETC(&pFMT->fmt, ulFlag, nIndentLevel);
    dstrDump << pszPrefix << "FORMATETC:  " << endl;
    dstrDump << pszFORMATETC;
    CoTaskMemFree(pszFORMATETC);

    pszDVASPECT = DumpDVASPECTFlags(pFMT->dwAspects);
    dstrDump << pszPrefix << "Aspect flags:     = " << pszDVASPECT << endl;
    CoTaskMemFree(pszDVASPECT);

    dstrDump << pszPrefix << "IsCacheValid?     = ";
    if (pFMT->fUseMe == TRUE)
    {
        dstrDump << "TRUE" << endl;
    }
    else
    {
        dstrDump << "FALSE" << endl;
    }

    // cleanup and provide pointer to character array
    pszDump = dstrDump.str();

    if (pszDump == NULL)
    {
        pszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return pszDump;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\stdimpl\oleregpv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	oleregpv.h
//
//  Contents:	Private header for the reg db api's
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//		08-Sep-95 davidwor  added size to szClsidRoot to allow
//				    sizeof{szClsidRoot) for efficiency
//		01-Dec-93 alexgo    32bit port
//
//--------------------------------------------------------------------------

#ifndef fOleRegPv_h
#define fOleRegPv_h

#define CLOSE(hkey) do { if (hkey) {Verify(ERROR_SUCCESS== \
	RegCloseKey(hkey)); hkey=NULL;}} while (0)

#define DELIM OLESTR(",")

#ifdef WIN32
#define Atol(sz) wcstol((sz), NULL, 10)
#else  //WIN16
FARINTERNAL_(LONG) Atol(LPOLESTR sz);
#endif //WIN32

extern const OLECHAR szClsidRoot[7];

#endif	//fOleRegPv_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\stdimpl\mf.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       mf.cpp
//
//  Contents:   Implentation of hte metafile picture object
//
//  Classes:    CMfObject
//
//  Functions:  OleIsDcMeta
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  added Dump method to CMfObject
//                                  added DumpCMfObject API
//                                  initialize m_pfnContinue in constructor
//              25-Jan-94 alexgo    first pass at converting to Cairo-style
//                                  memory allocations.
//              11-Jan-93 alexgo    added VDATEHEAP macros to every
//                                  function and method
//              31-Dec-93 ErikGav   chicago port
//              17-Dec-93 ChrisWe   fixed second argument to SelectPalette calls
//                                  in CallbackFuncForDraw
//              07-Dec-93 ChrisWe   made default params to StSetSize explicit
//              07-Dec-93 alexgo    merged 16bit RC9 changes
//              29-Nov-93 alexgo    32bit port
//              04-Jun-93 srinik    support for demand loading and discarding
//                                  of caches
//              13-Mar-92 srinik    created
//
//--------------------------------------------------------------------------

#include <le2int.h>
#include <qd2gdi.h>
#include "mf.h"

#ifdef _DEBUG
#include <dbgdump.h>
#endif // _DEBUG

#define M_HPRES()               (m_hPres ? m_hPres : LoadHPRES())

/*
 *      IMPLEMENTATION of CMfObject
 *
 */


//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::CMfObject
//
//  Synopsis:   constructor for the metafile object
//
//  Effects:
//
//  Arguments:  [pCacheNode]    -- pointer to the cache node for this object
//              [dwAspect]      -- drawing aspect for the object
//              [fConvert]      -- specifies whether to convert from Mac
//                                 QuickDraw format
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              13-Feb-95 t-ScottH  initialize m_pfnContinue
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

CMfObject::CMfObject(LPCACHENODE pCacheNode, DWORD dwAspect, BOOL fConvert)
{
	VDATEHEAP();

	m_ulRefs        = 1;
	m_hPres         = NULL;
	m_dwSize        = 0;
	m_dwAspect      = dwAspect;
	m_pCacheNode    = pCacheNode;
	m_dwContinue    = 0;
        m_pfnContinue   = NULL;
	m_lWidth        = 0;
	m_lHeight       = 0;
		
	m_fConvert      = fConvert;
	m_pMetaInfo     = NULL;
	m_pCurMdc       = NULL;
	m_fMetaDC       = FALSE;
	m_nRecord       = 0;
	m_error         = NOERROR;
	m_pColorSet     = NULL;

        m_hPalDCOriginal = NULL;
        m_hPalLast = NULL;
}


//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::~CMfObject
//
//  Synopsis:   Destroys a metafile presentation object
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

CMfObject::~CMfObject (void)
{
	VDATEHEAP();

	CMfObject::DiscardHPRES();
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::QueryInterface
//
//  Synopsis:   returns supported interfaces
//
//  Effects:
//
//  Arguments:  [iid]           -- the requested interface ID
//              [ppvObj]        -- where to put the interface pointer
//
//  Requires:
//
//  Returns:    NOERROR, E_NOINTERFACE
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CMfObject::QueryInterface (REFIID iid, void FAR* FAR* ppvObj)
{
	VDATEHEAP();

	if (IsEqualIID(iid, IID_IUnknown) || IsEqualIID(iid, IID_IOlePresObj))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	else
	{
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::AddRef
//
//  Synopsis:   Increments the reference count
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG  -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CMfObject::AddRef(void)
{
	VDATEHEAP();
	
	return ++m_ulRefs;
}
			
//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::Release
//
//  Synopsis:   decrements the reference count
//
//  Effects:    deletes the object once the ref count goes to zero
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CMfObject::Release(void)
{
	VDATEHEAP();

	if (--m_ulRefs == 0) {
		delete this;
		return 0;
	}

	return m_ulRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::GetData
//
//  Synopsis:   Retrieves data in the specified format from the object
//
//  Effects:
//
//  Arguments:  [pformatetcIn]  -- the requested data format
//              [pmedium]       -- where to put the data
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObject
//
//  Algorithm:  Does error checking and then gets a copy of the metafilepict
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CMfObject::GetData(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
	VDATEHEAP();

	SCODE   sc;
	
	// null out in case of error
	pmedium->tymed = (DWORD) TYMED_NULL;
	pmedium->pUnkForRelease = NULL;

	if (!(pformatetcIn->tymed & (DWORD) TYMED_MFPICT))
	{
		sc = DV_E_TYMED;
	}
	else if (pformatetcIn->cfFormat != CF_METAFILEPICT)
	{
		sc = DV_E_CLIPFORMAT;
	}
	else if (IsBlank())
	{
		sc = OLE_E_BLANK;
	}
	// here we actually try to get the data
	else if (NULL == (pmedium->hGlobal = GetHmfp()))
	{
		sc = E_OUTOFMEMORY;
	}
	else {
		pmedium->tymed = (DWORD) TYMED_MFPICT;
		return NOERROR;
	}

	return ResultFromScode(sc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::GetDataHere
//
//  Synopsis:   Retrieves data of the specified format into the specified
//              medium
//
//  Effects:
//
//  Arguments:  [pformatetcIn]  -- the requested data format
//              [pmedium]       -- where to put the data
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:  Does error checking and then copies the metafile into a
//              stream.
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CMfObject::GetDataHere
	(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
	VDATEHEAP();

	SCODE   sc;
	
	if (pformatetcIn->cfFormat != CF_METAFILEPICT)
	{
		sc = DV_E_CLIPFORMAT;
	}
	else if (pmedium->tymed != (DWORD) TYMED_ISTREAM)
	{
		sc = DV_E_TYMED;
	}
	else if (pmedium->pstm == NULL)
	{
		sc = E_INVALIDARG;
	}
	else if (IsBlank())
	{
		sc = OLE_E_BLANK;
	}
	else
	{
		HANDLE hpres = M_HPRES();
		return UtHMFToPlaceableMFStm(&hpres, m_dwSize, m_lWidth,
						m_lHeight, pmedium->pstm);
	}

	return ResultFromScode(sc);
}


//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::SetDataWDO
//
//  Synopsis:   Stores a metafile in this object
//
//  Effects:
//
//  Arguments:  [pformatetc]    -- format of the data coming in
//              [pmedium]       -- the new metafile (data)
//              [fRelease]      -- if true, then we'll release the [pmedium]
//              [pDataObj]      -- unused for MF objects
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:  does error checking and then stores the new data.
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CMfObject::SetDataWDO (LPFORMATETC    pformatetc,
				    STGMEDIUM *    pmedium,
				    BOOL           fRelease,
				    IDataObject *  /* UNUSED */)
{
	VDATEHEAP();

	HRESULT         error;
	BOOL            fTakeData = FALSE;
	
	if (pformatetc->cfFormat != CF_METAFILEPICT)
	{
		return ResultFromScode(DV_E_CLIPFORMAT);
	}
	
	if (pmedium->tymed != (DWORD) TYMED_MFPICT)
	{
		return ResultFromScode(DV_E_TYMED);
	}

	if ((pmedium->pUnkForRelease == NULL) && fRelease)
	{
		// we can take the ownership of the data
		fTakeData = TRUE;
	}
	
	// ChangeData will keep the data if fRelease is TRUE, else it copies
	error = ChangeData (pmedium->hGlobal, fTakeData);

	if (fTakeData)
	{
		pmedium->tymed = (DWORD) TYMED_NULL;
	}
	else if (fRelease)
	{
		ReleaseStgMedium(pmedium);
	}
	
	return error;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::GetHmfp (internal)
//
//  Synopsis:   Gets a copy of the stored metafile presentation
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    HANDLE
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

INTERNAL_(HANDLE) CMfObject::GetHmfp (void)
{
	VDATEHEAP();

	return UtGetHMFPICT((HMETAFILE)GetCopyOfHPRES(), TRUE, m_lWidth,
		m_lHeight);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::ChangeData (internal)
//
//  Synopsis:   Swaps the stored metafile presentation
//
//  Effects:
//
//  Arguments:  [hMfp]          -- the new metafile
//              [fDelete]       -- if TRUE, then delete [hMfp]
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port, fixed GlobalUnlock bug
//  Notes:
//
// If the routine fails then the object will be left with it's old data.
// If fDelete is TRUE, then hMeta, and the hMF it contains will be deleted
// whether the routine is successful or not.
//
//--------------------------------------------------------------------------

INTERNAL CMfObject::ChangeData (HANDLE hMfp, BOOL fDelete)
{
	VDATEHEAP();


	HANDLE                  hNewMF;
	LPMETAFILEPICT          lpMetaPict;
	DWORD                   dwSize;
	HRESULT                 error = NOERROR;

	if ((lpMetaPict = (LPMETAFILEPICT) GlobalLock (hMfp)) == NULL)
	{
		if (fDelete)
		{
			LEVERIFY( NULL == GlobalFree (hMfp) );
		}
		return E_OUTOFMEMORY;
	}

	if (!fDelete) {
		if (NULL == (hNewMF = CopyMetaFile (lpMetaPict->hMF, NULL)))
		{
			return E_OUTOFMEMORY;
		}
	}
	else
	{
		hNewMF = lpMetaPict->hMF;
	}

		
	if (lpMetaPict->mm != MM_ANISOTROPIC)
	{
		error = ResultFromScode(E_UNSPEC);
		LEWARN( error, "Mapping mode is not anisotropic" );

	}
	else if (0 == (dwSize =  MfGetSize (&hNewMF)))
	{
		error = ResultFromScode(OLE_E_BLANK);
	}
	else
	{
		if (m_hPres)
		{
			LEVERIFY( DeleteMetaFile (m_hPres) );
		}
		m_hPres         = (HMETAFILE)hNewMF;
		m_dwSize        = dwSize;
		m_lWidth        = lpMetaPict->xExt;
		m_lHeight       = lpMetaPict->yExt;
	}

	GlobalUnlock (hMfp);
	
	if (error != NOERROR)
	{
		LEVERIFY( DeleteMetaFile ((HMETAFILE)hNewMF) );
	}

	if (fDelete)
	{
		LEVERIFY( NULL == GlobalFree (hMfp) );
	}

	return error;
}


//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::Draw
//
//  Synopsis:   Draws the stored presentation
//
//  Effects:
//
//  Arguments:  [pvAspect]      -- the drawing aspect
//              [hicTargetDev]  -- the target device
//              [hdcDraw]       -- hdc to draw into
//              [lprcBounds]    -- bounding rectangle to draw into
//              [lprcWBounds]   -- bounding rectangle for the metafile
//              [pfnContinue]   -- function to call while drawing
//              [dwContinue]    -- parameter to [pfnContinue]
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:  Sets the viewport and metafile boundaries, then plays
//              the metafile
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CMfObject::Draw (void *     /* UNUSED pvAspect */,
			      HDC        /* UNUSED hicTargetDev */,
			      HDC        hdcDraw,
			      LPCRECTL   lprcBounds,
			      LPCRECTL   lprcWBounds,
			      BOOL (CALLBACK * pfnContinue)(ULONG_PTR),
			      ULONG_PTR      dwContinue)
{
	VDATEHEAP();

	m_error = NOERROR;
	
	int		iRgn;
	int             iOldDc;
	RECT            rect;
	LPRECT          lpRrc = (LPRECT) &rect;

	Assert(lprcBounds);

	if (!M_HPRES())
	{
		return ResultFromScode(OLE_E_BLANK);
	}

	rect.left   = lprcBounds->left;
	rect.right  = lprcBounds->right;
	rect.top    = lprcBounds->top;
	rect.bottom = lprcBounds->bottom;

	iOldDc = SaveDC (hdcDraw);
	if (0 == iOldDc)
	{
		return ResultFromScode(E_OUTOFMEMORY);
	}

	m_nRecord = RECORD_COUNT;
	m_fMetaDC = OleIsDcMeta (hdcDraw);

	if (!m_fMetaDC) {
	    iRgn = IntersectClipRect (hdcDraw, lpRrc->left, lpRrc->top,
						   lpRrc->right, lpRrc->bottom);
	    Assert( ERROR != iRgn );

	    if (iRgn == NULLREGION) {
		goto errRtn;
	    }
	    if (iRgn == ERROR) {
		m_error = ResultFromScode(E_UNSPEC);
		goto errRtn;
	    }


		// Because the LPToDP conversion takes the current world
                // transform into consideration, we must check to see
                // if we are in a GM_ADVANCED device context.  If so,
                // save its state and reset to GM_COMPATIBLE while we
                // convert LP to DP (then restore the DC).

                if (GM_ADVANCED == GetGraphicsMode(hdcDraw))
                {
                    HDC screendc = GetDC(NULL);
                    RECT rect = {0, 0, 1000, 1000};
                    HDC emfdc = CreateEnhMetaFile(screendc, NULL, &rect, NULL);
                    PlayMetaFile( emfdc, m_hPres);
                    HENHMETAFILE hemf = CloseEnhMetaFile(emfdc);
                    PlayEnhMetaFile( hdcDraw, hemf, lpRrc);
                    DeleteEnhMetaFile( hemf );

                    goto errRtn;
                }
                else
                {
                    LEVERIFY( LPtoDP (hdcDraw, (LPPOINT) lpRrc, 2) );
                }

                LEVERIFY( 0 != SetMapMode (hdcDraw, MM_ANISOTROPIC) );
                LEVERIFY( SetViewportOrg (hdcDraw, lpRrc->left, lpRrc->top) );
                LEVERIFY( SetViewportExt (hdcDraw, lpRrc->right - lpRrc->left,
					     lpRrc->bottom - lpRrc->top) );

	}
	else
	{
		iOldDc = -1;

		if (!lprcWBounds)
		{
			return ResultFromScode(E_DRAW);
		}

		m_pMetaInfo = (LPMETAINFO)PrivMemAlloc(sizeof(METAINFO));
		if( !m_pMetaInfo )
		{
			AssertSz(m_pMetaInfo, "Memory allocation failed");
			m_error = ResultFromScode(E_OUTOFMEMORY);
			goto errRtn;
		}
		
		m_pCurMdc = (LPMETADC) (m_pMetaInfo);

		m_pMetaInfo->xwo  = lprcWBounds->left;
		m_pMetaInfo->ywo  = lprcWBounds->top;
		m_pMetaInfo->xwe  = lprcWBounds->right;
		m_pMetaInfo->ywe  = lprcWBounds->bottom;

		m_pMetaInfo->xro  = lpRrc->left - lprcWBounds->left;
		m_pMetaInfo->yro  = lpRrc->top - lprcWBounds->top;
		
		m_pCurMdc->xre    = lpRrc->right - lpRrc->left;
		m_pCurMdc->yre    = lpRrc->bottom - lpRrc->top;
		m_pCurMdc->xMwo   = 0;
		m_pCurMdc->yMwo   = 0;
		m_pCurMdc->xMwe   = 0;
		m_pCurMdc->yMwe   = 0;
		m_pCurMdc->pNext  = NULL;
	}

	m_pfnContinue = pfnContinue;
	m_dwContinue = dwContinue;

	// m_hPalDCOriginal and m_hPalLast are used to clean up any 
	// palettes that are selected into a DC during the metafile 
	// enumeration.
        m_hPalDCOriginal = NULL;
        m_hPalLast = NULL;

	LEVERIFY( EnumMetaFile(hdcDraw, m_hPres, MfCallbackFuncForDraw,
						(LPARAM) this) );

	if (m_fMetaDC)
	{
	    CleanStack();

	}

	// if m_hPalLast exists at this point, we have duped a palette
	// and it needs to be freed.
        if (m_hPalLast)
	{
	    HPALETTE hPalTemp;

	    // when calling SelectPalette on a Metafile DC, the old
	    // palette is not returned.  We need to select another
	    // palette into the metafile DC so DeleteObject can be
	    // called.  To do this, we will use the stock palette.
	    if (m_fMetaDC)
	    {
	        hPalTemp = (HPALETTE)GetStockObject(DEFAULT_PALETTE);
	    }
	    else
	    {
	        // Get the original palette selected in the DC.
	        hPalTemp = m_hPalDCOriginal;
	    }

	    // hPalTemp could be NULL...

	    if (hPalTemp)
	    {
	        // Should this palette be selected in the foreground?
	        // [Probably not, this code is well-tested]
	        SelectPalette(hdcDraw, hPalTemp, TRUE);
	    }

	    DeleteObject(m_hPalLast);
	}

	m_fMetaDC = FALSE;

errRtn:

	LEVERIFY( RestoreDC (hdcDraw, iOldDc) );
	return m_error;
}


//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::GetColorSet
//
//  Synopsis:   Retrieves the logical palette associated with the metafile
//
//  Effects:
//
//  Arguments:  [pvAspect]      -- the drawing aspect
//              [hicTargetDev]  -- target device
//              [ppColorSet]    -- where to put the logical palette pointer
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:  Plays the metafile into a new metafile.  The play callback
//              function stores the metafile palette which is then returned.
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


STDMETHODIMP CMfObject::GetColorSet (LPVOID         /* UNUSED pvAspect     */,
				     HDC            /* UNUSED hicTargetDev */,
				     LPLOGPALETTE * ppColorSet)
{
	VDATEHEAP();

	if (IsBlank() || !M_HPRES())
	{
		return ResultFromScode(OLE_E_BLANK);
	}

	m_pColorSet = NULL;
	
	HDC hdcMeta = CreateMetaFile(NULL);
	if (NULL == hdcMeta)
	{
		return ResultFromScode(E_OUTOFMEMORY);
	}

	m_error = NOERROR;


	LEVERIFY( EnumMetaFile(hdcMeta, m_hPres, MfCallbackFuncForGetColorSet,
			       (LPARAM) this) );

	HMETAFILE hMetaFile = CloseMetaFile(hdcMeta);

	if( hMetaFile )
	{
		DeleteMetaFile(hMetaFile);
	}
	
	if( m_error != NOERROR )
	{
		return m_error;
	}
		
	if ((*ppColorSet = m_pColorSet) == NULL)
	{
		return ResultFromScode(S_FALSE);
	}

	return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Function:   MfCallBackFunForDraw
//
//  Synopsis:   callback function for drawing metafiles -- call's the caller's
//              draw method (via a passed in this pointer)
//
//  Effects:
//
//  Arguments:  [hdc]           -- the device context
//              [lpHTable]      -- pointer to the MF handle table
//              [lpMFR]         -- pointer to metafile record
//              [nObj]          -- number of objects
//
//  Requires:
//
//  Returns:    non-zero to continue, zero stops the drawing
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


int CALLBACK __loadds MfCallbackFuncForDraw
    (HDC hdc, HANDLETABLE FAR* lpHTable, METARECORD FAR* lpMFR, int nObj,
     LPARAM lpobj)
{
	VDATEHEAP();

    return ((CMfObject FAR*) lpobj)->CallbackFuncForDraw(hdc, lpHTable,
					lpMFR, nObj);
}

//+-------------------------------------------------------------------------
//
//  Function:   MfCallbackFuncForGetColorSet
//
//  Synopsis:   callback function for grabbing the palette from a metafile
//
//  Effects:
//
//  Arguments:  [hdc]           -- the device context
//              [lpHTable]      -- pointer to the MF handle table
//              [lpMFR]         -- pointer to metafile record
//              [nObj]          -- number of objects
//
//  Requires:
//
//  Returns:    non-zero to continue, zero stops the drawing
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

int CALLBACK __loadds MfCallbackFuncForGetColorSet
    (HDC hdc, HANDLETABLE FAR* lpHTable, METARECORD FAR* lpMFR, int nObj,
     LPARAM lpobj)
{
	VDATEHEAP();

    return ((CMfObject FAR*) lpobj)->CallbackFuncForGetColorSet(hdc, lpHTable,
								lpMFR, nObj);
}




//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::CallbackFuncForGetColorSet
//
//  Synopsis:   Merges all the color palettes in the metafile into
//              one palette (called when GetColorSet enumerates the metafile)
//
//  Effects:
//
//  Arguments:  [hdc]           -- the device context
//              [lpHTable]      -- pointer to the MF handle table
//              [lpMFR]         -- pointer to metafile record
//              [nObj]          -- number of objects
//
//  Requires:
//
//  Returns:    non-zero to continue, zero stops the drawing
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

int CMfObject::CallbackFuncForGetColorSet(HDC           /* UNUSED hdc */,
					  LPHANDLETABLE /* UNUSED lpHTable */,
					  LPMETARECORD  lpMFR,
					  int           /* UNUSED nObj */)
{
	VDATEHEAP();

	if (lpMFR->rdFunction == META_CREATEPALETTE)
	{
		LPLOGPALETTE    lplogpal = (LPLOGPALETTE) &(lpMFR->rdParm[0]);
		UINT            uPalSize =   (lplogpal->palNumEntries) *
						sizeof(PALETTEENTRY)
						+ 2 * sizeof(WORD);
		
		if (m_pColorSet == NULL)
		{
			// This is the first CreatePalette record.

			m_pColorSet = (LPLOGPALETTE)PubMemAlloc(uPalSize);
			if(NULL == m_pColorSet)
			{
				m_error = ResultFromScode(E_OUTOFMEMORY);
				return FALSE;
			}
			_xmemcpy(m_pColorSet, lplogpal, (size_t) uPalSize);
		}
		
		// if we hit more than one CreatePalette record then, we need to
		// merge those palette records.

		// REVIEW32:: err, we don't ever seem to do this
		// mergeing referred to above :(
	}

	return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::CallbackFuncForDraw
//
//  Synopsis:   Draws the metafile
//
//  Effects:
//
//  Arguments:  [hdc]           -- the device context
//              [lpHTable]      -- pointer to the MF handle table
//              [lpMFR]         -- pointer to metafile record
//              [nObj]          -- number of objects
//
//  Requires:
//
//  Returns:    non-zero to continue, zero stops the drawing
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              17-Dec-93 ChrisWe   fixed second argument to SelectPalette calls
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

int CMfObject::CallbackFuncForDraw
	(HDC hdc, LPHANDLETABLE lpHTable, LPMETARECORD lpMFR, int nObj)
{
    VDATEHEAP();

	
    if (!--m_nRecord)
    {
        m_nRecord = RECORD_COUNT;
		
	if (m_pfnContinue && !((*(m_pfnContinue))(m_dwContinue)))
	{
	    m_error = ResultFromScode(E_ABORT);
	    return FALSE;
	}
    }

    if (m_fMetaDC)
    {
        switch (lpMFR->rdFunction)
	{
	    case META_SETWINDOWORG:
	        SetPictOrg (hdc, (SHORT)lpMFR->rdParm[1], (SHORT)lpMFR->rdParm[0],
				FALSE);
		    return TRUE;
			
	    case META_OFFSETWINDOWORG:
	        SetPictOrg (hdc, (SHORT)lpMFR->rdParm[1], (SHORT)lpMFR->rdParm[0],
			TRUE);
		    return TRUE;
		
	    case META_SETWINDOWEXT:
	        SetPictExt (hdc, (SHORT)lpMFR->rdParm[1], (SHORT)lpMFR->rdParm[0]);
		    return TRUE;
		
	    case META_SCALEWINDOWEXT:
		ScalePictExt (hdc, (SHORT)lpMFR->rdParm[3], (SHORT)lpMFR->rdParm[2],
				(SHORT)lpMFR->rdParm[1], (SHORT)lpMFR->rdParm[0]);
		return TRUE;
	
	    case META_SCALEVIEWPORTEXT:
		ScaleRectExt (hdc, (SHORT)lpMFR->rdParm[3], (SHORT)lpMFR->rdParm[2],
			(SHORT)lpMFR->rdParm[1], (SHORT)lpMFR->rdParm[0]);
		return TRUE;
	
	    case META_SAVEDC:
	    {
	        BOOL fSucceeded = PushDc();
		LEVERIFY( fSucceeded );
		if (!fSucceeded)
		    return FALSE;
		break;
	    }

	    case META_RESTOREDC:
	 	LEVERIFY( PopDc() );
		break;

	    case META_SELECTPALETTE:
	    {
		// All selectpalette records are recorded such that the
                // palette is rendered in foreground mode.  Rather than
                // allowing the record to play out in this fashion, we
                // grab the handle and select it ourselves, forcing it
                // to background (using colors already mapped in the DC)

		// Dupe the palette.
 	        HPALETTE hPal = UtDupPalette((HPALETTE) lpHTable->objectHandle[lpMFR->rdParm[0]]);
                
		// Select the dupe into the DC.  EnumMetaFile calls DeleteObject
		// on the palette handle in the metafile handle table.  If that 
		// palette is currently selected into a DC, we rip and leak the
		// resource.
                LEVERIFY( NULL != SelectPalette(hdc, hPal, TRUE) );

		// if we had previously saved a palette, we need to delete
		// it (for the case of multiple SelectPalette calls in a 
		// MetaFile).
		if (m_hPalLast)
		{
		    DeleteObject(m_hPalLast);
		}

		// remember our duped palette so that it can be properly destroyed
		// later.
		m_hPalLast = hPal;

		return TRUE;
            }
	
	    case META_OFFSETVIEWPORTORG:
		AssertSz(0, "OffsetViewportOrg() in metafile");
		return TRUE;
		
	    case META_SETVIEWPORTORG:
		AssertSz(0, "SetViewportOrg() in metafile");
		return TRUE;
		
	    case META_SETVIEWPORTEXT:
		AssertSz(0, "SetViewportExt() in metafile");
		return TRUE;
		
	    case META_SETMAPMODE:
		AssertSz(lpMFR->rdParm[0] == MM_ANISOTROPIC,
			"SetmapMode() in metafile with invalid mapping mode");
		return TRUE;
		
	    default:
		break;
	}
    }
    else
    {       // non-metafile DC. (ScreenDC or other DC...)

        if (lpMFR->rdFunction == META_SELECTPALETTE)
	{
	// All selectpalette records are recorded such that the
        // palette is rendered in foreground mode.  Rather than
        // allowing the record to play out in this fashion, we
        // grab the handle and select it ourselves, forcing it
        // to background (using colors already mapped in the DC)

	    
	    HPALETTE hPal = UtDupPalette((HPALETTE) lpHTable->objectHandle[lpMFR->rdParm[0]]);

	    HPALETTE hPalOld = SelectPalette(hdc, hPal, TRUE);

	    if (!m_hPalDCOriginal)
	    {
	        m_hPalDCOriginal = hPalOld;
        }
	    else
	    {
	        // This case gets hit if we have already stored
			// the original palette from the DC.  This means
			// that hPalOld is a palette we have created using
			// UtDupPal above.  This means we need to delete
			// the old palette and remember the new one.

			if(hPalOld)
				DeleteObject(hPalOld);
  	    }

            m_hPalLast = hPal;

	    return TRUE;
        }
    }
	
    LEVERIFY( PlayMetaFileRecord (hdc, lpHTable, lpMFR, (unsigned) nObj) );
    return TRUE;
}



//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::SetPictOrg (private)
//
//  Synopsis:   Sets the hdc's origin via SetWindowOrg
//
//  Effects:
//
//  Arguments:  [hdc]           -- the device context
//              [xOrg]          -- the x origin
//              [yOrg]          -- the y origin
//              [fOffset]       -- if TRUE, [xOrg] and [yOrg] are offsets
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:      used by the metafile interpreter
//
//--------------------------------------------------------------------------

INTERNAL_(void) CMfObject::SetPictOrg
	(HDC hdc, int xOrg, int yOrg, BOOL fOffset)
{
	VDATEHEAP();

	if (fOffset)
	{

		m_pCurMdc->xMwo += xOrg;
		m_pCurMdc->yMwo += yOrg;
	}
	else
	{
		m_pCurMdc->xMwo = xOrg;
		m_pCurMdc->yMwo = yOrg;
	}

	if (m_pCurMdc->xMwe && m_pCurMdc->yMwe)
	{
		LEVERIFY ( SetWindowOrg (hdc,  // Review (davepl) MEIN GOT!
					(m_pCurMdc->xMwo -
				MulDiv (m_pMetaInfo->xro, m_pCurMdc->xMwe,
					m_pCurMdc->xre)),
			(m_pCurMdc->yMwo -
				MulDiv (m_pMetaInfo->yro, m_pCurMdc->yMwe,
					m_pCurMdc->yre))) );
	}
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::SetPictExt
//
//  Synopsis:   Sets teh metafile's extents
//
//  Effects:
//
//  Arguments:  [hdc]   -- the device context
//              [xExt]  -- the X-extent
//              [yExt]  -- the Y-extent
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:      used by the metafile interpreter
//
//--------------------------------------------------------------------------

INTERNAL_(void) CMfObject::SetPictExt (HDC hdc, int xExt, int yExt)
{
	VDATEHEAP();

	m_pCurMdc->xMwe = xExt;
	m_pCurMdc->yMwe = yExt;

	// Assert( m_pCurMdc->xre && m_pCurMdc->yre );

	int xNewExt = MulDiv (m_pMetaInfo->xwe, xExt, m_pCurMdc->xre);
	int yNewExt = MulDiv (m_pMetaInfo->ywe, yExt, m_pCurMdc->yre);

	int xNewOrg = m_pCurMdc->xMwo
		      - MulDiv (m_pMetaInfo->xro, xExt, m_pCurMdc->xre);
	int yNewOrg = m_pCurMdc->yMwo
		      - MulDiv (m_pMetaInfo->yro, yExt, m_pCurMdc->yre);

	LEVERIFY( SetWindowExt (hdc, xNewExt, yNewExt) );
	LEVERIFY( SetWindowOrg (hdc, xNewOrg, yNewOrg) );
}


//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::ScalePictExt
//
//  Synopsis:   Scales the metafile
//
//  Effects:
//
//  Arguments:  [hdc]           -- the device context
//              [xNum]          -- the x numerator
//              [xDenom]        -- the x demominator
//              [yNum]          -- the y numberator
//              [yDenom]        -- the y demoninator
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:      used by the metafile interpreter
//
//--------------------------------------------------------------------------

INTERNAL_(void) CMfObject::ScalePictExt (HDC hdc,
					 int xNum,
					 int xDenom,
					 int yNum,
					 int yDenom)
{
	VDATEHEAP();

	Assert( xDenom && yDenom );

	int xNewExt = MulDiv (m_pCurMdc->xMwe, xNum, xDenom);
	int yNewExt = MulDiv (m_pCurMdc->yMwe, yNum, yDenom);

	SetPictExt(hdc, xNewExt, yNewExt);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::ScaleRectExt
//
//  Synopsis:   scales the viewport
//
//  Effects:
//
//  Arguments:  [hdc]           -- the device context
//              [xNum]          -- the x numerator
//              [xDenom]        -- the x demominator
//              [yNum]          -- the y numberator
//              [yDenom]        -- the y demoninator
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:      Used by the metafile interpreter
//
//--------------------------------------------------------------------------

INTERNAL_(void) CMfObject::ScaleRectExt(HDC hdc,
					int xNum,
					int xDenom,
					int yNum,
					int yDenom)
{
	VDATEHEAP();

	AssertSz( xDenom, "Denominator is 0 for x-rect scaling");
        AssertSz( yDenom, "Denominator is 0 for y-rect scaling");

	m_pCurMdc->xre = MulDiv (m_pCurMdc->xre, xNum, xDenom);
	m_pCurMdc->yre = MulDiv (m_pCurMdc->yre, yNum, yDenom);

	SetPictExt (hdc, m_pCurMdc->xMwe, m_pCurMdc->yMwe);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::PushDC
//
//  Synopsis:   pushes metafile info onto a stack
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    BOOL -- TRUE if successful, FALSE otherwise
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:      Used by the metafile interpreter engine.
//
//--------------------------------------------------------------------------

INTERNAL_(BOOL) CMfObject::PushDc (void)
{
	VDATEHEAP();

	LPMETADC        pNode = NULL;

	pNode = (LPMETADC) PrivMemAlloc(sizeof(METADC));
	
	if (pNode)
	{
		*pNode =  *m_pCurMdc;
		m_pCurMdc->pNext = pNode;
		pNode->pNext = NULL;
		m_pCurMdc = pNode;
		return TRUE;
	}

	m_error = ResultFromScode(E_OUTOFMEMORY);
	return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::PopDC
//
//  Synopsis:   pops metafile info from the metafile info stack
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    BOOL -- TRUE if successful, FALSE otherwise (more pops
//              than pushes)
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:      used in the metafile interpreter
//
//--------------------------------------------------------------------------

INTERNAL_(BOOL) CMfObject::PopDc (void)
{
	VDATEHEAP();

	LPMETADC        pPrev = (LPMETADC) (m_pMetaInfo);
	LPMETADC        pCur  = ((LPMETADC) (m_pMetaInfo))->pNext;

	if (NULL == pCur)
	{
		LEWARN( NULL == pCur, "More pops than pushes from DC stack" );
		return FALSE;
	}

	while (pCur->pNext)
	{
		pPrev = pCur;
		pCur  = pCur->pNext;
	}

	if (pCur)
	{
		PrivMemFree(pCur);
	}
	
	pPrev->pNext = NULL;
	m_pCurMdc    = pPrev;

	return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::CleanStack
//
//  Synopsis:   Deletes the stack of metafile info
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:      used in the metafile interpreter
//
//--------------------------------------------------------------------------

INTERNAL_(void) CMfObject::CleanStack (void)
{
	VDATEHEAP();

	LPMETADC        pCur;

	while (NULL != (pCur = ((LPMETADC) (m_pMetaInfo))->pNext))
	{
		((LPMETADC) (m_pMetaInfo))->pNext = pCur->pNext;
		PrivMemFree(pCur);
	}

	PrivMemFree(m_pMetaInfo);
	
	m_pCurMdc      = NULL;
	m_pMetaInfo    = NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   QD2GDI
//
//  Synopsis:   Converts macintosh pictures to Win32 GDI metafiles
//
//  Effects:
//
//  Arguments:  [hBits]         -- handle to the mac picture bits
//
//  Requires:
//
//  Returns:    HMETAFILE
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Loads ole2conv.dll and calls QD2GDI in that dll
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

FARINTERNAL_(HMETAFILE) QD2GDI (HANDLE hBits)
{
	VDATEHEAP();

	USERPREFS userPrefs =
	{
		{'Q','D','2','G','D','I'},      //signature
		2,                              //structure version number
		sizeof(USERPREFS),              //structure size
		NULL,                           //source filename
		NULL,                           //or source handle
		NULL,                           //returned memory-based
						//metafile
		3,                              //simulated pattern lines
		5,                              //use max dimension
						//non-squarer pen
		1,                              //arithmetic transfer
		1,                              //create opaque text
		1,                              //simulate non-rectangular
						//regions
		0,                              //don't optimize for PowerPoint
		{0,0,0,0,0,0}                   //reserved
	};
	


	HINSTANCE       hinstFilter;
	void (FAR PASCAL *qd2gdiPtr)( USERPREFS FAR *, PICTINFO FAR *);
	PICTINFO        pictinfo;

	hinstFilter = LoadLibrary(OLESTR("OLECNV32.DLL"));

    if (hinstFilter == NULL)
    {
        return NULL;
    }

	*((FARPROC*)&qd2gdiPtr)  = GetProcAddress(hinstFilter, "QD2GDI");

	userPrefs.sourceFilename        = NULL;
	userPrefs.sourceHandle          = hBits;
	pictinfo.hmf                    = NULL;

	if (qd2gdiPtr == NULL)
	{
		goto errRtn;
	}
	
	(*qd2gdiPtr)( (USERPREFS FAR *)&userPrefs, (PICTINFO FAR *)&pictinfo);
	
errRtn:
	LEVERIFY( FreeLibrary(hinstFilter) );
	return (HMETAFILE)pictinfo.hmf;

}

//+-------------------------------------------------------------------------
//
//  Function:   MfGetSize
//
//  Synopsis:   Returns the size of a metafile
//
//  Effects:
//
//  Arguments:  [lphmf]         -- pointer to the metafile handle
//
//  Requires:
//
//  Returns:    DWORD -- the size of the metafile
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

INTERNAL_(DWORD) MfGetSize (LPHANDLE lphmf)
{
	VDATEHEAP();

	return GetMetaFileBitsEx((HMETAFILE)*lphmf,0,NULL);
}

//+-------------------------------------------------------------------------
//
//  Function:   OleIsDcMeta
//
//  Synopsis:   Returns whether a device context is really a metafile
//
//  Effects:
//
//  Arguments:  [hdc]           -- the device context
//
//  Requires:
//
//  Returns:    BOOL (TRUE if a metafile)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDAPI_(BOOL)   OleIsDcMeta (HDC hdc)
{
	VDATEHEAP();

	return (GetDeviceCaps (hdc, TECHNOLOGY) == DT_METAFILE);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::Load
//
//  Synopsis:   Loads an metafile object from the given stream
//
//  Effects:
//
//  Arguments:  [lpstream]              -- the stream from which to load
//              [fReadHeaderOnly]       -- if TRUE, then only the header is
//                                         read
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CMfObject::Load(LPSTREAM lpstream, BOOL fReadHeaderOnly)
{
	VDATEHEAP();

	DWORD           dwBuf[4];
	HRESULT         error;
	
	/* read dwCompression, width, height, size of data */
	error = StRead(lpstream, dwBuf, 4*sizeof(DWORD));
	if (error)
	{
		return error;
	}

	AssertSz (dwBuf[0] == 0, "Picture compression factor is non-zero");
	
	m_lWidth  = (LONG) dwBuf[1];
	m_lHeight = (LONG) dwBuf[2];
	m_dwSize  = dwBuf[3];

	if (!m_dwSize || fReadHeaderOnly)
	{
		return NOERROR;
	}
	
	return UtGetHMFFromMFStm(lpstream, m_dwSize, m_fConvert,
		(LPLPVOID) &m_hPres);
}


//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::Save
//
//  Synopsis:   Saves the metafile to the given stream
//
//  Effects:
//
//  Arguments:  [lpstream]      -- the stream to save to
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CMfObject::Save(LPSTREAM lpstream)
{
	VDATEHEAP();

	HRESULT         error;
	DWORD           dwBuf[4];
	
	/* write dwCompression, width, height, size of data */

	dwBuf[0]  = 0L;
	dwBuf[1]  = (DWORD) m_lWidth;
	dwBuf[2]  = (DWORD) m_lHeight;
	dwBuf[3]  = m_dwSize;

	error = StWrite(lpstream, dwBuf, sizeof(dwBuf));
	if (error)
	{
		return error;
	}


	// if blank object, don't write any more; no error.
	if (IsBlank() || m_hPres == NULL)
	{
		StSetSize(lpstream, 0, TRUE);
		return NOERROR;
	}
	
	return UtHMFToMFStm((LPLPVOID)&m_hPres, m_dwSize, lpstream);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::GetExtent
//
//  Synopsis:   Retrieves the extents of the metafile
//
//  Effects:
//
//  Arguments:  [dwDrawAspect]  -- the drawing aspect we're interested in
//                                 (must match the aspect of the current
//                                 metafile)
//              [lpsizel]       -- where to put the extent info
//
//  Requires:
//
//  Returns:    NOERROR, DV_E_DVASPECT, OLE_E_BLANK
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CMfObject::GetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
	VDATEHEAP();

	if (0 == (dwDrawAspect & m_dwAspect))
	{
		return ResultFromScode(DV_E_DVASPECT);
	}
	
	if (IsBlank())
	{
		return ResultFromScode(OLE_E_BLANK);
	}

	lpsizel->cx = m_lWidth;
	lpsizel->cy = m_lHeight;
	return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::IsBlank
//
//  Synopsis:   Returns whether or not the metafile is blank
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    TRUE/FALSE
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(BOOL) CMfObject::IsBlank(void)
{
	VDATEHEAP();

	return (m_dwSize ? FALSE : TRUE);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::LoadHPRES (private)
//
//  Synopsis:   Loads the presentation from the cache's stream and returns
//              a handle to it
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    HANDLE to the metafile
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

INTERNAL_(HANDLE) CMfObject::LoadHPRES(void)
{
	VDATEHEAP();

	LPSTREAM        pstm = NULL;
	
	if (NULL != m_pCacheNode)
	{
	    pstm = m_pCacheNode->GetStm(TRUE /*fSeekToPresBits*/, STGM_READ);
	}
	if (pstm)
	{
		LEVERIFY( SUCCEEDED(Load(pstm)));
		pstm->Release();
	}
	
	return m_hPres;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::DiscardHPRES
//
//  Synopsis:   deletes the stored metafile
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IOlePresObj
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(void) CMfObject::DiscardHPRES(void)
{
	VDATEHEAP();

	if (m_hPres)
	{
		LEVERIFY( DeleteMetaFile (m_hPres) );
		m_hPres = NULL;
	}
}
	

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::GetCopyOfHPRES (private)
//
//  Synopsis:   makes a copy of the metafile (if one is present), otherwise
//              just load it from the stream (but don't store it in [this]
//              object)
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    HANDLE to the metafile
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


INTERNAL_(HANDLE) CMfObject::GetCopyOfHPRES(void)
{
	VDATEHEAP();

	HANDLE          hPres;
	
	// Make a copy if the presentation data is already loaded
	if (m_hPres)
	{
		return CopyMetaFile(m_hPres, NULL);
	}
	
	// Load the presentation data now and return the same handle.
	// No need to copy the data. If the caller wants the m_hPres to be
	// set he would call LoadHPRES() directly.

	hPres = LoadHPRES();
	m_hPres = NULL;	    // NULL this, LoadHPRES set it.
	return hPres;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMfObject::Dump, public (_DEBUG only)
//
//  Synopsis:   return a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [ppszDump]      - an out pointer to a null terminated character array
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   [ppszDump]  - argument
//
//  Derivation:
//
//  Algorithm:  use dbgstream to create a string containing information on the
//              content of data structures
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

HRESULT CMfObject::Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    char *pszHRESULT;
    char *pszDVASPECT;
    dbgstream dstrPrefix;
    dbgstream dstrDump(500);

    // determine prefix of newlines
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << this << " _VB ";
    }

    // determine indentation prefix for all newlines
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    dstrDump << pszPrefix << "No. of References                 = " << m_ulRefs     << endl;

    dstrDump << pszPrefix << "pMETAINFO (Metafile information)  = " << m_pMetaInfo  << endl;

    dstrDump << pszPrefix << "pMETADC (current device context)  = " << m_pCurMdc    << endl;

    dstrDump << pszPrefix << "IsMetaDeviceContext?              = ";
    if (m_fMetaDC == TRUE)
    {
        dstrDump << "TRUE" << endl;
    }
    else
    {
        dstrDump << "FALSE" << endl;
    }

    dstrDump << pszPrefix << "No. of Records in Metafile        = " << m_nRecord    << endl;

    pszHRESULT = DumpHRESULT(m_error);
    dstrDump << pszPrefix << "Error code                        = " << pszHRESULT   << endl;
    CoTaskMemFree(pszHRESULT);

    dstrDump << pszPrefix << "pLOGPALETTE (Color set palette)   = " << m_pColorSet  << endl;

    dstrDump << pszPrefix << "ConvertFromMac?                   = ";
    if (m_fConvert == TRUE)
    {
        dstrDump << "TRUE" << endl;
    }
    else
    {
        dstrDump << "FALSE" << endl;
    }

    dstrDump << pszPrefix << "Continue                          = " << ((ULONG) m_dwContinue) << endl;

    dstrDump << pszPrefix << "fp Continue                       = " << m_pfnContinue<< endl;

    pszDVASPECT = DumpDVASPECTFlags(m_dwAspect);
    dstrDump << pszPrefix << "Aspect flags                      = " << pszDVASPECT  << endl;
    CoTaskMemFree(pszDVASPECT);

    dstrDump << pszPrefix << "Size                              = " << m_dwSize     << endl;

    dstrDump << pszPrefix << "Width                             = " << m_lWidth     << endl;

    dstrDump << pszPrefix << "Height                            = " << m_lHeight    << endl;

    dstrDump << pszPrefix << "pCacheNode                        = " << m_pCacheNode << endl;

    // cleanup and provide pointer to character array
    *ppszDump = dstrDump.str();

    if (*ppszDump == NULL)
    {
        *ppszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return NOERROR;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCMfObject, public (_DEBUG only)
//
//  Synopsis:   calls the CMfObject::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pMFO]          - pointer to CMfObject
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCMfObject(CMfObject *pMFO, ULONG ulFlag, int nIndentLevel)
{
    HRESULT hresult;
    char *pszDump;

    if (pMFO == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    hresult = pMFO->Dump(&pszDump, ulFlag, nIndentLevel);

    if (hresult != NOERROR)
    {
        CoTaskMemFree(pszDump);

        return DumpHRESULT(hresult);
    }

    return pszDump;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\stdimpl\oregverb.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       oregverb.cpp
//
//  Contents:   Implementation of the enumerator for regdb verbs
//
//  Classes:    CEnumVerb
//
//  Functions:  OleRegEnumVerbs
//
//  History:    dd-mmm-yy Author    Comment
//              12-Sep-95 davidwor  made cache thread-safe
//              08-Sep-95 davidwor  optimized caching code
//              12-Jul-95 t-gabes   cache verbs and enumerator
//              01-Feb-95 t-ScottH  add Dump method to CEnumVerb and API
//                                  DumpCEnumVerb
//              25-Jan-94 alexgo    first pass at converting to Cairo-style
//                                  memory allocations.
//              11-Jan-94 alexgo    added VDATEHEAP macros to every function
//              31-Dec-93 erikgav   chicago port
//              01-Dec-93 alexgo    32bit port
//              12-Nov-93 jasonful  author
//
//--------------------------------------------------------------------------


#include <le2int.h>
#pragma SEG(oregverb)

#include <reterr.h>
#include "oleregpv.h"

#ifdef _DEBUG
#include <dbgdump.h>
#endif // _DEBUG

ASSERTDATA

#define MAX_STR                 256
#define MAX_VERB                33
#define OLEIVERB_LOWEST         OLEIVERB_HIDE

// reg db key
static const OLECHAR VERB[] = OLESTR("\\Verb");

// stdfileediting key
static const OLECHAR STDFILE[] = OLESTR("\\Protocol\\StdFileEditing");

// default verbs
static const OLECHAR DEFVERB[] =
        OLESTR("Software\\Microsoft\\OLE1\\UnregisteredVerb");

// default verb
static const OLECHAR EDIT[] = OLESTR("Edit");

//+-------------------------------------------------------------------------
//
//  Struct:     VerbList
//
//  Purpose:    to hold the enumerator's list of verbs
//
//  History:    dd-mmm-yy Author    Comment
//              12-Jul-95 t-gabes   author
//
//  Notes:
//
//--------------------------------------------------------------------------

typedef struct VerbList
{
    ULONG       cRef;           // reference count
    CLSID       clsid;          // CLSID of the cached verbs
    ULONG       cVerbs;         // count of verbs in oleverb array
    OLEVERB     oleverb[1];     // variable-size list of verbs
} VERBLIST, *LPVERBLIST;

STDAPI MakeVerbList(HKEY hkey, REFCLSID rclsid, LPVERBLIST *ppVerbList);
STDAPI OleReleaseEnumVerbCache(void);

//+-------------------------------------------------------------------------
//
//  Class:      CEnumVerb
//
//  Purpose:    enumerates the verbs listed in the reg db for a given class
//
//  Interface:  IEnumOLEVERB
//
//  History:    dd-mmm-yy Author    Comment
//              02-Aug-95 t-gabes   rewrote to use cache
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

class FAR CEnumVerb : public IEnumOLEVERB, public CPrivAlloc
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IEnumOLEVERB methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, LPOLEVERB reelt,
            ULONG FAR* pceltFetched);
    STDMETHOD(Skip) (THIS_ ULONG celt);
    STDMETHOD(Reset) (THIS);
    STDMETHOD(Clone) (THIS_ LPENUMOLEVERB FAR* ppenm);

    ULONG GetRefCount (void);

#ifdef _DEBUG
    HRESULT Dump (char **ppszDump, ULONG ulFlag, int nIndentLevel);
    friend char *DumpCEnumVerb (CEnumVerb *pEV, ULONG ulFlag, int nIndentLevel);
#endif // _DEBUG

private:
    CEnumVerb (LPVERBLIST pVerbs, LONG iVerb=0);

    ULONG       m_cRef;         // reference count
    LONG        m_iVerb;        // current verb number (0 is the first)
    LPVERBLIST  m_VerbList;     // all the verbs for this class

    friend HRESULT STDAPICALLTYPE OleRegEnumVerbs (REFCLSID, LPENUMOLEVERB FAR*);
    friend HRESULT STDAPICALLTYPE OleReleaseEnumVerbCache(void);
};

//+-------------------------------------------------------------------------
//
//  Struct:     EnumVerbCache
//
//  Purpose:    to cache the enumerator for the last enumerated class
//
//  History:    dd-mmm-yy Author    Comment
//              12-Jul-95 t-gabes   author
//
//
//--------------------------------------------------------------------------

typedef struct
{
    CEnumVerb*  pEnum;      // pointer to the cached enumerator
#ifdef _DEBUG
    LONG        iCalls;     // total calls counter
    LONG        iHits;      // cache hit counter
#endif // _DEBUG
} EnumVerbCache;

// Last enumerator used
EnumVerbCache g_EnumCache = { NULL };

//+-------------------------------------------------------------------------
//
//  Function:   OleRegEnumVerbs
//
//  Synopsis:   Creates an enumerator to go through the verbs in the reg db
//              for the given class ID
//
//  Effects:
//
//  Arguments:  [clsid]         -- the class ID we're interested in
//              [ppenum]        -- where to put the enumerator pointer
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Makes sure that the info is in the database and then
//              creates the enumerator
//
//  History:    dd-mmm-yy Author    Comment
//              12-Sep-95 davidwor  modified to make thread-safe
//              08-Sep-95 davidwor  optimized caching code
//              12-Jul-95 t-gabes   rewrote to use cache
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleRegEnumVerbs)
STDAPI OleRegEnumVerbs
        (REFCLSID           clsid,
        LPENUMOLEVERB FAR*  ppenum)
{
    OLETRACEIN((API_OleRegEnumVerbs, PARAMFMT("clsid= %I, ppenum= %p"),
                    &clsid, ppenum));
    VDATEHEAP();

    CEnumVerb*  pEnum;
    LPVERBLIST  pVerbList;
    BOOL        fOle1Class;
    OLECHAR     szKey[MAX_STR];
    int         cchBase;
    HKEY        hkey;
    HRESULT     hresult;

    VDATEPTROUT_LABEL (ppenum, LPENUMOLEVERB, errSafeRtn, hresult);
    *ppenum = NULL;

#ifdef _DEBUG
    // Increment total calls counter
    InterlockedIncrement(&g_EnumCache.iCalls);
#endif // _DEBUG
    // Grab the global enumerator and put a NULL in its place. If another
    // thread calls into OleRegEnumVerbs during this operation they won't
    // be able to mess with the enumerator we're working with.
    pEnum = (CEnumVerb *)InterlockedExchangePointer((PVOID *)&g_EnumCache.pEnum, 0);
    if (pEnum != NULL)
    {
        if (IsEqualCLSID(clsid, pEnum->m_VerbList->clsid))
        {
#ifdef _DEBUG
            // Increment cache hits counter
            InterlockedIncrement(&g_EnumCache.iHits);
#endif

            if (1 == pEnum->GetRefCount())
            {
                // No other references -> AddRef and return this copy
                *ppenum = pEnum;
                pEnum->AddRef();
                pEnum->Reset();
                LEDebugOut((DEB_TRACE, "VERB Enumerator cache handed out\n"));
            }
            else
            {
                // Has additional references -> return a Cloned copy
                if (NOERROR == pEnum->Clone(ppenum))
                {
                    (*ppenum)->Reset();
                    LEDebugOut((DEB_TRACE, "VERB Enumerator cache cloned\n"));
                }
            }

            // Swap our enumerator with the current contents of the global. If
            // another thread called OleRegEnumVerbs during this operation and
            // stored an enumerator in the global, we need to Release it.
            pEnum = (CEnumVerb *)InterlockedExchangePointer((PVOID *)&g_EnumCache.pEnum, (PVOID)pEnum);
            if (pEnum != NULL)
            {
                pEnum->Release();
                LEDebugOut((DEB_TRACE, "VERB Enumerator cache released (replacing global)\n"));
            }

            goto errRtn;
        }
        else
        {
            // Our clsid didn't match the clsid of the cache so we'll release the
            // cached enumerator and proceed with creating a new enumerator to
            // store in the global cache.
            pEnum->Release();
            LEDebugOut((DEB_TRACE, "VERB Enumerator cache released (different CLSID)\n"));
        }
    }

    fOle1Class = CoIsOle1Class(clsid);

    if (fOle1Class)
    {
        // Fills out szKey and cchBase as follows:
        //   szKey   - "<ProgID>\Protocol\StdFileEditing"
        //   cchBase - length of "<ProgID>" portion

        LPOLESTR    psz;

        RetErr(ProgIDFromCLSID(clsid, &psz));

        cchBase = _xstrlen(psz);

        memcpy(szKey, psz, cchBase * sizeof(OLECHAR));
        memcpy(&szKey[cchBase], STDFILE, sizeof(STDFILE));

        PubMemFree(psz);
    }
    else
    {
        // Fills out szKey and cchBase as follows:
        //   szKey   - "CLSID\{clsid}"
        //   cchBase - length of full szKey string

        memcpy(szKey, szClsidRoot, sizeof(szClsidRoot));

        if (0 == StringFromCLSID2(clsid, &szKey[sizeof(szClsidRoot) / sizeof(OLECHAR) - 1], sizeof(szKey)))
            return ResultFromScode(E_OUTOFMEMORY);

        cchBase = _xstrlen(szKey);
    }

    // append "\Verb" to the end
    _xstrcat(szKey, VERB);

    if (ERROR_SUCCESS != OpenClassesRootKeyEx(
                szKey,
                KEY_READ,
                &hkey))
    {
        // verb key doesn't exist, so figure out why

        szKey[cchBase] = OLESTR('\0');
        // szKey now contains one of the following:
        //   OLE1 - "<ProgID>"
        //   OLE2 - "CLSID\{clsid}"

        if (ERROR_SUCCESS != OpenClassesRootKeyEx(
                    szKey,
                    KEY_READ,
                    &hkey))
        {
            // the class isn't registered
            return ReportResult(0, REGDB_E_CLASSNOTREG, 0, 0);
        }

        CLOSE(hkey);

        // The class has no verbs. This is fine for OLE1 but not OLE2
        if (!fOle1Class)
            return ResultFromScode(OLEOBJ_E_NOVERBS);

        // if hkey is NULL, MakeVerbList will use the default verb
        hkey = NULL;
    }

    // make the verb list
    RetErr(MakeVerbList(hkey, clsid, &pVerbList));
    Assert(pVerbList != NULL);

    // create a CEnumVerb object (this calls AddRef on pVerbList)
    pEnum = new FAR CEnumVerb(pVerbList);
    if (NULL == pEnum)
    {
        PrivMemFree(pVerbList);
        hresult = ResultFromScode(E_OUTOFMEMORY);
        goto errSafeRtn;
    }

    // set the out parameter and AddRef on behalf of the caller
    *ppenum = pEnum;
    pEnum->AddRef();

    LEDebugOut((DEB_TRACE, "VERB Enumerator cache created\n"));

    // Swap our enumerator with the current contents of the global. If
    // another thread called OleRegEnumVerbs during this operation and
    // stored an enumerator in the global, we need to Release it.
    pEnum = (CEnumVerb *)InterlockedExchangePointer((PVOID *)&g_EnumCache.pEnum, (PVOID)pEnum);
    if (pEnum != NULL)
    {
        pEnum->Release();
        LEDebugOut((DEB_TRACE, "VERB Enumerator cache released (replacing global)\n"));
    }

errRtn:
    hresult = *ppenum ? NOERROR : ResultFromScode (E_OUTOFMEMORY);

    // hook the new interface
    CALLHOOKOBJECTCREATE(S_OK, CLSID_NULL, IID_IEnumOLEVERB, (IUnknown **)ppenum);

errSafeRtn:
    LEDebugOut((DEB_TRACE, "VERB Enumerator cache hits/calls: (%d/%d)\n", g_EnumCache.iHits, g_EnumCache.iCalls));
    OLETRACEOUT((API_OleRegEnumVerbs, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   MakeVerbList
//
//  Synopsis:   gets the list of verbs from the reg db
//
//  Effects:
//
//  Arguments:  [hkey]          -- handle to reg key to get verbs from
//                                 NULL for default verb
//              [rclsid]        -- CLSID to store with verb list
//              [ppVerbList]    -- OUT paramater for where to put result
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: none
//
//  Algorithm:  Calls RegEnumKey to loop through the reg keys and create a
//              list of verbs, which are then collected into one
//              larger list.  Also, flags and attribs are parsed out.
//
//  History:    dd-mmm-yy Author    Comment
//              12-Sep-95 davidwor  modified to make thread-safe
//              08-Sep-95 davidwor  optimized caching code
//              14-Jul-95 t-gabes   Author
//
//  Notes:
//              OLEVERB flags are given default values if they are not in
//              reg db. This works well for OLE 1.0
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumVerb_MakeVerbList)
STDAPI MakeVerbList
        (HKEY       hkey,
        REFCLSID    rclsid,
        LPVERBLIST  *ppVerbList)
{
    VDATEHEAP();

    LONG        cbValue;
    LPVERBLIST  pVerbList;
    OLECHAR     szBuf[MAX_VERB];        // regdb buffer
    OLEVERB *   rgVerbs = NULL;         // verb info array
    OLECHAR *   pszNames = NULL;        // list of NULL-delimited verb names
    DWORD       cchSpace = 0;           // space left for verb names (in bytes)
    DWORD       cchName;                // size of one name (in bytes)
    DWORD       cVerbs;                 // number of verbs
    DWORD       iVerbs;                 // verb array index
    LONG        maxVerbIdx = 0;
    LONG        maxVerbNum = OLEIVERB_LOWEST;
    LONG        minVerbNum = OLEIVERB_LOWEST - 1;
    HRESULT     hresult = NOERROR;

    VDATEPTROUT(ppVerbList, LPVERBLIST);
    *ppVerbList = NULL;

    if (NULL == hkey)
    {
        /*
         * No verbs registered
         */

        cbValue = sizeof(szBuf);

        // read the default verb name from the reg db
        if (ERROR_SUCCESS != QueryClassesRootValue(
                DEFVERB,
                szBuf,
                &cbValue))
        {
            // when all else fails, use the string "Edit"
            _xstrcpy(szBuf, EDIT);
            cbValue = sizeof(EDIT);
        }

        pVerbList = (LPVERBLIST)PrivMemAlloc(sizeof(VERBLIST) + cbValue);
        if (NULL == pVerbList)
            return ResultFromScode(E_OUTOFMEMORY);

        // fill out a single verb with the defaults
        pVerbList->cRef = 0;
        pVerbList->clsid = rclsid;
        pVerbList->cVerbs = 1;
        pVerbList->oleverb[0].lVerb = 0;
        pVerbList->oleverb[0].fuFlags = MF_STRING | MF_UNCHECKED | MF_ENABLED;
        pVerbList->oleverb[0].grfAttribs = OLEVERBATTRIB_ONCONTAINERMENU;
        pVerbList->oleverb[0].lpszVerbName = (LPOLESTR)&pVerbList->oleverb[1];
        memcpy(pVerbList->oleverb[0].lpszVerbName, szBuf, cbValue);

        *ppVerbList = pVerbList;
        return NOERROR;
    }

    /*
     * Have registered verbs
     */

    // determine number of subkeys
    hresult = RegQueryInfoKey(
            hkey, NULL, NULL, NULL, &cVerbs,
            NULL, NULL, NULL, NULL, NULL, NULL, NULL);

    if (ERROR_SUCCESS != hresult || !cVerbs)
    {
        // they have a "Verb" key but no verb subkeys
        hresult = ResultFromScode(OLEOBJ_E_NOVERBS);
        goto errRtn;
    }

    // preallocate this much space for verb names (in bytes)
    cchSpace = sizeof(OLECHAR) * cVerbs * 32;

    // allocate the VerbList with space for each OLEVERB
    // and space for 32 characters for each verb name
    pVerbList = (LPVERBLIST)PrivMemAlloc(
            sizeof(VERBLIST) +
            sizeof(OLEVERB) * (cVerbs - 1) +
            cchSpace);

    if (NULL == pVerbList)
    {
        hresult = ResultFromScode(E_OUTOFMEMORY);
        goto errRtn;
    }

    pVerbList->cRef = 0;
    pVerbList->clsid = rclsid;
    pVerbList->cVerbs = cVerbs;

    // Allocate temporary storage for the verbs. Later we'll move the verbs
    // from this list into the final VerbList in sorted order.
    rgVerbs = (OLEVERB *)PrivMemAlloc(sizeof(OLEVERB) * cVerbs);

    if (NULL == rgVerbs)
    {
        hresult = ResultFromScode(E_OUTOFMEMORY);
        goto errRtn;
    }

    // point pszNames at the first verb name
    pszNames = (OLECHAR *)&pVerbList->oleverb[cVerbs];

    for (iVerbs = 0; iVerbs < cVerbs; iVerbs++)
    {
        LPOLESTR    psz = pszNames;

        // read a verb number
        hresult = RegEnumKey(hkey, iVerbs, szBuf, MAX_VERB);
        if (NOERROR != hresult)
            goto errRtn;

        // this is how much space remains
        cbValue = cchSpace;

        // read a verb name on the verb number
        hresult = RegQueryValue(hkey, szBuf, pszNames, &cbValue);
        if (NOERROR != hresult)
            goto errRtn;

        // for safety, make sure verb name isn't too long
        if (cbValue > (MAX_VERB + 8) * sizeof(OLECHAR))
        {
            cbValue = (MAX_VERB + 8) * sizeof(OLECHAR);
            pszNames[MAX_VERB + 8 - 1] = OLESTR('\0');
        }

        rgVerbs[iVerbs].lVerb = Atol(szBuf);

        if (rgVerbs[iVerbs].lVerb > maxVerbNum)
        {
            maxVerbNum = rgVerbs[iVerbs].lVerb;
            maxVerbIdx = iVerbs;
        }

        rgVerbs[iVerbs].fuFlags = MF_STRING | MF_UNCHECKED | MF_ENABLED;
        rgVerbs[iVerbs].grfAttribs = OLEVERBATTRIB_ONCONTAINERMENU;

        // see if the verb name is followed by a delimiter
        while (*psz && *psz != DELIM[0])
            psz++;

        // determine size of verb name (in characters)
        cchName = (ULONG)(psz - pszNames + 1);

        if (*psz == DELIM[0])
        {
            // Parse the menu flags and attributes by finding each delimiter
            // and stuffing a 0 over it. This breaks the string into three
            // parts which can be handled separately.
            LPOLESTR    pszFlags;

            *psz++ = OLESTR('\0');              // replace delimiter with 0
            pszFlags = psz;                     // remember start of flags

            while (*psz && *psz != DELIM[0])
                psz++;

            if (*psz == DELIM[0])
            {
                *psz++ = OLESTR('\0');          // replace delimiter with 0
                if (*psz != 0)
                    rgVerbs[iVerbs].grfAttribs = Atol(psz);
            }

            // now that the flags portion ends with a 0 we can parse it
            if (*pszFlags != 0)
                rgVerbs[iVerbs].fuFlags = Atol(pszFlags);
        }

        rgVerbs[iVerbs].lpszVerbName = pszNames;

        pszNames += cchName;    // move pointer to next verb name position
        cchSpace -= cchName;    // calculate how much space is left
    }

    // sort the verbs while putting them in the final verb list
    for (iVerbs = 0; iVerbs < cVerbs; iVerbs++)
    {
        LONG    minCurNum = maxVerbNum,
                minCurIdx = maxVerbIdx;
        LONG    idx, num;

        // find next verb
        for (idx = 0; idx < (LONG)cVerbs; idx++)
        {
            num = rgVerbs[idx].lVerb;
            if (num < minCurNum && num > minVerbNum)
            {
                minCurNum = num;
                minCurIdx = idx;
            }
        }

        pVerbList->oleverb[iVerbs].lVerb        = rgVerbs[minCurIdx].lVerb;
        pVerbList->oleverb[iVerbs].fuFlags      = rgVerbs[minCurIdx].fuFlags;
        pVerbList->oleverb[iVerbs].grfAttribs   = rgVerbs[minCurIdx].grfAttribs;
        pVerbList->oleverb[iVerbs].lpszVerbName = rgVerbs[minCurIdx].lpszVerbName;

        minVerbNum = minCurNum;
    }

    *ppVerbList = pVerbList;

errRtn:
    if (rgVerbs)
        PrivMemFree(rgVerbs);
    if (hkey)
        CLOSE(hkey);

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleReleaseEnumVerbCache
//
//  Synopsis:   Releases the cache if necessary
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Just call Release method
//
//  History:    dd-mmm-yy Author    Comment
//              12-Sep-95 davidwor  modified to make thread-safe
//              18-Jul-95 t-gabes   Author
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleReleaseEnumVerbCache)
STDAPI OleReleaseEnumVerbCache(void)
{
    CEnumVerb*  pEnum;

    pEnum = (CEnumVerb *)InterlockedExchangePointer((PVOID *)&g_EnumCache.pEnum, 0);

    if (NULL != pEnum)
    {
        pEnum->Release();
        LEDebugOut((DEB_TRACE, "VERB Enumerator cache released\n"));
    }

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumVerb::CEnumVerb
//
//  Synopsis:   Constructor for the verb enumerator
//
//  Effects:
//
//  Arguments:
//              [pVerbs]        -- ptr to the verb list
//              [iVerb]         -- the index of the verb we're on
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              12-Sep-95 davidwor  modified to make thread-safe
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumVerb_ctor)
CEnumVerb::CEnumVerb
        (LPVERBLIST pVerbs,
        LONG        iVerb)
{
    VDATEHEAP();

    m_cRef     = 1;
    m_iVerb    = iVerb;
    m_VerbList = pVerbs;

    // AddRef the VerbList since we now have a reference to it
    InterlockedIncrement((long *)&m_VerbList->cRef);
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumVerb::QueryInterface
//
//  Synopsis:   returns the interface implementation
//
//  Effects:
//
//  Arguments:  [iid]           -- the requested interface id
//              [ppv]           -- where to put a pointer to the interface
//
//  Requires:
//
//  Returns:    NOERROR, E_NOINTERFACE
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IEnumOLEVERB
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumVerb_QueryInterface)
STDMETHODIMP CEnumVerb::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    VDATEHEAP();

    VDATEPTROUT(ppv, LPVOID);

    if (IsEqualIID(iid, IID_IUnknown) ||
        IsEqualIID(iid, IID_IEnumOLEVERB))
    {
        *ppv = this;
        AddRef();
        return NOERROR;
    }

    *ppv = NULL;
    return ResultFromScode(E_NOINTERFACE);
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumVerb::AddRef
//
//  Synopsis:   increments the reference count
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IEnumOLEVERB
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              12-Sep-95 davidwor  modified to make thread-safe
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumVerb_AddRef)
STDMETHODIMP_(ULONG) CEnumVerb::AddRef(void)
{
    VDATEHEAP();

    return InterlockedIncrement((long *)&m_cRef);
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumVerb::Release
//
//  Synopsis:   decrements the reference count
//
//  Effects:    will delete the object when ref count goes to zero
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG -- the new ref count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IEnumOLEVERB
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              12-Sep-95 davidwor  modified to make thread-safe
//              18-Jul-95 t-gabes   release verb cache when finished
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumVerb_Release)
STDMETHODIMP_(ULONG) CEnumVerb::Release(void)
{
    VDATEHEAP();

    ULONG   cRef;

    cRef = InterlockedDecrement((long *)&m_cRef);
    if (0 == cRef)
    {
        if (0 == InterlockedDecrement((long *)&m_VerbList->cRef))
        {
            // no more references to m_VerbList so free it
            PrivMemFree(m_VerbList);
            LEDebugOut((DEB_TRACE, "VERB Enumerator verb list released\n"));
        }

        delete this;
        return 0;
    }

    return cRef;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumVerb::Next
//
//  Synopsis:   gets the next [cverb] verbs from the verb list
//
//  Effects:
//
//  Arguments:  [cverb]         -- the number of verbs to get
//              [rgverb]        -- where to put the verbs
//              [pcverbFetched] -- where to put the num of verbs retrieved
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IEnumOLEVERB
//
//  Algorithm:  loops through [cverb] times and grabs the info from the
//              reg db
//
//  History:    dd-mmm-yy Author    Comment
//              17-Jul-95 t-gabes   rewrote to use cache
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumVerb_Next)
STDMETHODIMP CEnumVerb::Next
        (ULONG      cverb,
        LPOLEVERB   rgverb,
        ULONG FAR*  pcverbFetched)
{
    VDATEHEAP();

    ULONG       iVerb;  // number successfully fetched
    HRESULT     hresult = NOERROR;

    if (!rgverb)
    {
        if (pcverbFetched)
            *pcverbFetched = 0;
        VDATEPTROUT(rgverb, OLEVERB);
    }

    if (pcverbFetched)
    {
        VDATEPTROUT(pcverbFetched, ULONG);
    }
    else if (cverb != 1)
    {
        // the spec says that if pcverbFetched == NULL, then
        // the count of elements to fetch must be 1
        return ResultFromScode(E_INVALIDARG);
    }

    for (iVerb = 0; iVerb < cverb; iVerb++)
    {
        if (m_iVerb >= (LONG)m_VerbList->cVerbs)
        {
            // no more
            hresult = ResultFromScode(S_FALSE);
            goto errRtn;
        }

        OLEVERB *lpov = &m_VerbList->oleverb[m_iVerb++];

        rgverb[iVerb].lVerb        = lpov->lVerb;
        rgverb[iVerb].fuFlags      = lpov->fuFlags;
        rgverb[iVerb].grfAttribs   = lpov->grfAttribs;
        rgverb[iVerb].lpszVerbName = UtDupString(lpov->lpszVerbName);
    }

errRtn:
    if (pcverbFetched)
    {
        *pcverbFetched = iVerb;
    }

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumVerb::Skip
//
//  Synopsis:   skips [c] verbs in the enumeration
//
//  Effects:
//
//  Arguments:  [c]     -- the number of verbs to skip
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IEnumOLEVERB
//
//  Algorithm:  adds [c] to the verb index
//
//  History:    dd-mmm-yy Author    Comment
//              17-Jul-95 t-gabes   rewrote to use cache
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumVerb_Skip)
STDMETHODIMP CEnumVerb::Skip(ULONG c)
{
    VDATEHEAP();

    m_iVerb += c;
    if (m_iVerb > (LONG)m_VerbList->cVerbs)
    {
        // skipping too many
        m_iVerb = m_VerbList->cVerbs;
        return ResultFromScode(S_FALSE);
    }

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumVerb::Reset
//
//  Synopsis:   resets the verb enumeration to the beginning
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IEnumOLEVERB
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              17-Jul-95 t-gabes   rewrote to use cache
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumVerb_Reset)
STDMETHODIMP CEnumVerb::Reset(void)
{
    VDATEHEAP();

    m_iVerb = 0;

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumVerb::Clone
//
//  Synopsis:   creates a copy of the enumerator
//
//  Effects:
//
//  Arguments:  [ppenum]        -- where to put a pointer to the new clone
//
//  Requires:
//
//  Returns:    NOERROR, E_OUTOFMEMORY
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IEnumOLEVERB
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumVerb_Clone)
STDMETHODIMP CEnumVerb::Clone(LPENUMOLEVERB FAR* ppenum)
{
    VDATEHEAP();

    VDATEPTROUT(ppenum, LPENUMOLEVERB);

    *ppenum = new FAR CEnumVerb(m_VerbList, m_iVerb);
    if (!*ppenum)
        return ResultFromScode(E_OUTOFMEMORY);

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumVerb::GetRefCount
//
//  Synopsis:   Gets the reference count for the class
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    ref count
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              12-Jul-95 t-gabes   Author
//
//  Notes:      This is needed so OleRegEnumVerbs knows when to dup the cache
//
//--------------------------------------------------------------------------

#pragma SEG(CEnumVerb_GetRefCount)
ULONG CEnumVerb::GetRefCount (void)
{
    VDATEHEAP();

    return m_cRef;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumVerb::Dump, public (_DEBUG only)
//
//  Synopsis:   return a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [ppszDump]      - an out pointer to a null terminated character array
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   [ppszDump]  - argument
//
//  Derivation:
//
//  Algorithm:  use dbgstream to create a string containing information on the
//              content of data structures
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

HRESULT CEnumVerb::Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    dbgstream dstrPrefix;
    dbgstream dstrDump;

    // determine prefix of newlines
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << this << " _VB ";
    }

    // determine indentation prefix for all newlines
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    dstrDump << pszPrefix << "No. of References     = " << m_cRef     << endl;

    dstrDump << pszPrefix << "Address of verb list  = " << m_VerbList << endl;

    dstrDump << pszPrefix << "Current Verb Number   = " << m_iVerb    << endl;

    // cleanup and provide pointer to character array
    *ppszDump = dstrDump.str();

    if (*ppszDump == NULL)
    {
        *ppszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return NOERROR;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCEnumVerb, public (_DEBUG only)
//
//  Synopsis:   calls the CEnumVerb::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pEV]          - pointer to CEnumVerb
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCEnumVerb(CEnumVerb *pEV, ULONG ulFlag, int nIndentLevel)
{
    char *pszDump;

    if (NULL == pEV)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    pEV->Dump(&pszDump, ulFlag, nIndentLevel);

    return pszDump;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\stdimpl\icon.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       icon.cpp
//
//  Contents:   Functions to create DVASPECT_ICON metafile from a filename
//              or class ID
//
//  Classes:
//
//  Functions:
//              OleGetIconOfFile
//              OleGetIconOfClass
//              OleMetafilePictFromIconAndLabel
//
//              HIconAndSourceFromClass: Extracts the first icon in a class's
//                      server path and returns the path and icon index to
//                      caller.
//              FIconFileFromClass:     Retrieves the path to the exe/dll
//                      containing the default icon, and the index of the icon.
//              IconLabelTextOut
//              XformWidthInPixelsToHimetric
//                      Converts an int width into HiMetric units
//              XformWidthInHimetricToPixels
//                      Converts an int width from HiMetric units
//              XformHeightInPixelsToHimetric
//                      Converts an int height into HiMetric units
//              XformHeightInHimetricToPixels
//                      Converts an int height from HiMetric units
//
//  History:    dd-mmm-yy Author    Comment
//              24-Nov-93 alexgo    32bit port
//              15-Dec-93 alexgo    fixed some bad UNICODE string handling
//              11-Jan-94 alexgo    added VDATEHEAP macros to every function
//              25-Jan-94 alexgo    first pass at converting to Cairo-style
//                                  memory allocations.
//              26-Apr-94 AlexT     Add tracing, fix bugs, etc
//              27-Dec-94 alexgo    fixed multithreading problems, added
//                                  support for quoted icon names
//
//  Notes:
//
//--------------------------------------------------------------------------


#include <le2int.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <commdlg.h>
#include <memory.h>
#include <cderr.h>
#include <resource.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#include "icon.h"

#define OLEUI_CCHKEYMAX         256
#define OLEUI_CCHPATHMAX        256
#define OLEUI_CCHLABELMAX       42

#define ICONINDEX               0

#define AUXUSERTYPE_SHORTNAME   USERCLASSTYPE_SHORT  // short name
#define HIMETRIC_PER_INCH       2540      // number HIMETRIC units per inch
#define PTS_PER_INCH            72      // number points (font size) per inch

#define MAP_PIX_TO_LOGHIM(x,ppli)   MulDiv(HIMETRIC_PER_INCH, (x), (ppli))
#define MAP_LOGHIM_TO_PIX(x,ppli)   MulDiv((ppli), (x), HIMETRIC_PER_INCH)

static OLECHAR const gszDefIconLabelKey[] =
    OLESTR( "Software\\Microsoft\\OLE2\\DefaultIconLabel");

#define IS_SEPARATOR(c)         ( (c) == OLESTR(' ') || (c) == OLESTR('\\') || (c) == OLESTR('/') || (c) == OLESTR('\t') || (c) == OLESTR('!') || (c) == OLESTR(':') )

//REVIEW:  what about the \\ case for UNC filenames, could it be considered a delimter also?

#define IS_FILENAME_DELIM(c)    ( (c) == OLESTR('\\') || (c) == OLESTR('/') || (c) == OLESTR(':') )


#ifdef WIN32
#define LSTRCPYN(lpdst, lpsrc, cch) \
(\
    lpdst[cch-1] = OLESTR('\0'), \
    lstrcpynW(lpdst, lpsrc, cch-1)\
)
#else
#define LSTRCPYN(lpdst, lpsrc, cch) \
(\
    lpdst[cch-1] = OLESTR('\0'), \
    lstrncpy(lpdst, lpsrc, cch-1)\
)
#endif

void IconLabelTextOut(HDC hDC, HFONT hFont, int nXStart, int nYStart,
              UINT fuOptions, RECT FAR * lpRect, LPCSTR lpszString,
              UINT cchString);

/*******
 *
 * ICON METAFILE FORMAT:
 *
 * The metafile generated with OleMetafilePictFromIconAndLabel contains
 * the following records which are used by the functions in DRAWICON.C
 * to draw the icon with and without the label and to extract the icon,
 * label, and icon source/index.
 *
 *  SetWindowOrg
 *  SetWindowExt
 *  DrawIcon:
 *      Inserts records of DIBBITBLT or DIBSTRETCHBLT, once for the
 *      AND mask, one for the image bits.
 *  Escape with the comment "IconOnly"
 *      This indicates where to stop record enumeration to draw only
 *      the icon.
 *  SetTextColor
 *  SetBkColor
 *  CreateFont
 *  SelectObject on the font.
 *  ExtTextOut
 *      One or more ExtTextOuts occur if the label is wrapped.  The
 *      text in these records is used to extract the label.
 *  SelectObject on the old font.
 *  DeleteObject on the font.
 *  Escape with a comment that contains the path to the icon source (ANSI).
 *  Escape with a comment that is the string of the icon index (ANSI).
 *
 *  Additional optional fields (new for 32-bit OLE, and only present if icon
 *  source or label was not translatable):
 *
 *  Escape with a comment that contains the string
 *    "OLE: Icon label next (Unicode)" (ANSI string)
 *  Escape with a comment that contains the Unicode label
 *
 *  Escape with a comment that contains the string
 *    "OLE: Icon source next (Unicode)" (ANSI string)
 *  Escape with a comment that contains the path to the icon source (UNICODE)
 *
 *******/




//+-------------------------------------------------------------------------
//
//  Function:   OleGetIconOfFile (public)
//
//  Synopsis:   Returns a hMetaPict containing an icon and label (filename)
//              for the specified filename
//
//  Effects:
//
//  Arguments:  [lpszPath]      -- LPOLESTR path including filename to use
//              [fUseAsLabel]   -- if TRUE, use the filename as the icon's
//                                 label; no label if FALSE
//
//  Requires:   lpszPath != NULL
//
//  Returns:    HGLOBAL to the hMetaPict
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  tries to get the icon from the class ID or from the
//              exe associated with the file extension.
//
//  History:    dd-mmm-yy Author    Comment
//              27-Nov-93 alexgo    first 32bit port (minor cleanup)
//              15-Dec-93 alexgo    changed lstrlen to _xstrlen
//              27-Dec-93 erikgav   chicago port
//              28-Dec-94 alexgo    fixed multithreading problems
//
//  Notes:
//
//--------------------------------------------------------------------------

STDAPI_(HGLOBAL) OleGetIconOfFile(LPOLESTR lpszPath, BOOL fUseFileAsLabel)
{
    OLETRACEIN((API_OleGetIconOfFile, PARAMFMT("lpszPath= %ws, fUseFileAsLabel= %B"),
        lpszPath, fUseFileAsLabel));

    VDATEHEAP();

    HGLOBAL         hMetaPict = NULL;
    BOOL            fUseGenericDocIcon = FALSE;
    BOOL            bRet;

    OLECHAR         szIconFile[OLEUI_CCHPATHMAX+1];
    OLECHAR         szLabel[OLEUI_CCHLABELMAX];
    OLECHAR         szDocument[OLEUI_CCHLABELMAX];
    CLSID           clsid;
    HICON           hDefIcon = NULL;
    UINT            IconIndex = 0;
    UINT            cchPath;
    BOOL            fGotLabel = FALSE;

    HRESULT         hResult = E_FAIL;
    UINT uFlags;

    LEDebugOut((DEB_TRACE, "%p _IN OleGetIconOfFile (%p, %d)\n",
                NULL, lpszPath, fUseFileAsLabel));


        *szIconFile = OLESTR('\0');
        *szDocument = OLESTR('\0');

    if (NULL == lpszPath)
    {
        //  The spec allows a NULL lpszPath...
        hMetaPict = NULL;
        goto ErrRtn;
    }

    SHFILEINFO shfi;
    uFlags = (SHGFI_ICON | SHGFI_LARGEICON | SHGFI_DISPLAYNAME |
                        SHGFI_TYPENAME | SHGFI_USEFILEATTRIBUTES);

    _xmemset(&shfi, 0, sizeof(shfi));

    if (fUseFileAsLabel)
        uFlags |= SHGFI_LINKOVERLAY;

    if (SHGetFileInfo( lpszPath, FILE_ATTRIBUTE_NORMAL, &shfi, sizeof(shfi), uFlags))
    {
                if (shfi.iIcon == 0)
                {
                        // Destroy the returned icon
                        DestroyIcon(shfi.hIcon);

                        // REVIEW: if non-NULL path str, do we want parameter validation?
                        hResult = GetClassFile(lpszPath, &clsid);

                        // use the clsid we got to get to the icon
                        if( NOERROR == hResult )
                        {
                                hDefIcon = HIconAndSourceFromClass(clsid, szIconFile, &IconIndex);
                        }
                }
                else
                {
                        hDefIcon = shfi.hIcon;

                        hResult = NOERROR;

                        OLECHAR szUnicodeLabel[OLEUI_CCHLABELMAX];


                        if (fUseFileAsLabel)
                                LSTRCPYN(szLabel, shfi.szDisplayName, sizeof(szLabel)/sizeof(OLECHAR));
                        else
                                LSTRCPYN(szLabel, shfi.szTypeName, sizeof(szLabel)/sizeof(OLECHAR));
                        
                        fGotLabel = TRUE;
                        
                        // need to fill out szIconFile, which is the path to the file in which the icon
                        // was extracted.  Unfortunately, the shell can't return this value to us, so we
                        // must get the file that OLE would have used in the fallback case.  This could
                        // be inconsistant with the shell if the application has installed a custom icon
                        // handler.
                        hResult = GetClassFile(lpszPath, &clsid);

                        if( NOERROR == hResult )
                        {
                            FIconFileFromClass(clsid, szIconFile, OLEUI_CCHPATHMAX, &IconIndex);
                        }

                }

    }

    cchPath = _xstrlen(lpszPath);

    if ((NOERROR != hResult) || (NULL == hDefIcon))
    {
        WORD index = 0;
        // we need to copy into a large buffer because the second
        // parameter of ExtractAssociatedIcon (the path name) is an
        // in/out
        lstrcpyn(szIconFile, lpszPath, sizeof(szIconFile)/sizeof(*szIconFile));
        hDefIcon = ExtractAssociatedIcon(g_hmodOLE2, szIconFile, &index);
        IconIndex = index;
    }

    if (fUseGenericDocIcon || hDefIcon <= (HICON)1)
    {
        DWORD dwLen;

        dwLen = GetModuleFileName(g_hmodOLE2,
                                  szIconFile,
                                  sizeof(szIconFile) / sizeof(OLECHAR));
        if (0 == dwLen)
        {
            LEDebugOut((DEB_WARN,
                        "OleGetIconOfFile: GetModuleFileName failed - %ld",
                        GetLastError()));
            goto ErrRtn;
        }

        szIconFile[sizeof(szIconFile)/sizeof(szIconFile[0])-1] = L'\0';

        IconIndex = ICONINDEX;
        hDefIcon = LoadIcon(g_hmodOLE2, MAKEINTRESOURCE(DEFICON));
    }

    // Now let's get the label we want to use.
    if (fGotLabel)
    {
        // Do nothing
    }
    else if (fUseFileAsLabel)
    {
        // This assumes the path uses only '\', '/', and '.' as separators
        // strip off path, so we just have the filename.
        LPOLESTR        lpszBeginFile;

        // set pointer to END of path, so we can walk backwards
        // through it.
        lpszBeginFile = lpszPath + cchPath - 1;

        while ((lpszBeginFile >= lpszPath) &&
               (!IS_FILENAME_DELIM(*lpszBeginFile)))
        {
#ifdef WIN32
            lpszBeginFile--;
#else
            lpszBeginFile = CharPrev(lpszPath, lpszBeginFile);
#endif
        }

        lpszBeginFile++;  // step back over the delimiter
        //  LSTRCPYN takes count of characters!
        LSTRCPYN(szLabel, lpszBeginFile, sizeof(szLabel) / sizeof(OLECHAR));
    }

    // use the short user type (AuxUserType2) for the label
    else if (0 == OleStdGetAuxUserType(clsid, AUXUSERTYPE_SHORTNAME,
                                       szLabel, OLEUI_CCHLABELMAX, NULL))
    {
        if (OLESTR('\0')==szDocument[0]) // review, this is always true
        {
            LONG lRet;
            LONG lcb;

            lcb = sizeof (szDocument);
            lRet = QueryClassesRootValue(gszDefIconLabelKey, szDocument, &lcb);

#if DBG==1
            if (ERROR_SUCCESS != lRet)
            {
                LEDebugOut((DEB_WARN,
                            "RegQueryValue for default icon label failed - %d\n",
                            GetLastError()));

            }

#endif

                        // NULL out last byte of string so don't rely on Reg behavior if buffer isn't big enough
                        szDocument[OLEUI_CCHLABELMAX -1] =  OLESTR('\0');
        }

        _xstrcpy(szLabel, szDocument);
    }

    hMetaPict = OleMetafilePictFromIconAndLabel(hDefIcon, szLabel,
                                                szIconFile, IconIndex);

    bRet = DestroyIcon(hDefIcon);
    Win4Assert(bRet && "DestroyIcon failed");

ErrRtn:
    LEDebugOut((DEB_TRACE, "%p OUT OleGetIconOfFile( %lx )\n",
                hMetaPict ));

    OLETRACEOUTEX((API_OleGetIconOfFile, RETURNFMT("%h"), hMetaPict));

    return hMetaPict;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetAssociatedExectutable
//
//  Synopsis:   Finds the executables associated with the provided extension
//
//  Effects:
//
//  Arguments:  [lpszExtension]         -- pointer to the extension
//              [lpszExecutable]        -- where to put the executable name
//                                         (assumes OLEUIPATHMAX OLECHAR buffer
//                                          from calling function)
//
//  Requires:   lpszExecutable must be large enough to hold the path
//
//  Returns:    TRUE if exe found, FALSE otherwise
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Queries reg database
//
//  History:    dd-mmm-yy Author    Comment
//              27-Nov-93 alexgo    32bit port
//              15-Dec-93 alexgo    fixed bug calculating size of strings
//              26-Apr-94 AlexT     Tracing, bug fixes
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL FAR PASCAL GetAssociatedExecutable(LPOLESTR lpszExtension,
                                        LPOLESTR lpszExecutable)
{
    VDATEHEAP();

    BOOL            bRet = FALSE;
    HKEY            hKey;
    LONG            dw;
    LRESULT         lRet;
    OLECHAR         szValue[OLEUI_CCHKEYMAX];
    OLECHAR         szKey[OLEUI_CCHKEYMAX];
    LPOLESTR        lpszTemp, lpszExe;

    LEDebugOut((DEB_ITRACE, "%p _IN GetAssociatedExecutable (%p, %p)\n",
                NULL, lpszExtension, lpszExecutable));

        // REVIEW: actually returns a LONG, which is indeed an LRESULT, not
        // sure why the distinction here

    lRet = OpenClassesRootKey(NULL, &hKey);
    if (ERROR_SUCCESS != lRet)
    {
        goto ErrRtn;
    }

    dw = sizeof(szValue);

    lRet = RegQueryValue(hKey, lpszExtension, szValue, &dw);
    if (ERROR_SUCCESS != lRet)
    {
        RegCloseKey(hKey);
        goto ErrRtn;
    }

    // szValue now has ProgID
    StringCbCopy(szKey, sizeof(szKey), szValue);
    StringCbCat(szKey, sizeof(szKey), OLESTR("\\Shell\\Open\\Command"));

    // RegQueryValue wants *bytes*, not characters
    dw = sizeof(szValue);

    lRet = RegQueryValue(hKey, szKey, szValue, &dw);

    RegCloseKey(hKey);
    if (ERROR_SUCCESS != lRet)
    {
        goto ErrRtn;
    }

    // szValue now has an executable name in it.  Let's null-terminate
    // at the first post-executable space (so we don't have cmd line
    // args.

    lpszTemp = szValue;
    PUSHORT pCharTypes;

    pCharTypes = (PUSHORT)_alloca (sizeof (USHORT) * (lstrlenW(lpszTemp) + 1));
    if (pCharTypes == NULL)
    {
        goto ErrRtn;
    }

    GetStringTypeW (CT_CTYPE1, lpszTemp, -1, pCharTypes);

    while ((OLESTR('\0') != *lpszTemp) && (pCharTypes[lpszTemp - szValue] & C1_SPACE))
    {
        lpszTemp++;     // Strip off leading spaces
    }

    lpszExe = lpszTemp;

    while ((OLESTR('\0') != *lpszTemp) && ((pCharTypes[lpszTemp - szValue] & C1_SPACE) == 0))
    {
        lpszTemp++;     // Set through exe name
    }

    // null terminate at first space (or at end).
    *lpszTemp = OLESTR('\0');

    Win4Assert(_xstrlen(lpszExe) < OLEUI_CCHPATHMAX &&
               "GetAssociatedFile too long");
    _xstrcpy(lpszExecutable, lpszExe);

    bRet = TRUE;

ErrRtn:
    LEDebugOut((DEB_ITRACE, "%p OUT GetAssociatedExecutable( %d )\n",
                bRet ));

    return bRet;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleGetIconOfClass (public)
//
//  Synopsis:   returns a hMetaPict containing an icon and label for the
//              specified class ID
//
//  Effects:
//
//  Arguments:  [rclsid]                -- the class ID to use
//              [lpszLabel]             -- the label for the icon
//              [fUseTypeAsLabel]       -- if TRUE, use the clsid's user type
//                                         as the label
//
//  Requires:
//
//  Returns:    HGLOBAL
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              15-Dec-93 alexgo    fixed small bugs with Unicode strings
//              27-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDAPI_(HGLOBAL) OleGetIconOfClass(REFCLSID rclsid, LPOLESTR lpszLabel,
    BOOL fUseTypeAsLabel)
{
    OLETRACEIN((API_OleGetIconOfClass,
                                PARAMFMT("rclisd= %I, lpszLabel= %p, fUseTypeAsLabel= %B"),
                                &rclsid, lpszLabel, fUseTypeAsLabel));

    VDATEHEAP();

    BOOL            bRet;
    OLECHAR         szLabel[OLEUI_CCHLABELMAX];
    OLECHAR         szIconFile[OLEUI_CCHPATHMAX];
    OLECHAR         szDocument[OLEUI_CCHLABELMAX];
    HICON           hDefIcon;
    UINT            IconIndex;
    HGLOBAL         hMetaPict = NULL;

    LEDebugOut((DEB_TRACE, "%p _IN OleGetIconOfClass (%p, %p, %d)\n",
                NULL, &rclsid, lpszLabel, fUseTypeAsLabel));

    *szLabel = OLESTR('\0');
    *szDocument = OLESTR('\0');

#if DBG==1
    if (fUseTypeAsLabel && (NULL != lpszLabel))
    {
        LEDebugOut((DEB_WARN,
                   "Ignoring non-NULL lpszLabel passed to OleGetIconOfClass\n"));
    }
#endif

    if (!fUseTypeAsLabel)  // Use string passed in as label
    {
        if (NULL != lpszLabel)
        {
            //  LSTRCPYN takes count of characters!
            LSTRCPYN(szLabel, lpszLabel, sizeof(szLabel) / sizeof(OLECHAR));
        }
    }
    // Use AuxUserType2 (short name) as label
    else if (0 == OleStdGetAuxUserType(rclsid, AUXUSERTYPE_SHORTNAME,
                                       szLabel,
                                       sizeof(szLabel) / sizeof(OLECHAR),
                                       NULL))
    {
        // If we can't get the AuxUserType2, then try the long name
        if (0 == OleStdGetUserTypeOfClass(rclsid,
                                          szLabel,
                                          sizeof(szLabel) / sizeof(OLECHAR),
                                          NULL))
        {
            if (OLESTR('\0') == szDocument[0])
            {
                // RegQueryValue expects number of *bytes*
                LONG lRet;
                LONG lcb;

                lcb = sizeof(szDocument);

                lRet = QueryClassesRootValue(gszDefIconLabelKey, szDocument, &lcb);

#if DBG==1
                if (ERROR_SUCCESS != lRet)
                {
                    LEDebugOut((DEB_WARN,
                                "RegQueryValue for default icon label failed - %d\n",
                                GetLastError()));
                }
#endif
                // NULL out last byte of string so don't rely on Reg behavior if buffer isn't big enough
                                szDocument[OLEUI_CCHLABELMAX -1] =  OLESTR('\0');
            }

            _xstrcpy(szLabel, szDocument);  // last resort
        }
    }

    // Get the icon, icon index, and path to icon file
    hDefIcon = HIconAndSourceFromClass(rclsid, szIconFile, &IconIndex);

    if (NULL == hDefIcon)  // Use Vanilla Document
    {
        DWORD dwLen;

        dwLen = GetModuleFileName(g_hmodOLE2,
                                  szIconFile,
                                  sizeof(szIconFile) / sizeof(OLECHAR));
        if (0 == dwLen)
        {
            LEDebugOut((DEB_WARN,
                        "OleGetIconOfClass: GetModuleFileName failed - %ld",
                        GetLastError()));
            goto ErrRtn;
        }

        IconIndex = ICONINDEX;
        hDefIcon = LoadIcon(g_hmodOLE2, MAKEINTRESOURCE(DEFICON));
    }

    // Create the metafile
    hMetaPict = OleMetafilePictFromIconAndLabel(hDefIcon, szLabel,
                                                szIconFile, IconIndex);

    if(hDefIcon)
    {
        bRet = DestroyIcon(hDefIcon);
        Win4Assert(bRet && "DestroyIcon failed");
    }

ErrRtn:
    LEDebugOut((DEB_TRACE, "%p OUT OleGetIconOfClass( %p )\n",
                NULL, hMetaPict ));

    OLETRACEOUTEX((API_OleGetIconOfClass, RETURNFMT("%h"), hMetaPict));

    return hMetaPict;
}

//+-------------------------------------------------------------------------
//
//  Function:   HIconAndSourceFromClass
//
//  Synopsis:
//      Given an object class name, finds an associated executable in the
//      registration database and extracts the first icon from that
//      executable.  If none is available or the class has no associated
//      executable, this function returns NULL.
//
//  Effects:
//
//  Arguments:  [rclsid]        -- pointer the class id
//              [pszSource]     -- where to put the source of the icon
//              [puIcon]        -- where to store the index of the icon
//                              -- in [pszSource]
//
//  Requires:
//
//  Returns:    HICON -- handle to the extracted icon
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              27-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


HICON FAR PASCAL HIconAndSourceFromClass(REFCLSID rclsid, LPOLESTR pszSource,
                                         UINT FAR *puIcon)
{
    VDATEHEAP();

    HICON           hIcon = NULL;
    UINT            IconIndex;

    LEDebugOut((DEB_ITRACE, "%p _IN HIconAndSourceFromClass (%p, %p, %p)\n",
                NULL, &rclsid, pszSource, puIcon));

    if (IsEqualCLSID(CLSID_NULL, rclsid) || NULL==pszSource)
    {
        goto ErrRtn;
    }

    if (!FIconFileFromClass(rclsid, pszSource, OLEUI_CCHPATHMAX, &IconIndex))
    {
        goto ErrRtn;
    }

    hIcon = ExtractIcon(g_hmodOLE2, pszSource, IconIndex);

        // REVIEW: What's special about icon handles > 32 ?

    if ((HICON)32 > hIcon)
    {
        // REVIEW: any cleanup or releasing of handle needed before we lose
        //         the ptr?

        hIcon=NULL;
    }
    else
    {
        *puIcon= IconIndex;
    }

ErrRtn:

    LEDebugOut((DEB_ITRACE, "%p OUT HIconAndSourceFromClass( %lx ) [ %d ]\n",
                NULL, hIcon, *puIcon));

    return hIcon;
}

//+-------------------------------------------------------------------------
//
//  Function:   ExtractNameAndIndex
//
//  Synopsis:   from the given string, extract the file name and icon index
//
//  Effects:
//
//  Arguments:  [pszInfo]       -- the starting string
//              [pszEXE]        -- where to put the name (already allocated)
//              [cchEXE]        -- sizeof pszEXE
//              [pIndex]        -- where to put the icon index
//
//  Requires:   pszInfo != NULL
//              pszEXE != NULL
//              cchEXE != 0
//              pIndex != NULL
//
//  Returns:    BOOL -- TRUE on success, FALSE on error
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  takes strings of the form '"name",index' or 'name,index'
//              from the DefaultIcon registry entry
//
//              parsing is very simple: if the name is enclosed in quotes,
//              take that as the exe name.  If any other characters exist,
//              they must be a comma followed by digits (for the icon index)
//
//              if the name is not enclosed by quotes, assume the name is
//              the entire string up until the last comma (if it exists).
//
//  History:    dd-mmm-yy Author    Comment
//              27-Dec-94 alexgo    author
//
//  Notes:      legal filenames in NT and Win95 can include commas, but not
//              quotation marks.
//
//--------------------------------------------------------------------------

BOOL ExtractNameAndIndex( LPOLESTR pszInfo, LPOLESTR pszEXE, UINT cchEXE,
        UINT *pIndex)
{
    BOOL        fRet = FALSE;
    LPOLESTR    pszStart = pszInfo;
    LPOLESTR    pszIndex = NULL;
    LPOLESTR    pszDest = pszEXE;
    UINT        cchName = 0;
    DWORD       i = 0;

    Assert(pszInfo);
    Assert(pszEXE);
    Assert(cchEXE != 0);
    Assert(pIndex);

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN ExtractNameAndIndex ( \"%ws\" , \"%ws\" ,"
        " %d , %p )\n", NULL, pszInfo, pszEXE, cchEXE, pIndex));

    *pIndex = 0;

    if( *pszStart == OLESTR('\"') )
    {
        // name enclosed by quotes; just zoom down til the very last quote

        pszStart++;

        while( *pszStart != OLESTR('\0') && *pszStart != OLESTR('\"') &&
            pszDest < (pszEXE + cchEXE))
        {
            *pszDest = *pszStart;
            pszDest++;
            pszStart++;
        }

        *pszDest = OLESTR('\0');

        if( *pszStart == OLESTR('\"') )
        {
            pszIndex = pszStart + 1;
        }
        else
        {
            pszIndex = pszStart;
        }

        fRet = TRUE;
    }
    else
    {
        // find the last comma (if available)

        pszIndex = pszStart + _xstrlen(pszStart);

        while( *pszIndex != OLESTR(',') && pszIndex > pszStart )
        {
            pszIndex--;
        }

        // if no comma was found, just reset the index pointer to the end
        if( pszIndex == pszStart )
        {
            pszIndex = pszStart + _xstrlen(pszStart);
        }

        cchName = (ULONG) (pszIndex - pszStart)/sizeof(OLECHAR);

        if( cchEXE > cchName )
        {
            while( pszStart < pszIndex )
            {
                *pszDest = *pszStart;
                pszDest++;
                pszStart++;
            }
            *pszDest = OLESTR('\0');

            fRet = TRUE;
        }
    }

    // now fetch the index value

    if( *pszIndex == OLESTR(',') )
    {
        pszIndex++;
    }

    *pIndex = wcstol(pszIndex, NULL, 10);

    LEDebugOut((DEB_ITRACE, "%p OUT ExtractNameAndIndex ( %d ) [ \"%ws\" , "
        " %d ]\n", NULL, fRet, pszEXE, *pIndex));

    return fRet;
}

#if DBG == 1

//+-------------------------------------------------------------------------
//
//  Function:   VerifyExtractNameAndIndex
//
//  Synopsis:   verifies the functioning of ExtractNameAndIndex (DEBUG only)
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              27-Dec-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void VerifyExtractNameAndIndex( void )
{
    OLECHAR szName[256];
    UINT    index = 0;
    BOOL    fRet = FALSE;

    VDATEHEAP();

    fRet = ExtractNameAndIndex( OLESTR("\"foo,8\",8"), szName, 256, &index);

    Assert(fRet);
    Assert(_xstrcmp(szName, OLESTR("foo,8")) == 0);
    Assert(index == 8);

    fRet = ExtractNameAndIndex( OLESTR("foo,8,8,89"), szName, 256, &index);

    Assert(fRet);
    Assert(_xstrcmp(szName, OLESTR("foo,8,8")) == 0);
    Assert(index == 89);

    fRet = ExtractNameAndIndex( OLESTR("progman.exe"), szName, 256, &index);

    Assert(fRet);
    Assert(_xstrcmp(szName, OLESTR("progman.exe")) == 0);
    Assert(index == 0);

    fRet = ExtractNameAndIndex( OLESTR("\"progman.exe\""), szName, 256,
            &index);

    Assert(fRet);
    Assert(_xstrcmp(szName, OLESTR("progman.exe")) == 0);
    Assert(index == 0);

    VDATEHEAP();
}

#endif // DBG == 1

LONG RegReadDefValue(HKEY hKey, LPOLESTR pszKey, LPOLESTR *ppszValue)
{
	HKEY hSubKey = NULL;
	DWORD dw = 0;
	LONG lRet;
	LPOLESTR pszValue = NULL;

	lRet = RegOpenKeyEx(hKey, pszKey, 0, KEY_READ, &hSubKey);
	if(lRet != ERROR_SUCCESS) goto ErrRtn;

	lRet = RegQueryValueEx(hSubKey, NULL, NULL, NULL, NULL, &dw);
	if(lRet != ERROR_SUCCESS) goto ErrRtn;

	pszValue = (LPOLESTR) CoTaskMemAlloc(dw);
	if(!pszValue)
	{
		lRet = ERROR_OUTOFMEMORY;
		goto ErrRtn;
	}

	lRet = RegQueryValueEx(hSubKey, NULL, NULL, NULL, (PBYTE) pszValue, &dw);
	
ErrRtn:
	if(lRet != ERROR_SUCCESS && pszValue)
	{
		CoTaskMemFree(pszValue);
		pszValue = NULL;
	}

	if(hSubKey)
		RegCloseKey(hSubKey);

	*ppszValue = pszValue;
	return lRet;

}


//+-------------------------------------------------------------------------
//
//  Function:   FIconFileFromClass, private
//
//  Synopsis:   Looks up the path to the exectuble that contains the class
//              default icon
//
//  Effects:
//
//  Arguments:  [rclsid]        -- the class ID to lookup
//              [pszEXE]        -- where to put the server name
//              [cch]           -- UINT size of [pszEXE]
//              [lpIndex]       -- where to put the index of the icon
//                                 in the executable
//
//  Requires:   pszEXE != NULL
//              cch != 0
//
//  Returns:    TRUE if one or more characters where found for [pszEXE],
//              FALSE otherwise
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              27-Nov-93 alexgo    32bit port
//              15-Dec-93 alexgo    fixed memory allocation bug and
//                                  some UNICODE string manip stuff
//              27-Apr-94 AlexT     Tracing, clean up memory allocation
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL FAR PASCAL FIconFileFromClass(REFCLSID rclsid, LPOLESTR pszEXE,
    UINT cch, UINT FAR *lpIndex)
{
    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN FIconFileFromClass (%p, %p, %d, %p)\n",
                NULL, &rclsid, pszEXE, cch, lpIndex));

    Win4Assert(NULL != pszEXE && "Bad argument to FIconFileFromClass");
    Win4Assert(cch != 0 && "Bad argument to FIconFileFromClass");

    BOOL            bRet;
    LPOLESTR        lpBuffer    = NULL;
    LPOLESTR        lpBufferExp = NULL;

    LONG            dw;
    LONG            lRet;
    HKEY            hKey;
    LPOLESTR        lpIndexString;

    if (IsEqualCLSID(CLSID_NULL, rclsid))
    {
        bRet = FALSE;
        goto ErrRtn;
    }

    //Here, we alloc a buffer (maxpathlen + 8) to
    //pass to RegQueryValue.  Then, we copy the exe to pszEXE and the
    //index to *lpIndex.

    if (CoIsOle1Class(rclsid))
    {
        LPOLESTR lpszProgID;

        // we've got an ole 1.0 class on our hands, so we look at
        // progID\protocol\stdfileedting\server to get the
        // name of the executable.

        // REVIEW: could this possibly fail and leave you with an
        // invalid ptr passed into regopenkey?

        ProgIDFromCLSID(rclsid, &lpszProgID);

        //Open up the class key
        lRet=OpenClassesRootKey(lpszProgID, &hKey);
        PubMemFree(lpszProgID);

        if (ERROR_SUCCESS != lRet)
        {
            bRet = FALSE;
            goto ErrRtn;
        }

        // RegQueryValue expects number of *bytes*
        lRet = RegReadDefValue(hKey, OLESTR("Protocol\\StdFileEditing\\Server"), &lpBuffer);

        RegCloseKey(hKey);

        if (ERROR_SUCCESS != lRet)
        {
            bRet = FALSE;
            goto ErrRtn;
        }

        // Use server and 0 as the icon index
        dw = ExpandEnvironmentStringsW(lpBuffer, pszEXE, cch);
        if(dw == 0 || dw > (LONG)cch)
        {
            bRet = FALSE;
            goto ErrRtn;
        }

        // REVIEW: is this internally trusted?  No validation...
        // (same for rest of writes to it this fn)

        *lpIndex = 0;

        bRet = TRUE;
        goto ErrRtn;
    }

    /*
     * We have to go walking in the registration database under the
     * classname, so we first open the classname key and then check
     * under "\\DefaultIcon" to get the file that contains the icon.
     */

    {
        LPOLESTR pszClass;
        OLECHAR szKey[64];

        StringFromCLSID(rclsid, &pszClass);

        _xstrcpy(szKey, OLESTR("CLSID\\"));
        _xstrcat(szKey, pszClass);
        PubMemFree(pszClass);

        //Open up the class key
        lRet=OpenClassesRootKey(szKey, &hKey);
    }


    if (ERROR_SUCCESS != lRet)
    {
        bRet = FALSE;
        goto ErrRtn;
    }

    //Get the executable path and icon index.

    // RegQueryValue expects number of bytes
	lRet = RegReadDefValue(hKey, OLESTR("DefaultIcon"), &lpBuffer);

    if (ERROR_SUCCESS != lRet)
    {
		// no DefaultIcon  key...try LocalServer
		lRet = RegReadDefValue(hKey, OLESTR("LocalServer32"), &lpBuffer);
    }

    if (ERROR_SUCCESS != lRet)
    {
		lRet = RegReadDefValue(hKey, OLESTR("LocalServer"), &lpBuffer);
    }

    RegCloseKey(hKey);

    if (ERROR_SUCCESS != lRet)
    {
        // no LocalServer entry either...they're outta luck.
        bRet = FALSE;
        goto ErrRtn;
    }

    // Nt #335548
    dw = ExpandEnvironmentStringsW(lpBuffer, NULL, 0);

	if(dw)
	{
		lpBufferExp = (LPOLESTR) CoTaskMemAlloc(dw * sizeof(OLECHAR));
		dw = ExpandEnvironmentStringsW(lpBuffer, lpBufferExp, dw);
	}

    if(!dw)
    {
        LEDebugOut((DEB_WARN, "ExpandEnvStrings failure!"));
        bRet = FALSE;
        goto ErrRtn;
    }

    // lpBuffer contains a string that looks like
    // "<pathtoexe>,<iconindex>",
    // so we need to separate the path and the icon index.

    bRet = ExtractNameAndIndex(lpBufferExp, pszEXE, cch, lpIndex);

#if DBG == 1
    // do some quick checking while we're at it.
    VerifyExtractNameAndIndex();
#endif // DBG == 1

ErrRtn:
	if(lpBuffer)
		CoTaskMemFree(lpBuffer);
	if(lpBufferExp)
		CoTaskMemFree(lpBufferExp);

    LEDebugOut((DEB_ITRACE, "%p OUT FIconFileFromClass ( %d ) [%d]\n",
                NULL, bRet, *lpIndex));

    return bRet;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleMetafilePictFromIconAndLabel (public)
//
//  Synopsis:
//      Creates a METAFILEPICT structure that container a metafile in which
//      the icon and label are drawn.  A comment record is inserted between
//      the icon and the label code so our special draw function can stop
//      playing before the label.
//
//  Effects:
//
//  Arguments:  [hIcon]         -- icon to draw into the metafile
//              [pszLabel]      -- the label string
//              [pszSourceFile] -- local pathname of the icon
//              [iIcon]         -- index into [pszSourceFile] for the icon
//
//  Requires:
//
//  Returns:    HGLOBAL to a METAFILEPICT structure (using MM_ANISOTROPIC
//              mapping mode)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              27-Nov-93 alexgo    first 32bit port
//              15-Dec-93 alexgo    fixed bugs with UNICODE strings
//              09-Mar-94 AlexT     Make this backwards compatible
//
//  Notes:      REVIEW32:: need to fix font grabbing etc, to be international
//              friendly, see comments below
//
//--------------------------------------------------------------------------

STDAPI_(HGLOBAL) OleMetafilePictFromIconAndLabel(HICON hIcon,
    LPOLESTR pwcsLabel, LPOLESTR pwcsSourceFile, UINT iIcon)
{
    OLETRACEIN((API_OleMetafilePictFromIconAndLabel,
                                PARAMFMT("hIcon= %h, pwcsLabel= %ws, pwcsSourceFile= %ws, iIcon= %d"),
                                        hIcon, pwcsLabel, pwcsSourceFile, iIcon));

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN OleMetafilePictFromIconAndLabel (%p, %p, %p, %d)\n",
                NULL, hIcon, pwcsLabel, pwcsSourceFile, iIcon));

    //Where to stop to exclude label (explicitly ANSI)
    static char szIconOnly[] = "IconOnly";
    static char szIconLabelNext[] =  "OLE: Icon label next (Unicode)";
    static char szIconSourceNext[] = "OLE: Icon source next (Unicode)";
    static char szDefaultChar[] = "?";

        // REVIEW: Mein Got!  This is a huge fn, could it be broken up?

    HGLOBAL         hMem = NULL;
    HDC             hDC, hDCScreen = NULL;
    HMETAFILE       hMF;
    LPMETAFILEPICT  pMF;
    OLECHAR         wszIconLabel[OLEUI_CCHLABELMAX + 1];
    char            szIconLabel[OLEUI_CCHLABELMAX + 1];
    UINT            cchLabelW;
    UINT            cchLabelA;
    UINT            cchIndex;
    BOOL            bUsedDefaultChar;
    TEXTMETRICA     textMetric;
    UINT            cxIcon, cyIcon;
    UINT            cxText, cyText;
    UINT            cx, cy;
    HFONT           hFont, hSysFont, hFontT;
    int             cyFont;
    char            szIndex[10];
    RECT            TextRect;
    char *          pszSourceFile;
    UINT            cchSourceFile = 0;
    int             iRet;
    BOOL            bWriteUnicodeLabel;
    BOOL            bWriteUnicodeSource;
    LOGFONT         logfont;

    if (NULL == hIcon)  // null icon is valid
    {
        goto ErrRtn;
    }

    //Need to use the screen DC for these operations
    hDCScreen = GetDC(NULL);

	if (!hDCScreen)
		goto ErrRtn;

        // REVIEW: ptr validation on IN params?

    bWriteUnicodeSource = FALSE;
    pszSourceFile = NULL;
    if (NULL != pwcsSourceFile)
    {

        //  Prepare source file string
        cchSourceFile = _xstrlen(pwcsSourceFile) + 1;
#if defined(WIN32)
        pszSourceFile = (char *) PrivMemAlloc(cchSourceFile * sizeof(WCHAR));
#else
        pszSourceFile = (char *) PrivMemAlloc(cchSourceFile);
#endif // WIN32
        if (NULL == pszSourceFile)
        {
            LEDebugOut((DEB_WARN, "PrivMemAlloc(%d) failed\n",
                   cchSourceFile));
            goto ErrRtn;
        }

#if defined(WIN32)
        iRet = WideCharToMultiByte(AreFileApisANSI() ? CP_ACP : CP_OEMCP, 0,
                       pwcsSourceFile, cchSourceFile,
                       pszSourceFile, cchSourceFile * sizeof(WCHAR),
                       szDefaultChar, &bUsedDefaultChar);
#else
        iRet = WideCharToMultiByte(AreFileApisANSI() ? CP_ACP : CP_OEMCP, 0,
                       pwcsSourceFile, cchSourceFile,
                       pszSourceFile, cchSourceFile,
                       szDefaultChar, &bUsedDefaultChar);
#endif // WIN32

        bWriteUnicodeSource = bUsedDefaultChar;

        if (0 == iRet)
        {
            //  Unexpected failure, since at worst we should have
            //  just filled in pszSourceFile with default characters.
            LEDebugOut((DEB_WARN, "WideCharToMultiByte failed - %lx\n",
                   GetLastError()));
        }
    }

    //  Create a memory metafile.  We explicitly make it an ANSI metafile for
    //  backwards compatibility.
#ifdef WIN32
    hDC = CreateMetaFileA(NULL);
#else
    hDC = CreateMetaFile(NULL);
#endif

    if (NULL == hDC)
    {
        LEDebugOut((DEB_WARN, "CreateMetaFile failed - %lx\n",
                GetLastError()));

        PrivMemFree(pszSourceFile);
        goto ErrRtn;
    }

    //Allocate the metafilepict
    hMem = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, sizeof(METAFILEPICT));

    if (NULL == hMem)
    {
        LEDebugOut((DEB_WARN, "GlobalAlloc failed - %lx\n",
                GetLastError()));

        hMF = CloseMetaFile(hDC);
        DeleteMetaFile(hMF);
        PrivMemFree(pszSourceFile);
        goto ErrRtn;
    }

    //  Prepare ANSI label
    szIconLabel[0] = '\0';
    cchLabelW = 0;
    cchLabelA = 0;

    // REVIEW: don't follow the logic here: you conditionally set it above
    // and explicity clear it here?

    bWriteUnicodeLabel = FALSE;
    if (NULL != pwcsLabel)
    {
        cchLabelW = _xstrlen(pwcsLabel) + 1;
        if (OLEUI_CCHLABELMAX < cchLabelW)
        {
                //REVIEW: would it be worth warning of the truncation in debug builds?
                // or is this a common case?

            LSTRCPYN(wszIconLabel, pwcsLabel, OLEUI_CCHLABELMAX);
            wszIconLabel[OLEUI_CCHLABELMAX] = L'\0';
            pwcsLabel = wszIconLabel;
            cchLabelW = OLEUI_CCHLABELMAX;
        }

#if defined(WIN32)
        cchLabelA = WideCharToMultiByte(AreFileApisANSI() ? CP_ACP : CP_OEMCP, 0,
                       pwcsLabel, cchLabelW,
                       szIconLabel, 0,
                       NULL, NULL);
#else
        cchLabelA = cchLabelW;
#endif // WIN32

        //  We have a label - translate it to ANSI for the TextOut's...
        iRet = WideCharToMultiByte(AreFileApisANSI() ? CP_ACP : CP_OEMCP, 0,
                                   pwcsLabel, cchLabelW,
                                   szIconLabel, sizeof(szIconLabel),
                                   szDefaultChar, &bUsedDefaultChar);

        if (0 == iRet)
        {
            //  Unexpected failure, since at worst we should have
            //  just filled in pszSourceFile with default characters.
            LEDebugOut((DEB_WARN, "WideCharToMultiByte failed - %lx\n",
                   GetLastError()));
        }

        bWriteUnicodeLabel = bUsedDefaultChar;
    }

    LOGFONT lf;
    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);
    hFont = CreateFontIndirect(&lf);

    hFontT= (HFONT) SelectObject(hDCScreen, hFont);

    GetTextMetricsA(hDCScreen, &textMetric);

    //  We use double the height to provide some margin space
    cyText = textMetric.tmHeight*3; //max 2 lines & some space

    SelectObject(hDCScreen, hFontT);

    cxIcon = GetSystemMetrics(SM_CXICON);
    cyIcon = GetSystemMetrics(SM_CYICON);

    cxText = cxIcon*3;  //extent of text based upon icon width causes
                        //the label to look nice and proportionate.

    // If we have no label, then we want the metafile to be the width of
    // the icon (plus margin), not the width of the fattest string.
    if ('\0' == szIconLabel[0])
    {
        cx = cxIcon + cxIcon / 4;
    }
    else
    {
        cx = max(cxText, cxIcon);
    }

    cy = cyIcon + cyText + 4;   //  Why 4?

    //Set the metafile size to fit the icon and label
    SetMapMode(hDC, MM_ANISOTROPIC);
    SetWindowOrgEx(hDC, 0, 0, NULL);
    SetWindowExtEx(hDC, cx, cy, NULL);

    //Set up rectangle to pass to IconLabelTextOut
    SetRectEmpty(&TextRect);

    TextRect.right = cx;
    TextRect.bottom = cy;

    //Draw the icon and the text, centered with respect to each other.
    DrawIcon(hDC, (cx - cxIcon) / 2, 0, hIcon);

    //String that indicates where to stop if we're only doing icons

    Escape(hDC, MFCOMMENT, sizeof(szIconOnly), szIconOnly, NULL);

    SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
    SetBkMode(hDC, TRANSPARENT);

    IconLabelTextOut(hDC, hFont, 0, cy - cyText, ETO_CLIPPED,
    &TextRect, szIconLabel, cchLabelA);

    //  Write comments containing the icon source file and index.

    if (NULL != pwcsSourceFile)
    {
        AssertSz(pszSourceFile != NULL, "Unicode source existed");

        //Escape wants number of *bytes*
        Escape(hDC, MFCOMMENT,
               cchSourceFile, pszSourceFile, NULL);

        cchIndex = wsprintfA(szIndex, "%u", iIcon);

        //  Escape wants number of *bytes*
        Escape(hDC, MFCOMMENT, cchIndex + 1, szIndex, NULL);
    }
    else if (bWriteUnicodeLabel || bWriteUnicodeSource)
    {
        //  We're going to write out comment records for the Unicode
        //  strings, so we need to emit dummy ANSI source comments.

        //Escape wants number of *bytes*
        Escape(hDC, MFCOMMENT, sizeof(""), "", NULL);

        //  Escape wants number of *bytes*
        Escape(hDC, MFCOMMENT, sizeof("0"), "0", NULL);
    }

    if (bWriteUnicodeLabel)
    {
        //  Now write out the UNICODE label
        Escape(hDC, MFCOMMENT,
               sizeof(szIconLabelNext), szIconLabelNext, NULL);

        Escape(hDC, MFCOMMENT,
               cchLabelW * sizeof(OLECHAR), (LPSTR) pwcsLabel,
               NULL);
    }

    if (bWriteUnicodeSource)
    {
        //  Now write out the UNICODE label
        Escape(hDC, MFCOMMENT,
               sizeof(szIconSourceNext), szIconSourceNext, NULL);

        Escape(hDC, MFCOMMENT,
               cchSourceFile * sizeof(OLECHAR), (LPSTR) pwcsSourceFile,
               NULL);
    }

    //All done with the metafile, now stuff it all into a METAFILEPICT.
    hMF = CloseMetaFile(hDC);

    if (NULL==hMF)
    {
        GlobalFree(hMem);
        hMem = NULL;        
        goto ErrRtn;
    }

    pMF=(LPMETAFILEPICT)GlobalLock(hMem);

    //Transform to HIMETRICS
    cx=XformWidthInPixelsToHimetric(hDCScreen, cx);
    cy=XformHeightInPixelsToHimetric(hDCScreen, cy);

    pMF->mm=MM_ANISOTROPIC;
    pMF->xExt=cx;
    pMF->yExt=cy;
    pMF->hMF=hMF;

    GlobalUnlock(hMem);

	if(hFont)
		DeleteObject(hFont);
    PrivMemFree(pszSourceFile);

        // REVIEW: any need to release the font resource?
ErrRtn:
	if(hDCScreen)
		ReleaseDC(NULL, hDCScreen);

    LEDebugOut((DEB_TRACE, "%p OUT OleMetafilePictFromIconAndLabel ( %p )\n",
                NULL, hMem));

    OLETRACEOUTEX((API_OleMetafilePictFromIconAndLabel,
                                        RETURNFMT("%h"), hMem));
    return hMem;
}

//+-------------------------------------------------------------------------
//
//  Function:   IconLabelTextOut (internal)
//
//  Synopsis:
//      Replacement for DrawText to be used in the "Display as Icon" metafile.
//      Uses ExtTextOutA to output a string center on (at most) two lines.
//      Uses a very simple word wrap algorithm to split the lines.
//
//  Effects:
//
//  Arguments:  [hDC]           -- device context (cannot be NULL)
//              [hFont]         -- font to use
//              [nXStart]       -- x-coordinate of starting position
//              [nYStart]       -- y-coordinate of starting position
//              [fuOptions]     -- rectangle type
//              [lpRect]        -- rect far * containing rectangle to draw
//                                 text in.
//              [lpszString]    -- string to draw
//              [cchString]     -- length of string (truncated if over
//                                 OLEUI_CCHLABELMAX), including terminating
//                                 NULL
//
//  Requires:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              28-Nov-93 alexgo    initial 32bit port
//              09-Mar-94 AlexT     Use ANSI strings
//
//  Notes:
//
//--------------------------------------------------------------------------
// POSTPPC: The parameter 'cchString' is superfluous since lpszString
// is guaranteed to be null terminated
void IconLabelTextOut(HDC hDC, HFONT hFont, int nXStart, int nYStart,
              UINT fuOptions, RECT FAR * lpRect, LPCSTR lpszString,
              UINT cchString)
{
    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN IconLabelTextOut (%lx, %lx, %d, %d, %d, %p, %p, %d)\n",
                NULL, hDC, hFont,
                nXStart, nYStart, fuOptions, lpRect, lpszString, cchString));

    AssertSz(hDC != NULL, "Bad arg to IconLabelTextOut");
    AssertSz(lpszString != NULL, "Bad arg to IconLabelTextOut");
    AssertSz(strlen(lpszString) < OLEUI_CCHLABELMAX,
         "Bad arg to IconLabelTextOut");

        // REVIEW: does our compiler have to initialize static function scoped
        // data?  I know old versions did...

    static char     szSeparators[] = " \t\\/!:";
    static char     szTempBuff[OLEUI_CCHLABELMAX];

    HDC             hDCScreen;
    int             cxString, cyString, cxMaxString;
    int             cxFirstLine, cyFirstLine, cxSecondLine;
    int             index;
    char            chKeep;
    LPSTR           lpszSecondLine;
    LPSTR           lpstrLast;
    HFONT           hFontT;
    SIZE            size;
    int             cch = (int) strlen(lpszString);
    UINT            uiAlign = GDI_ERROR;

    // Initialization stuff...

    StringCbCopyA(szTempBuff, sizeof(szTempBuff), lpszString);

    // set maximum width

    cxMaxString = lpRect->right - lpRect->left;

    // get screen DC to do text size calculations
    hDCScreen = GetDC(NULL);

    if(!hDCScreen)
        return;

    hFontT= (HFONT)SelectObject(hDCScreen, hFont);

    // get the extent of our label
    GetTextExtentPointA(hDCScreen, szTempBuff, cch, &size);

    cxString = size.cx;
    cyString = size.cy;

    // Select in the font we want to use
    SelectObject(hDC, hFont);

    // Center the string
    uiAlign = SetTextAlign(hDC, TA_CENTER);

    // String is smaller than max string - just center, ETO, and return.
    if (cxString <= cxMaxString)
    {
        ExtTextOutA(hDC,
                nXStart + lpRect->right / 2,
                nYStart,
                fuOptions,
                lpRect,
                szTempBuff,
                cch,
                NULL);

        goto CleanupAndLeave;
    }


    // String is too long...we've got to word-wrap it.
    // Are there any spaces, slashes, tabs, or bangs in string?


    if (strlen(szTempBuff) != strcspn(szTempBuff, szSeparators))
    {
        // Yep, we've got spaces, so we'll try to find the largest
        // space-terminated string that will fit on the first line.

        index = cch;

        while (index >= 0)
        {
            // scan the string backwards for spaces, slashes,
            // tabs, or bangs

                // REVIEW: scary.  Could this result in a negative
                // index, or is it guarnateed to hit a separator
                // before that?

            while (!IS_SEPARATOR(szTempBuff[index]) )
            {
                index--;
            }

            if (index <= 0)
            {
                break;
            }

            // remember what char was there
            chKeep = szTempBuff[index];

            szTempBuff[index] = '\0';  // just for now

            GetTextExtentPointA(hDCScreen, szTempBuff,
                    index,&size);

            cxFirstLine = size.cx;
            cyFirstLine = size.cy;

                // REVIEW: but chKeep is NOT an OLECHAR

            // put the right OLECHAR back
            szTempBuff[index] = chKeep;

            if (cxFirstLine <= cxMaxString)
            {
                ExtTextOutA(hDC,
                        nXStart + lpRect->right / 2,
                        nYStart,
                        fuOptions,
                        lpRect,
                        szTempBuff,
                        index + 1,
                        NULL);

                lpszSecondLine = szTempBuff;
                lpszSecondLine += index + 1;

                GetTextExtentPointA(hDCScreen,
                            lpszSecondLine,
                            (int) strlen(lpszSecondLine),
                            &size);

                // If the second line is wider than the
                // rectangle, we just want to clip the text.
                cxSecondLine = min(size.cx, cxMaxString);

                ExtTextOutA(hDC,
                        nXStart + lpRect->right / 2,
                        nYStart + cyFirstLine,
                        fuOptions,
                        lpRect,
                        lpszSecondLine,
                        (int) strlen(lpszSecondLine),
                        NULL);

                goto CleanupAndLeave;
            }  // end if

            index--;
        }  // end while
    }  // end if

    // Here, there are either no spaces in the string
    // (strchr(szTempBuff, ' ') returned NULL), or there spaces in the
    // string, but they are positioned so that the first space
    // terminated string is still longer than one line.
    // So, we walk backwards from the end of the string until we
    // find the largest string that will fit on the first
    // line , and then we just clip the second line.

    // We allow 40 characters in the label, but the metafile is
    // only as wide as 10 W's (for aesthetics - 20 W's wide looked
    // dumb.  This means that if we split a long string in half (in
    // terms of characters), then we could still be wider than the
    // metafile.  So, if this is the case, we just step backwards
    // from the halfway point until we get something that will fit.
    // Since we just let ETO clip the second line

    cch = (int) strlen(szTempBuff);
    lpstrLast = &szTempBuff[cch];
    chKeep = *lpstrLast;
    *lpstrLast = '\0';

    GetTextExtentPointA(hDCScreen, szTempBuff, cch, &size);

    cxFirstLine = size.cx;
    cyFirstLine = size.cy;

    while (cxFirstLine > cxMaxString)
    {
        *lpstrLast = chKeep;

        // The string is always ansi, so always use CharPrevA.
        lpstrLast = CharPrevA(szTempBuff, lpstrLast);

        if (szTempBuff == lpstrLast)
        {
            goto CleanupAndLeave;
        }

        chKeep = *lpstrLast;
        *lpstrLast = '\0';

        // need to calculate the new length of the string
        cch = (int) strlen(szTempBuff);

        GetTextExtentPointA(hDCScreen, szTempBuff,
                    cch, &size);
        cxFirstLine = size.cx;
    }

    ExtTextOutA(hDC,
        nXStart + lpRect->right / 2,
        nYStart,
        fuOptions,
        lpRect,
        szTempBuff,
        (int) strlen(szTempBuff),
        NULL);

    szTempBuff[cch] = chKeep;
    lpszSecondLine = szTempBuff;
    lpszSecondLine += cch;

    GetTextExtentPointA(hDCScreen, lpszSecondLine,
            (int) strlen(lpszSecondLine), &size);

    // If the second line is wider than the rectangle, we
    // just want to clip the text.
    cxSecondLine = min(size.cx, cxMaxString);

    ExtTextOutA(hDC,
        nXStart + lpRect->right / 2,
        nYStart + cyFirstLine,
        fuOptions,
        lpRect,
        lpszSecondLine,
        (int) strlen(lpszSecondLine),
        NULL);

CleanupAndLeave:
    //  If we changed the alignment we restore it here
    if (uiAlign != GDI_ERROR)
    {
        SetTextAlign(hDC, uiAlign);
    }

    SelectObject(hDCScreen, hFontT);
    ReleaseDC(NULL, hDCScreen);

    LEDebugOut((DEB_ITRACE, "%p OUT IconLabelTextOut ()\n"));
}

//+-------------------------------------------------------------------------
//
//  Function:   OleStdGetUserTypeOfClass, private
//
//  Synopsis:   Returns the user type info of the specified class
//
//  Effects:
//
//  Arguments:  [rclsid]        -- the class ID in question
//              [lpszUserType]  -- where to put the user type string
//              [cch]           -- the length of [lpszUserType] (in
//                                 *characters*, not bytes)
//              [hKey]          -- handle to the reg db (may be NULL)
//
//  Requires:
//
//  Returns:    UINT -- the number of characters put into the return string
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDAPI_(UINT) OleStdGetUserTypeOfClass(REFCLSID rclsid, LPOLESTR lpszUserType, UINT cch, HKEY hKey)
{
    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN OleStdGetUserTypeOfClass (%p, %p, %d, %lx)\n",
                NULL, &rclsid, lpszUserType, cch, hKey));

    LONG dw = 0;
    LONG lRet;

    // REVIEW: would make more sense to set this when the reg is opened

    BOOL bCloseRegDB = FALSE;

    if (hKey == NULL)
    {
        //Open up the root key.
        lRet=OpenClassesRootKey(NULL, &hKey);

        if ((LONG)ERROR_SUCCESS!=lRet)
        {
            goto ErrRtn;
        }

        bCloseRegDB = TRUE;
    }


    // Get a string containing the class name
    {
        LPOLESTR lpszCLSID;
        OLECHAR szKey[128];

        StringFromCLSID(rclsid, &lpszCLSID);

        _xstrcpy(szKey, OLESTR("CLSID\\"));
        _xstrcat(szKey, lpszCLSID);
        PubMemFree((LPVOID)lpszCLSID);

        dw = cch * sizeof(OLECHAR);
        lRet = RegQueryValue(hKey, szKey, lpszUserType, &dw);
        dw = dw / sizeof(OLECHAR);
    }

    if ((LONG)ERROR_SUCCESS!=lRet)
    {
        dw = 0;
    }

    if ( ((LONG)ERROR_SUCCESS!=lRet) && (CoIsOle1Class(rclsid)) )
    {
        LPOLESTR lpszProgID;

        // We've got an OLE 1.0 class, so let's try to get the user
        // type name from the ProgID entry.

        ProgIDFromCLSID(rclsid, &lpszProgID);

        // REVIEW: will progidfromclsid always set your ptr for you?

        dw = cch * sizeof(OLECHAR);
        lRet = RegQueryValue(hKey, lpszProgID, lpszUserType, &dw);
        dw = dw / sizeof(OLECHAR);

        PubMemFree((LPVOID)lpszProgID);

        if ((LONG)ERROR_SUCCESS != lRet)
        {
            dw = 0;
        }
    }


    if (bCloseRegDB)
    {
        RegCloseKey(hKey);
    }

ErrRtn:
    LEDebugOut((DEB_ITRACE, "%p OUT OleStdGetUserTypeOfClass ( %d )\n",
                NULL, dw));

    return (UINT)dw;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleStdGetAuxUserType, private
//
//  Synopsis:   Returns the specified AuxUserType from the reg db
//
//  Effects:
//
//  Arguments:  [rclsid]        -- the class ID in question
//              [hKey]          -- handle to the reg db root (may be NULL)
//              [wAuxUserType]  -- which field to look for (name, exe, etc)
//              [lpszUserType]  -- where to put the returned string
//              [cch]           -- size of [lpszUserType] in *characters*
//
//  Requires:
//
//  Returns:    UINT -- number of characters in returned string.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//              27-Apr-94 AlexT     Tracing, clean up
//
//  Notes:
//
//--------------------------------------------------------------------------

STDAPI_(UINT) OleStdGetAuxUserType(REFCLSID rclsid,
    WORD            wAuxUserType,
    LPOLESTR        lpszAuxUserType,
    int             cch,
    HKEY            hKey)
{
    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN OleStdGetAuxUserType (%p, %hu, %p, %d, %lx)\n",
                NULL, &rclsid, wAuxUserType, lpszAuxUserType, cch, hKey));

    LONG            dw = 0;
    HKEY            hThisKey;
    BOOL            bCloseRegDB = FALSE;
    LRESULT         lRet;
    LPOLESTR        lpszCLSID;
    OLECHAR         szKey[OLEUI_CCHKEYMAX];
    OLECHAR         szTemp[32];

    lpszAuxUserType[0] = OLESTR('\0');

    if (NULL == hKey)
    {
        lRet = OpenClassesRootKey(NULL, &hThisKey);

        if (ERROR_SUCCESS != lRet)
        {
            goto ErrRtn;
        }

        bCloseRegDB = TRUE;
    }
    else
    {
        hThisKey = hKey;
    }

    StringFromCLSID(rclsid, &lpszCLSID);

    _xstrcpy(szKey, OLESTR("CLSID\\"));
    _xstrcat(szKey, lpszCLSID);
    wsprintf(szTemp, OLESTR("\\AuxUserType\\%d"), wAuxUserType);
    _xstrcat(szKey, szTemp);
    PubMemFree(lpszCLSID);

    dw = cch * sizeof(OLECHAR);

    lRet = RegQueryValue(hThisKey, szKey, lpszAuxUserType, &dw);

    //  Convert dw from byte count to OLECHAR count
    dw = dw / sizeof(OLECHAR);

    if (ERROR_SUCCESS != lRet)
    {
        dw = 0;
        lpszAuxUserType[0] = '\0';
    }

    if (bCloseRegDB)
    {
        RegCloseKey(hThisKey);
    }

ErrRtn:
    //  dw is

    LEDebugOut((DEB_ITRACE, "%p OUT OleStdGetAuxUserType ( %d )\n",
                NULL, dw));

    return (UINT)dw;
}

//REVIEW: these seem redundant, could the fns be mereged creatively?

//+-------------------------------------------------------------------------
//
//  Function:
//      XformWidthInPixelsToHimetric
//      XformWidthInHimetricToPixels
//      XformHeightInPixelsToHimetric
//      XformHeightInHimetricToPixels
//
//  Synopsis:
//      Functions to convert an int between a device coordinate system and
//      logical HiMetric units.
//
//  Effects:
//
//  Arguments:
//
//      [hDC]           HDC providing reference to the pixel mapping.  If
//                      NULL, a screen DC is used.
//
//   Size Functions:
//      [lpSizeSrc]     LPSIZEL providing the structure to convert.  This
//                      contains pixels in XformSizeInPixelsToHimetric and
//                      logical HiMetric units in the complement function.
//      [lpSizeDst]     LPSIZEL providing the structure to receive converted
//                      units.  This contains pixels in
//                      XformSizeInPixelsToHimetric and logical HiMetric
//                      units in the complement function.
//
//   Width Functions:
//      [iWidth]        int containing the value to convert.
//
//  Requires:
//
//  Returns:
//      Size Functions:     None
//      Width Functions:    Converted value of the input parameters.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port (initial)
//
//  Notes:
//
//  When displaying on the screen, Window apps display everything enlarged
//  from its actual size so that it is easier to read. For example, if an
//  app wants to display a 1in. horizontal line, that when printed is
//  actually a 1in. line on the printed page, then it will display the line
//  on the screen physically larger than 1in. This is described as a line
//  that is "logically" 1in. along the display width. Windows maintains as
//  part of the device-specific information about a given display device:
//      LOGPIXELSX -- no. of pixels per logical in along the display width
//      LOGPIXELSY -- no. of pixels per logical in along the display height
//
//  The following formula converts a distance in pixels into its equivalent
//  logical HIMETRIC units:
//
//      DistInHiMetric = (HIMETRIC_PER_INCH * DistInPix)
//                       -------------------------------
//                           PIXELS_PER_LOGICAL_IN
//
//
//      REVIEW32::  merge all these functions into one, as they all do
//      basically the same thing
//
//--------------------------------------------------------------------------

STDAPI_(int) XformWidthInPixelsToHimetric(HDC hDC, int iWidthInPix)
{
    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN XformWidthInPixelsToHimetric (%lx, %d)\n",
                NULL, hDC, iWidthInPix));

    int             iXppli;     // Pixels per logical inch along width
    int             iWidthInHiMetric;
    BOOL            fSystemDC=FALSE;

    if (NULL==hDC)
    {
        hDC=GetDC(NULL);
        fSystemDC=TRUE;

        if(!hDC)
            return 0;
    }

    iXppli = GetDeviceCaps (hDC, LOGPIXELSX);

    // We got pixel units, convert them to logical HIMETRIC along
    // the display
    iWidthInHiMetric = MAP_PIX_TO_LOGHIM(iWidthInPix, iXppli);

    if (fSystemDC)
    {
        ReleaseDC(NULL, hDC);
    }

    LEDebugOut((DEB_ITRACE, "%p OUT XformWidthInPixelsToHimetric (%d)\n",
                NULL, iWidthInHiMetric));

    return iWidthInHiMetric;
}

//+-------------------------------------------------------------------------
//
//  Function:   XformWidthInHimetricToPixels
//
//  Synopsis:   see XformWidthInPixelsToHimetric
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDAPI_(int) XformWidthInHimetricToPixels(HDC hDC, int iWidthInHiMetric)
{
    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN XformWidthInHimetricToPixels (%lx, %d)\n",
                NULL, hDC, iWidthInHiMetric));

    int             iXppli;     //Pixels per logical inch along width
    int             iWidthInPix;
    BOOL            fSystemDC=FALSE;

    if (NULL==hDC)
    {
        hDC=GetDC(NULL);
        fSystemDC=TRUE;

        if(!hDC)
            return 0;
    }

    iXppli = GetDeviceCaps (hDC, LOGPIXELSX);

    // We got logical HIMETRIC along the display, convert them to
    // pixel units

    iWidthInPix = MAP_LOGHIM_TO_PIX(iWidthInHiMetric, iXppli);

    if (fSystemDC)
    {
        ReleaseDC(NULL, hDC);
    }

    LEDebugOut((DEB_ITRACE, "%p OUT XformWidthInHimetricToPixels (%d)\n",
                NULL, iWidthInPix));

    return iWidthInPix;
}

//+-------------------------------------------------------------------------
//
//  Function:   XformHeightInPixelsToHimetric
//
//  Synopsis:   see XformWidthInPixelsToHimetric
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDAPI_(int) XformHeightInPixelsToHimetric(HDC hDC, int iHeightInPix)
{
    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN XformHeightInPixelsToHimetric (%lx, %d)\n",
                NULL, hDC, iHeightInPix));

    int             iYppli;     //Pixels per logical inch along height
    int             iHeightInHiMetric;
    BOOL            fSystemDC=FALSE;

    if (NULL==hDC)
    {
        hDC=GetDC(NULL);
        fSystemDC=TRUE;

        if(!hDC)
            return 0;
    }

    iYppli = GetDeviceCaps (hDC, LOGPIXELSY);

    // We got pixel units, convert them to logical HIMETRIC along the
    // display
    iHeightInHiMetric = MAP_PIX_TO_LOGHIM(iHeightInPix, iYppli);

    if (fSystemDC)
    {
        ReleaseDC(NULL, hDC);
    }

    LEDebugOut((DEB_ITRACE, "%p OUT XformHeightInPixelsToHimetric (%d)\n",
                NULL, hDC, iHeightInHiMetric));

    return iHeightInHiMetric;
}

//+-------------------------------------------------------------------------
//
//  Function:   XformHeightInHimetricToPixels
//
//  Synopsis:   see XformWidthInPixelsToHimetric
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDAPI_(int) XformHeightInHimetricToPixels(HDC hDC, int iHeightInHiMetric)
{
    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN XformHeightInHimetricToPixels (%lx, %d)\n",
               NULL, hDC, iHeightInHiMetric));

    int             iYppli;     //Pixels per logical inch along height
    int             iHeightInPix;
    BOOL            fSystemDC=FALSE;

    if (NULL==hDC)
    {
        hDC=GetDC(NULL);
        fSystemDC=TRUE;

        if(!hDC)
            return 0;
    }

    iYppli = GetDeviceCaps (hDC, LOGPIXELSY);

    // We got logical HIMETRIC along the display, convert them to pixel
    // units
    iHeightInPix = MAP_LOGHIM_TO_PIX(iHeightInHiMetric, iYppli);

    if (fSystemDC)
    {
        ReleaseDC(NULL, hDC);
    }

    LEDebugOut((DEB_ITRACE, "%p OUT XformHeightInHimetricToPixels (%d)\n",
               NULL, hDC, iHeightInPix));

    return iHeightInPix;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\stdimpl\olereg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       olereg.cpp
//
//  Contents:   Helper routines to interrogate the reg database
//
//  Classes:
//
//  Functions:  OleRegGetUserType
//              OleRegGetMiscStatus
//              OleGetAutoConvert
//              OleSetAutoConvert
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-94 alexgo    added VDATEHEAP macros to every function
//              30-Nov-93 alexgo    32bit port
//              11-Nov-92 jasonful  author
//
//--------------------------------------------------------------------------

#include <le2int.h>
#pragma SEG(olereg)

#include <reterr.h>
#include "oleregpv.h"
#include <ctype.h>

ASSERTDATA
#define MAX_STR 512

// Reg Db Keys
static const OLECHAR szAuxUserTypeKey[]         = OLESTR("AuxUserType");
static const OLECHAR szMiscStatusKey[]          = OLESTR("MiscStatus") ;
static const OLECHAR szProgIDKey[]              = OLESTR("ProgID");
static const OLECHAR szClsidKey[]               = OLESTR("Clsid");
static const OLECHAR szAutoConverTo[]    = OLESTR("AutoConvertTo");

// this is really a global variable
const OLECHAR szClsidRoot[]     = OLESTR("CLSID\\");


static INTERNAL OleRegGetDword
        (HKEY           hkey,
        LPCOLESTR       szKey,
        DWORD FAR*      pdw);

static INTERNAL OleRegGetDword
        (HKEY           hkey,
        DWORD           dwKey,
        DWORD FAR*      pdw);

static INTERNAL OleRegGetString
        (HKEY           hkey,
        LPCOLESTR       szKey,
        LPOLESTR FAR*   pszValue);


static  INTERNAL OleRegGetString
        (HKEY           hkey,
        DWORD           dwKey,
        LPOLESTR FAR*   pszValue);

//+-------------------------------------------------------------------------
//
//  Function:   Atol (static)
//
//  Synopsis:   Converts string to integer
//
//  Effects:
//
//  Arguments:  [sz]    -- the string
//
//  Requires:
//
//  Returns:    LONG
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:      32bit OLE just uses wcstol as a #define
//
//              original 16bit comment:
//
//              Replacement for stdlib atol,
//              which didn't work and doesn't take far pointers.
//              Must be tolerant of leading spaces.
//
//--------------------------------------------------------------------------
#ifndef WIN32
#pragma SEG(Atol)
FARINTERNAL_(LONG) Atol
        (LPOLESTR sz)
{
        VDATEHEAP();

        signed int      sign = +1;
        UINT            base = 10;
        LONG            l = 0;

        if (NULL==sz)
        {
                Assert (0);
                return 0;
        }
        while (isspace(*sz))
        {
                sz++;
        }

        if (*sz== OLESTR('-'))
        {
                sz++;
                sign = -1;
        }
        if (sz[0]==OLESTR('0') && sz[1]==OLESTR('x'))
        {
                base = 16;
                sz+=2;
        }

        if (base==10)
        {
                while (isdigit(*sz))
                {
                        l = l * base + *sz - OLESTR('0');
                        sz++;
                }
        }
        else
        {
                Assert (base==16);
                while (isxdigit(*sz))
                {
                        l = l * base + isdigit(*sz) ? *sz - OLESTR('0') :
                                toupper(*sz) - OLESTR('A') + 10;
                        sz++;
                }
        }
        return l * sign;
}
#endif  //!WIN32



//+-------------------------------------------------------------------------
//
//  Function:   OleRegGetDword
//
//  Synopsis:   returns the value of subkey "szKey" as a DWORD
//
//  Effects:
//
//  Arguments:  [hkey]  -- handle to a key in the regdb
//              [szKey] -- the subkey to look for
//              [pdw]   -- where to put the dword
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleRegGetDword)
static INTERNAL OleRegGetDword
        (HKEY           hkey,
        LPCOLESTR       szKey,
        DWORD FAR*      pdw)
{
        VDATEHEAP();

        VDATEPTRIN (pdw, DWORD);

        LPOLESTR        szLong = NULL;

        HRESULT hresult = OleRegGetString (hkey, szKey, &szLong);
        if (hresult != NOERROR)
        {
                return hresult;
        }
        *pdw = Atol (szLong);
        PubMemFree(szLong);
        return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleRegGetDword (overloaded)
//
//  Synopsis:   Gets a dword from a sub-key given as a dword
//
//  Effects:
//
//  Arguments:  [hkey]  -- handle to a key in the regdb
//              [dwKey] -- number to convert to a string key to lookup in
//                         the regdb
//              [pdw]   -- where to put the dword
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-Nov-93 alexgo    32bit port
//
//  Notes:      REVIEW32:  This deep layering is kinda strange, as each
//              overloaded function is used exactly once.  It might be
//              better just to inline the stuff and be done with it.
//
//--------------------------------------------------------------------------

#pragma SEG(OleRegGetDword)
static  INTERNAL OleRegGetDword
        (HKEY           hkey,
        DWORD           dwKey,
        DWORD FAR*      pdw)
{
        VDATEHEAP();

        OLECHAR szBuf[MAX_STR];
        wsprintf(szBuf, OLESTR("%ld"), dwKey);

        return OleRegGetDword (hkey, szBuf, pdw);
}

//+-------------------------------------------------------------------------
//
//  Function:   OleRegGetString
//
//  Synopsis:   Return the value of subkey [szKey] of key [hkey] as a string
//
//  Effects:
//
//  Arguments:  [hkey]          -- a handle to a key in the reg db
//              [szKey]         -- the subkey to get the value of
//              [ppszValue]     -- where to put the value string
//
//  Requires:
//
//  Returns:    HRESULT (NOERROR, E_OUTOFMEMORY, REGDB_E_KEYMISSING)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Dec-93 alexgo    32bit port
//              15-Dec-93 ChrisWe   cb is supposed to be the size of the
//                                  buffer in bytes; changed to use sizeof()
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleRegGetString)
static INTERNAL OleRegGetString
        (HKEY           hkey,
        LPCOLESTR       szKey,
        LPOLESTR FAR*   ppszValue)
{
    VDATEHEAP();

    OLECHAR         szBuf [MAX_STR];
    LONG            cb = sizeof(szBuf);

    *ppszValue = NULL;

    if (ERROR_SUCCESS == RegQueryValue (hkey, (LPOLESTR) szKey,
            szBuf, &cb))
    {
        *ppszValue = UtDupString (szBuf);
        return *ppszValue ? NOERROR : ResultFromScode (E_OUTOFMEMORY);
    }
    return ReportResult(0, REGDB_E_KEYMISSING, 0, 0);
}

//+-------------------------------------------------------------------------
//
//  Function:   OleRegGetString (overloaded)
//
//  Synopsis:   Gets the string value of the DWORD subkey
//
//  Effects:
//
//  Arguments:  [hkey]          -- handle to a key in the regdb
//              [dwKey]         -- the subkey value
//              [ppszValue]     -- where to put the return value
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

static INTERNAL OleRegGetString
        (HKEY           hkey,
        DWORD           dwKey,
        LPOLESTR FAR*   ppszValue)
{
        VDATEHEAP();

        OLECHAR szBuf[MAX_STR];
        wsprintf(szBuf, OLESTR("%ld"), dwKey);

        return OleRegGetString (hkey, szBuf, ppszValue);
}

//+-------------------------------------------------------------------------
//
//  Function:   OleRegGetUserType
//
//  Synopsis:   Returns the user type name for the class id.
//
//  Effects:
//
//  Arguments:  [clsid]         -- the class ID to look up
//              [dwFormOfType]  -- flag indicating whether the fullname,
//                                 shortname, or app name is desired
//              [ppszUserType]  -- where to put the type string
//
//  Requires:   returned string must be deleted
//
//  Returns:    HRESULT (NOERROR, OLE_E_CLSID)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleRegGetUserType)
STDAPI OleRegGetUserType
        (REFCLSID       clsid,
        DWORD           dwFormOfType,  // as in IOleObject::GetUserType
        LPOLESTR FAR*   ppszUserType)   // out parm
{
        OLETRACEIN((API_OleRegGetUserType, PARAMFMT("clsid= %I, dwFormOfType= %x, ppszUserType= %p"),
                        &clsid, dwFormOfType, ppszUserType));

        VDATEHEAP();

        LPOLESTR    pszTemp;
        HKEY        hkeyClsid = NULL;
        HKEY        hkeyAux   = NULL;
        HRESULT     hresult   = NOERROR;

        VDATEPTROUT_LABEL (ppszUserType, LPOLESTR, safeRtn, hresult);
        *ppszUserType = NULL;

        ErrRtnH(CoOpenClassKey(clsid, FALSE, &hkeyClsid));

        if (dwFormOfType == USERCLASSTYPE_FULL ||
                ERROR_SUCCESS != RegOpenKeyEx (hkeyClsid, szAuxUserTypeKey, 0, KEY_READ, &hkeyAux))
        {
            // use Main User Type Name (value of key CLSID(...))
            hresult = OleRegGetString(hkeyClsid, (LPOLESTR)NULL,
                                      &pszTemp);
            if (SUCCEEDED(hresult))
            {
                // If no user type string is registered under the class key,
                // OleRegGetString returns NOERROR and returns an empty string.
                // We need to check for this and return the appropriate error.
                if ( !pszTemp[0] )
                {
                    PubMemFree(pszTemp);
                    hresult = ResultFromScode(REGDB_E_INVALIDVALUE);
                    goto errRtn;
                }
                *ppszUserType = pszTemp;
            }
        }
        else
        {
            // look under key AuxUserType
            if (NOERROR !=
                OleRegGetString (hkeyAux, dwFormOfType, ppszUserType)
                || NULL==*ppszUserType
                || '\0'==(*ppszUserType)[0])
            {
                // Couldn't find the particular FormOfType requested,
                // so use Full User Type Name (value of main
                // CLSID key), as per spec
                ErrRtnH (OleRegGetString (hkeyClsid, (LPOLESTR)NULL,
                        ppszUserType));
            }
        }

  errRtn:

        CLOSE (hkeyClsid);
        CLOSE (hkeyAux);

  safeRtn:
        OLETRACEOUT((API_OleRegGetUserType, hresult));

        return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleRegGetMiscStatus
//
//  Synopsis:   Retrieves misc status bits from the reg db
//
//  Effects:
//
//  Arguments:  [clsid]         -- the class ID
//              [dwAspect]      -- specify the aspect (used in querrying
//                                 the reg db)
//              [pdwStatus]     -- return to return the status bits
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Dec-93 alexgo    32bit port
//
//  Notes:      Uses default (0) is the MiscStatus key is missing
//
//--------------------------------------------------------------------------

#pragma SEG(OleRegGetMiscStatus)
STDAPI OleRegGetMiscStatus
        (REFCLSID       clsid,
        DWORD           dwAspect,
        DWORD FAR*      pdwStatus)
{
    OLETRACEIN((API_OleRegGetMiscStatus, PARAMFMT("clsid= %I, dwAspect= %x, pdwStatus= %p"),
                    &clsid, dwAspect, pdwStatus));

    VDATEHEAP();

    HKEY            hkeyClsid       = NULL;
    HKEY            hkeyMisc        = NULL;
    HRESULT         hresult         = NOERROR;

    VDATEPTROUT_LABEL(pdwStatus, DWORD, safeRtn, hresult);
    *pdwStatus = 0;

    ErrRtnH(CoOpenClassKey(clsid, FALSE, &hkeyClsid));

    // Open MiscStatus key
    if (ERROR_SUCCESS != RegOpenKeyEx (hkeyClsid, szMiscStatusKey, 0, KEY_READ, &hkeyMisc))
    {
        // MiscStatus key not there, so use default.
        hresult = NOERROR;
        goto errRtn;
    }
    if (OleRegGetDword (hkeyMisc, dwAspect, pdwStatus) != NOERROR)
    {
        // Get default value from main Misc key
        ErrRtnH (OleRegGetDword (hkeyMisc,
                (LPOLESTR)NULL, pdwStatus));
        // Got default value
    }
    // Got value for dwAspect

errRtn:
    CLOSE (hkeyMisc);
    CLOSE (hkeyClsid);

safeRtn:
    OLETRACEOUT((API_OleRegGetMiscStatus, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleGetAutoConvert
//
//  Synopsis:   Retrieves the class ID that [clsidOld] should be converted
//              to via auto convert
//
//  Effects:
//
//  Arguments:  [clsidOld]      -- the original class ID
//              [pClsidNew]     -- where to put the new convert-to class ID
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Apr-94 kevinro   removed bogus assert, restructured
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleGetAutoConvert)
STDAPI OleGetAutoConvert(REFCLSID clsidOld, LPCLSID pClsidNew)
{
        OLETRACEIN((API_OleGetAutoConvert, PARAMFMT("clsidOld= %I, pClsidNew= %p"),
                        &clsidOld, pClsidNew));

        VDATEHEAP();

        HRESULT hresult;
        HKEY hkeyClsid = NULL;
        LPOLESTR lpszClsid = NULL;
        VDATEPTROUT_LABEL (pClsidNew, CLSID, errRtn, hresult);
        *pClsidNew = CLSID_NULL;

        hresult = CoOpenClassKey(clsidOld, FALSE, &hkeyClsid);
        if (FAILED(hresult))
        {
            goto errRtn;
        }

        hresult = OleRegGetString(hkeyClsid, szAutoConverTo, &lpszClsid);

        if (SUCCEEDED(hresult))
        {
                // Its Possible there is an AutoConvert Key under the CLSID but it has not value

                if (OLESTR('\0') == lpszClsid[0])
                {
                        hresult = REGDB_E_KEYMISSING;
                }
                else
                {
                        // convert string into CLSID
                        hresult = CLSIDFromString(lpszClsid, pClsidNew);
                }
        }

        CLOSE(hkeyClsid);
        PubMemFree(lpszClsid);

errRtn:
        OLETRACEOUT((API_OleGetAutoConvert, hresult));

        return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleSetAutoConvert
//
//  Synopsis:   Sets the autoconvert information in the regdb
//
//  Effects:
//
//  Arguments:  [clsidOld]      -- the original class id
//              [clsidNew]      -- that class id that [clsidOld] should be
//                                 auto-converted to
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleSetAutoConvert)
STDAPI OleSetAutoConvert(REFCLSID clsidOld, REFCLSID clsidNew)
{
        OLETRACEIN((API_OleSetAutoConvert, PARAMFMT("clsidOld= %I, clsidNew= %I"),
                                &clsidOld, &clsidNew));

        VDATEHEAP();

        HRESULT         hresult;
        HKEY            hkeyClsid = NULL;

        ErrRtnH(CoOpenClassKey(clsidOld, TRUE, &hkeyClsid));

        if (IsEqualCLSID(clsidNew, CLSID_NULL))
        {
                // ignore error since there may not be a value at present
                (void)RegDeleteKey(hkeyClsid, szAutoConverTo);
        }
        else
        {
                OLECHAR szClsid[MAX_STR];
                Verify(StringFromCLSID2(clsidNew, szClsid, sizeof(szClsid))
                        != 0);

                if (RegSetValue(hkeyClsid, szAutoConverTo, REG_SZ, szClsid,
                        _xstrlen(szClsid)) != ERROR_SUCCESS)
                {
                        hresult = ResultFromScode(REGDB_E_WRITEREGDB);
                }
        }

errRtn:
        CLOSE(hkeyClsid);

        OLETRACEOUT((API_OleSetAutoConvert, hresult));

        return hresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\stdimpl\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   stdimpl
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\..\common\$(DEST_TREE);..\..\..\ih;..\..\inc
INCLUDES=     $(INCLUDES);..\..\..\com\dcomrem;..\..\..\com\objact
INCLUDES=     $(INCLUDES);..\..\..\com\inc
INCLUDES=     $(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\$(O)

C_DEFINES=    \
              $(C_DEFINES)          \
              -D_TRACKLINK_=1

SOURCES=      \
              ..\defcf.cpp    \
              ..\defhndlr.cpp \
              ..\deflink.cpp  \
              ..\defutil.cpp  \
              ..\gen.cpp      \
              ..\icon.cpp     \
              ..\mf.cpp       \
              ..\emf.cpp      \
              ..\olereg.cpp   \
              ..\oregfmt.cpp  \
              ..\oregverb.cpp

UMTYPE=       windows

USE_IOSTREAM=1

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\util\convert.cpp ===
//+----------------------------------------------------------------------------
//
//      File:
//              convert.cpp
//
//      Contents:
//              This module contains the code to read/write DIB, metafile,
//              placeable metafiles, olepres stream, etc... This module also
//              contains routines for converting from one format to other.
//
//      Classes:
//
//      Functions:
//
//      History:
//              15-Feb-94 alexgo    fixed a bug in loading placeable metafiles
//                                  from a storage (incorrect size calculation).
//              25-Jan-94 alexgo    first pass at converting to Cairo-style
//                                  memory allocations.
//              01/11/93 - alexgo  - added VDATEHEAP macros to every function
//              12/08/93 - ChrisWe - fixed wPrepareBitmapHeader not to use
//                      (LPOLESTR) cast
//              12/07/93 - ChrisWe - make default params to StSetSize explicit
//              12/02/93 - ChrisWe - more formatting; fixed UtHMFToMFStm,
//                      32 bit version, which was doing questionable things
//                      with the hBits handle;  got rid of the OLESTR
//                      uses in favor of (void *) or (BYTE *) as appropriate
//              11/29/93 - ChrisWe - move CONVERT_SOURCEISICON, returned
//                      by UtOlePresStmToContentsStm(), to utils.h
//              11/28/93 - ChrisWe - begin file inspection and cleanup
//              06/28/93 - SriniK - created
//
//-----------------------------------------------------------------------------

#include <le2int.h>

#pragma SEG(ole2)

NAME_SEG(convert)
ASSERTDATA

#ifndef _MAC
FARINTERNAL_(HMETAFILE) QD2GDI(HANDLE hBits);
#endif

void UtGetHEMFFromContentsStm(LPSTREAM lpstm, HANDLE * phdata);


/************************   FILE FORMATS   **********************************

Normal Metafile (memory or disk based):

         ------------ ---------------
        | METAHEADER | Metafile bits |
         ------------ ---------------

Placeable Metafile:

         --------------------- -----------------
        | PLACEABLEMETAHEADER | Normal metafile |
         --------------------- -----------------

Memory Based DIB:

         ------------------ --------------- ----------
        | BITMAPINFOHEADER | RGBQUAD array | DIB bits |
         ------------------ --------------- ----------

DIB file format:

         ------------------ ------------------
        | BITMAPFILEHEADER | Memory based DIB |
         ------------------ ------------------

Ole10NativeStream Format:

         -------- ----------------------
        | dwSize | Object's Native data |
         -------- ----------------------

PBrush Native data format:

         -----------------
        | Dib File format |
         -----------------

MSDraw Native data format:

         --------------------- ------------- ------------- -----------------
        | mapping mode (WORD) | xExt (WORD) | yExt (WORD) | Normal metafile |
         --------------------- ------------- ------------- -----------------

*****************************************************************************/


FARINTERNAL UtGetHGLOBALFromStm(LPSTREAM lpstream, DWORD dwSize,
                HANDLE FAR* lphPres)
{
        VDATEHEAP();

        HANDLE hBits = NULL;
        void FAR *lpBits = NULL;
        HRESULT error;

        // initialize this for error return cases
        *lphPres = NULL;

        // allocate a new handle
        if (!(hBits = GlobalAlloc(GMEM_MOVEABLE, dwSize))
                        || !(lpBits = (BYTE *)GlobalLock(hBits)))
        {
                error = ResultFromScode(E_OUTOFMEMORY);
                goto errRtn;
        }

        // read the stream into the allocated memory
        if (error = StRead(lpstream, lpBits, dwSize))
                goto errRtn;

        // if we got this far, return new handle
        *lphPres = hBits;

errRtn:
        // unlock the handle, if it was successfully locked
        if (lpBits)
                GlobalUnlock(hBits);

        // free the handle if there was an error
        if ((error != NOERROR) && hBits)
                GlobalFree(hBits);

        return(error);
}


#ifndef _MAC

FARINTERNAL UtGetHDIBFromDIBFileStm(LPSTREAM pstm, HANDLE FAR* lphdata)
{
        VDATEHEAP();

        BITMAPFILEHEADER bfh;
        DWORD dwSize; // the size of the data to read
        HRESULT error;

        // read the bitmap file header
        if (error = pstm->Read(&bfh, sizeof(BITMAPFILEHEADER), NULL))
        {
                *lphdata = NULL;
                return(error);
        }

        // calculate the size of the DIB to read
        dwSize = bfh.bfSize - sizeof(BITMAPFILEHEADER);

        // read the DIB
        return(UtGetHGLOBALFromStm(pstm, dwSize, lphdata));
}


FARINTERNAL_(HANDLE) UtGetHMFPICT(HMETAFILE hMF, BOOL fDeleteOnError,
                DWORD xExt, DWORD yExt)
{
        VDATEHEAP();

        HANDLE hmfp; // handle to the new METAFILEPICT
        LPMETAFILEPICT lpmfp; // pointer to the new METAFILEPICT

        // if no METAFILE, nothing to do
        if (hMF == NULL)
                return(NULL);

        // allocate a new handle
        if (!(hmfp = GlobalAlloc(GMEM_MOVEABLE, sizeof(METAFILEPICT))))
                goto errRtn;

        // lock the handle
        if (!(lpmfp = (LPMETAFILEPICT)GlobalLock(hmfp)))
                goto errRtn;

        // make the METAFILEPICT
        lpmfp->hMF = hMF;
        lpmfp->xExt = (int)xExt;
        lpmfp->yExt = (int)yExt;
        lpmfp->mm = MM_ANISOTROPIC;

        GlobalUnlock(hmfp);
        return(hmfp);

errRtn:
        if (hmfp)
                GlobalFree(hmfp);

        if (fDeleteOnError)
                DeleteMetaFile(hMF);

        return(NULL);
}

#endif // _MAC

//+-------------------------------------------------------------------------
//
//  Function:   UtGetHMFFromMFStm
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [lpstream] -- stream containing metafile or PICT
//              [dwSize] -- data size within stream
//              [fConvert] -- FALSE for metafile, TRUE for PICT
//              [lphPres] -- placeholder for output metafile
//
//  Requires:   lpstream positioned at start of data
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  Algorithm:
//
//  History:    29-Apr-94 AlexT     Add comment block, enabled Mac conversion
//
//  Notes:
//
//--------------------------------------------------------------------------

FARINTERNAL UtGetHMFFromMFStm(LPSTREAM lpstream, DWORD dwSize,
                BOOL fConvert, HANDLE FAR* lphPres)
{
#ifdef WIN32
        LEDebugOut((DEB_ITRACE, "%p _IN UtGetHMFFromMFStm (%p, %d, %d, %p)\n",
                NULL, lpstream, dwSize, fConvert, lphPres));

        VDATEHEAP();

        BYTE *pbMFData = NULL;
        METAHEADER MetaHdr;
        HRESULT hrError;

        // initialize this in case of error return
        *lphPres = NULL;

        // allocate a global handle for the data (since QD2GDI needs a
        // handle)

        pbMFData = (BYTE *) GlobalAlloc(GMEM_FIXED, dwSize);
        if (NULL == pbMFData)
        {
            hrError = ResultFromScode(E_OUTOFMEMORY);
            goto errRtn;
        }

        // read the stream into the bit storage

        ULONG cbRead;
        hrError = lpstream->Read(pbMFData, dwSize, &cbRead);
        if (FAILED(hrError))
        {
            return(hrError);
        }

        // As TOC is being written at the end of presentation, it is essential
        // to place the seek pointer at the end of presentation data. Hence,
        // seek past the extra meta header written by UtHMFToMFStm ignoring error
        lpstream->Read(&MetaHdr, sizeof(MetaHdr), NULL);

        // hrError = StRead(lpstream, pbMFData, dwSize);

        if (hrError != NOERROR)
        {
            goto errRtn;
        }

        if (fConvert)
        {
            //  It's a Mac PICT
            *lphPres = QD2GDI((HGLOBAL) pbMFData);
        }
        else
        {
            //  It's a Windows metafile
            *lphPres = SetMetaFileBitsEx(dwSize, pbMFData);
        }

        if (*lphPres == NULL)
            hrError = ResultFromScode(E_OUTOFMEMORY);

errRtn:
        if (NULL != pbMFData)
        {
            GlobalFree(pbMFData);
        }

        LEDebugOut((DEB_ITRACE, "%p OUT UtGetHMFFromMFStm ( %lx ) [ %p ]\n",
                    NULL, hrError, *lphPres));

        return(hrError);
#else
        HANDLE hBits; // handle to the new METAFILE
        void FAR* lpBits = NULL;
        HRESULT error;

        // initialize this in case of error return
        *lphPres = NULL;

        // allocate a new handle, and lock the bits
        if (!(hBits = GlobalAlloc(GMEM_MOVEABLE, dwSize))
                        || !(lpBits = GlobalLock(hBits)))
        {
                error = ResultFromScode(E_OUTOFMEMORY);
                goto errRtn;
        }

        // read the stream into the bit storage
        error = StRead(lpstream, lpBits, dwSize);
        GlobalUnlock(hBits);

        if (error)
                goto errRtn;

        if (!fConvert)
                *lphPres = SetMetaFileBits(hBits);
        else
        {
                if (*lphPres = QD2GDI(hBits))
                {
                        // Need to free this handle upon success
                        GlobalFree(hBits);
                        hBits = NULL;
                }

        }

        if (!*lphPres)
                error = ResultFromScode(E_OUTOFMEMORY);

errRtn:
        if (error && hBits)
                GlobalFree(hBits);
        return(error);
#endif // WIN32
}


FARINTERNAL UtGetSizeAndExtentsFromPlaceableMFStm(LPSTREAM pstm,
                DWORD FAR* pdwSize, LONG FAR* plWidth, LONG FAR* plHeight)
{
        VDATEHEAP();

        HRESULT error;
        LARGE_INTEGER large_int; // used to set the seek pointer
        ULARGE_INTEGER ularge_int; // retrieves the new seek position
        LONG xExt; // the x extent of the metafile
        LONG yExt; // the y extent of the metafile
        METAHEADER mfh;
        PLACEABLEMETAHEADER plac_mfh;

        // read the placeable metafile header
        if (error = pstm->Read(&plac_mfh, sizeof(plac_mfh), NULL))
                return(error);

        // check the magic number in the header
        if (plac_mfh.key != PMF_KEY)
                return ResultFromScode(E_FAIL);

        // remember the seek pointer
        LISet32(large_int, 0);
        if (error = pstm->Seek(large_int, STREAM_SEEK_CUR, &ularge_int))
                return(error);

        // read metafile header
        if (error = pstm->Read(&mfh, sizeof(mfh), NULL))
                return(error);

        // seek back to the begining of metafile header
        LISet32(large_int,  ularge_int.LowPart);
        if (error = pstm->Seek(large_int, STREAM_SEEK_SET, NULL))
                return(error);

        // calculate the extents of the metafile
        xExt = (plac_mfh.bbox.right - plac_mfh.bbox.left);// metafile units
        yExt = (plac_mfh.bbox.bottom - plac_mfh.bbox.top);// metafile units

        // REVIEW, why aren't there constants for this?
        xExt = (xExt * 2540) / plac_mfh.inch; // HIMETRIC units
        yExt = (yExt * 2540) / plac_mfh.inch; // HIMETRIC units

        if (pdwSize)
        {
#ifdef WIN16
                //this code seems to work OK on Win16
                *pdwSize = 2 * (mfh.mtSize + mfh.mtHeaderSize);
                                // REVIEW NT: review METAHEADER
#else   //WIN32
                //mt.Size is the size in words of the metafile.
                //this fixes bug 6739 (static objects can't be copied
                //or loaded from a file).
                *pdwSize = sizeof(WORD) * mfh.mtSize;
#endif  //WIN16
        }

        if (plWidth)
                *plWidth = xExt;

        if (plHeight)
                *plHeight = yExt;

        return NOERROR;
}


FARINTERNAL UtGetHMFPICTFromPlaceableMFStm(LPSTREAM pstm, HANDLE FAR* lphdata)
{
        VDATEHEAP();

        HRESULT error; // error state so far
        DWORD dwSize; // size of the METAFILE we have to read from the stream
        LONG xExt; // x extent of the METAFILE we have to read from the stream
        LONG yExt; // y extent of the METAFILE we have to read from the stream
        HMETAFILE hMF; // handle to the METAFILE read from the stream

        if (lphdata == NULL)
                return ResultFromScode(E_INVALIDARG);

        // initialize this in case of error return
        *lphdata = NULL;

        // get the size of the METAFILE
        if (error = UtGetSizeAndExtentsFromPlaceableMFStm(pstm, &dwSize,
                        &xExt, &yExt))
                return(error);

        // fetch the METAFILE
        if (error = UtGetHMFFromMFStm(pstm, dwSize, FALSE /*fConvert*/,
                        (HANDLE FAR *)&hMF))
                return(error);

        // convert to a METAFILEPICT
        if (!(*lphdata = UtGetHMFPICT(hMF, TRUE /*fDeleteOnError*/, xExt,
                        yExt)))
                return ResultFromScode(E_OUTOFMEMORY);

        return NOERROR;
}



/****************************************************************************/
/*****************              Write routines          *********************/
/****************************************************************************/

#ifndef _MAC


//+----------------------------------------------------------------------------
//
//      Function:
//              iFindDIBits
//
//      Synopsis:
//              Returns offset from beginning of BITMAPINFOHEADER to the bits
//
//      Arguments:
//              [lpbih] -- pointer to the BITMAPINFOHEADER
//
//      History:
//              09/21/98 - DavidShi
//
//-----------------------------------------------------------------------------
FARINTERNAL_(int) iFindDIBits (LPBITMAPINFOHEADER lpbih)
{
   int iPalSize;   // size of palette info
   int iNumColors=0; // number of colors in DIB


   //
   // Find the number of colors
   //
   switch (lpbih->biBitCount)
   {
       case 1:
           iNumColors = 2;
           break;
       case 4:
           iNumColors = 16;
           break;
       case 8:
           iNumColors = 256;
           break;

   }
   if (lpbih->biSize >= sizeof(BITMAPINFOHEADER))
   {
       if (lpbih->biClrUsed)
       {
           iNumColors = (int)lpbih->biClrUsed;
       }

   }
   //
   // Calculate the size of the color table.
   //
   if (lpbih->biSize < sizeof(BITMAPINFOHEADER))
   {

       iPalSize =  iNumColors * sizeof(RGBTRIPLE);

   }
   else if (lpbih->biCompression==BI_BITFIELDS)
   {

        if (lpbih->biSize < sizeof(BITMAPV4HEADER))
        {
                iPalSize = 3*sizeof(DWORD);
        }
        else
                iPalSize = 0;
   }
   else
   {
        iPalSize = iNumColors * sizeof(RGBQUAD);
   }
   return lpbih->biSize + iPalSize;

}
//+----------------------------------------------------------------------------
//
//      Function:
//              wPrepareBitmapHeader, static
//
//      Synopsis:
//              Initializes the content of a BITMAPFILEHEADER. Forces bitmap
//              bits to immediately follow the header.
//
//      Arguments:
//              [lpbfh] -- pointer to the BITMAPFILEHEADER to initialize
//              [lpbih] -- pointer to DIB
//              [dwSize] -- the size of the file; obtained by dividing
//                      the size of the file by 4 (see win32 documentation.)
//
//      History:
//              12/08/93 - ChrisWe - made static
//
//-----------------------------------------------------------------------------

static INTERNAL_(void) wPrepareBitmapFileHeader(LPBITMAPFILEHEADER lpbfh,
              LPBITMAPINFOHEADER lpbih,
              DWORD dwSize  )
{
        VDATEHEAP();

        // NOTE THESE ARE NOT SUPPOSED TO BE UNICODE
        // see win32s documentation
        ((char *)(&lpbfh->bfType))[0] = 'B';
        ((char *)(&lpbfh->bfType))[1] = 'M';

        lpbfh->bfSize = dwSize + sizeof(BITMAPFILEHEADER);
        lpbfh->bfReserved1 = 0;
        lpbfh->bfReserved2 = 0;
        lpbfh->bfOffBits = sizeof(BITMAPFILEHEADER)+iFindDIBits (lpbih);
}


FARINTERNAL UtHDIBToDIBFileStm(HANDLE hdata, DWORD dwSize, LPSTREAM pstm)
{
        VDATEHEAP();

        HRESULT error;
        BITMAPFILEHEADER bfh;
        LPBITMAPINFOHEADER pbih;
        if (!(pbih = (LPBITMAPINFOHEADER)GlobalLock (hdata)))
            return E_OUTOFMEMORY;


        wPrepareBitmapFileHeader(&bfh, pbih, dwSize);
        GlobalUnlock (hdata);

        if (error = pstm->Write(&bfh, sizeof(bfh), NULL))
                return(error);

        return UtHGLOBALtoStm(hdata, dwSize, pstm);
}


FARINTERNAL UtDIBStmToDIBFileStm(LPSTREAM pstmDIB, DWORD dwSize,
                LPSTREAM pstmDIBFile)
{
        VDATEHEAP();

        HRESULT error;
        
        BITMAPFILEHEADER bfh;
        BITMAPINFOHEADER bih;
        ULARGE_INTEGER ularge_int; // indicates how much to copy
        LARGE_INTEGER large_int;
        
        error = pstmDIB->Read (&bih, sizeof(bih), NULL);
        LISet32(large_int, 0);

        wPrepareBitmapFileHeader(&bfh, &bih, dwSize);

        if (error = pstmDIBFile->Write(&bfh, sizeof(bfh), NULL))
                return(error);

        if (error = pstmDIBFile->Write(&bih, sizeof(bih), NULL))
                return(error);

        ULISet32(ularge_int, (dwSize - sizeof(bih)));
        if ((error = pstmDIB->CopyTo(pstmDIBFile, ularge_int, NULL,
                        NULL)) == NOERROR)
                StSetSize(pstmDIBFile, 0, TRUE);

        return(error);
}


// REVIEW, move these to utils.h so that gen.cpp and mf.cpp can use them for
// the same purposes
// REVIEW, add some more comments; is HDIBFILEHDR a windows structure?
struct tagHDIBFILEHDR
{
        DWORD dwCompression;
        DWORD dwWidth;
        DWORD dwHeight;
        DWORD dwSize;
};
typedef struct tagHDIBFILEHDR HDIBFILEHDR;

struct tagOLEPRESSTMHDR
{
        DWORD dwAspect;
        DWORD dwLindex;
        DWORD dwAdvf;
};
typedef struct tagOLEPRESSTMHDR OLEPRESSTMHDR;

FARINTERNAL UtHDIBFileToOlePresStm(HANDLE hdata, LPSTREAM pstm)
{
        VDATEHEAP();

        HRESULT error;
        HDIBFILEHDR hdfh;
        LPBITMAPFILEHEADER lpbfh;
        LPBITMAPINFOHEADER lpbmi;

        if (!(lpbfh = (LPBITMAPFILEHEADER)GlobalLock(hdata)))
                return ResultFromScode(E_OUTOFMEMORY);

        lpbmi = (LPBITMAPINFOHEADER)(((BYTE *)lpbfh) +
                        sizeof(BITMAPFILEHEADER));

        hdfh.dwCompression = 0;
        // REVIEW, these casts are hosed
        UtGetDibExtents(lpbmi, (LPLONG)&hdfh.dwWidth, (LPLONG)&hdfh.dwHeight);

        hdfh.dwSize = lpbfh->bfSize - sizeof(BITMAPFILEHEADER);

        // write compesssion, Width, Height, size
        if (error = pstm->Write(&hdfh, sizeof(hdfh), 0))
                goto errRtn;

        // write the BITMAPINFOHEADER
        // REVIEW, does this size include the data?
        if ((error = pstm->Write(lpbmi, hdfh.dwSize, NULL)) == NOERROR)
                StSetSize(pstm, 0, TRUE);

errRtn:
        GlobalUnlock(hdata);
        return(error);
}

#endif // _MAC



FARINTERNAL UtHMFToMFStm(HANDLE FAR* lphMF, DWORD dwSize, LPSTREAM lpstream)
{
        VDATEHEAP();

        HRESULT error;

        // if there's no handle, there's nothing to do
        if (*lphMF == 0)
                return ResultFromScode(OLE_E_BLANK);

#ifdef _MAC

        AssertSz(GetHandleSize((Handle)*lphMF) == dwSize,
                        "pic hdl size not correct");
        HLock( (HANDLE)*lphMF );

        error = StWrite(lpstream, * (*lphMF), dwSize);

        // Eric: We should be unlocking, right?
        HUnlock((HANDLE)(*lphMF));

        if (error != NOERROR)
                AssertSz(0, "StWrite failure" );

#else

        HANDLE hBits = NULL;
        void *lpBits;

#ifdef WIN32

        // allocate memory to hold the METAFILE bits
        // Bug 18346 - OLE16 use to get the Handle size of the Metafile which was a METAHEADER bigger than the
        //   actual Metafile.  Need to write out this much more worth of data so 16 bit dlls can read the Picture.

        dwSize += sizeof(METAHEADER);

        hBits = GlobalAlloc(GPTR, dwSize);
        if (hBits == NULL)
                return ResultFromScode(E_OUTOFMEMORY);

        if (!(lpBits = GlobalLock(hBits)))
        {
                error = HRESULT_FROM_WIN32(GetLastError());
                goto errRtn;
        }
        
        // REVIEW, shouldn't we check the returned size?
        // REVIEW, what should we do about enhanced metafiles?  If we
        // convert and write those out (which have more features that 32 bit
        // apps might use,) then you can't read the same document on a win16
        // machine....
        GetMetaFileBitsEx((HMETAFILE)*lphMF, dwSize, lpBits);

        // write the metafile bits out to the stream
        error = StWrite(lpstream, lpBits, dwSize);

        GlobalUnlock(hBits);

errRtn:
        // free the metafile bits
        GlobalFree(hBits);

#else
        if (!(hBits = GetMetaFileBits(*lphMF)))
        {
                error = ResultFromScode(E_OUTOFMEMORY);
                        goto errRtn;
        }

        if (lpBits = GlobalLock(hBits))
        {
                error = StWrite(lpstream, lpBits, dwSize);
                GlobalUnlock(hBits);
        }
        else
                error = ResultFromScode(E_OUTOFMEMORY);

        if (hBits)
                *lphMF = SetMetaFileBits(hBits);
errRtn:

#endif // WIN32
#endif // _MAC

        // set the stream size
        if (error == NOERROR)
                StSetSize(lpstream, 0, TRUE);

        return(error);
}


//+----------------------------------------------------------------------------
//
//      Function:
//              wPreparePlaceableMFHeader, static
//
//      Synopsis:
//              Initializes a PLACEABLEMETAHEADER.
//
//      Arguments:
//              [lpplac_mfh] -- pointer to the PLACEABLEMETAHEADER to initialize
//              [lWidth] -- Width of the metafile
//                      REVIEW, in what units?
//                      REVIEW, why is this not unsigned?
//              [lHeight] -- Height of the metafile
//                      REVIEW, in what units?
//                      REVIEW, why is this not unsigned?
//
//      Notes:
//
//      History:
//              12/08/93 - ChrisWe - made static
//
//-----------------------------------------------------------------------------
static INTERNAL_(void) wPreparePlaceableMFHeader(
                PLACEABLEMETAHEADER FAR* lpplac_mfh, LONG lWidth, LONG lHeight)
{
    VDATEHEAP();

    WORD FAR* lpw; // roves over the words included in the checksum

    lpplac_mfh->key = PMF_KEY;
    lpplac_mfh->hmf = 0;
    lpplac_mfh->inch = 576; // REVIEW, where's this magic number from?
    lpplac_mfh->bbox.left = 0;
    lpplac_mfh->bbox.top = 0;
    lpplac_mfh->bbox.right = (WORD) (lWidth * lpplac_mfh->inch) / 2540;
                    // REVIEW, more magic
    lpplac_mfh->bbox.bottom = (WORD) (lHeight * lpplac_mfh->inch) / 2540;
                    // REVIEW, more magic
    lpplac_mfh->reserved = NULL;

    // Compute the checksum of the 10 words that precede the checksum field.
    // It is calculated by XORing zero with those 10 words.
    for(lpplac_mfh->checksum = 0, lpw = (WORD FAR*)lpplac_mfh;
                    lpw < (WORD FAR*)&lpplac_mfh->checksum; ++lpw)
            lpplac_mfh->checksum ^= *lpw;
}


FARINTERNAL UtHMFToPlaceableMFStm(HANDLE FAR* lphMF, DWORD dwSize,
                LONG lWidth, LONG lHeight, LPSTREAM pstm)
{
    VDATEHEAP();

    PLACEABLEMETAHEADER plac_mfh;
    HRESULT error;

    wPreparePlaceableMFHeader(&plac_mfh, lWidth, lHeight);

    // write the placeable header to the stream
    if (error = pstm->Write(&plac_mfh, sizeof(plac_mfh), NULL))
            return(error);

    // write the rest of the METAFILE to the stream
    return UtHMFToMFStm(lphMF, dwSize, pstm);
}


FARINTERNAL UtMFStmToPlaceableMFStm(LPSTREAM pstmMF, DWORD dwSize,
                LONG lWidth, LONG lHeight, LPSTREAM pstmPMF)
{
        VDATEHEAP();

        PLACEABLEMETAHEADER plac_mfh;
        HRESULT error;
        ULARGE_INTEGER ularge_int; // indicates how much data to copy

        wPreparePlaceableMFHeader(&plac_mfh, lWidth, lHeight);

        // write the placeable header to the stream
        if (error = pstmPMF->Write(&plac_mfh, sizeof(plac_mfh), NULL))
                return(error);

        // copy the METAFILE data from one stream to the other
        ULISet32(ularge_int, dwSize);
        if ((error = pstmMF->CopyTo(pstmPMF, ularge_int, NULL, NULL)) ==
                        NOERROR)
                StSetSize(pstmPMF, 0, TRUE);

        return(error);
}

//+-------------------------------------------------------------------------
//
//  Function:   UtWriteOlePresStmHeader, private
//
//  Synopsis:   Write the presentation stream header
//
//  Effects:
//
//  Arguments:  [lpstream] -- destination stream
//              [pforetc]  -- FORMATETC for this presentation
//              [dwAdvf]   -- advise flags for the presentation
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  Algorithm:
//
//  History:    11-May-94 AlexT     Added function header, translate to
//                                  ANSI before saving ptd
//
//  Notes:      This function can fail in low memory for presentations with
//              non-NULL ptds (since we allocate memory to do the conversion
//              to the persistent format).  NtIssue #2789
//
//--------------------------------------------------------------------------

FARINTERNAL UtWriteOlePresStmHeader(LPSTREAM lpstream, LPFORMATETC pforetc,
                DWORD dwAdvf)
{
    VDATEHEAP();

    HRESULT error;
    OLEPRESSTMHDR opsh;

    // write clip format
    // REVIEW, change name of this function?
    if (error = WriteClipformatStm(lpstream, pforetc->cfFormat))
        return(error);

    // write target device info
    if (pforetc->ptd)
    {
        DVTDINFO dvtdInfo;
        DVTARGETDEVICE *ptdA;

        error = UtGetDvtd32Info(pforetc->ptd, &dvtdInfo);
        if (FAILED(error))
        {
            return(error);
        }

        ptdA = (DVTARGETDEVICE *) PrivMemAlloc(dvtdInfo.cbConvertSize);
        if (NULL == ptdA)
        {
            return(E_OUTOFMEMORY);
        }

        error = UtConvertDvtd32toDvtd16(pforetc->ptd, &dvtdInfo, ptdA);

        if (SUCCEEDED(error))
        {
            error = StWrite(lpstream, ptdA, ptdA->tdSize);
        }

        PrivMemFree(ptdA);

        if (FAILED(error))
        {
            return(error);
        }
    }
    else
    {
        // if ptd is null then write 4 as size.
        // REVIEW, what is that the sizeof()?
        DWORD dwNullPtdLength = 4;

        if (error = StWrite(lpstream, &dwNullPtdLength, sizeof(DWORD)))
            return(error);
    }

    opsh.dwAspect = pforetc->dwAspect;
    opsh.dwLindex = pforetc->lindex;
    opsh.dwAdvf = dwAdvf;

    // write DVASPECT, lindex, advise flags
    return StWrite(lpstream, &opsh, sizeof(opsh));
}

//+-------------------------------------------------------------------------
//
//  Function:   UtReadOlePresStmHeader
//
//  Synopsis:   Reads in a presentation stream header
//
//  Arguments:  [pstm] -- source stream
//              [pforetc] -- FORMATETC to be filled in
//              [pdwAdvf] -- advise flags to be filled in
//              [pfConvert] -- Mac conversion required, to be filled in
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  Algorithm:
//
//  History:    11-May-94 AlexT     Added function header, translate ptd
//                                  from ANSI when loading
//
//  Notes:
//
//--------------------------------------------------------------------------

FARINTERNAL UtReadOlePresStmHeader(LPSTREAM pstm, LPFORMATETC pforetc,
                DWORD FAR* pdwAdvf, BOOL FAR* pfConvert)
{
    VDATEHEAP();

    HRESULT error;
    DWORD dwRead;
    OLEPRESSTMHDR opsh;

    // initialize this for error return cases
    // Check for NULL ptr, as caller may not need this information

    if (pfConvert)
    {
        *pfConvert = FALSE;
    }

    // there's no target device information yet
    pforetc->ptd = NULL;

    // REVIEW, rename this function to indicate its origin?
    error = ReadClipformatStm(pstm, &dwRead);

    if (error == NOERROR)
        pforetc->cfFormat = (CLIPFORMAT)dwRead;
    else
    {
#ifndef _MAC
        if (GetScode(error) == OLE_S_MAC_CLIPFORMAT)
        {
           // check whether the clipformat is "pict"
           // REVIEW, what's this cuteness?
           if (dwRead != *((DWORD *)"TCIP"))
                return(error);

           if (pfConvert)
                *pfConvert = TRUE;
           else
                return ResultFromScode(DV_E_CLIPFORMAT);

           pforetc->cfFormat = CF_METAFILEPICT;
        }
        else
#endif
            return(error);
    }

    // set the proper tymed
    if (pforetc->cfFormat == CF_METAFILEPICT)
    {
        pforetc->tymed = TYMED_MFPICT;
    }
    else if (pforetc->cfFormat == CF_ENHMETAFILE)
    {
        pforetc->tymed = TYMED_ENHMF;
    }
    else if (pforetc->cfFormat == CF_BITMAP)
    {
        AssertSz(0, "We don't read/save CF_BITMAP anymore");
        return ResultFromScode(DV_E_CLIPFORMAT);
    }
    else if (pforetc->cfFormat == NULL)
    {
        pforetc->tymed = TYMED_NULL;
    }
    else
    {
        pforetc->tymed = TYMED_HGLOBAL;
    }

    // Read targetdevice info.
    if (error = StRead(pstm, &dwRead, sizeof(dwRead)))
        return(error);

    // if the tdSize of ptd is non-null and is > 4, then go ahead read the
    // remaining data of the target device info
    if (dwRead > 4)
    {
        DVTARGETDEVICE *ptdA;
        DVTDINFO dvtdInfo;

        ptdA = (DVTARGETDEVICE *) PrivMemAlloc(dwRead);
        if (NULL == ptdA)
        {
            return ResultFromScode(E_OUTOFMEMORY);
        }

        ptdA->tdSize = dwRead;
        error = StRead(pstm, ((BYTE*)ptdA) + sizeof(dwRead),
                       dwRead - sizeof(dwRead));

        if (SUCCEEDED(error))
        {
            error = UtGetDvtd16Info(ptdA, &dvtdInfo);
            if (SUCCEEDED(error))
            {
                pforetc->ptd = (DVTARGETDEVICE *) PubMemAlloc(dvtdInfo.cbConvertSize);
                if (NULL == pforetc->ptd)
                {
                    error = E_OUTOFMEMORY;
                }
                else
                {
                    error = UtConvertDvtd16toDvtd32(ptdA, &dvtdInfo, pforetc->ptd);
                }
            }
        }

        PrivMemFree(ptdA);

        if (FAILED(error))
        {
            goto errRtn;
        }
    }
    else
        pforetc->ptd = NULL;

    // Read DVASPECT, lindex, advise flags
    if ((error = StRead(pstm, &opsh, sizeof(opsh))) != NOERROR)
        goto errRtn;

    pforetc->dwAspect = opsh.dwAspect;
    pforetc->lindex = opsh.dwLindex;
    if (pdwAdvf)
        *pdwAdvf = opsh.dwAdvf;

    return NOERROR;

errRtn:
    if (pforetc->ptd)
    {
        PubMemFree(pforetc->ptd);
        pforetc->ptd = NULL;
    }

    return(error);
}


FARINTERNAL UtOlePresStmToContentsStm(LPSTORAGE pstg, LPOLESTR lpszPresStm,
                BOOL fDeletePresStm, UINT FAR* puiStatus)
{
        VDATEHEAP();

        LPSTREAM pstmOlePres;
        LPSTREAM pstmContents = NULL;
        HRESULT error;
        FORMATETC foretc;
        HDIBFILEHDR hdfh;

        // there's no status yet
        *puiStatus = 0;

        // POSTPPC:
        //
        // This function needs to be rewritten to correctly handle the case described in
        // the comments below (rather than just skipping out of the function if the contents
        // stream already exists).  The best course of action will probably be to convert
        // DIBs->Metafiles and Metafiles->DIBs in the needed cases.

        // The code inside the #ifdef below is used to determine if the contents
        // stream has already been created (which is the case for an object that has
        // been converted to a bitmap) because in the case of an object that has been
        // converted to a static DIB and the object has a METAFILE presentation stream
        // we already have a cachenode created as a DIB and we will read the contents
        // stream after this call to get the DIB data.  However, this function sees
        // the metafile presentation, and converts it into the contents stream (which
        // when then try to load as a DIB) and bad things happen (it doesn't work).  If
        // the stream already exists, then we bail out of this function.
        if (pstg->CreateStream(OLE_CONTENTS_STREAM,(STGM_READWRITE | STGM_SHARE_EXCLUSIVE), NULL,
                         0, &pstmContents) != NOERROR)
        {
            return NOERROR;
        }

        // created stream, it must not have existed
        pstmContents->Release();
        pstg->DestroyElement(OLE_CONTENTS_STREAM);

        if ((error = pstg->OpenStream(lpszPresStm, NULL,
                        (STGM_READ | STGM_SHARE_EXCLUSIVE), 0, &pstmOlePres)) !=
                        NOERROR)
        {
                // we can't open the source stream
                *puiStatus |= CONVERT_NOSOURCE;

                // check whether "CONTENTS" stream exits
                if (pstg->OpenStream(OLE_CONTENTS_STREAM, NULL,
                                (STGM_READ | STGM_SHARE_EXCLUSIVE), 0,
                                &pstmContents) != NOERROR)
                {
                        // we can't open the destination stream either
                        // REVIEW, since we can't open the source, who cares?
                        // REVIEW, is there a cheaper way to test existence
                        // other than opening?
                        *puiStatus |= CONVERT_NODESTINATION;
                }
                else
                        pstmContents->Release();

                return(error);
        }

        foretc.ptd = NULL;
        if (error = UtReadOlePresStmHeader(pstmOlePres, &foretc, NULL, NULL))
                goto errRtn;

        if (error = pstmOlePres->Read(&hdfh, sizeof(hdfh), 0))
                goto errRtn;

        AssertSz(hdfh.dwCompression == 0,
                        "Non-zero compression not supported");

        if (error = OpenOrCreateStream(pstg, OLE_CONTENTS_STREAM,
                        &pstmContents))
        {
                *puiStatus |= CONVERT_NODESTINATION;
                goto errRtn;
        }

        if (foretc.dwAspect == DVASPECT_ICON)
        {
                *puiStatus |= CONVERT_SOURCEISICON;
                fDeletePresStm = FALSE;
                error = NOERROR;
                goto errRtn;
        }

        if (foretc.cfFormat == CF_DIB)
                error = UtDIBStmToDIBFileStm(pstmOlePres, hdfh.dwSize,
                                pstmContents);
        else if (foretc.cfFormat == CF_METAFILEPICT)
                error = UtMFStmToPlaceableMFStm(pstmOlePres,
                                hdfh.dwSize, hdfh.dwWidth, hdfh.dwHeight,
                                pstmContents);
        else
                error = ResultFromScode(DV_E_CLIPFORMAT);

errRtn:
        if (pstmOlePres)
                pstmOlePres->Release();

        if (pstmContents)
                pstmContents->Release();

        if (foretc.ptd)
                PubMemFree(foretc.ptd);

        if (error == NOERROR)
        {
                if (fDeletePresStm && lpszPresStm)
                        pstg->DestroyElement(lpszPresStm);
        }
        else
        {
                pstg->DestroyElement(OLE_CONTENTS_STREAM);
        }

        return(error);
}

FARINTERNAL UtOlePresStmToContentsStm(LPSTORAGE pstg, LPOLESTR lpszPresStm,
				LPSTREAM pstmContents, UINT FAR* puiStatus)
{
	HRESULT error = S_OK;
    LPSTREAM pstmOlePres = NULL;
    FORMATETC foretc;
    HDIBFILEHDR hdfh;

    // there's no status yet
    *puiStatus = 0;

    if ((error = pstg->OpenStream(lpszPresStm, NULL,
                    (STGM_READ | STGM_SHARE_EXCLUSIVE), 0, &pstmOlePres)) !=
                    NOERROR)
    {
            // we can't open the source stream
            *puiStatus |= CONVERT_NOSOURCE;
            return(error);
    }

    foretc.ptd = NULL;
    if (error = UtReadOlePresStmHeader(pstmOlePres, &foretc, NULL, NULL))
            goto errRtn;

    if (error = pstmOlePres->Read(&hdfh, sizeof(hdfh), 0))
            goto errRtn;

    AssertSz(hdfh.dwCompression == 0,
                    "Non-zero compression not supported");

    if (foretc.dwAspect == DVASPECT_ICON)
    {
            *puiStatus |= CONVERT_SOURCEISICON;
            error = NOERROR;
            goto errRtn;
    }

    if (foretc.cfFormat == CF_DIB)
            error = UtDIBStmToDIBFileStm(pstmOlePres, hdfh.dwSize,
                            pstmContents);
    else if (foretc.cfFormat == CF_METAFILEPICT)
            error = UtMFStmToPlaceableMFStm(pstmOlePres,
                            hdfh.dwSize, hdfh.dwWidth, hdfh.dwHeight,
                            pstmContents);
    else
            error = ResultFromScode(DV_E_CLIPFORMAT);

errRtn:
    if (pstmOlePres)
            pstmOlePres->Release();

	return error;
}


FARINTERNAL_(HANDLE) UtGetHPRESFromNative(LPSTORAGE pstg, LPSTREAM pstm, CLIPFORMAT cfFormat,
                BOOL fOle10Native)
{
        VDATEHEAP();

        BOOL fReleaseStm = !pstm;
        HGLOBAL hdata = NULL;

        if ((cfFormat != CF_METAFILEPICT) &&
            (cfFormat != CF_DIB) &&
            (cfFormat != CF_ENHMETAFILE))
        {
                return(NULL);
        }

        if (fOle10Native)
        {
                DWORD dwSize;

				if(!pstm)
				{
					if (pstg->OpenStream(OLE10_NATIVE_STREAM, NULL,
									(STGM_READ | STGM_SHARE_EXCLUSIVE), 0,
									&pstm) != NOERROR)
							return(NULL);
				}

                if (pstm->Read(&dwSize, sizeof(DWORD), NULL) == NOERROR)
                {
                        // is it PBrush native data?
                        if (cfFormat == CF_DIB)
                                UtGetHDIBFromDIBFileStm(pstm, &hdata);
                        else
                        {
                                // MSDraw native data or PaintBrush
                                //
                                UtGetHMFPICTFromMSDrawNativeStm(pstm, dwSize,
                                                &hdata);
                        }
                }
        }
        else
        {
				if(!pstm)
				{
					if (pstg->OpenStream(OLE_CONTENTS_STREAM, NULL,
									(STGM_READ | STGM_SHARE_EXCLUSIVE), 0,
									&pstm) != NOERROR)
							return(NULL);
				}

                if (cfFormat == CF_DIB)
                {
                        UtGetHDIBFromDIBFileStm(pstm, &hdata);
                }
                else if (cfFormat == CF_METAFILEPICT)
                {
                        UtGetHMFPICTFromPlaceableMFStm(pstm, &hdata);
                }
                else
                {
                        UtGetHEMFFromContentsStm(pstm, &hdata);
                }
        }

		if(fReleaseStm)
			pstm->Release();

        return(hdata);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\stdimpl\srvhndlr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       srvhndlr.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------


#ifndef _SRVHNDLR_H_DEFINED_
#define _SRVHNDLR_H_DEFINED_

class CStdIdentity;
class CEmbServerClientSite;


//+---------------------------------------------------------------------------
//
//  Class:      CServerHandler ()
//
//  Purpose:
//
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
class CServerHandler : public IServerHandler
{
public:


    CServerHandler(CStdIdentity *pStdId);
    ~CServerHandler();

    // IUnknown methods

    STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);

    // IServerHandler
    STDMETHOD(Run) (DWORD dwDHFlags, REFIID riidClientInterface, MInterfacePointer* pIRDClientInterface, BOOL fHasIPSite, LPOLESTR szContainerApp,
                         LPOLESTR szContainerObj,IStorage *  pStg,IAdviseSink* pAdvSink,DWORD *pdwConnection,
                         HRESULT *hresultClsidUser, CLSID *pContClassID, HRESULT *hresultContentMiscStatus,
                         DWORD *pdwMiscStatus
                        );

    STDMETHOD(DoVerb) (LONG iVerb, LPMSG lpmsg,BOOL fUseRunClientSite, 
                            IOleClientSite* pIRDClientSite,LONG lindex,HWND hwndParent,
                            LPCRECT lprcPosRect);

    STDMETHOD(SetClientSite) (IOleClientSite* pClientSite);

    // Delegating IDataObject facing container

    STDMETHOD(GetData) ( LPFORMATETC pformatetcIn,
            LPSTGMEDIUM pmedium );
    STDMETHOD(GetDataHere) ( LPFORMATETC pformatetc,
            LPSTGMEDIUM pmedium );
    STDMETHOD(QueryGetData) ( LPFORMATETC pformatetc );
    STDMETHOD(GetCanonicalFormatEtc) ( LPFORMATETC pformatetc,
            LPFORMATETC pformatetcOut);
    STDMETHOD(SetData) ( LPFORMATETC pformatetc,
            LPSTGMEDIUM pmedium, BOOL fRelease);
    STDMETHOD(EnumFormatEtc) ( DWORD dwDirection,
            LPENUMFORMATETC FAR* ppenumFormatEtc);
    STDMETHOD(DAdvise) ( FORMATETC FAR* pFormatetc, DWORD advf,
            IAdviseSink FAR* pAdvSink,
            DWORD FAR* pdwConnection);
    STDMETHOD(DUnadvise) ( DWORD dwConnection);
    STDMETHOD(EnumDAdvise) ( LPENUMSTATDATA FAR* ppenumAdvise);



private:
    STDMETHOD_(void, ReleaseObject)();

    INTERNAL(QueryServerInterface) (REFIID riid,void ** ppInterface);
    INTERNAL(ReleaseServerInterface) (void * ppInterface);
    INTERNAL(GetClientSiteFromMInterfacePtr) (REFIID riidClientInterface, MInterfacePointer* pIRDClientSite,BOOL fHasIPSite, LPOLECLIENTSITE* ppOleClientSite);

    ULONG           _cRefs;             // refcount on IServerHandler
    CStdIdentity *m_pStdId;             // Pointer to StdIdentity for Embedding Handler.

    LPOLECLIENTSITE m_pOleEmbServerClientSite; // Review, shouldn't need Pointer to client site if have one.
    CEmbServerClientSite *m_pCEmbServerClientSite; //  member pointing to ClientSiteObject.
};

// Wrapper object for Serverhandler Interfaces on the ClientSite.

class CEmbServerWrapper : public IServerHandler, public IDataObject
{
public:

    CEmbServerWrapper(IUnknown *pUnkOuter,IServerHandler *ServerHandler);
    ~CEmbServerWrapper();

    // Controlling Unknown.
    class CPrivUnknown : public IUnknown
    {
    public:
        STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj);
        STDMETHOD_(ULONG,AddRef) (void);
        STDMETHOD_(ULONG,Release) (void);
        
        CEmbServerWrapper *m_EmbServerWrapper;
    };

    friend class CPrivUnknown;
    CPrivUnknown m_Unknown;

    // IUnknown Methods
    STDMETHOD(QueryInterface) ( REFIID iid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);

    // IServerHandler
    STDMETHOD(Run) (DWORD dwDHFlags, REFIID riidClientInterface, MInterfacePointer* pIRDClientInterface, 
                     BOOL fHasIPSite,LPOLESTR szContainerApp,
                     LPOLESTR szContainerObj,IStorage *  pStg,IAdviseSink* pAdvSink,DWORD *pdwConnection,
                     HRESULT *hresultClsidUser, CLSID *pContClassID, HRESULT *hresultContentMiscStatus,
                     DWORD *pdwMiscStatus
                        );

    STDMETHOD(DoVerb) (LONG iVerb, LPMSG lpmsg,BOOL fUseRunClientSite, 
                            IOleClientSite* pIRDClientSite,LONG lindex,HWND hwndParent,
                            LPCRECT lprcPosRect);

    STDMETHOD(SetClientSite) (IOleClientSite* pClientSite);

    // Delegating IDataObject facing container

    STDMETHOD(GetData) ( LPFORMATETC pformatetcIn,
            LPSTGMEDIUM pmedium );
    STDMETHOD(GetDataHere) ( LPFORMATETC pformatetc,
            LPSTGMEDIUM pmedium );
    STDMETHOD(QueryGetData) ( LPFORMATETC pformatetc );
    STDMETHOD(GetCanonicalFormatEtc) ( LPFORMATETC pformatetc,
            LPFORMATETC pformatetcOut);
    STDMETHOD(SetData) ( LPFORMATETC pformatetc,
            LPSTGMEDIUM pmedium, BOOL fRelease);
    STDMETHOD(EnumFormatEtc) ( DWORD dwDirection,
            LPENUMFORMATETC FAR* ppenumFormatEtc);
    STDMETHOD(DAdvise) ( FORMATETC FAR* pFormatetc, DWORD advf,
            IAdviseSink FAR* pAdvSink,
            DWORD FAR* pdwConnection);
    STDMETHOD(DUnadvise) ( DWORD dwConnection);
    STDMETHOD(EnumDAdvise) ( LPENUMSTATDATA FAR* ppenumAdvise);

public: 
    IUnknown *m_pUnkOuter; // Controlling Unknown
    ULONG m_cRefs;

    IServerHandler *m_ServerHandler; // pointer to real server Handler.


};


HRESULT CreateServerHandler(const CLSID *pClsID, IUnknown *punk,
                            IClientSiteHandler *pClntHndlr,
                            IServerHandler **ppSrvHdlr);


CEmbServerWrapper* CreateEmbServerWrapper(IUnknown *pUnkOuter,IServerHandler *ServerHandler);


#endif //  _SRVHNDLR_H_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\util\global.cpp ===
//+----------------------------------------------------------------------------
//
//	File:
//		global.cpp
//
//	Contents:
//		Ut functions that deal with HGlobals for debugging;
//		see le2int.h
//
//	Classes:
//
//	Functions:
//		UtGlobalAlloc
//		UtGlobalReAlloc
//		UtGlobalLock
//		UtGlobalUnlock
//		UtGlobalFree
//              UtGlobalFlush
//              UtSetClipboardData
//
//	History:
//		12/20/93 - ChrisWe - created
//		01/11/94 - alexgo  - added VDATEHEAP macros to every function
//              02/25/94 AlexT      Add some generic integrity checking
//              03/30/94 AlexT      Add UtSetClipboardData
//
//  Notes:
//
//  These routines are designed to catch bugs that corrupt GlobalAlloc memory.
//  We cannot guarantee that all global memory will be manipulated with these
//  routines (e.g.  OLE might allocate a handle and the client application
//  might free it), so we can't require that these routines be used in pairs.
//
//-----------------------------------------------------------------------------


#include <le2int.h>

#if DBG==1 && defined(WIN32)
#include <olesem.hxx>

ASSERTDATA

// undefine these, so we don't call ourselves recursively
// if this module is used, these are defined in le2int.h to replace
// the existing allocator with the functions here
#undef GlobalAlloc
#undef GlobalReAlloc
#undef GlobalLock
#undef GlobalUnlock
#undef GlobalFree
#undef SetClipboardData

//  Same ones as in memapi.cxx
#define OLEMEM_ALLOCBYTE       0xde
#define OLEMEM_FREEBYTE        0xed

typedef struct s_GlobalAllocInfo
{
    HGLOBAL hGlobal;                        //  A GlobalAlloc'd HGLOBAL
    SIZE_T   cbGlobalSize;                   //  GlobalSize(hGlobal)
    SIZE_T   cbUser;                         //  size requested by caller
    ULONG   ulIndex;                        //  allocation index (1st, 2nd...)
    struct s_GlobalAllocInfo *pNext;
} SGLOBALALLOCINFO, *PSGLOBALALLOCINFO;

//+-------------------------------------------------------------------------
//
//  Class:      CGlobalTrack
//
//  Purpose:    GlobalAlloc memory tracking
//
//  History:    25-Feb-94 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CGlobalTrack
{
  public:

    //
    //  We only have a constructor for debug builds, to ensure this object
    //  is statically allocated. Statically allocated objects are initialized
    //  to all zeroes, which is what we need.
    //

    CGlobalTrack();

    HGLOBAL cgtGlobalAlloc(UINT uiFlag, SIZE_T cbUser);
    HGLOBAL cgtGlobalReAlloc(HGLOBAL hGlobal, SIZE_T cbUser, UINT uiFlag);
    HGLOBAL cgtGlobalFree(HGLOBAL hGlobal);
    LPVOID  cgtGlobalLock(HGLOBAL hGlobal);
    BOOL    cgtGlobalUnlock(HGLOBAL hGlobal);

    void    cgtVerifyAll(void);
    void    cgtFlushTracking(void);
    BOOL    cgtStopTracking(HGLOBAL hGlobal);

  private:
    SIZE_T CalculateAllocSize(SIZE_T cbUser);
    void InitializeRegion(HGLOBAL hGlobal, SIZE_T cbStart, SIZE_T cbEnd);
    void Track(HGLOBAL hGlobal, SIZE_T cbUser);
    void Retrack(HGLOBAL hOld, HGLOBAL hNew);
    void VerifyHandle(HGLOBAL hGlobal);

    ULONG _ulIndex;
    PSGLOBALALLOCINFO _pRoot;
    static COleStaticMutexSem _mxsGlobalMemory;
};

COleStaticMutexSem CGlobalTrack::_mxsGlobalMemory;

CGlobalTrack gGlobalTrack;



//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::CGlobalTrack, public
//
//  Synopsis:   constructor
//
//  History:    28-Feb-94 AlexT     Created
//
//--------------------------------------------------------------------------

CGlobalTrack::CGlobalTrack()
{
    Win4Assert (g_fDllState == DLL_STATE_STATIC_CONSTRUCTING);
    Win4Assert (_pRoot == NULL && _ulIndex == 0);
}



//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::cgtGlobalAlloc, public
//
//  Synopsis:   Debugging version of GlobalAlloc
//
//  Arguments:  [uiFlag] -- allocation flags
//              [cbUser] -- requested allocation size
//
//  Requires:   We must return a "real" GlobalAlloc'd pointer, because
//              we may not necessarily be the ones to free it.
//
//  Returns:    HGLOBAL
//
//  Algorithm:  We allocate an extra amount to form a tail and initialize it
//              to a known value.
//
//  History:    25-Feb-94 AlexT     Added this prologue
//
//  Notes:
//
//--------------------------------------------------------------------------

HGLOBAL CGlobalTrack::cgtGlobalAlloc(UINT uiFlag, SIZE_T cbUser)
{
    VDATEHEAP();

    SIZE_T cbAlloc;
    HGLOBAL hGlobal;

    cbAlloc = CalculateAllocSize(cbUser);
    hGlobal = GlobalAlloc(uiFlag, cbAlloc);
    if (NULL == hGlobal)
    {
        LEDebugOut((DEB_WARN, "GlobalAlloc(%ld) failed - %lx\n", cbAlloc,
                   GetLastError()));
    }
    else
    {
        if (uiFlag & GMEM_ZEROINIT)
        {
            //   Caller asked for zeroinit, so we only initialize the tail
            InitializeRegion(hGlobal, cbUser, cbAlloc);
        }
        else
        {
            //  Caller did not ask for zeroinit, so we initialize the whole
            //  region
            InitializeRegion(hGlobal, 0, cbAlloc);
        }

        Track(hGlobal, cbUser);
    }

    return(hGlobal);
}

//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::cgtGlobalReAlloc, public
//
//  Synopsis:   Debugging version of GlobalReAlloc
//
//  Arguments:  [hGlobal] -- handle to reallocate
//              [cbUser] -- requested allocation size
//              [uiFlag] -- allocation flags
//
//  Returns:    reallocated handle
//
//  Algorithm:
//
//    if (modify only)
//      reallocate
//    else
//      reallocate with tail
//      initialize tail
//
//    update tracking information
//
//  History:    25-Feb-94 AlexT     Added this prologue
//
//  Notes:
//
//--------------------------------------------------------------------------

HGLOBAL CGlobalTrack::cgtGlobalReAlloc(HGLOBAL hGlobal, SIZE_T cbUser, UINT uiFlag)
{
    VDATEHEAP();

    HGLOBAL hNew;
    SIZE_T cbAlloc;

    VerifyHandle(hGlobal);

    if (uiFlag & GMEM_MODIFY)
    {
        //  We're not changing sizes, so there's no work for us to do

        LEDebugOut((DEB_WARN, "UtGlobalReAlloc modifying global handle\n"));
        hNew = GlobalReAlloc(hGlobal, cbUser, uiFlag);
    }
    else
    {
        cbAlloc = CalculateAllocSize(cbUser);
        hNew = GlobalReAlloc(hGlobal, cbAlloc, uiFlag);
        if (NULL == hNew)
        {
            LEDebugOut((DEB_WARN, "GlobalReAlloc failed - %lx\n",
                        GetLastError()));
        }
        else
        {
            InitializeRegion(hNew, cbUser, cbAlloc);
        }
    }

    if (NULL != hNew)
    {
        if (uiFlag & GMEM_MODIFY)
        {
            //  Retrack will only track hNew if we were tracking hGlobal
            Retrack(hGlobal, hNew);
        }
        else
        {
            //  We've allocated a new block, so we always want to track the
            //  new one
            cgtStopTracking(hGlobal);
            Track(hNew, cbUser);
        }
    }

    return(hNew);
}

//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::cgtGlobalFree, public
//
//  Synopsis:   Debugging version of GlobalReAlloc
//
//  Arguments:  [hGlobal] -- global handle to free
//
//  Returns:    Same as GlobalFree
//
//  Algorithm:
//
//  History:    25-Feb-94 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

HGLOBAL CGlobalTrack::cgtGlobalFree(HGLOBAL hGlobal)
{
    VDATEHEAP();

    HGLOBAL hReturn;

    VerifyHandle(hGlobal);

    hReturn = GlobalFree(hGlobal);

    if (NULL == hReturn)
    {
        cgtStopTracking(hGlobal);
    }
    else
    {
        LEDebugOut((DEB_WARN, "GlobalFree did not free %lx\n", hGlobal));
    }

    return(hReturn);
}

//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::cgtGlobalLock, public
//
//  Synopsis:   Debugging version of GlobalLock
//
//  Arguments:  [hGlobal] -- global memory handle
//
//  Returns:    Same as GlobalLock
//
//  History:    25-Feb-94 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

LPVOID CGlobalTrack::cgtGlobalLock(HGLOBAL hGlobal)
{
    VDATEHEAP();

    VerifyHandle(hGlobal);
    return(GlobalLock(hGlobal));
}

//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::cgtGlobalUnlock, public
//
//  Synopsis:   Debugging version of GlobalUnlock
//
//  Arguments:  [hGlobal] -- global memory handle
//
//  Returns:    Same as GlobalUnlock
//
//  History:    25-Feb-94 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CGlobalTrack::cgtGlobalUnlock(HGLOBAL hGlobal)
{
    VDATEHEAP();

    VerifyHandle(hGlobal);
    return(GlobalUnlock(hGlobal));
}

//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::cgtVerifyAll, public
//
//  Synopsis:   Verify all tracked handles
//
//  History:    28-Feb-94 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void CGlobalTrack::cgtVerifyAll(void)
{
    VerifyHandle(NULL);
}

//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::cgtFlushTracking
//
//  Synopsis:   Stops all tracking
//
//  Effects:    Frees all internal memory
//
//  History:    28-Feb-94 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void CGlobalTrack::cgtFlushTracking(void)
{
    COleStaticLock lck(_mxsGlobalMemory);
    BOOL bResult;

    while (NULL != _pRoot)
    {
        bResult = cgtStopTracking(_pRoot->hGlobal);
        Assert(bResult && "CGT::cgtFlushTracking problem");
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::CalculateAllocSize, private
//
//  Synopsis:   calculate total allocation size (inluding tail)
//
//  Arguments:  [cbUser] -- requested size
//
//  Returns:    total count of bytes to allocate
//
//  Algorithm:  calculate bytes needed to have at least one guard page at the
//              end
//
//  History:    28-Feb-94 AlexT     Created
//
//  Notes:      By keeping this calculation in one location we make it
//              easier to maintain.
//
//--------------------------------------------------------------------------

SIZE_T CGlobalTrack::CalculateAllocSize(SIZE_T cbUser)
{
    SYSTEM_INFO si;
    SIZE_T cbAlloc;

    GetSystemInfo(&si);

    //  Calculate how many pages are need to cover cbUser
    cbAlloc = ((cbUser + si.dwPageSize - 1) / si.dwPageSize) * si.dwPageSize;

    //  Add an extra page so that the tail is at least one page long
    cbAlloc += si.dwPageSize;

    return(cbAlloc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::InitializeRegion, private
//
//  Synopsis:   initialize region to bad value
//
//  Effects:    fills in memory region
//
//  Arguments:  [hGlobal] -- global memory handle
//              [cbStart] -- count of bytes to skip
//              [cbEnd]   -- end offset (exclusive)
//
//  Requires:   cbEnd > cbStart
//
//  Algorithm:  fill in hGlobal from cbStart (inclusive) to cbEnd (exclusive)
//
//  History:    28-Feb-94 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void CGlobalTrack::InitializeRegion(HGLOBAL hGlobal, SIZE_T cbStart, SIZE_T cbEnd)
{
    BYTE *pbStart;
    BYTE *pb;

    Assert(cbStart < cbEnd && "illogical parameters");
    Assert(cbEnd <= GlobalSize(hGlobal) && "global memory too small");

    //  GlobalLock on GMEM_FIXED memory is a nop, so this is a safe call
    pbStart = (BYTE *) GlobalLock(hGlobal);

    if (NULL == pbStart)
    {
        //  Shouldn't have failed - (we allocated > 0 bytes)

        LEDebugOut((DEB_WARN, "GlobalLock failed - %lx\n", GetLastError()));
        return;
    }

    //  Initialize the tail portion of the memory
    for (pb = pbStart + cbStart; pb < pbStart + cbEnd; pb++)
    {
        *pb = OLEMEM_ALLOCBYTE;
    }

    GlobalUnlock(hGlobal);
}

//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::Track, private
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [hGlobal] -- global memory handle
//              [cbUser] -- user allocation size
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    28-Feb-94 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void CGlobalTrack::Track(HGLOBAL hGlobal, SIZE_T cbUser)
{
    COleStaticLock lck(_mxsGlobalMemory);
    PSGLOBALALLOCINFO pgi;

    if (cgtStopTracking(hGlobal))
    {
        //  If it's already in our list, it's possible that someone else
        //  freed the HGLOBAL without telling us - remove our stale one
        LEDebugOut((DEB_WARN, "CGT::Track - %lx was already in list!\n",
                    hGlobal));
    }

    pgi = (PSGLOBALALLOCINFO) PrivMemAlloc(sizeof(SGLOBALALLOCINFO));
    if (NULL == pgi)
    {
        LEDebugOut((DEB_WARN, "CGT::Insert - PrivMemAlloc failed\n"));

        //  Okay fine - we just won't track this one

        return;
    }

    pgi->hGlobal = hGlobal;
    pgi->cbGlobalSize = GlobalSize(hGlobal);
    Assert((0 == cbUser || pgi->cbGlobalSize > 0) && "GlobalSize failed - bad handle?");
    pgi->cbUser = cbUser;
    pgi->ulIndex = ++_ulIndex;
    pgi->pNext = _pRoot;
    _pRoot = pgi;
}

//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::Retrack, private
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [hOld] -- previous handle
//              [hNew] -- new handle
//
//  Modifies:
//
//  Algorithm:
//
//  History:    28-Feb-94 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void CGlobalTrack::Retrack(HGLOBAL hOld, HGLOBAL hNew)
{
    COleStaticLock lck(_mxsGlobalMemory);
    PSGLOBALALLOCINFO pgi;

    if (hOld != hNew && cgtStopTracking(hNew))
    {
        //  If hNew was already in the list, it's possible that someone else
        //  freed the HGLOBAL without telling us so we removed the stale one
        LEDebugOut((DEB_WARN, "CGT::Retrack - %lx was already in list!\n", hNew));
    }

    for (pgi = _pRoot; NULL != pgi; pgi = pgi->pNext)
    {
        if (pgi->hGlobal == hOld)
        {
            pgi->hGlobal = hNew;
            break;
        }
    }

    if (NULL == pgi)
    {
        //  We didn't find hOld
        LEDebugOut((DEB_WARN, "CGT::Retrack - hOld (%lx) not found\n", hOld));
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::cgtStopTracking, public
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [hGlobal] -- global handle
//
//  Modifies:
//
//  Algorithm:
//
//  History:    28-Feb-94 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CGlobalTrack::cgtStopTracking(HGLOBAL hGlobal)
{
    COleStaticLock lck(_mxsGlobalMemory);
    PSGLOBALALLOCINFO *ppgi = &_pRoot;
    PSGLOBALALLOCINFO pgi;

    while (*ppgi != NULL && (*ppgi)->hGlobal != hGlobal)
    {
        ppgi = &((*ppgi)->pNext);
    }

    if (NULL == *ppgi)
    {
        return(FALSE);
    }

    pgi = *ppgi;
    Assert(pgi->hGlobal == hGlobal && "CGT::cgtStopTracking search problem");

    *ppgi = pgi->pNext;

    PrivMemFree(pgi);
    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Member:     CGlobalTrack::VerifyHandle, private
//
//  Synopsis:   Verify global handle
//
//  Arguments:  [hGlobal] -- global memory handle
//
//  Signals:    Asserts if bad
//
//  Algorithm:
//
//  History:    28-Feb-94 AlexT     Created
//              22-Jun-94 AlexT     Allow for handle to have been freed and
//                                  reallocated under us
//
//--------------------------------------------------------------------------

void CGlobalTrack::VerifyHandle(HGLOBAL hGlobal)
{
    COleStaticLock lck(_mxsGlobalMemory);
    PSGLOBALALLOCINFO pgi, pgiNext;
    SIZE_T cbAlloc;
    BYTE *pbStart;
    BYTE *pb;

    //  Note that we use a while loop (recording pgiNext up front) instead
    //  of a for loop because pgi will get removed from the list if we call
    //  cgtStopTracking on it

    pgi = _pRoot;
    while (NULL != pgi)
    {
        pgiNext = pgi->pNext;

        if (NULL == hGlobal || pgi->hGlobal == hGlobal)
        {
            if (pgi->cbGlobalSize != GlobalSize(pgi->hGlobal))
            {
                //  pgi->hGlobal's size has changed since we started tracking
                //  it;  it must have been freed or reallocated by someone
                //  else.  Stop tracking it.

                //  This call will remove pgi from the list (so we NULL it to
                //  make sure we don't try reusing it)!

                cgtStopTracking(pgi->hGlobal);
                pgi = NULL;
            }
            else
            {
                cbAlloc = CalculateAllocSize(pgi->cbUser);

                pbStart = (BYTE *) GlobalLock(pgi->hGlobal);

                // it is legitimate to have a zero length (NULL memory) handle
                if (NULL == pbStart)
                {
                    LEDebugOut((DEB_WARN, "GlobalLock failed - %lx\n",
                               GetLastError()));
                }
                else
                {
                    for (pb = pbStart + pgi->cbUser;
                         pb < pbStart + cbAlloc;
                         pb++)
                    {
                        if (*pb != OLEMEM_ALLOCBYTE)
                            break;
                    }

                    if (pb < pbStart + cbAlloc)
                    {
                        //  In general an application may have freed and reallocated
                        //  any HGLOBAL, so we can only warn about corruption.

                        LEDebugOut((DEB_WARN, "HGLOBAL #%ld may be corrupt\n",
                                   pgi->ulIndex));
#ifdef GLOBALDBG
                        //  If GLOBALDBG is true, then all allocations should be
                        //  coming through these routines.  In this case we assert
                        //  if we've found corruption.
                        Assert(0 && "CGlobalTrack::VerifyHandle - HGLOBAL corrupt");
#endif
                    }

                    GlobalUnlock(pgi->hGlobal);
                }
            }
        }

        pgi = pgiNext;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   UtGlobalAlloc, ReAlloc, Free, Lock, Unlock
//
//  Synopsis:   Debug versions of Global memory routines
//
//  Arguments:  Same as Windows APIs
//
//  History:    28-Feb-94 AlexT     Created
//
//  Notes:      These entry points just call the worker routines
//
//--------------------------------------------------------------------------

extern "C" HGLOBAL WINAPI UtGlobalAlloc(UINT uiFlag, SIZE_T cbUser)
{
    return gGlobalTrack.cgtGlobalAlloc(uiFlag, cbUser);
}

extern "C" HGLOBAL WINAPI UtGlobalReAlloc(HGLOBAL hGlobal, SIZE_T cbUser, UINT uiFlag)
{
    return gGlobalTrack.cgtGlobalReAlloc(hGlobal, cbUser, uiFlag);
}

extern "C" LPVOID WINAPI UtGlobalLock(HGLOBAL hGlobal)
{
    return gGlobalTrack.cgtGlobalLock(hGlobal);
}

extern "C" BOOL WINAPI UtGlobalUnlock(HGLOBAL hGlobal)
{
    return gGlobalTrack.cgtGlobalUnlock(hGlobal);
}

extern "C" HGLOBAL WINAPI UtGlobalFree(HGLOBAL hGlobal)
{
    return gGlobalTrack.cgtGlobalFree(hGlobal);
}

extern "C" void UtGlobalFlushTracking(void)
{
    gGlobalTrack.cgtFlushTracking();
}

//+-------------------------------------------------------------------------
//
//  Function:   UtSetClipboardData
//
//  Synopsis:   Calls Windows SetClipboardData and stops tracking the handle
//
//  Arguments:  [uFormat] -- clipboard format
//              [hMem]    -- data handle
//
//  Returns:    Same as SetClipboard
//
//  Algorithm:  If SetClipboardData succeeds, stop tracking the handle
//
//  History:    30-Mar-94 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

extern "C" HANDLE WINAPI UtSetClipboardData(UINT uFormat, HANDLE hMem)
{
    HANDLE hRet;

    hRet = SetClipboardData(uFormat, hMem);

    if (NULL != hRet)
    {
        gGlobalTrack.cgtStopTracking(hMem);
    }

    return(hRet);
}

#endif  //  DBG==1 && defined(WIN32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\util\map_kv.cpp ===
/////////////////////////////////////////////////////////////////////////////
// class CMapKeyToValue - a mapping from 'KEY's to 'VALUE's, passed in as
// pv/cb pairs.  The keys can be variable length, although we optmizize the
// case when they are all the same.
//
/////////////////////////////////////////////////////////////////////////////

#include <le2int.h>
#pragma SEG(map_kv)

#include "map_kv.h"
#include "valid.h"

#include "plex.h"
ASSERTDATA


/////////////////////////////////////////////////////////////////////////////


#pragma SEG(CMapKeyToValue_ctor)
CMapKeyToValue::CMapKeyToValue(UINT cbValue, UINT cbKey,
	int nBlockSize, LPFNHASHKEY lpfnHashKey, UINT nHashSize)
{
	VDATEHEAP();

	Assert(nBlockSize > 0);

	m_cbValue = cbValue;
	m_cbKey = cbKey;
	m_cbKeyInAssoc = (UINT) (cbKey == 0 ? sizeof(CKeyWrap) : cbKey);

	m_pHashTable = NULL;
	m_nHashTableSize = nHashSize;
	m_lpfnHashKey = lpfnHashKey;

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

#pragma SEG(CMapKeyToValue_dtor)
CMapKeyToValue::~CMapKeyToValue()
{
	VDATEHEAP();

	ASSERT_VALID(this);
	RemoveAll();
    Assert(m_nCount == 0);
}

#define LOCKTHIS
#define UNLOCKTHIS

#ifdef NEVER
void CMapKeyToValue::LockThis(void)
{
	VDATEHEAP();

    LOCKTHIS;
}

void CMapKeyToValue::UnlockThis(void)
{
	VDATEHEAP();

    UNLOCKTHIS;
}

#endif //NEVER

#pragma SEG(MKVDefaultHashKey)
// simple, default hash function
// REVIEW: need to check the value in this for GUIDs and strings
STDAPI_(UINT) MKVDefaultHashKey(LPVOID pKey, UINT cbKey)
{
	VDATEHEAP();

	UINT hash = 0;
	BYTE FAR* lpb = (BYTE FAR*)pKey;

	while (cbKey-- != 0)
		hash = 257 * hash + *lpb++;

	return hash;
}


#pragma SEG(CMapKeyToValue_InitHashTable)
BOOL CMapKeyToValue::InitHashTable()
{
	VDATEHEAP();

	ASSERT_VALID(this);
	Assert(m_nHashTableSize  > 0);
	
	if (m_pHashTable != NULL)
		return TRUE;

	Assert(m_nCount == 0);

	if ((m_pHashTable = (CAssoc FAR* FAR*)PrivMemAlloc(m_nHashTableSize * 
		sizeof(CAssoc FAR*))) == NULL)
		return FALSE;

	_xmemset(m_pHashTable, 0, sizeof(CAssoc FAR*) * m_nHashTableSize);

	ASSERT_VALID(this);

	return TRUE;
}


#pragma SEG(CMapKeyToValue_RemoveAll)
void CMapKeyToValue::RemoveAll()
{
	VDATEHEAP();

    LOCKTHIS;

	ASSERT_VALID(this);

	// free all key values and then hash table
	if (m_pHashTable != NULL)
	{
		// destroy assocs
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			register CAssoc FAR* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
				// assoc itself is freed by FreeDataChain below
				FreeAssocKey(pAssoc);
		}

		// free hash table
		PrivMemFree(m_pHashTable);
		m_pHashTable = NULL;
	}

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;

    ASSERT_VALID(this);
    UNLOCKTHIS;
}

/////////////////////////////////////////////////////////////////////////////
// Assoc helpers
// CAssoc's are singly linked all the time

#pragma SEG(CMapKeyToValue_NewAssoc)
CMapKeyToValue::CAssoc  FAR*
    CMapKeyToValue::NewAssoc(UINT hash, LPVOID pKey, UINT cbKey, LPVOID pValue)
{
	VDATEHEAP();

	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex FAR* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, SizeAssoc());

		if (newBlock == NULL)
			return NULL;

		// chain them into free list
		register BYTE  FAR* pbAssoc = (BYTE FAR*) newBlock->data();
		// free in reverse order to make it easier to debug
		pbAssoc += (m_nBlockSize - 1) * SizeAssoc();
		for (int i = m_nBlockSize-1; i >= 0; i--, pbAssoc -= SizeAssoc())
		{
			((CAssoc FAR*)pbAssoc)->pNext = m_pFreeList;
			m_pFreeList = (CAssoc FAR*)pbAssoc;
		}
	}
	Assert(m_pFreeList != NULL); // we must have something

	CMapKeyToValue::CAssoc  FAR* pAssoc = m_pFreeList;

	// init all fields except pNext while still on free list
	pAssoc->nHashValue = hash;
	if (!SetAssocKey(pAssoc, pKey, cbKey))
		return NULL;

	SetAssocValue(pAssoc, pValue);

	// remove from free list after successfully initializing it (except pNext)
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;
	Assert(m_nCount > 0);       // make sure we don't overflow

	return pAssoc;
}


#pragma SEG(CMapKeyToValue_FreeAssoc)
// free individual assoc by freeing key and putting on free list
void CMapKeyToValue::FreeAssoc(CMapKeyToValue::CAssoc  FAR* pAssoc)
{
	VDATEHEAP();

	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;
	Assert(m_nCount >= 0);      // make sure we don't underflow

	FreeAssocKey(pAssoc);
}


#pragma SEG(CMapKeyToValue_GetAssocAt)
// find association (or return NULL)
CMapKeyToValue::CAssoc  FAR*
CMapKeyToValue::GetAssocAt(LPVOID pKey, UINT cbKey, UINT FAR& nHash) const
{
	VDATEHEAP();

	if (m_lpfnHashKey)
	    nHash = (*m_lpfnHashKey)(pKey, cbKey) % m_nHashTableSize;
	else
	    nHash = MKVDefaultHashKey(pKey, cbKey) % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	register CAssoc  FAR* pAssoc;
	for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareAssocKey(pAssoc, pKey, cbKey))
			return pAssoc;
	}
	return NULL;
}


#pragma SEG(CMapKeyToValue_CompareAssocKey)
BOOL CMapKeyToValue::CompareAssocKey(CAssoc FAR* pAssoc, LPVOID pKey2, UINT cbKey2) const
{
	VDATEHEAP();

	LPVOID pKey1;
	UINT cbKey1;

	GetAssocKeyPtr(pAssoc, &pKey1, &cbKey1);
	return cbKey1 == cbKey2 && _xmemcmp(pKey1, pKey2, cbKey1) == 0;
}


#pragma SEG(CMapKeyToValue_SetAssocKey)
BOOL CMapKeyToValue::SetAssocKey(CAssoc FAR* pAssoc, LPVOID pKey, UINT cbKey) const
{
	VDATEHEAP();

	Assert(cbKey == m_cbKey || m_cbKey == 0);

	if (m_cbKey == 0)
	{
		Assert(m_cbKeyInAssoc == sizeof(CKeyWrap));

		// alloc, set size and pointer
		if ((pAssoc->key.pKey = PrivMemAlloc(cbKey)) == NULL)
			return FALSE;

		pAssoc->key.cbKey = cbKey;
	}

	LPVOID pKeyTo;

	GetAssocKeyPtr(pAssoc, &pKeyTo, &cbKey);

	_xmemcpy(pKeyTo, pKey, cbKey);

	return TRUE;
}


#pragma SEG(CMapKeyToValue_GetAssocKeyPtr)
// gets pointer to key and its length
void CMapKeyToValue::GetAssocKeyPtr(CAssoc FAR* pAssoc, LPVOID FAR* ppKey,UINT FAR* pcbKey) const
{
	VDATEHEAP();

	if (m_cbKey == 0)
	{
		// variable length key; go indirect
		*ppKey = pAssoc->key.pKey;
		*pcbKey = pAssoc->key.cbKey;
	}
	else
	{
		// fixed length key; key in assoc
		*ppKey = (LPVOID)&pAssoc->key;
		*pcbKey = m_cbKey;
	}
}


#pragma SEG(CMapKeyToValue_FreeAssocKey)
void CMapKeyToValue::FreeAssocKey(CAssoc FAR* pAssoc) const
{
	VDATEHEAP();

	if (m_cbKey == 0)
		PrivMemFree(pAssoc->key.pKey);
}


#pragma SEG(CMapKeyToValue_GetAssocValuePtr)
void CMapKeyToValue::GetAssocValuePtr(CAssoc FAR* pAssoc, LPVOID FAR* ppValue) const
{
	VDATEHEAP();

	*ppValue = (char FAR*)&pAssoc->key + m_cbKeyInAssoc;
}


#pragma SEG(CMapKeyToValue_GetAssocValue)
void CMapKeyToValue::GetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const
{
	VDATEHEAP();

	LPVOID pValueFrom;
	GetAssocValuePtr(pAssoc, &pValueFrom);
	Assert(pValue != NULL);
	_xmemcpy(pValue, pValueFrom, m_cbValue);
}


#pragma SEG(CMapKeyToValue_SetAssocValue)
void CMapKeyToValue::SetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const
{
	VDATEHEAP();

	LPVOID pValueTo;
	GetAssocValuePtr(pAssoc, &pValueTo);
	if (pValue == NULL)
		_xmemset(pValueTo, 0, m_cbValue);
	else
		_xmemcpy(pValueTo, pValue, m_cbValue);
}


/////////////////////////////////////////////////////////////////////////////

#pragma SEG(CMapKeyToValue_Lookup)
// lookup value given key; return FALSE if key not found; in that
// case, the value is set to all zeros
BOOL CMapKeyToValue::Lookup(LPVOID pKey, UINT cbKey, LPVOID pValue) const
{
	VDATEHEAP();

    UINT nHash;
    BOOL fFound;

    LOCKTHIS;
    fFound = LookupHKey((HMAPKEY)GetAssocAt(pKey, cbKey, nHash), pValue);
    UNLOCKTHIS;
    return fFound;
}


#pragma SEG(CMapKeyToValue_LookupHKey)
// lookup value given key; return FALSE if NULL (or bad) key; in that
// case, the value is set to all zeros
BOOL CMapKeyToValue::LookupHKey(HMAPKEY hKey, LPVOID pValue) const
{
	VDATEHEAP();

    BOOL fFound = FALSE;

    LOCKTHIS;

	// REVIEW: would like some way to verify that hKey is valid
	register CAssoc  FAR* pAssoc = (CAssoc FAR*)hKey;
	if (pAssoc == NULL)
	{
		_xmemset(pValue, 0, m_cbValue);
                goto Exit;       // not in map
	}

	ASSERT_VALID(this);

	GetAssocValue(pAssoc, pValue);
    fFound = TRUE;
Exit:
    UNLOCKTHIS;
    return fFound;
}


#pragma SEG(CMapKeyToValue_LookupAdd)
// lookup and if not found add; returns FALSE only if OOM; if added,
// value added and pointer passed are set to zeros.
BOOL CMapKeyToValue::LookupAdd(LPVOID pKey, UINT cbKey, LPVOID pValue) const
{
	VDATEHEAP();

    BOOL fFound;

    LOCKTHIS;

    fFound = Lookup(pKey, cbKey, pValue);
    if (!fFound) // value set to zeros since lookup failed
        fFound = ((CMapKeyToValue FAR*)this)->SetAt(pKey, cbKey, NULL);

    UNLOCKTHIS;
    return fFound;
}


#pragma SEG(CMapKeyToValue_SetAt)
// the only place new assocs are created; return FALSE if OOM;
// never returns FALSE if keys already exists
BOOL CMapKeyToValue::SetAt(LPVOID pKey, UINT cbKey, LPVOID pValue)
{
	VDATEHEAP();

	UINT nHash;
    register CAssoc  FAR* pAssoc;
    BOOL fFound = FALSE;

    LOCKTHIS;

	ASSERT_VALID(this);

	if ((pAssoc = GetAssocAt(pKey, cbKey, nHash)) == NULL)
	{
		if (!InitHashTable())
			// out of memory
			goto Exit;

		// it doesn't exist, add a new Association
		if ((pAssoc = NewAssoc(nHash, pKey, cbKey, pValue)) == NULL)
			goto Exit;

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHash];
		m_pHashTable[nHash] = pAssoc;

		ASSERT_VALID(this);
	}
	else
                SetAssocValue(pAssoc, pValue);

    fFound = TRUE;
Exit:
    UNLOCKTHIS;
    return fFound;
}


#pragma SEG(CMapKeyToValue_SetAtHKey)
// set existing hkey to value; return FALSE if NULL or bad key
BOOL CMapKeyToValue::SetAtHKey(HMAPKEY hKey, LPVOID pValue)
{
	VDATEHEAP();

    BOOL fDone = FALSE;
    LOCKTHIS;
	// REVIEW: would like some way to verify that hKey is valid
	register CAssoc  FAR* pAssoc = (CAssoc FAR*)hKey;
	if (pAssoc == NULL)
		goto Exit;       // not in map

	ASSERT_VALID(this);

    SetAssocValue(pAssoc, pValue);
    fDone = TRUE;
Exit:
    UNLOCKTHIS;
    return fDone;
}


#pragma SEG(CMapKeyToValue_RemoveKey)
// remove key - return TRUE if removed
BOOL CMapKeyToValue::RemoveKey(LPVOID pKey, UINT cbKey)
{
	VDATEHEAP();

    BOOL fFound = FALSE;
    UINT i;

    LOCKTHIS;
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		goto Exit;       // nothing in the table

	register CAssoc  FAR* FAR* ppAssocPrev;
	if (m_lpfnHashKey)
	    i = (*m_lpfnHashKey)(pKey, cbKey) % m_nHashTableSize;
	else
	    i = MKVDefaultHashKey(pKey, cbKey) % m_nHashTableSize;

	ppAssocPrev = &m_pHashTable[i];

	CAssoc  FAR* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareAssocKey(pAssoc, pKey, cbKey))
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;       // remove from list
			FreeAssoc(pAssoc);
			ASSERT_VALID(this);
            fFound = TRUE;
            break;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
Exit:
     UNLOCKTHIS;
     return fFound;
}


#pragma SEG(CMapKeyToValue_RemoveHKey)
// remove key based on pAssoc (HMAPKEY)
BOOL CMapKeyToValue::RemoveHKey(HMAPKEY hKey)
{
	VDATEHEAP();

    BOOL fFound = FALSE;

    // REVIEW: would like some way to verify that hKey is valid
	CAssoc  FAR* pAssoc = (CAssoc FAR*)hKey;

    LOCKTHIS;
    ASSERT_VALID(this);

	if (m_pHashTable == NULL)
        goto Exit;       // nothing in the table

    if (pAssoc == NULL || pAssoc->nHashValue >= m_nHashTableSize)
        goto Exit; // null hkey or bad hash value

	register CAssoc  FAR* FAR* ppAssocPrev;
	ppAssocPrev = &m_pHashTable[pAssoc->nHashValue];

	while (*ppAssocPrev != NULL)
	{
		if (*ppAssocPrev == pAssoc)
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;       // remove from list
			FreeAssoc(pAssoc);
			ASSERT_VALID(this);
            fFound = TRUE;
            break;
		}
		ppAssocPrev = &(*ppAssocPrev)->pNext;
	}

Exit:
    UNLOCKTHIS;
    return fFound;
}


#pragma SEG(CMapKeyToValue_GetHKey)
HMAPKEY CMapKeyToValue::GetHKey(LPVOID pKey, UINT cbKey) const
{
	VDATEHEAP();

    UINT nHash;
    HMAPKEY hKey;

    LOCKTHIS;
	ASSERT_VALID(this);

    hKey = (HMAPKEY)GetAssocAt(pKey, cbKey, nHash);
    UNLOCKTHIS;
    return hKey;
}


/////////////////////////////////////////////////////////////////////////////
// Iterating

// for fixed length keys, copies key to pKey; pcbKey can be NULL;
// for variable length keys, copies pointer to key to pKey; sets pcbKey.

#pragma SEG(CMapKeyToValue_GetNextAssoc)
void CMapKeyToValue::GetNextAssoc(POSITION FAR* pNextPosition,
		LPVOID pKey, UINT FAR* pcbKey, LPVOID pValue) const
{
	VDATEHEAP();

	ASSERT_VALID(this);

	Assert(m_pHashTable != NULL);       // never call on empty map

	register CAssoc  FAR* pAssocRet = (CAssoc  FAR*)*pNextPosition;
	Assert(pAssocRet != NULL);

	if (pAssocRet == (CAssoc  FAR*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
				break;
		Assert(pAssocRet != NULL);  // must find something
	}

	// find next association
	CAssoc  FAR* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = pAssocRet->nHashValue + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	// fill in return data
	*pNextPosition = (POSITION) pAssocNext;

	// fill in key/pointer to key
	LPVOID pKeyFrom;
	UINT cbKey;
	GetAssocKeyPtr(pAssocRet, &pKeyFrom, &cbKey);
	if (m_cbKey == 0)
		// variable length key; just return pointer to key itself
		*(void FAR* FAR*)pKey = pKeyFrom;
	else
		_xmemcpy(pKey, pKeyFrom, cbKey);

	if (pcbKey != NULL)
		*pcbKey = cbKey;

	// get value
	GetAssocValue(pAssocRet, pValue);
}

/////////////////////////////////////////////////////////////////////////////

#pragma SEG(CMapKeyToValue_AssertValid)
void CMapKeyToValue::AssertValid() const
{
	VDATEHEAP();

#ifdef _DEBUG
	Assert(m_cbKeyInAssoc == (m_cbKey == 0 ? sizeof(CKeyWrap) : m_cbKey));

	Assert(m_nHashTableSize > 0);
	Assert(m_nCount == 0 || m_pHashTable != NULL);

	if (m_pHashTable != NULL)
		Assert(IsValidReadPtrIn(m_pHashTable, m_nHashTableSize * sizeof(CAssoc FAR*)));

	if (m_lpfnHashKey)
	    Assert(IsValidCodePtr((FARPROC)m_lpfnHashKey));

	if (m_pFreeList != NULL)
		Assert(IsValidReadPtrIn(m_pFreeList, SizeAssoc()));

	if (m_pBlocks != NULL)
		Assert(IsValidReadPtrIn(m_pBlocks, SizeAssoc() * m_nBlockSize));

#endif //_DEBUG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\util\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   util
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\..\common\$(DEST_TREE);..\..\..\ih;..\..\inc

SOURCES=      \
              ..\convert.cpp  \
              ..\global.cpp   \
              ..\map_kv.cpp   \
              ..\ole2util.cpp \
              ..\plex.cpp     \
              ..\utils.cpp    \
              ..\utstream.cpp

UMTYPE=       windows

!include ..\..\precomp2.inc
USE_IOSTREAM=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\util\plex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library. 
// Copyright (C) 1992 Microsoft Corporation 
// All rights reserved. 
//  
// This source code is only intended as a supplement to the 
// Microsoft Foundation Classes Reference and Microsoft 
// QuickHelp documentation provided with the library. 
// See these sources for detailed information regarding the 
// Microsoft Foundation Classes product. 

#include <le2int.h>
#pragma SEG(plex)

#include "plex.h"
ASSERTDATA

// Collection support
#ifdef OLE_COLL_SEG
#pragma code_seg(OLE_COLL_SEG)
#endif


#pragma SEG(CPlex_Create)  
CPlex FAR* CPlex::Create(CPlex FAR* FAR& pHead, UINT nMax, UINT cbElement)
{
	VDATEHEAP();

	Assert(nMax > 0 && cbElement > 0);
	CPlex FAR* p = (CPlex FAR*)PrivMemAlloc(sizeof(CPlex) + nMax * cbElement);
	if (p == NULL)
		return NULL;

	p->nMax = nMax;
	p->nCur = 0;
	p->pNext = pHead;
	pHead = p;  // change head (adds in reverse order for simplicity)
	return p;
}

#pragma SEG(CPlex_FreeDataChain)  
void CPlex::FreeDataChain()     // free this one and links
{
	VDATEHEAP();

    CPlex FAR* pThis;
    CPlex FAR* pNext;

    for (pThis = this; pThis != NULL; pThis = pNext) {
        pNext = pThis->pNext;
        pThis->pNext = NULL; // So compiler won't do nasty optimizations
		PrivMemFree(pThis);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\stdimpl\srvhndlr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       srvhndlr.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:     9-18-95    JohannP     Created
//              10-30-96    rogerg      Changed to New Embed ServerHandler Model.                            
//
//----------------------------------------------------------------------------



#include <le2int.h>

#include <ole2int.h>
#include <stdid.hxx>        // CStdIdentity
#include <marshal.hxx>      // CStdMarshal
#include <idtable.hxx>      // Indentity Table
#include <ipidtbl.hxx>      // IpidTable.
#include "xmit.hxx"

#include "srvhndlr.h"
#include "clthndlr.h"
#include "defhndlr.h"

extern HRESULT UnMarshalHelper(MInterfacePointer *pIFP, REFIID riid, void **ppv);
extern INTERNAL_(BOOL) ChkIfLocalOID(OBJREF &objref, CStdIdentity **ppStdId);

// TODO: All Marshaling and set up for Run, DoVerb, SetClientSite should be moved
//       Into the EmbHelper so all DefHndlr has to do is call the Function as normal.

//+---------------------------------------------------------------------------
//
//  Method:     CreateEmbeddingServerHandler
//
//  Synopsis: Creates a New Instance of the Embedded Server Handler.
//
//  Arguments:  
//              pStdId - Pointer to StandardIdentity for Object
//              ppunkESHandler - PlaceHolder to Return the New serverHandler.
//
//  Returns:    HRESULT
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT CreateEmbeddingServerHandler(CStdIdentity *pStdId,IUnknown **ppunkESHandler)
{
    *ppunkESHandler = new CServerHandler(pStdId); 

    return *ppunkESHandler ? NOERROR : E_FAIL; 
}


//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::CServerHandler
//
//  Synopsis:   Constructor
//
//  Arguments:  
//              pStdId - Pointer to StandardIdentity for Object
//
//  Returns:    
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CServerHandler::CServerHandler(CStdIdentity *pStdid)
{
    _cRefs = 1;         // this is the first addref for the serverhandler interface
    m_pStdId = pStdid;

    if (m_pStdId)
        m_pStdId->AddRef();

    m_pOleEmbServerClientSite = NULL;
    m_pCEmbServerClientSite = NULL;

    return;
}

//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::~CServerHandler
//
//  Synopsis:   Destructor
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CServerHandler::~CServerHandler()
{
    Win4Assert(NULL == m_pStdId);
    Win4Assert(NULL == m_pOleEmbServerClientSite);
    Win4Assert(NULL == m_pCEmbServerClientSite); 
}


//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppv] --
//
//  Returns:
//
//  History:    9-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CServerHandler::QueryInterface( REFIID riid, void **ppv )
{
    HRESULT     hresult = NOERROR;
    VDATEHEAP();

    LEDebugOut((DEB_TRACE,
        "%p _IN CServerHandler::QueryInterface "
        "( %p , %p )\n", this, riid, ppv));

    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IServerHandler) )
    {
        *ppv = (void FAR *)this;
        AddRef();
    }
    else
    {
        hresult = E_NOINTERFACE;
        *ppv = NULL;
    }


    LEDebugOut((DEB_TRACE, "%p OUT CServerHandler::QueryInterface ( %lx ) "
        "[ %p ]\n", this, hresult, *ppv));

    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::AddRef
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    9-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CServerHandler::AddRef( void )
{
    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CServerHandler::AddRef ( )\n", this));

    InterlockedIncrement((long *)&_cRefs);

    LEDebugOut((DEB_TRACE, "%p OUT CServerHandler::AddRef ( %ld ) ", this,
        _cRefs));

    return _cRefs;
}

//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::Release
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    9-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CServerHandler::Release( void )
{
ULONG   cRefs;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CServerHandler::Release ( )\n", this));

    if (0 == (cRefs = InterlockedDecrement( (long*) &_cRefs)) )
    {
        ReleaseObject(); 
        delete this;
        return 0;
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::Release ( %ld ) ", this,
        cRefs));

    return cRefs;
}


//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::ReleaseObject
//
//  Synopsis:   Releases any references on StdIdentity or Real Object.
//
//  Arguments:  (none)
//              
//
//  Returns:    
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP_(void) CServerHandler::ReleaseObject()
{
LPUNKNOWN lpUnkForSafeRelease;

    LEDebugOut((DEB_TRACE, "%p _IN CServerHandler::ReleaseObject ( )\n", this));

    if (m_pOleEmbServerClientSite)
    {
        lpUnkForSafeRelease = (LPUNKNOWN) m_pOleEmbServerClientSite;
        m_pOleEmbServerClientSite = NULL;
        lpUnkForSafeRelease->Release();
    }
    
    if (m_pCEmbServerClientSite)
    {
    CEmbServerClientSite *pEmbServerClientSite = m_pCEmbServerClientSite;

        m_pCEmbServerClientSite = NULL;
        pEmbServerClientSite->Release();
    }

    if (m_pStdId)
    {
    CStdIdentity* pUnkObj = m_pStdId;

        m_pStdId = NULL;
        pUnkObj->Release();
    }

    LEDebugOut((DEB_TRACE, "%p _Out CServerHandler::ReleaseObject ( )\n", this));
}


//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::QueryServerInterface
//
//  Synopsis:   Gets Requested Interface from the Server.
//
//  Arguments:  
//              
//
//  Returns:    
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------

INTERNAL  CServerHandler::QueryServerInterface(REFIID riid,void ** ppInterface)           
{                       
IPIDEntry *pIPIDEntry;
HRESULT hrDisconnect;
HRESULT hr = E_NOINTERFACE;

// TODO: Other option is for Stdid to hold onto EmbServerHandler and then has the Stdid
//    Call ReleaseObject, Release on the EmbServerHandler in its when the real server object
//    is being released or Disconnected. This option should be tried and if it works would 
//    be preferred.

    if (m_pStdId)
    {
        LOCK(gComLock);

        m_pStdId->LockServer();
    
        if (SUCCEEDED(hr = m_pStdId->FindIPIDEntry(riid,&pIPIDEntry)) )
        {
            UNLOCK(gComLock);
        }
        else
        {
            hrDisconnect = m_pStdId->PreventDisconnect();
            if (SUCCEEDED(hrDisconnect))
            {
                hr = m_pStdId->MarshalIPID(riid,1 /*cRefs */,MSHLFLAGS_NORMAL, &pIPIDEntry);

                if (SUCCEEDED(hr))
                {
                    m_pStdId->DecSrvIPIDCnt(pIPIDEntry,1, 0, NULL, MSHLFLAGS_NORMAL); // release Marshaled Ipid.
                }

            }

            UNLOCK(gComLock);
            m_pStdId->HandlePendingDisconnect(hrDisconnect);
        }
    

        if ( FAILED(hr) || (IPIDF_DISCONNECTED & pIPIDEntry->dwFlags) )
        {
            m_pStdId->UnLockServer();
            hr = (NOERROR == hr) ? RPC_E_DISCONNECTED : E_NOINTERFACE;
            *ppInterface  = NULL;
        }
        else
        {
            *ppInterface = pIPIDEntry->pv;
        }
    }
   
    ASSERT_LOCK_NOT_HELD(gComLock);

    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::ReleaseServerInterface
//
//  Synopsis:   Releases Lock in Interface obtained from QueryServerInterface
//
//  Arguments:  
//              
//
//  Returns:    
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------

INTERNAL  CServerHandler::ReleaseServerInterface(void * pInterface)
{

    if (m_pStdId)
    {
        m_pStdId->UnLockServer();
    }

    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::Run
//
//  Synopsis:   Server Handler side of invoked when ::Run is Called.
//
//  Arguments:  
//              
//
//  Returns:   
//
//  Comments:   To be as identical to the ::Run in the Defhndlr as possible 
//              ::Run ignores errors if it fails to get the Interfaces and also
//              any error value that is returned from ::SetClientSite. 
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CServerHandler::Run(DWORD dwDHFlags,
                                    REFIID riidClientInterface,
                                    MInterfacePointer* pIRDClientInterface,
                                    BOOL fHasIPSite,
                                    LPOLESTR szContainerApp,
                                    LPOLESTR szContainerObj,
                                    IStorage *  pStg,
                                    IAdviseSink* pAdvSink,
                                    DWORD *pdwConnection,
                                    HRESULT *hresultClsidUser,
                                    CLSID *pContClassID,
                                    HRESULT *hresultContentMiscStatus,
                                    DWORD *pdwMiscStatus)

{
IPersistStorage *pIStorage = NULL;
IOleObject *pIOleObject = NULL;
HRESULT hresult = NOERROR;

    LEDebugOut((DEB_TRACE, "%p _IN CServerHandler::Run\n", this));

    *pdwConnection = 0; // make sure dwConnection is 0 on an error.

    QueryServerInterface(IID_IOleObject,(void **) &pIOleObject);

    if (pStg && (NOERROR == QueryServerInterface(IID_IPersistStorage,(void **) &pIStorage)) )
    {
        Win4Assert(pIStorage);

        if (DH_INIT_NEW & dwDHFlags)
        {
            hresult = pIStorage->InitNew(pStg);
        }
        else
        {
            hresult = pIStorage->Load(pStg);
        }
    }

    Win4Assert(NULL == m_pOleEmbServerClientSite);
    if ( (NOERROR == hresult) && pIRDClientInterface && pIOleObject)
    {
        hresult = GetClientSiteFromMInterfacePtr(riidClientInterface,pIRDClientInterface,fHasIPSite,&m_pOleEmbServerClientSite);
        
        if (SUCCEEDED(hresult))
        {
            hresult = pIOleObject->SetClientSite(m_pOleEmbServerClientSite);
        }

       hresult = NOERROR; // !!! don't fail on SetClientSite Failure.
    }

    if ((NOERROR == hresult) && (NULL != szContainerApp) && pIOleObject)
    {
        hresult = pIOleObject->SetHostNames(szContainerApp,szContainerObj);
    }

    if ( (NOERROR == hresult) && pAdvSink && pIOleObject )
    {
        hresult = pIOleObject->Advise(pAdvSink,pdwConnection);
    }

    if ( (NOERROR == hresult) && pIOleObject )
    {
        *hresultClsidUser = pIOleObject->GetUserClassID(pContClassID);
        *hresultContentMiscStatus = pIOleObject->GetMiscStatus(DVASPECT_CONTENT,pdwMiscStatus);
    }

    // m_pOleEmbServerClientSite gets set by SetClientSite called above.
    if ( (NOERROR == hresult) && (m_pOleEmbServerClientSite) && pIOleObject)
    {
    LPMONIKER pmk = NULL;

        if( m_pOleEmbServerClientSite->GetMoniker
                    (OLEGETMONIKER_ONLYIFTHERE,
                    OLEWHICHMK_OBJREL, &pmk) == NOERROR)
        {
            AssertOutPtrIface(NOERROR, pmk);

            // SetMoniker Failure doesn't result in a ::Run Failure
            pIOleObject->SetMoniker(OLEWHICHMK_OBJREL, pmk);

            pmk->Release();
        }
    }

    if (pIStorage)
        ReleaseServerInterface((void *) pIStorage);

    if (pIOleObject)
        ReleaseServerInterface((void *) pIOleObject);

   LEDebugOut((DEB_TRACE, "%p OUT CServerHandler::Run "
        "( %lx )\n", this, hresult));

    return hresult;
}


//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::DoVerb
//
//  Synopsis:   Server Handler side of invoked when ::DoVerb is Called.
//
//  Arguments:  
//              
//
//  Returns:    
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CServerHandler::DoVerb (LONG iVerb, LPMSG lpmsg,BOOL fUseRunClientSite, IOleClientSite* pIOleClientSite, 
                                     LONG lindex,HWND hwndParent,LPCRECT lprcPosRect)
{
IOleObject *pIOleObject = NULL;
IOleClientSite *pDoVerbClientSite = NULL;
HRESULT hr = NOERROR;

    LEDebugOut((DEB_TRACE, "%p _IN CServerHandler::DoVerb "
        "( %ld , %p , %p , %ld , %lx , %p )\n", this,
        iVerb, lpmsg, pIOleClientSite, lindex, hwndParent, lprcPosRect));

    if (NOERROR == (hr = QueryServerInterface(IID_IOleObject,(void **) &pIOleObject))  )
    {
        Win4Assert(pIOleObject);

        if (fUseRunClientSite)
        {

            pDoVerbClientSite = m_pOleEmbServerClientSite;
            
            // inform client site of operation what interfaces to support
            // Todo: Send in Prefetched info for DoVerb here.
        if (m_pCEmbServerClientSite)
        {
                m_pCEmbServerClientSite->SetDoVerbState(TRUE);
        }

            // put addref on Clientsite so liveness is the same as if marshaled by DoVerb
            // TODO: This isn't really necessayr since Handler also holds a ref.
            if (m_pOleEmbServerClientSite)
            {
                m_pOleEmbServerClientSite->AddRef();
            }
            
        }
        else
        {
            pDoVerbClientSite = pIOleClientSite;

        }

        hr = pIOleObject->DoVerb(iVerb,lpmsg,pDoVerbClientSite,lindex,hwndParent,lprcPosRect);
        
    if (fUseRunClientSite)
    {
            if (m_pCEmbServerClientSite)
            {
                m_pCEmbServerClientSite->SetDoVerbState(FALSE);
            }

            if (m_pOleEmbServerClientSite)
            {
                m_pOleEmbServerClientSite->Release();
            }

    }

    }

   if (pIOleObject)
        ReleaseServerInterface((void *) pIOleObject);


    LEDebugOut((DEB_TRACE, "%p OUT CServerHandler::Run "
        "( %lx )\n", this, hr));

    return hr;
}

// helper function for creating ClientSite Handler
INTERNAL CServerHandler::GetClientSiteFromMInterfacePtr(REFIID riidClientInterface, 
                                 MInterfacePointer* pIRDClientSite, BOOL fHasIPSite, LPOLECLIENTSITE* ppOleClientSite)
{
HRESULT hr = E_UNEXPECTED;

    *ppOleClientSite = NULL;

    Win4Assert(NULL != pIRDClientSite);

    if (pIRDClientSite)
    {
    CXmitRpcStream Stm( (InterfaceData *) pIRDClientSite);
     
        if (IsEqualIID(IID_IClientSiteHandler,riidClientInterface))
        {
        OBJREF  objref;
        CEmbServerClientSite *pCEmbServerClientSite;

           // If there is a ClientSide Handler, set up server side.
            if (SUCCEEDED(hr = ReadObjRef(&Stm, objref)))
            {

                Win4Assert(IsEqualIID(objref.iid, IID_IClientSiteHandler));

                pCEmbServerClientSite = new CEmbServerClientSite(NULL);
            
                if (pCEmbServerClientSite)
                {
                    if (NOERROR == (hr = pCEmbServerClientSite->Initialize(objref,fHasIPSite)))
                    {
                        m_pCEmbServerClientSite = pCEmbServerClientSite; // set up member variable.
      
                        // TODO: should be a QI for the ClientSite.
                        *ppOleClientSite = (LPOLECLIENTSITE) pCEmbServerClientSite;
                        (*ppOleClientSite)->AddRef();
                    }
                    else
                    {
                        pCEmbServerClientSite->Release();
                    }
                
                }

               FreeObjRef(objref);
            }

        }
        else
        {
            m_pCEmbServerClientSite = NULL; // make sure EmbClientSite member var is NULL.

            // Didn't wrap ClientSite with ClientSiteHandler, just UnMarshal and hand back.
            hr = CoUnmarshalInterface(&Stm,IID_IOleClientSite, (void **) ppOleClientSite);

            if (FAILED(hr))
            {
                *ppOleClientSite = NULL;
            }
        }
    }


    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CServerHandler::SetClientSite
//
//  Synopsis:   Sets the client site for the object
//
//  Effects:
//
//  Arguments:  [pClientSite]   -- pointer to the client site
//
//  Requires:
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------

STDMETHODIMP CServerHandler::SetClientSite(IOleClientSite* pOleClientSite)
{
HRESULT hresult = NOERROR;
IOleObject *pIOleObject = NULL;

    if (NOERROR == (hresult = QueryServerInterface(IID_IOleObject,(void **) &pIOleObject)) )
    {
        if (NOERROR == hresult)
        {
            hresult = pIOleObject->SetClientSite(pOleClientSite);
        }
    }

    if (pIOleObject)
        ReleaseServerInterface(pIOleObject);

    return hresult;
}


//+---------------------------------------------------------------------------
//
//  Function:  Delagatory IDataObject impl facing container
//
//  Synopsis:
//
//  Arguments: 
//
//  Returns:
//
//  History:    11-17-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//+---------------------------------------------------------------------------

STDMETHODIMP CServerHandler::GetData(FORMATETC *pformatetcIn,STGMEDIUM *pmedium)
{
LPDATAOBJECT pDataObject = NULL;
HRESULT hr;

   if (NOERROR == (hr = QueryServerInterface(IID_IDataObject,(void **) &pDataObject)) )
   {
        hr = pDataObject->GetData(pformatetcIn,pmedium);
        ReleaseServerInterface(pDataObject);
   }

  return hr;
}

STDMETHODIMP CServerHandler::GetDataHere(FORMATETC *pformatetc,STGMEDIUM *pmedium)
{
LPDATAOBJECT pDataObject = NULL;
HRESULT hr;

   if (NOERROR == (hr = QueryServerInterface(IID_IDataObject,(void **) &pDataObject)) )
   {
        hr = pDataObject->GetDataHere(pformatetc,pmedium);
        ReleaseServerInterface(pDataObject);
   }

  return hr;
}

STDMETHODIMP CServerHandler::QueryGetData(FORMATETC *pformatetc)
{
LPDATAOBJECT pDataObject = NULL;
HRESULT hr;

   if (NOERROR == (hr = QueryServerInterface(IID_IDataObject,(void **) &pDataObject)) )
   {
        hr = pDataObject->QueryGetData(pformatetc);
        ReleaseServerInterface(pDataObject);
   }

  return hr;
}

STDMETHODIMP CServerHandler::GetCanonicalFormatEtc(FORMATETC *pformatetcIn,FORMATETC *pformatetcOut)
{
LPDATAOBJECT pDataObject = NULL;
HRESULT hr;

   if (NOERROR == (hr = QueryServerInterface(IID_IDataObject,(void **) &pDataObject)) )
   {
        hr = pDataObject->GetCanonicalFormatEtc(pformatetcIn,pformatetcOut);
        ReleaseServerInterface(pDataObject);
   }

  return hr;
}

STDMETHODIMP CServerHandler::SetData(FORMATETC *pformatetc,STGMEDIUM *pmedium,BOOL fRelease)
{
LPDATAOBJECT pDataObject = NULL;
HRESULT hr;

   if (NOERROR == (hr = QueryServerInterface(IID_IDataObject,(void **) &pDataObject)) )
   {
        hr = pDataObject->SetData(pformatetc,pmedium,fRelease);
        ReleaseServerInterface(pDataObject);
   }

  return hr;
}

STDMETHODIMP CServerHandler::EnumFormatEtc(DWORD dwDirection,IEnumFORMATETC **ppenumFormatEtc)
{
LPDATAOBJECT pDataObject = NULL;
HRESULT hr;

   if (NOERROR == (hr = QueryServerInterface(IID_IDataObject,(void **) &pDataObject)) )
   {
        hr = pDataObject->EnumFormatEtc(dwDirection,ppenumFormatEtc);
        ReleaseServerInterface(pDataObject);
   }

  return hr;
}

STDMETHODIMP CServerHandler::DAdvise(FORMATETC *pformatetc,DWORD advf, IAdviseSink *pAdvSink,
                    DWORD *pdwConnection)
{
LPDATAOBJECT pDataObject = NULL;
HRESULT hr;

   if (NOERROR == (hr = QueryServerInterface(IID_IDataObject,(void **) &pDataObject)) )
   {
        hr = pDataObject->DAdvise(pformatetc,
                            advf, (IAdviseSink *)
                            pAdvSink,pdwConnection);
        ReleaseServerInterface(pDataObject);
   }

  return hr;
}

STDMETHODIMP CServerHandler::DUnadvise(DWORD dwConnection)
{
LPDATAOBJECT pDataObject = NULL;
HRESULT hr;

   if (NOERROR == (hr = QueryServerInterface(IID_IDataObject,(void **) &pDataObject)) )
   {
        hr = pDataObject->DUnadvise(dwConnection);
        ReleaseServerInterface(pDataObject);
   }

  return hr;
}

STDMETHODIMP CServerHandler::EnumDAdvise(IEnumSTATDATA **ppenumAdvise)
{
LPDATAOBJECT pDataObject = NULL;
HRESULT hr;

   if (NOERROR == (hr = QueryServerInterface(IID_IDataObject,(void **) &pDataObject)) )
   {
        hr = pDataObject->EnumDAdvise(ppenumAdvise);
        ReleaseServerInterface(pDataObject);
   }

  return hr;
}



//////////////////////

// rogerg, wrapper object for ServerHandler on the ClientSide.

//////////////////////

// CEmbServerWrapper implementation for Server Handler.

CEmbServerWrapper* CreateEmbServerWrapper(IUnknown *pUnkOuter,IServerHandler *ServerHandler)
{
    return new CEmbServerWrapper(pUnkOuter,ServerHandler);
}



//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerWrapper::CEmbServerWrapper
//
//  Synopsis:   Constructor
//
//  Arguments:  
//              pStdId - Pointer to StandardIdentity for Object
//
//  Returns:    
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CEmbServerWrapper::CEmbServerWrapper (IUnknown *pUnkOuter,IServerHandler *pServerHandler)
{
    VDATEHEAP();

    Win4Assert(pServerHandler);

    if (!pUnkOuter)
    {
        pUnkOuter = &m_Unknown;
    }

    m_pUnkOuter  = pUnkOuter;
    m_Unknown.m_EmbServerWrapper = this;

    if(pServerHandler)
    {
        m_ServerHandler = pServerHandler;
        m_ServerHandler->AddRef();
    }

    m_cRefs = 1;

}



//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::~CServerHandler
//
//  Synopsis:   Destructor
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CEmbServerWrapper::~CEmbServerWrapper()
{
    Win4Assert(NULL == m_ServerHandler);
}


//+-------------------------------------------------------------------------
//
//  Member:     CEmbServerWrapper::CPrivUnknown::QueryInterface
//
//  Synopsis:   Returns a pointer to one of the supported interfaces.
//
//  Effects:
//
//  Arguments:  [iid]           -- the requested interface ID
//              [ppv]           -- where to put the iface pointer
//
//  Requires:
//
//  Returns:    HRESULT
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CEmbServerWrapper::CPrivUnknown::QueryInterface(REFIID iid,
    LPLPVOID ppv)
{
HRESULT         hresult;

    VDATEHEAP();

    Win4Assert(m_EmbServerWrapper);

    LEDebugOut((DEB_TRACE,
        "%p _IN CDefObject::CUnknownImpl::QueryInterface "
        "( %p , %p )\n", m_EmbServerWrapper, iid, ppv));

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (void FAR *)this;
    }
    else if (IsEqualIID(iid, IID_IDataObject))
    {
        *ppv = (void FAR *)(IDataObject *) m_EmbServerWrapper;
    }
    else if(m_EmbServerWrapper->m_ServerHandler)
    {

        Win4Assert(0 && "QI for non-Wrapped interface");

        hresult = m_EmbServerWrapper->m_ServerHandler->QueryInterface(iid,(void **) ppv);


        LEDebugOut((DEB_TRACE,
            "%p OUT CDefObject::CUnknownImpl::QueryInterface "
            "( %lx ) [ %p ]\n", m_EmbServerWrapper, hresult,
            (ppv) ? *ppv : 0 ));

        return hresult;
    }
    else
    {
        // Don't have a ServerHandler.
        *ppv = NULL;

        LEDebugOut((DEB_TRACE,
            "%p OUT CDefObject::CUnkownImpl::QueryInterface "
            "( %lx ) [ %p ]\n", m_EmbServerWrapper, CO_E_OBJNOTCONNECTED,
            0 ));

        return E_NOINTERFACE;
    }

    // this indirection is important since there are different
    // implementationsof AddRef (this unk and the others).
    ((IUnknown FAR*) *ppv)->AddRef();

    LEDebugOut((DEB_TRACE,
        "%p OUT CDefObject::CUnknownImpl::QueryInterface "
        "( %lx ) [ %p ]\n", m_EmbServerWrapper, NOERROR, *ppv));

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEmbServerWrapper::CPrivUnknown::AddRef
//
//  Synopsis:   Increments the reference count.
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG (the new reference count)
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IUnkown
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              03-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEmbServerWrapper::CPrivUnknown::AddRef( void )
{
ULONG cRefs;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::CPrivUnknown::AddRef "
        "( )\n", m_EmbServerWrapper));

    Win4Assert(m_EmbServerWrapper->m_cRefs != 0);
    Win4Assert(m_EmbServerWrapper);

    // we need to keep track of the hander's reference count separately
    // from the handler/advise sink combination in order to handle
    // our running/stopped state transitions.

    cRefs = InterlockedIncrement((long *) &(m_EmbServerWrapper->m_cRefs)); 

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::CPrivUnknown::AddRef "
        "( %lu )\n", m_EmbServerWrapper, m_EmbServerWrapper->m_cRefs));

    return cRefs;

}

//+-------------------------------------------------------------------------
//
//  Member:     CEmbServerWrapper::CPrivUnknown::Release
//
//  Synopsis:   Decrements the ref count, cleaning up and deleting the
//              object if necessary
//
//  Effects:    May delete the object (and potentially objects to which the
//              handler has pointer)
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG--the new ref count
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              03-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEmbServerWrapper::CPrivUnknown::Release( void )
{

    VDATEHEAP();

    ULONG           refcount;

    Win4Assert(m_EmbServerWrapper);


    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::CPrivUnknown::Release "
        "( )\n", m_EmbServerWrapper));

    refcount = InterlockedDecrement((long *) &(m_EmbServerWrapper->m_cRefs));

    if (0 == refcount)
    {
        if (m_EmbServerWrapper->m_ServerHandler)
        {
        IServerHandler *pServerHandler = m_EmbServerWrapper->m_ServerHandler;

            m_EmbServerWrapper->m_ServerHandler = NULL; 
            pServerHandler->Release();
        }

        delete m_EmbServerWrapper;
        
    }

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::CPrivUnknown::Release "
        "( %lu )\n", m_EmbServerWrapper, refcount));

    return refcount;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerWrapper::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppv] --
//
//  Returns:
//
//  History:    9-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP  CEmbServerWrapper::QueryInterface( REFIID riid, void **ppv )                                                        
{                                                                                                                                        
    HRESULT     hresult;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::QueryInterface ( %lx , "
        "%p )\n", this, riid, ppv));

    Assert(m_pUnkOuter);

    hresult = m_pUnkOuter->QueryInterface(riid, ppv);

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::QueryInterface ( %lx ) "
        "[ %p ]\n", this, hresult, *ppv));

    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerWrapper::AddRef
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    9-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
                                                                                                                                                                                                                                                                                
STDMETHODIMP_(ULONG) CEmbServerWrapper::AddRef( void )                                                                           
{                                                                                                                                         
    ULONG       crefs;;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::AddRef ( )\n", this));

    Assert(m_pUnkOuter);

    crefs = m_pUnkOuter->AddRef();

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::AddRef ( %ld ) ", this,
        crefs));

    return crefs;
}  

//+---------------------------------------------------------------------------
//
//  Method:     CEmbServerClientSite::Release
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    9-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
                                                                                                                                       
STDMETHODIMP_(ULONG) CEmbServerWrapper::Release( void )                                                                          
{                                                                                                                                         
    ULONG       crefs;;

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN CDefObject::Release ( )\n", this));

    Assert(m_pUnkOuter);

    crefs = m_pUnkOuter->Release();

    LEDebugOut((DEB_TRACE, "%p OUT CDefObject::Release ( %ld ) ", this,
        crefs));

    return crefs;
}

// IServerHandler Implementation
//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::Run
//
//  Synopsis:   Server Handler side of invoked when ::Run is Called.
//
//  Arguments:  
//              
//
//  Returns:    
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CEmbServerWrapper::Run(DWORD dwDHFlags,
                                    REFIID riidClientInterface,
                                    MInterfacePointer* pIRDClientInterface,
                                    BOOL fHasIPSite,
                                    LPOLESTR szContainerApp,
                                    LPOLESTR szContainerObj,
                                    IStorage *  pStg,
                                    IAdviseSink* pAdvSink,
                                    DWORD *pdwConnection,
                                    HRESULT *hresultClsidUser,
                                    CLSID *pContClassID,
                                    HRESULT *hresultContentMiscStatus,
                                    DWORD *pdwMiscStatus)

{
HRESULT hresult = RPC_E_DISCONNECTED;

    Win4Assert(m_ServerHandler);

    if (m_ServerHandler)
    {
        hresult =  m_ServerHandler->Run(dwDHFlags,riidClientInterface,pIRDClientInterface, fHasIPSite, szContainerApp,
                                szContainerObj,pStg,pAdvSink,pdwConnection,
                                hresultClsidUser,pContClassID,hresultContentMiscStatus,
                                pdwMiscStatus);
    }

    return hresult;
}


//+---------------------------------------------------------------------------
//
//  Method:     CServerHandler::DoVerb
//
//  Synopsis:   Server Handler side of invoked when ::DoVerb is Called.
//
//  Arguments:  
//              
//
//  Returns:    
//
//  History:    10-30-96   rogerg       Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CEmbServerWrapper::DoVerb (LONG iVerb, LPMSG lpmsg,BOOL fUseRunClientSite, 
                            IOleClientSite* pIRDClientSite,LONG lindex,HWND hwndParent,
                            LPCRECT lprcPosRect)
{
HRESULT hresult = RPC_E_DISCONNECTED;

    Win4Assert(m_ServerHandler);

    if (m_ServerHandler)
    {
        hresult =   m_ServerHandler->DoVerb(iVerb,lpmsg,fUseRunClientSite,pIRDClientSite,
                    lindex,hwndParent,lprcPosRect);
    }

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CServerHandler::SetClientSite
//
//  Synopsis:   Sets the client site for the object
//
//  Effects:
//
//  Arguments:  [pClientSite]   -- pointer to the client site
//
//  Requires:
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------

STDMETHODIMP CEmbServerWrapper::SetClientSite(IOleClientSite* pOleClientSite)
{
HRESULT hresult = RPC_E_DISCONNECTED;

   Win4Assert(m_ServerHandler);

    if (m_ServerHandler)
    {
        hresult =   m_ServerHandler->SetClientSite(pOleClientSite);
    }

    return hresult;
}


// IDataObject implementation.

STDMETHODIMP CEmbServerWrapper::GetData(FORMATETC *pformatetcIn,STGMEDIUM *pmedium)
{
HRESULT hresult = RPC_E_DISCONNECTED;

    Win4Assert(m_ServerHandler);

    if (m_ServerHandler)
    {
        hresult =   m_ServerHandler->GetData(pformatetcIn,pmedium);
    }

    return hresult;
}

STDMETHODIMP CEmbServerWrapper::GetDataHere(FORMATETC *pformatetc,STGMEDIUM *pmedium)
{
HRESULT hresult = RPC_E_DISCONNECTED;

    Win4Assert(m_ServerHandler);
    
    if (m_ServerHandler)
    {
        hresult =  m_ServerHandler->GetDataHere(pformatetc,pmedium);
    }

    return hresult;
}

STDMETHODIMP CEmbServerWrapper::QueryGetData(FORMATETC *pformatetc)
{
HRESULT hresult = RPC_E_DISCONNECTED;

    Win4Assert(m_ServerHandler);
    
    if (m_ServerHandler)
    {
        hresult =  m_ServerHandler->QueryGetData(pformatetc);
    }
    
    return hresult;
}

STDMETHODIMP CEmbServerWrapper::GetCanonicalFormatEtc(FORMATETC *pformatetcIn,FORMATETC *pformatetcOut)
{
HRESULT hresult = RPC_E_DISCONNECTED;

    Win4Assert(m_ServerHandler);
    return m_ServerHandler->GetCanonicalFormatEtc(pformatetcIn,pformatetcOut);
}

STDMETHODIMP CEmbServerWrapper::SetData(FORMATETC *pformatetc,STGMEDIUM *pmedium,BOOL fRelease)
{
HRESULT hresult = RPC_E_DISCONNECTED;

    Win4Assert(m_ServerHandler);
    
    if (m_ServerHandler)
    {
        hresult =  m_ServerHandler->SetData(pformatetc,pmedium,fRelease);
    }

    return hresult;
}

STDMETHODIMP CEmbServerWrapper::EnumFormatEtc(DWORD dwDirection,IEnumFORMATETC **ppenumFormatEtc)
{
HRESULT hresult = RPC_E_DISCONNECTED;

    Win4Assert(m_ServerHandler);
    
    if (m_ServerHandler)
    {
        hresult =  m_ServerHandler->EnumFormatEtc(dwDirection,ppenumFormatEtc);
    }

    return hresult;
}

STDMETHODIMP CEmbServerWrapper::DAdvise(FORMATETC *pformatetc,DWORD advf, 
                                     IAdviseSink *pAdvSink,DWORD *pdwConnection)
{
HRESULT hresult = RPC_E_DISCONNECTED;

    Win4Assert(m_ServerHandler);
    
    if (m_ServerHandler)
    {
        hresult =  m_ServerHandler->DAdvise(pformatetc,
                            advf, (IAdviseSink *)
                            pAdvSink,pdwConnection);
    }

    return hresult;
}

STDMETHODIMP CEmbServerWrapper::DUnadvise(DWORD dwConnection)
{
HRESULT hresult = RPC_E_DISCONNECTED;

    Win4Assert(m_ServerHandler);

    if (m_ServerHandler)
    {
        hresult =   m_ServerHandler->DUnadvise(dwConnection);
    }

    return hresult;
}

STDMETHODIMP CEmbServerWrapper::EnumDAdvise(IEnumSTATDATA **ppenumAdvise)
{
HRESULT hresult = RPC_E_DISCONNECTED;

    Win4Assert(m_ServerHandler);
    
    if (m_ServerHandler)
    {
        hresult =  m_ServerHandler->EnumDAdvise(ppenumAdvise);
    }

    return hresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\util\ole2util.cpp ===
//+----------------------------------------------------------------------------
//
//      File:
//              ole2util.cpp
//
//      Contents:
//              Ole internal utility routines
//
//      Classes:
//
//      Functions:
//
//      History:
//              06/01/94 - AlexGo  - UtQueryPictFormat now supports
//                      enhanced metafiles
//              03/18/94 - AlexGo  - fixed UtGetPresStreamName (incorrect
//                      string processing)
//              01/11/94 - ChrisWe - don't reference unlocked handle in
//                      UtConvertBitmapToDib
//              01/11/94 - alexgo  - added VDATEHEAP macro to every function
//              12/07/93 - ChrisWe - removed incorrect uses of (LPOLESTR);
//                      removed duplicate GetClassFromDataObj function, which
//                      is the same as UtGetClassID
//              11/30/93 - ChrisWe - continue file cleanup; don't open
//                      streams in UtRemoveExtraOlePresStreams()
//              11/28/93 - ChrisWe - file cleanup and inspection;
//                      reformatted many functions
//              11/22/93 - ChrisWe - replace overloaded ==, != with
//                      IsEqualIID and IsEqualCLSID
//              06/28/93 - SriniK - added UtGetDibExtents
//              11/16/92 - JasonFul - created; moved contents here from util.cpp
//
//-----------------------------------------------------------------------------

#include <le2int.h>
#pragma SEG(ole2util)

NAME_SEG(Ole2Utils)
ASSERTDATA

#define WIDTHBYTES(i)   ((i+31)/32*4)

#define PALETTESIZE     256    /* Number of entries in the system palette     */

// REVIEW, according to the spec, IDataObject::EnumFormatEtc() is only
// required to service one dwDirection DATADIR_ value at a time.  This
// function has been asking it to do more than one at a time, and expecting
// return of FORMATETCs that match all the requested directions.  Code
// seen in OleRegEnumFormatEtc() checks on creation, and fails if any
// value other than plain DATADIR_GET or plain DATADIR_SET is specified
// so this has clearly never worked for OLE1, or registration database lookups
// since the only caller of UtIsFormatSupported has always asked for both
// at the same time.
#pragma SEG(UtIsFormatSupported)
FARINTERNAL_(BOOL) UtIsFormatSupported(IDataObject FAR* lpDataObj,
		DWORD dwDirection, CLIPFORMAT cfFormat)
{
	VDATEHEAP();

	FORMATETC formatetc; // a place to fetch formats from the enumerator
	IEnumFORMATETC FAR* penm; // enumerates the formats of [lpDataObj]
	ULONG ulNumFetched; // a count of the number of formats fetched
	HRESULT error; // the error state so far

	// try to get the enumerator from the data object
	error = lpDataObj->EnumFormatEtc(dwDirection, &penm);

	if (error != NOERROR)
	{                       
		if (FAILED(error))
			return FALSE;
		else
		{
			CLSID clsid;

			// Use reg db; this case is primarily for the OLE1
			// compatibility code since it may talk to a data
			// object from a server in the same process as
			// the server.
			if (UtGetClassID(lpDataObj, &clsid) != TRUE)
				return(FALSE);

			// synthesize an enumerator
			// REVIEW, if the data object is synthesized for
			// the OLE1 object, why doesn't that implementation
			// go ahead and synthesize this?  Why does it have
			// to be done like this?  What if it's on the clipboard
			// and someone wants to use it?
			if (OleRegEnumFormatEtc(clsid, dwDirection, &penm)
					!= NOERROR)
				return FALSE;
			Assert(penm);
		}
	}

	// check for the format we're looking for
	while(NOERROR == (error = penm->Next(1, &formatetc, &ulNumFetched)))
	{
		if ((ulNumFetched == 1) && (formatetc.cfFormat == cfFormat))
			break;
	}
	
	// release the enumerator
	penm->Release();

	// if error isn't S_FALSE, we fetched an item, and broke out of the
	// while loop above --> the format was found.  Return TRUE indicating
	// that the format is supported
	return(error == NOERROR ? TRUE : FALSE);
}


#pragma SEG(UtDupPalette)
FARINTERNAL_(HPALETTE) UtDupPalette(HPALETTE hpalette)
{
	VDATEHEAP();

	WORD cEntries; // holds the number of entries in the palette
	HANDLE hLogPal; // ia a handle to a new logical palette
	LPLOGPALETTE pLogPal; // is a pointer to the new logical palette
	HPALETTE hpaletteNew = NULL; // the new palette we will return

	if (0 == GetObject(hpalette, sizeof(cEntries), &cEntries))
		return(NULL);

	if (NULL == (hLogPal = GlobalAlloc(GMEM_MOVEABLE,
			sizeof (LOGPALETTE) +
			cEntries * sizeof (PALETTEENTRY))))
		return(NULL);

	if (NULL == (pLogPal = (LPLOGPALETTE)GlobalLock(hLogPal)))
		goto errRtn;
		
	if (0 == GetPaletteEntries(hpalette, 0, cEntries,
			pLogPal->palPalEntry))
		goto errRtn;

	pLogPal->palVersion = 0x300;
	pLogPal->palNumEntries = cEntries;

	if (NULL == (hpaletteNew = CreatePalette(pLogPal)))
		goto errRtn;

errRtn:
	if (pLogPal)
		GlobalUnlock(hLogPal);

	if (hLogPal)
		GlobalFree(hLogPal);

	AssertSz(hpaletteNew, "Warning: UtDupPalette Failed");
	return(hpaletteNew);
}
	
//+-------------------------------------------------------------------------
//
//  Function:   UtFormatToTymed
//
//  Synopsis:   gets the right TYMED for the given rendering format
//
//  Effects:
//
//  Arguments:  [cf]    -- the clipboard format
//
//  Requires:
//
//  Returns:    one of the TYMED enumeration
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              07-Jul-94 alexgo    added EMF's
//              
//  Notes:      This should only be called for formats that we can
//              render
//
//--------------------------------------------------------------------------

#pragma SEG(UtFormatToTymed)
FARINTERNAL_(DWORD) UtFormatToTymed(CLIPFORMAT cf)
{
	VDATEHEAP();

	if( cf == CF_METAFILEPICT )
	{
		return TYMED_MFPICT;
	}
	else if( cf == CF_BITMAP )
	{
		return TYMED_GDI;
	}
	else if( cf == CF_DIB )
	{
		return TYMED_HGLOBAL;
	}
	else if( cf == CF_ENHMETAFILE )
	{
		return TYMED_ENHMF;
	}
	else if( cf == CF_PALETTE )
	{
		LEWARN(1,"Trying to render CF_PALETTE");
		return TYMED_GDI;
	}

	LEDebugOut((DEB_WARN, "WARNING: trying to render clipformat (%lx)\n",
		cf));

	return TYMED_HGLOBAL;
}

//+-------------------------------------------------------------------------
//
//  Function:   UtQueryPictFormat
//
//  Synopsis:   finds our "preferred" drawing formatetc from the given
//              data object
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]  -- the source data object
//              [lpforetc]      -- where to stuff the preferred format
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 alexgo    rewrite/now supports Enhanced Metafiles
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(UtQueryPictFormat)
FARINTERNAL_(BOOL) UtQueryPictFormat(LPDATAOBJECT lpSrcDataObj,
		LPFORMATETC lpforetc)
{
	FORMATETC foretctemp; // local copy of current values of format desc
	VDATEHEAP();

	LEDebugOut((DEB_ITRACE, "%p _IN UtQueryPictFormat ( %p , %p )\n",
		NULL, lpSrcDataObj, lpforetc));

	// copy format descriptor
	foretctemp = *lpforetc;

	// set values and query for our preferred formats in order of
	// preference

	
	foretctemp.cfFormat = CF_METAFILEPICT;
	foretctemp.tymed = TYMED_MFPICT;        
	if (lpSrcDataObj->QueryGetData(&foretctemp) == NOERROR)
	{
		goto QuerySuccess;
	}

	foretctemp.cfFormat = CF_ENHMETAFILE;
	foretctemp.tymed = TYMED_ENHMF;
	if( lpSrcDataObj->QueryGetData(&foretctemp) == NOERROR )
	{
		goto QuerySuccess;
	}
	foretctemp.cfFormat = CF_DIB;
	foretctemp.tymed = TYMED_HGLOBAL;       
	if (lpSrcDataObj->QueryGetData(&foretctemp) == NOERROR)
	{
		goto QuerySuccess;
	}
	
	foretctemp.cfFormat = CF_BITMAP;
	foretctemp.tymed = TYMED_GDI;   
	if (lpSrcDataObj->QueryGetData(&foretctemp) == NOERROR)
	{
		goto QuerySuccess;
	}

	LEDebugOut((DEB_ITRACE, "%p OUT UtQueryPictFormat ( %lu )\n",
		NULL, FALSE));

	return FALSE;

QuerySuccess:
	// data object supports this format; change passed in
	// format to match

	lpforetc->cfFormat = foretctemp.cfFormat;
	lpforetc->tymed = foretctemp.tymed;

	// return success

	LEDebugOut((DEB_ITRACE, "%p OUT UtQueryPictFormat ( %lu )\n",
		NULL, TRUE));

	return(TRUE);
}


#pragma SEG(UtConvertDibToBitmap)
FARINTERNAL_(HBITMAP) UtConvertDibToBitmap(HANDLE hDib)
{
	VDATEHEAP();

	LPBITMAPINFOHEADER lpbmih;
	HDC hdc; // the device context to create the bitmap for
	size_t uBitsOffset; // the offset to where the image begins in the DIB
	HBITMAP hBitmap; // the bitmap we'll return
	
	if (!(lpbmih = (LPBITMAPINFOHEADER)GlobalLock(hDib)))
		return(NULL);

	if (!(hdc = GetDC(NULL))) // Get screen DC.
	{
		// REVIEW: we may have to use the target device of this
		// cache node.
		return(NULL);
	}

	uBitsOffset =  sizeof(BITMAPINFOHEADER) +
			(lpbmih->biClrUsed ? lpbmih->biClrUsed :
			UtPaletteSize(lpbmih));
					
	hBitmap = CreateDIBitmap(hdc, lpbmih, CBM_INIT,
			((BYTE *)lpbmih)+uBitsOffset,
			(LPBITMAPINFO) lpbmih, DIB_RGB_COLORS);

	// release the DC
	ReleaseDC(NULL, hdc);

	return hBitmap;
}

//+----------------------------------------------------------------------------
//
//      Function:
//              UtConvertBitmapToDib, internal
//
//      Synopsis:
//              Creates a Device Independent Bitmap capturing the content of
//              the argument bitmap.
//
//      Arguments:
//              [hBitmap] -- Handle to the bitmap to convert
//              [hpal] -- color palette for the bitmap; may be null for
//                      default stock palette
//
//      Returns:
//              Handle to the DIB.  May be null if any part of the conversion
//              failed.
//
//      Notes:
//
//      History:
//              11/29/93 - ChrisWe - file inspection and cleanup
//              07/18/94 - DavePl  - fixed for 16, 32, bpp bitmaps
//
//-----------------------------------------------------------------------------

FARINTERNAL_(HANDLE) UtConvertBitmapToDib(HBITMAP hBitmap, HPALETTE hpal)
{
    VDATEHEAP();

    HDC hScreenDC;      
    BITMAP bm;                  // bitmap for hBitmap
    UINT uBits;                 // number of color bits for bitmap
    size_t uBmiSize;            // size of bitmap info for the DIB
    size_t biSizeImage;         // temp to hold value in the handle memory
    HANDLE hBmi;                // handle for the new DIB bitmap we'll create
    LPBITMAPINFOHEADER lpBmi;   // pointer to the actual data area for DIB
    HANDLE hDib = NULL;         // the DIB we'll return
    BOOL fSuccess = FALSE;
    DWORD dwCompression;
    BOOL fDeletePalette = FALSE;
    
    if (NULL == hBitmap)
    {
	return(NULL);
    }

    // if no palette provided, use the default

    if (NULL == hpal)
    {
	// This block fixes NTBUG #13029.  The problem is that on a palette
	// device (ie a 256 color video driver), we don't get passed the palette
	// that is used by the DDB.  So, we build the palette based on what
	// is currently selected into the system palette.

	// POSTPPC:
	//
	// We should change the clipboard code that calls this to ask for 
	// CF_PALETTE from the IDataObject that the DDB was obtained from, that
	// way we know we get the colors that the calling app really intended
	HDC hDCGlobal = GetDC(NULL);
	if(!hDCGlobal)
		return NULL;
	int iRasterCaps = GetDeviceCaps(hDCGlobal, RASTERCAPS);

	ReleaseDC(NULL, hDCGlobal);

	if ((iRasterCaps & RC_PALETTE))
	{
	    // Based the following code from the win sdk MYPAL example program.
	    // this creates a palette out of the currently active palette.
            HANDLE hLogPal = GlobalAlloc (GHND,
                                   (sizeof (LOGPALETTE) +
                                   (sizeof (PALETTEENTRY) * (PALETTESIZE))));

	    // if we are OOM, return failure now, because we aren't going
	    // to make it through the allocations later on.

	    if (!hLogPal)
	        return NULL;

	    LPLOGPALETTE pLogPal = (LPLOGPALETTE)GlobalLock (hLogPal);

	    // 0x300 is a magic number required by GDI
            pLogPal->palVersion    = 0x300;
            pLogPal->palNumEntries = PALETTESIZE;

            // fill in intensities for all palette entry colors 
            for (int iLoop = 0; iLoop < PALETTESIZE; iLoop++) 
            {
                *((WORD *) (&pLogPal->palPalEntry[iLoop].peRed)) = (WORD)iLoop;
                pLogPal->palPalEntry[iLoop].peBlue  = 0;
                pLogPal->palPalEntry[iLoop].peFlags = PC_EXPLICIT;
            }

            // create a logical color palette according the information
            // in the LOGPALETTE structure.
            hpal = CreatePalette ((LPLOGPALETTE) pLogPal) ;

	    GlobalUnlock(hLogPal);
	    GlobalFree(hLogPal);

	    if (!hpal)
	        return NULL;

	    fDeletePalette = TRUE;
	}
	else
	{
	    hpal = (HPALETTE)GetStockObject(DEFAULT_PALETTE);
	}
    }
	
    if (NULL == GetObject(hBitmap, sizeof(bm), (LPVOID)&bm))
    {
	return(NULL);
    }


    uBits = bm.bmPlanes * bm.bmBitsPixel;

    // Based on the number of bits per pixel, set up the size
    // of the color table, and the compression type as per the
    // the following table:
    //
    //
    // BPP         Palette Size               Compression   
    // ~~~         ~~~~~~~~~~~~               ~~~~~~~~~~~   
    // 1,2,4,8     2^BPP * sizeof(RGBQUAD)    None          
    // 16, 32      3 * sizeof(DWORD) masks    BI_BITFIELDS  
    // 24          0                          None          


    if (16 == bm.bmBitsPixel || 32 == bm.bmBitsPixel)
    {
	uBmiSize = sizeof(BITMAPINFOHEADER) + 3 * sizeof(DWORD);
	dwCompression = BI_BITFIELDS;
    }
    else if (24 == bm.bmBitsPixel)
    {
	uBmiSize = sizeof(BITMAPINFOHEADER);
	dwCompression = BI_RGB;
    }
    else
    {
	Assert( bm.bmBitsPixel == 1 ||
		bm.bmBitsPixel == 2 ||
		bm.bmBitsPixel == 4 ||
		bm.bmBitsPixel == 8 );


    // VGA and EGA are planar devices on Chicago, so uBits needs
    // to be used when determining the size of the bitmap info +
    // the size of the color table.
	uBmiSize = sizeof(BITMAPINFOHEADER) + 
			(1 << uBits) * sizeof(RGBQUAD);
	dwCompression = BI_RGB;
    }

    // Allocate enough memory to hold the BITMAPINFOHEADER

    hBmi = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, (DWORD)uBmiSize);
    if (NULL == hBmi)
    {
	return NULL;
    }

    lpBmi = (LPBITMAPINFOHEADER) GlobalLock(hBmi);
    if (NULL == lpBmi)
    {
	GlobalFree(hBmi);
	return NULL;
    }
    
    // Set up any interesting non-zero fields

    lpBmi->biSize        = (LONG)sizeof(BITMAPINFOHEADER);
    lpBmi->biWidth       = (LONG) bm.bmWidth;
    lpBmi->biHeight      = (LONG) bm.bmHeight;
    lpBmi->biPlanes      = 1;
    lpBmi->biBitCount    = (WORD) uBits;
    lpBmi->biCompression = dwCompression;
    
    // Grab the screen DC and set out palette into it
		
    hScreenDC = GetDC(NULL);    
    if (NULL == hScreenDC)
    {
	GlobalUnlock(hBmi);
	goto errRtn;
    }


    // Call GetDIBits with a NULL lpBits parm, so that it will calculate
    // the biSizeImage field for us

    GetDIBits(hScreenDC,                // DC
	      hBitmap,                  // Bitmap handle
	      0,                        // First scan line
	      bm.bmHeight,              // Number of scan lines
	      NULL,                     // Buffer
	      (LPBITMAPINFO)lpBmi,      // BITMAPINFO
	      DIB_RGB_COLORS);

    // If the driver did not fill in the biSizeImage field, make one up
    
    if (0 == lpBmi->biSizeImage)
    {
	LEDebugOut((DEB_WARN, "WARNING: biSizeImage was not computed for us\n"));
   
	lpBmi->biSizeImage = WIDTHBYTES((DWORD)bm.bmWidth * uBits) * bm.bmHeight;
    }

    // Realloc the buffer to provide space for the bits.  Use a new handle so
    // that in the failure case we do not lose the exiting handle, which we
    // would need to clean up properly.
    
    biSizeImage = lpBmi->biSizeImage;
    GlobalUnlock(hBmi);

    hDib = GlobalReAlloc(hBmi, (uBmiSize + biSizeImage), GMEM_MOVEABLE);
    if (NULL == hDib)
    {
	goto errRtn;
    }

    // If the realloc succeeded, we can get rid of the old handle

    hBmi = NULL;

    // re-acquire the pointer to the handle
    
    lpBmi = (LPBITMAPINFOHEADER)GlobalLock(hDib);
    if (NULL == lpBmi)
    {
	goto errRtn;
    }

    hpal = SelectPalette(hScreenDC, hpal, FALSE);
    RealizePalette(hScreenDC);

    // Call GetDIBits with a NON-NULL lpBits parm, and get the actual bits
    
    if (GetDIBits(hScreenDC,                    // DC
		  hBitmap,                      // HBITMAP
		  0,                            // First scan line
		  (WORD)lpBmi->biHeight,        // Count of scan lines
		  ((BYTE FAR *)lpBmi)+uBmiSize, // Bitmap bits
		  (LPBITMAPINFO)lpBmi,          // BITMAPINFOHEADER
		  DIB_RGB_COLORS)               // Palette style
	)
    {
	fSuccess = TRUE;        
    }

    GlobalUnlock(hDib);

errRtn:
    
    if (hScreenDC)
    {
	// Select back the old palette into the screen DC
	
	SelectPalette(hScreenDC, hpal, FALSE);     
	ReleaseDC(NULL, hScreenDC);
    }

    if (fDeletePalette)
    {
        DeleteObject(hpal);
    }

    // If we failed, we need to free up the header and the DIB
    // memory
	
    if (FALSE == fSuccess)
    {
	if (hBmi)
	{
	    GlobalFree(hBmi);
	}
	
	if (hDib)
	{
	    GlobalFree(hDib);
	    hDib = NULL;
	}
    }

    return(hDib);
}

//+----------------------------------------------------------------------------
//
//      Function:
//              UtPaletteSize, internal
//
//      Synopsis:
//              Returns the size of a color table for a palette given the
//              number of bits of color desired.
//
//		Basically, the number of color table entries is:
//
//		    1BPP
//			    1<<1 = 2
//
//		    4BPP
//			    if pbmi->biClrUsed is not zero and is less than 16, then use pbmi->biClrUsed, 
//			    otherwise use 1 << 4 = 16
//
//		    8BPP
//			    if pbmi->biClrUsed is not zero and is less than 256, then use pbmi->biClrUsed, 
//			    otherwise use 1 << 8 = 256
//
//		    16BPP
//			    if pbmi->biCompression is BITFIELDS then there are three color entries, 
//			    otherwise no color entries.
//
//		    24BPP 
//			    pbmi->biCompression must be BI_RGB, there is no color table.
//
//		    32BPP
//			    if pbmi->biCompression is BITFIELDS then there are three color entries, 
//			    otherwise no color entries.
//
//
//		    There is never a case with a color table larger than 256 colors.
//
//      Arguments:
//              [lpHeader] -- ptr to BITMAPINFOHEADER structure
//
//      Returns:
//              Size in bytes of color information
//
//      Notes:
//
//      History:
//              11/29/93 - ChrisWe - change bit count argument to unsigned,
//                      and return value to size_t
//
//              07/18/94 - DavePl - Fixed for 16, 24, 32bpp DIBs
//
//-----------------------------------------------------------------------------


FARINTERNAL_(size_t) UtPaletteSize(BITMAPINFOHEADER * pbmi)
{
DWORD dwSize;
WORD biBitCount = pbmi->biBitCount;


    VDATEHEAP();

    // Compute size of color table information in a DIB.

    if (8 >= biBitCount)
    {	
	if (pbmi->biClrUsed && (pbmi->biClrUsed <= (DWORD) (1 << biBitCount)) )
	{
	    dwSize = pbmi->biClrUsed * sizeof(RGBQUAD);
	}
	else
	{
	    Assert(0 == pbmi->biClrUsed);

	    dwSize = (1 << biBitCount) * sizeof(RGBQUAD);
	}
    }
    else if (BI_BITFIELDS == pbmi->biCompression)
    {
	Assert(24 != biBitCount);  // BI_BITFIELDS should never be set for 24 bit.
	dwSize = 3 * sizeof(RGBQUAD);
    }
    else
    {
	dwSize = 0;
    }

    Assert( (dwSize < 65536) && "Palette size overflows WORD");

    return dwSize;
}

//+-------------------------------------------------------------------------
//
//  Function:   UtGetDibExtents
//
//  Synopsis:   Returns the size of the DIB in HIMETRIC units
//
//  Effects:
//
//  Arguments:  [lpbmi]         -- the BITMAPINFOHEADER for the DIB
//              [plWidth]       -- OUT param for width
//              [plHeight]      -- OUT param for height
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              04-Aug-94 Davepl    Corrected logic
//
//  Notes:
//
//--------------------------------------------------------------------------

FARINTERNAL_(void) UtGetDibExtents(LPBITMAPINFOHEADER lpbmi,
		LONG F